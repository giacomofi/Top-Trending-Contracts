['pragma solidity ^0.4.17;\n', '\n', '/// @author developers //NB!\n', '/// @notice <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f784828787988583b7939281929b9887928584">[email&#160;protected]</a> //NB!\n', '/// @title  Contract presale //NB!\n', '\n', 'contract AvPresale {\n', '\n', '    string public constant RELEASE = "0.2.3_AviaTest";\n', '\n', '    //config// \n', '    uint public constant PRESALE_START  = 5307620; /* 23.03.2018 17:19:00 +3GMT */ //NB!\n', '    uint public constant PRESALE_END    = 5314027; /* 24.03.2018 20:00:00 +3GMT */ //NB!\n', '    uint public constant WITHDRAWAL_END = 5314987; /* 25.03.2018 00:00:00 +3GMT */ //NB!\n', '\n', '    address public constant OWNER = 0x32Bac79f4B6395DEa37f0c2B68b6e26ce24a59EA; //NB!\n', '\n', '    uint public constant MIN_TOTAL_AMOUNT_GET_ETH = 1; //NB!\n', '    uint public constant MAX_TOTAL_AMOUNT_GET_ETH = 2; //NB!\n', '\t//min send value 0.001 ETH (1 finney)\n', '    uint public constant MIN_GET_AMOUNT_FINNEY = 10; //NB!\n', '\n', '    string[5] private standingNames = ["BEFORE_START",  "PRESALE_RUNNING", "WITHDRAWAL_RUNNING", "MONEY_BACK_RUNNING", "CLOSED" ];\n', '    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, MONEY_BACK_RUNNING, CLOSED }\n', '\n', '    uint public total_amount = 0;\n', '    uint public total_money_back = 0;\n', '    mapping (address => uint) public balances;\n', '\n', '    uint private constant MIN_TOTAL_AMOUNT_GET = MIN_TOTAL_AMOUNT_GET_ETH * 1 ether;\n', '    uint private constant MAX_TOTAL_AMOUNT_GET = MAX_TOTAL_AMOUNT_GET_ETH * 1 ether;\n', '    uint private constant MIN_GET_AMOUNT = MIN_GET_AMOUNT_FINNEY * 1 finney;\n', '    bool public isTerminated = false;\n', '    bool public isStopped = false;\n', '\n', '\n', '    function AvPresale () public checkSettings() { }\n', '\n', '\n', '    //methods//\n', '\t\n', '\t//The transfer of money to the owner\n', '    function sendMoneyOwner() external\n', '\tinStanding(State.WITHDRAWAL_RUNNING)\n', '    onlyOwner\n', '    noReentrancy\n', '    {\n', '        OWNER.transfer(this.balance);\n', '    }\n', '\t\n', '\t//Money back to users\n', '    function moneyBack() external\n', '    inStanding(State.MONEY_BACK_RUNNING)\n', '    noReentrancy\n', '    {\n', '        sendMoneyBack();\n', '    }\n', '\t\n', '    //payments\n', '    function ()\n', '    payable\n', '    noReentrancy\n', '    public\n', '    {\n', '        State state = currentStanding();\n', '        if (state == State.PRESALE_RUNNING) {\n', '            getMoney();\n', '        } else if (state == State.MONEY_BACK_RUNNING) {\n', '            sendMoneyBack();\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    //Forced termination\n', '    function termination() external\n', '    inStandingBefore(State.MONEY_BACK_RUNNING)\n', '    onlyOwner\n', '    {\n', '        isTerminated = true;\n', '    }\n', '\n', '    //Forced stop with the possibility of withdrawal\n', '    function stop() external\n', '    inStanding(State.PRESALE_RUNNING)\n', '    onlyOwner\n', '    {\n', '        isStopped = true;\n', '    }\n', '\n', '\n', '    //Current status of the contract\n', '    function standing() external constant\n', '    returns (string)\n', '    {\n', '        return standingNames[ uint(currentStanding()) ];\n', '    }\n', '\n', '    //Method adding money to the user\n', '    function getMoney() private notTooSmallAmountOnly {\n', '      if (total_amount + msg.value > MAX_TOTAL_AMOUNT_GET) {\n', '          var change_to_return = total_amount + msg.value - MAX_TOTAL_AMOUNT_GET;\n', '          var acceptable_remainder = MAX_TOTAL_AMOUNT_GET - total_amount;\n', '          balances[msg.sender] += acceptable_remainder;\n', '          total_amount += acceptable_remainder;\n', '          msg.sender.transfer(change_to_return);\n', '      } else {\n', '          balances[msg.sender] += msg.value;\n', '          total_amount += msg.value;\n', '      }\n', '    }\n', '\t\n', '\t//Method of repayment users \n', '    function sendMoneyBack() private tokenHoldersOnly {\n', '        uint amount_to_money_back = min(balances[msg.sender], this.balance - msg.value) ;\n', '        balances[msg.sender] -= amount_to_money_back;\n', '        total_money_back += amount_to_money_back;\n', '        msg.sender.transfer(amount_to_money_back + msg.value);\n', '    }\n', '\n', '    //Determining the current status of the contract\n', '    function currentStanding() private constant returns (State) {\n', '        if (isTerminated) {\n', '            return this.balance > 0\n', '                   ? State.MONEY_BACK_RUNNING\n', '                   : State.CLOSED;\n', '        } else if (block.number < PRESALE_START) {\n', '            return State.BEFORE_START;\n', '        } else if (block.number <= PRESALE_END && total_amount < MAX_TOTAL_AMOUNT_GET && !isStopped) {\n', '            return State.PRESALE_RUNNING;\n', '        } else if (this.balance == 0) {\n', '            return State.CLOSED;\n', '        } else if (block.number <= WITHDRAWAL_END && total_amount >= MIN_TOTAL_AMOUNT_GET) {\n', '            return State.WITHDRAWAL_RUNNING;\n', '        } else {\n', '            return State.MONEY_BACK_RUNNING;\n', '        }\n', '    }\n', '\n', '    function min(uint a, uint b) pure private returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    //Prohibition if the condition does not match\n', '    modifier inStanding(State state) {\n', '        require(state == currentStanding());\n', '        _;\n', '    }\n', '\n', '    //Prohibition if the current state was not before\n', '    modifier inStandingBefore(State state) {\n', '        require(currentStanding() < state);\n', '        _;\n', '    }\n', '\n', '    //Works on users&#39;s command\n', '    modifier tokenHoldersOnly(){\n', '        require(balances[msg.sender] > 0);\n', '        _;\n', '    }\n', '\n', '    //Do not accept transactions with a sum less than the configuration limit\n', '    modifier notTooSmallAmountOnly(){\n', '        require(msg.value >= MIN_GET_AMOUNT);\n', '        _;\n', '    }\n', '\n', '    //Prohibition of repeated treatment\n', '    bool private lock = false;\n', '    modifier noReentrancy() {\n', '        require(!lock);\n', '        lock = true;\n', '        _;\n', '        lock = false;\n', '    }\n', '\t\n', '\t //Prohibition if it does not match the settings\n', '    modifier checkSettings() {\n', '        if ( OWNER == 0x0\n', '            || PRESALE_START == 0\n', '            || PRESALE_END == 0\n', '            || WITHDRAWAL_END ==0\n', '            || PRESALE_START <= block.number\n', '            || PRESALE_START >= PRESALE_END\n', '            || PRESALE_END   >= WITHDRAWAL_END\n', '            || MIN_TOTAL_AMOUNT_GET > MAX_TOTAL_AMOUNT_GET )\n', '                revert();\n', '        _;\n', '    }\n', '\t\n', '\t//Works on owner&#39;s command\n', '    modifier onlyOwner(){\n', '        require(msg.sender == OWNER);\n', '        _;\n', '    }\n', '}']
['pragma solidity ^0.4.17;\n', '\n', '/// @author developers //NB!\n', '/// @notice support@developers //NB!\n', '/// @title  Contract presale //NB!\n', '\n', 'contract AvPresale {\n', '\n', '    string public constant RELEASE = "0.2.3_AviaTest";\n', '\n', '    //config// \n', '    uint public constant PRESALE_START  = 5307620; /* 23.03.2018 17:19:00 +3GMT */ //NB!\n', '    uint public constant PRESALE_END    = 5314027; /* 24.03.2018 20:00:00 +3GMT */ //NB!\n', '    uint public constant WITHDRAWAL_END = 5314987; /* 25.03.2018 00:00:00 +3GMT */ //NB!\n', '\n', '    address public constant OWNER = 0x32Bac79f4B6395DEa37f0c2B68b6e26ce24a59EA; //NB!\n', '\n', '    uint public constant MIN_TOTAL_AMOUNT_GET_ETH = 1; //NB!\n', '    uint public constant MAX_TOTAL_AMOUNT_GET_ETH = 2; //NB!\n', '\t//min send value 0.001 ETH (1 finney)\n', '    uint public constant MIN_GET_AMOUNT_FINNEY = 10; //NB!\n', '\n', '    string[5] private standingNames = ["BEFORE_START",  "PRESALE_RUNNING", "WITHDRAWAL_RUNNING", "MONEY_BACK_RUNNING", "CLOSED" ];\n', '    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, MONEY_BACK_RUNNING, CLOSED }\n', '\n', '    uint public total_amount = 0;\n', '    uint public total_money_back = 0;\n', '    mapping (address => uint) public balances;\n', '\n', '    uint private constant MIN_TOTAL_AMOUNT_GET = MIN_TOTAL_AMOUNT_GET_ETH * 1 ether;\n', '    uint private constant MAX_TOTAL_AMOUNT_GET = MAX_TOTAL_AMOUNT_GET_ETH * 1 ether;\n', '    uint private constant MIN_GET_AMOUNT = MIN_GET_AMOUNT_FINNEY * 1 finney;\n', '    bool public isTerminated = false;\n', '    bool public isStopped = false;\n', '\n', '\n', '    function AvPresale () public checkSettings() { }\n', '\n', '\n', '    //methods//\n', '\t\n', '\t//The transfer of money to the owner\n', '    function sendMoneyOwner() external\n', '\tinStanding(State.WITHDRAWAL_RUNNING)\n', '    onlyOwner\n', '    noReentrancy\n', '    {\n', '        OWNER.transfer(this.balance);\n', '    }\n', '\t\n', '\t//Money back to users\n', '    function moneyBack() external\n', '    inStanding(State.MONEY_BACK_RUNNING)\n', '    noReentrancy\n', '    {\n', '        sendMoneyBack();\n', '    }\n', '\t\n', '    //payments\n', '    function ()\n', '    payable\n', '    noReentrancy\n', '    public\n', '    {\n', '        State state = currentStanding();\n', '        if (state == State.PRESALE_RUNNING) {\n', '            getMoney();\n', '        } else if (state == State.MONEY_BACK_RUNNING) {\n', '            sendMoneyBack();\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    //Forced termination\n', '    function termination() external\n', '    inStandingBefore(State.MONEY_BACK_RUNNING)\n', '    onlyOwner\n', '    {\n', '        isTerminated = true;\n', '    }\n', '\n', '    //Forced stop with the possibility of withdrawal\n', '    function stop() external\n', '    inStanding(State.PRESALE_RUNNING)\n', '    onlyOwner\n', '    {\n', '        isStopped = true;\n', '    }\n', '\n', '\n', '    //Current status of the contract\n', '    function standing() external constant\n', '    returns (string)\n', '    {\n', '        return standingNames[ uint(currentStanding()) ];\n', '    }\n', '\n', '    //Method adding money to the user\n', '    function getMoney() private notTooSmallAmountOnly {\n', '      if (total_amount + msg.value > MAX_TOTAL_AMOUNT_GET) {\n', '          var change_to_return = total_amount + msg.value - MAX_TOTAL_AMOUNT_GET;\n', '          var acceptable_remainder = MAX_TOTAL_AMOUNT_GET - total_amount;\n', '          balances[msg.sender] += acceptable_remainder;\n', '          total_amount += acceptable_remainder;\n', '          msg.sender.transfer(change_to_return);\n', '      } else {\n', '          balances[msg.sender] += msg.value;\n', '          total_amount += msg.value;\n', '      }\n', '    }\n', '\t\n', '\t//Method of repayment users \n', '    function sendMoneyBack() private tokenHoldersOnly {\n', '        uint amount_to_money_back = min(balances[msg.sender], this.balance - msg.value) ;\n', '        balances[msg.sender] -= amount_to_money_back;\n', '        total_money_back += amount_to_money_back;\n', '        msg.sender.transfer(amount_to_money_back + msg.value);\n', '    }\n', '\n', '    //Determining the current status of the contract\n', '    function currentStanding() private constant returns (State) {\n', '        if (isTerminated) {\n', '            return this.balance > 0\n', '                   ? State.MONEY_BACK_RUNNING\n', '                   : State.CLOSED;\n', '        } else if (block.number < PRESALE_START) {\n', '            return State.BEFORE_START;\n', '        } else if (block.number <= PRESALE_END && total_amount < MAX_TOTAL_AMOUNT_GET && !isStopped) {\n', '            return State.PRESALE_RUNNING;\n', '        } else if (this.balance == 0) {\n', '            return State.CLOSED;\n', '        } else if (block.number <= WITHDRAWAL_END && total_amount >= MIN_TOTAL_AMOUNT_GET) {\n', '            return State.WITHDRAWAL_RUNNING;\n', '        } else {\n', '            return State.MONEY_BACK_RUNNING;\n', '        }\n', '    }\n', '\n', '    function min(uint a, uint b) pure private returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    //Prohibition if the condition does not match\n', '    modifier inStanding(State state) {\n', '        require(state == currentStanding());\n', '        _;\n', '    }\n', '\n', '    //Prohibition if the current state was not before\n', '    modifier inStandingBefore(State state) {\n', '        require(currentStanding() < state);\n', '        _;\n', '    }\n', '\n', "    //Works on users's command\n", '    modifier tokenHoldersOnly(){\n', '        require(balances[msg.sender] > 0);\n', '        _;\n', '    }\n', '\n', '    //Do not accept transactions with a sum less than the configuration limit\n', '    modifier notTooSmallAmountOnly(){\n', '        require(msg.value >= MIN_GET_AMOUNT);\n', '        _;\n', '    }\n', '\n', '    //Prohibition of repeated treatment\n', '    bool private lock = false;\n', '    modifier noReentrancy() {\n', '        require(!lock);\n', '        lock = true;\n', '        _;\n', '        lock = false;\n', '    }\n', '\t\n', '\t //Prohibition if it does not match the settings\n', '    modifier checkSettings() {\n', '        if ( OWNER == 0x0\n', '            || PRESALE_START == 0\n', '            || PRESALE_END == 0\n', '            || WITHDRAWAL_END ==0\n', '            || PRESALE_START <= block.number\n', '            || PRESALE_START >= PRESALE_END\n', '            || PRESALE_END   >= WITHDRAWAL_END\n', '            || MIN_TOTAL_AMOUNT_GET > MAX_TOTAL_AMOUNT_GET )\n', '                revert();\n', '        _;\n', '    }\n', '\t\n', "\t//Works on owner's command\n", '    modifier onlyOwner(){\n', '        require(msg.sender == OWNER);\n', '        _;\n', '    }\n', '}']
