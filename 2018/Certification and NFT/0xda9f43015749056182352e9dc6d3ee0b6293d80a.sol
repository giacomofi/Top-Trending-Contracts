['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4a2e2f3e2f0a2b32232527302f24642925">[email&#160;protected]</a>> (https://github.com/dete)\n', 'contract ERC721 {\n', '    // Required methods\n', '    function totalSupply() public view returns (uint256 total);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) external view returns (address owner);\n', '    function approve(address _to, uint256 _tokenId) external;\n', '    function transfer(address _to, uint256 _tokenId) external;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    \n', '    // Optional methods used by ServiceStation contract\n', '    function tuneLambo(uint256 _newattributes, uint256 _tokenId) external;\n', '    function getLamboAttributes(uint256 _id) external view returns (uint256 attributes);\n', '    function getLamboModel(uint256 _tokenId) external view returns (uint64 _model);\n', '    // Events\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event Approval(address owner, address approved, uint256 tokenId);\n', '\n', '    // Optional\n', '    // function name() public view returns (string name);\n', '    // function symbol() public view returns (string symbol);\n', '    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n', '    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n', '\n', '    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '}\n', '\n', '\n', '\n', '/// @title A facet of EtherLamboCore that manages special access privileges.\n', '/// @author Axiom Zen (https://www.axiomzen.co) adapted by Kenny Bania\n', '/// @dev ...\n', 'contract EtherLambosAccessControl {\n', '    // This facet controls access control for Etherlambos. There are four roles managed here:\n', '    //\n', '    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n', '    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n', '    //         set to the address that created the smart contract in the EtherLamboCore constructor.\n', '    //\n', '    //     - The CFO: The CFO can withdraw funds from EtherLamboCore and its auction contracts.\n', '    //\n', '    //     - The COO: The COO can release new models for sale.\n', '    //\n', '    // It should be noted that these roles are distinct without overlap in their access abilities, the\n', '    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\n', '    // address to any role, the CEO address itself doesn&#39;t have the ability to act in those roles. This\n', '    // restriction is intentional so that we aren&#39;t tempted to use the CEO address frequently out of\n', '    // convenience. The less we use an address, the less likely it is that we somehow compromise the\n', '    // account.\n', '\n', '    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n', '    event ContractUpgrade(address newContract);\n', '\n', '    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '    address public cooAddress;\n', '\n', '    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused = false;\n', '\n', '    /// @dev Access modifier for CEO-only functionality\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for CFO-only functionality\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for COO-only functionality\n', '    modifier onlyCOO() {\n', '        require(msg.sender == cooAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == cooAddress ||\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cfoAddress\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '    /// @param _newCEO The address of the new CEO\n', '    function setCEO(address _newCEO) external onlyCEO {\n', '        require(_newCEO != address(0));\n', '\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n', '    /// @param _newCFO The address of the new CFO\n', '    function setCFO(address _newCFO) external onlyCEO {\n', '        require(_newCFO != address(0));\n', '\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n', '    /// @param _newCOO The address of the new COO\n', '    function setCOO(address _newCOO) external onlyCEO {\n', '        require(_newCOO != address(0));\n', '\n', '        cooAddress = _newCOO;\n', '    }\n', '\n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '    ///  a bug or exploit is detected and we need to limit damage.\n', '    function pause() external onlyCLevel whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '    ///  one reason we may pause the contract is when CFO or COO accounts are\n', '    ///  compromised.\n', '    /// @notice This is public rather than external so it can be called by\n', '    ///  derived contracts.\n', '    function unpause() public onlyCEO whenPaused {\n', '        // can&#39;t unpause if contract was upgraded\n', '        paused = false;\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title Base contract for EtherLambos. Holds all common structs, events and base variables.\n', '/// @author Axiom Zen (https://www.axiomzen.co) adapted by Kenny Bania\n', '/// @dev ...\n', 'contract EtherLambosBase is EtherLambosAccessControl {\n', '    /*** EVENTS ***/\n', '\n', '    /// @dev The Build event is fired whenever a new car model is build by the COO\n', '    event Build(address owner, uint256 lamboId, uint256 attributes);\n', '\n', '    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a car\n', '    ///  ownership is assigned, including builds.\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '\n', '    event Tune(uint256 _newattributes, uint256 _tokenId);\n', '    \n', '    /*** DATA TYPES ***/\n', '\n', '    /// @dev The main EtherLambos struct. Every car in EtherLambos is represented by a copy\n', '    ///  of this structure, so great care was taken to ensure that it fits neatly into\n', '    ///  exactly two 256-bit words. Note that the order of the members in this structure\n', '    ///  is important because of the byte-packing rules used by Ethereum.\n', '    ///  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html\n', '    struct Lambo {\n', '        // sports-car attributes like max speed, weight etc. are stored here.\n', '        // These attributes can be changed due to tuning/upgrades\n', '        uint256 attributes;\n', '\n', '        // The timestamp from the block when this car came was constructed.\n', '        uint64 buildTime;\n', '        \n', '        // the Lambo model identifier\n', '        uint64 model;\n', '\n', '    }\n', '\n', '\n', '    // An approximation of currently how many seconds are in between blocks.\n', '    uint256 public secondsPerBlock = 15;\n', '\n', '    /*** STORAGE ***/\n', '\n', '    /// @dev An array containing the Lambo struct for all Lambos in existence. The ID\n', '    ///  of each car is actually an index into this array. Note that 0 is invalid index.\n', '    Lambo[] lambos;\n', '\n', '    /// @dev A mapping from car IDs to the address that owns them. All cars have\n', '    ///  some valid owner address.\n', '    mapping (uint256 => address) public lamboIndexToOwner;\n', '\n', '    // @dev A mapping from owner address to count of tokens that address owns.\n', '    //  Used internally inside balanceOf() to resolve ownership count.\n', '    mapping (address => uint256) ownershipTokenCount;\n', '\n', '    /// @dev A mapping from LamboIDs to an address that has been approved to call\n', '    ///  transferFrom(). Each Lambo can only have one approved address for transfer\n', '    ///  at any time. A zero value means no approval is outstanding.\n', '    mapping (uint256 => address) public lamboIndexToApproved;\n', '\n', '    /// @dev The address of the MarketPlace contract that handles sales of Lambos. This\n', '    ///  same contract handles both peer-to-peer sales as well as new model sales. \n', '    MarketPlace public marketPlace;\n', '    ServiceStation public serviceStation;\n', '    /// @dev Assigns ownership of a specific Lambo to an address.\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        // Since the number of lambos is capped to 2^32 we can&#39;t overflow this\n', '        ownershipTokenCount[_to]++;\n', '        // transfer ownership\n', '        lamboIndexToOwner[_tokenId] = _to;\n', '        // When creating new lambos _from is 0x0, but we can&#39;t account that address.\n', '        if (_from != address(0)) {\n', '            ownershipTokenCount[_from]--;\n', '            // clear any previously approved ownership exchange\n', '            delete lamboIndexToApproved[_tokenId];\n', '        }\n', '        // Emit the transfer event.\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /// @dev An internal method that creates a new lambo and stores it. This\n', '    ///  method doesn&#39;t do any checking and should only be called when the\n', '    ///  input data is known to be valid. Will generate both a Build event\n', '    ///  and a Transfer event.\n', '    /// @param _attributes The lambo&#39;s attributes.\n', '    /// @param _owner The inital owner of this car, must be non-zero\n', '    function _createLambo(\n', '        uint256 _attributes,\n', '        address _owner,\n', '        uint64  _model\n', '    )\n', '        internal\n', '        returns (uint)\n', '    {\n', '\n', '        \n', '        Lambo memory _lambo = Lambo({\n', '            attributes: _attributes,\n', '            buildTime: uint64(now),\n', '            model:_model\n', '        });\n', '        uint256 newLamboId = lambos.push(_lambo) - 1;\n', '\n', '        // It&#39;s probably never going to happen, 4 billion cars is A LOT, but\n', '        // let&#39;s just be 100% sure we never let this happen.\n', '        require(newLamboId == uint256(uint32(newLamboId)));\n', '\n', '        // emit the build event\n', '        Build(\n', '            _owner,\n', '            newLamboId,\n', '            _lambo.attributes\n', '        );\n', '\n', '        // This will assign ownership, and also emit the Transfer event as\n', '        // per ERC721 draft\n', '        _transfer(0, _owner, newLamboId);\n', '\n', '        return newLamboId;\n', '    }\n', '     /// @dev An internal method that tunes an existing lambo. This\n', '    ///  method doesn&#39;t do any checking and should only be called when the\n', '    ///  input data is known to be valid. Will generate a Tune event\n', '    /// @param _newattributes The lambo&#39;s new attributes.\n', '    /// @param _tokenId The car to be tuned.\n', '    function _tuneLambo(\n', '        uint256 _newattributes,\n', '        uint256 _tokenId\n', '    )\n', '        internal\n', '    {\n', '        lambos[_tokenId].attributes=_newattributes;\n', '     \n', '        // emit the tune event\n', '        Tune(\n', '            _tokenId,\n', '            _newattributes\n', '        );\n', '\n', '    }\n', '    // Any C-level can fix how many seconds per blocks are currently observed.\n', '    function setSecondsPerBlock(uint256 secs) external onlyCLevel {\n', '        //require(secs < cooldowns[0]);\n', '        secondsPerBlock = secs;\n', '    }\n', '}\n', '\n', '/// @title The external contract that is responsible for generating metadata for the cars,\n', '///  it has one function that will return the data as bytes.\n', 'contract ERC721Metadata {\n', '    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\n', '    function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {\n', '        if (_tokenId == 1) {\n', '            buffer[0] = "Hello World! :D";\n', '            count = 15;\n', '        } else if (_tokenId == 2) {\n', '            buffer[0] = "I would definitely choose a medi";\n', '            buffer[1] = "um length string.";\n', '            count = 49;\n', '        } else if (_tokenId == 3) {\n', '            buffer[0] = "Lorem ipsum dolor sit amet, mi e";\n', '            buffer[1] = "st accumsan dapibus augue lorem,";\n', '            buffer[2] = " tristique vestibulum id, libero";\n', '            buffer[3] = " suscipit varius sapien aliquam.";\n', '            count = 128;\n', '        }\n', '    }\n', '}\n', '\n', '/// @title The facet of the EtherLambosCore contract that manages ownership, ERC-721 (draft) compliant.\n', '/// @author Axiom Zen (https://www.axiomzen.co) adapted by Cryptoknights\n', '/// @dev Ref: https://github.com/ethereum/EIPs/issues/721\n', '\n', 'contract EtherLambosOwnership is EtherLambosBase, ERC721 {\n', '\n', '    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '    string public constant name = "EtherLambos";\n', '    string public constant symbol = "EL";\n', '\n', '    // The contract that will return lambo metadata\n', '    ERC721Metadata public erc721Metadata;\n', '\n', '    bytes4 constant InterfaceSignature_ERC165 =\n', '        bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));\n', '\n', '    bytes4 constant InterfaceSignature_ERC721 =\n', '        bytes4(keccak256(&#39;name()&#39;)) ^\n', '        bytes4(keccak256(&#39;symbol()&#39;)) ^\n', '        bytes4(keccak256(&#39;totalSupply()&#39;)) ^\n', '        bytes4(keccak256(&#39;balanceOf(address)&#39;)) ^\n', '        bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) ^\n', '        bytes4(keccak256(&#39;approve(address,uint256)&#39;)) ^\n', '        bytes4(keccak256(&#39;transfer(address,uint256)&#39;)) ^\n', '        bytes4(keccak256(&#39;transferFrom(address,address,uint256)&#39;)) ^\n', '        bytes4(keccak256(&#39;tokensOfOwner(address)&#39;)) ^\n', '        bytes4(keccak256(&#39;tokenMetadata(uint256,string)&#39;));\n', '\n', '    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n', '    ///  Returns true for any standardized interfaces implemented by this contract. We implement\n', '    ///  ERC-165 (obviously!) and ERC-721.\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\n', '    {\n', '        // DEBUG ONLY\n', '        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\n', '\n', '        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\n', '    }\n', '\n', '    /// @dev Set the address of the sibling contract that tracks metadata.\n', '    ///  CEO only.\n', '    function setMetadataAddress(address _contractAddress) public onlyCEO {\n', '        erc721Metadata = ERC721Metadata(_contractAddress);\n', '    }\n', '\n', '    // Internal utility functions: These functions all assume that their input arguments\n', '    // are valid. We leave it to public methods to sanitize their inputs and follow\n', '    // the required logic.\n', '\n', '    /// @dev Checks if a given address is the current owner of a particular Lambo.\n', '    /// @param _claimant the address we are validating against.\n', '    /// @param _tokenId kitten id, only valid when > 0\n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return lamboIndexToOwner[_tokenId] == _claimant;\n', '    }\n', '\n', '    /// @dev Checks if a given address currently has transferApproval for a particular Lambo.\n', '    /// @param _claimant the address we are confirming Lambo is approved for.\n', '    /// @param _tokenId lambo id, only valid when > 0\n', '    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return lamboIndexToApproved[_tokenId] == _claimant;\n', '    }\n', '\n', '    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n', '    ///  approval. Setting _approved to address(0) clears all transfer approval.\n', '    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\n', '    ///  _approve() and transferFrom() are used together for putting Lambos on sale, and\n', '    ///  there is no value in spamming the log with Approval events in that case.\n', '    function _approve(uint256 _tokenId, address _approved) internal {\n', '        lamboIndexToApproved[_tokenId] = _approved;\n', '    }\n', '\n', '    /// @notice Returns the number of Lambos owned by a specific address.\n', '    /// @param _owner The owner address to check.\n', '    /// @dev Required for ERC-721 compliance\n', '    function balanceOf(address _owner) public view returns (uint256 count) {\n', '        return ownershipTokenCount[_owner];\n', '    }\n', '\n', '    /// @notice Transfers a Lambo to another address. If transferring to a smart\n', '    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or\n', '    ///  EtherLambos specifically) or your Lambo may be lost forever. Seriously.\n', '    /// @param _to The address of the recipient, can be a user or contract.\n', '    /// @param _tokenId The ID of the Lambo to transfer.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function transfer(\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        // Safety check to prevent against an unexpected 0x0 default.\n', '        require(_to != address(0));\n', '        // Disallow transfers to this contract to prevent accidental misuse.\n', '        // The contract should never own any lambos.\n', '        require(_to != address(this));\n', '        // Disallow transfers to the auction contracts to prevent accidental\n', '        // misuse. Marketplace contracts should only take ownership of Lambos\n', '        // through the allow + transferFrom flow.\n', '        require(_to != address(marketPlace));\n', '\n', '        // You can only send your own car.\n', '        require(_owns(msg.sender, _tokenId));\n', '\n', '        // Reassign ownership, clear pending approvals, emit Transfer event.\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /// @notice Grant another address the right to transfer a specific Lambo via\n', '    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n', '    /// @param _to The address to be granted transfer approval. Pass address(0) to\n', '    ///  clear all approvals.\n', '    /// @param _tokenId The ID of the Lambo that can be transferred if this call succeeds.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function approve(\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        // Only an owner can grant transfer approval.\n', '        require(_owns(msg.sender, _tokenId));\n', '\n', '        // Register the approval (replacing any previous approval).\n', '        _approve(_tokenId, _to);\n', '\n', '        // Emit approval event.\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /// @notice Transfer a Lambo owned by another address, for which the calling address\n', '    ///  has previously been granted transfer approval by the owner.\n', '    /// @param _from The address that owns the Lambo to be transfered.\n', '    /// @param _to The address that should take ownership of the Lambo. Can be any address,\n', '    ///  including the caller.\n', '    /// @param _tokenId The ID of the Lambo to be transferred.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        // Safety check to prevent against an unexpected 0x0 default.\n', '        require(_to != address(0));\n', '        // Disallow transfers to this contract to prevent accidental misuse.\n', '        // The contract should never own any lambos.\n', '        require(_to != address(this));\n', '        // Check for approval and valid ownership\n', '        require(_approvedFor(msg.sender, _tokenId));\n', '        require(_owns(_from, _tokenId));\n', '\n', '        // Reassign ownership (also clears pending approvals and emits Transfer event).\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /// @notice Returns the total number of Lambos currently in existence.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function totalSupply() public view returns (uint) {\n', '        return lambos.length - 1;\n', '    }\n', '\n', '    /// @notice Returns the address currently assigned ownership of a given Lambo.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function ownerOf(uint256 _tokenId)\n', '        external\n', '        view\n', '        returns (address owner)\n', '    {\n', '        owner = lamboIndexToOwner[_tokenId];\n', '\n', '        require(owner != address(0));\n', '    }\n', '\n', '    /// @notice Returns a list of all Lambo IDs assigned to an address.\n', '    /// @param _owner The owner whose Lambo we are interested in.\n', '    /// @dev This method MUST NEVER be called by smart contract code. First, it&#39;s fairly\n', '    ///  expensive (it walks the entire Lambo array looking for cars belonging to owner),\n', '    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '    ///  not contract-to-contract calls.\n', '    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '\n', '        if (tokenCount == 0) {\n', '            // Return an empty array\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            uint256 totalCars = totalSupply();\n', '            uint256 resultIndex = 0;\n', '\n', '            // We count on the fact that all cars have IDs starting at 1 and increasing\n', '            // sequentially up to the totalCat count.\n', '            uint256 carId;\n', '\n', '            for (carId = 1; carId <= totalCars; carId++) {\n', '                if (lamboIndexToOwner[carId] == _owner) {\n', '                    result[resultIndex] = carId;\n', '                    resultIndex++;\n', '                }\n', '            }\n', '\n', '            return result;\n', '        }\n', '    }\n', '\n', '    /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="accddecdcfc4c2c5c8ecc2c3d8c8c3d882c2c9d8">[email&#160;protected]</a>>)\n', '    ///  This method is licenced under the Apache License.\n', '    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n', '    function _memcpy(uint _dest, uint _src, uint _len) private view {\n', '        // Copy word-length chunks while possible\n', '        for(; _len >= 32; _len -= 32) {\n', '            assembly {\n', '                mstore(_dest, mload(_src))\n', '            }\n', '            _dest += 32;\n', '            _src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint256 mask = 256 ** (32 - _len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(_src), not(mask))\n', '            let destpart := and(mload(_dest), mask)\n', '            mstore(_dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e7869586848f898e83a7898893838893c9898293">[email&#160;protected]</a>>)\n', '    ///  This method is licenced under the Apache License.\n', '    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n', '    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) {\n', '        var outputString = new string(_stringLength);\n', '        uint256 outputPtr;\n', '        uint256 bytesPtr;\n', '\n', '        assembly {\n', '            outputPtr := add(outputString, 32)\n', '            bytesPtr := _rawBytes\n', '        }\n', '\n', '        _memcpy(outputPtr, bytesPtr, _stringLength);\n', '\n', '        return outputString;\n', '    }\n', '\n', '    /// @notice Returns a URI pointing to a metadata package for this token conforming to\n', '    ///  ERC-721 (https://github.com/ethereum/EIPs/issues/721)\n', '    /// @param _tokenId The ID number of the Lambos whose metadata should be returned.\n', '    function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) {\n', '        require(erc721Metadata != address(0));\n', '        bytes32[4] memory buffer;\n', '        uint256 count;\n', '        (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);\n', '\n', '        return _toString(buffer, count);\n', '    }\n', '}\n', '\n', '\n', '/// @title MarketPlace core\n', '/// @dev Contains models, variables, and internal methods for the marketplace.\n', '/// @notice We omit a fallback function to prevent accidental sends to this contract.\n', 'contract MarketPlaceBase is Ownable {\n', '\n', '    // Represents an sale on an NFT\n', '    struct Sale {\n', '        // Current owner of NFT\n', '        address seller;\n', '        // Price (in wei) \n', '        uint128 price;\n', '        // Time when sale started\n', '        // NOTE: 0 if this sale has been concluded\n', '        uint64 startedAt;\n', '    }\n', '    \n', '    struct Affiliates {\n', '        address affiliate_address;\n', '        uint64 commission;\n', '        uint64 pricecut;\n', '    }\n', '    \n', '    //Affiliates[] affiliates;\n', '    // Reference to contract tracking NFT ownership\n', '    ERC721 public nonFungibleContract;\n', '\n', '    // Cut owner takes on each sale, measured in basis points (1/100 of a percent).\n', '    // Values 0-10,000 map to 0%-100%\n', '    uint256 public ownerCut;\n', '\n', '    //map the Affiliate Code to the Affiliate\n', '    mapping (uint256 => Affiliates) codeToAffiliate;\n', '\n', '    // Map from token ID to their corresponding sale.\n', '    mapping (uint256 => Sale) tokenIdToSale;\n', '\n', '    event SaleCreated(uint256 tokenId, uint256 price);\n', '    event SaleSuccessful(uint256 tokenId, uint256 price, address buyer);\n', '    event SaleCancelled(uint256 tokenId);\n', '\n', '    /// @dev Returns true if the claimant owns the token.\n', '    /// @param _claimant - Address claiming to own the token.\n', '    /// @param _tokenId - ID of token whose ownership to verify.\n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n', '    }\n', '\n', '    /// @dev Escrows the NFT, assigning ownership to this contract.\n', '    /// Throws if the escrow fails.\n', '    /// @param _owner - Current owner address of token to escrow.\n', '    /// @param _tokenId - ID of token whose approval to verify.\n', '    function _escrow(address _owner, uint256 _tokenId) internal {\n', '        // it will throw if transfer fails\n', '        nonFungibleContract.transferFrom(_owner, this, _tokenId);\n', '    }\n', '\n', '    /// @dev Transfers an NFT owned by this contract to another address.\n', '    /// Returns true if the transfer succeeds.\n', '    /// @param _receiver - Address to transfer NFT to.\n', '    /// @param _tokenId - ID of token to transfer.\n', '    function _transfer(address _receiver, uint256 _tokenId) internal {\n', '        // it will throw if transfer fails\n', '        nonFungibleContract.transfer(_receiver, _tokenId);\n', '    }\n', '\n', '    /// @dev Adds an sale to the list of open sales. Also fires the\n', '    ///  SaleCreated event.\n', '    /// @param _tokenId The ID of the token to be put on sale.\n', '    /// @param _sale Sale to add.\n', '    function _addSale(uint256 _tokenId, Sale _sale) internal {\n', '        \n', '\n', '        tokenIdToSale[_tokenId] = _sale;\n', '\n', '        SaleCreated(\n', '            uint256(_tokenId),\n', '            uint256(_sale.price)\n', '        );\n', '    }\n', '\n', '    /// @dev Cancels a sale unconditionally.\n', '    function _cancelSale(uint256 _tokenId, address _seller) internal {\n', '        _removeSale(_tokenId);\n', '        _transfer(_seller, _tokenId);\n', '        SaleCancelled(_tokenId);\n', '    }\n', '\n', '    /// @dev Computes the price and transfers winnings.\n', '    /// Does NOT transfer ownership of token.\n', '    function _bid(uint256 _tokenId, uint256 _bidAmount)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        // Get a reference to the sale struct\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '\n', '        // Explicitly check that this sale is currently live.\n', '        // (Because of how Ethereum mappings work, we can&#39;t just count\n', '        // on the lookup above failing. An invalid _tokenId will just\n', '        // return a sale object that is all zeros.)\n', '        require(_isOnSale(sale));\n', '\n', '        // Check that the bid is greater than or equal to the current price\n', '        uint256 price = sale.price;\n', '        require(_bidAmount >= price);\n', '\n', '        // Grab a reference to the seller before the sale struct\n', '        // gets deleted.\n', '        address seller = sale.seller;\n', '\n', '        // The bid is good! Remove the sale before sending the fees\n', '        // to the sender so we can&#39;t have a reentrancy attack.\n', '        _removeSale(_tokenId);\n', '\n', '        // Transfer proceeds to seller (if there are any!)\n', '        if (price > 0) {\n', '            // Calculate the Marketplace&#39;s cut.\n', '            // (NOTE: _computeCut() is guaranteed to return a\n', '            // value <= price, so this subtraction can&#39;t go negative.)\n', '            uint256 marketplaceCut = _computeCut(price);\n', '            uint256 sellerProceeds = price - marketplaceCut;\n', '\n', '            // NOTE: Doing a transfer() in the middle of a complex\n', '            // method like this is generally discouraged because of\n', '            // reentrancy attacks and DoS attacks if the seller is\n', '            // a contract with an invalid fallback function. We explicitly\n', '            // guard against reentrancy attacks by removing the auction\n', '            // before calling transfer(), and the only thing the seller\n', '            // can DoS is the sale of their own asset! (And if it&#39;s an\n', '            // accident, they can call cancelAuction(). )\n', '            seller.transfer(sellerProceeds);\n', '        }\n', '\n', '        // Calculate any excess funds included with the bid. If the excess\n', '        // is anything worth worrying about, transfer it back to bidder.\n', '        // NOTE: We checked above that the bid amount is greater than or\n', '        // equal to the price so this cannot underflow.\n', '        uint256 bidExcess = _bidAmount - price;\n', '\n', '        // Return the funds. Similar to the previous transfer, this is\n', '        // not susceptible to a re-entry attack because the auction is\n', '        // removed before any transfers occur.\n', '        msg.sender.transfer(bidExcess);\n', '\n', '        // Tell the world!\n', '        SaleSuccessful(_tokenId, price, msg.sender);\n', '\n', '        return price;\n', '    }\n', '\n', '    /// @dev Removes a sale from the list of open sales.\n', '    /// @param _tokenId - ID of NFT on sale.\n', '    function _removeSale(uint256 _tokenId) internal {\n', '        delete tokenIdToSale[_tokenId];\n', '    }\n', '\n', '    /// @dev Returns true if the NFT is on sale.\n', '    /// @param _sale - Sale to check.\n', '    function _isOnSale(Sale storage _sale) internal view returns (bool) {\n', '        return (_sale.startedAt > 0);\n', '    }\n', '\n', '\n', '    /// @dev Computes owner&#39;s cut of a sale.\n', '    /// @param _price - Sale price of NFT.\n', '    function _computeCut(uint256 _price) internal view returns (uint256) {\n', '        // NOTE: We don&#39;t use SafeMath (or similar) in this function because\n', '        //  all of our entry functions carefully cap the maximum values for\n', '        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\n', '        //  statement in the Marketplace constructor). The result of this\n', '        //  function is always guaranteed to be <= _price.\n', '        return _price * ownerCut / 10000;\n', '    }\n', '    function _computeAffiliateCut(uint256 _price,Affiliates affiliate) internal view returns (uint256) {\n', '        // NOTE: We don&#39;t use SafeMath (or similar) in this function because\n', '        //  all of our entry functions carefully cap the maximum values for\n', '        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\n', '        //  statement in the Marketplace constructor). The result of this\n', '        //  function is always guaranteed to be <= _price.\n', '        return _price * affiliate.commission / 10000;\n', '    }\n', '    /// @dev Adds an affiliate to the list.\n', '    /// @param _code The referall code of the affiliate.\n', '    /// @param _affiliate Affiliate to add.\n', '    function _addAffiliate(uint256 _code, Affiliates _affiliate) internal {\n', '        codeToAffiliate[_code] = _affiliate;\n', '   \n', '    }\n', '    \n', '    /// @dev Removes a affiliate from the list.\n', '    /// @param _code - The referall code of the affiliate.\n', '    function _removeAffiliate(uint256 _code) internal {\n', '        delete codeToAffiliate[_code];\n', '    }\n', '    \n', '    \n', '    //_bidReferral(_tokenId, msg.value);\n', '    /// @dev Computes the price and transfers winnings.\n', '    /// Does NOT transfer ownership of token.\n', '    function _bidReferral(uint256 _tokenId, uint256 _bidAmount,Affiliates _affiliate)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        \n', '        // Get a reference to the sale struct\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '\n', '        //Only Owner of Contract can sell referrals\n', '        require(sale.seller==owner);\n', '\n', '        // Explicitly check that this sale is currently live.\n', '        // (Because of how Ethereum mappings work, we can&#39;t just count\n', '        // on the lookup above failing. An invalid _tokenId will just\n', '        // return a sale object that is all zeros.)\n', '        require(_isOnSale(sale));\n', '        // Check that the bid is greater than or equal to the current price\n', '        \n', '        uint256 price = sale.price;\n', '        \n', '        //deduce the affiliate pricecut\n', '        price=price * _affiliate.pricecut / 10000;  \n', '        require(_bidAmount >= price);\n', '\n', '        // Grab a reference to the seller before the sale struct\n', '        // gets deleted.\n', '        address seller = sale.seller;\n', '        address affiliate_address = _affiliate.affiliate_address;\n', '        \n', '        // The bid is good! Remove the sale before sending the fees\n', '        // to the sender so we can&#39;t have a reentrancy attack.\n', '        _removeSale(_tokenId);\n', '\n', '        // Transfer proceeds to seller (if there are any!)\n', '        if (price > 0) {\n', '            // Calculate the Marketplace&#39;s cut.\n', '            // (NOTE: _computeCut() is guaranteed to return a\n', '            // value <= price, so this subtraction can&#39;t go negative.)\n', '            uint256 affiliateCut = _computeAffiliateCut(price,_affiliate);\n', '            uint256 sellerProceeds = price - affiliateCut;\n', '\n', '            // NOTE: Doing a transfer() in the middle of a complex\n', '            // method like this is generally discouraged because of\n', '            // reentrancy attacks and DoS attacks if the seller is\n', '            // a contract with an invalid fallback function. We explicitly\n', '            // guard against reentrancy attacks by removing the auction\n', '            // before calling transfer(), and the only thing the seller\n', '            // can DoS is the sale of their own asset! (And if it&#39;s an\n', '            // accident, they can call cancelAuction(). )\n', '            seller.transfer(sellerProceeds);\n', '            affiliate_address.transfer(affiliateCut);\n', '        }\n', '\n', '        // Calculate any excess funds included with the bid. If the excess\n', '        // is anything worth worrying about, transfer it back to bidder.\n', '        // NOTE: We checked above that the bid amount is greater than or\n', '        // equal to the price so this cannot underflow.\n', '        uint256 bidExcess = _bidAmount - price;\n', '\n', '        // Return the funds. Similar to the previous transfer, this is\n', '        // not susceptible to a re-entry attack because the auction is\n', '        // removed before any transfers occur.\n', '        msg.sender.transfer(bidExcess);\n', '\n', '        // Tell the world!\n', '        SaleSuccessful(_tokenId, price, msg.sender);\n', '\n', '        return price;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    Pause();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    Unpause();\n', '    return true;\n', '  }\n', '}\n', '\n', '/// @title MarketPlace for non-fungible tokens.\n', '/// @notice We omit a fallback function to prevent accidental sends to this contract.\n', 'contract MarketPlace is Pausable, MarketPlaceBase {\n', '\n', '\t// @dev Sanity check that allows us to ensure that we are pointing to the\n', '    //  right auction in our setSaleMarketplaceAddress() call.\n', '    bool public isMarketplace = true;\n', '\t\n', '    /// @dev The ERC-165 interface signature for ERC-721.\n', '    ///  Ref: https://github.com/ethereum/EIPs/issues/165\n', '    ///  Ref: https://github.com/ethereum/EIPs/issues/721\n', '    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\n', '\n', '    /// @dev Constructor creates a reference to the NFT ownership contract\n', '    ///  and verifies the owner cut is in the valid range.\n', '    /// @param _nftAddress - address of a deployed contract implementing\n', '    ///  the Nonfungible Interface.\n', '    /// @param _cut - percent cut the owner takes on each sale, must be\n', '    ///  between 0-10,000.\n', '    function MarketPlace(address _nftAddress, uint256 _cut) public {\n', '        require(_cut <= 10000);\n', '        ownerCut = _cut;\n', '\n', '        ERC721 candidateContract = ERC721(_nftAddress);\n', '        //require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n', '        nonFungibleContract = candidateContract;\n', '    }\n', '    function setNFTAddress(address _nftAddress, uint256 _cut) external onlyOwner {\n', '        require(_cut <= 10000);\n', '        ownerCut = _cut;\n', '        ERC721 candidateContract = ERC721(_nftAddress);\n', '        //require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n', '        nonFungibleContract = candidateContract;\n', '    }\n', '    /// @dev Remove all Ether from the contract, which is the owner&#39;s cuts\n', '    ///  as well as any Ether sent directly to the contract address.\n', '    ///  Always transfers to the NFT contract, but can be called either by\n', '    ///  the owner or the NFT contract.\n', '    function withdrawBalance() external {\n', '        address nftAddress = address(nonFungibleContract);\n', '\n', '        require(\n', '            msg.sender == owner ||\n', '            msg.sender == nftAddress\n', '        );\n', '        // We are using this boolean method to make sure that even if one fails it will still work\n', '        bool res = nftAddress.send(this.balance);\n', '    }\n', '\n', '    /// @dev Creates and begins a new sale.\n', '    /// @param _tokenId - ID of token to sale, sender must be owner.\n', '    /// @param _price - Price of item (in wei)\n', '    /// @param _seller - Seller, if not the message sender\n', '    function createSale(\n', '        uint256 _tokenId,\n', '        uint256 _price,\n', '        address _seller\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        // Sanity check that no inputs overflow how many bits we&#39;ve allocated\n', '        // to store them in the auction struct.\n', '        require(_price == uint256(uint128(_price)));\n', '        \n', '        //require(_owns(msg.sender, _tokenId));\n', '        //_escrow(msg.sender, _tokenId);\n', '        \n', '        require(msg.sender == address(nonFungibleContract));\n', '        _escrow(_seller, _tokenId);\n', '        \n', '        Sale memory sale = Sale(\n', '            _seller,\n', '            uint128(_price),\n', '            uint64(now)\n', '        );\n', '        _addSale(_tokenId, sale);\n', '    }\n', '\n', '\n', '    \n', '\n', '    /// @dev Bids on a sale, completing the sale and transferring\n', '    ///  ownership of the NFT if enough Ether is supplied.\n', '    /// @param _tokenId - ID of token to bid on.\n', '    function bid(uint256 _tokenId)\n', '        external\n', '        payable\n', '        whenNotPaused\n', '    {\n', '        // _bid will throw if the bid or funds transfer fails\n', '       _bid(_tokenId, msg.value); \n', '       _transfer(msg.sender, _tokenId);\n', '      \n', '    }\n', '\n', '    /// @dev Bids on a sale, completing the sale and transferring\n', '    ///  ownership of the NFT if enough Ether is supplied.\n', '    /// @param _tokenId - ID of token to bid on.\n', '    function bidReferral(uint256 _tokenId,uint256 _code)\n', '        external\n', '        payable\n', '        whenNotPaused\n', '    {\n', '        // _bid will throw if the bid or funds transfer fails\n', '        Affiliates storage affiliate = codeToAffiliate[_code];\n', '        \n', '        require(affiliate.affiliate_address!=0&&_code>0);\n', '        _bidReferral(_tokenId, msg.value,affiliate);\n', '        _transfer(msg.sender, _tokenId);\n', '\n', '       \n', '    }\n', '    \n', '    /// @dev Cancels an sale that hasn&#39;t been won yet.\n', '    ///  Returns the NFT to original owner.\n', '    /// @notice This is a state-modifying function that can\n', '    ///  be called while the contract is paused.\n', '    /// @param _tokenId - ID of token on sale\n', '    function cancelSale(uint256 _tokenId)\n', '        external\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        address seller = sale.seller;\n', '        require(msg.sender == seller);\n', '        _cancelSale(_tokenId, seller);\n', '    }\n', '\n', '    /// @dev Cancels a sale when the contract is paused.\n', '    ///  Only the owner may do this, and NFTs are returned to\n', '    ///  the seller. This should only be used in emergencies.\n', '    /// @param _tokenId - ID of the NFT on sale to cancel.\n', '    function cancelSaleWhenPaused(uint256 _tokenId)\n', '        whenPaused\n', '        onlyOwner\n', '        external\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        _cancelSale(_tokenId, sale.seller);\n', '    }\n', '\n', '    /// @dev Returns sale info for an NFT on sale.\n', '    /// @param _tokenId - ID of NFT on sale.\n', '    function getSale(uint256 _tokenId)\n', '        external\n', '        view\n', '        returns\n', '    (\n', '        address seller,\n', '        uint256 price,\n', '        uint256 startedAt\n', '    ) {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        return (\n', '            sale.seller,\n', '            sale.price,\n', '            sale.startedAt\n', '        );\n', '    }\n', '\n', '    /// @dev Returns the current price of a sale.\n', '    /// @param _tokenId - ID of the token price we are checking.\n', '    function getCurrentPrice(uint256 _tokenId)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        return sale.price;\n', '    }\n', '\n', '\n', '    /// @dev Creates and begins a new sale.\n', '    /// @param _code - ID of token to sale, sender must be owner.\n', '    /// @param _commission - percentage of commission for affiliate\n', '    /// @param _pricecut - percentage of sell price cut for buyer\n', '    /// @param _affiliate_address - affiliate address \n', '    function createAffiliate(\n', '        uint256 _code,\n', '        uint64  _commission,\n', '        uint64  _pricecut,\n', '        address _affiliate_address\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '\n', '        Affiliates memory affiliate = Affiliates(\n', '            address(_affiliate_address),\n', '            uint64(_commission),\n', '            uint64(_pricecut)\n', '        );\n', '        _addAffiliate(_code, affiliate);\n', '    }\n', '    \n', '    /// @dev Returns affiliate info for an affiliate code.\n', '    /// @param _code - code for an affiliate.\n', '    function getAffiliate(uint256 _code)\n', '        external\n', '        view\n', '        onlyOwner\n', '        returns\n', '    (\n', '         address affiliate_address,\n', '         uint64 commission,\n', '         uint64 pricecut\n', '    ) {\n', '        Affiliates storage affiliate = codeToAffiliate[_code];\n', '        \n', '        return (\n', '            affiliate.affiliate_address,\n', '            affiliate.commission,\n', '            affiliate.pricecut\n', '        );\n', '    }\n', '     /// @dev Removes affiliate.\n', '    ///  Only the owner may do this\n', '    /// @param _code - code for an affiliate.\n', '    function removeAffiliate(uint256 _code)\n', '        onlyOwner\n', '        external\n', '    {\n', '        _removeAffiliate(_code); \n', '        \n', '    }\n', '}\n', '\n', '\n', '/// @title ServiceStationBase core\n', '/// @dev Contains models, variables, and internal methods for the ServiceStation.\n', 'contract ServiceStationBase {\n', '\n', '    // Reference to contract tracking NFT ownership\n', '    ERC721 public nonFungibleContract;\n', '\n', '    struct Tune{\n', '        uint256 startChange;\n', '        uint256 rangeChange;\n', '        uint256 attChange;\n', '        bool plusMinus;\n', '        bool replace;\n', '        uint128 price;\n', '        bool active;\n', '        uint64 model;\n', '    }\n', '    Tune[] options;\n', '    \n', '   \n', '    \n', '    /// @dev Returns true if the claimant owns the token.\n', '    /// @param _claimant - Address claiming to own the token.\n', '    /// @param _tokenId - ID of token whose ownership to verify.\n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n', '    }\n', '  \n', '    /// @dev Calls the NFT Contract with the tuned attributes \n', '    function _tune(uint256 _newattributes, uint256 _tokenId) internal {\n', '    nonFungibleContract.tuneLambo(_newattributes, _tokenId);\n', '    }\n', '    \n', '    function _changeAttributes(uint256 _tokenId,uint256 _optionIndex) internal {\n', '    \n', '    //Get model from token\n', '    uint64 model = nonFungibleContract.getLamboModel(_tokenId);\n', '    //throw if tune option is not made for model\n', '    require(options[_optionIndex].model==model);\n', '    \n', '    //Get original attributes\n', '    uint256 attributes = nonFungibleContract.getLamboAttributes(_tokenId);\n', '    uint256 part=0;\n', '    \n', '    //Dissect for options\n', '    part=(attributes/(10 ** options[_optionIndex].startChange)) % (10 ** options[_optionIndex].rangeChange);\n', '    //part=1544;\n', '    //Change attributes & verify\n', '    //Should attChange be added,subtracted or replaced?\n', '    if(options[_optionIndex].replace == false)\n', '        {\n', '            \n', '            //change should be added\n', '            if(options[_optionIndex].plusMinus == false)\n', '            {\n', '                //e.g. if range = 4 then value can not be higher then 9999 - overflow check\n', '                require((part+options[_optionIndex].attChange)<(10**options[_optionIndex].rangeChange));\n', '                //add to attributes\n', '                attributes=attributes+options[_optionIndex].attChange*(10 ** options[_optionIndex].startChange);\n', '            }\n', '            else{\n', '                //do some subtraction\n', '                //e.g. value must be greater then 0\n', '                require(part>options[_optionIndex].attChange);\n', '                //substract from attributes \n', '                attributes-=options[_optionIndex].attChange*(10 ** options[_optionIndex].startChange);\n', '            }\n', '        }\n', '    else\n', '        {\n', '            //do some replacing\n', '            attributes=attributes-part*(10 ** options[_optionIndex].startChange);\n', '            attributes+=options[_optionIndex].attChange*(10 ** options[_optionIndex].startChange);\n', '        }\n', '    \n', '  \n', '   \n', '    //Tune Lambo in NFT contract\n', '    _tune(uint256(attributes), _tokenId);\n', '       \n', '        \n', '    }\n', '    \n', '    \n', '}\n', '\n', '\n', '/// @title ServiceStation for non-fungible tokens.\n', 'contract ServiceStation is Pausable, ServiceStationBase {\n', '\n', '\t// @dev Sanity check that allows us to ensure that we are pointing to the right call.\n', '    bool public isServicestation = true;\n', '\t\n', '    /// @dev The ERC-165 interface signature for ERC-721.\n', '    ///  Ref: https://github.com/ethereum/EIPs/issues/165\n', '    ///  Ref: https://github.com/ethereum/EIPs/issues/721\n', '    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\n', '\n', '    uint256 public optionCount;\n', '    mapping (uint64 => uint256) public modelIndexToOptionCount;\n', '    /// @dev Constructor creates a reference to the NFT ownership contract\n', '    ///  and verifies the owner cut is in the valid range.\n', '    /// @param _nftAddress - address of a deployed contract implementing\n', '    ///  the Nonfungible Interface.\n', '    function ServiceStation(address _nftAddress) public {\n', '\n', '        ERC721 candidateContract = ERC721(_nftAddress);\n', '        //require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n', '        nonFungibleContract = candidateContract;\n', '        _newTuneOption(0,0,0,false,false,0,0);\n', '        \n', '    }\n', '    function setNFTAddress(address _nftAddress) external onlyOwner {\n', '        \n', '        ERC721 candidateContract = ERC721(_nftAddress);\n', '        //require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n', '        nonFungibleContract = candidateContract;\n', '    }\n', '    \n', '    function newTuneOption(\n', '        uint32 _startChange,\n', '        uint32 _rangeChange,\n', '        uint256 _attChange,\n', '        bool _plusMinus,\n', '        bool _replace,\n', '        uint128 _price,\n', '        uint64 _model\n', '        )\n', '        external\n', '        {\n', '           //Only allow owner to add new options\n', '           require(msg.sender == owner ); \n', '           optionCount++;\n', '           modelIndexToOptionCount[_model]++;\n', '           _newTuneOption(_startChange,_rangeChange,_attChange,_plusMinus, _replace,_price,_model);\n', '       \n', '        }\n', '    function changeTuneOption(\n', '        uint32 _startChange,\n', '        uint32 _rangeChange,\n', '        uint256 _attChange,\n', '        bool _plusMinus,\n', '        bool _replace,\n', '        uint128 _price,\n', '        bool _isactive,\n', '        uint64 _model,\n', '        uint256 _optionIndex\n', '        )\n', '        external\n', '        {\n', '           //Only allow owner to add new options\n', '           require(msg.sender == owner ); \n', '           \n', '           \n', '           _changeTuneOption(_startChange,_rangeChange,_attChange,_plusMinus, _replace,_price,_isactive,_model,_optionIndex);\n', '       \n', '        }\n', '        \n', '    function _newTuneOption( uint32 _startChange,\n', '        uint32 _rangeChange,\n', '        uint256 _attChange,\n', '        bool _plusMinus,\n', '        bool _replace,\n', '        uint128 _price,\n', '        uint64 _model\n', '        ) \n', '        internal\n', '        {\n', '        \n', '           Tune memory _option = Tune({\n', '            startChange: _startChange,\n', '            rangeChange: _rangeChange,\n', '            attChange: _attChange,\n', '            plusMinus: _plusMinus,\n', '            replace: _replace,\n', '            price: _price,\n', '            active: true,\n', '            model: _model\n', '            });\n', '        \n', '        options.push(_option);\n', '    }\n', '    \n', '    function _changeTuneOption( uint32 _startChange,\n', '        uint32 _rangeChange,\n', '        uint256 _attChange,\n', '        bool _plusMinus,\n', '        bool _replace,\n', '        uint128 _price,\n', '        bool _isactive,\n', '        uint64 _model,\n', '        uint256 _optionIndex\n', '        ) \n', '        internal\n', '        {\n', '        \n', '           Tune memory _option = Tune({\n', '            startChange: _startChange,\n', '            rangeChange: _rangeChange,\n', '            attChange: _attChange,\n', '            plusMinus: _plusMinus,\n', '            replace: _replace,\n', '            price: _price,\n', '            active: _isactive,\n', '            model: _model\n', '            });\n', '        \n', '        options[_optionIndex]=_option;\n', '    }\n', '    \n', '    function disableTuneOption(uint256 index) external\n', '    {\n', '        require(msg.sender == owner ); \n', '        options[index].active=false;\n', '    }\n', '    \n', '    function enableTuneOption(uint256 index) external\n', '    {\n', '        require(msg.sender == owner ); \n', '        options[index].active=true;\n', '    }\n', '    function getOption(uint256 _index) \n', '    external view\n', '    returns (\n', '        uint256 _startChange,\n', '        uint256 _rangeChange,\n', '        uint256 _attChange,\n', '        bool _plusMinus,\n', '        uint128 _price,\n', '        bool active,\n', '        uint64 model\n', '    ) \n', '    {\n', '      \n', '        //require(options[_index].active);\n', '        return (\n', '            options[_index].startChange,\n', '            options[_index].rangeChange,\n', '            options[_index].attChange,\n', '            options[_index].plusMinus,\n', '            options[_index].price,\n', '            options[_index].active,\n', '            options[_index].model\n', '        );  \n', '    }\n', '    \n', '    function getOptionCount() external view returns (uint256 _optionCount)\n', '        {\n', '        return optionCount;    \n', '        }\n', '    \n', '    function tuneLambo(uint256 _tokenId,uint256 _optionIndex) external payable\n', '    {\n', '       //Caller needs to own Lambo\n', '       require(_owns(msg.sender, _tokenId)); \n', '       //Tuning Option needs to be enabled\n', '       require(options[_optionIndex].active);\n', '       //Enough money for tuning to spend?\n', '       require(msg.value>=options[_optionIndex].price);\n', '       \n', '       _changeAttributes(_tokenId,_optionIndex);\n', '    }\n', '    /// @dev Remove all Ether from the contract, which is the owner&#39;s cuts\n', '    ///  as well as any Ether sent directly to the contract address.\n', '    ///  Always transfers to the NFT contract, but can be called either by\n', '    ///  the owner or the NFT contract.\n', '    function withdrawBalance() external {\n', '        address nftAddress = address(nonFungibleContract);\n', '\n', '        require(\n', '            msg.sender == owner ||\n', '            msg.sender == nftAddress\n', '        );\n', '        // We are using this boolean method to make sure that even if one fails it will still work\n', '        bool res = owner.send(this.balance);\n', '    }\n', '\n', '    function getOptionsForModel(uint64 _model) external view returns(uint256[] _optionsModel) {\n', '        //uint256 tokenCount = balanceOf(_owner);\n', '\n', '        //if (tokenCount == 0) {\n', '            // Return an empty array\n', '        //    return new uint256[](0);\n', '        //} else {\n', '            uint256[] memory result = new uint256[](modelIndexToOptionCount[_model]);\n', '            //uint256 totalCars = totalSupply();\n', '            uint256 resultIndex = 0;\n', '\n', '            // We count on the fact that all cars have IDs starting at 0 and increasing\n', '            // sequentially up to the optionCount count.\n', '            uint256 optionId;\n', '\n', '            for (optionId = 1; optionId <= optionCount; optionId++) {\n', '                if (options[optionId].model == _model && options[optionId].active == true) {\n', '                    result[resultIndex] = optionId;\n', '                    resultIndex++;\n', '                }\n', '            }\n', '\n', '            return result;\n', '       // }\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '////No SiringClockAuction needed for Lambos\n', '////No separate modification for SaleContract needed\n', '\n', '/// @title Handles creating sales for sale of lambos.\n', '///  This wrapper of ReverseSale exists only so that users can create\n', '///  sales with only one transaction.\n', 'contract EtherLambosSale is EtherLambosOwnership {\n', '\n', '    // @notice The sale contract variables are defined in EtherLambosBase to allow\n', '    //  us to refer to them in EtherLambosOwnership to prevent accidental transfers.\n', '    // `saleMarketplace` refers to the auction for p2p sale of cars.\n', '   \n', '\n', '    /// @dev Sets the reference to the sale auction.\n', '    /// @param _address - Address of sale contract.\n', '    function setMarketplaceAddress(address _address) external onlyCEO {\n', '        MarketPlace candidateContract = MarketPlace(_address);\n', '\n', '        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n', '        require(candidateContract.isMarketplace());\n', '\n', '        // Set the new contract address\n', '        marketPlace = candidateContract;\n', '    }\n', '\n', '\n', '    /// @dev Put a lambo up for sale.\n', '    ///  Does some ownership trickery to create auctions in one tx.\n', '    function createLamboSale(\n', '        uint256 _carId,\n', '        uint256 _price\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        // Sale contract checks input sizes\n', '        // If lambo is already on any sale, this will throw\n', '        // because it will be owned by the sale contract.\n', '        require(_owns(msg.sender, _carId));\n', '        \n', '        _approve(_carId, marketPlace);\n', '        // Sale throws if inputs are invalid and clears\n', '        // transfer after escrowing the lambo.\n', '        marketPlace.createSale(\n', '            _carId,\n', '            _price,\n', '            msg.sender\n', '        );\n', '    }\n', '    \n', '    \n', '    function bulkCreateLamboSale(\n', '        uint256 _price,\n', '        uint256 _tokenIdStart,\n', '        uint256 _tokenCount\n', '    )\n', '        external\n', '        onlyCOO\n', '    {\n', '        // Sale contract checks input sizes\n', '        // If lambo is already on any sale, this will throw\n', '        // because it will be owned by the sale contract.\n', '        for(uint256 i=0;i<_tokenCount;i++)\n', '            {\n', '            require(_owns(msg.sender, _tokenIdStart+i));\n', '        \n', '            _approve(_tokenIdStart+i, marketPlace);\n', '            // Sale throws if inputs are invalid and clears\n', '            // transfer after escrowing the lambo.\n', '            marketPlace.createSale(\n', '                _tokenIdStart+i,\n', '                _price,\n', '             msg.sender\n', '            );\n', '        }\n', '    }\n', '    /// @dev Transfers the balance of the marketPlace contract\n', '    /// to the EtherLambosCore contract. We use two-step withdrawal to\n', '    /// prevent two transfer calls in the auction bid function.\n', '    function withdrawSaleBalances() external onlyCLevel {\n', '        marketPlace.withdrawBalance();\n', '        \n', '    }\n', '}\n', '\n', '/// @title all functions related to creating lambos\n', 'contract EtherLambosBuilding is EtherLambosSale {\n', '\n', '    // Limits the number of cars the contract owner can ever create.\n', '    //uint256 public constant PROMO_CREATION_LIMIT = 5000;\n', '    //uint256 public constant GEN0_CREATION_LIMIT = 45000;\n', '\n', '\n', '    // Counts the number of cars the contract owner has created.\n', '    uint256 public lambosBuildCount;\n', '\n', '\n', '    /// @dev we can build lambos. Only callable by COO\n', '    /// @param _attributes the encoded attributes of the lambo to be created, any value is accepted\n', '    /// @param _owner the future owner of the created lambo. Default to contract COO\n', '    /// @param _model the model of the created lambo. \n', '    function createLambo(uint256 _attributes, address _owner, uint64 _model) external onlyCOO {\n', '        address lamboOwner = _owner;\n', '        if (lamboOwner == address(0)) {\n', '             lamboOwner = cooAddress;\n', '        }\n', '        //require(promoCreatedCount < PROMO_CREATION_LIMIT);\n', '\n', '        lambosBuildCount++;\n', '        _createLambo(_attributes, lamboOwner, _model);\n', '    }\n', '\n', '    function bulkCreateLambo(uint256 _attributes, address _owner, uint64 _model,uint256 count, uint256 startNo) external onlyCOO {\n', '        address lamboOwner = _owner;\n', '        uint256 att=_attributes;\n', '        if (lamboOwner == address(0)) {\n', '             lamboOwner = cooAddress;\n', '        }\n', '        \n', '        //do some replacing\n', '            //_attributes=_attributes-part*(10 ** 66);\n', '        \n', '        \n', '        //require(promoCreatedCount < PROMO_CREATION_LIMIT);\n', '        for(uint256 i=0;i<count;i++)\n', '            {\n', '            lambosBuildCount++;\n', '            att=_attributes+(startNo+i)*(10 ** 66);\n', '            _createLambo(att, lamboOwner, _model);\n', '            }\n', '    }\n', '}\n', '\n', '/// @title all functions related to tuning lambos\n', 'contract EtherLambosTuning is EtherLambosBuilding {\n', '\n', '    // Counts the number of tunings have been done.\n', '    uint256 public lambosTuneCount;\n', '\n', '    function setServicestationAddress(address _address) external onlyCEO {\n', '        ServiceStation candidateContract = ServiceStation(_address);\n', '\n', '        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n', '        require(candidateContract.isServicestation());\n', '\n', '        // Set the new contract address\n', '        serviceStation = candidateContract;\n', '    }\n', '    /// @dev we can tune lambos. Only callable by ServiceStation contract\n', '    /// @param _newattributes the new encoded attributes of the lambo to be updated\n', '    /// @param _tokenId the lambo to be tuned.\n', '    function tuneLambo(uint256 _newattributes, uint256 _tokenId) external {\n', '        \n', '        //Tuning can only be done by the ServiceStation Contract. \n', '        require(\n', '            msg.sender == address(serviceStation)\n', '        );\n', '        \n', '        \n', '        lambosTuneCount++;\n', '        _tuneLambo(_newattributes, _tokenId);\n', '    }\n', '    function withdrawTuneBalances() external onlyCLevel {\n', '        serviceStation.withdrawBalance();\n', '        \n', '    }\n', '\n', '}\n', '\n', '/// @title EtherLambos: Collectible, tuneable, and super stylish lambos on the Ethereum blockchain.\n', '/// @author Cryptoknights code adapted from Axiom Zen (https://www.axiomzen.co)\n', '/// @dev The main EtherLambos contract, keeps track of lambos.\n', 'contract EtherLambosCore is EtherLambosTuning {\n', '\n', '    // This is the main EtherLambos contract. In order to keep our code seperated into logical sections,\n', '    // we&#39;ve broken it up in two ways. First, we have several seperately-instantiated sibling contracts\n', '    // that handle sales. The sales are\n', '    // seperate since their logic is somewhat complex and there&#39;s always a risk of subtle bugs. By keeping\n', '    // them in their own contracts, we can upgrade them without disrupting the main contract that tracks\n', '    // lambo ownership. \n', '    //\n', '    // Secondly, we break the core contract into multiple files using inheritence, one for each major\n', '    // facet of functionality of EtherLambos. This allows us to keep related code bundled together while still\n', '    // avoiding a single giant file with everything in it. The breakdown is as follows:\n', '    //\n', '    //      - EtherLambosBase: This is where we define the most fundamental code shared throughout the core\n', '    //             functionality. This includes our main data storage, constants and data types, plus\n', '    //             internal functions for managing these items.\n', '    //\n', '    //      - EtherLambosAccessControl: This contract manages the various addresses and constraints for operations\n', '    //             that can be executed only by specific roles. Namely CEO, CFO and COO.\n', '    //\n', '    //      - EtherLambosOwnership: This provides the methods required for basic non-fungible token\n', '    //             transactions, following the draft ERC-721 spec (https://github.com/ethereum/EIPs/issues/721).\n', '    //\n', '    //      - EtherLambosSale: Here we have the public methods for sales. \n', '    //\n', '    //      - EtherLambosBuilding: This final facet contains the functionality we use for creating new cars.\n', '    //             \n', '\n', '    // Set in case the core contract is broken and an upgrade is required\n', '    address public newContractAddress;\n', '\n', '    /// @notice Creates the main EtherLambos smart contract instance.\n', '    function EtherLambosCore() public {\n', '        // Starts paused.\n', '        paused = true;\n', '\n', '        // the creator of the contract is the initial CEO\n', '        ceoAddress = msg.sender;\n', '\n', '        // the creator of the contract is also the initial COO\n', '        cooAddress = msg.sender;\n', '\n', '        // start with the car 0 \n', '        _createLambo(uint256(-1), address(0),0);\n', '    }\n', '\n', '    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\n', '    ///  breaking bug. This method does nothing but keep track of the new contract and\n', '    ///  emit a message indicating that the new address is set. It&#39;s up to clients of this\n', '    ///  contract to update to the new contract address in that case. (This contract will\n', '    ///  be paused indefinitely if such an upgrade takes place.)\n', '    /// @param _v2Address new address\n', '    function setNewAddress(address _v2Address) external onlyCEO whenPaused {\n', '        // See README.md for updgrade plan\n', '        newContractAddress = _v2Address;\n', '        ContractUpgrade(_v2Address);\n', '    }\n', '\n', '    /// @notice No tipping!\n', '    /// @dev Reject all Ether from being sent here, unless it&#39;s from the marketPlace contract.\n', '    /// (Hopefully, we can prevent user accidents.)\n', '    function() external payable {\n', '        require(\n', '            msg.sender == address(marketPlace)\n', '        );\n', '    }\n', '\n', '    /// @notice Returns all the relevant information about a specific lambo.\n', '    /// @param _id The ID of the lambo of interest.\n', '    function getLambo(uint256 _id)\n', '        external\n', '        view\n', '        returns (\n', '        uint256 buildTime,\n', '        uint256 attributes\n', '    ) {\n', '        Lambo storage kit = lambos[_id];\n', '\n', '        buildTime = uint256(kit.buildTime);\n', '        attributes = kit.attributes;\n', '    }\n', '    /// @notice Returns all the relevant information about a specific lambo.\n', '    /// @param _id The ID of the lambo of interest.\n', '    function getLamboAttributes(uint256 _id)\n', '        external\n', '        view\n', '        returns (\n', '        uint256 attributes\n', '    ) {\n', '        Lambo storage kit = lambos[_id];\n', '        attributes = kit.attributes;\n', '        return attributes;\n', '    }\n', '    \n', '    /// @notice Returns all the relevant information about a specific lambo.\n', '    /// @param _id The ID of the lambo of interest.\n', '    function getLamboModel(uint256 _id)\n', '        external\n', '        view\n', '        returns (\n', '        uint64 model\n', '    ) {\n', '        Lambo storage kit = lambos[_id];\n', '        model = kit.model;\n', '        return model;\n', '    }\n', '    /// @dev Override unpause so it requires all external contract addresses\n', '    ///  to be set before contract can be unpaused. Also, we can&#39;t have\n', '    ///  newContractAddress set either, because then the contract was upgraded.\n', '    /// @notice This is public rather than external so we can call super.unpause\n', '    ///  without using an expensive CALL.\n', '    function unpause() public onlyCEO whenPaused {\n', '        require(marketPlace != address(0));\n', '        require(serviceStation != address(0));\n', '        require(newContractAddress == address(0));\n', '\n', '        // Actually unpause the contract.\n', '        super.unpause();\n', '    }\n', '\n', '    // @dev Allows the CFO to capture the balance available to the contract.\n', '    function withdrawBalance() external onlyCFO {\n', '        uint256 balance = this.balance;\n', '        cfoAddress.send(balance);\n', '     \n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\n', 'contract ERC721 {\n', '    // Required methods\n', '    function totalSupply() public view returns (uint256 total);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) external view returns (address owner);\n', '    function approve(address _to, uint256 _tokenId) external;\n', '    function transfer(address _to, uint256 _tokenId) external;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    \n', '    // Optional methods used by ServiceStation contract\n', '    function tuneLambo(uint256 _newattributes, uint256 _tokenId) external;\n', '    function getLamboAttributes(uint256 _id) external view returns (uint256 attributes);\n', '    function getLamboModel(uint256 _tokenId) external view returns (uint64 _model);\n', '    // Events\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event Approval(address owner, address approved, uint256 tokenId);\n', '\n', '    // Optional\n', '    // function name() public view returns (string name);\n', '    // function symbol() public view returns (string symbol);\n', '    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n', '    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n', '\n', '    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '}\n', '\n', '\n', '\n', '/// @title A facet of EtherLamboCore that manages special access privileges.\n', '/// @author Axiom Zen (https://www.axiomzen.co) adapted by Kenny Bania\n', '/// @dev ...\n', 'contract EtherLambosAccessControl {\n', '    // This facet controls access control for Etherlambos. There are four roles managed here:\n', '    //\n', '    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n', '    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n', '    //         set to the address that created the smart contract in the EtherLamboCore constructor.\n', '    //\n', '    //     - The CFO: The CFO can withdraw funds from EtherLamboCore and its auction contracts.\n', '    //\n', '    //     - The COO: The COO can release new models for sale.\n', '    //\n', '    // It should be noted that these roles are distinct without overlap in their access abilities, the\n', '    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\n', "    // address to any role, the CEO address itself doesn't have the ability to act in those roles. This\n", "    // restriction is intentional so that we aren't tempted to use the CEO address frequently out of\n", '    // convenience. The less we use an address, the less likely it is that we somehow compromise the\n', '    // account.\n', '\n', '    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n', '    event ContractUpgrade(address newContract);\n', '\n', '    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '    address public cooAddress;\n', '\n', '    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused = false;\n', '\n', '    /// @dev Access modifier for CEO-only functionality\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for CFO-only functionality\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for COO-only functionality\n', '    modifier onlyCOO() {\n', '        require(msg.sender == cooAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == cooAddress ||\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cfoAddress\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '    /// @param _newCEO The address of the new CEO\n', '    function setCEO(address _newCEO) external onlyCEO {\n', '        require(_newCEO != address(0));\n', '\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n', '    /// @param _newCFO The address of the new CFO\n', '    function setCFO(address _newCFO) external onlyCEO {\n', '        require(_newCFO != address(0));\n', '\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n', '    /// @param _newCOO The address of the new COO\n', '    function setCOO(address _newCOO) external onlyCEO {\n', '        require(_newCOO != address(0));\n', '\n', '        cooAddress = _newCOO;\n', '    }\n', '\n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '    ///  a bug or exploit is detected and we need to limit damage.\n', '    function pause() external onlyCLevel whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '    ///  one reason we may pause the contract is when CFO or COO accounts are\n', '    ///  compromised.\n', '    /// @notice This is public rather than external so it can be called by\n', '    ///  derived contracts.\n', '    function unpause() public onlyCEO whenPaused {\n', "        // can't unpause if contract was upgraded\n", '        paused = false;\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title Base contract for EtherLambos. Holds all common structs, events and base variables.\n', '/// @author Axiom Zen (https://www.axiomzen.co) adapted by Kenny Bania\n', '/// @dev ...\n', 'contract EtherLambosBase is EtherLambosAccessControl {\n', '    /*** EVENTS ***/\n', '\n', '    /// @dev The Build event is fired whenever a new car model is build by the COO\n', '    event Build(address owner, uint256 lamboId, uint256 attributes);\n', '\n', '    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a car\n', '    ///  ownership is assigned, including builds.\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '\n', '    event Tune(uint256 _newattributes, uint256 _tokenId);\n', '    \n', '    /*** DATA TYPES ***/\n', '\n', '    /// @dev The main EtherLambos struct. Every car in EtherLambos is represented by a copy\n', '    ///  of this structure, so great care was taken to ensure that it fits neatly into\n', '    ///  exactly two 256-bit words. Note that the order of the members in this structure\n', '    ///  is important because of the byte-packing rules used by Ethereum.\n', '    ///  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html\n', '    struct Lambo {\n', '        // sports-car attributes like max speed, weight etc. are stored here.\n', '        // These attributes can be changed due to tuning/upgrades\n', '        uint256 attributes;\n', '\n', '        // The timestamp from the block when this car came was constructed.\n', '        uint64 buildTime;\n', '        \n', '        // the Lambo model identifier\n', '        uint64 model;\n', '\n', '    }\n', '\n', '\n', '    // An approximation of currently how many seconds are in between blocks.\n', '    uint256 public secondsPerBlock = 15;\n', '\n', '    /*** STORAGE ***/\n', '\n', '    /// @dev An array containing the Lambo struct for all Lambos in existence. The ID\n', '    ///  of each car is actually an index into this array. Note that 0 is invalid index.\n', '    Lambo[] lambos;\n', '\n', '    /// @dev A mapping from car IDs to the address that owns them. All cars have\n', '    ///  some valid owner address.\n', '    mapping (uint256 => address) public lamboIndexToOwner;\n', '\n', '    // @dev A mapping from owner address to count of tokens that address owns.\n', '    //  Used internally inside balanceOf() to resolve ownership count.\n', '    mapping (address => uint256) ownershipTokenCount;\n', '\n', '    /// @dev A mapping from LamboIDs to an address that has been approved to call\n', '    ///  transferFrom(). Each Lambo can only have one approved address for transfer\n', '    ///  at any time. A zero value means no approval is outstanding.\n', '    mapping (uint256 => address) public lamboIndexToApproved;\n', '\n', '    /// @dev The address of the MarketPlace contract that handles sales of Lambos. This\n', '    ///  same contract handles both peer-to-peer sales as well as new model sales. \n', '    MarketPlace public marketPlace;\n', '    ServiceStation public serviceStation;\n', '    /// @dev Assigns ownership of a specific Lambo to an address.\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', "        // Since the number of lambos is capped to 2^32 we can't overflow this\n", '        ownershipTokenCount[_to]++;\n', '        // transfer ownership\n', '        lamboIndexToOwner[_tokenId] = _to;\n', "        // When creating new lambos _from is 0x0, but we can't account that address.\n", '        if (_from != address(0)) {\n', '            ownershipTokenCount[_from]--;\n', '            // clear any previously approved ownership exchange\n', '            delete lamboIndexToApproved[_tokenId];\n', '        }\n', '        // Emit the transfer event.\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /// @dev An internal method that creates a new lambo and stores it. This\n', "    ///  method doesn't do any checking and should only be called when the\n", '    ///  input data is known to be valid. Will generate both a Build event\n', '    ///  and a Transfer event.\n', "    /// @param _attributes The lambo's attributes.\n", '    /// @param _owner The inital owner of this car, must be non-zero\n', '    function _createLambo(\n', '        uint256 _attributes,\n', '        address _owner,\n', '        uint64  _model\n', '    )\n', '        internal\n', '        returns (uint)\n', '    {\n', '\n', '        \n', '        Lambo memory _lambo = Lambo({\n', '            attributes: _attributes,\n', '            buildTime: uint64(now),\n', '            model:_model\n', '        });\n', '        uint256 newLamboId = lambos.push(_lambo) - 1;\n', '\n', "        // It's probably never going to happen, 4 billion cars is A LOT, but\n", "        // let's just be 100% sure we never let this happen.\n", '        require(newLamboId == uint256(uint32(newLamboId)));\n', '\n', '        // emit the build event\n', '        Build(\n', '            _owner,\n', '            newLamboId,\n', '            _lambo.attributes\n', '        );\n', '\n', '        // This will assign ownership, and also emit the Transfer event as\n', '        // per ERC721 draft\n', '        _transfer(0, _owner, newLamboId);\n', '\n', '        return newLamboId;\n', '    }\n', '     /// @dev An internal method that tunes an existing lambo. This\n', "    ///  method doesn't do any checking and should only be called when the\n", '    ///  input data is known to be valid. Will generate a Tune event\n', "    /// @param _newattributes The lambo's new attributes.\n", '    /// @param _tokenId The car to be tuned.\n', '    function _tuneLambo(\n', '        uint256 _newattributes,\n', '        uint256 _tokenId\n', '    )\n', '        internal\n', '    {\n', '        lambos[_tokenId].attributes=_newattributes;\n', '     \n', '        // emit the tune event\n', '        Tune(\n', '            _tokenId,\n', '            _newattributes\n', '        );\n', '\n', '    }\n', '    // Any C-level can fix how many seconds per blocks are currently observed.\n', '    function setSecondsPerBlock(uint256 secs) external onlyCLevel {\n', '        //require(secs < cooldowns[0]);\n', '        secondsPerBlock = secs;\n', '    }\n', '}\n', '\n', '/// @title The external contract that is responsible for generating metadata for the cars,\n', '///  it has one function that will return the data as bytes.\n', 'contract ERC721Metadata {\n', '    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\n', '    function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {\n', '        if (_tokenId == 1) {\n', '            buffer[0] = "Hello World! :D";\n', '            count = 15;\n', '        } else if (_tokenId == 2) {\n', '            buffer[0] = "I would definitely choose a medi";\n', '            buffer[1] = "um length string.";\n', '            count = 49;\n', '        } else if (_tokenId == 3) {\n', '            buffer[0] = "Lorem ipsum dolor sit amet, mi e";\n', '            buffer[1] = "st accumsan dapibus augue lorem,";\n', '            buffer[2] = " tristique vestibulum id, libero";\n', '            buffer[3] = " suscipit varius sapien aliquam.";\n', '            count = 128;\n', '        }\n', '    }\n', '}\n', '\n', '/// @title The facet of the EtherLambosCore contract that manages ownership, ERC-721 (draft) compliant.\n', '/// @author Axiom Zen (https://www.axiomzen.co) adapted by Cryptoknights\n', '/// @dev Ref: https://github.com/ethereum/EIPs/issues/721\n', '\n', 'contract EtherLambosOwnership is EtherLambosBase, ERC721 {\n', '\n', '    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '    string public constant name = "EtherLambos";\n', '    string public constant symbol = "EL";\n', '\n', '    // The contract that will return lambo metadata\n', '    ERC721Metadata public erc721Metadata;\n', '\n', '    bytes4 constant InterfaceSignature_ERC165 =\n', "        bytes4(keccak256('supportsInterface(bytes4)'));\n", '\n', '    bytes4 constant InterfaceSignature_ERC721 =\n', "        bytes4(keccak256('name()')) ^\n", "        bytes4(keccak256('symbol()')) ^\n", "        bytes4(keccak256('totalSupply()')) ^\n", "        bytes4(keccak256('balanceOf(address)')) ^\n", "        bytes4(keccak256('ownerOf(uint256)')) ^\n", "        bytes4(keccak256('approve(address,uint256)')) ^\n", "        bytes4(keccak256('transfer(address,uint256)')) ^\n", "        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n", "        bytes4(keccak256('tokensOfOwner(address)')) ^\n", "        bytes4(keccak256('tokenMetadata(uint256,string)'));\n", '\n', '    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n', '    ///  Returns true for any standardized interfaces implemented by this contract. We implement\n', '    ///  ERC-165 (obviously!) and ERC-721.\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\n', '    {\n', '        // DEBUG ONLY\n', '        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\n', '\n', '        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\n', '    }\n', '\n', '    /// @dev Set the address of the sibling contract that tracks metadata.\n', '    ///  CEO only.\n', '    function setMetadataAddress(address _contractAddress) public onlyCEO {\n', '        erc721Metadata = ERC721Metadata(_contractAddress);\n', '    }\n', '\n', '    // Internal utility functions: These functions all assume that their input arguments\n', '    // are valid. We leave it to public methods to sanitize their inputs and follow\n', '    // the required logic.\n', '\n', '    /// @dev Checks if a given address is the current owner of a particular Lambo.\n', '    /// @param _claimant the address we are validating against.\n', '    /// @param _tokenId kitten id, only valid when > 0\n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return lamboIndexToOwner[_tokenId] == _claimant;\n', '    }\n', '\n', '    /// @dev Checks if a given address currently has transferApproval for a particular Lambo.\n', '    /// @param _claimant the address we are confirming Lambo is approved for.\n', '    /// @param _tokenId lambo id, only valid when > 0\n', '    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return lamboIndexToApproved[_tokenId] == _claimant;\n', '    }\n', '\n', '    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n', '    ///  approval. Setting _approved to address(0) clears all transfer approval.\n', '    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\n', '    ///  _approve() and transferFrom() are used together for putting Lambos on sale, and\n', '    ///  there is no value in spamming the log with Approval events in that case.\n', '    function _approve(uint256 _tokenId, address _approved) internal {\n', '        lamboIndexToApproved[_tokenId] = _approved;\n', '    }\n', '\n', '    /// @notice Returns the number of Lambos owned by a specific address.\n', '    /// @param _owner The owner address to check.\n', '    /// @dev Required for ERC-721 compliance\n', '    function balanceOf(address _owner) public view returns (uint256 count) {\n', '        return ownershipTokenCount[_owner];\n', '    }\n', '\n', '    /// @notice Transfers a Lambo to another address. If transferring to a smart\n', '    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or\n', '    ///  EtherLambos specifically) or your Lambo may be lost forever. Seriously.\n', '    /// @param _to The address of the recipient, can be a user or contract.\n', '    /// @param _tokenId The ID of the Lambo to transfer.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function transfer(\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        // Safety check to prevent against an unexpected 0x0 default.\n', '        require(_to != address(0));\n', '        // Disallow transfers to this contract to prevent accidental misuse.\n', '        // The contract should never own any lambos.\n', '        require(_to != address(this));\n', '        // Disallow transfers to the auction contracts to prevent accidental\n', '        // misuse. Marketplace contracts should only take ownership of Lambos\n', '        // through the allow + transferFrom flow.\n', '        require(_to != address(marketPlace));\n', '\n', '        // You can only send your own car.\n', '        require(_owns(msg.sender, _tokenId));\n', '\n', '        // Reassign ownership, clear pending approvals, emit Transfer event.\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /// @notice Grant another address the right to transfer a specific Lambo via\n', '    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n', '    /// @param _to The address to be granted transfer approval. Pass address(0) to\n', '    ///  clear all approvals.\n', '    /// @param _tokenId The ID of the Lambo that can be transferred if this call succeeds.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function approve(\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        // Only an owner can grant transfer approval.\n', '        require(_owns(msg.sender, _tokenId));\n', '\n', '        // Register the approval (replacing any previous approval).\n', '        _approve(_tokenId, _to);\n', '\n', '        // Emit approval event.\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /// @notice Transfer a Lambo owned by another address, for which the calling address\n', '    ///  has previously been granted transfer approval by the owner.\n', '    /// @param _from The address that owns the Lambo to be transfered.\n', '    /// @param _to The address that should take ownership of the Lambo. Can be any address,\n', '    ///  including the caller.\n', '    /// @param _tokenId The ID of the Lambo to be transferred.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        // Safety check to prevent against an unexpected 0x0 default.\n', '        require(_to != address(0));\n', '        // Disallow transfers to this contract to prevent accidental misuse.\n', '        // The contract should never own any lambos.\n', '        require(_to != address(this));\n', '        // Check for approval and valid ownership\n', '        require(_approvedFor(msg.sender, _tokenId));\n', '        require(_owns(_from, _tokenId));\n', '\n', '        // Reassign ownership (also clears pending approvals and emits Transfer event).\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /// @notice Returns the total number of Lambos currently in existence.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function totalSupply() public view returns (uint) {\n', '        return lambos.length - 1;\n', '    }\n', '\n', '    /// @notice Returns the address currently assigned ownership of a given Lambo.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function ownerOf(uint256 _tokenId)\n', '        external\n', '        view\n', '        returns (address owner)\n', '    {\n', '        owner = lamboIndexToOwner[_tokenId];\n', '\n', '        require(owner != address(0));\n', '    }\n', '\n', '    /// @notice Returns a list of all Lambo IDs assigned to an address.\n', '    /// @param _owner The owner whose Lambo we are interested in.\n', "    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\n", '    ///  expensive (it walks the entire Lambo array looking for cars belonging to owner),\n', '    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '    ///  not contract-to-contract calls.\n', '    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '\n', '        if (tokenCount == 0) {\n', '            // Return an empty array\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            uint256 totalCars = totalSupply();\n', '            uint256 resultIndex = 0;\n', '\n', '            // We count on the fact that all cars have IDs starting at 1 and increasing\n', '            // sequentially up to the totalCat count.\n', '            uint256 carId;\n', '\n', '            for (carId = 1; carId <= totalCars; carId++) {\n', '                if (lamboIndexToOwner[carId] == _owner) {\n', '                    result[resultIndex] = carId;\n', '                    resultIndex++;\n', '                }\n', '            }\n', '\n', '            return result;\n', '        }\n', '    }\n', '\n', '    /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)\n', '    ///  This method is licenced under the Apache License.\n', '    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n', '    function _memcpy(uint _dest, uint _src, uint _len) private view {\n', '        // Copy word-length chunks while possible\n', '        for(; _len >= 32; _len -= 32) {\n', '            assembly {\n', '                mstore(_dest, mload(_src))\n', '            }\n', '            _dest += 32;\n', '            _src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint256 mask = 256 ** (32 - _len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(_src), not(mask))\n', '            let destpart := and(mload(_dest), mask)\n', '            mstore(_dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\n', '    ///  This method is licenced under the Apache License.\n', '    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n', '    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) {\n', '        var outputString = new string(_stringLength);\n', '        uint256 outputPtr;\n', '        uint256 bytesPtr;\n', '\n', '        assembly {\n', '            outputPtr := add(outputString, 32)\n', '            bytesPtr := _rawBytes\n', '        }\n', '\n', '        _memcpy(outputPtr, bytesPtr, _stringLength);\n', '\n', '        return outputString;\n', '    }\n', '\n', '    /// @notice Returns a URI pointing to a metadata package for this token conforming to\n', '    ///  ERC-721 (https://github.com/ethereum/EIPs/issues/721)\n', '    /// @param _tokenId The ID number of the Lambos whose metadata should be returned.\n', '    function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) {\n', '        require(erc721Metadata != address(0));\n', '        bytes32[4] memory buffer;\n', '        uint256 count;\n', '        (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);\n', '\n', '        return _toString(buffer, count);\n', '    }\n', '}\n', '\n', '\n', '/// @title MarketPlace core\n', '/// @dev Contains models, variables, and internal methods for the marketplace.\n', '/// @notice We omit a fallback function to prevent accidental sends to this contract.\n', 'contract MarketPlaceBase is Ownable {\n', '\n', '    // Represents an sale on an NFT\n', '    struct Sale {\n', '        // Current owner of NFT\n', '        address seller;\n', '        // Price (in wei) \n', '        uint128 price;\n', '        // Time when sale started\n', '        // NOTE: 0 if this sale has been concluded\n', '        uint64 startedAt;\n', '    }\n', '    \n', '    struct Affiliates {\n', '        address affiliate_address;\n', '        uint64 commission;\n', '        uint64 pricecut;\n', '    }\n', '    \n', '    //Affiliates[] affiliates;\n', '    // Reference to contract tracking NFT ownership\n', '    ERC721 public nonFungibleContract;\n', '\n', '    // Cut owner takes on each sale, measured in basis points (1/100 of a percent).\n', '    // Values 0-10,000 map to 0%-100%\n', '    uint256 public ownerCut;\n', '\n', '    //map the Affiliate Code to the Affiliate\n', '    mapping (uint256 => Affiliates) codeToAffiliate;\n', '\n', '    // Map from token ID to their corresponding sale.\n', '    mapping (uint256 => Sale) tokenIdToSale;\n', '\n', '    event SaleCreated(uint256 tokenId, uint256 price);\n', '    event SaleSuccessful(uint256 tokenId, uint256 price, address buyer);\n', '    event SaleCancelled(uint256 tokenId);\n', '\n', '    /// @dev Returns true if the claimant owns the token.\n', '    /// @param _claimant - Address claiming to own the token.\n', '    /// @param _tokenId - ID of token whose ownership to verify.\n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n', '    }\n', '\n', '    /// @dev Escrows the NFT, assigning ownership to this contract.\n', '    /// Throws if the escrow fails.\n', '    /// @param _owner - Current owner address of token to escrow.\n', '    /// @param _tokenId - ID of token whose approval to verify.\n', '    function _escrow(address _owner, uint256 _tokenId) internal {\n', '        // it will throw if transfer fails\n', '        nonFungibleContract.transferFrom(_owner, this, _tokenId);\n', '    }\n', '\n', '    /// @dev Transfers an NFT owned by this contract to another address.\n', '    /// Returns true if the transfer succeeds.\n', '    /// @param _receiver - Address to transfer NFT to.\n', '    /// @param _tokenId - ID of token to transfer.\n', '    function _transfer(address _receiver, uint256 _tokenId) internal {\n', '        // it will throw if transfer fails\n', '        nonFungibleContract.transfer(_receiver, _tokenId);\n', '    }\n', '\n', '    /// @dev Adds an sale to the list of open sales. Also fires the\n', '    ///  SaleCreated event.\n', '    /// @param _tokenId The ID of the token to be put on sale.\n', '    /// @param _sale Sale to add.\n', '    function _addSale(uint256 _tokenId, Sale _sale) internal {\n', '        \n', '\n', '        tokenIdToSale[_tokenId] = _sale;\n', '\n', '        SaleCreated(\n', '            uint256(_tokenId),\n', '            uint256(_sale.price)\n', '        );\n', '    }\n', '\n', '    /// @dev Cancels a sale unconditionally.\n', '    function _cancelSale(uint256 _tokenId, address _seller) internal {\n', '        _removeSale(_tokenId);\n', '        _transfer(_seller, _tokenId);\n', '        SaleCancelled(_tokenId);\n', '    }\n', '\n', '    /// @dev Computes the price and transfers winnings.\n', '    /// Does NOT transfer ownership of token.\n', '    function _bid(uint256 _tokenId, uint256 _bidAmount)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        // Get a reference to the sale struct\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '\n', '        // Explicitly check that this sale is currently live.\n', "        // (Because of how Ethereum mappings work, we can't just count\n", '        // on the lookup above failing. An invalid _tokenId will just\n', '        // return a sale object that is all zeros.)\n', '        require(_isOnSale(sale));\n', '\n', '        // Check that the bid is greater than or equal to the current price\n', '        uint256 price = sale.price;\n', '        require(_bidAmount >= price);\n', '\n', '        // Grab a reference to the seller before the sale struct\n', '        // gets deleted.\n', '        address seller = sale.seller;\n', '\n', '        // The bid is good! Remove the sale before sending the fees\n', "        // to the sender so we can't have a reentrancy attack.\n", '        _removeSale(_tokenId);\n', '\n', '        // Transfer proceeds to seller (if there are any!)\n', '        if (price > 0) {\n', "            // Calculate the Marketplace's cut.\n", '            // (NOTE: _computeCut() is guaranteed to return a\n', "            // value <= price, so this subtraction can't go negative.)\n", '            uint256 marketplaceCut = _computeCut(price);\n', '            uint256 sellerProceeds = price - marketplaceCut;\n', '\n', '            // NOTE: Doing a transfer() in the middle of a complex\n', '            // method like this is generally discouraged because of\n', '            // reentrancy attacks and DoS attacks if the seller is\n', '            // a contract with an invalid fallback function. We explicitly\n', '            // guard against reentrancy attacks by removing the auction\n', '            // before calling transfer(), and the only thing the seller\n', "            // can DoS is the sale of their own asset! (And if it's an\n", '            // accident, they can call cancelAuction(). )\n', '            seller.transfer(sellerProceeds);\n', '        }\n', '\n', '        // Calculate any excess funds included with the bid. If the excess\n', '        // is anything worth worrying about, transfer it back to bidder.\n', '        // NOTE: We checked above that the bid amount is greater than or\n', '        // equal to the price so this cannot underflow.\n', '        uint256 bidExcess = _bidAmount - price;\n', '\n', '        // Return the funds. Similar to the previous transfer, this is\n', '        // not susceptible to a re-entry attack because the auction is\n', '        // removed before any transfers occur.\n', '        msg.sender.transfer(bidExcess);\n', '\n', '        // Tell the world!\n', '        SaleSuccessful(_tokenId, price, msg.sender);\n', '\n', '        return price;\n', '    }\n', '\n', '    /// @dev Removes a sale from the list of open sales.\n', '    /// @param _tokenId - ID of NFT on sale.\n', '    function _removeSale(uint256 _tokenId) internal {\n', '        delete tokenIdToSale[_tokenId];\n', '    }\n', '\n', '    /// @dev Returns true if the NFT is on sale.\n', '    /// @param _sale - Sale to check.\n', '    function _isOnSale(Sale storage _sale) internal view returns (bool) {\n', '        return (_sale.startedAt > 0);\n', '    }\n', '\n', '\n', "    /// @dev Computes owner's cut of a sale.\n", '    /// @param _price - Sale price of NFT.\n', '    function _computeCut(uint256 _price) internal view returns (uint256) {\n', "        // NOTE: We don't use SafeMath (or similar) in this function because\n", '        //  all of our entry functions carefully cap the maximum values for\n', '        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\n', '        //  statement in the Marketplace constructor). The result of this\n', '        //  function is always guaranteed to be <= _price.\n', '        return _price * ownerCut / 10000;\n', '    }\n', '    function _computeAffiliateCut(uint256 _price,Affiliates affiliate) internal view returns (uint256) {\n', "        // NOTE: We don't use SafeMath (or similar) in this function because\n", '        //  all of our entry functions carefully cap the maximum values for\n', '        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\n', '        //  statement in the Marketplace constructor). The result of this\n', '        //  function is always guaranteed to be <= _price.\n', '        return _price * affiliate.commission / 10000;\n', '    }\n', '    /// @dev Adds an affiliate to the list.\n', '    /// @param _code The referall code of the affiliate.\n', '    /// @param _affiliate Affiliate to add.\n', '    function _addAffiliate(uint256 _code, Affiliates _affiliate) internal {\n', '        codeToAffiliate[_code] = _affiliate;\n', '   \n', '    }\n', '    \n', '    /// @dev Removes a affiliate from the list.\n', '    /// @param _code - The referall code of the affiliate.\n', '    function _removeAffiliate(uint256 _code) internal {\n', '        delete codeToAffiliate[_code];\n', '    }\n', '    \n', '    \n', '    //_bidReferral(_tokenId, msg.value);\n', '    /// @dev Computes the price and transfers winnings.\n', '    /// Does NOT transfer ownership of token.\n', '    function _bidReferral(uint256 _tokenId, uint256 _bidAmount,Affiliates _affiliate)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        \n', '        // Get a reference to the sale struct\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '\n', '        //Only Owner of Contract can sell referrals\n', '        require(sale.seller==owner);\n', '\n', '        // Explicitly check that this sale is currently live.\n', "        // (Because of how Ethereum mappings work, we can't just count\n", '        // on the lookup above failing. An invalid _tokenId will just\n', '        // return a sale object that is all zeros.)\n', '        require(_isOnSale(sale));\n', '        // Check that the bid is greater than or equal to the current price\n', '        \n', '        uint256 price = sale.price;\n', '        \n', '        //deduce the affiliate pricecut\n', '        price=price * _affiliate.pricecut / 10000;  \n', '        require(_bidAmount >= price);\n', '\n', '        // Grab a reference to the seller before the sale struct\n', '        // gets deleted.\n', '        address seller = sale.seller;\n', '        address affiliate_address = _affiliate.affiliate_address;\n', '        \n', '        // The bid is good! Remove the sale before sending the fees\n', "        // to the sender so we can't have a reentrancy attack.\n", '        _removeSale(_tokenId);\n', '\n', '        // Transfer proceeds to seller (if there are any!)\n', '        if (price > 0) {\n', "            // Calculate the Marketplace's cut.\n", '            // (NOTE: _computeCut() is guaranteed to return a\n', "            // value <= price, so this subtraction can't go negative.)\n", '            uint256 affiliateCut = _computeAffiliateCut(price,_affiliate);\n', '            uint256 sellerProceeds = price - affiliateCut;\n', '\n', '            // NOTE: Doing a transfer() in the middle of a complex\n', '            // method like this is generally discouraged because of\n', '            // reentrancy attacks and DoS attacks if the seller is\n', '            // a contract with an invalid fallback function. We explicitly\n', '            // guard against reentrancy attacks by removing the auction\n', '            // before calling transfer(), and the only thing the seller\n', "            // can DoS is the sale of their own asset! (And if it's an\n", '            // accident, they can call cancelAuction(). )\n', '            seller.transfer(sellerProceeds);\n', '            affiliate_address.transfer(affiliateCut);\n', '        }\n', '\n', '        // Calculate any excess funds included with the bid. If the excess\n', '        // is anything worth worrying about, transfer it back to bidder.\n', '        // NOTE: We checked above that the bid amount is greater than or\n', '        // equal to the price so this cannot underflow.\n', '        uint256 bidExcess = _bidAmount - price;\n', '\n', '        // Return the funds. Similar to the previous transfer, this is\n', '        // not susceptible to a re-entry attack because the auction is\n', '        // removed before any transfers occur.\n', '        msg.sender.transfer(bidExcess);\n', '\n', '        // Tell the world!\n', '        SaleSuccessful(_tokenId, price, msg.sender);\n', '\n', '        return price;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    Pause();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    Unpause();\n', '    return true;\n', '  }\n', '}\n', '\n', '/// @title MarketPlace for non-fungible tokens.\n', '/// @notice We omit a fallback function to prevent accidental sends to this contract.\n', 'contract MarketPlace is Pausable, MarketPlaceBase {\n', '\n', '\t// @dev Sanity check that allows us to ensure that we are pointing to the\n', '    //  right auction in our setSaleMarketplaceAddress() call.\n', '    bool public isMarketplace = true;\n', '\t\n', '    /// @dev The ERC-165 interface signature for ERC-721.\n', '    ///  Ref: https://github.com/ethereum/EIPs/issues/165\n', '    ///  Ref: https://github.com/ethereum/EIPs/issues/721\n', '    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\n', '\n', '    /// @dev Constructor creates a reference to the NFT ownership contract\n', '    ///  and verifies the owner cut is in the valid range.\n', '    /// @param _nftAddress - address of a deployed contract implementing\n', '    ///  the Nonfungible Interface.\n', '    /// @param _cut - percent cut the owner takes on each sale, must be\n', '    ///  between 0-10,000.\n', '    function MarketPlace(address _nftAddress, uint256 _cut) public {\n', '        require(_cut <= 10000);\n', '        ownerCut = _cut;\n', '\n', '        ERC721 candidateContract = ERC721(_nftAddress);\n', '        //require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n', '        nonFungibleContract = candidateContract;\n', '    }\n', '    function setNFTAddress(address _nftAddress, uint256 _cut) external onlyOwner {\n', '        require(_cut <= 10000);\n', '        ownerCut = _cut;\n', '        ERC721 candidateContract = ERC721(_nftAddress);\n', '        //require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n', '        nonFungibleContract = candidateContract;\n', '    }\n', "    /// @dev Remove all Ether from the contract, which is the owner's cuts\n", '    ///  as well as any Ether sent directly to the contract address.\n', '    ///  Always transfers to the NFT contract, but can be called either by\n', '    ///  the owner or the NFT contract.\n', '    function withdrawBalance() external {\n', '        address nftAddress = address(nonFungibleContract);\n', '\n', '        require(\n', '            msg.sender == owner ||\n', '            msg.sender == nftAddress\n', '        );\n', '        // We are using this boolean method to make sure that even if one fails it will still work\n', '        bool res = nftAddress.send(this.balance);\n', '    }\n', '\n', '    /// @dev Creates and begins a new sale.\n', '    /// @param _tokenId - ID of token to sale, sender must be owner.\n', '    /// @param _price - Price of item (in wei)\n', '    /// @param _seller - Seller, if not the message sender\n', '    function createSale(\n', '        uint256 _tokenId,\n', '        uint256 _price,\n', '        address _seller\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', "        // Sanity check that no inputs overflow how many bits we've allocated\n", '        // to store them in the auction struct.\n', '        require(_price == uint256(uint128(_price)));\n', '        \n', '        //require(_owns(msg.sender, _tokenId));\n', '        //_escrow(msg.sender, _tokenId);\n', '        \n', '        require(msg.sender == address(nonFungibleContract));\n', '        _escrow(_seller, _tokenId);\n', '        \n', '        Sale memory sale = Sale(\n', '            _seller,\n', '            uint128(_price),\n', '            uint64(now)\n', '        );\n', '        _addSale(_tokenId, sale);\n', '    }\n', '\n', '\n', '    \n', '\n', '    /// @dev Bids on a sale, completing the sale and transferring\n', '    ///  ownership of the NFT if enough Ether is supplied.\n', '    /// @param _tokenId - ID of token to bid on.\n', '    function bid(uint256 _tokenId)\n', '        external\n', '        payable\n', '        whenNotPaused\n', '    {\n', '        // _bid will throw if the bid or funds transfer fails\n', '       _bid(_tokenId, msg.value); \n', '       _transfer(msg.sender, _tokenId);\n', '      \n', '    }\n', '\n', '    /// @dev Bids on a sale, completing the sale and transferring\n', '    ///  ownership of the NFT if enough Ether is supplied.\n', '    /// @param _tokenId - ID of token to bid on.\n', '    function bidReferral(uint256 _tokenId,uint256 _code)\n', '        external\n', '        payable\n', '        whenNotPaused\n', '    {\n', '        // _bid will throw if the bid or funds transfer fails\n', '        Affiliates storage affiliate = codeToAffiliate[_code];\n', '        \n', '        require(affiliate.affiliate_address!=0&&_code>0);\n', '        _bidReferral(_tokenId, msg.value,affiliate);\n', '        _transfer(msg.sender, _tokenId);\n', '\n', '       \n', '    }\n', '    \n', "    /// @dev Cancels an sale that hasn't been won yet.\n", '    ///  Returns the NFT to original owner.\n', '    /// @notice This is a state-modifying function that can\n', '    ///  be called while the contract is paused.\n', '    /// @param _tokenId - ID of token on sale\n', '    function cancelSale(uint256 _tokenId)\n', '        external\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        address seller = sale.seller;\n', '        require(msg.sender == seller);\n', '        _cancelSale(_tokenId, seller);\n', '    }\n', '\n', '    /// @dev Cancels a sale when the contract is paused.\n', '    ///  Only the owner may do this, and NFTs are returned to\n', '    ///  the seller. This should only be used in emergencies.\n', '    /// @param _tokenId - ID of the NFT on sale to cancel.\n', '    function cancelSaleWhenPaused(uint256 _tokenId)\n', '        whenPaused\n', '        onlyOwner\n', '        external\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        _cancelSale(_tokenId, sale.seller);\n', '    }\n', '\n', '    /// @dev Returns sale info for an NFT on sale.\n', '    /// @param _tokenId - ID of NFT on sale.\n', '    function getSale(uint256 _tokenId)\n', '        external\n', '        view\n', '        returns\n', '    (\n', '        address seller,\n', '        uint256 price,\n', '        uint256 startedAt\n', '    ) {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        return (\n', '            sale.seller,\n', '            sale.price,\n', '            sale.startedAt\n', '        );\n', '    }\n', '\n', '    /// @dev Returns the current price of a sale.\n', '    /// @param _tokenId - ID of the token price we are checking.\n', '    function getCurrentPrice(uint256 _tokenId)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        return sale.price;\n', '    }\n', '\n', '\n', '    /// @dev Creates and begins a new sale.\n', '    /// @param _code - ID of token to sale, sender must be owner.\n', '    /// @param _commission - percentage of commission for affiliate\n', '    /// @param _pricecut - percentage of sell price cut for buyer\n', '    /// @param _affiliate_address - affiliate address \n', '    function createAffiliate(\n', '        uint256 _code,\n', '        uint64  _commission,\n', '        uint64  _pricecut,\n', '        address _affiliate_address\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '\n', '        Affiliates memory affiliate = Affiliates(\n', '            address(_affiliate_address),\n', '            uint64(_commission),\n', '            uint64(_pricecut)\n', '        );\n', '        _addAffiliate(_code, affiliate);\n', '    }\n', '    \n', '    /// @dev Returns affiliate info for an affiliate code.\n', '    /// @param _code - code for an affiliate.\n', '    function getAffiliate(uint256 _code)\n', '        external\n', '        view\n', '        onlyOwner\n', '        returns\n', '    (\n', '         address affiliate_address,\n', '         uint64 commission,\n', '         uint64 pricecut\n', '    ) {\n', '        Affiliates storage affiliate = codeToAffiliate[_code];\n', '        \n', '        return (\n', '            affiliate.affiliate_address,\n', '            affiliate.commission,\n', '            affiliate.pricecut\n', '        );\n', '    }\n', '     /// @dev Removes affiliate.\n', '    ///  Only the owner may do this\n', '    /// @param _code - code for an affiliate.\n', '    function removeAffiliate(uint256 _code)\n', '        onlyOwner\n', '        external\n', '    {\n', '        _removeAffiliate(_code); \n', '        \n', '    }\n', '}\n', '\n', '\n', '/// @title ServiceStationBase core\n', '/// @dev Contains models, variables, and internal methods for the ServiceStation.\n', 'contract ServiceStationBase {\n', '\n', '    // Reference to contract tracking NFT ownership\n', '    ERC721 public nonFungibleContract;\n', '\n', '    struct Tune{\n', '        uint256 startChange;\n', '        uint256 rangeChange;\n', '        uint256 attChange;\n', '        bool plusMinus;\n', '        bool replace;\n', '        uint128 price;\n', '        bool active;\n', '        uint64 model;\n', '    }\n', '    Tune[] options;\n', '    \n', '   \n', '    \n', '    /// @dev Returns true if the claimant owns the token.\n', '    /// @param _claimant - Address claiming to own the token.\n', '    /// @param _tokenId - ID of token whose ownership to verify.\n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n', '    }\n', '  \n', '    /// @dev Calls the NFT Contract with the tuned attributes \n', '    function _tune(uint256 _newattributes, uint256 _tokenId) internal {\n', '    nonFungibleContract.tuneLambo(_newattributes, _tokenId);\n', '    }\n', '    \n', '    function _changeAttributes(uint256 _tokenId,uint256 _optionIndex) internal {\n', '    \n', '    //Get model from token\n', '    uint64 model = nonFungibleContract.getLamboModel(_tokenId);\n', '    //throw if tune option is not made for model\n', '    require(options[_optionIndex].model==model);\n', '    \n', '    //Get original attributes\n', '    uint256 attributes = nonFungibleContract.getLamboAttributes(_tokenId);\n', '    uint256 part=0;\n', '    \n', '    //Dissect for options\n', '    part=(attributes/(10 ** options[_optionIndex].startChange)) % (10 ** options[_optionIndex].rangeChange);\n', '    //part=1544;\n', '    //Change attributes & verify\n', '    //Should attChange be added,subtracted or replaced?\n', '    if(options[_optionIndex].replace == false)\n', '        {\n', '            \n', '            //change should be added\n', '            if(options[_optionIndex].plusMinus == false)\n', '            {\n', '                //e.g. if range = 4 then value can not be higher then 9999 - overflow check\n', '                require((part+options[_optionIndex].attChange)<(10**options[_optionIndex].rangeChange));\n', '                //add to attributes\n', '                attributes=attributes+options[_optionIndex].attChange*(10 ** options[_optionIndex].startChange);\n', '            }\n', '            else{\n', '                //do some subtraction\n', '                //e.g. value must be greater then 0\n', '                require(part>options[_optionIndex].attChange);\n', '                //substract from attributes \n', '                attributes-=options[_optionIndex].attChange*(10 ** options[_optionIndex].startChange);\n', '            }\n', '        }\n', '    else\n', '        {\n', '            //do some replacing\n', '            attributes=attributes-part*(10 ** options[_optionIndex].startChange);\n', '            attributes+=options[_optionIndex].attChange*(10 ** options[_optionIndex].startChange);\n', '        }\n', '    \n', '  \n', '   \n', '    //Tune Lambo in NFT contract\n', '    _tune(uint256(attributes), _tokenId);\n', '       \n', '        \n', '    }\n', '    \n', '    \n', '}\n', '\n', '\n', '/// @title ServiceStation for non-fungible tokens.\n', 'contract ServiceStation is Pausable, ServiceStationBase {\n', '\n', '\t// @dev Sanity check that allows us to ensure that we are pointing to the right call.\n', '    bool public isServicestation = true;\n', '\t\n', '    /// @dev The ERC-165 interface signature for ERC-721.\n', '    ///  Ref: https://github.com/ethereum/EIPs/issues/165\n', '    ///  Ref: https://github.com/ethereum/EIPs/issues/721\n', '    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\n', '\n', '    uint256 public optionCount;\n', '    mapping (uint64 => uint256) public modelIndexToOptionCount;\n', '    /// @dev Constructor creates a reference to the NFT ownership contract\n', '    ///  and verifies the owner cut is in the valid range.\n', '    /// @param _nftAddress - address of a deployed contract implementing\n', '    ///  the Nonfungible Interface.\n', '    function ServiceStation(address _nftAddress) public {\n', '\n', '        ERC721 candidateContract = ERC721(_nftAddress);\n', '        //require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n', '        nonFungibleContract = candidateContract;\n', '        _newTuneOption(0,0,0,false,false,0,0);\n', '        \n', '    }\n', '    function setNFTAddress(address _nftAddress) external onlyOwner {\n', '        \n', '        ERC721 candidateContract = ERC721(_nftAddress);\n', '        //require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n', '        nonFungibleContract = candidateContract;\n', '    }\n', '    \n', '    function newTuneOption(\n', '        uint32 _startChange,\n', '        uint32 _rangeChange,\n', '        uint256 _attChange,\n', '        bool _plusMinus,\n', '        bool _replace,\n', '        uint128 _price,\n', '        uint64 _model\n', '        )\n', '        external\n', '        {\n', '           //Only allow owner to add new options\n', '           require(msg.sender == owner ); \n', '           optionCount++;\n', '           modelIndexToOptionCount[_model]++;\n', '           _newTuneOption(_startChange,_rangeChange,_attChange,_plusMinus, _replace,_price,_model);\n', '       \n', '        }\n', '    function changeTuneOption(\n', '        uint32 _startChange,\n', '        uint32 _rangeChange,\n', '        uint256 _attChange,\n', '        bool _plusMinus,\n', '        bool _replace,\n', '        uint128 _price,\n', '        bool _isactive,\n', '        uint64 _model,\n', '        uint256 _optionIndex\n', '        )\n', '        external\n', '        {\n', '           //Only allow owner to add new options\n', '           require(msg.sender == owner ); \n', '           \n', '           \n', '           _changeTuneOption(_startChange,_rangeChange,_attChange,_plusMinus, _replace,_price,_isactive,_model,_optionIndex);\n', '       \n', '        }\n', '        \n', '    function _newTuneOption( uint32 _startChange,\n', '        uint32 _rangeChange,\n', '        uint256 _attChange,\n', '        bool _plusMinus,\n', '        bool _replace,\n', '        uint128 _price,\n', '        uint64 _model\n', '        ) \n', '        internal\n', '        {\n', '        \n', '           Tune memory _option = Tune({\n', '            startChange: _startChange,\n', '            rangeChange: _rangeChange,\n', '            attChange: _attChange,\n', '            plusMinus: _plusMinus,\n', '            replace: _replace,\n', '            price: _price,\n', '            active: true,\n', '            model: _model\n', '            });\n', '        \n', '        options.push(_option);\n', '    }\n', '    \n', '    function _changeTuneOption( uint32 _startChange,\n', '        uint32 _rangeChange,\n', '        uint256 _attChange,\n', '        bool _plusMinus,\n', '        bool _replace,\n', '        uint128 _price,\n', '        bool _isactive,\n', '        uint64 _model,\n', '        uint256 _optionIndex\n', '        ) \n', '        internal\n', '        {\n', '        \n', '           Tune memory _option = Tune({\n', '            startChange: _startChange,\n', '            rangeChange: _rangeChange,\n', '            attChange: _attChange,\n', '            plusMinus: _plusMinus,\n', '            replace: _replace,\n', '            price: _price,\n', '            active: _isactive,\n', '            model: _model\n', '            });\n', '        \n', '        options[_optionIndex]=_option;\n', '    }\n', '    \n', '    function disableTuneOption(uint256 index) external\n', '    {\n', '        require(msg.sender == owner ); \n', '        options[index].active=false;\n', '    }\n', '    \n', '    function enableTuneOption(uint256 index) external\n', '    {\n', '        require(msg.sender == owner ); \n', '        options[index].active=true;\n', '    }\n', '    function getOption(uint256 _index) \n', '    external view\n', '    returns (\n', '        uint256 _startChange,\n', '        uint256 _rangeChange,\n', '        uint256 _attChange,\n', '        bool _plusMinus,\n', '        uint128 _price,\n', '        bool active,\n', '        uint64 model\n', '    ) \n', '    {\n', '      \n', '        //require(options[_index].active);\n', '        return (\n', '            options[_index].startChange,\n', '            options[_index].rangeChange,\n', '            options[_index].attChange,\n', '            options[_index].plusMinus,\n', '            options[_index].price,\n', '            options[_index].active,\n', '            options[_index].model\n', '        );  \n', '    }\n', '    \n', '    function getOptionCount() external view returns (uint256 _optionCount)\n', '        {\n', '        return optionCount;    \n', '        }\n', '    \n', '    function tuneLambo(uint256 _tokenId,uint256 _optionIndex) external payable\n', '    {\n', '       //Caller needs to own Lambo\n', '       require(_owns(msg.sender, _tokenId)); \n', '       //Tuning Option needs to be enabled\n', '       require(options[_optionIndex].active);\n', '       //Enough money for tuning to spend?\n', '       require(msg.value>=options[_optionIndex].price);\n', '       \n', '       _changeAttributes(_tokenId,_optionIndex);\n', '    }\n', "    /// @dev Remove all Ether from the contract, which is the owner's cuts\n", '    ///  as well as any Ether sent directly to the contract address.\n', '    ///  Always transfers to the NFT contract, but can be called either by\n', '    ///  the owner or the NFT contract.\n', '    function withdrawBalance() external {\n', '        address nftAddress = address(nonFungibleContract);\n', '\n', '        require(\n', '            msg.sender == owner ||\n', '            msg.sender == nftAddress\n', '        );\n', '        // We are using this boolean method to make sure that even if one fails it will still work\n', '        bool res = owner.send(this.balance);\n', '    }\n', '\n', '    function getOptionsForModel(uint64 _model) external view returns(uint256[] _optionsModel) {\n', '        //uint256 tokenCount = balanceOf(_owner);\n', '\n', '        //if (tokenCount == 0) {\n', '            // Return an empty array\n', '        //    return new uint256[](0);\n', '        //} else {\n', '            uint256[] memory result = new uint256[](modelIndexToOptionCount[_model]);\n', '            //uint256 totalCars = totalSupply();\n', '            uint256 resultIndex = 0;\n', '\n', '            // We count on the fact that all cars have IDs starting at 0 and increasing\n', '            // sequentially up to the optionCount count.\n', '            uint256 optionId;\n', '\n', '            for (optionId = 1; optionId <= optionCount; optionId++) {\n', '                if (options[optionId].model == _model && options[optionId].active == true) {\n', '                    result[resultIndex] = optionId;\n', '                    resultIndex++;\n', '                }\n', '            }\n', '\n', '            return result;\n', '       // }\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '////No SiringClockAuction needed for Lambos\n', '////No separate modification for SaleContract needed\n', '\n', '/// @title Handles creating sales for sale of lambos.\n', '///  This wrapper of ReverseSale exists only so that users can create\n', '///  sales with only one transaction.\n', 'contract EtherLambosSale is EtherLambosOwnership {\n', '\n', '    // @notice The sale contract variables are defined in EtherLambosBase to allow\n', '    //  us to refer to them in EtherLambosOwnership to prevent accidental transfers.\n', '    // `saleMarketplace` refers to the auction for p2p sale of cars.\n', '   \n', '\n', '    /// @dev Sets the reference to the sale auction.\n', '    /// @param _address - Address of sale contract.\n', '    function setMarketplaceAddress(address _address) external onlyCEO {\n', '        MarketPlace candidateContract = MarketPlace(_address);\n', '\n', '        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n', '        require(candidateContract.isMarketplace());\n', '\n', '        // Set the new contract address\n', '        marketPlace = candidateContract;\n', '    }\n', '\n', '\n', '    /// @dev Put a lambo up for sale.\n', '    ///  Does some ownership trickery to create auctions in one tx.\n', '    function createLamboSale(\n', '        uint256 _carId,\n', '        uint256 _price\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        // Sale contract checks input sizes\n', '        // If lambo is already on any sale, this will throw\n', '        // because it will be owned by the sale contract.\n', '        require(_owns(msg.sender, _carId));\n', '        \n', '        _approve(_carId, marketPlace);\n', '        // Sale throws if inputs are invalid and clears\n', '        // transfer after escrowing the lambo.\n', '        marketPlace.createSale(\n', '            _carId,\n', '            _price,\n', '            msg.sender\n', '        );\n', '    }\n', '    \n', '    \n', '    function bulkCreateLamboSale(\n', '        uint256 _price,\n', '        uint256 _tokenIdStart,\n', '        uint256 _tokenCount\n', '    )\n', '        external\n', '        onlyCOO\n', '    {\n', '        // Sale contract checks input sizes\n', '        // If lambo is already on any sale, this will throw\n', '        // because it will be owned by the sale contract.\n', '        for(uint256 i=0;i<_tokenCount;i++)\n', '            {\n', '            require(_owns(msg.sender, _tokenIdStart+i));\n', '        \n', '            _approve(_tokenIdStart+i, marketPlace);\n', '            // Sale throws if inputs are invalid and clears\n', '            // transfer after escrowing the lambo.\n', '            marketPlace.createSale(\n', '                _tokenIdStart+i,\n', '                _price,\n', '             msg.sender\n', '            );\n', '        }\n', '    }\n', '    /// @dev Transfers the balance of the marketPlace contract\n', '    /// to the EtherLambosCore contract. We use two-step withdrawal to\n', '    /// prevent two transfer calls in the auction bid function.\n', '    function withdrawSaleBalances() external onlyCLevel {\n', '        marketPlace.withdrawBalance();\n', '        \n', '    }\n', '}\n', '\n', '/// @title all functions related to creating lambos\n', 'contract EtherLambosBuilding is EtherLambosSale {\n', '\n', '    // Limits the number of cars the contract owner can ever create.\n', '    //uint256 public constant PROMO_CREATION_LIMIT = 5000;\n', '    //uint256 public constant GEN0_CREATION_LIMIT = 45000;\n', '\n', '\n', '    // Counts the number of cars the contract owner has created.\n', '    uint256 public lambosBuildCount;\n', '\n', '\n', '    /// @dev we can build lambos. Only callable by COO\n', '    /// @param _attributes the encoded attributes of the lambo to be created, any value is accepted\n', '    /// @param _owner the future owner of the created lambo. Default to contract COO\n', '    /// @param _model the model of the created lambo. \n', '    function createLambo(uint256 _attributes, address _owner, uint64 _model) external onlyCOO {\n', '        address lamboOwner = _owner;\n', '        if (lamboOwner == address(0)) {\n', '             lamboOwner = cooAddress;\n', '        }\n', '        //require(promoCreatedCount < PROMO_CREATION_LIMIT);\n', '\n', '        lambosBuildCount++;\n', '        _createLambo(_attributes, lamboOwner, _model);\n', '    }\n', '\n', '    function bulkCreateLambo(uint256 _attributes, address _owner, uint64 _model,uint256 count, uint256 startNo) external onlyCOO {\n', '        address lamboOwner = _owner;\n', '        uint256 att=_attributes;\n', '        if (lamboOwner == address(0)) {\n', '             lamboOwner = cooAddress;\n', '        }\n', '        \n', '        //do some replacing\n', '            //_attributes=_attributes-part*(10 ** 66);\n', '        \n', '        \n', '        //require(promoCreatedCount < PROMO_CREATION_LIMIT);\n', '        for(uint256 i=0;i<count;i++)\n', '            {\n', '            lambosBuildCount++;\n', '            att=_attributes+(startNo+i)*(10 ** 66);\n', '            _createLambo(att, lamboOwner, _model);\n', '            }\n', '    }\n', '}\n', '\n', '/// @title all functions related to tuning lambos\n', 'contract EtherLambosTuning is EtherLambosBuilding {\n', '\n', '    // Counts the number of tunings have been done.\n', '    uint256 public lambosTuneCount;\n', '\n', '    function setServicestationAddress(address _address) external onlyCEO {\n', '        ServiceStation candidateContract = ServiceStation(_address);\n', '\n', '        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n', '        require(candidateContract.isServicestation());\n', '\n', '        // Set the new contract address\n', '        serviceStation = candidateContract;\n', '    }\n', '    /// @dev we can tune lambos. Only callable by ServiceStation contract\n', '    /// @param _newattributes the new encoded attributes of the lambo to be updated\n', '    /// @param _tokenId the lambo to be tuned.\n', '    function tuneLambo(uint256 _newattributes, uint256 _tokenId) external {\n', '        \n', '        //Tuning can only be done by the ServiceStation Contract. \n', '        require(\n', '            msg.sender == address(serviceStation)\n', '        );\n', '        \n', '        \n', '        lambosTuneCount++;\n', '        _tuneLambo(_newattributes, _tokenId);\n', '    }\n', '    function withdrawTuneBalances() external onlyCLevel {\n', '        serviceStation.withdrawBalance();\n', '        \n', '    }\n', '\n', '}\n', '\n', '/// @title EtherLambos: Collectible, tuneable, and super stylish lambos on the Ethereum blockchain.\n', '/// @author Cryptoknights code adapted from Axiom Zen (https://www.axiomzen.co)\n', '/// @dev The main EtherLambos contract, keeps track of lambos.\n', 'contract EtherLambosCore is EtherLambosTuning {\n', '\n', '    // This is the main EtherLambos contract. In order to keep our code seperated into logical sections,\n', "    // we've broken it up in two ways. First, we have several seperately-instantiated sibling contracts\n", '    // that handle sales. The sales are\n', "    // seperate since their logic is somewhat complex and there's always a risk of subtle bugs. By keeping\n", '    // them in their own contracts, we can upgrade them without disrupting the main contract that tracks\n', '    // lambo ownership. \n', '    //\n', '    // Secondly, we break the core contract into multiple files using inheritence, one for each major\n', '    // facet of functionality of EtherLambos. This allows us to keep related code bundled together while still\n', '    // avoiding a single giant file with everything in it. The breakdown is as follows:\n', '    //\n', '    //      - EtherLambosBase: This is where we define the most fundamental code shared throughout the core\n', '    //             functionality. This includes our main data storage, constants and data types, plus\n', '    //             internal functions for managing these items.\n', '    //\n', '    //      - EtherLambosAccessControl: This contract manages the various addresses and constraints for operations\n', '    //             that can be executed only by specific roles. Namely CEO, CFO and COO.\n', '    //\n', '    //      - EtherLambosOwnership: This provides the methods required for basic non-fungible token\n', '    //             transactions, following the draft ERC-721 spec (https://github.com/ethereum/EIPs/issues/721).\n', '    //\n', '    //      - EtherLambosSale: Here we have the public methods for sales. \n', '    //\n', '    //      - EtherLambosBuilding: This final facet contains the functionality we use for creating new cars.\n', '    //             \n', '\n', '    // Set in case the core contract is broken and an upgrade is required\n', '    address public newContractAddress;\n', '\n', '    /// @notice Creates the main EtherLambos smart contract instance.\n', '    function EtherLambosCore() public {\n', '        // Starts paused.\n', '        paused = true;\n', '\n', '        // the creator of the contract is the initial CEO\n', '        ceoAddress = msg.sender;\n', '\n', '        // the creator of the contract is also the initial COO\n', '        cooAddress = msg.sender;\n', '\n', '        // start with the car 0 \n', '        _createLambo(uint256(-1), address(0),0);\n', '    }\n', '\n', '    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\n', '    ///  breaking bug. This method does nothing but keep track of the new contract and\n', "    ///  emit a message indicating that the new address is set. It's up to clients of this\n", '    ///  contract to update to the new contract address in that case. (This contract will\n', '    ///  be paused indefinitely if such an upgrade takes place.)\n', '    /// @param _v2Address new address\n', '    function setNewAddress(address _v2Address) external onlyCEO whenPaused {\n', '        // See README.md for updgrade plan\n', '        newContractAddress = _v2Address;\n', '        ContractUpgrade(_v2Address);\n', '    }\n', '\n', '    /// @notice No tipping!\n', "    /// @dev Reject all Ether from being sent here, unless it's from the marketPlace contract.\n", '    /// (Hopefully, we can prevent user accidents.)\n', '    function() external payable {\n', '        require(\n', '            msg.sender == address(marketPlace)\n', '        );\n', '    }\n', '\n', '    /// @notice Returns all the relevant information about a specific lambo.\n', '    /// @param _id The ID of the lambo of interest.\n', '    function getLambo(uint256 _id)\n', '        external\n', '        view\n', '        returns (\n', '        uint256 buildTime,\n', '        uint256 attributes\n', '    ) {\n', '        Lambo storage kit = lambos[_id];\n', '\n', '        buildTime = uint256(kit.buildTime);\n', '        attributes = kit.attributes;\n', '    }\n', '    /// @notice Returns all the relevant information about a specific lambo.\n', '    /// @param _id The ID of the lambo of interest.\n', '    function getLamboAttributes(uint256 _id)\n', '        external\n', '        view\n', '        returns (\n', '        uint256 attributes\n', '    ) {\n', '        Lambo storage kit = lambos[_id];\n', '        attributes = kit.attributes;\n', '        return attributes;\n', '    }\n', '    \n', '    /// @notice Returns all the relevant information about a specific lambo.\n', '    /// @param _id The ID of the lambo of interest.\n', '    function getLamboModel(uint256 _id)\n', '        external\n', '        view\n', '        returns (\n', '        uint64 model\n', '    ) {\n', '        Lambo storage kit = lambos[_id];\n', '        model = kit.model;\n', '        return model;\n', '    }\n', '    /// @dev Override unpause so it requires all external contract addresses\n', "    ///  to be set before contract can be unpaused. Also, we can't have\n", '    ///  newContractAddress set either, because then the contract was upgraded.\n', '    /// @notice This is public rather than external so we can call super.unpause\n', '    ///  without using an expensive CALL.\n', '    function unpause() public onlyCEO whenPaused {\n', '        require(marketPlace != address(0));\n', '        require(serviceStation != address(0));\n', '        require(newContractAddress == address(0));\n', '\n', '        // Actually unpause the contract.\n', '        super.unpause();\n', '    }\n', '\n', '    // @dev Allows the CFO to capture the balance available to the contract.\n', '    function withdrawBalance() external onlyCFO {\n', '        uint256 balance = this.balance;\n', '        cfoAddress.send(balance);\n', '     \n', '    }\n', '}']
