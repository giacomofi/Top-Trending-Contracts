['pragma solidity ^0.4.24;\n', '\n', '/*\n', '* This contract implements the ERC721 standard and provides services for DigiRights platform \n', '*/\n', 'interface ERC721 {\n', '    \n', '    /*\n', '    * Mandatory functions of ERC721 standard\n', '    */\n', '    function totalSupply() external view returns (uint256 total);\n', '    function balanceOf(bytes32 _owner) external view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) external view returns (bytes32 owner);\n', '    function approve(bytes32 _from,bytes32 _to, uint256 _tokenId) external;\n', '    function transferFrom(bytes32 _from, bytes32 _to, uint256 _tokenId) external;\n', '\n', '        \n', '    /*\n', '    * Events \n', '    */\n', '    event Transfer(bytes32 from, bytes32 to, uint256 tokenId);\n', '    event Approval(bytes32 owner, bytes32 approved, uint256 tokenId);\n', '\n', '    // ERC-165 Compatibility\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '}\n', '\n', 'contract DigiRights is ERC721 {\n', '\n', '    string private NAME = "Ionixx DigiRights";\n', '    string private SYMBOL = "INX DIGI";\n', '\n', '    bytes4 constant InterfaceID_ERC165 =\n', '    bytes4(keccak256("supportsInterface(bytes4)"));\n', '\n', '    bytes4 constant InterfaceID_ERC721 =\n', '    bytes4(keccak256("name()")) ^\n', '    bytes4(keccak256("symbol()")) ^\n', '    bytes4(keccak256("totalSupply()")) ^\n', '    bytes4(keccak256("balanceOf(bytes32)")) ^\n', '    bytes4(keccak256("ownerOf(uint256)")) ^\n', '    bytes4(keccak256("approve(bytes32,uint256)")) ^\n', '    bytes4(keccak256("transfer(bytes32,uint256)")) ^\n', '    bytes4(keccak256("transferFrom(bytes32,bytes32,uint256)")) ^\n', '    bytes4(keccak256("tokensOfOwner(bytes32)"));\n', '\n', '    /*  @desc Metadata of the token implemented as a structure\n', '        @attributes owner: Creator of the Token\n', '        @attributes name: Name of the file\n', '        @attributes descripton: descripton of the file\n', '        @attributes file_hash: hash of the file\n', '    */\n', '    struct Token {\n', '        bytes32 owner;\n', '        string name;\n', '        string description;\n', '        string file_hash;\n', '        uint256 token_id;\n', '        uint256 timestamp;\n', '        string file_type;\n', '        string extension;\n', '    }\n', '\n', '    Token[] tokens;\n', '\n', '    mapping (uint256 => bytes32) public ownerOf;\n', '    mapping (bytes32 => uint256) ownerTokenCount;\n', '    mapping (uint256 => bytes32) public tokenIndexToApproved;   \n', '    mapping(string => bool) filehash;\n', '    \n', '    event Created(bytes32 owner, uint256 tokenId);\n', '    \n', '    \n', ' \n', '    /*  @desc provides the name of the token\n', '        @return string: name of the token\n', '    */\n', '    function name() external view returns (string) {\n', '        return NAME;\n', '    }\n', '    \n', '    /*  @desc provides the symbol of the token\n', '        @return string: symbol of the token\n', '    */\n', '    function symbol() external view returns (string) {\n', '        return SYMBOL;\n', '    }\n', '    \n', '    /*  @desc provides the total supply limit of the token\n', '        @return uint256: total supply\n', '    */\n', '    function totalSupply() external view returns (uint256) {\n', '        return tokens.length;\n', '    }\n', '    \n', '    /*  @desc provides the total number of tokens owned by the user\n', '        @param _owner: owner hash\n', '        @return uint256: number of tokens\n', '    */\n', '    function balanceOf(bytes32 _owner) external view returns (uint256) {\n', '        return ownerTokenCount[_owner];\n', '    }\n', '    \n', '    /*  @desc provides the owner of the given token\n', '        @param _tokenId: token ID\n', '        @return uint256: number of tokens\n', '    */\n', '    function ownerOf(uint256 _tokenId) external view returns (bytes32 owner) {\n', '        owner = ownerOf[_tokenId];\n', '    }\n', '    \n', '    /*  @desc approves a user to use his/her token\n', '        @param _from: from hash\n', '        @param _to: to hash\n', '        @param _tokenId: token ID\n', '    */\n', '    function approve(bytes32 _from,bytes32 _to, uint256 _tokenId) external {\n', '        require(_owns(_from, _tokenId));\n', '\n', '        tokenIndexToApproved[_tokenId] = _to;\n', '        emit Approval(ownerOf[_tokenId], tokenIndexToApproved[_tokenId], _tokenId);\n', '    }\n', '    \n', '    /*  @desc transfers token from one hash to another hash when they have approval\n', '        @param _from: from hash\n', '        @param _to: to hash\n', '        @param _tokenId: token ID\n', '    */\n', '    function transferFrom(bytes32 _from, bytes32 _to, uint256 _tokenId) external {\n', '        require(_to.length != 0 );\n', '        require(_to != _from);\n', '        require(_owns(_from, _tokenId));\n', '\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /*  @desc provides the tokens owned by an user\n', '        @param _owner: owner hash\n', '        @param tokenIds: token ID as array\n', '    */\n', '    function tokensOfOwner(bytes32 _owner) external view returns (uint256[]) {\n', '        uint256 balance = this.balanceOf(_owner);\n', '\n', '        if (balance == 0) {\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](balance);\n', '            uint256 maxTokenId = this.totalSupply();\n', '            uint256 idx = 0;\n', '\n', '            uint256 tokenId;\n', '            for (tokenId = 0; tokenId <= maxTokenId; tokenId++) {\n', '                if (ownerOf[tokenId] == _owner) {\n', '                    result[idx] = tokenId;\n', '                    idx++;\n', '                }\n', '            }\n', '            return result;\n', '        }\n', '\n', '    }\n', '    \n', '    /*  @desc obtains ther token details\n', '        @param _owner: owner hash \n', '        @param _tokenId: token ID \n', '        @return owner: owner hash\n', '        @return name: file name\n', '        @return description: file description\n', '        @return hash: file hash\n', '    */\n', '    function getToken(bytes32 _owner,uint256 _tokenId) external view returns (bytes32 owner,string token_name,string description,string file_hash,\n', '        uint256 token_id,\n', '        uint256 timestamp,\n', '        string file_type,string extension) {\n', '        require(_owns(_owner,_tokenId) == true);\n', '        uint256 length = this.totalSupply();\n', '        require(_tokenId < length);\n', '        Token memory token = tokens[_tokenId];\n', '        owner = token.owner;\n', '        token_name = token.name;\n', '        description = token.description;\n', '        file_hash = token.file_hash;\n', '        token_id = token.token_id;\n', '        timestamp = token.timestamp;\n', '        file_type=token.file_type;\n', '        extension=token.extension;\n', '    }\n', '\n', '    /*  @desc checks if the contract supports interface\n', '        @param _interfaceID: interface ID \n', '        @return bool: flag if the interface is implemented or not\n', '    */\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n', '        return ((_interfaceID == InterfaceID_ERC165) || (_interfaceID == InterfaceID_ERC721));\n', '    }\n', '    \n', '    /*  @desc creates a new token and assigns it to the user\n', '        @param _from: from hash\n', '        @param name: file name\n', '        @param description: file description\n', '        @param hash: file hash\n', '    */\n', '    function createToken(bytes32 _from,string token_name,string description,string file_hash,string file_type , string extension) public {\n', '        require(_from.length != 0 );\n', '        require(filehash[file_hash] == false);\n', '        filehash[file_hash] = true;\n', '        mint(_from,token_name,description,file_hash ,file_type,extension);\n', '        \n', '    }\n', '    \n', '    /*\n', '    * Internal functions\n', '    */\n', '    function _owns(bytes32 _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return ownerOf[_tokenId] == _claimant;\n', '    }\n', '\n', '    function _approvedFor(bytes32 _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return tokenIndexToApproved[_tokenId] == _claimant;\n', '    }\n', '\n', '    function _transfer(bytes32 _from, bytes32 _to, uint256 _tokenId) internal {\n', '        \n', '        ownerTokenCount[_to]++;\n', '        ownerOf[_tokenId] = _to;\n', '\n', '        if (_from.length != 0 ) {\n', '            ownerTokenCount[_from]--;\n', '            delete tokenIndexToApproved[_tokenId];\n', '        }\n', '\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '    \n', '    function mint(bytes32 owner,string token_name,string description,string hash,string file_type, string extension) internal {\n', '        Token memory token = Token({\n', '            owner:owner,\n', '            name:token_name,\n', '            description:description,\n', '            file_hash:hash,\n', '            file_type: file_type,\n', '            extension: extension,\n', '            token_id: this.totalSupply(),\n', '            timestamp:block.timestamp\n', '        });\n', '        uint256 tokenId =tokens.push(token) - 1;\n', '        emit Created(owner, tokenId);\n', '        _transfer(0, owner, tokenId);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/*\n', '* This contract implements the ERC721 standard and provides services for DigiRights platform \n', '*/\n', 'interface ERC721 {\n', '    \n', '    /*\n', '    * Mandatory functions of ERC721 standard\n', '    */\n', '    function totalSupply() external view returns (uint256 total);\n', '    function balanceOf(bytes32 _owner) external view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) external view returns (bytes32 owner);\n', '    function approve(bytes32 _from,bytes32 _to, uint256 _tokenId) external;\n', '    function transferFrom(bytes32 _from, bytes32 _to, uint256 _tokenId) external;\n', '\n', '        \n', '    /*\n', '    * Events \n', '    */\n', '    event Transfer(bytes32 from, bytes32 to, uint256 tokenId);\n', '    event Approval(bytes32 owner, bytes32 approved, uint256 tokenId);\n', '\n', '    // ERC-165 Compatibility\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '}\n', '\n', 'contract DigiRights is ERC721 {\n', '\n', '    string private NAME = "Ionixx DigiRights";\n', '    string private SYMBOL = "INX DIGI";\n', '\n', '    bytes4 constant InterfaceID_ERC165 =\n', '    bytes4(keccak256("supportsInterface(bytes4)"));\n', '\n', '    bytes4 constant InterfaceID_ERC721 =\n', '    bytes4(keccak256("name()")) ^\n', '    bytes4(keccak256("symbol()")) ^\n', '    bytes4(keccak256("totalSupply()")) ^\n', '    bytes4(keccak256("balanceOf(bytes32)")) ^\n', '    bytes4(keccak256("ownerOf(uint256)")) ^\n', '    bytes4(keccak256("approve(bytes32,uint256)")) ^\n', '    bytes4(keccak256("transfer(bytes32,uint256)")) ^\n', '    bytes4(keccak256("transferFrom(bytes32,bytes32,uint256)")) ^\n', '    bytes4(keccak256("tokensOfOwner(bytes32)"));\n', '\n', '    /*  @desc Metadata of the token implemented as a structure\n', '        @attributes owner: Creator of the Token\n', '        @attributes name: Name of the file\n', '        @attributes descripton: descripton of the file\n', '        @attributes file_hash: hash of the file\n', '    */\n', '    struct Token {\n', '        bytes32 owner;\n', '        string name;\n', '        string description;\n', '        string file_hash;\n', '        uint256 token_id;\n', '        uint256 timestamp;\n', '        string file_type;\n', '        string extension;\n', '    }\n', '\n', '    Token[] tokens;\n', '\n', '    mapping (uint256 => bytes32) public ownerOf;\n', '    mapping (bytes32 => uint256) ownerTokenCount;\n', '    mapping (uint256 => bytes32) public tokenIndexToApproved;   \n', '    mapping(string => bool) filehash;\n', '    \n', '    event Created(bytes32 owner, uint256 tokenId);\n', '    \n', '    \n', ' \n', '    /*  @desc provides the name of the token\n', '        @return string: name of the token\n', '    */\n', '    function name() external view returns (string) {\n', '        return NAME;\n', '    }\n', '    \n', '    /*  @desc provides the symbol of the token\n', '        @return string: symbol of the token\n', '    */\n', '    function symbol() external view returns (string) {\n', '        return SYMBOL;\n', '    }\n', '    \n', '    /*  @desc provides the total supply limit of the token\n', '        @return uint256: total supply\n', '    */\n', '    function totalSupply() external view returns (uint256) {\n', '        return tokens.length;\n', '    }\n', '    \n', '    /*  @desc provides the total number of tokens owned by the user\n', '        @param _owner: owner hash\n', '        @return uint256: number of tokens\n', '    */\n', '    function balanceOf(bytes32 _owner) external view returns (uint256) {\n', '        return ownerTokenCount[_owner];\n', '    }\n', '    \n', '    /*  @desc provides the owner of the given token\n', '        @param _tokenId: token ID\n', '        @return uint256: number of tokens\n', '    */\n', '    function ownerOf(uint256 _tokenId) external view returns (bytes32 owner) {\n', '        owner = ownerOf[_tokenId];\n', '    }\n', '    \n', '    /*  @desc approves a user to use his/her token\n', '        @param _from: from hash\n', '        @param _to: to hash\n', '        @param _tokenId: token ID\n', '    */\n', '    function approve(bytes32 _from,bytes32 _to, uint256 _tokenId) external {\n', '        require(_owns(_from, _tokenId));\n', '\n', '        tokenIndexToApproved[_tokenId] = _to;\n', '        emit Approval(ownerOf[_tokenId], tokenIndexToApproved[_tokenId], _tokenId);\n', '    }\n', '    \n', '    /*  @desc transfers token from one hash to another hash when they have approval\n', '        @param _from: from hash\n', '        @param _to: to hash\n', '        @param _tokenId: token ID\n', '    */\n', '    function transferFrom(bytes32 _from, bytes32 _to, uint256 _tokenId) external {\n', '        require(_to.length != 0 );\n', '        require(_to != _from);\n', '        require(_owns(_from, _tokenId));\n', '\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /*  @desc provides the tokens owned by an user\n', '        @param _owner: owner hash\n', '        @param tokenIds: token ID as array\n', '    */\n', '    function tokensOfOwner(bytes32 _owner) external view returns (uint256[]) {\n', '        uint256 balance = this.balanceOf(_owner);\n', '\n', '        if (balance == 0) {\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](balance);\n', '            uint256 maxTokenId = this.totalSupply();\n', '            uint256 idx = 0;\n', '\n', '            uint256 tokenId;\n', '            for (tokenId = 0; tokenId <= maxTokenId; tokenId++) {\n', '                if (ownerOf[tokenId] == _owner) {\n', '                    result[idx] = tokenId;\n', '                    idx++;\n', '                }\n', '            }\n', '            return result;\n', '        }\n', '\n', '    }\n', '    \n', '    /*  @desc obtains ther token details\n', '        @param _owner: owner hash \n', '        @param _tokenId: token ID \n', '        @return owner: owner hash\n', '        @return name: file name\n', '        @return description: file description\n', '        @return hash: file hash\n', '    */\n', '    function getToken(bytes32 _owner,uint256 _tokenId) external view returns (bytes32 owner,string token_name,string description,string file_hash,\n', '        uint256 token_id,\n', '        uint256 timestamp,\n', '        string file_type,string extension) {\n', '        require(_owns(_owner,_tokenId) == true);\n', '        uint256 length = this.totalSupply();\n', '        require(_tokenId < length);\n', '        Token memory token = tokens[_tokenId];\n', '        owner = token.owner;\n', '        token_name = token.name;\n', '        description = token.description;\n', '        file_hash = token.file_hash;\n', '        token_id = token.token_id;\n', '        timestamp = token.timestamp;\n', '        file_type=token.file_type;\n', '        extension=token.extension;\n', '    }\n', '\n', '    /*  @desc checks if the contract supports interface\n', '        @param _interfaceID: interface ID \n', '        @return bool: flag if the interface is implemented or not\n', '    */\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n', '        return ((_interfaceID == InterfaceID_ERC165) || (_interfaceID == InterfaceID_ERC721));\n', '    }\n', '    \n', '    /*  @desc creates a new token and assigns it to the user\n', '        @param _from: from hash\n', '        @param name: file name\n', '        @param description: file description\n', '        @param hash: file hash\n', '    */\n', '    function createToken(bytes32 _from,string token_name,string description,string file_hash,string file_type , string extension) public {\n', '        require(_from.length != 0 );\n', '        require(filehash[file_hash] == false);\n', '        filehash[file_hash] = true;\n', '        mint(_from,token_name,description,file_hash ,file_type,extension);\n', '        \n', '    }\n', '    \n', '    /*\n', '    * Internal functions\n', '    */\n', '    function _owns(bytes32 _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return ownerOf[_tokenId] == _claimant;\n', '    }\n', '\n', '    function _approvedFor(bytes32 _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return tokenIndexToApproved[_tokenId] == _claimant;\n', '    }\n', '\n', '    function _transfer(bytes32 _from, bytes32 _to, uint256 _tokenId) internal {\n', '        \n', '        ownerTokenCount[_to]++;\n', '        ownerOf[_tokenId] = _to;\n', '\n', '        if (_from.length != 0 ) {\n', '            ownerTokenCount[_from]--;\n', '            delete tokenIndexToApproved[_tokenId];\n', '        }\n', '\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '    \n', '    function mint(bytes32 owner,string token_name,string description,string hash,string file_type, string extension) internal {\n', '        Token memory token = Token({\n', '            owner:owner,\n', '            name:token_name,\n', '            description:description,\n', '            file_hash:hash,\n', '            file_type: file_type,\n', '            extension: extension,\n', '            token_id: this.totalSupply(),\n', '            timestamp:block.timestamp\n', '        });\n', '        uint256 tokenId =tokens.push(token) - 1;\n', '        emit Created(owner, tokenId);\n', '        _transfer(0, owner, tokenId);\n', '    }\n', '}']
