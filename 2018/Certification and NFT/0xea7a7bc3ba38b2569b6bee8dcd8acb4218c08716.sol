['pragma solidity ^0.4.23;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender; \n', '    }\n', '\n', '    /**\n', '        @dev Transfers the ownership of the contract.\n', '\n', '        @param _owner Address of the new owner\n', '    */\n', '    function setOwner(address _owner) public onlyOwner returns (bool) {\n', '        require(_owner != address(0));\n', '        owner = _owner;\n', '        return true;\n', '    } \n', '}\n', '\n', '\n', 'contract HasWorkers is Ownable {\n', '    mapping(address => uint256) private workerToIndex;    \n', '    address[] private workers;\n', '\n', '    event AddedWorker(address _worker);\n', '    event RemovedWorker(address _worker);\n', '\n', '    constructor() public {\n', '        workers.length++;\n', '    }\n', '\n', '    modifier onlyWorker() {\n', '        require(isWorker(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier workerOrOwner() {\n', '        require(isWorker(msg.sender) || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function isWorker(address _worker) public view returns (bool) {\n', '        return workerToIndex[_worker] != 0;\n', '    }\n', '\n', '    function allWorkers() public view returns (address[] memory result) {\n', '        result = new address[](workers.length - 1);\n', '        for (uint256 i = 1; i < workers.length; i++) {\n', '            result[i - 1] = workers[i];\n', '        }\n', '    }\n', '\n', '    function addWorker(address _worker) public onlyOwner returns (bool) {\n', '        require(!isWorker(_worker));\n', '        uint256 index = workers.push(_worker) - 1;\n', '        workerToIndex[_worker] = index;\n', '        emit AddedWorker(_worker);\n', '        return true;\n', '    }\n', '\n', '    function removeWorker(address _worker) public onlyOwner returns (bool) {\n', '        require(isWorker(_worker));\n', '        uint256 index = workerToIndex[_worker];\n', '        address lastWorker = workers[workers.length - 1];\n', '        workerToIndex[lastWorker] = index;\n', '        workers[index] = lastWorker;\n', '        workers.length--;\n', '        delete workerToIndex[_worker];\n', '        emit RemovedWorker(_worker);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract ControllerStorage {\n', '    address public walletsDelegate;\n', '    address public controllerDelegate;\n', '    address public forward;\n', '    uint256 public createdWallets;\n', '    mapping(bytes32 => bytes32) public gStorage;\n', '}\n', '\n', 'contract DelegateProxy {\n', '  /**\n', '   * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n', '   * @param _dst Destination address to perform the delegatecall\n', '   * @param _calldata Calldata for the delegatecall\n', '   */\n', '  function delegatedFwd(address _dst, bytes _calldata) internal {\n', '    assembly {\n', '      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n', '      let size := returndatasize\n', '\n', '      let ptr := mload(0x40)\n', '      returndatacopy(ptr, 0, size)\n', '\n', '      // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n', '      // if the call returned error data, forward it\n', '      switch result case 0 { revert(ptr, size) }\n', '      default { return(ptr, size) }\n', '    }\n', '  }\n', '}\n', '\n', 'contract DelegateProvider {\n', '    function getDelegate() public view returns (address delegate);\n', '}\n', '\n', 'contract ControllerProxy is ControllerStorage, Ownable, HasWorkers, DelegateProvider, DelegateProxy {\n', '    function getDelegate() public view returns (address delegate) {\n', '        delegate = walletsDelegate;\n', '    }\n', '\n', '    function setWalletsDelegate(address _delegate) public onlyOwner returns (bool) {\n', '        walletsDelegate = _delegate;\n', '        return true;\n', '    }\n', '\n', '    function setControllerDelegate(address _delegate) public onlyOwner returns (bool) {\n', '        controllerDelegate = _delegate;\n', '        return true;\n', '    }\n', '\n', '    function() public payable {\n', '        if (gasleft() > 2400) {\n', '            delegatedFwd(controllerDelegate, msg.data);\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender; \n', '    }\n', '\n', '    /**\n', '        @dev Transfers the ownership of the contract.\n', '\n', '        @param _owner Address of the new owner\n', '    */\n', '    function setOwner(address _owner) public onlyOwner returns (bool) {\n', '        require(_owner != address(0));\n', '        owner = _owner;\n', '        return true;\n', '    } \n', '}\n', '\n', '\n', 'contract HasWorkers is Ownable {\n', '    mapping(address => uint256) private workerToIndex;    \n', '    address[] private workers;\n', '\n', '    event AddedWorker(address _worker);\n', '    event RemovedWorker(address _worker);\n', '\n', '    constructor() public {\n', '        workers.length++;\n', '    }\n', '\n', '    modifier onlyWorker() {\n', '        require(isWorker(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier workerOrOwner() {\n', '        require(isWorker(msg.sender) || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function isWorker(address _worker) public view returns (bool) {\n', '        return workerToIndex[_worker] != 0;\n', '    }\n', '\n', '    function allWorkers() public view returns (address[] memory result) {\n', '        result = new address[](workers.length - 1);\n', '        for (uint256 i = 1; i < workers.length; i++) {\n', '            result[i - 1] = workers[i];\n', '        }\n', '    }\n', '\n', '    function addWorker(address _worker) public onlyOwner returns (bool) {\n', '        require(!isWorker(_worker));\n', '        uint256 index = workers.push(_worker) - 1;\n', '        workerToIndex[_worker] = index;\n', '        emit AddedWorker(_worker);\n', '        return true;\n', '    }\n', '\n', '    function removeWorker(address _worker) public onlyOwner returns (bool) {\n', '        require(isWorker(_worker));\n', '        uint256 index = workerToIndex[_worker];\n', '        address lastWorker = workers[workers.length - 1];\n', '        workerToIndex[lastWorker] = index;\n', '        workers[index] = lastWorker;\n', '        workers.length--;\n', '        delete workerToIndex[_worker];\n', '        emit RemovedWorker(_worker);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract ControllerStorage {\n', '    address public walletsDelegate;\n', '    address public controllerDelegate;\n', '    address public forward;\n', '    uint256 public createdWallets;\n', '    mapping(bytes32 => bytes32) public gStorage;\n', '}\n', '\n', 'contract DelegateProxy {\n', '  /**\n', '   * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n', '   * @param _dst Destination address to perform the delegatecall\n', '   * @param _calldata Calldata for the delegatecall\n', '   */\n', '  function delegatedFwd(address _dst, bytes _calldata) internal {\n', '    assembly {\n', '      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n', '      let size := returndatasize\n', '\n', '      let ptr := mload(0x40)\n', '      returndatacopy(ptr, 0, size)\n', '\n', '      // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n', '      // if the call returned error data, forward it\n', '      switch result case 0 { revert(ptr, size) }\n', '      default { return(ptr, size) }\n', '    }\n', '  }\n', '}\n', '\n', 'contract DelegateProvider {\n', '    function getDelegate() public view returns (address delegate);\n', '}\n', '\n', 'contract ControllerProxy is ControllerStorage, Ownable, HasWorkers, DelegateProvider, DelegateProxy {\n', '    function getDelegate() public view returns (address delegate) {\n', '        delegate = walletsDelegate;\n', '    }\n', '\n', '    function setWalletsDelegate(address _delegate) public onlyOwner returns (bool) {\n', '        walletsDelegate = _delegate;\n', '        return true;\n', '    }\n', '\n', '    function setControllerDelegate(address _delegate) public onlyOwner returns (bool) {\n', '        controllerDelegate = _delegate;\n', '        return true;\n', '    }\n', '\n', '    function() public payable {\n', '        if (gasleft() > 2400) {\n', '            delegatedFwd(controllerDelegate, msg.data);\n', '        }\n', '    }\n', '}']
