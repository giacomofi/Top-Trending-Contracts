['pragma solidity ^0.4.24;\n', 'contract Ownable{\n', '    address public owner;\n', '    event ownerTransfer(address indexed oldOwner, address indexed newOwner);\n', '    event ownerGone(address indexed oldOwner);\n', '\n', '    constructor(){\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function changeOwner(address _newOwner) public onlyOwner{\n', '        require(_newOwner != address(0x0));\n', '        emit ownerTransfer(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', 'contract Haltable is Ownable{\n', '    bool public paused;\n', '    event ContractPaused(address by);\n', '    event ContractUnpaused(address by);\n', '\n', '    /**\n', '     * @dev Paused by default.\n', '     */\n', '    constructor(){\n', '        paused = true;\n', '    }\n', '    function pause() public onlyOwner {\n', '        paused = true;\n', '        emit ContractPaused(owner);\n', '    }\n', '    function unpause() public onlyOwner {\n', '        paused = false;\n', '        emit ContractUnpaused(owner);\n', '    }\n', '    modifier stopOnPause(){\n', '        if(msg.sender != owner){\n', '            require(paused == false);\n', '        }\n', '        _;\n', '    }\n', '}\n', 'interface ABIO_Token {\n', '    function owner() external returns (address);\n', '    function transfer(address receiver, uint amount) external;\n', '    function burnMyBalance() external;\n', '}\n', 'interface ABIO_preICO{\n', '    function weiRaised() external returns (uint);\n', '    function fundingGoal() external returns (uint);\n', '    function extGoalReached() external returns (uint);\n', '}\n', 'contract ABIO_BaseICO is Haltable{\n', '    mapping(address => uint256) ethBalances;\n', '\n', '    uint public weiRaised;//total raised in wei\n', '    uint public abioSold;//amount of ABIO sold\n', '    uint public volume; //total amount of ABIO selling in this preICO\n', '\n', '    uint public startDate;\n', '    uint public length;\n', '    uint public deadline;\n', '    bool public restTokensBurned;\n', '\n', '    uint public weiPerABIO; //how much wei one ABIO costs\n', '    uint public minInvestment;\n', '    uint public fundingGoal;\n', '    bool public fundingGoalReached;\n', '    address public treasury;\n', '\n', '    ABIO_Token public abioToken;\n', '\n', '    event ICOStart(uint volume, uint weiPerABIO, uint minInvestment);\n', '    event SoftcapReached(address recipient, uint totalAmountRaised);\n', '    event FundsReceived(address backer, uint amount);\n', '    event FundsWithdrawn(address receiver, uint amount);\n', '\n', '    event ChangeTreasury(address operator, address newTreasury);\n', '    event PriceAdjust(address operator, uint multipliedBy ,uint newMin, uint newPrice);\n', '\n', '         /**\n', '         * @notice allows owner to change the treasury in case of hack/lost keys.\n', '         * @dev Marked external because it is never called from this contract.\n', '         */\n', '         function changeTreasury(address _newTreasury) external onlyOwner{\n', '             treasury = _newTreasury;\n', '             emit ChangeTreasury(msg.sender, _newTreasury);\n', '         }\n', '\n', '         /**\n', '         * @notice allows owner to adjust `minInvestment` and `weiPerABIO` in case of extreme jumps of Ether&#39;s dollar-value.\n', '         * @param _multiplier Both `minInvestment` and `weiPerABIO` will be multiplied by `_multiplier`. It is supposed to be close to oldEthPrice/newEthPrice\n', '         * @param _multiplier MULTIPLIER IS SUPPLIED AS PERCENTAGE\n', '         */\n', '         function adjustPrice(uint _multiplier) external onlyOwner{\n', '             require(_multiplier < 400 && _multiplier > 25);\n', '             minInvestment = minInvestment * _multiplier / 100;\n', '             weiPerABIO = weiPerABIO * _multiplier / 100;\n', '             emit PriceAdjust(msg.sender, _multiplier, minInvestment, weiPerABIO);\n', '         }\n', '\n', '         /**\n', '          * @notice Called everytime we receive a contribution in ETH.\n', '          * @dev Tokens are immediately transferred to the contributor, even if goal doesn&#39;t get reached.\n', '          */\n', '         function () payable stopOnPause{\n', '             require(now < deadline);\n', '             require(msg.value >= minInvestment);\n', '             uint amount = msg.value;\n', '             ethBalances[msg.sender] += amount;\n', '             weiRaised += amount;\n', '             if(!fundingGoalReached && weiRaised >= fundingGoal){goalReached();}\n', '\n', '             uint ABIOAmount = amount / weiPerABIO ;\n', '             abioToken.transfer(msg.sender, ABIOAmount);\n', '             abioSold += ABIOAmount;\n', '             emit FundsReceived(msg.sender, amount);\n', '         }\n', '\n', '         /**\n', '         * @notice We implement tokenFallback in case someone decides to send us tokens or we want to increase ICO Volume.\n', '         * @dev If someone sends random tokens transaction is reverted.\n', '         * @dev If owner of token sends tokens, we accept them.\n', '         * @dev Crowdsale opens once this contract gets the tokens.\n', '         */\n', '         function tokenFallback(address _from, uint _value, bytes) external{\n', '             require(msg.sender == address(abioToken));\n', '             require(_from == abioToken.owner() || _from == owner);\n', '             volume = _value;\n', '             paused = false;\n', '             deadline = now + length;\n', '             emit ICOStart(_value, weiPerABIO, minInvestment);\n', '         }\n', '\n', '         /**\n', '         * @notice Burns tokens leftover from an ICO round.\n', '         * @dev This can be called by anyone after deadline since it&#39;s an essential and inevitable part.\n', '         */\n', '         function burnRestTokens() afterDeadline{\n', '                 require(!restTokensBurned);\n', '                 abioToken.burnMyBalance();\n', '                 restTokensBurned = true;\n', '         }\n', '\n', '         function isRunning() view returns (bool){\n', '             return (now < deadline);\n', '         }\n', '\n', '         function goalReached() internal;\n', '\n', '         modifier afterDeadline() { if (now >= deadline) _; }\n', '}\n', '\n', '\n', 'contract ABIO_ICO is ABIO_BaseICO{\n', '    ABIO_preICO PICO;\n', '    uint weiRaisedInPICO;\n', '    uint abioSoldInPICO;\n', '\n', '    event Prolonged(address oabiotor, uint newDeadline);\n', '    bool didProlong;\n', '    constructor(address _abioAddress, address _treasury, address _PICOAddr, uint _lenInMins,uint _minInvestment, uint _priceInWei){\n', '         abioToken = ABIO_Token(_abioAddress);\n', '         treasury = _treasury;\n', '\n', '         PICO = ABIO_preICO(_PICOAddr);\n', '         weiRaisedInPICO = PICO.weiRaised();\n', '         fundingGoal = PICO.fundingGoal();\n', '         if (weiRaisedInPICO >= fundingGoal){\n', '             goalReached();\n', '         }\n', '         minInvestment = _minInvestment;\n', '\n', '         startDate = now;\n', '         length = _lenInMins * 1 minutes;\n', '         weiPerABIO = _priceInWei;\n', '         fundingGoal = PICO.fundingGoal();\n', '    }\n', '\n', '    /**\n', '    * @notice a function that changes state if goal reached. If the PICO didn&#39;t reach goal, it reports back to it.\n', '    */\n', '    function goalReached() internal {\n', '        emit SoftcapReached(treasury, fundingGoal);\n', '        fundingGoalReached = true;\n', '        if (weiRaisedInPICO < fundingGoal){\n', '            PICO.extGoalReached();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Lets participants withdraw the funds if goal was missed.\n', '     * @notice Lets treasury collect the funds if goal was reached.\n', '     * @dev The contract is obligated to return the ETH to contributors if goal isn&#39;t reached,\n', '     *      so we have to wait until the end for a withdrawal.\n', '     */\n', '    function safeWithdrawal() afterDeadline stopOnPause{\n', '        if (!fundingGoalReached) {\n', '            uint amount = ethBalances[msg.sender];\n', '            ethBalances[msg.sender] = 0;\n', '            if (amount > 0) {\n', '                if (msg.sender.send(amount)) {\n', '                    emit FundsWithdrawn(msg.sender, amount);\n', '                } else {\n', '                    ethBalances[msg.sender] = amount;\n', '                }\n', '            }\n', '        }\n', '        else if (fundingGoalReached) {\n', '            require(treasury == msg.sender);\n', '            if (treasury.send(weiRaised)) {\n', '                emit FundsWithdrawn(treasury, weiRaised);\n', '            } else if (treasury.send(address(this).balance)){\n', '                emit FundsWithdrawn(treasury, address(this).balance);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Is going to be called in an extreme case where we need to prolong the ICO (e.g. missed Softcap by a few ETH)/\n', '    * @dev It&#39;s only called once, has to be called at least 4 days before ICO end and prolongs the ICO for no more than 3 weeks.\n', '    */\n', '    function prolong(uint _timeInMins) external onlyOwner{\n', '        require(!didProlong);\n', '        require(now <= deadline - 4 days);\n', '        uint t = _timeInMins * 1 minutes;\n', '        require(t <= 3 weeks);\n', '        deadline += t;\n', '        length += t;\n', '\n', '        didProlong = true;\n', '        emit Prolonged(msg.sender, deadline);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', 'contract Ownable{\n', '    address public owner;\n', '    event ownerTransfer(address indexed oldOwner, address indexed newOwner);\n', '    event ownerGone(address indexed oldOwner);\n', '\n', '    constructor(){\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function changeOwner(address _newOwner) public onlyOwner{\n', '        require(_newOwner != address(0x0));\n', '        emit ownerTransfer(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', 'contract Haltable is Ownable{\n', '    bool public paused;\n', '    event ContractPaused(address by);\n', '    event ContractUnpaused(address by);\n', '\n', '    /**\n', '     * @dev Paused by default.\n', '     */\n', '    constructor(){\n', '        paused = true;\n', '    }\n', '    function pause() public onlyOwner {\n', '        paused = true;\n', '        emit ContractPaused(owner);\n', '    }\n', '    function unpause() public onlyOwner {\n', '        paused = false;\n', '        emit ContractUnpaused(owner);\n', '    }\n', '    modifier stopOnPause(){\n', '        if(msg.sender != owner){\n', '            require(paused == false);\n', '        }\n', '        _;\n', '    }\n', '}\n', 'interface ABIO_Token {\n', '    function owner() external returns (address);\n', '    function transfer(address receiver, uint amount) external;\n', '    function burnMyBalance() external;\n', '}\n', 'interface ABIO_preICO{\n', '    function weiRaised() external returns (uint);\n', '    function fundingGoal() external returns (uint);\n', '    function extGoalReached() external returns (uint);\n', '}\n', 'contract ABIO_BaseICO is Haltable{\n', '    mapping(address => uint256) ethBalances;\n', '\n', '    uint public weiRaised;//total raised in wei\n', '    uint public abioSold;//amount of ABIO sold\n', '    uint public volume; //total amount of ABIO selling in this preICO\n', '\n', '    uint public startDate;\n', '    uint public length;\n', '    uint public deadline;\n', '    bool public restTokensBurned;\n', '\n', '    uint public weiPerABIO; //how much wei one ABIO costs\n', '    uint public minInvestment;\n', '    uint public fundingGoal;\n', '    bool public fundingGoalReached;\n', '    address public treasury;\n', '\n', '    ABIO_Token public abioToken;\n', '\n', '    event ICOStart(uint volume, uint weiPerABIO, uint minInvestment);\n', '    event SoftcapReached(address recipient, uint totalAmountRaised);\n', '    event FundsReceived(address backer, uint amount);\n', '    event FundsWithdrawn(address receiver, uint amount);\n', '\n', '    event ChangeTreasury(address operator, address newTreasury);\n', '    event PriceAdjust(address operator, uint multipliedBy ,uint newMin, uint newPrice);\n', '\n', '         /**\n', '         * @notice allows owner to change the treasury in case of hack/lost keys.\n', '         * @dev Marked external because it is never called from this contract.\n', '         */\n', '         function changeTreasury(address _newTreasury) external onlyOwner{\n', '             treasury = _newTreasury;\n', '             emit ChangeTreasury(msg.sender, _newTreasury);\n', '         }\n', '\n', '         /**\n', "         * @notice allows owner to adjust `minInvestment` and `weiPerABIO` in case of extreme jumps of Ether's dollar-value.\n", '         * @param _multiplier Both `minInvestment` and `weiPerABIO` will be multiplied by `_multiplier`. It is supposed to be close to oldEthPrice/newEthPrice\n', '         * @param _multiplier MULTIPLIER IS SUPPLIED AS PERCENTAGE\n', '         */\n', '         function adjustPrice(uint _multiplier) external onlyOwner{\n', '             require(_multiplier < 400 && _multiplier > 25);\n', '             minInvestment = minInvestment * _multiplier / 100;\n', '             weiPerABIO = weiPerABIO * _multiplier / 100;\n', '             emit PriceAdjust(msg.sender, _multiplier, minInvestment, weiPerABIO);\n', '         }\n', '\n', '         /**\n', '          * @notice Called everytime we receive a contribution in ETH.\n', "          * @dev Tokens are immediately transferred to the contributor, even if goal doesn't get reached.\n", '          */\n', '         function () payable stopOnPause{\n', '             require(now < deadline);\n', '             require(msg.value >= minInvestment);\n', '             uint amount = msg.value;\n', '             ethBalances[msg.sender] += amount;\n', '             weiRaised += amount;\n', '             if(!fundingGoalReached && weiRaised >= fundingGoal){goalReached();}\n', '\n', '             uint ABIOAmount = amount / weiPerABIO ;\n', '             abioToken.transfer(msg.sender, ABIOAmount);\n', '             abioSold += ABIOAmount;\n', '             emit FundsReceived(msg.sender, amount);\n', '         }\n', '\n', '         /**\n', '         * @notice We implement tokenFallback in case someone decides to send us tokens or we want to increase ICO Volume.\n', '         * @dev If someone sends random tokens transaction is reverted.\n', '         * @dev If owner of token sends tokens, we accept them.\n', '         * @dev Crowdsale opens once this contract gets the tokens.\n', '         */\n', '         function tokenFallback(address _from, uint _value, bytes) external{\n', '             require(msg.sender == address(abioToken));\n', '             require(_from == abioToken.owner() || _from == owner);\n', '             volume = _value;\n', '             paused = false;\n', '             deadline = now + length;\n', '             emit ICOStart(_value, weiPerABIO, minInvestment);\n', '         }\n', '\n', '         /**\n', '         * @notice Burns tokens leftover from an ICO round.\n', "         * @dev This can be called by anyone after deadline since it's an essential and inevitable part.\n", '         */\n', '         function burnRestTokens() afterDeadline{\n', '                 require(!restTokensBurned);\n', '                 abioToken.burnMyBalance();\n', '                 restTokensBurned = true;\n', '         }\n', '\n', '         function isRunning() view returns (bool){\n', '             return (now < deadline);\n', '         }\n', '\n', '         function goalReached() internal;\n', '\n', '         modifier afterDeadline() { if (now >= deadline) _; }\n', '}\n', '\n', '\n', 'contract ABIO_ICO is ABIO_BaseICO{\n', '    ABIO_preICO PICO;\n', '    uint weiRaisedInPICO;\n', '    uint abioSoldInPICO;\n', '\n', '    event Prolonged(address oabiotor, uint newDeadline);\n', '    bool didProlong;\n', '    constructor(address _abioAddress, address _treasury, address _PICOAddr, uint _lenInMins,uint _minInvestment, uint _priceInWei){\n', '         abioToken = ABIO_Token(_abioAddress);\n', '         treasury = _treasury;\n', '\n', '         PICO = ABIO_preICO(_PICOAddr);\n', '         weiRaisedInPICO = PICO.weiRaised();\n', '         fundingGoal = PICO.fundingGoal();\n', '         if (weiRaisedInPICO >= fundingGoal){\n', '             goalReached();\n', '         }\n', '         minInvestment = _minInvestment;\n', '\n', '         startDate = now;\n', '         length = _lenInMins * 1 minutes;\n', '         weiPerABIO = _priceInWei;\n', '         fundingGoal = PICO.fundingGoal();\n', '    }\n', '\n', '    /**\n', "    * @notice a function that changes state if goal reached. If the PICO didn't reach goal, it reports back to it.\n", '    */\n', '    function goalReached() internal {\n', '        emit SoftcapReached(treasury, fundingGoal);\n', '        fundingGoalReached = true;\n', '        if (weiRaisedInPICO < fundingGoal){\n', '            PICO.extGoalReached();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Lets participants withdraw the funds if goal was missed.\n', '     * @notice Lets treasury collect the funds if goal was reached.\n', "     * @dev The contract is obligated to return the ETH to contributors if goal isn't reached,\n", '     *      so we have to wait until the end for a withdrawal.\n', '     */\n', '    function safeWithdrawal() afterDeadline stopOnPause{\n', '        if (!fundingGoalReached) {\n', '            uint amount = ethBalances[msg.sender];\n', '            ethBalances[msg.sender] = 0;\n', '            if (amount > 0) {\n', '                if (msg.sender.send(amount)) {\n', '                    emit FundsWithdrawn(msg.sender, amount);\n', '                } else {\n', '                    ethBalances[msg.sender] = amount;\n', '                }\n', '            }\n', '        }\n', '        else if (fundingGoalReached) {\n', '            require(treasury == msg.sender);\n', '            if (treasury.send(weiRaised)) {\n', '                emit FundsWithdrawn(treasury, weiRaised);\n', '            } else if (treasury.send(address(this).balance)){\n', '                emit FundsWithdrawn(treasury, address(this).balance);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Is going to be called in an extreme case where we need to prolong the ICO (e.g. missed Softcap by a few ETH)/\n', "    * @dev It's only called once, has to be called at least 4 days before ICO end and prolongs the ICO for no more than 3 weeks.\n", '    */\n', '    function prolong(uint _timeInMins) external onlyOwner{\n', '        require(!didProlong);\n', '        require(now <= deadline - 4 days);\n', '        uint t = _timeInMins * 1 minutes;\n', '        require(t <= 3 weeks);\n', '        deadline += t;\n', '        length += t;\n', '\n', '        didProlong = true;\n', '        emit Prolonged(msg.sender, deadline);\n', '    }\n', '}']
