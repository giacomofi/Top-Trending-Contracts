['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev Adds onlyOwner modifier. Subcontracts should implement checkOwner to check if caller is owner.\n', ' */\n', 'contract Ownable {\n', '    modifier onlyOwner() {\n', '        checkOwner();\n', '        _;\n', '    }\n', '\n', '    function checkOwner() internal;\n', '}\n', '\n', '/**\n', ' * @title OwnableImpl\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract OwnableImpl is Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function OwnableImpl() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    function checkOwner() internal {\n', '        require(msg.sender == owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Secured\n', ' * @dev Adds only(role) modifier. Subcontracts should implement checkRole to check if caller is allowed to do action.\n', ' */\n', 'contract Secured {\n', '    modifier only(string role) {\n', '        require(msg.sender == getRole(role));\n', '        _;\n', '    }\n', '\n', '    function getRole(string role) constant public returns (address);\n', '}\n', '\n', 'contract SecuredImpl is Ownable, Secured {\n', '\tmapping(string => address) users;\n', '\tevent RoleTransferred(address indexed previousUser, address indexed newUser, string role);\n', '\n', '\tfunction getRole(string role) constant public returns (address) {\n', '\t\treturn users[role];\n', '\t}\n', '\n', '\tfunction transferRole(string role, address to) onlyOwner public {\n', '\t\trequire(to != address(0));\n', '\t\temit RoleTransferred(users[role], to, role);\n', '\t\tusers[role] = to;\n', '\t}\n', '}\n', '\n', 'contract Factory {\n', '    event TokenCreated(address addr);\n', '    event SaleCreated(address addr);\n', '\n', '    function createICO(bytes token, bytes sale) public {\n', '        address tokenAddress = create(token);\n', '        emit TokenCreated(tokenAddress);\n', '        address saleAddress = create(sale);\n', '        emit SaleCreated(saleAddress);\n', '        SecuredImpl(tokenAddress).transferRole("minter", saleAddress);\n', '        OwnableImpl(tokenAddress).transferOwnership(msg.sender);\n', '        OwnableImpl(saleAddress).transferOwnership(msg.sender);\n', '    }\n', '\n', '    function create(bytes code) internal returns (address addr) {\n', '        assembly {\n', '            addr := create(0, add(code,0x20), mload(code))\n', '            switch extcodesize(addr) case 0 {revert(0, 0)} default {}\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev Adds onlyOwner modifier. Subcontracts should implement checkOwner to check if caller is owner.\n', ' */\n', 'contract Ownable {\n', '    modifier onlyOwner() {\n', '        checkOwner();\n', '        _;\n', '    }\n', '\n', '    function checkOwner() internal;\n', '}\n', '\n', '/**\n', ' * @title OwnableImpl\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract OwnableImpl is Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function OwnableImpl() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    function checkOwner() internal {\n', '        require(msg.sender == owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Secured\n', ' * @dev Adds only(role) modifier. Subcontracts should implement checkRole to check if caller is allowed to do action.\n', ' */\n', 'contract Secured {\n', '    modifier only(string role) {\n', '        require(msg.sender == getRole(role));\n', '        _;\n', '    }\n', '\n', '    function getRole(string role) constant public returns (address);\n', '}\n', '\n', 'contract SecuredImpl is Ownable, Secured {\n', '\tmapping(string => address) users;\n', '\tevent RoleTransferred(address indexed previousUser, address indexed newUser, string role);\n', '\n', '\tfunction getRole(string role) constant public returns (address) {\n', '\t\treturn users[role];\n', '\t}\n', '\n', '\tfunction transferRole(string role, address to) onlyOwner public {\n', '\t\trequire(to != address(0));\n', '\t\temit RoleTransferred(users[role], to, role);\n', '\t\tusers[role] = to;\n', '\t}\n', '}\n', '\n', 'contract Factory {\n', '    event TokenCreated(address addr);\n', '    event SaleCreated(address addr);\n', '\n', '    function createICO(bytes token, bytes sale) public {\n', '        address tokenAddress = create(token);\n', '        emit TokenCreated(tokenAddress);\n', '        address saleAddress = create(sale);\n', '        emit SaleCreated(saleAddress);\n', '        SecuredImpl(tokenAddress).transferRole("minter", saleAddress);\n', '        OwnableImpl(tokenAddress).transferOwnership(msg.sender);\n', '        OwnableImpl(saleAddress).transferOwnership(msg.sender);\n', '    }\n', '\n', '    function create(bytes code) internal returns (address addr) {\n', '        assembly {\n', '            addr := create(0, add(code,0x20), mload(code))\n', '            switch extcodesize(addr) case 0 {revert(0, 0)} default {}\n', '        }\n', '    }\n', '}']
