['/**\n', ' * @title CryptoDivert DAPP\n', ' * @dev Implementation of the CryptoDivert Smart Contract.\n', ' * @version 2018.04.05 \n', ' * @copyright All rights reserved (c) 2018 Cryptology ltd, Hong Kong.\n', ' * @author Cryptology ltd, Hong Kong.\n', ' * @disclaimer CryptoDivert DAPP provided by Cryptology ltd, Hong Kong is for illustrative purposes only. \n', ' * \n', ' * The interface for this contract is running on https://CryptoDivert.io \n', ' * \n', ' * You can also use the contract in https://www.myetherwallet.com/#contracts. \n', ' * With ABI / JSON Interface:\n', ' * [{"constant":true,"inputs":[],"name":"showPendingAdmin","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_password","type":"string"},{"name":"_originAddress","type":"address"}],"name":"Retrieve","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"ping","outputs":[{"name":"","type":"string"},{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"whoIsAdmin","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_newAdmin","type":"address"}],"name":"setAdmin","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_originAddressHash","type":"bytes20"},{"name":"_releaseTime","type":"uint256"},{"name":"_privacyCommission","type":"uint16"}],"name":"SafeGuard","outputs":[{"name":"","type":"bool"}],"payable":true,"stateMutability":"payable","type":"function"},{"constant":true,"inputs":[{"name":"_originAddressHash","type":"bytes20"}],"name":"AuditSafeGuard","outputs":[{"name":"_safeGuarded","type":"uint256"},{"name":"_timelock","type":"uint256"},{"name":"_privacypercentage","type":"uint16"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"AuditBalances","outputs":[{"name":"","type":"uint256"},{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"confirmAdmin","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"RetrieveCommissions","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":true,"stateMutability":"payable","type":"fallback"},{"anonymous":false,"inputs":[{"indexed":false,"name":"pendingAdmin","type":"address"},{"indexed":false,"name":"currentAdmin","type":"address"}],"name":"ContractAdminTransferPending","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"newAdmin","type":"address"},{"indexed":false,"name":"previousAdmin","type":"address"}],"name":"NewContractAdmin","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"value","type":"uint256"}],"name":"CommissionsWithdrawn","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"hash","type":"bytes20"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":false,"name":"comissions","type":"uint256"}],"name":"SafeGuardSuccess","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"value","type":"uint256"}],"name":"RetrieveSuccess","type":"event"}]\n', ' * \n', ' * ABOUT\n', ' * This Distributed Application (DAPP) provides private (pseudo-anonymous) transactions on the ETH blockchain.\n', ' * A forensic expert will be able to trace these transaction with some time and effort. If you don&#39;t do\n', ' * anything illegal where time and effort will be spend to trace you down this should be providing you enough privacy. \n', ' * You can create public and private transfers (public: anybody with the password can retrieve, private: only a specific address can retrieve).\n', ' * For private transfers there will be no direct link between safeguarding and retrieving the funds, only an indirect link\n', ' * where a forensic investigator would have to trial and error hashing all retrieved password/address combinations \n', ' * until he stumbles upon the one you used to safeguard the ETH. The more usage this DAPP gets, the more private it becomes.\n', ' *\n', ' * You can check our FAQ at https://cryptodivert.io/faq for details.\n', ' * \n', ' * This software is supplied "AS IS" without any warranties and support. \n', ' * Cryptology ltd assumes no responsibility or liability for the use of the software, \n', ' * conveys no license or title under any patent, copyright, or mask work right to the product. \n', ' * Cryptology ltd make no representation or warranty that such application will be suitable for \n', ' * the specified use without further testing or modification.\n', ' * \n', ' * To the maximum extent permitted by applicable law, in no event shall Cryptology ltd be liable for \n', ' * any direct, indirect, punitive, incidental, special, consequential damages or any damages \n', ' * whatsoever including, without limitation, damages for loss of use, data or profits, arising \n', ' * out of or in any way connected with the use or performance of the CryptoDivert DAPP, with the delay \n', ' * or inability to use the CryptoDivert DAPP or related services, the provision of or failure to \n', ' * provide services, or for any information obtained through the CryptoDivert DAPP, or otherwise arising out \n', ' * of the use of the CryptoDivert DAPP, whether based on contract, tort, negligence, strict liability \n', ' * or otherwise, even if Cryptology ltd has been advised of the possibility of damages. \n', ' * Because some states/jurisdictions do not allow the exclusion or limitation of liability for \n', ' * consequential or incidental damages, the above limitation may not apply to you. \n', ' * If you are dissatisfied with any portion of the CryptoDivert DAPP, or with any of these terms of \n', ' * use, your sole and exclusive remedy is to discontinue using the CryptoDivert DAPP.\n', ' * \n', ' * DO NOT USE THIS DAPP IN A WAY THAT VIOLATES ANY LAW, WOULD CREATE LIABILITY OR PROMOTES\n', ' * ILLEGAL ACTIVITIES. \n', ' */\n', ' \n', 'pragma solidity ^0.4.21;\n', '\n', 'contract CryptoDivert {\n', '    using SafeMath for uint256; // We don&#39;t like overflow errors.\n', '    \n', '    // ETH address of the admin.\n', '    // Some methods from this contract can only be executed by the admin address.\n', '    address private admin;\n', '    \n', '    // Used to confirm a new Admin address. The current admin sets this variable \n', '    // when he wants to transfer the contract. The change will only be implemented \n', '    // once the new admin ETH address confirms the address is correct.\n', '    address private pendingAdmin; \n', '    \n', '    // 0x ETH address, we check input against this address.\n', '    address private constant NO_ADDRESS = address(0);\n', '    \n', '    // Store the originating addresses for every SafeGuard. These will be used to \n', '    // verify the bytes20 hash when a safeguard is retrieved.\n', '    mapping (bytes20 => address) private senders;\n', '    \n', '    // Allow a SafeGuard to be locked until a certain time (e.g. can`t be retrieved before).\n', '    mapping (bytes20 => uint256) private timers;\n', '    \n', '    // Allow a maximum deviation of the amount by x% where x/100 is x * 1%\n', '    mapping (bytes20 => uint16) private privacyDeviation;\n', '    \n', '    // Store the value of every SafeGuard.\n', '    mapping (bytes20 => uint256) private balances;\n', '    \n', '    // Keep balance administrations. \n', '    uint256 private userBalance; // The total value of all outstanding safeguards combined.\n', '    \n', '    // Create additional privacy (only for receiver hashed transfers)\n', '    uint256 private privacyFund;\n', '    \n', '    /// EVENTS ///\n', '    event ContractAdminTransferPending(address pendingAdmin, address currentAdmin);\n', '    event NewContractAdmin(address newAdmin, address previousAdmin);\n', '    event SafeGuardSuccess(bytes20 hash, uint256 value, uint256 comissions);\n', '    event RetrieveSuccess(uint256 value);\n', '    \n', '    \n', '    /// MODIFIERS ///\n', '    /**\n', '     * @dev Only allow a method to be executed if &#39;_who&#39; is not the 0x address\n', '     */\n', '    modifier isAddress(address _who) {\n', '        require(_who != NO_ADDRESS);\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Only allow a method the be executed if the input hasn&#39;t been messed with.\n', '     */\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length >= size +4); // +4 because the 4 bytes of the method.\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Only allow a method to be executed if &#39;msg.sender&#39; is the admin.\n', '     */\n', '    modifier OnlyByAdmin() {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Only allow a method to be executed if &#39;_who&#39; is not the admin.\n', '     */\n', '    modifier isNotAdmin(address _who) {\n', '        require(_who != admin);\n', '        _;\n', '    }\n', '\n', '    /// PUBLIC METHODS ///    \n', '    function CryptoDivert() public {\n', '        // We need to define the initial administrator for this DAPP.\n', '        // This should be transferred to the permanent administrator after the contract\n', '        // has been created on the blockchain.\n', '        admin = msg.sender;\n', '    }\n', '    \n', '    /**\n', '     * @dev Process users sending ETH to this contract.\n', '     * Don&#39;t send ETH directly to this contract, use the SafeGuard method to \n', '     * safeguard your ETHs; then again we don&#39;t mind if you like to \n', '     * buy us a beer (or a Lambo). In that case thanks for the ETH! \n', '     * We&#39;ll assume you actually intended to tip us.\n', '     */\n', '    function() public payable {\n', '    }\n', '    \n', '    /// EXTERNAL VIEW METHODS ///\n', '    /**\n', '     * @dev Test for web3js interface to see if contract is correctly initialized.\n', '     */\n', '    function ping() external view returns(string, uint256) {\n', '        return ("CryptoDivert version 2018.04.05", now);\n', '    }\n', '    \n', '    \n', '    /**\n', '     * @dev Shows who is the pending admin for this contract\n', '     * @return &#39;pendingAdmin&#39;\n', '     */\n', '    function showPendingAdmin() external view \n', '    OnlyByAdmin()\n', '    returns(address) \n', '    {\n', '        require(pendingAdmin != NO_ADDRESS);\n', '        return pendingAdmin;\n', '    }\n', '    \n', '    /**\n', '     * @dev Shows who is the admin for this contract\n', '     * @return &#39;admin&#39;\n', '     */\n', '    function whoIsAdmin() external view \n', '    returns(address) \n', '    {\n', '        return admin;\n', '    }\n', '    \n', '    /**\n', '     * @dev Check if the internal administration is correct. The safeguarded user balances added to the \n', '     * un-retrieved admin commission should be the same as the ETH balance of this contract.\n', '     * \n', '     * @return uint256 The total current safeguarded balance of all users &#39;userBalance&#39; + &#39;privacyfund&#39;.\n', '     * @return uint256 The outstanding admin commissions &#39;commissions&#39;.\n', '     */\n', '    function AuditBalances() external view returns(uint256, uint256) {\n', '        assert(address(this).balance >= userBalance);\n', '        uint256 pendingBalance = userBalance.add(privacyFund);\n', '        uint256 commissions = address(this).balance.sub(pendingBalance);\n', '        \n', '        return(pendingBalance, commissions);\n', '    }\n', '    \n', '    /**\n', '     * @dev Check the remaining balance for a safeguarded transaction\n', '     *\n', '     * @param _originAddressHash The RIPEMD160 Hash (bytes20) of a password and the originating ETH address.\n', '     * @return uint256 The remaining value in Wei for this safeguard.\n', '     */\n', '    function AuditSafeGuard(bytes20 _originAddressHash) external view \n', '    returns(uint256 _safeGuarded, uint256 _timelock, uint16 _privacypercentage)\n', '    {\n', '        // Only by the address that uploaded the safeguard to make it harder for prying eyes to track.\n', '        require(msg.sender == senders[_originAddressHash] || msg.sender == admin);\n', '         \n', '        _safeGuarded = balances[_originAddressHash];\n', '        _timelock = timers[_originAddressHash];\n', '        _privacypercentage = privacyDeviation[_originAddressHash];\n', '        \n', '        return (_safeGuarded, _timelock, _privacypercentage);\n', '    }\n', '    \n', '    \n', '    /// EXTERNAL METHODS ///\n', '    /**\n', '     * @dev Safeguard a value in Wei. You can retreive this after &#39;_releaseTime&#39; via any ETH address \n', '     * by callling the Retreive method with your password and the originating ETH address.\n', '     * \n', '     * To prevent the password from being visible in the blockchain (everything added is visible in the blockchain!)\n', '     * and allow more users to set the same password, you need to create a RIPEMD160 Hash from your password\n', '     * and your originating (or intended receiver) ETH address: e.g. if you choose password: &#39;secret&#39; and transfer balance \n', '     * from (or to) ETH address (ALL LOWERCASE!) &#39;0x14723a09acff6d2a60dcdf7aa4aff308fddc160c&#39; you should RIPEMD160 Hash:\n', '     * &#39;secret0x14723a09acff6d2a60dcdf7aa4aff308fddc160c&#39;.\n', '     * http://www.md5calc.com/ RIPEMD160 gives us the 20 bytes Hash: &#39;602bc74a8e09f80c2d5bbc4374b8f400f33f2683&#39;.\n', '     * If you manually transfer value to this contract make sure to enter the hash as a bytes20 &#39;0x602bc74a8e09f80c2d5bbc4374b8f400f33f2683&#39;.\n', '     * Before you transfer any value to SafeGuard, test the example above and make sure you get the same hash, \n', '     * then test a transfer (and Retreive!) with a small amount (minimal 1 finney) before SafeGuarding a larger amount. \n', '     * \n', '     * IF YOU MAKE AN ERROR WITH YOUR HASH, OR FORGET YOUR PASSWORD, YOUR FUNDS WILL BE SAFEGUARDED FOREVER.\n', '     * \n', '     * @param _originAddressHash The RIPEMD160 Hash (bytes20) of a password and the msg.sender or intended receiver ETH address.\n', '     * @param _releaseTime The UNIX time (uint256) until when this balance is locked up.\n', '     * @param _privacyCommission The maximum deviation (up or down) that you are willing to use to make tracking on the amount harder.\n', '     * @return true Usefull if this method is called from a contract.\n', '     */\n', '    function SafeGuard(bytes20 _originAddressHash, uint256 _releaseTime, uint16 _privacyCommission) external payable\n', '    onlyPayloadSize(3*32)\n', '    returns(bool)\n', '    {\n', '        // We can only SafeGuard anything if there is value transferred.\n', '        // Minimal value is 1 finney, to prevent SPAM and any errors with the commissions calculations.\n', '        require(msg.value >= 1 finney); \n', '        \n', '        // Prevent Re-usage of a compromised password by this address; Check that we have not used this before. \n', '        // In case we have used this password, but haven&#39;t retrieved the amount, the password is still \n', '        // uncompromised and we can add this amount to the existing amount.\n', '        // A password/ETH combination that was used before will be known to the blockchain (clear text) \n', '        // after the Retrieve method has been called and can&#39;t be used again to prevent others retrieving you funds.\n', '        require(senders[_originAddressHash] == NO_ADDRESS || balances[_originAddressHash] > 0);\n', '       \n', '        // We don&#39;t know your password (Only you do!) so we can&#39;t possible check wether or not \n', '        // you created the correct hash, we have to assume you did. Only store the first sender of this hash\n', '        // to prevent someone uploading a small amount with this hash to gain access to the AuditSafeGuard method \n', '        // or reset the timer.\n', '        if(senders[_originAddressHash] == NO_ADDRESS) {\n', '            \n', '            senders[_originAddressHash] = msg.sender;\n', '            \n', '            // If you set a timer we check if it&#39;s in the future and add it to this SafeGuard.\n', '            if (_releaseTime > now) {\n', '                timers[_originAddressHash] = _releaseTime;\n', '            } else {\n', '                timers[_originAddressHash] = now;\n', '            }\n', '            \n', '            // if we have set a privacy deviation store it, max 100% = 10000.\n', '            if (_privacyCommission > 0 && _privacyCommission <= 10000) {\n', '                privacyDeviation[_originAddressHash] = _privacyCommission;\n', '            }\n', '        }    \n', '        \n', '        // To pay for our servers (and maybe a beer or two) we charge a 0.8% fee (that&#39;s 80cents per 100$).\n', '        uint256 _commission = msg.value.div(125); //100/125 = 0.8\n', '        uint256 _balanceAfterCommission = msg.value.sub(_commission);\n', '        balances[_originAddressHash] = balances[_originAddressHash].add(_balanceAfterCommission);\n', '        \n', '        // Keep score of total user balance \n', '        userBalance = userBalance.add(_balanceAfterCommission);\n', '        \n', '        // Double check that our administration is correct.\n', '        // The administration can only be incorrect if someone found a loophole in Solidity or in our programming.\n', '        // The assert will effectively revert the transaction in case someone is cheating.\n', '        assert(address(this).balance >= userBalance); \n', '        \n', '        // Let the user know what a great success.\n', '        emit SafeGuardSuccess(_originAddressHash, _balanceAfterCommission, _commission);\n', '        \n', '        return true;\n', '    } \n', '    \n', '    /**\n', '     * @dev Retrieve a safeguarded value to the ETH address that calls this method.\n', '     * \n', '     * The safeguarded value can be retrieved by any ETH address, including the originating ETH address and contracts.\n', '     * All you need is the (clear text) password and the originating ETH address that was used to transfer the \n', '     * value to this contract. This method will recreate the RIPEMD160 Hash that was \n', '     * given to the SafeGuard method (this will only succeed when both password and address are correct).\n', '     * The value can only be retrieved after the release timer for this SafeGuard (if any) has expired.\n', '     * \n', '     * This Retrieve method can be traced in the blockchain via the input field. \n', '     * We can create additional anonimity by hashing the receivers address instead of the originating address\n', '     * in the SafeGuard method. By doing this we render searching for the originating address \n', '     * in the input field useless. To make the tracement harder, we will charge an addition random \n', '     * commission between 0 and 5% so the outgoing value is randomized. This will still not create \n', '     * 100% anonimity because it is possible to hash every password and receiver address combination and compare it\n', '     * to the hash that was originally given when safeguarding the transaction. \n', '     * \n', '     * @param _password The password that was originally hashed for this safeguarded value.\n', '     * @param _originAddress The address where this safeguarded value was received from.\n', '     * @return true Usefull if this method is called from a contract.\n', '     */ \n', '    function Retrieve(string _password, address _originAddress) external \n', '    isAddress(_originAddress) \n', '    onlyPayloadSize(2*32)\n', '    returns(bool)\n', '    {\n', '        \n', '        // Re-create the _originAddressHash that was given when transferring to this contract.\n', '        // Either the sender&#39;s address was hashed (and allows to retrieve from any address) or \n', '        // the receiver&#39;s address was hashed (more private, but only allows to retrieve from that address).\n', '        bytes20 _addressHash = _getOriginAddressHash(_originAddress, _password); \n', '        bytes20 _senderHash = _getOriginAddressHash(msg.sender, _password); \n', '        bytes20 _transactionHash;\n', '        uint256 _randomPercentage; // used to make a receiver hashed transaction more private.\n', '        uint256 _month = 30 * 24 * 60 * 60;\n', '        \n', '        // Check if the given &#39;_originAddress&#39; is the same as the address that transferred to this contract.\n', '        // We do this to prevent people simply giving any hash.\n', '        if (_originAddress == senders[_addressHash]) { // Public Transaction, hashed with originating address.\n', '            \n', '            // Anybody with the password and the sender&#39;s address\n', '            _transactionHash = _addressHash;\n', '            \n', '        } \n', '        else if (msg.sender == senders[_addressHash] && timers[_addressHash].add(_month) < now ) { // Private transaction, retrieve by sender after a month delay. \n', '            \n', '            // Allow a sender to retrieve his transfer, only a month after the timelock expired \n', '            _transactionHash = _addressHash;\n', '            \n', '        }\n', '        else { // Private transaction, hashed with receivers address\n', '            \n', '            // Allow a pre-defined receiver to retrieve.\n', '            _transactionHash = _senderHash;\n', '        }\n', '        \n', '        // Check if the _transactionHash exists and this balance hasn&#39;t been received already.\n', '        // We would normally do this with a require(), but to keep it more private we need the \n', '        // method to be executed also if it will not result.\n', '        if (balances[_transactionHash] == 0) {\n', '            emit RetrieveSuccess(0);\n', '            return false;    \n', '        }\n', '        \n', '        // Check if this SafeGuard has a timelock and if it already has expired.\n', '        // In case the transaction was sent to a pre-defined address, the sender can retrieve the transaction 1 month after it expired.\n', '        // We would normally do this with a require(), but to keep it more private we need the \n', '        // method to be executed also if it will not result.\n', '        if (timers[_transactionHash] > now ) {\n', '            emit RetrieveSuccess(0);\n', '            return false;\n', '        }\n', '        \n', '        // Prepare to transfer the balance out.\n', '        uint256 _balance = balances[_transactionHash];\n', '        balances[_transactionHash] = 0;\n', '        \n', '        // Check if the sender allowed for a deviation (up or down) of the value to make tracking harder.\n', '        // To do this we need to randomize the balance a little so it\n', '        // become less traceable: To make the tracement harder, we will calculate an \n', '        // additional random commission between 0 and the allowed deviation which can be added to or substracted from \n', '        // this transfer&#39;s balance so the outgoing value is randomized.\n', '        if (privacyDeviation[_transactionHash] > 0) {\n', '             _randomPercentage = _randomize(now, privacyDeviation[_transactionHash]);\n', '        }\n', '        \n', '        if(_randomPercentage > 0) {\n', '            // Calculate the privacy commissions amount in wei.\n', '            uint256 _privacyCommission = _balance.div(10000).mul(_randomPercentage);\n', '            \n', '            // Check integrity of privacyFund\n', '            if (userBalance.add(privacyFund) > address(this).balance) {\n', '                privacyFund = 0;\n', '            }\n', '            \n', '            // Check if we have enough availability in the privacy fund to add to this Retrieve\n', '            if (_privacyCommission <= privacyFund) {\n', '                // we have enough funds to add\n', '                 privacyFund = privacyFund.sub(_privacyCommission);\n', '                 userBalance = userBalance.add(_privacyCommission);\n', '                _balance = _balance.add(_privacyCommission);\n', '               \n', '            } else {\n', '                // the privacy fund is not filled enough, you will contribute to it.\n', '                _balance = _balance.sub(_privacyCommission);\n', '                userBalance = userBalance.sub(_privacyCommission);\n', '                privacyFund = privacyFund.add(_privacyCommission);\n', '            }\n', '        }\n', '        \n', '        // Keep score of total user balance \n', '        userBalance = userBalance.sub(_balance);\n', '        \n', '        // Transfer the value.\n', '        msg.sender.transfer(_balance);\n', '        \n', '        // Double check that our admin is correct. If not then revert this transaction.\n', '        assert(address(this).balance >= userBalance);\n', '        \n', '        emit RetrieveSuccess(_balance);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Retrieve commissions to the Admin address. \n', '     */\n', '    function RetrieveCommissions() external OnlyByAdmin() {\n', '        // The fees are the remainder of the contract balance after the userBalance and privacyFund\n', '        // reservations have been substracted. \n', '        uint256 pendingBalance = userBalance.add(privacyFund);\n', '        uint256 commissions = address(this).balance.sub(pendingBalance);\n', '        \n', '        // Transfer the commissions.\n', '        msg.sender.transfer(commissions);\n', '        \n', '        // Double check that our admin is correct.\n', '        assert(address(this).balance >= userBalance);\n', '    } \n', '    \n', '    /**\n', '     * @dev Approve a new admin for this contract. The new admin will have to \n', '     * confirm that he is the admin. \n', '     * @param _newAdmin the new owner of the contract.\n', '     */\n', '    function setAdmin(address _newAdmin) external \n', '    OnlyByAdmin() \n', '    isAddress(_newAdmin)\n', '    isNotAdmin(_newAdmin)\n', '    onlyPayloadSize(32)\n', '    {\n', '        pendingAdmin = _newAdmin;\n', '        emit ContractAdminTransferPending(pendingAdmin, admin);\n', '    }\n', '    \n', '    /**\n', '     * @dev Let the pending admin confirm his address and become the new admin.\n', '     */ \n', '    function confirmAdmin() external\n', '    {\n', '        require(msg.sender==pendingAdmin);\n', '        address _previousAdmin = admin;\n', '        admin = pendingAdmin;\n', '        pendingAdmin = NO_ADDRESS;\n', '        \n', '        emit NewContractAdmin(admin, _previousAdmin);\n', '    }\n', '    \n', '    \n', '    /// PRIVATE METHODS ///\n', '    /**\n', '     * @dev Create a (semi) random number.\n', '     * This is not truely random, as that isn&#39;t possible in the blockchain, but \n', '     * random enough for our purpose.\n', '     * \n', '     * @param _seed Randomizing seed.\n', '     * @param _max Max value.\n', '     */\n', '    function _randomize(uint256 _seed, uint256 _max) private view returns(uint256 _return) {\n', '        _return = uint256(keccak256(_seed, block.blockhash(block.number -1), block.difficulty, block.coinbase));\n', '        return _return % _max;\n', '    }\n', '    \n', '    function _getOriginAddressHash(address _address, string _password) private pure returns(bytes20) {\n', '        string memory _addressString = toAsciiString(_address);\n', '        return ripemd160(_password,"0x",_addressString);\n', '    }\n', '    \n', '    function toAsciiString(address x) private pure returns (string) {\n', '    bytes memory s = new bytes(40);\n', '        for (uint i = 0; i < 20; i++) {\n', '            byte b = byte(uint8(uint(x) / (2**(8*(19 - i)))));\n', '            byte hi = byte(uint8(b) / 16);\n', '            byte lo = byte(uint8(b) - 16 * uint8(hi));\n', '            s[2*i] = char(hi);\n', '            s[2*i+1] = char(lo);            \n', '        }\n', '        return string(s);\n', '    }\n', '    \n', '    function char(byte b) private pure returns (byte c) {\n', '        if (b < 10) return byte(uint8(b) + 0x30);\n', '        else return byte(uint8(b) + 0x57);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['/**\n', ' * @title CryptoDivert DAPP\n', ' * @dev Implementation of the CryptoDivert Smart Contract.\n', ' * @version 2018.04.05 \n', ' * @copyright All rights reserved (c) 2018 Cryptology ltd, Hong Kong.\n', ' * @author Cryptology ltd, Hong Kong.\n', ' * @disclaimer CryptoDivert DAPP provided by Cryptology ltd, Hong Kong is for illustrative purposes only. \n', ' * \n', ' * The interface for this contract is running on https://CryptoDivert.io \n', ' * \n', ' * You can also use the contract in https://www.myetherwallet.com/#contracts. \n', ' * With ABI / JSON Interface:\n', ' * [{"constant":true,"inputs":[],"name":"showPendingAdmin","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_password","type":"string"},{"name":"_originAddress","type":"address"}],"name":"Retrieve","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"ping","outputs":[{"name":"","type":"string"},{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"whoIsAdmin","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_newAdmin","type":"address"}],"name":"setAdmin","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_originAddressHash","type":"bytes20"},{"name":"_releaseTime","type":"uint256"},{"name":"_privacyCommission","type":"uint16"}],"name":"SafeGuard","outputs":[{"name":"","type":"bool"}],"payable":true,"stateMutability":"payable","type":"function"},{"constant":true,"inputs":[{"name":"_originAddressHash","type":"bytes20"}],"name":"AuditSafeGuard","outputs":[{"name":"_safeGuarded","type":"uint256"},{"name":"_timelock","type":"uint256"},{"name":"_privacypercentage","type":"uint16"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"AuditBalances","outputs":[{"name":"","type":"uint256"},{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"confirmAdmin","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"RetrieveCommissions","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":true,"stateMutability":"payable","type":"fallback"},{"anonymous":false,"inputs":[{"indexed":false,"name":"pendingAdmin","type":"address"},{"indexed":false,"name":"currentAdmin","type":"address"}],"name":"ContractAdminTransferPending","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"newAdmin","type":"address"},{"indexed":false,"name":"previousAdmin","type":"address"}],"name":"NewContractAdmin","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"value","type":"uint256"}],"name":"CommissionsWithdrawn","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"hash","type":"bytes20"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":false,"name":"comissions","type":"uint256"}],"name":"SafeGuardSuccess","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"value","type":"uint256"}],"name":"RetrieveSuccess","type":"event"}]\n', ' * \n', ' * ABOUT\n', ' * This Distributed Application (DAPP) provides private (pseudo-anonymous) transactions on the ETH blockchain.\n', " * A forensic expert will be able to trace these transaction with some time and effort. If you don't do\n", ' * anything illegal where time and effort will be spend to trace you down this should be providing you enough privacy. \n', ' * You can create public and private transfers (public: anybody with the password can retrieve, private: only a specific address can retrieve).\n', ' * For private transfers there will be no direct link between safeguarding and retrieving the funds, only an indirect link\n', ' * where a forensic investigator would have to trial and error hashing all retrieved password/address combinations \n', ' * until he stumbles upon the one you used to safeguard the ETH. The more usage this DAPP gets, the more private it becomes.\n', ' *\n', ' * You can check our FAQ at https://cryptodivert.io/faq for details.\n', ' * \n', ' * This software is supplied "AS IS" without any warranties and support. \n', ' * Cryptology ltd assumes no responsibility or liability for the use of the software, \n', ' * conveys no license or title under any patent, copyright, or mask work right to the product. \n', ' * Cryptology ltd make no representation or warranty that such application will be suitable for \n', ' * the specified use without further testing or modification.\n', ' * \n', ' * To the maximum extent permitted by applicable law, in no event shall Cryptology ltd be liable for \n', ' * any direct, indirect, punitive, incidental, special, consequential damages or any damages \n', ' * whatsoever including, without limitation, damages for loss of use, data or profits, arising \n', ' * out of or in any way connected with the use or performance of the CryptoDivert DAPP, with the delay \n', ' * or inability to use the CryptoDivert DAPP or related services, the provision of or failure to \n', ' * provide services, or for any information obtained through the CryptoDivert DAPP, or otherwise arising out \n', ' * of the use of the CryptoDivert DAPP, whether based on contract, tort, negligence, strict liability \n', ' * or otherwise, even if Cryptology ltd has been advised of the possibility of damages. \n', ' * Because some states/jurisdictions do not allow the exclusion or limitation of liability for \n', ' * consequential or incidental damages, the above limitation may not apply to you. \n', ' * If you are dissatisfied with any portion of the CryptoDivert DAPP, or with any of these terms of \n', ' * use, your sole and exclusive remedy is to discontinue using the CryptoDivert DAPP.\n', ' * \n', ' * DO NOT USE THIS DAPP IN A WAY THAT VIOLATES ANY LAW, WOULD CREATE LIABILITY OR PROMOTES\n', ' * ILLEGAL ACTIVITIES. \n', ' */\n', ' \n', 'pragma solidity ^0.4.21;\n', '\n', 'contract CryptoDivert {\n', "    using SafeMath for uint256; // We don't like overflow errors.\n", '    \n', '    // ETH address of the admin.\n', '    // Some methods from this contract can only be executed by the admin address.\n', '    address private admin;\n', '    \n', '    // Used to confirm a new Admin address. The current admin sets this variable \n', '    // when he wants to transfer the contract. The change will only be implemented \n', '    // once the new admin ETH address confirms the address is correct.\n', '    address private pendingAdmin; \n', '    \n', '    // 0x ETH address, we check input against this address.\n', '    address private constant NO_ADDRESS = address(0);\n', '    \n', '    // Store the originating addresses for every SafeGuard. These will be used to \n', '    // verify the bytes20 hash when a safeguard is retrieved.\n', '    mapping (bytes20 => address) private senders;\n', '    \n', '    // Allow a SafeGuard to be locked until a certain time (e.g. can`t be retrieved before).\n', '    mapping (bytes20 => uint256) private timers;\n', '    \n', '    // Allow a maximum deviation of the amount by x% where x/100 is x * 1%\n', '    mapping (bytes20 => uint16) private privacyDeviation;\n', '    \n', '    // Store the value of every SafeGuard.\n', '    mapping (bytes20 => uint256) private balances;\n', '    \n', '    // Keep balance administrations. \n', '    uint256 private userBalance; // The total value of all outstanding safeguards combined.\n', '    \n', '    // Create additional privacy (only for receiver hashed transfers)\n', '    uint256 private privacyFund;\n', '    \n', '    /// EVENTS ///\n', '    event ContractAdminTransferPending(address pendingAdmin, address currentAdmin);\n', '    event NewContractAdmin(address newAdmin, address previousAdmin);\n', '    event SafeGuardSuccess(bytes20 hash, uint256 value, uint256 comissions);\n', '    event RetrieveSuccess(uint256 value);\n', '    \n', '    \n', '    /// MODIFIERS ///\n', '    /**\n', "     * @dev Only allow a method to be executed if '_who' is not the 0x address\n", '     */\n', '    modifier isAddress(address _who) {\n', '        require(_who != NO_ADDRESS);\n', '        _;\n', '    }\n', '    \n', '    /**\n', "     * @dev Only allow a method the be executed if the input hasn't been messed with.\n", '     */\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length >= size +4); // +4 because the 4 bytes of the method.\n', '        _;\n', '    }\n', '    \n', '    /**\n', "     * @dev Only allow a method to be executed if 'msg.sender' is the admin.\n", '     */\n', '    modifier OnlyByAdmin() {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '    \n', '    /**\n', "     * @dev Only allow a method to be executed if '_who' is not the admin.\n", '     */\n', '    modifier isNotAdmin(address _who) {\n', '        require(_who != admin);\n', '        _;\n', '    }\n', '\n', '    /// PUBLIC METHODS ///    \n', '    function CryptoDivert() public {\n', '        // We need to define the initial administrator for this DAPP.\n', '        // This should be transferred to the permanent administrator after the contract\n', '        // has been created on the blockchain.\n', '        admin = msg.sender;\n', '    }\n', '    \n', '    /**\n', '     * @dev Process users sending ETH to this contract.\n', "     * Don't send ETH directly to this contract, use the SafeGuard method to \n", "     * safeguard your ETHs; then again we don't mind if you like to \n", '     * buy us a beer (or a Lambo). In that case thanks for the ETH! \n', "     * We'll assume you actually intended to tip us.\n", '     */\n', '    function() public payable {\n', '    }\n', '    \n', '    /// EXTERNAL VIEW METHODS ///\n', '    /**\n', '     * @dev Test for web3js interface to see if contract is correctly initialized.\n', '     */\n', '    function ping() external view returns(string, uint256) {\n', '        return ("CryptoDivert version 2018.04.05", now);\n', '    }\n', '    \n', '    \n', '    /**\n', '     * @dev Shows who is the pending admin for this contract\n', "     * @return 'pendingAdmin'\n", '     */\n', '    function showPendingAdmin() external view \n', '    OnlyByAdmin()\n', '    returns(address) \n', '    {\n', '        require(pendingAdmin != NO_ADDRESS);\n', '        return pendingAdmin;\n', '    }\n', '    \n', '    /**\n', '     * @dev Shows who is the admin for this contract\n', "     * @return 'admin'\n", '     */\n', '    function whoIsAdmin() external view \n', '    returns(address) \n', '    {\n', '        return admin;\n', '    }\n', '    \n', '    /**\n', '     * @dev Check if the internal administration is correct. The safeguarded user balances added to the \n', '     * un-retrieved admin commission should be the same as the ETH balance of this contract.\n', '     * \n', "     * @return uint256 The total current safeguarded balance of all users 'userBalance' + 'privacyfund'.\n", "     * @return uint256 The outstanding admin commissions 'commissions'.\n", '     */\n', '    function AuditBalances() external view returns(uint256, uint256) {\n', '        assert(address(this).balance >= userBalance);\n', '        uint256 pendingBalance = userBalance.add(privacyFund);\n', '        uint256 commissions = address(this).balance.sub(pendingBalance);\n', '        \n', '        return(pendingBalance, commissions);\n', '    }\n', '    \n', '    /**\n', '     * @dev Check the remaining balance for a safeguarded transaction\n', '     *\n', '     * @param _originAddressHash The RIPEMD160 Hash (bytes20) of a password and the originating ETH address.\n', '     * @return uint256 The remaining value in Wei for this safeguard.\n', '     */\n', '    function AuditSafeGuard(bytes20 _originAddressHash) external view \n', '    returns(uint256 _safeGuarded, uint256 _timelock, uint16 _privacypercentage)\n', '    {\n', '        // Only by the address that uploaded the safeguard to make it harder for prying eyes to track.\n', '        require(msg.sender == senders[_originAddressHash] || msg.sender == admin);\n', '         \n', '        _safeGuarded = balances[_originAddressHash];\n', '        _timelock = timers[_originAddressHash];\n', '        _privacypercentage = privacyDeviation[_originAddressHash];\n', '        \n', '        return (_safeGuarded, _timelock, _privacypercentage);\n', '    }\n', '    \n', '    \n', '    /// EXTERNAL METHODS ///\n', '    /**\n', "     * @dev Safeguard a value in Wei. You can retreive this after '_releaseTime' via any ETH address \n", '     * by callling the Retreive method with your password and the originating ETH address.\n', '     * \n', '     * To prevent the password from being visible in the blockchain (everything added is visible in the blockchain!)\n', '     * and allow more users to set the same password, you need to create a RIPEMD160 Hash from your password\n', "     * and your originating (or intended receiver) ETH address: e.g. if you choose password: 'secret' and transfer balance \n", "     * from (or to) ETH address (ALL LOWERCASE!) '0x14723a09acff6d2a60dcdf7aa4aff308fddc160c' you should RIPEMD160 Hash:\n", "     * 'secret0x14723a09acff6d2a60dcdf7aa4aff308fddc160c'.\n", "     * http://www.md5calc.com/ RIPEMD160 gives us the 20 bytes Hash: '602bc74a8e09f80c2d5bbc4374b8f400f33f2683'.\n", "     * If you manually transfer value to this contract make sure to enter the hash as a bytes20 '0x602bc74a8e09f80c2d5bbc4374b8f400f33f2683'.\n", '     * Before you transfer any value to SafeGuard, test the example above and make sure you get the same hash, \n', '     * then test a transfer (and Retreive!) with a small amount (minimal 1 finney) before SafeGuarding a larger amount. \n', '     * \n', '     * IF YOU MAKE AN ERROR WITH YOUR HASH, OR FORGET YOUR PASSWORD, YOUR FUNDS WILL BE SAFEGUARDED FOREVER.\n', '     * \n', '     * @param _originAddressHash The RIPEMD160 Hash (bytes20) of a password and the msg.sender or intended receiver ETH address.\n', '     * @param _releaseTime The UNIX time (uint256) until when this balance is locked up.\n', '     * @param _privacyCommission The maximum deviation (up or down) that you are willing to use to make tracking on the amount harder.\n', '     * @return true Usefull if this method is called from a contract.\n', '     */\n', '    function SafeGuard(bytes20 _originAddressHash, uint256 _releaseTime, uint16 _privacyCommission) external payable\n', '    onlyPayloadSize(3*32)\n', '    returns(bool)\n', '    {\n', '        // We can only SafeGuard anything if there is value transferred.\n', '        // Minimal value is 1 finney, to prevent SPAM and any errors with the commissions calculations.\n', '        require(msg.value >= 1 finney); \n', '        \n', '        // Prevent Re-usage of a compromised password by this address; Check that we have not used this before. \n', "        // In case we have used this password, but haven't retrieved the amount, the password is still \n", '        // uncompromised and we can add this amount to the existing amount.\n', '        // A password/ETH combination that was used before will be known to the blockchain (clear text) \n', "        // after the Retrieve method has been called and can't be used again to prevent others retrieving you funds.\n", '        require(senders[_originAddressHash] == NO_ADDRESS || balances[_originAddressHash] > 0);\n', '       \n', "        // We don't know your password (Only you do!) so we can't possible check wether or not \n", '        // you created the correct hash, we have to assume you did. Only store the first sender of this hash\n', '        // to prevent someone uploading a small amount with this hash to gain access to the AuditSafeGuard method \n', '        // or reset the timer.\n', '        if(senders[_originAddressHash] == NO_ADDRESS) {\n', '            \n', '            senders[_originAddressHash] = msg.sender;\n', '            \n', "            // If you set a timer we check if it's in the future and add it to this SafeGuard.\n", '            if (_releaseTime > now) {\n', '                timers[_originAddressHash] = _releaseTime;\n', '            } else {\n', '                timers[_originAddressHash] = now;\n', '            }\n', '            \n', '            // if we have set a privacy deviation store it, max 100% = 10000.\n', '            if (_privacyCommission > 0 && _privacyCommission <= 10000) {\n', '                privacyDeviation[_originAddressHash] = _privacyCommission;\n', '            }\n', '        }    \n', '        \n', "        // To pay for our servers (and maybe a beer or two) we charge a 0.8% fee (that's 80cents per 100$).\n", '        uint256 _commission = msg.value.div(125); //100/125 = 0.8\n', '        uint256 _balanceAfterCommission = msg.value.sub(_commission);\n', '        balances[_originAddressHash] = balances[_originAddressHash].add(_balanceAfterCommission);\n', '        \n', '        // Keep score of total user balance \n', '        userBalance = userBalance.add(_balanceAfterCommission);\n', '        \n', '        // Double check that our administration is correct.\n', '        // The administration can only be incorrect if someone found a loophole in Solidity or in our programming.\n', '        // The assert will effectively revert the transaction in case someone is cheating.\n', '        assert(address(this).balance >= userBalance); \n', '        \n', '        // Let the user know what a great success.\n', '        emit SafeGuardSuccess(_originAddressHash, _balanceAfterCommission, _commission);\n', '        \n', '        return true;\n', '    } \n', '    \n', '    /**\n', '     * @dev Retrieve a safeguarded value to the ETH address that calls this method.\n', '     * \n', '     * The safeguarded value can be retrieved by any ETH address, including the originating ETH address and contracts.\n', '     * All you need is the (clear text) password and the originating ETH address that was used to transfer the \n', '     * value to this contract. This method will recreate the RIPEMD160 Hash that was \n', '     * given to the SafeGuard method (this will only succeed when both password and address are correct).\n', '     * The value can only be retrieved after the release timer for this SafeGuard (if any) has expired.\n', '     * \n', '     * This Retrieve method can be traced in the blockchain via the input field. \n', '     * We can create additional anonimity by hashing the receivers address instead of the originating address\n', '     * in the SafeGuard method. By doing this we render searching for the originating address \n', '     * in the input field useless. To make the tracement harder, we will charge an addition random \n', '     * commission between 0 and 5% so the outgoing value is randomized. This will still not create \n', '     * 100% anonimity because it is possible to hash every password and receiver address combination and compare it\n', '     * to the hash that was originally given when safeguarding the transaction. \n', '     * \n', '     * @param _password The password that was originally hashed for this safeguarded value.\n', '     * @param _originAddress The address where this safeguarded value was received from.\n', '     * @return true Usefull if this method is called from a contract.\n', '     */ \n', '    function Retrieve(string _password, address _originAddress) external \n', '    isAddress(_originAddress) \n', '    onlyPayloadSize(2*32)\n', '    returns(bool)\n', '    {\n', '        \n', '        // Re-create the _originAddressHash that was given when transferring to this contract.\n', "        // Either the sender's address was hashed (and allows to retrieve from any address) or \n", "        // the receiver's address was hashed (more private, but only allows to retrieve from that address).\n", '        bytes20 _addressHash = _getOriginAddressHash(_originAddress, _password); \n', '        bytes20 _senderHash = _getOriginAddressHash(msg.sender, _password); \n', '        bytes20 _transactionHash;\n', '        uint256 _randomPercentage; // used to make a receiver hashed transaction more private.\n', '        uint256 _month = 30 * 24 * 60 * 60;\n', '        \n', "        // Check if the given '_originAddress' is the same as the address that transferred to this contract.\n", '        // We do this to prevent people simply giving any hash.\n', '        if (_originAddress == senders[_addressHash]) { // Public Transaction, hashed with originating address.\n', '            \n', "            // Anybody with the password and the sender's address\n", '            _transactionHash = _addressHash;\n', '            \n', '        } \n', '        else if (msg.sender == senders[_addressHash] && timers[_addressHash].add(_month) < now ) { // Private transaction, retrieve by sender after a month delay. \n', '            \n', '            // Allow a sender to retrieve his transfer, only a month after the timelock expired \n', '            _transactionHash = _addressHash;\n', '            \n', '        }\n', '        else { // Private transaction, hashed with receivers address\n', '            \n', '            // Allow a pre-defined receiver to retrieve.\n', '            _transactionHash = _senderHash;\n', '        }\n', '        \n', "        // Check if the _transactionHash exists and this balance hasn't been received already.\n", '        // We would normally do this with a require(), but to keep it more private we need the \n', '        // method to be executed also if it will not result.\n', '        if (balances[_transactionHash] == 0) {\n', '            emit RetrieveSuccess(0);\n', '            return false;    \n', '        }\n', '        \n', '        // Check if this SafeGuard has a timelock and if it already has expired.\n', '        // In case the transaction was sent to a pre-defined address, the sender can retrieve the transaction 1 month after it expired.\n', '        // We would normally do this with a require(), but to keep it more private we need the \n', '        // method to be executed also if it will not result.\n', '        if (timers[_transactionHash] > now ) {\n', '            emit RetrieveSuccess(0);\n', '            return false;\n', '        }\n', '        \n', '        // Prepare to transfer the balance out.\n', '        uint256 _balance = balances[_transactionHash];\n', '        balances[_transactionHash] = 0;\n', '        \n', '        // Check if the sender allowed for a deviation (up or down) of the value to make tracking harder.\n', '        // To do this we need to randomize the balance a little so it\n', '        // become less traceable: To make the tracement harder, we will calculate an \n', '        // additional random commission between 0 and the allowed deviation which can be added to or substracted from \n', "        // this transfer's balance so the outgoing value is randomized.\n", '        if (privacyDeviation[_transactionHash] > 0) {\n', '             _randomPercentage = _randomize(now, privacyDeviation[_transactionHash]);\n', '        }\n', '        \n', '        if(_randomPercentage > 0) {\n', '            // Calculate the privacy commissions amount in wei.\n', '            uint256 _privacyCommission = _balance.div(10000).mul(_randomPercentage);\n', '            \n', '            // Check integrity of privacyFund\n', '            if (userBalance.add(privacyFund) > address(this).balance) {\n', '                privacyFund = 0;\n', '            }\n', '            \n', '            // Check if we have enough availability in the privacy fund to add to this Retrieve\n', '            if (_privacyCommission <= privacyFund) {\n', '                // we have enough funds to add\n', '                 privacyFund = privacyFund.sub(_privacyCommission);\n', '                 userBalance = userBalance.add(_privacyCommission);\n', '                _balance = _balance.add(_privacyCommission);\n', '               \n', '            } else {\n', '                // the privacy fund is not filled enough, you will contribute to it.\n', '                _balance = _balance.sub(_privacyCommission);\n', '                userBalance = userBalance.sub(_privacyCommission);\n', '                privacyFund = privacyFund.add(_privacyCommission);\n', '            }\n', '        }\n', '        \n', '        // Keep score of total user balance \n', '        userBalance = userBalance.sub(_balance);\n', '        \n', '        // Transfer the value.\n', '        msg.sender.transfer(_balance);\n', '        \n', '        // Double check that our admin is correct. If not then revert this transaction.\n', '        assert(address(this).balance >= userBalance);\n', '        \n', '        emit RetrieveSuccess(_balance);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Retrieve commissions to the Admin address. \n', '     */\n', '    function RetrieveCommissions() external OnlyByAdmin() {\n', '        // The fees are the remainder of the contract balance after the userBalance and privacyFund\n', '        // reservations have been substracted. \n', '        uint256 pendingBalance = userBalance.add(privacyFund);\n', '        uint256 commissions = address(this).balance.sub(pendingBalance);\n', '        \n', '        // Transfer the commissions.\n', '        msg.sender.transfer(commissions);\n', '        \n', '        // Double check that our admin is correct.\n', '        assert(address(this).balance >= userBalance);\n', '    } \n', '    \n', '    /**\n', '     * @dev Approve a new admin for this contract. The new admin will have to \n', '     * confirm that he is the admin. \n', '     * @param _newAdmin the new owner of the contract.\n', '     */\n', '    function setAdmin(address _newAdmin) external \n', '    OnlyByAdmin() \n', '    isAddress(_newAdmin)\n', '    isNotAdmin(_newAdmin)\n', '    onlyPayloadSize(32)\n', '    {\n', '        pendingAdmin = _newAdmin;\n', '        emit ContractAdminTransferPending(pendingAdmin, admin);\n', '    }\n', '    \n', '    /**\n', '     * @dev Let the pending admin confirm his address and become the new admin.\n', '     */ \n', '    function confirmAdmin() external\n', '    {\n', '        require(msg.sender==pendingAdmin);\n', '        address _previousAdmin = admin;\n', '        admin = pendingAdmin;\n', '        pendingAdmin = NO_ADDRESS;\n', '        \n', '        emit NewContractAdmin(admin, _previousAdmin);\n', '    }\n', '    \n', '    \n', '    /// PRIVATE METHODS ///\n', '    /**\n', '     * @dev Create a (semi) random number.\n', "     * This is not truely random, as that isn't possible in the blockchain, but \n", '     * random enough for our purpose.\n', '     * \n', '     * @param _seed Randomizing seed.\n', '     * @param _max Max value.\n', '     */\n', '    function _randomize(uint256 _seed, uint256 _max) private view returns(uint256 _return) {\n', '        _return = uint256(keccak256(_seed, block.blockhash(block.number -1), block.difficulty, block.coinbase));\n', '        return _return % _max;\n', '    }\n', '    \n', '    function _getOriginAddressHash(address _address, string _password) private pure returns(bytes20) {\n', '        string memory _addressString = toAsciiString(_address);\n', '        return ripemd160(_password,"0x",_addressString);\n', '    }\n', '    \n', '    function toAsciiString(address x) private pure returns (string) {\n', '    bytes memory s = new bytes(40);\n', '        for (uint i = 0; i < 20; i++) {\n', '            byte b = byte(uint8(uint(x) / (2**(8*(19 - i)))));\n', '            byte hi = byte(uint8(b) / 16);\n', '            byte lo = byte(uint8(b) - 16 * uint8(hi));\n', '            s[2*i] = char(hi);\n', '            s[2*i+1] = char(lo);            \n', '        }\n', '        return string(s);\n', '    }\n', '    \n', '    function char(byte b) private pure returns (byte c) {\n', '        if (b < 10) return byte(uint8(b) + 0x30);\n', '        else return byte(uint8(b) + 0x57);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
