['pragma solidity ^0.4.14;\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Four Leaf clover (FLC) Token interface \n', '// ----------------------------------------------------------------------------\n', 'contract FLC {\n', '    function create(uint units) public;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// contract WhiteListAccess\n', '// ----------------------------------------------------------------------------\n', 'contract WhiteListAccess {\n', '    \n', '    function WhiteListAccess() public {\n', '        owner = msg.sender;\n', '        whitelist[owner] = true;\n', '        whitelist[address(this)] = true;        \n', '    }\n', '    \n', '    address public owner;\n', '    mapping (address => bool) whitelist;\n', '\n', '    modifier onlyBy(address who) { require(msg.sender == who); _; }\n', '    modifier onlyOwner {require(msg.sender == owner); _;}\n', '    modifier onlyWhitelisted {require(whitelist[msg.sender]); _;}\n', '\n', '    function addToWhiteList(address trusted) public onlyOwner() {\n', '        whitelist[trusted] = true;\n', '    }\n', '\n', '    function removeFromWhiteList(address untrusted) public onlyOwner() {\n', '        whitelist[untrusted] = false;\n', '    }\n', '\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// NRB_Common contract\n', '// ----------------------------------------------------------------------------\n', 'contract NRB_Common is WhiteListAccess {\n', '    \n', '    string public name;             // contract&#39;s name\n', '    bool _init;\n', '    \n', '    function NRB_Common() public { ETH_address = 0x1; }\n', '\n', '    // Deployment\n', '    address public ETH_address;    // representation of Ether as Token (0x1)\n', '    address public FLC_address;\n', '    address public NRB_address;\n', '\n', '    function init(address _main, address _flc) public {\n', '        require(!_init);\n', '        FLC_address = _flc;\n', '        NRB_address = _main;\n', '        whitelist[NRB_address] = true;\n', '        _init = true;\n', '    }\n', '\n', '    // Debug\n', '    event Debug(string, bool);\n', '    event Debug(string, uint);\n', '    event Debug(string, uint, uint);\n', '    event Debug(string, uint, uint, uint);\n', '    event Debug(string, uint, uint, uint, uint);\n', '    event Debug(string, address);\n', '    event Debug(string, address, address);\n', '    event Debug(string, address, address, address);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// NRB_Tokens (main) contract\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract NRB_Tokens is NRB_Common {\n', '\n', '    // how much raised for each token\n', '    mapping(address => uint) raisedAmount;\n', '\n', '    mapping(address => Token) public tokens;\n', '    mapping(uint => address) public tokenlist;\n', '    uint public tokenlenth;\n', '    \n', '    struct Token {\n', '        bool registered;\n', '        bool validated;\n', '        uint index;\n', '        uint decimals;\n', '        uint nextRecord;\n', '        string name;\n', '        string symbol;\n', '        address addrs;\n', '    }\n', '\n', '    function NRB_Tokens() public {\n', '        name = "NRB_Tokens";\n', '        tokenlenth = 1;\n', '        registerAndValidateToken(ETH_address, "Ethereum", "ETH", 18, 7812500000000000);\n', '    }\n', '\n', '    function getTokenListLength() constant public returns (uint) {\n', '        return tokenlenth-1;\n', '    }\n', '\n', '    function getTokenByIndex(uint _index) constant public returns (bool, uint, uint, uint, string, string, address) {\n', '        return getTokenByAddress(tokenlist[_index]);\n', '    }\n', '\n', '    function getTokenByAddress(address _token) constant public returns (bool, uint, uint, uint, string, string, address) {\n', '        Token memory _t = tokens[_token];\n', '        return (_t.validated, _t.index, _t.decimals, _t.nextRecord, _t.name, _t.symbol, _t.addrs);\n', '    }\n', '\n', '    function getTokenAddressByIndex(uint _index) constant public returns (address) {\n', '        return tokens[tokenlist[_index]].addrs;\n', '    }\n', '\n', '    function isTokenRegistered(address _token) constant public returns (bool) {\n', '        return tokens[_token].registered;\n', '    }\n', '\n', '    function registerTokenPayment(address _token, uint _value) public onlyWhitelisted() {\n', '        raisedAmount[_token] = raisedAmount[_token] + _value;\n', '    }\n', '\n', '    function registerAndValidateToken(address _token, string _name, string _symbol, uint _decimals, uint _nextRecord) public onlyOwner() {\n', '        registerToken(_token, _name, _symbol, _decimals, _nextRecord);\n', '        tokens[_token].validated = true;\n', '    }\n', '\n', '    function registerToken(address _token, string _name, string _symbol, uint _decimals, uint _nextRecord) public onlyWhitelisted() {\n', '        require(!tokens[_token].validated);\n', '        if (_token != ETH_address) {\n', '            require(ERC20Interface(_token).totalSupply() > 0);\n', '            require(ERC20Interface(_token).balanceOf(address(this)) == 0);\n', '        }\n', '        tokens[_token].validated = false;\n', '        tokens[_token].registered = true;\n', '        tokens[_token].addrs = _token;\n', '        tokens[_token].name = _name;\n', '        tokens[_token].symbol = _symbol;\n', '        tokens[_token].decimals = _decimals;\n', '        tokens[_token].index = tokenlenth;\n', '        tokens[_token].nextRecord = _nextRecord;\n', '        tokenlist[tokenlenth] = _token;\n', '        tokenlenth++;\n', '    }\n', '\n', '    function validateToken(address _token, bool _valid) public onlyOwner() {\n', '        tokens[_token].validated = _valid;\n', '    }\n', '\n', '    function sendFLC(address user, address token, uint totalpaid) public onlyWhitelisted() returns (uint) {\n', '        uint flc = 0;\n', '        uint next = 0;\n', '        (flc, next) = calculateFLCCore(token, totalpaid);\n', '        if (flc > 0) {\n', '            tokens[token].nextRecord = next;\n', '            FLC(FLC_address).create(flc);\n', '            ERC20Interface(FLC_address).transfer(user, flc);\n', '        }\n', '        return flc;\n', '    }\n', '\n', '    function calculateFLC(address token, uint totalpaid) constant public returns (uint) {\n', '        uint flc = 0;\n', '        uint next = 0;\n', '        (flc, next) = calculateFLCCore(token, totalpaid);\n', '        return flc;\n', '    }\n', '\n', '    function calculateFLCCore(address token, uint totalpaid) constant public returns (uint, uint) {\n', '        uint next = tokens[token].nextRecord;\n', '        uint flc = 0;\n', '        while (next <= totalpaid) {\n', '            next = next * 2;\n', '            flc++;\n', '        }\n', '        return (flc, next);\n', '    }\n', '\n', '    // recover tokens sent accidentally\n', '    function _withdrawal(address _token) public {\n', '        uint _balance =  ERC20Interface(_token).balanceOf(address(this));\n', '        if (_balance > 0) {\n', '            ERC20Interface(_token).transfer(owner, _balance);\n', '        }\n', '    }\n', '    \n', '    // Don&#39;t accept ETH\n', '    function () public payable {\n', '        revert();\n', '    }\n', '}']
['pragma solidity ^0.4.14;\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Four Leaf clover (FLC) Token interface \n', '// ----------------------------------------------------------------------------\n', 'contract FLC {\n', '    function create(uint units) public;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// contract WhiteListAccess\n', '// ----------------------------------------------------------------------------\n', 'contract WhiteListAccess {\n', '    \n', '    function WhiteListAccess() public {\n', '        owner = msg.sender;\n', '        whitelist[owner] = true;\n', '        whitelist[address(this)] = true;        \n', '    }\n', '    \n', '    address public owner;\n', '    mapping (address => bool) whitelist;\n', '\n', '    modifier onlyBy(address who) { require(msg.sender == who); _; }\n', '    modifier onlyOwner {require(msg.sender == owner); _;}\n', '    modifier onlyWhitelisted {require(whitelist[msg.sender]); _;}\n', '\n', '    function addToWhiteList(address trusted) public onlyOwner() {\n', '        whitelist[trusted] = true;\n', '    }\n', '\n', '    function removeFromWhiteList(address untrusted) public onlyOwner() {\n', '        whitelist[untrusted] = false;\n', '    }\n', '\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// NRB_Common contract\n', '// ----------------------------------------------------------------------------\n', 'contract NRB_Common is WhiteListAccess {\n', '    \n', "    string public name;             // contract's name\n", '    bool _init;\n', '    \n', '    function NRB_Common() public { ETH_address = 0x1; }\n', '\n', '    // Deployment\n', '    address public ETH_address;    // representation of Ether as Token (0x1)\n', '    address public FLC_address;\n', '    address public NRB_address;\n', '\n', '    function init(address _main, address _flc) public {\n', '        require(!_init);\n', '        FLC_address = _flc;\n', '        NRB_address = _main;\n', '        whitelist[NRB_address] = true;\n', '        _init = true;\n', '    }\n', '\n', '    // Debug\n', '    event Debug(string, bool);\n', '    event Debug(string, uint);\n', '    event Debug(string, uint, uint);\n', '    event Debug(string, uint, uint, uint);\n', '    event Debug(string, uint, uint, uint, uint);\n', '    event Debug(string, address);\n', '    event Debug(string, address, address);\n', '    event Debug(string, address, address, address);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// NRB_Tokens (main) contract\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract NRB_Tokens is NRB_Common {\n', '\n', '    // how much raised for each token\n', '    mapping(address => uint) raisedAmount;\n', '\n', '    mapping(address => Token) public tokens;\n', '    mapping(uint => address) public tokenlist;\n', '    uint public tokenlenth;\n', '    \n', '    struct Token {\n', '        bool registered;\n', '        bool validated;\n', '        uint index;\n', '        uint decimals;\n', '        uint nextRecord;\n', '        string name;\n', '        string symbol;\n', '        address addrs;\n', '    }\n', '\n', '    function NRB_Tokens() public {\n', '        name = "NRB_Tokens";\n', '        tokenlenth = 1;\n', '        registerAndValidateToken(ETH_address, "Ethereum", "ETH", 18, 7812500000000000);\n', '    }\n', '\n', '    function getTokenListLength() constant public returns (uint) {\n', '        return tokenlenth-1;\n', '    }\n', '\n', '    function getTokenByIndex(uint _index) constant public returns (bool, uint, uint, uint, string, string, address) {\n', '        return getTokenByAddress(tokenlist[_index]);\n', '    }\n', '\n', '    function getTokenByAddress(address _token) constant public returns (bool, uint, uint, uint, string, string, address) {\n', '        Token memory _t = tokens[_token];\n', '        return (_t.validated, _t.index, _t.decimals, _t.nextRecord, _t.name, _t.symbol, _t.addrs);\n', '    }\n', '\n', '    function getTokenAddressByIndex(uint _index) constant public returns (address) {\n', '        return tokens[tokenlist[_index]].addrs;\n', '    }\n', '\n', '    function isTokenRegistered(address _token) constant public returns (bool) {\n', '        return tokens[_token].registered;\n', '    }\n', '\n', '    function registerTokenPayment(address _token, uint _value) public onlyWhitelisted() {\n', '        raisedAmount[_token] = raisedAmount[_token] + _value;\n', '    }\n', '\n', '    function registerAndValidateToken(address _token, string _name, string _symbol, uint _decimals, uint _nextRecord) public onlyOwner() {\n', '        registerToken(_token, _name, _symbol, _decimals, _nextRecord);\n', '        tokens[_token].validated = true;\n', '    }\n', '\n', '    function registerToken(address _token, string _name, string _symbol, uint _decimals, uint _nextRecord) public onlyWhitelisted() {\n', '        require(!tokens[_token].validated);\n', '        if (_token != ETH_address) {\n', '            require(ERC20Interface(_token).totalSupply() > 0);\n', '            require(ERC20Interface(_token).balanceOf(address(this)) == 0);\n', '        }\n', '        tokens[_token].validated = false;\n', '        tokens[_token].registered = true;\n', '        tokens[_token].addrs = _token;\n', '        tokens[_token].name = _name;\n', '        tokens[_token].symbol = _symbol;\n', '        tokens[_token].decimals = _decimals;\n', '        tokens[_token].index = tokenlenth;\n', '        tokens[_token].nextRecord = _nextRecord;\n', '        tokenlist[tokenlenth] = _token;\n', '        tokenlenth++;\n', '    }\n', '\n', '    function validateToken(address _token, bool _valid) public onlyOwner() {\n', '        tokens[_token].validated = _valid;\n', '    }\n', '\n', '    function sendFLC(address user, address token, uint totalpaid) public onlyWhitelisted() returns (uint) {\n', '        uint flc = 0;\n', '        uint next = 0;\n', '        (flc, next) = calculateFLCCore(token, totalpaid);\n', '        if (flc > 0) {\n', '            tokens[token].nextRecord = next;\n', '            FLC(FLC_address).create(flc);\n', '            ERC20Interface(FLC_address).transfer(user, flc);\n', '        }\n', '        return flc;\n', '    }\n', '\n', '    function calculateFLC(address token, uint totalpaid) constant public returns (uint) {\n', '        uint flc = 0;\n', '        uint next = 0;\n', '        (flc, next) = calculateFLCCore(token, totalpaid);\n', '        return flc;\n', '    }\n', '\n', '    function calculateFLCCore(address token, uint totalpaid) constant public returns (uint, uint) {\n', '        uint next = tokens[token].nextRecord;\n', '        uint flc = 0;\n', '        while (next <= totalpaid) {\n', '            next = next * 2;\n', '            flc++;\n', '        }\n', '        return (flc, next);\n', '    }\n', '\n', '    // recover tokens sent accidentally\n', '    function _withdrawal(address _token) public {\n', '        uint _balance =  ERC20Interface(_token).balanceOf(address(this));\n', '        if (_balance > 0) {\n', '            ERC20Interface(_token).transfer(owner, _balance);\n', '        }\n', '    }\n', '    \n', "    // Don't accept ETH\n", '    function () public payable {\n', '        revert();\n', '    }\n', '}']
