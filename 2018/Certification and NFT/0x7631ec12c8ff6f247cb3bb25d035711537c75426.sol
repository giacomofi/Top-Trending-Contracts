['pragma solidity 0.4.21;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract tokenRecipient {\n', '    event receivedEther(address sender, uint amount);\n', '    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);\n', '\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n', '        Token t = Token(_token);\n', '        require(t.transferFrom(_from, this, _value));\n', '        receivedTokens(_from, _value, _token, _extraData);\n', '    }\n', '\n', '    function () payable public {\n', '        receivedEther(msg.sender, msg.value);\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    mapping (address => uint256) public balanceOf;\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', '/**\n', ' * The shareholder association contract itself\n', ' */\n', 'contract QuantumGoldDAO is Ownable, tokenRecipient {\n', '\n', '    uint public minimumQuorum;\n', '    uint public debatingPeriodInMinutes;\n', '    Proposal[] public proposals;\n', '    uint public numProposals;\n', '    Token public sharesTokenAddress;\n', '\n', '    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);\n', '    event Voted(uint proposalID, bool position, address voter);\n', '    event ProposalTallied(uint proposalID, uint result, uint quorum, bool active);\n', '    event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, address newSharesTokenAddress);\n', '\n', '    struct Proposal {\n', '        address recipient;\n', '        uint amount;\n', '        string description;\n', '        uint minExecutionDate;\n', '        bool executed;\n', '        bool proposalPassed;\n', '        uint numberOfVotes;\n', '        bytes32 proposalHash;\n', '        Vote[] votes;\n', '        mapping (address => bool) voted;\n', '    }\n', '\n', '    struct Vote {\n', '        bool inSupport;\n', '        address voter;\n', '    }\n', '\n', '    // Modifier that allows only shareholders to vote and create new proposals\n', '    modifier onlyShareholders {\n', '        require(sharesTokenAddress.balanceOf(msg.sender) > 0);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Constructor function\n', '     *\n', '     * First time setup\n', '     */\n', '    function QuantumGoldDAO(Token sharesAddress, uint minimumSharesToPassAVote, uint minutesForDebate) payable public {\n', '        changeVotingRules(sharesAddress, minimumSharesToPassAVote, minutesForDebate);\n', '    }\n', '\n', '    /**\n', '     * Change voting rules\n', '     *\n', '     * Make so that proposals need to be discussed for at least `minutesForDebate/60` hours\n', '     * and all voters combined must own more than `minimumSharesToPassAVote` shares of token `sharesAddress` to be executed\n', '     *\n', '     * @param sharesAddress token address\n', '     * @param minimumSharesToPassAVote proposal can vote only if the sum of shares held by all voters exceed this number\n', '     * @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed\n', '     */\n', '    function changeVotingRules(Token sharesAddress, uint minimumSharesToPassAVote, uint minutesForDebate) onlyOwner public {\n', '        sharesTokenAddress = Token(sharesAddress);\n', '        if (minimumSharesToPassAVote == 0 ) minimumSharesToPassAVote = 1;\n', '        minimumQuorum = minimumSharesToPassAVote;\n', '        debatingPeriodInMinutes = minutesForDebate;\n', '        ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, sharesTokenAddress);\n', '    }\n', '    \n', '    /**\n', '     * Add Proposal\n', '     *\n', '     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n', '     *\n', '     * @param beneficiary who to send the ether to\n', '     * @param weiAmount amount of ether to send, in wei\n', '     * @param jobDescription Description of job\n', '     * @param transactionBytecode bytecode of transaction\n', '     */\n', '    function newProposal(\n', '        address beneficiary,\n', '        uint weiAmount,\n', '        string jobDescription,\n', '        bytes transactionBytecode\n', '    )\n', '        onlyShareholders public\n', '        returns (uint proposalID)\n', '    {\n', '        proposalID = proposals.length++;\n', '        Proposal storage p = proposals[proposalID];\n', '        p.recipient = beneficiary;\n', '        p.amount = weiAmount;\n', '        p.description = jobDescription;\n', '        p.proposalHash = keccak256(beneficiary, weiAmount, transactionBytecode);\n', '        p.minExecutionDate = now + debatingPeriodInMinutes * 1 minutes;\n', '        p.executed = false;\n', '        p.proposalPassed = false;\n', '        p.numberOfVotes = 0;\n', '        ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);\n', '        numProposals = proposalID+1;\n', '\n', '        return proposalID;\n', '    }\n', '\n', '    /**\n', '     * Add proposal in Ether\n', '     *\n', '     * Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n', '     * This is a convenience function to use if the amount to be given is in round number of ether units.\n', '     *\n', '     * @param beneficiary who to send the ether to\n', '     * @param etherAmount amount of ether to send\n', '     * @param jobDescription Description of job\n', '     * @param transactionBytecode bytecode of transaction\n', '     */\n', '    function newProposalInEther(\n', '        address beneficiary,\n', '        uint etherAmount,\n', '        string jobDescription,\n', '        bytes transactionBytecode\n', '    )\n', '        onlyShareholders public\n', '        returns (uint proposalID)\n', '    {\n', '        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);\n', '    }\n', '\n', '    /**\n', '     * Check if a proposal code matches\n', '     *\n', '     * @param proposalNumber ID number of the proposal to query\n', '     * @param beneficiary who to send the ether to\n', '     * @param weiAmount amount of ether to send\n', '     * @param transactionBytecode bytecode of transaction\n', '     */\n', '    function checkProposalCode(\n', '        uint proposalNumber,\n', '        address beneficiary,\n', '        uint weiAmount,\n', '        bytes transactionBytecode\n', '    )\n', '        constant public\n', '        returns (bool codeChecksOut)\n', '    {\n', '        Proposal storage p = proposals[proposalNumber];\n', '        return p.proposalHash == keccak256(beneficiary, weiAmount, transactionBytecode);\n', '    }\n', '\n', '    /**\n', '     * Log a vote for a proposal\n', '     *\n', '     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`\n', '     *\n', '     * @param proposalNumber number of proposal\n', '     * @param supportsProposal either in favor or against it\n', '     */\n', '    function vote(\n', '        uint proposalNumber,\n', '        bool supportsProposal\n', '    )\n', '        onlyShareholders public\n', '        returns (uint voteID)\n', '    {\n', '        Proposal storage p = proposals[proposalNumber];\n', '        require(p.voted[msg.sender] != true);\n', '\n', '        voteID = p.votes.length++;\n', '        p.votes[voteID] = Vote({inSupport: supportsProposal, voter: msg.sender});\n', '        p.voted[msg.sender] = true;\n', '        p.numberOfVotes = voteID +1;\n', '        Voted(proposalNumber,  supportsProposal, msg.sender);\n', '        return voteID;\n', '    }\n', '\n', '    /**\n', '     * Finish vote\n', '     *\n', '     * Count the votes proposal #`proposalNumber` and execute it if approved\n', '     *\n', '     * @param proposalNumber proposal number\n', '     * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it\n', '     */\n', '    function executeProposal(uint proposalNumber, bytes transactionBytecode) public {\n', '        Proposal storage p = proposals[proposalNumber];\n', '\n', '        require(now > p.minExecutionDate                                             // If it is past the voting deadline\n', '            && !p.executed                                                          // and it has not already been executed\n', '            && p.proposalHash == keccak256(p.recipient, p.amount, transactionBytecode)); // and the supplied code matches the proposal...\n', '\n', '\n', '        // ...then tally the results\n', '        uint quorum = 0;\n', '        uint yea = 0;\n', '        uint nay = 0;\n', '\n', '        for (uint i = 0; i <  p.votes.length; ++i) {\n', '            Vote storage v = p.votes[i];\n', '            uint voteWeight = sharesTokenAddress.balanceOf(v.voter);\n', '            quorum += voteWeight;\n', '            if (v.inSupport) {\n', '                yea += voteWeight;\n', '            } else {\n', '                nay += voteWeight;\n', '            }\n', '        }\n', '\n', '        require(quorum >= minimumQuorum); // Check if a minimum quorum has been reached\n', '\n', '        if (yea > nay ) {\n', '            // Proposal passed; execute the transaction\n', '\n', '            p.executed = true;\n', '            require(p.recipient.call.value(p.amount)(transactionBytecode));\n', '\n', '            p.proposalPassed = true;\n', '        } else {\n', '            // Proposal failed\n', '            p.proposalPassed = false;\n', '        }\n', '\n', '        // Fire Events\n', '        ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed);\n', '    }\n', '}']