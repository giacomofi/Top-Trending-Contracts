['//File: contracts/acl/IACL.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', 'interface IACL {\n', '    function initialize(address permissionsCreator) public;\n', '    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n', '}\n', '\n', '//File: contracts/kernel/IKernel.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', 'interface IKernel {\n', '    event SetApp(bytes32 indexed namespace, bytes32 indexed name, bytes32 indexed id, address app);\n', '\n', '    function acl() public view returns (IACL);\n', '    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n', '\n', '    function setApp(bytes32 namespace, bytes32 name, address app) public returns (bytes32 id);\n', '    function getApp(bytes32 id) public view returns (address);\n', '}\n', '//File: contracts/kernel/KernelStorage.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', 'contract KernelConstants {\n', '    bytes32 constant public CORE_NAMESPACE = keccak256("core");\n', '    bytes32 constant public APP_BASES_NAMESPACE = keccak256("base");\n', '    bytes32 constant public APP_ADDR_NAMESPACE = keccak256("app");\n', '\n', '    bytes32 constant public KERNEL_APP_ID = keccak256("kernel.aragonpm.eth");\n', '    bytes32 constant public KERNEL_APP = keccak256(CORE_NAMESPACE, KERNEL_APP_ID);\n', '\n', '    bytes32 constant public ACL_APP_ID = keccak256("acl.aragonpm.eth");\n', '    bytes32 constant public ACL_APP = keccak256(APP_ADDR_NAMESPACE, ACL_APP_ID);\n', '}\n', '\n', '\n', 'contract KernelStorage is KernelConstants {\n', '    mapping (bytes32 => address) public apps;\n', '}\n', '\n', '//File: contracts/acl/ACLSyntaxSugar.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', 'contract ACLSyntaxSugar {\n', '    function arr() internal pure returns (uint256[] r) {}\n', '\n', '    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a));\n', '    }\n', '\n', '    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b));\n', '    }\n', '\n', '    function arr(address _a) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a));\n', '    }\n', '\n', '    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b));\n', '    }\n', '\n', '    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), _b, _c);\n', '    }\n', '\n', '    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b));\n', '    }\n', '\n', '    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n', '    }\n', '\n', '    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b), uint256(_c));\n', '    }\n', '\n', '    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b), uint256(_c));\n', '    }\n', '\n', '    function arr(uint256 _a) internal pure returns (uint256[] r) {\n', '        r = new uint256[](1);\n', '        r[0] = _a;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n', '        r = new uint256[](2);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n', '        r = new uint256[](3);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '        r[2] = _c;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n', '        r = new uint256[](4);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '        r[2] = _c;\n', '        r[3] = _d;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n', '        r = new uint256[](5);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '        r[2] = _c;\n', '        r[3] = _d;\n', '        r[4] = _e;\n', '    }\n', '}\n', '\n', '\n', 'contract ACLHelpers {\n', '    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n', '        return uint8(_x >> (8 * 30));\n', '    }\n', '\n', '    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n', '        return uint8(_x >> (8 * 31));\n', '    }\n', '\n', '    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n', '        a = uint32(_x);\n', '        b = uint32(_x >> (8 * 4));\n', '        c = uint32(_x >> (8 * 8));\n', '    }\n', '}\n', '\n', '//File: contracts/apps/IAppProxy.sol\n', 'pragma solidity 0.4.18;\n', '\n', 'interface IAppProxy {\n', '    function isUpgradeable() public pure returns (bool);\n', '    function getCode() public view returns (address);\n', '}\n', '\n', '//File: contracts/apps/AppStorage.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', 'contract AppStorage {\n', '    IKernel public kernel;\n', '    bytes32 public appId;\n', '    address internal pinnedCode; // used by Proxy Pinned\n', '    uint256 internal initializationBlock; // used by Initializable\n', '    uint256[95] private storageOffset; // forces App storage to start at after 100 slots\n', '    uint256 private offset;\n', '}\n', '\n', '//File: contracts/common/Initializable.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', 'contract Initializable is AppStorage {\n', '    modifier onlyInit {\n', '        require(initializationBlock == 0);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @return Block number in which the contract was initialized\n', '    */\n', '    function getInitializationBlock() public view returns (uint256) {\n', '        return initializationBlock;\n', '    }\n', '\n', '    /**\n', '    * @dev Function to be called by top level contract after initialization has finished.\n', '    */\n', '    function initialized() internal onlyInit {\n', '        initializationBlock = getBlockNumber();\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the current block number.\n', '    *      Using a function rather than `block.number` allows us to easily mock the block number in\n', '    *      tests.\n', '    */\n', '    function getBlockNumber() internal view returns (uint256) {\n', '        return block.number;\n', '    }\n', '}\n', '\n', '//File: contracts/common/DelegateProxy.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', 'contract DelegateProxy {\n', '    /**\n', '    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n', '    * @param _dst Destination address to perform the delegatecall\n', '    * @param _calldata Calldata for the delegatecall\n', '    */\n', '    function delegatedFwd(address _dst, bytes _calldata) internal {\n', '        require(isContract(_dst));\n', '        assembly {\n', '            let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n', '            let size := returndatasize\n', '\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n', '            // if the call returned error data, forward it\n', '            switch result case 0 { revert(ptr, size) }\n', '            default { return(ptr, size) }\n', '        }\n', '    }\n', '\n', '    function isContract(address _target) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(_target) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '//File: contracts/apps/AppProxyBase.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract AppProxyBase is IAppProxy, AppStorage, DelegateProxy, KernelConstants {\n', '    /**\n', '    * @dev Initialize AppProxy\n', '    * @param _kernel Reference to organization kernel for the app\n', '    * @param _appId Identifier for app\n', '    * @param _initializePayload Payload for call to be made after setup to initialize\n', '    */\n', '    function AppProxyBase(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public {\n', '        kernel = _kernel;\n', '        appId = _appId;\n', '\n', '        // Implicit check that kernel is actually a Kernel\n', '        // The EVM doesn&#39;t actually provide a way for us to make sure, but we can force a revert to\n', '        // occur if the kernel is set to 0x0 or a non-code address when we try to call a method on\n', '        // it.\n', '        address appCode = getAppBase(appId);\n', '\n', '        // If initialize payload is provided, it will be executed\n', '        if (_initializePayload.length > 0) {\n', '            require(isContract(appCode));\n', '            // Cannot make delegatecall as a delegateproxy.delegatedFwd as it\n', '            // returns ending execution context and halts contract deployment\n', '            require(appCode.delegatecall(_initializePayload));\n', '        }\n', '    }\n', '\n', '    function getAppBase(bytes32 _appId) internal view returns (address) {\n', '        return kernel.getApp(keccak256(APP_BASES_NAMESPACE, _appId));\n', '    }\n', '\n', '    function () payable public {\n', '        address target = getCode();\n', '        require(target != 0); // if app code hasn&#39;t been set yet, don&#39;t call\n', '        delegatedFwd(target, msg.data);\n', '    }\n', '}\n', '//File: contracts/apps/AppProxyUpgradeable.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', 'contract AppProxyUpgradeable is AppProxyBase {\n', '    address public pinnedCode;\n', '\n', '    /**\n', '    * @dev Initialize AppProxyUpgradeable (makes it an upgradeable Aragon app)\n', '    * @param _kernel Reference to organization kernel for the app\n', '    * @param _appId Identifier for app\n', '    * @param _initializePayload Payload for call to be made after setup to initialize\n', '    */\n', '    function AppProxyUpgradeable(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n', '             AppProxyBase(_kernel, _appId, _initializePayload) public\n', '    {\n', '\n', '    }\n', '\n', '    function getCode() public view returns (address) {\n', '        return getAppBase(appId);\n', '    }\n', '\n', '    function isUpgradeable() public pure returns (bool) {\n', '        return true;\n', '    }\n', '}\n', '\n', '//File: contracts/apps/AppProxyPinned.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', 'contract AppProxyPinned is AppProxyBase {\n', '    /**\n', '    * @dev Initialize AppProxyPinned (makes it an un-upgradeable Aragon app)\n', '    * @param _kernel Reference to organization kernel for the app\n', '    * @param _appId Identifier for app\n', '    * @param _initializePayload Payload for call to be made after setup to initialize\n', '    */\n', '    function AppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n', '             AppProxyBase(_kernel, _appId, _initializePayload) public\n', '    {\n', '        pinnedCode = getAppBase(appId);\n', '        require(pinnedCode != address(0));\n', '    }\n', '\n', '    function getCode() public view returns (address) {\n', '        return pinnedCode;\n', '    }\n', '\n', '    function isUpgradeable() public pure returns (bool) {\n', '        return false;\n', '    }\n', '\n', '    function () payable public {\n', '        delegatedFwd(getCode(), msg.data);\n', '    }\n', '}\n', '//File: contracts/factory/AppProxyFactory.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', 'contract AppProxyFactory {\n', '    event NewAppProxy(address proxy);\n', '\n', '    function newAppProxy(IKernel _kernel, bytes32 _appId) public returns (AppProxyUpgradeable) {\n', '        return newAppProxy(_kernel, _appId, new bytes(0));\n', '    }\n', '\n', '    function newAppProxy(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyUpgradeable) {\n', '        AppProxyUpgradeable proxy = new AppProxyUpgradeable(_kernel, _appId, _initializePayload);\n', '        NewAppProxy(address(proxy));\n', '        return proxy;\n', '    }\n', '\n', '    function newAppProxyPinned(IKernel _kernel, bytes32 _appId) public returns (AppProxyPinned) {\n', '        return newAppProxyPinned(_kernel, _appId, new bytes(0));\n', '    }\n', '\n', '    function newAppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyPinned) {\n', '        AppProxyPinned proxy = new AppProxyPinned(_kernel, _appId, _initializePayload);\n', '        NewAppProxy(address(proxy));\n', '        return proxy;\n', '    }\n', '}\n', '\n', '//File: contracts/kernel/Kernel.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Kernel is IKernel, KernelStorage, Initializable, AppProxyFactory, ACLSyntaxSugar {\n', '    bytes32 constant public APP_MANAGER_ROLE = keccak256("APP_MANAGER_ROLE");\n', '\n', '    /**\n', '    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n', '    * @notice Initializes a kernel instance along with its ACL and sets `_permissionsCreator` as the entity that can create other permissions\n', '    * @param _baseAcl Address of base ACL app\n', '    * @param _permissionsCreator Entity that will be given permission over createPermission\n', '    */\n', '    function initialize(address _baseAcl, address _permissionsCreator) onlyInit public {\n', '        initialized();\n', '\n', '        IACL acl = IACL(newAppProxy(this, ACL_APP_ID));\n', '\n', '        _setApp(APP_BASES_NAMESPACE, ACL_APP_ID, _baseAcl);\n', '        _setApp(APP_ADDR_NAMESPACE, ACL_APP_ID, acl);\n', '\n', '        acl.initialize(_permissionsCreator);\n', '    }\n', '\n', '    /**\n', '    * @dev Create a new instance of an app linked to this kernel and set its base\n', '    *      implementation if it was not already set\n', '    * @param _name Name of the app\n', '    * @param _appBase Address of the app&#39;s base implementation\n', '    * @return AppProxy instance\n', '    */\n', '    function newAppInstance(bytes32 _name, address _appBase) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (IAppProxy appProxy) {\n', '        _setAppIfNew(APP_BASES_NAMESPACE, _name, _appBase);\n', '        appProxy = newAppProxy(this, _name);\n', '    }\n', '\n', '    /**\n', '    * @dev Create a new pinned instance of an app linked to this kernel and set\n', '    *      its base implementation if it was not already set\n', '    * @param _name Name of the app\n', '    * @param _appBase Address of the app&#39;s base implementation\n', '    * @return AppProxy instance\n', '    */\n', '    function newPinnedAppInstance(bytes32 _name, address _appBase) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (IAppProxy appProxy) {\n', '        _setAppIfNew(APP_BASES_NAMESPACE, _name, _appBase);\n', '        appProxy = newAppProxyPinned(this, _name);\n', '    }\n', '\n', '    /**\n', '    * @dev Set the resolving address of an app instance or base implementation\n', '    * @param _namespace App namespace to use\n', '    * @param _name Name of the app\n', '    * @param _app Address of the app\n', '    * @return ID of app\n', '    */\n', '    function setApp(bytes32 _namespace, bytes32 _name, address _app) auth(APP_MANAGER_ROLE, arr(_namespace, _name)) kernelIntegrity public returns (bytes32 id) {\n', '        return _setApp(_namespace, _name, _app);\n', '    }\n', '\n', '    /**\n', '    * @dev Get the address of an app instance or base implementation\n', '    * @param _id App identifier\n', '    * @return Address of the app\n', '    */\n', '    function getApp(bytes32 _id) public view returns (address) {\n', '        return apps[_id];\n', '    }\n', '\n', '    /**\n', '    * @dev Get the installed ACL app\n', '    * @return ACL app\n', '    */\n', '    function acl() public view returns (IACL) {\n', '        return IACL(getApp(ACL_APP));\n', '    }\n', '\n', '    /**\n', '    * @dev Function called by apps to check ACL on kernel or to check permission status\n', '    * @param _who Sender of the original call\n', '    * @param _where Address of the app\n', '    * @param _what Identifier for a group of actions in app\n', '    * @param _how Extra data for ACL auth\n', '    * @return boolean indicating whether the ACL allows the role or not\n', '    */\n', '    function hasPermission(address _who, address _where, bytes32 _what, bytes _how) public view returns (bool) {\n', '        return acl().hasPermission(_who, _where, _what, _how);\n', '    }\n', '\n', '    function _setApp(bytes32 _namespace, bytes32 _name, address _app) internal returns (bytes32 id) {\n', '        id = keccak256(_namespace, _name);\n', '        apps[id] = _app;\n', '        SetApp(_namespace, _name, id, _app);\n', '    }\n', '\n', '    function _setAppIfNew(bytes32 _namespace, bytes32 _name, address _app) internal returns (bytes32 id) {\n', '        id = keccak256(_namespace, _name);\n', '\n', '        if (_app != address(0)) {\n', '            address app = getApp(id);\n', '            if (app != address(0)) {\n', '                require(app == _app);\n', '            } else {\n', '                apps[id] = _app;\n', '                SetApp(_namespace, _name, id, _app);\n', '            }\n', '        }\n', '    }\n', '\n', '    modifier auth(bytes32 _role, uint256[] memory params) {\n', '        bytes memory how;\n', '        uint256 byteLength = params.length * 32;\n', '        assembly {\n', '            how := params // forced casting\n', '            mstore(how, byteLength)\n', '        }\n', '        // Params is invalid from this point fwd\n', '        require(hasPermission(msg.sender, address(this), _role, how));\n', '        _;\n', '    }\n', '\n', '    modifier kernelIntegrity {\n', '        _; // After execution check integrity\n', '        address kernel = getApp(KERNEL_APP);\n', '        uint256 size;\n', '        assembly { size := extcodesize(kernel) }\n', '        require(size > 0);\n', '    }\n', '}\n', '\n', '//File: contracts/kernel/KernelProxy.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', 'contract KernelProxy is KernelStorage, DelegateProxy {\n', '    /**\n', '    * @dev KernelProxy is a proxy contract to a kernel implementation. The implementation\n', '    *      can update the reference, which effectively upgrades the contract\n', '    * @param _kernelImpl Address of the contract used as implementation for kernel\n', '    */\n', '    function KernelProxy(address _kernelImpl) public {\n', '        apps[keccak256(CORE_NAMESPACE, KERNEL_APP_ID)] = _kernelImpl;\n', '    }\n', '\n', '    /**\n', '    * @dev All calls made to the proxy are forwarded to the kernel implementation via a delegatecall\n', '    * @return Any bytes32 value the implementation returns\n', '    */\n', '    function () payable public {\n', '        delegatedFwd(apps[KERNEL_APP], msg.data);\n', '    }\n', '}\n', '//File: contracts/evmscript/IEVMScriptExecutor.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', 'interface IEVMScriptExecutor {\n', '    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n', '}\n', '\n', '//File: contracts/evmscript/IEVMScriptRegistry.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', 'contract EVMScriptRegistryConstants {\n', '    bytes32 constant public EVMSCRIPT_REGISTRY_APP_ID = keccak256("evmreg.aragonpm.eth");\n', '    bytes32 constant public EVMSCRIPT_REGISTRY_APP = keccak256(keccak256("app"), EVMSCRIPT_REGISTRY_APP_ID);\n', '}\n', '\n', '\n', 'interface IEVMScriptRegistry {\n', '    function addScriptExecutor(address executor) external returns (uint id);\n', '    function disableScriptExecutor(uint256 executorId) external;\n', '\n', '    function getScriptExecutor(bytes script) public view returns (address);\n', '}\n', '//File: contracts/evmscript/ScriptHelpers.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', 'library ScriptHelpers {\n', '    // To test with JS and compare with actual encoder. Maintaining for reference.\n', '    // t = function() { return IEVMScriptExecutor.at(&#39;0x4bcdd59d6c77774ee7317fc1095f69ec84421e49&#39;).contract.execScript.getData(...[].slice.call(arguments)).slice(10).match(/.{1,64}/g) }\n', '    // run = function() { return ScriptHelpers.new().then(sh => { sh.abiEncode.call(...[].slice.call(arguments)).then(a => console.log(a.slice(2).match(/.{1,64}/g)) ) }) }\n', '    // This is truly not beautiful but lets no daydream to the day solidity gets reflection features\n', '\n', '    function abiEncode(bytes _a, bytes _b, address[] _c) public pure returns (bytes d) {\n', '        return encode(_a, _b, _c);\n', '    }\n', '\n', '    function encode(bytes memory _a, bytes memory _b, address[] memory _c) internal pure returns (bytes memory d) {\n', '        // A is positioned after the 3 position words\n', '        uint256 aPosition = 0x60;\n', '        uint256 bPosition = aPosition + 32 * abiLength(_a);\n', '        uint256 cPosition = bPosition + 32 * abiLength(_b);\n', '        uint256 length = cPosition + 32 * abiLength(_c);\n', '\n', '        d = new bytes(length);\n', '        assembly {\n', '            // Store positions\n', '            mstore(add(d, 0x20), aPosition)\n', '            mstore(add(d, 0x40), bPosition)\n', '            mstore(add(d, 0x60), cPosition)\n', '        }\n', '\n', '        // Copy memory to correct position\n', '        copy(d, getPtr(_a), aPosition, _a.length);\n', '        copy(d, getPtr(_b), bPosition, _b.length);\n', '        copy(d, getPtr(_c), cPosition, _c.length * 32); // 1 word per address\n', '    }\n', '\n', '    function abiLength(bytes memory _a) internal pure returns (uint256) {\n', '        // 1 for length +\n', '        // memory words + 1 if not divisible for 32 to offset word\n', '        return 1 + (_a.length / 32) + (_a.length % 32 > 0 ? 1 : 0);\n', '    }\n', '\n', '    function abiLength(address[] _a) internal pure returns (uint256) {\n', '        // 1 for length + 1 per item\n', '        return 1 + _a.length;\n', '    }\n', '\n', '    function copy(bytes _d, uint256 _src, uint256 _pos, uint256 _length) internal pure {\n', '        uint dest;\n', '        assembly {\n', '            dest := add(add(_d, 0x20), _pos)\n', '        }\n', '        memcpy(dest, _src, _length + 32);\n', '    }\n', '\n', '    function getPtr(bytes memory _x) internal pure returns (uint256 ptr) {\n', '        assembly {\n', '            ptr := _x\n', '        }\n', '    }\n', '\n', '    function getPtr(address[] memory _x) internal pure returns (uint256 ptr) {\n', '        assembly {\n', '            ptr := _x\n', '        }\n', '    }\n', '\n', '    function getSpecId(bytes _script) internal pure returns (uint32) {\n', '        return uint32At(_script, 0);\n', '    }\n', '\n', '    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n', '        assembly {\n', '            result := mload(add(_data, add(0x20, _location)))\n', '        }\n', '    }\n', '\n', '    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {\n', '        uint256 word = uint256At(_data, _location);\n', '\n', '        assembly {\n', '            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\n', '            0x1000000000000000000000000)\n', '        }\n', '    }\n', '\n', '    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {\n', '        uint256 word = uint256At(_data, _location);\n', '\n', '        assembly {\n', '            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),\n', '            0x100000000000000000000000000000000000000000000000000000000)\n', '        }\n', '    }\n', '\n', '    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n', '        assembly {\n', '            result := add(_data, add(0x20, _location))\n', '        }\n', '    }\n', '\n', '    function toBytes(bytes4 _sig) internal pure returns (bytes) {\n', '        bytes memory payload = new bytes(4);\n', '        payload[0] = bytes1(_sig);\n', '        payload[1] = bytes1(_sig << 8);\n', '        payload[2] = bytes1(_sig << 16);\n', '        payload[3] = bytes1(_sig << 24);\n', '        return payload;\n', '    }\n', '\n', '    function memcpy(uint _dest, uint _src, uint _len) public pure {\n', '        uint256 src = _src;\n', '        uint256 dest = _dest;\n', '        uint256 len = _len;\n', '\n', '        // Copy word-length chunks while possible\n', '        for (; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '}\n', '//File: contracts/evmscript/EVMScriptRunner.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract EVMScriptRunner is AppStorage, EVMScriptRegistryConstants {\n', '    using ScriptHelpers for bytes;\n', '\n', '    function runScript(bytes _script, bytes _input, address[] _blacklist) protectState internal returns (bytes output) {\n', '        // TODO: Too much data flying around, maybe extracting spec id here is cheaper\n', '        address executorAddr = getExecutor(_script);\n', '        require(executorAddr != address(0));\n', '\n', '        bytes memory calldataArgs = _script.encode(_input, _blacklist);\n', '        bytes4 sig = IEVMScriptExecutor(0).execScript.selector;\n', '\n', '        require(executorAddr.delegatecall(sig, calldataArgs));\n', '\n', '        return returnedDataDecoded();\n', '    }\n', '\n', '    function getExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n', '        return IEVMScriptExecutor(getExecutorRegistry().getScriptExecutor(_script));\n', '    }\n', '\n', '    // TODO: Internal\n', '    function getExecutorRegistry() internal view returns (IEVMScriptRegistry) {\n', '        address registryAddr = kernel.getApp(EVMSCRIPT_REGISTRY_APP);\n', '        return IEVMScriptRegistry(registryAddr);\n', '    }\n', '\n', '    /**\n', '    * @dev copies and returns last&#39;s call data. Needs to ABI decode first\n', '    */\n', '    function returnedDataDecoded() internal view returns (bytes ret) {\n', '        assembly {\n', '            let size := returndatasize\n', '            switch size\n', '            case 0 {}\n', '            default {\n', '                ret := mload(0x40) // free mem ptr get\n', '                mstore(0x40, add(ret, add(size, 0x20))) // free mem ptr set\n', '                returndatacopy(ret, 0x20, sub(size, 0x20)) // copy return data\n', '            }\n', '        }\n', '        return ret;\n', '    }\n', '\n', '    modifier protectState {\n', '        address preKernel = kernel;\n', '        bytes32 preAppId = appId;\n', '        _; // exec\n', '        require(kernel == preKernel);\n', '        require(appId == preAppId);\n', '    }\n', '}\n', '//File: contracts/apps/AragonApp.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract AragonApp is AppStorage, Initializable, ACLSyntaxSugar, EVMScriptRunner {\n', '    modifier auth(bytes32 _role) {\n', '        require(canPerform(msg.sender, _role, new uint256[](0)));\n', '        _;\n', '    }\n', '\n', '    modifier authP(bytes32 _role, uint256[] params) {\n', '        require(canPerform(msg.sender, _role, params));\n', '        _;\n', '    }\n', '\n', '    function canPerform(address _sender, bytes32 _role, uint256[] params) public view returns (bool) {\n', '        bytes memory how; // no need to init memory as it is never used\n', '        if (params.length > 0) {\n', '            uint256 byteLength = params.length * 32;\n', '            assembly {\n', '                how := params // forced casting\n', '                mstore(how, byteLength)\n', '            }\n', '        }\n', '        return address(kernel) == 0 || kernel.hasPermission(_sender, address(this), _role, how);\n', '    }\n', '}\n', '\n', '//File: contracts/acl/ACL.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'interface ACLOracle {\n', '    function canPerform(address who, address where, bytes32 what) public view returns (bool);\n', '}\n', '\n', '\n', 'contract ACL is IACL, AragonApp, ACLHelpers {\n', '    bytes32 constant public CREATE_PERMISSIONS_ROLE = keccak256("CREATE_PERMISSIONS_ROLE");\n', '\n', '    // whether a certain entity has a permission\n', '    mapping (bytes32 => bytes32) permissions; // 0 for no permission, or parameters id\n', '    mapping (bytes32 => Param[]) public permissionParams;\n', '\n', '    // who is the manager of a permission\n', '    mapping (bytes32 => address) permissionManager;\n', '\n', '    enum Op { NONE, EQ, NEQ, GT, LT, GTE, LTE, NOT, AND, OR, XOR, IF_ELSE, RET } // op types\n', '\n', '    struct Param {\n', '        uint8 id;\n', '        uint8 op;\n', '        uint240 value; // even though value is an uint240 it can store addresses\n', '        // in the case of 32 byte hashes losing 2 bytes precision isn&#39;t a huge deal\n', '        // op and id take less than 1 byte each so it can be kept in 1 sstore\n', '    }\n', '\n', '    uint8 constant BLOCK_NUMBER_PARAM_ID = 200;\n', '    uint8 constant TIMESTAMP_PARAM_ID    = 201;\n', '    uint8 constant SENDER_PARAM_ID       = 202;\n', '    uint8 constant ORACLE_PARAM_ID       = 203;\n', '    uint8 constant LOGIC_OP_PARAM_ID     = 204;\n', '    uint8 constant PARAM_VALUE_PARAM_ID  = 205;\n', '    // TODO: Add execution times param type?\n', '\n', '    bytes32 constant public EMPTY_PARAM_HASH = keccak256(uint256(0));\n', '    address constant ANY_ENTITY = address(-1);\n', '\n', '    modifier onlyPermissionManager(address _app, bytes32 _role) {\n', '        require(msg.sender == getPermissionManager(_app, _role));\n', '        _;\n', '    }\n', '\n', '    event SetPermission(address indexed entity, address indexed app, bytes32 indexed role, bool allowed);\n', '    event ChangePermissionManager(address indexed app, bytes32 indexed role, address indexed manager);\n', '\n', '    /**\n', '    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n', '    * @notice Initializes an ACL instance and sets `_permissionsCreator` as the entity that can create other permissions\n', '    * @param _permissionsCreator Entity that will be given permission over createPermission\n', '    */\n', '    function initialize(address _permissionsCreator) onlyInit public {\n', '        initialized();\n', '        require(msg.sender == address(kernel));\n', '\n', '        _createPermission(_permissionsCreator, this, CREATE_PERMISSIONS_ROLE, _permissionsCreator);\n', '    }\n', '\n', '    /**\n', '    * @dev Creates a permission that wasn&#39;t previously set. Access is limited by the ACL.\n', '    *      If a created permission is removed it is possible to reset it with createPermission.\n', '    * @notice Create a new permission granting `_entity` the ability to perform actions of role `_role` on `_app` (setting `_manager` as the permission manager)\n', '    * @param _entity Address of the whitelisted entity that will be able to perform the role\n', '    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n', '    * @param _role Identifier for the group of actions in app given access to perform\n', '    * @param _manager Address of the entity that will be able to grant and revoke the permission further.\n', '    */\n', '    function createPermission(address _entity, address _app, bytes32 _role, address _manager) external {\n', '        require(hasPermission(msg.sender, address(this), CREATE_PERMISSIONS_ROLE));\n', '\n', '        _createPermission(_entity, _app, _role, _manager);\n', '    }\n', '\n', '    /**\n', '    * @dev Grants permission if allowed. This requires `msg.sender` to be the permission manager\n', '    * @notice Grants `_entity` the ability to perform actions of role `_role` on `_app`\n', '    * @param _entity Address of the whitelisted entity that will be able to perform the role\n', '    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n', '    * @param _role Identifier for the group of actions in app given access to perform\n', '    */\n', '    function grantPermission(address _entity, address _app, bytes32 _role)\n', '        external\n', '    {\n', '        grantPermissionP(_entity, _app, _role, new uint256[](0));\n', '    }\n', '\n', '    /**\n', '    * @dev Grants a permission with parameters if allowed. This requires `msg.sender` to be the permission manager\n', '    * @notice Grants `_entity` the ability to perform actions of role `_role` on `_app`\n', '    * @param _entity Address of the whitelisted entity that will be able to perform the role\n', '    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n', '    * @param _role Identifier for the group of actions in app given access to perform\n', '    * @param _params Permission parameters\n', '    */\n', '    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] _params)\n', '        onlyPermissionManager(_app, _role)\n', '        public\n', '    {\n', '        require(!hasPermission(_entity, _app, _role));\n', '\n', '        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;\n', '        _setPermission(_entity, _app, _role, paramsHash);\n', '    }\n', '\n', '    /**\n', '    * @dev Revokes permission if allowed. This requires `msg.sender` to be the the permission manager\n', '    * @notice Revokes `_entity` the ability to perform actions of role `_role` on `_app`\n', '    * @param _entity Address of the whitelisted entity to revoke access from\n', '    * @param _app Address of the app in which the role will be revoked\n', '    * @param _role Identifier for the group of actions in app being revoked\n', '    */\n', '    function revokePermission(address _entity, address _app, bytes32 _role)\n', '        onlyPermissionManager(_app, _role)\n', '        external\n', '    {\n', '        require(hasPermission(_entity, _app, _role));\n', '\n', '        _setPermission(_entity, _app, _role, bytes32(0));\n', '    }\n', '\n', '    /**\n', '    * @notice Sets `_newManager` as the manager of the permission `_role` in `_app`\n', '    * @param _newManager Address for the new manager\n', '    * @param _app Address of the app in which the permission management is being transferred\n', '    * @param _role Identifier for the group of actions being transferred\n', '    */\n', '    function setPermissionManager(address _newManager, address _app, bytes32 _role)\n', '        onlyPermissionManager(_app, _role)\n', '        external\n', '    {\n', '        _setPermissionManager(_newManager, _app, _role);\n', '    }\n', '\n', '    /**\n', '    * @dev Get manager for permission\n', '    * @param _app Address of the app\n', '    * @param _role Identifier for a group of actions in app\n', '    * @return address of the manager for the permission\n', '    */\n', '    function getPermissionManager(address _app, bytes32 _role) public view returns (address) {\n', '        return permissionManager[roleHash(_app, _role)];\n', '    }\n', '\n', '    /**\n', '    * @dev Function called by apps to check ACL on kernel or to check permission statu\n', '    * @param _who Sender of the original call\n', '    * @param _where Address of the app\n', '    * @param _where Identifier for a group of actions in app\n', '    * @param _how Permission parameters\n', '    * @return boolean indicating whether the ACL allows the role or not\n', '    */\n', '    function hasPermission(address _who, address _where, bytes32 _what, bytes memory _how) public view returns (bool) {\n', '        uint256[] memory how;\n', '        uint256 intsLength = _how.length / 32;\n', '        assembly {\n', '            how := _how // forced casting\n', '            mstore(how, intsLength)\n', '        }\n', '        // _how is invalid from this point fwd\n', '        return hasPermission(_who, _where, _what, how);\n', '    }\n', '\n', '    function hasPermission(address _who, address _where, bytes32 _what, uint256[] memory _how) public view returns (bool) {\n', '        bytes32 whoParams = permissions[permissionHash(_who, _where, _what)];\n', '        if (whoParams != bytes32(0) && evalParams(whoParams, _who, _where, _what, _how)) {\n', '            return true;\n', '        }\n', '\n', '        bytes32 anyParams = permissions[permissionHash(ANY_ENTITY, _where, _what)];\n', '        if (anyParams != bytes32(0) && evalParams(anyParams, ANY_ENTITY, _where, _what, _how)) {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function hasPermission(address _who, address _where, bytes32 _what) public view returns (bool) {\n', '        uint256[] memory empty = new uint256[](0);\n', '        return hasPermission(_who, _where, _what, empty);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal createPermission for access inside the kernel (on instantiation)\n', '    */\n', '    function _createPermission(address _entity, address _app, bytes32 _role, address _manager) internal {\n', '        // only allow permission creation (or re-creation) when there is no manager\n', '        require(getPermissionManager(_app, _role) == address(0));\n', '\n', '        _setPermission(_entity, _app, _role, EMPTY_PARAM_HASH);\n', '        _setPermissionManager(_manager, _app, _role);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function called to actually save the permission\n', '    */\n', '    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {\n', '        permissions[permissionHash(_entity, _app, _role)] = _paramsHash;\n', '\n', '        SetPermission(_entity, _app, _role, _paramsHash != bytes32(0));\n', '    }\n', '\n', '    function _saveParams(uint256[] _encodedParams) internal returns (bytes32) {\n', '        bytes32 paramHash = keccak256(_encodedParams);\n', '        Param[] storage params = permissionParams[paramHash];\n', '\n', '        if (params.length == 0) { // params not saved before\n', '            for (uint256 i = 0; i < _encodedParams.length; i++) {\n', '                uint256 encodedParam = _encodedParams[i];\n', '                Param memory param = Param(decodeParamId(encodedParam), decodeParamOp(encodedParam), uint240(encodedParam));\n', '                params.push(param);\n', '            }\n', '        }\n', '\n', '        return paramHash;\n', '    }\n', '\n', '    function evalParams(\n', '        bytes32 _paramsHash,\n', '        address _who,\n', '        address _where,\n', '        bytes32 _what,\n', '        uint256[] _how\n', '    ) internal view returns (bool)\n', '    {\n', '        if (_paramsHash == EMPTY_PARAM_HASH) {\n', '            return true;\n', '        }\n', '\n', '        return evalParam(_paramsHash, 0, _who, _where, _what, _how);\n', '    }\n', '\n', '    function evalParam(\n', '        bytes32 _paramsHash,\n', '        uint32 _paramId,\n', '        address _who,\n', '        address _where,\n', '        bytes32 _what,\n', '        uint256[] _how\n', '    ) internal view returns (bool)\n', '    {\n', '        if (_paramId >= permissionParams[_paramsHash].length) {\n', '            return false; // out of bounds\n', '        }\n', '\n', '        Param memory param = permissionParams[_paramsHash][_paramId];\n', '\n', '        if (param.id == LOGIC_OP_PARAM_ID) {\n', '            return evalLogic(param, _paramsHash, _who, _where, _what, _how);\n', '        }\n', '\n', '        uint256 value;\n', '        uint256 comparedTo = uint256(param.value);\n', '\n', '        // get value\n', '        if (param.id == ORACLE_PARAM_ID) {\n', '            value = ACLOracle(param.value).canPerform(_who, _where, _what) ? 1 : 0;\n', '            comparedTo = 1;\n', '        } else if (param.id == BLOCK_NUMBER_PARAM_ID) {\n', '            value = blockN();\n', '        } else if (param.id == TIMESTAMP_PARAM_ID) {\n', '            value = time();\n', '        } else if (param.id == SENDER_PARAM_ID) {\n', '            value = uint256(msg.sender);\n', '        } else if (param.id == PARAM_VALUE_PARAM_ID) {\n', '            value = uint256(param.value);\n', '        } else {\n', '            if (param.id >= _how.length) {\n', '                return false;\n', '            }\n', '            value = uint256(uint240(_how[param.id])); // force lost precision\n', '        }\n', '\n', '        if (Op(param.op) == Op.RET) {\n', '            return uint256(value) > 0;\n', '        }\n', '\n', '        return compare(value, Op(param.op), comparedTo);\n', '    }\n', '\n', '    function evalLogic(Param _param, bytes32 _paramsHash, address _who, address _where, bytes32 _what, uint256[] _how) internal view returns (bool) {\n', '        if (Op(_param.op) == Op.IF_ELSE) {\n', '            var (condition, success, failure) = decodeParamsList(uint256(_param.value));\n', '            bool result = evalParam(_paramsHash, condition, _who, _where, _what, _how);\n', '\n', '            return evalParam(_paramsHash, result ? success : failure, _who, _where, _what, _how);\n', '        }\n', '\n', '        var (v1, v2,) = decodeParamsList(uint256(_param.value));\n', '        bool r1 = evalParam(_paramsHash, v1, _who, _where, _what, _how);\n', '\n', '        if (Op(_param.op) == Op.NOT) {\n', '            return !r1;\n', '        }\n', '\n', '        if (r1 && Op(_param.op) == Op.OR) {\n', '            return true;\n', '        }\n', '\n', '        if (!r1 && Op(_param.op) == Op.AND) {\n', '            return false;\n', '        }\n', '\n', '        bool r2 = evalParam(_paramsHash, v2, _who, _where, _what, _how);\n', '\n', '        if (Op(_param.op) == Op.XOR) {\n', '            return (r1 && !r2) || (!r1 && r2);\n', '        }\n', '\n', '        return r2; // both or and and depend on result of r2 after checks\n', '    }\n', '\n', '    function compare(uint256 _a, Op _op, uint256 _b) internal pure returns (bool) {\n', '        if (_op == Op.EQ)  return _a == _b;                              // solium-disable-line lbrace\n', '        if (_op == Op.NEQ) return _a != _b;                              // solium-disable-line lbrace\n', '        if (_op == Op.GT)  return _a > _b;                               // solium-disable-line lbrace\n', '        if (_op == Op.LT)  return _a < _b;                               // solium-disable-line lbrace\n', '        if (_op == Op.GTE) return _a >= _b;                              // solium-disable-line lbrace\n', '        if (_op == Op.LTE) return _a <= _b;                              // solium-disable-line lbrace\n', '        return false;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function that sets management\n', '    */\n', '    function _setPermissionManager(address _newManager, address _app, bytes32 _role) internal {\n', '        permissionManager[roleHash(_app, _role)] = _newManager;\n', '        ChangePermissionManager(_app, _role, _newManager);\n', '    }\n', '\n', '    function roleHash(address _where, bytes32 _what) pure internal returns (bytes32) {\n', '        return keccak256(uint256(1), _where, _what);\n', '    }\n', '\n', '    function permissionHash(address _who, address _where, bytes32 _what) pure internal returns (bytes32) {\n', '        return keccak256(uint256(2), _who, _where, _what);\n', '    }\n', '\n', '    function time() internal view returns (uint64) { return uint64(block.timestamp); } // solium-disable-line security/no-block-members\n', '\n', '    function blockN() internal view returns (uint256) { return block.number; }\n', '}\n', '\n', '//File: contracts/evmscript/EVMScriptRegistry.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract EVMScriptRegistry is IEVMScriptRegistry, EVMScriptRegistryConstants, AragonApp {\n', '    using ScriptHelpers for bytes;\n', '\n', '    // WARN: Manager can censor all votes and the like happening in an org\n', '    bytes32 constant public REGISTRY_MANAGER_ROLE = bytes32(1);\n', '\n', '    struct ExecutorEntry {\n', '        address executor;\n', '        bool enabled;\n', '    }\n', '\n', '    ExecutorEntry[] public executors;\n', '\n', '    function initialize() onlyInit public {\n', '        initialized();\n', '        // Create empty record to begin executor IDs at 1\n', '        executors.push(ExecutorEntry(address(0), false));\n', '    }\n', '\n', '    function addScriptExecutor(address _executor) external auth(REGISTRY_MANAGER_ROLE) returns (uint id) {\n', '        return executors.push(ExecutorEntry(_executor, true));\n', '    }\n', '\n', '    function disableScriptExecutor(uint256 _executorId) external auth(REGISTRY_MANAGER_ROLE) {\n', '        executors[_executorId].enabled = false;\n', '    }\n', '\n', '    function getScriptExecutor(bytes _script) public view returns (address) {\n', '        uint256 id = _script.getSpecId();\n', '\n', '        if (id == 0 || id >= executors.length) {\n', '            return address(0);\n', '        }\n', '\n', '        ExecutorEntry storage entry = executors[id];\n', '        return entry.enabled ? entry.executor : address(0);\n', '    }\n', '}\n', '\n', '//File: contracts/evmscript/executors/CallsScript.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '// Inspired by https://github.com/reverendus/tx-manager\n', '\n', '\n', '\n', '\n', '\n', 'contract CallsScript is IEVMScriptExecutor {\n', '    using ScriptHelpers for bytes;\n', '\n', '    uint256 constant internal SCRIPT_START_LOCATION = 4;\n', '\n', '    event LogScriptCall(address indexed sender, address indexed src, address indexed dst);\n', '\n', '    /**\n', '    * @notice Executes a number of call scripts\n', '    * @param _script [ specId (uint32) ] many calls with this structure ->\n', '    *    [ to (address: 20 bytes) ] [ calldataLength (uint32: 4 bytes) ] [ calldata (calldataLength bytes) ]\n', '    * @param _input Input is ignored in callscript\n', '    * @param _blacklist Addresses the script cannot call to, or will revert.\n', '    * @return always returns empty byte array\n', '    */\n', '    function execScript(bytes _script, bytes _input, address[] _blacklist) external returns (bytes) {\n', '        uint256 location = SCRIPT_START_LOCATION; // first 32 bits are spec id\n', '        while (location < _script.length) {\n', '            address contractAddress = _script.addressAt(location);\n', '            // Check address being called is not blacklist\n', '            for (uint i = 0; i < _blacklist.length; i++) {\n', '                require(contractAddress != _blacklist[i]);\n', '            }\n', '\n', '            // logged before execution to ensure event ordering in receipt\n', '            // if failed entire execution is reverted regardless\n', '            LogScriptCall(msg.sender, address(this), contractAddress);\n', '\n', '            uint256 calldataLength = uint256(_script.uint32At(location + 0x14));\n', '            uint256 calldataStart = _script.locationOf(location + 0x14 + 0x04);\n', '\n', '            assembly {\n', '                let success := call(sub(gas, 5000), contractAddress, 0, calldataStart, calldataLength, 0, 0)\n', '                switch success case 0 { revert(0, 0) }\n', '            }\n', '\n', '            location += (0x14 + 0x04 + calldataLength);\n', '        }\n', '    }\n', '}\n', '//File: contracts/evmscript/executors/DelegateScript.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', 'interface DelegateScriptTarget {\n', '    function exec() public;\n', '}\n', '\n', '\n', 'contract DelegateScript is IEVMScriptExecutor {\n', '    using ScriptHelpers for *;\n', '\n', '    uint256 constant internal SCRIPT_START_LOCATION = 4;\n', '\n', '    /**\n', '    * @notice Executes script by delegatecall into a contract\n', '    * @param _script [ specId (uint32) ][ contract address (20 bytes) ]\n', '    * @param _input ABI encoded call to be made to contract (if empty executes default exec() function)\n', '    * @param _blacklist If any address is passed, will revert.\n', '    * @return Call return data\n', '    */\n', '    function execScript(bytes _script, bytes _input, address[] _blacklist) external returns (bytes) {\n', '        require(_blacklist.length == 0); // dont have ability to control bans, so fail.\n', '\n', '        // Script should be spec id + address (20 bytes)\n', '        require(_script.length == SCRIPT_START_LOCATION + 20);\n', '        return delegate(_script.addressAt(SCRIPT_START_LOCATION), _input);\n', '    }\n', '\n', '    /**\n', '    * @dev Delegatecall to contract with input data\n', '    */\n', '    function delegate(address _addr, bytes memory _input) internal returns (bytes memory output) {\n', '        require(isContract(_addr));\n', '        require(_addr.delegatecall(_input.length > 0 ? _input : defaultInput()));\n', '        return returnedData();\n', '    }\n', '\n', '    function isContract(address _target) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(_target) }\n', '        return size > 0;\n', '    }\n', '\n', '    function defaultInput() internal pure returns (bytes) {\n', '        return DelegateScriptTarget(0).exec.selector.toBytes();\n', '    }\n', '\n', '    /**\n', '    * @dev copies and returns last&#39;s call data\n', '    */\n', '    function returnedData() internal view returns (bytes ret) {\n', '        assembly {\n', '            let size := returndatasize\n', '            ret := mload(0x40) // free mem ptr get\n', '            mstore(0x40, add(ret, add(size, 0x20))) // free mem ptr set\n', '            mstore(ret, size) // set array length\n', '            returndatacopy(add(ret, 0x20), 0, size) // copy return data\n', '        }\n', '        return ret;\n', '    }\n', '}\n', '//File: contracts/evmscript/executors/DeployDelegateScript.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '// Inspired by: https://github.com/dapphub/ds-proxy/blob/master/src/proxy.sol\n', '\n', '\n', 'contract DeployDelegateScript is DelegateScript {\n', '    uint256 constant internal SCRIPT_START_LOCATION = 4;\n', '\n', '    mapping (bytes32 => address) cache;\n', '\n', '    /**\n', '    * @notice Executes script by delegatecall into a deployed contract (exec() function)\n', '    * @param _script [ specId (uint32) ][ contractInitcode (bytecode) ]\n', '    * @param _input ABI encoded call to be made to contract (if empty executes default exec() function)\n', '    * @param _blacklist If any address is passed, will revert.\n', '    * @return Call return data\n', '    */\n', '    function execScript(bytes _script, bytes _input, address[] _blacklist) external returns (bytes) {\n', '        require(_blacklist.length == 0); // dont have ability to control bans, so fail.\n', '\n', '        bytes32 id = keccak256(_script);\n', '        address deployed = cache[id];\n', '        if (deployed == address(0)) {\n', '            deployed = deploy(_script);\n', '            cache[id] = deployed;\n', '        }\n', '\n', '        return DelegateScript.delegate(deployed, _input);\n', '    }\n', '\n', '    /**\n', '    * @dev Deploys contract byte code to network\n', '    */\n', '    function deploy(bytes _script) internal returns (address addr) {\n', '        assembly {\n', '            // 0x24 = 0x20 (length) + 0x04 (spec id uint32)\n', '            // Length of code is 4 bytes less than total script size\n', '            addr := create(0, add(_script, 0x24), sub(mload(_script), 0x04))\n', '            switch iszero(extcodesize(addr))\n', '            case 1 { revert(0, 0) } // throw if contract failed to deploy\n', '        }\n', '    }\n', '}\n', '//File: contracts/factory/EVMScriptRegistryFactory.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract EVMScriptRegistryFactory is AppProxyFactory, EVMScriptRegistryConstants {\n', '    address public baseReg;\n', '    address public baseCalls;\n', '    address public baseDel;\n', '    address public baseDeployDel;\n', '\n', '    function EVMScriptRegistryFactory() public {\n', '        baseReg = address(new EVMScriptRegistry());\n', '        baseCalls = address(new CallsScript());\n', '        baseDel = address(new DelegateScript());\n', '        baseDeployDel = address(new DeployDelegateScript());\n', '    }\n', '\n', '    function newEVMScriptRegistry(Kernel _dao, address _root) public returns (EVMScriptRegistry reg) {\n', '        reg = EVMScriptRegistry(_dao.newPinnedAppInstance(EVMSCRIPT_REGISTRY_APP_ID, baseReg));\n', '        reg.initialize();\n', '\n', '        ACL acl = ACL(_dao.acl());\n', '\n', '        _dao.setApp(_dao.APP_ADDR_NAMESPACE(), EVMSCRIPT_REGISTRY_APP_ID, reg);\n', '        acl.createPermission(this, reg, reg.REGISTRY_MANAGER_ROLE(), this);\n', '\n', '        reg.addScriptExecutor(baseCalls);     // spec 1 = CallsScript\n', '        reg.addScriptExecutor(baseDel);       // spec 2 = DelegateScript\n', '        reg.addScriptExecutor(baseDeployDel); // spec 3 = DeployDelegateScript\n', '\n', '        acl.revokePermission(this, reg, reg.REGISTRY_MANAGER_ROLE());\n', '        acl.setPermissionManager(_root, reg, reg.REGISTRY_MANAGER_ROLE());\n', '\n', '        return reg;\n', '    }\n', '}\n', '\n', '//File: contracts/factory/DAOFactory.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract DAOFactory {\n', '    address public baseKernel;\n', '    address public baseACL;\n', '    EVMScriptRegistryFactory public regFactory;\n', '\n', '    event DeployDAO(address dao);\n', '    event DeployEVMScriptRegistry(address reg);\n', '\n', '    function DAOFactory(address _baseKernel, address _baseACL, address _regFactory) public {\n', '        // No need to init as it cannot be killed by devops199\n', '        if (_regFactory != address(0)) {\n', '            regFactory = EVMScriptRegistryFactory(_regFactory);\n', '        }\n', '\n', '        baseKernel = _baseKernel;\n', '        baseACL = _baseACL;\n', '    }\n', '\n', '    /**\n', '    * @param _root Address that will be granted control to setup DAO permissions\n', '    */\n', '    function newDAO(address _root) public returns (Kernel dao) {\n', '        dao = Kernel(new KernelProxy(baseKernel));\n', '\n', '        address initialRoot = address(regFactory) != address(0) ? this : _root;\n', '        dao.initialize(baseACL, initialRoot);\n', '\n', '        ACL acl = ACL(dao.acl());\n', '\n', '        if (address(regFactory) != address(0)) {\n', '            bytes32 permRole = acl.CREATE_PERMISSIONS_ROLE();\n', '            bytes32 appManagerRole = dao.APP_MANAGER_ROLE();\n', '\n', '            acl.grantPermission(regFactory, acl, permRole);\n', '\n', '            acl.createPermission(regFactory, dao, appManagerRole, this);\n', '\n', '            EVMScriptRegistry reg = regFactory.newEVMScriptRegistry(dao, _root);\n', '            DeployEVMScriptRegistry(address(reg));\n', '\n', '            acl.revokePermission(regFactory, dao, appManagerRole);\n', '            acl.grantPermission(_root, acl, permRole);\n', '\n', '            acl.setPermissionManager(address(0), dao, appManagerRole);\n', '            acl.setPermissionManager(_root, acl, permRole);\n', '        }\n', '\n', '        DeployDAO(dao);\n', '    }\n', '}']