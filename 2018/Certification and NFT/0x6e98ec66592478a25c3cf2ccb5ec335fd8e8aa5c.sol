['pragma solidity ^0.4.19;\n', '\n', '/*\n', '*\n', '* Domain on day 1: https://etherbonds.io/\n', '*\n', '* This contract implements bond contracts on the Ethereum blockchain\n', '* - You can buy a bond for ETH (NominalPrice)\n', '* - While buying you can set a desirable MaturityDate\n', '* - After you reach the MaturityDate you can redeem the bond for the MaturityPrice\n', '* - MaturityPrice is always greater than the NominalPrice\n', '* - greater the MaturityDate = higher profit\n', "* - You can't redeem a bond after MaxRedeemTime\n", '* \n', '* For example, you bought a bond for 1 ETH which will mature in 1 month for 63% profit.\n', '* After the month you can redeem the bond and receive your 1.63 ETH.\n', '*\n', "* If you don't want to wait for your bond maturity you can sell it to another investor. \n", '* For example you bought a 1 year bond, 6 months have passed and you urgently need money. \n', '* You can sell the bond on a secondary market to other investors before the maturity date.\n', '* You can also redeem your bond prematurely but only for a part of the nominal price.\n', '*\n', '* !!! THIS IS A HIGH RISK INVESTMENT ASSET !!!\n', '* !!! THIS IS GAMBLING !!!\n', '* !!! THIS IS A PONZI SCHEME !!!\n', '* All funds invested are going to prev investors for the exception of FounderFee and AgentFee\n', '*\n', '* Bonds are generating profit due to NEW and NEW investors BUYING them\n', '* If the contract has no ETH in it you will FAIL to redeem your bond\n', '* However as soon as new bonds will be issued the contract will receive ETH and\n', '* you will be able to redeem the bond.\n', '*\n', '* You can also refer a friend for 10% of the bonds he buys. Your friend will also receive a referral bonus for trading with your code!\n', '*\n', '*/\n', '\n', '/*\n', '* ------------------------------\n', '* Main functions are:\n', '* Buy() - to buy a new issued bond\n', '* Redeem() - to redeem your bond for profit \n', '*\n', '* BuyOnSecondaryMarket() - to buy a bond from other investors\n', '* PlaceSellOrder() - to place your bond on the secondary market for selling\n', '* CancelSellOrder() - stop selling your bond\n', '* Withdraw() - to withdraw agant commission or funds after selling a bond on the secondary market\n', '* ------------------------------\n', '*/\n', '\n', '/**\n', '/* Math operations with safety checks\n', '*/\n', 'contract SafeMath \n', '{\n', '    function mul(uint a, uint b) internal pure returns (uint) \n', '    {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) \n', '    {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) \n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) \n', '    {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function assert(bool assertion) internal pure\n', '    {\n', '        if (!assertion) \n', '        {\n', '            revert();\n', '        }   \n', '    }\n', '}\n', '\n', 'contract EtherBonds is SafeMath\n', '{\n', '    /* A founder can write here useful information */\n', '    /* For example current domain name or report a problem */\n', '    string public README = "STATUS_OK";\n', '    \n', '    /* You can refer a friend and you will be receiving a bonus for EACH his deal */\n', '    /* The friend will also have a bonus but only once */\n', '    /* You should have at least one bond in your history to be an agent */\n', '    /* Just ask your friend to specify your wallet address with his FIRST deal */\n', '    uint32 AgentBonusInPercent = 10;\n', '    /* A user gets a bonus for adding an agent for his first deal */\n', '    uint32 UserRefBonusInPercent = 3;\n', '    \n', '    /* How long it takes for a bond to mature  */\n', "    uint32 MinMaturityTimeInDays = 30; // don't set less than 15 days\n", '    uint32 MaxMaturityTimeInDays = 240;\n', '    \n', '    /* Minimum price of a bond */\n', '    uint MinNominalBondPrice = 0.006 ether;\n', '    \n', '    /* How much % of your bond you can redeem prematurely */\n', '    uint32 PrematureRedeemPartInPercent = 25;\n', '    /* How much this option costs */\n', '    uint32 PrematureRedeemCostInPercent = 20;\n', '    \n', '    /* Be careful! */\n', "    /* If you don't redeem your bond AFTER its maturity date */\n", '    /* the bond will become irredeemable! */\n', '    uint32 RedeemRangeInDays = 1;\n', '    uint32 ExtraRedeemRangeInDays = 3;\n', '    /* However you can prolong your redeem period for a price */\n', '    uint32 ExtraRedeemRangeCostInPercent = 10;\n', '    \n', '    /* Founder takes a fee for each bond sold */\n', "    /* There is no way for a founder to take all the contract's money, fonder takes only the fee */\n", '    address public Founder;\n', '    uint32 public FounderFeeInPercent = 5;\n', '    \n', '    /* Events */\n', '    event Issued(uint32 bondId, address owner);\n', '    event Sold(uint32 bondId, address seller, address buyer, uint price);\n', '    event SellOrderPlaced(uint32 bondId, address seller);\n', '    event SellOrderCanceled(uint32 bondId, address seller);\n', '    event Redeemed(uint32 bondId, address owner);\n', '    \n', '    struct Bond \n', '    {\n', '        /* Unique ID of a bond */\n', '        uint32 id;\n', '        \n', '        address owner;\n', '        \n', '        uint32 issueTime;\n', '        uint32 maturityTime;\n', '        uint32 redeemTime;\n', '        \n', "        /* A bond can't be redeemed after this date */\n", '        uint32 maxRedeemTime;\n', '        bool canBeRedeemedPrematurely;\n', '        \n', '        uint nominalPrice;\n', '        uint maturityPrice;\n', '        \n', '        /* You can resell your bond to another user */\n', '        uint sellingPrice;\n', '    }\n', '    uint32 NextBondID = 1;\n', '    mapping(uint32 => Bond) public Bonds;\n', '    \n', '    struct UserInfo\n', '    {\n', '        /* This address will receive commission for this user trading */\n', '        address agent;\n', '        \n', '        uint32 totalBonds;\n', '        mapping(uint32 => uint32) bonds;\n', '    }\n', '    mapping(address => UserInfo) public Users;\n', '\n', '    mapping(address => uint) public Balances;\n', '\n', '    /* MAIN */\n', '    \n', '    function EtherBonds() public \n', '    {\n', '        Founder = msg.sender;\n', '    }\n', '    \n', '    function ContractInfo() \n', '        public view returns(\n', '            string readme,\n', '            uint32 agentBonusInPercent,\n', '            uint32 userRefBonusInPercent,\n', '            uint32 minMaturityTimeInDays,\n', '            uint32 maxMaturityTimeInDays,\n', '            uint minNominalBondPrice,\n', '            uint32 prematureRedeemPartInPercent,\n', '            uint32 prematureRedeemCostInPercent,\n', '            uint32 redeemRangeInDays,\n', '            uint32 extraRedeemRangeInDays,\n', '            uint32 extraRedeemRangeCostInPercent,\n', '            uint32 nextBondID,\n', '            uint balance\n', '            )\n', '    {\n', '        readme = README;\n', '        agentBonusInPercent = AgentBonusInPercent;\n', '        userRefBonusInPercent = UserRefBonusInPercent;\n', '        minMaturityTimeInDays = MinMaturityTimeInDays;\n', '        maxMaturityTimeInDays = MaxMaturityTimeInDays;\n', '        minNominalBondPrice = MinNominalBondPrice;\n', '        prematureRedeemPartInPercent = PrematureRedeemPartInPercent;\n', '        prematureRedeemCostInPercent = PrematureRedeemCostInPercent;\n', '        redeemRangeInDays = RedeemRangeInDays;\n', '        extraRedeemRangeInDays = ExtraRedeemRangeInDays;\n', '        extraRedeemRangeCostInPercent = ExtraRedeemRangeCostInPercent;\n', '        nextBondID = NextBondID;\n', '        balance = this.balance;\n', '    }\n', '    \n', '    /* This function calcs how much profit will a bond bring */\n', '    function MaturityPrice(\n', '        uint nominalPrice, \n', '        uint32 maturityTimeInDays,\n', '        bool hasExtraRedeemRange,\n', '        bool canBeRedeemedPrematurely,\n', '        bool hasRefBonus\n', '        ) \n', '        public view returns(uint)\n', '    {\n', '        uint nominalPriceModifierInPercent = 100;\n', '        \n', '        if (hasExtraRedeemRange)\n', '        {\n', '            nominalPriceModifierInPercent = sub(\n', '                nominalPriceModifierInPercent, \n', '                ExtraRedeemRangeCostInPercent\n', '                );\n', '        }\n', '        \n', '        if (canBeRedeemedPrematurely)\n', '        {\n', '            nominalPriceModifierInPercent = sub(\n', '                nominalPriceModifierInPercent, \n', '                PrematureRedeemCostInPercent\n', '                );\n', '        }\n', '        \n', '        if (hasRefBonus)\n', '        {\n', '            nominalPriceModifierInPercent = add(\n', '                nominalPriceModifierInPercent, \n', '                UserRefBonusInPercent\n', '                );\n', '        }\n', '        \n', '        nominalPrice = div(\n', '            mul(nominalPrice, nominalPriceModifierInPercent), \n', '            100\n', '            );\n', '        \n', '        //y = 1.177683 - 0.02134921*x + 0.001112346*x^2 - 0.000010194*x^3 + 0.00000005298844*x^4\n', '        /*\n', '        15days        +7%\n', '        30days       +30%\n', '        60days      +138%\n', '        120days     +700%\n', '        240days    +9400% \n', '        */\n', '        \n', '        uint x = maturityTimeInDays;\n', '        \n', '        /* The formula will break if x < 15 */\n', '        require(x >= 15);\n', '        \n', '        var a = mul(2134921000, x);\n', '        var b = mul(mul(111234600, x), x);\n', '        var c = mul(mul(mul(1019400, x), x), x);\n', '        var d = mul(mul(mul(mul(5298, x), x), x), x);\n', '        \n', '        var k = sub(sub(add(add(117168300000, b), d), a), c);\n', '        k = div(k, 10000000);\n', '        \n', '        return div(mul(nominalPrice, k), 10000);\n', '    }\n', '    \n', '    /* This function checks if you can change your bond back to money */\n', '    function CanBeRedeemed(Bond bond) \n', '        internal view returns(bool) \n', '    {\n', '        return \n', '            bond.issueTime > 0 &&                       // a bond should be issued\n', '            bond.owner != 0 &&                          // it should should have an owner\n', '            bond.redeemTime == 0 &&                     // it should not be already redeemed\n', '            bond.sellingPrice == 0 &&                   // it should not be reserved for selling\n', '            (\n', '                !IsPremature(bond.maturityTime) ||      // it should be mature / be redeemable prematurely \n', '                bond.canBeRedeemedPrematurely\n', '            ) &&       \n', "            block.timestamp <= bond.maxRedeemTime;      // be careful, you can't redeem too old bonds\n", '    }\n', '    \n', '    /* For some external checkings we gonna to wrap this in a function */\n', '    function IsPremature(uint maturityTime)\n', '        public view returns(bool) \n', '    {\n', '        return maturityTime > block.timestamp;\n', '    }\n', '    \n', '    /* This is how you buy bonds on the primary market */\n', '    function Buy(\n', '        uint32 maturityTimeInDays,\n', '        bool hasExtraRedeemRange,\n', '        bool canBeRedeemedPrematurely,\n', '        address agent // you can leave it 0\n', '        ) \n', '        public payable\n', '    {\n', "        /* We don't issue bonds cheaper than MinNominalBondPrice*/\n", '        require(msg.value >= MinNominalBondPrice);\n', '        \n', "        /* We don't issue bonds out of allowed maturity range */\n", '        require(\n', '            maturityTimeInDays >= MinMaturityTimeInDays && \n', '            maturityTimeInDays <= MaxMaturityTimeInDays\n', '            );\n', '            \n', '        /* You can have a bonus on your first deal if specify an agent */\n', '        bool hasRefBonus = false;\n', '            \n', '        /* On your first deal ...  */\n', '        if (Users[msg.sender].agent == 0 && Users[msg.sender].totalBonds == 0)\n', '        {\n', '            /* ... you may specify an agent and get a bonus for this ... */\n', '            if (agent != 0)\n', '            {\n', '                /* ... the agent should have some bonds behind him */\n', '                if (Users[agent].totalBonds > 0)\n', '                {\n', '                    Users[msg.sender].agent = agent;\n', '                    hasRefBonus = true;\n', '                }\n', '                else\n', '                {\n', '                    agent = 0;\n', '                }\n', '            }\n', '        }\n', '        /* On all your next deals you will have the same agent as on the first one */\n', '        else\n', '        {\n', '            agent = Users[msg.sender].agent;\n', '        }\n', '            \n', '        /* Issuing a new bond */\n', '        Bond memory newBond;\n', '        newBond.id = NextBondID;\n', '        newBond.owner = msg.sender;\n', '        newBond.issueTime = uint32(block.timestamp);\n', '        newBond.canBeRedeemedPrematurely = canBeRedeemedPrematurely;\n', '        \n', '        /* You cant redeem your bond for profit untill this date */\n', '        newBond.maturityTime = \n', '            newBond.issueTime + maturityTimeInDays*24*60*60;\n', '        \n', '        /* Your time to redeem is limited */    \n', '        newBond.maxRedeemTime = \n', '            newBond.maturityTime + (hasExtraRedeemRange?ExtraRedeemRangeInDays:RedeemRangeInDays)*24*60*60;\n', '        \n', '        newBond.nominalPrice = msg.value;\n', '        \n', '        newBond.maturityPrice = MaturityPrice(\n', '            newBond.nominalPrice,\n', '            maturityTimeInDays,\n', '            hasExtraRedeemRange,\n', '            canBeRedeemedPrematurely,\n', '            hasRefBonus\n', '            );\n', '        \n', '        Bonds[newBond.id] = newBond;\n', '        NextBondID += 1;\n', '        \n', '        /* Linking the bond to the owner so later he can easily find it */\n', '        var user = Users[newBond.owner];\n', '        user.bonds[user.totalBonds] = newBond.id;\n', '        user.totalBonds += 1;\n', '        \n', '        /* Notify all users about the issuing event */\n', '        Issued(newBond.id, newBond.owner);\n', '        \n', "        /* Founder's fee */\n", '        uint moneyToFounder = div(\n', '            mul(newBond.nominalPrice, FounderFeeInPercent), \n', '            100\n', '            );\n', '        /* Agent bonus */\n', '        uint moneyToAgent = div(\n', '            mul(newBond.nominalPrice, AgentBonusInPercent), \n', '            100\n', '            );\n', '        \n', '        if (agent != 0 && moneyToAgent > 0)\n', '        {\n', "            /* Agent can potentially block user's trading attempts, so we dont use just .transfer*/\n", '            Balances[agent] = add(Balances[agent], moneyToAgent);\n', '        }\n', '        \n', '        /* Founder always gets his fee */\n', '        require(moneyToFounder > 0);\n', '        \n', '        Founder.transfer(moneyToFounder);\n', '    }\n', '    \n', '    /* You can also buy bonds on secondary market from other users */\n', '    function BuyOnSecondaryMarket(uint32 bondId) \n', '        public payable\n', '    {\n', '        var bond = Bonds[bondId];\n', '        \n', '        /* A bond you are buying should be issued */\n', '        require(bond.issueTime > 0);\n', '        /* Checking, if the bond is a valuable asset */\n', '        require(bond.redeemTime == 0 && block.timestamp < bond.maxRedeemTime);\n', '        \n', '        var price = bond.sellingPrice;\n', '        /* You can only buy a bond if an owner is selling it */\n', '        require(price > 0);\n', '        /* You should have enough money to pay the owner */\n', '        require(price <= msg.value);\n', '        \n', "        /* It's ok if you accidentally transfer more money, we will send them back */\n", '        var residue = msg.value - price;\n', '        \n', '        /* Transfering the bond */\n', '        var oldOwner = bond.owner;\n', '        var newOwner = msg.sender;\n', '        require(newOwner != 0 && newOwner != oldOwner);\n', '        \n', '        bond.sellingPrice = 0;\n', '        bond.owner = newOwner;\n', '        \n', '        var user = Users[bond.owner];\n', '        user.bonds[user.totalBonds] = bond.id;\n', '        user.totalBonds += 1;\n', '        \n', '        /* Doublechecking the price */\n', '        require(add(price, residue) == msg.value);\n', '        \n', '        /* Notify all users about the exchange event */\n', '        Sold(bond.id, oldOwner, newOwner, price);\n', '        \n', "        /* Old owner can potentially block user's trading attempts, so we dont use just .transfer*/\n", '        Balances[oldOwner] = add(Balances[oldOwner], price);\n', '        \n', '        if (residue > 0)\n', '        {\n', '            /* If there is residue we will send it back */\n', '            newOwner.transfer(residue);\n', '        }\n', '    }\n', '    \n', '    /* You can sell your bond on the secondary market */\n', '    function PlaceSellOrder(uint32 bondId, uint sellingPrice) \n', '        public\n', '    {\n', '        /* To protect from an accidental selling by 0 price */\n', '        /* The selling price should be in Wei */\n', '        require(sellingPrice >= MinNominalBondPrice);\n', '        \n', '        var bond = Bonds[bondId];\n', '        \n', '        /* A bond you are selling should be issued */\n', '        require(bond.issueTime > 0);\n', "        /* You can't update selling price, please, call CancelSellOrder beforehand */\n", '        require(bond.sellingPrice == 0);\n', "        /* You can't sell useless bonds */\n", '        require(bond.redeemTime == 0 && block.timestamp < bond.maxRedeemTime);\n', "        /* You should own a bond you're selling */\n", '        require(bond.owner == msg.sender);\n', '        \n', '        bond.sellingPrice = sellingPrice;\n', '        \n', '        /* Notify all users about you wanting to sell the bond */\n', '        SellOrderPlaced(bond.id, bond.owner);\n', '    }\n', '    \n', '    /* You can cancel your sell order */\n', '    function CancelSellOrder(uint32 bondId) \n', '        public\n', '    {\n', '        var bond = Bonds[bondId];\n', '        \n', '        /* Bond should be reserved for selling */\n', '        require(bond.sellingPrice > 0);\n', '        \n', "        /* You should own a bond which sell order you're cancelling */\n", '        require(bond.owner == msg.sender);\n', '        \n', '        bond.sellingPrice = 0;\n', '        \n', '        /* Notify all users about cancelling the selling order */\n', '        SellOrderCanceled(bond.id, bond.owner);\n', '    }\n', '    \n', "    /* Sometimes we can't just use .transfer for a security reason */\n", '    function Withdraw()\n', '        public\n', '    {\n', '        require(Balances[msg.sender] > 0);\n', '\n', "        /* Don't forget about double entering in .transfer! */\n", '        var money = Balances[msg.sender];\n', '        Balances[msg.sender] = 0;\n', '\n', '        msg.sender.transfer(money);\n', '    }\n', '\n', '    /* You can redeem bonds back to the contract for profit */\n', '    /* But you need to wait till maturityTime */\n', '    /* This is the key function where you get profit for a bond you own */\n', '    function Redeem(uint32 bondId) \n', '        public\n', '    {\n', '        var bond = Bonds[bondId];\n', '        \n', '        require(CanBeRedeemed(bond));\n', '        \n', '        /* You should own a bond you redeem */\n', '        require(bond.owner == msg.sender);\n', '        \n', '        /* If a bond has redeemTime it has been redeemed */\n', '        bond.redeemTime = uint32(block.timestamp);\n', '        \n', "        /* If it's a premature redeem you will only get \n", '        PrematureRedeemPartInPercent of nominalPrice back */\n', '        if (IsPremature(bond.maturityTime))\n', '        {\n', '            bond.maturityPrice = div(\n', '                mul(bond.nominalPrice, PrematureRedeemPartInPercent), \n', '                100\n', '                );\n', '        }\n', '        \n', '        /* Notify all users about the redeem event */\n', '        Redeemed(bond.id, bond.owner);\n', '        \n', '        /* Transfer funds to the owner */\n', '        /* This is how you earn money */\n', '        bond.owner.transfer(bond.maturityPrice);\n', '    }\n', '    \n', '    /* Be carefull, this function can return a bound of a differet owner\n', '    if the bond was sold. Always check the bond owner */\n', '    function UserBondByOffset(uint32 offset) \n', '        public view \n', '        returns(\n', '            uint32 bondId,\n', '            bool canBeRedeemed,\n', '            bool isPremature\n', '            ) \n', '    {\n', '        var bond = Bonds[Users[msg.sender].bonds[offset]];\n', '        \n', '        bondId = bond.id;\n', '        canBeRedeemed = CanBeRedeemed(bond);\n', '        isPremature = IsPremature(bond.maturityTime);\n', '    }\n', '    \n', '    function BondInfoById(uint32 bondId) \n', '        public view \n', '        returns(\n', '            bool canBeRedeemed,\n', '            bool isPremature\n', '            ) \n', '    {\n', '        var bond = Bonds[bondId];\n', '        \n', '        canBeRedeemed = CanBeRedeemed(bond);\n', '        isPremature = IsPremature(bond.maturityTime);\n', '    }\n', '    \n', '    /* ADMIN */\n', '     \n', '    function AdmChange_README(string value) public\n', '    {\n', '        require(msg.sender == Founder);\n', '        \n', '        README = value;\n', '    }\n', '}']