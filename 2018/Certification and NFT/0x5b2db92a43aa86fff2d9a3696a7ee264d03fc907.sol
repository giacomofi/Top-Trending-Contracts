['pragma solidity ^0.4.17;\n', '\n', '/*\n', '\n', ' * source       https://github.com/blockbitsio/\n', '\n', ' * @name        Application Entity Generic Contract\n', ' * @package     BlockBitsIO\n', ' * @author      Micky Socaci <micky@nowlive.ro>\n', '\n', '    Used for the ABI interface when assets need to call Application Entity.\n', '\n', '    This is required, otherwise we end up loading the assets themselves when we load the ApplicationEntity contract\n', '    and end up in a loop\n', '*/\n', '\n', '\n', '\n', 'contract ApplicationEntityABI {\n', '\n', '    address public ProposalsEntity;\n', '    address public FundingEntity;\n', '    address public MilestonesEntity;\n', '    address public MeetingsEntity;\n', '    address public BountyManagerEntity;\n', '    address public TokenManagerEntity;\n', '    address public ListingContractEntity;\n', '    address public FundingManagerEntity;\n', '    address public NewsContractEntity;\n', '\n', '    bool public _initialized = false;\n', '    bool public _locked = false;\n', '    uint8 public CurrentEntityState;\n', '    uint8 public AssetCollectionNum;\n', '    address public GatewayInterfaceAddress;\n', '    address public deployerAddress;\n', '    address testAddressAllowUpgradeFrom;\n', '    mapping (bytes32 => uint8) public EntityStates;\n', '    mapping (bytes32 => address) public AssetCollection;\n', '    mapping (uint8 => bytes32) public AssetCollectionIdToName;\n', '    mapping (bytes32 => uint256) public BylawsUint256;\n', '    mapping (bytes32 => bytes32) public BylawsBytes32;\n', '\n', '    function ApplicationEntity() public;\n', '    function getEntityState(bytes32 name) public view returns (uint8);\n', '    function linkToGateway( address _GatewayInterfaceAddress, bytes32 _sourceCodeUrl ) external;\n', '    function setUpgradeState(uint8 state) public ;\n', '    function addAssetProposals(address _assetAddresses) external;\n', '    function addAssetFunding(address _assetAddresses) external;\n', '    function addAssetMilestones(address _assetAddresses) external;\n', '    function addAssetMeetings(address _assetAddresses) external;\n', '    function addAssetBountyManager(address _assetAddresses) external;\n', '    function addAssetTokenManager(address _assetAddresses) external;\n', '    function addAssetFundingManager(address _assetAddresses) external;\n', '    function addAssetListingContract(address _assetAddresses) external;\n', '    function addAssetNewsContract(address _assetAddresses) external;\n', '    function getAssetAddressByName(bytes32 _name) public view returns (address);\n', '    function setBylawUint256(bytes32 name, uint256 value) public;\n', '    function getBylawUint256(bytes32 name) public view returns (uint256);\n', '    function setBylawBytes32(bytes32 name, bytes32 value) public;\n', '    function getBylawBytes32(bytes32 name) public view returns (bytes32);\n', '    function initialize() external returns (bool);\n', '    function getParentAddress() external view returns(address);\n', '    function createCodeUpgradeProposal( address _newAddress, bytes32 _sourceCodeUrl ) external returns (uint256);\n', '    function acceptCodeUpgradeProposal(address _newAddress) external;\n', '    function initializeAssetsToThisApplication() external returns (bool);\n', '    function transferAssetsToNewApplication(address _newAddress) external returns (bool);\n', '    function lock() external returns (bool);\n', '    function canInitiateCodeUpgrade(address _sender) public view returns(bool);\n', '    function doStateChanges() public;\n', '    function hasRequiredStateChanges() public view returns (bool);\n', '    function anyAssetHasChanges() public view returns (bool);\n', '    function extendedAnyAssetHasChanges() internal view returns (bool);\n', '    function getRequiredStateChanges() public view returns (uint8, uint8);\n', '    function getTimestamp() view public returns (uint256);\n', '\n', '}\n', '\n', '/*\n', '\n', ' * source       https://github.com/blockbitsio/\n', '\n', ' * @name        Application Asset Contract\n', ' * @package     BlockBitsIO\n', ' * @author      Micky Socaci <micky@nowlive.ro>\n', '\n', ' Any contract inheriting this will be usable as an Asset in the Application Entity\n', '\n', '*/\n', '\n', '\n', '\n', '\n', 'contract ApplicationAsset {\n', '\n', '    event EventAppAssetOwnerSet(bytes32 indexed _name, address indexed _owner);\n', '    event EventRunBeforeInit(bytes32 indexed _name);\n', '    event EventRunBeforeApplyingSettings(bytes32 indexed _name);\n', '\n', '\n', '    mapping (bytes32 => uint8) public EntityStates;\n', '    mapping (bytes32 => uint8) public RecordStates;\n', '    uint8 public CurrentEntityState;\n', '\n', '    event EventEntityProcessor(bytes32 indexed _assetName, uint8 indexed _current, uint8 indexed _required);\n', '    event DebugEntityRequiredChanges( bytes32 _assetName, uint8 indexed _current, uint8 indexed _required );\n', '\n', '    bytes32 public assetName;\n', '\n', '    /* Asset records */\n', '    uint8 public RecordNum = 0;\n', '\n', '    /* Asset initialised or not */\n', '    bool public _initialized = false;\n', '\n', '    /* Asset settings present or not */\n', '    bool public _settingsApplied = false;\n', '\n', '    /* Asset owner ( ApplicationEntity address ) */\n', '    address public owner = address(0x0) ;\n', '    address public deployerAddress;\n', '\n', '    function ApplicationAsset() public {\n', '        deployerAddress = msg.sender;\n', '    }\n', '\n', '    function setInitialApplicationAddress(address _ownerAddress) public onlyDeployer requireNotInitialised {\n', '        owner = _ownerAddress;\n', '    }\n', '\n', '    function setInitialOwnerAndName(bytes32 _name) external\n', '        requireNotInitialised\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        // init states\n', '        setAssetStates();\n', '        assetName = _name;\n', '        // set initial state\n', '        CurrentEntityState = getEntityState("NEW");\n', '        runBeforeInitialization();\n', '        _initialized = true;\n', '        EventAppAssetOwnerSet(_name, owner);\n', '        return true;\n', '    }\n', '\n', '    function setAssetStates() internal {\n', '        // Asset States\n', '        EntityStates["__IGNORED__"]     = 0;\n', '        EntityStates["NEW"]             = 1;\n', '        // Funding Stage States\n', '        RecordStates["__IGNORED__"]     = 0;\n', '    }\n', '\n', '    function getRecordState(bytes32 name) public view returns (uint8) {\n', '        return RecordStates[name];\n', '    }\n', '\n', '    function getEntityState(bytes32 name) public view returns (uint8) {\n', '        return EntityStates[name];\n', '    }\n', '\n', '    function runBeforeInitialization() internal requireNotInitialised  {\n', '        EventRunBeforeInit(assetName);\n', '    }\n', '\n', '    function applyAndLockSettings()\n', '        public\n', '        onlyDeployer\n', '        requireInitialised\n', '        requireSettingsNotApplied\n', '        returns(bool)\n', '    {\n', '        runBeforeApplyingSettings();\n', '        _settingsApplied = true;\n', '        return true;\n', '    }\n', '\n', '    function runBeforeApplyingSettings() internal requireInitialised requireSettingsNotApplied  {\n', '        EventRunBeforeApplyingSettings(assetName);\n', '    }\n', '\n', '    function transferToNewOwner(address _newOwner) public requireInitialised onlyOwner returns (bool) {\n', '        require(owner != address(0x0) && _newOwner != address(0x0));\n', '        owner = _newOwner;\n', '        EventAppAssetOwnerSet(assetName, owner);\n', '        return true;\n', '    }\n', '\n', '    function getApplicationAssetAddressByName(bytes32 _name)\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        address asset = ApplicationEntityABI(owner).getAssetAddressByName(_name);\n', '        if( asset != address(0x0) ) {\n', '            return asset;\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function getApplicationState() public view returns (uint8) {\n', '        return ApplicationEntityABI(owner).CurrentEntityState();\n', '    }\n', '\n', '    function getApplicationEntityState(bytes32 name) public view returns (uint8) {\n', '        return ApplicationEntityABI(owner).getEntityState(name);\n', '    }\n', '\n', '    function getAppBylawUint256(bytes32 name) public view requireInitialised returns (uint256) {\n', '        ApplicationEntityABI CurrentApp = ApplicationEntityABI(owner);\n', '        return CurrentApp.getBylawUint256(name);\n', '    }\n', '\n', '    function getAppBylawBytes32(bytes32 name) public view requireInitialised returns (bytes32) {\n', '        ApplicationEntityABI CurrentApp = ApplicationEntityABI(owner);\n', '        return CurrentApp.getBylawBytes32(name);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyApplicationEntity() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier requireInitialised() {\n', '        require(_initialized == true);\n', '        _;\n', '    }\n', '\n', '    modifier requireNotInitialised() {\n', '        require(_initialized == false);\n', '        _;\n', '    }\n', '\n', '    modifier requireSettingsApplied() {\n', '        require(_settingsApplied == true);\n', '        _;\n', '    }\n', '\n', '    modifier requireSettingsNotApplied() {\n', '        require(_settingsApplied == false);\n', '        _;\n', '    }\n', '\n', '    modifier onlyDeployer() {\n', '        require(msg.sender == deployerAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAsset(bytes32 _name) {\n', '        address AssetAddress = getApplicationAssetAddressByName(_name);\n', '        require( msg.sender == AssetAddress);\n', '        _;\n', '    }\n', '\n', '    function getTimestamp() view public returns (uint256) {\n', '        return now;\n', '    }\n', '\n', '\n', '}\n', '\n', '/*\n', '\n', ' * source       https://github.com/blockbitsio/\n', '\n', ' * @name        Token Contract\n', ' * @package     BlockBitsIO\n', ' * @author      Micky Socaci <micky@nowlive.ro>\n', '\n', ' Zeppelin ERC20 Standard Token\n', '\n', '*/\n', '\n', '\n', '\n', 'contract ABIToken {\n', '\n', '    string public  symbol;\n', '    string public  name;\n', '    uint8 public   decimals;\n', '    uint256 public totalSupply;\n', '    string public  version;\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    address public manager;\n', '    address public deployer;\n', '    bool public mintingFinished = false;\n', '    bool public initialized = false;\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool success);\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success);\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '    function finishMinting() public returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 indexed value);\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MintFinished();\n', '}\n', '\n', '/*\n', '\n', ' * source       https://github.com/blockbitsio/\n', '\n', ' * @name        Application Asset Contract ABI\n', ' * @package     BlockBitsIO\n', ' * @author      Micky Socaci <micky@nowlive.ro>\n', '\n', ' Any contract inheriting this will be usable as an Asset in the Application Entity\n', '\n', '*/\n', '\n', '\n', '\n', 'contract ABIApplicationAsset {\n', '\n', '    bytes32 public assetName;\n', '    uint8 public CurrentEntityState;\n', '    uint8 public RecordNum;\n', '    bool public _initialized;\n', '    bool public _settingsApplied;\n', '    address public owner;\n', '    address public deployerAddress;\n', '    mapping (bytes32 => uint8) public EntityStates;\n', '    mapping (bytes32 => uint8) public RecordStates;\n', '\n', '    function setInitialApplicationAddress(address _ownerAddress) public;\n', '    function setInitialOwnerAndName(bytes32 _name) external returns (bool);\n', '    function getRecordState(bytes32 name) public view returns (uint8);\n', '    function getEntityState(bytes32 name) public view returns (uint8);\n', '    function applyAndLockSettings() public returns(bool);\n', '    function transferToNewOwner(address _newOwner) public returns (bool);\n', '    function getApplicationAssetAddressByName(bytes32 _name) public returns(address);\n', '    function getApplicationState() public view returns (uint8);\n', '    function getApplicationEntityState(bytes32 name) public view returns (uint8);\n', '    function getAppBylawUint256(bytes32 name) public view returns (uint256);\n', '    function getAppBylawBytes32(bytes32 name) public view returns (bytes32);\n', '    function getTimestamp() view public returns (uint256);\n', '\n', '\n', '}\n', '\n', '/*\n', '\n', ' * source       https://github.com/blockbitsio/\n', '\n', ' * @name        Token Manager Contract\n', ' * @package     BlockBitsIO\n', ' * @author      Micky Socaci <micky@nowlive.ro>\n', '\n', '*/\n', '\n', '\n', '\n', '\n', '\n', 'contract ABITokenManager is ABIApplicationAsset {\n', '\n', '    address public TokenSCADAEntity;\n', '    address public TokenEntity;\n', '    address public MarketingMethodAddress;\n', '    bool OwnerTokenBalancesReleased = false;\n', '\n', '    function addSettings(address _scadaAddress, address _tokenAddress, address _marketing ) public;\n', '    function getTokenSCADARequiresHardCap() public view returns (bool);\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '    function finishMinting() public returns (bool);\n', '    function mintForMarketingPool(address _to, uint256 _amount) external returns (bool);\n', '    function ReleaseOwnersLockedTokens(address _multiSigOutputAddress) public returns (bool);\n', '\n', '}\n', '\n', '/*\n', '\n', ' * source       https://github.com/blockbitsio/\n', '\n', ' * @name        Listing Contract ABI\n', ' * @package     BlockBitsIO\n', ' * @author      Micky Socaci <micky@nowlive.ro>\n', '\n', '*/\n', '\n', '\n', '\n', '\n', '\n', 'contract ABIListingContract is ABIApplicationAsset {\n', '\n', '    address public managerAddress;\n', '    // child items\n', '    struct item {\n', '        bytes32 name;\n', '        address itemAddress;\n', '        bool    status;\n', '        uint256 index;\n', '    }\n', '\n', '    mapping ( uint256 => item ) public items;\n', '    uint256 public itemNum;\n', '\n', '    function setManagerAddress(address _manager) public;\n', '    function addItem(bytes32 _name, address _address) public;\n', '    function getNewsContractAddress(uint256 _childId) external view returns (address);\n', '    function canBeDelisted(uint256 _childId) public view returns (bool);\n', '    function getChildStatus( uint256 _childId ) public view returns (bool);\n', '    function delistChild( uint256 _childId ) public;\n', '\n', '}\n', '\n', '/*\n', '\n', ' * source       https://github.com/blockbitsio/\n', '\n', ' * @name        Funding Contract ABI\n', ' * @package     BlockBitsIO\n', ' * @author      Micky Socaci <micky@nowlive.ro>\n', '\n', ' Contains the Funding Contract code deployed and linked to the Application Entity\n', '\n', '\n', '    !!! Links directly to Milestones\n', '\n', '*/\n', '\n', '\n', '\n', '\n', '\n', 'contract ABIFunding is ABIApplicationAsset {\n', '\n', '    address public multiSigOutputAddress;\n', '    address public DirectInput;\n', '    address public MilestoneInput;\n', '    address public TokenManagerEntity;\n', '    address public FundingManagerEntity;\n', '\n', '    struct FundingStage {\n', '        bytes32 name;\n', '        uint8   state;\n', '        uint256 time_start;\n', '        uint256 time_end;\n', '        uint256 amount_cap_soft;            // 0 = not enforced\n', '        uint256 amount_cap_hard;            // 0 = not enforced\n', '        uint256 amount_raised;              // 0 = not enforced\n', '        // funding method settings\n', '        uint256 minimum_entry;\n', '        uint8   methods;                    // FundingMethodIds\n', '        // token settings\n', '        uint256 fixed_tokens;\n', '        uint8   price_addition_percentage;  //\n', '        uint8   token_share_percentage;\n', '        uint8   index;\n', '    }\n', '\n', '    mapping (uint8 => FundingStage) public Collection;\n', '    uint8 public FundingStageNum;\n', '    uint8 public currentFundingStage;\n', '    uint256 public AmountRaised;\n', '    uint256 public MilestoneAmountRaised;\n', '    uint256 public GlobalAmountCapSoft;\n', '    uint256 public GlobalAmountCapHard;\n', '    uint8 public TokenSellPercentage;\n', '    uint256 public Funding_Setting_funding_time_start;\n', '    uint256 public Funding_Setting_funding_time_end;\n', '    uint256 public Funding_Setting_cashback_time_start;\n', '    uint256 public Funding_Setting_cashback_time_end;\n', '    uint256 public Funding_Setting_cashback_before_start_wait_duration;\n', '    uint256 public Funding_Setting_cashback_duration;\n', '\n', '\n', '    function addFundingStage(\n', '        bytes32 _name,\n', '        uint256 _time_start,\n', '        uint256 _time_end,\n', '        uint256 _amount_cap_soft,\n', '        uint256 _amount_cap_hard,   // required > 0\n', '        uint8   _methods,\n', '        uint256 _minimum_entry,\n', '        uint256 _fixed_tokens,\n', '        uint8   _price_addition_percentage,\n', '        uint8   _token_share_percentage\n', '    )\n', '    public;\n', '\n', '    function addSettings(address _outputAddress, uint256 soft_cap, uint256 hard_cap, uint8 sale_percentage, address _direct, address _milestone ) public;\n', '    function getStageAmount(uint8 StageId) public view returns ( uint256 );\n', '    function allowedPaymentMethod(uint8 _payment_method) public pure returns (bool);\n', '    function receivePayment(address _sender, uint8 _payment_method) payable public returns(bool);\n', '    function canAcceptPayment(uint256 _amount) public view returns (bool);\n', '    function getValueOverCurrentCap(uint256 _amount) public view returns (uint256);\n', '    function isFundingStageUpdateAllowed(uint8 _new_state ) public view returns (bool);\n', '    function getRecordStateRequiredChanges() public view returns (uint8);\n', '    function doStateChanges() public;\n', '    function hasRequiredStateChanges() public view returns (bool);\n', '    function getRequiredStateChanges() public view returns (uint8, uint8, uint8);\n', '\n', '}\n', '\n', '/*\n', '\n', ' * source       https://github.com/blockbitsio/\n', '\n', ' * @name        Funding Contract ABI\n', ' * @package     BlockBitsIO\n', ' * @author      Micky Socaci <micky@nowlive.ro>\n', '\n', ' Contains the Funding Contract code deployed and linked to the Application Entity\n', '\n', '*/\n', '\n', '\n', '\n', '\n', '\n', 'contract ABIFundingManager is ABIApplicationAsset {\n', '\n', '    bool public fundingProcessed;\n', '    bool FundingPoolBalancesAllocated;\n', '    uint8 public VaultCountPerProcess;\n', '    uint256 public lastProcessedVaultId;\n', '    uint256 public vaultNum;\n', '    uint256 public LockedVotingTokens;\n', '    bytes32 public currentTask;\n', '    mapping (bytes32 => bool) public taskByHash;\n', '    mapping  (address => address) public vaultList;\n', '    mapping  (uint256 => address) public vaultById;\n', '\n', '    function receivePayment(address _sender, uint8 _payment_method, uint8 _funding_stage) payable public returns(bool);\n', '    function getMyVaultAddress(address _sender) public view returns (address);\n', '    function setVaultCountPerProcess(uint8 _perProcess) external;\n', '    function getHash(bytes32 actionType, bytes32 arg1) public pure returns ( bytes32 );\n', '    function getCurrentMilestoneProcessed() public view returns (bool);\n', '    function processFundingFailedFinished() public view returns (bool);\n', '    function processFundingSuccessfulFinished() public view returns (bool);\n', '    function getCurrentMilestoneIdHash() internal view returns (bytes32);\n', '    function processMilestoneFinished() public view returns (bool);\n', '    function processEmergencyFundReleaseFinished() public view returns (bool);\n', '    function getAfterTransferLockedTokenBalances(address vaultAddress, bool excludeCurrent) public view returns (uint256);\n', '    function VaultRequestedUpdateForLockedVotingTokens(address owner) public;\n', '    function doStateChanges() public;\n', '    function hasRequiredStateChanges() public view returns (bool);\n', '    function getRequiredStateChanges() public view returns (uint8, uint8);\n', '    function ApplicationInFundingOrDevelopment() public view returns(bool);\n', '\n', '}\n', '\n', '/*\n', '\n', ' * source       https://github.com/blockbitsio/\n', '\n', ' * @name        Milestones Contract\n', ' * @package     BlockBitsIO\n', ' * @author      Micky Socaci <micky@nowlive.ro>\n', '\n', ' Contains the Milestones Contract code deployed and linked to the Application Entity\n', '\n', '*/\n', '\n', '\n', '\n', '\n', '\n', 'contract ABIMilestones is ABIApplicationAsset {\n', '\n', '    struct Record {\n', '        bytes32 name;\n', '        string description;                     // will change to hash pointer ( external storage )\n', '        uint8 state;\n', '        uint256 duration;\n', '        uint256 time_start;                     // start at unixtimestamp\n', '        uint256 last_state_change_time;         // time of last state change\n', '        uint256 time_end;                       // estimated end time >> can be increased by proposal\n', '        uint256 time_ended;                     // actual end time\n', '        uint256 meeting_time;\n', '        uint8 funding_percentage;\n', '        uint8 index;\n', '    }\n', '\n', '    uint8 public currentRecord;\n', '    uint256 public MilestoneCashBackTime = 0;\n', '    mapping (uint8 => Record) public Collection;\n', '    mapping (bytes32 => bool) public MilestonePostponingHash;\n', '    mapping (bytes32 => uint256) public ProposalIdByHash;\n', '\n', '    function getBylawsProjectDevelopmentStart() public view returns (uint256);\n', '    function getBylawsMinTimeInTheFutureForMeetingCreation() public view returns (uint256);\n', '    function getBylawsCashBackVoteRejectedDuration() public view returns (uint256);\n', '    function addRecord( bytes32 _name, string _description, uint256 _duration, uint8 _perc ) public;\n', '    function getMilestoneFundingPercentage(uint8 recordId) public view returns (uint8);\n', '    function doStateChanges() public;\n', '    function getRecordStateRequiredChanges() public view returns (uint8);\n', '    function hasRequiredStateChanges() public view returns (bool);\n', '    function afterVoteNoCashBackTime() public view returns ( bool );\n', '    function getHash(uint8 actionType, bytes32 arg1, bytes32 arg2) public pure returns ( bytes32 );\n', '    function getCurrentHash() public view returns ( bytes32 );\n', '    function getCurrentProposalId() internal view returns ( uint256 );\n', '    function setCurrentMilestoneMeetingTime(uint256 _meeting_time) public;\n', '    function isRecordUpdateAllowed(uint8 _new_state ) public view returns (bool);\n', '    function getRequiredStateChanges() public view returns (uint8, uint8, uint8);\n', '    function ApplicationIsInDevelopment() public view returns(bool);\n', '    function MeetingTimeSetFailure() public view returns (bool);\n', '\n', '}\n', '\n', '/*\n', '\n', ' * source       https://github.com/blockbitsio/\n', '\n', ' * @name        Proposals Contract\n', ' * @package     BlockBitsIO\n', ' * @author      Micky Socaci <micky@nowlive.ro>\n', '\n', ' Contains the Proposals Contract code deployed and linked to the Application Entity\n', '\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Proposals is ApplicationAsset {\n', '\n', '    ApplicationEntityABI public Application;\n', '    ABIListingContract public ListingContractEntity;\n', '    ABIFunding public FundingEntity;\n', '    ABIFundingManager public FundingManagerEntity;\n', '    ABITokenManager public TokenManagerEntity;\n', '    ABIToken public TokenEntity;\n', '    ABIMilestones public MilestonesEntity;\n', '\n', '    function getRecordState(bytes32 name) public view returns (uint8) {\n', '        return RecordStates[name];\n', '    }\n', '\n', '    function getActionType(bytes32 name) public view returns (uint8) {\n', '        return ActionTypes[name];\n', '    }\n', '\n', '    function getProposalState(uint256 _proposalId) public view returns (uint8) {\n', '        return ProposalsById[_proposalId].state;\n', '    }\n', '\n', '    mapping (bytes32 => uint8) public ActionTypes;\n', '\n', '    function setActionTypes() internal {\n', '        // owner initiated\n', '        ActionTypes["MILESTONE_DEADLINE"] = 1;\n', '        ActionTypes["MILESTONE_POSTPONING"] = 2;\n', '        ActionTypes["EMERGENCY_FUND_RELEASE"] = 60;\n', '        ActionTypes["IN_DEVELOPMENT_CODE_UPGRADE"] = 50;\n', '\n', '        // shareholder initiated\n', '        ActionTypes["AFTER_COMPLETE_CODE_UPGRADE"] = 51;\n', '        ActionTypes["PROJECT_DELISTING"] = 75;\n', '    }\n', '\n', '\n', '    function setAssetStates() internal {\n', '\n', '        setActionTypes();\n', '\n', '        RecordStates["NEW"]                 = 1;\n', '        RecordStates["ACCEPTING_VOTES"]     = 2;\n', '        RecordStates["VOTING_ENDED"]        = 3;\n', '        RecordStates["VOTING_RESULT_YES"]   = 10;\n', '        RecordStates["VOTING_RESULT_NO"]    = 20;\n', '    }\n', '\n', '    event EventNewProposalCreated ( bytes32 indexed _hash, uint256 indexed _proposalId );\n', '\n', '    function runBeforeApplyingSettings()\n', '        internal\n', '        requireInitialised\n', '        requireSettingsNotApplied\n', '    {\n', "        address FundingAddress = getApplicationAssetAddressByName('Funding');\n", '        FundingEntity = ABIFunding(FundingAddress);\n', '\n', "        address FundingManagerAddress = getApplicationAssetAddressByName('FundingManager');\n", '        FundingManagerEntity = ABIFundingManager(FundingManagerAddress);\n', '\n', "        address TokenManagerAddress = getApplicationAssetAddressByName('TokenManager');\n", '        TokenManagerEntity = ABITokenManager(TokenManagerAddress);\n', '        TokenEntity = ABIToken(TokenManagerEntity.TokenEntity());\n', '\n', "        address ListingContractAddress = getApplicationAssetAddressByName('ListingContract');\n", '        ListingContractEntity = ABIListingContract(ListingContractAddress);\n', '\n', "        address MilestonesContractAddress = getApplicationAssetAddressByName('Milestones');\n", '        MilestonesEntity = ABIMilestones(MilestonesContractAddress);\n', '\n', '        EventRunBeforeApplyingSettings(assetName);\n', '    }\n', '\n', '    function getBylawsProposalVotingDuration() public view returns (uint256) {\n', '        return getAppBylawUint256("proposal_voting_duration");\n', '    }\n', '\n', '    function getBylawsMilestoneMinPostponing() public view returns (uint256) {\n', '        return getAppBylawUint256("min_postponing");\n', '    }\n', '\n', '    function getBylawsMilestoneMaxPostponing() public view returns (uint256) {\n', '        return getAppBylawUint256("max_postponing");\n', '    }\n', '\n', '    function getHash(uint8 actionType, bytes32 arg1, bytes32 arg2) public pure returns ( bytes32 ) {\n', '        return keccak256(actionType, arg1, arg2);\n', '    }\n', '\n', '\n', '    // need to implement a way to just iterate through active proposals, and remove the ones we already processed\n', '    // otherwise someone with malicious intent could add a ton of proposals, just to make our contract cost a ton of gas.\n', '\n', "    // to that end, we allow individual proposal processing. so that we don't get affected by people with too much\n", '    // money and time on their hands.\n', '\n', '    // whenever the system created a proposal, it will store the id, and process it when required.\n', '\n', '    // not that much of an issue at this stage because:\n', '    // NOW:\n', '    // - only the system can create - MILESTONE_DEADLINE\n', '    // - only the deployer can create - MILESTONE_POSTPONING / EMERGENCY_FUND_RELEASE / IN_DEVELOPMENT_CODE_UPGRADE\n', '\n', '    // FUTURE:\n', '    // - PROJECT_DELISTING is tied into an existing "listing id" which will be created by the system ( if requested by\n', '    // someone, but at quite a significant cost )\n', '    // - AFTER_COMPLETE_CODE_UPGRADE\n', '\n', '    mapping (uint8 => uint256) public ActiveProposalIds;\n', '    uint8 public ActiveProposalNum = 0;\n', '\n', '    mapping (uint256 => bool) public ExpiredProposalIds;\n', '\n', '    function process() public onlyApplicationEntity {\n', '        for(uint8 i = 0; i < ActiveProposalNum; i++) {\n', '\n', '            if(\n', '                getProposalType(ActiveProposalIds[i]) == getActionType("PROJECT_DELISTING") ||\n', '                getProposalType(ActiveProposalIds[i]) == getActionType("AFTER_COMPLETE_CODE_UPGRADE")\n', '            ) {\n', '                ProcessVoteTotals( ActiveProposalIds[i], VoteCountPerProcess );\n', '            } else {\n', '                // try expiry ending\n', '                tryEndVoting(ActiveProposalIds[i]);\n', '            }\n', '\n', '        }\n', '    }\n', '\n', '    function hasRequiredStateChanges() public view returns (bool) {\n', '        for(uint8 i = 0; i < ActiveProposalNum; i++) {\n', '            if( needsProcessing( ActiveProposalIds[i] ) ) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function getRequiredStateChanges() public view returns (uint8) {\n', '        if(hasRequiredStateChanges()) {\n', '            return ActiveProposalNum;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function addCodeUpgradeProposal(address _addr, bytes32 _sourceCodeUrl)\n', '        external\n', '        onlyApplicationEntity   // shareholder check is done directly in Gateway by calling applicationEntity to confirm\n', '        returns (uint256)\n', '    {\n', '\n', '        // hash enforces only 1 possible voting of this type per record.\n', '        // basically if a vote failed, you need to deploy it with changes to a new address. that simple.\n', '\n', '        // depending on the application overall state, we have 2 different voting implementations.\n', '\n', '        uint8 thisAction;\n', '\n', '        if(getApplicationState() == getApplicationEntityState("IN_DEVELOPMENT") ) {\n', '            thisAction = getActionType("IN_DEVELOPMENT_CODE_UPGRADE");\n', '\n', '        } else if(getApplicationState() == getApplicationEntityState("DEVELOPMENT_COMPLETE") ) {\n', '            thisAction = getActionType("AFTER_COMPLETE_CODE_UPGRADE");\n', '        }\n', '\n', '        return createProposal(\n', '            msg.sender,\n', '            "CODE_UPGRADE",\n', '            getHash( thisAction, bytes32(_addr), 0 ),\n', '            thisAction,\n', '            _addr,\n', '            _sourceCodeUrl,\n', '            0\n', '        );\n', '    }\n', '\n', '\n', '    function createMilestoneAcceptanceProposal()\n', '        external\n', '        onlyAsset("Milestones")\n', '        returns (uint256)\n', '    {\n', '\n', '        uint8 recordId = MilestonesEntity.currentRecord();\n', '        return createProposal(\n', '            msg.sender,\n', '            "MILESTONE_DEADLINE",\n', '            getHash( getActionType("MILESTONE_DEADLINE"), bytes32( recordId ), 0 ),\n', '            getActionType("MILESTONE_DEADLINE"),\n', '            0,\n', '            0,\n', '            uint256(recordId)\n', '        );\n', '    }\n', '\n', '    function createMilestonePostponingProposal(uint256 _duration)\n', '        external\n', '        onlyDeployer\n', '        returns (uint256)\n', '    {\n', '        if(_duration >= getBylawsMilestoneMinPostponing() && _duration <= getBylawsMilestoneMaxPostponing() ) {\n', '\n', '            uint8 recordId = MilestonesEntity.currentRecord();\n', '            return createProposal(\n', '                msg.sender,\n', '                "MILESTONE_POSTPONING",\n', '                getHash( getActionType("MILESTONE_POSTPONING"), bytes32( recordId ), 0 ),\n', '                getActionType("MILESTONE_POSTPONING"),\n', '                0,\n', '                0,\n', '                _duration\n', '            );\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function getCurrentMilestonePostponingProposalDuration() public view returns (uint256) {\n', '        uint8 recordId = MilestonesEntity.currentRecord();\n', '        bytes32 hash = getHash( getActionType("MILESTONE_POSTPONING"), bytes32( recordId ), 0 );\n', '        ProposalRecord memory proposal = ProposalsById[ ProposalIdByHash[hash] ];\n', '        return proposal.extra;\n', '    }\n', '\n', '    function getCurrentMilestoneProposalStatusForType(uint8 _actionType ) public view returns (uint8) {\n', '\n', '        if(_actionType == getActionType("MILESTONE_DEADLINE") || _actionType == getActionType("MILESTONE_POSTPONING")) {\n', '            uint8 recordId = MilestonesEntity.currentRecord();\n', '            bytes32 hash = getHash( _actionType, bytes32( recordId ), 0 );\n', '            uint256 ProposalId = ProposalIdByHash[hash];\n', '            ProposalRecord memory proposal = ProposalsById[ProposalId];\n', '            return proposal.state;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function createEmergencyFundReleaseProposal()\n', '        external\n', '        onlyDeployer\n', '        returns (uint256)\n', '    {\n', '        return createProposal(\n', '            msg.sender,\n', '            "EMERGENCY_FUND_RELEASE",\n', '            getHash( getActionType("EMERGENCY_FUND_RELEASE"), 0, 0 ),\n', '            getActionType("EMERGENCY_FUND_RELEASE"),\n', '            0,\n', '            0,\n', '            0\n', '        );\n', '    }\n', '\n', '    function createDelistingProposal(uint256 _projectId)\n', '        external\n', '        onlyTokenHolder\n', '        returns (uint256)\n', '    {\n', "        // let's validate the project is actually listed first in order to remove any spamming ability.\n", '        if( ListingContractEntity.canBeDelisted(_projectId) == true) {\n', '\n', '            return createProposal(\n', '                msg.sender,\n', '                "PROJECT_DELISTING",\n', '                getHash( getActionType("PROJECT_DELISTING"), bytes32(_projectId), 0 ),\n', '                getActionType("PROJECT_DELISTING"),\n', '                0,\n', '                0,\n', '                _projectId\n', '            );\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    modifier onlyTokenHolder() {\n', '        require( getTotalTokenVotingPower(msg.sender) > 0 );\n', '        _;\n', '    }\n', '\n', '    struct ProposalRecord {\n', '        address creator;\n', '        bytes32 name;\n', '        uint8 actionType;\n', '        uint8 state;\n', '        bytes32 hash;                       // action name + args hash\n', '        address addr;\n', '        bytes32 sourceCodeUrl;\n', '        uint256 extra;\n', '        uint256 time_start;\n', '        uint256 time_end;\n', '        uint256 index;\n', '    }\n', '\n', '    mapping (uint256 => ProposalRecord) public ProposalsById;\n', '    mapping (bytes32 => uint256) public ProposalIdByHash;\n', '\n', '    function createProposal(\n', '        address _creator,\n', '        bytes32 _name,\n', '        bytes32 _hash,\n', '        uint8   _action,\n', '        address _addr,\n', '        bytes32 _sourceCodeUrl,\n', '        uint256 _extra\n', '    )\n', '        internal\n', '        returns (uint256)\n', '    {\n', '\n', '        // if(_action > 0) {\n', '\n', '        if(ProposalIdByHash[_hash] == 0) {\n', '\n', '            ProposalRecord storage proposal = ProposalsById[++RecordNum];\n', '            proposal.creator        = _creator;\n', '            proposal.name           = _name;\n', '            proposal.actionType     = _action;\n', '            proposal.addr           = _addr;\n', '            proposal.sourceCodeUrl  = _sourceCodeUrl;\n', '            proposal.extra          = _extra;\n', '            proposal.hash           = _hash;\n', '            proposal.state          = getRecordState("NEW");\n', '            proposal.time_start     = getTimestamp();\n', '            proposal.time_end       = getTimestamp() + getBylawsProposalVotingDuration();\n', '            proposal.index          = RecordNum;\n', '\n', '            ProposalIdByHash[_hash] = RecordNum;\n', '\n', '        } else {\n', '            // already exists!\n', '            revert();\n', '        }\n', '\n', '        initProposalVoting(RecordNum);\n', '        EventNewProposalCreated ( _hash, RecordNum );\n', '        return RecordNum;\n', '\n', '        /*\n', '        } else {\n', '            // no action?!\n', '            revert();\n', '        }\n', '        */\n', '    }\n', '\n', '    function acceptCodeUpgrade(uint256 _proposalId) internal {\n', '        ProposalRecord storage proposal = ProposalsById[_proposalId];\n', '        // reinitialize this each time, because we rely on "owner" as the address, and it will change\n', '        Application = ApplicationEntityABI(owner);\n', '        Application.acceptCodeUpgradeProposal(proposal.addr);\n', '    }\n', '\n', '\n', '    function initProposalVoting(uint256 _proposalId) internal {\n', '\n', '        ResultRecord storage result = ResultsByProposalId[_proposalId];\n', '        ProposalRecord storage proposal = ProposalsById[_proposalId];\n', '\n', '        if(getApplicationState() == getApplicationEntityState("IN_DEVELOPMENT") ) {\n', '\n', '            if(proposal.actionType == getActionType("PROJECT_DELISTING") ) {\n', '                // while in development project delisting can be voted by all available tokens, except owner\n', '                uint256 ownerLockedTokens = TokenEntity.balanceOf(TokenManagerEntity);\n', '                result.totalAvailable = TokenEntity.totalSupply() - ownerLockedTokens;\n', '\n', "                // since we're counting unlocked tokens, we need to recount votes each time we want to end the voting period\n", '                result.requiresCounting = true;\n', '\n', '            } else {\n', '                // any other proposal is only voted by "locked ether", thus we use locked tokens\n', '                result.totalAvailable = FundingManagerEntity.LockedVotingTokens();\n', '\n', '                // locked tokens do not require recounting.\n', '                result.requiresCounting = false;\n', '            }\n', '\n', '        } else if(getApplicationState() == getApplicationEntityState("DEVELOPMENT_COMPLETE") ) {\n', '            // remove residual token balance from TokenManagerEntity.\n', '            uint256 residualLockedTokens = TokenEntity.balanceOf(TokenManagerEntity);\n', '            result.totalAvailable = TokenEntity.totalSupply() - residualLockedTokens;\n', '\n', "            // since we're counting unlocked tokens, we need to recount votes each time we want to end the voting period\n", '            result.requiresCounting = true;\n', '        }\n', '        result.requiredForResult = result.totalAvailable / 2;   // 50%\n', '\n', '        proposal.state = getRecordState("ACCEPTING_VOTES");\n', '        addActiveProposal(_proposalId);\n', '\n', '        tryFinaliseNonLockedTokensProposal(_proposalId);\n', '    }\n', '\n', '\n', '\n', '    /*\n', '\n', '    Voting\n', '\n', '    */\n', '\n', '    struct VoteStruct {\n', '        address voter;\n', '        uint256 time;\n', '        bool    vote;\n', '        uint256 power;\n', '        bool    annulled;\n', '        uint256 index;\n', '    }\n', '\n', '    struct ResultRecord {\n', '        uint256 totalAvailable;\n', '        uint256 requiredForResult;\n', '        uint256 totalSoFar;\n', '        uint256 yes;\n', '        uint256 no;\n', '        bool    requiresCounting;\n', '    }\n', '\n', '\n', '    mapping (uint256 => mapping (uint256 => VoteStruct) ) public VotesByProposalId;\n', '    mapping (uint256 => mapping (address => VoteStruct) ) public VotesByCaster;\n', '    mapping (uint256 => uint256 ) public VotesNumByProposalId;\n', '    mapping (uint256 => ResultRecord ) public ResultsByProposalId;\n', '\n', '    function RegisterVote(uint256 _proposalId, bool _myVote) public {\n', '        address Voter = msg.sender;\n', '\n', '        // get voting power\n', '        uint256 VoterPower = getVotingPower(_proposalId, Voter);\n', '\n', '        // get proposal for state\n', '        ProposalRecord storage proposal = ProposalsById[_proposalId];\n', '\n', '        // make sure voting power is greater than 0\n', '        // make sure proposal.state allows receiving votes\n', '        // make sure proposal.time_end has not passed.\n', '\n', '        if(VoterPower > 0 && proposal.state == getRecordState("ACCEPTING_VOTES")) {\n', '\n', '            // first check if this Voter has a record registered,\n', '            // and if they did, annul initial vote, update results, and add new one\n', '            if( hasPreviousVote(_proposalId, Voter) ) {\n', '                undoPreviousVote(_proposalId, Voter);\n', '            }\n', '\n', '            registerNewVote(_proposalId, Voter, _myVote, VoterPower);\n', '\n', '            // this is where we can end voting before time if result.yes or result.no > totalSoFar\n', '            tryEndVoting(_proposalId);\n', '\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function hasPreviousVote(uint256 _proposalId, address _voter) public view returns (bool) {\n', '        VoteStruct storage previousVoteByCaster = VotesByCaster[_proposalId][_voter];\n', '        if( previousVoteByCaster.power > 0 ) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function undoPreviousVote(uint256 _proposalId, address _voter) internal {\n', '\n', '        VoteStruct storage previousVoteByCaster = VotesByCaster[_proposalId][_voter];\n', '\n', '        // if( previousVoteByCaster.power > 0 ) {\n', '            previousVoteByCaster.annulled = true;\n', '\n', '            VoteStruct storage previousVoteByProposalId = VotesByProposalId[_proposalId][previousVoteByCaster.index];\n', '            previousVoteByProposalId.annulled = true;\n', '\n', '            ResultRecord storage result = ResultsByProposalId[_proposalId];\n', '\n', '            // update total so far as well\n', '            result.totalSoFar-= previousVoteByProposalId.power;\n', '\n', '            if(previousVoteByProposalId.vote == true) {\n', '                result.yes-= previousVoteByProposalId.power;\n', '            // } else if(previousVoteByProposalId.vote == false) {\n', '            } else {\n', '                result.no-= previousVoteByProposalId.power;\n', '            }\n', '        // }\n', '\n', '    }\n', '\n', '    function registerNewVote(uint256 _proposalId, address _voter, bool _myVote, uint256 _power) internal {\n', '\n', '        // handle new vote\n', '        uint256 currentVoteId = VotesNumByProposalId[_proposalId]++;\n', '        VoteStruct storage vote = VotesByProposalId[_proposalId][currentVoteId];\n', '            vote.voter = _voter;\n', '            vote.time = getTimestamp();\n', '            vote.vote = _myVote;\n', '            vote.power = _power;\n', '            vote.index = currentVoteId;\n', '\n', '        VotesByCaster[_proposalId][_voter] = VotesByProposalId[_proposalId][currentVoteId];\n', '\n', '        addVoteIntoResult(_proposalId, _myVote, _power );\n', '    }\n', '\n', '    event EventAddVoteIntoResult ( uint256 indexed _proposalId, bool indexed _type, uint256 indexed _power );\n', '\n', '    function addVoteIntoResult(uint256 _proposalId, bool _type, uint256 _power ) internal {\n', '\n', '        EventAddVoteIntoResult(_proposalId, _type, _power );\n', '\n', '        ResultRecord storage newResult = ResultsByProposalId[_proposalId];\n', '        newResult.totalSoFar+= _power;\n', '        if(_type == true) {\n', '            newResult.yes+= _power;\n', '        } else {\n', '            newResult.no+= _power;\n', '        }\n', '    }\n', '\n', '    function getTotalTokenVotingPower(address _voter) public view returns ( uint256 ) {\n', '        address VaultAddress = FundingManagerEntity.getMyVaultAddress(_voter);\n', '        uint256 VotingPower = TokenEntity.balanceOf(VaultAddress);\n', '        VotingPower+= TokenEntity.balanceOf(_voter);\n', '        return VotingPower;\n', '    }\n', '\n', '    function getVotingPower(uint256 _proposalId, address _voter) public view returns ( uint256 ) {\n', '        uint256 VotingPower = 0;\n', '        ProposalRecord storage proposal = ProposalsById[_proposalId];\n', '\n', '        if(proposal.actionType == getActionType("AFTER_COMPLETE_CODE_UPGRADE")) {\n', '\n', '            return TokenEntity.balanceOf(_voter);\n', '\n', '        } else {\n', '\n', '            address VaultAddress = FundingManagerEntity.getMyVaultAddress(_voter);\n', '            if(VaultAddress != address(0x0)) {\n', '                VotingPower = TokenEntity.balanceOf(VaultAddress);\n', '\n', '                if( proposal.actionType == getActionType("PROJECT_DELISTING") ) {\n', "                    // for project delisting, we want to also include tokens in the voter's wallet.\n", '                    VotingPower+= TokenEntity.balanceOf(_voter);\n', '                }\n', '            }\n', '        }\n', '        return VotingPower;\n', '    }\n', '\n', '\n', '    mapping( uint256 => uint256 ) public lastProcessedVoteIdByProposal;\n', '    mapping( uint256 => uint256 ) public ProcessedVotesByProposal;\n', '    mapping( uint256 => uint256 ) public VoteCountAtProcessingStartByProposal;\n', '    uint256 public VoteCountPerProcess = 10;\n', '\n', '    function setVoteCountPerProcess(uint256 _perProcess) external onlyDeployer {\n', '        if(_perProcess > 0) {\n', '            VoteCountPerProcess = _perProcess;\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    event EventProcessVoteTotals ( uint256 indexed _proposalId, uint256 indexed start, uint256 indexed end );\n', '\n', '    function ProcessVoteTotals(uint256 _proposalId, uint256 length) public onlyApplicationEntity {\n', '\n', '        uint256 start = lastProcessedVoteIdByProposal[_proposalId] + 1;\n', '        uint256 end = start + length - 1;\n', '        if(end > VotesNumByProposalId[_proposalId]) {\n', '            end = VotesNumByProposalId[_proposalId];\n', '        }\n', '\n', '        EventProcessVoteTotals(_proposalId, start, end);\n', '\n', '        // first run\n', '        if(start == 1) {\n', '            // save vote count at start, so we can reset if it changes\n', '            VoteCountAtProcessingStartByProposal[_proposalId] = VotesNumByProposalId[_proposalId];\n', '\n', '            // reset vote totals to 0\n', '            ResultRecord storage result = ResultsByProposalId[_proposalId];\n', '            result.yes = 0;\n', '            result.no = 0;\n', '            result.totalSoFar = 0;\n', '        }\n', '\n', '        // reset to start if vote count has changed in the middle of processing run\n', '        if(VoteCountAtProcessingStartByProposal[_proposalId] != VotesNumByProposalId[_proposalId]) {\n', '            // we received votes while counting\n', '            // reset from start\n', '            lastProcessedVoteIdByProposal[_proposalId] = 0;\n', '            // exit\n', '            return;\n', '        }\n', '\n', '        for(uint256 i = start; i <= end; i++) {\n', '\n', '            VoteStruct storage vote = VotesByProposalId[_proposalId][i - 1];\n', '            // process vote into totals.\n', '            if(vote.annulled != true) {\n', '                addVoteIntoResult(_proposalId, vote.vote, vote.power );\n', '            }\n', '\n', '            lastProcessedVoteIdByProposal[_proposalId]++;\n', '        }\n', '\n', '        // reset iterator so we can call it again.\n', '        if(lastProcessedVoteIdByProposal[_proposalId] >= VotesNumByProposalId[_proposalId] ) {\n', '\n', '            ProcessedVotesByProposal[_proposalId] = lastProcessedVoteIdByProposal[_proposalId];\n', '            lastProcessedVoteIdByProposal[_proposalId] = 0;\n', '            tryEndVoting(_proposalId);\n', '        }\n', '    }\n', '\n', '    function canEndVoting(uint256 _proposalId) public view returns (bool) {\n', '\n', '        ResultRecord memory result = ResultsByProposalId[_proposalId];\n', '        if(result.requiresCounting == false) {\n', '            if(result.yes > result.requiredForResult || result.no > result.requiredForResult) {\n', '                return true;\n', '            }\n', '        }\n', '        else {\n', '\n', '            if(ProcessedVotesByProposal[_proposalId] == VotesNumByProposalId[_proposalId]) {\n', '                if(result.yes > result.requiredForResult || result.no > result.requiredForResult) {\n', '                    return true;\n', '                }\n', '            }\n', '\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function getProposalType(uint256 _proposalId) public view returns (uint8) {\n', '        return ProposalsById[_proposalId].actionType;\n', '    }\n', '\n', '    function expiryChangesState(uint256 _proposalId) public view returns (bool) {\n', '        ProposalRecord memory proposal = ProposalsById[_proposalId];\n', '        if( proposal.state == getRecordState("ACCEPTING_VOTES") && proposal.time_end < getTimestamp() ) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function needsProcessing(uint256 _proposalId) public view returns (bool) {\n', '        if( expiryChangesState(_proposalId) ) {\n', '            return true;\n', '        }\n', '\n', '        ResultRecord memory result = ResultsByProposalId[_proposalId];\n', '        if(result.requiresCounting == true) {\n', '            if( lastProcessedVoteIdByProposal[_proposalId] < VotesNumByProposalId[_proposalId] ) {\n', '                if(ProcessedVotesByProposal[_proposalId] == VotesNumByProposalId[_proposalId]) {\n', '                    return false;\n', '                }\n', '            }\n', '\n', '        } else {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function tryEndVoting(uint256 _proposalId) internal {\n', '        if(canEndVoting(_proposalId)) {\n', '            finaliseProposal(_proposalId);\n', '        }\n', '\n', '        if(expiryChangesState(_proposalId) ) {\n', '            finaliseExpiredProposal(_proposalId);\n', '        }\n', '    }\n', '\n', '    function finaliseProposal(uint256 _proposalId) internal {\n', '\n', '        ResultRecord storage result = ResultsByProposalId[_proposalId];\n', '        ProposalRecord storage proposal = ProposalsById[_proposalId];\n', '\n', '        // Milestone Deadline proposals cannot be ended "by majority vote", we rely on finaliseExpiredProposal here\n', '        // because we want to allow everyone to be able to vote "NO" if they choose to cashback.\n', '\n', '        if( proposal.actionType != getActionType("MILESTONE_DEADLINE")) {\n', '            // read results,\n', '            if(result.yes > result.requiredForResult) {\n', '                // voting resulted in YES\n', '                proposal.state = getRecordState("VOTING_RESULT_YES");\n', '            } else if (result.no >= result.requiredForResult) {\n', '                // voting resulted in NO\n', '                proposal.state = getRecordState("VOTING_RESULT_NO");\n', '            }\n', '        }\n', '\n', '        runActionAfterResult(_proposalId);\n', '    }\n', '\n', '    function finaliseExpiredProposal(uint256 _proposalId) internal {\n', '\n', '        ResultRecord storage result = ResultsByProposalId[_proposalId];\n', '        ProposalRecord storage proposal = ProposalsById[_proposalId];\n', '\n', '        // an expired proposal with no votes will end as YES\n', '        if(result.yes == 0 && result.no == 0) {\n', '            proposal.state = getRecordState("VOTING_RESULT_YES");\n', '        } else {\n', '            // read results,\n', '            if(result.yes > result.no) {\n', '                // voting resulted in YES\n', '                proposal.state = getRecordState("VOTING_RESULT_YES");\n', '            } else if (result.no >= result.yes) {\n', '                // tie equals no\n', '                // voting resulted in NO\n', '                proposal.state = getRecordState("VOTING_RESULT_NO");\n', '            }\n', '        }\n', '        runActionAfterResult(_proposalId);\n', '    }\n', '\n', '    function tryFinaliseNonLockedTokensProposal(uint256 _proposalId) internal {\n', '\n', '        ResultRecord storage result = ResultsByProposalId[_proposalId];\n', '        ProposalRecord storage proposal = ProposalsById[_proposalId];\n', '\n', '        if(result.requiredForResult == 0) {\n', '            proposal.state = getRecordState("VOTING_RESULT_YES");\n', '            runActionAfterResult(_proposalId);\n', '        }\n', '    }\n', '\n', '    function addActiveProposal(uint256 _proposalId) internal {\n', '        ActiveProposalIds[ActiveProposalNum++]= _proposalId;\n', '    }\n', '\n', '    function removeAndReindexActive(uint256 _proposalId) internal {\n', '\n', '        bool found = false;\n', '        for (uint8 i = 0; i < ActiveProposalNum; i++) {\n', '            if(ActiveProposalIds[i] == _proposalId) {\n', '                found = true;\n', '            }\n', '            if(found) {\n', '                ActiveProposalIds[i] = ActiveProposalIds[i+1];\n', '            }\n', '        }\n', '\n', '        ActiveProposalNum--;\n', '    }\n', '\n', '\n', '    bool public EmergencyFundingReleaseApproved = false;\n', '\n', '    function runActionAfterResult(uint256 _proposalId) internal {\n', '\n', '        ProposalRecord storage proposal = ProposalsById[_proposalId];\n', '\n', '        if(proposal.state == getRecordState("VOTING_RESULT_YES")) {\n', '\n', '            if(proposal.actionType == getActionType("MILESTONE_DEADLINE")) {\n', '\n', '            } else if (proposal.actionType == getActionType("MILESTONE_POSTPONING")) {\n', '\n', '            } else if (proposal.actionType == getActionType("EMERGENCY_FUND_RELEASE")) {\n', '                EmergencyFundingReleaseApproved = true;\n', '\n', '            } else if (proposal.actionType == getActionType("PROJECT_DELISTING")) {\n', '\n', '                ListingContractEntity.delistChild( proposal.extra );\n', '\n', '            } else if (\n', '                proposal.actionType == getActionType("IN_DEVELOPMENT_CODE_UPGRADE") ||\n', '                proposal.actionType == getActionType("AFTER_COMPLETE_CODE_UPGRADE")\n', '            ) {\n', '\n', '                // initiate code upgrade\n', '                acceptCodeUpgrade(_proposalId);\n', '            }\n', '\n', '            removeAndReindexActive(_proposalId);\n', '\n', '        } else if(proposal.state == getRecordState("VOTING_RESULT_NO")) {\n', '\n', '            //\n', '            if(proposal.actionType == getActionType("MILESTONE_DEADLINE")) {\n', '\n', '            } else {\n', '                removeAndReindexActive(_proposalId);\n', '            }\n', '        }\n', '    }\n', '\n', '    // used by vault cash back\n', '    function getMyVoteForCurrentMilestoneRelease(address _voter) public view returns (bool) {\n', '        // find proposal id for current milestone\n', '        uint8 recordId = MilestonesEntity.currentRecord();\n', '        bytes32 hash = getHash( getActionType("MILESTONE_DEADLINE"), bytes32( recordId ), 0 );\n', '        uint256 proposalId = ProposalIdByHash[hash];\n', '        // based on that proposal id, find my vote\n', '        VoteStruct memory vote = VotesByCaster[proposalId][_voter];\n', '        return vote.vote;\n', '    }\n', '\n', '    function getHasVoteForCurrentMilestoneRelease(address _voter) public view returns (bool) {\n', '        // find proposal id for current milestone\n', '        uint8 recordId = MilestonesEntity.currentRecord();\n', '        bytes32 hash = getHash( getActionType("MILESTONE_DEADLINE"), bytes32( recordId ), 0 );\n', '        uint256 proposalId = ProposalIdByHash[hash];\n', '        return hasPreviousVote(proposalId, _voter);\n', '    }\n', '\n', '    function getMyVote(uint256 _proposalId, address _voter) public view returns (bool) {\n', '        VoteStruct memory vote = VotesByCaster[_proposalId][_voter];\n', '        return vote.vote;\n', '    }\n', '\n', '}']