['pragma solidity ^0.4.19;\n', '\n', 'contract owned {\n', '    address public owner;\n', '    address public candidate;\n', '\n', '    function owned() payable public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        candidate = _owner;\n', '    }\n', '    \n', '    function confirmOwner() public {\n', '        require(candidate == msg.sender);\n', '        owner = candidate;\n', '        delete candidate;\n', '    }\n', '}\n', '\n', 'contract CryptaurMigrations is owned\n', '{\n', '    address backend;\n', '    modifier backendOrOwner {\n', '        require(backend == msg.sender || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    mapping(bytes => address) addressByServices;\n', '    mapping(address => bytes) servicesbyAddress;\n', '\n', '    event AddService(uint dateTime, bytes serviceName, address serviceAddress);\n', '\n', '    function CryptaurMigrations() public owned() { }\n', '    \n', '    function setBackend(address _backend) onlyOwner public {\n', '        backend = _backend;\n', '    }\n', '    \n', '    function setService(bytes serviceName, address serviceAddress) public backendOrOwner\n', '    {\n', '\t\taddressByServices[serviceName] = serviceAddress;\n', '\t\tservicesbyAddress[serviceAddress] = serviceName;\n', '\t\tAddService(now, serviceName, serviceAddress);\n', '    }\n', '    \n', '    function getServiceAddress(bytes serviceName) public view returns(address)\n', '    {\n', '\t\treturn addressByServices[serviceName];\n', '    }\n', '\n', '    function getServiceName(address serviceAddress) public view returns(bytes)\n', '    {\n', '\t\treturn servicesbyAddress[serviceAddress];\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'contract owned {\n', '    address public owner;\n', '    address public candidate;\n', '\n', '    function owned() payable public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        candidate = _owner;\n', '    }\n', '    \n', '    function confirmOwner() public {\n', '        require(candidate == msg.sender);\n', '        owner = candidate;\n', '        delete candidate;\n', '    }\n', '}\n', '\n', 'contract CryptaurMigrations is owned\n', '{\n', '    address backend;\n', '    modifier backendOrOwner {\n', '        require(backend == msg.sender || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    mapping(bytes => address) addressByServices;\n', '    mapping(address => bytes) servicesbyAddress;\n', '\n', '    event AddService(uint dateTime, bytes serviceName, address serviceAddress);\n', '\n', '    function CryptaurMigrations() public owned() { }\n', '    \n', '    function setBackend(address _backend) onlyOwner public {\n', '        backend = _backend;\n', '    }\n', '    \n', '    function setService(bytes serviceName, address serviceAddress) public backendOrOwner\n', '    {\n', '\t\taddressByServices[serviceName] = serviceAddress;\n', '\t\tservicesbyAddress[serviceAddress] = serviceName;\n', '\t\tAddService(now, serviceName, serviceAddress);\n', '    }\n', '    \n', '    function getServiceAddress(bytes serviceName) public view returns(address)\n', '    {\n', '\t\treturn addressByServices[serviceName];\n', '    }\n', '\n', '    function getServiceName(address serviceAddress) public view returns(bytes)\n', '    {\n', '\t\treturn servicesbyAddress[serviceAddress];\n', '    }\n', '}']
