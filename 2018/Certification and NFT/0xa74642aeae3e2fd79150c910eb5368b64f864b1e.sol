['pragma solidity^0.4.24;\n', '\n', '/**\n', '                        MOBIUS 2D\n', '                     https://m2d.win \n', '                                       \n', '    This game was inspired by FOMO3D. Our code is much cleaner and more efficient (built from scratch).\n', '    Some useless "features" like the teams were not implemented.\n', ' \n', '    The Mobius2D game consists of rounds with guaranteed winners!\n', '    You buy "shares" (instad of keys) for a given round, and you get returns from investors after you.\n', '    The sare price is constant until the hard deadline, after which it increases exponentially. \n', '    If a round is inactive for a day it can end earlier than the hard deadline.\n', '    If a round runs longer, it is guaranteed to finish not much after the hard deadline (and the last investor gets the big jackpot).\n', '    Additionally, if you invest more than 0.1 ETH you get a chance to win an airdrop and you get bonus shares\n', '    Part of all funds also go to a big final jackpot - the last investor (before a round runs out) wins.\n', '    Payouts work in REAL TIME - you can withdraw your returns at any time!\n', '    Additionally, the first round is an ICO, so you&#39;ll also get our tokens by participating!\n', '    !!!!!!!!!!!!!!\n', '    Token holders will receive part of current and future revenue of this and any other game we develop!\n', '    !!!!!!!!!!!!!!\n', '    \n', '    .................................. LAUGHING MAN sssyyhddmN..........................................\n', '    ..........................Nmdyyso+/:--.``` :`  `-`:--:/+ossyhdmN....................................\n', '    ......................Ndhyso/:.`   --.     o.  /+`o::` `` `-:+osyh..................................\n', '    ..................MNdyso/-` /-`/:+./:/..`  +.  //.o +.+::+ -`  `-/sshdN.............................\n', '    ................Ndyso:` ` --:+`o//.-:-```  ...  ``` - /::::/ +..-` ./osh............................\n', '    ..............Nhso/. .-.:/`o--:``   `..-:::oss+::--.``    .:/::/`+-`/../sydN........................\n', '    ............mhso-``-:+./:-:.   .-/+osssssssssssssssssso+:-`  -//o::+:/` .:oyhN......................\n', '    ..........Nhso:`  .+-./ `  .:+sssssso+//:-------:://+ossssso/---.`-`/:-o/ `:syd.....................\n', '    ........Mdyo- +/../`-`  ./osssso/-.`                 ``.:+ossss+:`  `-+`  ` `/sy....................\n', '    ......MNys/` -:-/:    -+ssss+-`                           `.:+ssss/.  `  -+-. .osh..................\n', '    ......mys-  :-/+-`  :osss+-`                                  .:osss+.  `//o:- `/syN................\n', '    ....Mdso. --:-/-  -osss+.                                       `-osss+`  :--://`-sy................\n', '    ....dso-. ++:+  `/sss+.                                           `:osss:  `:.-+  -sy...............\n', '    ..Mdso``+///.` .osss:                                               `/sss+`  :/-.. -syN.............\n', '    ..mss` `+::/  .ssso.                                                  :sss+` `+:/+  -syN............\n', '    ..ys-   ```  .ssso`                                                    -sss+` `:::+:`/sh............\n', '    Mds+ `:/..  `osso`                                                      -sss+  -:`.` `ssN...........\n', '    Mys. `/+::  +sss/........................................................+sss:.....-::+sy..NN.......\n', '    ds+  :-/-  .ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssyyhdN...\n', '    hs: `/+::   :/+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ossssyhNM\n', '    ss. `:::`                    ````                        ```                               ``-+sssyN\n', '    ss` /:-+` `o++:           .:+oooo+/.                 `-/ooooo+-`                               -sssy\n', '    ss  `:/:  `sss/          :ooo++/++os/`              .oso++/++oso.                               osss\n', '    ss``/:--  `sss/         ./.`      `.::              /-.`     ``-/`                             -sssy\n', '    ss.:::-:.  ssso         `            `                                                    ``.-+sssyN\n', '    hs:`:/:/.  /sss.   .++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++oossssyhNM\n', '    ds+ ``     .sss/   -ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssyyyyhmN...\n', '    Nss.:::::.  +sss.   +sss/........................................osss:...+sss:......../shmNNN.......\n', '    Mds+..-:::` `osso`  `+sss:                                     `+sss:   -sss+  .:-.` `ssN...........\n', '    ..ys- .+.::  .ssso`  `/sss+.                                  -osss:   -sss+` `:++-` /sh............\n', '    ..mss` .-.    .ssso.   :osss/`                              .+ssso.   :sss+` `.:+:` -syN............\n', '    ..Mdso`  `--:` .osss:   `/ssss/.`                        `-+ssso:`  `/sss+` `++.-. -syN.............\n', '    ....dso` -//+-` `/sss+.   ./ossso/-``                `.:+sssso:`  `:osss:  .::+/. -sy...............\n', '    ....Mdso. `-//-`  -osss+.   `-+ssssso+/:-.`````..-:/+osssso/.   `-osss+.` -///-  -sy................\n', '    ......mys- `/://.`  :osss+-`   `-/+osssssssssssssssssso+:.    .:osss+.  .:`..-``/syN................\n', '    ......MNys/` ..+-/:   -+ssss+-`    `.-://++oooo++/:-.`    `.:+ssss/.  .`      .osh..................\n', '    ........Mdyo- `::/.  `  ./osssso/-.`                 ``.:+ossss+:` `  .//`  `/sy....................\n', '    ..........Nhso-     :+:.`  .:+sssssso+//:--------://+ossssso/:.  `::/: --/.:syd.....................\n', '    ............mhso-` ./+--+-:    .-/+osssssssssssssssssso+/-.  .+` `//-/ `::oyhN......................\n', '    ..............Nhso/`   +/:--+.-`    `..-:::////::--.``    .`:/-o`  ./`./sydN........................\n', '    ................Ndys+:` ``--+++-  .:  `.``      `` -.`/:/`.o./::.  ./osh............................\n', '    ..................MNdyso/-` ` :`  +-  :+.o`s ::-/++`s`+/o.-:`  `-/sshdN.............................\n', '    ......................Ndhyso/:.` .+   +/:/ +:/-./:-`+: `` `.:+osyh..................................\n', '    ..........................Nmdyyso+/:--/.``      ``..-:/+ossyhdmN....................................\n', '    ..............................MN..dhhyyssssssssssssyyhddmN..........................................\n', ' */\n', ' \n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', '    // It&#39;s O(log n), instead of O(n) for naive repeated multiplication.\n', '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'interface MobiusToken {\n', '    function mint(address _to, uint _amount) external;\n', '    function finishMinting() external returns (bool);\n', '    function disburseDividends() external payable;\n', '}\n', ' \n', 'contract Mobius2D is DSMath, DSAuth {\n', '    // IPFS hash of the website - can be accessed even if our domain goes down.\n', '    // Just go to any public IPFS gateway and use this hash - e.g. ipfs.infura.io/ipfs/<ipfsHash>\n', '    string public ipfsHash;\n', '    string public ipfsHashType = "ipfs"; // can either be ipfs, or ipns\n', '\n', '    MobiusToken public token;\n', '\n', '    // In case of an upgrade, these variables will be set. An upgrade does not affect a currently running round,\n', '    // nor does it do anything with investors&#39; vaults.\n', '    bool public upgraded;\n', '    address public nextVersion;\n', '\n', '    // Total stats\n', '    uint public totalSharesSold;\n', '    uint public totalEarningsGenerated;\n', '    uint public totalDividendsPaid;\n', '    uint public totalJackpotsWon;\n', '\n', '    // Fractions for where revenue goes\n', '    uint public constant DEV_FRACTION = WAD / 20;             // 5% goes to devs\n', '    uint public constant DEV_DIVISOR = 20;             // 5% \n', '\n', '    uint public constant RETURNS_FRACTION = 65 * 10**16;      // 65% goes to share holders\n', '    // 1% if it is a referral purchase, this value will be taken from the above fraction (e.g. if 1% is for refferals, then 64% goes to returns) \n', '    uint public constant REFERRAL_FRACTION = 1 * 10**16;  \n', '    uint public constant JACKPOT_SEED_FRACTION = WAD / 20;    // 5% goes to the next round&#39;s jackpot\n', '    uint public constant JACKPOT_FRACTION = 15 * 10**16;      // 15% goes to the final jackpot\n', '    uint public constant AIRDROP_FRACTION = WAD / 100;        // 1% goes to airdrops\n', '    uint public constant DIVIDENDS_FRACTION = 9 * 10**16;     // 9% goes to token holders!\n', '\n', '    uint public constant STARTING_SHARE_PRICE = 1 finney; // a 1000th of an ETH\n', '    uint public constant PRICE_INCREASE_PERIOD = 1 hours; // how often the price doubles after the hard deadline\n', '\n', '    uint public constant HARD_DEADLINE_DURATION = 30 days; // hard deadline is this much after the round start\n', '    uint public constant SOFT_DEADLINE_DURATION = 1 days; // max soft deadline\n', '    uint public constant TIME_PER_SHARE = 5 minutes; // how much time is added to the soft deadline per share purchased\n', '    \n', '    uint public jackpotSeed;// Jackpot from previous rounds\n', '    uint public devBalance; // outstanding balance for devs\n', '    uint public raisedICO;\n', '\n', '    // Helpers to calculate returns - no funds are ever held on lockdown\n', '    uint public unclaimedReturns;\n', '    uint public constant MULTIPLIER = RAY;\n', '\n', '    // This represents an investor. No need to player IDs - they are useless (everyone already has a unique address).\n', '    // Just use native mappings (duh!)\n', '    struct Investor {\n', '        uint lastCumulativeReturnsPoints;\n', '        uint shares;\n', '    }\n', '\n', '    // This represents a round\n', '    struct MobiusRound {\n', '        uint totalInvested;        \n', '        uint jackpot;\n', '        uint airdropPot;\n', '        uint totalShares;\n', '        uint cumulativeReturnsPoints; // this is to help calculate returns when the total number of shares changes\n', '        uint hardDeadline;\n', '        uint softDeadline;\n', '        uint price;\n', '        uint lastPriceIncreaseTime;\n', '        address lastInvestor;\n', '        bool finalized;\n', '        mapping (address => Investor) investors;\n', '    }\n', '\n', '    struct Vault {\n', '        uint totalReturns; // Total balance = returns + referral returns + jackpots/airdrops \n', '        uint refReturns; // how much of the total is from referrals\n', '    }\n', '\n', '    mapping (address => Vault) vaults;\n', '\n', '    uint public latestRoundID;// the first round has an ID of 0\n', '    MobiusRound[] rounds;\n', '\n', '    event SharesIssued(address indexed to, uint shares);\n', '    event ReturnsWithdrawn(address indexed by, uint amount);\n', '    event JackpotWon(address by, uint amount);\n', '    event AirdropWon(address by, uint amount);\n', '    event RoundStarted(uint indexed ID, uint hardDeadline);\n', '    event IPFSHashSet(string _type, string _hash);\n', '\n', '    constructor(address _token) public {\n', '        token = MobiusToken(_token);\n', '    }\n', '\n', '    // The return values will include all vault balance, but you must specify a roundID because\n', '    // Returns are not actually calculated in storage until you invest in the round or withdraw them\n', '    function estimateReturns(address investor, uint roundID) public view \n', '    returns (uint totalReturns, uint refReturns) \n', '    {\n', '        MobiusRound storage rnd = rounds[roundID];\n', '        uint outstanding;\n', '        if(rounds.length > 1) {\n', '            if(hasReturns(investor, roundID - 1)) {\n', '                MobiusRound storage prevRnd = rounds[roundID - 1];\n', '                outstanding = _outstandingReturns(investor, prevRnd);\n', '            }\n', '        }\n', '\n', '        outstanding += _outstandingReturns(investor, rnd);\n', '        \n', '        totalReturns = vaults[investor].totalReturns + outstanding;\n', '        refReturns = vaults[investor].refReturns;\n', '    }\n', '\n', '    function hasReturns(address investor, uint roundID) public view returns (bool) {\n', '        MobiusRound storage rnd = rounds[roundID];\n', '        return rnd.cumulativeReturnsPoints > rnd.investors[investor].lastCumulativeReturnsPoints;\n', '    }\n', '\n', '    function investorInfo(address investor, uint roundID) external view\n', '    returns(uint shares, uint totalReturns, uint referralReturns) \n', '    {\n', '        MobiusRound storage rnd = rounds[roundID];\n', '        shares = rnd.investors[investor].shares;\n', '        (totalReturns, referralReturns) = estimateReturns(investor, roundID);\n', '    }\n', '\n', '    function roundInfo(uint roundID) external view \n', '    returns(\n', '        address leader, \n', '        uint price,\n', '        uint jackpot, \n', '        uint airdrop, \n', '        uint shares, \n', '        uint totalInvested,\n', '        uint distributedReturns,\n', '        uint _hardDeadline,\n', '        uint _softDeadline,\n', '        bool finalized\n', '        )\n', '    {\n', '        MobiusRound storage rnd = rounds[roundID];\n', '        leader = rnd.lastInvestor;\n', '        price = rnd.price;\n', '        jackpot = rnd.jackpot;\n', '        airdrop = rnd.airdropPot;\n', '        shares = rnd.totalShares;\n', '        totalInvested = rnd.totalInvested;\n', '        distributedReturns = wmul(rnd.totalInvested, RETURNS_FRACTION);\n', '        _hardDeadline = rnd.hardDeadline;\n', '        _softDeadline = rnd.softDeadline;\n', '        finalized = rnd.finalized;\n', '    }\n', '\n', '    function totalsInfo() external view \n', '    returns(\n', '        uint totalReturns,\n', '        uint totalShares,\n', '        uint totalDividends,\n', '        uint totalJackpots\n', '    ) {\n', '        MobiusRound storage rnd = rounds[latestRoundID];\n', '        if(rnd.softDeadline > now) {\n', '            totalShares = totalSharesSold + rnd.totalShares;\n', '            totalReturns = totalEarningsGenerated + wmul(rnd.totalInvested, RETURNS_FRACTION);\n', '            totalDividends = totalDividendsPaid + wmul(rnd.totalInvested, DIVIDENDS_FRACTION);\n', '        } else {\n', '            totalShares = totalSharesSold;\n', '            totalReturns = totalEarningsGenerated;\n', '            totalDividends = totalDividendsPaid;\n', '        }\n', '        totalJackpots = totalJackpotsWon;\n', '    }\n', '\n', '    function () public payable {\n', '        buyShares(address(0x0));\n', '    }\n', '\n', '    /// Function to buy shares in the latest round. Purchase logic is abstracted\n', '    function buyShares(address ref) public payable {        \n', '        if(rounds.length > 0) {\n', '            MobiusRound storage rnd = rounds[latestRoundID];   \n', '               \n', '            _purchase(rnd, msg.value, ref);            \n', '        } else {\n', '            revert("Not yet started");\n', '        }\n', '    }\n', '\n', '    /// Function to purchase with what you have in your vault as returns\n', '    function reinvestReturns(uint value) public {        \n', '        reinvestReturns(value, address(0x0));\n', '    }\n', '\n', '    function reinvestReturns(uint value, address ref) public {        \n', '        MobiusRound storage rnd = rounds[latestRoundID];\n', '        _updateReturns(msg.sender, rnd);        \n', '        require(vaults[msg.sender].totalReturns >= value, "Can&#39;t spend what you don&#39;t have");        \n', '        vaults[msg.sender].totalReturns = sub(vaults[msg.sender].totalReturns, value);\n', '        vaults[msg.sender].refReturns = min(vaults[msg.sender].refReturns, vaults[msg.sender].totalReturns);\n', '        unclaimedReturns = sub(unclaimedReturns, value);\n', '        _purchase(rnd, value, ref);\n', '    }\n', '\n', '    function withdrawReturns() public {\n', '        MobiusRound storage rnd = rounds[latestRoundID];\n', '\n', '        if(rounds.length > 1) {// check if they also have returns from before\n', '            if(hasReturns(msg.sender, latestRoundID - 1)) {\n', '                MobiusRound storage prevRnd = rounds[latestRoundID - 1];\n', '                _updateReturns(msg.sender, prevRnd);\n', '            }\n', '        }\n', '        _updateReturns(msg.sender, rnd);\n', '        uint amount = vaults[msg.sender].totalReturns;\n', '        require(amount > 0, "Nothing to withdraw!");\n', '        unclaimedReturns = sub(unclaimedReturns, amount);\n', '        vaults[msg.sender].totalReturns = 0;\n', '        vaults[msg.sender].refReturns = 0;\n', '        \n', '        rnd.investors[msg.sender].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\n', '        msg.sender.transfer(amount);\n', '\n', '        emit ReturnsWithdrawn(msg.sender, amount);\n', '    }\n', '\n', '    // Manually update your returns for a given round in case you were inactive since before it ended\n', '    function updateMyReturns(uint roundID) public {\n', '        MobiusRound storage rnd = rounds[roundID];\n', '        _updateReturns(msg.sender, rnd);\n', '    }\n', '\n', '    function finalizeAndRestart() public payable {\n', '        finalizeLastRound();\n', '        startNewRound();\n', '    }\n', '\n', '    /// Anyone can start a new round\n', '    function startNewRound() public payable {\n', '        require(!upgraded, "This contract has been upgraded!");\n', '        if(rounds.length > 0) {\n', '            require(rounds[latestRoundID].finalized, "Previous round not finalized");\n', '            require(rounds[latestRoundID].softDeadline < now, "Previous round still running");\n', '        }\n', '        uint _rID = rounds.length++;\n', '        MobiusRound storage rnd = rounds[_rID];\n', '        latestRoundID = _rID;\n', '\n', '        rnd.lastInvestor = msg.sender;\n', '        rnd.price = STARTING_SHARE_PRICE;\n', '        rnd.hardDeadline = now + HARD_DEADLINE_DURATION;\n', '        rnd.softDeadline = now + SOFT_DEADLINE_DURATION;\n', '        rnd.jackpot = jackpotSeed;\n', '        jackpotSeed = 0; \n', '\n', '        _purchase(rnd, msg.value, address(0x0));\n', '        emit RoundStarted(_rID, rnd.hardDeadline);\n', '    }\n', '\n', '    /// Anyone can finalize a finished round\n', '    function finalizeLastRound() public {\n', '        MobiusRound storage rnd = rounds[latestRoundID];\n', '        _finalizeRound(rnd);\n', '    }\n', '    \n', '    /// This is how devs pay the bills\n', '    function withdrawDevShare() public auth {\n', '        uint value = devBalance;\n', '        devBalance = 0;\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    function setIPFSHash(string _type, string _hash) public auth {\n', '        ipfsHashType = _type;\n', '        ipfsHash = _hash;\n', '        emit IPFSHashSet(_type, _hash);\n', '    }\n', '\n', '    function upgrade(address _nextVersion) public auth {\n', '        require(_nextVersion != address(0x0), "Invalid Address!");\n', '        require(!upgraded, "Already upgraded!");\n', '        upgraded = true;\n', '        nextVersion = _nextVersion;\n', '        if(rounds[latestRoundID].finalized) {\n', '            //if last round was finalized (and no new round was started), transfer the jackpot seed to the new version\n', '            vaults[nextVersion].totalReturns = jackpotSeed;\n', '            jackpotSeed = 0;\n', '        }\n', '    }\n', '\n', '    /// Purchase logic\n', '    function _purchase(MobiusRound storage rnd, uint value, address ref) internal {\n', '        require(rnd.softDeadline >= now, "After deadline!");\n', '        require(value >= rnd.price/10, "Not enough Ether!");\n', '        rnd.totalInvested = add(rnd.totalInvested, value);\n', '\n', '        // Set the last investor (to win the jackpot after the deadline)\n', '        if(value >= rnd.price)\n', '            rnd.lastInvestor = msg.sender;\n', '        // Check out airdrop \n', '        _airDrop(rnd, value);\n', '        // Process revenue in different "buckets"\n', '        _splitRevenue(rnd, value, ref);\n', '        // Update returns before issuing shares\n', '        _updateReturns(msg.sender, rnd);\n', '        //issue shares for the current round. 1 share = 1 time increase for the deadline\n', '        uint newShares = _issueShares(rnd, msg.sender, value);\n', '\n', '        //Mint tokens during the first round\n', '        if(rounds.length == 1) {\n', '            token.mint(msg.sender, newShares);\n', '        }\n', '        uint timeIncreases = newShares/WAD;// since 1 share is represented by 1 * 10^18, divide by 10^18\n', '        // adjust soft deadline to new soft deadline\n', '        uint newDeadline = add(rnd.softDeadline, mul(timeIncreases, TIME_PER_SHARE));\n', '        rnd.softDeadline = min(newDeadline, now + SOFT_DEADLINE_DURATION);\n', '        // If after hard deadline, double the price every price increase periods\n', '        if(now > rnd.hardDeadline) {\n', '            if(now > rnd.lastPriceIncreaseTime + PRICE_INCREASE_PERIOD) {\n', '                rnd.price = rnd.price * 2;\n', '                rnd.lastPriceIncreaseTime = now;\n', '            }\n', '        }\n', '    }\n', '\n', '    function _finalizeRound(MobiusRound storage rnd) internal {\n', '        require(!rnd.finalized, "Already finalized!");\n', '        require(rnd.softDeadline < now, "Round still running!");\n', '\n', '        if(rounds.length == 1) {\n', '            // After finishing minting tokens they will be transferable and dividends will be available!\n', '            require(token.finishMinting(), "Couldn&#39;t finish minting tokens!");\n', '        }\n', '        // Transfer jackpot to winner&#39;s vault\n', '        vaults[rnd.lastInvestor].totalReturns = add(vaults[rnd.lastInvestor].totalReturns, rnd.jackpot);\n', '        unclaimedReturns = add(unclaimedReturns, rnd.jackpot);\n', '        \n', '        emit JackpotWon(rnd.lastInvestor, rnd.jackpot);\n', '        totalJackpotsWon += rnd.jackpot;\n', '        // transfer the leftover to the next round&#39;s jackpot\n', '        jackpotSeed = add(jackpotSeed, wmul(rnd.totalInvested, JACKPOT_SEED_FRACTION));\n', '        //Empty the AD pot if it has a balance.\n', '        jackpotSeed = add(jackpotSeed, rnd.airdropPot);\n', '        if(upgraded) {\n', '            // if upgraded transfer the jackpot seed to the new version\n', '            vaults[nextVersion].totalReturns = jackpotSeed;\n', '            jackpotSeed = 0; \n', '        }        \n', '        //Send out dividends to token holders\n', '        uint _div;\n', '        if(rounds.length == 1){\n', '            // 2% during the first round, and the normal fraction otherwise\n', '            _div = wmul(rnd.totalInvested, 2 * 10**16);            \n', '        } else {\n', '            _div = wmul(rnd.totalInvested, DIVIDENDS_FRACTION);            \n', '        }\n', '        token.disburseDividends.value(_div)();\n', '        totalDividendsPaid += _div;\n', '        totalSharesSold += rnd.totalShares;\n', '        totalEarningsGenerated += wmul(rnd.totalInvested, RETURNS_FRACTION);\n', '\n', '        rnd.finalized = true;\n', '    }\n', '\n', '    /** \n', '        This is where the magic happens: every investor gets an exact share of all returns proportional to their shares\n', '        If you&#39;re early, you&#39;ll have a larger share for longer, so obviously you earn more.\n', '    */\n', '    function _updateReturns(address _investor, MobiusRound storage rnd) internal {\n', '        if(rnd.investors[_investor].shares == 0) {\n', '            return;\n', '        }\n', '        \n', '        uint outstanding = _outstandingReturns(_investor, rnd);\n', '\n', '        // if there are any returns, transfer them to the investor&#39;s vaults\n', '        if (outstanding > 0) {\n', '            vaults[_investor].totalReturns = add(vaults[_investor].totalReturns, outstanding);\n', '        }\n', '\n', '        rnd.investors[_investor].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\n', '    }\n', '\n', '    function _outstandingReturns(address _investor, MobiusRound storage rnd) internal view returns(uint) {\n', '        if(rnd.investors[_investor].shares == 0) {\n', '            return 0;\n', '        }\n', '        // check if there&#39;ve been new returns\n', '        uint newReturns = sub(\n', '            rnd.cumulativeReturnsPoints, \n', '            rnd.investors[_investor].lastCumulativeReturnsPoints\n', '            );\n', '\n', '        uint outstanding = 0;\n', '        if(newReturns != 0) { \n', '            // outstanding returns = (total new returns points * ivestor shares) / MULTIPLIER\n', '            // The MULTIPLIER is used also at the point of returns disbursment\n', '            outstanding = mul(newReturns, rnd.investors[_investor].shares) / MULTIPLIER;\n', '        }\n', '\n', '        return outstanding;\n', '    }\n', '\n', '    /// Process revenue according to fractions\n', '    function _splitRevenue(MobiusRound storage rnd, uint value, address ref) internal {\n', '        uint roundReturns;\n', '        uint returnsOffset;\n', '        if(rounds.length == 1){\n', '            returnsOffset = 13 * 10**16;// during the first round reduce returns (by 13%) and give more to the ICO\n', '        }\n', '        if(ref != address(0x0)) {\n', '            // if there was a referral\n', '            roundReturns = wmul(value, RETURNS_FRACTION - REFERRAL_FRACTION - returnsOffset);\n', '            uint _ref = wmul(value, REFERRAL_FRACTION);\n', '            vaults[ref].totalReturns = add(vaults[ref].totalReturns, _ref);            \n', '            vaults[ref].refReturns = add(vaults[ref].refReturns, _ref);\n', '            unclaimedReturns = add(unclaimedReturns, _ref);\n', '        } else {\n', '            roundReturns = wmul(value, RETURNS_FRACTION - returnsOffset);\n', '        }\n', '        \n', '        uint airdrop = wmul(value, AIRDROP_FRACTION);\n', '        uint jackpot = wmul(value, JACKPOT_FRACTION);\n', '        \n', '        uint dev;\n', '        // During the ICO, devs get 25% (5% originally, 7% from the dividends fraction, \n', '        // and 13% from the returns), leaving 2% for dividends, and 52% for returns \n', '        // This is only during the first round, and later rounds leave the original fractions:\n', '        // 5% for devs, 9% dividends, 65% returns \n', '        if(rounds.length == 1){\n', '            // calculate dividends at the end, no need to do it at every purchase\n', '            dev = value / 4; // 25% \n', '            raisedICO += dev;\n', '        } else {\n', '            dev = value / DEV_DIVISOR;\n', '        }\n', '        // if this is the first purchase, send to jackpot (no one can claim these returns otherwise)\n', '        if(rnd.totalShares == 0) {\n', '            rnd.jackpot = add(rnd.jackpot, roundReturns);\n', '        } else {\n', '            _disburseReturns(rnd, roundReturns);\n', '        }\n', '        \n', '        rnd.airdropPot = add(rnd.airdropPot, airdrop);\n', '        rnd.jackpot = add(rnd.jackpot, jackpot);\n', '        devBalance = add(devBalance, dev);\n', '    }\n', '\n', '    function _disburseReturns(MobiusRound storage rnd, uint value) internal {\n', '        unclaimedReturns = add(unclaimedReturns, value);// keep track of unclaimed returns\n', '        // The returns points represent returns*MULTIPLIER/totalShares (at the point of purchase)\n', '        // This allows us to keep outstanding balances of shareholders when the total supply changes in real time\n', '        if(rnd.totalShares == 0) {\n', '            rnd.cumulativeReturnsPoints = mul(value, MULTIPLIER) / wdiv(value, rnd.price);\n', '        } else {\n', '            rnd.cumulativeReturnsPoints = add(\n', '                rnd.cumulativeReturnsPoints, \n', '                mul(value, MULTIPLIER) / rnd.totalShares\n', '            );\n', '        }\n', '    }\n', '\n', '    function _issueShares(MobiusRound storage rnd, address _investor, uint value) internal returns(uint) {    \n', '        if(rnd.investors[_investor].lastCumulativeReturnsPoints == 0) {\n', '            rnd.investors[_investor].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\n', '        }    \n', '        \n', '        uint newShares = wdiv(value, rnd.price);\n', '        \n', '        //bonuses:\n', '        if(value >= 100 ether) {\n', '            newShares = mul(newShares, 2);//get double shares if you paid more than 100 ether\n', '        } else if(value >= 10 ether) {\n', '            newShares = add(newShares, newShares/2);//50% bonus\n', '        } else if(value >= 1 ether) {\n', '            newShares = add(newShares, newShares/3);//33% bonus\n', '        } else if(value >= 100 finney) {\n', '            newShares = add(newShares, newShares/10);//10% bonus\n', '        }\n', '\n', '        rnd.investors[_investor].shares = add(rnd.investors[_investor].shares, newShares);\n', '        rnd.totalShares = add(rnd.totalShares, newShares);\n', '        emit SharesIssued(_investor, newShares);\n', '        return newShares;\n', '    }    \n', '\n', '    function _airDrop(MobiusRound storage rnd, uint value) internal {\n', '        require(msg.sender == tx.origin, "ONLY HOOMANS (or scripts that don&#39;t use smart contracts)!");\n', '        if(value > 100 finney) {\n', '            /**\n', '                Creates a random number from the last block hash and current timestamp.\n', '                One could add more seemingly random data like the msg.sender, etc, but that doesn&#39;t \n', '                make it harder for a miner to manipulate the result in their favor (if they intended to).\n', '             */\n', '            uint chance = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), now)));\n', '            if(chance % 200 == 0) {// once in 200 times\n', '                uint prize = rnd.airdropPot / 2;// win half of the pot, regardless of how much you paid\n', '                rnd.airdropPot = rnd.airdropPot / 2;\n', '                vaults[msg.sender].totalReturns = add(vaults[msg.sender].totalReturns, prize);\n', '                unclaimedReturns = add(unclaimedReturns, prize);\n', '                totalJackpotsWon += prize;\n', '                emit AirdropWon(msg.sender, prize);\n', '            }\n', '        }\n', '    }\n', '}']
['pragma solidity^0.4.24;\n', '\n', '/**\n', '                        MOBIUS 2D\n', '                     https://m2d.win \n', '                                       \n', '    This game was inspired by FOMO3D. Our code is much cleaner and more efficient (built from scratch).\n', '    Some useless "features" like the teams were not implemented.\n', ' \n', '    The Mobius2D game consists of rounds with guaranteed winners!\n', '    You buy "shares" (instad of keys) for a given round, and you get returns from investors after you.\n', '    The sare price is constant until the hard deadline, after which it increases exponentially. \n', '    If a round is inactive for a day it can end earlier than the hard deadline.\n', '    If a round runs longer, it is guaranteed to finish not much after the hard deadline (and the last investor gets the big jackpot).\n', '    Additionally, if you invest more than 0.1 ETH you get a chance to win an airdrop and you get bonus shares\n', '    Part of all funds also go to a big final jackpot - the last investor (before a round runs out) wins.\n', '    Payouts work in REAL TIME - you can withdraw your returns at any time!\n', "    Additionally, the first round is an ICO, so you'll also get our tokens by participating!\n", '    !!!!!!!!!!!!!!\n', '    Token holders will receive part of current and future revenue of this and any other game we develop!\n', '    !!!!!!!!!!!!!!\n', '    \n', '    .................................. LAUGHING MAN sssyyhddmN..........................................\n', '    ..........................Nmdyyso+/:--.``` :`  `-`:--:/+ossyhdmN....................................\n', '    ......................Ndhyso/:.`   --.     o.  /+`o::` `` `-:+osyh..................................\n', '    ..................MNdyso/-` /-`/:+./:/..`  +.  //.o +.+::+ -`  `-/sshdN.............................\n', '    ................Ndyso:` ` --:+`o//.-:-```  ...  ``` - /::::/ +..-` ./osh............................\n', '    ..............Nhso/. .-.:/`o--:``   `..-:::oss+::--.``    .:/::/`+-`/../sydN........................\n', '    ............mhso-``-:+./:-:.   .-/+osssssssssssssssssso+:-`  -//o::+:/` .:oyhN......................\n', '    ..........Nhso:`  .+-./ `  .:+sssssso+//:-------:://+ossssso/---.`-`/:-o/ `:syd.....................\n', '    ........Mdyo- +/../`-`  ./osssso/-.`                 ``.:+ossss+:`  `-+`  ` `/sy....................\n', '    ......MNys/` -:-/:    -+ssss+-`                           `.:+ssss/.  `  -+-. .osh..................\n', '    ......mys-  :-/+-`  :osss+-`                                  .:osss+.  `//o:- `/syN................\n', '    ....Mdso. --:-/-  -osss+.                                       `-osss+`  :--://`-sy................\n', '    ....dso-. ++:+  `/sss+.                                           `:osss:  `:.-+  -sy...............\n', '    ..Mdso``+///.` .osss:                                               `/sss+`  :/-.. -syN.............\n', '    ..mss` `+::/  .ssso.                                                  :sss+` `+:/+  -syN............\n', '    ..ys-   ```  .ssso`                                                    -sss+` `:::+:`/sh............\n', '    Mds+ `:/..  `osso`                                                      -sss+  -:`.` `ssN...........\n', '    Mys. `/+::  +sss/........................................................+sss:.....-::+sy..NN.......\n', '    ds+  :-/-  .ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssyyhdN...\n', '    hs: `/+::   :/+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ossssyhNM\n', '    ss. `:::`                    ````                        ```                               ``-+sssyN\n', '    ss` /:-+` `o++:           .:+oooo+/.                 `-/ooooo+-`                               -sssy\n', '    ss  `:/:  `sss/          :ooo++/++os/`              .oso++/++oso.                               osss\n', '    ss``/:--  `sss/         ./.`      `.::              /-.`     ``-/`                             -sssy\n', '    ss.:::-:.  ssso         `            `                                                    ``.-+sssyN\n', '    hs:`:/:/.  /sss.   .++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++oossssyhNM\n', '    ds+ ``     .sss/   -ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssyyyyhmN...\n', '    Nss.:::::.  +sss.   +sss/........................................osss:...+sss:......../shmNNN.......\n', '    Mds+..-:::` `osso`  `+sss:                                     `+sss:   -sss+  .:-.` `ssN...........\n', '    ..ys- .+.::  .ssso`  `/sss+.                                  -osss:   -sss+` `:++-` /sh............\n', '    ..mss` .-.    .ssso.   :osss/`                              .+ssso.   :sss+` `.:+:` -syN............\n', '    ..Mdso`  `--:` .osss:   `/ssss/.`                        `-+ssso:`  `/sss+` `++.-. -syN.............\n', '    ....dso` -//+-` `/sss+.   ./ossso/-``                `.:+sssso:`  `:osss:  .::+/. -sy...............\n', '    ....Mdso. `-//-`  -osss+.   `-+ssssso+/:-.`````..-:/+osssso/.   `-osss+.` -///-  -sy................\n', '    ......mys- `/://.`  :osss+-`   `-/+osssssssssssssssssso+:.    .:osss+.  .:`..-``/syN................\n', '    ......MNys/` ..+-/:   -+ssss+-`    `.-://++oooo++/:-.`    `.:+ssss/.  .`      .osh..................\n', '    ........Mdyo- `::/.  `  ./osssso/-.`                 ``.:+ossss+:` `  .//`  `/sy....................\n', '    ..........Nhso-     :+:.`  .:+sssssso+//:--------://+ossssso/:.  `::/: --/.:syd.....................\n', '    ............mhso-` ./+--+-:    .-/+osssssssssssssssssso+/-.  .+` `//-/ `::oyhN......................\n', '    ..............Nhso/`   +/:--+.-`    `..-:::////::--.``    .`:/-o`  ./`./sydN........................\n', '    ................Ndys+:` ``--+++-  .:  `.``      `` -.`/:/`.o./::.  ./osh............................\n', '    ..................MNdyso/-` ` :`  +-  :+.o`s ::-/++`s`+/o.-:`  `-/sshdN.............................\n', '    ......................Ndhyso/:.` .+   +/:/ +:/-./:-`+: `` `.:+osyh..................................\n', '    ..........................Nmdyyso+/:--/.``      ``..-:/+ossyhdmN....................................\n', '    ..............................MN..dhhyyssssssssssssyyhddmN..........................................\n', ' */\n', ' \n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', "    // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'interface MobiusToken {\n', '    function mint(address _to, uint _amount) external;\n', '    function finishMinting() external returns (bool);\n', '    function disburseDividends() external payable;\n', '}\n', ' \n', 'contract Mobius2D is DSMath, DSAuth {\n', '    // IPFS hash of the website - can be accessed even if our domain goes down.\n', '    // Just go to any public IPFS gateway and use this hash - e.g. ipfs.infura.io/ipfs/<ipfsHash>\n', '    string public ipfsHash;\n', '    string public ipfsHashType = "ipfs"; // can either be ipfs, or ipns\n', '\n', '    MobiusToken public token;\n', '\n', '    // In case of an upgrade, these variables will be set. An upgrade does not affect a currently running round,\n', "    // nor does it do anything with investors' vaults.\n", '    bool public upgraded;\n', '    address public nextVersion;\n', '\n', '    // Total stats\n', '    uint public totalSharesSold;\n', '    uint public totalEarningsGenerated;\n', '    uint public totalDividendsPaid;\n', '    uint public totalJackpotsWon;\n', '\n', '    // Fractions for where revenue goes\n', '    uint public constant DEV_FRACTION = WAD / 20;             // 5% goes to devs\n', '    uint public constant DEV_DIVISOR = 20;             // 5% \n', '\n', '    uint public constant RETURNS_FRACTION = 65 * 10**16;      // 65% goes to share holders\n', '    // 1% if it is a referral purchase, this value will be taken from the above fraction (e.g. if 1% is for refferals, then 64% goes to returns) \n', '    uint public constant REFERRAL_FRACTION = 1 * 10**16;  \n', "    uint public constant JACKPOT_SEED_FRACTION = WAD / 20;    // 5% goes to the next round's jackpot\n", '    uint public constant JACKPOT_FRACTION = 15 * 10**16;      // 15% goes to the final jackpot\n', '    uint public constant AIRDROP_FRACTION = WAD / 100;        // 1% goes to airdrops\n', '    uint public constant DIVIDENDS_FRACTION = 9 * 10**16;     // 9% goes to token holders!\n', '\n', '    uint public constant STARTING_SHARE_PRICE = 1 finney; // a 1000th of an ETH\n', '    uint public constant PRICE_INCREASE_PERIOD = 1 hours; // how often the price doubles after the hard deadline\n', '\n', '    uint public constant HARD_DEADLINE_DURATION = 30 days; // hard deadline is this much after the round start\n', '    uint public constant SOFT_DEADLINE_DURATION = 1 days; // max soft deadline\n', '    uint public constant TIME_PER_SHARE = 5 minutes; // how much time is added to the soft deadline per share purchased\n', '    \n', '    uint public jackpotSeed;// Jackpot from previous rounds\n', '    uint public devBalance; // outstanding balance for devs\n', '    uint public raisedICO;\n', '\n', '    // Helpers to calculate returns - no funds are ever held on lockdown\n', '    uint public unclaimedReturns;\n', '    uint public constant MULTIPLIER = RAY;\n', '\n', '    // This represents an investor. No need to player IDs - they are useless (everyone already has a unique address).\n', '    // Just use native mappings (duh!)\n', '    struct Investor {\n', '        uint lastCumulativeReturnsPoints;\n', '        uint shares;\n', '    }\n', '\n', '    // This represents a round\n', '    struct MobiusRound {\n', '        uint totalInvested;        \n', '        uint jackpot;\n', '        uint airdropPot;\n', '        uint totalShares;\n', '        uint cumulativeReturnsPoints; // this is to help calculate returns when the total number of shares changes\n', '        uint hardDeadline;\n', '        uint softDeadline;\n', '        uint price;\n', '        uint lastPriceIncreaseTime;\n', '        address lastInvestor;\n', '        bool finalized;\n', '        mapping (address => Investor) investors;\n', '    }\n', '\n', '    struct Vault {\n', '        uint totalReturns; // Total balance = returns + referral returns + jackpots/airdrops \n', '        uint refReturns; // how much of the total is from referrals\n', '    }\n', '\n', '    mapping (address => Vault) vaults;\n', '\n', '    uint public latestRoundID;// the first round has an ID of 0\n', '    MobiusRound[] rounds;\n', '\n', '    event SharesIssued(address indexed to, uint shares);\n', '    event ReturnsWithdrawn(address indexed by, uint amount);\n', '    event JackpotWon(address by, uint amount);\n', '    event AirdropWon(address by, uint amount);\n', '    event RoundStarted(uint indexed ID, uint hardDeadline);\n', '    event IPFSHashSet(string _type, string _hash);\n', '\n', '    constructor(address _token) public {\n', '        token = MobiusToken(_token);\n', '    }\n', '\n', '    // The return values will include all vault balance, but you must specify a roundID because\n', '    // Returns are not actually calculated in storage until you invest in the round or withdraw them\n', '    function estimateReturns(address investor, uint roundID) public view \n', '    returns (uint totalReturns, uint refReturns) \n', '    {\n', '        MobiusRound storage rnd = rounds[roundID];\n', '        uint outstanding;\n', '        if(rounds.length > 1) {\n', '            if(hasReturns(investor, roundID - 1)) {\n', '                MobiusRound storage prevRnd = rounds[roundID - 1];\n', '                outstanding = _outstandingReturns(investor, prevRnd);\n', '            }\n', '        }\n', '\n', '        outstanding += _outstandingReturns(investor, rnd);\n', '        \n', '        totalReturns = vaults[investor].totalReturns + outstanding;\n', '        refReturns = vaults[investor].refReturns;\n', '    }\n', '\n', '    function hasReturns(address investor, uint roundID) public view returns (bool) {\n', '        MobiusRound storage rnd = rounds[roundID];\n', '        return rnd.cumulativeReturnsPoints > rnd.investors[investor].lastCumulativeReturnsPoints;\n', '    }\n', '\n', '    function investorInfo(address investor, uint roundID) external view\n', '    returns(uint shares, uint totalReturns, uint referralReturns) \n', '    {\n', '        MobiusRound storage rnd = rounds[roundID];\n', '        shares = rnd.investors[investor].shares;\n', '        (totalReturns, referralReturns) = estimateReturns(investor, roundID);\n', '    }\n', '\n', '    function roundInfo(uint roundID) external view \n', '    returns(\n', '        address leader, \n', '        uint price,\n', '        uint jackpot, \n', '        uint airdrop, \n', '        uint shares, \n', '        uint totalInvested,\n', '        uint distributedReturns,\n', '        uint _hardDeadline,\n', '        uint _softDeadline,\n', '        bool finalized\n', '        )\n', '    {\n', '        MobiusRound storage rnd = rounds[roundID];\n', '        leader = rnd.lastInvestor;\n', '        price = rnd.price;\n', '        jackpot = rnd.jackpot;\n', '        airdrop = rnd.airdropPot;\n', '        shares = rnd.totalShares;\n', '        totalInvested = rnd.totalInvested;\n', '        distributedReturns = wmul(rnd.totalInvested, RETURNS_FRACTION);\n', '        _hardDeadline = rnd.hardDeadline;\n', '        _softDeadline = rnd.softDeadline;\n', '        finalized = rnd.finalized;\n', '    }\n', '\n', '    function totalsInfo() external view \n', '    returns(\n', '        uint totalReturns,\n', '        uint totalShares,\n', '        uint totalDividends,\n', '        uint totalJackpots\n', '    ) {\n', '        MobiusRound storage rnd = rounds[latestRoundID];\n', '        if(rnd.softDeadline > now) {\n', '            totalShares = totalSharesSold + rnd.totalShares;\n', '            totalReturns = totalEarningsGenerated + wmul(rnd.totalInvested, RETURNS_FRACTION);\n', '            totalDividends = totalDividendsPaid + wmul(rnd.totalInvested, DIVIDENDS_FRACTION);\n', '        } else {\n', '            totalShares = totalSharesSold;\n', '            totalReturns = totalEarningsGenerated;\n', '            totalDividends = totalDividendsPaid;\n', '        }\n', '        totalJackpots = totalJackpotsWon;\n', '    }\n', '\n', '    function () public payable {\n', '        buyShares(address(0x0));\n', '    }\n', '\n', '    /// Function to buy shares in the latest round. Purchase logic is abstracted\n', '    function buyShares(address ref) public payable {        \n', '        if(rounds.length > 0) {\n', '            MobiusRound storage rnd = rounds[latestRoundID];   \n', '               \n', '            _purchase(rnd, msg.value, ref);            \n', '        } else {\n', '            revert("Not yet started");\n', '        }\n', '    }\n', '\n', '    /// Function to purchase with what you have in your vault as returns\n', '    function reinvestReturns(uint value) public {        \n', '        reinvestReturns(value, address(0x0));\n', '    }\n', '\n', '    function reinvestReturns(uint value, address ref) public {        \n', '        MobiusRound storage rnd = rounds[latestRoundID];\n', '        _updateReturns(msg.sender, rnd);        \n', '        require(vaults[msg.sender].totalReturns >= value, "Can\'t spend what you don\'t have");        \n', '        vaults[msg.sender].totalReturns = sub(vaults[msg.sender].totalReturns, value);\n', '        vaults[msg.sender].refReturns = min(vaults[msg.sender].refReturns, vaults[msg.sender].totalReturns);\n', '        unclaimedReturns = sub(unclaimedReturns, value);\n', '        _purchase(rnd, value, ref);\n', '    }\n', '\n', '    function withdrawReturns() public {\n', '        MobiusRound storage rnd = rounds[latestRoundID];\n', '\n', '        if(rounds.length > 1) {// check if they also have returns from before\n', '            if(hasReturns(msg.sender, latestRoundID - 1)) {\n', '                MobiusRound storage prevRnd = rounds[latestRoundID - 1];\n', '                _updateReturns(msg.sender, prevRnd);\n', '            }\n', '        }\n', '        _updateReturns(msg.sender, rnd);\n', '        uint amount = vaults[msg.sender].totalReturns;\n', '        require(amount > 0, "Nothing to withdraw!");\n', '        unclaimedReturns = sub(unclaimedReturns, amount);\n', '        vaults[msg.sender].totalReturns = 0;\n', '        vaults[msg.sender].refReturns = 0;\n', '        \n', '        rnd.investors[msg.sender].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\n', '        msg.sender.transfer(amount);\n', '\n', '        emit ReturnsWithdrawn(msg.sender, amount);\n', '    }\n', '\n', '    // Manually update your returns for a given round in case you were inactive since before it ended\n', '    function updateMyReturns(uint roundID) public {\n', '        MobiusRound storage rnd = rounds[roundID];\n', '        _updateReturns(msg.sender, rnd);\n', '    }\n', '\n', '    function finalizeAndRestart() public payable {\n', '        finalizeLastRound();\n', '        startNewRound();\n', '    }\n', '\n', '    /// Anyone can start a new round\n', '    function startNewRound() public payable {\n', '        require(!upgraded, "This contract has been upgraded!");\n', '        if(rounds.length > 0) {\n', '            require(rounds[latestRoundID].finalized, "Previous round not finalized");\n', '            require(rounds[latestRoundID].softDeadline < now, "Previous round still running");\n', '        }\n', '        uint _rID = rounds.length++;\n', '        MobiusRound storage rnd = rounds[_rID];\n', '        latestRoundID = _rID;\n', '\n', '        rnd.lastInvestor = msg.sender;\n', '        rnd.price = STARTING_SHARE_PRICE;\n', '        rnd.hardDeadline = now + HARD_DEADLINE_DURATION;\n', '        rnd.softDeadline = now + SOFT_DEADLINE_DURATION;\n', '        rnd.jackpot = jackpotSeed;\n', '        jackpotSeed = 0; \n', '\n', '        _purchase(rnd, msg.value, address(0x0));\n', '        emit RoundStarted(_rID, rnd.hardDeadline);\n', '    }\n', '\n', '    /// Anyone can finalize a finished round\n', '    function finalizeLastRound() public {\n', '        MobiusRound storage rnd = rounds[latestRoundID];\n', '        _finalizeRound(rnd);\n', '    }\n', '    \n', '    /// This is how devs pay the bills\n', '    function withdrawDevShare() public auth {\n', '        uint value = devBalance;\n', '        devBalance = 0;\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    function setIPFSHash(string _type, string _hash) public auth {\n', '        ipfsHashType = _type;\n', '        ipfsHash = _hash;\n', '        emit IPFSHashSet(_type, _hash);\n', '    }\n', '\n', '    function upgrade(address _nextVersion) public auth {\n', '        require(_nextVersion != address(0x0), "Invalid Address!");\n', '        require(!upgraded, "Already upgraded!");\n', '        upgraded = true;\n', '        nextVersion = _nextVersion;\n', '        if(rounds[latestRoundID].finalized) {\n', '            //if last round was finalized (and no new round was started), transfer the jackpot seed to the new version\n', '            vaults[nextVersion].totalReturns = jackpotSeed;\n', '            jackpotSeed = 0;\n', '        }\n', '    }\n', '\n', '    /// Purchase logic\n', '    function _purchase(MobiusRound storage rnd, uint value, address ref) internal {\n', '        require(rnd.softDeadline >= now, "After deadline!");\n', '        require(value >= rnd.price/10, "Not enough Ether!");\n', '        rnd.totalInvested = add(rnd.totalInvested, value);\n', '\n', '        // Set the last investor (to win the jackpot after the deadline)\n', '        if(value >= rnd.price)\n', '            rnd.lastInvestor = msg.sender;\n', '        // Check out airdrop \n', '        _airDrop(rnd, value);\n', '        // Process revenue in different "buckets"\n', '        _splitRevenue(rnd, value, ref);\n', '        // Update returns before issuing shares\n', '        _updateReturns(msg.sender, rnd);\n', '        //issue shares for the current round. 1 share = 1 time increase for the deadline\n', '        uint newShares = _issueShares(rnd, msg.sender, value);\n', '\n', '        //Mint tokens during the first round\n', '        if(rounds.length == 1) {\n', '            token.mint(msg.sender, newShares);\n', '        }\n', '        uint timeIncreases = newShares/WAD;// since 1 share is represented by 1 * 10^18, divide by 10^18\n', '        // adjust soft deadline to new soft deadline\n', '        uint newDeadline = add(rnd.softDeadline, mul(timeIncreases, TIME_PER_SHARE));\n', '        rnd.softDeadline = min(newDeadline, now + SOFT_DEADLINE_DURATION);\n', '        // If after hard deadline, double the price every price increase periods\n', '        if(now > rnd.hardDeadline) {\n', '            if(now > rnd.lastPriceIncreaseTime + PRICE_INCREASE_PERIOD) {\n', '                rnd.price = rnd.price * 2;\n', '                rnd.lastPriceIncreaseTime = now;\n', '            }\n', '        }\n', '    }\n', '\n', '    function _finalizeRound(MobiusRound storage rnd) internal {\n', '        require(!rnd.finalized, "Already finalized!");\n', '        require(rnd.softDeadline < now, "Round still running!");\n', '\n', '        if(rounds.length == 1) {\n', '            // After finishing minting tokens they will be transferable and dividends will be available!\n', '            require(token.finishMinting(), "Couldn\'t finish minting tokens!");\n', '        }\n', "        // Transfer jackpot to winner's vault\n", '        vaults[rnd.lastInvestor].totalReturns = add(vaults[rnd.lastInvestor].totalReturns, rnd.jackpot);\n', '        unclaimedReturns = add(unclaimedReturns, rnd.jackpot);\n', '        \n', '        emit JackpotWon(rnd.lastInvestor, rnd.jackpot);\n', '        totalJackpotsWon += rnd.jackpot;\n', "        // transfer the leftover to the next round's jackpot\n", '        jackpotSeed = add(jackpotSeed, wmul(rnd.totalInvested, JACKPOT_SEED_FRACTION));\n', '        //Empty the AD pot if it has a balance.\n', '        jackpotSeed = add(jackpotSeed, rnd.airdropPot);\n', '        if(upgraded) {\n', '            // if upgraded transfer the jackpot seed to the new version\n', '            vaults[nextVersion].totalReturns = jackpotSeed;\n', '            jackpotSeed = 0; \n', '        }        \n', '        //Send out dividends to token holders\n', '        uint _div;\n', '        if(rounds.length == 1){\n', '            // 2% during the first round, and the normal fraction otherwise\n', '            _div = wmul(rnd.totalInvested, 2 * 10**16);            \n', '        } else {\n', '            _div = wmul(rnd.totalInvested, DIVIDENDS_FRACTION);            \n', '        }\n', '        token.disburseDividends.value(_div)();\n', '        totalDividendsPaid += _div;\n', '        totalSharesSold += rnd.totalShares;\n', '        totalEarningsGenerated += wmul(rnd.totalInvested, RETURNS_FRACTION);\n', '\n', '        rnd.finalized = true;\n', '    }\n', '\n', '    /** \n', '        This is where the magic happens: every investor gets an exact share of all returns proportional to their shares\n', "        If you're early, you'll have a larger share for longer, so obviously you earn more.\n", '    */\n', '    function _updateReturns(address _investor, MobiusRound storage rnd) internal {\n', '        if(rnd.investors[_investor].shares == 0) {\n', '            return;\n', '        }\n', '        \n', '        uint outstanding = _outstandingReturns(_investor, rnd);\n', '\n', "        // if there are any returns, transfer them to the investor's vaults\n", '        if (outstanding > 0) {\n', '            vaults[_investor].totalReturns = add(vaults[_investor].totalReturns, outstanding);\n', '        }\n', '\n', '        rnd.investors[_investor].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\n', '    }\n', '\n', '    function _outstandingReturns(address _investor, MobiusRound storage rnd) internal view returns(uint) {\n', '        if(rnd.investors[_investor].shares == 0) {\n', '            return 0;\n', '        }\n', "        // check if there've been new returns\n", '        uint newReturns = sub(\n', '            rnd.cumulativeReturnsPoints, \n', '            rnd.investors[_investor].lastCumulativeReturnsPoints\n', '            );\n', '\n', '        uint outstanding = 0;\n', '        if(newReturns != 0) { \n', '            // outstanding returns = (total new returns points * ivestor shares) / MULTIPLIER\n', '            // The MULTIPLIER is used also at the point of returns disbursment\n', '            outstanding = mul(newReturns, rnd.investors[_investor].shares) / MULTIPLIER;\n', '        }\n', '\n', '        return outstanding;\n', '    }\n', '\n', '    /// Process revenue according to fractions\n', '    function _splitRevenue(MobiusRound storage rnd, uint value, address ref) internal {\n', '        uint roundReturns;\n', '        uint returnsOffset;\n', '        if(rounds.length == 1){\n', '            returnsOffset = 13 * 10**16;// during the first round reduce returns (by 13%) and give more to the ICO\n', '        }\n', '        if(ref != address(0x0)) {\n', '            // if there was a referral\n', '            roundReturns = wmul(value, RETURNS_FRACTION - REFERRAL_FRACTION - returnsOffset);\n', '            uint _ref = wmul(value, REFERRAL_FRACTION);\n', '            vaults[ref].totalReturns = add(vaults[ref].totalReturns, _ref);            \n', '            vaults[ref].refReturns = add(vaults[ref].refReturns, _ref);\n', '            unclaimedReturns = add(unclaimedReturns, _ref);\n', '        } else {\n', '            roundReturns = wmul(value, RETURNS_FRACTION - returnsOffset);\n', '        }\n', '        \n', '        uint airdrop = wmul(value, AIRDROP_FRACTION);\n', '        uint jackpot = wmul(value, JACKPOT_FRACTION);\n', '        \n', '        uint dev;\n', '        // During the ICO, devs get 25% (5% originally, 7% from the dividends fraction, \n', '        // and 13% from the returns), leaving 2% for dividends, and 52% for returns \n', '        // This is only during the first round, and later rounds leave the original fractions:\n', '        // 5% for devs, 9% dividends, 65% returns \n', '        if(rounds.length == 1){\n', '            // calculate dividends at the end, no need to do it at every purchase\n', '            dev = value / 4; // 25% \n', '            raisedICO += dev;\n', '        } else {\n', '            dev = value / DEV_DIVISOR;\n', '        }\n', '        // if this is the first purchase, send to jackpot (no one can claim these returns otherwise)\n', '        if(rnd.totalShares == 0) {\n', '            rnd.jackpot = add(rnd.jackpot, roundReturns);\n', '        } else {\n', '            _disburseReturns(rnd, roundReturns);\n', '        }\n', '        \n', '        rnd.airdropPot = add(rnd.airdropPot, airdrop);\n', '        rnd.jackpot = add(rnd.jackpot, jackpot);\n', '        devBalance = add(devBalance, dev);\n', '    }\n', '\n', '    function _disburseReturns(MobiusRound storage rnd, uint value) internal {\n', '        unclaimedReturns = add(unclaimedReturns, value);// keep track of unclaimed returns\n', '        // The returns points represent returns*MULTIPLIER/totalShares (at the point of purchase)\n', '        // This allows us to keep outstanding balances of shareholders when the total supply changes in real time\n', '        if(rnd.totalShares == 0) {\n', '            rnd.cumulativeReturnsPoints = mul(value, MULTIPLIER) / wdiv(value, rnd.price);\n', '        } else {\n', '            rnd.cumulativeReturnsPoints = add(\n', '                rnd.cumulativeReturnsPoints, \n', '                mul(value, MULTIPLIER) / rnd.totalShares\n', '            );\n', '        }\n', '    }\n', '\n', '    function _issueShares(MobiusRound storage rnd, address _investor, uint value) internal returns(uint) {    \n', '        if(rnd.investors[_investor].lastCumulativeReturnsPoints == 0) {\n', '            rnd.investors[_investor].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\n', '        }    \n', '        \n', '        uint newShares = wdiv(value, rnd.price);\n', '        \n', '        //bonuses:\n', '        if(value >= 100 ether) {\n', '            newShares = mul(newShares, 2);//get double shares if you paid more than 100 ether\n', '        } else if(value >= 10 ether) {\n', '            newShares = add(newShares, newShares/2);//50% bonus\n', '        } else if(value >= 1 ether) {\n', '            newShares = add(newShares, newShares/3);//33% bonus\n', '        } else if(value >= 100 finney) {\n', '            newShares = add(newShares, newShares/10);//10% bonus\n', '        }\n', '\n', '        rnd.investors[_investor].shares = add(rnd.investors[_investor].shares, newShares);\n', '        rnd.totalShares = add(rnd.totalShares, newShares);\n', '        emit SharesIssued(_investor, newShares);\n', '        return newShares;\n', '    }    \n', '\n', '    function _airDrop(MobiusRound storage rnd, uint value) internal {\n', '        require(msg.sender == tx.origin, "ONLY HOOMANS (or scripts that don\'t use smart contracts)!");\n', '        if(value > 100 finney) {\n', '            /**\n', '                Creates a random number from the last block hash and current timestamp.\n', "                One could add more seemingly random data like the msg.sender, etc, but that doesn't \n", '                make it harder for a miner to manipulate the result in their favor (if they intended to).\n', '             */\n', '            uint chance = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), now)));\n', '            if(chance % 200 == 0) {// once in 200 times\n', '                uint prize = rnd.airdropPot / 2;// win half of the pot, regardless of how much you paid\n', '                rnd.airdropPot = rnd.airdropPot / 2;\n', '                vaults[msg.sender].totalReturns = add(vaults[msg.sender].totalReturns, prize);\n', '                unclaimedReturns = add(unclaimedReturns, prize);\n', '                totalJackpotsWon += prize;\n', '                emit AirdropWon(msg.sender, prize);\n', '            }\n', '        }\n', '    }\n', '}']
