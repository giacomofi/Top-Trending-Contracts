['pragma solidity ^0.4.15;\n', '\n', 'pragma solidity ^0.4.15;\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is Token {\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '  }\n', '\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.15;\n', '\n', '\n', 'pragma solidity ^0.4.15;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender == owner)\n', '      _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/*\n', ' * Pausable\n', ' * Abstract contract that allows children to implement an\n', ' * emergency stop mechanism.\n', ' */\n', '\n', 'contract Pausable is Ownable {\n', '  bool public stopped;\n', '\n', '  modifier stopInEmergency {\n', '    if (stopped) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    if (!stopped) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function emergencyStop() external onlyOwner {\n', '    stopped = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function release() external onlyOwner onlyInEmergency {\n', '    stopped = false;\n', '  }\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.15;\n', '\n', 'contract Utils{\n', '\n', '  //verifies the amount greater than zero\n', '\n', '  modifier greaterThanZero(uint256 _value){\n', '    require(_value>0);\n', '    _;\n', '  }\n', '\n', '  ///verifies an address\n', '\n', '  modifier validAddress(address _add){\n', '    require(_add!=0x0);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.15;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract Crowdsale is StandardToken, Pausable, SafeMath, Utils{\n', '\tstring public constant name = "BlockAim Token";\n', '\tstring public constant symbol = "BA";\n', '\tuint256 public constant decimals = 18;\n', '\tstring public version = "1.0";\n', '\tbool public tradingStarted = false;\n', '\n', '    /**\n', '   * @dev modifier that throws if trading has not started yet\n', '   */\n', '   modifier hasStartedTrading() {\n', '   \trequire(tradingStarted);\n', '   \t_;\n', '   }\n', '  /**\n', '   * @dev Allows the owner to enable the trading. This can not be undone\n', '   */\n', '   function startTrading() onlyOwner() {\n', '   \ttradingStarted = true;\n', '   }\n', '\n', '   function transfer(address _to, uint _value) hasStartedTrading returns (bool success) {super.transfer(_to, _value);}\n', '\n', '   function transferFrom(address _from, address _to, uint _value) hasStartedTrading returns (bool success) {super.transferFrom(_from, _to, _value);}\n', '\n', '   enum State{\n', '   \tInactive,\n', '   \tFunding,\n', '   \tSuccess,\n', '   \tFailure\n', '   }\n', '\n', '   uint256 public investmentETH;\n', '   mapping(uint256 => bool) transactionsClaimed;\n', '   uint256 public initialSupply;\n', '   address wallet;\n', '   uint256 public constant _totalSupply = 100 * (10**6) * 10 ** decimals; // 100M ~ 10 Crores\n', '   uint256 public fundingStartBlock; // crowdsale start block\n', '   uint256 public tokensPerEther = 300; // 1 ETH = 300 tokens\n', '   uint256 public constant tokenCreationMax = 10 * (10**6) * 10 ** decimals; // 10M ~ 1 Crores\n', '   address[] public investors;\n', '\n', '   //displays number of uniq investors\n', '   function investorsCount() constant external returns(uint) { return investors.length; }\n', '\n', '   function Crowdsale(uint256 _fundingStartBlock, address _owner, address _wallet){\n', '      owner = _owner;\n', '      fundingStartBlock =_fundingStartBlock;\n', '      totalSupply = _totalSupply;\n', '      initialSupply = 0;\n', '      wallet = _wallet;\n', '\n', '      //check configuration if something in setup is looking weird\n', '      if (\n', '        tokensPerEther == 0\n', '        || owner == 0x0\n', '        || wallet == 0x0\n', '        || fundingStartBlock == 0\n', '        || totalSupply == 0\n', '        || tokenCreationMax == 0\n', '        || fundingStartBlock <= block.number)\n', '      throw;\n', '\n', '   }\n', '\n', '   // don&#39;t just send ether to the contract expecting to get tokens\n', '   //function() { throw; }\n', '   ////@dev This function manages the Crowdsale State machine\n', '   ///We make it a function and do not assign to a variable//\n', '   ///so that no chance of stale variable\n', '   function getState() constant public returns(State){\n', '   \t///once we reach success lock the State\n', '   \tif(block.number<fundingStartBlock) return State.Inactive;\n', '   \telse if(block.number>fundingStartBlock && initialSupply<tokenCreationMax) return State.Funding;\n', '   \telse if (initialSupply >= tokenCreationMax) return State.Success;\n', '   \telse return State.Failure;\n', '   }\n', '\n', '   ///get total tokens in that address mapping\n', '   function getTokens(address addr) public returns(uint256){\n', '   \treturn balances[addr];\n', '   }\n', '\n', ' \n', '   function() external payable stopInEmergency{\n', '   \t// Abort if not in Funding Active state.\n', '   \tif(getState() == State.Success) throw;\n', '   \tif (msg.value == 0) throw;\n', '   \tuint256 newCreatedTokens = safeMul(msg.value,tokensPerEther);\n', '   \t///since we are creating tokens we need to increase the total supply\n', '   \tinitialSupply = safeAdd(initialSupply,newCreatedTokens);\n', '   \tif(initialSupply>tokenCreationMax) throw;\n', '      if (balances[msg.sender] == 0) investors.push(msg.sender);\n', '      investmentETH += msg.value;\n', '      balances[msg.sender] = safeAdd(balances[msg.sender],newCreatedTokens);\n', '      Transfer(this, msg.sender, newCreatedTokens);\n', '      // Pocket the money\n', '      if(!wallet.send(msg.value)) throw;\n', '   }\n', '\n', '\n', '   ///to be done only the owner can run this function\n', '   function tokenMint(address addr,uint256 tokens)\n', '   external\n', '   stopInEmergency\n', '   onlyOwner()\n', '   {\n', '   \tif(getState() == State.Success) throw;\n', '    if(addr == 0x0) throw;\n', '   \tif (tokens == 0) throw;\n', '   \tuint256 newCreatedTokens = tokens * 1 ether;\n', '   \tinitialSupply = safeAdd(initialSupply,newCreatedTokens);\n', '   \tif(initialSupply>tokenCreationMax) throw;\n', '      if (balances[addr] == 0) investors.push(addr);\n', '      balances[addr] = safeAdd(balances[addr],newCreatedTokens);\n', '      Transfer(this, addr, newCreatedTokens);\n', '   }\n', '\n', '   \n', '   ///change exchange rate ~ update price everyday\n', '   function changeExchangeRate(uint256 eth)\n', '   external\n', '   onlyOwner()\n', '   {\n', '     if(eth == 0) throw;\n', '     tokensPerEther = eth;\n', '  }\n', '\n', '  ///blacklist the users which are fraudulent\n', '  ///from getting any tokens\n', '  ///to do also refund just in cases\n', '  function blacklist(address addr)\n', '  external\n', '  onlyOwner()\n', '  {\n', '     balances[addr] = 0;\n', '  }\n', '\n', '}']