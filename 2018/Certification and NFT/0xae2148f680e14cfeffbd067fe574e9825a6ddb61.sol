['pragma solidity ^0.4.13;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    emit RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    emit RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address&#39; access to this role\n', '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) public {\n', '    _burn(msg.sender, _value);\n', '  }\n', '\n', '  function _burn(address _who, uint256 _value) internal {\n', '    require(_value <= balances[_who]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', '    // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '    balances[_who] = balances[_who].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    emit Burn(_who, _value);\n', '    emit Transfer(_who, address(0), _value);\n', '  }\n', '}\n', '\n', 'contract Staff is Ownable, RBAC {\n', '\n', '\tstring public constant ROLE_STAFF = "staff";\n', '\n', '\tfunction addStaff(address _staff) public onlyOwner {\n', '\t\taddRole(_staff, ROLE_STAFF);\n', '\t}\n', '\n', '\tfunction removeStaff(address _staff) public onlyOwner {\n', '\t\tremoveRole(_staff, ROLE_STAFF);\n', '\t}\n', '\n', '\tfunction isStaff(address _staff) view public returns (bool) {\n', '\t\treturn hasRole(_staff, ROLE_STAFF);\n', '\t}\n', '}\n', '\n', 'contract StaffUtil {\n', '\tStaff public staffContract;\n', '\n', '\tconstructor (Staff _staffContract) public {\n', '\t\trequire(msg.sender == _staffContract.owner());\n', '\t\tstaffContract = _staffContract;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == staffContract.owner());\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyOwnerOrStaff() {\n', '\t\trequire(msg.sender == staffContract.owner() || staffContract.isStaff(msg.sender));\n', '\t\t_;\n', '\t}\n', '}\n', '\n', 'contract Crowdsale is StaffUtil {\n', '\tusing SafeMath for uint256;\n', '\n', '\tToken tokenContract;\n', '\tPromoCodes promoCodesContract;\n', '\tDiscountPhases discountPhasesContract;\n', '\tDiscountStructs discountStructsContract;\n', '\n', '\taddress ethFundsWallet;\n', '\tuint256 referralBonusPercent;\n', '\tuint256 startDate;\n', '\n', '\tuint256 crowdsaleStartDate;\n', '\tuint256 endDate;\n', '\tuint256 tokenDecimals;\n', '\tuint256 tokenRate;\n', '\tuint256 tokensForSaleCap;\n', '\tuint256 minPurchaseInWei;\n', '\tuint256 maxInvestorContributionInWei;\n', '\tbool paused;\n', '\tbool finalized;\n', '\tuint256 weiRaised;\n', '\tuint256 soldTokens;\n', '\tuint256 bonusTokens;\n', '\tuint256 sentTokens;\n', '\tuint256 claimedSoldTokens;\n', '\tuint256 claimedBonusTokens;\n', '\tuint256 claimedSentTokens;\n', '\tuint256 purchasedTokensClaimDate;\n', '\tuint256 bonusTokensClaimDate;\n', '\tmapping(address => Investor) public investors;\n', '\n', '\tenum InvestorStatus {UNDEFINED, WHITELISTED, BLOCKED}\n', '\n', '\tstruct Investor {\n', '\t\tInvestorStatus status;\n', '\t\tuint256 contributionInWei;\n', '\t\tuint256 purchasedTokens;\n', '\t\tuint256 bonusTokens;\n', '\t\tuint256 referralTokens;\n', '\t\tuint256 receivedTokens;\n', '\t\tTokensPurchase[] tokensPurchases;\n', '\t\tbool isBlockpass;\n', '\t}\n', '\n', '\tstruct TokensPurchase {\n', '\t\tuint256 value;\n', '\t\tuint256 amount;\n', '\t\tuint256 bonus;\n', '\t\taddress referrer;\n', '\t\tuint256 referrerSentAmount;\n', '\t}\n', '\n', '\tevent InvestorWhitelisted(address indexed investor, uint timestamp, address byStaff);\n', '\tevent InvestorBlocked(address indexed investor, uint timestamp, address byStaff);\n', '\tevent TokensPurchased(\n', '\t\taddress indexed investor,\n', '\t\tuint indexed purchaseId,\n', '\t\tuint256 value,\n', '\t\tuint256 purchasedAmount,\n', '\t\tuint256 promoCodeAmount,\n', '\t\tuint256 discountPhaseAmount,\n', '\t\tuint256 discountStructAmount,\n', '\t\taddress indexed referrer,\n', '\t\tuint256 referrerSentAmount,\n', '\t\tuint timestamp\n', '\t);\n', '\tevent TokensPurchaseRefunded(\n', '\t\taddress indexed investor,\n', '\t\tuint indexed purchaseId,\n', '\t\tuint256 value,\n', '\t\tuint256 amount,\n', '\t\tuint256 bonus,\n', '\t\tuint timestamp,\n', '\t\taddress byStaff\n', '\t);\n', '\tevent Paused(uint timestamp, address byStaff);\n', '\tevent Resumed(uint timestamp, address byStaff);\n', '\tevent Finalized(uint timestamp, address byStaff);\n', '\tevent TokensSent(address indexed investor, uint256 amount, uint timestamp, address byStaff);\n', '\tevent PurchasedTokensClaimLocked(uint date, uint timestamp, address byStaff);\n', '\tevent PurchasedTokensClaimUnlocked(uint timestamp, address byStaff);\n', '\tevent BonusTokensClaimLocked(uint date, uint timestamp, address byStaff);\n', '\tevent BonusTokensClaimUnlocked(uint timestamp, address byStaff);\n', '\tevent CrowdsaleStartDateUpdated(uint date, uint timestamp, address byStaff);\n', '\tevent EndDateUpdated(uint date, uint timestamp, address byStaff);\n', '\tevent MinPurchaseChanged(uint256 minPurchaseInWei, uint timestamp, address byStaff);\n', '\tevent MaxInvestorContributionChanged(uint256 maxInvestorContributionInWei, uint timestamp, address byStaff);\n', '\tevent TokenRateChanged(uint newRate, uint timestamp, address byStaff);\n', '\tevent TokensClaimed(\n', '\t\taddress indexed investor,\n', '\t\tuint256 purchased,\n', '\t\tuint256 bonus,\n', '\t\tuint256 referral,\n', '\t\tuint256 received,\n', '\t\tuint timestamp,\n', '\t\taddress byStaff\n', '\t);\n', '\tevent TokensBurned(uint256 amount, uint timestamp, address byStaff);\n', '\n', '\tconstructor (\n', '\t\tuint256[11] uint256Args,\n', '\t\taddress[5] addressArgs\n', '\t) StaffUtil(Staff(addressArgs[4])) public {\n', '\n', '\t\t// uint256 args\n', '\t\tstartDate = uint256Args[0];\n', '\t\tcrowdsaleStartDate = uint256Args[1];\n', '\t\tendDate = uint256Args[2];\n', '\t\ttokenDecimals = uint256Args[3];\n', '\t\ttokenRate = uint256Args[4];\n', '\t\ttokensForSaleCap = uint256Args[5];\n', '\t\tminPurchaseInWei = uint256Args[6];\n', '\t\tmaxInvestorContributionInWei = uint256Args[7];\n', '\t\tpurchasedTokensClaimDate = uint256Args[8];\n', '\t\tbonusTokensClaimDate = uint256Args[9];\n', '\t\treferralBonusPercent = uint256Args[10];\n', '\n', '\t\t// address args\n', '\t\tethFundsWallet = addressArgs[0];\n', '\t\tpromoCodesContract = PromoCodes(addressArgs[1]);\n', '\t\tdiscountPhasesContract = DiscountPhases(addressArgs[2]);\n', '\t\tdiscountStructsContract = DiscountStructs(addressArgs[3]);\n', '\n', '\t\trequire(startDate < crowdsaleStartDate);\n', '\t\trequire(crowdsaleStartDate < endDate);\n', '\t\trequire(tokenDecimals > 0);\n', '\t\trequire(tokenRate > 0);\n', '\t\trequire(tokensForSaleCap > 0);\n', '\t\trequire(minPurchaseInWei <= maxInvestorContributionInWei);\n', '\t\trequire(ethFundsWallet != address(0));\n', '\t}\n', '\n', '\tfunction getState() external view returns (bool[2] boolArgs, uint256[18] uint256Args, address[6] addressArgs) {\n', '\t\tboolArgs[0] = paused;\n', '\t\tboolArgs[1] = finalized;\n', '\t\tuint256Args[0] = weiRaised;\n', '\t\tuint256Args[1] = soldTokens;\n', '\t\tuint256Args[2] = bonusTokens;\n', '\t\tuint256Args[3] = sentTokens;\n', '\t\tuint256Args[4] = claimedSoldTokens;\n', '\t\tuint256Args[5] = claimedBonusTokens;\n', '\t\tuint256Args[6] = claimedSentTokens;\n', '\t\tuint256Args[7] = purchasedTokensClaimDate;\n', '\t\tuint256Args[8] = bonusTokensClaimDate;\n', '\t\tuint256Args[9] = startDate;\n', '\t\tuint256Args[10] = crowdsaleStartDate;\n', '\t\tuint256Args[11] = endDate;\n', '\t\tuint256Args[12] = tokenRate;\n', '\t\tuint256Args[13] = tokenDecimals;\n', '\t\tuint256Args[14] = minPurchaseInWei;\n', '\t\tuint256Args[15] = maxInvestorContributionInWei;\n', '\t\tuint256Args[16] = referralBonusPercent;\n', '\t\tuint256Args[17] = getTokensForSaleCap();\n', '\t\taddressArgs[0] = staffContract;\n', '\t\taddressArgs[1] = ethFundsWallet;\n', '\t\taddressArgs[2] = promoCodesContract;\n', '\t\taddressArgs[3] = discountPhasesContract;\n', '\t\taddressArgs[4] = discountStructsContract;\n', '\t\taddressArgs[5] = tokenContract;\n', '\t}\n', '\n', '\tfunction fitsTokensForSaleCap(uint256 _amount) public view returns (bool) {\n', '\t\treturn getDistributedTokens().add(_amount) <= getTokensForSaleCap();\n', '\t}\n', '\n', '\tfunction getTokensForSaleCap() public view returns (uint256) {\n', '\t\tif (tokenContract != address(0)) {\n', '\t\t\treturn tokenContract.balanceOf(this);\n', '\t\t}\n', '\t\treturn tokensForSaleCap;\n', '\t}\n', '\n', '\tfunction getDistributedTokens() public view returns (uint256) {\n', '\t\treturn soldTokens.sub(claimedSoldTokens).add(bonusTokens.sub(claimedBonusTokens)).add(sentTokens.sub(claimedSentTokens));\n', '\t}\n', '\n', '\tfunction setTokenContract(Token token) external onlyOwner {\n', '\t\trequire(token.balanceOf(this) >= 0);\n', '\t\trequire(tokenContract == address(0));\n', '\t\trequire(token != address(0));\n', '\t\ttokenContract = token;\n', '\t}\n', '\n', '\tfunction getInvestorClaimedTokens(address _investor) external view returns (uint256) {\n', '\t\tif (tokenContract != address(0)) {\n', '\t\t\treturn tokenContract.balanceOf(_investor);\n', '\t\t}\n', '\t\treturn 0;\n', '\t}\n', '\n', '\tfunction isBlockpassInvestor(address _investor) external constant returns (bool) {\n', '\t\treturn investors[_investor].status == InvestorStatus.WHITELISTED && investors[_investor].isBlockpass;\n', '\t}\n', '\n', '\tfunction whitelistInvestor(address _investor, bool _isBlockpass) external onlyOwnerOrStaff {\n', '\t\trequire(_investor != address(0));\n', '\t\trequire(investors[_investor].status != InvestorStatus.WHITELISTED);\n', '\n', '\t\tinvestors[_investor].status = InvestorStatus.WHITELISTED;\n', '\t\tinvestors[_investor].isBlockpass = _isBlockpass;\n', '\n', '\t\temit InvestorWhitelisted(_investor, now, msg.sender);\n', '\t}\n', '\n', '\tfunction bulkWhitelistInvestor(address[] _investors) external onlyOwnerOrStaff {\n', '\t\tfor (uint256 i = 0; i < _investors.length; i++) {\n', '\t\t\tif (_investors[i] != address(0) && investors[_investors[i]].status != InvestorStatus.WHITELISTED) {\n', '\t\t\t\tinvestors[_investors[i]].status = InvestorStatus.WHITELISTED;\n', '\t\t\t\temit InvestorWhitelisted(_investors[i], now, msg.sender);\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\tfunction blockInvestor(address _investor) external onlyOwnerOrStaff {\n', '\t\trequire(_investor != address(0));\n', '\t\trequire(investors[_investor].status != InvestorStatus.BLOCKED);\n', '\n', '\t\tinvestors[_investor].status = InvestorStatus.BLOCKED;\n', '\n', '\t\temit InvestorBlocked(_investor, now, msg.sender);\n', '\t}\n', '\n', '\tfunction lockPurchasedTokensClaim(uint256 _date) external onlyOwner {\n', '\t\trequire(_date > now);\n', '\t\tpurchasedTokensClaimDate = _date;\n', '\t\temit PurchasedTokensClaimLocked(_date, now, msg.sender);\n', '\t}\n', '\n', '\tfunction unlockPurchasedTokensClaim() external onlyOwner {\n', '\t\tpurchasedTokensClaimDate = now;\n', '\t\temit PurchasedTokensClaimUnlocked(now, msg.sender);\n', '\t}\n', '\n', '\tfunction lockBonusTokensClaim(uint256 _date) external onlyOwner {\n', '\t\trequire(_date > now);\n', '\t\tbonusTokensClaimDate = _date;\n', '\t\temit BonusTokensClaimLocked(_date, now, msg.sender);\n', '\t}\n', '\n', '\tfunction unlockBonusTokensClaim() external onlyOwner {\n', '\t\tbonusTokensClaimDate = now;\n', '\t\temit BonusTokensClaimUnlocked(now, msg.sender);\n', '\t}\n', '\n', '\tfunction setCrowdsaleStartDate(uint256 _date) external onlyOwner {\n', '\t\tcrowdsaleStartDate = _date;\n', '\t\temit CrowdsaleStartDateUpdated(_date, now, msg.sender);\n', '\t}\n', '\n', '\tfunction setEndDate(uint256 _date) external onlyOwner {\n', '\t\tendDate = _date;\n', '\t\temit EndDateUpdated(_date, now, msg.sender);\n', '\t}\n', '\n', '\tfunction setMinPurchaseInWei(uint256 _minPurchaseInWei) external onlyOwner {\n', '\t\tminPurchaseInWei = _minPurchaseInWei;\n', '\t\temit MinPurchaseChanged(_minPurchaseInWei, now, msg.sender);\n', '\t}\n', '\n', '\tfunction setMaxInvestorContributionInWei(uint256 _maxInvestorContributionInWei) external onlyOwner {\n', '\t\trequire(minPurchaseInWei <= _maxInvestorContributionInWei);\n', '\t\tmaxInvestorContributionInWei = _maxInvestorContributionInWei;\n', '\t\temit MaxInvestorContributionChanged(_maxInvestorContributionInWei, now, msg.sender);\n', '\t}\n', '\n', '\tfunction changeTokenRate(uint256 _tokenRate) external onlyOwner {\n', '\t\trequire(_tokenRate > 0);\n', '\t\ttokenRate = _tokenRate;\n', '\t\temit TokenRateChanged(_tokenRate, now, msg.sender);\n', '\t}\n', '\n', '\tfunction buyTokens(bytes32 _promoCode, address _referrer) external payable {\n', '\t\trequire(!finalized);\n', '\t\trequire(!paused);\n', '\t\trequire(startDate < now);\n', '\t\trequire(investors[msg.sender].status == InvestorStatus.WHITELISTED);\n', '\t\trequire(msg.value > 0);\n', '\t\trequire(msg.value >= minPurchaseInWei);\n', '\t\trequire(investors[msg.sender].contributionInWei.add(msg.value) <= maxInvestorContributionInWei);\n', '\n', '\t\t// calculate purchased amount\n', '\t\tuint256 purchasedAmount;\n', '\t\tif (tokenDecimals > 18) {\n', '\t\t\tpurchasedAmount = msg.value.mul(tokenRate).mul(10 ** (tokenDecimals - 18));\n', '\t\t} else if (tokenDecimals < 18) {\n', '\t\t\tpurchasedAmount = msg.value.mul(tokenRate).div(10 ** (18 - tokenDecimals));\n', '\t\t} else {\n', '\t\t\tpurchasedAmount = msg.value.mul(tokenRate);\n', '\t\t}\n', '\n', '\t\t// calculate total amount, this includes promo code amount or discount phase amount\n', '\t\tuint256 promoCodeBonusAmount = promoCodesContract.applyBonusAmount(msg.sender, purchasedAmount, _promoCode);\n', '\t\tuint256 discountPhaseBonusAmount = discountPhasesContract.calculateBonusAmount(purchasedAmount);\n', '\t\tuint256 discountStructBonusAmount = discountStructsContract.getBonus(msg.sender, purchasedAmount, msg.value);\n', '\t\tuint256 bonusAmount = promoCodeBonusAmount.add(discountPhaseBonusAmount).add(discountStructBonusAmount);\n', '\n', '\t\t// update referrer&#39;s referral tokens\n', '\t\tuint256 referrerBonusAmount;\n', '\t\taddress referrerAddr;\n', '\t\tif (\n', '\t\t\t_referrer != address(0)\n', '\t\t\t&& msg.sender != _referrer\n', '\t\t\t&& investors[_referrer].status == InvestorStatus.WHITELISTED\n', '\t\t) {\n', '\t\t\treferrerBonusAmount = purchasedAmount * referralBonusPercent / 100;\n', '\t\t\treferrerAddr = _referrer;\n', '\t\t}\n', '\n', '\t\t// check that calculated tokens will not exceed tokens for sale cap\n', '\t\trequire(fitsTokensForSaleCap(purchasedAmount.add(bonusAmount).add(referrerBonusAmount)));\n', '\n', '\t\t// update crowdsale total amount of capital raised\n', '\t\tweiRaised = weiRaised.add(msg.value);\n', '\t\tsoldTokens = soldTokens.add(purchasedAmount);\n', '\t\tbonusTokens = bonusTokens.add(bonusAmount).add(referrerBonusAmount);\n', '\n', '\t\t// update referrer&#39;s bonus tokens\n', '\t\tinvestors[referrerAddr].referralTokens = investors[referrerAddr].referralTokens.add(referrerBonusAmount);\n', '\n', '\t\t// update investor&#39;s purchased tokens\n', '\t\tinvestors[msg.sender].purchasedTokens = investors[msg.sender].purchasedTokens.add(purchasedAmount);\n', '\n', '\t\t// update investor&#39;s bonus tokens\n', '\t\tinvestors[msg.sender].bonusTokens = investors[msg.sender].bonusTokens.add(bonusAmount);\n', '\n', '\t\t// update investor&#39;s tokens eth value\n', '\t\tinvestors[msg.sender].contributionInWei = investors[msg.sender].contributionInWei.add(msg.value);\n', '\n', '\t\t// update investor&#39;s tokens purchases\n', '\t\tuint tokensPurchasesLength = investors[msg.sender].tokensPurchases.push(TokensPurchase({\n', '\t\t\tvalue : msg.value,\n', '\t\t\tamount : purchasedAmount,\n', '\t\t\tbonus : bonusAmount,\n', '\t\t\treferrer : referrerAddr,\n', '\t\t\treferrerSentAmount : referrerBonusAmount\n', '\t\t\t})\n', '\t\t);\n', '\n', '\t\t// log investor&#39;s tokens purchase\n', '\t\temit TokensPurchased(\n', '\t\t\tmsg.sender,\n', '\t\t\ttokensPurchasesLength - 1,\n', '\t\t\tmsg.value,\n', '\t\t\tpurchasedAmount,\n', '\t\t\tpromoCodeBonusAmount,\n', '\t\t\tdiscountPhaseBonusAmount,\n', '\t\t\tdiscountStructBonusAmount,\n', '\t\t\treferrerAddr,\n', '\t\t\treferrerBonusAmount,\n', '\t\t\tnow\n', '\t\t);\n', '\n', '\t\t// forward eth to funds wallet\n', '\t\trequire(ethFundsWallet.call.gas(300000).value(msg.value)());\n', '\t}\n', '\n', '\tfunction sendTokens(address _investor, uint256 _amount) external onlyOwner {\n', '\t\trequire(investors[_investor].status == InvestorStatus.WHITELISTED);\n', '\t\trequire(_amount > 0);\n', '\t\trequire(fitsTokensForSaleCap(_amount));\n', '\n', '\t\t// update crowdsale total amount of capital raised\n', '\t\tsentTokens = sentTokens.add(_amount);\n', '\n', '\t\t// update investor&#39;s received tokens balance\n', '\t\tinvestors[_investor].receivedTokens = investors[_investor].receivedTokens.add(_amount);\n', '\n', '\t\t// log tokens sent action\n', '\t\temit TokensSent(\n', '\t\t\t_investor,\n', '\t\t\t_amount,\n', '\t\t\tnow,\n', '\t\t\tmsg.sender\n', '\t\t);\n', '\t}\n', '\n', '\tfunction burnUnsoldTokens() external onlyOwner {\n', '\t\trequire(tokenContract != address(0));\n', '\t\trequire(finalized);\n', '\n', '\t\tuint256 tokensToBurn = tokenContract.balanceOf(this).sub(getDistributedTokens());\n', '\t\trequire(tokensToBurn > 0);\n', '\n', '\t\ttokenContract.burn(tokensToBurn);\n', '\n', '\t\t// log tokens burned action\n', '\t\temit TokensBurned(tokensToBurn, now, msg.sender);\n', '\t}\n', '\n', '\tfunction claimTokens() external {\n', '\t\trequire(tokenContract != address(0));\n', '\t\trequire(!paused);\n', '\t\trequire(investors[msg.sender].status == InvestorStatus.WHITELISTED);\n', '\n', '\t\tuint256 clPurchasedTokens;\n', '\t\tuint256 clReceivedTokens;\n', '\t\tuint256 clBonusTokens_;\n', '\t\tuint256 clRefTokens;\n', '\n', '\t\trequire(purchasedTokensClaimDate < now || bonusTokensClaimDate < now);\n', '\n', '\t\t{\n', '\t\t\tuint256 purchasedTokens = investors[msg.sender].purchasedTokens;\n', '\t\t\tuint256 receivedTokens = investors[msg.sender].receivedTokens;\n', '\t\t\tif (purchasedTokensClaimDate < now && (purchasedTokens > 0 || receivedTokens > 0)) {\n', '\t\t\t\tinvestors[msg.sender].contributionInWei = 0;\n', '\t\t\t\tinvestors[msg.sender].purchasedTokens = 0;\n', '\t\t\t\tinvestors[msg.sender].receivedTokens = 0;\n', '\n', '\t\t\t\tclaimedSoldTokens = claimedSoldTokens.add(purchasedTokens);\n', '\t\t\t\tclaimedSentTokens = claimedSentTokens.add(receivedTokens);\n', '\n', '\t\t\t\t// free up storage used by transaction\n', '\t\t\t\tdelete (investors[msg.sender].tokensPurchases);\n', '\n', '\t\t\t\tclPurchasedTokens = purchasedTokens;\n', '\t\t\t\tclReceivedTokens = receivedTokens;\n', '\n', '\t\t\t\ttokenContract.transfer(msg.sender, purchasedTokens.add(receivedTokens));\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\t{\n', '\t\t\tuint256 bonusTokens_ = investors[msg.sender].bonusTokens;\n', '\t\t\tuint256 refTokens = investors[msg.sender].referralTokens;\n', '\t\t\tif (bonusTokensClaimDate < now && (bonusTokens_ > 0 || refTokens > 0)) {\n', '\t\t\t\tinvestors[msg.sender].bonusTokens = 0;\n', '\t\t\t\tinvestors[msg.sender].referralTokens = 0;\n', '\n', '\t\t\t\tclaimedBonusTokens = claimedBonusTokens.add(bonusTokens_).add(refTokens);\n', '\n', '\t\t\t\tclBonusTokens_ = bonusTokens_;\n', '\t\t\t\tclRefTokens = refTokens;\n', '\n', '\t\t\t\ttokenContract.transfer(msg.sender, bonusTokens_.add(refTokens));\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\trequire(clPurchasedTokens > 0 || clBonusTokens_ > 0 || clRefTokens > 0 || clReceivedTokens > 0);\n', '\t\temit TokensClaimed(msg.sender, clPurchasedTokens, clBonusTokens_, clRefTokens, clReceivedTokens, now, msg.sender);\n', '\t}\n', '\n', '\tfunction refundTokensPurchase(address _investor, uint _purchaseId) external payable onlyOwner {\n', '\t\trequire(msg.value > 0);\n', '\t\trequire(investors[_investor].tokensPurchases[_purchaseId].value == msg.value);\n', '\n', '\t\t_refundTokensPurchase(_investor, _purchaseId);\n', '\n', '\t\t// forward eth to investor&#39;s wallet address\n', '\t\t_investor.transfer(msg.value);\n', '\t}\n', '\n', '\tfunction refundAllInvestorTokensPurchases(address _investor) external payable onlyOwner {\n', '\t\trequire(msg.value > 0);\n', '\t\trequire(investors[_investor].contributionInWei == msg.value);\n', '\n', '\t\tfor (uint i = 0; i < investors[_investor].tokensPurchases.length; i++) {\n', '\t\t\tif (investors[_investor].tokensPurchases[i].value == 0) {\n', '\t\t\t\tcontinue;\n', '\t\t\t}\n', '\n', '\t\t\t_refundTokensPurchase(_investor, i);\n', '\t\t}\n', '\n', '\t\t// forward eth to investor&#39;s wallet address\n', '\t\t_investor.transfer(msg.value);\n', '\t}\n', '\n', '\tfunction _refundTokensPurchase(address _investor, uint _purchaseId) private {\n', '\t\t// update referrer&#39;s referral tokens\n', '\t\taddress referrer = investors[_investor].tokensPurchases[_purchaseId].referrer;\n', '\t\tif (referrer != address(0)) {\n', '\t\t\tuint256 sentAmount = investors[_investor].tokensPurchases[_purchaseId].referrerSentAmount;\n', '\t\t\tinvestors[referrer].referralTokens = investors[referrer].referralTokens.sub(sentAmount);\n', '\t\t\tbonusTokens = bonusTokens.sub(sentAmount);\n', '\t\t}\n', '\n', '\t\t// update investor&#39;s eth amount\n', '\t\tuint256 purchaseValue = investors[_investor].tokensPurchases[_purchaseId].value;\n', '\t\tinvestors[_investor].contributionInWei = investors[_investor].contributionInWei.sub(purchaseValue);\n', '\n', '\t\t// update investor&#39;s purchased tokens\n', '\t\tuint256 purchaseAmount = investors[_investor].tokensPurchases[_purchaseId].amount;\n', '\t\tinvestors[_investor].purchasedTokens = investors[_investor].purchasedTokens.sub(purchaseAmount);\n', '\n', '\t\t// update investor&#39;s bonus tokens\n', '\t\tuint256 bonusAmount = investors[_investor].tokensPurchases[_purchaseId].bonus;\n', '\t\tinvestors[_investor].bonusTokens = investors[_investor].bonusTokens.sub(bonusAmount);\n', '\n', '\t\t// update crowdsale total amount of capital raised\n', '\t\tweiRaised = weiRaised.sub(purchaseValue);\n', '\t\tsoldTokens = soldTokens.sub(purchaseAmount);\n', '\t\tbonusTokens = bonusTokens.sub(bonusAmount);\n', '\n', '\t\t// free up storage used by transaction\n', '\t\tdelete (investors[_investor].tokensPurchases[_purchaseId]);\n', '\n', '\t\t// log investor&#39;s tokens purchase refund\n', '\t\temit TokensPurchaseRefunded(_investor, _purchaseId, purchaseValue, purchaseAmount, bonusAmount, now, msg.sender);\n', '\t}\n', '\n', '\tfunction getInvestorTokensPurchasesLength(address _investor) public constant returns (uint) {\n', '\t\treturn investors[_investor].tokensPurchases.length;\n', '\t}\n', '\n', '\tfunction getInvestorTokensPurchase(\n', '\t\taddress _investor,\n', '\t\tuint _purchaseId\n', '\t) external constant returns (\n', '\t\tuint256 value,\n', '\t\tuint256 amount,\n', '\t\tuint256 bonus,\n', '\t\taddress referrer,\n', '\t\tuint256 referrerSentAmount\n', '\t) {\n', '\t\tvalue = investors[_investor].tokensPurchases[_purchaseId].value;\n', '\t\tamount = investors[_investor].tokensPurchases[_purchaseId].amount;\n', '\t\tbonus = investors[_investor].tokensPurchases[_purchaseId].bonus;\n', '\t\treferrer = investors[_investor].tokensPurchases[_purchaseId].referrer;\n', '\t\treferrerSentAmount = investors[_investor].tokensPurchases[_purchaseId].referrerSentAmount;\n', '\t}\n', '\n', '\tfunction pause() external onlyOwner {\n', '\t\trequire(!paused);\n', '\n', '\t\tpaused = true;\n', '\n', '\t\temit Paused(now, msg.sender);\n', '\t}\n', '\n', '\tfunction resume() external onlyOwner {\n', '\t\trequire(paused);\n', '\n', '\t\tpaused = false;\n', '\n', '\t\temit Resumed(now, msg.sender);\n', '\t}\n', '\n', '\tfunction finalize() external onlyOwner {\n', '\t\trequire(!finalized);\n', '\n', '\t\tfinalized = true;\n', '\n', '\t\temit Finalized(now, msg.sender);\n', '\t}\n', '}\n', '\n', 'contract DiscountPhases is StaffUtil {\n', '\tusing SafeMath for uint256;\n', '\n', '\tevent DiscountPhaseAdded(uint index, string name, uint8 percent, uint fromDate, uint toDate, uint timestamp, address byStaff);\n', '\tevent DiscountPhaseRemoved(uint index, uint timestamp, address byStaff);\n', '\n', '\tstruct DiscountPhase {\n', '\t\tuint8 percent;\n', '\t\tuint fromDate;\n', '\t\tuint toDate;\n', '\t}\n', '\n', '\tDiscountPhase[] public discountPhases;\n', '\n', '\tconstructor(Staff _staffContract) StaffUtil(_staffContract) public {\n', '\t}\n', '\n', '\tfunction calculateBonusAmount(uint256 _purchasedAmount) public constant returns (uint256) {\n', '\t\tfor (uint i = 0; i < discountPhases.length; i++) {\n', '\t\t\tif (now >= discountPhases[i].fromDate && now <= discountPhases[i].toDate) {\n', '\t\t\t\treturn _purchasedAmount.mul(discountPhases[i].percent).div(100);\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\tfunction addDiscountPhase(string _name, uint8 _percent, uint _fromDate, uint _toDate) public onlyOwnerOrStaff {\n', '\t\trequire(bytes(_name).length > 0);\n', '\t\trequire(_percent > 0 && _percent <= 100);\n', '\n', '\t\tif (now > _fromDate) {\n', '\t\t\t_fromDate = now;\n', '\t\t}\n', '\t\trequire(_fromDate < _toDate);\n', '\n', '\t\tfor (uint i = 0; i < discountPhases.length; i++) {\n', '\t\t\trequire(_fromDate > discountPhases[i].toDate || _toDate < discountPhases[i].fromDate);\n', '\t\t}\n', '\n', '\t\tuint index = discountPhases.push(DiscountPhase({percent : _percent, fromDate : _fromDate, toDate : _toDate})) - 1;\n', '\n', '\t\temit DiscountPhaseAdded(index, _name, _percent, _fromDate, _toDate, now, msg.sender);\n', '\t}\n', '\n', '\tfunction removeDiscountPhase(uint _index) public onlyOwnerOrStaff {\n', '\t\trequire(now < discountPhases[_index].toDate);\n', '\t\tdelete discountPhases[_index];\n', '\t\temit DiscountPhaseRemoved(_index, now, msg.sender);\n', '\t}\n', '}\n', '\n', 'contract DiscountStructs is StaffUtil {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public crowdsale;\n', '\n', '\tevent DiscountStructAdded(\n', '\t\tuint index,\n', '\t\tbytes32 name,\n', '\t\tuint256 tokens,\n', '\t\tuint[2] dates,\n', '\t\tuint256[] fromWei,\n', '\t\tuint256[] toWei,\n', '\t\tuint256[] percent,\n', '\t\tuint timestamp,\n', '\t\taddress byStaff\n', '\t);\n', '\tevent DiscountStructRemoved(\n', '\t\tuint index,\n', '\t\tuint timestamp,\n', '\t\taddress byStaff\n', '\t);\n', '\tevent DiscountStructUsed(\n', '\t\tuint index,\n', '\t\tuint step,\n', '\t\taddress investor,\n', '\t\tuint256 tokens,\n', '\t\tuint timestamp\n', '\t);\n', '\n', '\tstruct DiscountStruct {\n', '\t\tuint256 availableTokens;\n', '\t\tuint256 distributedTokens;\n', '\t\tuint fromDate;\n', '\t\tuint toDate;\n', '\t}\n', '\n', '\tstruct DiscountStep {\n', '\t\tuint256 fromWei;\n', '\t\tuint256 toWei;\n', '\t\tuint256 percent;\n', '\t}\n', '\n', '\tDiscountStruct[] public discountStructs;\n', '\tmapping(uint => DiscountStep[]) public discountSteps;\n', '\n', '\tconstructor(Staff _staffContract) StaffUtil(_staffContract) public {\n', '\t}\n', '\n', '\tmodifier onlyCrowdsale() {\n', '\t\trequire(msg.sender == crowdsale);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction setCrowdsale(Crowdsale _crowdsale) external onlyOwner {\n', '\t\trequire(crowdsale == address(0));\n', '\t\trequire(_crowdsale.staffContract() == staffContract);\n', '\t\tcrowdsale = _crowdsale;\n', '\t}\n', '\n', '\tfunction getBonus(address _investor, uint256 _purchasedAmount, uint256 _purchasedValue) public onlyCrowdsale returns (uint256) {\n', '\t\tfor (uint i = 0; i < discountStructs.length; i++) {\n', '\t\t\tif (now >= discountStructs[i].fromDate && now <= discountStructs[i].toDate) {\n', '\n', '\t\t\t\tif (discountStructs[i].distributedTokens >= discountStructs[i].availableTokens) {\n', '\t\t\t\t\treturn;\n', '\t\t\t\t}\n', '\n', '\t\t\t\tfor (uint j = 0; j < discountSteps[i].length; j++) {\n', '\t\t\t\t\tif (_purchasedValue >= discountSteps[i][j].fromWei\n', '\t\t\t\t\t\t&& (_purchasedValue < discountSteps[i][j].toWei || discountSteps[i][j].toWei == 0)) {\n', '\t\t\t\t\t\tuint256 bonus = _purchasedAmount.mul(discountSteps[i][j].percent).div(100);\n', '\t\t\t\t\t\tif (discountStructs[i].distributedTokens.add(bonus) > discountStructs[i].availableTokens) {\n', '\t\t\t\t\t\t\treturn;\n', '\t\t\t\t\t\t}\n', '\t\t\t\t\t\tdiscountStructs[i].distributedTokens = discountStructs[i].distributedTokens.add(bonus);\n', '\t\t\t\t\t\temit DiscountStructUsed(i, j, _investor, bonus, now);\n', '\t\t\t\t\t\treturn bonus;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\n', '\t\t\t\treturn;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\tfunction calculateBonus(uint256 _purchasedAmount, uint256 _purchasedValue) public constant returns (uint256) {\n', '\t\tfor (uint i = 0; i < discountStructs.length; i++) {\n', '\t\t\tif (now >= discountStructs[i].fromDate && now <= discountStructs[i].toDate) {\n', '\n', '\t\t\t\tif (discountStructs[i].distributedTokens >= discountStructs[i].availableTokens) {\n', '\t\t\t\t\treturn;\n', '\t\t\t\t}\n', '\n', '\t\t\t\tfor (uint j = 0; j < discountSteps[i].length; j++) {\n', '\t\t\t\t\tif (_purchasedValue >= discountSteps[i][j].fromWei\n', '\t\t\t\t\t\t&& (_purchasedValue < discountSteps[i][j].toWei || discountSteps[i][j].toWei == 0)) {\n', '\t\t\t\t\t\tuint256 bonus = _purchasedAmount.mul(discountSteps[i][j].percent).div(100);\n', '\t\t\t\t\t\tif (discountStructs[i].distributedTokens.add(bonus) > discountStructs[i].availableTokens) {\n', '\t\t\t\t\t\t\treturn;\n', '\t\t\t\t\t\t}\n', '\t\t\t\t\t\treturn bonus;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\n', '\t\t\t\treturn;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\tfunction addDiscountStruct(bytes32 _name, uint256 _tokens, uint[2] _dates, uint256[] _fromWei, uint256[] _toWei, uint256[] _percent) external onlyOwnerOrStaff {\n', '\t\trequire(_name.length > 0);\n', '\t\trequire(_tokens > 0);\n', '\t\trequire(_dates[0] < _dates[1]);\n', '\t\trequire(_fromWei.length > 0 && _fromWei.length == _toWei.length && _fromWei.length == _percent.length);\n', '\n', '\t\tfor (uint j = 0; j < discountStructs.length; j++) {\n', '\t\t\trequire(_dates[0] > discountStructs[j].fromDate || _dates[1] < discountStructs[j].toDate);\n', '\t\t}\n', '\n', '\t\tDiscountStruct memory ds = DiscountStruct(_tokens, 0, _dates[0], _dates[1]);\n', '\t\tuint index = discountStructs.push(ds) - 1;\n', '\n', '\t\tfor (uint i = 0; i < _fromWei.length; i++) {\n', '\t\t\trequire(_fromWei[i] > 0 || _toWei[i] > 0);\n', '\t\t\tif (_fromWei[i] > 0 && _toWei[i] > 0) {\n', '\t\t\t\trequire(_fromWei[i] < _toWei[i]);\n', '\t\t\t}\n', '\t\t\trequire(_percent[i] > 0 && _percent[i] <= 100);\n', '\t\t\tdiscountSteps[index].push(DiscountStep(_fromWei[i], _toWei[i], _percent[i]));\n', '\t\t}\n', '\n', '\t\temit DiscountStructAdded(index, _name, _tokens, _dates, _fromWei, _toWei, _percent, now, msg.sender);\n', '\t}\n', '\n', '\tfunction removeDiscountStruct(uint _index) public onlyOwnerOrStaff {\n', '\t\trequire(now < discountStructs[_index].toDate);\n', '\t\tdelete discountStructs[_index];\n', '\t\tdelete discountSteps[_index];\n', '\t\temit DiscountStructRemoved(_index, now, msg.sender);\n', '\t}\n', '}\n', '\n', 'contract PromoCodes is StaffUtil {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public crowdsale;\n', '\n', '\tevent PromoCodeAdded(bytes32 indexed code, string name, uint8 percent, uint256 maxUses, uint timestamp, address byStaff);\n', '\tevent PromoCodeRemoved(bytes32 indexed code, uint timestamp, address byStaff);\n', '\tevent PromoCodeUsed(bytes32 indexed code, address investor, uint timestamp);\n', '\n', '\tstruct PromoCode {\n', '\t\tuint8 percent;\n', '\t\tuint256 uses;\n', '\t\tuint256 maxUses;\n', '\t\tmapping(address => bool) investors;\n', '\t}\n', '\n', '\tmapping(bytes32 => PromoCode) public promoCodes;\n', '\n', '\tconstructor(Staff _staffContract) StaffUtil(_staffContract) public {\n', '\t}\n', '\n', '\tmodifier onlyCrowdsale() {\n', '\t\trequire(msg.sender == crowdsale);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction setCrowdsale(Crowdsale _crowdsale) external onlyOwner {\n', '\t\trequire(crowdsale == address(0));\n', '\t\trequire(_crowdsale.staffContract() == staffContract);\n', '\t\tcrowdsale = _crowdsale;\n', '\t}\n', '\n', '\tfunction applyBonusAmount(address _investor, uint256 _purchasedAmount, bytes32 _promoCode) public onlyCrowdsale returns (uint256) {\n', '\t\tif (promoCodes[_promoCode].percent == 0\n', '\t\t|| promoCodes[_promoCode].investors[_investor]\n', '\t\t|| promoCodes[_promoCode].uses == promoCodes[_promoCode].maxUses) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\tpromoCodes[_promoCode].investors[_investor] = true;\n', '\t\tpromoCodes[_promoCode].uses = promoCodes[_promoCode].uses + 1;\n', '\t\temit PromoCodeUsed(_promoCode, _investor, now);\n', '\t\treturn _purchasedAmount.mul(promoCodes[_promoCode].percent).div(100);\n', '\t}\n', '\n', '\tfunction calculateBonusAmount(address _investor, uint256 _purchasedAmount, bytes32 _promoCode) public constant returns (uint256) {\n', '\t\tif (promoCodes[_promoCode].percent == 0\n', '\t\t|| promoCodes[_promoCode].investors[_investor]\n', '\t\t|| promoCodes[_promoCode].uses == promoCodes[_promoCode].maxUses) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\treturn _purchasedAmount.mul(promoCodes[_promoCode].percent).div(100);\n', '\t}\n', '\n', '\tfunction addPromoCode(string _name, bytes32 _code, uint256 _maxUses, uint8 _percent) public onlyOwnerOrStaff {\n', '\t\trequire(bytes(_name).length > 0);\n', '\t\trequire(_code[0] != 0);\n', '\t\trequire(_percent > 0 && _percent <= 100);\n', '\t\trequire(_maxUses > 0);\n', '\t\trequire(promoCodes[_code].percent == 0);\n', '\n', '\t\tpromoCodes[_code].percent = _percent;\n', '\t\tpromoCodes[_code].maxUses = _maxUses;\n', '\n', '\t\temit PromoCodeAdded(_code, _name, _percent, _maxUses, now, msg.sender);\n', '\t}\n', '\n', '\tfunction removePromoCode(bytes32 _code) public onlyOwnerOrStaff {\n', '\t\tdelete promoCodes[_code];\n', '\t\temit PromoCodeRemoved(_code, now, msg.sender);\n', '\t}\n', '}\n', '\n', 'contract Token is BurnableToken {\n', '}']