['pragma solidity ^0.4.24;\n', '\n', '// File: zos-lib/contracts/migrations/Migratable.sol\n', '\n', '/**\n', ' * @title Migratable\n', ' * Helper contract to support intialization and migration schemes between\n', ' * different implementations of a contract in the context of upgradeability.\n', ' * To use it, replace the constructor with a function that has the\n', ' * `isInitializer` modifier starting with `"0"` as `migrationId`.\n', ' * When you want to apply some migration code during an upgrade, increase\n', ' * the `migrationId`. Or, if the migration code must be applied only after\n', ' * another migration has been already applied, use the `isMigration` modifier.\n', ' * This helper supports multiple inheritance.\n', " * WARNING: It is the developer's responsibility to ensure that migrations are\n", ' * applied in a correct order, or that they are run at all.\n', ' * See `Initializable` for a simpler version.\n', ' */\n', 'contract Migratable {\n', '  /**\n', '   * @dev Emitted when the contract applies a migration.\n', '   * @param contractName Name of the Contract.\n', '   * @param migrationId Identifier of the migration applied.\n', '   */\n', '  event Migrated(string contractName, string migrationId);\n', '\n', '  /**\n', '   * @dev Mapping of the already applied migrations.\n', '   * (contractName => (migrationId => bool))\n', '   */\n', '  mapping (string => mapping (string => bool)) internal migrated;\n', '\n', '  /**\n', '   * @dev Internal migration id used to specify that a contract has already been initialized.\n', '   */\n', '  string constant private INITIALIZED_ID = "initialized";\n', '\n', '\n', '  /**\n', '   * @dev Modifier to use in the initialization function of a contract.\n', '   * @param contractName Name of the contract.\n', '   * @param migrationId Identifier of the migration.\n', '   */\n', '  modifier isInitializer(string contractName, string migrationId) {\n', '    validateMigrationIsPending(contractName, INITIALIZED_ID);\n', '    validateMigrationIsPending(contractName, migrationId);\n', '    _;\n', '    emit Migrated(contractName, migrationId);\n', '    migrated[contractName][migrationId] = true;\n', '    migrated[contractName][INITIALIZED_ID] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to use in the migration of a contract.\n', '   * @param contractName Name of the contract.\n', '   * @param requiredMigrationId Identifier of the previous migration, required\n', '   * to apply new one.\n', '   * @param newMigrationId Identifier of the new migration to be applied.\n', '   */\n', '  modifier isMigration(string contractName, string requiredMigrationId, string newMigrationId) {\n', '    require(isMigrated(contractName, requiredMigrationId), "Prerequisite migration ID has not been run yet");\n', '    validateMigrationIsPending(contractName, newMigrationId);\n', '    _;\n', '    emit Migrated(contractName, newMigrationId);\n', '    migrated[contractName][newMigrationId] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns true if the contract migration was applied.\n', '   * @param contractName Name of the contract.\n', '   * @param migrationId Identifier of the migration.\n', '   * @return true if the contract migration was applied, false otherwise.\n', '   */\n', '  function isMigrated(string contractName, string migrationId) public view returns(bool) {\n', '    return migrated[contractName][migrationId];\n', '  }\n', '\n', '  /**\n', '   * @dev Initializer that marks the contract as initialized.\n', '   * It is important to run this if you had deployed a previous version of a Migratable contract.\n', '   * For more information see https://github.com/zeppelinos/zos-lib/issues/158.\n', '   */\n', '  function initialize() isInitializer("Migratable", "1.2.1") public {\n', '  }\n', '\n', '  /**\n', '   * @dev Reverts if the requested migration was already executed.\n', '   * @param contractName Name of the contract.\n', '   * @param migrationId Identifier of the migration.\n', '   */\n', '  function validateMigrationIsPending(string contractName, string migrationId) private view {\n', '    require(!isMigrated(contractName, migrationId), "Requested target migration ID has already been run");\n', '  }\n', '}\n', '\n', '// File: openzeppelin-zos/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable is Migratable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function initialize(address _sender) public isInitializer("Ownable", "1.9.0") {\n', '    owner = _sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-zos/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Migratable, Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  function initialize(address _sender) isInitializer("Pausable", "1.9.0")  public {\n', '    Ownable.initialize(_sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: openzeppelin-zos/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-zos/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/marketplace/MarketplaceStorage.sol\n', '\n', '/**\n', ' * @title Interface for contracts conforming to ERC-20\n', ' */\n', 'contract ERC20Interface {\n', '  function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '}\n', '\n', '\n', '/**\n', ' * @title Interface for contracts conforming to ERC-721\n', ' */\n', 'contract ERC721Interface {\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address);\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function supportsInterface(bytes4) public view returns (bool);\n', '}\n', '\n', '\n', 'contract ERC721Verifiable is ERC721Interface {\n', '  function verifyFingerprint(uint256, bytes) public view returns (bool);\n', '}\n', '\n', '\n', 'contract MarketplaceStorage {\n', '  ERC20Interface public acceptedToken;\n', '\n', '  struct Order {\n', '    // Order ID\n', '    bytes32 id;\n', '    // Owner of the NFT\n', '    address seller;\n', '    // NFT registry address\n', '    address nftAddress;\n', '    // Price (in wei) for the published item\n', '    uint256 price;\n', '    // Time when this sale ends\n', '    uint256 expiresAt;\n', '  }\n', '\n', '  // From ERC721 registry assetId to Order (to avoid asset collision)\n', '  mapping (address => mapping(uint256 => Order)) public orderByAssetId;\n', '\n', '  uint256 public ownerCutPerMillion;\n', '  uint256 public publicationFeeInWei;\n', '\n', '  address public legacyNFTAddress;\n', '\n', '  bytes4 public constant InterfaceId_ValidateFingerprint = bytes4(\n', '    keccak256("verifyFingerprint(uint256,bytes)")\n', '  );\n', '\n', '  bytes4 public constant ERC721_Interface = bytes4(0x80ac58cd);\n', '\n', '  // EVENTS\n', '  event OrderCreated(\n', '    bytes32 id,\n', '    uint256 indexed assetId,\n', '    address indexed seller,\n', '    address nftAddress,\n', '    uint256 priceInWei,\n', '    uint256 expiresAt\n', '  );\n', '  event OrderSuccessful(\n', '    bytes32 id,\n', '    uint256 indexed assetId,\n', '    address indexed seller,\n', '    address nftAddress,\n', '    uint256 totalPrice,\n', '    address indexed buyer\n', '  );\n', '  event OrderCancelled(\n', '    bytes32 id,\n', '    uint256 indexed assetId,\n', '    address indexed seller,\n', '    address nftAddress\n', '  );\n', '\n', '  event ChangedPublicationFee(uint256 publicationFee);\n', '  event ChangedOwnerCutPerMillion(uint256 ownerCutPerMillion);\n', '  event ChangeLegacyNFTAddress(address indexed legacyNFTAddress);\n', '\n', '  // [LEGACY] Auction events\n', '  event AuctionCreated(\n', '    bytes32 id,\n', '    uint256 indexed assetId,\n', '    address indexed seller,\n', '    uint256 priceInWei,\n', '    uint256 expiresAt\n', '  );\n', '  event AuctionSuccessful(\n', '    bytes32 id,\n', '    uint256 indexed assetId,\n', '    address indexed seller,\n', '    uint256 totalPrice,\n', '    address indexed winner\n', '  );\n', '  event AuctionCancelled(\n', '    bytes32 id,\n', '    uint256 indexed assetId,\n', '    address indexed seller\n', '  );\n', '}\n', '\n', '// File: contracts/marketplace/Marketplace.sol\n', '\n', 'contract Marketplace is Migratable, Ownable, Pausable, MarketplaceStorage {\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  /**\n', "    * @dev Sets the publication fee that's charged to users to publish items\n", '    * @param _publicationFee - Fee amount in wei this contract charges to publish an item\n', '    */\n', '  function setPublicationFee(uint256 _publicationFee) external onlyOwner {\n', '    publicationFeeInWei = _publicationFee;\n', '    emit ChangedPublicationFee(publicationFeeInWei);\n', '  }\n', '\n', '  /**\n', "    * @dev Sets the share cut for the owner of the contract that's\n", '    *  charged to the seller on a successful sale\n', '    * @param _ownerCutPerMillion - Share amount, from 0 to 999,999\n', '    */\n', '  function setOwnerCutPerMillion(uint256 _ownerCutPerMillion) external onlyOwner {\n', '    require(_ownerCutPerMillion < 1000000, "The owner cut should be between 0 and 999,999");\n', '\n', '    ownerCutPerMillion = _ownerCutPerMillion;\n', '    emit ChangedOwnerCutPerMillion(ownerCutPerMillion);\n', '  }\n', '\n', '  /**\n', '    * @dev Sets the legacy NFT address to be used\n', "    * @param _legacyNFTAddress - Address of the NFT address used for legacy methods that don't have nftAddress as parameter\n", '    */\n', '  function setLegacyNFTAddress(address _legacyNFTAddress) external onlyOwner {\n', '    _requireERC721(_legacyNFTAddress);\n', '\n', '    legacyNFTAddress = _legacyNFTAddress;\n', '    emit ChangeLegacyNFTAddress(legacyNFTAddress);\n', '  }\n', '\n', '  /**\n', '    * @dev Initialize this contract. Acts as a constructor\n', '    * @param _acceptedToken - Address of the ERC20 accepted for this marketplace\n', "    * @param _legacyNFTAddress - Address of the NFT address used for legacy methods that don't have nftAddress as parameter\n", '    */\n', '  function initialize(\n', '    address _acceptedToken,\n', '    address _legacyNFTAddress,\n', '    address _owner\n', '  )\n', '    public\n', '    isInitializer("Marketplace", "0.0.1")\n', '  {\n', '\n', '    // msg.sender is the App contract not the real owner. Calls ownable behind the scenes...sigh\n', '    require(_owner != address(0), "Invalid owner");\n', '    Pausable.initialize(_owner);\n', '\n', '    require(_acceptedToken.isContract(), "The accepted token address must be a deployed contract");\n', '    acceptedToken = ERC20Interface(_acceptedToken);\n', '\n', '    _requireERC721(_legacyNFTAddress);\n', '    legacyNFTAddress = _legacyNFTAddress;\n', '  }\n', '\n', '  /**\n', '    * @dev Creates a new order\n', '    * @param nftAddress - Non fungible registry address\n', '    * @param assetId - ID of the published NFT\n', '    * @param priceInWei - Price in Wei for the supported coin\n', '    * @param expiresAt - Duration of the order (in hours)\n', '    */\n', '  function createOrder(\n', '    address nftAddress,\n', '    uint256 assetId,\n', '    uint256 priceInWei,\n', '    uint256 expiresAt\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    _createOrder(\n', '      nftAddress,\n', '      assetId,\n', '      priceInWei,\n', '      expiresAt\n', '    );\n', '  }\n', '\n', '  /**\n', '    * @dev [LEGACY] Creates a new order\n', '    * @param assetId - ID of the published NFT\n', '    * @param priceInWei - Price in Wei for the supported coin\n', '    * @param expiresAt - Duration of the order (in hours)\n', '    */\n', '  function createOrder(\n', '    uint256 assetId,\n', '    uint256 priceInWei,\n', '    uint256 expiresAt\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    _createOrder(\n', '      legacyNFTAddress,\n', '      assetId,\n', '      priceInWei,\n', '      expiresAt\n', '    );\n', '\n', '    Order memory order = orderByAssetId[legacyNFTAddress][assetId];\n', '    emit AuctionCreated(\n', '      order.id,\n', '      assetId,\n', '      order.seller,\n', '      order.price,\n', '      order.expiresAt\n', '    );\n', '  }\n', '\n', '  /**\n', '    * @dev Cancel an already published order\n', '    *  can only be canceled by seller or the contract owner\n', '    * @param nftAddress - Address of the NFT registry\n', '    * @param assetId - ID of the published NFT\n', '    */\n', '  function cancelOrder(address nftAddress, uint256 assetId) public whenNotPaused {\n', '    _cancelOrder(nftAddress, assetId);\n', '  }\n', '\n', '  /**\n', '    * @dev [LEGACY] Cancel an already published order\n', '    *  can only be canceled by seller or the contract owner\n', '    * @param assetId - ID of the published NFT\n', '    */\n', '  function cancelOrder(uint256 assetId) public whenNotPaused {\n', '    Order memory order = _cancelOrder(legacyNFTAddress, assetId);\n', '\n', '    emit AuctionCancelled(\n', '      order.id,\n', '      assetId,\n', '      order.seller\n', '    );\n', '  }\n', '\n', '  /**\n', '    * @dev Executes the sale for a published NFT and checks for the asset fingerprint\n', '    * @param nftAddress - Address of the NFT registry\n', '    * @param assetId - ID of the published NFT\n', '    * @param price - Order price\n', '    * @param fingerprint - Verification info for the asset\n', '    */\n', '  function safeExecuteOrder(\n', '    address nftAddress,\n', '    uint256 assetId,\n', '    uint256 price,\n', '    bytes fingerprint\n', '  )\n', '   public\n', '   whenNotPaused\n', '  {\n', '    _executeOrder(\n', '      nftAddress,\n', '      assetId,\n', '      price,\n', '      fingerprint\n', '    );\n', '  }\n', '\n', '  /**\n', '    * @dev Executes the sale for a published NFT\n', '    * @param nftAddress - Address of the NFT registry\n', '    * @param assetId - ID of the published NFT\n', '    * @param price - Order price\n', '    */\n', '  function executeOrder(\n', '    address nftAddress,\n', '    uint256 assetId,\n', '    uint256 price\n', '  )\n', '   public\n', '   whenNotPaused\n', '  {\n', '    _executeOrder(\n', '      nftAddress,\n', '      assetId,\n', '      price,\n', '      ""\n', '    );\n', '  }\n', '\n', '  /**\n', '    * @dev [LEGACY] Executes the sale for a published NFT\n', '    * @param assetId - ID of the published NFT\n', '    * @param price - Order price\n', '    */\n', '  function executeOrder(\n', '    uint256 assetId,\n', '    uint256 price\n', '  )\n', '   public\n', '   whenNotPaused\n', '  {\n', '    Order memory order = _executeOrder(\n', '      legacyNFTAddress,\n', '      assetId,\n', '      price,\n', '      ""\n', '    );\n', '\n', '    emit AuctionSuccessful(\n', '      order.id,\n', '      assetId,\n', '      order.seller,\n', '      price,\n', '      msg.sender\n', '    );\n', '  }\n', '\n', '  /**\n', '    * @dev [LEGACY] Gets an order using the legacy NFT address.\n', "    * @dev It's equivalent to orderByAssetId[legacyNFTAddress][assetId] but returns same structure as the old Auction\n", '    * @param assetId - ID of the published NFT\n', '    */\n', '  function auctionByAssetId(\n', '    uint256 assetId\n', '  )\n', '    public\n', '    view\n', '    returns\n', '    (bytes32, address, uint256, uint256)\n', '  {\n', '    Order memory order = orderByAssetId[legacyNFTAddress][assetId];\n', '    return (order.id, order.seller, order.price, order.expiresAt);\n', '  }\n', '\n', '  /**\n', '    * @dev Creates a new order\n', '    * @param nftAddress - Non fungible registry address\n', '    * @param assetId - ID of the published NFT\n', '    * @param priceInWei - Price in Wei for the supported coin\n', '    * @param expiresAt - Duration of the order (in hours)\n', '    */\n', '  function _createOrder(\n', '    address nftAddress,\n', '    uint256 assetId,\n', '    uint256 priceInWei,\n', '    uint256 expiresAt\n', '  )\n', '    internal\n', '  {\n', '    _requireERC721(nftAddress);\n', '\n', '    ERC721Interface nftRegistry = ERC721Interface(nftAddress);\n', '    address assetOwner = nftRegistry.ownerOf(assetId);\n', '\n', '    require(msg.sender == assetOwner, "Only the owner can create orders");\n', '    require(\n', '      nftRegistry.getApproved(assetId) == address(this) || nftRegistry.isApprovedForAll(assetOwner, address(this)),\n', '      "The contract is not authorized to manage the asset"\n', '    );\n', '    require(priceInWei > 0, "Price should be bigger than 0");\n', '    require(expiresAt > block.timestamp.add(1 minutes), "Publication should be more than 1 minute in the future");\n', '\n', '    bytes32 orderId = keccak256(\n', '      abi.encodePacked(\n', '        block.timestamp,\n', '        assetOwner,\n', '        assetId,\n', '        nftAddress,\n', '        priceInWei\n', '      )\n', '    );\n', '\n', '    orderByAssetId[nftAddress][assetId] = Order({\n', '      id: orderId,\n', '      seller: assetOwner,\n', '      nftAddress: nftAddress,\n', '      price: priceInWei,\n', '      expiresAt: expiresAt\n', '    });\n', '\n', "    // Check if there's a publication fee and\n", '    // transfer the amount to marketplace owner\n', '    if (publicationFeeInWei > 0) {\n', '      require(\n', '        acceptedToken.transferFrom(msg.sender, owner, publicationFeeInWei),\n', '        "Transfering the publication fee to the Marketplace owner failed"\n', '      );\n', '    }\n', '\n', '    emit OrderCreated(\n', '      orderId,\n', '      assetId,\n', '      assetOwner,\n', '      nftAddress,\n', '      priceInWei,\n', '      expiresAt\n', '    );\n', '  }\n', '\n', '  /**\n', '    * @dev Cancel an already published order\n', '    *  can only be canceled by seller or the contract owner\n', '    * @param nftAddress - Address of the NFT registry\n', '    * @param assetId - ID of the published NFT\n', '    */\n', '  function _cancelOrder(address nftAddress, uint256 assetId) internal returns (Order) {\n', '    Order memory order = orderByAssetId[nftAddress][assetId];\n', '\n', '    require(order.id != 0, "Asset not published");\n', '    require(order.seller == msg.sender || msg.sender == owner, "Unauthorized user");\n', '\n', '    bytes32 orderId = order.id;\n', '    address orderSeller = order.seller;\n', '    address orderNftAddress = order.nftAddress;\n', '    delete orderByAssetId[nftAddress][assetId];\n', '\n', '    emit OrderCancelled(\n', '      orderId,\n', '      assetId,\n', '      orderSeller,\n', '      orderNftAddress\n', '    );\n', '\n', '    return order;\n', '  }\n', '\n', '  /**\n', '    * @dev Executes the sale for a published NFT\n', '    * @param nftAddress - Address of the NFT registry\n', '    * @param assetId - ID of the published NFT\n', '    * @param price - Order price\n', '    * @param fingerprint - Verification info for the asset\n', '    */\n', '  function _executeOrder(\n', '    address nftAddress,\n', '    uint256 assetId,\n', '    uint256 price,\n', '    bytes fingerprint\n', '  )\n', '   internal returns (Order)\n', '  {\n', '    _requireERC721(nftAddress);\n', '\n', '    ERC721Verifiable nftRegistry = ERC721Verifiable(nftAddress);\n', '\n', '    if (nftRegistry.supportsInterface(InterfaceId_ValidateFingerprint)) {\n', '      require(\n', '        nftRegistry.verifyFingerprint(assetId, fingerprint),\n', '        "The asset fingerprint is not valid"\n', '      );\n', '    }\n', '    Order memory order = orderByAssetId[nftAddress][assetId];\n', '\n', '    require(order.id != 0, "Asset not published");\n', '\n', '    address seller = order.seller;\n', '\n', '    require(seller != address(0), "Invalid address");\n', '    require(seller != msg.sender, "Unauthorized user");\n', '    require(order.price == price, "The price is not correct");\n', '    require(block.timestamp < order.expiresAt, "The order expired");\n', '    require(seller == nftRegistry.ownerOf(assetId), "The seller is no longer the owner");\n', '\n', '    uint saleShareAmount = 0;\n', '\n', '    bytes32 orderId = order.id;\n', '    delete orderByAssetId[nftAddress][assetId];\n', '\n', '    if (ownerCutPerMillion > 0) {\n', '      // Calculate sale share\n', '      saleShareAmount = price.mul(ownerCutPerMillion).div(1000000);\n', '\n', '      // Transfer share amount for marketplace Owner\n', '      require(\n', '        acceptedToken.transferFrom(msg.sender, owner, saleShareAmount),\n', '        "Transfering the cut to the Marketplace owner failed"\n', '      );\n', '    }\n', '\n', '    // Transfer sale amount to seller\n', '    require(\n', '      acceptedToken.transferFrom(msg.sender, seller, price.sub(saleShareAmount)),\n', '      "Transfering the sale amount to the seller failed"\n', '    );\n', '\n', '    // Transfer asset owner\n', '    nftRegistry.safeTransferFrom(\n', '      seller,\n', '      msg.sender,\n', '      assetId\n', '    );\n', '\n', '    emit OrderSuccessful(\n', '      orderId,\n', '      assetId,\n', '      seller,\n', '      nftAddress,\n', '      price,\n', '      msg.sender\n', '    );\n', '\n', '    return order;\n', '  }\n', '\n', '  function _requireERC721(address nftAddress) internal view {\n', '    require(nftAddress.isContract(), "The NFT Address should be a contract");\n', '\n', '    ERC721Interface nftRegistry = ERC721Interface(nftAddress);\n', '    require(\n', '      nftRegistry.supportsInterface(ERC721_Interface),\n', '      "The NFT contract has an invalid ERC721 implementation"\n', '    );\n', '  }\n', '}']