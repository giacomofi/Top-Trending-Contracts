['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract PresaleFallbackReceiver {\n', '  bool public presaleFallBackCalled;\n', '\n', '  function presaleFallBack(uint256 _presaleWeiRaised) public returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title RefundVault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Supports refunding the money if crowdsale fails,\n', ' * and forwarding it if crowdsale is successful.\n', ' */\n', 'contract RefundVault is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  enum State { Active, Refunding, Closed }\n', '\n', '  mapping (address => uint256) public deposited;\n', '  address public wallet;\n', '  State public state;\n', '\n', '  event Closed();\n', '  event RefundsEnabled();\n', '  event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '  function RefundVault(address _wallet) public {\n', '    require(_wallet != address(0));\n', '    wallet = _wallet;\n', '    state = State.Active;\n', '  }\n', '\n', '  function deposit(address investor) onlyOwner public payable {\n', '    require(state == State.Active);\n', '    deposited[investor] = deposited[investor].add(msg.value);\n', '  }\n', '\n', '  function close() onlyOwner public {\n', '    require(state == State.Active);\n', '    state = State.Closed;\n', '    Closed();\n', '    wallet.transfer(this.balance);\n', '  }\n', '\n', '  function enableRefunds() onlyOwner public {\n', '    require(state == State.Active);\n', '    state = State.Refunding;\n', '    RefundsEnabled();\n', '  }\n', '\n', '  function refund(address investor) public {\n', '    require(state == State.Refunding);\n', '    uint256 depositedValue = deposited[investor];\n', '    deposited[investor] = 0;\n', '    investor.transfer(depositedValue);\n', '    Refunded(investor, depositedValue);\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', 'contract Controlled {\n', '    /// @notice The address of the controller is the only address that can call\n', '    ///  a function with this modifier\n', '    modifier onlyController { require(msg.sender == controller); _; }\n', '\n', '    address public controller;\n', '\n', '    function Controlled() public { controller = msg.sender;}\n', '\n', '    /// @notice Changes the controller of the contract\n', '    /// @param _newController The new controller of the contract\n', '    function changeController(address _newController) public onlyController {\n', '        controller = _newController;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract BTCPaymentI is Ownable, PresaleFallbackReceiver {\n', '  PaymentFallbackReceiver public presale;\n', '  PaymentFallbackReceiver public mainsale;\n', '\n', '  function addPayment(address _beneficiary, uint256 _tokens) public;\n', '  function setPresale(address _presale) external;\n', '  function setMainsale(address _mainsale) external;\n', '  function presaleFallBack(uint256) public returns (bool);\n', '}\n', '\n', '\n', 'contract PaymentFallbackReceiver {\n', '  BTCPaymentI public payment;\n', '\n', '  enum SaleType { pre, main }\n', '\n', '  function PaymentFallbackReceiver(address _payment) public {\n', '    require(_payment != address(0));\n', '    payment = BTCPaymentI(_payment);\n', '  }\n', '\n', '  modifier onlyPayment() {\n', '    require(msg.sender == address(payment));\n', '    _;\n', '  }\n', '\n', '  event MintByBTC(SaleType _saleType, address indexed _beneficiary, uint256 _tokens);\n', '\n', '  /**\n', '   * @dev paymentFallBack() is called in BTCPayment.addPayment().\n', '   * Presale or Mainsale contract should mint token to beneficiary,\n', '   * and apply corresponding ether amount to max ether cap.\n', '   * @param _beneficiary ethereum address who receives tokens\n', '   * @param _tokens amount of FXT to mint\n', '   */\n', '  function paymentFallBack(address _beneficiary, uint256 _tokens) external onlyPayment();\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Sudo\n', ' * @dev Some functions should be restricted so as not to be available in any situation.\n', ' * `onlySudoEnabled` modifier controlls it.\n', ' */\n', 'contract Sudo is Ownable {\n', '  bool public sudoEnabled;\n', '\n', '  modifier onlySudoEnabled() {\n', '    require(sudoEnabled);\n', '    _;\n', '  }\n', '\n', '  event SudoEnabled(bool _sudoEnabled);\n', '\n', '  function Sudo(bool _sudoEnabled) public {\n', '    sudoEnabled = _sudoEnabled;\n', '  }\n', '\n', '  function enableSudo(bool _sudoEnabled) public onlyOwner {\n', '    sudoEnabled = _sudoEnabled;\n', '    SudoEnabled(_sudoEnabled);\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract FXTI is ERC20 {\n', '  bool public sudoEnabled = true;\n', '\n', '  function transfer(address _to, uint256 _amount) public returns (bool success);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\n', '\n', '  function generateTokens(address _owner, uint _amount) public returns (bool);\n', '\n', '  function destroyTokens(address _owner, uint _amount) public returns (bool);\n', '\n', '  function blockAddress(address _addr) public;\n', '\n', '  function unblockAddress(address _addr) public;\n', '\n', '  function enableSudo(bool _sudoEnabled) public;\n', '\n', '  function enableTransfers(bool _transfersEnabled) public;\n', '\n', '  // byList functions\n', '\n', '  function generateTokensByList(address[] _owners, uint[] _amounts) public returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title KYCInterface\n', ' */\n', 'contract KYCI is Ownable {\n', '  function setAdmin(address _addr, bool _value) public returns (bool);\n', '  function isRegistered(address _addr, bool _isPresale) public returns (bool);\n', '  function register(address _addr, bool _isPresale) public;\n', '  function registerByList(address[] _addrs, bool _isPresale) public;\n', '  function unregister(address _addr, bool _isPresale)public;\n', '  function unregisterByList(address[] _addrs, bool _isPresale) public;\n', '}\n', '\n', '\n', '/**\n', ' * @dev This base contract is inherited by FXTPresale and FXTMainsale\n', ' * and have related contracts address and ether funded in the sale as state.\n', ' * Main purpose of this base contract is to provide the interface to control\n', ' * generating / burning token and increase / decrease ether ether funded in the sale.\n', ' * Those functions are only called in case of emergency situation such as\n', ' * erroneous action handling Bitcoin payment.\n', ' */\n', 'contract SaleBase is Sudo, Pausable, PaymentFallbackReceiver {\n', '  using SafeMath for uint256;\n', '\n', '  // related contracts\n', '  FXTI public token;\n', '  KYCI public kyc;\n', '  RefundVault public vault;\n', '\n', '  // fuzex account to hold ownership of contracts after sale finalized\n', '  address public fuzexAccount;\n', '\n', '  // common sale parameters\n', '  mapping (address => uint256) public beneficiaryFunded;\n', '  uint256 public weiRaised;\n', '\n', '  bool public isFinalized; // whether sale is finalized\n', '\n', '  /**\n', '   * @dev After sale finalized, token and other contract ownership is transferred to\n', "   * another contract or account. So this modifier doesn't effect contract logic, just\n", '   * make sure of it.\n', '   */\n', '  modifier onlyNotFinalized() {\n', '    require(!isFinalized);\n', '    _;\n', '  }\n', '\n', '  function SaleBase(\n', '    address _token,\n', '    address _kyc,\n', '    address _vault,\n', '    address _payment,\n', '    address _fuzexAccount)\n', '    Sudo(false) // sudoEnabled\n', '    PaymentFallbackReceiver(_payment)\n', '    public\n', '  {\n', '    require(_token != address(0)\n', '     && _kyc != address(0)\n', '     && _vault != address(0)\n', '     && _fuzexAccount != address(0));\n', '\n', '    token = FXTI(_token);\n', '    kyc = KYCI(_kyc);\n', '    vault = RefundVault(_vault);\n', '    fuzexAccount = _fuzexAccount;\n', '  }\n', '\n', '  /**\n', '   * @dev Below 4 functions are only called in case of emergency and certain situation.\n', '   * e.g. Wrong parameters for BTCPayment.addPayment function so that token should be burned and\n', '   * wei-raised should be modified.\n', '   */\n', '  function increaseWeiRaised(uint256 _amount) public onlyOwner onlyNotFinalized onlySudoEnabled {\n', '    weiRaised = weiRaised.add(_amount);\n', '  }\n', '\n', '  function decreaseWeiRaised(uint256 _amount) public onlyOwner onlyNotFinalized onlySudoEnabled {\n', '    weiRaised = weiRaised.sub(_amount);\n', '  }\n', '\n', '  function generateTokens(address _owner, uint _amount) public onlyOwner onlyNotFinalized onlySudoEnabled returns (bool) {\n', '    return token.generateTokens(_owner, _amount);\n', '  }\n', '\n', '  function destroyTokens(address _owner, uint _amount) public onlyOwner onlyNotFinalized onlySudoEnabled returns (bool) {\n', '    return token.destroyTokens(_owner, _amount);\n', '  }\n', '\n', '  /**\n', '   * @dev Prevent token holder from transfer.\n', '   */\n', '  function blockAddress(address _addr) public onlyOwner onlyNotFinalized onlySudoEnabled {\n', '    token.blockAddress(_addr);\n', '  }\n', '\n', '  function unblockAddress(address _addr) public onlyOwner onlyNotFinalized onlySudoEnabled {\n', '    token.unblockAddress(_addr);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer ownership of other contract whoes owner is `this` to other address.\n', '   */\n', '  function changeOwnership(address _target, address _newOwner) public onlyOwner {\n', '    Ownable(_target).transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer ownership of MiniMeToken whoes controller is `this` to other address.\n', '   */\n', '  function changeController(address _target, address _newOwner) public onlyOwner {\n', '    Controlled(_target).changeController(_newOwner);\n', '  }\n', '\n', '  function setFinalize() internal onlyOwner {\n', '    require(!isFinalized);\n', '    isFinalized = true;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title FXTPresale\n', ' * @dev Private-sale is finished before this contract is deployed.\n', ' *\n', ' */\n', 'contract FXTPresale is SaleBase {\n', '  uint256 public baseRate = 12000;    // 1 ETH = 12000 FXT\n', '  uint256 public PRE_BONUS = 25;     // presale bonus 25%\n', '  uint256 public BONUS_COEFF = 100;\n', '\n', '  // private-sale parameters\n', '  uint256 public privateEtherFunded;\n', '  uint256 public privateMaxEtherCap;\n', '\n', '  // presale parameters\n', '  uint256 public presaleMaxEtherCap;\n', '  uint256 public presaleMinPurchase;\n', '\n', '  uint256 public maxEtherCap;   // max ether cap for both private-sale & presale\n', '\n', '  uint64 public startTime;     // when presale starts\n', '  uint64 public endTime;       // when presale ends\n', '\n', '  event PresaleTokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 toFund, uint256 tokens);\n', '\n', '  /**\n', '   * @dev only presale registered address can participate presale.\n', "   * private-sale doesn't require to check address because owner deals with it.\n", '   */\n', '  modifier onlyRegistered(address _addr) {\n', '    require(kyc.isRegistered(_addr, true));\n', '    _;\n', '  }\n', '\n', '  function FXTPresale(\n', '    address _token,\n', '    address _kyc,\n', '    address _vault,\n', '    address _payment,\n', '    address _fuzexAccount,\n', '    uint64 _startTime,\n', '    uint64 _endTime,\n', '    uint256 _privateEtherFunded,\n', '    uint256 _privateMaxEtherCap,\n', '    uint256 _presaleMaxEtherCap,\n', '    uint256 _presaleMinPurchase)\n', '    SaleBase(_token, _kyc, _vault, _payment, _fuzexAccount)\n', '    public\n', '  {\n', '    require(now < _startTime && _startTime < _endTime);\n', '\n', '    require(_privateEtherFunded >= 0);\n', '    require(_privateMaxEtherCap > 0);\n', '    require(_presaleMaxEtherCap > 0);\n', '    require(_presaleMinPurchase > 0);\n', '\n', '    require(_presaleMinPurchase < _presaleMaxEtherCap);\n', '\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '\n', '    privateEtherFunded = _privateEtherFunded;\n', '    privateMaxEtherCap = _privateMaxEtherCap;\n', '\n', '    presaleMaxEtherCap = _presaleMaxEtherCap;\n', '    presaleMinPurchase = _presaleMinPurchase;\n', '\n', '    maxEtherCap = privateMaxEtherCap.add(presaleMaxEtherCap);\n', '    weiRaised = _privateEtherFunded; // ether funded during private-sale\n', '\n', '    require(weiRaised <= maxEtherCap);\n', '  }\n', '\n', '  function () external payable {\n', '    buyPresale(msg.sender);\n', '  }\n', '\n', '  /**\n', "   * @dev paymentFallBack() assumes that paid BTC doesn't exceed the max ether cap.\n", '   * BTC / ETH price (or rate) is determined using reliable outer resources.\n', '   * @param _beneficiary ethereum address who receives tokens\n', '   * @param _tokens amount of FXT to mint\n', '   */\n', '  function paymentFallBack(address _beneficiary, uint256 _tokens)\n', '    external\n', '    onlyPayment\n', '  {\n', '    // only check time and parameters\n', '    require(startTime <= now && now <= endTime);\n', '    require(_beneficiary != address(0));\n', '    require(_tokens > 0);\n', '\n', '    uint256 rate = getRate();\n', '    uint256 weiAmount = _tokens.div(rate);\n', '\n', '    require(weiAmount >= presaleMinPurchase);\n', '\n', '    // funded ether should not exceed max ether cap.\n', '    require(weiRaised.add(weiAmount) <= maxEtherCap);\n', '\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    beneficiaryFunded[_beneficiary] = beneficiaryFunded[_beneficiary].add(weiAmount);\n', '\n', '    token.generateTokens(_beneficiary, _tokens);\n', '    MintByBTC(SaleType.pre, _beneficiary, _tokens);\n', '  }\n', '\n', '  function buyPresale(address _beneficiary)\n', '    public\n', '    payable\n', '    onlyRegistered(_beneficiary)\n', '    whenNotPaused\n', '  {\n', '    // check validity\n', '    require(_beneficiary != address(0));\n', '    require(msg.value >= presaleMinPurchase);\n', '    require(validPurchase());\n', '\n', '    uint256 toFund;\n', '    uint256 tokens;\n', '\n', '    (toFund, tokens) = buy(_beneficiary);\n', '\n', '    PresaleTokenPurchase(msg.sender, _beneficiary, toFund, tokens);\n', '  }\n', '\n', '  function buy(address _beneficiary)\n', '    internal\n', '    returns (uint256 toFund, uint256 tokens)\n', '  {\n', '    // calculate eth amount\n', '    uint256 weiAmount = msg.value;\n', '    uint256 totalAmount = weiRaised.add(weiAmount);\n', '\n', '    if (totalAmount > maxEtherCap) {\n', '      toFund = maxEtherCap.sub(weiRaised);\n', '    } else {\n', '      toFund = weiAmount;\n', '    }\n', '\n', '    require(toFund > 0);\n', '    require(weiAmount >= toFund);\n', '\n', '    uint256 rate = getRate();\n', '    tokens = toFund.mul(rate);\n', '    uint256 toReturn = weiAmount.sub(toFund);\n', '\n', '    weiRaised = weiRaised.add(toFund);\n', '    beneficiaryFunded[_beneficiary] = beneficiaryFunded[_beneficiary].add(toFund);\n', '\n', '    token.generateTokens(_beneficiary, tokens);\n', '\n', '    if (toReturn > 0) {\n', '      msg.sender.transfer(toReturn);\n', '    }\n', '\n', '    forwardFunds(toFund);\n', '  }\n', '\n', '  function validPurchase() internal view returns (bool) {\n', '    bool nonZeroPurchase = msg.value != 0;\n', '    bool validTime = now >= startTime && now <= endTime;\n', '    return nonZeroPurchase && !maxReached() && validTime;\n', '  }\n', '\n', '  /**\n', '   * @dev get current rate\n', '   */\n', '  function getRate() public view returns (uint256) {\n', '    return calcRate(PRE_BONUS);\n', '  }\n', '\n', '  /**\n', '   * @dev Calculate rate wrt _bonus. if _bonus is 15, this function\n', '   * returns baseRate * 1.15.\n', '   * rate = 12000 * (25 + 100) / 100 for 25% bonus\n', '   */\n', '  function calcRate(uint256 _bonus) internal view returns (uint256) {\n', '    return _bonus.add(BONUS_COEFF).mul(baseRate).div(BONUS_COEFF);\n', '  }\n', '\n', '  /**\n', '   * @dev Checks whether max ether cap is reached for presale\n', '   * @return true if max ether cap is reaced\n', '   */\n', '  function maxReached() public view  returns (bool) {\n', '    return weiRaised == maxEtherCap;\n', '  }\n', '\n', '  function forwardFunds(uint256 _toFund) internal {\n', '    vault.deposit.value(_toFund)(msg.sender);\n', '  }\n', '\n', '  function finalizePresale(address _mainsale) public onlyOwner {\n', '      require(!isFinalized);\n', '      require(maxReached() || now > endTime);\n', '\n', '      PresaleFallbackReceiver mainsale = PresaleFallbackReceiver(_mainsale);\n', '\n', '      require(mainsale.presaleFallBack(weiRaised));\n', '      require(payment.presaleFallBack(weiRaised));\n', '\n', '      vault.close();\n', '\n', '      changeController(address(token), _mainsale);\n', '      changeOwnership(address(vault), fuzexAccount);\n', '\n', '      enableSudo(false);\n', '      setFinalize();\n', '  }\n', '}']