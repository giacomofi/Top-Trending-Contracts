['pragma solidity ^0.4.23;\n', '\n', 'contract UnionPay {\n', '    event UserPay(address from,address to,uint256 amount, uint256 amountIndeed,uint256 transId);\n', '    event BareUserPay(address from,uint256 amount,bytes data);  \n', '    \n', '    address public owner;  \n', '    address public platform;\n', '    mapping(bytes32 => uint8)  userReceipts;\n', '\n', '    constructor() public {\n', '      owner = msg.sender;\n', '      platform = msg.sender;\n', '    }\n', '  \n', '    modifier onlyOwner() {\n', '      require(msg.sender == owner);\n', '      _;\n', '    }\n', '  \n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '      if (newOwner != address(0)) {\n', '        owner = newOwner;\n', '      }\n', '    }\n', '\n', '    function safePay(uint256 _transId,uint256 _feePercentage,address _to, bytes _sig) payable public returns(bool) {\n', '        require(_feePercentage>=0 && _feePercentage<=100);\n', '        require(_to != address(0));\n', '        require(userReceipts[getReceiptId(msg.sender,_to,_transId)] == 0);\n', '        require(platform!=address(0));\n', '\n', '        bytes32 message = prefixed(keccak256(msg.sender, _to, msg.value, _feePercentage,_transId));\n', '\n', '        require(recoverSigner(message, _sig) == platform);\n', '        userReceipts[getReceiptId(msg.sender,_to,_transId)] = 1;\n', '        \n', '        if (_feePercentage == 0){\n', '            if (msg.value > 0){\n', '                _to.transfer(msg.value);\n', '            }\n', '            emit UserPay(msg.sender,_to,msg.value,msg.value,_transId);\n', '            return true;\n', '        }        \n', '        uint256 val = _feePercentage * msg.value;\n', '        assert(val/_feePercentage == msg.value);\n', '        val = val/100;\n', '        if (msg.value>val){\n', '            _to.transfer(msg.value - val);\n', '        }\n', '        emit UserPay(msg.sender,_to,msg.value,msg.value - val,_transId);\n', '        return true;\n', '    }\n', '    \n', '    function getReceiptId(address _from,address _to, uint256 _transId) internal pure returns(bytes32){\n', '        return keccak256(_from, _to,_transId);\n', '    }\n', '    \n', '    function receiptUsed(address _from,address _to,uint256 _transId) public view returns(bool){\n', '        return userReceipts[getReceiptId(_from,_to,_transId)] == 1;\n', '    }\n', '    \n', '    function plainPay() public payable returns(bool){\n', '        emit BareUserPay(msg.sender,msg.value,msg.data);\n', '        return true;\n', '    }\n', '    \n', '    function () public payable{\n', '        emit BareUserPay(msg.sender,msg.value,msg.data);\n', '    }\n', '    \n', '    function setPlatform(address _checker) public onlyOwner{\n', '        require(_checker!=address(0));\n', '        platform = _checker;\n', '    }\n', '    \n', '    function withdraw() public onlyOwner{\n', '        require(platform!=address(0));\n', '        platform.transfer(address(this).balance);\n', '    }\n', '    \n', '    function getBalance() public view returns(uint256){\n', '        return address(this).balance;\n', '    }\n', '\n', '\n', '    // Signature methods\n', '\n', '    function splitSignature(bytes sig)\n', '    internal\n', '    pure\n', '    returns(uint8, bytes32, bytes32) {\n', '        require(sig.length == 65);\n', '\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        assembly {\n', '            // first 32 bytes, after the length prefix\n', '            r: = mload(add(sig, 32))\n', '            // second 32 bytes\n', '            s: = mload(add(sig, 64))\n', '            // final byte (first byte of the next 32 bytes)\n', '            v: = byte(0, mload(add(sig, 96)))\n', '        }\n', '\n', '        return (v, r, s);\n', '    }\n', '\n', '    function recoverSigner(bytes32 message, bytes sig)\n', '    internal\n', '    pure\n', '    returns(address) {\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '\n', '        (v, r, s) = splitSignature(sig);\n', '\n', '        return ecrecover(message, v, r, s);\n', '    }\n', '\n', '    // Builds a prefixed hash to mimic the behavior of eth_sign.\n', '    function prefixed(bytes32 hash) internal pure returns(bytes32) {\n', '        return keccak256("\\x19Ethereum Signed Message:\\n32", hash);\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'contract UnionPay {\n', '    event UserPay(address from,address to,uint256 amount, uint256 amountIndeed,uint256 transId);\n', '    event BareUserPay(address from,uint256 amount,bytes data);  \n', '    \n', '    address public owner;  \n', '    address public platform;\n', '    mapping(bytes32 => uint8)  userReceipts;\n', '\n', '    constructor() public {\n', '      owner = msg.sender;\n', '      platform = msg.sender;\n', '    }\n', '  \n', '    modifier onlyOwner() {\n', '      require(msg.sender == owner);\n', '      _;\n', '    }\n', '  \n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '      if (newOwner != address(0)) {\n', '        owner = newOwner;\n', '      }\n', '    }\n', '\n', '    function safePay(uint256 _transId,uint256 _feePercentage,address _to, bytes _sig) payable public returns(bool) {\n', '        require(_feePercentage>=0 && _feePercentage<=100);\n', '        require(_to != address(0));\n', '        require(userReceipts[getReceiptId(msg.sender,_to,_transId)] == 0);\n', '        require(platform!=address(0));\n', '\n', '        bytes32 message = prefixed(keccak256(msg.sender, _to, msg.value, _feePercentage,_transId));\n', '\n', '        require(recoverSigner(message, _sig) == platform);\n', '        userReceipts[getReceiptId(msg.sender,_to,_transId)] = 1;\n', '        \n', '        if (_feePercentage == 0){\n', '            if (msg.value > 0){\n', '                _to.transfer(msg.value);\n', '            }\n', '            emit UserPay(msg.sender,_to,msg.value,msg.value,_transId);\n', '            return true;\n', '        }        \n', '        uint256 val = _feePercentage * msg.value;\n', '        assert(val/_feePercentage == msg.value);\n', '        val = val/100;\n', '        if (msg.value>val){\n', '            _to.transfer(msg.value - val);\n', '        }\n', '        emit UserPay(msg.sender,_to,msg.value,msg.value - val,_transId);\n', '        return true;\n', '    }\n', '    \n', '    function getReceiptId(address _from,address _to, uint256 _transId) internal pure returns(bytes32){\n', '        return keccak256(_from, _to,_transId);\n', '    }\n', '    \n', '    function receiptUsed(address _from,address _to,uint256 _transId) public view returns(bool){\n', '        return userReceipts[getReceiptId(_from,_to,_transId)] == 1;\n', '    }\n', '    \n', '    function plainPay() public payable returns(bool){\n', '        emit BareUserPay(msg.sender,msg.value,msg.data);\n', '        return true;\n', '    }\n', '    \n', '    function () public payable{\n', '        emit BareUserPay(msg.sender,msg.value,msg.data);\n', '    }\n', '    \n', '    function setPlatform(address _checker) public onlyOwner{\n', '        require(_checker!=address(0));\n', '        platform = _checker;\n', '    }\n', '    \n', '    function withdraw() public onlyOwner{\n', '        require(platform!=address(0));\n', '        platform.transfer(address(this).balance);\n', '    }\n', '    \n', '    function getBalance() public view returns(uint256){\n', '        return address(this).balance;\n', '    }\n', '\n', '\n', '    // Signature methods\n', '\n', '    function splitSignature(bytes sig)\n', '    internal\n', '    pure\n', '    returns(uint8, bytes32, bytes32) {\n', '        require(sig.length == 65);\n', '\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        assembly {\n', '            // first 32 bytes, after the length prefix\n', '            r: = mload(add(sig, 32))\n', '            // second 32 bytes\n', '            s: = mload(add(sig, 64))\n', '            // final byte (first byte of the next 32 bytes)\n', '            v: = byte(0, mload(add(sig, 96)))\n', '        }\n', '\n', '        return (v, r, s);\n', '    }\n', '\n', '    function recoverSigner(bytes32 message, bytes sig)\n', '    internal\n', '    pure\n', '    returns(address) {\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '\n', '        (v, r, s) = splitSignature(sig);\n', '\n', '        return ecrecover(message, v, r, s);\n', '    }\n', '\n', '    // Builds a prefixed hash to mimic the behavior of eth_sign.\n', '    function prefixed(bytes32 hash) internal pure returns(bytes32) {\n', '        return keccak256("\\x19Ethereum Signed Message:\\n32", hash);\n', '    }\n', '}']
