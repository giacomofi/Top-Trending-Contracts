['pragma solidity 0.4.21;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface Token {\n', '    function transfer(address _to, uint256 _amount) public returns (bool success);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function decimals()public view returns (uint8);\n', '    function burnAllTokens() public;\n', '}\n', '\n', '/**\n', ' * @title Vault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Funds will be transferred to owner once sale ends\n', ' */\n', 'contract Vault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    enum State { Active, Refunding, Withdraw }\n', '\n', '    mapping (address => uint256) public deposited;\n', '    address public wallet;\n', '    State public state;\n', '\n', '    event Withdraw();\n', '    event RefundsEnabled();\n', '    event Withdrawn(address _wallet);\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '      \n', '    function Vault(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '        state = State.Active;\n', '    }\n', '\n', '    function deposit(address investor) public onlyOwner  payable{\n', '        \n', '        require(state == State.Active || state == State.Withdraw);//allowing to deposit even in withdraw state since withdraw state will be started once totalFunding reaches 10,000 ether\n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '        \n', '    }\n', '\n', '    function activateWithdrawal() public onlyOwner {\n', '        if(state == State.Active){\n', '          state = State.Withdraw;\n', '          emit Withdraw();\n', '        }\n', '    }\n', '    \n', '    function activateRefund()public onlyOwner {\n', '        require(state == State.Active);\n', '        state = State.Refunding;\n', '        emit RefundsEnabled();\n', '    }\n', '    \n', '    function withdrawToWallet() onlyOwner public{\n', '    require(state == State.Withdraw);\n', '    wallet.transfer(this.balance);\n', '    emit Withdrawn(wallet);\n', '  }\n', '  \n', '   function refund(address investor) public {\n', '    require(state == State.Refunding);\n', '    uint256 depositedValue = deposited[investor];\n', '    deposited[investor] = 0;\n', '    investor.transfer(depositedValue);\n', '    emit Refunded(investor, depositedValue);\n', '  }\n', '  \n', ' function isRefunding()public onlyOwner view returns(bool) {\n', '     return (state == State.Refunding);\n', ' }\n', '}\n', '\n', '\n', 'contract DroneTokenSale is Ownable{\n', '      using SafeMath for uint256;\n', '      \n', '      //Token to be used for this sale\n', '      Token public token;\n', '      \n', '      //All funds will go into this vault\n', '      Vault public vault;\n', '  \n', '      //rate of token in ether 1eth = 20000 DRONE\n', '      uint256 public rate = 20000;\n', '      /*\n', '      *There will be 4 phases\n', '      * 1. Pre-sale\n', '      * 2. ICO Phase 1\n', '      * 3. ICO Phase 2\n', '      * 4. ICO Phase 3\n', '      */\n', '      struct PhaseInfo{\n', '          uint256 hardcap;\n', '          uint256 startTime;\n', '          uint256 endTime;\n', '          uint8 [3] bonusPercentages;//3 type of bonuses above 100eth, 10-100ether, less than 10ether\n', '          uint256 weiRaised;\n', '      }\n', '      \n', '      //info of each phase\n', '      PhaseInfo[] public phases;\n', '      \n', '      //Total funding\n', '      uint256 public totalFunding;\n', '      \n', '      //total tokesn available for sale\n', '      uint256 tokensAvailableForSale = 3000000000;\n', '      \n', '      \n', '      uint8 public noOfPhases;\n', '      \n', '      \n', '      //Keep track of whether contract is up or not\n', '      bool public contractUp;\n', '      \n', '      //Keep track of whether the sale has ended or not\n', '      bool public saleEnded;\n', '      \n', '      //Event to trigger Sale stop\n', '      event SaleStopped(address _owner, uint256 time);\n', '      \n', '      //Event to trigger normal flow of sale end\n', '      event Finalized(address _owner, uint256 time);\n', '    \n', '     /**\n', '     * event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '     event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    \n', '    //modifiers    \n', '    modifier _contractUp(){\n', '        require(contractUp);\n', '        _;\n', '    }\n', '  \n', '     modifier nonZeroAddress(address _to) {\n', '        require(_to != address(0));\n', '        _;\n', '    }\n', '    \n', '    modifier minEthContribution() {\n', '        require(msg.value >= 0.1 ether);\n', '        _;\n', '    }\n', '    \n', '    modifier _saleEnded() {\n', '        require(saleEnded);\n', '        _;\n', '    }\n', '    \n', '    modifier _saleNotEnded() {\n', '        require(!saleEnded);\n', '        _;\n', '    }\n', '  \n', '    \n', '    /**\n', '    *     @dev Check if sale contract has enough tokens on its account balance \n', '    *     to reward all possible participations within sale period\n', '    */\n', '    function powerUpContract() external onlyOwner {\n', '        // Contract should not be powered up previously\n', '        require(!contractUp);\n', '\n', '        // Contract should have enough DRONE credits\n', '        require(token.balanceOf(this) >= tokensAvailableForSale);\n', '        \n', '        \n', '      \n', '        //activate the sale process\n', '        contractUp = true;\n', '    }\n', '    \n', '    //for Emergency/Hard stop of the sale\n', '    function emergencyStop() external onlyOwner _contractUp _saleNotEnded{\n', '        saleEnded = true;    \n', '        \n', '     if(totalFunding < 10000 ether){\n', '            vault.activateRefund();\n', '        }\n', '        else{\n', '            vault.activateWithdrawal();\n', '        }\n', '        \n', '      emit SaleStopped(msg.sender, now);\n', '    }\n', '    \n', '    /**\n', '   * @dev Must be called after sale ends, to do some extra finalization\n', '   * work. Calls the contract&#39;s finalization function.\n', '   */\n', '    function finalize()public onlyOwner _contractUp _saleNotEnded{\n', '        require(saleTimeOver());\n', '        \n', '        saleEnded = true;\n', '        \n', '        if(totalFunding < 10000 ether){\n', '            vault.activateRefund();\n', '        }\n', '        else{\n', '            vault.activateWithdrawal();\n', '        }\n', '       \n', '       emit Finalized(msg.sender, now);\n', '    }\n', '    \n', '      // @return true if all the tiers has been ended\n', '  function saleTimeOver() public view returns (bool) {\n', '    \n', '    return now > phases[noOfPhases-1].endTime;\n', '  }\n', '  \n', '    //if crowdsales is over, the money rasied should be transferred to the wallet address\n', '  function withdrawFunds() public onlyOwner{\n', '  \n', '      vault.withdrawToWallet();\n', '  }\n', '  \n', '  //method to refund money\n', '  function getRefund()public {\n', '      \n', '      vault.refund(msg.sender);\n', '  }\n', '  \n', '  /**\n', '  * @dev Can be called only once. The method to allow owner to set tier information\n', '  * @param _noOfPhases The integer to set number of tiers\n', '  * @param _startTimes The array containing start time of each tier\n', '  * @param _endTimes The array containing end time of each tier\n', '  * @param _hardCaps The array containing hard cap for each tier\n', '  * @param _bonusPercentages The array containing bonus percentage for each tier\n', '  * The arrays should be in sync with each other. For each index 0 for each of the array should contain info about Tier 1, similarly for Tier2, 3 and 4 .\n', '  * Sales hard cap will be the hard cap of last tier\n', '  */\n', '  function setTiersInfo(uint8 _noOfPhases, uint256[] _startTimes, uint256[] _endTimes, uint256[] _hardCaps, uint8[3][4] _bonusPercentages)private {\n', '    \n', '    \n', '    require(_noOfPhases==4);\n', '    \n', '    //Each array should contain info about each tier\n', '    require(_startTimes.length == _noOfPhases);\n', '    require(_endTimes.length==_noOfPhases);\n', '    require(_hardCaps.length==_noOfPhases);\n', '    require(_bonusPercentages.length==_noOfPhases);\n', '    \n', '    noOfPhases = _noOfPhases;\n', '    \n', '    for(uint8 i=0;i<_noOfPhases;i++){\n', '        require(_hardCaps[i]>0);\n', '        require(_endTimes[i]>_startTimes[i]);\n', '        if(i>0){\n', '            \n', '        \n', '            \n', '            //start time of this tier should be greater than previous tier\n', '            require(_startTimes[i] > _endTimes[i-1]);\n', '            \n', '            phases.push(PhaseInfo({\n', '                hardcap:_hardCaps[i],\n', '                startTime:_startTimes[i],\n', '                endTime:_endTimes[i],\n', '                bonusPercentages:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '        else{\n', '            //start time of tier1 should be greater than current time\n', '            require(_startTimes[i]>now);\n', '          \n', '            phases.push(PhaseInfo({\n', '                hardcap:_hardCaps[i],\n', '                startTime:_startTimes[i],\n', '                endTime:_endTimes[i],\n', '                bonusPercentages:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '    }\n', '  }\n', '  \n', '  \n', '    /**\n', '    * @dev Constructor method\n', '    * @param _tokenToBeUsed Address of the token to be used for Sales\n', '    * @param _wallet Address of the wallet which will receive the collected funds\n', '    */  \n', '    function DroneTokenSale(address _tokenToBeUsed, address _wallet)public nonZeroAddress(_tokenToBeUsed) nonZeroAddress(_wallet){\n', '        \n', '        token = Token(_tokenToBeUsed);\n', '        vault = new Vault(_wallet);\n', '        \n', '        uint256[] memory startTimes = new uint256[](4);\n', '        uint256[] memory endTimes = new uint256[](4);\n', '        uint256[] memory hardCaps = new uint256[](4);\n', '        uint8[3] [4] memory bonusPercentages;\n', '        \n', '        //pre-sales\n', '        startTimes[0] = 1522321200; //MARCH 29, 2018 11:00 AM GMT\n', '        endTimes[0] = 1523790000; //APRIL 15, 2018 11:00 AM GMT\n', '        hardCaps[0] = 10000 ether;\n', '        bonusPercentages[0][0] = 35;\n', '        bonusPercentages[0][1] = 30;\n', '        bonusPercentages[0][2] = 25;\n', '        \n', '        //phase-1\n', '        startTimes[1] = 1525172460; //MAY 01, 2018 11:01 AM GMT \n', '        endTimes[1] = 1526382000; //MAY 15, 2018 11:00 AM GMT\n', '        hardCaps[1] = 20000 ether;\n', '        bonusPercentages[1][0] = 25;// above 100 ether\n', '        bonusPercentages[1][1] = 20;// 10<=x<=100\n', '        bonusPercentages[1][2] = 15;// less than 10 ether\n', '        \n', '        \n', '        //phase-2\n', '        startTimes[2] = 1526382060; //MAY 15, 2018 11:01 AM GMT\n', '        endTimes[2] = 1527850800; //JUNE 01, 2018 11:00 AM GMT\n', '        hardCaps[2] = 30000 ether;\n', '        bonusPercentages[2][0] = 15;\n', '        bonusPercentages[2][1] = 10;\n', '        bonusPercentages[2][2] = 5;\n', '        \n', '        //phase-3\n', '        startTimes[3] = 1527850860; //JUNE 01, 2018 11:01 AM GMT\n', '        endTimes[3] = 1533034800; //JULY 31, 2018 11:OO AM GMT\n', '        hardCaps[3] = 75000 ether;\n', '        bonusPercentages[3][0] = 0;\n', '        bonusPercentages[3][1] = 0;\n', '        bonusPercentages[3][2] = 0;\n', '\n', '        setTiersInfo(4, startTimes, endTimes, hardCaps, bonusPercentages);\n', '        \n', '    }\n', '    \n', '\n', '   //Fallback function used to buytokens\n', '   function()public payable{\n', '       buyTokens(msg.sender);\n', '   }\n', '   \n', '   /**\n', '   * @dev Low level token purchase function\n', '   * @param beneficiary The address who will receive the tokens for this transaction\n', '   */\n', '   function buyTokens(address beneficiary)public _contractUp _saleNotEnded minEthContribution nonZeroAddress(beneficiary) payable returns(bool){\n', '       \n', '       int8 currentPhaseIndex = getCurrentlyRunningPhase();\n', '       assert(currentPhaseIndex>=0);\n', '       \n', '        // recheck this for storage and memory\n', '       PhaseInfo storage currentlyRunningPhase = phases[uint256(currentPhaseIndex)];\n', '       \n', '       \n', '       uint256 weiAmount = msg.value;\n', '\n', '       //Check hard cap for this phase has not been reached\n', '       require(weiAmount.add(currentlyRunningPhase.weiRaised) <= currentlyRunningPhase.hardcap);\n', '       \n', '       \n', '       uint256 tokens = weiAmount.mul(rate).div(1000000000000000000);//considering decimal places to be zero for token\n', '       \n', '       uint256 bonusedTokens = applyBonus(tokens, currentlyRunningPhase.bonusPercentages, weiAmount);\n', '       \n', '      \n', '       \n', '      \n', '       totalFunding = totalFunding.add(weiAmount);\n', '       \n', '       currentlyRunningPhase.weiRaised = currentlyRunningPhase.weiRaised.add(weiAmount);\n', '       \n', '       vault.deposit.value(msg.value)(msg.sender);\n', '       \n', '       token.transfer(beneficiary, bonusedTokens);\n', '       \n', '       emit TokenPurchase(msg.sender, beneficiary, weiAmount, bonusedTokens);\n', '\n', '       return true;\n', '       \n', '   }\n', '   \n', '    /**\n', '    *@dev Method to calculate bonus for the user as per currently running phase and contribution by the user\n', '    * @param tokens Total tokens purchased by the user\n', '    * @param percentages Array of bonus percentages for the phase as per ethers sent\n', '    * @param weiSent Amount of ethers(in form of wei) sent by the user\n', '    */\n', '     function applyBonus(uint256 tokens, uint8 [3]percentages, uint256 weiSent) private pure returns  (uint256) {\n', '         \n', '         uint256 tokensToAdd = 0;\n', '         \n', '         if(weiSent<10 ether){\n', '             tokensToAdd = tokens.mul(percentages[2]).div(100);\n', '         }\n', '         else if(weiSent>=10 ether && weiSent<=100 ether){\n', '              tokensToAdd = tokens.mul(percentages[1]).div(100);\n', '         }\n', '         \n', '         else{\n', '              tokensToAdd = tokens.mul(percentages[0]).div(100);\n', '         }\n', '        \n', '        return tokens.add(tokensToAdd);\n', '    }\n', '    \n', '   /**\n', '    * @dev returns the currently running tier index as per time\n', '    * Return -1 if no tier is running currently\n', '    * */\n', '   function getCurrentlyRunningPhase()public view returns(int8){\n', '      for(uint8 i=0;i<noOfPhases;i++){\n', '          if(now>=phases[i].startTime && now<=phases[i].endTime){\n', '              return int8(i);\n', '          }\n', '      }   \n', '      return -1;\n', '   }\n', '   \n', '   \n', '   \n', '   /**\n', '   * @dev Get functing info of user/address. It will return how much funding the user has made in terms of wei\n', '   */\n', '   function getFundingInfoForUser(address _user)public view nonZeroAddress(_user) returns(uint256){\n', '       return vault.deposited(_user);\n', '   }\n', '   \n', '   /**\n', '   *@dev Method to check whether refund process has been initiated or not by the contract.\n', '   */\n', '   function isRefunding()public view returns(bool) {\n', '       return vault.isRefunding();\n', '   }\n', '   \n', '   /**\n', '   *@dev Method to burn all remanining tokens left with the sales contract after the sale has ended\n', '   */\n', '   function burnRemainingTokens()public onlyOwner _contractUp _saleEnded {\n', '       \n', '       token.burnAllTokens();\n', '   }\n', '   \n', '   /**\n', '   * @dev Method to activate withdrawal of funds even in between of sale. The WIthdrawal will only be activate iff totalFunding has reached 10,000 ether\n', '   */\n', '   function activateWithdrawal()public onlyOwner _saleNotEnded _contractUp {\n', '       \n', '       require(totalFunding >= 10000 ether);\n', '       vault.activateWithdrawal();\n', '       \n', '   }\n', '      \n', '}']
['pragma solidity 0.4.21;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface Token {\n', '    function transfer(address _to, uint256 _amount) public returns (bool success);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function decimals()public view returns (uint8);\n', '    function burnAllTokens() public;\n', '}\n', '\n', '/**\n', ' * @title Vault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Funds will be transferred to owner once sale ends\n', ' */\n', 'contract Vault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    enum State { Active, Refunding, Withdraw }\n', '\n', '    mapping (address => uint256) public deposited;\n', '    address public wallet;\n', '    State public state;\n', '\n', '    event Withdraw();\n', '    event RefundsEnabled();\n', '    event Withdrawn(address _wallet);\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '      \n', '    function Vault(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '        state = State.Active;\n', '    }\n', '\n', '    function deposit(address investor) public onlyOwner  payable{\n', '        \n', '        require(state == State.Active || state == State.Withdraw);//allowing to deposit even in withdraw state since withdraw state will be started once totalFunding reaches 10,000 ether\n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '        \n', '    }\n', '\n', '    function activateWithdrawal() public onlyOwner {\n', '        if(state == State.Active){\n', '          state = State.Withdraw;\n', '          emit Withdraw();\n', '        }\n', '    }\n', '    \n', '    function activateRefund()public onlyOwner {\n', '        require(state == State.Active);\n', '        state = State.Refunding;\n', '        emit RefundsEnabled();\n', '    }\n', '    \n', '    function withdrawToWallet() onlyOwner public{\n', '    require(state == State.Withdraw);\n', '    wallet.transfer(this.balance);\n', '    emit Withdrawn(wallet);\n', '  }\n', '  \n', '   function refund(address investor) public {\n', '    require(state == State.Refunding);\n', '    uint256 depositedValue = deposited[investor];\n', '    deposited[investor] = 0;\n', '    investor.transfer(depositedValue);\n', '    emit Refunded(investor, depositedValue);\n', '  }\n', '  \n', ' function isRefunding()public onlyOwner view returns(bool) {\n', '     return (state == State.Refunding);\n', ' }\n', '}\n', '\n', '\n', 'contract DroneTokenSale is Ownable{\n', '      using SafeMath for uint256;\n', '      \n', '      //Token to be used for this sale\n', '      Token public token;\n', '      \n', '      //All funds will go into this vault\n', '      Vault public vault;\n', '  \n', '      //rate of token in ether 1eth = 20000 DRONE\n', '      uint256 public rate = 20000;\n', '      /*\n', '      *There will be 4 phases\n', '      * 1. Pre-sale\n', '      * 2. ICO Phase 1\n', '      * 3. ICO Phase 2\n', '      * 4. ICO Phase 3\n', '      */\n', '      struct PhaseInfo{\n', '          uint256 hardcap;\n', '          uint256 startTime;\n', '          uint256 endTime;\n', '          uint8 [3] bonusPercentages;//3 type of bonuses above 100eth, 10-100ether, less than 10ether\n', '          uint256 weiRaised;\n', '      }\n', '      \n', '      //info of each phase\n', '      PhaseInfo[] public phases;\n', '      \n', '      //Total funding\n', '      uint256 public totalFunding;\n', '      \n', '      //total tokesn available for sale\n', '      uint256 tokensAvailableForSale = 3000000000;\n', '      \n', '      \n', '      uint8 public noOfPhases;\n', '      \n', '      \n', '      //Keep track of whether contract is up or not\n', '      bool public contractUp;\n', '      \n', '      //Keep track of whether the sale has ended or not\n', '      bool public saleEnded;\n', '      \n', '      //Event to trigger Sale stop\n', '      event SaleStopped(address _owner, uint256 time);\n', '      \n', '      //Event to trigger normal flow of sale end\n', '      event Finalized(address _owner, uint256 time);\n', '    \n', '     /**\n', '     * event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '     event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    \n', '    //modifiers    \n', '    modifier _contractUp(){\n', '        require(contractUp);\n', '        _;\n', '    }\n', '  \n', '     modifier nonZeroAddress(address _to) {\n', '        require(_to != address(0));\n', '        _;\n', '    }\n', '    \n', '    modifier minEthContribution() {\n', '        require(msg.value >= 0.1 ether);\n', '        _;\n', '    }\n', '    \n', '    modifier _saleEnded() {\n', '        require(saleEnded);\n', '        _;\n', '    }\n', '    \n', '    modifier _saleNotEnded() {\n', '        require(!saleEnded);\n', '        _;\n', '    }\n', '  \n', '    \n', '    /**\n', '    *     @dev Check if sale contract has enough tokens on its account balance \n', '    *     to reward all possible participations within sale period\n', '    */\n', '    function powerUpContract() external onlyOwner {\n', '        // Contract should not be powered up previously\n', '        require(!contractUp);\n', '\n', '        // Contract should have enough DRONE credits\n', '        require(token.balanceOf(this) >= tokensAvailableForSale);\n', '        \n', '        \n', '      \n', '        //activate the sale process\n', '        contractUp = true;\n', '    }\n', '    \n', '    //for Emergency/Hard stop of the sale\n', '    function emergencyStop() external onlyOwner _contractUp _saleNotEnded{\n', '        saleEnded = true;    \n', '        \n', '     if(totalFunding < 10000 ether){\n', '            vault.activateRefund();\n', '        }\n', '        else{\n', '            vault.activateWithdrawal();\n', '        }\n', '        \n', '      emit SaleStopped(msg.sender, now);\n', '    }\n', '    \n', '    /**\n', '   * @dev Must be called after sale ends, to do some extra finalization\n', "   * work. Calls the contract's finalization function.\n", '   */\n', '    function finalize()public onlyOwner _contractUp _saleNotEnded{\n', '        require(saleTimeOver());\n', '        \n', '        saleEnded = true;\n', '        \n', '        if(totalFunding < 10000 ether){\n', '            vault.activateRefund();\n', '        }\n', '        else{\n', '            vault.activateWithdrawal();\n', '        }\n', '       \n', '       emit Finalized(msg.sender, now);\n', '    }\n', '    \n', '      // @return true if all the tiers has been ended\n', '  function saleTimeOver() public view returns (bool) {\n', '    \n', '    return now > phases[noOfPhases-1].endTime;\n', '  }\n', '  \n', '    //if crowdsales is over, the money rasied should be transferred to the wallet address\n', '  function withdrawFunds() public onlyOwner{\n', '  \n', '      vault.withdrawToWallet();\n', '  }\n', '  \n', '  //method to refund money\n', '  function getRefund()public {\n', '      \n', '      vault.refund(msg.sender);\n', '  }\n', '  \n', '  /**\n', '  * @dev Can be called only once. The method to allow owner to set tier information\n', '  * @param _noOfPhases The integer to set number of tiers\n', '  * @param _startTimes The array containing start time of each tier\n', '  * @param _endTimes The array containing end time of each tier\n', '  * @param _hardCaps The array containing hard cap for each tier\n', '  * @param _bonusPercentages The array containing bonus percentage for each tier\n', '  * The arrays should be in sync with each other. For each index 0 for each of the array should contain info about Tier 1, similarly for Tier2, 3 and 4 .\n', '  * Sales hard cap will be the hard cap of last tier\n', '  */\n', '  function setTiersInfo(uint8 _noOfPhases, uint256[] _startTimes, uint256[] _endTimes, uint256[] _hardCaps, uint8[3][4] _bonusPercentages)private {\n', '    \n', '    \n', '    require(_noOfPhases==4);\n', '    \n', '    //Each array should contain info about each tier\n', '    require(_startTimes.length == _noOfPhases);\n', '    require(_endTimes.length==_noOfPhases);\n', '    require(_hardCaps.length==_noOfPhases);\n', '    require(_bonusPercentages.length==_noOfPhases);\n', '    \n', '    noOfPhases = _noOfPhases;\n', '    \n', '    for(uint8 i=0;i<_noOfPhases;i++){\n', '        require(_hardCaps[i]>0);\n', '        require(_endTimes[i]>_startTimes[i]);\n', '        if(i>0){\n', '            \n', '        \n', '            \n', '            //start time of this tier should be greater than previous tier\n', '            require(_startTimes[i] > _endTimes[i-1]);\n', '            \n', '            phases.push(PhaseInfo({\n', '                hardcap:_hardCaps[i],\n', '                startTime:_startTimes[i],\n', '                endTime:_endTimes[i],\n', '                bonusPercentages:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '        else{\n', '            //start time of tier1 should be greater than current time\n', '            require(_startTimes[i]>now);\n', '          \n', '            phases.push(PhaseInfo({\n', '                hardcap:_hardCaps[i],\n', '                startTime:_startTimes[i],\n', '                endTime:_endTimes[i],\n', '                bonusPercentages:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '    }\n', '  }\n', '  \n', '  \n', '    /**\n', '    * @dev Constructor method\n', '    * @param _tokenToBeUsed Address of the token to be used for Sales\n', '    * @param _wallet Address of the wallet which will receive the collected funds\n', '    */  \n', '    function DroneTokenSale(address _tokenToBeUsed, address _wallet)public nonZeroAddress(_tokenToBeUsed) nonZeroAddress(_wallet){\n', '        \n', '        token = Token(_tokenToBeUsed);\n', '        vault = new Vault(_wallet);\n', '        \n', '        uint256[] memory startTimes = new uint256[](4);\n', '        uint256[] memory endTimes = new uint256[](4);\n', '        uint256[] memory hardCaps = new uint256[](4);\n', '        uint8[3] [4] memory bonusPercentages;\n', '        \n', '        //pre-sales\n', '        startTimes[0] = 1522321200; //MARCH 29, 2018 11:00 AM GMT\n', '        endTimes[0] = 1523790000; //APRIL 15, 2018 11:00 AM GMT\n', '        hardCaps[0] = 10000 ether;\n', '        bonusPercentages[0][0] = 35;\n', '        bonusPercentages[0][1] = 30;\n', '        bonusPercentages[0][2] = 25;\n', '        \n', '        //phase-1\n', '        startTimes[1] = 1525172460; //MAY 01, 2018 11:01 AM GMT \n', '        endTimes[1] = 1526382000; //MAY 15, 2018 11:00 AM GMT\n', '        hardCaps[1] = 20000 ether;\n', '        bonusPercentages[1][0] = 25;// above 100 ether\n', '        bonusPercentages[1][1] = 20;// 10<=x<=100\n', '        bonusPercentages[1][2] = 15;// less than 10 ether\n', '        \n', '        \n', '        //phase-2\n', '        startTimes[2] = 1526382060; //MAY 15, 2018 11:01 AM GMT\n', '        endTimes[2] = 1527850800; //JUNE 01, 2018 11:00 AM GMT\n', '        hardCaps[2] = 30000 ether;\n', '        bonusPercentages[2][0] = 15;\n', '        bonusPercentages[2][1] = 10;\n', '        bonusPercentages[2][2] = 5;\n', '        \n', '        //phase-3\n', '        startTimes[3] = 1527850860; //JUNE 01, 2018 11:01 AM GMT\n', '        endTimes[3] = 1533034800; //JULY 31, 2018 11:OO AM GMT\n', '        hardCaps[3] = 75000 ether;\n', '        bonusPercentages[3][0] = 0;\n', '        bonusPercentages[3][1] = 0;\n', '        bonusPercentages[3][2] = 0;\n', '\n', '        setTiersInfo(4, startTimes, endTimes, hardCaps, bonusPercentages);\n', '        \n', '    }\n', '    \n', '\n', '   //Fallback function used to buytokens\n', '   function()public payable{\n', '       buyTokens(msg.sender);\n', '   }\n', '   \n', '   /**\n', '   * @dev Low level token purchase function\n', '   * @param beneficiary The address who will receive the tokens for this transaction\n', '   */\n', '   function buyTokens(address beneficiary)public _contractUp _saleNotEnded minEthContribution nonZeroAddress(beneficiary) payable returns(bool){\n', '       \n', '       int8 currentPhaseIndex = getCurrentlyRunningPhase();\n', '       assert(currentPhaseIndex>=0);\n', '       \n', '        // recheck this for storage and memory\n', '       PhaseInfo storage currentlyRunningPhase = phases[uint256(currentPhaseIndex)];\n', '       \n', '       \n', '       uint256 weiAmount = msg.value;\n', '\n', '       //Check hard cap for this phase has not been reached\n', '       require(weiAmount.add(currentlyRunningPhase.weiRaised) <= currentlyRunningPhase.hardcap);\n', '       \n', '       \n', '       uint256 tokens = weiAmount.mul(rate).div(1000000000000000000);//considering decimal places to be zero for token\n', '       \n', '       uint256 bonusedTokens = applyBonus(tokens, currentlyRunningPhase.bonusPercentages, weiAmount);\n', '       \n', '      \n', '       \n', '      \n', '       totalFunding = totalFunding.add(weiAmount);\n', '       \n', '       currentlyRunningPhase.weiRaised = currentlyRunningPhase.weiRaised.add(weiAmount);\n', '       \n', '       vault.deposit.value(msg.value)(msg.sender);\n', '       \n', '       token.transfer(beneficiary, bonusedTokens);\n', '       \n', '       emit TokenPurchase(msg.sender, beneficiary, weiAmount, bonusedTokens);\n', '\n', '       return true;\n', '       \n', '   }\n', '   \n', '    /**\n', '    *@dev Method to calculate bonus for the user as per currently running phase and contribution by the user\n', '    * @param tokens Total tokens purchased by the user\n', '    * @param percentages Array of bonus percentages for the phase as per ethers sent\n', '    * @param weiSent Amount of ethers(in form of wei) sent by the user\n', '    */\n', '     function applyBonus(uint256 tokens, uint8 [3]percentages, uint256 weiSent) private pure returns  (uint256) {\n', '         \n', '         uint256 tokensToAdd = 0;\n', '         \n', '         if(weiSent<10 ether){\n', '             tokensToAdd = tokens.mul(percentages[2]).div(100);\n', '         }\n', '         else if(weiSent>=10 ether && weiSent<=100 ether){\n', '              tokensToAdd = tokens.mul(percentages[1]).div(100);\n', '         }\n', '         \n', '         else{\n', '              tokensToAdd = tokens.mul(percentages[0]).div(100);\n', '         }\n', '        \n', '        return tokens.add(tokensToAdd);\n', '    }\n', '    \n', '   /**\n', '    * @dev returns the currently running tier index as per time\n', '    * Return -1 if no tier is running currently\n', '    * */\n', '   function getCurrentlyRunningPhase()public view returns(int8){\n', '      for(uint8 i=0;i<noOfPhases;i++){\n', '          if(now>=phases[i].startTime && now<=phases[i].endTime){\n', '              return int8(i);\n', '          }\n', '      }   \n', '      return -1;\n', '   }\n', '   \n', '   \n', '   \n', '   /**\n', '   * @dev Get functing info of user/address. It will return how much funding the user has made in terms of wei\n', '   */\n', '   function getFundingInfoForUser(address _user)public view nonZeroAddress(_user) returns(uint256){\n', '       return vault.deposited(_user);\n', '   }\n', '   \n', '   /**\n', '   *@dev Method to check whether refund process has been initiated or not by the contract.\n', '   */\n', '   function isRefunding()public view returns(bool) {\n', '       return vault.isRefunding();\n', '   }\n', '   \n', '   /**\n', '   *@dev Method to burn all remanining tokens left with the sales contract after the sale has ended\n', '   */\n', '   function burnRemainingTokens()public onlyOwner _contractUp _saleEnded {\n', '       \n', '       token.burnAllTokens();\n', '   }\n', '   \n', '   /**\n', '   * @dev Method to activate withdrawal of funds even in between of sale. The WIthdrawal will only be activate iff totalFunding has reached 10,000 ether\n', '   */\n', '   function activateWithdrawal()public onlyOwner _saleNotEnded _contractUp {\n', '       \n', '       require(totalFunding >= 10000 ether);\n', '       vault.activateWithdrawal();\n', '       \n', '   }\n', '      \n', '}']
