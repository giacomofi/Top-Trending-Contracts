['pragma solidity ^0.4.23;\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20Interface - Standard ERC20 Interface Definition\n', '// Enuma Blockchain Platform\n', '//\n', '// Copyright (c) 2017 Enuma Technologies Limited.\n', '// https://www.enuma.io/\n', '// ----------------------------------------------------------------------------\n', '\n', '// ----------------------------------------------------------------------------\n', '// Based on the final ERC20 specification at:\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '\n', '   event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '   event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '   function name() public view returns (string);\n', '   function symbol() public view returns (string);\n', '   function decimals() public view returns (uint8);\n', '   function totalSupply() public view returns (uint256);\n', '\n', '   function balanceOf(address _owner) public view returns (uint256 balance);\n', '   function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '   function transfer(address _to, uint256 _value) public returns (bool success);\n', '   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '   function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Math - General Math Utility Library\n', '// Enuma Blockchain Platform\n', '//\n', '// Copyright (c) 2017 Enuma Technologies Limited.\n', '// https://www.enuma.io/\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', 'library Math {\n', '\n', '   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 r = a + b;\n', '\n', '      require(r >= a);\n', '\n', '      return r;\n', '   }\n', '\n', '\n', '   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      require(a >= b);\n', '\n', '      return a - b;\n', '   }\n', '\n', '\n', '   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a == 0) {\n', '         return 0;\n', '      }\n', '\n', '      uint256 r = a * b;\n', '\n', '      require(r / a == b);\n', '\n', '      return r;\n', '   }\n', '\n', '\n', '   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      return a / b;\n', '   }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned - Ownership model with 2 phase transfers\n', '// Enuma Blockchain Platform\n', '//\n', '// Copyright (c) 2017 Enuma Technologies Limited.\n', '// https://www.enuma.io/\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// Implements a simple ownership model with 2-phase transfer.\n', 'contract Owned {\n', '\n', '   address public owner;\n', '   address public proposedOwner;\n', '\n', '   event OwnershipTransferInitiated(address indexed _proposedOwner);\n', '   event OwnershipTransferCompleted(address indexed _newOwner);\n', '\n', '\n', '   constructor() public\n', '   {\n', '      owner = msg.sender;\n', '   }\n', '\n', '\n', '   modifier onlyOwner() {\n', '      require(isOwner(msg.sender) == true);\n', '      _;\n', '   }\n', '\n', '\n', '   function isOwner(address _address) public view returns (bool) {\n', '      return (_address == owner);\n', '   }\n', '\n', '\n', '   function initiateOwnershipTransfer(address _proposedOwner) public onlyOwner returns (bool) {\n', '      require(_proposedOwner != address(0));\n', '      require(_proposedOwner != address(this));\n', '      require(_proposedOwner != owner);\n', '\n', '      proposedOwner = _proposedOwner;\n', '\n', '      emit OwnershipTransferInitiated(proposedOwner);\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '   function completeOwnershipTransfer() public returns (bool) {\n', '      require(msg.sender == proposedOwner);\n', '\n', '      owner = msg.sender;\n', '      proposedOwner = address(0);\n', '\n', '      emit OwnershipTransferCompleted(owner);\n', '\n', '      return true;\n', '   }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Finalizable - Basic implementation of the finalization pattern\n', '// Enuma Blockchain Platform\n', '//\n', '// Copyright (c) 2017 Enuma Technologies Limited.\n', '// https://www.enuma.io/\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', 'contract Finalizable is Owned() {\n', '\n', '   bool public finalized;\n', '\n', '   event Finalized();\n', '\n', '\n', '   constructor() public\n', '   {\n', '      finalized = false;\n', '   }\n', '\n', '\n', '   function finalize() public onlyOwner returns (bool) {\n', '      require(!finalized);\n', '\n', '      finalized = true;\n', '\n', '      emit Finalized();\n', '\n', '      return true;\n', '   }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// OpsManaged - Implements an Owner and Ops Permission Model\n', '// Enuma Blockchain Platform\n', '//\n', '// Copyright (c) 2017 Enuma Technologies Limited.\n', '// https://www.enuma.io/\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '\n', '//\n', '// Implements a security model with owner and ops.\n', '//\n', 'contract OpsManaged is Owned() {\n', '\n', '   address public opsAddress;\n', '\n', '   event OpsAddressUpdated(address indexed _newAddress);\n', '\n', '\n', '   constructor() public\n', '   {\n', '   }\n', '\n', '\n', '   modifier onlyOwnerOrOps() {\n', '      require(isOwnerOrOps(msg.sender));\n', '      _;\n', '   }\n', '\n', '\n', '   function isOps(address _address) public view returns (bool) {\n', '      return (opsAddress != address(0) && _address == opsAddress);\n', '   }\n', '\n', '\n', '   function isOwnerOrOps(address _address) public view returns (bool) {\n', '      return (isOwner(_address) || isOps(_address));\n', '   }\n', '\n', '\n', '   function setOpsAddress(address _newOpsAddress) public onlyOwner returns (bool) {\n', '      require(_newOpsAddress != owner);\n', '      require(_newOpsAddress != address(this));\n', '\n', '      opsAddress = _newOpsAddress;\n', '\n', '      emit OpsAddressUpdated(opsAddress);\n', '\n', '      return true;\n', '   }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20Token - Standard ERC20 Implementation\n', '// Enuma Blockchain Platform\n', '//\n', '// Copyright (c) 2017 Enuma Technologies Limited.\n', '// https://www.enuma.io/\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', 'contract ERC20Token is ERC20Interface {\n', '\n', '   using Math for uint256;\n', '\n', '   string  private tokenName;\n', '   string  private tokenSymbol;\n', '   uint8   private tokenDecimals;\n', '   uint256 internal tokenTotalSupply;\n', '\n', '   mapping(address => uint256) internal balances;\n', '   mapping(address => mapping (address => uint256)) allowed;\n', '\n', '\n', '   constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply, address _initialTokenHolder) public {\n', '      tokenName = _name;\n', '      tokenSymbol = _symbol;\n', '      tokenDecimals = _decimals;\n', '      tokenTotalSupply = _totalSupply;\n', '\n', '      // The initial balance of tokens is assigned to the given token holder address.\n', '      balances[_initialTokenHolder] = _totalSupply;\n', '\n', '      // Per EIP20, the constructor should fire a Transfer event if tokens are assigned to an account.\n', '      emit Transfer(0x0, _initialTokenHolder, _totalSupply);\n', '   }\n', '\n', '\n', '   function name() public view returns (string) {\n', '      return tokenName;\n', '   }\n', '\n', '\n', '   function symbol() public view returns (string) {\n', '      return tokenSymbol;\n', '   }\n', '\n', '\n', '   function decimals() public view returns (uint8) {\n', '      return tokenDecimals;\n', '   }\n', '\n', '\n', '   function totalSupply() public view returns (uint256) {\n', '      return tokenTotalSupply;\n', '   }\n', '\n', '\n', '   function balanceOf(address _owner) public view returns (uint256 balance) {\n', '      return balances[_owner];\n', '   }\n', '\n', '\n', '   function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '   }\n', '\n', '\n', '   function transfer(address _to, uint256 _value) public returns (bool success) {\n', '      balances[msg.sender] = balances[msg.sender].sub(_value);\n', '      balances[_to] = balances[_to].add(_value);\n', '\n', '      emit Transfer(msg.sender, _to, _value);\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '      balances[_from] = balances[_from].sub(_value);\n', '      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '      balances[_to] = balances[_to].add(_value);\n', '\n', '      emit Transfer(_from, _to, _value);\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '   function approve(address _spender, uint256 _value) public returns (bool success) {\n', '      allowed[msg.sender][_spender] = _value;\n', '\n', '      emit Approval(msg.sender, _spender, _value);\n', '\n', '      return true;\n', '   }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// FinalizableToken - Extension to ERC20Token with ops and finalization\n', '// Enuma Blockchain Platform\n', '//\n', '// Copyright (c) 2017 Enuma Technologies Limited.\n', '// https://www.enuma.io/\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '//\n', '// ERC20 token with the following additions:\n', '//    1. Owner/Ops Ownership\n', '//    2. Finalization\n', '//\n', 'contract FinalizableToken is ERC20Token, OpsManaged, Finalizable {\n', '\n', '   using Math for uint256;\n', '\n', '\n', '   // The constructor will assign the initial token supply to the owner (msg.sender).\n', '   constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public\n', '      ERC20Token(_name, _symbol, _decimals, _totalSupply, msg.sender)\n', '      OpsManaged()\n', '      Finalizable()\n', '   {\n', '   }\n', '\n', '\n', '   function transfer(address _to, uint256 _value) public returns (bool success) {\n', '      validateTransfer(msg.sender, _to);\n', '\n', '      return super.transfer(_to, _value);\n', '   }\n', '\n', '\n', '   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '      validateTransfer(msg.sender, _to);\n', '\n', '      return super.transferFrom(_from, _to, _value);\n', '   }\n', '\n', '\n', '   function validateTransfer(address _sender, address _to) private view {\n', '      // Once the token is finalized, everybody can transfer tokens.\n', '      if (finalized) {\n', '         return;\n', '      }\n', '\n', '      if (isOwner(_to)) {\n', '         return;\n', '      }\n', '\n', '      // Before the token is finalized, only owner and ops are allowed to initiate transfers.\n', '      // This allows them to move tokens while the sale is still ongoing for example.\n', '      require(isOwnerOrOps(_sender));\n', '   }\n', '}\n', '\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// FlexibleTokenSale - Token Sale Contract\n', '// Enuma Blockchain Platform\n', '//\n', '// Copyright (c) 2017 Enuma Technologies Limited.\n', '// https://www.enuma.io/\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', 'contract FlexibleTokenSale is Finalizable, OpsManaged {\n', '\n', '   using Math for uint256;\n', '\n', '   //\n', '   // Lifecycle\n', '   //\n', '   uint256 public startTime;\n', '   uint256 public endTime;\n', '   bool public suspended;\n', '\n', '   //\n', '   // Pricing\n', '   //\n', '   uint256 public tokensPerKEther;\n', '   uint256 public bonus;\n', '   uint256 public maxTokensPerAccount;\n', '   uint256 public contributionMin;\n', '   uint256 public tokenConversionFactor;\n', '\n', '   //\n', '   // Wallets\n', '   //\n', '   address public walletAddress;\n', '\n', '   //\n', '   // Token\n', '   //\n', '   FinalizableToken public token;\n', '\n', '   //\n', '   // Counters\n', '   //\n', '   uint256 public totalTokensSold;\n', '   uint256 public totalEtherCollected;\n', '\n', '\n', '   //\n', '   // Events\n', '   //\n', '   event Initialized();\n', '   event TokensPerKEtherUpdated(uint256 _newValue);\n', '   event MaxTokensPerAccountUpdated(uint256 _newMax);\n', '   event BonusUpdated(uint256 _newValue);\n', '   event SaleWindowUpdated(uint256 _startTime, uint256 _endTime);\n', '   event WalletAddressUpdated(address _newAddress);\n', '   event SaleSuspended();\n', '   event SaleResumed();\n', '   event TokensPurchased(address _beneficiary, uint256 _cost, uint256 _tokens);\n', '   event TokensReclaimed(uint256 _amount);\n', '\n', '\n', '   constructor(uint256 _startTime, uint256 _endTime, address _walletAddress) public\n', '      OpsManaged()\n', '   {\n', '      require(_endTime > _startTime);\n', '\n', '      require(_walletAddress != address(0));\n', '      require(_walletAddress != address(this));\n', '\n', '      walletAddress = _walletAddress;\n', '\n', '      finalized = false;\n', '      suspended = false;\n', '\n', '      startTime = _startTime;\n', '      endTime   = _endTime;\n', '\n', '      // Use some defaults config values. Classes deriving from FlexibleTokenSale\n', '      // should set their own defaults\n', '      tokensPerKEther     = 100000;\n', '      bonus               = 0;\n', '      maxTokensPerAccount = 0;\n', '      contributionMin     = 0.1 ether;\n', '\n', '      totalTokensSold     = 0;\n', '      totalEtherCollected = 0;\n', '   }\n', '\n', '\n', '   function currentTime() public constant returns (uint256) {\n', '      return now;\n', '   }\n', '\n', '\n', '   // Initialize should be called by the owner as part of the deployment + setup phase.\n', '   // It will associate the sale contract with the token contract and perform basic checks.\n', '   function initialize(FinalizableToken _token) external onlyOwner returns(bool) {\n', '      require(address(token) == address(0));\n', '      require(address(_token) != address(0));\n', '      require(address(_token) != address(this));\n', '      require(address(_token) != address(walletAddress));\n', '      require(isOwnerOrOps(address(_token)) == false);\n', '\n', '      token = _token;\n', '\n', '      // This factor is used when converting cost <-> tokens.\n', '      // 18 is because of the ETH -> Wei conversion.\n', '      // 3 because prices are in K ETH instead of just ETH.\n', '      // 4 because bonuses are expressed as 0 - 10000 for 0.00% - 100.00% (with 2 decimals).\n', '      tokenConversionFactor = 10**(uint256(18).sub(_token.decimals()).add(3).add(4));\n', '      require(tokenConversionFactor > 0);\n', '\n', '      emit Initialized();\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '   //\n', '   // Owner Configuation\n', '   //\n', '\n', '   // Allows the owner to change the wallet address which is used for collecting\n', '   // ether received during the token sale.\n', '   function setWalletAddress(address _walletAddress) external onlyOwner returns(bool) {\n', '      require(_walletAddress != address(0));\n', '      require(_walletAddress != address(this));\n', '      require(_walletAddress != address(token));\n', '      require(isOwnerOrOps(_walletAddress) == false);\n', '\n', '      walletAddress = _walletAddress;\n', '\n', '      emit WalletAddressUpdated(_walletAddress);\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '   // Allows the owner to set an optional limit on the amount of tokens that can be purchased\n', '   // by a contributor. It can also be set to 0 to remove limit.\n', '   function setMaxTokensPerAccount(uint256 _maxTokens) external onlyOwner returns(bool) {\n', '\n', '      maxTokensPerAccount = _maxTokens;\n', '\n', '      emit MaxTokensPerAccountUpdated(_maxTokens);\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '   // Allows the owner to specify the conversion rate for ETH -> tokens.\n', '   // For example, passing 1,000,000 would mean that 1 ETH would purchase 1000 tokens.\n', '   function setTokensPerKEther(uint256 _tokensPerKEther) external onlyOwner returns(bool) {\n', '      require(_tokensPerKEther > 0);\n', '\n', '      tokensPerKEther = _tokensPerKEther;\n', '\n', '      emit TokensPerKEtherUpdated(_tokensPerKEther);\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '   // Allows the owner to set a bonus to apply to all purchases.\n', '   // For example, setting it to 2000 means that instead of receiving 200 tokens,\n', '   // for a given price, contributors would receive 240 tokens (20.00% bonus).\n', '   function setBonus(uint256 _bonus) external onlyOwner returns(bool) {\n', '      require(_bonus <= 10000);\n', '\n', '      bonus = _bonus;\n', '\n', '      emit BonusUpdated(_bonus);\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '   // Allows the owner to set a sale window which will allow the sale (aka buyTokens) to\n', '   // receive contributions between _startTime and _endTime. Once _endTime is reached,\n', '   // the sale contract will automatically stop accepting incoming contributions.\n', '   function setSaleWindow(uint256 _startTime, uint256 _endTime) external onlyOwner returns(bool) {\n', '      require(_startTime > 0);\n', '      require(_endTime > _startTime);\n', '\n', '      startTime = _startTime;\n', '      endTime   = _endTime;\n', '\n', '      emit SaleWindowUpdated(_startTime, _endTime);\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '   // Allows the owner to suspend the sale until it is manually resumed at a later time.\n', '   function suspend() external onlyOwner returns(bool) {\n', '      if (suspended == true) {\n', '          return false;\n', '      }\n', '\n', '      suspended = true;\n', '\n', '      emit SaleSuspended();\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '   // Allows the owner to resume the sale.\n', '   function resume() external onlyOwner returns(bool) {\n', '      if (suspended == false) {\n', '          return false;\n', '      }\n', '\n', '      suspended = false;\n', '\n', '      emit SaleResumed();\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '   //\n', '   // Contributions\n', '   //\n', '\n', '   // Default payable function which can be used to purchase tokens.\n', '   function () payable public {\n', '      buyTokens(msg.sender);\n', '   }\n', '\n', '\n', '   // Allows the caller to purchase tokens for a specific beneficiary (proxy purchase).\n', '   function buyTokens(address _beneficiary) public payable returns (uint256) {\n', '      return buyTokensInternal(_beneficiary, bonus);\n', '   }\n', '\n', '\n', '   function buyTokensInternal(address _beneficiary, uint256 _bonus) internal returns (uint256) {\n', '      require(!finalized);\n', '      require(!suspended);\n', '      require(currentTime() >= startTime);\n', '      require(currentTime() <= endTime);\n', '      require(msg.value >= contributionMin);\n', '      require(_beneficiary != address(0));\n', '      require(_beneficiary != address(this));\n', '      require(_beneficiary != address(token));\n', '\n', '      // We don&#39;t want to allow the wallet collecting ETH to\n', '      // directly be used to purchase tokens.\n', '      require(msg.sender != address(walletAddress));\n', '\n', '      // Check how many tokens are still available for sale.\n', '      uint256 saleBalance = token.balanceOf(address(this));\n', '      require(saleBalance > 0);\n', '\n', '      // Calculate how many tokens the contributor could purchase based on ETH received.\n', '      uint256 tokens = msg.value.mul(tokensPerKEther).mul(_bonus.add(10000)).div(tokenConversionFactor);\n', '      require(tokens > 0);\n', '\n', '      uint256 cost = msg.value;\n', '      uint256 refund = 0;\n', '\n', '      // Calculate what is the maximum amount of tokens that the contributor\n', '      // should be allowed to purchase\n', '      uint256 maxTokens = saleBalance;\n', '\n', '      if (maxTokensPerAccount > 0) {\n', '         // There is a maximum amount of tokens per account in place.\n', '         // Check if the user already hit that limit.\n', '         uint256 userBalance = getUserTokenBalance(_beneficiary);\n', '         require(userBalance < maxTokensPerAccount);\n', '\n', '         uint256 quotaBalance = maxTokensPerAccount.sub(userBalance);\n', '\n', '         if (quotaBalance < saleBalance) {\n', '            maxTokens = quotaBalance;\n', '         }\n', '      }\n', '\n', '      require(maxTokens > 0);\n', '\n', '      if (tokens > maxTokens) {\n', '         // The contributor sent more ETH than allowed to purchase.\n', '         // Limit the amount of tokens that they can purchase in this transaction.\n', '         tokens = maxTokens;\n', '\n', '         // Calculate the actual cost for that new amount of tokens.\n', '         cost = tokens.mul(tokenConversionFactor).div(tokensPerKEther.mul(_bonus.add(10000)));\n', '\n', '         if (msg.value > cost) {\n', '            // If the contributor sent more ETH than needed to buy the tokens,\n', '            // the balance should be refunded.\n', '            refund = msg.value.sub(cost);\n', '         }\n', '      }\n', '\n', '      // This is the actual amount of ETH that can be sent to the wallet.\n', '      uint256 contribution = msg.value.sub(refund);\n', '      walletAddress.transfer(contribution);\n', '\n', '      // Update our stats counters.\n', '      totalTokensSold     = totalTokensSold.add(tokens);\n', '      totalEtherCollected = totalEtherCollected.add(contribution);\n', '\n', '      // Transfer tokens to the beneficiary.\n', '      require(token.transfer(_beneficiary, tokens));\n', '\n', '      // Issue a refund for the excess ETH, as needed.\n', '      if (refund > 0) {\n', '         msg.sender.transfer(refund);\n', '      }\n', '\n', '      emit TokensPurchased(_beneficiary, cost, tokens);\n', '\n', '      return tokens;\n', '   }\n', '\n', '\n', '   // Returns the number of tokens that the user has purchased. Will be checked against the\n', '   // maximum allowed. Can be overriden in a sub class to change the calculations.\n', '   function getUserTokenBalance(address _beneficiary) internal view returns (uint256) {\n', '      return token.balanceOf(_beneficiary);\n', '   }\n', '\n', '\n', '   // Allows the owner to take back the tokens that are assigned to the sale contract.\n', '   function reclaimTokens() external onlyOwner returns (bool) {\n', '      uint256 tokens = token.balanceOf(address(this));\n', '\n', '      if (tokens == 0) {\n', '         return false;\n', '      }\n', '\n', '      address tokenOwner = token.owner();\n', '      require(tokenOwner != address(0));\n', '\n', '      require(token.transfer(tokenOwner, tokens));\n', '\n', '      emit TokensReclaimed(tokens);\n', '\n', '      return true;\n', '   }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// CaspianTokenConfig - Token Contract Configuration\n', '//\n', '// Copyright (c) 2018 Caspian, Limited (TM).\n', '// http://www.caspian.tech/\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', 'contract CaspianTokenConfig {\n', '\n', '    string  public constant TOKEN_SYMBOL      = "CSP";\n', '    string  public constant TOKEN_NAME        = "Caspian Token";\n', '    uint8   public constant TOKEN_DECIMALS    = 18;\n', '\n', '    uint256 public constant DECIMALSFACTOR    = 10**uint256(TOKEN_DECIMALS);\n', '    uint256 public constant TOKEN_TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;\n', '}\n', '\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// CaspianTokenSaleConfig - Token Sale Configuration\n', '//\n', '// Copyright (c) 2018 Caspian, Limited (TM).\n', '// http://www.caspian.tech/\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', 'contract CaspianTokenSaleConfig is CaspianTokenConfig {\n', '\n', '    //\n', '    // Time\n', '    //\n', '    uint256 public constant INITIAL_STARTTIME    = 1538553600; // 2018-10-03, 08:00:00 UTC\n', '    uint256 public constant INITIAL_ENDTIME      = 1538726400; // 2018-10-05, 08:00:00 UTC\n', '\n', '\n', '    //\n', '    // Purchases\n', '    //\n', '\n', '    // Minimum amount of ETH that can be used for purchase.\n', '    uint256 public constant CONTRIBUTION_MIN     = 0.5 ether;\n', '\n', '    // Price of tokens, based on the 1 ETH = 4000 CSP conversion ratio.\n', '    uint256 public constant TOKENS_PER_KETHER    = 4000000;\n', '\n', '    // Amount of bonus applied to the sale. 2000 = 20.00% bonus, 750 = 7.50% bonus, 0 = no bonus.\n', '    uint256 public constant BONUS                = 0;\n', '\n', '    // Maximum amount of tokens that can be purchased for each account. 0 for no maximum.\n', '    uint256 public constant TOKENS_ACCOUNT_MAX   = 400000 * DECIMALSFACTOR; // 100 ETH Max\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// CaspianTokenSale - Token Sale Contract\n', '//\n', '// Copyright (c) 2018 Caspian, Limited (TM).\n', '// http://www.caspian.tech/\n', '//\n', '// Based on code from Enuma Technologies.\n', '// Copyright (c) 2017 Enuma Technologies Limited.\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', 'contract CaspianTokenSale is FlexibleTokenSale, CaspianTokenSaleConfig {\n', '\n', '   //\n', '   // Whitelist\n', '   //\n', '   uint8 public currentPhase;\n', '\n', '   mapping(address => uint8) public whitelist;\n', '\n', '\n', '   //\n', '   // Events\n', '   //\n', '   event WhitelistUpdated(address indexed _account, uint8 _phase);\n', '\n', '\n', '   constructor(address wallet) public\n', '      FlexibleTokenSale(INITIAL_STARTTIME, INITIAL_ENDTIME, wallet)\n', '   {\n', '      tokensPerKEther     = TOKENS_PER_KETHER;\n', '      bonus               = BONUS;\n', '      maxTokensPerAccount = TOKENS_ACCOUNT_MAX;\n', '      contributionMin     = CONTRIBUTION_MIN;\n', '      currentPhase        = 1;\n', '   }\n', '\n', '\n', '   // Allows the owner or ops to add/remove people from the whitelist.\n', '   function updateWhitelist(address _address, uint8 _phase) external onlyOwnerOrOps returns (bool) {\n', '      return updateWhitelistInternal(_address, _phase);\n', '   }\n', '\n', '\n', '   function updateWhitelistInternal(address _address, uint8 _phase) internal returns (bool) {\n', '      require(_address != address(0));\n', '      require(_address != address(this));\n', '      require(_address != walletAddress);\n', '      require(_phase <= 1);\n', '\n', '      whitelist[_address] = _phase;\n', '\n', '      emit WhitelistUpdated(_address, _phase);\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '   // Allows the owner or ops to add/remove people from the whitelist, in batches.\n', '   function updateWhitelistBatch(address[] _addresses, uint8 _phase) external onlyOwnerOrOps returns (bool) {\n', '      require(_addresses.length > 0);\n', '\n', '      for (uint256 i = 0; i < _addresses.length; i++) {\n', '         require(updateWhitelistInternal(_addresses[i], _phase));\n', '      }\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '   // This is an extension to the buyToken function in FlexibleTokenSale which also takes\n', '   // care of checking contributors against the whitelist. Since buyTokens supports proxy payments\n', '   // we check that both the sender and the beneficiary have been whitelisted.\n', '   function buyTokensInternal(address _beneficiary, uint256 _bonus) internal returns (uint256) {\n', '      require(whitelist[msg.sender] >= currentPhase);\n', '      require(whitelist[_beneficiary] >= currentPhase);\n', '\n', '      return super.buyTokensInternal(_beneficiary, _bonus);\n', '   }\n', '}']