['pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract Base\n', '{\n', '    uint8 constant HEROLEVEL_MIN = 1;\n', '    uint8 constant HEROLEVEL_MAX = 5;\n', '\n', '    uint8 constant LIMITCHIP_MINLEVEL = 3;\n', '    uint constant PARTWEIGHT_NORMAL = 100;\n', '    uint constant PARTWEIGHT_LIMIT = 40;\n', '\n', '    address creator;\n', '\n', '    constructor() public\n', '    {\n', '        creator = msg.sender;\n', '    }\n', '\n', '    modifier MasterAble()\n', '    {\n', '        require(msg.sender == creator);\n', '        _;\n', '    }\n', '\n', '    function IsLimitPart(uint8 level, uint part) internal pure returns(bool)\n', '    {\n', '        if (level < LIMITCHIP_MINLEVEL) return false;\n', '        if (part < GetPartNum(level)) return false;\n', '        return true;\n', '    }\n', '\n', '    function GetPartWeight(uint8 level, uint part) internal pure returns(uint)\n', '    {\n', '        if (IsLimitPart(level, part)) return PARTWEIGHT_LIMIT;\n', '        return PARTWEIGHT_NORMAL;\n', '    }\n', '    \n', '    function GetPartNum(uint8 level) internal pure returns(uint)\n', '    {\n', '        if (level <= 2) return 3;\n', '        else if (level <= 4) return 4;\n', '        return 5;\n', '    }\n', '\n', '}\n', '\n', 'contract BasicTime\n', '{\n', '    uint constant DAY_SECONDS = 60 * 60 * 24;\n', '\n', '    function GetDayCount(uint timestamp) pure internal returns(uint)\n', '    {\n', '        return timestamp/DAY_SECONDS;\n', '    }\n', '\n', '    function GetExpireTime(uint timestamp, uint dayCnt) pure internal returns(uint)\n', '    {\n', '        uint dayEnd = GetDayCount(timestamp) + dayCnt;\n', '        return dayEnd * DAY_SECONDS;\n', '    }\n', '\n', '}\n', '\n', 'contract BasicAuth is Base\n', '{\n', '\n', '    address master;\n', '    mapping(address => bool) auth_list;\n', '\n', '    function InitMaster(address acc) internal\n', '    {\n', '        require(address(0) != acc);\n', '        master = acc;\n', '    }\n', '\n', '    modifier MasterAble()\n', '    {\n', '        require(msg.sender == creator || msg.sender == master);\n', '        _;\n', '    }\n', '\n', '    modifier OwnerAble(address acc)\n', '    {\n', '        require(acc == tx.origin);\n', '        _;\n', '    }\n', '\n', '    modifier AuthAble()\n', '    {\n', '        require(auth_list[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function CanHandleAuth(address from) internal view returns(bool)\n', '    {\n', '        return from == creator || from == master;\n', '    }\n', '    \n', '    function SetAuth(address target) external\n', '    {\n', '        require(CanHandleAuth(tx.origin) || CanHandleAuth(msg.sender));\n', '        auth_list[target] = true;\n', '    }\n', '\n', '    function ClearAuth(address target) external\n', '    {\n', '        require(CanHandleAuth(tx.origin) || CanHandleAuth(msg.sender));\n', '        delete auth_list[target];\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract ProductionBoiler is BasicAuth\n', '{\n', '\n', '    struct Boiler\n', '    {\n', '        uint m_Expire;\n', '        uint32[] m_Chips;\n', '    }\n', '\n', '    mapping(address => mapping(uint => Boiler)) g_Boilers;\n', '\n', '    constructor(address Master) public\n', '    {\n', '        InitMaster(Master);\n', '    }\n', '\n', '    function IsBoilerValid(address acc, uint idx) external view returns(bool)\n', '    {\n', '        Boiler storage obj = g_Boilers[acc][idx];\n', '        if (obj.m_Chips.length > 0) return false;\n', '        return true;\n', '    }\n', '\n', '    function IsBoilerExpire(address acc, uint idx) external view returns(bool)\n', '    {\n', '        Boiler storage obj = g_Boilers[acc][idx];\n', '        return obj.m_Expire <= now;\n', '    }\n', '\n', '    //=========================================================================\n', '\n', '    function GenerateChips(address acc, uint idx, uint cd, uint32[] chips) external AuthAble OwnerAble(acc)\n', '    {\n', '        Boiler storage obj = g_Boilers[acc][idx];\n', '        obj.m_Expire = cd+now;\n', '        obj.m_Chips = chips;\n', '    }\n', '\n', '    function CollectChips(address acc, uint idx) external AuthAble OwnerAble(acc) returns(uint32[] chips)\n', '    {\n', '        Boiler storage obj = g_Boilers[acc][idx];\n', '        chips = new uint32[](obj.m_Chips.length);\n', '        for (uint i=0; i<obj.m_Chips.length; i++)\n', '        {\n', '            chips[i] = obj.m_Chips[i];\n', '            delete obj.m_Chips[i];\n', '        }\n', '        obj.m_Chips.length = 0;\n', '        obj.m_Expire = 0;\n', '    }\n', '\n', '    function GetBoilerInfo(address acc, uint idx) external view returns(uint, uint32[])\n', '    {\n', '        Boiler storage obj = g_Boilers[acc][idx];\n', '        return (obj.m_Expire,obj.m_Chips);\n', '    }\n', '\n', '}']