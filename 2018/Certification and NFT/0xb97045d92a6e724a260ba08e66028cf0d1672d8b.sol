['pragma solidity 0.4.19;\n', '\n', 'contract Countout {\n', '\n', '    address public owner;\n', '    uint128 public ownerBank;\n', '    uint8 public round;\n', '    uint8 public round_after;\n', '    uint8 public currentCount;\n', '    uint8 public totalCount;\n', '    uint128 public initialPrice = 0.005 ether;\n', '    uint128 public bonusPrice = 0.1 ether;\n', '    uint128 public nextPrice;\n', '    uint128 public sumPrice;\n', '    uint256 public lastTransactionTime;\n', '    address public lastCountAddress;    \n', '    uint8 private randomCount;\n', '    \n', '    address[] public sevenWinnerAddresses;      \n', '    mapping (address => uint128) public addressToBalance;\n', '\n', '    event Count(address from, uint8 count);\n', '    event Hit(address from, uint8 count);\n', '\n', '    /*** CONSTRUCTOR ***/\n', '    function Countout() public {\n', '        owner = msg.sender;\n', '        _renew();\n', '        _keepLastTransaction();\n', '        //Set randomcount as 10 as pre-sale\n', '        randomCount = 10;\n', '    }\n', '\n', '    /*** Owner Action ***/\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        if (_newOwner != address(0)) {\n', '            owner = _newOwner;\n', '        }\n', '    }\n', '\n', '    function ownerWithdraw() public onlyOwner {\n', '        require (block.timestamp > lastTransactionTime + 7 days); \n', '\n', '        if (round_after < 77 && sevenWinnerAddresses.length > 0){\n', '            uint128 sevensWinnerBack = (ownerBank + sumPrice) / uint8(sevenWinnerAddresses.length) - 0.0000007 ether;\n', '            uint8 i;\n', '            for (i = 0; i < sevenWinnerAddresses.length; i++){\n', '                addressToBalance[sevenWinnerAddresses[i]]  = addressToBalance[sevenWinnerAddresses[i]] + sevensWinnerBack;\n', '            }         \n', '               \n', '        } else {\n', '            owner.transfer(this.balance);\n', '        }\n', '        sumPrice = 0;\n', '        ownerBank = 0;\n', '    }\n', '\n', '    function sevenWinnerWithdraw() public {\n', '        require(addressToBalance[msg.sender] > 0);\n', '        msg.sender.transfer(addressToBalance[msg.sender]);\n', '        addressToBalance[msg.sender] = 0;\n', '    }    \n', '\n', '    /*** Main Function ***/\n', '    function _payFee(uint128 _price, address _referralAddress) internal returns (uint128 _processing){\n', '        uint128 _cut = _price / 100;\n', '        _processing = _price - _cut;\n', '        if (_referralAddress != address(0)){\n', '            _referralAddress.transfer(_cut);\n', '        } else {    \n', '            ownerBank = ownerBank + _cut;    \n', '        }\n', '        uint8 i;\n', '        for (i = 0; i < sevenWinnerAddresses.length; i++){\n', '            addressToBalance[sevenWinnerAddresses[i]]  = addressToBalance[sevenWinnerAddresses[i]] + _cut;\n', '            _processing = _processing - _cut;\n', '        }\n', '\n', '        uint128 _remaining = (7 - uint8(sevenWinnerAddresses.length)) * _cut;\n', '        ownerBank = ownerBank + _remaining;\n', '        _processing = _processing - _remaining;\n', '    }\n', '\n', '    function _renew() internal{\n', '        round++;\n', '        if (sevenWinnerAddresses.length == 7){\n', '            round_after++;\n', '        }\n', '        currentCount = 0;\n', '        nextPrice = initialPrice;\n', '\n', '        randomCount = uint8(block.blockhash(block.number-randomCount))%10 + 1;\n', '\n', '        if(randomCount >= 7){\n', '            randomCount = uint8(block.blockhash(block.number-randomCount-randomCount))%10 + 1;  \n', '        }\n', '        \n', '        if (sevenWinnerAddresses.length < 7 && randomCount == 7){\n', '            randomCount++;\n', '        }         \n', '\n', '    }\n', '\n', '    function _keepLastTransaction() internal{\n', '        lastTransactionTime = block.timestamp;\n', '        lastCountAddress = msg.sender;\n', '    }\n', '\n', '    function countUp(address _referralAddress) public payable {\n', '        require (block.timestamp < lastTransactionTime + 7 days);    \n', '        require (msg.value == nextPrice); \n', '\n', '        uint128 _price = uint128(msg.value);\n', '        uint128 _processing;\n', '      \n', '        totalCount++;\n', '        currentCount++; \n', '\n', '        _processing = _payFee(_price, _referralAddress);     \n', '        \n', '        if (currentCount > 1) {\n', '            lastCountAddress.transfer(_processing);\n', '        } else {\n', '            sumPrice = sumPrice + _processing;\n', '        }\n', '\n', '        if (currentCount == randomCount) {\n', '            Hit(msg.sender, currentCount);\n', '            _renew(); \n', '\n', '        } else {\n', '            if (currentCount == 7) {\n', '                if (sevenWinnerAddresses.length < 7){\n', '                    sevenWinnerAddresses.push(msg.sender);\n', '                } else {\n', '\n', '                    if (sumPrice <= bonusPrice) {\n', '                        msg.sender.transfer(sumPrice);\n', '                        sumPrice = 0;\n', '                    } else {\n', '                        msg.sender.transfer(bonusPrice);\n', '                        sumPrice = sumPrice - bonusPrice;\n', '                   }\n', '                }\n', '                _renew();\n', '            } else {\n', '                nextPrice = nextPrice * 3/2;\n', '            }   \n', '\n', '            Count(msg.sender, currentCount);            \n', '        }\n', '        _keepLastTransaction(); \n', '    }\n', '\n', '}']
['pragma solidity 0.4.19;\n', '\n', 'contract Countout {\n', '\n', '    address public owner;\n', '    uint128 public ownerBank;\n', '    uint8 public round;\n', '    uint8 public round_after;\n', '    uint8 public currentCount;\n', '    uint8 public totalCount;\n', '    uint128 public initialPrice = 0.005 ether;\n', '    uint128 public bonusPrice = 0.1 ether;\n', '    uint128 public nextPrice;\n', '    uint128 public sumPrice;\n', '    uint256 public lastTransactionTime;\n', '    address public lastCountAddress;    \n', '    uint8 private randomCount;\n', '    \n', '    address[] public sevenWinnerAddresses;      \n', '    mapping (address => uint128) public addressToBalance;\n', '\n', '    event Count(address from, uint8 count);\n', '    event Hit(address from, uint8 count);\n', '\n', '    /*** CONSTRUCTOR ***/\n', '    function Countout() public {\n', '        owner = msg.sender;\n', '        _renew();\n', '        _keepLastTransaction();\n', '        //Set randomcount as 10 as pre-sale\n', '        randomCount = 10;\n', '    }\n', '\n', '    /*** Owner Action ***/\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        if (_newOwner != address(0)) {\n', '            owner = _newOwner;\n', '        }\n', '    }\n', '\n', '    function ownerWithdraw() public onlyOwner {\n', '        require (block.timestamp > lastTransactionTime + 7 days); \n', '\n', '        if (round_after < 77 && sevenWinnerAddresses.length > 0){\n', '            uint128 sevensWinnerBack = (ownerBank + sumPrice) / uint8(sevenWinnerAddresses.length) - 0.0000007 ether;\n', '            uint8 i;\n', '            for (i = 0; i < sevenWinnerAddresses.length; i++){\n', '                addressToBalance[sevenWinnerAddresses[i]]  = addressToBalance[sevenWinnerAddresses[i]] + sevensWinnerBack;\n', '            }         \n', '               \n', '        } else {\n', '            owner.transfer(this.balance);\n', '        }\n', '        sumPrice = 0;\n', '        ownerBank = 0;\n', '    }\n', '\n', '    function sevenWinnerWithdraw() public {\n', '        require(addressToBalance[msg.sender] > 0);\n', '        msg.sender.transfer(addressToBalance[msg.sender]);\n', '        addressToBalance[msg.sender] = 0;\n', '    }    \n', '\n', '    /*** Main Function ***/\n', '    function _payFee(uint128 _price, address _referralAddress) internal returns (uint128 _processing){\n', '        uint128 _cut = _price / 100;\n', '        _processing = _price - _cut;\n', '        if (_referralAddress != address(0)){\n', '            _referralAddress.transfer(_cut);\n', '        } else {    \n', '            ownerBank = ownerBank + _cut;    \n', '        }\n', '        uint8 i;\n', '        for (i = 0; i < sevenWinnerAddresses.length; i++){\n', '            addressToBalance[sevenWinnerAddresses[i]]  = addressToBalance[sevenWinnerAddresses[i]] + _cut;\n', '            _processing = _processing - _cut;\n', '        }\n', '\n', '        uint128 _remaining = (7 - uint8(sevenWinnerAddresses.length)) * _cut;\n', '        ownerBank = ownerBank + _remaining;\n', '        _processing = _processing - _remaining;\n', '    }\n', '\n', '    function _renew() internal{\n', '        round++;\n', '        if (sevenWinnerAddresses.length == 7){\n', '            round_after++;\n', '        }\n', '        currentCount = 0;\n', '        nextPrice = initialPrice;\n', '\n', '        randomCount = uint8(block.blockhash(block.number-randomCount))%10 + 1;\n', '\n', '        if(randomCount >= 7){\n', '            randomCount = uint8(block.blockhash(block.number-randomCount-randomCount))%10 + 1;  \n', '        }\n', '        \n', '        if (sevenWinnerAddresses.length < 7 && randomCount == 7){\n', '            randomCount++;\n', '        }         \n', '\n', '    }\n', '\n', '    function _keepLastTransaction() internal{\n', '        lastTransactionTime = block.timestamp;\n', '        lastCountAddress = msg.sender;\n', '    }\n', '\n', '    function countUp(address _referralAddress) public payable {\n', '        require (block.timestamp < lastTransactionTime + 7 days);    \n', '        require (msg.value == nextPrice); \n', '\n', '        uint128 _price = uint128(msg.value);\n', '        uint128 _processing;\n', '      \n', '        totalCount++;\n', '        currentCount++; \n', '\n', '        _processing = _payFee(_price, _referralAddress);     \n', '        \n', '        if (currentCount > 1) {\n', '            lastCountAddress.transfer(_processing);\n', '        } else {\n', '            sumPrice = sumPrice + _processing;\n', '        }\n', '\n', '        if (currentCount == randomCount) {\n', '            Hit(msg.sender, currentCount);\n', '            _renew(); \n', '\n', '        } else {\n', '            if (currentCount == 7) {\n', '                if (sevenWinnerAddresses.length < 7){\n', '                    sevenWinnerAddresses.push(msg.sender);\n', '                } else {\n', '\n', '                    if (sumPrice <= bonusPrice) {\n', '                        msg.sender.transfer(sumPrice);\n', '                        sumPrice = 0;\n', '                    } else {\n', '                        msg.sender.transfer(bonusPrice);\n', '                        sumPrice = sumPrice - bonusPrice;\n', '                   }\n', '                }\n', '                _renew();\n', '            } else {\n', '                nextPrice = nextPrice * 3/2;\n', '            }   \n', '\n', '            Count(msg.sender, currentCount);            \n', '        }\n', '        _keepLastTransaction(); \n', '    }\n', '\n', '}']
