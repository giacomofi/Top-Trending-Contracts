['library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract CryptoProtect is Ownable {\n', '    using SafeMath for uint256;\n', '    \n', '    ERC20Interface tokenInterface;\n', '    \n', '    // Policy State --\n', '    // 1 - active\n', '    // 2 - inactive\n', '    // 3 - claimed\n', '    struct Policy {\n', '        uint256 premiumAmount;\n', '        uint256 payoutAmount;\n', '        uint256 endDate;\n', '        uint8 state;\n', '    }\n', '    \n', '    struct Token {\n', '        mapping (string => Policy) token;\n', '    }\n', '    \n', '    struct Exchange {\n', '        mapping (string => Token) exchange;\n', '    }\n', '    \n', '    struct Pool{\n', '        uint256 endDate;\n', '        uint256 amount;\n', '    }\n', '    \n', '    mapping(address => Exchange) policies;\n', '    \n', '    Pool[]              private poolRecords;\n', '    uint                private poolRecordsIndex;\n', '    uint256             private poolBackedAmount;\n', '    \n', '    // poolState state --\n', '    // 1 - active\n', '    // 2 - not active\n', '    uint8               public poolState;\n', '    uint256             public poolMaxAmount;\n', '    uint256             public poolStartDate;\n', '    \n', '    uint256             public minPremium;\n', '    uint256             public maxPremium;\n', '    \n', '    string             public contractName;\n', '    \n', '    event PoolStateUpdate(uint8 indexed state);\n', '    event PremiumReceived(address indexed addr, uint256 indexed amount, uint indexed id);\n', '    event ClaimSubmitted(address indexed addr, string indexed exchange, string indexed token);\n', '    event ClaimPayout(address indexed addr, string indexed exchange, string indexed token);\n', '    event PoolBackedAmountUpdate(uint256 indexed amount);\n', '    event PoolPremiumLimitUpdate(uint256 indexed min, uint256 indexed max);\n', '\n', '    constructor(\n', '        string _contractName,\n', '        address _tokenContract,\n', '        uint256 _poolMaxAmount,\n', '        uint256 _poolBackedAmount,\n', '        uint256 _minPremium,\n', '        uint256 _maxPremium\n', '    )\n', '        public\n', '    {\n', '        contractName = _contractName;\n', '        tokenInterface = ERC20Interface(_tokenContract);\n', '        \n', '        poolState = 1;\n', '        poolStartDate = now;\n', '        poolMaxAmount = _poolMaxAmount;\n', '        poolBackedAmount = _poolBackedAmount;\n', '        \n', '        minPremium = _minPremium;\n', '        maxPremium = _maxPremium;\n', '    }\n', '    \n', '    /**\n', '     * @dev Modifier to check pool state\n', '     */\n', '    modifier verifyPoolState() {\n', '        require(poolState == 1);\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Check policy eligibility\n', '     */\n', '    function isEligible(address _addr, string _exchange, string _token) internal view \n', '        returns (bool)\n', '    {\n', '        if (\n', '            policies[_addr].exchange[_exchange].token[_token].state == 0 ||\n', '            policies[_addr].exchange[_exchange].token[_token].endDate < now\n', '        ) {\n', '            return true;\n', '        }\n', '        \n', '        return false;\n', '    }\n', '    \n', '    /**\n', '     * @dev Compute Pool Amount\n', '     */\n', '    function computePoolAmount() internal view \n', '        returns (uint256)\n', '    {\n', '        uint256 currentPoolAmount = 0;\n', '        \n', '        // limited by gas\n', '        for (uint i = poolRecordsIndex; i< poolRecords.length; i++) {\n', '            if (poolRecords[i].endDate < now) {\n', '                continue;\n', '            }\n', '            \n', '            currentPoolAmount = currentPoolAmount.add(poolRecords[i].amount);\n', '        }\n', '        \n', '        return currentPoolAmount.add(poolBackedAmount);\n', '    }\n', '    \n', '    /**\n', '     * @dev Make Transaction\n', '     * Make transaction using transferFrom\n', '     */\n', '    function MakeTransaction(\n', '        address _tokenOwner,\n', '        uint256 _premiumAmount,\n', '        uint256 _payoutAmount,\n', '        string _exchange,\n', '        string _token,\n', '        uint8 _id\n', '    ) \n', '        external\n', '        verifyPoolState()\n', '    {\n', '        // check parameters\n', '        require(_tokenOwner != address(0));\n', '        \n', '        require(_premiumAmount < _payoutAmount);\n', '        require(_premiumAmount >= minPremium);\n', '        require(_premiumAmount <= maxPremium);\n', '        \n', '        require(bytes(_exchange).length > 0);\n', '        require(bytes(_token).length > 0);\n', '        require(_id > 0);\n', '        \n', '        // require(computePoolAmount() < poolMaxAmount); // reduce cost\n', '        \n', '        // check eligibility\n', '        require(isEligible(_tokenOwner, _exchange, _token));\n', '        \n', '        // check that token owner address has valid amount\n', '        require(tokenInterface.balanceOf(_tokenOwner) >= _premiumAmount);\n', '        require(tokenInterface.allowance(_tokenOwner, address(this)) >= _premiumAmount);\n', '        \n', '        // record data\n', '        policies[_tokenOwner].exchange[_exchange].token[_token].premiumAmount = _premiumAmount;\n', '        policies[_tokenOwner].exchange[_exchange].token[_token].payoutAmount = _payoutAmount;\n', '        policies[_tokenOwner].exchange[_exchange].token[_token].endDate = now.add(90 * 1 days);\n', '        policies[_tokenOwner].exchange[_exchange].token[_token].state = 1;\n', '        \n', '        // record pool\n', '        poolRecords.push(Pool(now.add(90 * 1 days), _premiumAmount));\n', '        \n', '        // transfer amount\n', '        tokenInterface.transferFrom(_tokenOwner, address(this), _premiumAmount);\n', '        \n', '        emit PremiumReceived(_tokenOwner, _premiumAmount, _id);\n', '    }\n', '    \n', '    /**\n', '     * @dev Get Policy\n', '     */\n', '    function GetPolicy(address _addr, string _exchange, string _token) public view \n', '        returns (\n', '            uint256 premiumAmount,\n', '            uint256 payoutAmount,\n', '            uint256 endDate,\n', '            uint8 state\n', '        )\n', '    {\n', '        return (\n', '            policies[_addr].exchange[_exchange].token[_token].premiumAmount,\n', '            policies[_addr].exchange[_exchange].token[_token].payoutAmount,\n', '            policies[_addr].exchange[_exchange].token[_token].endDate,\n', '            policies[_addr].exchange[_exchange].token[_token].state\n', '        );\n', '    }\n', '    \n', '    /**\n', '     * @dev Get Policy\n', '     */\n', '    function SubmitClaim(address _addr, string _exchange, string _token) public \n', '        returns (bool submitted)\n', '    {\n', '        require(policies[_addr].exchange[_exchange].token[_token].state == 1);\n', '        require(policies[_addr].exchange[_exchange].token[_token].endDate > now);\n', '        \n', '        emit ClaimSubmitted(_addr, _exchange, _token);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Get Current Pool Amount\n', '     */\n', '    function GetCurrentPoolAmount() public view \n', '        returns (uint256)\n', '    {\n', '        return computePoolAmount();\n', '    }\n', '    \n', '    /**\n', '     * @dev Check Eligibility\n', '     */\n', '    function CheckEligibility(address _addr, string _exchange, string _token) public view\n', '        returns (bool) \n', '    {\n', '        return(isEligible(_addr, _exchange, _token));\n', '    }\n', '    \n', '    /**\n', '     * @dev Check Token Balance\n', '     */\n', '    function CheckBalance(address _addr) public view returns (uint256){\n', '        return tokenInterface.balanceOf(_addr);\n', '    }\n', '    \n', '    /**\n', '     * @dev Check Token Allowance\n', '     */\n', '    function CheckAllowance(address _addr) public view returns (uint256){\n', '        return tokenInterface.allowance(_addr, address(this));\n', '    }\n', '    \n', '    /**\n', '     * @dev Update Pool State\n', '     */\n', '    function UpdatePolicyState(address _addr, string _exchange, string _token, uint8 _state) external\n', '        onlyOwner\n', '    {\n', '        require(policies[_addr].exchange[_exchange].token[_token].state != 0);\n', '        policies[_addr].exchange[_exchange].token[_token].state = _state;\n', '        \n', '        if (_state == 3) {\n', '            emit ClaimPayout(_addr, _exchange, _token);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev Update Pool State\n', '     */\n', '    function UpdatePoolState(uint8 _state) external\n', '        onlyOwner\n', '    {\n', '        poolState = _state;\n', '        emit PoolStateUpdate(_state);\n', '    }\n', '    \n', '    /**\n', '     * @dev Update Backed Amount\n', '     */\n', '    function UpdateBackedAmount(uint256 _amount) external\n', '        onlyOwner\n', '    {\n', '        poolBackedAmount = _amount;\n', '        \n', '        emit PoolBackedAmountUpdate(_amount);\n', '    }\n', '    \n', '    /**\n', '     * @dev Update Premium Limit\n', '     */\n', '    function UpdatePremiumLimit(uint256 _min, uint256 _max) external\n', '        onlyOwner\n', '    {\n', '        require(_min < _max);\n', '        minPremium = _min;\n', '        maxPremium = _max;\n', '        \n', '        emit PoolPremiumLimitUpdate(_min, _max);\n', '    }\n', '    \n', '    /**\n', '     * @dev Initiate Payout\n', '     */\n', '    function InitiatePayout(address _addr, string _exchange, string _token) external\n', '        onlyOwner\n', '    {\n', '        require(policies[_addr].exchange[_exchange].token[_token].state == 1);\n', '        require(policies[_addr].exchange[_exchange].token[_token].payoutAmount > 0);\n', '        \n', '        uint256 payoutAmount = policies[_addr].exchange[_exchange].token[_token].payoutAmount;\n', '        require(payoutAmount <= tokenInterface.balanceOf(address(this)));\n', '        \n', '        policies[_addr].exchange[_exchange].token[_token].state = 3;\n', '        tokenInterface.transfer(_addr, payoutAmount);\n', '        \n', '        emit ClaimPayout(_addr, _exchange, _token);\n', '    }\n', '    \n', '    /**\n', '     * @dev Withdraw Fee\n', '     */\n', '    function WithdrawFee(uint256 _amount) external\n', '        onlyOwner\n', '    {\n', '        require(_amount <= tokenInterface.balanceOf(address(this)));\n', '        tokenInterface.transfer(owner, _amount);\n', '    }\n', '    \n', '    /**\n', '     * @dev Emergency Drain\n', '     * in case something went wrong and token is stuck in contract\n', '     */\n', '    function EmergencyDrain(ERC20Interface _anyToken) external\n', '        onlyOwner\n', '        returns(bool)\n', '    {\n', '        if (address(this).balance > 0) {\n', '            owner.transfer(address(this).balance);\n', '        }\n', '        \n', '        if (_anyToken != address(0)) {\n', '            _anyToken.transfer(owner, _anyToken.balanceOf(this));\n', '        }\n', '        return true;\n', '    }\n', '}']