['pragma solidity 0.4.25;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', '\n', 'library Math {\n', '  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // (a + b) / 2 can overflow, so we distribute\n', '    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '\n', '  function balanceOf(address _who) public view returns (uint256);\n', '\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function decimals() public view returns (uint256);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/*\n', '    Modified Util contract as used by Kyber Network\n', '*/\n', '\n', 'library Utils {\n', '\n', '    uint256 constant internal PRECISION = (10**18);\n', '    uint256 constant internal MAX_QTY   = (10**28); // 10B tokens\n', '    uint256 constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\n', '    uint256 constant internal MAX_DECIMALS = 18;\n', '    uint256 constant internal ETH_DECIMALS = 18;\n', '    uint256 constant internal MAX_UINT = 2**256-1;\n', '\n', "    // Currently constants can't be accessed from other contracts, so providing functions to do that here\n", '    function precision() internal pure returns (uint256) { return PRECISION; }\n', '    function max_qty() internal pure returns (uint256) { return MAX_QTY; }\n', '    function max_rate() internal pure returns (uint256) { return MAX_RATE; }\n', '    function max_decimals() internal pure returns (uint256) { return MAX_DECIMALS; }\n', '    function eth_decimals() internal pure returns (uint256) { return ETH_DECIMALS; }\n', '    function max_uint() internal pure returns (uint256) { return MAX_UINT; }\n', '\n', '    /// @notice Retrieve the number of decimals used for a given ERC20 token\n', '    /// @dev As decimals are an optional feature in ERC20, this contract uses `call` to\n', "    /// ensure that an exception doesn't cause transaction failure\n", '    /// @param token the token for which we should retrieve the decimals\n', '    /// @return decimals the number of decimals in the given token\n', '    function getDecimals(address token)\n', '        internal\n', '        view\n', '        returns (uint256 decimals)\n', '    {\n', '        bytes4 functionSig = bytes4(keccak256("decimals()"));\n', '\n', '        /// @dev Using assembly due to issues with current solidity `address.call()`\n', '        /// implementation: https://github.com/ethereum/solidity/issues/2884\n', '        assembly {\n', '            // Pointer to next free memory slot\n', '            let ptr := mload(0x40)\n', '            // Store functionSig variable at ptr\n', '            mstore(ptr,functionSig)\n', '            let functionSigLength := 0x04\n', '            let wordLength := 0x20\n', '\n', '            let success := call(\n', '                                5000, // Amount of gas\n', '                                token, // Address to call\n', '                                0, // ether to send\n', '                                ptr, // ptr to input data\n', '                                functionSigLength, // size of data\n', '                                ptr, // where to store output data (overwrite input)\n', '                                wordLength // size of output data (32 bytes)\n', '                               )\n', '\n', '            switch success\n', '            case 0 {\n', "                decimals := 18 // If the token doesn't implement `decimals()`, return 18 as default\n", '            }\n', '            case 1 {\n', '                decimals := mload(ptr) // Set decimals to return data from call\n', '            }\n', '            mstore(0x40,add(ptr,0x04)) // Reset the free memory pointer to the next known free location\n', '        }\n', '    }\n', '\n', '    /// @dev Checks that a given address has its token allowance and balance set above the given amount\n', '    /// @param tokenOwner the address which should have custody of the token\n', '    /// @param tokenAddress the address of the token to check\n', '    /// @param tokenAmount the amount of the token which should be set\n', '    /// @param addressToAllow the address which should be allowed to transfer the token\n', '    /// @return bool true if the allowance and balance is set, false if not\n', '    function tokenAllowanceAndBalanceSet(\n', '        address tokenOwner,\n', '        address tokenAddress,\n', '        uint256 tokenAmount,\n', '        address addressToAllow\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (\n', '            ERC20(tokenAddress).allowance(tokenOwner, addressToAllow) >= tokenAmount &&\n', '            ERC20(tokenAddress).balanceOf(tokenOwner) >= tokenAmount\n', '        );\n', '    }\n', '\n', '    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\n', '        if (dstDecimals >= srcDecimals) {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n', '        } else {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n', '        }\n', '    }\n', '\n', '    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\n', '\n', '        //source quantity is rounded up. to avoid dest quantity being too low.\n', '        uint numerator;\n', '        uint denominator;\n', '        if (srcDecimals >= dstDecimals) {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n', '            denominator = rate;\n', '        } else {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            numerator = (PRECISION * dstQty);\n', '            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n', '        }\n', '        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n', '    }\n', '\n', '    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns (uint) {\n', '        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\n', '    }\n', '\n', '    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns (uint) {\n', '        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\n', '    }\n', '\n', '    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\n', '        internal pure returns (uint)\n', '    {\n', '        require(srcAmount <= MAX_QTY);\n', '        require(destAmount <= MAX_QTY);\n', '\n', '        if (dstDecimals >= srcDecimals) {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\n', '        } else {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\n', '        }\n', '    }\n', '\n', "    /// @notice Bringing this in from the Math library as we've run out of space in TotlePrimary (see EIP-170)\n", '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'library ERC20SafeTransfer {\n', '    function safeTransfer(address _tokenAddress, address _to, uint256 _value) internal returns (bool success) {\n', '\n', '        require(_tokenAddress.call(bytes4(keccak256("transfer(address,uint256)")), _to, _value));\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function safeTransferFrom(address _tokenAddress, address _from, address _to, uint256 _value) internal returns (bool success) {\n', '\n', '        require(_tokenAddress.call(bytes4(keccak256("transferFrom(address,address,uint256)")), _from, _to, _value));\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function safeApprove(address _tokenAddress, address _spender, uint256 _value) internal returns (bool success) {\n', '\n', '        require(_tokenAddress.call(bytes4(keccak256("approve(address,uint256)")), _spender, _value));\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function fetchReturnData() internal returns (bool success){\n', '        assembly {\n', '            switch returndatasize()\n', '            case 0 {\n', '                success := 1\n', '            }\n', '            case 32 {\n', '                returndatacopy(0, 0, 32)\n', '                success := mload(0)\n', '            }\n', '            default {\n', '                revert(0, 0)\n', '            }\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/// @title A contract which is used to check and set allowances of tokens\n', '/// @dev In order to use this contract is must be inherited in the contract which is using\n', '/// its functionality\n', 'contract AllowanceSetter {\n', '    uint256 constant MAX_UINT = 2**256 - 1;\n', '\n', '    /// @notice A function which allows the caller to approve the max amount of any given token\n', '    /// @dev In order to function correctly, token allowances should not be set anywhere else in\n', '    /// the inheriting contract\n', '    /// @param addressToApprove the address which we want to approve to transfer the token\n', '    /// @param token the token address which we want to call approve on\n', '    function approveAddress(address addressToApprove, address token) internal {\n', '        if(ERC20(token).allowance(address(this), addressToApprove) == 0) {\n', '            require(ERC20SafeTransfer.safeApprove(token, addressToApprove, MAX_UINT));\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/// @title A contract which can be used to ensure only the TotlePrimary contract can call\n', '/// some functions\n', '/// @dev Defines a modifier which should be used when only the totle contract should\n', '/// able able to call a function\n', 'contract TotleControl is Ownable {\n', '    address public totlePrimary;\n', '\n', '    /// @dev A modifier which only allows code execution if msg.sender equals totlePrimary address\n', '    modifier onlyTotle() {\n', '        require(msg.sender == totlePrimary);\n', '        _;\n', '    }\n', '\n', '    /// @notice Contract constructor\n', '    /// @dev As this contract inherits ownable, msg.sender will become the contract owner\n', '    /// @param _totlePrimary the address of the contract to be set as totlePrimary\n', '    constructor(address _totlePrimary) public {\n', '        require(_totlePrimary != address(0x0));\n', '        totlePrimary = _totlePrimary;\n', '    }\n', '\n', '    /// @notice A function which allows only the owner to change the address of totlePrimary\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param _totlePrimary the address of the contract to be set as totlePrimary\n', '    function setTotle(\n', '        address _totlePrimary\n', '    ) external onlyOwner {\n', '        require(_totlePrimary != address(0x0));\n', '        totlePrimary = _totlePrimary;\n', '    }\n', '}\n', '\n', '/// @title A contract which allows its owner to withdraw any ether which is contained inside\n', 'contract Withdrawable is Ownable {\n', '\n', '    /// @notice Withdraw ether contained in this contract and send it back to owner\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param _token The address of the token that the user wants to withdraw\n', '    /// @param _amount The amount of tokens that the caller wants to withdraw\n', '    /// @return bool value indicating whether the transfer was successful\n', '    function withdrawToken(address _token, uint256 _amount) external onlyOwner returns (bool) {\n', '        return ERC20SafeTransfer.safeTransfer(_token, owner, _amount);\n', '    }\n', '\n', '    /// @notice Withdraw ether contained in this contract and send it back to owner\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param _amount The amount of ether that the caller wants to withdraw\n', '    function withdrawETH(uint256 _amount) external onlyOwner {\n', '        owner.transfer(_amount);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Paused();\n', '  event Unpaused();\n', '\n', '  bool private _paused = false;\n', '\n', '  /**\n', '   * @return true if the contract is paused, false otherwise.\n', '   */\n', '  function paused() public view returns (bool) {\n', '    return _paused;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!_paused, "Contract is paused.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(_paused, "Contract not paused.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused {\n', '    _paused = true;\n', '    emit Paused();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused {\n', '    _paused = false;\n', '    emit Unpaused();\n', '  }\n', '}\n', '\n', 'contract ErrorReporter {\n', '    function revertTx(string reason) public pure {\n', '        revert(reason);\n', '    }\n', '}\n', '\n', 'contract SelectorProvider {\n', '    bytes4 constant getAmountToGive = bytes4(keccak256("getAmountToGive(bytes)"));\n', '    bytes4 constant staticExchangeChecks = bytes4(keccak256("staticExchangeChecks(bytes)"));\n', '    bytes4 constant performBuyOrder = bytes4(keccak256("performBuyOrder(bytes,uint256)"));\n', '    bytes4 constant performSellOrder = bytes4(keccak256("performSellOrder(bytes,uint256)"));\n', '\n', '    function getSelector(bytes4 genericSelector) public pure returns (bytes4);\n', '}\n', '\n', '/// @title Interface for all exchange handler contracts\n', 'contract ExchangeHandler is TotleControl, Withdrawable, Pausable {\n', '\n', '    /*\n', '    *   State Variables\n', '    */\n', '\n', '    SelectorProvider public selectorProvider;\n', '    ErrorReporter public errorReporter;\n', '    /* Logger public logger; */\n', '    /*\n', '    *   Modifiers\n', '    */\n', '\n', '    modifier onlySelf() {\n', '        require(msg.sender == address(this));\n', '        _;\n', '    }\n', '\n', '    /// @notice Constructor\n', '    /// @dev Calls the constructor of the inherited TotleControl\n', '    /// @param _selectorProvider the provider for this exchanges function selectors\n', '    /// @param totlePrimary the address of the totlePrimary contract\n', '    constructor(\n', '        address _selectorProvider,\n', '        address totlePrimary,\n', '        address _errorReporter\n', '        /* ,address _logger */\n', '    )\n', '        TotleControl(totlePrimary)\n', '        public\n', '    {\n', '        require(_selectorProvider != address(0x0));\n', '        require(_errorReporter != address(0x0));\n', '        /* require(_logger != address(0x0)); */\n', '        selectorProvider = SelectorProvider(_selectorProvider);\n', '        errorReporter = ErrorReporter(_errorReporter);\n', '        /* logger = Logger(_logger); */\n', '    }\n', '\n', '    /// @notice Gets the amount that Totle needs to give for this order\n', '    /// @param genericPayload the data for this order in a generic format\n', '    /// @return amountToGive amount taker needs to give in order to fill the order\n', '    function getAmountToGive(\n', '        bytes genericPayload\n', '    )\n', '        public\n', '        view\n', '        onlyTotle\n', '        whenNotPaused\n', '        returns (uint256 amountToGive)\n', '    {\n', '        bool success;\n', '        bytes4 functionSelector = selectorProvider.getSelector(this.getAmountToGive.selector);\n', '\n', '        assembly {\n', '            let functionSelectorLength := 0x04\n', '            let functionSelectorOffset := 0x1C\n', '            let scratchSpace := 0x0\n', '            let wordLength := 0x20\n', '            let bytesLength := mload(genericPayload)\n', '            let totalLength := add(functionSelectorLength, bytesLength)\n', '            let startOfNewData := add(genericPayload, functionSelectorOffset)\n', '\n', '            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\n', '            let functionSelectorCorrect := mload(scratchSpace)\n', '            mstore(genericPayload, functionSelectorCorrect)\n', '\n', '            success := call(\n', '                            gas,\n', '                            address, // This address of the current contract\n', '                            callvalue,\n', '                            startOfNewData, // Start data at the beginning of the functionSelector\n', '                            totalLength, // Total length of all data, including functionSelector\n', '                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\n', '                            wordLength // Length of return variable is one word\n', '                           )\n', '            amountToGive := mload(scratchSpace)\n', '            if eq(success, 0) { revert(0, 0) }\n', '        }\n', '    }\n', '\n', '    /// @notice Perform exchange-specific checks on the given order\n', '    /// @dev this should be called to check for payload errors\n', '    /// @param genericPayload the data for this order in a generic format\n', '    /// @return checksPassed value representing pass or fail\n', '    function staticExchangeChecks(\n', '        bytes genericPayload\n', '    )\n', '        public\n', '        view\n', '        onlyTotle\n', '        whenNotPaused\n', '        returns (bool checksPassed)\n', '    {\n', '        bool success;\n', '        bytes4 functionSelector = selectorProvider.getSelector(this.staticExchangeChecks.selector);\n', '        assembly {\n', '            let functionSelectorLength := 0x04\n', '            let functionSelectorOffset := 0x1C\n', '            let scratchSpace := 0x0\n', '            let wordLength := 0x20\n', '            let bytesLength := mload(genericPayload)\n', '            let totalLength := add(functionSelectorLength, bytesLength)\n', '            let startOfNewData := add(genericPayload, functionSelectorOffset)\n', '\n', '            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\n', '            let functionSelectorCorrect := mload(scratchSpace)\n', '            mstore(genericPayload, functionSelectorCorrect)\n', '\n', '            success := call(\n', '                            gas,\n', '                            address, // This address of the current contract\n', '                            callvalue,\n', '                            startOfNewData, // Start data at the beginning of the functionSelector\n', '                            totalLength, // Total length of all data, including functionSelector\n', '                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\n', '                            wordLength // Length of return variable is one word\n', '                           )\n', '            checksPassed := mload(scratchSpace)\n', '            if eq(success, 0) { revert(0, 0) }\n', '        }\n', '    }\n', '\n', '    /// @notice Perform a buy order at the exchange\n', '    /// @param genericPayload the data for this order in a generic format\n', '    /// @param  amountToGiveForOrder amount that should be spent on this order\n', '    /// @return amountSpentOnOrder the amount that would be spent on the order\n', '    /// @return amountReceivedFromOrder the amount that was received from this order\n', '    function performBuyOrder(\n', '        bytes genericPayload,\n', '        uint256 amountToGiveForOrder\n', '    )\n', '        public\n', '        payable\n', '        onlyTotle\n', '        whenNotPaused\n', '        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\n', '    {\n', '        bool success;\n', '        bytes4 functionSelector = selectorProvider.getSelector(this.performBuyOrder.selector);\n', '        assembly {\n', '            let callDataOffset := 0x44\n', '            let functionSelectorOffset := 0x1C\n', '            let functionSelectorLength := 0x04\n', '            let scratchSpace := 0x0\n', '            let wordLength := 0x20\n', '            let startOfFreeMemory := mload(0x40)\n', '\n', '            calldatacopy(startOfFreeMemory, callDataOffset, calldatasize)\n', '\n', '            let bytesLength := mload(startOfFreeMemory)\n', '            let totalLength := add(add(functionSelectorLength, bytesLength), wordLength)\n', '\n', '            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\n', '\n', '            let functionSelectorCorrect := mload(scratchSpace)\n', '\n', '            mstore(startOfFreeMemory, functionSelectorCorrect)\n', '\n', '            mstore(add(startOfFreeMemory, add(wordLength, bytesLength)), amountToGiveForOrder)\n', '\n', '            let startOfNewData := add(startOfFreeMemory,functionSelectorOffset)\n', '\n', '            success := call(\n', '                            gas,\n', '                            address, // This address of the current contract\n', '                            callvalue,\n', '                            startOfNewData, // Start data at the beginning of the functionSelector\n', '                            totalLength, // Total length of all data, including functionSelector\n', '                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\n', '                            mul(wordLength, 0x02) // Length of return variables is two words\n', '                          )\n', '            amountSpentOnOrder := mload(scratchSpace)\n', '            amountReceivedFromOrder := mload(add(scratchSpace, wordLength))\n', '            if eq(success, 0) { revert(0, 0) }\n', '        }\n', '    }\n', '\n', '    /// @notice Perform a sell order at the exchange\n', '    /// @param genericPayload the data for this order in a generic format\n', '    /// @param  amountToGiveForOrder amount that should be spent on this order\n', '    /// @return amountSpentOnOrder the amount that would be spent on the order\n', '    /// @return amountReceivedFromOrder the amount that was received from this order\n', '    function performSellOrder(\n', '        bytes genericPayload,\n', '        uint256 amountToGiveForOrder\n', '    )\n', '        public\n', '        onlyTotle\n', '        whenNotPaused\n', '        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\n', '    {\n', '        bool success;\n', '        bytes4 functionSelector = selectorProvider.getSelector(this.performSellOrder.selector);\n', '        assembly {\n', '            let callDataOffset := 0x44\n', '            let functionSelectorOffset := 0x1C\n', '            let functionSelectorLength := 0x04\n', '            let scratchSpace := 0x0\n', '            let wordLength := 0x20\n', '            let startOfFreeMemory := mload(0x40)\n', '\n', '            calldatacopy(startOfFreeMemory, callDataOffset, calldatasize)\n', '\n', '            let bytesLength := mload(startOfFreeMemory)\n', '            let totalLength := add(add(functionSelectorLength, bytesLength), wordLength)\n', '\n', '            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\n', '\n', '            let functionSelectorCorrect := mload(scratchSpace)\n', '\n', '            mstore(startOfFreeMemory, functionSelectorCorrect)\n', '\n', '            mstore(add(startOfFreeMemory, add(wordLength, bytesLength)), amountToGiveForOrder)\n', '\n', '            let startOfNewData := add(startOfFreeMemory,functionSelectorOffset)\n', '\n', '            success := call(\n', '                            gas,\n', '                            address, // This address of the current contract\n', '                            callvalue,\n', '                            startOfNewData, // Start data at the beginning of the functionSelector\n', '                            totalLength, // Total length of all data, including functionSelector\n', '                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\n', '                            mul(wordLength, 0x02) // Length of return variables is two words\n', '                          )\n', '            amountSpentOnOrder := mload(scratchSpace)\n', '            amountReceivedFromOrder := mload(add(scratchSpace, wordLength))\n', '            if eq(success, 0) { revert(0, 0) }\n', '        }\n', '    }\n', '}\n', '\n', '/*\n', '\n', '  Copyright 2018 ZeroEx Intl.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract LibEIP712 {\n', '\n', '    // EIP191 header for EIP712 prefix\n', '    string constant internal EIP191_HEADER = "\\x19\\x01";\n', '\n', '    // EIP712 Domain Name value\n', '    string constant internal EIP712_DOMAIN_NAME = "0x Protocol";\n', '\n', '    // EIP712 Domain Version value\n', '    string constant internal EIP712_DOMAIN_VERSION = "2";\n', '\n', '    // Hash of the EIP712 Domain Separator Schema\n', '    bytes32 constant internal EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n', '        "EIP712Domain(",\n', '        "string name,",\n', '        "string version,",\n', '        "address verifyingContract",\n', '        ")"\n', '    ));\n', '\n', '    // Hash of the EIP712 Domain Separator data\n', '    // solhint-disable-next-line var-name-mixedcase\n', '    bytes32 public EIP712_DOMAIN_HASH;\n', '\n', '    constructor ()\n', '        public\n', '    {\n', '        EIP712_DOMAIN_HASH = keccak256(abi.encodePacked(\n', '            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n', '            keccak256(bytes(EIP712_DOMAIN_NAME)),\n', '            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n', '            bytes32(address(this))\n', '        ));\n', '    }\n', '\n', '    /// @dev Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\n', '    /// @param hashStruct The EIP712 hash struct.\n', '    /// @return EIP712 hash applied to this EIP712 Domain.\n', '    function hashEIP712Message(bytes32 hashStruct)\n', '        internal\n', '        view\n', '        returns (bytes32 result)\n', '    {\n', '        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n', '\n', '        // Assembly for more efficient computing:\n', '        // keccak256(abi.encodePacked(\n', '        //     EIP191_HEADER,\n', '        //     EIP712_DOMAIN_HASH,\n', '        //     hashStruct\n', '        // ));\n', '\n', '        assembly {\n', '            // Load free memory pointer\n', '            let memPtr := mload(64)\n', '\n', '            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n', '            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n', '            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n', '\n', '            // Compute hash\n', '            result := keccak256(memPtr, 66)\n', '        }\n', '        return result;\n', '    }\n', '}\n', '\n', '/*\n', '\n', '  Copyright 2018 ZeroEx Intl.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'contract LibOrder is\n', '    LibEIP712\n', '{\n', '    // Hash for the EIP712 Order Schema\n', '    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(abi.encodePacked(\n', '        "Order(",\n', '        "address makerAddress,",\n', '        "address takerAddress,",\n', '        "address feeRecipientAddress,",\n', '        "address senderAddress,",\n', '        "uint256 makerAssetAmount,",\n', '        "uint256 takerAssetAmount,",\n', '        "uint256 makerFee,",\n', '        "uint256 takerFee,",\n', '        "uint256 expirationTimeSeconds,",\n', '        "uint256 salt,",\n', '        "bytes makerAssetData,",\n', '        "bytes takerAssetData",\n', '        ")"\n', '    ));\n', '\n', '    // A valid order remains fillable until it is expired, fully filled, or cancelled.\n', "    // An order's state is unaffected by external factors, like account balances.\n", '    enum OrderStatus {\n', '        INVALID,                     // Default value\n', '        INVALID_MAKER_ASSET_AMOUNT,  // Order does not have a valid maker asset amount\n', '        INVALID_TAKER_ASSET_AMOUNT,  // Order does not have a valid taker asset amount\n', '        FILLABLE,                    // Order is fillable\n', '        EXPIRED,                     // Order has already expired\n', '        FULLY_FILLED,                // Order is fully filled\n', '        CANCELLED                    // Order has been cancelled\n', '    }\n', '\n', '    // solhint-disable max-line-length\n', '    struct Order {\n', '        address makerAddress;           // Address that created the order.\n', '        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\n', '        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\n', '        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n', '        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\n', '        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\n', '        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\n', '        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\n', '        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\n', "        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\n", '        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\n', '        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\n', '    }\n', '    // solhint-enable max-line-length\n', '\n', '    struct OrderInfo {\n', "        uint8 orderStatus;                    // Status that describes order's validity and fillability.\n", '        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).\n', '        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\n', '    }\n', '\n', '    /// @dev Calculates Keccak-256 hash of the order.\n', '    /// @param order The order structure.\n', '    /// @return Keccak-256 EIP712 hash of the order.\n', '    function getOrderHash(Order memory order)\n', '        internal\n', '        view\n', '        returns (bytes32 orderHash)\n', '    {\n', '        orderHash = hashEIP712Message(hashOrder(order));\n', '        return orderHash;\n', '    }\n', '\n', '    /// @dev Calculates EIP712 hash of the order.\n', '    /// @param order The order structure.\n', '    /// @return EIP712 hash of the order.\n', '    function hashOrder(Order memory order)\n', '        internal\n', '        pure\n', '        returns (bytes32 result)\n', '    {\n', '        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n', '        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n', '        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n', '\n', '        // Assembly for more efficiently computing:\n', '        // keccak256(abi.encodePacked(\n', '        //     EIP712_ORDER_SCHEMA_HASH,\n', '        //     bytes32(order.makerAddress),\n', '        //     bytes32(order.takerAddress),\n', '        //     bytes32(order.feeRecipientAddress),\n', '        //     bytes32(order.senderAddress),\n', '        //     order.makerAssetAmount,\n', '        //     order.takerAssetAmount,\n', '        //     order.makerFee,\n', '        //     order.takerFee,\n', '        //     order.expirationTimeSeconds,\n', '        //     order.salt,\n', '        //     keccak256(order.makerAssetData),\n', '        //     keccak256(order.takerAssetData)\n', '        // ));\n', '\n', '        assembly {\n', '            // Calculate memory addresses that will be swapped out before hashing\n', '            let pos1 := sub(order, 32)\n', '            let pos2 := add(order, 320)\n', '            let pos3 := add(order, 352)\n', '\n', '            // Backup\n', '            let temp1 := mload(pos1)\n', '            let temp2 := mload(pos2)\n', '            let temp3 := mload(pos3)\n', '\n', '            // Hash in place\n', '            mstore(pos1, schemaHash)\n', '            mstore(pos2, makerAssetDataHash)\n', '            mstore(pos3, takerAssetDataHash)\n', '            result := keccak256(pos1, 416)\n', '\n', '            // Restore\n', '            mstore(pos1, temp1)\n', '            mstore(pos2, temp2)\n', '            mstore(pos3, temp3)\n', '        }\n', '        return result;\n', '    }\n', '}\n', '\n', '/*\n', '\n', '  Copyright 2018 ZeroEx Intl.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'contract LibFillResults\n', '{\n', '    struct FillResults {\n', '        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\n', '        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\n', '        uint256 makerFeePaid;            // Total amount of ZRX paid by maker(s) to feeRecipient(s).\n', '        uint256 takerFeePaid;            // Total amount of ZRX paid by taker to feeRecipients(s).\n', '    }\n', '\n', '    struct MatchedFillResults {\n', '        FillResults left;                    // Amounts filled and fees paid of left order.\n', '        FillResults right;                   // Amounts filled and fees paid of right order.\n', "        uint256 leftMakerAssetSpreadAmount;  // Spread between price of left and right order, denominated in the left order's makerAsset, paid to taker.\n", '    }\n', '\n', '    /// @dev Adds properties of both FillResults instances.\n', '    ///      Modifies the first FillResults instance specified.\n', '    /// @param totalFillResults Fill results instance that will be added onto.\n', '    /// @param singleFillResults Fill results instance that will be added to totalFillResults.\n', '    function addFillResults(FillResults memory totalFillResults, FillResults memory singleFillResults)\n', '        internal\n', '        pure\n', '    {\n', '        totalFillResults.makerAssetFilledAmount = SafeMath.add(totalFillResults.makerAssetFilledAmount, singleFillResults.makerAssetFilledAmount);\n', '        totalFillResults.takerAssetFilledAmount = SafeMath.add(totalFillResults.takerAssetFilledAmount, singleFillResults.takerAssetFilledAmount);\n', '        totalFillResults.makerFeePaid = SafeMath.add(totalFillResults.makerFeePaid, singleFillResults.makerFeePaid);\n', '        totalFillResults.takerFeePaid = SafeMath.add(totalFillResults.takerFeePaid, singleFillResults.takerFeePaid);\n', '    }\n', '}\n', '\n', 'contract IExchangeCore {\n', '\n', '    bytes public ZRX_ASSET_DATA;\n', '\n', '    /// @dev Fills the input order.\n', '    /// @param order Order struct containing order specifications.\n', '    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n', '    /// @param signature Proof that order has been created by maker.\n', '    /// @return Amounts filled and fees paid by maker and taker.\n', '    function fillOrder(\n', '        LibOrder.Order memory order,\n', '        uint256 takerAssetFillAmount,\n', '        bytes memory signature\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory fillResults);\n', '\n', '    function fillOrderNoThrow(\n', '        LibOrder.Order memory order,\n', '        uint256 takerAssetFillAmount,\n', '        bytes memory signature\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory fillResults);\n', '\n', '    /// @dev Gets information about an order: status, hash, and amount filled.\n', '    /// @param order Order to gather information on.\n', '    /// @return OrderInfo Information about the order and its state.\n', '    ///                   See LibOrder.OrderInfo for a complete description.\n', '    function getOrderInfo(LibOrder.Order memory order)\n', '        public\n', '        view\n', '        returns (LibOrder.OrderInfo memory orderInfo);\n', '\n', '    /// @dev Gets an asset proxy.\n', '    /// @param assetProxyId Id of the asset proxy.\n', '    /// @return The asset proxy registered to assetProxyId. Returns 0x0 if no proxy is registered.\n', '    function getAssetProxy(bytes4 assetProxyId)\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    function isValidSignature(\n', '        bytes32 hash,\n', '        address signerAddress,\n', '        bytes memory signature\n', '    )\n', '        public\n', '        view\n', '        returns (bool isValid);\n', '}\n', '\n', 'interface WETH {\n', '    function deposit() external payable;\n', '    function withdraw(uint256 amount) external;\n', '}\n', '\n', '/// @title ZeroExExchangeSelectorProvider\n', '/// @notice Provides this exchange implementation with correctly formatted function selectors\n', 'contract ZeroExExchangeSelectorProvider is SelectorProvider {\n', '    function getSelector(bytes4 genericSelector) public pure returns (bytes4) {\n', '        if (genericSelector == getAmountToGive) {\n', '            return bytes4(keccak256("getAmountToGive_((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes))"));\n', '        } else if (genericSelector == staticExchangeChecks) {\n', '            return bytes4(keccak256("staticExchangeChecks_((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes))"));\n', '        } else if (genericSelector == performBuyOrder) {\n', '            return bytes4(keccak256("performBuyOrder_((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes))"));\n', '        } else if (genericSelector == performSellOrder) {\n', '            return bytes4(keccak256("performSellOrder_((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes))"));\n', '        } else {\n', '            return bytes4(0x0);\n', '        }\n', '    }\n', '}\n', '\n', '// "((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes),bytes)"\n', '\n', '/// @title ZeroExExchangeHandler\n', '/// @notice Handles the all ZeroExExchange trades for the primary contract\n', 'contract ZeroExExchangeHandler is ExchangeHandler, AllowanceSetter  {\n', '\n', '    /*\n', '    *   State Variables\n', '    */\n', '\n', '    IExchangeCore public exchange;\n', '    /// @dev note that this is dependent on the deployment of 0xV2. This is the ERC20 asset proxy + the mainnet address of the ZRX token\n', '    bytes constant ZRX_ASSET_DATA = "\\xf4\\x72\\x61\\xb0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xe4\\x1d\\x24\\x89\\x57\\x1d\\x32\\x21\\x89\\x24\\x6d\\xaf\\xa5\\xeb\\xde\\x1f\\x46\\x99\\xf4\\x98";\n', '    address ERC20_ASSET_PROXY;\n', '    WETH weth;\n', '\n', '    /*\n', '    *   Types\n', '    */\n', '\n', '    /// @notice Constructor\n', '    /// @param _exchange Address of the IExchangeCore exchange\n', '    /// @param selectorProvider the provider for this exchanges function selectors\n', '    /// @param totlePrimary the address of the totlePrimary contract\n', '    constructor(\n', '        address _exchange,\n', '        address selectorProvider,\n', '        address totlePrimary,\n', '        address _weth,\n', '        address errorReporter\n', '        /* ,address logger */\n', '    )\n', '        ExchangeHandler(selectorProvider, totlePrimary, errorReporter/*, logger*/)\n', '        public\n', '    {\n', '        require(_exchange != address(0x0));\n', '        exchange = IExchangeCore(_exchange);\n', '        ERC20_ASSET_PROXY = exchange.getAssetProxy(toBytes4(ZRX_ASSET_DATA, 0));\n', '        weth = WETH(_weth);\n', '    }\n', '\n', '    struct OrderData {\n', '        address makerAddress;           // Address that created the order.\n', '        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\n', '        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\n', '        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n', '        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\n', '        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\n', '        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\n', '        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\n', '        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\n', "        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\n", '        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\n', '        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\n', '        bytes signature;\n', '    }\n', '\n', '    /*\n', '    *   Public functions\n', '    */\n', '\n', '    /*\n', '    *   Internal functions\n', '    */\n', '\n', '    /// @notice Gets the amount that Totle needs to give for this order\n', '    /// @param data LibOrder.Order struct containing order values\n', '    /// @return amountToGive amount taker needs to give in order to fill the order\n', '    function getAmountToGive_(\n', '        OrderData data\n', '    )\n', '      public\n', '      view\n', '      onlySelf\n', '      returns (uint256 amountToGive)\n', '    {\n', '        LibOrder.OrderInfo memory orderInfo = exchange.getOrderInfo(\n', '            getZeroExOrder(data)\n', '        );\n', '        uint makerAssetAvailable = getAssetDataAvailable(data.makerAssetData, data.makerAddress);\n', '        uint feeAssetAvailable = getAssetDataAvailable(ZRX_ASSET_DATA, data.makerAddress);\n', '\n', '        uint maxFromMakerFee = data.makerFee == 0 ? Utils.max_uint() : getPartialAmount(feeAssetAvailable, data.makerFee, data.takerAssetAmount);\n', '        amountToGive = Math.min(Math.min(\n', '            getPartialAmount(makerAssetAvailable, data.makerAssetAmount, data.takerAssetAmount),\n', '            maxFromMakerFee),\n', '            SafeMath.sub(data.takerAssetAmount, orderInfo.orderTakerAssetFilledAmount)\n', '        );\n', '        /* logger.log("Getting amountToGive from ZeroEx arg2: amountToGive", amountToGive); */\n', '    }\n', '\n', '    function getAssetDataAvailable(bytes assetData, address account) internal view returns (uint){\n', '        address tokenAddress = toAddress(assetData, 16);\n', '        ERC20 token = ERC20(tokenAddress);\n', '        return Math.min(token.balanceOf(account), token.allowance(account, ERC20_ASSET_PROXY));\n', '    }\n', '\n', '    function getZeroExOrder(OrderData data) internal pure returns (LibOrder.Order) {\n', '        return LibOrder.Order({\n', '            makerAddress: data.makerAddress,\n', '            takerAddress: data.takerAddress,\n', '            feeRecipientAddress: data.feeRecipientAddress,\n', '            senderAddress: data.senderAddress,\n', '            makerAssetAmount: data.makerAssetAmount,\n', '            takerAssetAmount: data.takerAssetAmount,\n', '            makerFee: data.makerFee,\n', '            takerFee: data.takerFee,\n', '            expirationTimeSeconds: data.expirationTimeSeconds,\n', '            salt: data.salt,\n', '            makerAssetData: data.makerAssetData,\n', '            takerAssetData: data.takerAssetData\n', '        });\n', '    }\n', '\n', '    /// @notice Perform exchange-specific checks on the given order\n', '    /// @dev This should be called to check for payload errors\n', '    /// @param data LibOrder.Order struct containing order values\n', '    /// @return checksPassed value representing pass or fail\n', '    function staticExchangeChecks_(\n', '        OrderData data\n', '    )\n', '        public\n', '        view\n', '        onlySelf\n', '        returns (bool checksPassed)\n', '    {\n', '\n', '        // Make sure that:\n', '        //  The order is not expired\n', '        //  Both the maker and taker assets are ERC20 tokens\n', "        //  The taker does not have to pay a fee (we don't support fees yet)\n", '        //  We are permitted to take this order\n', '        //  We are permitted to send this order\n', '        // TODO: Should we check signatures here?\n', '        return (block.timestamp <= data.expirationTimeSeconds &&\n', '                toBytes4(data.takerAssetData, 0) == bytes4(0xf47261b0) &&\n', '                toBytes4(data.makerAssetData, 0) == bytes4(0xf47261b0) &&\n', '                data.takerFee == 0 &&\n', '                (data.takerAddress == address(0x0) || data.takerAddress == address(this)) &&\n', '                (data.senderAddress == address(0x0) || data.senderAddress == address(this))\n', '        );\n', '    }\n', '\n', '    /// @notice Perform a buy order at the exchange\n', '    /// @param data LibOrder.Order struct containing order values\n', '    /// @return amountSpentOnOrder the amount that would be spent on the order\n', '    /// @return amountReceivedFromOrder the amount that was received from this order\n', '    function performBuyOrder_(\n', '        OrderData data\n', '    )\n', '        public\n', '        payable\n', '        onlySelf\n', '        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\n', '    {\n', '        uint256 amountToGiveForOrder = toUint(msg.data, msg.data.length - 32);\n', '\n', '        approveAddress(ERC20_ASSET_PROXY, toAddress(data.takerAssetData, 16));\n', '\n', '        weth.deposit.value(amountToGiveForOrder)();\n', '\n', '        LibFillResults.FillResults memory results = exchange.fillOrder(\n', '            getZeroExOrder(data),\n', '            amountToGiveForOrder,\n', '            data.signature\n', '        );\n', '        require(ERC20SafeTransfer.safeTransfer(toAddress(data.makerAssetData, 16), totlePrimary, results.makerAssetFilledAmount));\n', '\n', '        amountSpentOnOrder = results.takerAssetFilledAmount;\n', '        amountReceivedFromOrder = results.makerAssetFilledAmount;\n', '        /* logger.log("Performed buy order on ZeroEx arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder", amountSpentOnOrder, amountReceivedFromOrder); */\n', '    }\n', '\n', '    /// @notice Perform a sell order at the exchange\n', '    /// @param data LibOrder.Order struct containing order values\n', '    /// @return amountSpentOnOrder the amount that would be spent on the order\n', '    /// @return amountReceivedFromOrder the amount that was received from this order\n', '    function performSellOrder_(\n', '        OrderData data\n', '    )\n', '        public\n', '        onlySelf\n', '        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\n', '    {\n', '        uint256 amountToGiveForOrder = toUint(msg.data, msg.data.length - 32);\n', '        approveAddress(ERC20_ASSET_PROXY, toAddress(data.takerAssetData, 16));\n', '\n', '        LibFillResults.FillResults memory results = exchange.fillOrder(\n', '            getZeroExOrder(data),\n', '            amountToGiveForOrder,\n', '            data.signature\n', '        );\n', '\n', '        weth.withdraw(results.makerAssetFilledAmount);\n', '        totlePrimary.transfer(results.makerAssetFilledAmount);\n', '\n', '        amountSpentOnOrder = results.takerAssetFilledAmount;\n', '        amountReceivedFromOrder = results.makerAssetFilledAmount;\n', '        /* logger.log("Performed sell order on ZeroEx arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder", amountSpentOnOrder, amountReceivedFromOrder); */\n', '    }\n', '\n', '    /// @notice Calculate the result of ((numerator * target) / denominator)\n', '    /// @param numerator the numerator in the equation\n', '    /// @param denominator the denominator in the equation\n', '    /// @param target the target for the equations\n', '    /// @return partialAmount the resultant value\n', '    function getPartialAmount(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return SafeMath.div(SafeMath.mul(numerator, target), denominator);\n', '    }\n', '\n', '    // @notice Extract an address from a string of bytes\n', '    // @param _bytes a string of at least 20 bytes\n', '    // @param _start the offset of the address within the byte stream\n', '    // @return tempAddress the address encoded in the bytestring beginning at _start\n', '    function toAddress(bytes _bytes, uint _start) internal  pure returns (address) {\n', '        require(_bytes.length >= (_start + 20));\n', '        address tempAddress;\n', '\n', '        assembly {\n', '            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '\n', '    function toBytes4(bytes _bytes, uint _start) internal pure returns (bytes4) {\n', '        require(_bytes.length >= (_start + 4));\n', '        bytes4 tempBytes4;\n', '\n', '        assembly {\n', '            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '        return tempBytes4;\n', '    }\n', '\n', '    // @notice Extract a uint256 from a string of bytes\n', '    // @param _bytes a string of at least 32 bytes\n', '    // @param _start the offset of the uint256 within the byte stream\n', '    // @return tempUint the uint encoded in the bytestring beginning at _start\n', '    function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) {\n', '        require(_bytes.length >= (_start + 32));\n', '        uint256 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    /*\n', '    *   Payable fallback function\n', '    */\n', '\n', '    /// @notice payable fallback to allow the exchange to return ether directly to this contract\n', '    /// @dev note that only the exchange should be able to send ether to this contract\n', '    function() public payable {\n', '        require(msg.sender == address(weth) || msg.sender == totlePrimary);\n', '    }\n', '}']