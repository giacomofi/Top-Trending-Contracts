['contract BCFBaseCompetition {\n', '    address public owner;\n', '    address public referee;\n', '\n', '    bool public paused = false;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyReferee() {\n', '        require(msg.sender == referee);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '\n', '    function setReferee(address newReferee) public onlyOwner {\n', '        require(newReferee != address(0));\n', '        referee = newReferee;\n', '    }\n', '    \n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '    \n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '    \n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '    }\n', '    \n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '    }\n', '}\n', '\n', 'contract BCFMain {\n', '    function isOwnerOfAllPlayerCards(uint256[], address) public pure returns (bool) {}\n', '    function implementsERC721() public pure returns (bool) {}\n', '    function getPlayerForCard(uint) \n', '        external\n', '        pure\n', '        returns (\n', '        uint8,\n', '        uint8,\n', '        uint8,\n', '        uint8,\n', '        uint8,\n', '        uint8,\n', '        uint8,\n', '        uint8,\n', '        bytes,\n', '        string,\n', '        uint8\n', '    ) {}\n', '}\n', '\n', '// TODO: Validate that the user has sent the correct ENTRY_FEE and refund them if more, revert if less\n', '// TODO: Validate formation type\n', '// TODO: Validate that there&#39;s at least 1 goalkeeper?\n', '// TODO: Validate the team name is under a certain number of characters?\n', '// TODO: Do we need to copy these values across to the contract storage?\n', '// TODO: Should the frontend do the sorting and league tables? We still need the business logic to determine final positions, \n', '//       but we don&#39;t need to calculate this every round, not doing so would reduce gas consumption\n', '// TODO: Need to work out whether it&#39;s more gas effecient to read player info every round or store it once and have it?\n', 'contract BCFLeague is BCFBaseCompetition {\n', '    \n', '    struct Team {\n', '        address manager;\n', '        bytes name;\n', '        uint[] cardIds;\n', '        uint gkCardId;\n', '        uint8 wins;\n', '        uint8 losses;\n', '        uint8 draws;\n', '        uint16 goalsFor;\n', '        uint16 goalsAgainst;\n', '    }\n', '\n', '    struct Match {\n', '        uint8 homeTeamId;\n', '        uint8 awayTeamId;\n', '        uint[] homeScorerIds;\n', '        uint[] awayScorerIds;\n', '        bool isFinished;\n', '    }\n', '\n', '    // Configuration - this will be set in the constructor, hence not being constants\n', '    uint public TEAMS_TOTAL;\n', '    uint public ENTRY_FEE;\n', '    uint public SQUAD_SIZE;\n', '    uint public TOTAL_ROUNDS;\n', '    uint public MATCHES_PER_ROUND;\n', '    uint public SECONDS_BETWEEN_ROUNDS;\n', '\n', '    // Status\n', '    enum CompetitionStatuses { Upcoming, OpenForEntry, PendingStart, Started, Finished, Settled }\n', '    CompetitionStatuses public competitionStatus;\n', '    uint public startedAt;\n', '    uint public nextRoundStartsAt;\n', '    int public currentRoundId = -1; // As we may have a round 0 so we don&#39;t want to default there\n', '\n', '    // Local Data Lookups\n', '    Team[] public teams;\n', '    mapping(address => uint) internal managerToTeamId;\n', '    mapping(uint => bool) internal cardIdToEntryStatus;\n', '    mapping(uint => Match[]) internal roundIdToMatches;\n', '\n', '    // Data Source\n', '    BCFMain public mainContract;\n', '\n', '    // Prize Pool\n', '    uint public constant PRIZE_POT_PERCENTAGE_MAX = 10000; // 10,000 = 100% so we get 2 digits of precision, 375 = 3.75%\n', '    uint public prizePool; // Holds the total prize pool\n', '    uint[] public prizeBreakdown; // Max 10,000 across all indexes. Holds breakdown by index, e.g. [0] 5000 = 50%, [1] 3500 = 35%, [2] 1500 = 15%\n', '    address[] public winners; // Corresponding array of winners for the prize pot, [0] = first placed winner\n', '\n', '    function BCFLeague(address dataStoreAddress, uint teamsTotal, uint entryFee, uint squadSize, uint roundTimeSecs) public {\n', '        require(teamsTotal % 2 == 0); // We only allow an even number of teams, this reduces complexity\n', '        require(teamsTotal > 0);\n', '        require(roundTimeSecs > 30 seconds && roundTimeSecs < 60 minutes);\n', '        require(entryFee >= 0);\n', '        require(squadSize > 0);\n', '        \n', '        // Initial state\n', '        owner = msg.sender;\n', '        referee = msg.sender;\n', '        \n', '        // League configuration\n', '        TEAMS_TOTAL = teamsTotal;\n', '        ENTRY_FEE = entryFee;\n', '        SQUAD_SIZE = squadSize;\n', '        TOTAL_ROUNDS = TEAMS_TOTAL - 1;\n', '        MATCHES_PER_ROUND = TEAMS_TOTAL / 2;\n', '        SECONDS_BETWEEN_ROUNDS = roundTimeSecs;\n', '\n', '        // Always start it as an upcoming league\n', '        competitionStatus = CompetitionStatuses.Upcoming;\n', '\n', '        // Set the data source\n', '        BCFMain candidateDataStoreContract = BCFMain(dataStoreAddress);\n', '        require(candidateDataStoreContract.implementsERC721());\n', '        mainContract = candidateDataStoreContract;\n', '    }\n', '\n', '    // **Gas guzzler**\n', '    // CURRENT GAS CONSUMPTION: 6339356\n', '    function generateFixtures() external onlyOwner {\n', '        require(competitionStatus == CompetitionStatuses.Upcoming);\n', '\n', '        // Generate the fixtures using a cycling algorithm:\n', '        for (uint round = 0; round < TOTAL_ROUNDS; round++) {\n', '            for (uint matchIndex = 0; matchIndex < MATCHES_PER_ROUND; matchIndex++) {\n', '                uint home = (round + matchIndex) % (TEAMS_TOTAL - 1);\n', '                uint away = (TEAMS_TOTAL - 1 - matchIndex + round) % (TEAMS_TOTAL - 1);\n', '\n', '                if (matchIndex == 0) {\n', '                    away = TEAMS_TOTAL - 1;\n', '                }\n', '\n', '                 Match memory _match;\n', '                 _match.homeTeamId = uint8(home);\n', '                 _match.awayTeamId = uint8(away);\n', '\n', '                roundIdToMatches[round].push(_match);\n', '            }\n', '        }\n', '    }\n', '\n', '    function createPrizePool(uint[] prizeStructure) external payable onlyOwner {\n', '        require(competitionStatus == CompetitionStatuses.Upcoming);\n', '        require(msg.value > 0 && msg.value <= 2 ether); // Set some sensible top and bottom values\n', '        require(prizeStructure.length > 0); // Can&#39;t create a prize pool with no breakdown structure\n', '\n', '        uint allocationTotal = 0;\n', '        for (uint i = 0; i < prizeStructure.length; i++) {\n', '            allocationTotal += prizeStructure[i];\n', '        }\n', '\n', '        require(allocationTotal > 0 && allocationTotal <= PRIZE_POT_PERCENTAGE_MAX); // Make sure we don&#39;t allocate more than 100% of the prize pool or 0%\n', '        prizePool += msg.value;\n', '        prizeBreakdown = prizeStructure;\n', '    }\n', '\n', '    function openCompetition() external onlyOwner whenNotPaused {\n', '        competitionStatus = CompetitionStatuses.OpenForEntry;\n', '    }\n', '\n', '    function startCompetition() external onlyReferee whenNotPaused {\n', '        require(competitionStatus == CompetitionStatuses.PendingStart);\n', '\n', '        // Move the status into Started\n', '        competitionStatus = CompetitionStatuses.Started;\n', '        \n', '        // Mark the startedAt to now\n', '        startedAt = now;\n', '        nextRoundStartsAt = now + 60 seconds;\n', '    }\n', '\n', '    function calculateMatchOutcomesForRoundId(int roundId) external onlyReferee whenNotPaused {\n', '        require(competitionStatus == CompetitionStatuses.Started);\n', '        require(nextRoundStartsAt > 0);\n', '        require(roundId == currentRoundId + 1); // We&#39;re only allowed to process the next round, we can&#39;t skip ahead\n', '        require(now > nextRoundStartsAt);\n', '\n', '        // Increment the round counter\n', '        // We complete the below first as during the calculateScorersForTeamIds we go off to another contract to fetch the \n', '        // current player attributes so to avoid re-entrancy we bump this first \n', '        currentRoundId++;\n', '\n', '        // As the total rounds aren&#39;t index based we need to compare it to the index+1\n', '        // this should never overrun as the gas cost of generating a league with more 20 teams makes this impossible\n', '        if (TOTAL_ROUNDS == uint(currentRoundId + 1)) {\n', '            competitionStatus = CompetitionStatuses.Finished;\n', '        } else {\n', '            nextRoundStartsAt = now + SECONDS_BETWEEN_ROUNDS;\n', '        }\n', '\n', '        // Actually calculate some of the outcomes \n', '        Match[] memory matches = roundIdToMatches[uint(roundId)];\n', '        for (uint i = 0; i < matches.length; i++) {\n', '            Match memory _match = matches[i];\n', '            var (homeScorers, awayScorers) = calculateScorersForTeamIds(_match.homeTeamId, _match.awayTeamId);\n', '\n', '            // Adjust the table values\n', '            updateTeamsTableAttributes(_match.homeTeamId, homeScorers.length, _match.awayTeamId, awayScorers.length);\n', '\n', '            // Save the goal scorers for this match and mark as finished\n', '            roundIdToMatches[uint(roundId)][i].isFinished = true;\n', '            roundIdToMatches[uint(roundId)][i].homeScorerIds = homeScorers;\n', '            roundIdToMatches[uint(roundId)][i].awayScorerIds = awayScorers;\n', '        }\n', '    }\n', '\n', '    function updateTeamsTableAttributes(uint homeTeamId, uint homeGoals, uint awayTeamId, uint awayGoals) internal {\n', '\n', '        // GOALS FOR\n', '        teams[homeTeamId].goalsFor += uint16(homeGoals);\n', '        teams[awayTeamId].goalsFor += uint16(awayGoals);\n', '\n', '        // GOALS AGAINST\n', '        teams[homeTeamId].goalsAgainst += uint16(awayGoals);\n', '        teams[awayTeamId].goalsAgainst += uint16(homeGoals);\n', '\n', '        // WINS / LOSSES / DRAWS\n', '        if (homeGoals == awayGoals) {            \n', '            teams[homeTeamId].draws++;\n', '            teams[awayTeamId].draws++;\n', '        } else if (homeGoals > awayGoals) {\n', '            teams[homeTeamId].wins++;\n', '            teams[awayTeamId].losses++;\n', '        } else {\n', '            teams[awayTeamId].wins++;\n', '            teams[homeTeamId].losses++;\n', '        }\n', '    }\n', '\n', '    function getAllMatchesForRoundId(uint roundId) public view returns (uint[], uint[], bool[]) {\n', '        Match[] memory matches = roundIdToMatches[roundId];\n', '        \n', '        uint[] memory _homeTeamIds = new uint[](matches.length);\n', '        uint[] memory _awayTeamIds = new uint[](matches.length);\n', '        bool[] memory matchStates = new bool[](matches.length);\n', '\n', '        for (uint i = 0; i < matches.length; i++) {\n', '            _homeTeamIds[i] = matches[i].homeTeamId;\n', '            _awayTeamIds[i] = matches[i].awayTeamId;\n', '            matchStates[i] = matches[i].isFinished;\n', '        }\n', '\n', '        return (_homeTeamIds, _awayTeamIds, matchStates);\n', '    }\n', '\n', '    function getMatchAtRoundIdAtIndex(uint roundId, uint index) public view returns (uint, uint, uint[], uint[], bool) {\n', '        Match[] memory matches = roundIdToMatches[roundId];\n', '        Match memory _match = matches[index];\n', '        return (_match.homeTeamId, _match.awayTeamId, _match.homeScorerIds, _match.awayScorerIds, _match.isFinished);\n', '    }\n', '\n', '    function getPlayerCardIdsForTeam(uint teamId) public view returns (uint[]) {\n', '        Team memory _team = teams[teamId];\n', '        return _team.cardIds;\n', '    }\n', '\n', '    function enterLeague(uint[] cardIds, uint gkCardId, bytes teamName) public payable whenNotPaused {\n', '        require(mainContract != address(0)); // Must have a valid data store to check card ownership\n', '        require(competitionStatus == CompetitionStatuses.OpenForEntry); // Competition must be open for entry\n', '        require(cardIds.length == SQUAD_SIZE); // Require a valid number of players\n', '        require(teamName.length > 3 && teamName.length < 18); // Require a valid team name\n', '        require(!hasEntered(msg.sender)); // Make sure the address hasn&#39;t already entered\n', '        require(!hasPreviouslyEnteredCardIds(cardIds)); // Require that none of the players have previously entered, avoiding managers swapping players between accounts\n', '        require(mainContract.isOwnerOfAllPlayerCards(cardIds, msg.sender)); // User must actually own these cards\n', '        require(teams.length < TEAMS_TOTAL); // We shouldn&#39;t ever hit this as the state should be managed, but just as a fallback\n', '        require(msg.value >= ENTRY_FEE); // User must have paid a valid entry fee\n', '\n', '        // Create a team and hold the teamId\n', '        Team memory _team;\n', '        _team.name = teamName;\n', '        _team.manager = msg.sender;\n', '        _team.cardIds = cardIds;\n', '        _team.gkCardId = gkCardId;\n', '        uint teamId = teams.push(_team) - 1;\n', '\n', '        // Keep track of who the manager is managing\n', '        managerToTeamId[msg.sender] = teamId;\n', '\n', '        // Track which team each card plays for\n', '        for (uint i = 0; i < cardIds.length; i++) {\n', '            cardIdToEntryStatus[cardIds[i]] = true;\n', '        }\n', '\n', '        // If we&#39;ve hit the team limit we can move the contract into the PendingStart status\n', '        if (teams.length == TEAMS_TOTAL) {\n', '            competitionStatus = CompetitionStatuses.PendingStart;\n', '        }\n', '    }\n', '\n', '    function hasPreviouslyEnteredCardIds(uint[] cardIds) view internal returns (bool) {\n', '        if (teams.length == 0) {\n', '            return false;\n', '        }\n', '\n', '        // This should only ever be a maximum of 5 iterations or 11\n', '        for (uint i = 0; i < cardIds.length; i++) {\n', '            uint cardId = cardIds[i];\n', '            bool hasEnteredCardPreviously = cardIdToEntryStatus[cardId];\n', '            if (hasEnteredCardPreviously) {\n', '                return true;\n', '            }\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function hasEntered(address manager) view internal returns (bool) {\n', '        if (teams.length == 0) {\n', '            return false;\n', '        }\n', '\n', '        // We have to lookup the team AND check the fields because of some of the workings of solidity\n', '        // 1. We could have a team at index 0, so we CAN&#39;T just check the index is > 0\n', '        // 2. Solidity intializes with an empty set of struct values, so we need to do equality on the manager field\n', '        uint teamIndex = managerToTeamId[manager];\n', '        Team memory team = teams[teamIndex];\n', '        if (team.manager == manager) {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function setMainContract(address _address) external onlyOwner {\n', '        BCFMain candidateContract = BCFMain(_address);\n', '        require(candidateContract.implementsERC721());\n', '        mainContract = candidateContract;\n', '    }\n', '\n', '    // ** Match Simulator **\n', '    function calculateScorersForTeamIds(uint homeTeamId, uint awayTeamId) internal view returns (uint[], uint[]) {\n', '        \n', '        var (homeTotals, homeCardsShootingAttributes) = calculateAttributeTotals(homeTeamId);\n', '        var (awayTotals, awayCardsShootingAttributes) = calculateAttributeTotals(awayTeamId); \n', '        \n', '        uint startSeed = now;\n', '        var (homeGoals, awayGoals) = calculateGoalsFromAttributeTotals(homeTeamId, awayTeamId, homeTotals, awayTotals, startSeed);\n', '\n', '        uint[] memory homeScorers = new uint[](homeGoals);\n', '        uint[] memory awayScorers = new uint[](awayGoals);\n', '\n', '        // Home Scorers\n', '        for (uint i = 0; i < homeScorers.length; i++) {\n', '            homeScorers[i] = determineGoalScoringCardIds(teams[homeTeamId].cardIds, homeCardsShootingAttributes, i);\n', '        }\n', '\n', '        // Away Scorers\n', '        for (i = 0; i < awayScorers.length; i++) {\n', '            awayScorers[i] = determineGoalScoringCardIds(teams[awayTeamId].cardIds, awayCardsShootingAttributes, i);\n', '        }\n', '\n', '        return (homeScorers, awayScorers);\n', '    }\n', '\n', '    function calculateGoalsFromAttributeTotals(uint homeTeamId, uint awayTeamId, uint[] homeTotals, uint[] awayTotals, uint startSeed) internal view returns (uint _homeGoals, uint _awayGoals) {\n', '\n', '        uint[] memory atkAttributes = new uint[](3); // 0 = possession, 1 = chance, 2 = shooting\n', '        uint[] memory defAttributes = new uint[](3); // 0 = regain posession, 1 = prevent chance, 3 = save shot\n', '\n', '        uint attackingTeamId = 0;\n', '        uint defendingTeamId = 0;\n', '        uint outcome = 0;\n', '        uint seed = startSeed * homeTotals[0] * awayTotals[0];\n', '\n', '        for (uint i = 0; i < 45; i++) {\n', '            \n', '            attackingTeamId = determineAttackingOrDefendingOutcomeForAttributes(homeTeamId, awayTeamId, homeTotals[0], awayTotals[0], seed+now);\n', '            seed++;\n', '\n', '            if (attackingTeamId == homeTeamId) {\n', '                defendingTeamId = awayTeamId;\n', '                atkAttributes[0] = homeTotals[3]; // Passing\n', '                atkAttributes[1] = homeTotals[4]; // Dribbling\n', '                atkAttributes[2] = homeTotals[2]; // Shooting\n', '                defAttributes[0] = awayTotals[1]; // Pace\n', '                defAttributes[1] = awayTotals[6]; // Physical\n', '                defAttributes[2] = awayTotals[5]; // Defending\n', '            } else {\n', '                defendingTeamId = homeTeamId;\n', '                atkAttributes[0] = awayTotals[3]; // Passing\n', '                atkAttributes[1] = awayTotals[4]; // Dribbling\n', '                atkAttributes[2] = awayTotals[2]; // Shooting\n', '                defAttributes[0] = homeTotals[1]; // Pace\n', '                defAttributes[1] = homeTotals[6]; // Physical\n', '                defAttributes[2] = homeTotals[5]; // Defending\n', '            }\n', '\n', '            outcome = determineAttackingOrDefendingOutcomeForAttributes(attackingTeamId, defendingTeamId, atkAttributes[0], defAttributes[0], seed);\n', '\t\t\tif (outcome == defendingTeamId) {\n', '                // Attack broken up\n', '\t\t\t\tcontinue;\n', '\t\t\t}\n', '            seed++;\n', '\n', '            outcome = determineAttackingOrDefendingOutcomeForAttributes(attackingTeamId, defendingTeamId, atkAttributes[1], defAttributes[1], seed);\n', '\t\t\tif (outcome == defendingTeamId) {\n', '                // Chance prevented\n', '\t\t\t\tcontinue;\n', '\t\t\t}\n', '            seed++;\n', '\n', '            outcome = determineAttackingOrDefendingOutcomeForAttributes(attackingTeamId, defendingTeamId, atkAttributes[2], defAttributes[2], seed);\n', '\t\t\tif (outcome == defendingTeamId) {\n', '                // Shot saved\n', '\t\t\t\tcontinue;\n', '\t\t\t}\n', '\n', '            // GOAL - determine whether it was the home team who scored or the away team\n', '            if (attackingTeamId == homeTeamId) {\n', '                // Home goal\n', '                _homeGoals += 1;\n', '            } else {\n', '                // Away goal\n', '                _awayGoals += 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    function calculateAttributeTotals(uint teamId) internal view returns (uint[], uint[]) {\n', '        \n', '        // NOTE: We store these in an array because of stack too deep errors from Solidity, \n', '        // We could seperate these out but in the end it will end up being uniweildly\n', '        // this is the case in subsquent arrays too, while not perfect does give us a bit more flexibility\n', '        uint[] memory totals = new uint[](7);\n', '        uint[] memory cardsShootingAttributes = new uint[](SQUAD_SIZE);\n', '        Team memory _team = teams[teamId];\n', '        \n', '        for (uint i = 0; i < SQUAD_SIZE; i++) {\n', '            var (overall,pace,shooting,passing,dribbling,defending,physical,,,,) = mainContract.getPlayerForCard(_team.cardIds[i]);\n', '\n', '            // If it&#39;s a goalie we forego attack for increased shot stopping avbility\n', '            if (_team.cardIds[i] == _team.gkCardId && _team.gkCardId > 0) {\n', '                totals[5] += (overall * 5);\n', '                totals[6] += overall;\n', '                cardsShootingAttributes[i] = 1; // Almost no chance for the GK to score\n', '            } else {\n', '                totals[0] += overall;\n', '                totals[1] += pace;\n', '                totals[2] += shooting;\n', '                totals[3] += passing;\n', '                totals[4] += dribbling;\n', '                totals[5] += defending;\n', '                totals[6] += physical;\n', '\n', '                cardsShootingAttributes[i] = shooting + dribbling; // Chance to score by combining shooting and dribbling\n', '            }\n', '        }\n', '\n', '        return (totals, cardsShootingAttributes);\n', '    }\n', '\n', '    function determineAttackingOrDefendingOutcomeForAttributes(uint attackingTeamId, uint defendingTeamId, uint atkAttributeTotal, uint defAttributeTotal, uint seed) internal view returns (uint) {\n', '        \n', '        uint max = atkAttributeTotal + defAttributeTotal;\n', '        uint randValue = uint(keccak256(block.blockhash(block.number-1), seed))%max;\n', '\n', '        if (randValue <= atkAttributeTotal) {\n', '\t\t    return attackingTeamId;\n', '\t    }\n', '\n', '\t    return defendingTeamId;\n', '    }\n', '\n', '    function determineGoalScoringCardIds(uint[] cardIds, uint[] shootingAttributes, uint seed) internal view returns(uint) {\n', '\n', '        uint max = 0;\n', '        uint min = 0;\n', '        for (uint i = 0; i < shootingAttributes.length; i++) {\n', '            max += shootingAttributes[i];\n', '        }\n', '\n', '        bytes32 randHash = keccak256(seed, now, block.blockhash(block.number - 1));\n', '        uint randValue = uint(randHash) % max + min;\n', '\n', '        for (i = 0; i < cardIds.length; i++) {\n', '            uint cardId = cardIds[i];\n', '            randValue -= shootingAttributes[i];\n', '\n', '            // We do the more than to handle wrap arounds on uint\n', '            if (randValue <= 0 || randValue >= max) {\n', '                return cardId;\n', '            }\n', '        }\n', '\n', '        return cardIds[0];\n', '    }\n', '\n', '    // ** Settlement **\n', '    function calculateWinningEntries() external onlyReferee {\n', '        require(competitionStatus == CompetitionStatuses.Finished);\n', '\n', '        address[] memory winningAddresses = new address[](prizeBreakdown.length);\n', '        uint[] memory winningTeamIds = new uint[](prizeBreakdown.length);\n', '        uint[] memory winningTeamPoints = new uint[](prizeBreakdown.length);\n', '\n', '        // League table position priority\n', '        // 1. Most Points\n', '        // 2. Biggest Goal Difference\n', '        // 3. Most Goals Scored\n', '        // 4. Number of Wins\n', '        // 5. First to Enter\n', '\n', '        // 1. Loop over all teams\n', '        bool isReplacementWinner = false;\n', '        for (uint i = 0; i < teams.length; i++) {\n', '            Team memory _team = teams[i];\n', '\n', '            // 2. Grab their current points\n', '            uint currPoints = (_team.wins * 3) + _team.draws;\n', '\n', '            // 3. Compare the points to each team in the winning team points array\n', '            for (uint x = 0; x < winningTeamPoints.length; x++) {\n', '                \n', '                // 4. Check if the current entry is more\n', '                isReplacementWinner = false;\n', '                if (currPoints > winningTeamPoints[x]) {\n', '                    isReplacementWinner = true;\n', '                // 5. We need to handle tie-break rules if 2 teams have the same number of points\n', '                } else if (currPoints == winningTeamPoints[x]) {\n', '                    \n', '                    // 5a. Unfortunately in this scenario we need to refetch the team we&#39;re comparing\n', '                    Team memory _comparisonTeam = teams[winningTeamIds[x]];\n', '\n', '                    int gdTeam = _team.goalsFor - _team.goalsAgainst;\n', '                    int gdComparedTeam = _comparisonTeam.goalsFor - _comparisonTeam.goalsAgainst;\n', '\n', '                    // 5b. GOAL DIFFERENCE\n', '                    if (gdTeam > gdComparedTeam) {\n', '                        isReplacementWinner = true;\n', '                    } else if (gdTeam == gdComparedTeam) {\n', '\n', '                        // 5c. MOST GOALS\n', '                        if (_team.goalsFor > _comparisonTeam.goalsFor) {\n', '                            isReplacementWinner = true;\n', '                        } else if (_team.goalsFor == _comparisonTeam.goalsFor) {\n', '\n', '                            // 5d. NUMBER OF WINS\n', '                            if (_team.wins > _comparisonTeam.wins) {\n', '                                isReplacementWinner = true;\n', '                            } else if (_team.wins == _comparisonTeam.wins) {\n', '\n', '                                // 5e. FIRST TO ENTER (LOWER INDEX)\n', '                                if (i < winningTeamIds[x]) {\n', '                                    isReplacementWinner = true;\n', '                                }\n', '                            }\n', '                        }\n', '                    }\n', '                }\n', '\n', '                // 6. Now we need to shift all elements down for the "paid places" for winning entries\n', '                if (isReplacementWinner) {\n', '                    \n', '                    // 7. We need to start by copying the current index into next one down, assuming it exists\n', '                    for (uint y = winningAddresses.length - 1; y > x; y--) {\n', '                        winningAddresses[y] = winningAddresses[y-1];\n', '                        winningTeamPoints[y] = winningTeamPoints[y-1];\n', '                        winningTeamIds[y] = winningTeamIds[y-1];\n', '                    }\n', '                    \n', '                    // 8. Set the current team and points as a replacemenet for the current entry\n', '                    winningAddresses[x] = _team.manager;\n', '                    winningTeamPoints[x] = currPoints;\n', '                    winningTeamIds[x] = i;\n', '                    break; // We don&#39;t need to compare values further down the chain\n', '                }\n', '            }\n', '        }\n', '\n', '        // Set the winning entries\n', '        winners = winningAddresses;\n', '    }\n', '\n', '    function settleLeague() external onlyOwner {\n', '        require(competitionStatus == CompetitionStatuses.Finished);\n', '        require(winners.length > 0);\n', '        require(prizeBreakdown.length == winners.length);\n', '        require(prizePool >= this.balance);\n', '\n', '        // Mark the contest as settled\n', '        competitionStatus = CompetitionStatuses.Settled;\n', '        \n', '        // Payout each winner\n', '        for (uint i = 0; i < winners.length; i++) {\n', '            address winner = winners[i];\n', '            uint percentageCut = prizeBreakdown[i]; // We can assume this index exists as we&#39;ve checked the lengths in the require\n', '\n', '            uint winningAmount = calculateWinnerCut(prizePool, percentageCut);\n', '            winner.transfer(winningAmount);\n', '        }\n', '    }\n', '\n', '    function calculateWinnerCut(uint totalPot, uint cut) internal pure returns (uint256) {\n', '        // PRIZE_POT_PERCENTAGE_MAX = 10,000 = 100%, required&#39;d <= PRIZE_POT_PERCENTAGE_MAX in the constructor so no requirement to validate here\n', '        uint finalCut = totalPot * cut / PRIZE_POT_PERCENTAGE_MAX;\n', '        return finalCut;\n', '    }  \n', '\n', '    function withdrawBalance() external onlyOwner {\n', '        owner.transfer(this.balance);\n', '    }\n', '\n', '    // Utils\n', '    function hasStarted() external view returns (bool) {\n', '        if (competitionStatus == CompetitionStatuses.Upcoming || competitionStatus == CompetitionStatuses.OpenForEntry || competitionStatus == CompetitionStatuses.PendingStart) {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function winningTeamId() external view returns (uint) {\n', '        require(competitionStatus == CompetitionStatuses.Finished || competitionStatus == CompetitionStatuses.Settled);\n', '\n', '        uint winningTeamId = 0;\n', '        for (uint i = 0; i < teams.length; i++) {\n', '            if (teams[i].manager == winners[0]) {\n', '                winningTeamId = i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        return winningTeamId;\n', '    }\n', '}']