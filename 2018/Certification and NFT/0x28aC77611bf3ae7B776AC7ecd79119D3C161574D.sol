['pragma solidity ^0.4.18;\n', '\n', 'contract CrowdsaleParameters {\n', '    ///////////////////////////////////////////////////////////////////////////\n', '    // Production Config\n', '    ///////////////////////////////////////////////////////////////////////////\n', '\n', '    // ICO period timestamps:\n', '    // 1524182400 = April 20, 2018.\n', '    // 1529452800 = June 20, 2018.\n', '\n', '    uint256 public constant generalSaleStartDate = 1524182400;\n', '    uint256 public constant generalSaleEndDate = 1529452800;\n', '\n', '    ///////////////////////////////////////////////////////////////////////////\n', '    // QA Config\n', '    ///////////////////////////////////////////////////////////////////////////\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////////////\n', '    // Configuration Independent Parameters\n', '    ///////////////////////////////////////////////////////////////////////////\n', '\n', '    struct AddressTokenAllocation {\n', '        address addr;\n', '        uint256 amount;\n', '    }\n', '\n', '    AddressTokenAllocation internal generalSaleWallet = AddressTokenAllocation(0x5aCdaeF4fa410F38bC26003d0F441d99BB19265A, 22800000);\n', '    AddressTokenAllocation internal bounty = AddressTokenAllocation(0xc1C77Ff863bdE913DD53fD6cfE2c68Dfd5AE4f7F, 2000000);\n', '    AddressTokenAllocation internal partners = AddressTokenAllocation(0x307744026f34015111B04ea4D3A8dB9FdA2650bb, 3200000);\n', '    AddressTokenAllocation internal team = AddressTokenAllocation(0xCC4271d219a2c33a92aAcB4C8D010e9FBf664D1c, 12000000);\n', '    AddressTokenAllocation internal featureDevelopment = AddressTokenAllocation(0x06281A31e1FfaC1d3877b29150bdBE93073E043B, 0);\n', '}\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    *  Constructor\n', '    *\n', '    *  Sets contract owner to address of constructor caller\n', '    */\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    *  Change Owner\n', '    *\n', '    *  Changes ownership of this contract. Only owner can call this method.\n', '    *\n', '    * @param newOwner - new owner&#39;s address\n', '    */\n', '    function changeOwner(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        require(newOwner != owner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract SBIToken is Owned, CrowdsaleParameters {\n', '    using SafeMath for uint256;\n', '    /* Public variables of the token */\n', '    string public standard = &#39;ERC20/SBI&#39;;\n', '    string public name = &#39;Subsoil Blockchain Investitions&#39;;\n', '    string public symbol = &#39;SBI&#39;;\n', '    uint8 public decimals = 18;\n', '\n', '    /* Arrays of all balances */\n', '    mapping (address => uint256) private balances;\n', '    mapping (address => mapping (address => uint256)) private allowed;\n', '    mapping (address => mapping (address => bool)) private allowanceUsed;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    event Issuance(uint256 _amount); // triggered when the total supply is increased\n', '    event Destruction(uint256 _amount); // triggered when the total supply is decreased\n', '\n', '    event NewSBIToken(address _token);\n', '\n', '    /* Miscellaneous */\n', '    uint256 public totalSupply = 0; // 40000000;\n', '    bool public transfersEnabled = true;\n', '\n', '    /**\n', '    *  Constructor\n', '    *\n', '    *  Initializes contract with initial supply tokens to the creator of the contract\n', '    */\n', '\n', '    function SBIToken() public {\n', '        owner = msg.sender;\n', '        mintToken(generalSaleWallet);\n', '        mintToken(bounty);\n', '        mintToken(partners);\n', '        mintToken(team);\n', '        NewSBIToken(address(this));\n', '    }\n', '\n', '    modifier transfersAllowed {\n', '        require(transfersEnabled);\n', '        _;\n', '    }\n', '\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    *  1. Associate crowdsale contract address with this Token\n', '    *  2. Allocate general sale amount\n', '    *\n', '    * @param _crowdsaleAddress - crowdsale contract address\n', '    */\n', '    function approveCrowdsale(address _crowdsaleAddress) external onlyOwner {\n', '        approveAllocation(generalSaleWallet, _crowdsaleAddress);\n', '    }\n', '\n', '    function approveAllocation(AddressTokenAllocation tokenAllocation, address _crowdsaleAddress) internal {\n', '        uint uintDecimals = decimals;\n', '        uint exponent = 10**uintDecimals;\n', '        uint amount = tokenAllocation.amount * exponent;\n', '\n', '        allowed[tokenAllocation.addr][_crowdsaleAddress] = amount;\n', '        Approval(tokenAllocation.addr, _crowdsaleAddress, amount);\n', '    }\n', '\n', '    /**\n', '    *  Get token balance of an address\n', '    *\n', '    * @param _address - address to query\n', '    * @return Token balance of _address\n', '    */\n', '    function balanceOf(address _address) public constant returns (uint256 balance) {\n', '        return balances[_address];\n', '    }\n', '\n', '    /**\n', '    *  Get token amount allocated for a transaction from _owner to _spender addresses\n', '    *\n', '    * @param _owner - owner address, i.e. address to transfer from\n', '    * @param _spender - spender address, i.e. address to transfer to\n', '    * @return Remaining amount allowed to be transferred\n', '    */\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '    *  Send coins from sender&#39;s address to address specified in parameters\n', '    *\n', '    * @param _to - address to send to\n', '    * @param _value - amount to send in Wei\n', '    */\n', '\n', '    function transfer(address _to, uint256 _value) public transfersAllowed onlyPayloadSize(2*32) returns (bool success) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    *  Create token and credit it to target address\n', '    *  Created tokens need to vest\n', '    *\n', '    */\n', '    function mintToken(AddressTokenAllocation tokenAllocation) internal {\n', '\n', '        uint uintDecimals = decimals;\n', '        uint exponent = 10**uintDecimals;\n', '        uint mintedAmount = tokenAllocation.amount * exponent;\n', '\n', '        // Mint happens right here: Balance becomes non-zero from zero\n', '        balances[tokenAllocation.addr] += mintedAmount;\n', '        totalSupply += mintedAmount;\n', '\n', '        // Emit Issue and Transfer events\n', '        Issuance(mintedAmount);\n', '        Transfer(address(this), tokenAllocation.addr, mintedAmount);\n', '    }\n', '\n', '    /**\n', '    *  Allow another contract to spend some tokens on your behalf\n', '    *\n', '    * @param _spender - address to allocate tokens for\n', '    * @param _value - number of tokens to allocate\n', '    * @return True in case of success, otherwise false\n', '    */\n', '    function approve(address _spender, uint256 _value) public onlyPayloadSize(2*32) returns (bool success) {\n', '        require(_value == 0 || allowanceUsed[msg.sender][_spender] == false);\n', '        allowed[msg.sender][_spender] = _value;\n', '        allowanceUsed[msg.sender][_spender] = false;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    *  A contract attempts to get the coins. Tokens should be previously allocated\n', '    *\n', '    * @param _to - address to transfer tokens to\n', '    * @param _from - address to transfer tokens from\n', '    * @param _value - number of tokens to transfer\n', '    * @return True in case of success, otherwise false\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed onlyPayloadSize(3*32) returns (bool success) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    *  Default method\n', '    *\n', '    *  This unnamed function is called whenever someone tries to send ether to\n', '    *  it. Just revert transaction because there is nothing that Token can do\n', '    *  with incoming ether.\n', '    *\n', '    *  Missing payable modifier prevents accidental sending of ether\n', '    */\n', '    function() public {}\n', '\n', '    /**\n', '    *  Enable or disable transfers\n', '    *\n', '    * @param _enable - True = enable, False = disable\n', '    */\n', '    function toggleTransfers(bool _enable) external onlyOwner {\n', '        transfersEnabled = _enable;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SBIBank\n', ' * @dev Bank contract that supports voting to withdraw money, cancel or refund\n', ' * multiple payees claiming funds sent to this contract\n', ' * according to the sbi tokens proportions they own and result of voting.\n', ' */\n', '\n', 'contract SBIBank is Owned, CrowdsaleParameters {\n', '    using SafeMath for uint256;\n', '    string public name = &#39;Subsoil Blockchain Investitions Bank&#39;;\n', '    SBIToken private token;\n', '    uint256 public currentVotingDate = 0;\n', '    uint public currentVotingAmount = 0;\n', '    uint public allowedWithdraw = 0;\n', '    uint public allowedRefund = 0;\n', '\n', '    uint256 public toAllow = 0;\n', '    uint256 public toCancel = 0;\n', '    uint256 public toRefund = 0;\n', '\n', '    // result of a voiting\n', '    uint8 result = 0;\n', '\n', '    address sbiBank = this;\n', '\n', '    // investors votes\n', '    mapping(address => uint8) public votes;\n', '    // investors votes dates\n', '    mapping(address => uint256) public voteDates;\n', '    // investors refunded amounts of voting\n', '    mapping(address => uint256) public alreadyRefunded;\n', '\n', '    event NewIncomingFunds(uint indexed amount, address indexed sender);\n', '    event NewVoting(uint256 indexed date, uint indexed amount);\n', '    event NewVote(address indexed voter, uint256 indexed date, uint8 indexed proposal);\n', '    event CancelVote(uint256 indexed date, uint indexed amount);\n', '    event AllowVote(uint256 indexed date, uint indexed amount);\n', '    event RefundVote(uint256 indexed date, uint indexed amount);\n', '    event Refund(uint256 indexed date, uint256 indexed amount, address indexed investor);\n', '    event Withdraw(uint256 indexed date, uint indexed amount);\n', '  /**\n', '   * @dev Constructor\n', '   */\n', '  function SBIBank(address _tokenAddress) public payable {\n', '     token = SBIToken(_tokenAddress);\n', '  }\n', '\n', '  /**\n', '   * @dev Start a new voting.\n', '   * @param _amount The amount of the funds requested to transfer.\n', '   */\n', '  function addVoting(uint _amount) public onlyOwner {\n', '    require(sbiBank.balance >= _amount);\n', '    // can add only if previouse voiting closed\n', '    require(currentVotingDate == 0 && currentVotingAmount == 0);\n', '    currentVotingDate = now;\n', '    currentVotingAmount = _amount;\n', '    NewVoting(now, _amount);\n', '  }\n', '  /*\n', '    returns current vote of investor\n', '  */\n', '  function voteOf(address voter) public constant returns (uint8 vote) {\n', '    return votes[voter];\n', '  }\n', '\n', '   /**\n', '   * @dev vote for only sbi tokens owners\n', '   */\n', '  function vote(uint8 proposal) public returns(uint8 prop) {\n', '      require(token.balanceOf(msg.sender) > 0);\n', '      require(now >= currentVotingDate && now <= currentVotingDate + 3 days);\n', '      require(proposal == 1 || proposal == 2 || proposal == 3);\n', '      // you can vote only once for current voiting\n', '      require(voteDates[msg.sender] != currentVotingDate);\n', '\n', '      alreadyRefunded[msg.sender] = 0;\n', '      votes[msg.sender] = proposal;\n', '      voteDates[msg.sender] = currentVotingDate;\n', '\n', '      if(proposal == 1) {\n', '          toAllow = toAllow + token.balanceOf(msg.sender);\n', '      }\n', '      if(proposal == 2) {\n', '          toCancel = toCancel + token.balanceOf(msg.sender);\n', '      }\n', '      if(proposal == 3) {\n', '          toRefund = toRefund + token.balanceOf(msg.sender);\n', '      }\n', '      NewVote(msg.sender, now, proposal);\n', '      return proposal;\n', '  }\n', '\n', '  /**\n', '   * @dev End current voting with 3 scenarios - toAllow, toCancel or toRefund\n', '   */\n', '  function endVoting() public onlyOwner {\n', '      require(currentVotingDate > 0 && now >= currentVotingDate + 3 days);\n', '      if (toAllow > toCancel && toAllow > toRefund) {\n', '          // toAllow withdraw\n', '          AllowVote(currentVotingDate, toAllow);\n', '          allowedWithdraw = currentVotingAmount;\n', '          allowedRefund = 0;\n', '      }\n', '      if (toCancel > toAllow && toCancel > toRefund) {\n', '          // toCancel voiting\n', '          CancelVote(currentVotingDate, toCancel);\n', '          allowedWithdraw = 0;\n', '          allowedRefund = 0;\n', '      }\n', '      if (toRefund > toAllow && toRefund > toCancel) {\n', '          // toCancel voiting\n', '          RefundVote(currentVotingDate, toRefund);\n', '          allowedRefund = currentVotingAmount;\n', '          allowedWithdraw = 0;\n', '      }\n', '      currentVotingDate = 0;\n', '      currentVotingAmount = 0;\n', '      toAllow = 0;\n', '      toCancel = 0;\n', '      toRefund = 0;\n', '  }\n', '\n', '  /**\n', '   * @dev Withdraw the current voiting amount\n', '   */\n', '  function withdraw() public onlyOwner {\n', '      require(currentVotingDate == 0);\n', '      require(allowedWithdraw > 0);\n', '      owner.transfer(allowedWithdraw);\n', '      Withdraw(now, allowedWithdraw);\n', '      allowedWithdraw = 0;\n', '  }\n', '\n', '  /**\n', '   * @dev End current voting with 3 scenarios - toAllow, toCancel or refund\n', '   */\n', '  function refund() public {\n', '      require(allowedRefund > 0);\n', '      // allows refund only once thrue the voiting\n', '      require(alreadyRefunded[msg.sender] == 0);\n', '      require(token.balanceOf(msg.sender) > 0);\n', '      // total supply tokens is 40 000 000\n', '      uint256 tokensPercent = token.balanceOf(msg.sender).div(40000000).div(1000000000000000);\n', '      uint256 refundedAmount = tokensPercent.mul(sbiBank.balance).div(1000);\n', '      address sender = msg.sender;\n', '      alreadyRefunded[msg.sender] = refundedAmount;\n', '      token.transferFrom(msg.sender, featureDevelopment.addr, token.balanceOf(msg.sender));\n', '      sender.transfer(refundedAmount);\n', '      Refund(now, refundedAmount, msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev payable fallback\n', '   */\n', '  function () external payable {\n', '      NewIncomingFunds(msg.value, msg.sender);\n', '  }\n', '}']