['pragma solidity 0.4.21;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Authorizable\n', ' * @dev The Authorizable contract has authorized addresses, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "multiple user permissions".\n', ' */\n', 'contract Authorizable is Ownable {\n', '    \n', '    mapping(address => bool) public authorized;\n', '    event AuthorizationSet(address indexed addressAuthorized, bool indexed authorization);\n', '\n', '    /**\n', '     * @dev The Authorizable constructor sets the first `authorized` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Authorizable() public {\n', '        authorize(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the authorized.\n', '     */\n', '    modifier onlyAuthorized() {\n', '        require(authorized[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows \n', '     * @param _address The address to change authorization.\n', '     */\n', '    function authorize(address _address) public onlyOwner {\n', '        require(!authorized[_address]);\n', '        emit AuthorizationSet(_address, true);\n', '        authorized[_address] = true;\n', '    }\n', '    /**\n', '     * @dev Disallows\n', '     * @param _address The address to change authorization.\n', '     */\n', '    function deauthorize(address _address) public onlyOwner {\n', '        require(authorized[_address]);\n', '        emit AuthorizationSet(_address, false);\n', '        authorized[_address] = false;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title PrivateSaleExchangeRate interface\n', ' */\n', 'contract PrivateSaleExchangeRate {\n', '    uint256 public rate;\n', '    uint256 public timestamp;\n', '    event UpdateUsdEthRate(uint _rate);\n', '    function updateUsdEthRate(uint _rate) public;\n', '    function getTokenAmount(uint256 _weiAmount) public view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @title Whitelist interface\n', ' */\n', 'contract Whitelist {\n', '    mapping(address => bool) whitelisted;\n', '    event AddToWhitelist(address _beneficiary);\n', '    event RemoveFromWhitelist(address _beneficiary);\n', '    function isWhitelisted(address _address) public view returns (bool);\n', '    function addToWhitelist(address _beneficiary) public;\n', '    function removeFromWhitelist(address _beneficiary) public;\n', '}\n', '\n', '// -----------------------------------------\n', '// -----------------------------------------\n', '// -----------------------------------------\n', '// Crowdsale\n', '// -----------------------------------------\n', '// -----------------------------------------\n', '// -----------------------------------------\n', '\n', 'contract Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    // The token being sold\n', '    ERC20 public token;\n', '\n', '    // Address where funds are collected\n', '    address public wallet;\n', '\n', '    // How many token units a buyer gets per wei\n', '    PrivateSaleExchangeRate public rate;\n', '\n', '    // Amount of wei raised\n', '    uint256 public weiRaised;\n', '    \n', '    // Amount of wei raised (token)\n', '    uint256 public tokenRaised;\n', '\n', '    /**\n', '    * Event for token purchase logging\n', '    * @param purchaser who paid for the tokens\n', '    * @param beneficiary who got the tokens\n', '    * @param value weis paid for purchase\n', '    * @param amount amount of tokens purchased\n', '    */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '    /**\n', '    * @param _rate Number of token units a buyer gets per wei\n', '    * @param _wallet Address where collected funds will be forwarded to\n', '    * @param _token Address of the token being sold\n', '    */\n', '    function Crowdsale(PrivateSaleExchangeRate _rate, address _wallet, ERC20 _token) public {\n', '        require(_rate.rate() > 0);\n', '        require(_token != address(0));\n', '        require(_wallet != address(0));\n', '\n', '        rate = _rate;\n', '        token = _token;\n', '        wallet = _wallet;\n', '    }\n', '\n', '    // -----------------------------------------\n', '    // Crowdsale external interface\n', '    // -----------------------------------------\n', '\n', '    /**\n', '    * @dev fallback function ***DO NOT OVERRIDE***\n', '    */\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @dev low level token purchase ***DO NOT OVERRIDE***\n', '    * @param _beneficiary Address performing the token purchase\n', '    */\n', '    function buyTokens(address _beneficiary) public payable {\n', '\n', '        uint256 weiAmount = msg.value;\n', '        \n', '         // calculate token amount to be created\n', '        uint256 tokenAmount = _getTokenAmount(weiAmount);\n', '        \n', '        _preValidatePurchase(_beneficiary, weiAmount, tokenAmount);\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        tokenRaised = tokenRaised.add(tokenAmount);\n', '\n', '        _processPurchase(_beneficiary, tokenAmount);\n', '        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokenAmount);\n', '\n', '        _updatePurchasingState(_beneficiary, weiAmount);\n', '\n', '        _forwardFunds();\n', '        _postValidatePurchase(_beneficiary, weiAmount);\n', '    }\n', '\n', '    // -----------------------------------------\n', '    // Internal interface (extensible)\n', '    // -----------------------------------------\n', '\n', '    /**\n', '    * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n', '    * @param _beneficiary Address performing the token purchase\n', '    * @param _weiAmount Value in wei involved in the purchase\n', '    */\n', '    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount, uint256 _tokenAmount) internal {\n', '        require(_beneficiary != address(0));\n', '        require(_weiAmount > 0);\n', '        require(_tokenAmount > 0);\n', '    }\n', '\n', '    /**\n', '    * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\n', '    * @param _beneficiary Address performing the token purchase\n', '    * @param _weiAmount Value in wei involved in the purchase\n', '    */\n', '    function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n', '        // optional override\n', '    }\n', '\n', '    /**\n', '    * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n', '    * @param _beneficiary Address performing the token purchase\n', '    * @param _tokenAmount Number of tokens to be emitted\n', '    */\n', '    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '        token.transfer(_beneficiary, _tokenAmount);\n', '    }\n', '    \n', '    /**\n', '    * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n', '    * @param _beneficiary Address receiving the tokens\n', '    * @param _tokenAmount Number of tokens to be purchased\n', '    */\n', '    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '        _deliverTokens(_beneficiary, _tokenAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\n', '    * @param _beneficiary Address receiving the tokens\n', '    * @param _weiAmount Value in wei involved in the purchase\n', '    */\n', '    function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n', '        // optional override\n', '    }\n', '\n', '    /**\n', '    * @dev Override to extend the way in which ether is converted to tokens.\n', '    * @param _weiAmount Value in wei to be converted into tokens\n', '    * @return Number of tokens that can be purchased with the specified _weiAmount\n', '    */\n', '    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n', '        return rate.getTokenAmount(_weiAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Determines how ETH is stored/forwarded on purchases.\n', '    */\n', '    function _forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title TimedCrowdsale\n', ' * @dev Crowdsale accepting contributions only within a time frame.\n', ' */\n', 'contract TimedCrowdsale is Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public openingTime;\n', '    uint256 public closingTime;\n', '\n', '    /**\n', '     * @dev Reverts if not in crowdsale time range. \n', '    */\n', '    modifier onlyWhileOpen {\n', '        require(now >= openingTime && now <= closingTime);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Constructor, takes crowdsale opening and closing times.\n', '     * @param _openingTime Crowdsale opening time\n', '     * @param _closingTime Crowdsale closing time\n', '     */\n', '    function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\n', '        \n', '        require(_closingTime >= now);\n', '         \n', '        require(_closingTime >= _openingTime);\n', '        openingTime = _openingTime;\n', '        closingTime = _closingTime;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks whether the period in which the crowdsale is open has already elapsed.\n', '     * @return Whether crowdsale period has elapsed\n', '     */\n', '    function hasClosed() public view returns (bool) {\n', '        return now > closingTime;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks whether the period in which the crowdsale is opened.\n', '     * @return Whether crowdsale period has elapsed\n', '     */\n', '    function hasOpening() public view returns (bool) {\n', '        return (now >= openingTime && now <= closingTime);\n', '    }\n', '  \n', '    /**\n', '     * @dev Extend parent behavior requiring to be within contributing period\n', '     * @param _beneficiary Token purchaser\n', '     * @param _weiAmount Amount of wei contributed\n', '     */\n', '    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount, uint256 _tokenAmount) internal onlyWhileOpen {\n', '        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title AllowanceCrowdsale\n', ' * @dev Extension of Crowdsale where tokens are held by a wallet, which approves an allowance to the crowdsale.\n', ' */\n', 'contract AllowanceCrowdsale is Crowdsale {\n', '    using SafeMath for uint256;\n', '    address public tokenWallet;\n', '\n', '    /**\n', '    * @dev Constructor, takes token wallet address. \n', '    * @param _tokenWallet Address holding the tokens, which has approved allowance to the crowdsale\n', '    */\n', '    function AllowanceCrowdsale(address _tokenWallet) public {\n', '        require(_tokenWallet != address(0));\n', '        tokenWallet = _tokenWallet;\n', '    }\n', '\n', '    /**\n', '    * @dev Overrides parent behavior by transferring tokens from wallet.\n', '    * @param _beneficiary Token purchaser\n', '    * @param _tokenAmount Amount of tokens purchased\n', '    */\n', '    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '        token.transferFrom(tokenWallet, _beneficiary, _tokenAmount);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title CappedCrowdsale\n', ' * @dev Crowdsale with a limit for total contributions.\n', ' */\n', 'contract CappedCrowdsale is Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public minWei;\n', '    uint256 public capToken;\n', '\n', '    /**\n', '    * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.\n', '    * @param _capToken Max amount of token to be contributed\n', '    */\n', '    function CappedCrowdsale(uint256 _capToken, uint256 _minWei) public {\n', '        require(_minWei > 0);\n', '        require(_capToken > 0);\n', '        minWei = _minWei;\n', '        capToken = _capToken;\n', '    }\n', '\n', '    /**\n', '    * @dev Checks whether the cap has been reached. \n', '    * @return Whether the cap was reached\n', '    */\n', '    function capReached() public view returns (bool) {\n', '        if(tokenRaised >= capToken) return true;\n', '        uint256 minTokens = rate.getTokenAmount(minWei);\n', '        if(capToken - tokenRaised <= minTokens) return true;\n', '        return false;\n', '    }\n', '\n', '    /**\n', '    * @dev Extend parent behavior requiring purchase to respect the funding cap.\n', '    * @param _beneficiary Token purchaser\n', '    * @param _weiAmount Amount of wei contributed\n', '    */\n', '    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount, uint256 _tokenAmount) internal {\n', '        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\n', '        require(_weiAmount >= minWei);\n', '        require(tokenRaised.add(_tokenAmount) <= capToken);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title WhitelistedCrowdsale\n', ' * @dev Crowdsale with a limit for total contributions.\n', ' */\n', 'contract WhitelistedCrowdsale is Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    // Only KYC investor allowed to buy the token\n', '    Whitelist public whitelist;\n', '\n', '    /**\n', '    * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.\n', '    * @param _whitelist whitelist contract\n', '    */\n', '    function WhitelistedCrowdsale(Whitelist _whitelist) public {\n', '        whitelist = _whitelist;\n', '    }\n', '\n', '    function isWhitelisted(address _address) public view returns (bool) {\n', '        return whitelist.isWhitelisted(_address);\n', '    }\n', '\n', '    /**\n', '    * @dev Extend parent behavior requiring purchase to respect the funding cap.\n', '    * @param _beneficiary Token purchaser\n', '    * @param _weiAmount Amount of wei contributed\n', '    */\n', '    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount, uint256 _tokenAmount) internal {\n', '        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\n', '        require(whitelist.isWhitelisted(_beneficiary));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ClaimedCrowdsale\n', ' * @dev Extension of Crowdsale where tokens are held by a wallet, which approves an allowance to the crowdsale.\n', ' */\n', 'contract ClaimCrowdsale is Crowdsale, Authorizable {\n', '    using SafeMath for uint256;\n', '    \n', '    uint256 divider;\n', '    event ClaimToken(address indexed claimant, address indexed beneficiary, uint256 claimAmount);\n', '     \n', '    // Claim remain amount of token\n', '    //addressIndices not use index 0 \n', '    address[] public addressIndices;\n', '\n', '    // get amount of claim token\n', '    mapping(address => uint256) mapAddressToToken;\n', '    \n', '    //get index of addressIndices if = 0 >> not found\n', '    mapping(address => uint256) mapAddressToIndex;\n', '    \n', '     // Amount of wei waiting for claim (token)\n', '    uint256 public waitingForClaimTokens;\n', '\n', '    /**\n', '    * @dev Constructor, takes token wallet address. \n', '    */\n', '    function ClaimCrowdsale(uint256 _divider) public {\n', '        require(_divider > 0);\n', '        divider = _divider;\n', '        addressIndices.push(address(0));\n', '    }\n', '    \n', '    /**\n', '    * @dev Claim remained token after closed time\n', '    */\n', '    function claim(address _beneficiary) public onlyAuthorized {\n', '       \n', '        require(_beneficiary != address(0));\n', '        require(mapAddressToToken[_beneficiary] > 0);\n', '        \n', '        // remove from list\n', '        uint indexToBeDeleted = mapAddressToIndex[_beneficiary];\n', '        require(indexToBeDeleted != 0);\n', '        \n', '        uint arrayLength = addressIndices.length;\n', '        // if index to be deleted is not the last index, swap position.\n', '        if (indexToBeDeleted < arrayLength-1) {\n', '            // swap \n', '            addressIndices[indexToBeDeleted] = addressIndices[arrayLength-1];\n', '            mapAddressToIndex[addressIndices[indexToBeDeleted]] = indexToBeDeleted;\n', '        }\n', '         // we can now reduce the array length by 1\n', '        addressIndices.length--;\n', '        mapAddressToIndex[_beneficiary] = 0;\n', '        \n', '        // deliver token\n', '        uint256 _claimAmount = mapAddressToToken[_beneficiary];\n', '        mapAddressToToken[_beneficiary] = 0;\n', '        waitingForClaimTokens = waitingForClaimTokens.sub(_claimAmount);\n', '        emit ClaimToken(msg.sender, _beneficiary, _claimAmount);\n', '        \n', '        _deliverTokens(_beneficiary, _claimAmount);\n', '    }\n', '    \n', '    function checkClaimTokenByIndex(uint index) public view returns (uint256){\n', '        require(index >= 0);\n', '        require(index < addressIndices.length);\n', '        return checkClaimTokenByAddress(addressIndices[index]);\n', '    }\n', '    \n', '    function checkClaimTokenByAddress(address _beneficiary) public view returns (uint256){\n', '        require(_beneficiary != address(0));\n', '        return mapAddressToToken[_beneficiary];\n', '    }\n', '    function countClaimBackers()  public view returns (uint256) {\n', '        return addressIndices.length-1;\n', '    }\n', '    \n', '    function _addToClaimList(address _beneficiary, uint256 _claimAmount) internal {\n', '        require(_beneficiary != address(0));\n', '        require(_claimAmount > 0);\n', '        \n', '        if(mapAddressToToken[_beneficiary] == 0){\n', '            addressIndices.push(_beneficiary);\n', '            mapAddressToIndex[_beneficiary] = addressIndices.length-1;\n', '        }\n', '        waitingForClaimTokens = waitingForClaimTokens.add(_claimAmount);\n', '        mapAddressToToken[_beneficiary] = mapAddressToToken[_beneficiary].add(_claimAmount);\n', '    }\n', '\n', '   \n', '    /**\n', '     * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n', '     * @param _beneficiary Address receiving the tokens\n', '     * @param _tokenAmount Number of tokens to be purchased\n', '     */\n', '    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '        \n', '        // To protect our private-sale investors who transfered eth via wallet from exchange.\n', '        // Instead of send all tokens amount back, the private-sale contract will send back in small portion of tokens (ppm). \n', '        // The full amount of tokens will be send later after the investor has confirmed received amount to us.\n', '        uint256 tokenSampleAmount = _tokenAmount.div(divider);\n', '\n', '        _addToClaimList(_beneficiary, _tokenAmount.sub(tokenSampleAmount));\n', '        _deliverTokens(_beneficiary, tokenSampleAmount);\n', '    }\n', '}\n', '\n', '// -----------------------------------------\n', '// -----------------------------------------\n', '// -----------------------------------------\n', '// ZMINE\n', '// -----------------------------------------\n', '// -----------------------------------------\n', '// -----------------------------------------\n', '\n', '/**\n', ' * @title ZminePrivateSale\n', ' */\n', 'contract ZminePrivateSale is ClaimCrowdsale\n', '                                , AllowanceCrowdsale\n', '                                , CappedCrowdsale\n', '                                , TimedCrowdsale\n', '                                , WhitelistedCrowdsale {\n', '    using SafeMath for uint256;\n', '    \n', '    /**\n', '     * @param _rate Number of token units a buyer gets per wei\n', '     * @param _whitelist Allowd address of buyer\n', '     * @param _wallet Address where collected funds will be forwarded to\n', '     * @param _token Address of the token being sold\n', '     */\n', '    function ZminePrivateSale(PrivateSaleExchangeRate _rate\n', '                                , Whitelist _whitelist\n', '                                , uint256 _capToken\n', '                                , uint256 _minWei\n', '                                , uint256 _openingTime\n', '                                , uint256 _closingTime\n', '                                , address _wallet\n', '                                , address _tokenWallet\n', '                                , ERC20 _token\n', '    ) public \n', '        Crowdsale(_rate, _wallet, _token) \n', '        ClaimCrowdsale(1000000)\n', '        AllowanceCrowdsale(_tokenWallet) \n', '        CappedCrowdsale(_capToken, _minWei)\n', '        TimedCrowdsale(_openingTime, _closingTime) \n', '        WhitelistedCrowdsale(_whitelist)\n', '    {\n', '        \n', '        \n', '        \n', '    }\n', '\n', '    function calculateTokenAmount(uint256 _weiAmount)  public view returns (uint256) {\n', '        return rate.getTokenAmount(_weiAmount);\n', '    }\n', '    \n', '     /**\n', '      * @dev Checks the amount of tokens left in the allowance.\n', '      * @return Amount of tokens left in the allowance\n', '      */\n', '    function remainingTokenForSale() public view returns (uint256) {\n', '        uint256 allowanceTokenLeft = (token.allowance(tokenWallet, this)).sub(waitingForClaimTokens);\n', '        uint256 balanceTokenLeft = (token.balanceOf(tokenWallet)).sub(waitingForClaimTokens);\n', '        if(allowanceTokenLeft < balanceTokenLeft) return allowanceTokenLeft;\n', '        return balanceTokenLeft;\n', '    }\n', '    \n', '     /**\n', '     * @dev Extend parent behavior requiring to be within contributing period\n', '     * @param _beneficiary Token purchaser\n', '     * @param _weiAmount Amount of wei contributed\n', '     */\n', '    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount, uint256 _tokenAmount) internal {\n', '        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\n', '        require(remainingTokenForSale().sub(_tokenAmount) >= 0);\n', '    }\n', '}\n', '\n', '// -----------------------------------------\n', '// -----------------------------------------\n', '// -----------------------------------------']