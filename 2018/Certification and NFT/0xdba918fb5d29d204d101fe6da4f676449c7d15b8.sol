['pragma solidity ^0.4.24;\n', 'interface IExchangeFormula {\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) external view returns (uint256);\n', '    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) external view returns (uint256);\n', '}\n', '\n', 'interface ITradeableAsset {\n', '    function totalSupply() external view returns (uint256);\n', '    function approve(address spender, uint tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '    function decimals() external view returns (uint256);\n', '    function transfer(address _to, uint256 _value) external;\n', '    function balanceOf(address _address) external view returns (uint256);\n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', '/* A basic permissions hierarchy (Owner -> Admin -> Everyone else). One owner may appoint and remove any number of admins\n', '   and may transfer ownership to another individual address */\n', 'contract Administered {\n', '    address public creator;\n', '\n', '    mapping (address => bool) public admins;\n', '    \n', '    constructor() public {\n', '        creator = msg.sender;\n', '        admins[creator] = true;\n', '    }\n', '\n', '    //Restrict to the current owner. There may be only 1 owner at a time, but \n', '    //ownership can be transferred.\n', '    modifier onlyOwner {\n', '        require(creator == msg.sender);\n', '        _;\n', '    }\n', '    \n', '    //Restrict to any admin. Not sufficient for highly sensitive methods\n', '    //since basic admin can be granted programatically regardless of msg.sender\n', '    modifier onlyAdmin {\n', '        require(admins[msg.sender] || creator == msg.sender);\n', '        _;\n', '    }\n', '\n', '    //Add an admin with basic privileges. Can be done by any superuser (or the owner)\n', '    function grantAdmin(address newAdmin) onlyOwner  public {\n', '        _grantAdmin(newAdmin);\n', '    }\n', '\n', '    function _grantAdmin(address newAdmin) internal\n', '    {\n', '        admins[newAdmin] = true;\n', '    }\n', '\n', '    //Transfer ownership\n', '    function changeOwner(address newOwner) onlyOwner public {\n', '        creator = newOwner;\n', '    }\n', '\n', '    //Remove an admin\n', '    function revokeAdminStatus(address user) onlyOwner public {\n', '        admins[user] = false;\n', '    }\n', '}\n', '\n', '/* A liqudity pool that executes buy and sell orders for an ETH / Token Pair */\n', '/* The owner deploys it and then adds tokens / ethereum in the desired ratio */\n', '\n', 'contract ExchangerV4 is Administered, tokenRecipient {\n', '    bool public enabled = false;    //Owner can turn off and on\n', '\n', '    //The token which is being bought and sold\n', '    ITradeableAsset public tokenContract;\n', '    //The contract that does the calculations to determine buy and sell pricing\n', '    IExchangeFormula public formulaContract;\n', '    //The reserve pct of this exchanger, expressed in ppm\n', '    uint32 public weight;\n', '    //The fee, in ppm\n', '    uint32 public fee=5000; //0.5%\n', '    //The portion of the total supply that is not currently (e.g. not yet issued) or not ever (e.g. burned) in circulation\n', '    //The formula calculates prices based on a circulating supply which is: total supply - uncirculated supply - reserve supply (balance of exchanger)\n', '    uint256 public uncirculatedSupplyCount=0;\n', '    //Accounting for the fees\n', '    uint256 public collectedFees=0;\n', '    //If part of the ether reserve is stored offsite for security reasons this variable holds that value\n', '    uint256 public virtualReserveBalance=0;\n', '    //Prevent the eth balance to be lover than a set value\n', '    //The min Eth reserve amount\n', '    uint256 public minReserve=0; //\n', '\n', '    /** \n', '        @dev Deploys an exchanger contract for a given token / Ether pairing\n', '        @param _token An ERC20 token\n', '        @param _weight The reserve fraction of this exchanger, in ppm\n', '        @param _formulaContract The contract with the algorithms to calculate price\n', '     */\n', '\n', '    constructor(address _token, \n', '                uint32 _weight,\n', '                address _formulaContract) {\n', '        require (_weight > 0 && weight <= 1000000);\n', '        \n', '        weight = _weight;\n', '        tokenContract = ITradeableAsset(_token);\n', '        formulaContract = IExchangeFormula(_formulaContract);\n', '    }\n', '\n', '    //Events raised on completion of buy and sell orders. \n', '    //The web client can use this info to provide users with their trading history for a given token\n', '    //and also to notify when a trade has completed.\n', '\n', '    event Buy(address indexed purchaser, uint256 amountInWei, uint256 amountInToken);\n', '    event Sell(address indexed seller, uint256 amountInToken, uint256 amountInWei);\n', '\n', '    /**\n', '     @dev Deposit tokens to the reserve.\n', '     */\n', '    function depositTokens(uint amount) onlyOwner public {\n', '        tokenContract.transferFrom(msg.sender, this, amount);\n', '    }\n', '        \n', '    /**\n', '    @dev Deposit ether to the reserve\n', '    */\n', '    function depositEther() onlyOwner public payable {\n', '    //return getQuotePrice(); \n', '    }\n', '\n', '    /**  \n', '     @dev Withdraw tokens from the reserve\n', '     */\n', '    function withdrawTokens(uint amount) onlyOwner public {\n', '        tokenContract.transfer(msg.sender, amount);\n', '    }\n', '\n', '    /**  \n', '     @dev Withdraw ether from the reserve\n', '     */\n', '    function withdrawEther(uint amountInWei) onlyOwner public {\n', '        msg.sender.transfer(amountInWei); //Transfers in wei\n', '    }\n', '\n', '    /**\n', '     @dev Withdraw accumulated fees, without disturbing the core reserve\n', '     */\n', '    function extractFees(uint amountInWei) onlyAdmin public {\n', '        require (amountInWei <= collectedFees);\n', '        msg.sender.transfer(amountInWei);\n', '    }\n', '\n', '    /**\n', '     @dev Enable trading\n', '     */\n', '    function enable() onlyAdmin public {\n', '        enabled = true;\n', '    }\n', '\n', '     /**\n', '      @dev Disable trading\n', '     */\n', '    function disable() onlyAdmin public {\n', '        enabled = false;\n', '    }\n', '\n', '     /**\n', '      @dev Play central banker and set the fractional reserve ratio, from 1 to 1000000 ppm.\n', '      It is highly disrecommended to do this while trading is enabled! Obviously this should \n', '      only be done in combination with a matching deposit or withdrawal of ether, \n', '      and I&#39;ll enforce it at a later point.\n', '     */\n', '    function setReserveWeight(uint ppm) onlyAdmin public {\n', '        require (ppm>0 && ppm<=1000000);\n', '        weight = uint32(ppm);\n', '    }\n', '\n', '    function setFee(uint ppm) onlyAdmin public {\n', '        require (ppm >= 0 && ppm <= 1000000);\n', '        fee = uint32(ppm);\n', '    }\n', '\n', '    /* The number of tokens that are burned, unissued, or otherwise not in circulation */\n', '    function setUncirculatedSupplyCount(uint newValue) onlyAdmin public {\n', '        require (newValue > 0);\n', '        uncirculatedSupplyCount = uint256(newValue);\n', '    }\n', '\n', '    /**\n', '     * The virtual reserve balance set here is added on to the actual ethereum balance of this contract\n', '     * when calculating price for buy/sell. Note that if you have no real ether in the reserve, you will \n', '     * not have liquidity for sells until you have some buys first.\n', '     */\n', '    function setVirtualReserveBalance(uint256 amountInWei) onlyAdmin public {\n', '        virtualReserveBalance = amountInWei;\n', '    }\n', '    \n', '    function setMinReserve(uint256 amountInWei) onlyAdmin public {\n', '        minReserve = amountInWei;\n', '    }     \n', '\n', '    //These methods return information about the exchanger, and the buy / sell rates offered on the Token / ETH pairing.\n', '    //They can be called without gas from any client.\n', '\n', '    /**  \n', '     @dev Audit the reserve balances, in the base token and in ether\n', '     returns: [token balance, ether balance - ledger]\n', '     */\n', '    function getReserveBalances() public view returns (uint256, uint256) {\n', '        return (tokenContract.balanceOf(this), address(this).balance+virtualReserveBalance);\n', '    }\n', '\n', '    /**\n', '     @dev Get the BUY price based on the order size. Returned as the number of tokens that the amountInWei will buy.\n', '     */\n', '    function getPurchasePrice(uint256 amountInWei) public view returns(uint) {\n', '        uint256 purchaseReturn = formulaContract.calculatePurchaseReturn(\n', '            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '            address(this).balance + virtualReserveBalance,\n', '            weight,\n', '            amountInWei \n', '        ); \n', '\n', '        purchaseReturn = (purchaseReturn - ((purchaseReturn * fee) / 1000000));\n', '\n', '        if (purchaseReturn > tokenContract.balanceOf(this)){\n', '            return tokenContract.balanceOf(this);\n', '        }\n', '        return purchaseReturn;\n', '    }\n', '\n', '    /**\n', '     @dev Get the SELL price based on the order size. Returned as amount (in wei) that you&#39;ll get for your tokens.\n', '     */\n', '    function getSalePrice(uint256 tokensToSell) public view returns(uint) {\n', '        uint256 saleReturn = formulaContract.calculateSaleReturn(\n', '            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '            address(this).balance + virtualReserveBalance,\n', '            weight,\n', '            tokensToSell \n', '        ); \n', '        saleReturn = (saleReturn - ((saleReturn * fee) / 1000000));\n', '        if (saleReturn > address(this).balance) {\n', '            return address(this).balance;\n', '        }\n', '        return saleReturn;\n', '    }\n', '\n', '    //buy and sell execute live trades against the exchanger. For either method, \n', '    //you must specify your minimum return (in total tokens or ether that you expect to receive for your trade)\n', '    //this protects the trader against slippage due to other orders that make it into earlier blocks after they \n', '    //place their order. \n', '    //\n', '    //With buy, send the amount of ether you want to spend on the token - you&#39;ll get it back immediately if minPurchaseReturn\n', '    //is not met or if this Exchanger is not in a condition to service your order (usually this happens when there is not a full \n', '    //reserve of tokens to satisfy the stated weight)\n', '    //\n', '    //With sell, first approve the exchanger to spend the number of tokens you want to sell\n', '    //Then call sell with that number and your minSaleReturn. The token transfer will not happen \n', '    //if the minSaleReturn is not met.\n', '    //\n', '    //Sales always go through, as long as there is any ether in the reserve... but those dumping massive quantities of tokens\n', '    //will naturally be given the shittest rates.\n', '\n', '    /**\n', '     @dev Buy tokens with ether. \n', '     @param minPurchaseReturn The minimum number of tokens you will accept.\n', '     */\n', '    function buy(uint minPurchaseReturn) public payable {\n', '        uint amount = formulaContract.calculatePurchaseReturn(\n', '            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '            (address(this).balance + virtualReserveBalance) - msg.value,\n', '            weight,\n', '            msg.value);\n', '        amount = (amount - ((amount * fee) / 1000000));\n', '        \n', '        //Now do the trade if conditions are met\n', '        require (enabled); // ADDED SEMICOLON    \n', '        require (amount >= minPurchaseReturn);\n', '        require (tokenContract.balanceOf(this) >= amount);\n', '        \n', '        //Accounting - so we can pull the fees out without changing the balance\n', '        collectedFees += (msg.value * fee) / 1000000;\n', '        \n', '        emit Buy(msg.sender, msg.value, amount);\n', '        tokenContract.transfer(msg.sender, amount);\n', '    }\n', '    \n', '    /**\n', '     @dev Sell tokens for ether\n', '     @param quantity Number of tokens to sell\n', '     @param minSaleReturn Minimum amount of ether (in wei) you will accept for your tokens\n', '     */\n', '    function sell(uint quantity, uint minSaleReturn) public {\n', '        uint amountInWei = formulaContract.calculateSaleReturn(\n', '            (tokenContract.totalSupply()- uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '             address(this).balance + virtualReserveBalance,\n', '             weight,\n', '             quantity\n', '        );\n', '        amountInWei = (amountInWei - ((amountInWei * fee) / 1000000));\n', '\n', '        require (enabled); // ADDED SEMICOLON\n', '        require (amountInWei >= minSaleReturn);\n', '        require (amountInWei <= address(this).balance);\n', '        require (address(this).balance - amountInWei > minReserve);\n', '        require (tokenContract.transferFrom(msg.sender, this, quantity));\n', '\n', '        collectedFees += (amountInWei * fee) / 1000000;\n', '\n', '        emit Sell(msg.sender, quantity, amountInWei);\n', '        msg.sender.transfer(amountInWei); //Always send ether last\n', '    }\n', '\n', '    //approveAndCall flow for selling entry point\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external {\n', '        //not needed: if it was the wrong token, the tx fails anyways require(_token == address(tokenContract));\n', '        sellOneStep(_value, 0, _from);\n', '    }    \n', '\n', '    //Variant of sell for one step ordering. The seller calls approveAndCall on the token\n', '    //which calls receiveApproval above, which calls this funciton\n', '    function sellOneStep(uint quantity, uint minSaleReturn, address seller) public {\n', '        uint amountInWei = formulaContract.calculateSaleReturn(\n', '            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '             address(this).balance + virtualReserveBalance,\n', '             weight,\n', '             quantity\n', '        );\n', '        amountInWei = (amountInWei - ((amountInWei * fee) / 1000000));\n', '        \n', '        require (enabled); // ADDED SEMICOLON\n', '        require (amountInWei >= minSaleReturn);\n', '        require (amountInWei <= address(this).balance);\n', '        require (address(this).balance - amountInWei > minReserve);\n', '        require (tokenContract.transferFrom(seller, this, quantity));\n', '\n', '        collectedFees += (amountInWei * fee) / 1000000;\n', '\n', '\n', '        emit Sell(seller, quantity, amountInWei);\n', '        seller.transfer(amountInWei); //Always send ether last\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', 'interface IExchangeFormula {\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) external view returns (uint256);\n', '    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) external view returns (uint256);\n', '}\n', '\n', 'interface ITradeableAsset {\n', '    function totalSupply() external view returns (uint256);\n', '    function approve(address spender, uint tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '    function decimals() external view returns (uint256);\n', '    function transfer(address _to, uint256 _value) external;\n', '    function balanceOf(address _address) external view returns (uint256);\n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', '/* A basic permissions hierarchy (Owner -> Admin -> Everyone else). One owner may appoint and remove any number of admins\n', '   and may transfer ownership to another individual address */\n', 'contract Administered {\n', '    address public creator;\n', '\n', '    mapping (address => bool) public admins;\n', '    \n', '    constructor() public {\n', '        creator = msg.sender;\n', '        admins[creator] = true;\n', '    }\n', '\n', '    //Restrict to the current owner. There may be only 1 owner at a time, but \n', '    //ownership can be transferred.\n', '    modifier onlyOwner {\n', '        require(creator == msg.sender);\n', '        _;\n', '    }\n', '    \n', '    //Restrict to any admin. Not sufficient for highly sensitive methods\n', '    //since basic admin can be granted programatically regardless of msg.sender\n', '    modifier onlyAdmin {\n', '        require(admins[msg.sender] || creator == msg.sender);\n', '        _;\n', '    }\n', '\n', '    //Add an admin with basic privileges. Can be done by any superuser (or the owner)\n', '    function grantAdmin(address newAdmin) onlyOwner  public {\n', '        _grantAdmin(newAdmin);\n', '    }\n', '\n', '    function _grantAdmin(address newAdmin) internal\n', '    {\n', '        admins[newAdmin] = true;\n', '    }\n', '\n', '    //Transfer ownership\n', '    function changeOwner(address newOwner) onlyOwner public {\n', '        creator = newOwner;\n', '    }\n', '\n', '    //Remove an admin\n', '    function revokeAdminStatus(address user) onlyOwner public {\n', '        admins[user] = false;\n', '    }\n', '}\n', '\n', '/* A liqudity pool that executes buy and sell orders for an ETH / Token Pair */\n', '/* The owner deploys it and then adds tokens / ethereum in the desired ratio */\n', '\n', 'contract ExchangerV4 is Administered, tokenRecipient {\n', '    bool public enabled = false;    //Owner can turn off and on\n', '\n', '    //The token which is being bought and sold\n', '    ITradeableAsset public tokenContract;\n', '    //The contract that does the calculations to determine buy and sell pricing\n', '    IExchangeFormula public formulaContract;\n', '    //The reserve pct of this exchanger, expressed in ppm\n', '    uint32 public weight;\n', '    //The fee, in ppm\n', '    uint32 public fee=5000; //0.5%\n', '    //The portion of the total supply that is not currently (e.g. not yet issued) or not ever (e.g. burned) in circulation\n', '    //The formula calculates prices based on a circulating supply which is: total supply - uncirculated supply - reserve supply (balance of exchanger)\n', '    uint256 public uncirculatedSupplyCount=0;\n', '    //Accounting for the fees\n', '    uint256 public collectedFees=0;\n', '    //If part of the ether reserve is stored offsite for security reasons this variable holds that value\n', '    uint256 public virtualReserveBalance=0;\n', '    //Prevent the eth balance to be lover than a set value\n', '    //The min Eth reserve amount\n', '    uint256 public minReserve=0; //\n', '\n', '    /** \n', '        @dev Deploys an exchanger contract for a given token / Ether pairing\n', '        @param _token An ERC20 token\n', '        @param _weight The reserve fraction of this exchanger, in ppm\n', '        @param _formulaContract The contract with the algorithms to calculate price\n', '     */\n', '\n', '    constructor(address _token, \n', '                uint32 _weight,\n', '                address _formulaContract) {\n', '        require (_weight > 0 && weight <= 1000000);\n', '        \n', '        weight = _weight;\n', '        tokenContract = ITradeableAsset(_token);\n', '        formulaContract = IExchangeFormula(_formulaContract);\n', '    }\n', '\n', '    //Events raised on completion of buy and sell orders. \n', '    //The web client can use this info to provide users with their trading history for a given token\n', '    //and also to notify when a trade has completed.\n', '\n', '    event Buy(address indexed purchaser, uint256 amountInWei, uint256 amountInToken);\n', '    event Sell(address indexed seller, uint256 amountInToken, uint256 amountInWei);\n', '\n', '    /**\n', '     @dev Deposit tokens to the reserve.\n', '     */\n', '    function depositTokens(uint amount) onlyOwner public {\n', '        tokenContract.transferFrom(msg.sender, this, amount);\n', '    }\n', '        \n', '    /**\n', '    @dev Deposit ether to the reserve\n', '    */\n', '    function depositEther() onlyOwner public payable {\n', '    //return getQuotePrice(); \n', '    }\n', '\n', '    /**  \n', '     @dev Withdraw tokens from the reserve\n', '     */\n', '    function withdrawTokens(uint amount) onlyOwner public {\n', '        tokenContract.transfer(msg.sender, amount);\n', '    }\n', '\n', '    /**  \n', '     @dev Withdraw ether from the reserve\n', '     */\n', '    function withdrawEther(uint amountInWei) onlyOwner public {\n', '        msg.sender.transfer(amountInWei); //Transfers in wei\n', '    }\n', '\n', '    /**\n', '     @dev Withdraw accumulated fees, without disturbing the core reserve\n', '     */\n', '    function extractFees(uint amountInWei) onlyAdmin public {\n', '        require (amountInWei <= collectedFees);\n', '        msg.sender.transfer(amountInWei);\n', '    }\n', '\n', '    /**\n', '     @dev Enable trading\n', '     */\n', '    function enable() onlyAdmin public {\n', '        enabled = true;\n', '    }\n', '\n', '     /**\n', '      @dev Disable trading\n', '     */\n', '    function disable() onlyAdmin public {\n', '        enabled = false;\n', '    }\n', '\n', '     /**\n', '      @dev Play central banker and set the fractional reserve ratio, from 1 to 1000000 ppm.\n', '      It is highly disrecommended to do this while trading is enabled! Obviously this should \n', '      only be done in combination with a matching deposit or withdrawal of ether, \n', "      and I'll enforce it at a later point.\n", '     */\n', '    function setReserveWeight(uint ppm) onlyAdmin public {\n', '        require (ppm>0 && ppm<=1000000);\n', '        weight = uint32(ppm);\n', '    }\n', '\n', '    function setFee(uint ppm) onlyAdmin public {\n', '        require (ppm >= 0 && ppm <= 1000000);\n', '        fee = uint32(ppm);\n', '    }\n', '\n', '    /* The number of tokens that are burned, unissued, or otherwise not in circulation */\n', '    function setUncirculatedSupplyCount(uint newValue) onlyAdmin public {\n', '        require (newValue > 0);\n', '        uncirculatedSupplyCount = uint256(newValue);\n', '    }\n', '\n', '    /**\n', '     * The virtual reserve balance set here is added on to the actual ethereum balance of this contract\n', '     * when calculating price for buy/sell. Note that if you have no real ether in the reserve, you will \n', '     * not have liquidity for sells until you have some buys first.\n', '     */\n', '    function setVirtualReserveBalance(uint256 amountInWei) onlyAdmin public {\n', '        virtualReserveBalance = amountInWei;\n', '    }\n', '    \n', '    function setMinReserve(uint256 amountInWei) onlyAdmin public {\n', '        minReserve = amountInWei;\n', '    }     \n', '\n', '    //These methods return information about the exchanger, and the buy / sell rates offered on the Token / ETH pairing.\n', '    //They can be called without gas from any client.\n', '\n', '    /**  \n', '     @dev Audit the reserve balances, in the base token and in ether\n', '     returns: [token balance, ether balance - ledger]\n', '     */\n', '    function getReserveBalances() public view returns (uint256, uint256) {\n', '        return (tokenContract.balanceOf(this), address(this).balance+virtualReserveBalance);\n', '    }\n', '\n', '    /**\n', '     @dev Get the BUY price based on the order size. Returned as the number of tokens that the amountInWei will buy.\n', '     */\n', '    function getPurchasePrice(uint256 amountInWei) public view returns(uint) {\n', '        uint256 purchaseReturn = formulaContract.calculatePurchaseReturn(\n', '            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '            address(this).balance + virtualReserveBalance,\n', '            weight,\n', '            amountInWei \n', '        ); \n', '\n', '        purchaseReturn = (purchaseReturn - ((purchaseReturn * fee) / 1000000));\n', '\n', '        if (purchaseReturn > tokenContract.balanceOf(this)){\n', '            return tokenContract.balanceOf(this);\n', '        }\n', '        return purchaseReturn;\n', '    }\n', '\n', '    /**\n', "     @dev Get the SELL price based on the order size. Returned as amount (in wei) that you'll get for your tokens.\n", '     */\n', '    function getSalePrice(uint256 tokensToSell) public view returns(uint) {\n', '        uint256 saleReturn = formulaContract.calculateSaleReturn(\n', '            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '            address(this).balance + virtualReserveBalance,\n', '            weight,\n', '            tokensToSell \n', '        ); \n', '        saleReturn = (saleReturn - ((saleReturn * fee) / 1000000));\n', '        if (saleReturn > address(this).balance) {\n', '            return address(this).balance;\n', '        }\n', '        return saleReturn;\n', '    }\n', '\n', '    //buy and sell execute live trades against the exchanger. For either method, \n', '    //you must specify your minimum return (in total tokens or ether that you expect to receive for your trade)\n', '    //this protects the trader against slippage due to other orders that make it into earlier blocks after they \n', '    //place their order. \n', '    //\n', "    //With buy, send the amount of ether you want to spend on the token - you'll get it back immediately if minPurchaseReturn\n", '    //is not met or if this Exchanger is not in a condition to service your order (usually this happens when there is not a full \n', '    //reserve of tokens to satisfy the stated weight)\n', '    //\n', '    //With sell, first approve the exchanger to spend the number of tokens you want to sell\n', '    //Then call sell with that number and your minSaleReturn. The token transfer will not happen \n', '    //if the minSaleReturn is not met.\n', '    //\n', '    //Sales always go through, as long as there is any ether in the reserve... but those dumping massive quantities of tokens\n', '    //will naturally be given the shittest rates.\n', '\n', '    /**\n', '     @dev Buy tokens with ether. \n', '     @param minPurchaseReturn The minimum number of tokens you will accept.\n', '     */\n', '    function buy(uint minPurchaseReturn) public payable {\n', '        uint amount = formulaContract.calculatePurchaseReturn(\n', '            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '            (address(this).balance + virtualReserveBalance) - msg.value,\n', '            weight,\n', '            msg.value);\n', '        amount = (amount - ((amount * fee) / 1000000));\n', '        \n', '        //Now do the trade if conditions are met\n', '        require (enabled); // ADDED SEMICOLON    \n', '        require (amount >= minPurchaseReturn);\n', '        require (tokenContract.balanceOf(this) >= amount);\n', '        \n', '        //Accounting - so we can pull the fees out without changing the balance\n', '        collectedFees += (msg.value * fee) / 1000000;\n', '        \n', '        emit Buy(msg.sender, msg.value, amount);\n', '        tokenContract.transfer(msg.sender, amount);\n', '    }\n', '    \n', '    /**\n', '     @dev Sell tokens for ether\n', '     @param quantity Number of tokens to sell\n', '     @param minSaleReturn Minimum amount of ether (in wei) you will accept for your tokens\n', '     */\n', '    function sell(uint quantity, uint minSaleReturn) public {\n', '        uint amountInWei = formulaContract.calculateSaleReturn(\n', '            (tokenContract.totalSupply()- uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '             address(this).balance + virtualReserveBalance,\n', '             weight,\n', '             quantity\n', '        );\n', '        amountInWei = (amountInWei - ((amountInWei * fee) / 1000000));\n', '\n', '        require (enabled); // ADDED SEMICOLON\n', '        require (amountInWei >= minSaleReturn);\n', '        require (amountInWei <= address(this).balance);\n', '        require (address(this).balance - amountInWei > minReserve);\n', '        require (tokenContract.transferFrom(msg.sender, this, quantity));\n', '\n', '        collectedFees += (amountInWei * fee) / 1000000;\n', '\n', '        emit Sell(msg.sender, quantity, amountInWei);\n', '        msg.sender.transfer(amountInWei); //Always send ether last\n', '    }\n', '\n', '    //approveAndCall flow for selling entry point\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external {\n', '        //not needed: if it was the wrong token, the tx fails anyways require(_token == address(tokenContract));\n', '        sellOneStep(_value, 0, _from);\n', '    }    \n', '\n', '    //Variant of sell for one step ordering. The seller calls approveAndCall on the token\n', '    //which calls receiveApproval above, which calls this funciton\n', '    function sellOneStep(uint quantity, uint minSaleReturn, address seller) public {\n', '        uint amountInWei = formulaContract.calculateSaleReturn(\n', '            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '             address(this).balance + virtualReserveBalance,\n', '             weight,\n', '             quantity\n', '        );\n', '        amountInWei = (amountInWei - ((amountInWei * fee) / 1000000));\n', '        \n', '        require (enabled); // ADDED SEMICOLON\n', '        require (amountInWei >= minSaleReturn);\n', '        require (amountInWei <= address(this).balance);\n', '        require (address(this).balance - amountInWei > minReserve);\n', '        require (tokenContract.transferFrom(seller, this, quantity));\n', '\n', '        collectedFees += (amountInWei * fee) / 1000000;\n', '\n', '\n', '        emit Sell(seller, quantity, amountInWei);\n', '        seller.transfer(amountInWei); //Always send ether last\n', '    }\n', '\n', '}']
