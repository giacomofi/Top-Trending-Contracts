['pragma solidity ^0.4.24;\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: node_modules/zos-lib/contracts/application/Package.sol\n', '\n', '/**\n', ' * @title Package\n', ' * @dev A package is composed by a set of versions, identified via semantic versioning,\n', ' * where each version has a contract address that refers to a reusable implementation,\n', ' * plus an optional content URI with metadata. Note that the semver identifier is restricted\n', ' * to major, minor, and patch, as prerelease tags are not supported.\n', ' */\n', 'contract Package is Ownable {\n', '  /**\n', '   * @dev Emitted when a version is added to the package.\n', '   * @param semanticVersion Name of the added version.\n', '   * @param contractAddress Contract associated with the version.\n', '   * @param contentURI Optional content URI with metadata of the version.\n', '   */\n', '  event VersionAdded(uint64[3] semanticVersion, address contractAddress, bytes contentURI);\n', '\n', '  struct Version {\n', '    uint64[3] semanticVersion;\n', '    address contractAddress;\n', '    bytes contentURI; \n', '  }\n', '\n', '  mapping (bytes32 => Version) internal versions;\n', '  mapping (uint64 => bytes32) internal majorToLatestVersion;\n', '  uint64 internal latestMajor;\n', '\n', '  /**\n', '   * @dev Returns a version given its semver identifier.\n', '   * @param semanticVersion Semver identifier of the version.\n', '   * @return Contract address and content URI for the version, or zero if not exists.\n', '   */\n', '  function getVersion(uint64[3] semanticVersion) public view returns (address contractAddress, bytes contentURI) {\n', '    Version storage version = versions[semanticVersionHash(semanticVersion)];\n', '    return (version.contractAddress, version.contentURI); \n', '  }\n', '\n', '  /**\n', '   * @dev Returns a contract for a version given its semver identifier.\n', '   * This method is equivalent to `getVersion`, but returns only the contract address.\n', '   * @param semanticVersion Semver identifier of the version.\n', '   * @return Contract address for the version, or zero if not exists.\n', '   */\n', '  function getContract(uint64[3] semanticVersion) public view returns (address contractAddress) {\n', '    Version storage version = versions[semanticVersionHash(semanticVersion)];\n', '    return version.contractAddress;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds a new version to the package. Only the Owner can add new versions.\n', '   * Reverts if the specified semver identifier already exists. \n', '   * Emits a `VersionAdded` event if successful.\n', '   * @param semanticVersion Semver identifier of the version.\n', '   * @param contractAddress Contract address for the version, must be non-zero.\n', '   * @param contentURI Optional content URI for the version.\n', '   */\n', '  function addVersion(uint64[3] semanticVersion, address contractAddress, bytes contentURI) public onlyOwner {\n', '    require(contractAddress != address(0), "Contract address is required");\n', '    require(!hasVersion(semanticVersion), "Given version is already registered in package");\n', '    require(!semanticVersionIsZero(semanticVersion), "Version must be non zero");\n', '\n', '    // Register version\n', '    bytes32 versionId = semanticVersionHash(semanticVersion);\n', '    versions[versionId] = Version(semanticVersion, contractAddress, contentURI);\n', '    \n', '    // Update latest major\n', '    uint64 major = semanticVersion[0];\n', '    if (major > latestMajor) {\n', '      latestMajor = semanticVersion[0];\n', '    }\n', '\n', '    // Update latest version for this major\n', '    uint64 minor = semanticVersion[1];\n', '    uint64 patch = semanticVersion[2];\n', '    uint64[3] latestVersionForMajor = versions[majorToLatestVersion[major]].semanticVersion;\n', '    if (semanticVersionIsZero(latestVersionForMajor) // No latest was set for this major\n', '       || (minor > latestVersionForMajor[1]) // Or current minor is greater \n', '       || (minor == latestVersionForMajor[1] && patch > latestVersionForMajor[2]) // Or current patch is greater\n', '       ) { \n', '      majorToLatestVersion[major] = versionId;\n', '    }\n', '\n', '    emit VersionAdded(semanticVersion, contractAddress, contentURI);\n', '  }\n', '\n', '  /**\n', '   * @dev Checks whether a version is present in the package.\n', '   * @param semanticVersion Semver identifier of the version.\n', '   * @return true if the version is registered in this package, false otherwise.\n', '   */\n', '  function hasVersion(uint64[3] semanticVersion) public view returns (bool) {\n', '    Version storage version = versions[semanticVersionHash(semanticVersion)];\n', '    return address(version.contractAddress) != address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the version with the highest semver identifier registered in the package.\n', '   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will always return `2.0.0`, regardless \n', '   * of the order in which they were registered. Returns zero if no versions are registered.\n', '   * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.\n', '   */\n', '  function getLatest() public view returns (uint64[3] semanticVersion, address contractAddress, bytes contentURI) {\n', '    return getLatestByMajor(latestMajor);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the version with the highest semver identifier for the given major.\n', '   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will return `1.3.0` for major `1`, \n', '   * regardless of the order in which they were registered. Returns zero if no versions are registered\n', '   * for the specified major.\n', '   * @param major Major identifier to query\n', '   * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.\n', '   */\n', '  function getLatestByMajor(uint64 major) public view returns (uint64[3] semanticVersion, address contractAddress, bytes contentURI) {\n', '    Version storage version = versions[majorToLatestVersion[major]];\n', '    return (version.semanticVersion, version.contractAddress, version.contentURI); \n', '  }\n', '\n', '  function semanticVersionHash(uint64[3] version) internal pure returns (bytes32) {\n', '    return keccak256(abi.encodePacked(version[0], version[1], version[2]));\n', '  }\n', '\n', '  function semanticVersionIsZero(uint64[3] version) internal pure returns (bool) {\n', '    return version[0] == 0 && version[1] == 0 && version[2] == 0;\n', '  }\n', '}']