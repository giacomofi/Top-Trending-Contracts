['pragma solidity ^0.4.21;\n', '\n', '// File: contracts/ISimpleCrowdsale.sol\n', '\n', 'interface ISimpleCrowdsale {\n', '    function getSoftCap() external view returns(uint256);\n', '    function isContributorInLists(address contributorAddress) external view returns(bool);\n', '    function processReservationFundContribution(\n', '        address contributor,\n', '        uint256 tokenAmount,\n', '        uint256 tokenBonusAmount\n', '    ) external payable;\n', '}\n', '\n', '// File: contracts/fund/ICrowdsaleReservationFund.sol\n', '\n', '/**\n', ' * @title ICrowdsaleReservationFund\n', ' * @dev ReservationFund methods used by crowdsale contract\n', ' */\n', 'interface ICrowdsaleReservationFund {\n', '    /**\n', '     * @dev Check if contributor has transactions\n', '     */\n', '    function canCompleteContribution(address contributor) external returns(bool);\n', '    /**\n', '     * @dev Complete contribution\n', '     * @param contributor Contributor`s address\n', '     */\n', '    function completeContribution(address contributor) external;\n', '    /**\n', '     * @dev Function accepts user`s contributed ether and amount of tokens to issue\n', '     * @param contributor Contributor wallet address.\n', '     * @param _tokensToIssue Token amount to issue\n', '     * @param _bonusTokensToIssue Bonus token amount to issue\n', '     */\n', '    function processContribution(address contributor, uint256 _tokensToIssue, uint256 _bonusTokensToIssue) external payable;\n', '\n', '    /**\n', '     * @dev Function returns current user`s contributed ether amount\n', '     */\n', '    function contributionsOf(address contributor) external returns(uint256);\n', '\n', '    /**\n', '     * @dev Function is called on the end of successful crowdsale\n', '     */\n', '    function onCrowdsaleEnd() external;\n', '}\n', '\n', '// File: contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMath {\n', '    /**\n', '    * @dev constructor\n', '    */\n', '    function SafeMath() public {\n', '    }\n', '\n', '    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(a >= b);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address previousOwner, address newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract.\n', '    */\n', '    function Ownable(address _owner) public {\n', '        owner = _owner == address(0) ? msg.sender : _owner;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '    * @dev confirm ownership by a new owner\n', '    */\n', '    function confirmOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', '// File: contracts/ReservationFund.sol\n', '\n', 'contract ReservationFund is ICrowdsaleReservationFund, Ownable, SafeMath {\n', '    bool public crowdsaleFinished = false;\n', '\n', '    mapping(address => uint256) contributions;\n', '    mapping(address => uint256) tokensToIssue;\n', '    mapping(address => uint256) bonusTokensToIssue;\n', '\n', '    ISimpleCrowdsale public crowdsale;\n', '\n', '    event RefundPayment(address contributor, uint256 etherAmount);\n', '    event TransferToFund(address contributor, uint256 etherAmount);\n', '    event FinishCrowdsale();\n', '\n', '    function ReservationFund(address _owner) public Ownable(_owner) {\n', '    }\n', '\n', '    modifier onlyCrowdsale() {\n', '        require(msg.sender == address(crowdsale));\n', '        _;\n', '    }\n', '\n', '    function setCrowdsaleAddress(address crowdsaleAddress) public onlyOwner {\n', '        require(crowdsale == address(0));\n', '        crowdsale = ISimpleCrowdsale(crowdsaleAddress);\n', '    }\n', '\n', '    function onCrowdsaleEnd() external onlyCrowdsale {\n', '        crowdsaleFinished = true;\n', '        FinishCrowdsale();\n', '    }\n', '\n', '\n', '    function canCompleteContribution(address contributor) external returns(bool) {\n', '        if(crowdsaleFinished) {\n', '            return false;\n', '        }\n', '        if(!crowdsale.isContributorInLists(contributor)) {\n', '            return false;\n', '        }\n', '        if(contributions[contributor] == 0) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check contributions by address\n', '     */\n', '    function contributionsOf(address contributor) external returns(uint256) {\n', '        return contributions[contributor];\n', '    }\n', '\n', '    /**\n', '     * @dev Process crowdsale contribution without whitelist\n', '     */\n', '    function processContribution(\n', '        address contributor,\n', '        uint256 _tokensToIssue,\n', '        uint256 _bonusTokensToIssue\n', '    ) external payable onlyCrowdsale {\n', '        contributions[contributor] = safeAdd(contributions[contributor], msg.value);\n', '        tokensToIssue[contributor] = safeAdd(tokensToIssue[contributor], _tokensToIssue);\n', '        bonusTokensToIssue[contributor] = safeAdd(bonusTokensToIssue[contributor], _bonusTokensToIssue);\n', '    }\n', '\n', '    /**\n', '     * @dev Complete contribution after if user is whitelisted\n', '     */\n', '    function completeContribution(address contributor) external {\n', '        require(!crowdsaleFinished);\n', '        require(crowdsale.isContributorInLists(contributor));\n', '        require(contributions[contributor] > 0);\n', '\n', '        uint256 etherAmount = contributions[contributor];\n', '        uint256 tokenAmount = tokensToIssue[contributor];\n', '        uint256 tokenBonusAmount = bonusTokensToIssue[contributor];\n', '\n', '        contributions[contributor] = 0;\n', '        tokensToIssue[contributor] = 0;\n', '        bonusTokensToIssue[contributor] = 0;\n', '\n', '        crowdsale.processReservationFundContribution.value(etherAmount)(contributor, tokenAmount, tokenBonusAmount);\n', '        TransferToFund(contributor, etherAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Refund payments if crowdsale is finalized\n', '     */\n', '    function refundPayment(address contributor) public {\n', '        require(crowdsaleFinished);\n', '        require(contributions[contributor] > 0 || tokensToIssue[contributor] > 0);\n', '        uint256 amountToRefund = contributions[contributor];\n', '\n', '        contributions[contributor] = 0;\n', '        tokensToIssue[contributor] = 0;\n', '        bonusTokensToIssue[contributor] = 0;\n', '\n', '        contributor.transfer(amountToRefund);\n', '        RefundPayment(contributor, amountToRefund);\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '// File: contracts/ISimpleCrowdsale.sol\n', '\n', 'interface ISimpleCrowdsale {\n', '    function getSoftCap() external view returns(uint256);\n', '    function isContributorInLists(address contributorAddress) external view returns(bool);\n', '    function processReservationFundContribution(\n', '        address contributor,\n', '        uint256 tokenAmount,\n', '        uint256 tokenBonusAmount\n', '    ) external payable;\n', '}\n', '\n', '// File: contracts/fund/ICrowdsaleReservationFund.sol\n', '\n', '/**\n', ' * @title ICrowdsaleReservationFund\n', ' * @dev ReservationFund methods used by crowdsale contract\n', ' */\n', 'interface ICrowdsaleReservationFund {\n', '    /**\n', '     * @dev Check if contributor has transactions\n', '     */\n', '    function canCompleteContribution(address contributor) external returns(bool);\n', '    /**\n', '     * @dev Complete contribution\n', '     * @param contributor Contributor`s address\n', '     */\n', '    function completeContribution(address contributor) external;\n', '    /**\n', '     * @dev Function accepts user`s contributed ether and amount of tokens to issue\n', '     * @param contributor Contributor wallet address.\n', '     * @param _tokensToIssue Token amount to issue\n', '     * @param _bonusTokensToIssue Bonus token amount to issue\n', '     */\n', '    function processContribution(address contributor, uint256 _tokensToIssue, uint256 _bonusTokensToIssue) external payable;\n', '\n', '    /**\n', '     * @dev Function returns current user`s contributed ether amount\n', '     */\n', '    function contributionsOf(address contributor) external returns(uint256);\n', '\n', '    /**\n', '     * @dev Function is called on the end of successful crowdsale\n', '     */\n', '    function onCrowdsaleEnd() external;\n', '}\n', '\n', '// File: contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMath {\n', '    /**\n', '    * @dev constructor\n', '    */\n', '    function SafeMath() public {\n', '    }\n', '\n', '    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(a >= b);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address previousOwner, address newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract.\n', '    */\n', '    function Ownable(address _owner) public {\n', '        owner = _owner == address(0) ? msg.sender : _owner;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '    * @dev confirm ownership by a new owner\n', '    */\n', '    function confirmOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', '// File: contracts/ReservationFund.sol\n', '\n', 'contract ReservationFund is ICrowdsaleReservationFund, Ownable, SafeMath {\n', '    bool public crowdsaleFinished = false;\n', '\n', '    mapping(address => uint256) contributions;\n', '    mapping(address => uint256) tokensToIssue;\n', '    mapping(address => uint256) bonusTokensToIssue;\n', '\n', '    ISimpleCrowdsale public crowdsale;\n', '\n', '    event RefundPayment(address contributor, uint256 etherAmount);\n', '    event TransferToFund(address contributor, uint256 etherAmount);\n', '    event FinishCrowdsale();\n', '\n', '    function ReservationFund(address _owner) public Ownable(_owner) {\n', '    }\n', '\n', '    modifier onlyCrowdsale() {\n', '        require(msg.sender == address(crowdsale));\n', '        _;\n', '    }\n', '\n', '    function setCrowdsaleAddress(address crowdsaleAddress) public onlyOwner {\n', '        require(crowdsale == address(0));\n', '        crowdsale = ISimpleCrowdsale(crowdsaleAddress);\n', '    }\n', '\n', '    function onCrowdsaleEnd() external onlyCrowdsale {\n', '        crowdsaleFinished = true;\n', '        FinishCrowdsale();\n', '    }\n', '\n', '\n', '    function canCompleteContribution(address contributor) external returns(bool) {\n', '        if(crowdsaleFinished) {\n', '            return false;\n', '        }\n', '        if(!crowdsale.isContributorInLists(contributor)) {\n', '            return false;\n', '        }\n', '        if(contributions[contributor] == 0) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check contributions by address\n', '     */\n', '    function contributionsOf(address contributor) external returns(uint256) {\n', '        return contributions[contributor];\n', '    }\n', '\n', '    /**\n', '     * @dev Process crowdsale contribution without whitelist\n', '     */\n', '    function processContribution(\n', '        address contributor,\n', '        uint256 _tokensToIssue,\n', '        uint256 _bonusTokensToIssue\n', '    ) external payable onlyCrowdsale {\n', '        contributions[contributor] = safeAdd(contributions[contributor], msg.value);\n', '        tokensToIssue[contributor] = safeAdd(tokensToIssue[contributor], _tokensToIssue);\n', '        bonusTokensToIssue[contributor] = safeAdd(bonusTokensToIssue[contributor], _bonusTokensToIssue);\n', '    }\n', '\n', '    /**\n', '     * @dev Complete contribution after if user is whitelisted\n', '     */\n', '    function completeContribution(address contributor) external {\n', '        require(!crowdsaleFinished);\n', '        require(crowdsale.isContributorInLists(contributor));\n', '        require(contributions[contributor] > 0);\n', '\n', '        uint256 etherAmount = contributions[contributor];\n', '        uint256 tokenAmount = tokensToIssue[contributor];\n', '        uint256 tokenBonusAmount = bonusTokensToIssue[contributor];\n', '\n', '        contributions[contributor] = 0;\n', '        tokensToIssue[contributor] = 0;\n', '        bonusTokensToIssue[contributor] = 0;\n', '\n', '        crowdsale.processReservationFundContribution.value(etherAmount)(contributor, tokenAmount, tokenBonusAmount);\n', '        TransferToFund(contributor, etherAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Refund payments if crowdsale is finalized\n', '     */\n', '    function refundPayment(address contributor) public {\n', '        require(crowdsaleFinished);\n', '        require(contributions[contributor] > 0 || tokensToIssue[contributor] > 0);\n', '        uint256 amountToRefund = contributions[contributor];\n', '\n', '        contributions[contributor] = 0;\n', '        tokensToIssue[contributor] = 0;\n', '        bonusTokensToIssue[contributor] = 0;\n', '\n', '        contributor.transfer(amountToRefund);\n', '        RefundPayment(contributor, amountToRefund);\n', '    }\n', '}']
