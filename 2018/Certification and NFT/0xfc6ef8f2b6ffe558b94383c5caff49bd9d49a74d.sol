['pragma solidity 0.4.24;\n', '\n', '// File: contracts/EventRegistry.sol\n', '\n', 'contract EventRegistry {\n', '    address[] verityEvents;\n', '    mapping(address => bool) verityEventsMap;\n', '\n', '    mapping(address => address[]) userEvents;\n', '\n', '    event NewVerityEvent(address eventAddress);\n', '\n', '    function registerEvent() public {\n', '        verityEvents.push(msg.sender);\n', '        verityEventsMap[msg.sender] = true;\n', '        emit NewVerityEvent(msg.sender);\n', '    }\n', '\n', '    function getUserEvents() public view returns(address[]) {\n', '        return userEvents[msg.sender];\n', '    }\n', '\n', '    function addEventToUser(address _user) external {\n', '        require(verityEventsMap[msg.sender]);\n', '\n', '        userEvents[_user].push(msg.sender);\n', '    }\n', '\n', '    function getEventsLength() public view returns(uint) {\n', '        return verityEvents.length;\n', '    }\n', '\n', '    function getEventsByIds(uint[] _ids) public view returns(uint[], address[]) {\n', '        address[] memory _events = new address[](_ids.length);\n', '\n', '        for(uint i = 0; i < _ids.length; ++i) {\n', '            _events[i] = verityEvents[_ids[i]];\n', '        }\n', '\n', '        return (_ids, _events);\n', '    }\n', '\n', '    function getUserEventsLength(address _user)\n', '        public\n', '        view\n', '        returns(uint)\n', '    {\n', '        return userEvents[_user].length;\n', '    }\n', '\n', '    function getUserEventsByIds(address _user, uint[] _ids)\n', '        public\n', '        view\n', '        returns(uint[], address[])\n', '    {\n', '        address[] memory _events = new address[](_ids.length);\n', '\n', '        for(uint i = 0; i < _ids.length; ++i) {\n', '            _events[i] = userEvents[_user][_ids[i]];\n', '        }\n', '\n', '        return (_ids, _events);\n', '    }\n', '}\n', '\n', '// File: contracts/VerityToken.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract VerityToken is StandardToken {\n', '  string public name = "VerityToken";\n', '  string public symbol = "VTY";\n', '  uint8 public decimals = 18;\n', '  uint public INITIAL_SUPPLY = 500000000 * 10 ** uint(decimals);\n', '\n', '  constructor() public {\n', '    totalSupply_ = INITIAL_SUPPLY;\n', '    balances[msg.sender] = INITIAL_SUPPLY;\n', '  }\n', '}\n', '\n', '// File: contracts/VerityEvent.sol\n', '\n', 'contract VerityEvent {\n', "    /// Contract's owner, used for permission management\n", '    address public owner;\n', '\n', '    /// Token contract address, used for tokend distribution\n', '    address public tokenAddress;\n', '\n', '    /// Event registry contract address\n', '    address public eventRegistryAddress;\n', '\n', '    /// Designated validation nodes that will decide rewards.\n', '    address[] eventResolvers;\n', '\n', '    /// - WaitingForRewards: Waiting for current master to set rewards.\n', '    /// - Validating: Master has set rewards. Vaiting for node validation.\n', '    /// - Finished: Either successfully validated or failed.\n', '    enum ValidationState {\n', '        WaitingForRewards,\n', '        Validating,\n', '        Finished\n', '    }\n', '    ValidationState validationState = ValidationState.WaitingForRewards;\n', '\n', '    struct RewardsValidation {\n', '        address currentMasterNode;\n', '        string rewardsHash;\n', '        uint approvalCount;\n', '        uint rejectionCount;\n', '        string[] altHashes;\n', '        mapping(address => uint) votersRound;\n', '        mapping(string => address[]) altHashVotes;\n', '        mapping(string => bool) rejectedHashes;\n', '    }\n', '    RewardsValidation rewardsValidation;\n', '\n', '    /// Round of validation. Increases by each failed validation\n', '    uint public rewardsValidationRound;\n', '\n', '    /// A list of all the participating wallet addresses, implemented as a mapping\n', '    /// to provide constant lookup times.\n', '    mapping(address => bool) participants;\n', '    address[] participantsIndex;\n', '\n', '    enum RewardType {\n', '        Ether,\n', '        Token\n', '    }\n', '    RewardType rewardType;\n', '\n', '    /// A mapping of addresses to their assigned rewards\n', '    mapping(address => mapping(uint => uint)) rewards;\n', '    address[] rewardsIndex;\n', '\n', '    /// Event application start time, users cannot apply to participate before it\n', '    uint applicationStartTime;\n', '\n', '    /// Event application end time, users cannot apply after this time\n', '    uint applicationEndTime;\n', '\n', '    /// Event actual start time, votes before this should not be accepted\n', '    uint eventStartTime;\n', '\n', '    /// Event end time, it is calculated in the constructor\n', '    uint eventEndTime;\n', '\n', '    /// Ipfs event data hash\n', '    string ipfsEventHash;\n', '\n', '    /// Event name, here for informational use - not used otherwise\n', '    /// owner can recover tokens and ether after this time\n', '    uint leftoversRecoverableAfter;\n', '\n', '    /// Amount of tokens that each user must stake before voting.\n', '    uint public stakingAmount;\n', '\n', '    struct Dispute {\n', '        uint amount;\n', '        uint timeout;\n', '        uint round;\n', '        uint expiresAt;\n', '        uint multiplier;\n', '        mapping(address => bool) disputers;\n', '        address currentDisputer;\n', '    }\n', '    Dispute dispute;\n', '\n', '    uint defaultDisputeTimeExtension = 1800; // 30 minutes\n', '\n', '    string public eventName;\n', '\n', '    /// Data feed hash, used for verification\n', '    string public dataFeedHash;\n', '\n', '    bytes32[] results;\n', '\n', '    enum RewardsDistribution {\n', '        Linear, // 0\n', '        Exponential // 1\n', '    }\n', '\n', '    struct ConsensusRules {\n', '        uint minTotalVotes;\n', '        uint minConsensusVotes;\n', '        uint minConsensusRatio;\n', '        uint minParticipantRatio;\n', '        uint maxParticipants;\n', '        RewardsDistribution rewardsDistribution;\n', '    }\n', '    ConsensusRules consensusRules;\n', '\n', "    /// Event's states\n", '    /// Events advance in the order defined here. Once the event reaches "Reward"\n', '    /// state, it cannot advance further.\n', '    /// Event states:\n', '    ///   - Waiting         -- Contract has been created, nothing is happening yet\n', '    ///   - Application     -- After applicationStartTime, the event advances here\n', '    ///                        new wallets can be added to the participats list during this state.\n', '    ///   - Running         -- Event is running, no new participants can be added\n', '    ///   - DisputeTimeout  -- Dispute possible\n', "    ///   - Reward          -- Participants can claim their payouts here - final state; can't be modified.\n", "    ///   - Failed          -- Event failed (no consensus, not enough users, timeout, ...) - final state; can't be modified\n", '    enum EventStates {\n', '        Waiting,\n', '        Application,\n', '        Running,\n', '        DisputeTimeout,\n', '        Reward,\n', '        Failed\n', '    }\n', '    EventStates eventState = EventStates.Waiting;\n', '\n', '    event StateTransition(EventStates newState);\n', '    event JoinEvent(address wallet);\n', '    event ClaimReward(address recipient);\n', '    event Error(string description);\n', '    event EventFailed(string description);\n', '    event ValidationStarted(uint validationRound);\n', '    event ValidationRestart(uint validationRound);\n', '    event DisputeTriggered(address byAddress);\n', '    event ClaimStake(address recipient);\n', '\n', '    constructor(\n', '        string _eventName,\n', '        uint _applicationStartTime,\n', '        uint _applicationEndTime,\n', '        uint _eventStartTime,\n', '        uint _eventRunTime, // in seconds\n', '        address _tokenAddress,\n', '        address _registry,\n', '        address[] _eventResolvers,\n', '        uint _leftoversRecoverableAfter, // with timestamp (in seconds)\n', '        uint[6] _consensusRules, // [minTotalVotes, minConsensusVotes, minConsensusRatio, minParticipantRatio, maxParticipants, distribution]\n', '        uint _stakingAmount,\n', '        uint[3] _disputeRules, // [dispute amount, dispute timeout, dispute multiplier]\n', '        string _ipfsEventHash\n', '    )\n', '        public\n', '        payable\n', '    {\n', '        require(_applicationStartTime < _applicationEndTime);\n', '        require(_eventStartTime > _applicationEndTime, "Event can\'t start before applications close.");\n', '\n', '        applicationStartTime = _applicationStartTime;\n', '        applicationEndTime = _applicationEndTime;\n', '        tokenAddress = _tokenAddress;\n', '\n', '        eventName = _eventName;\n', '        eventStartTime = _eventStartTime;\n', '        eventEndTime = _eventStartTime + _eventRunTime;\n', '\n', '        eventResolvers = _eventResolvers;\n', '\n', '        owner = msg.sender;\n', '        leftoversRecoverableAfter = _leftoversRecoverableAfter;\n', '\n', '        rewardsValidationRound = 1;\n', '        rewardsValidation.currentMasterNode = eventResolvers[0];\n', '\n', '        stakingAmount = _stakingAmount;\n', '\n', '        ipfsEventHash = _ipfsEventHash;\n', '\n', '        setConsensusRules(_consensusRules);\n', '        setDisputeData(_disputeRules);\n', '\n', '        eventRegistryAddress = _registry;\n', '\n', '        EventRegistry(eventRegistryAddress).registerEvent();\n', '    }\n', '\n', '    /// A modifier signifiying that a certain method can only be used by the creator\n', '    /// of the contract.\n', '    /// Rollbacks the transaction on failure.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /// A modifier signifiying that rewards can be set only by the designated master node.\n', '    /// Rollbacks the transaction on failure.\n', '    modifier onlyCurrentMaster() {\n', '        require(\n', '            msg.sender == rewardsValidation.currentMasterNode,\n', '            "Not a designated master node."\n', '        );\n', '        _;\n', '    }\n', '\n', '    ///\tA modifier signifying that a certain method can only be used by a wallet\n', '    ///\tmarked as a participant.\n', '    ///\tRollbacks the transaction or failure.\n', '    modifier onlyParticipating() {\n', '        require(\n', '            isParticipating(msg.sender),\n', '            "Not participating."\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// A modifier signifying that a certain method can only be used when the event\n', '    /// is in a certain state.\n', "    /// @param _state The event's required state\n", '    /// Example:\n', '    /// \tfunction claimReward() onlyParticipanting onlyState(EventStates.Reward) {\n', '    /// \t\t// ... content\n', '    /// \t}\n', '    modifier onlyState(EventStates _state) {\n', '        require(\n', '            _state == eventState,\n', '            "Not possible in current event state."\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// A modifier taking care of all the timed state transitions.\n', '    /// Should always be used before all other modifiers, especially `onlyState`,\n', '    /// since it can change state.\n', '    /// Should probably be used in ALL non-constant (transaction) methods of\n', '    /// the contract.\n', '    modifier timedStateTransition() {\n', '        if (eventState == EventStates.Waiting && now >= applicationStartTime) {\n', '            advanceState();\n', '        }\n', '\n', '        if (eventState == EventStates.Application && now >= applicationEndTime) {\n', '            if (participantsIndex.length < consensusRules.minTotalVotes) {\n', '                markAsFailed("Not enough users joined for required minimum votes.");\n', '            } else {\n', '                advanceState();\n', '            }\n', '        }\n', '\n', '        if (eventState == EventStates.DisputeTimeout && now >= dispute.expiresAt) {\n', '            advanceState();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier onlyChangeableState() {\n', '        require(\n', '            uint(eventState) < uint(EventStates.Reward),\n', '            "Event state can\'t be modified anymore."\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyAfterLefroversCanBeRecovered() {\n', '        require(now >= leftoversRecoverableAfter);\n', '        _;\n', '    }\n', '\n', '    modifier canValidateRewards(uint forRound) {\n', '        require(\n', '            isNode(msg.sender) && !isMasterNode(),\n', '            "Not a valid sender address."\n', '        );\n', '\n', '        require(\n', '            validationState == ValidationState.Validating,\n', '            "Not validating rewards."\n', '        );\n', '\n', '        require(\n', '            forRound == rewardsValidationRound,\n', '            "Validation round mismatch."\n', '        );\n', '\n', '        require(\n', '            rewardsValidation.votersRound[msg.sender] < rewardsValidationRound,\n', '            "Already voted for this round."\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// Ensure we can receive money at any time.\n', '    /// Not used, but we might want to extend the reward fund while event is running.\n', '    function() public payable {}\n', '\n', '    /// Apply for participation in this event.\n', '    /// Available only during the Application state.\n', '    /// A transaction to this function has to be done by the users themselves,\n', '    /// registering their wallet address as a participent.\n', '    /// The transaction does not have to include any funds.\n', '    function joinEvent()\n', '        public\n', '        timedStateTransition\n', '    {\n', '        if (isParticipating(msg.sender)) {\n', '            emit Error("You are already participating.");\n', '            return;\n', '        }\n', '\n', '        if (eventState != EventStates.Application) {\n', '            emit Error("You can only join in the Application state.");\n', '            return;\n', '        }\n', '\n', '        if (\n', '            stakingAmount > 0 &&\n', '            VerityToken(tokenAddress).allowance(msg.sender, address(this)) < stakingAmount\n', '        ) {\n', '            emit Error("Not enough tokens staked.");\n', '            return;\n', '        }\n', '\n', '        if (stakingAmount > 0) {\n', '            VerityToken(tokenAddress).transferFrom(msg.sender, address(this), stakingAmount);\n', '        }\n', '        participants[msg.sender] = true;\n', '        participantsIndex.push(msg.sender);\n', '        EventRegistry(eventRegistryAddress).addEventToUser(msg.sender);\n', '        emit JoinEvent(msg.sender);\n', '    }\n', '\n', '    /// Checks whether an address is participating in this event.\n', '    /// @param _user The addres to check for participation\n', '    /// @return {bool} Whether the given address is a participant of this event\n', '    function isParticipating(address _user) public view returns(bool) {\n', '        return participants[_user];\n', '    }\n', '\n', '    function getParticipants() public view returns(address[]) {\n', '        return participantsIndex;\n', '    }\n', '\n', '    function getEventTimes() public view returns(uint[5]) {\n', '        return [\n', '            applicationStartTime,\n', '            applicationEndTime,\n', '            eventStartTime,\n', '            eventEndTime,\n', '            leftoversRecoverableAfter\n', '        ];\n', '    }\n', '\n', '    /// Assign the actual rewards.\n', '    /// Receives a list of addresses and a list rewards. Mapping between the two\n', "    /// is done by the addresses' and reward's numerical index in the list, so\n", '    /// order is important.\n', '    /// @param _addresses A list of addresses\n', '    /// @param _etherRewards A list of ether rewards, must be the exact same length as addresses\n', '    /// @param _tokenRewards A list of token rewards, must be the exact same length as addresses\n', '    function setRewards(\n', '        address[] _addresses,\n', '        uint[] _etherRewards,\n', '        uint[] _tokenRewards\n', '    )\n', '        public\n', '        onlyCurrentMaster\n', '        timedStateTransition\n', '        onlyState(EventStates.Running)\n', '    {\n', '        require(\n', '            _addresses.length == _etherRewards.length &&\n', '            _addresses.length == _tokenRewards.length\n', '        );\n', '\n', '        require(\n', '            validationState == ValidationState.WaitingForRewards,\n', '            "Not possible in this validation state."\n', '        );\n', '\n', '        for (uint i = 0; i < _addresses.length; ++i) {\n', '            rewards[_addresses[i]][uint(RewardType.Ether)] = _etherRewards[i];\n', '            rewards[_addresses[i]][uint(RewardType.Token)] = _tokenRewards[i];\n', '            rewardsIndex.push(_addresses[i]);\n', '        }\n', '    }\n', '\n', '    /// Triggered by the master node once rewards are set and ready to validate\n', '    function markRewardsSet(string rewardsHash)\n', '        public\n', '        onlyCurrentMaster\n', '        timedStateTransition\n', '        onlyState(EventStates.Running)\n', '    {\n', '        require(\n', '            validationState == ValidationState.WaitingForRewards,\n', '            "Not possible in this validation state."\n', '        );\n', '\n', '        rewardsValidation.rewardsHash = rewardsHash;\n', '        rewardsValidation.approvalCount = 1;\n', '        validationState = ValidationState.Validating;\n', '        emit ValidationStarted(rewardsValidationRound);\n', '    }\n', '\n', '    /// Called by event resolver nodes if they agree with rewards\n', '    function approveRewards(uint validationRound)\n', '        public\n', '        onlyState(EventStates.Running)\n', '        canValidateRewards(validationRound)\n', '    {\n', '        ++rewardsValidation.approvalCount;\n', '        rewardsValidation.votersRound[msg.sender] = rewardsValidationRound;\n', '        checkApprovalRatio();\n', '    }\n', '\n', "    /// Called by event resolvers if they don't agree with rewards\n", '    function rejectRewards(uint validationRound, string altHash)\n', '        public\n', '        onlyState(EventStates.Running)\n', '        canValidateRewards(validationRound)\n', '    {\n', '        ++rewardsValidation.rejectionCount;\n', '        rewardsValidation.votersRound[msg.sender] = rewardsValidationRound;\n', '\n', '        if (!rewardsValidation.rejectedHashes[altHash]) {\n', '            rewardsValidation.altHashes.push(altHash);\n', '            rewardsValidation.altHashVotes[altHash].push(msg.sender);\n', '        }\n', '\n', '        checkRejectionRatio();\n', '    }\n', '\n', '    /// Trigger a dispute.\n', '    function triggerDispute()\n', '        public\n', '        timedStateTransition\n', '        onlyParticipating\n', '        onlyState(EventStates.DisputeTimeout)\n', '    {\n', '        require(\n', '            VerityToken(tokenAddress).allowance(msg.sender, address(this)) >=\n', '            dispute.amount * dispute.multiplier**dispute.round,\n', '            "Not enough tokens staked for dispute."\n', '        );\n', '\n', '        require(\n', '            dispute.disputers[msg.sender] == false,\n', '            "Already triggered a dispute."\n', '        );\n', '\n', '        /// Increase dispute amount for next dispute and store disputer\n', '        dispute.amount = dispute.amount * dispute.multiplier**dispute.round;\n', '        ++dispute.round;\n', '        dispute.disputers[msg.sender] = true;\n', '        dispute.currentDisputer = msg.sender;\n', '\n', '        /// Transfer staked amount\n', '        VerityToken(tokenAddress).transferFrom(msg.sender, address(this), dispute.amount);\n', '\n', '        /// Restart event\n', '        deleteValidationData();\n', '        deleteRewards();\n', '        eventState = EventStates.Application;\n', '        applicationEndTime = eventStartTime = now + defaultDisputeTimeExtension;\n', '        eventEndTime = eventStartTime + defaultDisputeTimeExtension;\n', '\n', '        /// Make consensus rules stricter\n', '        /// Increases by ~10% of consensus diff\n', '        consensusRules.minConsensusRatio += (100 - consensusRules.minConsensusRatio) * 100 / 1000;\n', '        /// Increase total votes required my ~10% and consensus votes by consensus ratio\n', '        uint votesIncrease = consensusRules.minTotalVotes * 100 / 1000;\n', '        consensusRules.minTotalVotes += votesIncrease;\n', '        consensusRules.minConsensusVotes += votesIncrease * consensusRules.minConsensusRatio / 100;\n', '\n', '        emit DisputeTriggered(msg.sender);\n', '    }\n', '\n', '    /// Checks current approvals for threshold\n', '    function checkApprovalRatio() private {\n', '        if (approvalRatio() >= consensusRules.minConsensusRatio) {\n', '            validationState = ValidationState.Finished;\n', '            dispute.expiresAt = now + dispute.timeout;\n', '            advanceState();\n', '        }\n', '    }\n', '\n', '    /// Checks current rejections for threshold\n', '    function checkRejectionRatio() private {\n', '        if (rejectionRatio() >= (100 - consensusRules.minConsensusRatio)) {\n', '            rejectCurrentValidation();\n', '        }\n', '    }\n', '\n', '    /// Handle the rejection of current rewards\n', '    function rejectCurrentValidation() private {\n', '        rewardsValidation.rejectedHashes[rewardsValidation.rewardsHash] = true;\n', '\n', '        // If approved votes are over the threshold all other hashes will also fail\n', '        if (\n', '            rewardsValidation.approvalCount + rewardsValidationRound - 1 >\n', '            rewardsValidation.rejectionCount - rewardsValidation.altHashes.length + 1\n', '        ) {\n', '            markAsFailed("Consensus can\'t be reached");\n', '        } else {\n', '            restartValidation();\n', '        }\n', '    }\n', '\n', '    function restartValidation() private {\n', '        ++rewardsValidationRound;\n', '        rewardsValidation.currentMasterNode = rewardsValidation.altHashVotes[rewardsValidation.altHashes[0]][0];\n', '\n', '        deleteValidationData();\n', '        deleteRewards();\n', '\n', '        emit ValidationRestart(rewardsValidationRound);\n', '    }\n', '\n', '    /// Delete rewards.\n', '    function deleteRewards() private {\n', '        for (uint j = 0; j < rewardsIndex.length; ++j) {\n', '            rewards[rewardsIndex[j]][uint(RewardType.Ether)] = 0;\n', '            rewards[rewardsIndex[j]][uint(RewardType.Token)] = 0;\n', '        }\n', '        delete rewardsIndex;\n', '    }\n', '\n', '    /// Delete validation data\n', '    function deleteValidationData() private {\n', '        rewardsValidation.approvalCount = 0;\n', '        rewardsValidation.rejectionCount = 0;\n', '        for (uint i = 0; i < rewardsValidation.altHashes.length; ++i) {\n', '            delete rewardsValidation.altHashVotes[rewardsValidation.altHashes[i]];\n', '        }\n', '        delete rewardsValidation.altHashes;\n', '        validationState = ValidationState.WaitingForRewards;\n', '    }\n', '\n', '    /// Ratio of nodes that approved of current hash\n', '    function approvalRatio() private view returns(uint) {\n', '        return rewardsValidation.approvalCount * 100 / eventResolvers.length;\n', '    }\n', '\n', '    /// Ratio of nodes that rejected the current hash\n', '    function rejectionRatio() private view returns(uint) {\n', '        return rewardsValidation.rejectionCount * 100 / eventResolvers.length;\n', '    }\n', '\n', '    /// Returns the whole array of event resolvers.\n', '    function getEventResolvers() public view returns(address[]) {\n', '        return eventResolvers;\n', '    }\n', '\n', '    /// Checks if the address is current master node.\n', '    function isMasterNode() public view returns(bool) {\n', '        return rewardsValidation.currentMasterNode == msg.sender;\n', '    }\n', '\n', '    function isNode(address node) private view returns(bool) {\n', '        for(uint i = 0; i < eventResolvers.length; ++i) {\n', '            if(eventResolvers[i] == node) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', "    /// Returns the calling user's assigned rewards. Can be 0.\n", '    /// Only available to participating users in the Reward state, since rewards\n', '    /// are not assigned before that.\n', '    function getReward()\n', '        public\n', '        view\n', '        returns(uint[2])\n', '    {\n', '        return [\n', '            rewards[msg.sender][uint(RewardType.Ether)],\n', '            rewards[msg.sender][uint(RewardType.Token)]\n', '        ];\n', '    }\n', '\n', '    /// Returns all the addresses that have rewards set.\n', '    function getRewardsIndex() public view returns(address[]) {\n', '        return rewardsIndex;\n', '    }\n', '\n', '    /// Returns rewards for specified addresses.\n', '    /// [[ethRewards, tokenRewards], [ethRewards, tokenRewards], ...]\n', '    function getRewards(address[] _addresses)\n', '        public\n', '        view\n', '        returns(uint[], uint[])\n', '    {\n', '        uint[] memory ethRewards = new uint[](_addresses.length);\n', '        uint[] memory tokenRewards = new uint[](_addresses.length);\n', '\n', '        for(uint i = 0; i < _addresses.length; ++i) {\n', '            ethRewards[i] = rewards[_addresses[i]][uint(RewardType.Ether)];\n', '            tokenRewards[i] = rewards[_addresses[i]][uint(RewardType.Token)];\n', '        }\n', '\n', '        return (ethRewards, tokenRewards);\n', '    }\n', '\n', '    /// Claim a reward.\n', '    /// Needs to be called by the users themselves.\n', '    /// Only available in the Reward state, after rewards have been received from\n', '    /// the validation nodes.\n', '    function claimReward()\n', '        public\n', '        onlyParticipating\n', '        timedStateTransition\n', '        onlyState(EventStates.Reward)\n', '    {\n', '        uint etherReward = rewards[msg.sender][uint(RewardType.Ether)];\n', '        uint tokenReward = rewards[msg.sender][uint(RewardType.Token)];\n', '\n', '        if (etherReward == 0 && tokenReward == 0) {\n', '            emit Error("You do not have any rewards to claim.");\n', '            return;\n', '        }\n', '\n', '        if (\n', '            address(this).balance < rewards[msg.sender][uint(RewardType.Ether)] ||\n', '            VerityToken(tokenAddress).balanceOf(address(this)) < rewards[msg.sender][uint(RewardType.Token)]\n', '        ) {\n', '            emit Error("Critical error: not enough balance to pay out reward. Contact Verity.");\n', '            return;\n', '        }\n', '\n', '        rewards[msg.sender][uint(RewardType.Ether)] = 0;\n', '        rewards[msg.sender][uint(RewardType.Token)] = 0;\n', '\n', '        msg.sender.transfer(etherReward);\n', '        if (tokenReward > 0) {\n', '            VerityToken(tokenAddress).transfer(msg.sender, tokenReward);\n', '        }\n', '\n', '        emit ClaimReward(msg.sender);\n', '    }\n', '\n', '    function claimFailed()\n', '        public\n', '        onlyParticipating\n', '        timedStateTransition\n', '        onlyState(EventStates.Failed)\n', '    {\n', '        require(\n', '            stakingAmount > 0,\n', '            "No stake to claim"\n', '        );\n', '\n', '        VerityToken(tokenAddress).transfer(msg.sender, stakingAmount);\n', '        participants[msg.sender] = false;\n', '        emit ClaimStake(msg.sender);\n', '    }\n', '\n', '    function setDataFeedHash(string _hash) public onlyOwner {\n', '        dataFeedHash = _hash;\n', '    }\n', '\n', '    function setResults(bytes32[] _results)\n', '        public\n', '        onlyCurrentMaster\n', '        timedStateTransition\n', '        onlyState(EventStates.Running)\n', '    {\n', '        results = _results;\n', '    }\n', '\n', '    function getResults() public view returns(bytes32[]) {\n', '        return results;\n', '    }\n', '\n', '    function getState() public view returns(uint) {\n', '        return uint(eventState);\n', '    }\n', '\n', '    function getBalance() public view returns(uint[2]) {\n', '        return [\n', '            address(this).balance,\n', '            VerityToken(tokenAddress).balanceOf(address(this))\n', '        ];\n', '    }\n', '\n', '    /// Returns an array of consensus rules.\n', '    /// [minTotalVotes, minConsensusVotes, minConsensusRatio, minParticipantRatio, maxParticipants]\n', '    function getConsensusRules() public view returns(uint[6]) {\n', '        return [\n', '            consensusRules.minTotalVotes,\n', '            consensusRules.minConsensusVotes,\n', '            consensusRules.minConsensusRatio,\n', '            consensusRules.minParticipantRatio,\n', '            consensusRules.maxParticipants,\n', '            uint(consensusRules.rewardsDistribution)\n', '        ];\n', '    }\n', '\n', '    /// Returns an array of dispute rules.\n', '    /// [dispute amount, dispute timeout, dispute round]\n', '    function getDisputeData() public view returns(uint[4], address) {\n', '        return ([\n', '            dispute.amount,\n', '            dispute.timeout,\n', '            dispute.multiplier,\n', '            dispute.round\n', '        ], dispute.currentDisputer);\n', '    }\n', '\n', '    function recoverLeftovers()\n', '        public\n', '        onlyOwner\n', '        onlyAfterLefroversCanBeRecovered\n', '    {\n', '        owner.transfer(address(this).balance);\n', '        uint tokenBalance = VerityToken(tokenAddress).balanceOf(address(this));\n', '        VerityToken(tokenAddress).transfer(owner, tokenBalance);\n', '    }\n', '\n', "    /// Advances the event's state to the next one. Only for internal use.\n", '    function advanceState() private onlyChangeableState {\n', '        eventState = EventStates(uint(eventState) + 1);\n', '        emit StateTransition(eventState);\n', '    }\n', '\n', '    /// Sets consensus rules. For internal use only.\n', '    function setConsensusRules(uint[6] rules) private {\n', '        consensusRules.minTotalVotes = rules[0];\n', '        consensusRules.minConsensusVotes = rules[1];\n', '        consensusRules.minConsensusRatio = rules[2];\n', '        consensusRules.minParticipantRatio = rules[3];\n', '        consensusRules.maxParticipants = rules[4];\n', '        consensusRules.rewardsDistribution = RewardsDistribution(rules[5]);\n', '    }\n', '\n', '    function markAsFailed(string description) private onlyChangeableState {\n', '        eventState = EventStates.Failed;\n', '        emit EventFailed(description);\n', '    }\n', '\n', '    function setDisputeData(uint[3] rules) private {\n', '        uint _multiplier = rules[2];\n', '        if (_multiplier <= 1) {\n', '            _multiplier = 1;\n', '        }\n', '\n', '        dispute.amount = rules[0];\n', '        dispute.timeout = rules[1];\n', '        dispute.multiplier = _multiplier;\n', '        dispute.round = 0;\n', '    }\n', '}']