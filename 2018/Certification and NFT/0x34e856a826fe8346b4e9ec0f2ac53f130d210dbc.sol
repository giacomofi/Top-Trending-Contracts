['pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', 'contract Lottery {\n', '\n', '\n', '\n', '    mapping(uint => address) public gamblers;// A mapping to store ethereum addresses of the gamblers\n', '    uint8 public player_count; //keep track of how many people are signed up.\n', '    uint public ante; //how big is the bet per person (in ether)\n', '    uint8 public required_number_players; //how many sign ups trigger the lottery\n', '    uint8 public next_round_players; //how many sign ups trigger the lottery\n', '    uint random; //random number\n', '    uint public winner_percentage; // how much does the winner get (in percentage)\n', '    address owner; // owner of the contract\n', '    uint bet_blocknumber; //block number on the moment the required number of players signed up\n', '\n', '\n', '    //constructor\n', '    function Lottery(){\n', '        owner = msg.sender;\n', '        player_count = 0;\n', '        ante = 0.01 ether;\n', '        required_number_players = 5;\n', '        winner_percentage = 90;\n', '    }\n', '\n', '    //adjust the ante, player number and percentage for the winner\n', '    function changeParameters(uint newAnte, uint8 newNumberOfPlayers, uint newWinnerPercentage) {\n', '        // Only the creator can alter this\n', '        if (msg.sender == owner) {\n', '         if (newAnte != uint80(0)) {\n', '            ante = newAnte;\n', '        }\n', '        if (newNumberOfPlayers != uint80(0)) {\n', '            required_number_players = newNumberOfPlayers;\n', '        }\n', '        if (newWinnerPercentage != uint80(0)) {\n', '            winner_percentage = newWinnerPercentage;\n', '        }\n', '    }\n', '}\n', '\n', 'function refund() {\n', '    if (msg.sender == owner) {\n', '        while (this.balance > ante) {\n', '                gamblers[player_count].transfer(ante);\n', '                player_count -=1;    \n', '            }\n', '            gamblers[1].transfer(this.balance);\n', '    }\n', '}\n', '// announce the winner with an event\n', 'event Announce_winner(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint _value\n', '    );\n', '\n', '// function when someone gambles a.k.a sends ether to the contract\n', 'function () payable {\n', '    // No arguments are necessary, all\n', '    // information is already part of\n', '    // the transaction. The keyword payable\n', '    // is required for the function to\n', '    // be able to receive Ether.\n', '\n', '    // If the bet is not equal to the ante, send the\n', '    // money back.\n', '    if(msg.value != ante) throw; // give it back, revert state changes, abnormal stop\n', '    player_count +=1;\n', '\n', '    gamblers[player_count] = msg.sender;\n', '    \n', '    // when we have enough participants\n', '    if (player_count == required_number_players) {\n', '        bet_blocknumber=block.number;\n', '    }\n', '    if (player_count == required_number_players) {\n', '        if (block.number == bet_blocknumber){\n', '            // pick a random number between 1 and 5\n', '            random = uint(block.blockhash(block.number))%required_number_players +1;\n', '            // more secure way to move funds: make the winners withdraw them. Will implement later.\n', '            //asyncSend(gamblers[random],winner_payout);\n', '            gamblers[random].transfer(ante*required_number_players*winner_percentage/100);\n', '            0xBdf8fF4648bF66c03160F572f67722cf9793cE6b.transfer((ante*required_number_players - ante*required_number_players*winner_percentage/100)/2);\n', '0xA7aa3509d62B9f8B6ee02EA0cFd3738873D3ee4C.transfer((ante*required_number_players - ante*required_number_players*winner_percentage/100)/2);\n', '            // move the gamblers who have joined the lottery but did not participate on this draw down on the mapping structure for next bets\n', '            next_round_players = player_count-required_number_players;\n', '            while (player_count > required_number_players) {\n', '                gamblers[player_count-required_number_players] = gamblers[player_count];\n', '                player_count -=1;    \n', '            }\n', '            player_count = next_round_players;\n', '        }\n', '        else throw;\n', '    }\n', '    \n', '}\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', 'contract Lottery {\n', '\n', '\n', '\n', '    mapping(uint => address) public gamblers;// A mapping to store ethereum addresses of the gamblers\n', '    uint8 public player_count; //keep track of how many people are signed up.\n', '    uint public ante; //how big is the bet per person (in ether)\n', '    uint8 public required_number_players; //how many sign ups trigger the lottery\n', '    uint8 public next_round_players; //how many sign ups trigger the lottery\n', '    uint random; //random number\n', '    uint public winner_percentage; // how much does the winner get (in percentage)\n', '    address owner; // owner of the contract\n', '    uint bet_blocknumber; //block number on the moment the required number of players signed up\n', '\n', '\n', '    //constructor\n', '    function Lottery(){\n', '        owner = msg.sender;\n', '        player_count = 0;\n', '        ante = 0.01 ether;\n', '        required_number_players = 5;\n', '        winner_percentage = 90;\n', '    }\n', '\n', '    //adjust the ante, player number and percentage for the winner\n', '    function changeParameters(uint newAnte, uint8 newNumberOfPlayers, uint newWinnerPercentage) {\n', '        // Only the creator can alter this\n', '        if (msg.sender == owner) {\n', '         if (newAnte != uint80(0)) {\n', '            ante = newAnte;\n', '        }\n', '        if (newNumberOfPlayers != uint80(0)) {\n', '            required_number_players = newNumberOfPlayers;\n', '        }\n', '        if (newWinnerPercentage != uint80(0)) {\n', '            winner_percentage = newWinnerPercentage;\n', '        }\n', '    }\n', '}\n', '\n', 'function refund() {\n', '    if (msg.sender == owner) {\n', '        while (this.balance > ante) {\n', '                gamblers[player_count].transfer(ante);\n', '                player_count -=1;    \n', '            }\n', '            gamblers[1].transfer(this.balance);\n', '    }\n', '}\n', '// announce the winner with an event\n', 'event Announce_winner(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint _value\n', '    );\n', '\n', '// function when someone gambles a.k.a sends ether to the contract\n', 'function () payable {\n', '    // No arguments are necessary, all\n', '    // information is already part of\n', '    // the transaction. The keyword payable\n', '    // is required for the function to\n', '    // be able to receive Ether.\n', '\n', '    // If the bet is not equal to the ante, send the\n', '    // money back.\n', '    if(msg.value != ante) throw; // give it back, revert state changes, abnormal stop\n', '    player_count +=1;\n', '\n', '    gamblers[player_count] = msg.sender;\n', '    \n', '    // when we have enough participants\n', '    if (player_count == required_number_players) {\n', '        bet_blocknumber=block.number;\n', '    }\n', '    if (player_count == required_number_players) {\n', '        if (block.number == bet_blocknumber){\n', '            // pick a random number between 1 and 5\n', '            random = uint(block.blockhash(block.number))%required_number_players +1;\n', '            // more secure way to move funds: make the winners withdraw them. Will implement later.\n', '            //asyncSend(gamblers[random],winner_payout);\n', '            gamblers[random].transfer(ante*required_number_players*winner_percentage/100);\n', '            0xBdf8fF4648bF66c03160F572f67722cf9793cE6b.transfer((ante*required_number_players - ante*required_number_players*winner_percentage/100)/2);\n', '0xA7aa3509d62B9f8B6ee02EA0cFd3738873D3ee4C.transfer((ante*required_number_players - ante*required_number_players*winner_percentage/100)/2);\n', '            // move the gamblers who have joined the lottery but did not participate on this draw down on the mapping structure for next bets\n', '            next_round_players = player_count-required_number_players;\n', '            while (player_count > required_number_players) {\n', '                gamblers[player_count-required_number_players] = gamblers[player_count];\n', '                player_count -=1;    \n', '            }\n', '            player_count = next_round_players;\n', '        }\n', '        else throw;\n', '    }\n', '    \n', '}\n', '}']
