['pragma solidity ^0.4.23;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender; \n', '    }\n', '\n', '    /**\n', '        @dev Transfers the ownership of the contract.\n', '\n', '        @param _owner Address of the new owner\n', '    */\n', '    function setOwner(address _owner) public onlyOwner returns (bool) {\n', '        require(_owner != address(0));\n', '        owner = _owner;\n', '        return true;\n', '    } \n', '}\n', '\n', 'interface TokenHandler {\n', '    function handleTokens(Token _token) public returns (bool);\n', '}\n', '\n', 'contract HasWorkers is Ownable {\n', '    mapping(address => uint256) private workerToIndex;    \n', '    address[] private workers;\n', '\n', '    event AddedWorker(address _worker);\n', '    event RemovedWorker(address _worker);\n', '\n', '    constructor() public {\n', '        workers.length++;\n', '    }\n', '\n', '    modifier onlyWorker() {\n', '        require(isWorker(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier workerOrOwner() {\n', '        require(isWorker(msg.sender) || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function isWorker(address _worker) public view returns (bool) {\n', '        return workerToIndex[_worker] != 0;\n', '    }\n', '\n', '    function allWorkers() public view returns (address[] memory result) {\n', '        result = new address[](workers.length - 1);\n', '        for (uint256 i = 1; i < workers.length; i++) {\n', '            result[i - 1] = workers[i];\n', '        }\n', '    }\n', '\n', '    function addWorker(address _worker) public onlyOwner returns (bool) {\n', '        require(!isWorker(_worker));\n', '        uint256 index = workers.push(_worker) - 1;\n', '        workerToIndex[_worker] = index;\n', '        emit AddedWorker(_worker);\n', '        return true;\n', '    }\n', '\n', '    function removeWorker(address _worker) public onlyOwner returns (bool) {\n', '        require(isWorker(_worker));\n', '        uint256 index = workerToIndex[_worker];\n', '        address lastWorker = workers[workers.length - 1];\n', '        workerToIndex[lastWorker] = index;\n', '        workers[index] = lastWorker;\n', '        workers.length--;\n', '        delete workerToIndex[_worker];\n', '        emit RemovedWorker(_worker);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract ControllerStorage {\n', '    address public walletsDelegate;\n', '    address public controllerDelegate;\n', '    address public forward;\n', '    uint256 public createdWallets;\n', '    mapping(bytes32 => bytes32) public gStorage;\n', '}\n', '\n', 'contract WalletStorage {\n', '    address public owner;\n', '}\n', '\n', 'contract DelegateProxy {\n', '  /**\n', '   * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n', '   * @param _dst Destination address to perform the delegatecall\n', '   * @param _calldata Calldata for the delegatecall\n', '   */\n', '  function delegatedFwd(address _dst, bytes _calldata) internal {\n', '    assembly {\n', '      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n', '      let size := returndatasize\n', '\n', '      let ptr := mload(0x40)\n', '      returndatacopy(ptr, 0, size)\n', '\n', '      // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n', '      // if the call returned error data, forward it\n', '      switch result case 0 { revert(ptr, size) }\n', '      default { return(ptr, size) }\n', '    }\n', '  }\n', '}\n', '\n', 'contract DelegateProvider {\n', '    function getDelegate() public view returns (address delegate);\n', '}\n', '\n', 'contract ControllerProxy is ControllerStorage, Ownable, HasWorkers, DelegateProvider, DelegateProxy {\n', '    function getDelegate() public view returns (address delegate) {\n', '        delegate = walletsDelegate;\n', '    }\n', '\n', '    function setWalletsDelegate(address _delegate) public onlyOwner returns (bool) {\n', '        walletsDelegate = _delegate;\n', '        return true;\n', '    }\n', '\n', '    function setControllerDelegate(address _delegate) public onlyOwner returns (bool) {\n', '        controllerDelegate = _delegate;\n', '        return true;\n', '    }\n', '\n', '    function() public payable {\n', '        if (gasleft() > 2400) {\n', '            delegatedFwd(controllerDelegate, msg.data);\n', '        }\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '}\n', '\n', 'contract WalletProxy is WalletStorage, DelegateProxy {\n', '    event ReceivedETH(address from, uint256 amount);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function() public payable {\n', '        if (msg.value > 0) {\n', '            emit ReceivedETH(msg.sender, msg.value);\n', '        }\n', '        if (gasleft() > 2400) {\n', '            delegatedFwd(DelegateProvider(owner).getDelegate(), msg.data);\n', '        }\n', '    }\n', '}\n', '\n', 'contract Wallet is WalletStorage {\n', '    function transferERC20Token(Token token, address to, uint256 amount) public returns (bool) {\n', '        require(msg.sender == owner);\n', '        return token.transfer(to, amount);\n', '    }\n', '    \n', '    function transferEther(address to, uint256 amount) public returns (bool) {\n', '        require(msg.sender == owner);\n', '        return to.call.value(amount)();\n', '    }\n', '\n', '    function() public payable {}\n', '}\n', '\n', 'contract Controller is ControllerStorage, Ownable, HasWorkers {\n', '    event CreatedUserWallet(address _wallet);\n', '\n', '    // Withdraw events\n', '    event WithdrawEth(address _wallet, address _to, uint256 _amount);\n', '    event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);\n', '    event ChangedForward(address _old, address _new, address _operator);\n', '\n', '    constructor() public {\n', '        setForward(msg.sender);\n', '    }\n', '\n', '    /*\n', '        @notice Executes any transaction\n', '    */\n', '    function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {\n', '        return destination.call.value(value)(_bytes);\n', '    }\n', '\n', '    /*\n', '        @notice Changes the address to forward all the funds\n', '\n', '        @param _forward New forward address\n', '    */\n', '    function setForward(address _forward) public onlyOwner returns (bool) {\n', '        emit ChangedForward(forward, _forward, msg.sender);\n', '        forward = _forward;\n', '        return true;\n', '    }\n', '\n', '    /*\n', '        @notice Creates a number of user wallets\n', '\n', '        @param number Amount of user wallets\n', '    */\n', '    function createWallets(uint256 number) public onlyWorker returns (bool) {\n', '        for (uint256 i = 0; i < number; i++) {\n', '            emit CreatedUserWallet(new WalletProxy());\n', '        }\n', '\n', '        createdWallets += number;\n', '        return true;\n', '    }\n', '\n', '    /*\n', '        @notice Withdraws all ETH from a wallet and sends it to the\n', '            forward address\n', '\n', '        @param wallet Address of the wallet\n', '    */\n', '    function withdrawEth(Wallet wallet) public onlyWorker returns (bool result) {\n', '        uint256 balance = address(wallet).balance;\n', '        result = wallet.transferEther(forward, balance);\n', '        \n', '        if (result) {\n', '            emit WithdrawEth(wallet, forward, balance);\n', '        }\n', '    }\n', '\n', '    /*\n', '        @notice Withdraws all ETH from a list of wallets and sends \n', '            all the funds to the forward address\n', '\n', '        @param wallets Address list of the wallets\n', '    */\n', '    function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {\n', '        uint256 size = wallets.length;\n', '        uint256 balance;\n', '        \n', '        Wallet wallet;\n', '\n', '        for (uint256 i = 0; i < size; i++) {\n', '            wallet = wallets[i];\n', '            balance = wallet.balance;\n', '            \n', '            if (wallet.transferEther(this, balance)) {\n', '                emit WithdrawEth(wallet, forward, balance);\n', '            }  \n', '        }\n', '\n', '        forward.call.value(address(this).balance)();\n', '\n', '        return true;\n', '    }\n', '\n', '    /*\n', '        @notice Withdraws all tokens from a wallet and sends it to the\n', '            forward address\n', '\n', '        @param token Token to withdraw\n', '        @param wallet Address of the wallet\n', '    */\n', '    function withdrawERC20(Token token, Wallet wallet) public onlyWorker returns (bool result) {\n', '        uint256 balance = token.balanceOf(wallet);\n', '        result = wallet.transferERC20Token(token, forward, balance);\n', '        \n', '        if (result) {\n', '            emit WithdrawToken(token, wallet, forward, balance);\n', '        }\n', '\n', '        TokenHandler(forward).handleTokens(token);\n', '    }\n', '\n', '    /*\n', '        @notice Withdraws all tokens from a list of wallets and sends \n', '            all the funds to the forward address\n', '\n', '        @param token Token to withdraw\n', '        @param wallets Address list of the wallets\n', '    */\n', '    function withdrawERC20Batch(Token token, Wallet[] wallets) public onlyWorker returns (bool) {\n', '        uint256 size = wallets.length;\n', '        uint256 balance;\n', '        Wallet wallet;\n', '\n', '        for (uint256 i = 0; i < size; i++) {\n', '            wallet = wallets[i];\n', '            balance = token.balanceOf(wallet);\n', '            \n', '            if (wallet.transferERC20Token(token, forward, balance)) {\n', '                emit WithdrawToken(token, wallet, forward, balance);\n', '            }\n', '        }\n', '\n', '        TokenHandler(forward).handleTokens(token);\n', '\n', '        return true;\n', '    }\n', '\n', '    function() public payable {}\n', '}']