['pragma solidity 0.4.24;\n', '\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Admin is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    struct Tier {\n', '        uint256 amountInCenter;\n', '        uint256 amountInOuter;\n', '        uint256 priceInCenter;\n', '        uint256 priceInOuter;\n', '        uint256 soldInCenter;\n', '        uint256 soldInOuter;\n', '        bool filledInCenter;\n', '        bool filledInOuter;\n', '    }\n', '\n', '    Tier[] public tiers;\n', '\n', '    bool public halted;\n', '    uint256 public logoPrice = 0;\n', '    uint256 public logoId;\n', '    address public platformWallet;\n', '\n', '    uint256 public feeForFirstArtWorkChangeRequest = 0 ether;\n', '    uint256 public feeForArtWorkChangeRequest = 0.2 ether;\n', '    uint256 public minResalePercentage = 15;\n', '\n', '    mapping(address => bool) public globalAdmins;\n', '    mapping(address => bool) public admins;\n', '    mapping(address => bool) public signers;\n', '\n', '    event Halted(bool _halted);\n', '\n', '    modifier onlyAdmin() {\n', '        require(true == admins[msg.sender] || true == globalAdmins[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyGlobalAdmin() {\n', '        require(true == globalAdmins[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier notHalted() {\n', '        require(halted == false);\n', '        _;\n', '    }\n', '\n', '    function addGlobalAdmin(address _address) public onlyOwner() {\n', '        globalAdmins[_address] = true;\n', '    }\n', '\n', '    function removeGlobalAdmin(address _address) public onlyOwner() {\n', '        globalAdmins[_address] = false;\n', '    }\n', '\n', '    function addAdmin(address _address) public onlyGlobalAdmin() {\n', '        admins[_address] = true;\n', '    }\n', '\n', '    function removeAdmin(address _address) public onlyGlobalAdmin() {\n', '        admins[_address] = true;\n', '    }\n', '\n', '    function setSigner(address _address, bool status) public onlyGlobalAdmin() {\n', '        signers[_address] = status;\n', '    }\n', '\n', '    function setLogoPrice(uint256 _price) public onlyGlobalAdmin() {\n', '        logoPrice = _price;\n', '    }\n', '\n', '    function setFeeForFirstArtWorkChangeRequest(uint256 _fee) public onlyGlobalAdmin() {\n', '        feeForFirstArtWorkChangeRequest = _fee;\n', '    }\n', '\n', '    function setFeeForArtWorkChangeRequest(uint256 _fee) public onlyGlobalAdmin() {\n', '        feeForArtWorkChangeRequest = _fee;\n', '    }\n', '\n', '    /// @notice global Admin update tier data\n', '    function setTierData(\n', '        uint256 _index,\n', '        uint256 _priceInCenter,\n', '        uint256 _priceInOuter) public onlyGlobalAdmin() {\n', '        Tier memory tier = tiers[_index];\n', '        tier.priceInCenter = _priceInCenter;\n', '        tier.priceInOuter = _priceInOuter;\n', '        tiers[_index] = tier;\n', '    }\n', '\n', '    function setMinResalePercentage(uint256 _minResalePercentage) public onlyGlobalAdmin() {\n', '        minResalePercentage = _minResalePercentage;\n', '    }\n', '\n', '    function isAdmin(address _address) public view returns (bool isAdmin_) {\n', '        return (true == admins[_address] || true == globalAdmins[_address]);\n', '    }\n', '\n', '    function setHalted(bool _halted) public onlyGlobalAdmin {\n', '        halted = _halted;\n', '\n', '        emit Halted(_halted);\n', '    }\n', '\n', '    function verify(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\n', '        bytes memory prefix = &#39;\\x19Ethereum Signed Message:\\n32&#39;;\n', '\n', '        return ecrecover(keccak256(abi.encodePacked(prefix, _hash)), _v, _r, _s);\n', '    }\n', '\n', '    function isContract(address addr) public view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '    function setPlatformWallet(address _addresss) public onlyGlobalAdmin() {\n', '        platformWallet = _addresss;\n', '    }\n', '}\n', '\n', 'contract BigIoAdSpace is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /// @notice Token\n', '    struct Token {\n', '        uint256 id;\n', '        uint256 x; // position X on map\n', '        uint256 y; // position Y on map\n', '        uint256 sizeA;\n', '        uint256 sizeB;\n', '        uint256 soldPrice; // price that user paid to buy token\n', '        uint256 actualPrice;\n', '        uint256 timesSold; // how many times token was sold\n', '        uint256 timesUpdated; // how many times artwork has been changed by current owner\n', '        uint256 soldAt; // when token was sold\n', '        uint256 inner;\n', '        uint256 outer;\n', '        uint256 soldNearby;\n', '    }\n', '\n', '    struct MetaData {\n', '        string meta;\n', '    }\n', '\n', '    struct InnerScope {\n', '        uint256 x1; // left top\n', '        uint256 y1;\n', '        uint256 x2; // right top\n', '        uint256 y2;\n', '        uint256 x3; // left bottom\n', '        uint256 y3;\n', '        uint256 x4; // right bottom\n', '        uint256 y4;\n', '    }\n', '\n', '    InnerScope public innerScope;\n', '\n', '    /// @notice mapping for token URIs\n', '    mapping(uint256 => MetaData) public metadata;\n', '\n', '    /// @notice Mapping from token ID to owner\n', '    mapping(uint256 => address) public tokenOwner;\n', '\n', '    mapping(uint256 => mapping(uint256 => bool)) public neighbours;\n', '    mapping(uint256 => uint256[]) public neighboursArea;\n', '\n', '    /// @notice Here different from base class we store the token not an id\n', '    /// Array with all token, used for enumeration\n', '    Token[] public allMinedTokens;\n', '\n', '    /// @notice Mapping from token id to position in the allMinedTokens array\n', '    mapping(uint256 => uint256) public allTokensIndex;\n', '\n', '    // store sold units and not-sold but generated units\n', '//    mapping(uint256 => mapping(uint256 => bool)) public soldUnits;\n', '    mapping(uint256 => mapping(uint256 => uint256)) public soldUnits;\n', '\n', '    address public platform;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event TokenPriceIncreased(uint256 _tokenId, uint256 _newPrice, uint256 _boughtTokenId, uint256 time);\n', '\n', '    constructor () public {\n', '        innerScope = InnerScope(\n', '            12, 11, // left top\n', '            67, 11, // right top\n', '            12, 34, // left bottom\n', '            67, 34\n', '        );\n', '    }\n', '\n', '    modifier onlyPlatform() {\n', '        require(msg.sender == platform);\n', '        _;\n', '    }\n', '\n', '    modifier exists(uint256 _tokenId) {\n', '        address owner = tokenOwner[_tokenId];\n', '        require(owner != address(0));\n', '        _;\n', '    }\n', '\n', '    function setPlatform(address _platform) public onlyOwner() {\n', '        platform = _platform;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return allMinedTokens.length;\n', '    }\n', '\n', '    /// @notice Check whether token is minted\n', '    function tokenExists(uint256 _tokenId) public view returns (bool) {\n', '        address owner = tokenOwner[_tokenId];\n', '        return owner != address(0);\n', '    }\n', '\n', '    /// @notice Check whether exist Unit with same x any y coordinates\n', '    /// and it was sold already\n', '    /// in order to prevent over writing\n', '    function unitExists(uint x, uint y) public view returns (bool) {\n', '        return (soldUnits[x][y] != 0);\n', '    }\n', '\n', '    function getOwner(uint256 _tokenId) public view returns (address) {\n', '        return tokenOwner[_tokenId];\n', '    }\n', '\n', '    /// @return token metadata\n', '    function getMetadata(uint256 _tokenId) public exists(_tokenId) view returns (string) {\n', '        return metadata[_tokenId].meta;\n', '    }\n', '\n', '    /// @notice update metadata for token\n', '    function setTokenMetadata(uint256 _tokenId, string meta) public  onlyPlatform exists(_tokenId) {\n', '        metadata[_tokenId] = MetaData(meta);\n', '    }\n', '\n', '    function increaseUpdateMetadataCounter(uint256 _tokenId) public onlyPlatform {\n', '        allMinedTokens[allTokensIndex[_tokenId]].timesUpdated = allMinedTokens[allTokensIndex[_tokenId]].timesUpdated.add(1);\n', '    }\n', '\n', '    /// @notice remove metadata for token\n', '    function removeTokenMetadata(uint256 _tokenId) public onlyPlatform exists(_tokenId) {\n', '        delete metadata[_tokenId];\n', '    }\n', '\n', '    // @return return the current price\n', '    function getCurrentPriceForToken(uint256 _tokenId) public exists(_tokenId) view returns (uint256) {\n', '        return allMinedTokens[allTokensIndex[_tokenId]].actualPrice;\n', '    }\n', '\n', '    /// @return tokenId, x, y, sizeA, sizeB, price, inner, outer\n', '    function getTokenData(uint256 _tokenId) public exists(_tokenId) view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n', '        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\n', '        return (_tokenId, token.x, token.y, token.sizeA, token.sizeB, token.actualPrice, token.soldPrice, token.inner, token.outer);\n', '    }\n', '\n', '    function getTokenSoldPrice(uint256 _tokenId) public exists(_tokenId) view returns (uint256) {\n', '        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\n', '        return token.soldPrice;\n', '    }\n', '\n', '    function getTokenUpdatedCounter(uint256 _tokenId) public exists(_tokenId) view returns (uint256) {\n', '        return allMinedTokens[allTokensIndex[_tokenId]].timesUpdated;\n', '    }\n', '\n', '    // @return return token sizes\n', '    function getTokenSizes(uint256 _tokenId) public exists(_tokenId) view returns (uint256, uint256) {\n', '        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\n', '        return (token.sizeA, token.sizeB);\n', '    }\n', '\n', '    // @return return token scopes\n', '    function getTokenScope(uint256 _tokenId) public exists(_tokenId) view returns (bool, bool) {\n', '        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\n', '        return (token.inner > 0, token.outer > 0);\n', '    }\n', '\n', '    // @return return token scope counters\n', '    function getTokenCounters(uint256 _tokenId) public exists(_tokenId) view returns (uint256, uint256, uint256, uint256) {\n', '        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\n', '        return (token.inner, token.outer, token.timesSold, token.soldNearby);\n', '    }\n', '\n', '    /// @notice Mint new token, not sell new token\n', '    /// BE sends: owner, x coordinate, y coordinate, price\n', '    /// @param to new owner\n', '    /// @param x coordinate\n', '    /// @param y coordinate\n', '    /// @param totalPrice calculated price for all units + % for siblings\n', '    function mint(\n', '        address to,\n', '        uint x,\n', '        uint y,\n', '        uint sizeA,\n', '        uint sizeB,\n', '        uint256 totalPrice,\n', '        uint256 actualPrice\n', '    ) public onlyPlatform() returns (uint256) {\n', '\n', '        // 1.\n', '        require(to != address(0));\n', '        require(sizeA.mul(sizeB) <= 100);\n', '\n', '        // 2. check area\n', '        uint256 inner;\n', '        uint256 total;\n', '\n', '        (total, inner) = calculateCounters(x, y, sizeA, sizeB);\n', '\n', '        // we avoid zero because we later compare against zero\n', '        uint256 tokenId = (allMinedTokens.length).add(1);\n', '\n', '        // @TODO: ACHTUNG - soldAt equals 0 during minting\n', '        Token memory minted = Token(tokenId, x, y, sizeA, sizeB, totalPrice, actualPrice, 0, 0, 0, inner, total.sub(inner), 0);\n', '\n', '        // 3. copy units and create siblings\n', '        copyToAllUnits(x, y, sizeA, sizeB, tokenId);\n', '\n', '        // 4. update state\n', '        updateInternalState(minted, to);\n', '\n', '        return tokenId;\n', '    }\n', '\n', '    function updateTokensState(uint256 _tokenId, uint256 newPrice) public onlyPlatform exists(_tokenId) {\n', '        uint256 index = allTokensIndex[_tokenId];\n', '        allMinedTokens[index].timesSold += 1;\n', '        allMinedTokens[index].timesUpdated = 0;\n', '        allMinedTokens[index].soldNearby = 0;\n', '        allMinedTokens[index].soldPrice = newPrice;\n', '        allMinedTokens[index].actualPrice = newPrice;\n', '        allMinedTokens[index].soldAt = now;\n', '    }\n', '\n', '    function updateOwner(uint256 _tokenId, address newOwner, address prevOwner) public onlyPlatform exists(_tokenId) {\n', '        require(newOwner != address(0));\n', '        require(prevOwner != address(0));\n', '        require(prevOwner == tokenOwner[_tokenId]);\n', '\n', '        // update data for new owner\n', '        tokenOwner[_tokenId] = newOwner;\n', '    }\n', '\n', '    function inInnerScope(uint256 x, uint256 y) public view returns (bool) {\n', '        // x should be between left top and right top corner\n', '        // y should be between left top and left bottom corner\n', '        if ((x >= innerScope.x1) && (x <= innerScope.x2) && (y >= innerScope.y1) && (y <= innerScope.y3)) {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function calculateCounters(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) public view returns (uint256 total, uint256 inner) {\n', '        uint256 upX = x.add(sizeA);\n', '        uint256 upY = y.add(sizeB);\n', '\n', '        // check for boundaries\n', '        require(x >= 1);\n', '        require(y >= 1);\n', '        require(upX <= 79);\n', '        require(upY <= 45);\n', '        require(sizeA > 0);\n', '        require(sizeB > 0);\n', '\n', '        uint256 i;\n', '        uint256 j;\n', '\n', '        for (i = x; i < upX; i++) {\n', '            for (j = y; j < upY; j++) {\n', '                require(soldUnits[i][j] == 0);\n', '\n', '                if (inInnerScope(i, j)) {\n', '                    inner = inner.add(1);\n', '                }\n', '\n', '                total = total.add(1);\n', '            }\n', '        }\n', '    }\n', '\n', '    function increasePriceForNeighbours(uint256 tokenId) public onlyPlatform {\n', '\n', '        Token memory token = allMinedTokens[allTokensIndex[tokenId]];\n', '\n', '        uint256 upX = token.x.add(token.sizeA);\n', '        uint256 upY = token.y.add(token.sizeB);\n', '\n', '        uint256 i;\n', '        uint256 j;\n', '        uint256 k;\n', '        uint256 _tokenId;\n', '\n', '\n', '        if (neighboursArea[tokenId].length == 0) {\n', '\n', '            for (i = token.x; i < upX; i++) {\n', '                // check neighbors on top of area\n', '                _tokenId = soldUnits[i][token.y - 1];\n', '\n', '                if (_tokenId != 0) {\n', '                    if (!neighbours[tokenId][_tokenId]) {\n', '                        neighbours[tokenId][_tokenId] = true;\n', '                        neighboursArea[tokenId].push(_tokenId);\n', '                    }\n', '                    if (!neighbours[_tokenId][tokenId]) {\n', '                        neighbours[_tokenId][tokenId] = true;\n', '                        neighboursArea[_tokenId].push(tokenId);\n', '                    }\n', '                }\n', '\n', '                // check neighbors on bottom of area\n', '                _tokenId = soldUnits[i][upY];\n', '                if (_tokenId != 0) {\n', '                    if (!neighbours[tokenId][_tokenId]) {\n', '                        neighbours[tokenId][_tokenId] = true;\n', '                        neighboursArea[tokenId].push(_tokenId);\n', '                    }\n', '                    if (!neighbours[_tokenId][tokenId]) {\n', '                        neighbours[_tokenId][tokenId] = true;\n', '                        neighboursArea[_tokenId].push(tokenId);\n', '                    }\n', '                }\n', '            }\n', '\n', '            for (j = token.y; j < upY; j++) {\n', '                // check neighbors on left of area of area\n', '                _tokenId = soldUnits[token.x - 1][j];\n', '                if (_tokenId != 0) {\n', '                    if (!neighbours[tokenId][_tokenId]) {\n', '                        neighbours[tokenId][_tokenId] = true;\n', '                        neighboursArea[tokenId].push(_tokenId);\n', '                    }\n', '                    if (!neighbours[_tokenId][tokenId]) {\n', '                        neighbours[_tokenId][tokenId] = true;\n', '                        neighboursArea[_tokenId].push(tokenId);\n', '                    }\n', '                }\n', '\n', '                // check neighbors on right of area of area\n', '                _tokenId = soldUnits[upX][j];\n', '                if (_tokenId != 0) {\n', '                    if (!neighbours[tokenId][_tokenId]) {\n', '                        neighbours[tokenId][_tokenId] = true;\n', '                        neighboursArea[tokenId].push(_tokenId);\n', '                    }\n', '                    if (!neighbours[_tokenId][tokenId]) {\n', '                        neighbours[_tokenId][tokenId] = true;\n', '                        neighboursArea[_tokenId].push(tokenId);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        // increase price\n', '        for (k = 0; k < neighboursArea[tokenId].length; k++) {\n', '            Token storage _token = allMinedTokens[allTokensIndex[neighboursArea[tokenId][k]]];\n', '            _token.soldNearby = _token.soldNearby.add(1);\n', '            _token.actualPrice = _token.actualPrice.add((_token.actualPrice.div(100)));\n', '            emit TokenPriceIncreased(_token.id, _token.actualPrice, _tokenId, now);\n', '        }\n', '    }\n', '\n', '    // move generated Units to sold array\n', '    // generate siblings and put it there\n', '    function copyToAllUnits(uint256 x, uint256 y, uint256 width, uint256 height, uint256 tokenId) internal {\n', '        uint256 upX = x + width; // 5\n', '        uint256 upY = y + height; // 3\n', '\n', '        uint256 i; // 1\n', '        uint256 j; // 1\n', '\n', '        for (i = x; i < upX; i++) {\n', '            for (j = y; j < upY; j++) {\n', '                soldUnits[i][j] = tokenId;\n', '            }\n', '        }\n', '    }\n', '\n', '    function updateInternalState(Token minted, address _to) internal {\n', '        uint256 lengthT = allMinedTokens.length;\n', '        allMinedTokens.push(minted);\n', '        allTokensIndex[minted.id] = lengthT;\n', '        tokenOwner[minted.id] = _to;\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract BigIOERC20token is StandardToken, Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    uint256 public maxSupply;\n', '\n', '    bool public allowedMinting;\n', '\n', '    mapping(address => bool) public mintingAgents;\n', '    mapping(address => bool) public stateChangeAgents;\n', '\n', '    event MintERC20(address indexed _holder, uint256 _tokens);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '    modifier onlyMintingAgents () {\n', '        require(mintingAgents[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    constructor (string _name, string _symbol, uint8 _decimals, uint256 _maxSupply) public StandardToken() {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '\n', '        maxSupply = _maxSupply;\n', '\n', '        allowedMinting = true;\n', '\n', '        mintingAgents[msg.sender] = true;\n', '    }\n', '\n', '    /// @notice update minting agent\n', '    function updateMintingAgent(address _agent, bool _status) public onlyOwner {\n', '        mintingAgents[_agent] = _status;\n', '    }\n', '\n', '    /// @notice allow to mint tokens\n', '    function mint(address _holder, uint256 _tokens) public onlyMintingAgents() {\n', '        require(allowedMinting == true && totalSupply_.add(_tokens) <= maxSupply);\n', '\n', '        totalSupply_ = totalSupply_.add(_tokens);\n', '\n', '        balances[_holder] = balanceOf(_holder).add(_tokens);\n', '\n', '        if (totalSupply_ == maxSupply) {\n', '            allowedMinting = false;\n', '        }\n', '        emit MintERC20(_holder, _tokens);\n', '        emit Transfer(0x0, _holder, _tokens);\n', '    }\n', '\n', '}\n', '\n', 'contract PricingStrategy {\n', '    using SafeMath for uint256;\n', '\n', '    function calculateMinPriceForNextRound(uint256 _tokenPrice, uint256 _minResalePercentage) public pure returns (uint256) {\n', '        return _tokenPrice.add(_tokenPrice.div(100).mul(_minResalePercentage));\n', '    }\n', '\n', '    function calculateSharesInTheRevenue(uint256 _prevTokenPrice, uint256 _newTokenPrice) public pure returns (uint256, uint256) {\n', '        uint256 revenue = _newTokenPrice.sub(_prevTokenPrice);\n', '        uint256 platformShare = revenue.mul(40).div(100);\n', '        uint256 forPrevOwner = revenue.sub(platformShare);\n', '        return (platformShare, forPrevOwner);\n', '    }\n', '}\n', '/// @title Platform\n', '/// @author Applicature\n', '/// @notice It is front contract which is used to sell, re-sell tokens and initiate paying dividends\n', 'contract Platform is Admin {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    struct Offer {\n', '        uint256 tokenId;\n', '        uint256 offerId;\n', '        address from;\n', '        uint256 offeredPrice;\n', '        uint256 tokenPrice;\n', '        bool accepted;\n', '        uint256 timestamp;\n', '    }\n', '\n', '    struct ArtWorkChangeRequest {\n', '        address fromUser;\n', '        uint256 tokenId;\n', '        uint256 changeId;\n', '        string meta;\n', '        uint256 timestamp;\n', '        bool isReviewed;\n', '    }\n', '\n', '    BigIoAdSpace public token;\n', '    BigIOERC20token public erc20token;\n', '\n', '    PricingStrategy public pricingStrategy;\n', '    ArtWorkChangeRequest[] public artWorkChangeRequests;\n', '\n', '    bool public isLogoInitied;\n', '\n', '    uint256 public logoX = 35;\n', '    uint256 public logoY = 18;\n', '\n', '    Offer[] public offers;\n', '\n', '    mapping(address => uint256) public pendingReturns;\n', '\n', '    event Minted(address indexed _owner, uint256 _tokenId, uint256 _x, uint256 _y, uint256 _sizeA, uint256 _sizeB, uint256 _price, uint256 _platformTransfer, uint256 _timestamp);\n', '\n', '    event Purchased(address indexed _from, address indexed _to, uint256 _tokenId, uint256 _price, uint256 _prevPrice, uint256 _prevOwnerTransfer, uint256 _platformTransfer, uint256 _timestamp);\n', '\n', '    event OfferMade(address indexed _fromUser, uint256 _tokenId, uint256 _offerId, uint256 _offeredPrice, uint256 _timestamp);\n', '\n', '    event OfferApproved(address indexed _owner, uint256 _tokenId, uint256 _offerId, uint256 _offeredPrice, uint256 _timestamp);\n', '\n', '    event OfferDeclined(address indexed _fromUser, uint256 _tokenId, uint256 _offerId, uint256 _offeredPrice, uint256 _timestamp);\n', '\n', '    event ArtWorkChangeRequestMade(\n', '        address indexed _fromUser,\n', '        uint256 _tokenId,\n', '        uint256 _changeId,\n', '        string _meta,\n', '        uint256 _platformTransfer,\n', '        uint256 _timestamp);\n', '\n', '    event ArtWorkChangeRequestApproved(\n', '        address indexed _fromUser,\n', '        uint256 _tokenId,\n', '        uint256 _changeId,\n', '        string _meta,\n', '        uint256 _timestamp);\n', '\n', '    event ArtWorkChangeRequestDeclined(\n', '        address indexed _fromUser,\n', '        uint256 _tokenId,\n', '        uint256 _changeId,\n', '        string _meta,\n', '        uint256 _timestamp);\n', '\n', '    event RemovedMetaData(uint256 _tokenId, address _admin, string _meta, uint256 _timestamp);\n', '    event ChangedOwnership(uint256 _tokenId, address _prevOwner, address _newOwner, uint256 _timestamp);\n', '\n', '    constructor(\n', '        address _platformWallet, // owner collects money\n', '        address _token,\n', '        address _erc20token,\n', '        address _pricingStrategy,\n', '        address _signer\n', '    ) public {\n', '\n', '        token = BigIoAdSpace(_token);\n', '        erc20token = BigIOERC20token(_erc20token);\n', '\n', '        platformWallet = _platformWallet;\n', '\n', '        pricingStrategy = PricingStrategy(_pricingStrategy);\n', '\n', '        signers[_signer] = true;\n', '\n', '        // 30%\n', '        tiers.push(\n', '            Tier(\n', '                400, // amountInCenter\n', '                600, // amountInOuter\n', '                1 ether, // priceInCenter\n', '                0.4 ether, // priceInOuter\n', '                0, // soldInCenter\n', '                0, // soldInOuter\n', '                false, // filledInCenter\n', '                false // filledInOuter\n', '            )\n', '        );\n', '        // 30%\n', '        tiers.push(\n', '            Tier(\n', '                400, 600, 1.2 ether, 0.6 ether, 0, 0, false, false\n', '            )\n', '        );\n', '        // 30%\n', '        tiers.push(\n', '            Tier(\n', '                400, 600, 1.4 ether, 0.8 ether, 0, 0, false, false\n', '            )\n', '        );\n', '        // 10%\n', '        tiers.push(\n', '            Tier(\n', '                144, 288, 1.6 ether, 1.0 ether, 0, 0, false, false\n', '            )\n', '        );\n', '    }\n', '\n', '    /// @notice init logo, call it as soon as possible\n', '    /// call it after setting platform in the token\n', '    /// Logo is BigIOToken which has 10*10 size and position in the center of map\n', '    function initLogo() public onlyOwner {\n', '        require(isLogoInitied == false);\n', '\n', '        isLogoInitied = true;\n', '\n', '        logoId = token.mint(platformWallet, logoX, logoY, 10, 10, 0 ether, 0 ether);\n', '\n', '        token.setTokenMetadata(logoId, "");\n', '\n', '        updateTierStatus(100, 0);\n', '\n', '        emit Minted(msg.sender, logoId, logoX, logoY, 10, 10, 0 ether, 0 ether, now);\n', '    }\n', '\n', '    function getPriceFor(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) public view returns(uint256 totalPrice, uint256 inner, uint256 outer) {\n', '        (inner, outer) = preMinting(x, y, sizeA, sizeB);\n', '\n', '        totalPrice = calculateTokenPrice(inner, outer);\n', '\n', '        return (totalPrice, inner, outer);\n', '    }\n', '\n', '    /// @notice sell new tokens during the round 0\n', '    /// all except logo\n', '    function buy(\n', '        uint256 x, // top left coordinates\n', '        uint256 y, // top left coordinates\n', '        uint256 sizeA, // size/width of a square\n', '        uint256 sizeB, // size/height of a square,\n', '        uint8 _v,  // component of signature\n', '        bytes32 _r, // component of signature\n', '        bytes32 _s // component of signature\n', '    ) public notHalted() payable {\n', '        address recoveredSigner = verify(keccak256(msg.sender), _v, _r, _s);\n', '\n', '        require(signers[recoveredSigner] == true);\n', '        require(msg.value > 0);\n', '\n', '        internalBuy(x, y, sizeA, sizeB);\n', '    }\n', '\n', '    function internalBuy(\n', '        uint256 x, // top left coordinates\n', '        uint256 y, // top left coordinates\n', '        uint256 sizeA, // size/width of a square\n', '        uint256 sizeB // size/height of a square,\n', '    ) internal {\n', '        // get and validate current tier\n', '        uint256 inner = 0;\n', '        uint256 outer = 0;\n', '        uint256 totalPrice = 0;\n', '\n', '        (inner, outer) = preMinting(x, y, sizeA, sizeB);\n', '        totalPrice = calculateTokenPrice(inner, outer);\n', '\n', '        require(totalPrice <= msg.value);\n', '\n', '        //         try to mint and update current tier\n', '        updateTierStatus(inner, outer);\n', '\n', '        uint256 actualPrice = inner.mul(tiers[3].priceInCenter).add(outer.mul(tiers[3].priceInOuter));\n', '\n', '        if (msg.value > actualPrice) {\n', '            actualPrice = msg.value;\n', '        }\n', '\n', '        uint256 tokenId = token.mint(msg.sender, x, y, sizeA, sizeB, msg.value, actualPrice);\n', '        erc20token.mint(msg.sender, inner.add(outer));\n', '\n', '        transferEthers(platformWallet, msg.value);\n', '\n', '        emit Minted(msg.sender, tokenId, x, y, sizeA, sizeB, msg.value, msg.value, now);\n', '    }\n', '\n', '    /// @notice allow user to make an offer after initial phase(re-sale)\n', '    /// any offer minResalePercentage is accepted automatically\n', '    function makeOffer(\n', '        uint256 _tokenId,\n', '        uint8 _v,  // component of signature\n', '        bytes32 _r, // component of signature\n', '        bytes32 _s // component of signature\n', '    ) public notHalted() payable {\n', '\n', '        address recoveredSigner = verify(keccak256(msg.sender), _v, _r, _s);\n', '\n', '        require(signers[recoveredSigner] == true);\n', '\n', '        require(msg.sender != address(0));\n', '        require(msg.value > 0);\n', '\n', '        uint256 currentPrice = getTokenPrice(_tokenId);\n', '        require(currentPrice > 0);\n', '\n', '        // special case for first sell of logo\n', '        if (_tokenId == logoId && token.getCurrentPriceForToken(_tokenId) == 0) {\n', '            require(msg.value >= logoPrice);\n', '\n', '            //update token&#39;s state\n', '            token.updateTokensState(logoId, msg.value);\n', '\n', '            // mint erc20 tokens\n', '            erc20token.mint(msg.sender, 100);\n', '\n', '            transferEthers(platformWallet, msg.value);\n', '\n', '            emit Purchased(0, msg.sender, _tokenId, msg.value, 0, 0, msg.value, now);\n', '\n', '            return;\n', '        }\n', '\n', '        uint256 minPrice = pricingStrategy.calculateMinPriceForNextRound(currentPrice, minResalePercentage);\n', '\n', '        require(msg.value >= minPrice);\n', '\n', '        uint256 offerCounter = offers.length;\n', '\n', '        offers.push(Offer(_tokenId, offerCounter, msg.sender, msg.value, currentPrice, false, now));\n', '        emit OfferMade(msg.sender, _tokenId, offerCounter, msg.value, now);\n', '\n', '        // 2. check condition for approve and do it\n', '        approve(offerCounter, _tokenId);\n', '    }\n', '\n', '    function getTokenPrice(uint256 _tokenId) public view returns (uint256 price) {\n', '\n', '        uint256 actualPrice = token.getCurrentPriceForToken(_tokenId);\n', '\n', '        // special case for first sell of logo\n', '        if (_tokenId == logoId && actualPrice == 0) {\n', '            require(logoPrice > 0);\n', '\n', '            return logoPrice;\n', '        } else {\n', '            uint256 indexInner = 0;\n', '            uint256 indexOuter = 0;\n', '\n', '            bool hasInner;\n', '            bool hasOuter;\n', '\n', '            (hasInner, hasOuter) = token.getTokenScope(_tokenId);\n', '            (indexInner, indexOuter) = getCurrentTierIndex();\n', '\n', '            if (_tokenId != logoId && hasInner) {\n', '                require(indexInner == 100000);\n', '            }\n', '\n', '            if (hasOuter) {\n', '                require(indexOuter == 100000);\n', '            }\n', '\n', '            return actualPrice;\n', '        }\n', '    }\n', '\n', '    function getArtWorkChangeFee(uint256 _tokenId) public view returns (uint256 fee) {\n', '\n', '        uint256 counter = token.getTokenUpdatedCounter(_tokenId);\n', '\n', '        if (counter > 0) {\n', '            return feeForArtWorkChangeRequest;\n', '        }\n', '\n', '        return feeForFirstArtWorkChangeRequest;\n', '    }\n', '\n', '    /// @notice it allows token owner to create art work change request\n', '    /// first user upload 2 images\n', '    /// then do call this function\n', '    /// admin can reject or approve it\n', '    function artWorkChangeRequest(uint256 _tokenId, string _meta, uint8 _v, bytes32 _r, bytes32 _s)\n', '        public payable returns (uint256)\n', '    {\n', '\n', '        address recoveredSigner = verify(keccak256(_meta), _v, _r, _s);\n', '\n', '        require(signers[recoveredSigner] == true);\n', '\n', '        require(msg.sender == token.getOwner(_tokenId));\n', '\n', '        uint256 fee = getArtWorkChangeFee(_tokenId);\n', '\n', '        require(msg.value >= fee);\n', '\n', '        uint256 changeRequestCounter = artWorkChangeRequests.length;\n', '\n', '        artWorkChangeRequests.push(\n', '            ArtWorkChangeRequest(msg.sender, _tokenId, changeRequestCounter, _meta, now, false)\n', '        );\n', '\n', '        token.increaseUpdateMetadataCounter(_tokenId);\n', '\n', '        transferEthers(platformWallet, msg.value);\n', '\n', '        emit ArtWorkChangeRequestMade(msg.sender, _tokenId, changeRequestCounter, _meta, msg.value, now);\n', '\n', '        return changeRequestCounter;\n', '    }\n', '\n', '    function artWorkChangeApprove(uint256 _index, uint256 _tokenId, bool approve) public onlyAdmin {\n', '        ArtWorkChangeRequest storage request = artWorkChangeRequests[_index];\n', '        require(false == request.isReviewed);\n', '\n', '        require(_tokenId == request.tokenId);\n', '        request.isReviewed = true;\n', '        if (approve) {\n', '            token.setTokenMetadata(_tokenId, request.meta);\n', '            emit ArtWorkChangeRequestApproved(\n', '                request.fromUser,\n', '                request.tokenId,\n', '                request.changeId,\n', '                request.meta,\n', '                now\n', '            );\n', '        } else {\n', '            emit ArtWorkChangeRequestDeclined(\n', '                request.fromUser,\n', '                request.tokenId,\n', '                request.changeId,\n', '                request.meta,\n', '                now\n', '            );\n', '        }\n', '    }\n', '\n', '    function artWorkChangeByAdmin(uint256 _tokenId, string _meta, uint256 _changeId) public onlyAdmin {\n', '        token.setTokenMetadata(_tokenId, _meta);\n', '        emit ArtWorkChangeRequestApproved(\n', '            msg.sender,\n', '            _tokenId,\n', '            _changeId,\n', '            _meta,\n', '            now\n', '        );\n', '    }\n', '\n', '    function changeTokenOwnerByAdmin(uint256 _tokenId, address _newOwner) public onlyAdmin {\n', '        address prevOwner = token.getOwner(_tokenId);\n', '        token.updateOwner(_tokenId, _newOwner, prevOwner);\n', '        emit ChangedOwnership(_tokenId, prevOwner, _newOwner, now);\n', '        string memory meta = token.getMetadata(_tokenId);\n', '        token.removeTokenMetadata(_tokenId);\n', '        emit RemovedMetaData(_tokenId, msg.sender, meta, now);\n', '    }\n', '\n', '    /// @return tokenId, x, y, sizeA, sizeB, price\n', '    function getTokenData(uint256 _tokenId) public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n', '        return token.getTokenData(_tokenId);\n', '    }\n', '\n', '    function getMetaData(uint256 _tokenId) public view returns(string) {\n', '        return token.getMetadata(_tokenId);\n', '    }\n', '\n', '    /// @notice Withdraw a bid that was overbid and platform owner share\n', '    function claim() public returns (bool) {\n', '        return claimInternal(msg.sender);\n', '    }\n', '\n', '    /// @notice Withdraw (for cold storage wallet) a bid that was overbid and platform owner share\n', '    function claimByAddress(address _address) public returns (bool) {\n', '        return claimInternal(_address);\n', '    }\n', '\n', '    function claimInternal(address _address) internal returns (bool) {\n', '        require(_address != address(0));\n', '\n', '        uint256 amount = pendingReturns[_address];\n', '\n', '        if (amount == 0) {\n', '            return;\n', '        }\n', '\n', '        pendingReturns[_address] = 0;\n', '\n', '        _address.transfer(amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @return index of current tiers, if 100000(cannot use -1) then round 0  finished\n', '    /// and we need to move to re-sale\n', '    function getCurrentTierIndex() public view returns (uint256, uint256) {\n', '        // cannot use -1\n', '        // so use not possible value for tiers.length\n', '        uint256 indexInner = 100000;\n', '        uint256 indexOuter = 100000;\n', '\n', '        for (uint256 i = 0; i < tiers.length; i++) {\n', '            if (!tiers[i].filledInCenter) {\n', '                indexInner = i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        for (uint256 k = 0; k < tiers.length; k++) {\n', '            if (!tiers[k].filledInOuter) {\n', '                indexOuter = k;\n', '                break;\n', '            }\n', '        }\n', '\n', '        return (indexInner, indexOuter);\n', '    }\n', '\n', '    /// @return current tier stats\n', '    /// index of current tiers, if 100000(cannot use -1) then initial sale is  finished\n', '    /// works only during the initial phase\n', '    function getCurrentTierStats() public view returns (uint256 indexInner, uint256 indexOuter, uint256 availableInner, uint256 availableInOuter, uint256 priceInCenter, uint256 priceInOuter, uint256 nextPriceInCenter, uint256 nextPriceInOuter) {\n', '\n', '        indexInner = 100000;\n', '        indexOuter = 100000;\n', '\n', '        for (uint256 i = 0; i < tiers.length; i++) {\n', '            if (!tiers[i].filledInCenter) {\n', '                indexInner = i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        for (uint256 k = 0; k < tiers.length; k++) {\n', '            if (!tiers[k].filledInOuter) {\n', '                indexOuter = k;\n', '                break;\n', '            }\n', '        }\n', '\n', '        Tier storage tier;\n', '\n', '        if (indexInner != 100000) {\n', '            tier = tiers[indexInner];\n', '\n', '            availableInner = tier.amountInCenter.sub(tier.soldInCenter);\n', '\n', '            priceInCenter = tier.priceInCenter;\n', '\n', '            if (indexInner < 3) {\n', '                nextPriceInCenter = tiers[indexInner + 1].priceInCenter;\n', '            }\n', '        }\n', '\n', '        if (indexOuter != 100000) {\n', '            tier = tiers[indexOuter];\n', '\n', '            availableInOuter = tier.amountInOuter.sub(tier.soldInOuter);\n', '\n', '            priceInOuter = tier.priceInOuter;\n', '\n', '            if (indexOuter < 3) {\n', '                nextPriceInOuter = tiers[indexOuter + 1].priceInOuter;\n', '            }\n', '        }\n', '    }\n', '\n', '    function calculateAmountOfUnits(uint256 sizeA, uint256 sizeB) public pure returns (uint256) {\n', '        return sizeA.mul(sizeB);\n', '    }\n', '\n', '    /// @notice approve the offer\n', '    function approve(uint256 _index, uint256 _tokenId) internal {\n', '        Offer memory localOffer = offers[_index];\n', '\n', '        address newOwner = localOffer.from;\n', '        address prevOwner = token.getOwner(_tokenId);\n', '\n', '        uint256 platformShare;\n', '        uint256 forPrevOwner;\n', '\n', '        uint256 soldPrice = token.getTokenSoldPrice(_tokenId);\n', '\n', '        (platformShare, forPrevOwner) = pricingStrategy.calculateSharesInTheRevenue(\n', '            soldPrice, localOffer.offeredPrice);\n', '\n', '        //update token&#39;s state\n', '        token.updateTokensState(_tokenId, localOffer.offeredPrice);\n', '\n', '        // update owner\n', '        token.updateOwner(_tokenId, newOwner, prevOwner);\n', '        localOffer.accepted = true;\n', '\n', '        transferEthers(platformWallet, platformShare);\n', '        transferEthers(prevOwner, forPrevOwner.add(soldPrice));\n', '\n', '        emit OfferApproved(newOwner, _tokenId, localOffer.offerId, localOffer.offeredPrice, now);\n', '        emit Purchased(prevOwner, newOwner, _tokenId, localOffer.offeredPrice, soldPrice, forPrevOwner.add(soldPrice), platformShare, now);\n', '\n', '        afterApproveAction(_tokenId);\n', '    }\n', '\n', '    function transferEthers(address _address, uint256 _wei) internal {\n', '        if (isContract(_address)) {\n', '            pendingReturns[_address] = pendingReturns[_address].add(_wei);\n', '        }\n', '        else {\n', '            _address.transfer(_wei);\n', '        }\n', '    }\n', '\n', '    function preMinting(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal view returns (uint256, uint256) {\n', '        //  calculate units for token\n', '        uint256 total = 0;\n', '        uint256 inner = 0;\n', '        uint256 outer = 0;\n', '\n', '\n', '        (total, inner) = token.calculateCounters(x, y, sizeA, sizeB);\n', '        outer = total.sub(inner);\n', '\n', '        require(total <= 100);\n', '\n', '        return (inner, outer);\n', '    }\n', '\n', '    function updateTierStatus(uint256 inner, uint256 outer) internal {\n', '        uint256 leftInner = inner;\n', '        uint256 leftOuter = outer;\n', '\n', '        for (uint256 i = 0; i < 4; i++) {\n', '            Tier storage tier = tiers[i];\n', '\n', '            if (leftInner > 0 && tier.filledInCenter == false) {\n', '                uint256 availableInner = tier.amountInCenter.sub(tier.soldInCenter);\n', '\n', '                if (availableInner > leftInner) {\n', '                    tier.soldInCenter = tier.soldInCenter.add(leftInner);\n', '\n', '                    leftInner = 0;\n', '                } else {\n', '                    tier.filledInCenter = true;\n', '                    tier.soldInCenter = tier.amountInCenter;\n', '\n', '                    leftInner = leftInner.sub(availableInner);\n', '                }\n', '            }\n', '\n', '            if (leftOuter > 0 && tier.filledInOuter == false) {\n', '                uint256 availableOuter = tier.amountInOuter.sub(tier.soldInOuter);\n', '\n', '                if (availableOuter > leftOuter) {\n', '                    tier.soldInOuter = tier.soldInOuter.add(leftOuter);\n', '\n', '                    leftOuter = 0;\n', '                } else {\n', '                    tier.filledInOuter = true;\n', '                    tier.soldInOuter = tier.amountInOuter;\n', '\n', '                    leftOuter = leftOuter.sub(availableOuter);\n', '                }\n', '            }\n', '        }\n', '\n', '        require(leftInner == 0 && leftOuter == 0);\n', '    }\n', '\n', '    function calculateTokenPrice(uint256 inner, uint256 outer) public view returns (uint256 price) {\n', '        uint256 leftInner = inner;\n', '        uint256 leftOuter = outer;\n', '\n', '        for (uint256 i = 0; i < 4; i++) {\n', '            Tier storage tier = tiers[i];\n', '\n', '            if (leftInner > 0 && tier.filledInCenter == false) {\n', '                uint256 availableInner = tier.amountInCenter.sub(tier.soldInCenter);\n', '\n', '                if (availableInner > leftInner) {\n', '                    price = price.add(leftInner.mul(tier.priceInCenter));\n', '                    leftInner = 0;\n', '                } else {\n', '                    price = price.add(availableInner.mul(tier.priceInCenter));\n', '                    leftInner = leftInner.sub(availableInner);\n', '                }\n', '            }\n', '\n', '            if (leftOuter > 0 && tier.filledInOuter == false) {\n', '                uint256 availableOuter = tier.amountInOuter.sub(tier.soldInOuter);\n', '\n', '                if (availableOuter > leftOuter) {\n', '                    price = price.add(leftOuter.mul(tier.priceInOuter));\n', '                    leftOuter = 0;\n', '                } else {\n', '                    price = price.add(availableOuter.mul(tier.priceInOuter));\n', '                    leftOuter = leftOuter.sub(availableOuter);\n', '                }\n', '            }\n', '        }\n', '\n', '        require(leftInner == 0 && leftOuter == 0);\n', '    }\n', '\n', '    function minPriceForNextRound(uint256 _tokenId) public view returns (uint256) {\n', '        if (_tokenId == logoId && token.getCurrentPriceForToken(_tokenId) == 0) {\n', '            return logoPrice;\n', '        } else {\n', '            // @TODO: check if sold-out\n', '\n', '            uint256 currentPrice = getTokenPrice(_tokenId);\n', '            uint256 minPrice = pricingStrategy.calculateMinPriceForNextRound(currentPrice, minResalePercentage);\n', '            return minPrice;\n', '        }\n', '    }\n', '\n', '    function afterApproveAction(uint256 _tokenId) internal {\n', '\n', '        uint256 indexInner = 100000;\n', '        uint256 indexOuter = 100000;\n', '\n', '        bool hasInner;\n', '        bool hasOuter;\n', '\n', '        (hasInner, hasOuter) = token.getTokenScope(_tokenId);\n', '        (indexInner, indexOuter) = getCurrentTierIndex();\n', '\n', '        if (hasInner && hasOuter && indexInner == 100000 && indexOuter == 100000) {\n', '            token.increasePriceForNeighbours(_tokenId);\n', '        } else if (!hasInner && hasOuter && indexOuter == 100000) {\n', '            token.increasePriceForNeighbours(_tokenId);\n', '        } else if (!hasOuter && hasInner && indexInner == 100000) {\n', '            token.increasePriceForNeighbours(_tokenId);\n', '        }\n', '    }\n', '\n', '    function canBuyExistentToken(uint256 _tokenId) public view returns (uint256 _allowed) {\n', '        uint256 indexInner = 0;\n', '        uint256 indexOuter = 0;\n', '\n', '        bool hasInner;\n', '        bool hasOuter;\n', '\n', '        (hasInner, hasOuter) = token.getTokenScope(_tokenId);\n', '        (indexInner, indexOuter) = getCurrentTierIndex();\n', '\n', '        if (token.getCurrentPriceForToken(_tokenId) == 0 && logoPrice == 0) {\n', '            return 4;\n', '        }\n', '\n', '        if (_tokenId != logoId && hasInner && indexInner != 100000) {\n', '            return 2;\n', '        }\n', '\n', '        if (hasOuter && indexOuter != 100000) {\n', '            return 3;\n', '        }\n', '\n', '        return 1;\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Admin is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    struct Tier {\n', '        uint256 amountInCenter;\n', '        uint256 amountInOuter;\n', '        uint256 priceInCenter;\n', '        uint256 priceInOuter;\n', '        uint256 soldInCenter;\n', '        uint256 soldInOuter;\n', '        bool filledInCenter;\n', '        bool filledInOuter;\n', '    }\n', '\n', '    Tier[] public tiers;\n', '\n', '    bool public halted;\n', '    uint256 public logoPrice = 0;\n', '    uint256 public logoId;\n', '    address public platformWallet;\n', '\n', '    uint256 public feeForFirstArtWorkChangeRequest = 0 ether;\n', '    uint256 public feeForArtWorkChangeRequest = 0.2 ether;\n', '    uint256 public minResalePercentage = 15;\n', '\n', '    mapping(address => bool) public globalAdmins;\n', '    mapping(address => bool) public admins;\n', '    mapping(address => bool) public signers;\n', '\n', '    event Halted(bool _halted);\n', '\n', '    modifier onlyAdmin() {\n', '        require(true == admins[msg.sender] || true == globalAdmins[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyGlobalAdmin() {\n', '        require(true == globalAdmins[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier notHalted() {\n', '        require(halted == false);\n', '        _;\n', '    }\n', '\n', '    function addGlobalAdmin(address _address) public onlyOwner() {\n', '        globalAdmins[_address] = true;\n', '    }\n', '\n', '    function removeGlobalAdmin(address _address) public onlyOwner() {\n', '        globalAdmins[_address] = false;\n', '    }\n', '\n', '    function addAdmin(address _address) public onlyGlobalAdmin() {\n', '        admins[_address] = true;\n', '    }\n', '\n', '    function removeAdmin(address _address) public onlyGlobalAdmin() {\n', '        admins[_address] = true;\n', '    }\n', '\n', '    function setSigner(address _address, bool status) public onlyGlobalAdmin() {\n', '        signers[_address] = status;\n', '    }\n', '\n', '    function setLogoPrice(uint256 _price) public onlyGlobalAdmin() {\n', '        logoPrice = _price;\n', '    }\n', '\n', '    function setFeeForFirstArtWorkChangeRequest(uint256 _fee) public onlyGlobalAdmin() {\n', '        feeForFirstArtWorkChangeRequest = _fee;\n', '    }\n', '\n', '    function setFeeForArtWorkChangeRequest(uint256 _fee) public onlyGlobalAdmin() {\n', '        feeForArtWorkChangeRequest = _fee;\n', '    }\n', '\n', '    /// @notice global Admin update tier data\n', '    function setTierData(\n', '        uint256 _index,\n', '        uint256 _priceInCenter,\n', '        uint256 _priceInOuter) public onlyGlobalAdmin() {\n', '        Tier memory tier = tiers[_index];\n', '        tier.priceInCenter = _priceInCenter;\n', '        tier.priceInOuter = _priceInOuter;\n', '        tiers[_index] = tier;\n', '    }\n', '\n', '    function setMinResalePercentage(uint256 _minResalePercentage) public onlyGlobalAdmin() {\n', '        minResalePercentage = _minResalePercentage;\n', '    }\n', '\n', '    function isAdmin(address _address) public view returns (bool isAdmin_) {\n', '        return (true == admins[_address] || true == globalAdmins[_address]);\n', '    }\n', '\n', '    function setHalted(bool _halted) public onlyGlobalAdmin {\n', '        halted = _halted;\n', '\n', '        emit Halted(_halted);\n', '    }\n', '\n', '    function verify(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\n', "        bytes memory prefix = '\\x19Ethereum Signed Message:\\n32';\n", '\n', '        return ecrecover(keccak256(abi.encodePacked(prefix, _hash)), _v, _r, _s);\n', '    }\n', '\n', '    function isContract(address addr) public view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '    function setPlatformWallet(address _addresss) public onlyGlobalAdmin() {\n', '        platformWallet = _addresss;\n', '    }\n', '}\n', '\n', 'contract BigIoAdSpace is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /// @notice Token\n', '    struct Token {\n', '        uint256 id;\n', '        uint256 x; // position X on map\n', '        uint256 y; // position Y on map\n', '        uint256 sizeA;\n', '        uint256 sizeB;\n', '        uint256 soldPrice; // price that user paid to buy token\n', '        uint256 actualPrice;\n', '        uint256 timesSold; // how many times token was sold\n', '        uint256 timesUpdated; // how many times artwork has been changed by current owner\n', '        uint256 soldAt; // when token was sold\n', '        uint256 inner;\n', '        uint256 outer;\n', '        uint256 soldNearby;\n', '    }\n', '\n', '    struct MetaData {\n', '        string meta;\n', '    }\n', '\n', '    struct InnerScope {\n', '        uint256 x1; // left top\n', '        uint256 y1;\n', '        uint256 x2; // right top\n', '        uint256 y2;\n', '        uint256 x3; // left bottom\n', '        uint256 y3;\n', '        uint256 x4; // right bottom\n', '        uint256 y4;\n', '    }\n', '\n', '    InnerScope public innerScope;\n', '\n', '    /// @notice mapping for token URIs\n', '    mapping(uint256 => MetaData) public metadata;\n', '\n', '    /// @notice Mapping from token ID to owner\n', '    mapping(uint256 => address) public tokenOwner;\n', '\n', '    mapping(uint256 => mapping(uint256 => bool)) public neighbours;\n', '    mapping(uint256 => uint256[]) public neighboursArea;\n', '\n', '    /// @notice Here different from base class we store the token not an id\n', '    /// Array with all token, used for enumeration\n', '    Token[] public allMinedTokens;\n', '\n', '    /// @notice Mapping from token id to position in the allMinedTokens array\n', '    mapping(uint256 => uint256) public allTokensIndex;\n', '\n', '    // store sold units and not-sold but generated units\n', '//    mapping(uint256 => mapping(uint256 => bool)) public soldUnits;\n', '    mapping(uint256 => mapping(uint256 => uint256)) public soldUnits;\n', '\n', '    address public platform;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event TokenPriceIncreased(uint256 _tokenId, uint256 _newPrice, uint256 _boughtTokenId, uint256 time);\n', '\n', '    constructor () public {\n', '        innerScope = InnerScope(\n', '            12, 11, // left top\n', '            67, 11, // right top\n', '            12, 34, // left bottom\n', '            67, 34\n', '        );\n', '    }\n', '\n', '    modifier onlyPlatform() {\n', '        require(msg.sender == platform);\n', '        _;\n', '    }\n', '\n', '    modifier exists(uint256 _tokenId) {\n', '        address owner = tokenOwner[_tokenId];\n', '        require(owner != address(0));\n', '        _;\n', '    }\n', '\n', '    function setPlatform(address _platform) public onlyOwner() {\n', '        platform = _platform;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return allMinedTokens.length;\n', '    }\n', '\n', '    /// @notice Check whether token is minted\n', '    function tokenExists(uint256 _tokenId) public view returns (bool) {\n', '        address owner = tokenOwner[_tokenId];\n', '        return owner != address(0);\n', '    }\n', '\n', '    /// @notice Check whether exist Unit with same x any y coordinates\n', '    /// and it was sold already\n', '    /// in order to prevent over writing\n', '    function unitExists(uint x, uint y) public view returns (bool) {\n', '        return (soldUnits[x][y] != 0);\n', '    }\n', '\n', '    function getOwner(uint256 _tokenId) public view returns (address) {\n', '        return tokenOwner[_tokenId];\n', '    }\n', '\n', '    /// @return token metadata\n', '    function getMetadata(uint256 _tokenId) public exists(_tokenId) view returns (string) {\n', '        return metadata[_tokenId].meta;\n', '    }\n', '\n', '    /// @notice update metadata for token\n', '    function setTokenMetadata(uint256 _tokenId, string meta) public  onlyPlatform exists(_tokenId) {\n', '        metadata[_tokenId] = MetaData(meta);\n', '    }\n', '\n', '    function increaseUpdateMetadataCounter(uint256 _tokenId) public onlyPlatform {\n', '        allMinedTokens[allTokensIndex[_tokenId]].timesUpdated = allMinedTokens[allTokensIndex[_tokenId]].timesUpdated.add(1);\n', '    }\n', '\n', '    /// @notice remove metadata for token\n', '    function removeTokenMetadata(uint256 _tokenId) public onlyPlatform exists(_tokenId) {\n', '        delete metadata[_tokenId];\n', '    }\n', '\n', '    // @return return the current price\n', '    function getCurrentPriceForToken(uint256 _tokenId) public exists(_tokenId) view returns (uint256) {\n', '        return allMinedTokens[allTokensIndex[_tokenId]].actualPrice;\n', '    }\n', '\n', '    /// @return tokenId, x, y, sizeA, sizeB, price, inner, outer\n', '    function getTokenData(uint256 _tokenId) public exists(_tokenId) view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n', '        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\n', '        return (_tokenId, token.x, token.y, token.sizeA, token.sizeB, token.actualPrice, token.soldPrice, token.inner, token.outer);\n', '    }\n', '\n', '    function getTokenSoldPrice(uint256 _tokenId) public exists(_tokenId) view returns (uint256) {\n', '        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\n', '        return token.soldPrice;\n', '    }\n', '\n', '    function getTokenUpdatedCounter(uint256 _tokenId) public exists(_tokenId) view returns (uint256) {\n', '        return allMinedTokens[allTokensIndex[_tokenId]].timesUpdated;\n', '    }\n', '\n', '    // @return return token sizes\n', '    function getTokenSizes(uint256 _tokenId) public exists(_tokenId) view returns (uint256, uint256) {\n', '        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\n', '        return (token.sizeA, token.sizeB);\n', '    }\n', '\n', '    // @return return token scopes\n', '    function getTokenScope(uint256 _tokenId) public exists(_tokenId) view returns (bool, bool) {\n', '        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\n', '        return (token.inner > 0, token.outer > 0);\n', '    }\n', '\n', '    // @return return token scope counters\n', '    function getTokenCounters(uint256 _tokenId) public exists(_tokenId) view returns (uint256, uint256, uint256, uint256) {\n', '        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\n', '        return (token.inner, token.outer, token.timesSold, token.soldNearby);\n', '    }\n', '\n', '    /// @notice Mint new token, not sell new token\n', '    /// BE sends: owner, x coordinate, y coordinate, price\n', '    /// @param to new owner\n', '    /// @param x coordinate\n', '    /// @param y coordinate\n', '    /// @param totalPrice calculated price for all units + % for siblings\n', '    function mint(\n', '        address to,\n', '        uint x,\n', '        uint y,\n', '        uint sizeA,\n', '        uint sizeB,\n', '        uint256 totalPrice,\n', '        uint256 actualPrice\n', '    ) public onlyPlatform() returns (uint256) {\n', '\n', '        // 1.\n', '        require(to != address(0));\n', '        require(sizeA.mul(sizeB) <= 100);\n', '\n', '        // 2. check area\n', '        uint256 inner;\n', '        uint256 total;\n', '\n', '        (total, inner) = calculateCounters(x, y, sizeA, sizeB);\n', '\n', '        // we avoid zero because we later compare against zero\n', '        uint256 tokenId = (allMinedTokens.length).add(1);\n', '\n', '        // @TODO: ACHTUNG - soldAt equals 0 during minting\n', '        Token memory minted = Token(tokenId, x, y, sizeA, sizeB, totalPrice, actualPrice, 0, 0, 0, inner, total.sub(inner), 0);\n', '\n', '        // 3. copy units and create siblings\n', '        copyToAllUnits(x, y, sizeA, sizeB, tokenId);\n', '\n', '        // 4. update state\n', '        updateInternalState(minted, to);\n', '\n', '        return tokenId;\n', '    }\n', '\n', '    function updateTokensState(uint256 _tokenId, uint256 newPrice) public onlyPlatform exists(_tokenId) {\n', '        uint256 index = allTokensIndex[_tokenId];\n', '        allMinedTokens[index].timesSold += 1;\n', '        allMinedTokens[index].timesUpdated = 0;\n', '        allMinedTokens[index].soldNearby = 0;\n', '        allMinedTokens[index].soldPrice = newPrice;\n', '        allMinedTokens[index].actualPrice = newPrice;\n', '        allMinedTokens[index].soldAt = now;\n', '    }\n', '\n', '    function updateOwner(uint256 _tokenId, address newOwner, address prevOwner) public onlyPlatform exists(_tokenId) {\n', '        require(newOwner != address(0));\n', '        require(prevOwner != address(0));\n', '        require(prevOwner == tokenOwner[_tokenId]);\n', '\n', '        // update data for new owner\n', '        tokenOwner[_tokenId] = newOwner;\n', '    }\n', '\n', '    function inInnerScope(uint256 x, uint256 y) public view returns (bool) {\n', '        // x should be between left top and right top corner\n', '        // y should be between left top and left bottom corner\n', '        if ((x >= innerScope.x1) && (x <= innerScope.x2) && (y >= innerScope.y1) && (y <= innerScope.y3)) {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function calculateCounters(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) public view returns (uint256 total, uint256 inner) {\n', '        uint256 upX = x.add(sizeA);\n', '        uint256 upY = y.add(sizeB);\n', '\n', '        // check for boundaries\n', '        require(x >= 1);\n', '        require(y >= 1);\n', '        require(upX <= 79);\n', '        require(upY <= 45);\n', '        require(sizeA > 0);\n', '        require(sizeB > 0);\n', '\n', '        uint256 i;\n', '        uint256 j;\n', '\n', '        for (i = x; i < upX; i++) {\n', '            for (j = y; j < upY; j++) {\n', '                require(soldUnits[i][j] == 0);\n', '\n', '                if (inInnerScope(i, j)) {\n', '                    inner = inner.add(1);\n', '                }\n', '\n', '                total = total.add(1);\n', '            }\n', '        }\n', '    }\n', '\n', '    function increasePriceForNeighbours(uint256 tokenId) public onlyPlatform {\n', '\n', '        Token memory token = allMinedTokens[allTokensIndex[tokenId]];\n', '\n', '        uint256 upX = token.x.add(token.sizeA);\n', '        uint256 upY = token.y.add(token.sizeB);\n', '\n', '        uint256 i;\n', '        uint256 j;\n', '        uint256 k;\n', '        uint256 _tokenId;\n', '\n', '\n', '        if (neighboursArea[tokenId].length == 0) {\n', '\n', '            for (i = token.x; i < upX; i++) {\n', '                // check neighbors on top of area\n', '                _tokenId = soldUnits[i][token.y - 1];\n', '\n', '                if (_tokenId != 0) {\n', '                    if (!neighbours[tokenId][_tokenId]) {\n', '                        neighbours[tokenId][_tokenId] = true;\n', '                        neighboursArea[tokenId].push(_tokenId);\n', '                    }\n', '                    if (!neighbours[_tokenId][tokenId]) {\n', '                        neighbours[_tokenId][tokenId] = true;\n', '                        neighboursArea[_tokenId].push(tokenId);\n', '                    }\n', '                }\n', '\n', '                // check neighbors on bottom of area\n', '                _tokenId = soldUnits[i][upY];\n', '                if (_tokenId != 0) {\n', '                    if (!neighbours[tokenId][_tokenId]) {\n', '                        neighbours[tokenId][_tokenId] = true;\n', '                        neighboursArea[tokenId].push(_tokenId);\n', '                    }\n', '                    if (!neighbours[_tokenId][tokenId]) {\n', '                        neighbours[_tokenId][tokenId] = true;\n', '                        neighboursArea[_tokenId].push(tokenId);\n', '                    }\n', '                }\n', '            }\n', '\n', '            for (j = token.y; j < upY; j++) {\n', '                // check neighbors on left of area of area\n', '                _tokenId = soldUnits[token.x - 1][j];\n', '                if (_tokenId != 0) {\n', '                    if (!neighbours[tokenId][_tokenId]) {\n', '                        neighbours[tokenId][_tokenId] = true;\n', '                        neighboursArea[tokenId].push(_tokenId);\n', '                    }\n', '                    if (!neighbours[_tokenId][tokenId]) {\n', '                        neighbours[_tokenId][tokenId] = true;\n', '                        neighboursArea[_tokenId].push(tokenId);\n', '                    }\n', '                }\n', '\n', '                // check neighbors on right of area of area\n', '                _tokenId = soldUnits[upX][j];\n', '                if (_tokenId != 0) {\n', '                    if (!neighbours[tokenId][_tokenId]) {\n', '                        neighbours[tokenId][_tokenId] = true;\n', '                        neighboursArea[tokenId].push(_tokenId);\n', '                    }\n', '                    if (!neighbours[_tokenId][tokenId]) {\n', '                        neighbours[_tokenId][tokenId] = true;\n', '                        neighboursArea[_tokenId].push(tokenId);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        // increase price\n', '        for (k = 0; k < neighboursArea[tokenId].length; k++) {\n', '            Token storage _token = allMinedTokens[allTokensIndex[neighboursArea[tokenId][k]]];\n', '            _token.soldNearby = _token.soldNearby.add(1);\n', '            _token.actualPrice = _token.actualPrice.add((_token.actualPrice.div(100)));\n', '            emit TokenPriceIncreased(_token.id, _token.actualPrice, _tokenId, now);\n', '        }\n', '    }\n', '\n', '    // move generated Units to sold array\n', '    // generate siblings and put it there\n', '    function copyToAllUnits(uint256 x, uint256 y, uint256 width, uint256 height, uint256 tokenId) internal {\n', '        uint256 upX = x + width; // 5\n', '        uint256 upY = y + height; // 3\n', '\n', '        uint256 i; // 1\n', '        uint256 j; // 1\n', '\n', '        for (i = x; i < upX; i++) {\n', '            for (j = y; j < upY; j++) {\n', '                soldUnits[i][j] = tokenId;\n', '            }\n', '        }\n', '    }\n', '\n', '    function updateInternalState(Token minted, address _to) internal {\n', '        uint256 lengthT = allMinedTokens.length;\n', '        allMinedTokens.push(minted);\n', '        allTokensIndex[minted.id] = lengthT;\n', '        tokenOwner[minted.id] = _to;\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract BigIOERC20token is StandardToken, Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    uint256 public maxSupply;\n', '\n', '    bool public allowedMinting;\n', '\n', '    mapping(address => bool) public mintingAgents;\n', '    mapping(address => bool) public stateChangeAgents;\n', '\n', '    event MintERC20(address indexed _holder, uint256 _tokens);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '    modifier onlyMintingAgents () {\n', '        require(mintingAgents[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    constructor (string _name, string _symbol, uint8 _decimals, uint256 _maxSupply) public StandardToken() {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '\n', '        maxSupply = _maxSupply;\n', '\n', '        allowedMinting = true;\n', '\n', '        mintingAgents[msg.sender] = true;\n', '    }\n', '\n', '    /// @notice update minting agent\n', '    function updateMintingAgent(address _agent, bool _status) public onlyOwner {\n', '        mintingAgents[_agent] = _status;\n', '    }\n', '\n', '    /// @notice allow to mint tokens\n', '    function mint(address _holder, uint256 _tokens) public onlyMintingAgents() {\n', '        require(allowedMinting == true && totalSupply_.add(_tokens) <= maxSupply);\n', '\n', '        totalSupply_ = totalSupply_.add(_tokens);\n', '\n', '        balances[_holder] = balanceOf(_holder).add(_tokens);\n', '\n', '        if (totalSupply_ == maxSupply) {\n', '            allowedMinting = false;\n', '        }\n', '        emit MintERC20(_holder, _tokens);\n', '        emit Transfer(0x0, _holder, _tokens);\n', '    }\n', '\n', '}\n', '\n', 'contract PricingStrategy {\n', '    using SafeMath for uint256;\n', '\n', '    function calculateMinPriceForNextRound(uint256 _tokenPrice, uint256 _minResalePercentage) public pure returns (uint256) {\n', '        return _tokenPrice.add(_tokenPrice.div(100).mul(_minResalePercentage));\n', '    }\n', '\n', '    function calculateSharesInTheRevenue(uint256 _prevTokenPrice, uint256 _newTokenPrice) public pure returns (uint256, uint256) {\n', '        uint256 revenue = _newTokenPrice.sub(_prevTokenPrice);\n', '        uint256 platformShare = revenue.mul(40).div(100);\n', '        uint256 forPrevOwner = revenue.sub(platformShare);\n', '        return (platformShare, forPrevOwner);\n', '    }\n', '}\n', '/// @title Platform\n', '/// @author Applicature\n', '/// @notice It is front contract which is used to sell, re-sell tokens and initiate paying dividends\n', 'contract Platform is Admin {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    struct Offer {\n', '        uint256 tokenId;\n', '        uint256 offerId;\n', '        address from;\n', '        uint256 offeredPrice;\n', '        uint256 tokenPrice;\n', '        bool accepted;\n', '        uint256 timestamp;\n', '    }\n', '\n', '    struct ArtWorkChangeRequest {\n', '        address fromUser;\n', '        uint256 tokenId;\n', '        uint256 changeId;\n', '        string meta;\n', '        uint256 timestamp;\n', '        bool isReviewed;\n', '    }\n', '\n', '    BigIoAdSpace public token;\n', '    BigIOERC20token public erc20token;\n', '\n', '    PricingStrategy public pricingStrategy;\n', '    ArtWorkChangeRequest[] public artWorkChangeRequests;\n', '\n', '    bool public isLogoInitied;\n', '\n', '    uint256 public logoX = 35;\n', '    uint256 public logoY = 18;\n', '\n', '    Offer[] public offers;\n', '\n', '    mapping(address => uint256) public pendingReturns;\n', '\n', '    event Minted(address indexed _owner, uint256 _tokenId, uint256 _x, uint256 _y, uint256 _sizeA, uint256 _sizeB, uint256 _price, uint256 _platformTransfer, uint256 _timestamp);\n', '\n', '    event Purchased(address indexed _from, address indexed _to, uint256 _tokenId, uint256 _price, uint256 _prevPrice, uint256 _prevOwnerTransfer, uint256 _platformTransfer, uint256 _timestamp);\n', '\n', '    event OfferMade(address indexed _fromUser, uint256 _tokenId, uint256 _offerId, uint256 _offeredPrice, uint256 _timestamp);\n', '\n', '    event OfferApproved(address indexed _owner, uint256 _tokenId, uint256 _offerId, uint256 _offeredPrice, uint256 _timestamp);\n', '\n', '    event OfferDeclined(address indexed _fromUser, uint256 _tokenId, uint256 _offerId, uint256 _offeredPrice, uint256 _timestamp);\n', '\n', '    event ArtWorkChangeRequestMade(\n', '        address indexed _fromUser,\n', '        uint256 _tokenId,\n', '        uint256 _changeId,\n', '        string _meta,\n', '        uint256 _platformTransfer,\n', '        uint256 _timestamp);\n', '\n', '    event ArtWorkChangeRequestApproved(\n', '        address indexed _fromUser,\n', '        uint256 _tokenId,\n', '        uint256 _changeId,\n', '        string _meta,\n', '        uint256 _timestamp);\n', '\n', '    event ArtWorkChangeRequestDeclined(\n', '        address indexed _fromUser,\n', '        uint256 _tokenId,\n', '        uint256 _changeId,\n', '        string _meta,\n', '        uint256 _timestamp);\n', '\n', '    event RemovedMetaData(uint256 _tokenId, address _admin, string _meta, uint256 _timestamp);\n', '    event ChangedOwnership(uint256 _tokenId, address _prevOwner, address _newOwner, uint256 _timestamp);\n', '\n', '    constructor(\n', '        address _platformWallet, // owner collects money\n', '        address _token,\n', '        address _erc20token,\n', '        address _pricingStrategy,\n', '        address _signer\n', '    ) public {\n', '\n', '        token = BigIoAdSpace(_token);\n', '        erc20token = BigIOERC20token(_erc20token);\n', '\n', '        platformWallet = _platformWallet;\n', '\n', '        pricingStrategy = PricingStrategy(_pricingStrategy);\n', '\n', '        signers[_signer] = true;\n', '\n', '        // 30%\n', '        tiers.push(\n', '            Tier(\n', '                400, // amountInCenter\n', '                600, // amountInOuter\n', '                1 ether, // priceInCenter\n', '                0.4 ether, // priceInOuter\n', '                0, // soldInCenter\n', '                0, // soldInOuter\n', '                false, // filledInCenter\n', '                false // filledInOuter\n', '            )\n', '        );\n', '        // 30%\n', '        tiers.push(\n', '            Tier(\n', '                400, 600, 1.2 ether, 0.6 ether, 0, 0, false, false\n', '            )\n', '        );\n', '        // 30%\n', '        tiers.push(\n', '            Tier(\n', '                400, 600, 1.4 ether, 0.8 ether, 0, 0, false, false\n', '            )\n', '        );\n', '        // 10%\n', '        tiers.push(\n', '            Tier(\n', '                144, 288, 1.6 ether, 1.0 ether, 0, 0, false, false\n', '            )\n', '        );\n', '    }\n', '\n', '    /// @notice init logo, call it as soon as possible\n', '    /// call it after setting platform in the token\n', '    /// Logo is BigIOToken which has 10*10 size and position in the center of map\n', '    function initLogo() public onlyOwner {\n', '        require(isLogoInitied == false);\n', '\n', '        isLogoInitied = true;\n', '\n', '        logoId = token.mint(platformWallet, logoX, logoY, 10, 10, 0 ether, 0 ether);\n', '\n', '        token.setTokenMetadata(logoId, "");\n', '\n', '        updateTierStatus(100, 0);\n', '\n', '        emit Minted(msg.sender, logoId, logoX, logoY, 10, 10, 0 ether, 0 ether, now);\n', '    }\n', '\n', '    function getPriceFor(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) public view returns(uint256 totalPrice, uint256 inner, uint256 outer) {\n', '        (inner, outer) = preMinting(x, y, sizeA, sizeB);\n', '\n', '        totalPrice = calculateTokenPrice(inner, outer);\n', '\n', '        return (totalPrice, inner, outer);\n', '    }\n', '\n', '    /// @notice sell new tokens during the round 0\n', '    /// all except logo\n', '    function buy(\n', '        uint256 x, // top left coordinates\n', '        uint256 y, // top left coordinates\n', '        uint256 sizeA, // size/width of a square\n', '        uint256 sizeB, // size/height of a square,\n', '        uint8 _v,  // component of signature\n', '        bytes32 _r, // component of signature\n', '        bytes32 _s // component of signature\n', '    ) public notHalted() payable {\n', '        address recoveredSigner = verify(keccak256(msg.sender), _v, _r, _s);\n', '\n', '        require(signers[recoveredSigner] == true);\n', '        require(msg.value > 0);\n', '\n', '        internalBuy(x, y, sizeA, sizeB);\n', '    }\n', '\n', '    function internalBuy(\n', '        uint256 x, // top left coordinates\n', '        uint256 y, // top left coordinates\n', '        uint256 sizeA, // size/width of a square\n', '        uint256 sizeB // size/height of a square,\n', '    ) internal {\n', '        // get and validate current tier\n', '        uint256 inner = 0;\n', '        uint256 outer = 0;\n', '        uint256 totalPrice = 0;\n', '\n', '        (inner, outer) = preMinting(x, y, sizeA, sizeB);\n', '        totalPrice = calculateTokenPrice(inner, outer);\n', '\n', '        require(totalPrice <= msg.value);\n', '\n', '        //         try to mint and update current tier\n', '        updateTierStatus(inner, outer);\n', '\n', '        uint256 actualPrice = inner.mul(tiers[3].priceInCenter).add(outer.mul(tiers[3].priceInOuter));\n', '\n', '        if (msg.value > actualPrice) {\n', '            actualPrice = msg.value;\n', '        }\n', '\n', '        uint256 tokenId = token.mint(msg.sender, x, y, sizeA, sizeB, msg.value, actualPrice);\n', '        erc20token.mint(msg.sender, inner.add(outer));\n', '\n', '        transferEthers(platformWallet, msg.value);\n', '\n', '        emit Minted(msg.sender, tokenId, x, y, sizeA, sizeB, msg.value, msg.value, now);\n', '    }\n', '\n', '    /// @notice allow user to make an offer after initial phase(re-sale)\n', '    /// any offer minResalePercentage is accepted automatically\n', '    function makeOffer(\n', '        uint256 _tokenId,\n', '        uint8 _v,  // component of signature\n', '        bytes32 _r, // component of signature\n', '        bytes32 _s // component of signature\n', '    ) public notHalted() payable {\n', '\n', '        address recoveredSigner = verify(keccak256(msg.sender), _v, _r, _s);\n', '\n', '        require(signers[recoveredSigner] == true);\n', '\n', '        require(msg.sender != address(0));\n', '        require(msg.value > 0);\n', '\n', '        uint256 currentPrice = getTokenPrice(_tokenId);\n', '        require(currentPrice > 0);\n', '\n', '        // special case for first sell of logo\n', '        if (_tokenId == logoId && token.getCurrentPriceForToken(_tokenId) == 0) {\n', '            require(msg.value >= logoPrice);\n', '\n', "            //update token's state\n", '            token.updateTokensState(logoId, msg.value);\n', '\n', '            // mint erc20 tokens\n', '            erc20token.mint(msg.sender, 100);\n', '\n', '            transferEthers(platformWallet, msg.value);\n', '\n', '            emit Purchased(0, msg.sender, _tokenId, msg.value, 0, 0, msg.value, now);\n', '\n', '            return;\n', '        }\n', '\n', '        uint256 minPrice = pricingStrategy.calculateMinPriceForNextRound(currentPrice, minResalePercentage);\n', '\n', '        require(msg.value >= minPrice);\n', '\n', '        uint256 offerCounter = offers.length;\n', '\n', '        offers.push(Offer(_tokenId, offerCounter, msg.sender, msg.value, currentPrice, false, now));\n', '        emit OfferMade(msg.sender, _tokenId, offerCounter, msg.value, now);\n', '\n', '        // 2. check condition for approve and do it\n', '        approve(offerCounter, _tokenId);\n', '    }\n', '\n', '    function getTokenPrice(uint256 _tokenId) public view returns (uint256 price) {\n', '\n', '        uint256 actualPrice = token.getCurrentPriceForToken(_tokenId);\n', '\n', '        // special case for first sell of logo\n', '        if (_tokenId == logoId && actualPrice == 0) {\n', '            require(logoPrice > 0);\n', '\n', '            return logoPrice;\n', '        } else {\n', '            uint256 indexInner = 0;\n', '            uint256 indexOuter = 0;\n', '\n', '            bool hasInner;\n', '            bool hasOuter;\n', '\n', '            (hasInner, hasOuter) = token.getTokenScope(_tokenId);\n', '            (indexInner, indexOuter) = getCurrentTierIndex();\n', '\n', '            if (_tokenId != logoId && hasInner) {\n', '                require(indexInner == 100000);\n', '            }\n', '\n', '            if (hasOuter) {\n', '                require(indexOuter == 100000);\n', '            }\n', '\n', '            return actualPrice;\n', '        }\n', '    }\n', '\n', '    function getArtWorkChangeFee(uint256 _tokenId) public view returns (uint256 fee) {\n', '\n', '        uint256 counter = token.getTokenUpdatedCounter(_tokenId);\n', '\n', '        if (counter > 0) {\n', '            return feeForArtWorkChangeRequest;\n', '        }\n', '\n', '        return feeForFirstArtWorkChangeRequest;\n', '    }\n', '\n', '    /// @notice it allows token owner to create art work change request\n', '    /// first user upload 2 images\n', '    /// then do call this function\n', '    /// admin can reject or approve it\n', '    function artWorkChangeRequest(uint256 _tokenId, string _meta, uint8 _v, bytes32 _r, bytes32 _s)\n', '        public payable returns (uint256)\n', '    {\n', '\n', '        address recoveredSigner = verify(keccak256(_meta), _v, _r, _s);\n', '\n', '        require(signers[recoveredSigner] == true);\n', '\n', '        require(msg.sender == token.getOwner(_tokenId));\n', '\n', '        uint256 fee = getArtWorkChangeFee(_tokenId);\n', '\n', '        require(msg.value >= fee);\n', '\n', '        uint256 changeRequestCounter = artWorkChangeRequests.length;\n', '\n', '        artWorkChangeRequests.push(\n', '            ArtWorkChangeRequest(msg.sender, _tokenId, changeRequestCounter, _meta, now, false)\n', '        );\n', '\n', '        token.increaseUpdateMetadataCounter(_tokenId);\n', '\n', '        transferEthers(platformWallet, msg.value);\n', '\n', '        emit ArtWorkChangeRequestMade(msg.sender, _tokenId, changeRequestCounter, _meta, msg.value, now);\n', '\n', '        return changeRequestCounter;\n', '    }\n', '\n', '    function artWorkChangeApprove(uint256 _index, uint256 _tokenId, bool approve) public onlyAdmin {\n', '        ArtWorkChangeRequest storage request = artWorkChangeRequests[_index];\n', '        require(false == request.isReviewed);\n', '\n', '        require(_tokenId == request.tokenId);\n', '        request.isReviewed = true;\n', '        if (approve) {\n', '            token.setTokenMetadata(_tokenId, request.meta);\n', '            emit ArtWorkChangeRequestApproved(\n', '                request.fromUser,\n', '                request.tokenId,\n', '                request.changeId,\n', '                request.meta,\n', '                now\n', '            );\n', '        } else {\n', '            emit ArtWorkChangeRequestDeclined(\n', '                request.fromUser,\n', '                request.tokenId,\n', '                request.changeId,\n', '                request.meta,\n', '                now\n', '            );\n', '        }\n', '    }\n', '\n', '    function artWorkChangeByAdmin(uint256 _tokenId, string _meta, uint256 _changeId) public onlyAdmin {\n', '        token.setTokenMetadata(_tokenId, _meta);\n', '        emit ArtWorkChangeRequestApproved(\n', '            msg.sender,\n', '            _tokenId,\n', '            _changeId,\n', '            _meta,\n', '            now\n', '        );\n', '    }\n', '\n', '    function changeTokenOwnerByAdmin(uint256 _tokenId, address _newOwner) public onlyAdmin {\n', '        address prevOwner = token.getOwner(_tokenId);\n', '        token.updateOwner(_tokenId, _newOwner, prevOwner);\n', '        emit ChangedOwnership(_tokenId, prevOwner, _newOwner, now);\n', '        string memory meta = token.getMetadata(_tokenId);\n', '        token.removeTokenMetadata(_tokenId);\n', '        emit RemovedMetaData(_tokenId, msg.sender, meta, now);\n', '    }\n', '\n', '    /// @return tokenId, x, y, sizeA, sizeB, price\n', '    function getTokenData(uint256 _tokenId) public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n', '        return token.getTokenData(_tokenId);\n', '    }\n', '\n', '    function getMetaData(uint256 _tokenId) public view returns(string) {\n', '        return token.getMetadata(_tokenId);\n', '    }\n', '\n', '    /// @notice Withdraw a bid that was overbid and platform owner share\n', '    function claim() public returns (bool) {\n', '        return claimInternal(msg.sender);\n', '    }\n', '\n', '    /// @notice Withdraw (for cold storage wallet) a bid that was overbid and platform owner share\n', '    function claimByAddress(address _address) public returns (bool) {\n', '        return claimInternal(_address);\n', '    }\n', '\n', '    function claimInternal(address _address) internal returns (bool) {\n', '        require(_address != address(0));\n', '\n', '        uint256 amount = pendingReturns[_address];\n', '\n', '        if (amount == 0) {\n', '            return;\n', '        }\n', '\n', '        pendingReturns[_address] = 0;\n', '\n', '        _address.transfer(amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @return index of current tiers, if 100000(cannot use -1) then round 0  finished\n', '    /// and we need to move to re-sale\n', '    function getCurrentTierIndex() public view returns (uint256, uint256) {\n', '        // cannot use -1\n', '        // so use not possible value for tiers.length\n', '        uint256 indexInner = 100000;\n', '        uint256 indexOuter = 100000;\n', '\n', '        for (uint256 i = 0; i < tiers.length; i++) {\n', '            if (!tiers[i].filledInCenter) {\n', '                indexInner = i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        for (uint256 k = 0; k < tiers.length; k++) {\n', '            if (!tiers[k].filledInOuter) {\n', '                indexOuter = k;\n', '                break;\n', '            }\n', '        }\n', '\n', '        return (indexInner, indexOuter);\n', '    }\n', '\n', '    /// @return current tier stats\n', '    /// index of current tiers, if 100000(cannot use -1) then initial sale is  finished\n', '    /// works only during the initial phase\n', '    function getCurrentTierStats() public view returns (uint256 indexInner, uint256 indexOuter, uint256 availableInner, uint256 availableInOuter, uint256 priceInCenter, uint256 priceInOuter, uint256 nextPriceInCenter, uint256 nextPriceInOuter) {\n', '\n', '        indexInner = 100000;\n', '        indexOuter = 100000;\n', '\n', '        for (uint256 i = 0; i < tiers.length; i++) {\n', '            if (!tiers[i].filledInCenter) {\n', '                indexInner = i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        for (uint256 k = 0; k < tiers.length; k++) {\n', '            if (!tiers[k].filledInOuter) {\n', '                indexOuter = k;\n', '                break;\n', '            }\n', '        }\n', '\n', '        Tier storage tier;\n', '\n', '        if (indexInner != 100000) {\n', '            tier = tiers[indexInner];\n', '\n', '            availableInner = tier.amountInCenter.sub(tier.soldInCenter);\n', '\n', '            priceInCenter = tier.priceInCenter;\n', '\n', '            if (indexInner < 3) {\n', '                nextPriceInCenter = tiers[indexInner + 1].priceInCenter;\n', '            }\n', '        }\n', '\n', '        if (indexOuter != 100000) {\n', '            tier = tiers[indexOuter];\n', '\n', '            availableInOuter = tier.amountInOuter.sub(tier.soldInOuter);\n', '\n', '            priceInOuter = tier.priceInOuter;\n', '\n', '            if (indexOuter < 3) {\n', '                nextPriceInOuter = tiers[indexOuter + 1].priceInOuter;\n', '            }\n', '        }\n', '    }\n', '\n', '    function calculateAmountOfUnits(uint256 sizeA, uint256 sizeB) public pure returns (uint256) {\n', '        return sizeA.mul(sizeB);\n', '    }\n', '\n', '    /// @notice approve the offer\n', '    function approve(uint256 _index, uint256 _tokenId) internal {\n', '        Offer memory localOffer = offers[_index];\n', '\n', '        address newOwner = localOffer.from;\n', '        address prevOwner = token.getOwner(_tokenId);\n', '\n', '        uint256 platformShare;\n', '        uint256 forPrevOwner;\n', '\n', '        uint256 soldPrice = token.getTokenSoldPrice(_tokenId);\n', '\n', '        (platformShare, forPrevOwner) = pricingStrategy.calculateSharesInTheRevenue(\n', '            soldPrice, localOffer.offeredPrice);\n', '\n', "        //update token's state\n", '        token.updateTokensState(_tokenId, localOffer.offeredPrice);\n', '\n', '        // update owner\n', '        token.updateOwner(_tokenId, newOwner, prevOwner);\n', '        localOffer.accepted = true;\n', '\n', '        transferEthers(platformWallet, platformShare);\n', '        transferEthers(prevOwner, forPrevOwner.add(soldPrice));\n', '\n', '        emit OfferApproved(newOwner, _tokenId, localOffer.offerId, localOffer.offeredPrice, now);\n', '        emit Purchased(prevOwner, newOwner, _tokenId, localOffer.offeredPrice, soldPrice, forPrevOwner.add(soldPrice), platformShare, now);\n', '\n', '        afterApproveAction(_tokenId);\n', '    }\n', '\n', '    function transferEthers(address _address, uint256 _wei) internal {\n', '        if (isContract(_address)) {\n', '            pendingReturns[_address] = pendingReturns[_address].add(_wei);\n', '        }\n', '        else {\n', '            _address.transfer(_wei);\n', '        }\n', '    }\n', '\n', '    function preMinting(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal view returns (uint256, uint256) {\n', '        //  calculate units for token\n', '        uint256 total = 0;\n', '        uint256 inner = 0;\n', '        uint256 outer = 0;\n', '\n', '\n', '        (total, inner) = token.calculateCounters(x, y, sizeA, sizeB);\n', '        outer = total.sub(inner);\n', '\n', '        require(total <= 100);\n', '\n', '        return (inner, outer);\n', '    }\n', '\n', '    function updateTierStatus(uint256 inner, uint256 outer) internal {\n', '        uint256 leftInner = inner;\n', '        uint256 leftOuter = outer;\n', '\n', '        for (uint256 i = 0; i < 4; i++) {\n', '            Tier storage tier = tiers[i];\n', '\n', '            if (leftInner > 0 && tier.filledInCenter == false) {\n', '                uint256 availableInner = tier.amountInCenter.sub(tier.soldInCenter);\n', '\n', '                if (availableInner > leftInner) {\n', '                    tier.soldInCenter = tier.soldInCenter.add(leftInner);\n', '\n', '                    leftInner = 0;\n', '                } else {\n', '                    tier.filledInCenter = true;\n', '                    tier.soldInCenter = tier.amountInCenter;\n', '\n', '                    leftInner = leftInner.sub(availableInner);\n', '                }\n', '            }\n', '\n', '            if (leftOuter > 0 && tier.filledInOuter == false) {\n', '                uint256 availableOuter = tier.amountInOuter.sub(tier.soldInOuter);\n', '\n', '                if (availableOuter > leftOuter) {\n', '                    tier.soldInOuter = tier.soldInOuter.add(leftOuter);\n', '\n', '                    leftOuter = 0;\n', '                } else {\n', '                    tier.filledInOuter = true;\n', '                    tier.soldInOuter = tier.amountInOuter;\n', '\n', '                    leftOuter = leftOuter.sub(availableOuter);\n', '                }\n', '            }\n', '        }\n', '\n', '        require(leftInner == 0 && leftOuter == 0);\n', '    }\n', '\n', '    function calculateTokenPrice(uint256 inner, uint256 outer) public view returns (uint256 price) {\n', '        uint256 leftInner = inner;\n', '        uint256 leftOuter = outer;\n', '\n', '        for (uint256 i = 0; i < 4; i++) {\n', '            Tier storage tier = tiers[i];\n', '\n', '            if (leftInner > 0 && tier.filledInCenter == false) {\n', '                uint256 availableInner = tier.amountInCenter.sub(tier.soldInCenter);\n', '\n', '                if (availableInner > leftInner) {\n', '                    price = price.add(leftInner.mul(tier.priceInCenter));\n', '                    leftInner = 0;\n', '                } else {\n', '                    price = price.add(availableInner.mul(tier.priceInCenter));\n', '                    leftInner = leftInner.sub(availableInner);\n', '                }\n', '            }\n', '\n', '            if (leftOuter > 0 && tier.filledInOuter == false) {\n', '                uint256 availableOuter = tier.amountInOuter.sub(tier.soldInOuter);\n', '\n', '                if (availableOuter > leftOuter) {\n', '                    price = price.add(leftOuter.mul(tier.priceInOuter));\n', '                    leftOuter = 0;\n', '                } else {\n', '                    price = price.add(availableOuter.mul(tier.priceInOuter));\n', '                    leftOuter = leftOuter.sub(availableOuter);\n', '                }\n', '            }\n', '        }\n', '\n', '        require(leftInner == 0 && leftOuter == 0);\n', '    }\n', '\n', '    function minPriceForNextRound(uint256 _tokenId) public view returns (uint256) {\n', '        if (_tokenId == logoId && token.getCurrentPriceForToken(_tokenId) == 0) {\n', '            return logoPrice;\n', '        } else {\n', '            // @TODO: check if sold-out\n', '\n', '            uint256 currentPrice = getTokenPrice(_tokenId);\n', '            uint256 minPrice = pricingStrategy.calculateMinPriceForNextRound(currentPrice, minResalePercentage);\n', '            return minPrice;\n', '        }\n', '    }\n', '\n', '    function afterApproveAction(uint256 _tokenId) internal {\n', '\n', '        uint256 indexInner = 100000;\n', '        uint256 indexOuter = 100000;\n', '\n', '        bool hasInner;\n', '        bool hasOuter;\n', '\n', '        (hasInner, hasOuter) = token.getTokenScope(_tokenId);\n', '        (indexInner, indexOuter) = getCurrentTierIndex();\n', '\n', '        if (hasInner && hasOuter && indexInner == 100000 && indexOuter == 100000) {\n', '            token.increasePriceForNeighbours(_tokenId);\n', '        } else if (!hasInner && hasOuter && indexOuter == 100000) {\n', '            token.increasePriceForNeighbours(_tokenId);\n', '        } else if (!hasOuter && hasInner && indexInner == 100000) {\n', '            token.increasePriceForNeighbours(_tokenId);\n', '        }\n', '    }\n', '\n', '    function canBuyExistentToken(uint256 _tokenId) public view returns (uint256 _allowed) {\n', '        uint256 indexInner = 0;\n', '        uint256 indexOuter = 0;\n', '\n', '        bool hasInner;\n', '        bool hasOuter;\n', '\n', '        (hasInner, hasOuter) = token.getTokenScope(_tokenId);\n', '        (indexInner, indexOuter) = getCurrentTierIndex();\n', '\n', '        if (token.getCurrentPriceForToken(_tokenId) == 0 && logoPrice == 0) {\n', '            return 4;\n', '        }\n', '\n', '        if (_tokenId != logoId && hasInner && indexInner != 100000) {\n', '            return 2;\n', '        }\n', '\n', '        if (hasOuter && indexOuter != 100000) {\n', '            return 3;\n', '        }\n', '\n', '        return 1;\n', '    }\n', '}']
