['pragma solidity ^0.4.24;\n', '\n', '//Swap Deployer functions - descriptions can be found in Deployer.sol\n', 'interface Deployer_Interface {\n', '  function newContract(address _party, address user_contract, uint _start_date) external payable returns (address);\n', '}\n', '\n', '//Slightly modified SafeMath library - includes a min function\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function min(uint a, uint b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '//Swap factory functions - descriptions can be found in Factory.sol\n', 'interface Factory_Interface {\n', '  function createToken(uint _supply, address _party, uint _start_date) external returns (address,address, uint);\n', '  function payToken(address _party, address _token_add) external;\n', '  function deployContract(uint _start_date) external payable returns (address);\n', '   function getBase() external view returns(address);\n', '  function getVariables() external view returns (address, uint, uint, address,uint);\n', '  function isWhitelisted(address _member) external view returns (bool);\n', '}\n', '\n', '\n', '/**\n', '*The DRCTLibrary contains the reference code used in the DRCT_Token (an ERC20 compliant token\n', '*representing the payout of the swap contract specified in the Factory contract).\n', '*/\n', 'library DRCTLibrary{\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /*Structs*/\n', '    /**\n', '    *@dev Keeps track of balance amounts in the balances array\n', '    */\n', '    struct Balance {\n', '        address owner;\n', '        uint amount;\n', '        }\n', '\n', '    struct TokenStorage{\n', '        //This is the factory contract that the token is standardized at\n', '        address factory_contract;\n', '        //Total supply of outstanding tokens in the contract\n', '        uint total_supply;\n', '        //Mapping from: swap address -> user balance struct (index for a particular user&#39;s balance can be found in swap_balances_index)\n', '        mapping(address => Balance[]) swap_balances;\n', '        //Mapping from: swap address -> user -> swap_balances index\n', '        mapping(address => mapping(address => uint)) swap_balances_index;\n', '        //Mapping from: user -> dynamic array of swap addresses (index for a particular swap can be found in user_swaps_index)\n', '        mapping(address => address[]) user_swaps;\n', '        //Mapping from: user -> swap address -> user_swaps index\n', '        mapping(address => mapping(address => uint)) user_swaps_index;\n', '        //Mapping from: user -> total balance accross all entered swaps\n', '        mapping(address => uint) user_total_balances;\n', '        //Mapping from: owner -> spender -> amount allowed\n', '        mapping(address => mapping(address => uint)) allowed;\n', '    }   \n', '\n', '    /*Events*/\n', '    /**\n', '    *@dev events for transfer and approvals\n', '    */\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    event CreateToken(address _from, uint _value);\n', '    \n', '    /*Functions*/\n', '    /**\n', '    *@dev Constructor - sets values for token name and token supply, as well as the \n', '    *factory_contract, the swap.\n', '    *@param _factory \n', '    */\n', '    function startToken(TokenStorage storage self,address _factory) public {\n', '        self.factory_contract = _factory;\n', '    }\n', '\n', '    /**\n', '    *@dev ensures the member is whitelisted\n', '    *@param _member is the member address that is chekced agaist the whitelist\n', '    */\n', '    function isWhitelisted(TokenStorage storage self,address _member) internal view returns(bool){\n', '        Factory_Interface _factory = Factory_Interface(self.factory_contract);\n', '        return _factory.isWhitelisted(_member);\n', '    }\n', '\n', '    /**\n', '    *@dev gets the factory address\n', '    */\n', '    function getFactoryAddress(TokenStorage storage self) external view returns(address){\n', '        return self.factory_contract;\n', '    }\n', '\n', '    /**\n', '    *@dev Token Creator - This function is called by the factory contract and creates new tokens\n', '    *for the user\n', '    *@param _supply amount of DRCT tokens created by the factory contract for this swap\n', '    *@param _owner address\n', '    *@param _swap address\n', '    */\n', '    function createToken(TokenStorage storage self,uint _supply, address _owner, address _swap) public{\n', '        require(msg.sender == self.factory_contract);\n', '        //Update total supply of DRCT Tokens\n', '        self.total_supply = self.total_supply.add(_supply);\n', '        //Update the total balance of the owner\n', '        self.user_total_balances[_owner] = self.user_total_balances[_owner].add(_supply);\n', '        //If the user has not entered any swaps already, push a zeroed address to their user_swaps mapping to prevent default value conflicts in user_swaps_index\n', '        if (self.user_swaps[_owner].length == 0)\n', '            self.user_swaps[_owner].push(address(0x0));\n', '        //Add a new swap index for the owner\n', '        self.user_swaps_index[_owner][_swap] = self.user_swaps[_owner].length;\n', '        //Push a new swap address to the owner&#39;s swaps\n', '        self.user_swaps[_owner].push(_swap);\n', '        //Push a zeroed Balance struct to the swap balances mapping to prevent default value conflicts in swap_balances_index\n', '        self.swap_balances[_swap].push(Balance({\n', '            owner: 0,\n', '            amount: 0\n', '        }));\n', '        //Add a new owner balance index for the swap\n', '        self.swap_balances_index[_swap][_owner] = 1;\n', '        //Push the owner&#39;s balance to the swap\n', '        self.swap_balances[_swap].push(Balance({\n', '            owner: _owner,\n', '            amount: _supply\n', '        }));\n', '        emit CreateToken(_owner,_supply);\n', '    }\n', '\n', '    /**\n', '    *@dev Called by the factory contract, and pays out to a _party\n', '    *@param _party being paid\n', '    *@param _swap address\n', '    */\n', '    function pay(TokenStorage storage self,address _party, address _swap) public{\n', '        require(msg.sender == self.factory_contract);\n', '        uint party_balance_index = self.swap_balances_index[_swap][_party];\n', '        require(party_balance_index > 0);\n', '        uint party_swap_balance = self.swap_balances[_swap][party_balance_index].amount;\n', '        //reduces the users totals balance by the amount in that swap\n', '        self.user_total_balances[_party] = self.user_total_balances[_party].sub(party_swap_balance);\n', '        //reduces the total supply by the amount of that users in that swap\n', '        self.total_supply = self.total_supply.sub(party_swap_balance);\n', '        //sets the partys balance to zero for that specific swaps party balances\n', '        self.swap_balances[_swap][party_balance_index].amount = 0;\n', '    }\n', '\n', '    /**\n', '    *@dev Returns the users total balance (sum of tokens in all swaps the user has tokens in)\n', '    *@param _owner user address\n', '    *@return user total balance\n', '    */\n', '    function balanceOf(TokenStorage storage self,address _owner) public constant returns (uint balance) {\n', '       return self.user_total_balances[_owner]; \n', '     }\n', '\n', '    /**\n', '    *@dev Getter for the total_supply of tokens in the contract\n', '    *@return total supply\n', '    */\n', '    function totalSupply(TokenStorage storage self) public constant returns (uint _total_supply) {\n', '       return self.total_supply;\n', '    }\n', '\n', '    /**\n', '    *@dev Removes the address from the swap balances for a swap, and moves the last address in the\n', '    *swap into their place\n', '    *@param _remove address of prevous owner\n', '    *@param _swap address used to get last addrss of the swap to replace the removed address\n', '    */\n', '    function removeFromSwapBalances(TokenStorage storage self,address _remove, address _swap) internal {\n', '        uint last_address_index = self.swap_balances[_swap].length.sub(1);\n', '        address last_address = self.swap_balances[_swap][last_address_index].owner;\n', '        //If the address we want to remove is the final address in the swap\n', '        if (last_address != _remove) {\n', '            uint remove_index = self.swap_balances_index[_swap][_remove];\n', '            //Update the swap&#39;s balance index of the last address to that of the removed address index\n', '            self.swap_balances_index[_swap][last_address] = remove_index;\n', '            //Set the swap&#39;s Balance struct at the removed index to the Balance struct of the last address\n', '            self.swap_balances[_swap][remove_index] = self.swap_balances[_swap][last_address_index];\n', '        }\n', '        //Remove the swap_balances index for this address\n', '        delete self.swap_balances_index[_swap][_remove];\n', '        //Finally, decrement the swap balances length\n', '        self.swap_balances[_swap].length = self.swap_balances[_swap].length.sub(1);\n', '    }\n', '\n', '    /**\n', '    *@dev This is the main function to update the mappings when a transfer happens\n', '    *@param _from address to send funds from\n', '    *@param _to address to send funds to\n', '    *@param _amount amount of token to send\n', '    */\n', '    function transferHelper(TokenStorage storage self,address _from, address _to, uint _amount) internal {\n', '        //Get memory copies of the swap arrays for the sender and reciever\n', '        address[] memory from_swaps = self.user_swaps[_from];\n', '        //Iterate over sender&#39;s swaps in reverse order until enough tokens have been transferred\n', '        for (uint i = from_swaps.length.sub(1); i > 0; i--) {\n', '            //Get the index of the sender&#39;s balance for the current swap\n', '            uint from_swap_user_index = self.swap_balances_index[from_swaps[i]][_from];\n', '            Balance memory from_user_bal = self.swap_balances[from_swaps[i]][from_swap_user_index];\n', '            //If the current swap will be entirely depleted - we remove all references to it for the sender\n', '            if (_amount >= from_user_bal.amount) {\n', '                _amount -= from_user_bal.amount;\n', '                //If this swap is to be removed, we know it is the (current) last swap in the user&#39;s user_swaps list, so we can simply decrement the length to remove it\n', '                self.user_swaps[_from].length = self.user_swaps[_from].length.sub(1);\n', '                //Remove the user swap index for this swap\n', '                delete self.user_swaps_index[_from][from_swaps[i]];\n', '                //If the _to address already holds tokens from this swap\n', '                if (self.user_swaps_index[_to][from_swaps[i]] != 0) {\n', '                    //Get the index of the _to balance in this swap\n', '                    uint to_balance_index = self.swap_balances_index[from_swaps[i]][_to];\n', '                    assert(to_balance_index != 0);\n', '                    //Add the _from tokens to _to\n', '                    self.swap_balances[from_swaps[i]][to_balance_index].amount = self.swap_balances[from_swaps[i]][to_balance_index].amount.add(from_user_bal.amount);\n', '                    //Remove the _from address from this swap&#39;s balance array\n', '                    removeFromSwapBalances(self,_from, from_swaps[i]);\n', '                } else {\n', '                    //Prepare to add a new swap by assigning the swap an index for _to\n', '                    if (self.user_swaps[_to].length == 0){\n', '                        self.user_swaps[_to].push(address(0x0));\n', '                    }\n', '                self.user_swaps_index[_to][from_swaps[i]] = self.user_swaps[_to].length;\n', '                //Add the new swap to _to\n', '                self.user_swaps[_to].push(from_swaps[i]);\n', '                //Give the reciever the sender&#39;s balance for this swap\n', '                self.swap_balances[from_swaps[i]][from_swap_user_index].owner = _to;\n', '                //Give the reciever the sender&#39;s swap balance index for this swap\n', '                self.swap_balances_index[from_swaps[i]][_to] = self.swap_balances_index[from_swaps[i]][_from];\n', '                //Remove the swap balance index from the sending party\n', '                delete self.swap_balances_index[from_swaps[i]][_from];\n', '            }\n', '            //If there is no more remaining to be removed, we break out of the loop\n', '            if (_amount == 0)\n', '                break;\n', '            } else {\n', '                //The amount in this swap is more than the amount we still need to transfer\n', '                uint to_swap_balance_index = self.swap_balances_index[from_swaps[i]][_to];\n', '                //If the _to address already holds tokens from this swap\n', '                if (self.user_swaps_index[_to][from_swaps[i]] != 0) {\n', '                    //Because both addresses are in this swap, and neither will be removed, we simply update both swap balances\n', '                    self.swap_balances[from_swaps[i]][to_swap_balance_index].amount = self.swap_balances[from_swaps[i]][to_swap_balance_index].amount.add(_amount);\n', '                } else {\n', '                    //Prepare to add a new swap by assigning the swap an index for _to\n', '                    if (self.user_swaps[_to].length == 0){\n', '                        self.user_swaps[_to].push(address(0x0));\n', '                    }\n', '                    self.user_swaps_index[_to][from_swaps[i]] = self.user_swaps[_to].length;\n', '                    //And push the new swap\n', '                    self.user_swaps[_to].push(from_swaps[i]);\n', '                    //_to is not in this swap, so we give this swap a new balance index for _to\n', '                    self.swap_balances_index[from_swaps[i]][_to] = self.swap_balances[from_swaps[i]].length;\n', '                    //And push a new balance for _to\n', '                    self.swap_balances[from_swaps[i]].push(Balance({\n', '                        owner: _to,\n', '                        amount: _amount\n', '                    }));\n', '                }\n', '                //Finally, update the _from user&#39;s swap balance\n', '                self.swap_balances[from_swaps[i]][from_swap_user_index].amount = self.swap_balances[from_swaps[i]][from_swap_user_index].amount.sub(_amount);\n', '                //Because we have transferred the last of the amount to the reciever, we break;\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    *@dev ERC20 compliant transfer function\n', '    *@param _to Address to send funds to\n', '    *@param _amount Amount of token to send\n', '    *@return true for successful\n', '    */\n', '    function transfer(TokenStorage storage self, address _to, uint _amount) public returns (bool) {\n', '        require(isWhitelisted(self,_to));\n', '        uint balance_owner = self.user_total_balances[msg.sender];\n', '        if (\n', '            _to == msg.sender ||\n', '            _to == address(0) ||\n', '            _amount == 0 ||\n', '            balance_owner < _amount\n', '        ) return false;\n', '        transferHelper(self,msg.sender, _to, _amount);\n', '        self.user_total_balances[msg.sender] = self.user_total_balances[msg.sender].sub(_amount);\n', '        self.user_total_balances[_to] = self.user_total_balances[_to].add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '    /**\n', '    *@dev ERC20 compliant transferFrom function\n', '    *@param _from address to send funds from (must be allowed, see approve function)\n', '    *@param _to address to send funds to\n', '    *@param _amount amount of token to send\n', '    *@return true for successful\n', '    */\n', '    function transferFrom(TokenStorage storage self, address _from, address _to, uint _amount) public returns (bool) {\n', '        require(isWhitelisted(self,_to));\n', '        uint balance_owner = self.user_total_balances[_from];\n', '        uint sender_allowed = self.allowed[_from][msg.sender];\n', '        if (\n', '            _to == _from ||\n', '            _to == address(0) ||\n', '            _amount == 0 ||\n', '            balance_owner < _amount ||\n', '            sender_allowed < _amount\n', '        ) return false;\n', '        transferHelper(self,_from, _to, _amount);\n', '        self.user_total_balances[_from] = self.user_total_balances[_from].sub(_amount);\n', '        self.user_total_balances[_to] = self.user_total_balances[_to].add(_amount);\n', '        self.allowed[_from][msg.sender] = self.allowed[_from][msg.sender].sub(_amount);\n', '        emit Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    *@dev ERC20 compliant approve function\n', '    *@param _spender party that msg.sender approves for transferring funds\n', '    *@param _amount amount of token to approve for sending\n', '    *@return true for successful\n', '    */\n', '    function approve(TokenStorage storage self, address _spender, uint _amount) public returns (bool) {\n', '        self.allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    *@dev Counts addresses involved in the swap based on the length of balances array for _swap\n', '    *@param _swap address\n', '    *@return the length of the balances array for the swap\n', '    */\n', '    function addressCount(TokenStorage storage self, address _swap) public constant returns (uint) { \n', '        return self.swap_balances[_swap].length; \n', '    }\n', '\n', '    /**\n', '    *@dev Gets the owner address and amount by specifying the swap address and index\n', '    *@param _ind specified index in the swap\n', '    *@param _swap specified swap address\n', '    *@return the owner address associated with a particular index in a particular swap\n', '    *@return the amount to transfer associated with a particular index in a particular swap\n', '    */\n', '    function getBalanceAndHolderByIndex(TokenStorage storage self, uint _ind, address _swap) public constant returns (uint, address) {\n', '        return (self.swap_balances[_swap][_ind].amount, self.swap_balances[_swap][_ind].owner);\n', '    }\n', '\n', '    /**\n', '    *@dev Gets the index by specifying the swap and owner addresses\n', '    *@param _owner specifed address\n', '    *@param _swap  specified swap address\n', '    *@return the index associated with the _owner address in a particular swap\n', '    */\n', '    function getIndexByAddress(TokenStorage storage self, address _owner, address _swap) public constant returns (uint) {\n', '        return self.swap_balances_index[_swap][_owner]; \n', '    }\n', '\n', '    /**\n', '    *@dev Look up how much the spender or contract is allowed to spend?\n', '    *@param _owner \n', '    *@param _spender party approved for transfering funds \n', '    *@return the allowed amount _spender can spend of _owner&#39;s balance\n', '    */\n', '    function allowance(TokenStorage storage self, address _owner, address _spender) public constant returns (uint) {\n', '        return self.allowed[_owner][_spender]; \n', '    }\n', '}\n', '\n', '/**\n', '*The DRCT_Token is an ERC20 compliant token representing the payout of the swap contract\n', '*specified in the Factory contract.\n', '*Each Factory contract is specified one DRCT Token and the token address can contain many\n', '*different swap contracts that are standardized at the Factory level.\n', '*The logic for the functions in this contract is housed in the DRCTLibary.sol.\n', '*/\n', 'contract DRCT_Token {\n', '\n', '    using DRCTLibrary for DRCTLibrary.TokenStorage;\n', '\n', '    /*Variables*/\n', '    DRCTLibrary.TokenStorage public drct;\n', '\n', '    /*Functions*/\n', '    /**\n', '    *@dev Constructor - sets values for token name and token supply, as well as the \n', '    *factory_contract, the swap.\n', '    *@param _factory \n', '    */\n', '    constructor() public {\n', '        drct.startToken(msg.sender);\n', '    }\n', '\n', '    /**\n', '    *@dev Token Creator - This function is called by the factory contract and creates new tokens\n', '    *for the user\n', '    *@param _supply amount of DRCT tokens created by the factory contract for this swap\n', '    *@param _owner address\n', '    *@param _swap address\n', '    */\n', '    function createToken(uint _supply, address _owner, address _swap) public{\n', '        drct.createToken(_supply,_owner,_swap);\n', '    }\n', '\n', '    /**\n', '    *@dev gets the factory address\n', '    */\n', '    function getFactoryAddress() external view returns(address){\n', '        return drct.getFactoryAddress();\n', '    }\n', '\n', '    /**\n', '    *@dev Called by the factory contract, and pays out to a _party\n', '    *@param _party being paid\n', '    *@param _swap address\n', '    */\n', '    function pay(address _party, address _swap) public{\n', '        drct.pay(_party,_swap);\n', '    }\n', '\n', '    /**\n', '    *@dev Returns the users total balance (sum of tokens in all swaps the user has tokens in)\n', '    *@param _owner user address\n', '    *@return user total balance\n', '    */\n', '    function balanceOf(address _owner) public constant returns (uint balance) {\n', '       return drct.balanceOf(_owner);\n', '     }\n', '\n', '    /**\n', '    *@dev Getter for the total_supply of tokens in the contract\n', '    *@return total supply\n', '    */\n', '    function totalSupply() public constant returns (uint _total_supply) {\n', '       return drct.totalSupply();\n', '    }\n', '\n', '    /**\n', '    *ERC20 compliant transfer function\n', '    *@param _to Address to send funds to\n', '    *@param _amount Amount of token to send\n', '    *@return true for successful\n', '    */\n', '    function transfer(address _to, uint _amount) public returns (bool) {\n', '        return drct.transfer(_to,_amount);\n', '    }\n', '\n', '    /**\n', '    *@dev ERC20 compliant transferFrom function\n', '    *@param _from address to send funds from (must be allowed, see approve function)\n', '    *@param _to address to send funds to\n', '    *@param _amount amount of token to send\n', '    *@return true for successful transfer\n', '    */\n', '    function transferFrom(address _from, address _to, uint _amount) public returns (bool) {\n', '        return drct.transferFrom(_from,_to,_amount);\n', '    }\n', '\n', '    /**\n', '    *@dev ERC20 compliant approve function\n', '    *@param _spender party that msg.sender approves for transferring funds\n', '    *@param _amount amount of token to approve for sending\n', '    *@return true for successful\n', '    */\n', '    function approve(address _spender, uint _amount) public returns (bool) {\n', '        return drct.approve(_spender,_amount);\n', '    }\n', '\n', '    /**\n', '    *@dev Counts addresses involved in the swap based on the length of balances array for _swap\n', '    *@param _swap address\n', '    *@return the length of the balances array for the swap\n', '    */\n', '    function addressCount(address _swap) public constant returns (uint) { \n', '        return drct.addressCount(_swap); \n', '    }\n', '\n', '    /**\n', '    *@dev Gets the owner address and amount by specifying the swap address and index\n', '    *@param _ind specified index in the swap\n', '    *@param _swap specified swap address\n', '    *@return the amount to transfer associated with a particular index in a particular swap\n', '    *@return the owner address associated with a particular index in a particular swap\n', '    */\n', '    function getBalanceAndHolderByIndex(uint _ind, address _swap) public constant returns (uint, address) {\n', '        return drct.getBalanceAndHolderByIndex(_ind,_swap);\n', '    }\n', '\n', '    /**\n', '    *@dev Gets the index by specifying the swap and owner addresses\n', '    *@param _owner specifed address\n', '    *@param _swap  specified swap address\n', '    *@return the index associated with the _owner address in a particular swap\n', '    */\n', '    function getIndexByAddress(address _owner, address _swap) public constant returns (uint) {\n', '        return drct.getIndexByAddress(_owner,_swap); \n', '    }\n', '\n', '    /**\n', '    *@dev Look up how much the spender or contract is allowed to spend?\n', '    *@param _owner address\n', '    *@param _spender party approved for transfering funds \n', '    *@return the allowed amount _spender can spend of _owner&#39;s balance\n', '    */\n', '    function allowance(address _owner, address _spender) public constant returns (uint) {\n', '        return drct.allowance(_owner,_spender); \n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '//ERC20 function interface with create token and withdraw\n', 'interface Wrapped_Ether_Interface {\n', '  function totalSupply() external constant returns (uint);\n', '  function balanceOf(address _owner) external constant returns (uint);\n', '  function transfer(address _to, uint _amount) external returns (bool);\n', '  function transferFrom(address _from, address _to, uint _amount) external returns (bool);\n', '  function approve(address _spender, uint _amount) external returns (bool);\n', '  function allowance(address _owner, address _spender) external constant returns (uint);\n', '  function withdraw(uint _value) external;\n', '  function createToken() external;\n', '\n', '}\n', '\n', 'interface Membership_Interface {\n', '    function getMembershipType(address _member) external constant returns(uint);\n', '}\n', '\n', '\n', '\n', '/**\n', '*The Factory contract sets the standardized variables and also deploys new contracts based on\n', '*these variables for the user.  \n', '*/\n', 'contract Factory {\n', '    using SafeMath for uint256;\n', '    \n', '    /*Variables*/\n', '    //Addresses of the Factory owner and oracle. For oracle information, \n', '    //check www.github.com/DecentralizedDerivatives/Oracles\n', '    address public owner;\n', '    address public oracle_address;\n', '    //Address of the user contract\n', '    address public user_contract;\n', '    //Address of the deployer contract\n', '    address internal deployer_address;\n', '    Deployer_Interface internal deployer;\n', '    address public token;\n', '    //A fee for creating a swap in wei.  Plan is for this to be zero, however can be raised to prevent spam\n', '    uint public fee;\n', '    //swap fee\n', '    uint public swapFee;\n', '    //Duration of swap contract in days\n', '    uint public duration;\n', '    //Multiplier of reference rate.  2x refers to a 50% move generating a 100% move in the contract payout values\n', '    uint public multiplier;\n', '    //Token_ratio refers to the number of DRCT Tokens a party will get based on the number of base tokens.  As an example, 1e15 indicates that a party will get 1000 DRCT Tokens based upon 1 ether of wrapped wei. \n', '    uint public token_ratio;\n', '    //Array of deployed contracts\n', '    address[] public contracts;\n', '    uint[] public startDates;\n', '    address public memberContract;\n', '    mapping(uint => bool) whitelistedTypes;\n', '    mapping(address => uint) public created_contracts;\n', '    mapping(address => uint) public token_dates;\n', '    mapping(uint => address) public long_tokens;\n', '    mapping(uint => address) public short_tokens;\n', '    mapping(address => uint) public token_type; //1=short 2=long\n', '\n', '    /*Events*/\n', '    //Emitted when a Swap is created\n', '    event ContractCreation(address _sender, address _created);\n', '\n', '    /*Modifiers*/\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /*Functions*/\n', '    /**\n', '    *@dev Constructor - Sets owner\n', '    */\n', '     constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    *@dev constructor function for cloned factory\n', '    */\n', '    function init(address _owner) public{\n', '        require(owner == address(0));\n', '        owner = _owner;\n', '    }\n', '\n', '    /**\n', '    *@dev Sets the Membership contract address\n', '    *@param _memberContract The new membership address\n', '    */\n', '    function setMemberContract(address _memberContract) public onlyOwner() {\n', '        memberContract = _memberContract;\n', '    }\n', '\n', '    /**\n', '    *@dev Sets the member types/permissions for those whitelisted\n', '    *@param _memberTypes is the list of member types\n', '    */\n', '    function setWhitelistedMemberTypes(uint[] _memberTypes) public onlyOwner(){\n', '        whitelistedTypes[0] = false;\n', '        for(uint i = 0; i<_memberTypes.length;i++){\n', '            whitelistedTypes[_memberTypes[i]] = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '    *@dev Checks the membership type/permissions for whitelisted members\n', '    *@param _member address to get membership type from\n', '    */\n', '    function isWhitelisted(address _member) public view returns (bool){\n', '        Membership_Interface Member = Membership_Interface(memberContract);\n', '        return whitelistedTypes[Member.getMembershipType(_member)];\n', '    }\n', ' \n', '    /**\n', '    *@dev Gets long and short token addresses based on specified date\n', '    *@param _date \n', '    *@return short and long tokens&#39; addresses\n', '    */\n', '    function getTokens(uint _date) public view returns(address, address){\n', '        return(long_tokens[_date],short_tokens[_date]);\n', '    }\n', '\n', '    /**\n', '    *@dev Gets the type of Token (long and short token) for the specifed \n', '    *token address\n', '    *@param _token address \n', '    *@return token type short = 1 and long = 2\n', '    */\n', '    function getTokenType(address _token) public view returns(uint){\n', '        return(token_type[_token]);\n', '    }\n', '\n', '    /**\n', '    *@dev Updates the fee amount\n', '    *@param _fee is the new fee amount\n', '    */\n', '    function setFee(uint _fee) public onlyOwner() {\n', '        fee = _fee;\n', '    }\n', '\n', '    /**\n', '    *@dev Updates the swap fee amount\n', '    *@param _swapFee is the new swap fee amount\n', '    */\n', '    function setSwapFee(uint _swapFee) public onlyOwner() {\n', '        swapFee = _swapFee;\n', '    }   \n', '\n', '    /**\n', '    *@dev Sets the deployer address\n', '    *@param _deployer is the new deployer address\n', '    */\n', '    function setDeployer(address _deployer) public onlyOwner() {\n', '        deployer_address = _deployer;\n', '        deployer = Deployer_Interface(_deployer);\n', '    }\n', '\n', '    /**\n', '    *@dev Sets the user_contract address\n', '    *@param _userContract is the new userContract address\n', '    */\n', '    function setUserContract(address _userContract) public onlyOwner() {\n', '        user_contract = _userContract;\n', '    }\n', '\n', '    /**\n', '    *@dev Sets token ratio, swap duration, and multiplier variables for a swap.\n', '    *@param _token_ratio the ratio of the tokens\n', '    *@param _duration the duration of the swap, in days\n', '    *@param _multiplier the multiplier used for the swap\n', '    *@param _swapFee the swap fee\n', '    */\n', '    function setVariables(uint _token_ratio, uint _duration, uint _multiplier, uint _swapFee) public onlyOwner() {\n', '        require(_swapFee < 10000);\n', '        token_ratio = _token_ratio;\n', '        duration = _duration;\n', '        multiplier = _multiplier;\n', '        swapFee = _swapFee;\n', '    }\n', '\n', '    /**\n', '    *@dev Sets the address of the base tokens used for the swap\n', '    *@param _token The address of a token to be used  as collateral\n', '    */\n', '    function setBaseToken(address _token) public onlyOwner() {\n', '        token = _token;\n', '    }\n', '\n', '    /**\n', '    *@dev Allows a user to deploy a new swap contract, if they pay the fee\n', '    *@param _start_date the contract start date \n', '    *@return new_contract address for he newly created swap address and calls \n', '    *event &#39;ContractCreation&#39;\n', '    */\n', '    function deployContract(uint _start_date) public payable returns (address) {\n', '        require(msg.value >= fee && isWhitelisted(msg.sender));\n', '        require(_start_date % 86400 == 0);\n', '        address new_contract = deployer.newContract(msg.sender, user_contract, _start_date);\n', '        contracts.push(new_contract);\n', '        created_contracts[new_contract] = _start_date;\n', '        emit ContractCreation(msg.sender,new_contract);\n', '        return new_contract;\n', '    }\n', '\n', '    /**\n', '    *@dev Deploys DRCT tokens for given start date\n', '    *@param _start_date of contract\n', '    */\n', '    function deployTokenContract(uint _start_date) public{\n', '        address _token;\n', '        require(_start_date % 86400 == 0);\n', '        require(long_tokens[_start_date] == address(0) && short_tokens[_start_date] == address(0));\n', '        _token = new DRCT_Token();\n', '        token_dates[_token] = _start_date;\n', '        long_tokens[_start_date] = _token;\n', '        token_type[_token]=2;\n', '        _token = new DRCT_Token();\n', '        token_type[_token]=1;\n', '        short_tokens[_start_date] = _token;\n', '        token_dates[_token] = _start_date;\n', '        startDates.push(_start_date);\n', '\n', '    }\n', '\n', '    /**\n', '    *@dev Deploys new tokens on a DRCT_Token contract -- called from within a swap\n', '    *@param _supply The number of tokens to create\n', '    *@param _party the address to send the tokens to\n', '    *@param _start_date the start date of the contract      \n', '    *@returns ltoken the address of the created DRCT long tokens\n', '    *@returns stoken the address of the created DRCT short tokens\n', '    *@returns token_ratio The ratio of the created DRCT token\n', '    */\n', '    function createToken(uint _supply, address _party, uint _start_date) public returns (address, address, uint) {\n', '        require(created_contracts[msg.sender] == _start_date);\n', '        address ltoken = long_tokens[_start_date];\n', '        address stoken = short_tokens[_start_date];\n', '        require(ltoken != address(0) && stoken != address(0));\n', '            DRCT_Token drct_interface = DRCT_Token(ltoken);\n', '            drct_interface.createToken(_supply.div(token_ratio), _party,msg.sender);\n', '            drct_interface = DRCT_Token(stoken);\n', '            drct_interface.createToken(_supply.div(token_ratio), _party,msg.sender);\n', '        return (ltoken, stoken, token_ratio);\n', '    }\n', '  \n', '    /**\n', '    *@dev Allows the owner to set a new oracle address\n', '    *@param _new_oracle_address \n', '    */\n', '    function setOracleAddress(address _new_oracle_address) public onlyOwner() {\n', '        oracle_address = _new_oracle_address; \n', '    }\n', '\n', '    /**\n', '    *@dev Allows the owner to set a new owner address\n', '    *@param _new_owner the new owner address\n', '    */\n', '    function setOwner(address _new_owner) public onlyOwner() { \n', '        owner = _new_owner; \n', '    }\n', '\n', '    /**\n', '    *@dev Allows the owner to pull contract creation fees\n', '    *@return the withdrawal fee _val and the balance where is the return function?\n', '    */\n', '    function withdrawFees() public onlyOwner(){\n', '        Wrapped_Ether_Interface token_interface = Wrapped_Ether_Interface(token);\n', '        uint _val = token_interface.balanceOf(address(this));\n', '        if(_val > 0){\n', '            token_interface.withdraw(_val);\n', '        }\n', '        owner.transfer(address(this).balance);\n', '     }\n', '\n', '    /**\n', '    *@dev fallback function\n', '    */ \n', '    function() public payable {\n', '    }\n', '\n', '    /**\n', '    *@dev Returns a tuple of many private variables.\n', '    *The variables from this function are pass through to the TokenLibrary.getVariables function\n', '    *@returns oracle_adress is the address of the oracle\n', '    *@returns duration is the duration of the swap\n', '    *@returns multiplier is the multiplier for the swap\n', '    *@returns token is the address of token\n', '    *@returns _swapFee is the swap fee \n', '    */\n', '    function getVariables() public view returns (address, uint, uint, address,uint){\n', '        return (oracle_address,duration, multiplier, token,swapFee);\n', '    }\n', '\n', '    /**\n', '    *@dev Pays out to a DRCT token\n', '    *@param _party is the address being paid\n', '    *@param _token_add token to pay out\n', '    */\n', '    function payToken(address _party, address _token_add) public {\n', '        require(created_contracts[msg.sender] > 0);\n', '        DRCT_Token drct_interface = DRCT_Token(_token_add);\n', '        drct_interface.pay(_party, msg.sender);\n', '    }\n', '\n', '    /**\n', '    *@dev Counts number of contacts created by this factory\n', '    *@return the number of contracts\n', '    */\n', '    function getCount() public constant returns(uint) {\n', '        return contracts.length;\n', '    }\n', '\n', '    /**\n', '    *@dev Counts number of start dates in this factory\n', '    *@return the number of active start dates\n', '    */\n', '    function getDateCount() public constant returns(uint) {\n', '        return startDates.length;\n', '    }\n', '}']