['pragma solidity ^0.4.23;\n', '\n', 'contract Htlc {\n', '\n', '    // ENUMS\n', '\n', '    enum State { Created, Refunded, Redeemed }\n', '\n', '    // TYPES\n', '\n', '    struct Channel { // Locks ETH in a channel by secret (redeemChannel) or time (refundChannels).\n', '        address initiator; // Initiated this channel.\n', '        address beneficiary; // Beneficiary of this channel.\n', '        uint amount; // If zero then channel not active anymore.\n', '        uint commission; // Commission amount to be paid to multisig authority.\n', '        uint createdAt; // Channel creation timestamp in seconds.\n', '        uint expiresAt; // Channel expiration timestamp in seconds.\n', '        bytes32 hashedSecret; // sha256(secret), hashed secret of channel initiator.\n', '        State state; // The state in which this channel is in.\n', '    }\n', '\n', '    // FIELDS\n', '\n', '    uint constant MAX_BATCH_ITERATIONS = 20; // Assuming 8mn gaslimit and >0.4mn gas usage for most expensive batch function\n', '    mapping (bytes32 => Channel) public channels; // Mapping of channel hashes to channel structs.\n', '    mapping (bytes32 => bool) public isAntecedentHashedSecret; // Mapping of secrets to whether they have been used already or not.\n', '    address public EXCHANGE_OPERATOR; // Can change the COMMISSION_RECIPIENT address.\n', '    bool public IS_EXCHANGE_OPERATIONAL; // Can change the COMMISSION_RECIPIENT address.\n', '    address public COMMISSION_RECIPIENT; // Recipient of exchange commissions.\n', '\n', '    // EVENTS\n', '\n', '    event ChannelCreated(bytes32 channelId);\n', '    event ChannelRedeemed(bytes32 channelId);\n', '    event ChannelRefunded(bytes32 channelId);\n', '\n', '    // MODIFIER\n', '\n', '    modifier only_exchange_operator {\n', '        require(msg.sender == EXCHANGE_OPERATOR, "PERMISSION_DENIED");\n', '        _;\n', '    }\n', '\n', '    // METHODS\n', '\n', '    // PRIVATE METHODS\n', '\n', '    /**\n', '    @notice Sets up a Channel to initiate or participate in.\n', '    @dev Whether right amount has been sent is handled at higher level functions.\n', '    */\n', '    function _setupChannel(address beneficiary, uint amount, uint commission, uint expiresAt, bytes32 hashedSecret)\n', '        private\n', '        returns (bytes32 channelId)\n', '    {\n', '        require(IS_EXCHANGE_OPERATIONAL, "EXCHANGE_NOT_OPERATIONAL");\n', '        require(now <= expiresAt, "TIMELOCK_TOO_EARLY");\n', '        require(amount > 0, "AMOUNT_IS_ZERO");\n', '        require(!isAntecedentHashedSecret[hashedSecret], "SECRET_CAN_BE_DISCOVERED");\n', '        isAntecedentHashedSecret[hashedSecret] = true;\n', '        // Create channel identifier\n', '        channelId = createChannelId(\n', '            msg.sender,\n', '            beneficiary,\n', '            amount,\n', '            commission,\n', '            now,\n', '            expiresAt,\n', '            hashedSecret\n', '        );\n', '        // Create channel\n', '        Channel storage channel = channels[channelId];\n', '        channel.initiator = msg.sender;\n', '        channel.beneficiary = beneficiary;\n', '        channel.amount = amount;\n', '        channel.commission = commission;\n', '        channel.createdAt = now;\n', '        channel.expiresAt = expiresAt;\n', '        channel.hashedSecret = hashedSecret;\n', '        channel.state = State.Created;\n', '        // Transfer commission to commission recipient\n', '        COMMISSION_RECIPIENT.transfer(commission);\n', '        emit ChannelCreated(channelId);\n', '    }\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /**\n', '    @notice Constructor function.\n', '    */\n', '    function Htlc(\n', '        address ofExchangeOperator,\n', '        address ofCommissionRecipient\n', '    )\n', '        public\n', '    {\n', '        EXCHANGE_OPERATOR = ofExchangeOperator;\n', '        IS_EXCHANGE_OPERATIONAL = true;\n', '        COMMISSION_RECIPIENT = ofCommissionRecipient;\n', '    }\n', '\n', '    /**\n', '    @notice Changes the exchange operator.\n', '    */\n', '    function changeExchangeOperator(address newExchangeOperator)\n', '        public\n', '        only_exchange_operator\n', '    {\n', '        EXCHANGE_OPERATOR = newExchangeOperator;\n', '    }\n', '\n', '    /**\n', '    @notice Changes the operational status of the exchange.\n', '    */\n', '    function changeExchangeStatus(bool newExchangeState)\n', '        public\n', '        only_exchange_operator\n', '    {\n', '        IS_EXCHANGE_OPERATIONAL = newExchangeState;\n', '    }\n', '\n', '    /**\n', '    @notice Changes the recipient of the commission.\n', '    */\n', '    function changeCommissionRecipient(address newCommissionRecipient)\n', '        public\n', '        only_exchange_operator\n', '    {\n', '        COMMISSION_RECIPIENT = newCommissionRecipient;\n', '    }\n', '\n', '    /**\n', '    @notice Hashes the channel specific values to create a unique identifier.\n', '    @dev Helper function to create channelIds\n', '    */\n', '    function createChannelId(\n', '        address initiator,\n', '        address beneficiary,\n', '        uint amount,\n', '        uint commission,\n', '        uint createdAt,\n', '        uint expiresAt,\n', '        bytes32 hashedSecret\n', '    )\n', '        public\n', '        pure\n', '        returns (bytes32 channelId)\n', '    {\n', '        channelId = keccak256(abi.encodePacked(\n', '            initiator,\n', '            beneficiary,\n', '            amount,\n', '            commission,\n', '            createdAt,\n', '            expiresAt,\n', '            hashedSecret\n', '        ));\n', '    }\n', '\n', '    /**\n', '    @notice Creates a Channel to initiate or participate in.\n', '    @dev If too little commission sent, channel wont be displayed in exchange frontend.\n', '    @dev Does check if right amount (msg.value) has been sent.\n', '    @param beneficiary Beneficiary of this channels amount.\n', '    @param amount Amount to be stored in this channel.\n', '    @param commission Commission amount to be paid to commission recipient.\n', '    @param expiresAt Channel expiration timestamp in seconds.\n', '    @param hashedSecret sha256(secret), hashed secret of channel initiator\n', '    @return channelId Unique channel identifier\n', '    */\n', '    function createChannel(\n', '        address beneficiary,\n', '        uint amount,\n', '        uint commission,\n', '        uint expiresAt,\n', '        bytes32 hashedSecret\n', '    )\n', '        public\n', '        payable\n', '        returns (bytes32 channelId)\n', '    {\n', '        // Require accurate msg.value sent\n', '        require(amount + commission >= amount, "UINT256_OVERFLOW");\n', '        require(msg.value == amount + commission, "INACCURATE_MSG_VALUE_SENT");\n', '        // Setup channel\n', '        _setupChannel(\n', '            beneficiary,\n', '            amount,\n', '            commission,\n', '            expiresAt,\n', '            hashedSecret\n', '        );\n', '    }\n', '\n', '    /**\n', '    @notice Creates a batch of channels\n', '    */\n', '    function batchCreateChannel(\n', '        address[] beneficiaries,\n', '        uint[] amounts,\n', '        uint[] commissions,\n', '        uint[] expiresAts,\n', '        bytes32[] hashedSecrets\n', '    )\n', '        public\n', '        payable\n', '        returns (bytes32[] channelId)\n', '    {\n', '        require(beneficiaries.length <= MAX_BATCH_ITERATIONS, "TOO_MANY_CHANNELS");\n', '        // Require accurate msg.value sent\n', '        uint valueToBeSent;\n', '        for (uint i = 0; i < beneficiaries.length; ++i) {\n', '            require(amounts[i] + commissions[i] >= amounts[i], "UINT256_OVERFLOW");\n', '            require(valueToBeSent + amounts[i] + commissions[i] >= valueToBeSent, "UINT256_OVERFLOW");\n', '            valueToBeSent += amounts[i] + commissions[i];\n', '        }\n', '        require(msg.value == valueToBeSent, "INACCURATE_MSG_VALUE_SENT");\n', '        // Setup channel\n', '        for (i = 0; i < beneficiaries.length; ++i)\n', '            _setupChannel(\n', '                beneficiaries[i],\n', '                amounts[i],\n', '                commissions[i],\n', '                expiresAts[i],\n', '                hashedSecrets[i]\n', '            );\n', '    }\n', '\n', '    /**\n', '    @notice Redeem ETH to channel beneficiary and and set channel state as redeemed.\n', '    */\n', '    function redeemChannel(bytes32 channelId, bytes32 secret)\n', '        public\n', '    {\n', '        // Require secret to open channels hashlock\n', '        require(sha256(abi.encodePacked(secret)) == channels[channelId].hashedSecret, "WRONG_SECRET");\n', '        require(channels[channelId].state == State.Created, "WRONG_STATE");\n', '        uint amount = channels[channelId].amount;\n', '        address beneficiary = channels[channelId].beneficiary;\n', '        channels[channelId].state = State.Redeemed;\n', '        // Execute channel\n', '        beneficiary.transfer(amount);\n', '        emit ChannelRedeemed(channelId);\n', '    }\n', '\n', '    /**\n', '    @notice Redeems a batch of channels.\n', '    */\n', '    function batchRedeemChannel(bytes32[] channelIds, bytes32[] secrets)\n', '        public\n', '    {\n', '        require(channelIds.length <= MAX_BATCH_ITERATIONS, "TOO_MANY_CHANNELS");\n', '        for (uint i = 0; i < channelIds.length; ++i)\n', '            redeemChannel(channelIds[i], secrets[i]);\n', '    }\n', '\n', '    /**\n', '    @notice Refund ETH to the channel initiator and set channel state as refuned.\n', '    */\n', '    function refundChannel(bytes32 channelId)\n', '        public\n', '    {\n', '        // Require enough time has passed to open channels timelock.\n', '        require(now >= channels[channelId].expiresAt, "TOO_EARLY");\n', '        require(channels[channelId].state == State.Created, "WRONG_STATE");\n', '        uint amount = channels[channelId].amount;\n', '        address initiator = channels[channelId].initiator;\n', '        channels[channelId].state = State.Refunded;\n', '        // Refund channel\n', '        initiator.transfer(amount);\n', '        emit ChannelRefunded(channelId);\n', '    }\n', '\n', '    /**\n', '    @notice Refunds a batch of channels.\n', '    */\n', '    function batchRefundChannel(bytes32[] channelIds)\n', '        public\n', '    {\n', '        require(channelIds.length <= MAX_BATCH_ITERATIONS, "TOO_MANY_CHANNELS");\n', '        for (uint i = 0; i < channelIds.length; ++i)\n', '            refundChannel(channelIds[i]);\n', '    }\n', '}']