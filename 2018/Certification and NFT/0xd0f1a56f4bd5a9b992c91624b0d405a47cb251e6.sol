['pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface \n', ' * \n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title OwnableWithAdmin \n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract OwnableWithAdmin {\n', '  address public owner;\n', '  address public adminOwner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    adminOwner = msg.sender;\n', '  }\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the admin.\n', '   */\n', '  modifier onlyAdmin() {\n', '    require(msg.sender == adminOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner or admin.\n', '   */\n', '  modifier onlyOwnerOrAdmin() {\n', '    require(msg.sender == adminOwner || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current adminOwner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferAdminOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(adminOwner, newOwner);\n', '    adminOwner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function uint2str(uint i) internal pure returns (string){\n', '      if (i == 0) return "0";\n', '      uint j = i;\n', '      uint length;\n', '      while (j != 0){\n', '          length++;\n', '          j /= 10;\n', '      }\n', '      bytes memory bstr = new bytes(length);\n', '      uint k = length - 1;\n', '      while (i != 0){\n', '          bstr[k--] = byte(48 + i % 10);\n', '          i /= 10;\n', '      }\n', '      return string(bstr);\n', '  }\n', ' \n', '  \n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title AirDrop\n', ' * @notice Contract is not payable.\n', ' * Owner or admin can allocate tokens.\n', ' * Tokens will be released direct. \n', ' *\n', ' *\n', ' */\n', 'contract AirDrop is OwnableWithAdmin {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 private constant DECIMALFACTOR = 10**uint256(18);\n', '\n', '\n', '  event FundsBooked(address backer, uint256 amount, bool isContribution);\n', '  event LogTokenClaimed(address indexed _recipient, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n', '  event LogNewAllocation(address indexed _recipient, uint256 _totalAllocated);\n', '  event LogRemoveAllocation(address indexed _recipient, uint256 _tokenAmountRemoved);\n', '  event LogOwnerSetAllocation(address indexed _recipient, uint256 _totalAllocated);\n', '  event LogTest();\n', '   \n', '\n', '  // Amount of tokens claimed\n', '  uint256 public grandTotalClaimed = 0;\n', '\n', '  // The token being sold\n', '  ERC20 public token;\n', '\n', '  // Amount of tokens Raised\n', '  uint256 public tokensTotal = 0;\n', '\n', '  // Max token amount\n', '  uint256 public hardCap = 0;\n', '  \n', '\n', '\n', '  // Buyers total allocation\n', '  mapping (address => uint256) public allocationsTotal;\n', '\n', '  // User total Claimed\n', '  mapping (address => uint256) public totalClaimed;\n', '\n', '\n', '  //Buyers\n', '  mapping(address => bool) public buyers;\n', '\n', '  //Buyers who received all there tokens\n', '  mapping(address => bool) public buyersReceived;\n', '\n', '  //List of all addresses\n', '  address[] public addresses;\n', '  \n', ' \n', '  constructor(ERC20 _token) public {\n', '     \n', '    require(_token != address(0));\n', '\n', '    token = _token;\n', '  }\n', '\n', '  \n', '  /**\n', '   * @dev fallback function ***DO NOT OVERRIDE***\n', '   */\n', '  function () public {\n', '    //Not payable\n', '  }\n', '\n', '  /**\n', '    * @dev Set many allocations buy admin\n', '    * @param _recipients Array of wallets\n', '    * @param _tokenAmount Amount Allocated tokens + 18 decimals\n', '    */\n', '  function setManyAllocations (address[] _recipients, uint256 _tokenAmount) onlyOwnerOrAdmin  public{\n', '    for (uint256 i = 0; i < _recipients.length; i++) {\n', '      setAllocation(_recipients[i],_tokenAmount);\n', '    }    \n', '  }\n', '\n', '\n', '  /**\n', '    * @dev Set allocation buy admin\n', '    * @param _recipient Users wallet\n', '    * @param _tokenAmount Amount Allocated tokens + 18 decimals\n', '    */\n', '  function setAllocation (address _recipient, uint256 _tokenAmount) onlyOwnerOrAdmin  public{\n', '      require(_tokenAmount > 0);      \n', '      require(_recipient != address(0)); \n', '\n', '      //Check hardCap \n', '      require(_validateHardCap(_tokenAmount));\n', '\n', '      //Allocate tokens\n', '      _setAllocation(_recipient, _tokenAmount);    \n', '\n', '      //Increese token amount\n', '      tokensTotal = tokensTotal.add(_tokenAmount);  \n', '\n', '      //Logg Allocation\n', '      emit LogOwnerSetAllocation(_recipient, _tokenAmount);\n', '  }\n', '\n', '  /**\n', '    * @dev Remove allocation \n', '    * @param _recipient Users wallet\n', '    *  \n', '    */\n', '  function removeAllocation (address _recipient) onlyOwner  public{         \n', '      require(_recipient != address(0)); \n', '      require(totalClaimed[_recipient] == 0); //Check if user claimed tokens\n', '\n', '\n', '      //_recipient total amount\n', '      uint256 _tokenAmountRemoved = allocationsTotal[_recipient];\n', '\n', '      //Decreese token amount\n', '      tokensTotal = tokensTotal.sub(_tokenAmountRemoved);\n', '\n', '      //Reset allocation\n', '      allocationsTotal[_recipient] = 0;\n', '       \n', '      //Set buyer to false\n', '      buyers[_recipient] = false;\n', '\n', '      emit LogRemoveAllocation(_recipient, _tokenAmountRemoved);\n', '  }\n', '\n', '\n', ' /**\n', '   * @dev Set internal allocation \n', '   *  _buyer The adress of the buyer\n', '   *  _tokenAmount Amount Allocated tokens + 18 decimals\n', '   */\n', '  function _setAllocation (address _buyer, uint256 _tokenAmount) internal{\n', '\n', '      if(!buyers[_buyer]){\n', '        //Add buyer to buyers list \n', '        buyers[_buyer] = true;\n', '\n', '        //Remove from list \n', '        buyersReceived[_buyer] = false;\n', '\n', '        //Add _buyer to addresses list\n', '        addresses.push(_buyer);\n', '\n', '        //Reset buyer allocation\n', '        allocationsTotal[_buyer] = 0;\n', '\n', '\n', '      }  \n', '\n', '      //Add tokens to buyers allocation\n', '      allocationsTotal[_buyer]  = allocationsTotal[_buyer].add(_tokenAmount); \n', '\n', '\n', '      //Logg Allocation\n', '      emit LogNewAllocation(_buyer, _tokenAmount);\n', '\n', '  }\n', '\n', '\n', '  /**\n', '    * @dev Return address available allocation\n', '    * @param _recipient which address is applicable\n', '    */\n', '  function checkAvailableTokens (address _recipient) public view returns (uint256) {\n', '    //Check if user have bought tokens\n', '    require(buyers[_recipient]); \n', '\n', '    return allocationsTotal[_recipient];\n', '  }\n', '\n', '  /**\n', '    * @dev Transfer a recipients available allocation to their address\n', '    * @param _recipients Array of addresses to withdraw tokens for\n', '    */\n', '  function distributeManyTokens(address[] _recipients) onlyOwnerOrAdmin public {\n', '    for (uint256 i = 0; i < _recipients.length; i++) {\n', '      distributeTokens( _recipients[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '    * @notice Withdraw available tokens\n', '    * \n', '    */\n', '  function withdrawTokens() public {\n', '    distributeTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '    * @dev Transfer a recipients available allocation to _recipient\n', '    *\n', '    */\n', '  function distributeTokens(address _recipient) public {\n', '    \n', '    //Check have bought tokens\n', '    require(buyers[_recipient]);\n', '\n', '    //If all tokens are received, add _recipient to buyersReceived\n', '    //To prevent the loop to fail if user allready used the withdrawTokens \n', '    buyersReceived[_recipient] = true;\n', '\n', '    uint256 _availableTokens = allocationsTotal[_recipient];\n', '     \n', '\n', '    //Check if contract has tokens\n', '    require(token.balanceOf(this)>=_availableTokens);\n', '\n', '    //Transfer tokens\n', '    require(token.transfer(_recipient, _availableTokens));\n', '\n', '    //Add claimed tokens to totalClaimed\n', '    totalClaimed[_recipient] = totalClaimed[_recipient].add(_availableTokens);\n', '\n', '    //Add claimed tokens to grandTotalClaimed\n', '    grandTotalClaimed = grandTotalClaimed.add(_availableTokens);\n', '\n', '\n', '    //Reset allocation\n', '    allocationsTotal[_recipient] = 0;\n', '\n', '\n', '    emit LogTokenClaimed(_recipient, _availableTokens, allocationsTotal[_recipient], grandTotalClaimed);\n', '\n', '    \n', '\n', '  }\n', '\n', '\n', '\n', '  function _validateHardCap(uint256 _tokenAmount) internal view returns (bool) {\n', '      return tokensTotal.add(_tokenAmount) <= hardCap;\n', '  }\n', '\n', '\n', '  function getListOfAddresses() public onlyOwnerOrAdmin view returns (address[]) {    \n', '    return addresses;\n', '  }\n', '\n', '\n', '  // Allow transfer of tokens back to owner or reserve wallet\n', '  function returnTokens() public onlyOwner {\n', '    uint256 balance = token.balanceOf(this);\n', '    require(token.transfer(owner, balance));\n', '  }\n', '\n', '  // Owner can transfer tokens that are sent here by mistake\n', '  function refundTokens(address _recipient, ERC20 _token) public onlyOwner {\n', '    uint256 balance = _token.balanceOf(this);\n', '    require(_token.transfer(_recipient, balance));\n', '  }\n', '\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title BYTMAirDrop\n', ' *  \n', ' *\n', '*/\n', 'contract BYTMAirDrop is AirDrop {\n', '  constructor(   \n', '    ERC20 _token\n', '  ) public AirDrop(_token) {\n', '\n', '    // 40,000,000 tokens\n', '    hardCap = 40000000 * (10**uint256(18)); \n', '\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface \n', ' * \n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title OwnableWithAdmin \n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract OwnableWithAdmin {\n', '  address public owner;\n', '  address public adminOwner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    adminOwner = msg.sender;\n', '  }\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the admin.\n', '   */\n', '  modifier onlyAdmin() {\n', '    require(msg.sender == adminOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner or admin.\n', '   */\n', '  modifier onlyOwnerOrAdmin() {\n', '    require(msg.sender == adminOwner || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current adminOwner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferAdminOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(adminOwner, newOwner);\n', '    adminOwner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function uint2str(uint i) internal pure returns (string){\n', '      if (i == 0) return "0";\n', '      uint j = i;\n', '      uint length;\n', '      while (j != 0){\n', '          length++;\n', '          j /= 10;\n', '      }\n', '      bytes memory bstr = new bytes(length);\n', '      uint k = length - 1;\n', '      while (i != 0){\n', '          bstr[k--] = byte(48 + i % 10);\n', '          i /= 10;\n', '      }\n', '      return string(bstr);\n', '  }\n', ' \n', '  \n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title AirDrop\n', ' * @notice Contract is not payable.\n', ' * Owner or admin can allocate tokens.\n', ' * Tokens will be released direct. \n', ' *\n', ' *\n', ' */\n', 'contract AirDrop is OwnableWithAdmin {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 private constant DECIMALFACTOR = 10**uint256(18);\n', '\n', '\n', '  event FundsBooked(address backer, uint256 amount, bool isContribution);\n', '  event LogTokenClaimed(address indexed _recipient, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n', '  event LogNewAllocation(address indexed _recipient, uint256 _totalAllocated);\n', '  event LogRemoveAllocation(address indexed _recipient, uint256 _tokenAmountRemoved);\n', '  event LogOwnerSetAllocation(address indexed _recipient, uint256 _totalAllocated);\n', '  event LogTest();\n', '   \n', '\n', '  // Amount of tokens claimed\n', '  uint256 public grandTotalClaimed = 0;\n', '\n', '  // The token being sold\n', '  ERC20 public token;\n', '\n', '  // Amount of tokens Raised\n', '  uint256 public tokensTotal = 0;\n', '\n', '  // Max token amount\n', '  uint256 public hardCap = 0;\n', '  \n', '\n', '\n', '  // Buyers total allocation\n', '  mapping (address => uint256) public allocationsTotal;\n', '\n', '  // User total Claimed\n', '  mapping (address => uint256) public totalClaimed;\n', '\n', '\n', '  //Buyers\n', '  mapping(address => bool) public buyers;\n', '\n', '  //Buyers who received all there tokens\n', '  mapping(address => bool) public buyersReceived;\n', '\n', '  //List of all addresses\n', '  address[] public addresses;\n', '  \n', ' \n', '  constructor(ERC20 _token) public {\n', '     \n', '    require(_token != address(0));\n', '\n', '    token = _token;\n', '  }\n', '\n', '  \n', '  /**\n', '   * @dev fallback function ***DO NOT OVERRIDE***\n', '   */\n', '  function () public {\n', '    //Not payable\n', '  }\n', '\n', '  /**\n', '    * @dev Set many allocations buy admin\n', '    * @param _recipients Array of wallets\n', '    * @param _tokenAmount Amount Allocated tokens + 18 decimals\n', '    */\n', '  function setManyAllocations (address[] _recipients, uint256 _tokenAmount) onlyOwnerOrAdmin  public{\n', '    for (uint256 i = 0; i < _recipients.length; i++) {\n', '      setAllocation(_recipients[i],_tokenAmount);\n', '    }    \n', '  }\n', '\n', '\n', '  /**\n', '    * @dev Set allocation buy admin\n', '    * @param _recipient Users wallet\n', '    * @param _tokenAmount Amount Allocated tokens + 18 decimals\n', '    */\n', '  function setAllocation (address _recipient, uint256 _tokenAmount) onlyOwnerOrAdmin  public{\n', '      require(_tokenAmount > 0);      \n', '      require(_recipient != address(0)); \n', '\n', '      //Check hardCap \n', '      require(_validateHardCap(_tokenAmount));\n', '\n', '      //Allocate tokens\n', '      _setAllocation(_recipient, _tokenAmount);    \n', '\n', '      //Increese token amount\n', '      tokensTotal = tokensTotal.add(_tokenAmount);  \n', '\n', '      //Logg Allocation\n', '      emit LogOwnerSetAllocation(_recipient, _tokenAmount);\n', '  }\n', '\n', '  /**\n', '    * @dev Remove allocation \n', '    * @param _recipient Users wallet\n', '    *  \n', '    */\n', '  function removeAllocation (address _recipient) onlyOwner  public{         \n', '      require(_recipient != address(0)); \n', '      require(totalClaimed[_recipient] == 0); //Check if user claimed tokens\n', '\n', '\n', '      //_recipient total amount\n', '      uint256 _tokenAmountRemoved = allocationsTotal[_recipient];\n', '\n', '      //Decreese token amount\n', '      tokensTotal = tokensTotal.sub(_tokenAmountRemoved);\n', '\n', '      //Reset allocation\n', '      allocationsTotal[_recipient] = 0;\n', '       \n', '      //Set buyer to false\n', '      buyers[_recipient] = false;\n', '\n', '      emit LogRemoveAllocation(_recipient, _tokenAmountRemoved);\n', '  }\n', '\n', '\n', ' /**\n', '   * @dev Set internal allocation \n', '   *  _buyer The adress of the buyer\n', '   *  _tokenAmount Amount Allocated tokens + 18 decimals\n', '   */\n', '  function _setAllocation (address _buyer, uint256 _tokenAmount) internal{\n', '\n', '      if(!buyers[_buyer]){\n', '        //Add buyer to buyers list \n', '        buyers[_buyer] = true;\n', '\n', '        //Remove from list \n', '        buyersReceived[_buyer] = false;\n', '\n', '        //Add _buyer to addresses list\n', '        addresses.push(_buyer);\n', '\n', '        //Reset buyer allocation\n', '        allocationsTotal[_buyer] = 0;\n', '\n', '\n', '      }  \n', '\n', '      //Add tokens to buyers allocation\n', '      allocationsTotal[_buyer]  = allocationsTotal[_buyer].add(_tokenAmount); \n', '\n', '\n', '      //Logg Allocation\n', '      emit LogNewAllocation(_buyer, _tokenAmount);\n', '\n', '  }\n', '\n', '\n', '  /**\n', '    * @dev Return address available allocation\n', '    * @param _recipient which address is applicable\n', '    */\n', '  function checkAvailableTokens (address _recipient) public view returns (uint256) {\n', '    //Check if user have bought tokens\n', '    require(buyers[_recipient]); \n', '\n', '    return allocationsTotal[_recipient];\n', '  }\n', '\n', '  /**\n', '    * @dev Transfer a recipients available allocation to their address\n', '    * @param _recipients Array of addresses to withdraw tokens for\n', '    */\n', '  function distributeManyTokens(address[] _recipients) onlyOwnerOrAdmin public {\n', '    for (uint256 i = 0; i < _recipients.length; i++) {\n', '      distributeTokens( _recipients[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '    * @notice Withdraw available tokens\n', '    * \n', '    */\n', '  function withdrawTokens() public {\n', '    distributeTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '    * @dev Transfer a recipients available allocation to _recipient\n', '    *\n', '    */\n', '  function distributeTokens(address _recipient) public {\n', '    \n', '    //Check have bought tokens\n', '    require(buyers[_recipient]);\n', '\n', '    //If all tokens are received, add _recipient to buyersReceived\n', '    //To prevent the loop to fail if user allready used the withdrawTokens \n', '    buyersReceived[_recipient] = true;\n', '\n', '    uint256 _availableTokens = allocationsTotal[_recipient];\n', '     \n', '\n', '    //Check if contract has tokens\n', '    require(token.balanceOf(this)>=_availableTokens);\n', '\n', '    //Transfer tokens\n', '    require(token.transfer(_recipient, _availableTokens));\n', '\n', '    //Add claimed tokens to totalClaimed\n', '    totalClaimed[_recipient] = totalClaimed[_recipient].add(_availableTokens);\n', '\n', '    //Add claimed tokens to grandTotalClaimed\n', '    grandTotalClaimed = grandTotalClaimed.add(_availableTokens);\n', '\n', '\n', '    //Reset allocation\n', '    allocationsTotal[_recipient] = 0;\n', '\n', '\n', '    emit LogTokenClaimed(_recipient, _availableTokens, allocationsTotal[_recipient], grandTotalClaimed);\n', '\n', '    \n', '\n', '  }\n', '\n', '\n', '\n', '  function _validateHardCap(uint256 _tokenAmount) internal view returns (bool) {\n', '      return tokensTotal.add(_tokenAmount) <= hardCap;\n', '  }\n', '\n', '\n', '  function getListOfAddresses() public onlyOwnerOrAdmin view returns (address[]) {    \n', '    return addresses;\n', '  }\n', '\n', '\n', '  // Allow transfer of tokens back to owner or reserve wallet\n', '  function returnTokens() public onlyOwner {\n', '    uint256 balance = token.balanceOf(this);\n', '    require(token.transfer(owner, balance));\n', '  }\n', '\n', '  // Owner can transfer tokens that are sent here by mistake\n', '  function refundTokens(address _recipient, ERC20 _token) public onlyOwner {\n', '    uint256 balance = _token.balanceOf(this);\n', '    require(_token.transfer(_recipient, balance));\n', '  }\n', '\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title BYTMAirDrop\n', ' *  \n', ' *\n', '*/\n', 'contract BYTMAirDrop is AirDrop {\n', '  constructor(   \n', '    ERC20 _token\n', '  ) public AirDrop(_token) {\n', '\n', '    // 40,000,000 tokens\n', '    hardCap = 40000000 * (10**uint256(18)); \n', '\n', '  }\n', '}']
