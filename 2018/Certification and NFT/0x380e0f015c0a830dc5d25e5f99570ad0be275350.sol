['pragma solidity ^0.4.19;\n', '\n', 'contract Button {\n', '  event Pressed(address indexed presser, uint256 endBlock);\n', '  event Winner(address winner, uint256 winnings);\n', '  event Donation(address donator, uint256 amount);\n', '\n', '  address public factory = msg.sender;\n', '\n', '  uint64 public countdown;\n', '  uint64 public countdownDecrement;\n', '  uint64 public cooloffIncrement;\n', '  uint64 public pressFee;\n', '  uint64 public signupFee; // basis points * contract value\n', '\n', '  address public lastPresser;\n', '  uint64 public endBlock;\n', '\n', '  struct Presser {\n', '    uint64 numPresses;\n', '    uint64 cooloffEnd;\n', '  }\n', '\n', '  mapping (address => Presser) public pressers;\n', '\n', '  // Signup fee collection.\n', '  address public owner;\n', '  uint256 public rake;\n', '\n', '  constructor (\n', '    uint64 _countdown, \n', '    uint64 _countdownDecrement, \n', '    uint64 _cooloffIncrement, \n', '    uint64 _pressFee, \n', '    uint64 _signupFee, \n', '    address _sender\n', '  ) public payable {\n', '    countdown = _countdown;\n', '    countdownDecrement = _countdownDecrement;\n', '    cooloffIncrement = _cooloffIncrement;\n', '    pressFee = _pressFee;\n', '    signupFee = _signupFee;\n', '    lastPresser = _sender;\n', '\n', '    owner = _sender;\n', '    endBlock = uint64(block.number + countdown);\n', '  }\n', '\n', '  function getInfo() public view returns(\n', '    uint64, // Countdown\n', '    uint64, // CountdownDecrement\n', '    uint64, // CooloffIncrement\n', '    uint64, // PressFee\n', '    uint64, // SignupFee\n', '    address,// LastPresser\n', '    uint64, // EndBlock\n', '    uint64, // NumPresses\n', '    uint64, // CooloffEnd\n', '    uint256 // Pot\n', '  ) {\n', '    Presser p = pressers[msg.sender];\n', '    return (\n', '      countdown, \n', '      countdownDecrement, \n', '      cooloffIncrement, \n', '      pressFee, \n', '      signupFee, \n', '      lastPresser, \n', '      endBlock, \n', '      p.numPresses,\n', '      p.cooloffEnd,\n', '      address(this).balance-rake\n', '    );\n', '  }\n', '\n', '  function press() public payable {\n', '    require(block.number <= endBlock);\n', '\n', '    Presser storage p = pressers[msg.sender];\n', '    require(p.cooloffEnd < block.number);\n', '\n', '    uint256 change = msg.value-pressFee;\n', '    if (p.numPresses == 0) {\n', '      // balance - value will never be negative.\n', '      uint128 npf = _newPresserFee(address(this).balance - rake - msg.value);\n', '      change -= npf;\n', '      rake += npf;\n', '    }\n', '    // Breaks when pressFee+newPresserFee > 2^256\n', '    require(change <= msg.value);\n', '\n', '    lastPresser = msg.sender;\n', '    uint64 finalCountdown = countdown - (p.numPresses*countdownDecrement);\n', '    if (finalCountdown < 10 || finalCountdown > countdown) {\n', '      finalCountdown = 10;\n', '    }\n', '    endBlock = uint64(block.number + finalCountdown);\n', '\n', '    p.numPresses++;\n', '    p.cooloffEnd = uint64(block.number + (p.numPresses*cooloffIncrement));\n', '\n', '    if (change > 0) {\n', '      // Re-entrancy protected by p.cooloffEnd guard.\n', '      msg.sender.transfer(change);\n', '    }\n', '\n', '    emit Pressed(msg.sender, endBlock);\n', '  }\n', '\n', '  function close() public {\n', '    require(block.number > endBlock);\n', '\n', '    ButtonFactory f = ButtonFactory(factory);\n', '\n', '    if (!owner.send(3*rake/4)){\n', "      // Owner can't accept their portion of the rake, so send it to the factory.\n", '      f.announceWinner.value(rake)(lastPresser, address(this).balance);\n', '    } else {\n', '      f.announceWinner.value(rake/4)(lastPresser, address(this).balance);\n', '    }\n', '\n', '    emit Winner(lastPresser, address(this).balance);\n', '    selfdestruct(lastPresser);\n', '  }\n', '\n', '  // Breaks when balance = 10^20 ether.\n', '  function newPresserFee() public view returns (uint128) {\n', '    return _newPresserFee(address(this).balance-rake);\n', '  }\n', '\n', '  // Caller must assure that _balance < max_uint128.\n', '  function _newPresserFee(uint256 _balance) private view returns (uint128) {\n', '    return uint128((_balance * signupFee) / 10000);\n', '  }\n', '\n', '  // Up the stakes...\n', '  function() payable public {\n', '    emit Donation(msg.sender, msg.value);\n', '  }\n', '}\n', '\n', '// Hey, my name is Joe...\n', 'contract ButtonFactory {\n', '  event NewButton(address indexed buttonAddr, address indexed creator, uint64 countdown, uint64 countdownDec, uint64 cooloffInc, uint64 pressFee, uint64 signupFee);\n', '  event ButtonWinner(address indexed buttonAddr, address indexed winner, uint256 pot);\n', '\n', '  address public owner = msg.sender;\n', '  uint256 public creationFee;\n', '\n', '  mapping (address => bool) buttons;\n', '\n', '  function setCreationFee(uint256 _fee) public {\n', '    require(msg.sender == owner);\n', '    creationFee = _fee;\n', '  }\n', '\n', '  function createButton(\n', '    uint64 _countdown, \n', '    uint64 _countdownDecrement, \n', '    uint64 _cooloffIncrement, \n', '    uint64 _pressFee, \n', '    uint64 _signupFee\n', '  ) public payable returns (address) {\n', '    uint256 cf = ((_countdown / 1441) + 1) * creationFee;\n', '    require(msg.value >= cf);\n', '    address newButton = new Button(_countdown, _countdownDecrement, _cooloffIncrement, _pressFee, _signupFee, msg.sender);\n', '    buttons[newButton] = true;\n', '\n', '    emit NewButton(newButton, msg.sender, _countdown, _countdownDecrement, _cooloffIncrement, _pressFee, _signupFee);\n', '    return newButton;\n', '  }\n', '\n', '  function announceWinner(address _winner, uint256 _pot) public payable {\n', '    require(buttons[msg.sender]);\n', '    delete buttons[msg.sender];\n', '    emit ButtonWinner(msg.sender, _winner, _pot);\n', '  }\n', '\n', '  function withdraw() public {\n', '    require(msg.sender == owner);\n', '    msg.sender.transfer(address(this).balance);\n', '  }\n', '}']