['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath { \n', 'function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n', 'if (a == 0) {\n', 'return 0;\n', '}\n', '\n', 'uint256 c = a * b;\n', 'require(c / a == b);\n', '\n', 'return c;\n', '} \n', 'function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', 'require(b > 0);\n', 'uint256 c = a / b; \n', 'return c;\n', '} \n', 'function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', 'require(b <= a);\n', 'uint256 c = a - b;\n', '\n', 'return c;\n', '} \n', 'function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', 'uint256 c = a + b;\n', 'require(c >= a);\n', '\n', 'return c;\n', '} \n', 'function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', 'require(b != 0);\n', 'return a % b;\n', '}\n', '}\n', '\n', 'contract ERC20Interface {\n', 'function totalSupply() public constant returns (uint);\n', 'function balanceOf(address tokenOwner) public constant returns (uint balance);\n', 'function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', 'function transfer(address to, uint tokens) public returns (bool success);\n', 'function approve(address spender, uint tokens) public returns (bool success);\n', 'function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', 'event Transfer(address indexed from, address indexed to, uint tokens);\n', 'event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}  \n', 'contract ApproveAndCallFallBack {\n', 'function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '} \n', 'contract Owned {\n', 'address public owner;\n', 'address public newOwner;\n', '\n', 'event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', 'constructor() public {\n', 'owner = msg.sender;\n', '}\n', '\n', 'modifier onlyOwner {\n', 'require(msg.sender == owner);\n', '_;\n', '}\n', '\n', 'function transferOwnership(address _newOwner) public onlyOwner {\n', 'newOwner = _newOwner;\n', '}\n', 'function acceptOwnership() public {\n', 'require(msg.sender == newOwner);\n', 'emit OwnershipTransferred(owner, newOwner);\n', 'owner = newOwner;\n', 'newOwner = address(0);\n', '}\n', '}  \n', 'contract FixedSupplyToken is ERC20Interface, Owned {\n', 'using SafeMath for uint;\n', '\n', 'string public symbol;\n', 'string public  name;\n', 'uint8 public decimals;\n', 'uint _totalSupply; \n', '\n', 'bool public crowdsaleEnabled;\n', 'uint public ethPerToken;\n', 'uint public bonusMinEth;\n', 'uint public bonusPct; \n', '\n', 'mapping(address => uint) balances;\n', 'mapping(address => mapping(address => uint)) allowed; \n', 'event Burn(address indexed from, uint256 value);\n', 'event Bonus(address indexed from, uint256 value);  \n', 'constructor() public {\n', 'symbol = "DN8";\n', 'name = "PLDGR.ORG";\n', 'decimals = 18;\n', '_totalSupply = 450000000000000000000000000;\n', '\n', '\n', 'crowdsaleEnabled = false;\n', 'ethPerToken = 20000;\n', 'bonusMinEth = 0;\n', 'bonusPct = 0; \n', '\n', 'balances[owner] = _totalSupply;\n', 'emit Transfer(address(0), owner, _totalSupply);\n', '} \n', 'function totalSupply() public view returns (uint) {\n', 'return _totalSupply.sub(balances[address(0)]);\n', '} \n', 'function balanceOf(address tokenOwner) public view returns (uint balance) {\n', 'return balances[tokenOwner];\n', '} \n', 'function transfer(address to, uint tokens) public returns (bool success) {\n', 'balances[msg.sender] = balances[msg.sender].sub(tokens);\n', 'balances[to] = balances[to].add(tokens);\n', 'emit Transfer(msg.sender, to, tokens);\n', 'return true;\n', '} \n', 'function approve(address spender, uint tokens) public returns (bool success) {\n', 'allowed[msg.sender][spender] = tokens;\n', 'emit Approval(msg.sender, spender, tokens);\n', 'return true;\n', '} \n', 'function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', 'balances[from] = balances[from].sub(tokens);\n', 'allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', 'balances[to] = balances[to].add(tokens);\n', 'emit Transfer(from, to, tokens);\n', 'return true;\n', '} \n', 'function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', 'return allowed[tokenOwner][spender];\n', '} \n', 'function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', 'allowed[msg.sender][spender] = tokens;\n', 'emit Approval(msg.sender, spender, tokens);\n', 'ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', 'return true;\n', '} \n', 'function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', 'return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '} \n', 'function () public payable { \n', 'require(crowdsaleEnabled);  \n', 'uint ethValue = msg.value; \n', 'uint tokens = ethValue.mul(ethPerToken); \n', 'if(bonusPct > 0 && ethValue >= bonusMinEth){ \n', 'uint bonus = tokens.div(100).mul(bonusPct); \n', 'emit Bonus(msg.sender, bonus); \n', 'tokens = tokens.add(bonus);\n', '} \n', 'balances[owner] = balances[owner].sub(tokens);\n', 'balances[msg.sender] = balances[msg.sender].add(tokens); \n', 'emit Transfer(owner, msg.sender, tokens);\n', '}  \n', 'function enableCrowdsale() public onlyOwner{\n', 'crowdsaleEnabled = true; \n', '} \n', 'function disableCrowdsale() public onlyOwner{\n', 'crowdsaleEnabled = false; \n', '} \n', 'function setTokenPrice(uint _ethPerToken) public onlyOwner{ \n', 'ethPerToken = _ethPerToken;\n', '}  \n', 'function setBonus(uint _bonusPct, uint _minEth) public onlyOwner {\n', 'bonusMinEth = _minEth;\n', 'bonusPct = _bonusPct;\n', '} \n', 'function burn(uint256 _value) public onlyOwner {\n', 'require(_value > 0);\n', 'require(_value <= balances[msg.sender]); \n', '\n', 'address burner = msg.sender; \n', 'balances[burner] = balances[burner].sub(_value); \n', '_totalSupply = _totalSupply.sub(_value);\n', '\n', 'emit Burn(burner, _value); \n', '}  \n', 'function withdraw(uint _amount) onlyOwner public {\n', 'require(_amount > 0); \n', 'require(_amount <= address(this).balance);     \n', '\n', 'owner.transfer(_amount);\n', '}\n', '\n', '\n', '}']