['pragma solidity 0.4.24;\n', '\n', '// File: contracts/ERC165/ERC165.sol\n', '\n', '/**\n', ' * @dev A standard for detecting smart contract interfaces.\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'contract ERC165 {\n', '\n', '  // bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));\n', '  bytes4 constant INTERFACE_ERC165 = 0x01ffc9a7;\n', '\n', '  /**\n', '   * @dev Checks if the smart contract includes a specific interface.\n', '   * @param _interfaceID The interface identifier, as specified in ERC-165.\n', '   */\n', '  function supportsInterface(bytes4 _interfaceID) public pure returns (bool) {\n', '    return _interfaceID == INTERFACE_ERC165;\n', '  }\n', '}\n', '\n', '// File: contracts/ERC721/ERC721Basic.sol\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Basic {\n', '  // bytes4(keccak256(&#39;balanceOf(address)&#39;)) ^\n', '  // bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) ^\n', '  // bytes4(keccak256(&#39;approve(address,uint256)&#39;)) ^\n', '  // bytes4(keccak256(&#39;getApproved(uint256)&#39;)) ^\n', '  // bytes4(keccak256(&#39;setApprovalForAll(address,bool)&#39;)) ^\n', '  // bytes4(keccak256(&#39;isApprovedForAll(address,address)&#39;)) ^\n', '  // bytes4(keccak256(&#39;transferFrom(address,address,uint256)&#39;)) ^\n', '  // bytes4(keccak256(&#39;safeTransferFrom(address,address,uint256)&#39;)) ^\n', '  // bytes4(keccak256(&#39;safeTransferFrom(address,address,uint256,bytes)&#39;));\n', '  bytes4 constant INTERFACE_ERC721 = 0x80ac58cd;\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool indexed _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '\n', '  // Note: This is not in the official ERC-721 standard so it&#39;s not included in the interface hash\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId) public;\n', '\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId) public;\n', '\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data) public;\n', '}\n', '\n', '// File: contracts/ERC721/ERC721.sol\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Enumerable is ERC721Basic {\n', '  // bytes4(keccak256(&#39;totalSupply()&#39;)) ^\n', '  // bytes4(keccak256(&#39;tokenOfOwnerByIndex(address,uint256)&#39;)) ^\n', '  // bytes4(keccak256(&#39;tokenByIndex(uint256)&#39;));\n', '  bytes4 constant INTERFACE_ERC721_ENUMERABLE = 0x780e9d63;\n', '\n', '  function totalSupply() public view returns (uint256);\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\n', '  function tokenByIndex(uint256 _index) public view returns (uint256);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Metadata is ERC721Basic {\n', '  // bytes4(keccak256(&#39;name()&#39;)) ^\n', '  // bytes4(keccak256(&#39;symbol()&#39;)) ^\n', '  // bytes4(keccak256(&#39;tokenURI(uint256)&#39;));\n', '  bytes4 constant INTERFACE_ERC721_METADATA = 0x5b5e139f;\n', '\n', '  function name() public view returns (string _name);\n', '  function symbol() public view returns (string _symbol);\n', '  function tokenURI(uint256 _tokenId) public view returns (string);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', '/* solium-disable-next-line no-empty-blocks */\n', 'contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n', '}\n', '\n', '// File: contracts/library/ProxyOwnable.sol\n', '\n', '/**\n', ' * @title ProxyOwnable\n', ' * @dev Essentially the Ownable contract, renamed for the purposes of separating it from the\n', ' *  DelayedOwnable contract (the owner of the token contract).\n', ' */\n', 'contract ProxyOwnable {\n', '  address public proxyOwner;\n', '\n', '  event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `proxyOwner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    proxyOwner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == proxyOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferProxyOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '\n', '    emit ProxyOwnershipTransferred(proxyOwner, _newOwner);\n', '\n', '    proxyOwner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/CodexRecordProxy.sol\n', '\n', '/**\n', ' * @title CodexRecordProxy, a proxy contract for token storage\n', ' * @dev This allows the token owner to optionally upgrade the token in the future\n', ' *  if there are changes needed in the business logic. See the upgradeTo function\n', ' *  for caveats.\n', ' * Based on MIT licensed code from\n', ' *  https://github.com/zeppelinos/labs/tree/master/upgradeability_using_inherited_storage\n', ' */\n', 'contract CodexRecordProxy is ProxyOwnable {\n', '  event Upgraded(string version, address indexed implementation);\n', '\n', '  string public version;\n', '  address public implementation;\n', '\n', '  constructor(address _implementation) public {\n', '    upgradeTo("1", _implementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Fallback function. Any transaction sent to this contract that doesn&#39;t match the\n', '   *  upgradeTo signature will fallback to this function, which in turn will use\n', '   *  DELEGATECALL to delegate the transaction data to the implementation.\n', '   */\n', '  function () payable public {\n', '    address _implementation = implementation;\n', '\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      let ptr := mload(0x40)\n', '      calldatacopy(ptr, 0, calldatasize)\n', '      let result := delegatecall(gas, _implementation, ptr, calldatasize, 0, 0)\n', '      let size := returndatasize\n', '      returndatacopy(ptr, 0, size)\n', '\n', '      switch result\n', '      case 0 { revert(ptr, size) }\n', '      default { return(ptr, size) }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Since name is passed into the ERC721 token constructor, it&#39;s not stored in the CodexRecordProxy\n', '   *  contract. Thus, we call into the contract directly to retrieve its value.\n', '   * @return string The name of the token\n', '   */\n', '  function name() external view returns (string) {\n', '    ERC721Metadata tokenMetadata = ERC721Metadata(implementation);\n', '\n', '    return tokenMetadata.name();\n', '  }\n', '\n', '  /**\n', '   * @dev Since symbol is passed into the ERC721 token constructor, it&#39;s not stored in the CodexRecordProxy\n', '   *  contract. Thus, we call into the contract directly to retrieve its value.\n', '   * @return string The symbol of token\n', '   */\n', '  function symbol() external view returns (string) {\n', '    ERC721Metadata tokenMetadata = ERC721Metadata(implementation);\n', '\n', '    return tokenMetadata.symbol();\n', '  }\n', '\n', '  /**\n', '   * @dev Upgrades the CodexRecordProxy to point at a new implementation. Only callable by the owner.\n', '   *  Only upgrade the token after extensive testing has been done. The storage is append only.\n', '   *  The new token must inherit from the previous token so the shape of the storage is maintained.\n', '   * @param _version The version of the token\n', '   * @param _implementation The address at which the implementation is available\n', '   */\n', '  function upgradeTo(string _version, address _implementation) public onlyOwner {\n', '    require(\n', '      keccak256(abi.encodePacked(_version)) != keccak256(abi.encodePacked(version)),\n', '      "The version cannot be the same");\n', '\n', '    require(\n', '      _implementation != implementation,\n', '      "The implementation cannot be the same");\n', '\n', '    require(\n', '      _implementation != address(0),\n', '      "The implementation cannot be the 0 address");\n', '\n', '    version = _version;\n', '    implementation = _implementation;\n', '\n', '    emit Upgraded(version, implementation);\n', '  }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '// File: contracts/ERC165/ERC165.sol\n', '\n', '/**\n', ' * @dev A standard for detecting smart contract interfaces.\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'contract ERC165 {\n', '\n', "  // bytes4(keccak256('supportsInterface(bytes4)'));\n", '  bytes4 constant INTERFACE_ERC165 = 0x01ffc9a7;\n', '\n', '  /**\n', '   * @dev Checks if the smart contract includes a specific interface.\n', '   * @param _interfaceID The interface identifier, as specified in ERC-165.\n', '   */\n', '  function supportsInterface(bytes4 _interfaceID) public pure returns (bool) {\n', '    return _interfaceID == INTERFACE_ERC165;\n', '  }\n', '}\n', '\n', '// File: contracts/ERC721/ERC721Basic.sol\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Basic {\n', "  // bytes4(keccak256('balanceOf(address)')) ^\n", "  // bytes4(keccak256('ownerOf(uint256)')) ^\n", "  // bytes4(keccak256('approve(address,uint256)')) ^\n", "  // bytes4(keccak256('getApproved(uint256)')) ^\n", "  // bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n", "  // bytes4(keccak256('isApprovedForAll(address,address)')) ^\n", "  // bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n", "  // bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n", "  // bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'));\n", '  bytes4 constant INTERFACE_ERC721 = 0x80ac58cd;\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool indexed _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '\n', "  // Note: This is not in the official ERC-721 standard so it's not included in the interface hash\n", '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId) public;\n', '\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId) public;\n', '\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data) public;\n', '}\n', '\n', '// File: contracts/ERC721/ERC721.sol\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Enumerable is ERC721Basic {\n', "  // bytes4(keccak256('totalSupply()')) ^\n", "  // bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n", "  // bytes4(keccak256('tokenByIndex(uint256)'));\n", '  bytes4 constant INTERFACE_ERC721_ENUMERABLE = 0x780e9d63;\n', '\n', '  function totalSupply() public view returns (uint256);\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\n', '  function tokenByIndex(uint256 _index) public view returns (uint256);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Metadata is ERC721Basic {\n', "  // bytes4(keccak256('name()')) ^\n", "  // bytes4(keccak256('symbol()')) ^\n", "  // bytes4(keccak256('tokenURI(uint256)'));\n", '  bytes4 constant INTERFACE_ERC721_METADATA = 0x5b5e139f;\n', '\n', '  function name() public view returns (string _name);\n', '  function symbol() public view returns (string _symbol);\n', '  function tokenURI(uint256 _tokenId) public view returns (string);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', '/* solium-disable-next-line no-empty-blocks */\n', 'contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n', '}\n', '\n', '// File: contracts/library/ProxyOwnable.sol\n', '\n', '/**\n', ' * @title ProxyOwnable\n', ' * @dev Essentially the Ownable contract, renamed for the purposes of separating it from the\n', ' *  DelayedOwnable contract (the owner of the token contract).\n', ' */\n', 'contract ProxyOwnable {\n', '  address public proxyOwner;\n', '\n', '  event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `proxyOwner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    proxyOwner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == proxyOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferProxyOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '\n', '    emit ProxyOwnershipTransferred(proxyOwner, _newOwner);\n', '\n', '    proxyOwner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/CodexRecordProxy.sol\n', '\n', '/**\n', ' * @title CodexRecordProxy, a proxy contract for token storage\n', ' * @dev This allows the token owner to optionally upgrade the token in the future\n', ' *  if there are changes needed in the business logic. See the upgradeTo function\n', ' *  for caveats.\n', ' * Based on MIT licensed code from\n', ' *  https://github.com/zeppelinos/labs/tree/master/upgradeability_using_inherited_storage\n', ' */\n', 'contract CodexRecordProxy is ProxyOwnable {\n', '  event Upgraded(string version, address indexed implementation);\n', '\n', '  string public version;\n', '  address public implementation;\n', '\n', '  constructor(address _implementation) public {\n', '    upgradeTo("1", _implementation);\n', '  }\n', '\n', '  /**\n', "   * @dev Fallback function. Any transaction sent to this contract that doesn't match the\n", '   *  upgradeTo signature will fallback to this function, which in turn will use\n', '   *  DELEGATECALL to delegate the transaction data to the implementation.\n', '   */\n', '  function () payable public {\n', '    address _implementation = implementation;\n', '\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      let ptr := mload(0x40)\n', '      calldatacopy(ptr, 0, calldatasize)\n', '      let result := delegatecall(gas, _implementation, ptr, calldatasize, 0, 0)\n', '      let size := returndatasize\n', '      returndatacopy(ptr, 0, size)\n', '\n', '      switch result\n', '      case 0 { revert(ptr, size) }\n', '      default { return(ptr, size) }\n', '    }\n', '  }\n', '\n', '  /**\n', "   * @dev Since name is passed into the ERC721 token constructor, it's not stored in the CodexRecordProxy\n", '   *  contract. Thus, we call into the contract directly to retrieve its value.\n', '   * @return string The name of the token\n', '   */\n', '  function name() external view returns (string) {\n', '    ERC721Metadata tokenMetadata = ERC721Metadata(implementation);\n', '\n', '    return tokenMetadata.name();\n', '  }\n', '\n', '  /**\n', "   * @dev Since symbol is passed into the ERC721 token constructor, it's not stored in the CodexRecordProxy\n", '   *  contract. Thus, we call into the contract directly to retrieve its value.\n', '   * @return string The symbol of token\n', '   */\n', '  function symbol() external view returns (string) {\n', '    ERC721Metadata tokenMetadata = ERC721Metadata(implementation);\n', '\n', '    return tokenMetadata.symbol();\n', '  }\n', '\n', '  /**\n', '   * @dev Upgrades the CodexRecordProxy to point at a new implementation. Only callable by the owner.\n', '   *  Only upgrade the token after extensive testing has been done. The storage is append only.\n', '   *  The new token must inherit from the previous token so the shape of the storage is maintained.\n', '   * @param _version The version of the token\n', '   * @param _implementation The address at which the implementation is available\n', '   */\n', '  function upgradeTo(string _version, address _implementation) public onlyOwner {\n', '    require(\n', '      keccak256(abi.encodePacked(_version)) != keccak256(abi.encodePacked(version)),\n', '      "The version cannot be the same");\n', '\n', '    require(\n', '      _implementation != implementation,\n', '      "The implementation cannot be the same");\n', '\n', '    require(\n', '      _implementation != address(0),\n', '      "The implementation cannot be the 0 address");\n', '\n', '    version = _version;\n', '    implementation = _implementation;\n', '\n', '    emit Upgraded(version, implementation);\n', '  }\n', '}']
