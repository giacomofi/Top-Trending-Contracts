['pragma solidity ^0.4.23;\n', 'pragma experimental "v0.5.0";\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'library AddressExtension {\n', '\n', '  function isValid(address _address) internal pure returns (bool) {\n', '    return 0 != _address;\n', '  }\n', '\n', '  function isAccount(address _address) internal view returns (bool result) {\n', '    assembly {\n', '      result := iszero(extcodesize(_address))\n', '    }\n', '  }\n', '\n', '  function toBytes(address _address) internal pure returns (bytes b) {\n', '   assembly {\n', '      let m := mload(0x40)\n', '      mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, _address))\n', '      mstore(0x40, add(m, 52))\n', '      b := m\n', '    }\n', '  }\n', '}\n', '\n', 'library Math {\n', '\n', '  struct Fraction {\n', '    uint256 numerator;\n', '    uint256 denominator;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    r = a * b;\n', '    require((a == 0) || (r / a == b));\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    r = a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    require((r = a - b) <= a);\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    require((r = a + b) >= a);\n', '  }\n', '\n', '  function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\n', '    return x <= y ? x : y;\n', '  }\n', '\n', '  function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\n', '    return x >= y ? x : y;\n', '  }\n', '\n', '  function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n', '    r = value * m;\n', '    if (r / value == m) {\n', '      r /= d;\n', '    } else {\n', '      r = mul(value / d, m);\n', '    }\n', '  }\n', '\n', '  function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n', '    r = value * m;\n', '    if (r / value == m) {\n', '      r /= d;\n', '      if (r % d != 0) {\n', '        r += 1;\n', '      }\n', '    } else {\n', '      r = mul(value / d, m);\n', '      if (value % d != 0) {\n', '        r += 1;\n', '      }\n', '    }\n', '  }\n', '\n', '  function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDiv(x, f.numerator, f.denominator);\n', '  }\n', '\n', '  function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDivCeil(x, f.numerator, f.denominator);\n', '  }\n', '\n', '  function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDiv(x, f.denominator, f.numerator);\n', '  }\n', '\n', '  function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDivCeil(x, f.denominator, f.numerator);\n', '  }\n', '}\n', '\n', 'contract FsTKAllocation {\n', '\n', '  function initialize(uint256 _vestedAmount) public;\n', '}\n', '\n', 'contract FsTKAuthority {\n', '\n', '  function isAuthorized(address sender, address _contract, bytes data) public view returns (bool);\n', '  function isApproved(bytes32 hash, uint256 approveTime, bytes approveToken) public view returns (bool);\n', '  function validate() public pure returns (bool);\n', '}\n', '\n', 'contract Authorizable {\n', '\n', '  event SetFsTKAuthority(FsTKAuthority indexed _address);\n', '\n', '  modifier onlyFsTKAuthorized {\n', '    require(fstkAuthority.isAuthorized(msg.sender, this, msg.data));\n', '    _;\n', '  }\n', '  modifier onlyFsTKApproved(bytes32 hash, uint256 approveTime, bytes approveToken) {\n', '    require(fstkAuthority.isApproved(hash, approveTime, approveToken));\n', '    _;\n', '  }\n', '\n', '  FsTKAuthority internal fstkAuthority;\n', '\n', '  constructor(FsTKAuthority _fstkAuthority) internal {\n', '    fstkAuthority = _fstkAuthority;\n', '  }\n', '\n', '  function setFsTKAuthority(FsTKAuthority _fstkAuthority) public onlyFsTKAuthorized {\n', '    require(_fstkAuthority.validate());\n', '    emit SetFsTKAuthority(fstkAuthority = _fstkAuthority);\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '  function balanceOf(address owner) public view returns (uint256);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract SecureERC20 is ERC20 {\n', '\n', '  event SetERC20ApproveChecking(bool approveChecking);\n', '\n', '  function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool);\n', '  function increaseAllowance(address spender, uint256 value) public returns (bool);\n', '  function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool);\n', '  function setERC20ApproveChecking(bool approveChecking) public;\n', '}\n', '\n', 'contract FsTKToken {\n', '\n', '  event SetupDirectDebit(address indexed debtor, address indexed receiver, DirectDebitInfo info);\n', '  event TerminateDirectDebit(address indexed debtor, address indexed receiver);\n', '  event WithdrawDirectDebitFailure(address indexed debtor, address indexed receiver);\n', '\n', '  event SetMetadata(string metadata);\n', '  event SetLiquid(bool liquidity);\n', '  event SetDelegate(bool isDelegateEnable);\n', '  event SetDirectDebit(bool isDirectDebitEnable);\n', '\n', '  struct DirectDebitInfo {\n', '    uint256 amount;\n', '    uint256 startTime;\n', '    uint256 interval;\n', '  }\n', '  struct DirectDebit {\n', '    DirectDebitInfo info;\n', '    uint256 epoch;\n', '  }\n', '  struct Instrument {\n', '    uint256 allowance;\n', '    DirectDebit directDebit;\n', '  }\n', '  struct Account {\n', '    uint256 balance;\n', '    uint256 nonce;\n', '    mapping (address => Instrument) instruments;\n', '  }\n', '\n', '  function spendableAllowance(address owner, address spender) public view returns (uint256);\n', '  function transfer(uint256[] data) public returns (bool);\n', '  function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool);\n', '  function delegateTransferAndCall(\n', '    uint256 nonce,\n', '    uint256 gasAmount,\n', '    address to,\n', '    uint256 value,\n', '    bytes data,\n', '    uint8 v,\n', '    bytes32 r,\n', '    bytes32 s\n', '  ) public returns (bool);\n', '\n', '  function directDebitOf(address debtor, address receiver) public view returns (DirectDebit);\n', '  function setupDirectDebit(address receiver, DirectDebitInfo info) public returns (bool);\n', '  function terminateDirectDebit(address receiver) public returns (bool);\n', '  function withdrawDirectDebit(address debtor) public returns (bool);\n', '  function withdrawDirectDebit(address[] debtors, bool strict) public returns (bool result);\n', '}\n', '\n', 'contract AbstractToken is SecureERC20, FsTKToken {\n', '  using AddressExtension for address;\n', '  using Math for uint256;\n', '\n', '  modifier liquid {\n', '    require(isLiquid);\n', '     _;\n', '  }\n', '  modifier canUseDirectDebit {\n', '    require(isDirectDebitEnable);\n', '     _;\n', '  }\n', '\n', '  bool public erc20ApproveChecking;\n', '  bool public isLiquid = true;\n', '  bool public isDelegateEnable;\n', '  bool public isDirectDebitEnable;\n', '  string public metadata;\n', '  mapping(address => Account) internal accounts;\n', '\n', '  constructor(string _metadata) public {\n', '    metadata = _metadata;\n', '  }\n', '\n', '  function balanceOf(address owner) public view returns (uint256) {\n', '    return accounts[owner].balance;\n', '  }\n', '\n', '  function allowance(address owner, address spender) public view returns (uint256) {\n', '    return accounts[owner].instruments[spender].allowance;\n', '  }\n', '\n', '  function transfer(address to, uint256 value) public liquid returns (bool) {\n', '    Account storage senderAccount = accounts[msg.sender];\n', '    uint256 senderBalance = senderAccount.balance;\n', '    require(value <= senderBalance);\n', '\n', '    senderAccount.balance = senderBalance - value;\n', '    accounts[to].balance += value;\n', '\n', '    emit Transfer(msg.sender, to, value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address from, address to, uint256 value) public liquid returns (bool) {\n', '    Account storage fromAccount = accounts[from];\n', '    uint256 fromBalance = fromAccount.balance;\n', '    Instrument storage senderInstrument = fromAccount.instruments[msg.sender];\n', '    uint256 senderAllowance = senderInstrument.allowance;\n', '    require(value <= fromBalance);\n', '    require(value <= senderAllowance);\n', '\n', '    fromAccount.balance = fromBalance - value;\n', '    senderInstrument.allowance = senderAllowance - value;\n', '    accounts[to].balance += value;\n', '\n', '    emit Transfer(from, to, value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address spender, uint256 value) public returns (bool) {\n', '    Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n', '    if (erc20ApproveChecking) {\n', '      require((value == 0) || (spenderInstrument.allowance == 0));\n', '    }\n', '    spenderInstrument.allowance = value;\n', '\n', '    emit Approval(msg.sender, spender, value);\n', '    return true;\n', '  }\n', '\n', '  function setERC20ApproveChecking(bool approveChecking) public {\n', '    emit SetERC20ApproveChecking(erc20ApproveChecking = approveChecking);\n', '  }\n', '\n', '  function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool) {\n', '    Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n', '    require(spenderInstrument.allowance == expectedValue);\n', '\n', '    spenderInstrument.allowance = newValue;\n', '\n', '    emit Approval(msg.sender, spender, newValue);\n', '    return true;\n', '  }\n', '\n', '  function increaseAllowance(address spender, uint256 value) public returns (bool) {\n', '    Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n', '\n', '    uint256 newValue = spenderInstrument.allowance.add(value);\n', '    spenderInstrument.allowance = newValue;\n', '\n', '    emit Approval(msg.sender, spender, newValue);\n', '    return true;\n', '  }\n', '\n', '  function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool) {\n', '    Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n', '\n', '    uint256 currentValue = spenderInstrument.allowance;\n', '    uint256 newValue;\n', '    if (strict) {\n', '      newValue = currentValue.sub(value);\n', '    } else if (value < currentValue) {\n', '      newValue = currentValue - value;\n', '    }\n', '    spenderInstrument.allowance = newValue;\n', '\n', '    emit Approval(msg.sender, spender, newValue);\n', '    return true;\n', '  }\n', '\n', '  function setMetadata0(string _metadata) internal {\n', '    emit SetMetadata(metadata = _metadata);\n', '  }\n', '\n', '  function setLiquid0(bool liquidity) internal {\n', '    emit SetLiquid(isLiquid = liquidity);\n', '  }\n', '\n', '  function setDelegate(bool delegate) public {\n', '    emit SetDelegate(isDelegateEnable = delegate);\n', '  }\n', '\n', '  function setDirectDebit(bool directDebit) public {\n', '    emit SetDirectDebit(isDirectDebitEnable = directDebit);\n', '  }\n', '\n', '  function spendableAllowance(address owner, address spender) public view returns (uint256) {\n', '    Account storage ownerAccount = accounts[owner];\n', '    return Math.min(\n', '      ownerAccount.instruments[spender].allowance,\n', '      ownerAccount.balance\n', '    );\n', '  }\n', '\n', '  function transfer(uint256[] data) public liquid returns (bool) {\n', '    Account storage senderAccount = accounts[msg.sender];\n', '    uint256 totalValue;\n', '    for (uint256 i = 0; i < data.length; i++) {\n', '      address receiver = address(data[i] >> 96);\n', '      uint256 value = data[i] & 0xffffffffffffffffffffffff;\n', '\n', '      totalValue = totalValue.add(value);\n', '      accounts[receiver].balance += value;\n', '\n', '      emit Transfer(msg.sender, receiver, value);\n', '    }\n', '\n', '    uint256 senderBalance = senderAccount.balance;\n', '    require(totalValue <= senderBalance);\n', '    senderAccount.balance = senderBalance - totalValue;\n', '\n', '    return true;\n', '  }\n', '\n', '  function transferAndCall(address to, uint256 value, bytes data) public payable liquid returns (bool) {\n', '    require(to != address(this));\n', '    require(transfer(to, value));\n', '    require(data.length >= 68);\n', '    assembly {\n', '        mstore(add(data, 36), value)\n', '        mstore(add(data, 68), caller)\n', '    }\n', '    require(to.call.value(msg.value)(data));\n', '    return true;\n', '  }\n', '\n', '  function delegateTransferAndCall(\n', '    uint256 nonce,\n', '    uint256 gasAmount,\n', '    address to,\n', '    uint256 value,\n', '    bytes data,\n', '    uint8 v,\n', '    bytes32 r,\n', '    bytes32 s\n', '  )\n', '    public\n', '    liquid\n', '    returns (bool)\n', '  {\n', '    require(isDelegateEnable);\n', '    require(to != address(this));\n', '\n', '    address signer = ecrecover(\n', '      keccak256(nonce, gasAmount, to, value, data),\n', '      v,\n', '      r,\n', '      s\n', '    );\n', '    Account storage signerAccount = accounts[signer];\n', '    require(nonce == signerAccount.nonce);\n', '    signerAccount.nonce = nonce.add(1);\n', '    uint256 signerBalance = signerAccount.balance;\n', '    uint256 total = value.add(gasAmount);\n', '    require(total <= signerBalance);\n', '\n', '    signerAccount.balance = signerBalance - total;\n', '    accounts[to].balance += value;\n', '    emit Transfer(signer, to, value);\n', '    accounts[msg.sender].balance += gasAmount;\n', '    emit Transfer(signer, msg.sender, gasAmount);\n', '\n', '    if (!to.isAccount()) {\n', '      require(data.length >= 68);\n', '      assembly {\n', '        mstore(add(data, 36), value)\n', '        mstore(add(data, 68), signer)\n', '      }\n', '      require(to.call(data));\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  function directDebitOf(address debtor, address receiver) public view returns (DirectDebit) {\n', '    return accounts[debtor].instruments[receiver].directDebit;\n', '  }\n', '\n', '  function setupDirectDebit(\n', '    address receiver,\n', '    DirectDebitInfo info\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({\n', '      info: info,\n', '      epoch: 0\n', '    });\n', '\n', '    emit SetupDirectDebit(msg.sender, receiver, info);\n', '    return true;\n', '  }\n', '\n', '  function terminateDirectDebit(address receiver) public returns (bool) {\n', '    delete accounts[msg.sender].instruments[receiver].directDebit;\n', '\n', '    emit TerminateDirectDebit(msg.sender, receiver);\n', '    return true;\n', '  }\n', '\n', '  function calculateTotalDirectDebitAmount(uint256 amount, uint256 epochNow, uint256 epochLast) pure private returns (uint256) {\n', '    require(amount > 0);\n', '    require(epochNow > epochLast);\n', '    return (epochNow - epochLast).mul(amount);\n', '  }\n', '\n', '  function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) {\n', '    Account storage debtorAccount = accounts[debtor];\n', '    uint256 debtorBalance = debtorAccount.balance;\n', '    DirectDebit storage directDebit = debtorAccount.instruments[msg.sender].directDebit;\n', '    uint256 epoch = block.timestamp.sub(directDebit.info.startTime) / directDebit.info.interval + 1;\n', '    uint256 amount = calculateTotalDirectDebitAmount(directDebit.info.amount, epoch, directDebit.epoch);\n', '    require(amount <= debtorBalance);\n', '\n', '    debtorAccount.balance = debtorBalance - amount;\n', '    accounts[msg.sender].balance += amount;\n', '    directDebit.epoch = epoch;\n', '\n', '    emit Transfer(debtor, msg.sender, amount);\n', '    return true;\n', '  }\n', '\n', '  function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) {\n', '    Account storage receiverAccount = accounts[msg.sender];\n', '    result = true;\n', '\n', '    for (uint256 i = 0; i < debtors.length; i++) {\n', '      address debtor = debtors[i];\n', '      Account storage debtorAccount = accounts[debtor];\n', '      uint256 debtorBalance = debtorAccount.balance;\n', '      DirectDebit storage directDebit = debtorAccount.instruments[msg.sender].directDebit;\n', '      uint256 epoch = block.timestamp.sub(directDebit.info.startTime) / directDebit.info.interval + 1;\n', '      uint256 amount = calculateTotalDirectDebitAmount(directDebit.info.amount, epoch, directDebit.epoch);\n', '\n', '      if (amount > debtorBalance) {\n', '        if (strict) {\n', '          revert();\n', '        }\n', '        result = false;\n', '        emit WithdrawDirectDebitFailure(debtor, msg.sender);\n', '      } else {\n', '        debtorAccount.balance = debtorBalance - amount;\n', '        receiverAccount.balance += amount;\n', '        directDebit.epoch = epoch;\n', '\n', '        emit Transfer(debtor, msg.sender, amount);\n', '      }\n', '    }\n', '  }\n', '}\n', '\n', 'contract AbstractVoucher {\n', '\n', '  event Consume(address indexed from, uint256 value, bytes32 challenge);\n', '\n', '  uint8 public constant decimals = 0;\n', '}\n', '\n', 'contract QuarterMillionTokenSupply is AbstractToken, AbstractVoucher, Authorizable {\n', '\n', '  uint256 public totalSupply;\n', '  string public constant name = "Quarter-million Token Supply";\n', '  string public constant symbol = "QTS";\n', '  bool public constant isConsumable = true;\n', '\n', '  constructor(\n', '    FsTKAuthority _fstkAuthority,\n', '    string _metadata\n', '  )\n', '    AbstractToken(_metadata)\n', '    Authorizable(_fstkAuthority)\n', '    public\n', '  {\n', '  }\n', '\n', '  function mint(address to, uint256 value) public onlyFsTKAuthorized returns (bool) {\n', '    totalSupply = totalSupply.add(value);\n', '    // garded by totalSupply\n', '    accounts[to].balance += value;\n', '\n', '    emit Transfer(address(0), to, value);\n', '    return true;\n', '  }\n', '\n', '  function consume(address from, uint256 value) public onlyFsTKAuthorized returns (bool) {\n', '    Account storage fromAccount = accounts[from];\n', '    uint256 fromBalance = fromAccount.balance;\n', '    require(value <= fromBalance);\n', '\n', '    // guarded by previous require\n', '    fromAccount.balance = fromBalance - value;\n', '    // guarded by totalSupply\n', '    totalSupply -= value;\n', '\n', '    emit Consume(from, value, bytes32(0));\n', '  }\n', '\n', '  function setMetadata(string infoUrl) public onlyFsTKAuthorized {\n', '    setMetadata0(infoUrl);\n', '  }\n', '\n', '  function setLiquid(bool liquidity) public onlyFsTKAuthorized {\n', '    setLiquid0(liquidity);\n', '  }\n', '\n', '  function setERC20ApproveChecking(bool approveChecking) public onlyFsTKAuthorized {\n', '    AbstractToken.setERC20ApproveChecking(approveChecking);\n', '  }\n', '\n', '  function setDelegate(bool delegate) public onlyFsTKAuthorized {\n', '    AbstractToken.setDelegate(delegate);\n', '  }\n', '\n', '  function setDirectDebit(bool directDebit) public onlyFsTKAuthorized {\n', '    AbstractToken.setDirectDebit(directDebit);\n', '  }\n', '\n', '  function transferToken(ERC20 erc20, address to, uint256 value) public onlyFsTKAuthorized {\n', '    erc20.transfer(to, value);\n', '  }\n', '}']