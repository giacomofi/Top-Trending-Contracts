['pragma solidity 0.4.24;\n', '\n', 'interface CommAuctionIface {\n', '    function getNextPrice(bytes32 democHash) external view returns (uint);\n', '    function noteBallotDeployed(bytes32 democHash) external;\n', '\n', '    // add more when we need it\n', '\n', '    function upgradeMe(address newSC) external;\n', '}\n', '\n', 'contract safeSend {\n', '    bool private txMutex3847834;\n', '\n', '    // we want to be able to call outside contracts (e.g. the admin proxy contract)\n', '    // but reentrency is bad, so here&#39;s a mutex.\n', '    function doSafeSend(address toAddr, uint amount) internal {\n', '        doSafeSendWData(toAddr, "", amount);\n', '    }\n', '\n', '    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\n', '        require(txMutex3847834 == false, "ss-guard");\n', '        txMutex3847834 = true;\n', '        // we need to use address.call.value(v)() because we want\n', '        // to be able to send to other contracts, even with no data,\n', '        // which might use more than 2300 gas in their fallback function.\n', '        require(toAddr.call.value(amount)(data), "ss-failed");\n', '        txMutex3847834 = false;\n', '    }\n', '}\n', '\n', 'contract payoutAllC is safeSend {\n', '    address private _payTo;\n', '\n', '    event PayoutAll(address payTo, uint value);\n', '\n', '    constructor(address initPayTo) public {\n', '        // DEV NOTE: you can overwrite _getPayTo if you want to reuse other storage vars\n', '        assert(initPayTo != address(0));\n', '        _payTo = initPayTo;\n', '    }\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return _payTo;\n', '    }\n', '\n', '    function _setPayTo(address newPayTo) internal {\n', '        _payTo = newPayTo;\n', '    }\n', '\n', '    function payoutAll() external {\n', '        address a = _getPayTo();\n', '        uint bal = address(this).balance;\n', '        doSafeSend(a, bal);\n', '        emit PayoutAll(a, bal);\n', '    }\n', '}\n', '\n', 'contract payoutAllCSettable is payoutAllC {\n', '    constructor (address initPayTo) payoutAllC(initPayTo) public {\n', '    }\n', '\n', '    function setPayTo(address) external;\n', '    function getPayTo() external view returns (address) {\n', '        return _getPayTo();\n', '    }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address newOwner);\n', '\n', '    modifier only_owner() {\n', '        require(msg.sender == owner, "only_owner: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier owner_or(address addr) {\n', '        require(msg.sender == addr || msg.sender == owner, "!owner-or");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address newOwner) only_owner() external {\n', '        owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '}\n', '\n', 'contract CommunityAuctionSimple is owned {\n', '    // about $1USD at $600usd/eth\n', '    uint public commBallotPriceWei = 1666666666000000;\n', '\n', '    struct Record {\n', '        bytes32 democHash;\n', '        uint ts;\n', '    }\n', '\n', '    mapping (address => Record[]) public ballotLog;\n', '    mapping (address => address) public upgrades;\n', '\n', '    function getNextPrice(bytes32) external view returns (uint) {\n', '        return commBallotPriceWei;\n', '    }\n', '\n', '    function noteBallotDeployed(bytes32 d) external {\n', '        require(upgrades[msg.sender] == address(0));\n', '        ballotLog[msg.sender].push(Record(d, now));\n', '    }\n', '\n', '    function upgradeMe(address newSC) external {\n', '        require(upgrades[msg.sender] == address(0));\n', '        upgrades[msg.sender] = newSC;\n', '    }\n', '\n', '    function getBallotLogN(address a) external view returns (uint) {\n', '        return ballotLog[a].length;\n', '    }\n', '\n', '    function setPriceWei(uint newPrice) only_owner() external {\n', '        commBallotPriceWei = newPrice;\n', '    }\n', '}\n', '\n', 'contract controlledIface {\n', '    function controller() external view returns (address);\n', '}\n', '\n', 'contract hasAdmins is owned {\n', '    mapping (uint => mapping (address => bool)) admins;\n', '    uint public currAdminEpoch = 0;\n', '    bool public adminsDisabledForever = false;\n', '    address[] adminLog;\n', '\n', '    event AdminAdded(address indexed newAdmin);\n', '    event AdminRemoved(address indexed oldAdmin);\n', '    event AdminEpochInc();\n', '    event AdminDisabledForever();\n', '\n', '    modifier only_admin() {\n', '        require(adminsDisabledForever == false, "admins must not be disabled");\n', '        require(isAdmin(msg.sender), "only_admin: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        _setAdmin(msg.sender, true);\n', '    }\n', '\n', '    function isAdmin(address a) view public returns (bool) {\n', '        return admins[currAdminEpoch][a];\n', '    }\n', '\n', '    function getAdminLogN() view external returns (uint) {\n', '        return adminLog.length;\n', '    }\n', '\n', '    function getAdminLog(uint n) view external returns (address) {\n', '        return adminLog[n];\n', '    }\n', '\n', '    function upgradeMeAdmin(address newAdmin) only_admin() external {\n', '        // note: already checked msg.sender has admin with `only_admin` modifier\n', '        require(msg.sender != owner, "owner cannot upgrade self");\n', '        _setAdmin(msg.sender, false);\n', '        _setAdmin(newAdmin, true);\n', '    }\n', '\n', '    function setAdmin(address a, bool _givePerms) only_admin() external {\n', '        require(a != msg.sender && a != owner, "cannot change your own (or owner&#39;s) permissions");\n', '        _setAdmin(a, _givePerms);\n', '    }\n', '\n', '    function _setAdmin(address a, bool _givePerms) internal {\n', '        admins[currAdminEpoch][a] = _givePerms;\n', '        if (_givePerms) {\n', '            emit AdminAdded(a);\n', '            adminLog.push(a);\n', '        } else {\n', '            emit AdminRemoved(a);\n', '        }\n', '    }\n', '\n', '    // safety feature if admins go bad or something\n', '    function incAdminEpoch() only_owner() external {\n', '        currAdminEpoch++;\n', '        admins[currAdminEpoch][msg.sender] = true;\n', '        emit AdminEpochInc();\n', '    }\n', '\n', '    // this is internal so contracts can all it, but not exposed anywhere in this\n', '    // contract.\n', '    function disableAdminForever() internal {\n', '        currAdminEpoch++;\n', '        adminsDisabledForever = true;\n', '        emit AdminDisabledForever();\n', '    }\n', '}\n', '\n', 'contract permissioned is owned, hasAdmins {\n', '    mapping (address => bool) editAllowed;\n', '    bool public adminLockdown = false;\n', '\n', '    event PermissionError(address editAddr);\n', '    event PermissionGranted(address editAddr);\n', '    event PermissionRevoked(address editAddr);\n', '    event PermissionsUpgraded(address oldSC, address newSC);\n', '    event SelfUpgrade(address oldSC, address newSC);\n', '    event AdminLockdown();\n', '\n', '    modifier only_editors() {\n', '        require(editAllowed[msg.sender], "only_editors: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier no_lockdown() {\n', '        require(adminLockdown == false, "no_lockdown: check failed");\n', '        _;\n', '    }\n', '\n', '\n', '    constructor() owned() hasAdmins() public {\n', '    }\n', '\n', '\n', '    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\n', '        editAllowed[e] = _editPerms;\n', '        if (_editPerms)\n', '            emit PermissionGranted(e);\n', '        else\n', '            emit PermissionRevoked(e);\n', '    }\n', '\n', '    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\n', '        editAllowed[oldSC] = false;\n', '        editAllowed[newSC] = true;\n', '        emit PermissionsUpgraded(oldSC, newSC);\n', '    }\n', '\n', '    // always allow SCs to upgrade themselves, even after lockdown\n', '    function upgradeMe(address newSC) only_editors() external {\n', '        editAllowed[msg.sender] = false;\n', '        editAllowed[newSC] = true;\n', '        emit SelfUpgrade(msg.sender, newSC);\n', '    }\n', '\n', '    function hasPermissions(address a) public view returns (bool) {\n', '        return editAllowed[a];\n', '    }\n', '\n', '    function doLockdown() external only_owner() no_lockdown() {\n', '        disableAdminForever();\n', '        adminLockdown = true;\n', '        emit AdminLockdown();\n', '    }\n', '}\n', '\n', 'contract upgradePtr {\n', '    address ptr = address(0);\n', '\n', '    modifier not_upgraded() {\n', '        require(ptr == address(0), "upgrade pointer is non-zero");\n', '        _;\n', '    }\n', '\n', '    function getUpgradePointer() view external returns (address) {\n', '        return ptr;\n', '    }\n', '\n', '    function doUpgradeInternal(address nextSC) internal {\n', '        ptr = nextSC;\n', '    }\n', '}\n', '\n', 'interface ERC20Interface {\n', '    // Get the total token supply\n', '    function totalSupply() constant external returns (uint256 _totalSupply);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'interface CommAuctionIface {\n', '    function getNextPrice(bytes32 democHash) external view returns (uint);\n', '    function noteBallotDeployed(bytes32 democHash) external;\n', '\n', '    // add more when we need it\n', '\n', '    function upgradeMe(address newSC) external;\n', '}\n', '\n', 'contract safeSend {\n', '    bool private txMutex3847834;\n', '\n', '    // we want to be able to call outside contracts (e.g. the admin proxy contract)\n', "    // but reentrency is bad, so here's a mutex.\n", '    function doSafeSend(address toAddr, uint amount) internal {\n', '        doSafeSendWData(toAddr, "", amount);\n', '    }\n', '\n', '    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\n', '        require(txMutex3847834 == false, "ss-guard");\n', '        txMutex3847834 = true;\n', '        // we need to use address.call.value(v)() because we want\n', '        // to be able to send to other contracts, even with no data,\n', '        // which might use more than 2300 gas in their fallback function.\n', '        require(toAddr.call.value(amount)(data), "ss-failed");\n', '        txMutex3847834 = false;\n', '    }\n', '}\n', '\n', 'contract payoutAllC is safeSend {\n', '    address private _payTo;\n', '\n', '    event PayoutAll(address payTo, uint value);\n', '\n', '    constructor(address initPayTo) public {\n', '        // DEV NOTE: you can overwrite _getPayTo if you want to reuse other storage vars\n', '        assert(initPayTo != address(0));\n', '        _payTo = initPayTo;\n', '    }\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return _payTo;\n', '    }\n', '\n', '    function _setPayTo(address newPayTo) internal {\n', '        _payTo = newPayTo;\n', '    }\n', '\n', '    function payoutAll() external {\n', '        address a = _getPayTo();\n', '        uint bal = address(this).balance;\n', '        doSafeSend(a, bal);\n', '        emit PayoutAll(a, bal);\n', '    }\n', '}\n', '\n', 'contract payoutAllCSettable is payoutAllC {\n', '    constructor (address initPayTo) payoutAllC(initPayTo) public {\n', '    }\n', '\n', '    function setPayTo(address) external;\n', '    function getPayTo() external view returns (address) {\n', '        return _getPayTo();\n', '    }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address newOwner);\n', '\n', '    modifier only_owner() {\n', '        require(msg.sender == owner, "only_owner: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier owner_or(address addr) {\n', '        require(msg.sender == addr || msg.sender == owner, "!owner-or");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address newOwner) only_owner() external {\n', '        owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '}\n', '\n', 'contract CommunityAuctionSimple is owned {\n', '    // about $1USD at $600usd/eth\n', '    uint public commBallotPriceWei = 1666666666000000;\n', '\n', '    struct Record {\n', '        bytes32 democHash;\n', '        uint ts;\n', '    }\n', '\n', '    mapping (address => Record[]) public ballotLog;\n', '    mapping (address => address) public upgrades;\n', '\n', '    function getNextPrice(bytes32) external view returns (uint) {\n', '        return commBallotPriceWei;\n', '    }\n', '\n', '    function noteBallotDeployed(bytes32 d) external {\n', '        require(upgrades[msg.sender] == address(0));\n', '        ballotLog[msg.sender].push(Record(d, now));\n', '    }\n', '\n', '    function upgradeMe(address newSC) external {\n', '        require(upgrades[msg.sender] == address(0));\n', '        upgrades[msg.sender] = newSC;\n', '    }\n', '\n', '    function getBallotLogN(address a) external view returns (uint) {\n', '        return ballotLog[a].length;\n', '    }\n', '\n', '    function setPriceWei(uint newPrice) only_owner() external {\n', '        commBallotPriceWei = newPrice;\n', '    }\n', '}\n', '\n', 'contract controlledIface {\n', '    function controller() external view returns (address);\n', '}\n', '\n', 'contract hasAdmins is owned {\n', '    mapping (uint => mapping (address => bool)) admins;\n', '    uint public currAdminEpoch = 0;\n', '    bool public adminsDisabledForever = false;\n', '    address[] adminLog;\n', '\n', '    event AdminAdded(address indexed newAdmin);\n', '    event AdminRemoved(address indexed oldAdmin);\n', '    event AdminEpochInc();\n', '    event AdminDisabledForever();\n', '\n', '    modifier only_admin() {\n', '        require(adminsDisabledForever == false, "admins must not be disabled");\n', '        require(isAdmin(msg.sender), "only_admin: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        _setAdmin(msg.sender, true);\n', '    }\n', '\n', '    function isAdmin(address a) view public returns (bool) {\n', '        return admins[currAdminEpoch][a];\n', '    }\n', '\n', '    function getAdminLogN() view external returns (uint) {\n', '        return adminLog.length;\n', '    }\n', '\n', '    function getAdminLog(uint n) view external returns (address) {\n', '        return adminLog[n];\n', '    }\n', '\n', '    function upgradeMeAdmin(address newAdmin) only_admin() external {\n', '        // note: already checked msg.sender has admin with `only_admin` modifier\n', '        require(msg.sender != owner, "owner cannot upgrade self");\n', '        _setAdmin(msg.sender, false);\n', '        _setAdmin(newAdmin, true);\n', '    }\n', '\n', '    function setAdmin(address a, bool _givePerms) only_admin() external {\n', '        require(a != msg.sender && a != owner, "cannot change your own (or owner\'s) permissions");\n', '        _setAdmin(a, _givePerms);\n', '    }\n', '\n', '    function _setAdmin(address a, bool _givePerms) internal {\n', '        admins[currAdminEpoch][a] = _givePerms;\n', '        if (_givePerms) {\n', '            emit AdminAdded(a);\n', '            adminLog.push(a);\n', '        } else {\n', '            emit AdminRemoved(a);\n', '        }\n', '    }\n', '\n', '    // safety feature if admins go bad or something\n', '    function incAdminEpoch() only_owner() external {\n', '        currAdminEpoch++;\n', '        admins[currAdminEpoch][msg.sender] = true;\n', '        emit AdminEpochInc();\n', '    }\n', '\n', '    // this is internal so contracts can all it, but not exposed anywhere in this\n', '    // contract.\n', '    function disableAdminForever() internal {\n', '        currAdminEpoch++;\n', '        adminsDisabledForever = true;\n', '        emit AdminDisabledForever();\n', '    }\n', '}\n', '\n', 'contract permissioned is owned, hasAdmins {\n', '    mapping (address => bool) editAllowed;\n', '    bool public adminLockdown = false;\n', '\n', '    event PermissionError(address editAddr);\n', '    event PermissionGranted(address editAddr);\n', '    event PermissionRevoked(address editAddr);\n', '    event PermissionsUpgraded(address oldSC, address newSC);\n', '    event SelfUpgrade(address oldSC, address newSC);\n', '    event AdminLockdown();\n', '\n', '    modifier only_editors() {\n', '        require(editAllowed[msg.sender], "only_editors: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier no_lockdown() {\n', '        require(adminLockdown == false, "no_lockdown: check failed");\n', '        _;\n', '    }\n', '\n', '\n', '    constructor() owned() hasAdmins() public {\n', '    }\n', '\n', '\n', '    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\n', '        editAllowed[e] = _editPerms;\n', '        if (_editPerms)\n', '            emit PermissionGranted(e);\n', '        else\n', '            emit PermissionRevoked(e);\n', '    }\n', '\n', '    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\n', '        editAllowed[oldSC] = false;\n', '        editAllowed[newSC] = true;\n', '        emit PermissionsUpgraded(oldSC, newSC);\n', '    }\n', '\n', '    // always allow SCs to upgrade themselves, even after lockdown\n', '    function upgradeMe(address newSC) only_editors() external {\n', '        editAllowed[msg.sender] = false;\n', '        editAllowed[newSC] = true;\n', '        emit SelfUpgrade(msg.sender, newSC);\n', '    }\n', '\n', '    function hasPermissions(address a) public view returns (bool) {\n', '        return editAllowed[a];\n', '    }\n', '\n', '    function doLockdown() external only_owner() no_lockdown() {\n', '        disableAdminForever();\n', '        adminLockdown = true;\n', '        emit AdminLockdown();\n', '    }\n', '}\n', '\n', 'contract upgradePtr {\n', '    address ptr = address(0);\n', '\n', '    modifier not_upgraded() {\n', '        require(ptr == address(0), "upgrade pointer is non-zero");\n', '        _;\n', '    }\n', '\n', '    function getUpgradePointer() view external returns (address) {\n', '        return ptr;\n', '    }\n', '\n', '    function doUpgradeInternal(address nextSC) internal {\n', '        ptr = nextSC;\n', '    }\n', '}\n', '\n', 'interface ERC20Interface {\n', '    // Get the total token supply\n', '    function totalSupply() constant external returns (uint256 _totalSupply);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}']
