['pragma solidity 0.4.25;\n', '\n', 'library SafeMath8 {\n', '\n', '    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint8 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint8 a, uint8 b) internal pure returns (uint8) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint8 a, uint8 b) internal pure returns (uint8) {\n', '        uint8 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function pow(uint8 a, uint8 b) internal pure returns (uint8) {\n', '        if (a == 0) return 0;\n', '        if (b == 0) return 1;\n', '\n', '        uint8 c = a ** b;\n', '        assert(c / (a ** (b - 1)) == a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library SafeMath16 {\n', '\n', '    function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint16 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint16 a, uint16 b) internal pure returns (uint16) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint16 a, uint16 b) internal pure returns (uint16) {\n', '        uint16 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function pow(uint16 a, uint16 b) internal pure returns (uint16) {\n', '        if (a == 0) return 0;\n', '        if (b == 0) return 1;\n', '\n', '        uint16 c = a ** b;\n', '        assert(c / (a ** (b - 1)) == a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library SafeMath32 {\n', '\n', '    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint32 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint32 a, uint32 b) internal pure returns (uint32) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint32 a, uint32 b) internal pure returns (uint32) {\n', '        uint32 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function pow(uint32 a, uint32 b) internal pure returns (uint32) {\n', '        if (a == 0) return 0;\n', '        if (b == 0) return 1;\n', '\n', '        uint32 c = a ** b;\n', '        assert(c / (a ** (b - 1)) == a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library SafeMath256 {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        if (b == 0) return 1;\n', '\n', '        uint256 c = a ** b;\n', '        assert(c / (a ** (b - 1)) == a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function _validateAddress(address _addr) internal pure {\n', '        require(_addr != address(0), "invalid address");\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "not a contract owner");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _validateAddress(newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused, "contract is paused");\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused() {\n', '        require(paused, "contract is not paused");\n', '        _;\n', '    }\n', '\n', '    function pause() public onlyOwner whenNotPaused {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    function unpause() public onlyOwner whenPaused {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', 'contract Controllable is Ownable {\n', '    mapping(address => bool) controllers;\n', '\n', '    modifier onlyController {\n', '        require(_isController(msg.sender), "no controller rights");\n', '        _;\n', '    }\n', '\n', '    function _isController(address _controller) internal view returns (bool) {\n', '        return controllers[_controller];\n', '    }\n', '\n', '    function _setControllers(address[] _controllers) internal {\n', '        for (uint256 i = 0; i < _controllers.length; i++) {\n', '            _validateAddress(_controllers[i]);\n', '            controllers[_controllers[i]] = true;\n', '        }\n', '    }\n', '}\n', '\n', 'contract Upgradable is Controllable {\n', '    address[] internalDependencies;\n', '    address[] externalDependencies;\n', '\n', '    function getInternalDependencies() public view returns(address[]) {\n', '        return internalDependencies;\n', '    }\n', '\n', '    function getExternalDependencies() public view returns(address[]) {\n', '        return externalDependencies;\n', '    }\n', '\n', '    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\n', '        for (uint256 i = 0; i < _newDependencies.length; i++) {\n', '            _validateAddress(_newDependencies[i]);\n', '        }\n', '        internalDependencies = _newDependencies;\n', '    }\n', '\n', '    function setExternalDependencies(address[] _newDependencies) public onlyOwner {\n', '        externalDependencies = _newDependencies;\n', '        _setControllers(_newDependencies);\n', '    }\n', '}\n', '\n', 'contract Getter {\n', '    function getDragonProfile(uint256) external view returns (bytes32, uint16, uint256, uint8, uint8, uint16, bool, uint32);\n', '    function getDragonStrength(uint256) external view returns (uint32);\n', '    function getDragonCurrentHealthAndMana(uint256) external view returns (uint32, uint32, uint8, uint8);\n', '    function getDragonHealthAndMana(uint256) external view returns (uint256, uint32, uint32, uint32, uint32);\n', '    function getDragonsAmount() external view returns (uint256);\n', '    function isDragonOwner(address, uint256) external view returns (bool);\n', '    function ownerOfDragon(uint256) public view returns (address);\n', '    function isDragonInGladiatorBattle(uint256) public view returns (bool);\n', '}\n', '\n', 'contract Core is Upgradable {\n', '    function setDragonRemainingHealthAndMana(uint256, uint32, uint32) external;\n', '    function increaseDragonExperience(uint256, uint256) external;\n', '    function increaseDragonWins(uint256) external;\n', '    function increaseDragonDefeats(uint256) external;\n', '    function resetDragonBuffs(uint256) external;\n', '    function getDragonFullRegenerationTime(uint256) external view returns (uint32);\n', '}\n', '\n', 'contract Battle {\n', '    function start(uint256, uint256, uint8[2], uint8[2], uint256, bool) external returns (uint256[2], uint32, uint32, uint32, uint32, uint256);\n', '}\n', '\n', 'contract Treasury {\n', '    uint256 public hatchingPrice;\n', '    function giveGold(address, uint256) external;\n', '    function remainingGold() external view returns (uint256);\n', '}\n', '\n', 'contract Random {\n', '    function random(uint256) external view returns (uint256);\n', '}\n', '\n', '\n', '\n', '\n', '//////////////CONTRACT//////////////\n', '\n', '\n', '\n', '\n', 'contract BattleController is Upgradable {\n', '    using SafeMath8 for uint8;\n', '    using SafeMath16 for uint16;\n', '    using SafeMath32 for uint32;\n', '    using SafeMath256 for uint256;\n', '\n', '    Core core;\n', '    Battle battle;\n', '    Treasury treasury;\n', '    Getter getter;\n', '    Random random;\n', '\n', '    // stores date to which dragon is untouchable as opponent for the battle\n', '    mapping (uint256 => uint256) lastBattleDate;\n', '\n', '    uint8 constant MAX_PERCENTAGE = 100;\n', '    uint8 constant MIN_HEALTH_PERCENTAGE = 50;\n', '    uint8 constant MAX_TACTICS_PERCENTAGE = 80;\n', '    uint8 constant MIN_TACTICS_PERCENTAGE = 20;\n', '    uint8 constant PERCENT_MULTIPLIER = 100;\n', '    uint8 constant DRAGON_STRENGTH_DIFFERENCE_PERCENTAGE = 10;\n', '\n', '    uint256 constant GOLD_REWARD_MULTIPLIER = 10 ** 18;\n', '\n', '    function _min(uint256 lth, uint256 rth) internal pure returns (uint256) {\n', '        return lth > rth ? rth : lth;\n', '    }\n', '\n', '    function _isTouchable(uint256 _id) internal view returns (bool) {\n', '        uint32 _regenerationTime = core.getDragonFullRegenerationTime(_id);\n', '        return lastBattleDate[_id].add(_regenerationTime.mul(4)) < now;\n', '    }\n', '\n', '    function _checkBattlePossibility(\n', '        address _sender,\n', '        uint256 _id,\n', '        uint256 _opponentId,\n', '        uint8[2] _tactics\n', '    ) internal view {\n', '        require(getter.isDragonOwner(_sender, _id), "not an owner");\n', '        require(!getter.isDragonOwner(_sender, _opponentId), "can\'t be owner of opponent dragon");\n', '        require(!getter.isDragonOwner(address(0), _opponentId), "opponent dragon has no owner");\n', '\n', '        require(!getter.isDragonInGladiatorBattle(_id), "your dragon participates in gladiator battle");\n', '        require(!getter.isDragonInGladiatorBattle(_opponentId), "opponent dragon participates in gladiator battle");\n', '\n', '        require(_isTouchable(_opponentId), "opponent dragon is untouchable");\n', '\n', '        require(\n', '            _tactics[0] >= MIN_TACTICS_PERCENTAGE &&\n', '            _tactics[0] <= MAX_TACTICS_PERCENTAGE &&\n', '            _tactics[1] >= MIN_TACTICS_PERCENTAGE &&\n', '            _tactics[1] <= MAX_TACTICS_PERCENTAGE,\n', '            "tactics value must be between 20 and 80"\n', '        );\n', '\n', '        uint8 _attackerHealthPercentage;\n', '        uint8 _attackerManaPercentage;\n', '        ( , , _attackerHealthPercentage, _attackerManaPercentage) = getter.getDragonCurrentHealthAndMana(_id);\n', '        require(\n', '            _attackerHealthPercentage >= MIN_HEALTH_PERCENTAGE,\n', '            "dragon\'s health less than 50%"\n', '        );\n', '        uint8 _opponentHealthPercentage;\n', '        uint8 _opponentManaPercentage;\n', '        ( , , _opponentHealthPercentage, _opponentManaPercentage) = getter.getDragonCurrentHealthAndMana(_opponentId);\n', '        require(\n', '            _opponentHealthPercentage == MAX_PERCENTAGE &&\n', '            _opponentManaPercentage == MAX_PERCENTAGE,\n', '            "opponent health and/or mana is not full"\n', '        );\n', '    }\n', '\n', '    function startBattle(\n', '        address _sender,\n', '        uint256 _id,\n', '        uint256 _opponentId,\n', '        uint8[2] _tactics\n', '    ) external onlyController returns (\n', '        uint256 battleId,\n', '        uint256 seed,\n', '        uint256[2] winnerLooserIds\n', '    ) {\n', '        _checkBattlePossibility(_sender, _id, _opponentId, _tactics);\n', '\n', '        seed = random.random(2**256 - 1);\n', '\n', '        uint32 _winnerHealth;\n', '        uint32 _winnerMana;\n', '        uint32 _looserHealth;\n', '        uint32 _looserMana;\n', '\n', '        (\n', '            winnerLooserIds,\n', '            _winnerHealth, _winnerMana,\n', '            _looserHealth, _looserMana,\n', '            battleId\n', '        ) = battle.start(\n', '            _id,\n', '            _opponentId,\n', '            _tactics,\n', '            [0, 0],\n', '            seed,\n', '            false\n', '        );\n', '\n', '        core.setDragonRemainingHealthAndMana(winnerLooserIds[0], _winnerHealth, _winnerMana);\n', '        core.setDragonRemainingHealthAndMana(winnerLooserIds[1], _looserHealth, _looserMana);\n', '\n', '        core.increaseDragonWins(winnerLooserIds[0]);\n', '        core.increaseDragonDefeats(winnerLooserIds[1]);\n', '\n', '        lastBattleDate[_opponentId] = now;\n', '\n', '        _payBattleRewards(\n', '            _sender,\n', '            _id,\n', '            _opponentId,\n', '            winnerLooserIds[0]\n', '        );\n', '    }\n', '\n', '    function _payBattleRewards(\n', '        address _sender,\n', '        uint256 _id,\n', '        uint256 _opponentId,\n', '        uint256 _winnerId\n', '    ) internal {\n', '        uint32 _strength = getter.getDragonStrength(_id);\n', '        uint32 _opponentStrength = getter.getDragonStrength(_opponentId);\n', '        bool _isAttackerWinner = _id == _winnerId;\n', '\n', '        uint256 _xpFactor = _calculateExperience(_isAttackerWinner, _strength, _opponentStrength);\n', '        core.increaseDragonExperience(_winnerId, _xpFactor);\n', '\n', '        if (_isAttackerWinner) {\n', '            uint256 _factor = _calculateGoldRewardFactor(_strength, _opponentStrength);\n', '            _payGoldReward(_sender, _id, _factor);\n', '        }\n', '    }\n', '\n', '    function _calculateExperience(\n', '        bool _isAttackerWinner,\n', '        uint32 _attackerStrength,\n', '        uint32 _opponentStrength\n', '    ) internal pure returns (uint256) {\n', '\n', '        uint8 _attackerFactor;\n', '        uint256 _winnerStrength;\n', '        uint256 _looserStrength;\n', '\n', '        uint8 _degree;\n', '\n', '        if (_isAttackerWinner) {\n', '            _attackerFactor = 10;\n', '            _winnerStrength = _attackerStrength;\n', '            _looserStrength = _opponentStrength;\n', '            _degree = _winnerStrength <= _looserStrength ? 2 : 5;\n', '        } else {\n', '            _attackerFactor = 5;\n', '            _winnerStrength = _opponentStrength;\n', '            _looserStrength = _attackerStrength;\n', '            _degree = _winnerStrength <= _looserStrength ? 1 : 5;\n', '        }\n', '\n', '        uint256 _factor = _looserStrength.pow(_degree).mul(_attackerFactor).div(_winnerStrength.pow(_degree));\n', '\n', '        if (_isAttackerWinner) {\n', '            return _factor;\n', '        }\n', '        return _min(_factor, 10); // 1\n', '    }\n', '\n', '    function _calculateGoldRewardFactor(\n', '        uint256 _winnerStrength,\n', '        uint256 _looserStrength\n', '    ) internal pure returns (uint256) {\n', '        uint8 _degree = _winnerStrength <= _looserStrength ? 1 : 8;\n', '        return _looserStrength.pow(_degree).mul(GOLD_REWARD_MULTIPLIER).div(_winnerStrength.pow(_degree));\n', '    }\n', '\n', '    function _getMaxGoldReward(\n', '        uint256 _hatchingPrice,\n', '        uint256 _dragonsAmount\n', '    ) internal pure returns (uint256) {\n', '        uint8 _factor;\n', '\n', '        if (_dragonsAmount < 15000) _factor = 20;\n', '        else if (_dragonsAmount < 30000) _factor = 10;\n', '        else _factor = 5;\n', '\n', '        return _hatchingPrice.mul(_factor).div(PERCENT_MULTIPLIER);\n', '    }\n', '\n', '    function _payGoldReward(\n', '        address _sender,\n', '        uint256 _id,\n', '        uint256 _factor\n', '    ) internal {\n', '        uint256 _goldRemain = treasury.remainingGold();\n', '        uint256 _dragonsAmount = getter.getDragonsAmount();\n', '        uint32 _coolness;\n', '        (, , , , , , , _coolness) = getter.getDragonProfile(_id);\n', '        uint256 _hatchingPrice = treasury.hatchingPrice();\n', '        // dragon coolness is multyplied by 100\n', '        uint256 _value = _goldRemain.mul(_coolness).mul(10).div(_dragonsAmount.pow(2)).div(100);\n', '        _value = _value.mul(_factor).div(GOLD_REWARD_MULTIPLIER);\n', '\n', '        uint256 _maxReward = _getMaxGoldReward(_hatchingPrice, _dragonsAmount);\n', '        if (_value > _maxReward) _value = _maxReward;\n', '        if (_value > _goldRemain) _value = _goldRemain;\n', '        treasury.giveGold(_sender, _value);\n', '    }\n', '\n', '    struct Opponent {\n', '        uint256 id;\n', '        uint256 timestamp;\n', '        uint32 strength;\n', '    }\n', '\n', '    function _iterateTimestampIndex(uint8 _index) internal pure returns (uint8) {\n', '        return _index < 5 ? _index.add(1) : 0;\n', '    }\n', '\n', '    function _getPercentOfValue(uint32 _value, uint8 _percent) internal pure returns (uint32) {\n', '        return _value.mul(_percent).div(PERCENT_MULTIPLIER);\n', '    }\n', '\n', '    function matchOpponents(uint256 _attackerId) external view returns (uint256[6]) {\n', '        uint32 _attackerStrength = getter.getDragonStrength(_attackerId);\n', '        uint32 _strengthDiff = _getPercentOfValue(_attackerStrength, DRAGON_STRENGTH_DIFFERENCE_PERCENTAGE);\n', '        uint32 _minStrength = _attackerStrength.sub(_strengthDiff);\n', '        uint32 _maxStrength = _attackerStrength.add(_strengthDiff);\n', '        uint32 _strength;\n', '        uint256 _timestamp; // usually the date of the last battle\n', '        uint8 _timestampIndex;\n', '        uint8 _healthPercentage;\n', '        uint8 _manaPercentage;\n', '\n', '        address _owner = getter.ownerOfDragon(_attackerId);\n', '\n', '        Opponent[6] memory _opponents;\n', '        _opponents[0].timestamp =\n', '        _opponents[1].timestamp =\n', '        _opponents[2].timestamp =\n', '        _opponents[3].timestamp =\n', '        _opponents[4].timestamp =\n', '        _opponents[5].timestamp = now;\n', '\n', '        for (uint256 _id = 1; _id <= getter.getDragonsAmount(); _id++) { // no dragon with id = 0\n', '\n', '            if (\n', '                _attackerId != _id\n', '                && !getter.isDragonOwner(_owner, _id)\n', '                && !getter.isDragonInGladiatorBattle(_id)\n', '                && _isTouchable(_id)\n', '            ) {\n', '                _strength = getter.getDragonStrength(_id);\n', '                if (_strength >= _minStrength && _strength <= _maxStrength) {\n', '\n', '                    ( , , _healthPercentage, _manaPercentage) = getter.getDragonCurrentHealthAndMana(_id);\n', '                    if (_healthPercentage == MAX_PERCENTAGE && _manaPercentage == MAX_PERCENTAGE) {\n', '\n', '                        (_timestamp, , , , ) = getter.getDragonHealthAndMana(_id);\n', '                        if (_timestamp < _opponents[_timestampIndex].timestamp) {\n', '\n', '                            _opponents[_timestampIndex] = Opponent(_id, _timestamp, _strength);\n', '                            _timestampIndex = _iterateTimestampIndex(_timestampIndex);\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        return [\n', '            _opponents[0].id,\n', '            _opponents[1].id,\n', '            _opponents[2].id,\n', '            _opponents[3].id,\n', '            _opponents[4].id,\n', '            _opponents[5].id\n', '        ];\n', '    }\n', '\n', '    function resetDragonBuffs(uint256 _id) external onlyController {\n', '        core.resetDragonBuffs(_id);\n', '    }\n', '\n', '    // UPDATE CONTRACT\n', '\n', '    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\n', '        super.setInternalDependencies(_newDependencies);\n', '\n', '        core = Core(_newDependencies[0]);\n', '        battle = Battle(_newDependencies[1]);\n', '        treasury = Treasury(_newDependencies[2]);\n', '        getter = Getter(_newDependencies[3]);\n', '        random = Random(_newDependencies[4]);\n', '    }\n', '}']