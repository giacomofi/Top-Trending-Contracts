['pragma solidity ^0.4.13;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract PausableToken is Ownable {\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function increaseFrozen(address _owner,uint256 _incrementalAmount) public returns (bool);\n', '    function burn(uint256 _value) public;\n', '}\n', '\n', 'contract AddressWhitelist is Ownable {\n', '    // the addresses that are included in the whitelist\n', '    mapping (address => bool) whitelisted;\n', '    \n', '    function isWhitelisted(address addr) view public returns (bool) {\n', '        return whitelisted[addr];\n', '    }\n', '\n', '    event LogWhitelistAdd(address indexed addr);\n', '\n', '    // add these addresses to the whitelist\n', '    function addToWhitelist(address[] addresses) public onlyOwner returns (bool) {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            if (!whitelisted[addresses[i]]) {\n', '                whitelisted[addresses[i]] = true;\n', '                LogWhitelistAdd(addresses[i]);\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    event LogWhitelistRemove(address indexed addr);\n', '\n', '    // remove these addresses from the whitelist\n', '    function removeFromWhitelist(address[] addresses) public onlyOwner returns (bool) {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            if (whitelisted[addresses[i]]) {\n', '                whitelisted[addresses[i]] = false;\n', '                LogWhitelistRemove(addresses[i]);\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract HorseTokenCrowdsale is Ownable, AddressWhitelist {\n', '    using SafeMath for uint256;\n', '    PausableToken  public tokenReward;                         // address of the token used as reward\n', '\n', '    // deployment variables for static supply sale\n', '    uint256 public initialSupply;\n', '    uint256 public tokensRemaining;\n', '    uint256 public decimals;\n', '\n', '    // multi-sig addresses and price variable\n', '    address public beneficiaryWallet;                           // beneficiaryMultiSig (founder group) or wallet account\n', '    uint256 public tokensPerEthPrice;                           // set initial value floating priceVar 10,000 tokens per Eth\n', '\n', '    // uint256 values for min,max,caps,tracking\n', '    uint256 public amountRaisedInWei;\n', '    uint256 public fundingMinCapInWei;\n', '\n', '    // pricing veriable\n', '    uint256 public p1_duration;\n', '    uint256 public p2_start;\n', '    uint256 public p1_white_duration;\n', '\n', '    // loop control, ICO startup and limiters\n', '    uint256 public fundingStartTime;                           // crowdsale start time#\n', '    uint256 public fundingEndTime;                             // crowdsale end time#\n', '    bool    public isCrowdSaleClosed               = false;     // crowdsale completion boolean\n', '    bool    public areFundsReleasedToBeneficiary   = false;     // boolean for founder to receive Eth or not\n', '    bool    public isCrowdSaleSetup                = false;     // boolean for crowdsale setup\n', '\n', '    // Gas price limit\n', '    uint256 maxGasPrice = 50000000000;\n', '\n', '    event Buy(address indexed _sender, uint256 _eth, uint256 _HORSE);\n', '    event Refund(address indexed _refunder, uint256 _value);\n', '    mapping(address => uint256) fundValue;\n', '\n', '\n', '    // convert tokens to decimals\n', '    function toPony(uint256 amount) public constant returns (uint256) {\n', '        return amount.mul(10**decimals);\n', '    }\n', '\n', '    // convert tokens to whole\n', '    function toHorse(uint256 amount) public constant returns (uint256) {\n', '        return amount.div(10**decimals);\n', '    }\n', '\n', '    function updateMaxGasPrice(uint256 _newGasPrice) public onlyOwner {\n', '        require(_newGasPrice != 0);\n', '        maxGasPrice = _newGasPrice;\n', '    }\n', '\n', '    // setup the CrowdSale parameters\n', '    function setupCrowdsale(uint256 _fundingStartTime) external onlyOwner {\n', '        if ((!(isCrowdSaleSetup))\n', '            && (!(beneficiaryWallet > 0))){\n', '            // init addresses\n', '            tokenReward                             = PausableToken(0x5B0751713b2527d7f002c0c4e2a37e1219610A6B);\n', '            beneficiaryWallet                       = 0xEb0B40a8bE19160Ca63076aE67357B1a10c8C31A;\n', '            tokensPerEthPrice                       = 12500;\n', '\n', '            // funding targets\n', '            fundingMinCapInWei                      = 400 ether;                          //400 Eth (min cap) - crowdsale is considered success after this value\n', '\n', '            // update values\n', '            decimals                                = 18;\n', '            amountRaisedInWei                       = 0;\n', '            initialSupply                           = toPony(100000000);                  //   100 million * 18 decimal\n', '            tokensRemaining                         = initialSupply;\n', '\n', '            fundingStartTime                        = _fundingStartTime;\n', '            p1_duration                             = 7 days;\n', '            p1_white_duration                       = 1 days;\n', '            \n', '            p2_start                                = fundingStartTime + p1_duration + 6 days;\n', '\n', '            fundingEndTime                          = p2_start + 4 weeks;\n', '\n', '            // configure crowdsale\n', '            isCrowdSaleSetup                        = true;\n', '            isCrowdSaleClosed                       = false;\n', '        }\n', '    }\n', '\n', '    function setBonusPrice() public constant returns (uint256 bonus) {\n', '        require(isCrowdSaleSetup);\n', '        require(fundingStartTime + p1_duration <= p2_start );\n', '        if (now >= fundingStartTime && now <= fundingStartTime + p1_duration) { // Phase-1 Bonus    +100% = 25,000 HORSE  = 1 ETH\n', '            bonus = 12500;\n', '        } else if (now > p2_start && now <= p2_start + 1 days ) { // Phase-2 day-1 Bonus +50% = 18,750 HORSE = 1 ETH\n', '            bonus = 6250;\n', '        } else if (now > p2_start + 1 days && now <= p2_start + 1 weeks ) { // Phase-2 week-1 Bonus +20% = 15,000 HORSE = 1 ETH\n', '            bonus = 2500;\n', '        } else if (now > p2_start + 1 weeks && now <= p2_start + 2 weeks ) { // Phase-2 week-2 Bonus +10% = 13,750 HORSE = 1 ETH\n', '            bonus = 1250;\n', '        } else if (now > p2_start + 2 weeks && now <= fundingEndTime ) { // Phase-2 week-3& week-4 Bonus +0% = 12,500 HORSE = 1 ETH\n', '            bonus = 0;\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    // p1_duration constant. Only p2 start changes. p2 start cannot be greater than 1 month from p1 end\n', '    function updateDuration(uint256 _newP2Start) external onlyOwner { // function to update the duration of phase-1 and adjust the start time of phase-2\n', '        require( isCrowdSaleSetup\n', '            && !(p2_start == _newP2Start)\n', '            && !(_newP2Start > fundingStartTime + p1_duration + 30 days)\n', '            && (now < p2_start)\n', '            && (fundingStartTime + p1_duration < _newP2Start));\n', '        p2_start = _newP2Start;\n', '        fundingEndTime = p2_start.add(4 weeks);\n', '    }\n', '\n', '    // default payable function when sending ether to this contract\n', '    function () external payable {\n', '        require(tx.gasprice <= maxGasPrice);\n', '        require(msg.data.length == 0);\n', '        \n', '        BuyHORSEtokens();\n', '    }\n', '\n', '    function BuyHORSEtokens() public payable {\n', '        // conditions (length, crowdsale setup, zero check, exceed funding contrib check, contract valid check, within funding block range check, balance overflow check etc)\n', '        require(!(msg.value == 0)\n', '        && (isCrowdSaleSetup)\n', '        && (now >= fundingStartTime)\n', '        && (now <= fundingEndTime)\n', '        && (tokensRemaining > 0));\n', '\n', '        // only whitelisted addresses are allowed during the first day of phase 1\n', '        if (now <= fundingStartTime + p1_white_duration) {\n', '            assert(isWhitelisted(msg.sender));\n', '        }\n', '        uint256 rewardTransferAmount        = 0;\n', '        uint256 rewardBaseTransferAmount    = 0;\n', '        uint256 rewardBonusTransferAmount   = 0;\n', '        uint256 contributionInWei           = msg.value;\n', '        uint256 refundInWei                 = 0;\n', '\n', '        rewardBonusTransferAmount       = setBonusPrice();\n', '        rewardBaseTransferAmount        = (msg.value.mul(tokensPerEthPrice)); // Since both ether and HORSE have 18 decimals, No need of conversion\n', '        rewardBonusTransferAmount       = (msg.value.mul(rewardBonusTransferAmount)); // Since both ether and HORSE have 18 decimals, No need of conversion\n', '        rewardTransferAmount            = rewardBaseTransferAmount.add(rewardBonusTransferAmount);\n', '\n', '        if (rewardTransferAmount > tokensRemaining) {\n', '            uint256 partialPercentage;\n', '            partialPercentage = tokensRemaining.mul(10**18).div(rewardTransferAmount);\n', '            contributionInWei = contributionInWei.mul(partialPercentage).div(10**18);\n', '            rewardBonusTransferAmount = rewardBonusTransferAmount.mul(partialPercentage).div(10**18);\n', '            rewardTransferAmount = tokensRemaining;\n', '            refundInWei = msg.value.sub(contributionInWei);\n', '        }\n', '\n', '        amountRaisedInWei               = amountRaisedInWei.add(contributionInWei);\n', '        tokensRemaining                 = tokensRemaining.sub(rewardTransferAmount);  // will cause throw if attempt to purchase over the token limit in one tx or at all once limit reached\n', '        fundValue[msg.sender]           = fundValue[msg.sender].add(contributionInWei);\n', '        assert(tokenReward.increaseFrozen(msg.sender, rewardBonusTransferAmount));\n', '        tokenReward.transfer(msg.sender, rewardTransferAmount);\n', '        Buy(msg.sender, contributionInWei, rewardTransferAmount);\n', '        if (refundInWei > 0) {\n', '            msg.sender.transfer(refundInWei);\n', '        }\n', '    }\n', '\n', '    function beneficiaryMultiSigWithdraw() external onlyOwner {\n', '        checkGoalReached();\n', '        require(areFundsReleasedToBeneficiary && (amountRaisedInWei >= fundingMinCapInWei));\n', '        beneficiaryWallet.transfer(this.balance);\n', '    }\n', '\n', '    function checkGoalReached() public returns (bytes32 response) { // return crowdfund status to owner for each result case, update public constant\n', '        // update state & status variables\n', '        require (isCrowdSaleSetup);\n', '        if ((amountRaisedInWei < fundingMinCapInWei) && (block.timestamp <= fundingEndTime && block.timestamp >= fundingStartTime)) { // ICO in progress, under softcap\n', '            areFundsReleasedToBeneficiary = false;\n', '            isCrowdSaleClosed = false;\n', '            return "In progress (Eth < Softcap)";\n', '        } else if ((amountRaisedInWei < fundingMinCapInWei) && (block.timestamp < fundingStartTime)) { // ICO has not started\n', '            areFundsReleasedToBeneficiary = false;\n', '            isCrowdSaleClosed = false;\n', '            return "Crowdsale is setup";\n', '        } else if ((amountRaisedInWei < fundingMinCapInWei) && (block.timestamp > fundingEndTime)) { // ICO ended, under softcap\n', '            areFundsReleasedToBeneficiary = false;\n', '            isCrowdSaleClosed = true;\n', '            return "Unsuccessful (Eth < Softcap)";\n', '        } else if ((amountRaisedInWei >= fundingMinCapInWei) && (tokensRemaining == 0)) { // ICO ended, all tokens gone\n', '            areFundsReleasedToBeneficiary = true;\n', '            isCrowdSaleClosed = true;\n', '            return "Successful (HORSE >= Hardcap)!";\n', '        } else if ((amountRaisedInWei >= fundingMinCapInWei) && (block.timestamp > fundingEndTime) && (tokensRemaining > 0)) { // ICO ended, over softcap!\n', '            areFundsReleasedToBeneficiary = true;\n', '            isCrowdSaleClosed = true;\n', '            return "Successful (Eth >= Softcap)!";\n', '        } else if ((amountRaisedInWei >= fundingMinCapInWei) && (tokensRemaining > 0) && (block.timestamp <= fundingEndTime)) { // ICO in progress, over softcap!\n', '            areFundsReleasedToBeneficiary = true;\n', '            isCrowdSaleClosed = false;\n', '            return "In progress (Eth >= Softcap)!";\n', '        }\n', '    }\n', '\n', "    function refund() external { // any contributor can call this to have their Eth returned. user's purchased HORSE tokens are burned prior refund of Eth.\n", '        checkGoalReached();\n', '        //require minCap not reached\n', '        require ((amountRaisedInWei < fundingMinCapInWei)\n', '        && (isCrowdSaleClosed)\n', '        && (now > fundingEndTime)\n', '        && (fundValue[msg.sender] > 0));\n', '\n', '        //refund Eth sent\n', '        uint256 ethRefund = fundValue[msg.sender];\n', '        fundValue[msg.sender] = 0;\n', '\n', '        //send Eth back, burn tokens\n', '        msg.sender.transfer(ethRefund);\n', '        Refund(msg.sender, ethRefund);\n', '    }\n', '\n', '    function burnRemainingTokens() onlyOwner external {\n', '        require(now > fundingEndTime);\n', '        uint256 tokensToBurn = tokenReward.balanceOf(this);\n', '        tokenReward.burn(tokensToBurn);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']