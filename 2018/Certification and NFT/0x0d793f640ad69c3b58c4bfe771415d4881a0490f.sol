['pragma solidity ^0.4.19;\n', '\n', '// File: contracts/ClaimRegistry.sol\n', '\n', 'contract ClaimRegistry {\n', '    function getSingleSubjectByAddress(address linkedAddress, uint subjectIndex) public view returns(address subject);\n', '    function getSubjectClaimSetSize(address subject, uint typeNameIx, uint attrNameIx) public constant returns (uint) ;\n', '    function getSubjectClaimSetEntryAt(address subject, uint typeNameIx, uint attrNameIx, uint ix) public constant returns (address issuer, uint url);\n', '    function getSubjectCountByAddress(address linkedAddress) public view returns(uint subjectCount);\n', ' }\n', '\n', '// File: contracts/NotakeyVerifierForICOP.sol\n', '\n', 'contract NotakeyVerifierForICOP {\n', '\n', '    uint public constant ICO_CONTRIBUTOR_TYPE = 6;\n', '    uint public constant REPORT_BUNDLE = 6;\n', '    uint public constant NATIONALITY_INDEX = 7;\n', '\n', '    address public claimRegistryAddr;\n', '    address public trustedIssuerAddr;\n', '    // address private callerIdentitySubject;\n', '\n', '    uint public constant USA = 883423532389192164791648750371459257913741948437809479060803100646309888;\n', '        // USA is 240nd; blacklist: 1 << (240-1)\n', '    uint public constant CHINA = 8796093022208;\n', '        // China is 44th; blacklist: 1 << (44-1)\n', '    uint public constant SOUTH_KOREA = 83076749736557242056487941267521536;\n', '        // SK is 117th; blacklist: 1 << (117-1)\n', '\n', '     event GotUnregisteredPaymentAddress(address indexed paymentAddress);\n', '\n', '\n', '    function NotakeyVerifierForICOP(address _trustedIssuerAddr, address _claimRegistryAddr) public {\n', '        claimRegistryAddr = _claimRegistryAddr;\n', '        trustedIssuerAddr  = _trustedIssuerAddr;\n', '    }\n', '\n', '    modifier onlyVerifiedSenders(address paymentAddress, uint256 nationalityBlacklist) {\n', '        // DISABLED for ICOP sale\n', '        // require(_hasIcoContributorType(paymentAddress));\n', '        require(!_preventedByNationalityBlacklist(paymentAddress, nationalityBlacklist));\n', '\n', '        _;\n', '    }\n', '\n', '    function sanityCheck() public pure returns (string) {\n', '        return "Hello Dashboard";\n', '    }\n', '\n', '    function isVerified(address subject, uint256 nationalityBlacklist) public constant onlyVerifiedSenders(subject, nationalityBlacklist) returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function _preventedByNationalityBlacklist(\n', '        address paymentAddress,\n', '        uint256 nationalityBlacklist) internal constant returns (bool)\n', '    {\n', '        var claimRegistry = ClaimRegistry(claimRegistryAddr);\n', '\n', '        uint subjectCount = _lookupOwnerIdentityCount(paymentAddress);\n', '\n', '        uint256 ignoredClaims;\n', '        uint claimCount;\n', '        address subject;\n', '\n', '        // Loop over all isued identities associated to this wallet adress and\n', '        // throw if any match to blacklist\n', '        for (uint subjectIndex = 0 ; subjectIndex < subjectCount ; subjectIndex++ ){\n', '            subject = claimRegistry.getSingleSubjectByAddress(paymentAddress, subjectIndex);\n', '            claimCount = claimRegistry.getSubjectClaimSetSize(subject, ICO_CONTRIBUTOR_TYPE, NATIONALITY_INDEX);\n', '            ignoredClaims = 0;\n', '\n', '            for (uint i = 0; i < claimCount; ++i) {\n', '                var (issuer, url) = claimRegistry.getSubjectClaimSetEntryAt(subject, ICO_CONTRIBUTOR_TYPE, NATIONALITY_INDEX, i);\n', '                var countryMask = 2**(url-1);\n', '\n', '                if (issuer != trustedIssuerAddr) {\n', '                    ignoredClaims += 1;\n', '                } else {\n', '                    if (((countryMask ^ nationalityBlacklist) & countryMask) != countryMask) {\n', '                        return true;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        // If the blacklist is empty (0), then that&#39;s fine for the V1 contract (where we validate the bundle);\n', '        // For our own sale, however, this attribute is a proxy indicator for whether the address is verified.\n', '        //\n', '        // Account for ignored claims (issued by unrecognized issuers)\n', '        require((claimCount - ignoredClaims) > 0);\n', '\n', '        return false;\n', '    }\n', '\n', '    function _lookupOwnerIdentityCount(address paymentAddress) internal constant returns (uint){\n', '        var claimRegistry = ClaimRegistry(claimRegistryAddr);\n', '        var subjectCount = claimRegistry.getSubjectCountByAddress(paymentAddress);\n', '\n', '        // The address is unregistered so we throw and log event\n', '        // This method and callers have to overriden as non-constant to emit events\n', '        // if ( subjectCount == 0 ) {\n', '            // GotUnregisteredPaymentAddress( paymentAddress );\n', '            // revert();\n', '        // }\n', '\n', '        require(subjectCount > 0);\n', '\n', '        return subjectCount;\n', '    }\n', '\n', '    function _hasIcoContributorType(address paymentAddress) internal constant returns (bool)\n', '    {\n', '        uint subjectCount = _lookupOwnerIdentityCount(paymentAddress);\n', '\n', '        var atLeastOneValidReport = false;\n', '        var atLeastOneValidNationality = false;\n', '        address subject;\n', '\n', '        var claimRegistry = ClaimRegistry(claimRegistryAddr);\n', '\n', '        // Loop over all isued identities associated to this wallet address and\n', '        // exit loop any satisfy the business logic requirement\n', '        for (uint subjectIndex = 0 ; subjectIndex < subjectCount ; subjectIndex++ ){\n', '            subject = claimRegistry.getSingleSubjectByAddress(paymentAddress, subjectIndex);\n', '\n', '            var nationalityCount = claimRegistry.getSubjectClaimSetSize(subject, ICO_CONTRIBUTOR_TYPE, NATIONALITY_INDEX);\n', '            for (uint nationalityIndex = 0; nationalityIndex < nationalityCount; ++nationalityIndex) {\n', '                var (nationalityIssuer,) = claimRegistry.getSubjectClaimSetEntryAt(subject, ICO_CONTRIBUTOR_TYPE, NATIONALITY_INDEX, nationalityIndex);\n', '                if (nationalityIssuer == trustedIssuerAddr) {\n', '                    atLeastOneValidNationality = true;\n', '                    break;\n', '                }\n', '            }\n', '\n', '            var reportCount = claimRegistry.getSubjectClaimSetSize(subject, ICO_CONTRIBUTOR_TYPE, REPORT_BUNDLE);\n', '            for (uint reportIndex = 0; reportIndex < reportCount; ++reportIndex) {\n', '                var (reportIssuer,) = claimRegistry.getSubjectClaimSetEntryAt(subject, ICO_CONTRIBUTOR_TYPE, REPORT_BUNDLE, reportIndex);\n', '                if (reportIssuer == trustedIssuerAddr) {\n', '                    atLeastOneValidReport = true;\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '\n', '        return atLeastOneValidNationality && atLeastOneValidReport;\n', '    }\n', '}\n', '\n', '// File: contracts/SecondPriceAuction.sol\n', '\n', '//! Copyright Parity Technologies, 2017.\n', '//! (original version: https://github.com/paritytech/second-price-auction)\n', '//!\n', '//! Copyright Notakey Latvia SIA, 2017.\n', '//! Original version modified to verify contributors against Notakey\n', '//! KYC smart contract.\n', '//!\n', '//! Released under the Apache Licence 2.\n', '\n', 'pragma solidity ^0.4.19;\n', '\n', '\n', '\n', '/// Stripped down ERC20 standard token interface.\n', 'contract Token {\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '}\n', '\n', '/// Simple modified second price auction contract. Price starts high and monotonically decreases\n', '/// until all tokens are sold at the current price with currently received funds.\n', '/// The price curve has been chosen to resemble a logarithmic curve\n', '/// and produce a reasonable auction timeline.\n', 'contract SecondPriceAuction {\n', '\t// Events:\n', '\n', '\t/// Someone bought in at a particular max-price.\n', '\tevent Buyin(address indexed who, uint accounted, uint received, uint price);\n', '\n', '\t/// Admin injected a purchase.\n', '\tevent Injected(address indexed who, uint accounted, uint received);\n', '\n', '\t/// At least 5 minutes has passed since last Ticked event.\n', '\tevent Ticked(uint era, uint received, uint accounted);\n', '\n', '\t/// The sale just ended with the current price.\n', '\tevent Ended(uint price);\n', '\n', '\t/// Finalised the purchase for `who`, who has been given `tokens` tokens.\n', '\tevent Finalised(address indexed who, uint tokens);\n', '\n', '\t/// Auction is over. All accounts finalised.\n', '\tevent Retired();\n', '\n', '\t// Constructor:\n', '\n', '\t/// Simple constructor.\n', '\t/// Token cap should take be in smallest divisible units.\n', '\t/// \tNOTE: original SecondPriceAuction contract stipulates token cap must be given in whole tokens.\n', '\t///\t\tThis does not seem correct, as only whole token values are transferred via transferFrom (which - in our wallet&#39;s case -\n', '\t///     expects transfers in the smallest divisible amount)\n', '\tfunction SecondPriceAuction(\n', '\t\taddress _trustedClaimIssuer,\n', '\t\taddress _notakeyClaimRegistry,\n', '\t\taddress _tokenContract,\n', '\t\taddress _treasury,\n', '\t\taddress _admin,\n', '\t\tuint _beginTime,\n', '\t\tuint _tokenCap\n', '\t)\n', '\t\tpublic\n', '\t{\n', '\t\t// this contract must be created by the notakey claim issuer (sender)\n', '\t\tverifier = new NotakeyVerifierForICOP(_trustedClaimIssuer, _notakeyClaimRegistry);\n', '\n', '\t\ttokenContract = Token(_tokenContract);\n', '\t\ttreasury = _treasury;\n', '\t\tadmin = _admin;\n', '\t\tbeginTime = _beginTime;\n', '\t\ttokenCap = _tokenCap;\n', '\t\tendTime = beginTime + DEFAULT_AUCTION_LENGTH;\n', '\t}\n', '\n', '\tfunction() public payable { buyin(); }\n', '\n', '\t// Public interaction:\n', '\tfunction moveStartDate(uint newStart)\n', '\t\tpublic\n', '\t\tbefore_beginning\n', '\t\tonly_admin\n', '\t{\n', '\t\tbeginTime = newStart;\n', '\t\tendTime = calculateEndTime();\n', '\t}\n', '\n', '\t/// Buyin function. Throws if the sale is not active and when refund would be needed.\n', '\tfunction buyin()\n', '\t\tpublic\n', '\t\tpayable\n', '\t\twhen_not_halted\n', '\t\twhen_active\n', '\t\tonly_eligible(msg.sender)\n', '\t{\n', '\t\tflushEra();\n', '\n', '\t\t// Flush bonus period:\n', '\t\tif (currentBonus > 0) {\n', '\t\t\t// Bonus is currently active...\n', '\t\t\tif (now >= beginTime + BONUS_MIN_DURATION\t\t\t\t// ...but outside the automatic bonus period\n', '\t\t\t\t&& lastNewInterest + BONUS_LATCH <= block.number\t// ...and had no new interest for some blocks\n', '\t\t\t) {\n', '\t\t\t\tcurrentBonus--;\n', '\t\t\t}\n', '\t\t\tif (now >= beginTime + BONUS_MAX_DURATION) {\n', '\t\t\t\tcurrentBonus = 0;\n', '\t\t\t}\n', '\t\t\tif (buyins[msg.sender].received == 0) {\t// We have new interest\n', '\t\t\t\tlastNewInterest = uint32(block.number);\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\tuint accounted;\n', '\t\tbool refund;\n', '\t\tuint price;\n', '\t\t(accounted, refund, price) = theDeal(msg.value);\n', '\n', '\t\t/// No refunds allowed.\n', '\t\trequire (!refund);\n', '\n', '\t\t// record the acceptance.\n', '\t\tbuyins[msg.sender].accounted += uint128(accounted);\n', '\t\tbuyins[msg.sender].received += uint128(msg.value);\n', '\t\ttotalAccounted += accounted;\n', '\t\ttotalReceived += msg.value;\n', '\t\tendTime = calculateEndTime();\n', '\t\tBuyin(msg.sender, accounted, msg.value, price);\n', '\n', '\t\t// send to treasury\n', '\t\ttreasury.transfer(msg.value);\n', '\t}\n', '\n', '\t/// Like buyin except no payment required and bonus automatically given.\n', '\tfunction inject(address _who, uint128 _received)\n', '\t\tpublic\n', '\t\tonly_admin\n', '\t\tonly_basic(_who)\n', '\t\tbefore_beginning\n', '\t{\n', '\t\tuint128 bonus = _received * uint128(currentBonus) / 100;\n', '\t\tuint128 accounted = _received + bonus;\n', '\n', '\t\tbuyins[_who].accounted += accounted;\n', '\t\tbuyins[_who].received += _received;\n', '\t\ttotalAccounted += accounted;\n', '\t\ttotalReceived += _received;\n', '\t\tendTime = calculateEndTime();\n', '\t\tInjected(_who, accounted, _received);\n', '\t}\n', '\n', '\t/// Mint tokens for a particular participant.\n', '\tfunction finalise(address _who)\n', '\t\tpublic\n', '\t\twhen_not_halted\n', '\t\twhen_ended\n', '\t\tonly_buyins(_who)\n', '\t{\n', '\t\t// end the auction if we&#39;re the first one to finalise.\n', '\t\tif (endPrice == 0) {\n', '\t\t\tendPrice = totalAccounted / tokenCap;\n', '\t\t\tEnded(endPrice);\n', '\t\t}\n', '\n', '\t\t// enact the purchase.\n', '\t\tuint total = buyins[_who].accounted;\n', '\t\tuint tokens = total / endPrice;\n', '\t\ttotalFinalised += total;\n', '\t\tdelete buyins[_who];\n', '\t\trequire (tokenContract.transferFrom(treasury, _who, tokens));\n', '\n', '\t\tFinalised(_who, tokens);\n', '\n', '\t\tif (totalFinalised == totalAccounted) {\n', '\t\t\tRetired();\n', '\t\t}\n', '\t}\n', '\n', '\t// Prviate utilities:\n', '\n', '\t/// Ensure the era tracker is prepared in case the current changed.\n', '\tfunction flushEra() private {\n', '\t\tuint currentEra = (now - beginTime) / ERA_PERIOD;\n', '\t\tif (currentEra > eraIndex) {\n', '\t\t\tTicked(eraIndex, totalReceived, totalAccounted);\n', '\t\t}\n', '\t\teraIndex = currentEra;\n', '\t}\n', '\n', '\t// Admin interaction:\n', '\n', '\t/// Emergency function to pause buy-in and finalisation.\n', '\tfunction setHalted(bool _halted) public only_admin { halted = _halted; }\n', '\n', '\t/// Emergency function to drain the contract of any funds.\n', '\tfunction drain() public only_admin { treasury.transfer(this.balance); }\n', '\n', '\t// Inspection:\n', '\n', '\t/// The current end time of the sale assuming that nobody else buys in.\n', '\tfunction calculateEndTime() public constant returns (uint) {\n', '\t\tvar factor = tokenCap / DIVISOR * EURWEI;\n', '\t\tuint16 scaleDownRatio = 1; // 1 for prod\n', '\t\treturn beginTime + (182035 * factor / (totalAccounted + factor / 10 ) - 0) / scaleDownRatio;\n', '\t}\n', '\n', '\t/// The current price for a single indivisible part of a token. If a buyin happens now, this is\n', '\t/// the highest price per indivisible token part that the buyer will pay. This doesn&#39;t\n', '\t/// include the discount which may be available.\n', '\tfunction currentPrice() public constant when_active returns (uint weiPerIndivisibleTokenPart) {\n', '\t\treturn ((EURWEI * 184325000 / (now - beginTime + 5760) - EURWEI*5) / DIVISOR);\n', '\t}\n', '\n', '\t/// Returns the total indivisible token parts available for purchase right now.\n', '\tfunction tokensAvailable() public constant when_active returns (uint tokens) {\n', '\t\tuint _currentCap = totalAccounted / currentPrice();\n', '\t\tif (_currentCap >= tokenCap) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\treturn tokenCap - _currentCap;\n', '\t}\n', '\n', '\t/// The largest purchase than can be made at present, not including any\n', '\t/// discount.\n', '\tfunction maxPurchase() public constant when_active returns (uint spend) {\n', '\t\treturn tokenCap * currentPrice() - totalAccounted;\n', '\t}\n', '\n', '\t/// Get the number of `tokens` that would be given if the sender were to\n', '\t/// spend `_value` now. Also tell you what `refund` would be given, if any.\n', '\tfunction theDeal(uint _value)\n', '\t\tpublic\n', '\t\tconstant\n', '\t\twhen_active\n', '\t\treturns (uint accounted, bool refund, uint price)\n', '\t{\n', '\t\tuint _bonus = bonus(_value);\n', '\n', '\t\tprice = currentPrice();\n', '\t\taccounted = _value + _bonus;\n', '\n', '\t\tuint available = tokensAvailable();\n', '\t\tuint tokens = accounted / price;\n', '\t\trefund = (tokens > available);\n', '\t}\n', '\n', '\t/// Any applicable bonus to `_value`.\n', '\tfunction bonus(uint _value)\n', '\t\tpublic\n', '\t\tconstant\n', '\t\twhen_active\n', '\t\treturns (uint extra)\n', '\t{\n', '\t\treturn _value * uint(currentBonus) / 100;\n', '\t}\n', '\n', '\t/// True if the sale is ongoing.\n', '\tfunction isActive() public constant returns (bool) { return now >= beginTime && now < endTime; }\n', '\n', '\t/// True if all buyins have finalised.\n', '\tfunction allFinalised() public constant returns (bool) { return now >= endTime && totalAccounted == totalFinalised; }\n', '\n', '\t/// Returns true if the sender of this transaction is a basic account.\n', '\tfunction isBasicAccount(address _who) internal constant returns (bool) {\n', '\t\tuint senderCodeSize;\n', '\t\tassembly {\n', '\t\t\tsenderCodeSize := extcodesize(_who)\n', '\t\t}\n', '\t    return senderCodeSize == 0;\n', '\t}\n', '\n', '\t// Modifiers:\n', '\n', '\t/// Ensure the sale is ongoing.\n', '\tmodifier when_active { require (isActive()); _; }\n', '\n', '\t/// Ensure the sale has not begun.\n', '\tmodifier before_beginning { require (now < beginTime); _; }\n', '\n', '\t/// Ensure the sale is ended.\n', '\tmodifier when_ended { require (now >= endTime); _; }\n', '\n', '\t/// Ensure we&#39;re not halted.\n', '\tmodifier when_not_halted { require (!halted); _; }\n', '\n', '\t/// Ensure `_who` is a participant.\n', '\tmodifier only_buyins(address _who) { require (buyins[_who].accounted != 0); _; }\n', '\n', '\t/// Ensure sender is admin.\n', '\tmodifier only_admin { require (msg.sender == admin); _; }\n', '\n', '\t/// Ensure that the signature is valid, `who` is a certified, basic account,\n', '\t/// the gas price is sufficiently low and the value is sufficiently high.\n', '\tmodifier only_eligible(address who) {\n', '\t\trequire (\n', '\t\t\tverifier.isVerified(who, verifier.USA() | verifier.CHINA() | verifier.SOUTH_KOREA()) &&\n', '\t\t\tisBasicAccount(who) &&\n', '\t\t\tmsg.value >= DUST_LIMIT\n', '\t\t);\n', '\t\t_;\n', '\t}\n', '\n', '\t/// Ensure sender is not a contract.\n', '\tmodifier only_basic(address who) { require (isBasicAccount(who)); _; }\n', '\n', '\t// State:\n', '\n', '\tstruct Account {\n', '\t\tuint128 accounted;\t// including bonus & hit\n', '\t\tuint128 received;\t// just the amount received, without bonus & hit\n', '\t}\n', '\n', '\t/// Those who have bought in to the auction.\n', '\tmapping (address => Account) public buyins;\n', '\n', '\t/// Total amount of ether received, excluding phantom "bonus" ether.\n', '\tuint public totalReceived = 0;\n', '\n', '\t/// Total amount of ether accounted for, including phantom "bonus" ether.\n', '\tuint public totalAccounted = 0;\n', '\n', '\t/// Total amount of ether which has been finalised.\n', '\tuint public totalFinalised = 0;\n', '\n', '\t/// The current end time. Gets updated when new funds are received.\n', '\tuint public endTime;\n', '\n', '\t/// The price per token; only valid once the sale has ended and at least one\n', '\t/// participant has finalised.\n', '\tuint public endPrice;\n', '\n', '\t/// Must be false for any public function to be called.\n', '\tbool public halted;\n', '\n', '\t/// The current percentage of bonus that purchasers get.\n', '\tuint8 public currentBonus = 15;\n', '\n', '\t/// The last block that had a new participant.\n', '\tuint32 public lastNewInterest;\n', '\n', '\t// Constants after constructor:\n', '\n', '\t/// The tokens contract.\n', '\tToken public tokenContract;\n', '\n', '\t/// The Notakey verifier contract.\n', '\tNotakeyVerifierForICOP public verifier;\n', '\n', '\t/// The treasury address; where all the Ether goes.\n', '\taddress public treasury;\n', '\n', '\t/// The admin address; auction can be paused or halted at any time by this.\n', '\taddress public admin;\n', '\n', '\t/// The time at which the sale begins.\n', '\tuint public beginTime;\n', '\n', '\t/// Maximum amount of tokens to mint. Once totalAccounted / currentPrice is\n', '\t/// greater than this, the sale ends.\n', '\tuint public tokenCap;\n', '\n', '\t// Era stuff (isolated)\n', '\t/// The era for which the current consolidated data represents.\n', '\tuint public eraIndex;\n', '\n', '\t/// The size of the era in seconds.\n', '\tuint constant public ERA_PERIOD = 5 minutes;\n', '\n', '\t// Static constants:\n', '\n', '\t/// Anything less than this is considered dust and cannot be used to buy in.\n', '\tuint constant public DUST_LIMIT = 5 finney;\n', '\n', '\t//# Statement to actually sign.\n', '\t//# ```js\n', '\t//# statement = function() { this.STATEMENT().map(s => s.substr(28)) }\n', '\t//# ```\n', '\n', '\t/// Minimum duration after sale begins that bonus is active.\n', '\tuint constant public BONUS_MIN_DURATION = 1 hours;\n', '\n', '\t/// Minimum duration after sale begins that bonus is active.\n', '\tuint constant public BONUS_MAX_DURATION = 12 hours;\n', '\n', '\t/// Number of consecutive blocks where there must be no new interest before bonus ends.\n', '\tuint constant public BONUS_LATCH = 2;\n', '\n', '\t/// Number of Wei in one EUR, constant.\n', '\tuint constant public EURWEI = 2000 szabo; // 500 eur ~ 1 eth\n', '\n', '\t/// Initial auction length\n', '\tuint constant public DEFAULT_AUCTION_LENGTH = 2 days;\n', '\n', '\t/// Divisor of the token.\n', '\tuint constant public DIVISOR = 1000;\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '// File: contracts/ClaimRegistry.sol\n', '\n', 'contract ClaimRegistry {\n', '    function getSingleSubjectByAddress(address linkedAddress, uint subjectIndex) public view returns(address subject);\n', '    function getSubjectClaimSetSize(address subject, uint typeNameIx, uint attrNameIx) public constant returns (uint) ;\n', '    function getSubjectClaimSetEntryAt(address subject, uint typeNameIx, uint attrNameIx, uint ix) public constant returns (address issuer, uint url);\n', '    function getSubjectCountByAddress(address linkedAddress) public view returns(uint subjectCount);\n', ' }\n', '\n', '// File: contracts/NotakeyVerifierForICOP.sol\n', '\n', 'contract NotakeyVerifierForICOP {\n', '\n', '    uint public constant ICO_CONTRIBUTOR_TYPE = 6;\n', '    uint public constant REPORT_BUNDLE = 6;\n', '    uint public constant NATIONALITY_INDEX = 7;\n', '\n', '    address public claimRegistryAddr;\n', '    address public trustedIssuerAddr;\n', '    // address private callerIdentitySubject;\n', '\n', '    uint public constant USA = 883423532389192164791648750371459257913741948437809479060803100646309888;\n', '        // USA is 240nd; blacklist: 1 << (240-1)\n', '    uint public constant CHINA = 8796093022208;\n', '        // China is 44th; blacklist: 1 << (44-1)\n', '    uint public constant SOUTH_KOREA = 83076749736557242056487941267521536;\n', '        // SK is 117th; blacklist: 1 << (117-1)\n', '\n', '     event GotUnregisteredPaymentAddress(address indexed paymentAddress);\n', '\n', '\n', '    function NotakeyVerifierForICOP(address _trustedIssuerAddr, address _claimRegistryAddr) public {\n', '        claimRegistryAddr = _claimRegistryAddr;\n', '        trustedIssuerAddr  = _trustedIssuerAddr;\n', '    }\n', '\n', '    modifier onlyVerifiedSenders(address paymentAddress, uint256 nationalityBlacklist) {\n', '        // DISABLED for ICOP sale\n', '        // require(_hasIcoContributorType(paymentAddress));\n', '        require(!_preventedByNationalityBlacklist(paymentAddress, nationalityBlacklist));\n', '\n', '        _;\n', '    }\n', '\n', '    function sanityCheck() public pure returns (string) {\n', '        return "Hello Dashboard";\n', '    }\n', '\n', '    function isVerified(address subject, uint256 nationalityBlacklist) public constant onlyVerifiedSenders(subject, nationalityBlacklist) returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function _preventedByNationalityBlacklist(\n', '        address paymentAddress,\n', '        uint256 nationalityBlacklist) internal constant returns (bool)\n', '    {\n', '        var claimRegistry = ClaimRegistry(claimRegistryAddr);\n', '\n', '        uint subjectCount = _lookupOwnerIdentityCount(paymentAddress);\n', '\n', '        uint256 ignoredClaims;\n', '        uint claimCount;\n', '        address subject;\n', '\n', '        // Loop over all isued identities associated to this wallet adress and\n', '        // throw if any match to blacklist\n', '        for (uint subjectIndex = 0 ; subjectIndex < subjectCount ; subjectIndex++ ){\n', '            subject = claimRegistry.getSingleSubjectByAddress(paymentAddress, subjectIndex);\n', '            claimCount = claimRegistry.getSubjectClaimSetSize(subject, ICO_CONTRIBUTOR_TYPE, NATIONALITY_INDEX);\n', '            ignoredClaims = 0;\n', '\n', '            for (uint i = 0; i < claimCount; ++i) {\n', '                var (issuer, url) = claimRegistry.getSubjectClaimSetEntryAt(subject, ICO_CONTRIBUTOR_TYPE, NATIONALITY_INDEX, i);\n', '                var countryMask = 2**(url-1);\n', '\n', '                if (issuer != trustedIssuerAddr) {\n', '                    ignoredClaims += 1;\n', '                } else {\n', '                    if (((countryMask ^ nationalityBlacklist) & countryMask) != countryMask) {\n', '                        return true;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', "        // If the blacklist is empty (0), then that's fine for the V1 contract (where we validate the bundle);\n", '        // For our own sale, however, this attribute is a proxy indicator for whether the address is verified.\n', '        //\n', '        // Account for ignored claims (issued by unrecognized issuers)\n', '        require((claimCount - ignoredClaims) > 0);\n', '\n', '        return false;\n', '    }\n', '\n', '    function _lookupOwnerIdentityCount(address paymentAddress) internal constant returns (uint){\n', '        var claimRegistry = ClaimRegistry(claimRegistryAddr);\n', '        var subjectCount = claimRegistry.getSubjectCountByAddress(paymentAddress);\n', '\n', '        // The address is unregistered so we throw and log event\n', '        // This method and callers have to overriden as non-constant to emit events\n', '        // if ( subjectCount == 0 ) {\n', '            // GotUnregisteredPaymentAddress( paymentAddress );\n', '            // revert();\n', '        // }\n', '\n', '        require(subjectCount > 0);\n', '\n', '        return subjectCount;\n', '    }\n', '\n', '    function _hasIcoContributorType(address paymentAddress) internal constant returns (bool)\n', '    {\n', '        uint subjectCount = _lookupOwnerIdentityCount(paymentAddress);\n', '\n', '        var atLeastOneValidReport = false;\n', '        var atLeastOneValidNationality = false;\n', '        address subject;\n', '\n', '        var claimRegistry = ClaimRegistry(claimRegistryAddr);\n', '\n', '        // Loop over all isued identities associated to this wallet address and\n', '        // exit loop any satisfy the business logic requirement\n', '        for (uint subjectIndex = 0 ; subjectIndex < subjectCount ; subjectIndex++ ){\n', '            subject = claimRegistry.getSingleSubjectByAddress(paymentAddress, subjectIndex);\n', '\n', '            var nationalityCount = claimRegistry.getSubjectClaimSetSize(subject, ICO_CONTRIBUTOR_TYPE, NATIONALITY_INDEX);\n', '            for (uint nationalityIndex = 0; nationalityIndex < nationalityCount; ++nationalityIndex) {\n', '                var (nationalityIssuer,) = claimRegistry.getSubjectClaimSetEntryAt(subject, ICO_CONTRIBUTOR_TYPE, NATIONALITY_INDEX, nationalityIndex);\n', '                if (nationalityIssuer == trustedIssuerAddr) {\n', '                    atLeastOneValidNationality = true;\n', '                    break;\n', '                }\n', '            }\n', '\n', '            var reportCount = claimRegistry.getSubjectClaimSetSize(subject, ICO_CONTRIBUTOR_TYPE, REPORT_BUNDLE);\n', '            for (uint reportIndex = 0; reportIndex < reportCount; ++reportIndex) {\n', '                var (reportIssuer,) = claimRegistry.getSubjectClaimSetEntryAt(subject, ICO_CONTRIBUTOR_TYPE, REPORT_BUNDLE, reportIndex);\n', '                if (reportIssuer == trustedIssuerAddr) {\n', '                    atLeastOneValidReport = true;\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '\n', '        return atLeastOneValidNationality && atLeastOneValidReport;\n', '    }\n', '}\n', '\n', '// File: contracts/SecondPriceAuction.sol\n', '\n', '//! Copyright Parity Technologies, 2017.\n', '//! (original version: https://github.com/paritytech/second-price-auction)\n', '//!\n', '//! Copyright Notakey Latvia SIA, 2017.\n', '//! Original version modified to verify contributors against Notakey\n', '//! KYC smart contract.\n', '//!\n', '//! Released under the Apache Licence 2.\n', '\n', 'pragma solidity ^0.4.19;\n', '\n', '\n', '\n', '/// Stripped down ERC20 standard token interface.\n', 'contract Token {\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '}\n', '\n', '/// Simple modified second price auction contract. Price starts high and monotonically decreases\n', '/// until all tokens are sold at the current price with currently received funds.\n', '/// The price curve has been chosen to resemble a logarithmic curve\n', '/// and produce a reasonable auction timeline.\n', 'contract SecondPriceAuction {\n', '\t// Events:\n', '\n', '\t/// Someone bought in at a particular max-price.\n', '\tevent Buyin(address indexed who, uint accounted, uint received, uint price);\n', '\n', '\t/// Admin injected a purchase.\n', '\tevent Injected(address indexed who, uint accounted, uint received);\n', '\n', '\t/// At least 5 minutes has passed since last Ticked event.\n', '\tevent Ticked(uint era, uint received, uint accounted);\n', '\n', '\t/// The sale just ended with the current price.\n', '\tevent Ended(uint price);\n', '\n', '\t/// Finalised the purchase for `who`, who has been given `tokens` tokens.\n', '\tevent Finalised(address indexed who, uint tokens);\n', '\n', '\t/// Auction is over. All accounts finalised.\n', '\tevent Retired();\n', '\n', '\t// Constructor:\n', '\n', '\t/// Simple constructor.\n', '\t/// Token cap should take be in smallest divisible units.\n', '\t/// \tNOTE: original SecondPriceAuction contract stipulates token cap must be given in whole tokens.\n', "\t///\t\tThis does not seem correct, as only whole token values are transferred via transferFrom (which - in our wallet's case -\n", '\t///     expects transfers in the smallest divisible amount)\n', '\tfunction SecondPriceAuction(\n', '\t\taddress _trustedClaimIssuer,\n', '\t\taddress _notakeyClaimRegistry,\n', '\t\taddress _tokenContract,\n', '\t\taddress _treasury,\n', '\t\taddress _admin,\n', '\t\tuint _beginTime,\n', '\t\tuint _tokenCap\n', '\t)\n', '\t\tpublic\n', '\t{\n', '\t\t// this contract must be created by the notakey claim issuer (sender)\n', '\t\tverifier = new NotakeyVerifierForICOP(_trustedClaimIssuer, _notakeyClaimRegistry);\n', '\n', '\t\ttokenContract = Token(_tokenContract);\n', '\t\ttreasury = _treasury;\n', '\t\tadmin = _admin;\n', '\t\tbeginTime = _beginTime;\n', '\t\ttokenCap = _tokenCap;\n', '\t\tendTime = beginTime + DEFAULT_AUCTION_LENGTH;\n', '\t}\n', '\n', '\tfunction() public payable { buyin(); }\n', '\n', '\t// Public interaction:\n', '\tfunction moveStartDate(uint newStart)\n', '\t\tpublic\n', '\t\tbefore_beginning\n', '\t\tonly_admin\n', '\t{\n', '\t\tbeginTime = newStart;\n', '\t\tendTime = calculateEndTime();\n', '\t}\n', '\n', '\t/// Buyin function. Throws if the sale is not active and when refund would be needed.\n', '\tfunction buyin()\n', '\t\tpublic\n', '\t\tpayable\n', '\t\twhen_not_halted\n', '\t\twhen_active\n', '\t\tonly_eligible(msg.sender)\n', '\t{\n', '\t\tflushEra();\n', '\n', '\t\t// Flush bonus period:\n', '\t\tif (currentBonus > 0) {\n', '\t\t\t// Bonus is currently active...\n', '\t\t\tif (now >= beginTime + BONUS_MIN_DURATION\t\t\t\t// ...but outside the automatic bonus period\n', '\t\t\t\t&& lastNewInterest + BONUS_LATCH <= block.number\t// ...and had no new interest for some blocks\n', '\t\t\t) {\n', '\t\t\t\tcurrentBonus--;\n', '\t\t\t}\n', '\t\t\tif (now >= beginTime + BONUS_MAX_DURATION) {\n', '\t\t\t\tcurrentBonus = 0;\n', '\t\t\t}\n', '\t\t\tif (buyins[msg.sender].received == 0) {\t// We have new interest\n', '\t\t\t\tlastNewInterest = uint32(block.number);\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\tuint accounted;\n', '\t\tbool refund;\n', '\t\tuint price;\n', '\t\t(accounted, refund, price) = theDeal(msg.value);\n', '\n', '\t\t/// No refunds allowed.\n', '\t\trequire (!refund);\n', '\n', '\t\t// record the acceptance.\n', '\t\tbuyins[msg.sender].accounted += uint128(accounted);\n', '\t\tbuyins[msg.sender].received += uint128(msg.value);\n', '\t\ttotalAccounted += accounted;\n', '\t\ttotalReceived += msg.value;\n', '\t\tendTime = calculateEndTime();\n', '\t\tBuyin(msg.sender, accounted, msg.value, price);\n', '\n', '\t\t// send to treasury\n', '\t\ttreasury.transfer(msg.value);\n', '\t}\n', '\n', '\t/// Like buyin except no payment required and bonus automatically given.\n', '\tfunction inject(address _who, uint128 _received)\n', '\t\tpublic\n', '\t\tonly_admin\n', '\t\tonly_basic(_who)\n', '\t\tbefore_beginning\n', '\t{\n', '\t\tuint128 bonus = _received * uint128(currentBonus) / 100;\n', '\t\tuint128 accounted = _received + bonus;\n', '\n', '\t\tbuyins[_who].accounted += accounted;\n', '\t\tbuyins[_who].received += _received;\n', '\t\ttotalAccounted += accounted;\n', '\t\ttotalReceived += _received;\n', '\t\tendTime = calculateEndTime();\n', '\t\tInjected(_who, accounted, _received);\n', '\t}\n', '\n', '\t/// Mint tokens for a particular participant.\n', '\tfunction finalise(address _who)\n', '\t\tpublic\n', '\t\twhen_not_halted\n', '\t\twhen_ended\n', '\t\tonly_buyins(_who)\n', '\t{\n', "\t\t// end the auction if we're the first one to finalise.\n", '\t\tif (endPrice == 0) {\n', '\t\t\tendPrice = totalAccounted / tokenCap;\n', '\t\t\tEnded(endPrice);\n', '\t\t}\n', '\n', '\t\t// enact the purchase.\n', '\t\tuint total = buyins[_who].accounted;\n', '\t\tuint tokens = total / endPrice;\n', '\t\ttotalFinalised += total;\n', '\t\tdelete buyins[_who];\n', '\t\trequire (tokenContract.transferFrom(treasury, _who, tokens));\n', '\n', '\t\tFinalised(_who, tokens);\n', '\n', '\t\tif (totalFinalised == totalAccounted) {\n', '\t\t\tRetired();\n', '\t\t}\n', '\t}\n', '\n', '\t// Prviate utilities:\n', '\n', '\t/// Ensure the era tracker is prepared in case the current changed.\n', '\tfunction flushEra() private {\n', '\t\tuint currentEra = (now - beginTime) / ERA_PERIOD;\n', '\t\tif (currentEra > eraIndex) {\n', '\t\t\tTicked(eraIndex, totalReceived, totalAccounted);\n', '\t\t}\n', '\t\teraIndex = currentEra;\n', '\t}\n', '\n', '\t// Admin interaction:\n', '\n', '\t/// Emergency function to pause buy-in and finalisation.\n', '\tfunction setHalted(bool _halted) public only_admin { halted = _halted; }\n', '\n', '\t/// Emergency function to drain the contract of any funds.\n', '\tfunction drain() public only_admin { treasury.transfer(this.balance); }\n', '\n', '\t// Inspection:\n', '\n', '\t/// The current end time of the sale assuming that nobody else buys in.\n', '\tfunction calculateEndTime() public constant returns (uint) {\n', '\t\tvar factor = tokenCap / DIVISOR * EURWEI;\n', '\t\tuint16 scaleDownRatio = 1; // 1 for prod\n', '\t\treturn beginTime + (182035 * factor / (totalAccounted + factor / 10 ) - 0) / scaleDownRatio;\n', '\t}\n', '\n', '\t/// The current price for a single indivisible part of a token. If a buyin happens now, this is\n', "\t/// the highest price per indivisible token part that the buyer will pay. This doesn't\n", '\t/// include the discount which may be available.\n', '\tfunction currentPrice() public constant when_active returns (uint weiPerIndivisibleTokenPart) {\n', '\t\treturn ((EURWEI * 184325000 / (now - beginTime + 5760) - EURWEI*5) / DIVISOR);\n', '\t}\n', '\n', '\t/// Returns the total indivisible token parts available for purchase right now.\n', '\tfunction tokensAvailable() public constant when_active returns (uint tokens) {\n', '\t\tuint _currentCap = totalAccounted / currentPrice();\n', '\t\tif (_currentCap >= tokenCap) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\treturn tokenCap - _currentCap;\n', '\t}\n', '\n', '\t/// The largest purchase than can be made at present, not including any\n', '\t/// discount.\n', '\tfunction maxPurchase() public constant when_active returns (uint spend) {\n', '\t\treturn tokenCap * currentPrice() - totalAccounted;\n', '\t}\n', '\n', '\t/// Get the number of `tokens` that would be given if the sender were to\n', '\t/// spend `_value` now. Also tell you what `refund` would be given, if any.\n', '\tfunction theDeal(uint _value)\n', '\t\tpublic\n', '\t\tconstant\n', '\t\twhen_active\n', '\t\treturns (uint accounted, bool refund, uint price)\n', '\t{\n', '\t\tuint _bonus = bonus(_value);\n', '\n', '\t\tprice = currentPrice();\n', '\t\taccounted = _value + _bonus;\n', '\n', '\t\tuint available = tokensAvailable();\n', '\t\tuint tokens = accounted / price;\n', '\t\trefund = (tokens > available);\n', '\t}\n', '\n', '\t/// Any applicable bonus to `_value`.\n', '\tfunction bonus(uint _value)\n', '\t\tpublic\n', '\t\tconstant\n', '\t\twhen_active\n', '\t\treturns (uint extra)\n', '\t{\n', '\t\treturn _value * uint(currentBonus) / 100;\n', '\t}\n', '\n', '\t/// True if the sale is ongoing.\n', '\tfunction isActive() public constant returns (bool) { return now >= beginTime && now < endTime; }\n', '\n', '\t/// True if all buyins have finalised.\n', '\tfunction allFinalised() public constant returns (bool) { return now >= endTime && totalAccounted == totalFinalised; }\n', '\n', '\t/// Returns true if the sender of this transaction is a basic account.\n', '\tfunction isBasicAccount(address _who) internal constant returns (bool) {\n', '\t\tuint senderCodeSize;\n', '\t\tassembly {\n', '\t\t\tsenderCodeSize := extcodesize(_who)\n', '\t\t}\n', '\t    return senderCodeSize == 0;\n', '\t}\n', '\n', '\t// Modifiers:\n', '\n', '\t/// Ensure the sale is ongoing.\n', '\tmodifier when_active { require (isActive()); _; }\n', '\n', '\t/// Ensure the sale has not begun.\n', '\tmodifier before_beginning { require (now < beginTime); _; }\n', '\n', '\t/// Ensure the sale is ended.\n', '\tmodifier when_ended { require (now >= endTime); _; }\n', '\n', "\t/// Ensure we're not halted.\n", '\tmodifier when_not_halted { require (!halted); _; }\n', '\n', '\t/// Ensure `_who` is a participant.\n', '\tmodifier only_buyins(address _who) { require (buyins[_who].accounted != 0); _; }\n', '\n', '\t/// Ensure sender is admin.\n', '\tmodifier only_admin { require (msg.sender == admin); _; }\n', '\n', '\t/// Ensure that the signature is valid, `who` is a certified, basic account,\n', '\t/// the gas price is sufficiently low and the value is sufficiently high.\n', '\tmodifier only_eligible(address who) {\n', '\t\trequire (\n', '\t\t\tverifier.isVerified(who, verifier.USA() | verifier.CHINA() | verifier.SOUTH_KOREA()) &&\n', '\t\t\tisBasicAccount(who) &&\n', '\t\t\tmsg.value >= DUST_LIMIT\n', '\t\t);\n', '\t\t_;\n', '\t}\n', '\n', '\t/// Ensure sender is not a contract.\n', '\tmodifier only_basic(address who) { require (isBasicAccount(who)); _; }\n', '\n', '\t// State:\n', '\n', '\tstruct Account {\n', '\t\tuint128 accounted;\t// including bonus & hit\n', '\t\tuint128 received;\t// just the amount received, without bonus & hit\n', '\t}\n', '\n', '\t/// Those who have bought in to the auction.\n', '\tmapping (address => Account) public buyins;\n', '\n', '\t/// Total amount of ether received, excluding phantom "bonus" ether.\n', '\tuint public totalReceived = 0;\n', '\n', '\t/// Total amount of ether accounted for, including phantom "bonus" ether.\n', '\tuint public totalAccounted = 0;\n', '\n', '\t/// Total amount of ether which has been finalised.\n', '\tuint public totalFinalised = 0;\n', '\n', '\t/// The current end time. Gets updated when new funds are received.\n', '\tuint public endTime;\n', '\n', '\t/// The price per token; only valid once the sale has ended and at least one\n', '\t/// participant has finalised.\n', '\tuint public endPrice;\n', '\n', '\t/// Must be false for any public function to be called.\n', '\tbool public halted;\n', '\n', '\t/// The current percentage of bonus that purchasers get.\n', '\tuint8 public currentBonus = 15;\n', '\n', '\t/// The last block that had a new participant.\n', '\tuint32 public lastNewInterest;\n', '\n', '\t// Constants after constructor:\n', '\n', '\t/// The tokens contract.\n', '\tToken public tokenContract;\n', '\n', '\t/// The Notakey verifier contract.\n', '\tNotakeyVerifierForICOP public verifier;\n', '\n', '\t/// The treasury address; where all the Ether goes.\n', '\taddress public treasury;\n', '\n', '\t/// The admin address; auction can be paused or halted at any time by this.\n', '\taddress public admin;\n', '\n', '\t/// The time at which the sale begins.\n', '\tuint public beginTime;\n', '\n', '\t/// Maximum amount of tokens to mint. Once totalAccounted / currentPrice is\n', '\t/// greater than this, the sale ends.\n', '\tuint public tokenCap;\n', '\n', '\t// Era stuff (isolated)\n', '\t/// The era for which the current consolidated data represents.\n', '\tuint public eraIndex;\n', '\n', '\t/// The size of the era in seconds.\n', '\tuint constant public ERA_PERIOD = 5 minutes;\n', '\n', '\t// Static constants:\n', '\n', '\t/// Anything less than this is considered dust and cannot be used to buy in.\n', '\tuint constant public DUST_LIMIT = 5 finney;\n', '\n', '\t//# Statement to actually sign.\n', '\t//# ```js\n', '\t//# statement = function() { this.STATEMENT().map(s => s.substr(28)) }\n', '\t//# ```\n', '\n', '\t/// Minimum duration after sale begins that bonus is active.\n', '\tuint constant public BONUS_MIN_DURATION = 1 hours;\n', '\n', '\t/// Minimum duration after sale begins that bonus is active.\n', '\tuint constant public BONUS_MAX_DURATION = 12 hours;\n', '\n', '\t/// Number of consecutive blocks where there must be no new interest before bonus ends.\n', '\tuint constant public BONUS_LATCH = 2;\n', '\n', '\t/// Number of Wei in one EUR, constant.\n', '\tuint constant public EURWEI = 2000 szabo; // 500 eur ~ 1 eth\n', '\n', '\t/// Initial auction length\n', '\tuint constant public DEFAULT_AUCTION_LENGTH = 2 days;\n', '\n', '\t/// Divisor of the token.\n', '\tuint constant public DIVISOR = 1000;\n', '}']
