['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title Maths\n', ' * A library to make working with numbers in Solidity hurt your brain less.\n', ' */\n', 'library Maths {\n', '  /**\n', '   * @dev Adds two addends together, returns the sum\n', '   * @param addendA the first addend\n', '   * @param addendB the second addend\n', '   * @return sum the sum of the equation (e.g. addendA + addendB)\n', '   */\n', '  function plus(\n', '    uint256 addendA,\n', '    uint256 addendB\n', '  ) public pure returns (uint256 sum) {\n', '    sum = addendA + addendB;\n', '  }\n', '\n', '  /**\n', '   * @dev Subtracts the minuend from the subtrahend, returns the difference\n', '   * @param minuend the minuend\n', '   * @param subtrahend the subtrahend\n', '   * @return difference the difference (e.g. minuend - subtrahend)\n', '   */\n', '  function minus(\n', '    uint256 minuend,\n', '    uint256 subtrahend\n', '  ) public pure returns (uint256 difference) {\n', '    assert(minuend >= subtrahend);\n', '    difference = minuend - subtrahend;\n', '  }\n', '\n', '  /**\n', '   * @dev Multiplies two factors, returns the product\n', '   * @param factorA the first factor\n', '   * @param factorB the second factor\n', '   * @return product the product of the equation (e.g. factorA * factorB)\n', '   */\n', '  function mul(\n', '    uint256 factorA,\n', '    uint256 factorB\n', '  ) public pure returns (uint256 product) {\n', '    if (factorA == 0 || factorB == 0) return 0;\n', '    product = factorA * factorB;\n', '    assert(product / factorA == factorB);\n', '  }\n', '\n', '  /**\n', '   * @dev Multiplies two factors, returns the product\n', '   * @param factorA the first factor\n', '   * @param factorB the second factor\n', '   * @return product the product of the equation (e.g. factorA * factorB)\n', '   */\n', '  function times(\n', '    uint256 factorA,\n', '    uint256 factorB\n', '  ) public pure returns (uint256 product) {\n', '    return mul(factorA, factorB);\n', '  }\n', '\n', '  /**\n', '   * @dev Divides the dividend by divisor, returns the truncated quotient\n', '   * @param dividend the dividend\n', '   * @param divisor the divisor\n', '   * @return quotient the quotient of the equation (e.g. dividend / divisor)\n', '   */\n', '  function div(\n', '    uint256 dividend,\n', '    uint256 divisor\n', '  ) public pure returns (uint256 quotient) {\n', '    quotient = dividend / divisor;\n', '    assert(quotient * divisor == dividend);\n', '  }\n', '\n', '  /**\n', '   * @dev Divides the dividend by divisor, returns the truncated quotient\n', '   * @param dividend the dividend\n', '   * @param divisor the divisor\n', '   * @return quotient the quotient of the equation (e.g. dividend / divisor)\n', '   */\n', '  function dividedBy(\n', '    uint256 dividend,\n', '    uint256 divisor\n', '  ) public pure returns (uint256 quotient) {\n', '    return div(dividend, divisor);\n', '  }\n', '\n', '  /**\n', '   * @dev Divides the dividend by divisor, returns the quotient and remainder\n', '   * @param dividend the dividend\n', '   * @param divisor the divisor\n', '   * @return quotient the quotient of the equation (e.g. dividend / divisor)\n', '   * @return remainder the remainder of the equation (e.g. dividend % divisor)\n', '   */\n', '  function divideSafely(\n', '    uint256 dividend,\n', '    uint256 divisor\n', '  ) public pure returns (uint256 quotient, uint256 remainder) {\n', '    quotient = div(dividend, divisor);\n', '    remainder = dividend % divisor;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the lesser of two values.\n', '   * @param a the first value\n', '   * @param b the second value\n', '   * @return result the lesser of the two values\n', '   */\n', '  function min(\n', '    uint256 a,\n', '    uint256 b\n', '  ) public pure returns (uint256 result) {\n', '    result = a <= b ? a : b;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the greater of two values.\n', '   * @param a the first value\n', '   * @param b the second value\n', '   * @return result the greater of the two values\n', '   */\n', '  function max(\n', '    uint256 a,\n', '    uint256 b\n', '  ) public pure returns (uint256 result) {\n', '    result = a >= b ? a : b;\n', '  }\n', '\n', '  /**\n', '   * @dev Determines whether a value is less than another.\n', '   * @param a the first value\n', '   * @param b the second value\n', '   * @return isTrue whether a is less than b\n', '   */\n', '  function isLessThan(uint256 a, uint256 b) public pure returns (bool isTrue) {\n', '    isTrue = a < b;\n', '  }\n', '\n', '  /**\n', '   * @dev Determines whether a value is equal to or less than another.\n', '   * @param a the first value\n', '   * @param b the second value\n', '   * @return isTrue whether a is less than or equal to b\n', '   */\n', '  function isAtMost(uint256 a, uint256 b) public pure returns (bool isTrue) {\n', '    isTrue = a <= b;\n', '  }\n', '\n', '  /**\n', '   * @dev Determines whether a value is greater than another.\n', '   * @param a the first value\n', '   * @param b the second value\n', '   * @return isTrue whether a is greater than b\n', '   */\n', '  function isGreaterThan(uint256 a, uint256 b) public pure returns (bool isTrue) {\n', '    isTrue = a > b;\n', '  }\n', '\n', '  /**\n', '   * @dev Determines whether a value is equal to or greater than another.\n', '   * @param a the first value\n', '   * @param b the second value\n', '   * @return isTrue whether a is less than b\n', '   */\n', '  function isAtLeast(uint256 a, uint256 b) public pure returns (bool isTrue) {\n', '    isTrue = a >= b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Manageable\n', ' */\n', 'contract Manageable {\n', '  address public owner;\n', '  address public manager;\n', '\n', '  event OwnershipChanged(address indexed previousOwner, address indexed newOwner);\n', '  event ManagementChanged(address indexed previousManager, address indexed newManager);\n', '\n', '  /**\n', '   * @dev The Manageable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Manageable() public {\n', '    owner = msg.sender;\n', '    manager = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner or manager.\n', '   */\n', '  modifier onlyManagement() {\n', '    require(msg.sender == owner || msg.sender == manager);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipChanged(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the owner or manager to replace the current manager\n', '   * @param newManager The address to give contract management rights.\n', '   */\n', '  function replaceManager(address newManager) public onlyManagement {\n', '    require(newManager != address(0));\n', '    ManagementChanged(manager, newManager);\n', '    manager = newManager;\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function totalSupply() public view returns (uint256);\n', '}\n', '\n', 'contract MythereumERC20Token is ERC20 {\n', '  function burn(address burner, uint256 amount) public returns (bool);\n', '  function mint(address to, uint256 amount) public returns (bool);\n', '}\n', '\n', 'contract MythereumCardToken {\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  ) public;\n', '\n', '  function isEditionAvailable(uint8 _editionNumber) public view returns (bool);\n', '  function cloneCard(address _owner, uint256 _tokenId) public returns (bool);\n', '  function mintEditionCards(\n', '    address _owner,\n', '    uint8 _editionNumber,\n', '    uint8 _numCards\n', '  ) public returns (bool);\n', '  function improveCard(\n', '    uint256 _tokenId,\n', '    uint256 _addedDamage,\n', '    uint256 _addedShield\n', '  ) public returns (bool);\n', '  function destroyCard(uint256 _tokenId) public returns (bool);\n', '}\n', '\n', 'contract Mythereum is Manageable {\n', '  using Maths for uint256;\n', '\n', '  struct Edition {\n', '    string  name;\n', '    uint256 sales;\n', '    uint256 maxSales;\n', '    uint8   packSize;\n', '    uint256 packPrice;\n', '    uint256 packPriceIncrease;\n', '  }\n', '\n', '  mapping (uint8 => Edition) public editions;\n', '  mapping (address => bool) public isVIP;\n', '  mapping (address => bool) public isTokenAccepted;\n', '  mapping (address => uint256) public tokenCostPerPack;\n', '\n', '  mapping (uint256 => uint256) public mythexCostPerUpgradeLevel;\n', '  mapping (uint256 => uint256) public cardDamageUpgradeLevel;\n', '  mapping (uint256 => uint256) public cardShieldUpgradeLevel;\n', '  uint256 public maxCardUpgradeLevel = 30;\n', '\n', '  address public cardTokenAddress;\n', '  address public xpTokenAddress;\n', '  address public mythexTokenAddress;\n', '  address public gameHostAddress;\n', '\n', '  /* data related to shared ownership */\n', '  uint256 public totalShares = 0;\n', '  uint256 public totalReleased = 0;\n', '  mapping(address => uint256) public shares;\n', '  mapping(address => uint256) public released;\n', '\n', '  event CardsPurchased(uint256 editionNumber, uint256 packSize, address buyer);\n', '  event CardDamageUpgraded(uint256 cardId, uint256 newLevel, uint256 mythexCost);\n', '  event CardShieldUpgraded(uint256 cardId, uint256 newLevel, uint256 mythexCost);\n', '\n', '  modifier onlyHosts() {\n', '    require(\n', '      msg.sender == owner ||\n', '      msg.sender == manager ||\n', '      msg.sender == gameHostAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  function Mythereum() public {\n', '    editions[0] = Edition({\n', '      name: "Genesis",\n', '      sales: 0,\n', '      maxSales: 5000,\n', '      packSize: 7,\n', '      packPrice: 100 finney,\n', '      packPriceIncrease: 1 finney\n', '    });\n', '\n', '    isVIP[msg.sender] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Disallow funds being sent directly to the contract since we can&#39;t know\n', '   *  which edition they&#39;d intended to purchase.\n', '   */\n', '  function () public payable {\n', '    revert();\n', '  }\n', '\n', '  function buyPack(\n', '    uint8 _editionNumber\n', '  ) public payable {\n', '    uint256 packPrice = isVIP[msg.sender] ? 0 : editions[_editionNumber].packPrice;\n', '\n', '    require(msg.value.isAtLeast(packPrice));\n', '    if (msg.value.isGreaterThan(packPrice)) {\n', '      msg.sender.transfer(msg.value.minus(packPrice));\n', '    }\n', '\n', '    _deliverPack(msg.sender, _editionNumber);\n', '  }\n', '\n', '  function buyPackWithERC20Tokens(\n', '    uint8   _editionNumber,\n', '    address _tokenAddress\n', '  ) public {\n', '    require(isTokenAccepted[_tokenAddress]);\n', '    _processERC20TokenPackPurchase(_editionNumber, _tokenAddress, msg.sender);\n', '  }\n', '\n', '  function upgradeCardDamage(uint256 _cardId) public {\n', '    require(cardDamageUpgradeLevel[_cardId].isLessThan(maxCardUpgradeLevel));\n', '    uint256 costOfUpgrade = 2 ** (cardDamageUpgradeLevel[_cardId] + 1);\n', '\n', '    MythereumERC20Token mythexContract = MythereumERC20Token(mythexTokenAddress);\n', '    require(mythexContract.balanceOf(msg.sender).isAtLeast(costOfUpgrade));\n', '    burnMythexTokens(msg.sender, costOfUpgrade);\n', '\n', '    cardDamageUpgradeLevel[_cardId]++;\n', '\n', '    MythereumCardToken cardToken = MythereumCardToken(cardTokenAddress);\n', '    require(cardToken.improveCard(_cardId, cardDamageUpgradeLevel[_cardId], 0));\n', '\n', '    CardDamageUpgraded(_cardId, cardDamageUpgradeLevel[_cardId], costOfUpgrade);\n', '  }\n', '\n', '  function upgradeCardShield(uint256 _cardId) public {\n', '    require(cardShieldUpgradeLevel[_cardId].isLessThan(maxCardUpgradeLevel));\n', '    uint256 costOfUpgrade = 2 ** (cardShieldUpgradeLevel[_cardId] + 1);\n', '\n', '    MythereumERC20Token mythexContract = MythereumERC20Token(mythexTokenAddress);\n', '    require(mythexContract.balanceOf(msg.sender).isAtLeast(costOfUpgrade));\n', '    burnMythexTokens(msg.sender, costOfUpgrade);\n', '\n', '    cardShieldUpgradeLevel[_cardId]++;\n', '\n', '    MythereumCardToken cardToken = MythereumCardToken(cardTokenAddress);\n', '    require(cardToken.improveCard(_cardId, 0, cardShieldUpgradeLevel[_cardId]));\n', '\n', '    CardShieldUpgraded(_cardId, cardShieldUpgradeLevel[_cardId], costOfUpgrade);\n', '  }\n', '\n', '  function receiveApproval(\n', '    address _sender,\n', '    uint256 _value,\n', '    address _tokenContract,\n', '    bytes _extraData\n', '  ) public {\n', '    require(isTokenAccepted[_tokenContract]);\n', '\n', '    uint8 editionNumber = 0;\n', '    if (_extraData.length != 0) editionNumber = uint8(_extraData[0]);\n', '\n', '    _processERC20TokenPackPurchase(editionNumber, _tokenContract, _sender);\n', '  }\n', '\n', '  function _processERC20TokenPackPurchase(\n', '    uint8   _editionNumber,\n', '    address _tokenAddress,\n', '    address _buyer\n', '  ) internal {\n', '    require(isTokenAccepted[_tokenAddress]);\n', '    ERC20 tokenContract = ERC20(_tokenAddress);\n', '    uint256 costPerPack = tokenCostPerPack[_tokenAddress];\n', '\n', '    uint256 ourBalanceBefore = tokenContract.balanceOf(address(this));\n', '    tokenContract.transferFrom(_buyer, address(this), costPerPack);\n', '\n', '    uint256 ourBalanceAfter = tokenContract.balanceOf(address(this));\n', '    require(ourBalanceAfter.isAtLeast(ourBalanceBefore.plus(costPerPack)));\n', '\n', '    _deliverPack(_buyer, _editionNumber);\n', '  }\n', '\n', '  function burnMythexTokens(address _burner, uint256 _amount) public onlyHosts {\n', '    require(_burner != address(0));\n', '    MythereumERC20Token(mythexTokenAddress).burn(_burner, _amount);\n', '  }\n', '\n', '  function burnXPTokens(address _burner, uint256 _amount) public onlyHosts {\n', '    require(_burner != address(0));\n', '    MythereumERC20Token(xpTokenAddress).burn(_burner, _amount);\n', '  }\n', '\n', '  function grantMythexTokens(address _recipient, uint256 _amount) public onlyHosts {\n', '    require(_recipient != address(0));\n', '    MythereumERC20Token(mythexTokenAddress).mint(_recipient, _amount);\n', '  }\n', '\n', '  function grantXPTokens(address _recipient, uint256 _amount) public onlyHosts {\n', '    require(_recipient != address(0));\n', '    MythereumERC20Token(xpTokenAddress).mint(_recipient, _amount);\n', '  }\n', '\n', '  function grantPromoPack(\n', '    address _recipient,\n', '    uint8 _editionNumber\n', '  ) public onlyManagement {\n', '    _deliverPack(_recipient, _editionNumber);\n', '  }\n', '\n', '  function setTokenAcceptanceRate(\n', '    address _token,\n', '    uint256 _costPerPack\n', '  ) public onlyManagement {\n', '    if (_costPerPack > 0) {\n', '      isTokenAccepted[_token] = true;\n', '      tokenCostPerPack[_token] = _costPerPack;\n', '    } else {\n', '      isTokenAccepted[_token] = false;\n', '      tokenCostPerPack[_token] = 0;\n', '    }\n', '  }\n', '\n', '  function transferERC20Tokens(\n', '    address _token,\n', '    address _recipient,\n', '    uint256 _amount\n', '  ) public onlyManagement {\n', '    require(ERC20(_token).transfer(_recipient, _amount));\n', '  }\n', '\n', '  function addVIP(address _vip) public onlyManagement {\n', '    isVIP[_vip] = true;\n', '  }\n', '\n', '  function removeVIP(address _vip) public onlyManagement {\n', '    isVIP[_vip] = false;\n', '  }\n', '\n', '  function setEditionSales(\n', '    uint8 _editionNumber,\n', '    uint256 _numSales\n', '  ) public onlyManagement {\n', '    editions[_editionNumber].sales = _numSales;\n', '  }\n', '\n', '  function setEditionMaxSales(\n', '    uint8 _editionNumber,\n', '    uint256 _maxSales\n', '  ) public onlyManagement {\n', '    editions[_editionNumber].maxSales = _maxSales;\n', '  }\n', '\n', '  function setEditionPackPrice(\n', '    uint8 _editionNumber,\n', '    uint256 _newPrice\n', '  ) public onlyManagement {\n', '    editions[_editionNumber].packPrice = _newPrice;\n', '  }\n', '\n', '  function setEditionPackPriceIncrease(\n', '    uint8 _editionNumber,\n', '    uint256 _increase\n', '  ) public onlyManagement {\n', '    editions[_editionNumber].packPriceIncrease = _increase;\n', '  }\n', '\n', '  function setEditionPackSize(\n', '    uint8 _editionNumber,\n', '    uint8 _newSize\n', '  ) public onlyManagement {\n', '    editions[_editionNumber].packSize = _newSize;\n', '  }\n', '\n', '  function setCardTokenAddress(address _addr) public onlyManagement {\n', '    require(_addr != address(0));\n', '    cardTokenAddress = _addr;\n', '  }\n', '\n', '  function setXPTokenAddress(address _addr) public onlyManagement {\n', '    require(_addr != address(0));\n', '    xpTokenAddress = _addr;\n', '  }\n', '\n', '  function setMythexTokenAddress(address _addr) public onlyManagement {\n', '    require(_addr != address(0));\n', '    mythexTokenAddress = _addr;\n', '  }\n', '\n', '  function setGameHostAddress(address _addr) public onlyManagement {\n', '    require(_addr != address(0));\n', '    gameHostAddress = _addr;\n', '  }\n', '\n', '  function claim() public {\n', '    _claim(msg.sender);\n', '  }\n', '\n', '  function addShareholder(address _payee, uint256 _shares) public onlyOwner {\n', '    require(_payee != address(0));\n', '    require(_shares.isAtLeast(1));\n', '    require(shares[_payee] == 0);\n', '\n', '    shares[_payee] = _shares;\n', '    totalShares = totalShares.plus(_shares);\n', '  }\n', '\n', '  function removeShareholder(address _payee) public onlyOwner {\n', '    require(shares[_payee] != 0);\n', '    _claim(_payee);\n', '    _forfeitShares(_payee, shares[_payee]);\n', '  }\n', '\n', '  function grantAdditionalShares(\n', '    address _payee,\n', '    uint256 _shares\n', '  ) public onlyOwner {\n', '    require(shares[_payee] != 0);\n', '    require(_shares.isAtLeast(1));\n', '\n', '    shares[_payee] = shares[_payee].plus(_shares);\n', '    totalShares = totalShares.plus(_shares);\n', '  }\n', '\n', '  function forfeitShares(uint256 _numShares) public {\n', '    _forfeitShares(msg.sender, _numShares);\n', '  }\n', '\n', '  function transferShares(address _to, uint256 _numShares) public {\n', '    require(_numShares.isAtLeast(1));\n', '    require(shares[msg.sender].isAtLeast(_numShares));\n', '\n', '    shares[msg.sender] = shares[msg.sender].minus(_numShares);\n', '    shares[_to] = shares[_to].plus(_numShares);\n', '  }\n', '\n', '  function transferEntireStake(address _to) public {\n', '    transferShares(_to, shares[msg.sender]);\n', '  }\n', '\n', '  function _claim(address payee) internal {\n', '    require(shares[payee].isAtLeast(1));\n', '\n', '    uint256 totalReceived = address(this).balance.plus(totalReleased);\n', '    uint256 payment = totalReceived.times(shares[payee]).dividedBy(totalShares).minus(released[payee]);\n', '\n', '    require(payment != 0);\n', '    require(address(this).balance.isAtLeast(payment));\n', '\n', '    released[payee] = released[payee].plus(payment);\n', '    totalReleased = totalReleased.plus(payment);\n', '\n', '    payee.transfer(payment);\n', '  }\n', '\n', '  function _forfeitShares(address payee, uint256 numShares) internal {\n', '    require(shares[payee].isAtLeast(numShares));\n', '    shares[payee] = shares[payee].minus(numShares);\n', '    totalShares = totalShares.minus(numShares);\n', '  }\n', '\n', '  function _deliverPack(address recipient, uint8 editionNumber) internal {\n', '    Edition storage edition = editions[editionNumber];\n', '    require(edition.sales.isLessThan(edition.maxSales.plus(edition.packSize)));\n', '\n', '    edition.sales = edition.sales.plus(edition.packSize);\n', '    edition.packPrice = edition.packPrice.plus(edition.packPriceIncrease);\n', '\n', '    MythereumCardToken cardToken = MythereumCardToken(cardTokenAddress);\n', '    cardToken.mintEditionCards(recipient, editionNumber, edition.packSize);\n', '\n', '    CardsPurchased(editionNumber, edition.packSize, recipient);\n', '  }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title Maths\n', ' * A library to make working with numbers in Solidity hurt your brain less.\n', ' */\n', 'library Maths {\n', '  /**\n', '   * @dev Adds two addends together, returns the sum\n', '   * @param addendA the first addend\n', '   * @param addendB the second addend\n', '   * @return sum the sum of the equation (e.g. addendA + addendB)\n', '   */\n', '  function plus(\n', '    uint256 addendA,\n', '    uint256 addendB\n', '  ) public pure returns (uint256 sum) {\n', '    sum = addendA + addendB;\n', '  }\n', '\n', '  /**\n', '   * @dev Subtracts the minuend from the subtrahend, returns the difference\n', '   * @param minuend the minuend\n', '   * @param subtrahend the subtrahend\n', '   * @return difference the difference (e.g. minuend - subtrahend)\n', '   */\n', '  function minus(\n', '    uint256 minuend,\n', '    uint256 subtrahend\n', '  ) public pure returns (uint256 difference) {\n', '    assert(minuend >= subtrahend);\n', '    difference = minuend - subtrahend;\n', '  }\n', '\n', '  /**\n', '   * @dev Multiplies two factors, returns the product\n', '   * @param factorA the first factor\n', '   * @param factorB the second factor\n', '   * @return product the product of the equation (e.g. factorA * factorB)\n', '   */\n', '  function mul(\n', '    uint256 factorA,\n', '    uint256 factorB\n', '  ) public pure returns (uint256 product) {\n', '    if (factorA == 0 || factorB == 0) return 0;\n', '    product = factorA * factorB;\n', '    assert(product / factorA == factorB);\n', '  }\n', '\n', '  /**\n', '   * @dev Multiplies two factors, returns the product\n', '   * @param factorA the first factor\n', '   * @param factorB the second factor\n', '   * @return product the product of the equation (e.g. factorA * factorB)\n', '   */\n', '  function times(\n', '    uint256 factorA,\n', '    uint256 factorB\n', '  ) public pure returns (uint256 product) {\n', '    return mul(factorA, factorB);\n', '  }\n', '\n', '  /**\n', '   * @dev Divides the dividend by divisor, returns the truncated quotient\n', '   * @param dividend the dividend\n', '   * @param divisor the divisor\n', '   * @return quotient the quotient of the equation (e.g. dividend / divisor)\n', '   */\n', '  function div(\n', '    uint256 dividend,\n', '    uint256 divisor\n', '  ) public pure returns (uint256 quotient) {\n', '    quotient = dividend / divisor;\n', '    assert(quotient * divisor == dividend);\n', '  }\n', '\n', '  /**\n', '   * @dev Divides the dividend by divisor, returns the truncated quotient\n', '   * @param dividend the dividend\n', '   * @param divisor the divisor\n', '   * @return quotient the quotient of the equation (e.g. dividend / divisor)\n', '   */\n', '  function dividedBy(\n', '    uint256 dividend,\n', '    uint256 divisor\n', '  ) public pure returns (uint256 quotient) {\n', '    return div(dividend, divisor);\n', '  }\n', '\n', '  /**\n', '   * @dev Divides the dividend by divisor, returns the quotient and remainder\n', '   * @param dividend the dividend\n', '   * @param divisor the divisor\n', '   * @return quotient the quotient of the equation (e.g. dividend / divisor)\n', '   * @return remainder the remainder of the equation (e.g. dividend % divisor)\n', '   */\n', '  function divideSafely(\n', '    uint256 dividend,\n', '    uint256 divisor\n', '  ) public pure returns (uint256 quotient, uint256 remainder) {\n', '    quotient = div(dividend, divisor);\n', '    remainder = dividend % divisor;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the lesser of two values.\n', '   * @param a the first value\n', '   * @param b the second value\n', '   * @return result the lesser of the two values\n', '   */\n', '  function min(\n', '    uint256 a,\n', '    uint256 b\n', '  ) public pure returns (uint256 result) {\n', '    result = a <= b ? a : b;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the greater of two values.\n', '   * @param a the first value\n', '   * @param b the second value\n', '   * @return result the greater of the two values\n', '   */\n', '  function max(\n', '    uint256 a,\n', '    uint256 b\n', '  ) public pure returns (uint256 result) {\n', '    result = a >= b ? a : b;\n', '  }\n', '\n', '  /**\n', '   * @dev Determines whether a value is less than another.\n', '   * @param a the first value\n', '   * @param b the second value\n', '   * @return isTrue whether a is less than b\n', '   */\n', '  function isLessThan(uint256 a, uint256 b) public pure returns (bool isTrue) {\n', '    isTrue = a < b;\n', '  }\n', '\n', '  /**\n', '   * @dev Determines whether a value is equal to or less than another.\n', '   * @param a the first value\n', '   * @param b the second value\n', '   * @return isTrue whether a is less than or equal to b\n', '   */\n', '  function isAtMost(uint256 a, uint256 b) public pure returns (bool isTrue) {\n', '    isTrue = a <= b;\n', '  }\n', '\n', '  /**\n', '   * @dev Determines whether a value is greater than another.\n', '   * @param a the first value\n', '   * @param b the second value\n', '   * @return isTrue whether a is greater than b\n', '   */\n', '  function isGreaterThan(uint256 a, uint256 b) public pure returns (bool isTrue) {\n', '    isTrue = a > b;\n', '  }\n', '\n', '  /**\n', '   * @dev Determines whether a value is equal to or greater than another.\n', '   * @param a the first value\n', '   * @param b the second value\n', '   * @return isTrue whether a is less than b\n', '   */\n', '  function isAtLeast(uint256 a, uint256 b) public pure returns (bool isTrue) {\n', '    isTrue = a >= b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Manageable\n', ' */\n', 'contract Manageable {\n', '  address public owner;\n', '  address public manager;\n', '\n', '  event OwnershipChanged(address indexed previousOwner, address indexed newOwner);\n', '  event ManagementChanged(address indexed previousManager, address indexed newManager);\n', '\n', '  /**\n', '   * @dev The Manageable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Manageable() public {\n', '    owner = msg.sender;\n', '    manager = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner or manager.\n', '   */\n', '  modifier onlyManagement() {\n', '    require(msg.sender == owner || msg.sender == manager);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipChanged(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the owner or manager to replace the current manager\n', '   * @param newManager The address to give contract management rights.\n', '   */\n', '  function replaceManager(address newManager) public onlyManagement {\n', '    require(newManager != address(0));\n', '    ManagementChanged(manager, newManager);\n', '    manager = newManager;\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function totalSupply() public view returns (uint256);\n', '}\n', '\n', 'contract MythereumERC20Token is ERC20 {\n', '  function burn(address burner, uint256 amount) public returns (bool);\n', '  function mint(address to, uint256 amount) public returns (bool);\n', '}\n', '\n', 'contract MythereumCardToken {\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  ) public;\n', '\n', '  function isEditionAvailable(uint8 _editionNumber) public view returns (bool);\n', '  function cloneCard(address _owner, uint256 _tokenId) public returns (bool);\n', '  function mintEditionCards(\n', '    address _owner,\n', '    uint8 _editionNumber,\n', '    uint8 _numCards\n', '  ) public returns (bool);\n', '  function improveCard(\n', '    uint256 _tokenId,\n', '    uint256 _addedDamage,\n', '    uint256 _addedShield\n', '  ) public returns (bool);\n', '  function destroyCard(uint256 _tokenId) public returns (bool);\n', '}\n', '\n', 'contract Mythereum is Manageable {\n', '  using Maths for uint256;\n', '\n', '  struct Edition {\n', '    string  name;\n', '    uint256 sales;\n', '    uint256 maxSales;\n', '    uint8   packSize;\n', '    uint256 packPrice;\n', '    uint256 packPriceIncrease;\n', '  }\n', '\n', '  mapping (uint8 => Edition) public editions;\n', '  mapping (address => bool) public isVIP;\n', '  mapping (address => bool) public isTokenAccepted;\n', '  mapping (address => uint256) public tokenCostPerPack;\n', '\n', '  mapping (uint256 => uint256) public mythexCostPerUpgradeLevel;\n', '  mapping (uint256 => uint256) public cardDamageUpgradeLevel;\n', '  mapping (uint256 => uint256) public cardShieldUpgradeLevel;\n', '  uint256 public maxCardUpgradeLevel = 30;\n', '\n', '  address public cardTokenAddress;\n', '  address public xpTokenAddress;\n', '  address public mythexTokenAddress;\n', '  address public gameHostAddress;\n', '\n', '  /* data related to shared ownership */\n', '  uint256 public totalShares = 0;\n', '  uint256 public totalReleased = 0;\n', '  mapping(address => uint256) public shares;\n', '  mapping(address => uint256) public released;\n', '\n', '  event CardsPurchased(uint256 editionNumber, uint256 packSize, address buyer);\n', '  event CardDamageUpgraded(uint256 cardId, uint256 newLevel, uint256 mythexCost);\n', '  event CardShieldUpgraded(uint256 cardId, uint256 newLevel, uint256 mythexCost);\n', '\n', '  modifier onlyHosts() {\n', '    require(\n', '      msg.sender == owner ||\n', '      msg.sender == manager ||\n', '      msg.sender == gameHostAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  function Mythereum() public {\n', '    editions[0] = Edition({\n', '      name: "Genesis",\n', '      sales: 0,\n', '      maxSales: 5000,\n', '      packSize: 7,\n', '      packPrice: 100 finney,\n', '      packPriceIncrease: 1 finney\n', '    });\n', '\n', '    isVIP[msg.sender] = true;\n', '  }\n', '\n', '  /**\n', "   * @dev Disallow funds being sent directly to the contract since we can't know\n", "   *  which edition they'd intended to purchase.\n", '   */\n', '  function () public payable {\n', '    revert();\n', '  }\n', '\n', '  function buyPack(\n', '    uint8 _editionNumber\n', '  ) public payable {\n', '    uint256 packPrice = isVIP[msg.sender] ? 0 : editions[_editionNumber].packPrice;\n', '\n', '    require(msg.value.isAtLeast(packPrice));\n', '    if (msg.value.isGreaterThan(packPrice)) {\n', '      msg.sender.transfer(msg.value.minus(packPrice));\n', '    }\n', '\n', '    _deliverPack(msg.sender, _editionNumber);\n', '  }\n', '\n', '  function buyPackWithERC20Tokens(\n', '    uint8   _editionNumber,\n', '    address _tokenAddress\n', '  ) public {\n', '    require(isTokenAccepted[_tokenAddress]);\n', '    _processERC20TokenPackPurchase(_editionNumber, _tokenAddress, msg.sender);\n', '  }\n', '\n', '  function upgradeCardDamage(uint256 _cardId) public {\n', '    require(cardDamageUpgradeLevel[_cardId].isLessThan(maxCardUpgradeLevel));\n', '    uint256 costOfUpgrade = 2 ** (cardDamageUpgradeLevel[_cardId] + 1);\n', '\n', '    MythereumERC20Token mythexContract = MythereumERC20Token(mythexTokenAddress);\n', '    require(mythexContract.balanceOf(msg.sender).isAtLeast(costOfUpgrade));\n', '    burnMythexTokens(msg.sender, costOfUpgrade);\n', '\n', '    cardDamageUpgradeLevel[_cardId]++;\n', '\n', '    MythereumCardToken cardToken = MythereumCardToken(cardTokenAddress);\n', '    require(cardToken.improveCard(_cardId, cardDamageUpgradeLevel[_cardId], 0));\n', '\n', '    CardDamageUpgraded(_cardId, cardDamageUpgradeLevel[_cardId], costOfUpgrade);\n', '  }\n', '\n', '  function upgradeCardShield(uint256 _cardId) public {\n', '    require(cardShieldUpgradeLevel[_cardId].isLessThan(maxCardUpgradeLevel));\n', '    uint256 costOfUpgrade = 2 ** (cardShieldUpgradeLevel[_cardId] + 1);\n', '\n', '    MythereumERC20Token mythexContract = MythereumERC20Token(mythexTokenAddress);\n', '    require(mythexContract.balanceOf(msg.sender).isAtLeast(costOfUpgrade));\n', '    burnMythexTokens(msg.sender, costOfUpgrade);\n', '\n', '    cardShieldUpgradeLevel[_cardId]++;\n', '\n', '    MythereumCardToken cardToken = MythereumCardToken(cardTokenAddress);\n', '    require(cardToken.improveCard(_cardId, 0, cardShieldUpgradeLevel[_cardId]));\n', '\n', '    CardShieldUpgraded(_cardId, cardShieldUpgradeLevel[_cardId], costOfUpgrade);\n', '  }\n', '\n', '  function receiveApproval(\n', '    address _sender,\n', '    uint256 _value,\n', '    address _tokenContract,\n', '    bytes _extraData\n', '  ) public {\n', '    require(isTokenAccepted[_tokenContract]);\n', '\n', '    uint8 editionNumber = 0;\n', '    if (_extraData.length != 0) editionNumber = uint8(_extraData[0]);\n', '\n', '    _processERC20TokenPackPurchase(editionNumber, _tokenContract, _sender);\n', '  }\n', '\n', '  function _processERC20TokenPackPurchase(\n', '    uint8   _editionNumber,\n', '    address _tokenAddress,\n', '    address _buyer\n', '  ) internal {\n', '    require(isTokenAccepted[_tokenAddress]);\n', '    ERC20 tokenContract = ERC20(_tokenAddress);\n', '    uint256 costPerPack = tokenCostPerPack[_tokenAddress];\n', '\n', '    uint256 ourBalanceBefore = tokenContract.balanceOf(address(this));\n', '    tokenContract.transferFrom(_buyer, address(this), costPerPack);\n', '\n', '    uint256 ourBalanceAfter = tokenContract.balanceOf(address(this));\n', '    require(ourBalanceAfter.isAtLeast(ourBalanceBefore.plus(costPerPack)));\n', '\n', '    _deliverPack(_buyer, _editionNumber);\n', '  }\n', '\n', '  function burnMythexTokens(address _burner, uint256 _amount) public onlyHosts {\n', '    require(_burner != address(0));\n', '    MythereumERC20Token(mythexTokenAddress).burn(_burner, _amount);\n', '  }\n', '\n', '  function burnXPTokens(address _burner, uint256 _amount) public onlyHosts {\n', '    require(_burner != address(0));\n', '    MythereumERC20Token(xpTokenAddress).burn(_burner, _amount);\n', '  }\n', '\n', '  function grantMythexTokens(address _recipient, uint256 _amount) public onlyHosts {\n', '    require(_recipient != address(0));\n', '    MythereumERC20Token(mythexTokenAddress).mint(_recipient, _amount);\n', '  }\n', '\n', '  function grantXPTokens(address _recipient, uint256 _amount) public onlyHosts {\n', '    require(_recipient != address(0));\n', '    MythereumERC20Token(xpTokenAddress).mint(_recipient, _amount);\n', '  }\n', '\n', '  function grantPromoPack(\n', '    address _recipient,\n', '    uint8 _editionNumber\n', '  ) public onlyManagement {\n', '    _deliverPack(_recipient, _editionNumber);\n', '  }\n', '\n', '  function setTokenAcceptanceRate(\n', '    address _token,\n', '    uint256 _costPerPack\n', '  ) public onlyManagement {\n', '    if (_costPerPack > 0) {\n', '      isTokenAccepted[_token] = true;\n', '      tokenCostPerPack[_token] = _costPerPack;\n', '    } else {\n', '      isTokenAccepted[_token] = false;\n', '      tokenCostPerPack[_token] = 0;\n', '    }\n', '  }\n', '\n', '  function transferERC20Tokens(\n', '    address _token,\n', '    address _recipient,\n', '    uint256 _amount\n', '  ) public onlyManagement {\n', '    require(ERC20(_token).transfer(_recipient, _amount));\n', '  }\n', '\n', '  function addVIP(address _vip) public onlyManagement {\n', '    isVIP[_vip] = true;\n', '  }\n', '\n', '  function removeVIP(address _vip) public onlyManagement {\n', '    isVIP[_vip] = false;\n', '  }\n', '\n', '  function setEditionSales(\n', '    uint8 _editionNumber,\n', '    uint256 _numSales\n', '  ) public onlyManagement {\n', '    editions[_editionNumber].sales = _numSales;\n', '  }\n', '\n', '  function setEditionMaxSales(\n', '    uint8 _editionNumber,\n', '    uint256 _maxSales\n', '  ) public onlyManagement {\n', '    editions[_editionNumber].maxSales = _maxSales;\n', '  }\n', '\n', '  function setEditionPackPrice(\n', '    uint8 _editionNumber,\n', '    uint256 _newPrice\n', '  ) public onlyManagement {\n', '    editions[_editionNumber].packPrice = _newPrice;\n', '  }\n', '\n', '  function setEditionPackPriceIncrease(\n', '    uint8 _editionNumber,\n', '    uint256 _increase\n', '  ) public onlyManagement {\n', '    editions[_editionNumber].packPriceIncrease = _increase;\n', '  }\n', '\n', '  function setEditionPackSize(\n', '    uint8 _editionNumber,\n', '    uint8 _newSize\n', '  ) public onlyManagement {\n', '    editions[_editionNumber].packSize = _newSize;\n', '  }\n', '\n', '  function setCardTokenAddress(address _addr) public onlyManagement {\n', '    require(_addr != address(0));\n', '    cardTokenAddress = _addr;\n', '  }\n', '\n', '  function setXPTokenAddress(address _addr) public onlyManagement {\n', '    require(_addr != address(0));\n', '    xpTokenAddress = _addr;\n', '  }\n', '\n', '  function setMythexTokenAddress(address _addr) public onlyManagement {\n', '    require(_addr != address(0));\n', '    mythexTokenAddress = _addr;\n', '  }\n', '\n', '  function setGameHostAddress(address _addr) public onlyManagement {\n', '    require(_addr != address(0));\n', '    gameHostAddress = _addr;\n', '  }\n', '\n', '  function claim() public {\n', '    _claim(msg.sender);\n', '  }\n', '\n', '  function addShareholder(address _payee, uint256 _shares) public onlyOwner {\n', '    require(_payee != address(0));\n', '    require(_shares.isAtLeast(1));\n', '    require(shares[_payee] == 0);\n', '\n', '    shares[_payee] = _shares;\n', '    totalShares = totalShares.plus(_shares);\n', '  }\n', '\n', '  function removeShareholder(address _payee) public onlyOwner {\n', '    require(shares[_payee] != 0);\n', '    _claim(_payee);\n', '    _forfeitShares(_payee, shares[_payee]);\n', '  }\n', '\n', '  function grantAdditionalShares(\n', '    address _payee,\n', '    uint256 _shares\n', '  ) public onlyOwner {\n', '    require(shares[_payee] != 0);\n', '    require(_shares.isAtLeast(1));\n', '\n', '    shares[_payee] = shares[_payee].plus(_shares);\n', '    totalShares = totalShares.plus(_shares);\n', '  }\n', '\n', '  function forfeitShares(uint256 _numShares) public {\n', '    _forfeitShares(msg.sender, _numShares);\n', '  }\n', '\n', '  function transferShares(address _to, uint256 _numShares) public {\n', '    require(_numShares.isAtLeast(1));\n', '    require(shares[msg.sender].isAtLeast(_numShares));\n', '\n', '    shares[msg.sender] = shares[msg.sender].minus(_numShares);\n', '    shares[_to] = shares[_to].plus(_numShares);\n', '  }\n', '\n', '  function transferEntireStake(address _to) public {\n', '    transferShares(_to, shares[msg.sender]);\n', '  }\n', '\n', '  function _claim(address payee) internal {\n', '    require(shares[payee].isAtLeast(1));\n', '\n', '    uint256 totalReceived = address(this).balance.plus(totalReleased);\n', '    uint256 payment = totalReceived.times(shares[payee]).dividedBy(totalShares).minus(released[payee]);\n', '\n', '    require(payment != 0);\n', '    require(address(this).balance.isAtLeast(payment));\n', '\n', '    released[payee] = released[payee].plus(payment);\n', '    totalReleased = totalReleased.plus(payment);\n', '\n', '    payee.transfer(payment);\n', '  }\n', '\n', '  function _forfeitShares(address payee, uint256 numShares) internal {\n', '    require(shares[payee].isAtLeast(numShares));\n', '    shares[payee] = shares[payee].minus(numShares);\n', '    totalShares = totalShares.minus(numShares);\n', '  }\n', '\n', '  function _deliverPack(address recipient, uint8 editionNumber) internal {\n', '    Edition storage edition = editions[editionNumber];\n', '    require(edition.sales.isLessThan(edition.maxSales.plus(edition.packSize)));\n', '\n', '    edition.sales = edition.sales.plus(edition.packSize);\n', '    edition.packPrice = edition.packPrice.plus(edition.packPriceIncrease);\n', '\n', '    MythereumCardToken cardToken = MythereumCardToken(cardTokenAddress);\n', '    cardToken.mintEditionCards(recipient, editionNumber, edition.packSize);\n', '\n', '    CardsPurchased(editionNumber, edition.packSize, recipient);\n', '  }\n', '}']
