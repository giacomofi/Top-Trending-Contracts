['pragma solidity ^0.4.21;\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Guess23 is owned {\n', '    \n', '    \n', '    uint8 public maxnumber  = 100;\n', '   // mapping (uint8 => address) players;\n', '    mapping(address=>uint8[]) mynumbers;\n', '    mapping(address => bool) isActuallyAnAddressOnMyList;\n', '    mapping(uint8 => address[]) whosDaWinner;\n', '    uint8[] allnumbers;\n', '    address[]  allplayers;\n', '    uint8 winningNumber;\n', '    uint256 _lastPlayer;\n', '    uint public maxplayers = 25;\n', '    uint public roundnum  = 1;\n', '    uint256 public myWinShare  = 5;\n', '    uint256 public myLoseShare  = 0;\n', '    address[] winnerlist;\n', '\n', '\n', '    function Lottery() internal {\n', '        state = LotteryState.Accepting;\n', '    }\n', '    \n', '    uint8 number;\n', '    \n', '    enum LotteryState { Accepting, Finished }\n', '    \n', '    LotteryState state; \n', '    \n', '    uint public minAmount = 10000000000000000;\n', '    \n', '    function isAddress(address check) public view returns(bool isIndeed) {\n', '   return isActuallyAnAddressOnMyList[check];\n', '}\n', '  function getBalance() public view returns(uint256 balance) {\n', '      return this.balance;\n', '  }\n', '   \n', '   function play(uint8 mynumber) payable {\n', '       require(msg.value == minAmount);\n', '       require(mynumber >=0);\n', '       require(mynumber <= maxnumber);\n', '       require(state == LotteryState.Accepting);\n', '      whosDaWinner[mynumber].push(msg.sender);\n', '      mynumbers[msg.sender].push(mynumber);\n', '       allnumbers.push(mynumber);\n', '       if (!isAddress(msg.sender)){\n', '           \n', '           allplayers.push(msg.sender);\n', '           isActuallyAnAddressOnMyList[msg.sender] = true;\n', '       }\n', '       if (allnumbers.length == maxplayers){\n', '           state = LotteryState.Finished;\n', '       }\n', '       \n', '   } \n', '   function seeMyNumbers()public view returns(uint8[], uint256) {\n', '       return(mynumbers[msg.sender],mynumbers[msg.sender].length);\n', '   }\n', '   function seeAllNumbers() public view returns(uint8[]){\n', '       return  allnumbers;\n', '       //return numberlist;\n', '   }\n', '   function seeAllPlayers() public view returns(address[]){\n', '       return allplayers;\n', '   }\n', '\n', '    function setMaxNumber(uint8 newNumber) public onlyOwner {\n', '        maxnumber = newNumber;\n', '    }\n', '    \n', '    function setMaxPlayers(uint8 newNumber) public onlyOwner {\n', '        maxplayers = newNumber;\n', '    }\n', '    \n', '    function setMinAmount(uint newNumber) public onlyOwner {\n', '        minAmount = newNumber;\n', '    }\n', '\n', '      function sum(uint8[] data) private returns (uint) {\n', '        uint S;\n', '        for(uint i;i < data.length;i++){\n', '            S += data[i];\n', '        }\n', '        return S;\n', '    }\n', '    \n', '    function setMyCut(uint256 win, uint256 lose) public onlyOwner {\n', '        myWinShare = win;\n', '        myLoseShare = lose;\n', '    }\n', '    \n', '    function determineNumber() private returns(uint8) {\n', '        \n', '        \n', '        winningNumber = uint8(sum(allnumbers)/allnumbers.length/3*2);\n', '       \n', '    }\n', '    \n', '    function determineWinner() public onlyOwner returns(uint8, address[]){\n', '        require (state == LotteryState.Finished);\n', '        determineNumber();\n', '       winnerlist = whosDaWinner[winningNumber];\n', '       if (winnerlist.length > 0){\n', '           owner.transfer(this.balance/100*myWinShare);\n', '           uint256 numwinners = winnerlist.length;\n', '           for (uint8 i =0; i<numwinners; i++){\n', '               \n', '               winnerlist[i].transfer(this.balance/numwinners);\n', '           }\n', '       } else {\n', '           owner.transfer(this.balance/100*myLoseShare);\n', '       }\n', '         return (winningNumber, winnerlist);\n', '        \n', '        \n', '    }\n', '    \n', '    function getNumAdd(uint8 num) public view returns(address[]) {\n', '        return whosDaWinner[num];\n', '        \n', '    }\n', '    \n', '    function getResults() public view returns(uint8, address[]){\n', '        return (winningNumber, winnerlist);\n', '    }\n', '    function startOver() public onlyOwner{\n', '      //  uint8 i = number;\n', '      for (uint8 i=0; i<allnumbers.length; i++){\n', '        delete (whosDaWinner[allnumbers[i]]);\n', '        //delete playerlist;\n', '        }\n', '    for (uint8 j=0;j<allplayers.length; j++){\n', '        delete mynumbers[allplayers[j]];\n', '        delete isActuallyAnAddressOnMyList[allplayers[j]];\n', '    }\n', '        delete allplayers;\n', '        delete allnumbers;\n', '        delete winnerlist;\n', '        \n', '        state = LotteryState.Accepting;\n', '        roundnum ++;\n', '        \n', '        \n', '}\n', '\n', '\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Guess23 is owned {\n', '    \n', '    \n', '    uint8 public maxnumber  = 100;\n', '   // mapping (uint8 => address) players;\n', '    mapping(address=>uint8[]) mynumbers;\n', '    mapping(address => bool) isActuallyAnAddressOnMyList;\n', '    mapping(uint8 => address[]) whosDaWinner;\n', '    uint8[] allnumbers;\n', '    address[]  allplayers;\n', '    uint8 winningNumber;\n', '    uint256 _lastPlayer;\n', '    uint public maxplayers = 25;\n', '    uint public roundnum  = 1;\n', '    uint256 public myWinShare  = 5;\n', '    uint256 public myLoseShare  = 0;\n', '    address[] winnerlist;\n', '\n', '\n', '    function Lottery() internal {\n', '        state = LotteryState.Accepting;\n', '    }\n', '    \n', '    uint8 number;\n', '    \n', '    enum LotteryState { Accepting, Finished }\n', '    \n', '    LotteryState state; \n', '    \n', '    uint public minAmount = 10000000000000000;\n', '    \n', '    function isAddress(address check) public view returns(bool isIndeed) {\n', '   return isActuallyAnAddressOnMyList[check];\n', '}\n', '  function getBalance() public view returns(uint256 balance) {\n', '      return this.balance;\n', '  }\n', '   \n', '   function play(uint8 mynumber) payable {\n', '       require(msg.value == minAmount);\n', '       require(mynumber >=0);\n', '       require(mynumber <= maxnumber);\n', '       require(state == LotteryState.Accepting);\n', '      whosDaWinner[mynumber].push(msg.sender);\n', '      mynumbers[msg.sender].push(mynumber);\n', '       allnumbers.push(mynumber);\n', '       if (!isAddress(msg.sender)){\n', '           \n', '           allplayers.push(msg.sender);\n', '           isActuallyAnAddressOnMyList[msg.sender] = true;\n', '       }\n', '       if (allnumbers.length == maxplayers){\n', '           state = LotteryState.Finished;\n', '       }\n', '       \n', '   } \n', '   function seeMyNumbers()public view returns(uint8[], uint256) {\n', '       return(mynumbers[msg.sender],mynumbers[msg.sender].length);\n', '   }\n', '   function seeAllNumbers() public view returns(uint8[]){\n', '       return  allnumbers;\n', '       //return numberlist;\n', '   }\n', '   function seeAllPlayers() public view returns(address[]){\n', '       return allplayers;\n', '   }\n', '\n', '    function setMaxNumber(uint8 newNumber) public onlyOwner {\n', '        maxnumber = newNumber;\n', '    }\n', '    \n', '    function setMaxPlayers(uint8 newNumber) public onlyOwner {\n', '        maxplayers = newNumber;\n', '    }\n', '    \n', '    function setMinAmount(uint newNumber) public onlyOwner {\n', '        minAmount = newNumber;\n', '    }\n', '\n', '      function sum(uint8[] data) private returns (uint) {\n', '        uint S;\n', '        for(uint i;i < data.length;i++){\n', '            S += data[i];\n', '        }\n', '        return S;\n', '    }\n', '    \n', '    function setMyCut(uint256 win, uint256 lose) public onlyOwner {\n', '        myWinShare = win;\n', '        myLoseShare = lose;\n', '    }\n', '    \n', '    function determineNumber() private returns(uint8) {\n', '        \n', '        \n', '        winningNumber = uint8(sum(allnumbers)/allnumbers.length/3*2);\n', '       \n', '    }\n', '    \n', '    function determineWinner() public onlyOwner returns(uint8, address[]){\n', '        require (state == LotteryState.Finished);\n', '        determineNumber();\n', '       winnerlist = whosDaWinner[winningNumber];\n', '       if (winnerlist.length > 0){\n', '           owner.transfer(this.balance/100*myWinShare);\n', '           uint256 numwinners = winnerlist.length;\n', '           for (uint8 i =0; i<numwinners; i++){\n', '               \n', '               winnerlist[i].transfer(this.balance/numwinners);\n', '           }\n', '       } else {\n', '           owner.transfer(this.balance/100*myLoseShare);\n', '       }\n', '         return (winningNumber, winnerlist);\n', '        \n', '        \n', '    }\n', '    \n', '    function getNumAdd(uint8 num) public view returns(address[]) {\n', '        return whosDaWinner[num];\n', '        \n', '    }\n', '    \n', '    function getResults() public view returns(uint8, address[]){\n', '        return (winningNumber, winnerlist);\n', '    }\n', '    function startOver() public onlyOwner{\n', '      //  uint8 i = number;\n', '      for (uint8 i=0; i<allnumbers.length; i++){\n', '        delete (whosDaWinner[allnumbers[i]]);\n', '        //delete playerlist;\n', '        }\n', '    for (uint8 j=0;j<allplayers.length; j++){\n', '        delete mynumbers[allplayers[j]];\n', '        delete isActuallyAnAddressOnMyList[allplayers[j]];\n', '    }\n', '        delete allplayers;\n', '        delete allnumbers;\n', '        delete winnerlist;\n', '        \n', '        state = LotteryState.Accepting;\n', '        roundnum ++;\n', '        \n', '        \n', '}\n', '\n', '\n', '}']
