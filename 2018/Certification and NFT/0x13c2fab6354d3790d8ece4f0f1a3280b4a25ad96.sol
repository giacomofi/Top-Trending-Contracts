['pragma solidity ^0.4.18;\n', '\n', ' /*\n', ' * Contract that is working with ERC223 tokens\n', ' * https://github.com/ethereum/EIPs/issues/223\n', ' */\n', '\n', '/// @title ERC223ReceivingContract - Standard contract implementation for compatibility with ERC223 tokens.\n', 'contract ERC223ReceivingContract {\n', '\n', '    /// @dev Function that is called when a user or another contract wants to transfer funds.\n', '    /// @param _from Transaction initiator, analogue of msg.sender\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @param _data Data containig a function signature and/or parameters\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) public;\n', '}\n', '\n', '/// @title Base Token contract - Functions to be implemented by token contracts.\n', 'contract Token {\n', '    /*\n', '     * Implements ERC 20 standard.\n', '     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\n', '     * https://github.com/ethereum/EIPs/issues/20\n', '     *\n', '     *  Added support for the ERC 223 "tokenFallback" method in a "transfer" function with a payload.\n', '     *  https://github.com/ethereum/EIPs/issues/223\n', '     */\n', '\n', '    /*\n', '     * ERC 20\n', '     */\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '    function burn(uint num) public;\n', '\n', '    /*\n', '     * ERC 223\n', '     */\n', '    function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);\n', '\n', '    /*\n', '     * Events\n', '     */\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event Burn(address indexed _burner, uint _value);\n', '\n', '    // There is no ERC223 compatible Transfer event, with `_data` included.\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/// @title PHI ERC223 Token with burn functionality\n', 'contract PhiToken is Token {\n', '\n', '    /*\n', '     *  Terminology:\n', '     *  1 token unit = PHI\n', '     *  1 token = PHI = sphi * multiplier\n', "     *  multiplier set from token's number of decimals (i.e. 10 ** decimals)\n", '     */\n', '\n', '    /*  \n', '     *  Section 1\n', '     *  - Variables\n', '     */\n', '    /// Token metadata\n', '    string constant public name = "PHI Token";\n', '    string constant public symbol = "PHI";\n', '    uint8 constant public decimals = 18;\n', '    using SafeMath for uint;\n', '    uint constant multiplier = 10 ** uint(decimals);\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    /*\n', '     * This is a slight change to the ERC20 base standard.\n', '     * function totalSupply() constant returns (uint256 supply);\n', '     * is replaced with:\n', '     * uint256 public totalSupply;\n', '     * This automatically creates a getter function for the totalSupply.\n', '     * This is moved to the base contract since public getter functions are not\n', '     * currently recognised as an implementation of the matching abstract\n', '     * function by the compiler.\n', '     *\n', '     * Hardcoded total supply (in sphi), it can be decreased only by burning tokens\n', '     */\n', '    uint256 public totalSupply =  24157817 * multiplier;\n', '\n', '    /// Keep track of assigned tokens at deploy\n', '    bool initialTokensAssigned = false;\n', '\n', '    /// Store pre-ico and ico address\n', '    address public PRE_ICO_ADDR;\n', '    address public ICO_ADDR;\n', '\n', '    /// Where tokens for team will be sent, used also for function-auth\n', '    address public WALLET_ADDR;\n', '\n', '    /// How long the tokens should be locked for transfers\n', '    uint public lockTime;\n', '\n', '    /* \n', '     *  Section 2\n', '     *  - modifiers\n', '     */\n', '    /// Do not allow transfers if lockTime is active, allow only\n', '    /// pre-ico and ico if it is (to distribute tokens)\n', '    modifier onlyIfLockTimePassed () {\n', '        require(now > lockTime || (msg.sender == PRE_ICO_ADDR || msg.sender == ICO_ADDR));\n', '        _;\n', '    }\n', '\n', '    /* \n', '     *  Section 3\n', '     *  - Events\n', '     */\n', '    event Deployed(uint indexed _total_supply);\n', '\n', '    /*\n', '     *  Public functions\n', '     */\n', '    /// @dev Contract constructor function, assigns tokens to ico, pre-ico,\n', '    /// wallet address and pre sale investors.\n', '    /// @param ico_address Address of the ico contract.\n', '    /// @param pre_ico_address Address of the pre-ico contract.\n', '    /// @param wallet_address Address of tokens to be sent to the PHI team.\n', '    /// @param _lockTime Epoch Timestamp describing how long the tokens should be\n', '    /// locked for transfers.\n', '    function PhiToken(\n', '        address ico_address,\n', '        address pre_ico_address,\n', '        address wallet_address,\n', '        uint _lockTime)\n', '        public\n', '    {\n', '        // Check destination address\n', '        require(ico_address != 0x0);\n', '        require(pre_ico_address != 0x0);\n', '        require(wallet_address != 0x0);\n', '        require(ico_address != pre_ico_address && wallet_address != ico_address);\n', '        require(initialTokensAssigned == false);\n', '        // _lockTime should be in the future\n', '        require(_lockTime > now);\n', '        lockTime = _lockTime;\n', '\n', '        WALLET_ADDR = wallet_address;\n', '\n', '        // Check total supply\n', '        require(totalSupply > multiplier);\n', '\n', '        // tokens to be assigned to pre-ico, ico and wallet address\n', '        uint initAssign = 0;\n', '\n', '        // to be sold in the ico\n', '        initAssign += assignTokens(ico_address, 7881196 * multiplier);\n', '        ICO_ADDR = ico_address;\n', '        // to be sold in the pre-ico\n', '        initAssign += assignTokens(pre_ico_address, 3524578 * multiplier);\n', '        PRE_ICO_ADDR = pre_ico_address;\n', '        // Reserved for the team, airdrop, marketing, business etc..\n', '        initAssign += assignTokens(wallet_address, 9227465 * multiplier);\n', '\n', '        // Pre sale allocations\n', '        uint presaleTokens = 0;\n', '        presaleTokens += assignTokens(address(0x72B16DC0e5f85aA4BBFcE81687CCc9D6871C2965), 230387 * multiplier);\n', '        presaleTokens += assignTokens(address(0x7270cC02d88Ea63FC26384f5d08e14EE87E75154), 132162 * multiplier);\n', '        presaleTokens += assignTokens(address(0x25F92f21222969BB0b1f14f19FBa770D30Ff678f), 132162 * multiplier);\n', '        presaleTokens += assignTokens(address(0xAc99C59D3353a34531Fae217Ba77139BBe4eDBb3), 443334 * multiplier);\n', '        presaleTokens += assignTokens(address(0xbe41D37eB2d2859143B9f1D29c7BC6d7e59174Da), 970826500000000000000000); // 970826.5 PHI\n', '        presaleTokens += assignTokens(address(0x63e9FA0e43Fcc7C702ed5997AfB8E215C5beE3c9), 970826500000000000000000); // 970826.5 PHI\n', '        presaleTokens += assignTokens(address(0x95c67812c5C41733419aC3b1916d2F282E7A15A4), 396486 * multiplier);\n', '        presaleTokens += assignTokens(address(0x1f5d30BB328498fF6E09b717EC22A9046C41C257), 20144 * multiplier);\n', '        presaleTokens += assignTokens(address(0x0a1ac564e95dAEDF8d454a3593b75CCdd474fc42), 19815 * multiplier);\n', '        presaleTokens += assignTokens(address(0x0C5448D5bC4C40b4d2b2c1D7E58E0541698d3e6E), 19815 * multiplier);\n', '        presaleTokens += assignTokens(address(0xFAe11D521538F067cE0B13B6f8C929cdEA934D07), 75279 * multiplier);\n', '        presaleTokens += assignTokens(address(0xEE51304603887fFF15c6d12165C6d96ff0f0c85b), 45949 * multiplier);\n', '        presaleTokens += assignTokens(address(0xd7Bab04C944faAFa232d6EBFE4f60FF8C4e9815F), 6127 * multiplier);\n', '        presaleTokens += assignTokens(address(0x603f39C81560019c8360F33bA45Bc1E4CAECb33e), 45949 * multiplier);\n', '        presaleTokens += assignTokens(address(0xBB5128f1093D1aa85F6d7D0cC20b8415E0104eDD), 15316 * multiplier);\n', '        \n', '        initialTokensAssigned = true;\n', '\n', '        Deployed(totalSupply);\n', '\n', '        assert(presaleTokens == 3524578 * multiplier);\n', '        assert(totalSupply == (initAssign.add(presaleTokens)));\n', '    }\n', '\n', '    /// @dev Helper function to assign tokens (team, pre-sale, ico, pre-ico etc..).\n', '    /// @notice It will be automatically called on deploy.\n', '    /// @param addr Receiver of the tokens.\n', '    /// @param amount Tokens (in sphi).\n', '    /// @return Tokens assigned\n', '    function assignTokens (address addr, uint amount) internal returns (uint) {\n', '        require(addr != 0x0);\n', '        require(initialTokensAssigned == false);\n', '        balances[addr] = amount;\n', '        Transfer(0x0, addr, balances[addr]);\n', '        return balances[addr];\n', '    }\n', '\n', '    /// @notice Allows `msg.sender` to simply destroy `_value` token units (sphi). This means the total\n', '    /// token supply will decrease.\n', '    /// @dev Allows to destroy token units (sphi).\n', '    /// @param _value Number of token units (sphi) to burn.\n', '    function burn(uint256 _value) public onlyIfLockTimePassed {\n', '        require(_value > 0);\n', '        require(balances[msg.sender] >= _value);\n', '        require(totalSupply >= _value);\n', '\n', '        uint pre_balance = balances[msg.sender];\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Burn(burner, _value);\n', '        Transfer(burner, 0x0, _value);\n', '        assert(balances[burner] == pre_balance.sub(_value));\n', '    }\n', '\n', '    /*\n', '     * Token functions\n', '     */\n', '\n', '    /// @notice Send `_value` tokens to `_to` from `msg.sender`.\n', "    /// @dev Transfers sender's tokens to a given address. Returns success.\n", '    /// @param _to Address of token receiver.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @return Returns success of function call.\n', '    function transfer(address _to, uint256 _value) public onlyIfLockTimePassed returns (bool) {\n', '        require(_to != 0x0);\n', '        require(_to != address(this));\n', '        require(balances[msg.sender] >= _value);\n', '        require(balances[_to].add(_value) >= balances[_to]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Send `_value` tokens to `_to` from `msg.sender` and trigger\n', '    /// tokenFallback if sender is a contract.\n', '    /// @dev Function that is called when a user or another contract wants to transfer funds.\n', '    /// @param _to Address of token receiver.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @param _data Data to be sent to tokenFallback\n', '    /// @return Returns success of function call.\n', '    function transfer(\n', '        address _to,\n', '        uint256 _value,\n', '        bytes _data)\n', '        public\n', '        onlyIfLockTimePassed\n', '        returns (bool)\n', '    {\n', '        require(transfer(_to, _value));\n', '\n', '        uint codeLength;\n', '\n', '        assembly {\n', '            // Retrieve the size of the code on target address, this needs assembly.\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        if (codeLength > 0) {\n', '            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '            receiver.tokenFallback(msg.sender, _value, _data);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Transfer `_value` tokens from `_from` to `_to` if `msg.sender` is allowed.\n', '    /// @dev Allows for an approved third party to transfer tokens from one\n', '    /// address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @return Returns success of function call.\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        onlyIfLockTimePassed\n', '        returns (bool)\n', '    {\n', '        require(_from != 0x0);\n', '        require(_to != 0x0);\n', '        require(_to != address(this));\n', '        require(balances[_from] >= _value);\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        require(balances[_to].add(_value) >= balances[_to]);\n', '\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    /// @return Returns success of function call.\n', '    function approve(address _spender, uint256 _value) public onlyIfLockTimePassed returns (bool) {\n', '        require(_spender != 0x0);\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        // allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        // already 0 to mitigate the race condition described here:\n', '        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require(_value == 0 || allowed[msg.sender][_spender] == 0);\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Read functions\n', '     */\n', '    /// @dev Returns number of allowed tokens that a spender can transfer on\n', '    /// behalf of a token owner.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    /// @return Returns remaining allowance for spender.\n', '    function allowance(address _owner, address _spender)\n', '        constant\n', '        public\n', '        returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by the given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @return Returns balance of owner.\n', '    function balanceOf(address _owner) constant public returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}']