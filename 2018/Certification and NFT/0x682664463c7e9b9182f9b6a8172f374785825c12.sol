['/*\n', ' * Copyright(C) 2018 by @phalexo (gitter) and Big Deeper Advisors, Inc. a Wyoming corporation.\n', ' * All rights reserved.\n', ' *\n', ' * A non-exclusive, non-transferable, perpetual license to use is hereby granted to Expercoin, Inc.\n', ' * For questions about the license contact: bigdeeperadvisors@gmail.com\n', ' *\n', ' * Expercoin, Inc. can be reached via support@expercoin.com and expercoin.com website.\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', 'contract References {\n', '\n', '  mapping (bytes32 => address) internal references;\n', '\n', '}\n', '\n', 'contract AuthorizedList {\n', '\n', '    bytes32 constant PRESIDENT = keccak256("Republics President!");\n', '    bytes32 constant STAFF_MEMBER = keccak256("Staff Member.");\n', '    bytes32 constant AIR_DROP = keccak256("Airdrop Permission.");\n', '    bytes32 constant INTERNAL = keccak256("Internal Authorization.");\n', '    mapping (address => mapping(bytes32 => bool)) authorized;\n', '\n', '}\n', '\n', 'contract Authorized is AuthorizedList {\n', '\n', '    /// @dev Set the initial permission for the contract creator\n', '    /// The contract creator can then add permissions for others\n', '    function Authorized() public {\n', '\n', '       authorized[msg.sender][PRESIDENT] = true;\n', '\n', '    }\n', '\n', '\n', '    /// @dev Ensure that _address is authorized, modifier\n', '    /// @param _address Address to be checked, usually msg.sender\n', '    /// @param _authorization key for specific authorization\n', '    modifier ifAuthorized(address _address, bytes32 _authorization) {\n', '\n', '       require(authorized[_address][_authorization] || authorized[_address][PRESIDENT], "Not authorized to access!");\n', '       _;\n', '\n', '    }\n', '\n', '    /// @dev Check _address&#39; authorization, boolean function\n', '    /// @param _address Boolean value, true if authorized, false otherwise\n', '    /// @param _authorization key for specific authorization\n', '    function isAuthorized(address _address, bytes32 _authorization) public view returns (bool) {\n', '\n', '       return authorized[_address][_authorization];\n', '\n', '    }\n', '\n', '    /// @dev Toggle boolean flag to allow or prevent access\n', '    /// @param _address Boolean value, true if authorized, false otherwise\n', '    /// @param _authorization key for specific authorization\n', '    function toggleAuthorization(address _address, bytes32 _authorization) public ifAuthorized(msg.sender, PRESIDENT) {\n', '\n', '       /// Prevent inadvertent self locking out, cannot change own authority\n', '       require(_address != msg.sender, "Cannot change own permissions.");\n', '\n', '       /// No need for lower level authorization to linger\n', '       if (_authorization == PRESIDENT && !authorized[_address][PRESIDENT])\n', '           authorized[_address][STAFF_MEMBER] = false;\n', '\n', '       authorized[_address][_authorization] = !authorized[_address][_authorization];\n', '\n', '    }\n', '\n', '}\n', '\n', 'contract main is References, AuthorizedList, Authorized {\n', '\n', '  event LogicUpgrade(address indexed _oldbiz, address indexed _newbiz);\n', '  event StorageUpgrade(address indexed _oldvars, address indexed _newvars);\n', '\n', '  function main(address _logic, address _storage) public Authorized() {\n', '\n', '     require(_logic != address(0), "main: Unexpectedly logic address is 0x0.");\n', '     require(_storage != address(0), "main: Unexpectedly storage address is 0x0.");\n', '     references[bytes32(0)] = _logic;\n', '     references[bytes32(1)] = _storage;\n', '\n', '  }\n', '\n', '  /// @dev Set an address at _key location\n', '  /// @param _address Address to set\n', '  /// @param _key bytes32 key location\n', '  function setReference(address _address, bytes32 _key) external ifAuthorized(msg.sender, PRESIDENT) {\n', '\n', '     require(_address != address(0), "setReference: Unexpectedly _address is 0x0");\n', '\n', '     if (_key == bytes32(0)) emit LogicUpgrade(references[bytes32(0)], _address);\n', '     else emit StorageUpgrade(references[_key], _address);\n', '\n', '     if (references[_key] != address(0))\n', '          delete references[_key];\n', '\n', '     references[_key] = _address;\n', '\n', '  }\n', '\n', '  /// @dev Retrieve contract address at _key location, mostly for convenience\n', '  /// @return Contract address or 0x0 if it does not exist\n', '  function getReference(bytes32 _key) external view ifAuthorized(msg.sender, PRESIDENT) returns(address) {\n', '\n', '      return references[_key];\n', '\n', '  }\n', '\n', '  function() external payable {\n', '\n', '      address _target = references[bytes32(0)];\n', '      assembly {\n', '          let _calldata := mload(0x40)\n', '          mstore(0x40, add(_calldata, calldatasize))\n', '          calldatacopy(_calldata, 0x0, calldatasize)\n', '          switch delegatecall(gas, _target, _calldata, calldatasize, 0, 0)\n', '            case 0 { revert(0, 0) }\n', '            default {\n', '              let _returndata := mload(0x40)\n', '              returndatacopy(_returndata, 0, returndatasize)\n', '              mstore(0x40, add(_returndata, returndatasize))\n', '              return(_returndata, returndatasize)\n', '            }\n', '       }\n', '   }\n', '\n', '}']
['/*\n', ' * Copyright(C) 2018 by @phalexo (gitter) and Big Deeper Advisors, Inc. a Wyoming corporation.\n', ' * All rights reserved.\n', ' *\n', ' * A non-exclusive, non-transferable, perpetual license to use is hereby granted to Expercoin, Inc.\n', ' * For questions about the license contact: bigdeeperadvisors@gmail.com\n', ' *\n', ' * Expercoin, Inc. can be reached via support@expercoin.com and expercoin.com website.\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', 'contract References {\n', '\n', '  mapping (bytes32 => address) internal references;\n', '\n', '}\n', '\n', 'contract AuthorizedList {\n', '\n', '    bytes32 constant PRESIDENT = keccak256("Republics President!");\n', '    bytes32 constant STAFF_MEMBER = keccak256("Staff Member.");\n', '    bytes32 constant AIR_DROP = keccak256("Airdrop Permission.");\n', '    bytes32 constant INTERNAL = keccak256("Internal Authorization.");\n', '    mapping (address => mapping(bytes32 => bool)) authorized;\n', '\n', '}\n', '\n', 'contract Authorized is AuthorizedList {\n', '\n', '    /// @dev Set the initial permission for the contract creator\n', '    /// The contract creator can then add permissions for others\n', '    function Authorized() public {\n', '\n', '       authorized[msg.sender][PRESIDENT] = true;\n', '\n', '    }\n', '\n', '\n', '    /// @dev Ensure that _address is authorized, modifier\n', '    /// @param _address Address to be checked, usually msg.sender\n', '    /// @param _authorization key for specific authorization\n', '    modifier ifAuthorized(address _address, bytes32 _authorization) {\n', '\n', '       require(authorized[_address][_authorization] || authorized[_address][PRESIDENT], "Not authorized to access!");\n', '       _;\n', '\n', '    }\n', '\n', "    /// @dev Check _address' authorization, boolean function\n", '    /// @param _address Boolean value, true if authorized, false otherwise\n', '    /// @param _authorization key for specific authorization\n', '    function isAuthorized(address _address, bytes32 _authorization) public view returns (bool) {\n', '\n', '       return authorized[_address][_authorization];\n', '\n', '    }\n', '\n', '    /// @dev Toggle boolean flag to allow or prevent access\n', '    /// @param _address Boolean value, true if authorized, false otherwise\n', '    /// @param _authorization key for specific authorization\n', '    function toggleAuthorization(address _address, bytes32 _authorization) public ifAuthorized(msg.sender, PRESIDENT) {\n', '\n', '       /// Prevent inadvertent self locking out, cannot change own authority\n', '       require(_address != msg.sender, "Cannot change own permissions.");\n', '\n', '       /// No need for lower level authorization to linger\n', '       if (_authorization == PRESIDENT && !authorized[_address][PRESIDENT])\n', '           authorized[_address][STAFF_MEMBER] = false;\n', '\n', '       authorized[_address][_authorization] = !authorized[_address][_authorization];\n', '\n', '    }\n', '\n', '}\n', '\n', 'contract main is References, AuthorizedList, Authorized {\n', '\n', '  event LogicUpgrade(address indexed _oldbiz, address indexed _newbiz);\n', '  event StorageUpgrade(address indexed _oldvars, address indexed _newvars);\n', '\n', '  function main(address _logic, address _storage) public Authorized() {\n', '\n', '     require(_logic != address(0), "main: Unexpectedly logic address is 0x0.");\n', '     require(_storage != address(0), "main: Unexpectedly storage address is 0x0.");\n', '     references[bytes32(0)] = _logic;\n', '     references[bytes32(1)] = _storage;\n', '\n', '  }\n', '\n', '  /// @dev Set an address at _key location\n', '  /// @param _address Address to set\n', '  /// @param _key bytes32 key location\n', '  function setReference(address _address, bytes32 _key) external ifAuthorized(msg.sender, PRESIDENT) {\n', '\n', '     require(_address != address(0), "setReference: Unexpectedly _address is 0x0");\n', '\n', '     if (_key == bytes32(0)) emit LogicUpgrade(references[bytes32(0)], _address);\n', '     else emit StorageUpgrade(references[_key], _address);\n', '\n', '     if (references[_key] != address(0))\n', '          delete references[_key];\n', '\n', '     references[_key] = _address;\n', '\n', '  }\n', '\n', '  /// @dev Retrieve contract address at _key location, mostly for convenience\n', '  /// @return Contract address or 0x0 if it does not exist\n', '  function getReference(bytes32 _key) external view ifAuthorized(msg.sender, PRESIDENT) returns(address) {\n', '\n', '      return references[_key];\n', '\n', '  }\n', '\n', '  function() external payable {\n', '\n', '      address _target = references[bytes32(0)];\n', '      assembly {\n', '          let _calldata := mload(0x40)\n', '          mstore(0x40, add(_calldata, calldatasize))\n', '          calldatacopy(_calldata, 0x0, calldatasize)\n', '          switch delegatecall(gas, _target, _calldata, calldatasize, 0, 0)\n', '            case 0 { revert(0, 0) }\n', '            default {\n', '              let _returndata := mload(0x40)\n', '              returndatacopy(_returndata, 0, returndatasize)\n', '              mstore(0x40, add(_returndata, returndatasize))\n', '              return(_returndata, returndatasize)\n', '            }\n', '       }\n', '   }\n', '\n', '}']
