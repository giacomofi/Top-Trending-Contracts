['/* ==================================================================== */\n', '/* Copyright (c) 2018 The ether.online Project.  All rights reserved.\n', '/* \n', '/* https://ether.online  The first RPG game of blockchain \n', '/*  \n', '/* authors rickhunter.shen@gmail.com   \n', '/*         ssesunding@gmail.com            \n', '/* ==================================================================== */\n', '\n', 'pragma solidity ^0.4.20;\n', '\n', 'contract AccessAdmin {\n', '    bool public isPaused = false;\n', '    address public addrAdmin;  \n', '\n', '    event AdminTransferred(address indexed preAdmin, address indexed newAdmin);\n', '\n', '    function AccessAdmin() public {\n', '        addrAdmin = msg.sender;\n', '    }  \n', '\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == addrAdmin);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!isPaused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(isPaused);\n', '        _;\n', '    }\n', '\n', '    function setAdmin(address _newAdmin) external onlyAdmin {\n', '        require(_newAdmin != address(0));\n', '        AdminTransferred(addrAdmin, _newAdmin);\n', '        addrAdmin = _newAdmin;\n', '    }\n', '\n', '    function doPause() external onlyAdmin whenNotPaused {\n', '        isPaused = true;\n', '    }\n', '\n', '    function doUnpause() external onlyAdmin whenPaused {\n', '        isPaused = false;\n', '    }\n', '}\n', '\n', '\n', 'contract AccessService is AccessAdmin {\n', '    address public addrService;\n', '    address public addrFinance;\n', '\n', '    modifier onlyService() {\n', '        require(msg.sender == addrService);\n', '        _;\n', '    }\n', '\n', '    modifier onlyFinance() {\n', '        require(msg.sender == addrFinance);\n', '        _;\n', '    }\n', '\n', '    function setService(address _newService) external {\n', '        require(msg.sender == addrService || msg.sender == addrAdmin);\n', '        require(_newService != address(0));\n', '        addrService = _newService;\n', '    }\n', '\n', '    function setFinance(address _newFinance) external {\n', '        require(msg.sender == addrFinance || msg.sender == addrAdmin);\n', '        require(_newFinance != address(0));\n', '        addrFinance = _newFinance;\n', '    }\n', '\n', '    function withdraw(address _target, uint256 _amount) \n', '        external \n', '    {\n', '        require(msg.sender == addrFinance || msg.sender == addrAdmin);\n', '        require(_amount > 0);\n', '        address receiver = _target == address(0) ? addrFinance : _target;\n', '        uint256 balance = this.balance;\n', '        if (_amount < balance) {\n', '            receiver.transfer(_amount);\n', '        } else {\n', '            receiver.transfer(this.balance);\n', '        }      \n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface IBitGuildToken {\n', '    function transfer(address _to, uint256 _value) external;\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '    function approve(address _spender, uint256 _value) external; \n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) external returns (bool);\n', '    function balanceOf(address _from) external view returns(uint256);\n', '}\n', '\n', 'interface IAgonFight {\n', '    function calcFight(uint64 _mFlag, uint64 _cFlag, uint256 _aSeed, uint256 _fSeed) external pure returns(uint64);\n', '}\n', '\n', 'contract ActionAgonPlat is AccessService {\n', '    using SafeMath for uint256; \n', '\n', '    event CreateAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag);\n', '    event CancelAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag);\n', '    event ChallengeAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag, address challenger);\n', '    event ResolveAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag, address challenger);\n', '\n', '    struct Agon {\n', '        address master;\n', '        address challenger;\n', '        uint64 agonPrice;\n', '        uint64 outFlag;\n', '        uint64 agonFlag;    \n', '        uint64 result;      // 1-win, 2-lose, 99-cancel\n', '    }\n', '\n', '    Agon[] agonArray;\n', '    IAgonFight fightContract;\n', '    IBitGuildToken public bitGuildContract;\n', '\n', '    mapping (address => uint64[]) public ownerToAgonIdArray;\n', '    uint256 public maxAgonCount = 6;\n', '    uint256 public maxResolvedAgonId = 0; \n', '    uint256[5] public agonValues;\n', '\n', '    function ActionAgonPlat(address _platAddr) public {\n', '        addrAdmin = msg.sender;\n', '        addrService = msg.sender;\n', '        addrFinance = msg.sender;\n', '\n', '        bitGuildContract = IBitGuildToken(_platAddr);\n', '\n', '        Agon memory order = Agon(0, 0, 0, 0, 1, 1);\n', '        agonArray.push(order);\n', '        agonValues[0] = 3000000000000000000000;\n', '        agonValues[1] = 12000000000000000000000;\n', '        agonValues[2] = 30000000000000000000000;\n', '        agonValues[3] = 60000000000000000000000;\n', '        agonValues[4] = 120000000000000000000000;\n', '    }\n', '\n', '    function() external {}\n', '\n', '    function setMaxAgonCount(uint256 _count) external onlyAdmin {\n', '        require(_count > 0 && _count < 20);\n', '        require(_count != maxAgonCount);\n', '        maxAgonCount = _count;\n', '    }\n', '\n', '    function setAgonFight(address _addr) external onlyAdmin {\n', '        fightContract = IAgonFight(_addr);\n', '    }\n', '\n', '    function setMaxResolvedAgonId() external {\n', '        uint256 length = agonArray.length;\n', '        for (uint256 i = maxResolvedAgonId; i < length; ++i) {\n', '            if (agonArray[i].result == 0) {\n', '                maxResolvedAgonId = i - 1;\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    function setAgonValues(uint256[5] values) external onlyAdmin {\n', '        require(values[0] >= 100);\n', '        require(values[1] >= values[0]);\n', '        require(values[2] >= values[1]);\n', '        require(values[3] >= values[2]);\n', '        require(values[4] >= values[3]);\n', '        require(values[4] <= 600000); \n', '        require(values[0] % 100 == 0);\n', '        require(values[1] % 100 == 0);\n', '        require(values[2] % 100 == 0);\n', '        require(values[3] % 100 == 0);\n', '        require(values[4] % 100 == 0);\n', '        agonValues[0] = values[0].mul(1000000000000000000);\n', '        agonValues[1] = values[1].mul(1000000000000000000);\n', '        agonValues[2] = values[2].mul(1000000000000000000);\n', '        agonValues[3] = values[3].mul(1000000000000000000);\n', '        agonValues[4] = values[4].mul(1000000000000000000);\n', '    }\n', '\n', '    function _getExtraParam(bytes _extraData) internal pure returns(uint64 p1, uint64 p2, uint64 p3) {\n', '        p1 = uint64(_extraData[0]);\n', '        p2 = uint64(_extraData[1]);\n', '        uint64 index = 2;\n', '        uint256 val = 0;\n', '        uint256 length = _extraData.length;\n', '        while (index < length) {\n', '            val += (uint256(_extraData[index]) * (256 ** (length - index - 1)));\n', '            index += 1;\n', '        }\n', '        p3 = uint64(val);\n', '    }\n', '\n', '    function receiveApproval(address _sender, uint256 _value, address _tokenContract, bytes _extraData) \n', '        external \n', '        whenNotPaused \n', '    {\n', '        require(msg.sender == address(bitGuildContract));\n', '        require(_extraData.length > 2 && _extraData.length <= 10);\n', '        var (p1, p2, p3) = _getExtraParam(_extraData);\n', '        if (p1 == 0) {\n', '            _newAgon(p3, p2, _sender, _value);\n', '        } else if (p1 == 1) {\n', '            _newChallenge(p3, p2, _sender, _value);\n', '        } else {\n', '            require(false);\n', '        }\n', '    }\n', '\n', '    function _newAgon(uint64 _outFlag, uint64 _valId, address _sender, uint256 _value) internal {\n', '        require(ownerToAgonIdArray[_sender].length < maxAgonCount);\n', '        require(_valId >= 0 && _valId <= 4);\n', '        require(_value == agonValues[_valId]);\n', '        \n', '        require(bitGuildContract.transferFrom(_sender, address(this), _value));\n', '\n', '        uint64 newAgonId = uint64(agonArray.length);\n', '        agonArray.length += 1;\n', '        Agon storage agon = agonArray[newAgonId];\n', '        agon.master = _sender;\n', '        agon.agonPrice = uint64(_value.div(1000000000000000000)); \n', '        agon.outFlag = _outFlag;\n', '\n', '        ownerToAgonIdArray[_sender].push(newAgonId);\n', '\n', '        CreateAgonPlat(uint64(newAgonId), _sender, _outFlag);\n', '    } \n', '\n', '    function _removeAgonIdByOwner(address _owner, uint64 _agonId) internal {\n', '        uint64[] storage agonIdArray = ownerToAgonIdArray[_owner];\n', '        uint256 length = agonIdArray.length;\n', '        require(length > 0);\n', '        uint256 findIndex = 99;\n', '        for (uint256 i = 0; i < length; ++i) {\n', '            if (_agonId == agonIdArray[i]) {\n', '                findIndex = i;\n', '            }\n', '        }\n', '        require(findIndex != 99);\n', '        if (findIndex != (length - 1)) {\n', '            agonIdArray[findIndex] = agonIdArray[length - 1];\n', '        } \n', '        agonIdArray.length -= 1;\n', '    }\n', '\n', '    function cancelAgon(uint64 _agonId) external {\n', '        require(_agonId < agonArray.length);\n', '        Agon storage agon = agonArray[_agonId];\n', '        require(agon.result == 0);\n', '        require(agon.challenger == address(0));\n', '        require(agon.master == msg.sender);\n', '\n', '        agon.result = 99;\n', '        _removeAgonIdByOwner(msg.sender, _agonId);\n', '        bitGuildContract.transfer(msg.sender, uint256(agon.agonPrice).mul(1000000000000000000));\n', '\n', '        CancelAgonPlat(_agonId, msg.sender, agon.outFlag);\n', '    }\n', '\n', '    function cancelAgonForce(uint64 _agonId) external onlyService {\n', '        require(_agonId < agonArray.length);\n', '        Agon storage agon = agonArray[_agonId];\n', '        require(agon.result == 0);\n', '        require(agon.challenger == address(0));\n', '\n', '        agon.result = 99;\n', '        _removeAgonIdByOwner(agon.master, _agonId);\n', '        bitGuildContract.transfer(agon.master, uint256(agon.agonPrice).mul(1000000000000000000));\n', '\n', '        CancelAgonPlat(_agonId, agon.master, agon.outFlag);\n', '    }\n', '\n', '    function _newChallenge(uint64 _agonId, uint64 _flag, address _sender, uint256 _value) internal {\n', '        require(_agonId < agonArray.length);\n', '        Agon storage agon = agonArray[_agonId];\n', '        require(agon.result == 0);\n', '        require(agon.master != _sender);\n', '        require(uint256(agon.agonPrice).mul(1000000000000000000) == _value);\n', '        require(agon.challenger == address(0));\n', '\n', '        require(bitGuildContract.transferFrom(_sender, address(this), _value));\n', '\n', '        agon.challenger = _sender;\n', '        agon.agonFlag = _flag;\n', '        ChallengeAgonPlat(_agonId, agon.master, agon.outFlag, _sender);\n', '    }\n', '\n', '    function fightAgon(uint64 _agonId, uint64 _mFlag, uint256 _aSeed, uint256 _fSeed) external onlyService {\n', '        require(_agonId < agonArray.length);\n', '        Agon storage agon = agonArray[_agonId];\n', '        require(agon.result == 0 && agon.challenger != address(0));\n', '        require(fightContract != address(0));\n', '        uint64 fRet = fightContract.calcFight(_mFlag, agon.agonFlag, _aSeed, _fSeed);\n', '        require(fRet == 1 || fRet == 2);\n', '        agon.result = fRet;\n', '        _removeAgonIdByOwner(agon.master, _agonId);\n', '        uint256 devCut = uint256(agon.agonPrice).div(10);\n', '        uint256 winVal = uint256(agon.agonPrice).mul(2).sub(devCut);\n', '        if (fRet == 1) {\n', '            bitGuildContract.transfer(agon.master, winVal.mul(1000000000000000000));\n', '        } else {\n', '            bitGuildContract.transfer(agon.challenger, winVal.mul(1000000000000000000));\n', '        }\n', '\n', '        ResolveAgonPlat(_agonId, agon.master, agon.outFlag, agon.challenger);\n', '    }\n', '\n', '    function getPlatBalance() external view returns(uint256) {\n', '        return bitGuildContract.balanceOf(this);\n', '    }\n', '\n', '    function withdrawPlat() external {\n', '        require(msg.sender == addrFinance || msg.sender == addrAdmin);\n', '        uint256 balance = bitGuildContract.balanceOf(this);\n', '        require(balance > 0);\n', '        bitGuildContract.transfer(addrFinance, balance);\n', '    }\n', '\n', '    function getAgon(uint256 _agonId) external view\n', '        returns(\n', '            address master,\n', '            address challenger,\n', '            uint64 agonPrice,\n', '            uint64 outFlag,\n', '            uint64 agonFlag,\n', '            uint64 result\n', '        )\n', '    {\n', '        require(_agonId < agonArray.length);\n', '        Agon memory agon = agonArray[_agonId];\n', '        master = agon.master;\n', '        challenger = agon.challenger;\n', '        agonPrice = agon.agonPrice;\n', '        outFlag = agon.outFlag;\n', '        agonFlag = agon.agonFlag;\n', '        result = agon.result;\n', '    }\n', '\n', '    function getAgonArray(uint64 _startAgonId, uint64 _count) external view\n', '        returns(\n', '            uint64[] agonIds,\n', '            address[] masters,\n', '            address[] challengers,\n', '            uint64[] agonPrices,           \n', '            uint64[] agonOutFlags,\n', '            uint64[] agonFlags,\n', '            uint64[] results\n', '        ) \n', '    {\n', '        uint64 length = uint64(agonArray.length);\n', '        require(_startAgonId < length);\n', '        require(_startAgonId > 0);\n', '        uint256 maxLen;\n', '        if (_count == 0) {\n', '            maxLen = length - _startAgonId;\n', '        } else {\n', '            maxLen = (length - _startAgonId) >= _count ? _count : (length - _startAgonId);\n', '        }\n', '        agonIds = new uint64[](maxLen);\n', '        masters = new address[](maxLen);\n', '        challengers = new address[](maxLen);\n', '        agonPrices = new uint64[](maxLen);\n', '        agonOutFlags = new uint64[](maxLen);\n', '        agonFlags = new uint64[](maxLen);\n', '        results = new uint64[](maxLen);\n', '        uint256 counter = 0;\n', '        for (uint64 i = _startAgonId; i < length; ++i) {\n', '            Agon storage tmpAgon = agonArray[i];\n', '            agonIds[counter] = i;\n', '            masters[counter] = tmpAgon.master;\n', '            challengers[counter] = tmpAgon.challenger;\n', '            agonPrices[counter] = tmpAgon.agonPrice;\n', '            agonOutFlags[counter] = tmpAgon.outFlag;\n', '            agonFlags[counter] = tmpAgon.agonFlag;\n', '            results[counter] = tmpAgon.result;\n', '            counter += 1;\n', '            if (counter >= maxLen) {\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    function getMaxAgonId() external view returns(uint256) {\n', '        return agonArray.length - 1;\n', '    }\n', '\n', '    function getAgonIdArray(address _owner) external view returns(uint64[]) {\n', '        return ownerToAgonIdArray[_owner];\n', '    }\n', '}']
['/* ==================================================================== */\n', '/* Copyright (c) 2018 The ether.online Project.  All rights reserved.\n', '/* \n', '/* https://ether.online  The first RPG game of blockchain \n', '/*  \n', '/* authors rickhunter.shen@gmail.com   \n', '/*         ssesunding@gmail.com            \n', '/* ==================================================================== */\n', '\n', 'pragma solidity ^0.4.20;\n', '\n', 'contract AccessAdmin {\n', '    bool public isPaused = false;\n', '    address public addrAdmin;  \n', '\n', '    event AdminTransferred(address indexed preAdmin, address indexed newAdmin);\n', '\n', '    function AccessAdmin() public {\n', '        addrAdmin = msg.sender;\n', '    }  \n', '\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == addrAdmin);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!isPaused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(isPaused);\n', '        _;\n', '    }\n', '\n', '    function setAdmin(address _newAdmin) external onlyAdmin {\n', '        require(_newAdmin != address(0));\n', '        AdminTransferred(addrAdmin, _newAdmin);\n', '        addrAdmin = _newAdmin;\n', '    }\n', '\n', '    function doPause() external onlyAdmin whenNotPaused {\n', '        isPaused = true;\n', '    }\n', '\n', '    function doUnpause() external onlyAdmin whenPaused {\n', '        isPaused = false;\n', '    }\n', '}\n', '\n', '\n', 'contract AccessService is AccessAdmin {\n', '    address public addrService;\n', '    address public addrFinance;\n', '\n', '    modifier onlyService() {\n', '        require(msg.sender == addrService);\n', '        _;\n', '    }\n', '\n', '    modifier onlyFinance() {\n', '        require(msg.sender == addrFinance);\n', '        _;\n', '    }\n', '\n', '    function setService(address _newService) external {\n', '        require(msg.sender == addrService || msg.sender == addrAdmin);\n', '        require(_newService != address(0));\n', '        addrService = _newService;\n', '    }\n', '\n', '    function setFinance(address _newFinance) external {\n', '        require(msg.sender == addrFinance || msg.sender == addrAdmin);\n', '        require(_newFinance != address(0));\n', '        addrFinance = _newFinance;\n', '    }\n', '\n', '    function withdraw(address _target, uint256 _amount) \n', '        external \n', '    {\n', '        require(msg.sender == addrFinance || msg.sender == addrAdmin);\n', '        require(_amount > 0);\n', '        address receiver = _target == address(0) ? addrFinance : _target;\n', '        uint256 balance = this.balance;\n', '        if (_amount < balance) {\n', '            receiver.transfer(_amount);\n', '        } else {\n', '            receiver.transfer(this.balance);\n', '        }      \n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface IBitGuildToken {\n', '    function transfer(address _to, uint256 _value) external;\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '    function approve(address _spender, uint256 _value) external; \n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) external returns (bool);\n', '    function balanceOf(address _from) external view returns(uint256);\n', '}\n', '\n', 'interface IAgonFight {\n', '    function calcFight(uint64 _mFlag, uint64 _cFlag, uint256 _aSeed, uint256 _fSeed) external pure returns(uint64);\n', '}\n', '\n', 'contract ActionAgonPlat is AccessService {\n', '    using SafeMath for uint256; \n', '\n', '    event CreateAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag);\n', '    event CancelAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag);\n', '    event ChallengeAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag, address challenger);\n', '    event ResolveAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag, address challenger);\n', '\n', '    struct Agon {\n', '        address master;\n', '        address challenger;\n', '        uint64 agonPrice;\n', '        uint64 outFlag;\n', '        uint64 agonFlag;    \n', '        uint64 result;      // 1-win, 2-lose, 99-cancel\n', '    }\n', '\n', '    Agon[] agonArray;\n', '    IAgonFight fightContract;\n', '    IBitGuildToken public bitGuildContract;\n', '\n', '    mapping (address => uint64[]) public ownerToAgonIdArray;\n', '    uint256 public maxAgonCount = 6;\n', '    uint256 public maxResolvedAgonId = 0; \n', '    uint256[5] public agonValues;\n', '\n', '    function ActionAgonPlat(address _platAddr) public {\n', '        addrAdmin = msg.sender;\n', '        addrService = msg.sender;\n', '        addrFinance = msg.sender;\n', '\n', '        bitGuildContract = IBitGuildToken(_platAddr);\n', '\n', '        Agon memory order = Agon(0, 0, 0, 0, 1, 1);\n', '        agonArray.push(order);\n', '        agonValues[0] = 3000000000000000000000;\n', '        agonValues[1] = 12000000000000000000000;\n', '        agonValues[2] = 30000000000000000000000;\n', '        agonValues[3] = 60000000000000000000000;\n', '        agonValues[4] = 120000000000000000000000;\n', '    }\n', '\n', '    function() external {}\n', '\n', '    function setMaxAgonCount(uint256 _count) external onlyAdmin {\n', '        require(_count > 0 && _count < 20);\n', '        require(_count != maxAgonCount);\n', '        maxAgonCount = _count;\n', '    }\n', '\n', '    function setAgonFight(address _addr) external onlyAdmin {\n', '        fightContract = IAgonFight(_addr);\n', '    }\n', '\n', '    function setMaxResolvedAgonId() external {\n', '        uint256 length = agonArray.length;\n', '        for (uint256 i = maxResolvedAgonId; i < length; ++i) {\n', '            if (agonArray[i].result == 0) {\n', '                maxResolvedAgonId = i - 1;\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    function setAgonValues(uint256[5] values) external onlyAdmin {\n', '        require(values[0] >= 100);\n', '        require(values[1] >= values[0]);\n', '        require(values[2] >= values[1]);\n', '        require(values[3] >= values[2]);\n', '        require(values[4] >= values[3]);\n', '        require(values[4] <= 600000); \n', '        require(values[0] % 100 == 0);\n', '        require(values[1] % 100 == 0);\n', '        require(values[2] % 100 == 0);\n', '        require(values[3] % 100 == 0);\n', '        require(values[4] % 100 == 0);\n', '        agonValues[0] = values[0].mul(1000000000000000000);\n', '        agonValues[1] = values[1].mul(1000000000000000000);\n', '        agonValues[2] = values[2].mul(1000000000000000000);\n', '        agonValues[3] = values[3].mul(1000000000000000000);\n', '        agonValues[4] = values[4].mul(1000000000000000000);\n', '    }\n', '\n', '    function _getExtraParam(bytes _extraData) internal pure returns(uint64 p1, uint64 p2, uint64 p3) {\n', '        p1 = uint64(_extraData[0]);\n', '        p2 = uint64(_extraData[1]);\n', '        uint64 index = 2;\n', '        uint256 val = 0;\n', '        uint256 length = _extraData.length;\n', '        while (index < length) {\n', '            val += (uint256(_extraData[index]) * (256 ** (length - index - 1)));\n', '            index += 1;\n', '        }\n', '        p3 = uint64(val);\n', '    }\n', '\n', '    function receiveApproval(address _sender, uint256 _value, address _tokenContract, bytes _extraData) \n', '        external \n', '        whenNotPaused \n', '    {\n', '        require(msg.sender == address(bitGuildContract));\n', '        require(_extraData.length > 2 && _extraData.length <= 10);\n', '        var (p1, p2, p3) = _getExtraParam(_extraData);\n', '        if (p1 == 0) {\n', '            _newAgon(p3, p2, _sender, _value);\n', '        } else if (p1 == 1) {\n', '            _newChallenge(p3, p2, _sender, _value);\n', '        } else {\n', '            require(false);\n', '        }\n', '    }\n', '\n', '    function _newAgon(uint64 _outFlag, uint64 _valId, address _sender, uint256 _value) internal {\n', '        require(ownerToAgonIdArray[_sender].length < maxAgonCount);\n', '        require(_valId >= 0 && _valId <= 4);\n', '        require(_value == agonValues[_valId]);\n', '        \n', '        require(bitGuildContract.transferFrom(_sender, address(this), _value));\n', '\n', '        uint64 newAgonId = uint64(agonArray.length);\n', '        agonArray.length += 1;\n', '        Agon storage agon = agonArray[newAgonId];\n', '        agon.master = _sender;\n', '        agon.agonPrice = uint64(_value.div(1000000000000000000)); \n', '        agon.outFlag = _outFlag;\n', '\n', '        ownerToAgonIdArray[_sender].push(newAgonId);\n', '\n', '        CreateAgonPlat(uint64(newAgonId), _sender, _outFlag);\n', '    } \n', '\n', '    function _removeAgonIdByOwner(address _owner, uint64 _agonId) internal {\n', '        uint64[] storage agonIdArray = ownerToAgonIdArray[_owner];\n', '        uint256 length = agonIdArray.length;\n', '        require(length > 0);\n', '        uint256 findIndex = 99;\n', '        for (uint256 i = 0; i < length; ++i) {\n', '            if (_agonId == agonIdArray[i]) {\n', '                findIndex = i;\n', '            }\n', '        }\n', '        require(findIndex != 99);\n', '        if (findIndex != (length - 1)) {\n', '            agonIdArray[findIndex] = agonIdArray[length - 1];\n', '        } \n', '        agonIdArray.length -= 1;\n', '    }\n', '\n', '    function cancelAgon(uint64 _agonId) external {\n', '        require(_agonId < agonArray.length);\n', '        Agon storage agon = agonArray[_agonId];\n', '        require(agon.result == 0);\n', '        require(agon.challenger == address(0));\n', '        require(agon.master == msg.sender);\n', '\n', '        agon.result = 99;\n', '        _removeAgonIdByOwner(msg.sender, _agonId);\n', '        bitGuildContract.transfer(msg.sender, uint256(agon.agonPrice).mul(1000000000000000000));\n', '\n', '        CancelAgonPlat(_agonId, msg.sender, agon.outFlag);\n', '    }\n', '\n', '    function cancelAgonForce(uint64 _agonId) external onlyService {\n', '        require(_agonId < agonArray.length);\n', '        Agon storage agon = agonArray[_agonId];\n', '        require(agon.result == 0);\n', '        require(agon.challenger == address(0));\n', '\n', '        agon.result = 99;\n', '        _removeAgonIdByOwner(agon.master, _agonId);\n', '        bitGuildContract.transfer(agon.master, uint256(agon.agonPrice).mul(1000000000000000000));\n', '\n', '        CancelAgonPlat(_agonId, agon.master, agon.outFlag);\n', '    }\n', '\n', '    function _newChallenge(uint64 _agonId, uint64 _flag, address _sender, uint256 _value) internal {\n', '        require(_agonId < agonArray.length);\n', '        Agon storage agon = agonArray[_agonId];\n', '        require(agon.result == 0);\n', '        require(agon.master != _sender);\n', '        require(uint256(agon.agonPrice).mul(1000000000000000000) == _value);\n', '        require(agon.challenger == address(0));\n', '\n', '        require(bitGuildContract.transferFrom(_sender, address(this), _value));\n', '\n', '        agon.challenger = _sender;\n', '        agon.agonFlag = _flag;\n', '        ChallengeAgonPlat(_agonId, agon.master, agon.outFlag, _sender);\n', '    }\n', '\n', '    function fightAgon(uint64 _agonId, uint64 _mFlag, uint256 _aSeed, uint256 _fSeed) external onlyService {\n', '        require(_agonId < agonArray.length);\n', '        Agon storage agon = agonArray[_agonId];\n', '        require(agon.result == 0 && agon.challenger != address(0));\n', '        require(fightContract != address(0));\n', '        uint64 fRet = fightContract.calcFight(_mFlag, agon.agonFlag, _aSeed, _fSeed);\n', '        require(fRet == 1 || fRet == 2);\n', '        agon.result = fRet;\n', '        _removeAgonIdByOwner(agon.master, _agonId);\n', '        uint256 devCut = uint256(agon.agonPrice).div(10);\n', '        uint256 winVal = uint256(agon.agonPrice).mul(2).sub(devCut);\n', '        if (fRet == 1) {\n', '            bitGuildContract.transfer(agon.master, winVal.mul(1000000000000000000));\n', '        } else {\n', '            bitGuildContract.transfer(agon.challenger, winVal.mul(1000000000000000000));\n', '        }\n', '\n', '        ResolveAgonPlat(_agonId, agon.master, agon.outFlag, agon.challenger);\n', '    }\n', '\n', '    function getPlatBalance() external view returns(uint256) {\n', '        return bitGuildContract.balanceOf(this);\n', '    }\n', '\n', '    function withdrawPlat() external {\n', '        require(msg.sender == addrFinance || msg.sender == addrAdmin);\n', '        uint256 balance = bitGuildContract.balanceOf(this);\n', '        require(balance > 0);\n', '        bitGuildContract.transfer(addrFinance, balance);\n', '    }\n', '\n', '    function getAgon(uint256 _agonId) external view\n', '        returns(\n', '            address master,\n', '            address challenger,\n', '            uint64 agonPrice,\n', '            uint64 outFlag,\n', '            uint64 agonFlag,\n', '            uint64 result\n', '        )\n', '    {\n', '        require(_agonId < agonArray.length);\n', '        Agon memory agon = agonArray[_agonId];\n', '        master = agon.master;\n', '        challenger = agon.challenger;\n', '        agonPrice = agon.agonPrice;\n', '        outFlag = agon.outFlag;\n', '        agonFlag = agon.agonFlag;\n', '        result = agon.result;\n', '    }\n', '\n', '    function getAgonArray(uint64 _startAgonId, uint64 _count) external view\n', '        returns(\n', '            uint64[] agonIds,\n', '            address[] masters,\n', '            address[] challengers,\n', '            uint64[] agonPrices,           \n', '            uint64[] agonOutFlags,\n', '            uint64[] agonFlags,\n', '            uint64[] results\n', '        ) \n', '    {\n', '        uint64 length = uint64(agonArray.length);\n', '        require(_startAgonId < length);\n', '        require(_startAgonId > 0);\n', '        uint256 maxLen;\n', '        if (_count == 0) {\n', '            maxLen = length - _startAgonId;\n', '        } else {\n', '            maxLen = (length - _startAgonId) >= _count ? _count : (length - _startAgonId);\n', '        }\n', '        agonIds = new uint64[](maxLen);\n', '        masters = new address[](maxLen);\n', '        challengers = new address[](maxLen);\n', '        agonPrices = new uint64[](maxLen);\n', '        agonOutFlags = new uint64[](maxLen);\n', '        agonFlags = new uint64[](maxLen);\n', '        results = new uint64[](maxLen);\n', '        uint256 counter = 0;\n', '        for (uint64 i = _startAgonId; i < length; ++i) {\n', '            Agon storage tmpAgon = agonArray[i];\n', '            agonIds[counter] = i;\n', '            masters[counter] = tmpAgon.master;\n', '            challengers[counter] = tmpAgon.challenger;\n', '            agonPrices[counter] = tmpAgon.agonPrice;\n', '            agonOutFlags[counter] = tmpAgon.outFlag;\n', '            agonFlags[counter] = tmpAgon.agonFlag;\n', '            results[counter] = tmpAgon.result;\n', '            counter += 1;\n', '            if (counter >= maxLen) {\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    function getMaxAgonId() external view returns(uint256) {\n', '        return agonArray.length - 1;\n', '    }\n', '\n', '    function getAgonIdArray(address _owner) external view returns(uint64[]) {\n', '        return ownerToAgonIdArray[_owner];\n', '    }\n', '}']
