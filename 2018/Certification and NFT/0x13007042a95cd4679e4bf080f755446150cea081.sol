['pragma solidity ^0.4.25;\n', '\n', 'contract subsetSum {\n', '    // Written by Ciar&#225;n &#211; hAol&#225;in, Maynooth University 2018\n', '\n', '    // Data types that we need\n', '    struct Number {\n', '        bool exists;\n', '        bool isUsed;\n', '    }\n', '    struct Leader {\n', '        address id;\n', '        uint256 difference;\n', '        uint256[] negativeSet;\n', '        uint256[] positiveSet;\n', '    }\n', '\n', '    // Things that we need to store\n', '    uint256[] numbers;\n', '    mapping (uint256 => Number) numberCheck;\n', '    mapping (address => bool) authorisedEntrants;\n', '    uint256 expiryTime;\n', '    address admin;\n', '    Leader leader;\n', '\n', '    // Initial set up\n', '    constructor (uint256[] memory setElements, uint256 expiry) public {\n', '        require(setElements.length>0 && expiry > now, &#39;Invalid parameters&#39;);\n', '        numbers = setElements;\n', '        for (uint256 i = 0; i<setElements.length; i++) {\n', '            numberCheck[setElements[i]].exists=true;\n', '        }\n', '        expiryTime = expiry;\n', '        admin = msg.sender;\n', '    }\n', '\n', '    // Record an event on the blockchain whenever a new record is recorded\n', '    event RunnerUpSubmission(address indexed submitter, uint256 submitterSolutionDifference);\n', '    event NewRecord(address indexed newRecordHolder, uint256 newRecordDifference);\n', '\n', '    // Only for the competition administrator\n', '    modifier adminOnly {\n', '        require(msg.sender==admin, &#39;This requires admin privileges&#39;);\n', '        _;\n', '    }\n', '\n', '    // Only for authorised entrants\n', '    modifier restrictedAccess {\n', '        require(now<expiryTime && authorisedEntrants[msg.sender], &#39;Unauthorised entrant&#39;);\n', '        _;\n', '    }\n', '\n', '    // Withdrawal of prize pot is only allowed after the competition is over, if and only if\n', '    // the withdrawer is currently on top of the leaderboard OR\n', '    // there is no leader, so admin requests withdrawal OR\n', '    // a month has passed after the deadline and the winner hasn&#39;t withdrawn the prize pot, so admin requests withdrawal.\n', '    modifier winnerOnly {\n', '        require(now>expiryTime && (msg.sender==leader.id || ((address(0)==leader.id || now>expiryTime+2629746) && msg.sender==admin)), "You don&#39;t have permission to withdraw the prize");\n', '        _;\n', '    }\n', '\n', '    // Get the numbers in the problem set\n', '    function getNumbers() public view returns(uint256[] numberSet) {\n', '        return numbers;\n', '    }\n', '\n', '    // Get the details of the current leader on the leaderboard\n', '    function getRecord() public view returns (address winningAddress, uint256 difference, uint256[] negativeSet, uint256[] positiveSet) {\n', '        return (leader.id, leader.difference, leader.negativeSet, leader.positiveSet);\n', '    }\n', '\n', '    // Get the current amount of money in the prize pot guaranteed to the person at the top of the leaderboard when the competition concludes.\n', '    function getPrizePot() public view returns (uint256 prizeFundAmount) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    // Get the expiry timestamp of the contract\n', '    function getExpiryDate() public view returns (uint256 expiryTimestamp) {\n', '        return expiryTime;\n', '    }\n', '    \n', '    // Get all the important Data\n', '    function getData() public view returns(uint256[] numberSet, address winningAddress, uint256 prizeFundAmount, uint256 expiryTimestamp) {\n', '        return (numbers, leader.id, address(this).balance, expiryTime);\n', '    }\n', '\n', '    // This (fallback) function allows anybody to add to the prize pot by simply sending ETH to the contract&#39;s address\n', '    function () public payable {    }\n', '\n', '    // For the sake of vanity...\n', '    function getAuthor() public pure returns (string authorName) {\n', '      return "Written by Ciar&#225;n &#211; hAol&#225;in, Maynooth University 2018";\n', '    }\n', '\n', '    // This functions allows the admin to authorise ETH addresses to enter the competition\n', '    function authoriseEntrants(address[] addressesToAuthorise) public adminOnly {\n', '        for (uint256 i = 0; i<addressesToAuthorise.length; i++) authorisedEntrants[addressesToAuthorise[i]]=true;\n', '    }\n', '\n', '    // Allows people to submit a new answer to the leaderboard. If it beats the current record, the new attempt will be recorded on the leaderboard.\n', '    function submitAnswer(uint256[] negativeSetSubmission, uint256[] positiveSetSubmission) public restrictedAccess returns (string response) {\n', '        require(negativeSetSubmission.length+positiveSetSubmission.length>0, &#39;Invalid submission.&#39;);\n', '        uint256 sumNegative = 0;\n', '        uint256 sumPositive = 0;\n', '        // Add everything up\n', '        for (uint256 i = 0; i<negativeSetSubmission.length; i++) {\n', '            require(numberCheck[negativeSetSubmission[i]].exists && !numberCheck[negativeSetSubmission[i]].isUsed, &#39;Invalid submission.&#39;);\n', '            sumNegative+=negativeSetSubmission[i];\n', '            numberCheck[negativeSetSubmission[i]].isUsed = true;\n', '        }\n', '        for (i = 0; i<positiveSetSubmission.length; i++) {\n', '            require(numberCheck[positiveSetSubmission[i]].exists && !numberCheck[positiveSetSubmission[i]].isUsed, &#39;Invalid submission.&#39;);\n', '            sumPositive+=positiveSetSubmission[i];\n', '            numberCheck[positiveSetSubmission[i]].isUsed = true;\n', '        }\n', '        // Input looks valid, now set everything back to normal\n', '        for (i = 0; i<negativeSetSubmission.length; i++) numberCheck[negativeSetSubmission[i]].isUsed = false;\n', '        for (i = 0; i<positiveSetSubmission.length; i++) numberCheck[positiveSetSubmission[i]].isUsed = false;\n', '        // Check the new result, if it&#39;s a new record, record it\n', '        uint256 difference = _diff(sumNegative, sumPositive);\n', '        if (leader.id==address(0) || difference<leader.difference) {\n', '            leader.id = msg.sender;\n', '            leader.difference=difference;\n', '            leader.negativeSet=negativeSetSubmission;\n', '            leader.positiveSet=positiveSetSubmission;\n', '            emit NewRecord(msg.sender, difference);\n', '            return "Congratulations, you are now on the top of the leaderboard.";\n', '        } else {\n', '            emit RunnerUpSubmission(msg.sender, difference);\n', '            return "Sorry, you haven&#39;t beaten the record.";\n', '        }\n', '    }\n', '\n', '    // Allows the winner to withdraw the prize pot\n', '    function withdrawPrize(address prizeRecipient) public winnerOnly {\n', '        prizeRecipient.transfer(address(this).balance);\n', '    }\n', '\n', '    // Internal function to check results\n', '    function _diff(uint256 a, uint256 b) private pure returns (uint256 difference) {\n', '        if (a>b) return a-b;\n', '        else return b-a;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.25;\n', '\n', 'contract subsetSum {\n', '    // Written by Ciarán Ó hAoláin, Maynooth University 2018\n', '\n', '    // Data types that we need\n', '    struct Number {\n', '        bool exists;\n', '        bool isUsed;\n', '    }\n', '    struct Leader {\n', '        address id;\n', '        uint256 difference;\n', '        uint256[] negativeSet;\n', '        uint256[] positiveSet;\n', '    }\n', '\n', '    // Things that we need to store\n', '    uint256[] numbers;\n', '    mapping (uint256 => Number) numberCheck;\n', '    mapping (address => bool) authorisedEntrants;\n', '    uint256 expiryTime;\n', '    address admin;\n', '    Leader leader;\n', '\n', '    // Initial set up\n', '    constructor (uint256[] memory setElements, uint256 expiry) public {\n', "        require(setElements.length>0 && expiry > now, 'Invalid parameters');\n", '        numbers = setElements;\n', '        for (uint256 i = 0; i<setElements.length; i++) {\n', '            numberCheck[setElements[i]].exists=true;\n', '        }\n', '        expiryTime = expiry;\n', '        admin = msg.sender;\n', '    }\n', '\n', '    // Record an event on the blockchain whenever a new record is recorded\n', '    event RunnerUpSubmission(address indexed submitter, uint256 submitterSolutionDifference);\n', '    event NewRecord(address indexed newRecordHolder, uint256 newRecordDifference);\n', '\n', '    // Only for the competition administrator\n', '    modifier adminOnly {\n', "        require(msg.sender==admin, 'This requires admin privileges');\n", '        _;\n', '    }\n', '\n', '    // Only for authorised entrants\n', '    modifier restrictedAccess {\n', "        require(now<expiryTime && authorisedEntrants[msg.sender], 'Unauthorised entrant');\n", '        _;\n', '    }\n', '\n', '    // Withdrawal of prize pot is only allowed after the competition is over, if and only if\n', '    // the withdrawer is currently on top of the leaderboard OR\n', '    // there is no leader, so admin requests withdrawal OR\n', "    // a month has passed after the deadline and the winner hasn't withdrawn the prize pot, so admin requests withdrawal.\n", '    modifier winnerOnly {\n', '        require(now>expiryTime && (msg.sender==leader.id || ((address(0)==leader.id || now>expiryTime+2629746) && msg.sender==admin)), "You don\'t have permission to withdraw the prize");\n', '        _;\n', '    }\n', '\n', '    // Get the numbers in the problem set\n', '    function getNumbers() public view returns(uint256[] numberSet) {\n', '        return numbers;\n', '    }\n', '\n', '    // Get the details of the current leader on the leaderboard\n', '    function getRecord() public view returns (address winningAddress, uint256 difference, uint256[] negativeSet, uint256[] positiveSet) {\n', '        return (leader.id, leader.difference, leader.negativeSet, leader.positiveSet);\n', '    }\n', '\n', '    // Get the current amount of money in the prize pot guaranteed to the person at the top of the leaderboard when the competition concludes.\n', '    function getPrizePot() public view returns (uint256 prizeFundAmount) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    // Get the expiry timestamp of the contract\n', '    function getExpiryDate() public view returns (uint256 expiryTimestamp) {\n', '        return expiryTime;\n', '    }\n', '    \n', '    // Get all the important Data\n', '    function getData() public view returns(uint256[] numberSet, address winningAddress, uint256 prizeFundAmount, uint256 expiryTimestamp) {\n', '        return (numbers, leader.id, address(this).balance, expiryTime);\n', '    }\n', '\n', "    // This (fallback) function allows anybody to add to the prize pot by simply sending ETH to the contract's address\n", '    function () public payable {    }\n', '\n', '    // For the sake of vanity...\n', '    function getAuthor() public pure returns (string authorName) {\n', '      return "Written by Ciarán Ó hAoláin, Maynooth University 2018";\n', '    }\n', '\n', '    // This functions allows the admin to authorise ETH addresses to enter the competition\n', '    function authoriseEntrants(address[] addressesToAuthorise) public adminOnly {\n', '        for (uint256 i = 0; i<addressesToAuthorise.length; i++) authorisedEntrants[addressesToAuthorise[i]]=true;\n', '    }\n', '\n', '    // Allows people to submit a new answer to the leaderboard. If it beats the current record, the new attempt will be recorded on the leaderboard.\n', '    function submitAnswer(uint256[] negativeSetSubmission, uint256[] positiveSetSubmission) public restrictedAccess returns (string response) {\n', "        require(negativeSetSubmission.length+positiveSetSubmission.length>0, 'Invalid submission.');\n", '        uint256 sumNegative = 0;\n', '        uint256 sumPositive = 0;\n', '        // Add everything up\n', '        for (uint256 i = 0; i<negativeSetSubmission.length; i++) {\n', "            require(numberCheck[negativeSetSubmission[i]].exists && !numberCheck[negativeSetSubmission[i]].isUsed, 'Invalid submission.');\n", '            sumNegative+=negativeSetSubmission[i];\n', '            numberCheck[negativeSetSubmission[i]].isUsed = true;\n', '        }\n', '        for (i = 0; i<positiveSetSubmission.length; i++) {\n', "            require(numberCheck[positiveSetSubmission[i]].exists && !numberCheck[positiveSetSubmission[i]].isUsed, 'Invalid submission.');\n", '            sumPositive+=positiveSetSubmission[i];\n', '            numberCheck[positiveSetSubmission[i]].isUsed = true;\n', '        }\n', '        // Input looks valid, now set everything back to normal\n', '        for (i = 0; i<negativeSetSubmission.length; i++) numberCheck[negativeSetSubmission[i]].isUsed = false;\n', '        for (i = 0; i<positiveSetSubmission.length; i++) numberCheck[positiveSetSubmission[i]].isUsed = false;\n', "        // Check the new result, if it's a new record, record it\n", '        uint256 difference = _diff(sumNegative, sumPositive);\n', '        if (leader.id==address(0) || difference<leader.difference) {\n', '            leader.id = msg.sender;\n', '            leader.difference=difference;\n', '            leader.negativeSet=negativeSetSubmission;\n', '            leader.positiveSet=positiveSetSubmission;\n', '            emit NewRecord(msg.sender, difference);\n', '            return "Congratulations, you are now on the top of the leaderboard.";\n', '        } else {\n', '            emit RunnerUpSubmission(msg.sender, difference);\n', '            return "Sorry, you haven\'t beaten the record.";\n', '        }\n', '    }\n', '\n', '    // Allows the winner to withdraw the prize pot\n', '    function withdrawPrize(address prizeRecipient) public winnerOnly {\n', '        prizeRecipient.transfer(address(this).balance);\n', '    }\n', '\n', '    // Internal function to check results\n', '    function _diff(uint256 a, uint256 b) private pure returns (uint256 difference) {\n', '        if (a>b) return a-b;\n', '        else return b-a;\n', '    }\n', '\n', '}']
