['pragma solidity ^0.4.22;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is not paused.\n', '    *               契約が一時停止されている場合にのみアクションを許可する\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is paused.\n', '    *               契約が一時停止されていない場合にのみアクションを許可する\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    *             一時停止するために所有者によって呼び出され、停止状態をトリガする\n', '    */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to unpause, returns to normal state\n', '    *             ポーズをとるためにオーナーが呼び出し、通常の状態に戻ります\n', '    */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', 'contract RocsBase is Pausable {\n', '\n', '    // 生誕代\n', '    uint128 public eggPrice = 50 finney;\n', '    function setEggPrice(uint128 _price) public onlyOwner {\n', '        eggPrice = _price;\n', '    }\n', '    // 進化代\n', '    uint128 public evolvePrice = 5 finney;\n', '    function setEvolvePrice(uint128 _price) public onlyOwner {\n', '        evolvePrice = _price;\n', '    }\n', '\n', '    // 生誕\n', '    event RocCreated(address owner, uint tokenId, uint rocId);\n', '    // ERC721\n', '    event Transfer(address from, address to, uint tokenId);\n', '    event ItemTransfer(address from, address to, uint tokenId);\n', '\n', '    /// @dev Rocの構造体\n', '    struct Roc {\n', '        // ID\n', '        uint rocId;\n', '        // DNA\n', '        string dna;\n', '        // 出品中フラグ 1は出品中\n', '        uint8 marketsFlg;\n', '    }\n', '\n', '    /// @dev Rocsの配列\n', '    Roc[] public rocs;\n', '\n', '    // rocIdとtokenIdのマッピング\n', '    mapping(uint => uint) public rocIndex;\n', '    // rocIdからtokenIdを取得\n', '    function getRocIdToTokenId(uint _rocId) public view returns (uint) {\n', '        return rocIndex[_rocId];\n', '    }\n', '\n', '    /// @dev 所有するアドレスへのマッピング\n', '    mapping (uint => address) public rocIndexToOwner;\n', '    // @dev 所有者アドレスから所有するトークン数へのマッピング\n', '    mapping (address => uint) public ownershipTokenCount;\n', '    /// @dev 呼び出しが承認されたアドレスへのマッピング\n', '    mapping (uint => address) public rocIndexToApproved;\n', '\n', '    /// @dev 特定のRocの所有権をアドレスに割り当てます。\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        ownershipTokenCount[_to]++;\n', '        ownershipTokenCount[_from]--;\n', '        rocIndexToOwner[_tokenId] = _to;\n', '        // イベント開始\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '}\n', '\n', '/// @title ERC-721に準拠した契約のインタフェース：置き換え不可能なトークン\n', 'contract ERC721 {\n', '    // イベント\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '    // 必要なメソッド\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint256 _tokenId) external view returns (address _owner);\n', '    function approve(address _to, uint256 _tokenId) external;\n', '    function transfer(address _to, uint256 _tokenId) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function totalSupply() public view returns (uint);\n', '\n', '    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '}\n', '\n', '/// @title Roc所有権を管理するコントラクト\n', '/// @dev OpenZeppelinのERC721ドラフト実装に準拠\n', 'contract RocsOwnership is RocsBase, ERC721 {\n', '\n', '    /// @notice ERC721で定義されている、置き換え不可能なトークンの名前と記号。\n', '    string public constant name = "CryptoFeather";\n', '    string public constant symbol = "CFE";\n', '\n', '    bytes4 constant InterfaceSignature_ERC165 = \n', '    bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));\n', '\n', '    bytes4 constant InterfaceSignature_ERC721 =\n', '    bytes4(keccak256(&#39;name()&#39;)) ^\n', '    bytes4(keccak256(&#39;symbol()&#39;)) ^\n', '    bytes4(keccak256(&#39;balanceOf(address)&#39;)) ^\n', '    bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;approve(address,uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;transfer(address,uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;transferFrom(address,address,uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;totalSupply()&#39;));\n', '\n', '    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n', '    ///  この契約によって実装された標準化されたインタフェースでtrueを返します。\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\n', '    {\n', '        // DEBUG ONLY\n', '        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\n', '        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\n', '    }\n', '\n', '    /// @dev 特定のアドレスに指定されたrocの現在の所有者であるかどうかをチェックします。\n', '    /// @param _claimant \n', '    /// @param _tokenId \n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return rocIndexToOwner[_tokenId] == _claimant;\n', '    }\n', '\n', '    /// @dev 特定のアドレスに指定されたrocが存在するかどうかをチェックします。\n', '    /// @param _claimant the address we are confirming kitten is approved for.\n', '    /// @param _tokenId kitten id, only valid when > 0\n', '    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return rocIndexToApproved[_tokenId] == _claimant;\n', '    }\n', '\n', '    /// @dev 以前の承認を上書きして、transferFrom（）に対して承認されたアドレスをマークします。\n', '    function _approve(uint256 _tokenId, address _approved) internal {\n', '        rocIndexToApproved[_tokenId] = _approved;\n', '    }\n', '\n', '    // 指定されたアドレスのroc数を取得します。\n', '    function balanceOf(address _owner) public view returns (uint256 count) {\n', '        return ownershipTokenCount[_owner];\n', '    }\n', '\n', '    /// @notice rocの所有者を変更します。\n', '    /// @dev ERC-721への準拠に必要\n', '    function transfer(address _to, uint256 _tokenId) public whenNotPaused {\n', '        // 安全チェック\n', '        require(_to != address(0));\n', '        // 自分のrocしか送ることはできません。\n', '        require(_owns(msg.sender, _tokenId));\n', '        // 所有権の再割り当て、保留中の承認のクリア、転送イベントの送信\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /// @notice transferFrom（）を介して別のアドレスに特定のrocを転送する権利を与えます。\n', '    /// @dev ERC-721への準拠に必要\n', '    function approve(address _to, uint256 _tokenId) external whenNotPaused {\n', '        // 所有者のみが譲渡承認を認めることができます。\n', '        require(_owns(msg.sender, _tokenId));\n', '        // 承認を登録します（以前の承認を置き換えます）。\n', '        _approve(_tokenId, _to);\n', '        // 承認イベントを発行する。\n', '        emit Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /// @notice roc所有者の変更を行います。を転送します。そのアドレスには、以前の所有者から転送承認が与えられています。\n', '    /// @dev ERC-721への準拠に必要\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public whenNotPaused {\n', '        // 安全チェック。\n', '        require(_to != address(0));\n', '        // 承認と有効な所有権の確認\n', '        require(_approvedFor(msg.sender, _tokenId));\n', '        require(_owns(_from, _tokenId));\n', '        // 所有権を再割り当てします（保留中の承認をクリアし、転送イベントを発行します）。\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /// @notice 現在存在するrocの総数を返します。\n', '    /// @dev ERC-721への準拠に必要です。\n', '    function totalSupply() public view returns (uint) {\n', '        return rocs.length - 1;\n', '    }\n', '\n', '    /// @notice 指定されたrocの現在所有権が割り当てられているアドレスを返します。\n', '    /// @dev ERC-721への準拠に必要です。\n', '    function ownerOf(uint256 _tokenId) external view returns (address owner) {\n', '        owner = rocIndexToOwner[_tokenId];\n', '        require(owner != address(0));\n', '    }\n', '\n', '    /// @dev この契約に所有権を割り当て、NFTを強制終了します。\n', '    /// @param _owner \n', '    /// @param _tokenId \n', '    function _escrow(address _owner, uint256 _tokenId) internal {\n', '        // it will throw if transfer fails\n', '        transferFrom(_owner, this, _tokenId);\n', '    }\n', '\n', '}\n', '\n', '/// @title Rocの飼育に関する管理を行うコントラクト\n', 'contract RocsBreeding is RocsOwnership {\n', '\n', '    /// @notice 新しいRocを作成して保存。 \n', '    /// @param _rocId \n', '    /// @param _dna \n', '    /// @param _marketsFlg \n', '    /// @param _owner \n', '    /// @dev RocCreatedイベントとTransferイベントの両方を生成します。 \n', '    function _createRoc(\n', '        uint _rocId,\n', '        string _dna,\n', '        uint _marketsFlg,\n', '        address _owner\n', '    )\n', '        internal\n', '        returns (uint)\n', '    {\n', '        Roc memory _roc = Roc({\n', '            rocId: _rocId,\n', '            dna: _dna,\n', '            marketsFlg: uint8(_marketsFlg)\n', '        });\n', '\n', '        uint newRocId = rocs.push(_roc) - 1;\n', '        // 同一のトークンIDが発生した場合は実行を停止します\n', '        require(newRocId == uint(newRocId));\n', '        // RocCreatedイベント\n', '        emit RocCreated(_owner, newRocId, _rocId);\n', '\n', '        // これにより所有権が割り当てられ、ERC721ドラフトごとに転送イベントが発行されます\n', '        rocIndex[_rocId] = newRocId;\n', '        _transfer(0, _owner, newRocId);\n', '\n', '        return newRocId;\n', '    }\n', '\n', '    /// @notice 新たに生み出します \n', '    /// @param _rocId \n', '    /// @param _dna \n', '    function giveProduce(uint _rocId, string _dna)\n', '        external\n', '        payable\n', '        whenNotPaused\n', '        returns(uint)\n', '    {\n', '        // 支払いを確認します。\n', '        require(msg.value >= eggPrice);\n', '        uint createRocId = _createRoc(\n', '            _rocId,\n', '            _dna, \n', '            0, \n', '            msg.sender\n', '        );\n', '        // 超過分を買い手に返す\n', '        uint256 bidExcess = msg.value - eggPrice;\n', '        msg.sender.transfer(bidExcess);\n', '\n', '        return createRocId;\n', '    }\n', '\n', '    /// @notice 初めてのRoc \n', '    /// @param _rocId \n', '    /// @param _dna \n', '    function freeGiveProduce(uint _rocId, string _dna)\n', '        external\n', '        payable\n', '        whenNotPaused\n', '        returns(uint)\n', '    {\n', '        // 初めてのRocか確認します。\n', '        require(balanceOf(msg.sender) == 0);\n', '        uint createRocId = _createRoc(\n', '            _rocId,\n', '            _dna, \n', '            0, \n', '            msg.sender\n', '        );\n', '        // 超過分を買い手に返す\n', '        uint256 bidExcess = msg.value;\n', '        msg.sender.transfer(bidExcess);\n', '\n', '        return createRocId;\n', '    }\n', '\n', '}\n', '\n', '/// @title Rocの売買のためのMarkets処理\n', 'contract RocsMarkets is RocsBreeding {\n', '\n', '    event MarketsCreated(uint256 tokenId, uint128 marketsPrice);\n', '    event MarketsSuccessful(uint256 tokenId, uint128 marketsPriceice, address buyer);\n', '    event MarketsCancelled(uint256 tokenId);\n', '\n', '    // NFT上のマーケットへの出品\n', '    struct Markets {\n', '        // 登録時のNFT売手\n', '        address seller;\n', '        // 価格\n', '        uint128 marketsPrice;\n', '    }\n', '\n', '    // トークンIDから対応するマーケットへの出品にマップします。\n', '    mapping (uint256 => Markets) tokenIdToMarkets;\n', '\n', '    // マーケットへの出品の手数料を設定\n', '    uint256 public ownerCut = 0;\n', '    function setOwnerCut(uint256 _cut) public onlyOwner {\n', '        require(_cut <= 10000);\n', '        ownerCut = _cut;\n', '    }\n', '\n', '    /// @notice Rocマーケットへの出品を作成し、開始します。\n', '    /// @param _rocId \n', '    /// @param _marketsPrice \n', '    function createRocSaleMarkets(\n', '        uint256 _rocId,\n', '        uint256 _marketsPrice\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        require(_marketsPrice == uint256(uint128(_marketsPrice)));\n', '\n', '        // チェック用のtokenIdをセット\n', '        uint checkTokenId = getRocIdToTokenId(_rocId);\n', '\n', '        // checkのオーナーである事\n', '        require(_owns(msg.sender, checkTokenId));\n', '        // checkのパラメータチェック\n', '        Roc memory roc = rocs[checkTokenId];\n', '        // マーケットへの出品中か確認してください。\n', '        require(uint8(roc.marketsFlg) == 0);\n', '        // 承認\n', '        _approve(checkTokenId, msg.sender);\n', '        // マーケットへの出品セット\n', '        _escrow(msg.sender, checkTokenId);\n', '        Markets memory markets = Markets(\n', '            msg.sender,\n', '            uint128(_marketsPrice)\n', '        );\n', '\n', '        // マーケットへの出品FLGをセット\n', '        rocs[checkTokenId].marketsFlg = 1;\n', '        _addMarkets(checkTokenId, markets);\n', '    }\n', '\n', '    /// @dev マーケットへの出品を公開マーケットへの出品のリストに追加します。 \n', '    ///  また、MarketsCreatedイベントを発生させます。\n', '    /// @param _tokenId The ID of the token to be put on markets.\n', '    /// @param _markets Markets to add.\n', '    function _addMarkets(uint256 _tokenId, Markets _markets) internal {\n', '        tokenIdToMarkets[_tokenId] = _markets;\n', '        emit MarketsCreated(\n', '            uint256(_tokenId),\n', '            uint128(_markets.marketsPrice)\n', '        );\n', '    }\n', '\n', '    /// @dev マーケットへの出品を公開マーケットへの出品のリストから削除します。\n', '    /// @param _tokenId \n', '    function _removeMarkets(uint256 _tokenId) internal {\n', '        delete tokenIdToMarkets[_tokenId];\n', '    }\n', '\n', '    /// @dev 無条件にマーケットへの出品を取り消します。\n', '    /// @param _tokenId \n', '    function _cancelMarkets(uint256 _tokenId) internal {\n', '        _removeMarkets(_tokenId);\n', '        emit MarketsCancelled(_tokenId);\n', '    }\n', '\n', '    /// @dev まだ獲得されていないMarketsをキャンセルします。\n', '    ///  元の所有者にNFTを返します。\n', '    /// @notice これは、契約が一時停止している間に呼び出すことができる状態変更関数です。\n', '    /// @param _rocId \n', '    function cancelMarkets(uint _rocId) external {\n', '        uint checkTokenId = getRocIdToTokenId(_rocId);\n', '        Markets storage markets = tokenIdToMarkets[checkTokenId];\n', '        address seller = markets.seller;\n', '        require(msg.sender == seller);\n', '        _cancelMarkets(checkTokenId);\n', '        rocIndexToOwner[checkTokenId] = seller;\n', '        rocs[checkTokenId].marketsFlg = 0;\n', '    }\n', '\n', '    /// @dev 契約が一時停止されたときにMarketsをキャンセルします。\n', '    ///  所有者だけがこれを行うことができ、NFTは売り手に返されます。 \n', '    ///  緊急時にのみ使用してください。\n', '    /// @param _rocId \n', '    function cancelMarketsWhenPaused(uint _rocId) whenPaused onlyOwner external {\n', '        uint checkTokenId = getRocIdToTokenId(_rocId);\n', '        Markets storage markets = tokenIdToMarkets[checkTokenId];\n', '        address seller = markets.seller;\n', '        _cancelMarkets(checkTokenId);\n', '        rocIndexToOwner[checkTokenId] = seller;\n', '        rocs[checkTokenId].marketsFlg = 0;\n', '    }\n', '\n', '    /// @dev Markets入札\n', '    ///  十分な量のEtherが供給されればNFTの所有権を移転する。\n', '    /// @param _rocId \n', '    function bid(uint _rocId) external payable whenNotPaused {\n', '        uint checkTokenId = getRocIdToTokenId(_rocId);\n', '        // マーケットへの出品構造体への参照を取得する\n', '        Markets storage markets = tokenIdToMarkets[checkTokenId];\n', '\n', '        uint128 sellingPrice = uint128(markets.marketsPrice);\n', '        // 入札額が価格以上である事を確認する。\n', '        // msg.valueはweiの数\n', '        require(msg.value >= sellingPrice);\n', '        // マーケットへの出品構造体が削除される前に、販売者への参照を取得します。\n', '        address seller = markets.seller;\n', '\n', '        // マーケットへの出品を削除します。\n', '        _removeMarkets(checkTokenId);\n', '\n', '        if (sellingPrice > 0) {\n', '            // 競売人のカットを計算します。\n', '            uint128 marketseerCut = uint128(_computeCut(sellingPrice));\n', '            uint128 sellerProceeds = sellingPrice - marketseerCut;\n', '\n', '            // 売り手に送金する\n', '            seller.transfer(sellerProceeds);\n', '        }\n', '\n', '        // 超過分を買い手に返す\n', '        msg.sender.transfer(msg.value - sellingPrice);\n', '        // イベント\n', '        emit MarketsSuccessful(checkTokenId, sellingPrice, msg.sender);\n', '\n', '        _transfer(seller, msg.sender, checkTokenId);\n', '        // マーケットへの出品FLGをセット\n', '        rocs[checkTokenId].marketsFlg = 0;\n', '    }\n', '\n', '    /// @dev 手数料計算\n', '    /// @param _price \n', '    function _computeCut(uint128 _price) internal view returns (uint) {\n', '        return _price * ownerCut / 10000;\n', '    }\n', '\n', '}\n', '\n', '/// @title CryptoRocs\n', 'contract RocsCore is RocsMarkets {\n', '\n', '    // コア契約が壊れてアップグレードが必要な場合に設定します\n', '    address public newContractAddress;\n', '\n', '    /// @dev 一時停止を無効にすると、契約を一時停止する前にすべての外部契約アドレスを設定する必要があります。\n', '    function unpause() public onlyOwner whenPaused {\n', '        require(newContractAddress == address(0));\n', '        // 実際に契約を一時停止しないでください。\n', '        super.unpause();\n', '    }\n', '\n', '    // @dev 利用可能な残高を取得できるようにします。\n', '    function withdrawBalance(uint _subtractFees) external onlyOwner {\n', '        uint256 balance = address(this).balance;\n', '        if (balance > _subtractFees) {\n', '            owner.transfer(balance - _subtractFees);\n', '        }\n', '    }\n', '\n', '    /// @notice tokenIdからRocに関するすべての関連情報を返します。\n', '    /// @param _tokenId トークンID\n', '    function getRoc(uint _tokenId)\n', '        external\n', '        view\n', '        returns (\n', '        uint rocId,\n', '        string dna,\n', '        uint marketsFlg\n', '    ) {\n', '        Roc memory roc = rocs[_tokenId];\n', '        rocId = uint(roc.rocId);\n', '        dna = string(roc.dna);\n', '        marketsFlg = uint(roc.marketsFlg);\n', '    }\n', '\n', '    /// @notice rocIdからRocに関するすべての関連情報を返します。\n', '    /// @param _rocId rocId\n', '    function getRocrocId(uint _rocId)\n', '        external\n', '        view\n', '        returns (\n', '        uint rocId,\n', '        string dna,\n', '        uint marketsFlg\n', '    ) {\n', '        Roc memory roc = rocs[getRocIdToTokenId(_rocId)];\n', '        rocId = uint(roc.rocId);\n', '        dna = string(roc.dna);\n', '        marketsFlg = uint(roc.marketsFlg);\n', '    }\n', '\n', '    /// @notice rocIdからMarkets情報を返します。\n', '    /// @param _rocId rocId\n', '    function getMarketsRocId(uint _rocId)\n', '        external\n', '        view\n', '        returns (\n', '        address seller,\n', '        uint marketsPrice\n', '    ) {\n', '        uint checkTokenId = getRocIdToTokenId(_rocId);\n', '        Markets memory markets = tokenIdToMarkets[checkTokenId];\n', '        seller = markets.seller;\n', '        marketsPrice = uint(markets.marketsPrice);\n', '    }\n', '\n', '    /// @notice rocIdからオーナー情報を返します。\n', '    /// @param _rocId rocId\n', '    function getRocIndexToOwner(uint _rocId)\n', '        external\n', '        view\n', '        returns (\n', '        address owner\n', '    ) {\n', '        uint checkTokenId = getRocIdToTokenId(_rocId);\n', '        owner = rocIndexToOwner[checkTokenId];\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.22;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is not paused.\n', '    *               契約が一時停止されている場合にのみアクションを許可する\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is paused.\n', '    *               契約が一時停止されていない場合にのみアクションを許可する\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    *             一時停止するために所有者によって呼び出され、停止状態をトリガする\n', '    */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to unpause, returns to normal state\n', '    *             ポーズをとるためにオーナーが呼び出し、通常の状態に戻ります\n', '    */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', 'contract RocsBase is Pausable {\n', '\n', '    // 生誕代\n', '    uint128 public eggPrice = 50 finney;\n', '    function setEggPrice(uint128 _price) public onlyOwner {\n', '        eggPrice = _price;\n', '    }\n', '    // 進化代\n', '    uint128 public evolvePrice = 5 finney;\n', '    function setEvolvePrice(uint128 _price) public onlyOwner {\n', '        evolvePrice = _price;\n', '    }\n', '\n', '    // 生誕\n', '    event RocCreated(address owner, uint tokenId, uint rocId);\n', '    // ERC721\n', '    event Transfer(address from, address to, uint tokenId);\n', '    event ItemTransfer(address from, address to, uint tokenId);\n', '\n', '    /// @dev Rocの構造体\n', '    struct Roc {\n', '        // ID\n', '        uint rocId;\n', '        // DNA\n', '        string dna;\n', '        // 出品中フラグ 1は出品中\n', '        uint8 marketsFlg;\n', '    }\n', '\n', '    /// @dev Rocsの配列\n', '    Roc[] public rocs;\n', '\n', '    // rocIdとtokenIdのマッピング\n', '    mapping(uint => uint) public rocIndex;\n', '    // rocIdからtokenIdを取得\n', '    function getRocIdToTokenId(uint _rocId) public view returns (uint) {\n', '        return rocIndex[_rocId];\n', '    }\n', '\n', '    /// @dev 所有するアドレスへのマッピング\n', '    mapping (uint => address) public rocIndexToOwner;\n', '    // @dev 所有者アドレスから所有するトークン数へのマッピング\n', '    mapping (address => uint) public ownershipTokenCount;\n', '    /// @dev 呼び出しが承認されたアドレスへのマッピング\n', '    mapping (uint => address) public rocIndexToApproved;\n', '\n', '    /// @dev 特定のRocの所有権をアドレスに割り当てます。\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        ownershipTokenCount[_to]++;\n', '        ownershipTokenCount[_from]--;\n', '        rocIndexToOwner[_tokenId] = _to;\n', '        // イベント開始\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '}\n', '\n', '/// @title ERC-721に準拠した契約のインタフェース：置き換え不可能なトークン\n', 'contract ERC721 {\n', '    // イベント\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '    // 必要なメソッド\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint256 _tokenId) external view returns (address _owner);\n', '    function approve(address _to, uint256 _tokenId) external;\n', '    function transfer(address _to, uint256 _tokenId) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function totalSupply() public view returns (uint);\n', '\n', '    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '}\n', '\n', '/// @title Roc所有権を管理するコントラクト\n', '/// @dev OpenZeppelinのERC721ドラフト実装に準拠\n', 'contract RocsOwnership is RocsBase, ERC721 {\n', '\n', '    /// @notice ERC721で定義されている、置き換え不可能なトークンの名前と記号。\n', '    string public constant name = "CryptoFeather";\n', '    string public constant symbol = "CFE";\n', '\n', '    bytes4 constant InterfaceSignature_ERC165 = \n', "    bytes4(keccak256('supportsInterface(bytes4)'));\n", '\n', '    bytes4 constant InterfaceSignature_ERC721 =\n', "    bytes4(keccak256('name()')) ^\n", "    bytes4(keccak256('symbol()')) ^\n", "    bytes4(keccak256('balanceOf(address)')) ^\n", "    bytes4(keccak256('ownerOf(uint256)')) ^\n", "    bytes4(keccak256('approve(address,uint256)')) ^\n", "    bytes4(keccak256('transfer(address,uint256)')) ^\n", "    bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n", "    bytes4(keccak256('totalSupply()'));\n", '\n', '    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n', '    ///  この契約によって実装された標準化されたインタフェースでtrueを返します。\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\n', '    {\n', '        // DEBUG ONLY\n', '        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\n', '        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\n', '    }\n', '\n', '    /// @dev 特定のアドレスに指定されたrocの現在の所有者であるかどうかをチェックします。\n', '    /// @param _claimant \n', '    /// @param _tokenId \n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return rocIndexToOwner[_tokenId] == _claimant;\n', '    }\n', '\n', '    /// @dev 特定のアドレスに指定されたrocが存在するかどうかをチェックします。\n', '    /// @param _claimant the address we are confirming kitten is approved for.\n', '    /// @param _tokenId kitten id, only valid when > 0\n', '    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return rocIndexToApproved[_tokenId] == _claimant;\n', '    }\n', '\n', '    /// @dev 以前の承認を上書きして、transferFrom（）に対して承認されたアドレスをマークします。\n', '    function _approve(uint256 _tokenId, address _approved) internal {\n', '        rocIndexToApproved[_tokenId] = _approved;\n', '    }\n', '\n', '    // 指定されたアドレスのroc数を取得します。\n', '    function balanceOf(address _owner) public view returns (uint256 count) {\n', '        return ownershipTokenCount[_owner];\n', '    }\n', '\n', '    /// @notice rocの所有者を変更します。\n', '    /// @dev ERC-721への準拠に必要\n', '    function transfer(address _to, uint256 _tokenId) public whenNotPaused {\n', '        // 安全チェック\n', '        require(_to != address(0));\n', '        // 自分のrocしか送ることはできません。\n', '        require(_owns(msg.sender, _tokenId));\n', '        // 所有権の再割り当て、保留中の承認のクリア、転送イベントの送信\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /// @notice transferFrom（）を介して別のアドレスに特定のrocを転送する権利を与えます。\n', '    /// @dev ERC-721への準拠に必要\n', '    function approve(address _to, uint256 _tokenId) external whenNotPaused {\n', '        // 所有者のみが譲渡承認を認めることができます。\n', '        require(_owns(msg.sender, _tokenId));\n', '        // 承認を登録します（以前の承認を置き換えます）。\n', '        _approve(_tokenId, _to);\n', '        // 承認イベントを発行する。\n', '        emit Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /// @notice roc所有者の変更を行います。を転送します。そのアドレスには、以前の所有者から転送承認が与えられています。\n', '    /// @dev ERC-721への準拠に必要\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public whenNotPaused {\n', '        // 安全チェック。\n', '        require(_to != address(0));\n', '        // 承認と有効な所有権の確認\n', '        require(_approvedFor(msg.sender, _tokenId));\n', '        require(_owns(_from, _tokenId));\n', '        // 所有権を再割り当てします（保留中の承認をクリアし、転送イベントを発行します）。\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /// @notice 現在存在するrocの総数を返します。\n', '    /// @dev ERC-721への準拠に必要です。\n', '    function totalSupply() public view returns (uint) {\n', '        return rocs.length - 1;\n', '    }\n', '\n', '    /// @notice 指定されたrocの現在所有権が割り当てられているアドレスを返します。\n', '    /// @dev ERC-721への準拠に必要です。\n', '    function ownerOf(uint256 _tokenId) external view returns (address owner) {\n', '        owner = rocIndexToOwner[_tokenId];\n', '        require(owner != address(0));\n', '    }\n', '\n', '    /// @dev この契約に所有権を割り当て、NFTを強制終了します。\n', '    /// @param _owner \n', '    /// @param _tokenId \n', '    function _escrow(address _owner, uint256 _tokenId) internal {\n', '        // it will throw if transfer fails\n', '        transferFrom(_owner, this, _tokenId);\n', '    }\n', '\n', '}\n', '\n', '/// @title Rocの飼育に関する管理を行うコントラクト\n', 'contract RocsBreeding is RocsOwnership {\n', '\n', '    /// @notice 新しいRocを作成して保存。 \n', '    /// @param _rocId \n', '    /// @param _dna \n', '    /// @param _marketsFlg \n', '    /// @param _owner \n', '    /// @dev RocCreatedイベントとTransferイベントの両方を生成します。 \n', '    function _createRoc(\n', '        uint _rocId,\n', '        string _dna,\n', '        uint _marketsFlg,\n', '        address _owner\n', '    )\n', '        internal\n', '        returns (uint)\n', '    {\n', '        Roc memory _roc = Roc({\n', '            rocId: _rocId,\n', '            dna: _dna,\n', '            marketsFlg: uint8(_marketsFlg)\n', '        });\n', '\n', '        uint newRocId = rocs.push(_roc) - 1;\n', '        // 同一のトークンIDが発生した場合は実行を停止します\n', '        require(newRocId == uint(newRocId));\n', '        // RocCreatedイベント\n', '        emit RocCreated(_owner, newRocId, _rocId);\n', '\n', '        // これにより所有権が割り当てられ、ERC721ドラフトごとに転送イベントが発行されます\n', '        rocIndex[_rocId] = newRocId;\n', '        _transfer(0, _owner, newRocId);\n', '\n', '        return newRocId;\n', '    }\n', '\n', '    /// @notice 新たに生み出します \n', '    /// @param _rocId \n', '    /// @param _dna \n', '    function giveProduce(uint _rocId, string _dna)\n', '        external\n', '        payable\n', '        whenNotPaused\n', '        returns(uint)\n', '    {\n', '        // 支払いを確認します。\n', '        require(msg.value >= eggPrice);\n', '        uint createRocId = _createRoc(\n', '            _rocId,\n', '            _dna, \n', '            0, \n', '            msg.sender\n', '        );\n', '        // 超過分を買い手に返す\n', '        uint256 bidExcess = msg.value - eggPrice;\n', '        msg.sender.transfer(bidExcess);\n', '\n', '        return createRocId;\n', '    }\n', '\n', '    /// @notice 初めてのRoc \n', '    /// @param _rocId \n', '    /// @param _dna \n', '    function freeGiveProduce(uint _rocId, string _dna)\n', '        external\n', '        payable\n', '        whenNotPaused\n', '        returns(uint)\n', '    {\n', '        // 初めてのRocか確認します。\n', '        require(balanceOf(msg.sender) == 0);\n', '        uint createRocId = _createRoc(\n', '            _rocId,\n', '            _dna, \n', '            0, \n', '            msg.sender\n', '        );\n', '        // 超過分を買い手に返す\n', '        uint256 bidExcess = msg.value;\n', '        msg.sender.transfer(bidExcess);\n', '\n', '        return createRocId;\n', '    }\n', '\n', '}\n', '\n', '/// @title Rocの売買のためのMarkets処理\n', 'contract RocsMarkets is RocsBreeding {\n', '\n', '    event MarketsCreated(uint256 tokenId, uint128 marketsPrice);\n', '    event MarketsSuccessful(uint256 tokenId, uint128 marketsPriceice, address buyer);\n', '    event MarketsCancelled(uint256 tokenId);\n', '\n', '    // NFT上のマーケットへの出品\n', '    struct Markets {\n', '        // 登録時のNFT売手\n', '        address seller;\n', '        // 価格\n', '        uint128 marketsPrice;\n', '    }\n', '\n', '    // トークンIDから対応するマーケットへの出品にマップします。\n', '    mapping (uint256 => Markets) tokenIdToMarkets;\n', '\n', '    // マーケットへの出品の手数料を設定\n', '    uint256 public ownerCut = 0;\n', '    function setOwnerCut(uint256 _cut) public onlyOwner {\n', '        require(_cut <= 10000);\n', '        ownerCut = _cut;\n', '    }\n', '\n', '    /// @notice Rocマーケットへの出品を作成し、開始します。\n', '    /// @param _rocId \n', '    /// @param _marketsPrice \n', '    function createRocSaleMarkets(\n', '        uint256 _rocId,\n', '        uint256 _marketsPrice\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        require(_marketsPrice == uint256(uint128(_marketsPrice)));\n', '\n', '        // チェック用のtokenIdをセット\n', '        uint checkTokenId = getRocIdToTokenId(_rocId);\n', '\n', '        // checkのオーナーである事\n', '        require(_owns(msg.sender, checkTokenId));\n', '        // checkのパラメータチェック\n', '        Roc memory roc = rocs[checkTokenId];\n', '        // マーケットへの出品中か確認してください。\n', '        require(uint8(roc.marketsFlg) == 0);\n', '        // 承認\n', '        _approve(checkTokenId, msg.sender);\n', '        // マーケットへの出品セット\n', '        _escrow(msg.sender, checkTokenId);\n', '        Markets memory markets = Markets(\n', '            msg.sender,\n', '            uint128(_marketsPrice)\n', '        );\n', '\n', '        // マーケットへの出品FLGをセット\n', '        rocs[checkTokenId].marketsFlg = 1;\n', '        _addMarkets(checkTokenId, markets);\n', '    }\n', '\n', '    /// @dev マーケットへの出品を公開マーケットへの出品のリストに追加します。 \n', '    ///  また、MarketsCreatedイベントを発生させます。\n', '    /// @param _tokenId The ID of the token to be put on markets.\n', '    /// @param _markets Markets to add.\n', '    function _addMarkets(uint256 _tokenId, Markets _markets) internal {\n', '        tokenIdToMarkets[_tokenId] = _markets;\n', '        emit MarketsCreated(\n', '            uint256(_tokenId),\n', '            uint128(_markets.marketsPrice)\n', '        );\n', '    }\n', '\n', '    /// @dev マーケットへの出品を公開マーケットへの出品のリストから削除します。\n', '    /// @param _tokenId \n', '    function _removeMarkets(uint256 _tokenId) internal {\n', '        delete tokenIdToMarkets[_tokenId];\n', '    }\n', '\n', '    /// @dev 無条件にマーケットへの出品を取り消します。\n', '    /// @param _tokenId \n', '    function _cancelMarkets(uint256 _tokenId) internal {\n', '        _removeMarkets(_tokenId);\n', '        emit MarketsCancelled(_tokenId);\n', '    }\n', '\n', '    /// @dev まだ獲得されていないMarketsをキャンセルします。\n', '    ///  元の所有者にNFTを返します。\n', '    /// @notice これは、契約が一時停止している間に呼び出すことができる状態変更関数です。\n', '    /// @param _rocId \n', '    function cancelMarkets(uint _rocId) external {\n', '        uint checkTokenId = getRocIdToTokenId(_rocId);\n', '        Markets storage markets = tokenIdToMarkets[checkTokenId];\n', '        address seller = markets.seller;\n', '        require(msg.sender == seller);\n', '        _cancelMarkets(checkTokenId);\n', '        rocIndexToOwner[checkTokenId] = seller;\n', '        rocs[checkTokenId].marketsFlg = 0;\n', '    }\n', '\n', '    /// @dev 契約が一時停止されたときにMarketsをキャンセルします。\n', '    ///  所有者だけがこれを行うことができ、NFTは売り手に返されます。 \n', '    ///  緊急時にのみ使用してください。\n', '    /// @param _rocId \n', '    function cancelMarketsWhenPaused(uint _rocId) whenPaused onlyOwner external {\n', '        uint checkTokenId = getRocIdToTokenId(_rocId);\n', '        Markets storage markets = tokenIdToMarkets[checkTokenId];\n', '        address seller = markets.seller;\n', '        _cancelMarkets(checkTokenId);\n', '        rocIndexToOwner[checkTokenId] = seller;\n', '        rocs[checkTokenId].marketsFlg = 0;\n', '    }\n', '\n', '    /// @dev Markets入札\n', '    ///  十分な量のEtherが供給されればNFTの所有権を移転する。\n', '    /// @param _rocId \n', '    function bid(uint _rocId) external payable whenNotPaused {\n', '        uint checkTokenId = getRocIdToTokenId(_rocId);\n', '        // マーケットへの出品構造体への参照を取得する\n', '        Markets storage markets = tokenIdToMarkets[checkTokenId];\n', '\n', '        uint128 sellingPrice = uint128(markets.marketsPrice);\n', '        // 入札額が価格以上である事を確認する。\n', '        // msg.valueはweiの数\n', '        require(msg.value >= sellingPrice);\n', '        // マーケットへの出品構造体が削除される前に、販売者への参照を取得します。\n', '        address seller = markets.seller;\n', '\n', '        // マーケットへの出品を削除します。\n', '        _removeMarkets(checkTokenId);\n', '\n', '        if (sellingPrice > 0) {\n', '            // 競売人のカットを計算します。\n', '            uint128 marketseerCut = uint128(_computeCut(sellingPrice));\n', '            uint128 sellerProceeds = sellingPrice - marketseerCut;\n', '\n', '            // 売り手に送金する\n', '            seller.transfer(sellerProceeds);\n', '        }\n', '\n', '        // 超過分を買い手に返す\n', '        msg.sender.transfer(msg.value - sellingPrice);\n', '        // イベント\n', '        emit MarketsSuccessful(checkTokenId, sellingPrice, msg.sender);\n', '\n', '        _transfer(seller, msg.sender, checkTokenId);\n', '        // マーケットへの出品FLGをセット\n', '        rocs[checkTokenId].marketsFlg = 0;\n', '    }\n', '\n', '    /// @dev 手数料計算\n', '    /// @param _price \n', '    function _computeCut(uint128 _price) internal view returns (uint) {\n', '        return _price * ownerCut / 10000;\n', '    }\n', '\n', '}\n', '\n', '/// @title CryptoRocs\n', 'contract RocsCore is RocsMarkets {\n', '\n', '    // コア契約が壊れてアップグレードが必要な場合に設定します\n', '    address public newContractAddress;\n', '\n', '    /// @dev 一時停止を無効にすると、契約を一時停止する前にすべての外部契約アドレスを設定する必要があります。\n', '    function unpause() public onlyOwner whenPaused {\n', '        require(newContractAddress == address(0));\n', '        // 実際に契約を一時停止しないでください。\n', '        super.unpause();\n', '    }\n', '\n', '    // @dev 利用可能な残高を取得できるようにします。\n', '    function withdrawBalance(uint _subtractFees) external onlyOwner {\n', '        uint256 balance = address(this).balance;\n', '        if (balance > _subtractFees) {\n', '            owner.transfer(balance - _subtractFees);\n', '        }\n', '    }\n', '\n', '    /// @notice tokenIdからRocに関するすべての関連情報を返します。\n', '    /// @param _tokenId トークンID\n', '    function getRoc(uint _tokenId)\n', '        external\n', '        view\n', '        returns (\n', '        uint rocId,\n', '        string dna,\n', '        uint marketsFlg\n', '    ) {\n', '        Roc memory roc = rocs[_tokenId];\n', '        rocId = uint(roc.rocId);\n', '        dna = string(roc.dna);\n', '        marketsFlg = uint(roc.marketsFlg);\n', '    }\n', '\n', '    /// @notice rocIdからRocに関するすべての関連情報を返します。\n', '    /// @param _rocId rocId\n', '    function getRocrocId(uint _rocId)\n', '        external\n', '        view\n', '        returns (\n', '        uint rocId,\n', '        string dna,\n', '        uint marketsFlg\n', '    ) {\n', '        Roc memory roc = rocs[getRocIdToTokenId(_rocId)];\n', '        rocId = uint(roc.rocId);\n', '        dna = string(roc.dna);\n', '        marketsFlg = uint(roc.marketsFlg);\n', '    }\n', '\n', '    /// @notice rocIdからMarkets情報を返します。\n', '    /// @param _rocId rocId\n', '    function getMarketsRocId(uint _rocId)\n', '        external\n', '        view\n', '        returns (\n', '        address seller,\n', '        uint marketsPrice\n', '    ) {\n', '        uint checkTokenId = getRocIdToTokenId(_rocId);\n', '        Markets memory markets = tokenIdToMarkets[checkTokenId];\n', '        seller = markets.seller;\n', '        marketsPrice = uint(markets.marketsPrice);\n', '    }\n', '\n', '    /// @notice rocIdからオーナー情報を返します。\n', '    /// @param _rocId rocId\n', '    function getRocIndexToOwner(uint _rocId)\n', '        external\n', '        view\n', '        returns (\n', '        address owner\n', '    ) {\n', '        uint checkTokenId = getRocIdToTokenId(_rocId);\n', '        owner = rocIndexToOwner[checkTokenId];\n', '    }\n', '\n', '}']
