['pragma solidity ^0.4.24;\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ETHSmartInvest {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 constant public ONE_HUNDRED   = 10000;\n', '    uint256 constant public INTEREST      = 330;\n', '    uint256 constant public MARKETING_FEE = 800;\n', '    uint256 constant public ADMIN_FEE     = 200;\n', '    uint256 constant public ONE_DAY       = 1 days;\n', '    uint256 constant public MINIMUM       = 0.01 ether;\n', '\n', '    uint256[] public referralPercents     = [200, 100, 50, 25, 10];\n', '\n', '    struct User {\n', '        uint256 time;\n', '        uint256 deposit;\n', '        uint256 reserve;\n', '        address referrer;\n', '        uint256 bonus;\n', '    }\n', '\n', '    address public marketing = 0x137b2E4b00d40a42926e0846aca79F9b0AeBeFb6;\n', '    address public admin = 0x51ed5021AeD7F39CB0B350EF3Dd6eF1A29D17Ec5;\n', '\n', '    mapping(address => User) public users;\n', '\n', '    event InvestorAdded(address indexed investor, uint256 amount);\n', '    event ReferrerAdded(address indexed investor, address indexed referrer);\n', '    event DepositIncreased(address indexed investor, uint256 amount, uint256 totalAmount);\n', '    event DepositAddAll(uint256 amount);\n', '    event DividendsPayed(address indexed investor, uint256 amount);\n', '    event RefBonusPayed(address indexed investor, uint256 amount);\n', '    event RefBonusAdded(address indexed investor, address indexed referrer, uint256 amount, uint256 indexed level);\n', '\n', '    function() external payable {\n', '        if (msg.value == 0) {\n', '            withdraw();\n', '        } else {\n', '            invest();\n', '        }\n', '    }\n', '\n', '    function invest() public payable {\n', '        require(msg.value >= MINIMUM);\n', '        marketing.transfer(msg.value * MARKETING_FEE / ONE_HUNDRED);\n', '        admin.transfer(msg.value * ADMIN_FEE / ONE_HUNDRED);\n', '\n', '        if (users[msg.sender].deposit > 0) {\n', '            saveDividends();\n', '            emit DepositIncreased(msg.sender, msg.value, users[msg.sender].deposit + msg.value);\n', '        } else {\n', '            emit InvestorAdded(msg.sender, msg.value);\n', '        }\n', '\n', '        emit DepositAddAll(msg.value);\n', '\n', '        users[msg.sender].deposit += msg.value;\n', '        users[msg.sender].time = block.timestamp;\n', '\n', '        if (users[msg.sender].referrer != 0x0) {\n', '            refSystem();\n', '        } else if (msg.data.length == 20) {\n', '            addReferrer();\n', '        }\n', '    }\n', '\n', '\n', '    function withdraw() public {\n', '        uint256 payout = getDividends(msg.sender);\n', '        emit DividendsPayed(msg.sender, payout);\n', '\n', '        if (getRefBonus(msg.sender) != 0) {\n', '            payout += getRefBonus(msg.sender);\n', '            emit RefBonusPayed(msg.sender, getRefBonus(msg.sender));\n', '            users[msg.sender].bonus = 0;\n', '        }\n', '\n', '        require(payout >= MINIMUM);\n', '\n', '        if (users[msg.sender].reserve != 0) {\n', '            users[msg.sender].reserve = 0;\n', '        }\n', '\n', '        users[msg.sender].time += (block.timestamp.sub(users[msg.sender].time)).div(ONE_DAY).mul(ONE_DAY);\n', '\n', '        msg.sender.transfer(payout);\n', '    }\n', '\n', '    function bytesToAddress(bytes source) internal pure returns(address parsedReferrer) {\n', '        assembly {\n', '            parsedReferrer := mload(add(source,0x14))\n', '        }\n', '        return parsedReferrer;\n', '    }\n', '\n', '    function addReferrer() internal {\n', '        address refAddr = bytesToAddress(bytes(msg.data));\n', '        if (refAddr != msg.sender) {\n', '            users[msg.sender].referrer = refAddr;\n', '\n', '            refSystem();\n', '            emit ReferrerAdded(msg.sender, refAddr);\n', '        }\n', '    }\n', '\n', '    function refSystem() internal {\n', '        address first = users[msg.sender].referrer;\n', '        users[first].bonus += msg.value * referralPercents[0] / ONE_HUNDRED;\n', '        emit RefBonusAdded(msg.sender, first, msg.value * referralPercents[0] / ONE_HUNDRED, 1);\n', '        address second = users[first].referrer;\n', '        if (second != address(0)) {\n', '            users[second].bonus += msg.value * referralPercents[1] / ONE_HUNDRED;\n', '            emit RefBonusAdded(msg.sender, second, msg.value * referralPercents[1] / ONE_HUNDRED, 2);\n', '            address third = users[second].referrer;\n', '            if (third != address(0)) {\n', '                users[third].bonus += msg.value * referralPercents[2] / ONE_HUNDRED;\n', '                emit RefBonusAdded(msg.sender, third, msg.value * referralPercents[2] / ONE_HUNDRED, 3);\n', '                address fourth = users[third].referrer;\n', '                if (fourth != address(0)) {\n', '                    users[fourth].bonus += msg.value * referralPercents[3] / ONE_HUNDRED;\n', '                    emit RefBonusAdded(msg.sender, fourth, msg.value * referralPercents[3] / ONE_HUNDRED, 4);\n', '                    address fifth = users[fourth].referrer;\n', '                    if (fifth != address(0)) {\n', '                        users[fifth].bonus += msg.value * referralPercents[4] / ONE_HUNDRED;\n', '                        emit RefBonusAdded(msg.sender, fifth, msg.value * referralPercents[4] / ONE_HUNDRED, 5);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function saveDividends() internal {\n', '        uint256 dividends = (users[msg.sender].deposit.mul(INTEREST).div(ONE_HUNDRED)).mul(block.timestamp.sub(users[msg.sender].time)).div(ONE_DAY);\n', '        users[msg.sender].reserve += dividends;\n', '    }\n', '\n', '    function getDividends(address userAddr) public view returns(uint256) {\n', '        return (users[userAddr].deposit.mul(INTEREST).div(ONE_HUNDRED)).mul((block.timestamp.sub(users[userAddr].time)).div(ONE_DAY)).add(users[userAddr].reserve);\n', '    }\n', '\n', '    function getRefBonus(address userAddr) public view returns(uint256) {\n', '        return users[userAddr].bonus;\n', '    }\n', '\n', '    function getNextTime(address userAddr) public view returns(uint256) {\n', '        if (users[userAddr].time != 0) {\n', '            return (block.timestamp.sub(users[userAddr].time)).div(ONE_DAY).mul(ONE_DAY).add(users[userAddr].time).add(ONE_DAY);\n', '        }\n', '    }\n', '\n', '}']