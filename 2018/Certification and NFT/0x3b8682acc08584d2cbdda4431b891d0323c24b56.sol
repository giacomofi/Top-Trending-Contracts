['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  } \n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract LoveToken {\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '  function freeze(address target) public returns (bool);\n', '  function release(address target) public returns (bool);\n', '}\n', '\n', 'contract LoveContribution is Ownable {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  //The token being given\n', '  LoveToken  token;\n', '  \n', '  // contribution in wei\n', '  mapping(address => uint256) public contributionOf;\n', '  \n', '  // array of contributors\n', '  address[] contributors;\n', '  \n', '  // array of top contributed winners\n', '   address[] topWinners=[address(0),address(0),address(0),address(0),address(0),address(0),address(0),address(0),address(0),address(0),address(0)];\n', '  \n', '  // array of random winners\n', '  address[] randomWinners;\n', '  \n', '  // won amount in wei\n', '  mapping(address => uint256) public amountWon;\n', '  \n', '  // ckeck whether the winner withdrawn the won amount\n', '  mapping(address => bool) public claimed;\n', '  \n', '  // ckeck whether the contributor completed KYC\n', '  mapping(address => bool) public KYCDone;\n', '\n', '  // start and end timestamps\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '\n', '  // price of token in wei\n', '  uint256 public rate = 10e14;\n', '\n', '  // amount of wei raised\n', '  uint256 public weiRaised;\n', '  \n', '  // amount of wei withdrawn by owner\n', '  uint256 public ownerWithdrawn;\n', '  \n', '  event contributionSuccessful(address indexed contributedBy, uint256 contribution, uint256 tokenReceived);\n', '  event FundTransfer(address indexed beneficiary, uint256 amount);\n', '  event FundTransferFailed();\n', '  event KYCApproved(address indexed contributor);\n', '\n', '  function LoveContribution(uint256 _startTime, uint256 _endTime, LoveToken  _token) public {\n', '    require(_startTime >= now);\n', '    require(_endTime >= _startTime);\n', '    require(_token != address(0));\n', '\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '    token = _token;\n', '  }\n', '\n', '  // fallback function can be used to buy tokens\n', '  function () external payable {\n', '    contribute();\n', '  }\n', '    \n', '   \n', '  /**\n', '   * @dev low level token purchase function\n', '   */\n', '  function contribute() internal {\n', '    uint256 weiAmount = msg.value;\n', '    require(msg.sender != address(0) && weiAmount >= 5e15);\n', '    require(now >= startTime && now <= endTime);\n', '    \n', '    // calculate the number of tokens to be send. multipling with (10 ** 8) since the token used has 8 decimals\n', '    uint256 numToken = getTokenAmount(weiAmount).mul(10 ** 8);\n', '    \n', '    // check whether the contract have enough token balance \n', '    require(token.balanceOf(this).sub(numToken) > 0 );\n', '    \n', '    // check whether the sender is contributing for the first time\n', '    if(contributionOf[msg.sender] <= 0){\n', '        contributors.push(msg.sender);\n', '        token.freeze(msg.sender);\n', '    }\n', '    \n', '    contributionOf[msg.sender] = contributionOf[msg.sender].add(weiAmount);\n', '    \n', '    token.transfer(msg.sender, numToken);\n', '    \n', '    weiRaised = weiRaised.add(weiAmount);\n', '    \n', '    updateWinnersList();\n', '    \n', '    contributionSuccessful(msg.sender,weiAmount,numToken);\n', '  }\n', '\n', '  // @return Number of tokens\n', '  function getTokenAmount(uint256 weiAmount) internal returns(uint256) {\n', '       uint256 tokenAmount;\n', '       \n', '        if(weiRaised <= 100 ether){\n', '            rate = 10e14;\n', '            tokenAmount = weiAmount.div(rate);\n', '            return tokenAmount;\n', '        }\n', '        else if(weiRaised > 100 ether && weiRaised <= 150 ether){\n', '            rate = 15e14;\n', '            tokenAmount = weiAmount.div(rate);\n', '            return tokenAmount;\n', '        }\n', '        else if(weiRaised > 150 ether && weiRaised <= 200 ether){\n', '            rate = 20e14;\n', '            tokenAmount = weiAmount.div(rate);\n', '            return tokenAmount;\n', '        }\n', '        else if(weiRaised > 200 ether && weiRaised <= 250 ether){\n', '            rate = 25e14;\n', '            tokenAmount = weiAmount.div(rate);\n', '            return tokenAmount;\n', '        }\n', '        else if(weiRaised > 250){\n', '            rate = 30e14;\n', '            tokenAmount = weiAmount.div(rate);\n', '            return tokenAmount;\n', '        }\n', '        \n', '  }\n', '  \n', '  // update winners list\n', '  function updateWinnersList() internal returns(bool) {\n', '      if(topWinners[0] != msg.sender){\n', '       bool flag=false;\n', '       for(uint256 i = 0; i < 10; i++){\n', '           if(topWinners[i] == msg.sender){\n', '               break;\n', '           }\n', '           if(contributionOf[msg.sender] > contributionOf[topWinners[i]]){\n', '               flag=true;\n', '               break;\n', '           }\n', '       }\n', '       if(flag == true){\n', '           for(uint256 j = 10; j > i; j--){\n', '               if(topWinners[j-1] != msg.sender){\n', '                   topWinners[j]=topWinners[j-1];\n', '               }\n', '               else{\n', '                   for(uint256 k = j; k < 10; k++){\n', '                       topWinners[k]=topWinners[k+1];\n', '                   }\n', '               }\n', '            }\n', '            topWinners[i]=msg.sender;\n', '       }\n', '       return true;\n', '     }\n', '  }\n', '\n', '  // @return true if contract is expired\n', '  function hasEnded() public view returns (bool) {\n', '    return (now > endTime) ;\n', '  }\n', '  \n', '  /**\n', '   * @dev Function to find the winners\n', '   */\n', '  function findWinners() public onlyOwner {\n', '    require(now >= endTime);\n', '    \n', '    // number of contributors\n', '    uint256 len=contributors.length;\n', '    \n', '    // factor multiplied to get the deserved percentage of weiRaised for a winner\n', '    uint256 mulFactor=50;\n', '    \n', '    // setting top ten winners with won amount \n', '    for(uint256 num = 0; num < 10 && num < len; num++){\n', '      amountWon[topWinners[num]]=(weiRaised.div(1000)).mul(mulFactor);\n', '      mulFactor=mulFactor.sub(5);\n', '     }\n', '     topWinners.length--;\n', '       \n', '    // setting next 10 random winners \n', '    if(len > 10 && len <= 20 ){\n', '        for(num = 0 ; num < 20 && num < len; num++){\n', '            if(amountWon[contributors[num]] <= 0){\n', '            randomWinners.push(contributors[num]);\n', '            amountWon[contributors[num]]=(weiRaised.div(1000)).mul(3);\n', '            }\n', '        }\n', '    }\n', '    else if(len > 20){\n', '        for(uint256 i = 0 ; i < 10; i++){\n', '            // finding a random number(winner) excluding the top 10 winners\n', '            uint256 randomNo=random(i+1) % len;\n', '            // To avoid multiple wining by same address\n', '            if(amountWon[contributors[randomNo]] <= 0){\n', '                randomWinners.push(contributors[randomNo]);\n', '                amountWon[contributors[randomNo]]=(weiRaised.div(1000)).mul(3);\n', '            }\n', '            else{\n', '                \n', '                for(uint256 j = 0; j < len; j++){\n', '                    randomNo=(randomNo.add(1)) % len;\n', '                    if(amountWon[contributors[randomNo]] <= 0){\n', '                        randomWinners.push(contributors[randomNo]);\n', '                        amountWon[contributors[randomNo]]=(weiRaised.div(1000)).mul(3);\n', '                        break;\n', '                    }\n', '                }\n', '            }\n', '        }    \n', '    }\n', '  }\n', '  \n', '    \n', '  /**\n', '   * @dev Generate a random using the block number and loop count as the seed of randomness.\n', '   */\n', '   function random(uint256 count) internal constant returns (uint256) {\n', '    uint256 rand = block.number.mul(count);\n', '    return rand;\n', '  }\n', '  \n', '  /**\n', '   * @dev Function to stop the contribution\n', '   */\n', '  function stop() public onlyOwner  {\n', '    endTime = now ;\n', '  }\n', '  \n', '  /**\n', '   * @dev Function for withdrawing eth by the owner\n', '   */\n', '  function ownerWithdrawal(uint256 amt) public onlyOwner  {\n', '    // Limit owner from withdrawing not more than 70% \n', '    require((amt.add(ownerWithdrawn)) <= (weiRaised.div(100)).mul(70));\n', '    if (owner.send(amt)) {\n', '        ownerWithdrawn=ownerWithdrawn.add(amt);\n', '        FundTransfer(owner, amt);\n', '    }\n', '  }\n', '  \n', '  /**\n', '   * @dev Function for approving contributors after KYC\n', '   */\n', '  function KYCApprove(address[] contributorsList) public onlyOwner  {\n', '    for (uint256 i = 0; i < contributorsList.length; i++) {\n', '        address addr=contributorsList[i];\n', '        //set KYC Status\n', '        KYCDone[addr]=true;\n', '        KYCApproved(addr);\n', '        token.release(addr);\n', '    }\n', '  }\n', '  \n', '  /**\n', '   * @dev Function for withdrawing won amount by the winners\n', '   */\n', '  function winnerWithdrawal() public {\n', '    require(now >= endTime);\n', '    //check whether winner\n', '    require(amountWon[msg.sender] > 0);\n', '    //check whether winner done KYC\n', '    require(KYCDone[msg.sender]);\n', '    //check whether winner already withdrawn the won amount \n', '    require(!claimed[msg.sender]);\n', '\n', '    if (msg.sender.send(amountWon[msg.sender])) {\n', '        claimed[msg.sender]=true;\n', '        FundTransfer(msg.sender,amountWon[msg.sender] );\n', '    }\n', '  }\n', '  \n', '  // @return Current token balance of this contract\n', '  function tokensAvailable()public view returns (uint256) {\n', '    return token.balanceOf(this);\n', '  }\n', '  \n', '  // @return List of top winners\n', '  function showTopWinners() public view returns (address[]) {\n', '    require(now >= endTime);\n', '        return (topWinners);\n', '  }\n', '  \n', '  // @return List of random winners\n', '  function showRandomWinners() public view returns (address[]) {\n', '    require(now >= endTime);\n', '        return (randomWinners);\n', '  }\n', '  \n', '  /**\n', '   * @dev Function to destroy contract\n', '   */\n', '  function destroy() public onlyOwner {\n', '    require(now >= endTime);\n', '    uint256 balance= this.balance;\n', '    owner.transfer(balance);\n', '    FundTransfer(owner, balance);\n', '    uint256 balanceToken = tokensAvailable();\n', '    token.transfer(owner, balanceToken);\n', '    selfdestruct(owner);\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  } \n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract LoveToken {\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '  function freeze(address target) public returns (bool);\n', '  function release(address target) public returns (bool);\n', '}\n', '\n', 'contract LoveContribution is Ownable {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  //The token being given\n', '  LoveToken  token;\n', '  \n', '  // contribution in wei\n', '  mapping(address => uint256) public contributionOf;\n', '  \n', '  // array of contributors\n', '  address[] contributors;\n', '  \n', '  // array of top contributed winners\n', '   address[] topWinners=[address(0),address(0),address(0),address(0),address(0),address(0),address(0),address(0),address(0),address(0),address(0)];\n', '  \n', '  // array of random winners\n', '  address[] randomWinners;\n', '  \n', '  // won amount in wei\n', '  mapping(address => uint256) public amountWon;\n', '  \n', '  // ckeck whether the winner withdrawn the won amount\n', '  mapping(address => bool) public claimed;\n', '  \n', '  // ckeck whether the contributor completed KYC\n', '  mapping(address => bool) public KYCDone;\n', '\n', '  // start and end timestamps\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '\n', '  // price of token in wei\n', '  uint256 public rate = 10e14;\n', '\n', '  // amount of wei raised\n', '  uint256 public weiRaised;\n', '  \n', '  // amount of wei withdrawn by owner\n', '  uint256 public ownerWithdrawn;\n', '  \n', '  event contributionSuccessful(address indexed contributedBy, uint256 contribution, uint256 tokenReceived);\n', '  event FundTransfer(address indexed beneficiary, uint256 amount);\n', '  event FundTransferFailed();\n', '  event KYCApproved(address indexed contributor);\n', '\n', '  function LoveContribution(uint256 _startTime, uint256 _endTime, LoveToken  _token) public {\n', '    require(_startTime >= now);\n', '    require(_endTime >= _startTime);\n', '    require(_token != address(0));\n', '\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '    token = _token;\n', '  }\n', '\n', '  // fallback function can be used to buy tokens\n', '  function () external payable {\n', '    contribute();\n', '  }\n', '    \n', '   \n', '  /**\n', '   * @dev low level token purchase function\n', '   */\n', '  function contribute() internal {\n', '    uint256 weiAmount = msg.value;\n', '    require(msg.sender != address(0) && weiAmount >= 5e15);\n', '    require(now >= startTime && now <= endTime);\n', '    \n', '    // calculate the number of tokens to be send. multipling with (10 ** 8) since the token used has 8 decimals\n', '    uint256 numToken = getTokenAmount(weiAmount).mul(10 ** 8);\n', '    \n', '    // check whether the contract have enough token balance \n', '    require(token.balanceOf(this).sub(numToken) > 0 );\n', '    \n', '    // check whether the sender is contributing for the first time\n', '    if(contributionOf[msg.sender] <= 0){\n', '        contributors.push(msg.sender);\n', '        token.freeze(msg.sender);\n', '    }\n', '    \n', '    contributionOf[msg.sender] = contributionOf[msg.sender].add(weiAmount);\n', '    \n', '    token.transfer(msg.sender, numToken);\n', '    \n', '    weiRaised = weiRaised.add(weiAmount);\n', '    \n', '    updateWinnersList();\n', '    \n', '    contributionSuccessful(msg.sender,weiAmount,numToken);\n', '  }\n', '\n', '  // @return Number of tokens\n', '  function getTokenAmount(uint256 weiAmount) internal returns(uint256) {\n', '       uint256 tokenAmount;\n', '       \n', '        if(weiRaised <= 100 ether){\n', '            rate = 10e14;\n', '            tokenAmount = weiAmount.div(rate);\n', '            return tokenAmount;\n', '        }\n', '        else if(weiRaised > 100 ether && weiRaised <= 150 ether){\n', '            rate = 15e14;\n', '            tokenAmount = weiAmount.div(rate);\n', '            return tokenAmount;\n', '        }\n', '        else if(weiRaised > 150 ether && weiRaised <= 200 ether){\n', '            rate = 20e14;\n', '            tokenAmount = weiAmount.div(rate);\n', '            return tokenAmount;\n', '        }\n', '        else if(weiRaised > 200 ether && weiRaised <= 250 ether){\n', '            rate = 25e14;\n', '            tokenAmount = weiAmount.div(rate);\n', '            return tokenAmount;\n', '        }\n', '        else if(weiRaised > 250){\n', '            rate = 30e14;\n', '            tokenAmount = weiAmount.div(rate);\n', '            return tokenAmount;\n', '        }\n', '        \n', '  }\n', '  \n', '  // update winners list\n', '  function updateWinnersList() internal returns(bool) {\n', '      if(topWinners[0] != msg.sender){\n', '       bool flag=false;\n', '       for(uint256 i = 0; i < 10; i++){\n', '           if(topWinners[i] == msg.sender){\n', '               break;\n', '           }\n', '           if(contributionOf[msg.sender] > contributionOf[topWinners[i]]){\n', '               flag=true;\n', '               break;\n', '           }\n', '       }\n', '       if(flag == true){\n', '           for(uint256 j = 10; j > i; j--){\n', '               if(topWinners[j-1] != msg.sender){\n', '                   topWinners[j]=topWinners[j-1];\n', '               }\n', '               else{\n', '                   for(uint256 k = j; k < 10; k++){\n', '                       topWinners[k]=topWinners[k+1];\n', '                   }\n', '               }\n', '            }\n', '            topWinners[i]=msg.sender;\n', '       }\n', '       return true;\n', '     }\n', '  }\n', '\n', '  // @return true if contract is expired\n', '  function hasEnded() public view returns (bool) {\n', '    return (now > endTime) ;\n', '  }\n', '  \n', '  /**\n', '   * @dev Function to find the winners\n', '   */\n', '  function findWinners() public onlyOwner {\n', '    require(now >= endTime);\n', '    \n', '    // number of contributors\n', '    uint256 len=contributors.length;\n', '    \n', '    // factor multiplied to get the deserved percentage of weiRaised for a winner\n', '    uint256 mulFactor=50;\n', '    \n', '    // setting top ten winners with won amount \n', '    for(uint256 num = 0; num < 10 && num < len; num++){\n', '      amountWon[topWinners[num]]=(weiRaised.div(1000)).mul(mulFactor);\n', '      mulFactor=mulFactor.sub(5);\n', '     }\n', '     topWinners.length--;\n', '       \n', '    // setting next 10 random winners \n', '    if(len > 10 && len <= 20 ){\n', '        for(num = 0 ; num < 20 && num < len; num++){\n', '            if(amountWon[contributors[num]] <= 0){\n', '            randomWinners.push(contributors[num]);\n', '            amountWon[contributors[num]]=(weiRaised.div(1000)).mul(3);\n', '            }\n', '        }\n', '    }\n', '    else if(len > 20){\n', '        for(uint256 i = 0 ; i < 10; i++){\n', '            // finding a random number(winner) excluding the top 10 winners\n', '            uint256 randomNo=random(i+1) % len;\n', '            // To avoid multiple wining by same address\n', '            if(amountWon[contributors[randomNo]] <= 0){\n', '                randomWinners.push(contributors[randomNo]);\n', '                amountWon[contributors[randomNo]]=(weiRaised.div(1000)).mul(3);\n', '            }\n', '            else{\n', '                \n', '                for(uint256 j = 0; j < len; j++){\n', '                    randomNo=(randomNo.add(1)) % len;\n', '                    if(amountWon[contributors[randomNo]] <= 0){\n', '                        randomWinners.push(contributors[randomNo]);\n', '                        amountWon[contributors[randomNo]]=(weiRaised.div(1000)).mul(3);\n', '                        break;\n', '                    }\n', '                }\n', '            }\n', '        }    \n', '    }\n', '  }\n', '  \n', '    \n', '  /**\n', '   * @dev Generate a random using the block number and loop count as the seed of randomness.\n', '   */\n', '   function random(uint256 count) internal constant returns (uint256) {\n', '    uint256 rand = block.number.mul(count);\n', '    return rand;\n', '  }\n', '  \n', '  /**\n', '   * @dev Function to stop the contribution\n', '   */\n', '  function stop() public onlyOwner  {\n', '    endTime = now ;\n', '  }\n', '  \n', '  /**\n', '   * @dev Function for withdrawing eth by the owner\n', '   */\n', '  function ownerWithdrawal(uint256 amt) public onlyOwner  {\n', '    // Limit owner from withdrawing not more than 70% \n', '    require((amt.add(ownerWithdrawn)) <= (weiRaised.div(100)).mul(70));\n', '    if (owner.send(amt)) {\n', '        ownerWithdrawn=ownerWithdrawn.add(amt);\n', '        FundTransfer(owner, amt);\n', '    }\n', '  }\n', '  \n', '  /**\n', '   * @dev Function for approving contributors after KYC\n', '   */\n', '  function KYCApprove(address[] contributorsList) public onlyOwner  {\n', '    for (uint256 i = 0; i < contributorsList.length; i++) {\n', '        address addr=contributorsList[i];\n', '        //set KYC Status\n', '        KYCDone[addr]=true;\n', '        KYCApproved(addr);\n', '        token.release(addr);\n', '    }\n', '  }\n', '  \n', '  /**\n', '   * @dev Function for withdrawing won amount by the winners\n', '   */\n', '  function winnerWithdrawal() public {\n', '    require(now >= endTime);\n', '    //check whether winner\n', '    require(amountWon[msg.sender] > 0);\n', '    //check whether winner done KYC\n', '    require(KYCDone[msg.sender]);\n', '    //check whether winner already withdrawn the won amount \n', '    require(!claimed[msg.sender]);\n', '\n', '    if (msg.sender.send(amountWon[msg.sender])) {\n', '        claimed[msg.sender]=true;\n', '        FundTransfer(msg.sender,amountWon[msg.sender] );\n', '    }\n', '  }\n', '  \n', '  // @return Current token balance of this contract\n', '  function tokensAvailable()public view returns (uint256) {\n', '    return token.balanceOf(this);\n', '  }\n', '  \n', '  // @return List of top winners\n', '  function showTopWinners() public view returns (address[]) {\n', '    require(now >= endTime);\n', '        return (topWinners);\n', '  }\n', '  \n', '  // @return List of random winners\n', '  function showRandomWinners() public view returns (address[]) {\n', '    require(now >= endTime);\n', '        return (randomWinners);\n', '  }\n', '  \n', '  /**\n', '   * @dev Function to destroy contract\n', '   */\n', '  function destroy() public onlyOwner {\n', '    require(now >= endTime);\n', '    uint256 balance= this.balance;\n', '    owner.transfer(balance);\n', '    FundTransfer(owner, balance);\n', '    uint256 balanceToken = tokensAvailable();\n', '    token.transfer(owner, balanceToken);\n', '    selfdestruct(owner);\n', '  }\n', '}']
