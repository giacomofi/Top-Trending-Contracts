['pragma solidity 0.4.25;\n', '\n', 'contract StandardToken {\n', '\n', '    /* Data structures */\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '\n', '    /* Events */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /* Read and write storage functions */\n', '\n', "    // Transfers sender's tokens to a given address. Returns success.\n", '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Allows allowed third party to transfer tokens from one address to another. Returns success. _value Number of tokens to transfer.\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Returns number of tokens owned by given address.\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Sets approved amount of tokens for spender. Returns success. _value Number of approved tokens.\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /* Read storage functions */\n', '\n', '    //Returns number of allowed tokens for given address. _owner Address of token owner. _spender Address of token spender.\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract AltTokenFund is StandardToken {\n', '\n', '    /* External contracts */\n', '\n', '    address public emissionContractAddress = 0x0;\n', '\n', '    //Token meta data\n', '    string constant public name = "Alt Token Fund";\n', '    string constant public symbol = "ATF";\n', '    uint8 constant public decimals = 8;\n', '\n', '    /* Storage */\n', '    address public owner = 0x0;\n', '    bool public emissionEnabled = true;\n', '    bool transfersEnabled = true;\n', '\n', '    /* Modifiers */\n', '\n', '    modifier isCrowdfundingContract() {\n', '        // Only emission address to do this action\n', '        if (msg.sender != emissionContractAddress) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        // Only owner is allowed to do this action.\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    /* Contract functions */\n', '\n', '    // TokenFund emission function. _for is Address of receiver, tokenCount is Number of tokens to issue.\n', '    function issueTokens(address _for, uint tokenCount)\n', '        external\n', '        isCrowdfundingContract\n', '        returns (bool)\n', '    {\n', '        if (emissionEnabled == false) {\n', '            revert();\n', '        }\n', '\n', '        balances[_for] += tokenCount;\n', '        totalSupply += tokenCount;\n', '        return true;\n', '    }\n', '\n', '    // Withdraws tokens for msg.sender.\n', '    function withdrawTokens(uint tokenCount)\n', '        public\n', '        returns (bool)\n', '    {\n', '        uint balance = balances[msg.sender];\n', '        if (balance < tokenCount) {\n', '            return false;\n', '        }\n', '        balances[msg.sender] -= tokenCount;\n', '        totalSupply -= tokenCount;\n', '        return true;\n', '    }\n', '\n', '    // Function to change address that is allowed to do emission.\n', '    function changeEmissionContractAddress(address newAddress)\n', '        external\n', '        onlyOwner\n', '    {\n', '        emissionContractAddress = newAddress;\n', '    }\n', '\n', '    // Function that enables/disables transfers of token, value is true/false\n', '    function enableTransfers(bool value)\n', '        external\n', '        onlyOwner\n', '    {\n', '        transfersEnabled = value;\n', '    }\n', '\n', '    // Function that enables/disables token emission.\n', '    function enableEmission(bool value)\n', '        external\n', '        onlyOwner\n', '    {\n', '        emissionEnabled = value;\n', '    }\n', '\n', '    /* Overriding ERC20 standard token functions to support transfer lock */\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        if (transfersEnabled == true) {\n', '            return super.transfer(_to, _value);\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        if (transfersEnabled == true) {\n', '            return super.transferFrom(_from, _to, _value);\n', '        }\n', '        return false;\n', '    }\n', '\n', '\n', '    // Contract constructor function sets initial token balances. _owner Address of the owner of AltTokenFund.\n', '    constructor (address _owner) public\n', '    {\n', '        totalSupply = 0;\n', '        owner = _owner;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Fund {\n', '\n', '  address public owner;\n', '  address public SetPriceAccount;\n', '  address public SetReferralAccount;\n', '\n', '  modifier onlyOwner {\n', '      if (msg.sender != owner) revert();\n', '      _;\n', '  }\n', '  \n', '  modifier onlySetPriceAccount {\n', '      if (msg.sender != SetPriceAccount) revert();\n', '      _;\n', '  }\n', '  \n', '  modifier onlySetReferralAccount {\n', '      if (msg.sender != SetReferralAccount) revert();\n', '      _;\n', '  }\n', '  \n', '    /* External contracts */\n', '    AltTokenFund public tokenFund;\n', '\n', '    /* Events */\n', '    event Deposit(address indexed from, uint256 value);\n', '    event Withdrawal(address indexed from, uint256 value);\n', '    event AddInvestment(address indexed to, uint256 value);\n', '\n', '    /* Storage */\n', '    address public ethAddress;\n', '    address public fundManagers;\n', '    address public supportAddress;\n', '    uint public tokenPrice = 1 finney; // 0.001 ETH\n', '    uint public managersFee = 1;\n', '    uint public referralFee = 3;\n', '    uint public supportFee = 1;\n', '\n', '    mapping (address => address) public referrals;\n', '\n', '/* Contract functions */\n', '\n', '    // Issue tokens _for address and send comissions\n', '\n', '    function issueTokens(address _for, uint tokenCount)\n', '    \tprivate\n', '    \treturns (bool)\n', '    {\n', '    \tif (tokenCount == 0) {\n', '        return false;\n', '      }\n', '\n', '      uint percent = tokenCount / 100;\n', '\n', '    // managersFee to the fund managers\n', '      if (!tokenFund.issueTokens(fundManagers, percent * managersFee)) {\n', '        // Tokens could not be issued.\n', '        revert();\n', '      }\n', '\n', '    // supportFee to the support team\n', '      if (!tokenFund.issueTokens(supportAddress, percent * supportFee)) {\n', '        // Tokens could not be issued.\n', '        revert();\n', '      }\n', '\n', '      if (referrals[_for] != 0) {\n', '      \t// referralFee to the referral\n', '      \tif (!tokenFund.issueTokens(referrals[_for], referralFee * percent)) {\n', '          // Tokens could not be issued.\n', '          revert();\n', '        }\n', '      } else {\n', '      \t// if there is no referral, referralFee goes to the fund managers\n', '      \tif (!tokenFund.issueTokens(fundManagers, referralFee * percent)) {\n', '          // Tokens could not be issued.\n', '          revert();\n', '        }\n', '      }\n', '\n', '      if (!tokenFund.issueTokens(_for, tokenCount - (referralFee+supportFee+managersFee) * percent)) {\n', '        // Tokens could not be issued.\n', '        revert();\n', '\t    }\n', '\n', '\t    return true;\n', '    }\n', '\n', '    // Issues tokens for users who made investment.\n', '    // @param beneficiary Address the tokens will be issued to.\n', '    // @param valueInWei investment in wei\n', '    function addInvestment(address beneficiary, uint valueInWei)\n', '        external\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        uint tokenCount = calculateTokens(valueInWei);\n', '    \treturn issueTokens(beneficiary, tokenCount);\n', '    }\n', '\n', '    // Issues tokens for users who made direct ETH payment.\n', '    function fund()\n', '        public\n', '        payable\n', '        returns (bool)\n', '    {\n', '        // Token count is rounded down. Sent ETH should be multiples of baseTokenPrice.\n', '        address beneficiary = msg.sender;\n', '        uint tokenCount = calculateTokens(msg.value);\n', '        uint roundedInvestment = tokenCount * tokenPrice / 100000000;\n', '\n', '        // Send change back to user.\n', '        if (msg.value > roundedInvestment && !beneficiary.send(msg.value - roundedInvestment)) {\n', '          revert();\n', '        }\n', '        // Send money to the fund ethereum address\n', '        if (!ethAddress.send(roundedInvestment)) {\n', '          revert();\n', '        }\n', '        return issueTokens(beneficiary, tokenCount);\n', '    }\n', '\n', '    function calculateTokens(uint valueInWei)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return valueInWei * 100000000 / tokenPrice;\n', '    }\n', '\n', '    function estimateTokens(uint valueInWei)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return valueInWei * (100000000-1000000*(referralFee+supportFee+managersFee)) / tokenPrice;\n', '    }\n', '\n', '    function setReferral(address client, address referral)\n', '        public\n', '        onlySetReferralAccount\n', '    {\n', '        referrals[client] = referral;\n', '    }\n', '\n', '    function getReferral(address client)\n', '        public\n', '        constant\n', '        returns (address)\n', '    {\n', '        return referrals[client];\n', '    }\n', '\n', '    /// @dev Sets token price (TKN/ETH) in Wei.\n', '    /// @param valueInWei New value.\n', '    function setTokenPrice(uint valueInWei)\n', '        public\n', '        onlySetPriceAccount\n', '    {\n', '        tokenPrice = valueInWei;\n', '    }\n', '\n', '\n', '    function changeComissions(uint newManagersFee, uint newSupportFee, uint newReferralFee) public\n', '        onlyOwner\n', '    {\n', '        managersFee = newManagersFee;\n', '        supportFee = newSupportFee;\n', '        referralFee = newReferralFee;\n', '    }\n', '\n', '    function changefundManagers(address newfundManagers) public\n', '        onlyOwner\n', '    {\n', '        fundManagers = newfundManagers;\n', '    }\n', '\n', '    function changeEthAddress(address newEthAddress) public\n', '        onlyOwner\n', '    {\n', '        ethAddress = newEthAddress;\n', '    }\n', '\n', '    function changeSupportAddress(address newSupportAddress) public\n', '        onlyOwner\n', '    {\n', '        supportAddress = newSupportAddress;\n', '    }\n', '    \n', '    function changeSetPriceAccount(address newSetPriceAccount) public\n', '        onlyOwner\n', '    {\n', '        SetPriceAccount = newSetPriceAccount;\n', '    }\n', '    \n', '     function changeSetReferralAccount (address newSetReferralAccount) public\n', '        onlyOwner\n', '    {\n', '        SetReferralAccount = newSetReferralAccount;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public\n', '      onlyOwner\n', '    {\n', '        owner = newOwner;\n', '    }\n', '\n', '    // Contract constructor function\n', '\n', '    constructor (address _owner, address _SetPriceAccount, address _SetReferralAccount, address _ethAddress, address _fundManagers, address _supportAddress, address _tokenAddress)\n', '    public\n', '    {\n', '        owner = _owner;\n', '        SetPriceAccount = _SetPriceAccount;\n', '        SetReferralAccount = _SetReferralAccount;\n', '        ethAddress = _ethAddress;\n', '        fundManagers = _fundManagers;\n', '        supportAddress = _supportAddress;\n', '        tokenFund = AltTokenFund(_tokenAddress);\n', '    }\n', '\n', '    // Fallback function. Calls fund() function to create tokens once contract receives payment.\n', '    function () public payable {\n', '        fund();\n', '    }\n', '}']