['pragma solidity ^0.4.25;\n', '\n', '/// @title A facet of CSportsCore that holds all important constants and modifiers\n', '/// @author CryptoSports, Inc. (https://cryptosports.team))\n', '/// @dev See the CSportsCore contract documentation to understand how the various CSports contract facets are arranged.\n', 'contract CSportsConstants {\n', '\n', '    /// @dev The maximum # of marketing tokens that can ever be created\n', '    /// by the commissioner.\n', '    uint16 public MAX_MARKETING_TOKENS = 2500;\n', '\n', '    /// @dev The starting price for commissioner auctions (if the average\n', '    ///   of the last 2 is less than this, we will use this value)\n', '    ///   A finney is 1/1000 of an ether.\n', '    uint256 public COMMISSIONER_AUCTION_FLOOR_PRICE = 5 finney; // 5 finney for production, 15 for script testing and 1 finney for Rinkeby\n', '\n', '    /// @dev The duration of commissioner auctions\n', '    uint256 public COMMISSIONER_AUCTION_DURATION = 14 days; // 30 days for testing;\n', '\n', '    /// @dev Number of seconds in a week\n', '    uint32 constant WEEK_SECS = 1 weeks;\n', '\n', '}\n', '\n', '/// @title A facet of CSportsCore that manages an individual&#39;s authorized role against access privileges.\n', '/// @author CryptoSports, Inc. (https://cryptosports.team))\n', '/// @dev See the CSportsCore contract documentation to understand how the various CSports contract facets are arranged.\n', 'contract CSportsAuth is CSportsConstants {\n', '    // This facet controls access control for CryptoSports. There are four roles managed here:\n', '    //\n', '    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n', '    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n', '    //         set to the address that created the smart contract in the CSportsCore constructor.\n', '    //\n', '    //     - The CFO: The CFO can withdraw funds from CSportsCore and its auction contracts.\n', '    //\n', '    //     - The COO: The COO can perform administrative functions.\n', '    //\n', '    //     - The Commisioner can perform "oracle" functions like adding new real world players,\n', '    //       setting players active/inactive, and scoring contests.\n', '    //\n', '\n', '    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n', '    event ContractUpgrade(address newContract);\n', '\n', '    /// The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '    address public cooAddress;\n', '    address public commissionerAddress;\n', '\n', '    /// @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused = false;\n', '\n', '    /// @dev Flag that identifies whether or not we are in development and should allow development\n', '    /// only functions to be called.\n', '    bool public isDevelopment = true;\n', '\n', '    /// @dev Access modifier to allow access to development mode functions\n', '    modifier onlyUnderDevelopment() {\n', '      require(isDevelopment == true);\n', '      _;\n', '    }\n', '\n', '    /// @dev Access modifier for CEO-only functionality\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for CFO-only functionality\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for COO-only functionality\n', '    modifier onlyCOO() {\n', '        require(msg.sender == cooAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for Commissioner-only functionality\n', '    modifier onlyCommissioner() {\n', '        require(msg.sender == commissionerAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Requires any one of the C level addresses\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == cooAddress ||\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cfoAddress ||\n', '            msg.sender == commissionerAddress\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev prevents contracts from hitting the method\n', '    modifier notContract() {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '\n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0);\n', '        _;\n', '    }\n', '\n', '    /// @dev One way switch to set the contract into prodution mode. This is one\n', '    /// way in that the contract can never be set back into development mode. Calling\n', '    /// this function will block all future calls to functions that are meant for\n', '    /// access only while we are under development. It will also enable more strict\n', '    /// additional checking on various parameters and settings.\n', '    function setProduction() public onlyCEO onlyUnderDevelopment {\n', '      isDevelopment = false;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '    /// @param _newCEO The address of the new CEO\n', '    function setCEO(address _newCEO) public onlyCEO {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n', '    /// @param _newCFO The address of the new CFO\n', '    function setCFO(address _newCFO) public onlyCEO {\n', '        require(_newCFO != address(0));\n', '\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n', '    /// @param _newCOO The address of the new COO\n', '    function setCOO(address _newCOO) public onlyCEO {\n', '        require(_newCOO != address(0));\n', '\n', '        cooAddress = _newCOO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Commissioner. Only available to the current CEO.\n', '    /// @param _newCommissioner The address of the new COO\n', '    function setCommissioner(address _newCommissioner) public onlyCEO {\n', '        require(_newCommissioner != address(0));\n', '\n', '        commissionerAddress = _newCommissioner;\n', '    }\n', '\n', '    /// @dev Assigns all C-Level addresses\n', '    /// @param _ceo CEO address\n', '    /// @param _cfo CFO address\n', '    /// @param _coo COO address\n', '    /// @param _commish Commissioner address\n', '    function setCLevelAddresses(address _ceo, address _cfo, address _coo, address _commish) public onlyCEO {\n', '        require(_ceo != address(0));\n', '        require(_cfo != address(0));\n', '        require(_coo != address(0));\n', '        require(_commish != address(0));\n', '        ceoAddress = _ceo;\n', '        cfoAddress = _cfo;\n', '        cooAddress = _coo;\n', '        commissionerAddress = _commish;\n', '    }\n', '\n', '    /// @dev Transfers the balance of this contract to the CFO\n', '    function withdrawBalance() external onlyCFO {\n', '        cfoAddress.transfer(address(this).balance);\n', '    }\n', '\n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '    ///  a bug or exploit is detected and we need to limit damage.\n', '    function pause() public onlyCLevel whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '    ///  one reason we may pause the contract is when CFO or COO accounts are\n', '    ///  compromised.\n', '    function unpause() public onlyCEO whenPaused {\n', '        paused = false;\n', '    }\n', '}\n', '\n', '/// @dev Interface required by league roster contract to access\n', '/// the mintPlayers(...) function\n', 'interface CSportsMinter {\n', '\n', '    /// @dev Called by league roster contract as a sanity check\n', '    function isMinter() external pure returns (bool);\n', '\n', '    /// @dev The method called by the league roster contract to mint a new player and create its commissioner auction\n', '    function mintPlayers(uint128[] _md5Tokens, uint256 _startPrice, uint256 _endPrice, uint256 _duration) external;\n', '}\n', '/// @dev This is the data structure that holds a roster player in the CSportsLeagueRoster\n', '/// contract. Also referenced by CSportsCore.\n', '/// @author CryptoSports, Inc. (http://cryptosports.team)\n', 'contract CSportsRosterPlayer {\n', '\n', '    struct RealWorldPlayer {\n', '\n', '        // The player&#39;s certified identification. This is the md5 hash of\n', '        // {player&#39;s last name}-{player&#39;s first name}-{player&#39;s birthday in YYYY-MM-DD format}-{serial number}\n', '        // where the serial number is usually 0, but gives us an ability to deal with making\n', '        // sure all MD5s are unique.\n', '        uint128 md5Token;\n', '\n', '        // Stores the average sale price of the most recent 2 commissioner sales\n', '        uint128 prevCommissionerSalePrice;\n', '\n', '        // The last time this real world player was minted.\n', '        uint64 lastMintedTime;\n', '\n', '        // The number of PlayerTokens minted for this real world player\n', '        uint32 mintedCount;\n', '\n', '        // When true, there is an active auction for this player owned by\n', '        // the commissioner (indicating a gen0 minting auction is in progress)\n', '        bool hasActiveCommissionerAuction;\n', '\n', '        // Indicates this real world player can be actively minted\n', '        bool mintingEnabled;\n', '\n', '        // Any metadata we want to attach to this player (in JSON format)\n', '        string metadata;\n', '\n', '    }\n', '\n', '}\n', '\n', '/// @title Contract that holds all of the real world player data. This data is\n', '/// added by the commissioner and represents an on-blockchain database of\n', '/// players in the league.\n', '/// @author CryptoSports, Inc. (http://cryptosports.team)\n', 'contract CSportsLeagueRoster is CSportsAuth, CSportsRosterPlayer  {\n', '\n', '  /*** STORAGE ***/\n', '\n', '  /// @dev Holds the coreContract which supports the CSportsMinter interface\n', '  CSportsMinter public minterContract;\n', '\n', '  /// @dev Holds one entry for each real-world player available in the\n', '  /// current league (e.g. NFL). There can be a maximum of 4,294,967,295\n', '  /// entries in this array (plenty) because it is indexed by a uint32.\n', '  /// This structure is constantly updated by a commissioner. If the\n', '  /// realWorldPlayer[<whatever].mintingEnabled property is true, then playerTokens\n', '  /// tied to this realWorldPlayer entry will automatically be minted.\n', '  RealWorldPlayer[] public realWorldPlayers;\n', '\n', '  mapping (uint128 => uint32) public md5TokenToRosterIndex;\n', '\n', '  /*** MODIFIERS ***/\n', '\n', '  /// @dev Access modifier for core contract only functions\n', '  modifier onlyCoreContract() {\n', '      require(msg.sender == address(minterContract));\n', '      _;\n', '  }\n', '\n', '  /*** FUNCTIONS ***/\n', '\n', '  /// @dev Contract constructor. All "C" level authorized addresses\n', '  /// are set to the contract creator.\n', '  constructor() public {\n', '    ceoAddress = msg.sender;\n', '    cfoAddress = msg.sender;\n', '    cooAddress = msg.sender;\n', '    commissionerAddress = msg.sender;\n', '  }\n', '\n', '  /// @dev Sanity check that identifies this contract is a league roster contract\n', '  function isLeagueRosterContract() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /// @dev Returns the full player structure from the league roster contract given its index.\n', '  /// @param idx Index of player we are interested in\n', '  function realWorldPlayerFromIndex(uint128 idx) public view returns (uint128 md5Token, uint128 prevCommissionerSalePrice, uint64 lastMintedTime, uint32 mintedCount, bool hasActiveCommissionerAuction, bool mintingEnabled) {\n', '    RealWorldPlayer memory _rwp;\n', '    _rwp = realWorldPlayers[idx];\n', '    md5Token = _rwp.md5Token;\n', '    prevCommissionerSalePrice = _rwp.prevCommissionerSalePrice;\n', '    lastMintedTime = _rwp.lastMintedTime;\n', '    mintedCount = _rwp.mintedCount;\n', '    hasActiveCommissionerAuction = _rwp.hasActiveCommissionerAuction;\n', '    mintingEnabled = _rwp.mintingEnabled;\n', '  }\n', '\n', '  /// @dev Sets the coreContractAddress that will restrict access\n', '  /// to certin functions\n', '  function setCoreContractAddress(address _address) public onlyCEO {\n', '\n', '    CSportsMinter candidateContract = CSportsMinter(_address);\n', '    // NOTE: verify that a contract is what we expect (not foolproof, just\n', '    // a sanity check)\n', '    require(candidateContract.isMinter());\n', '    // Set the new contract address\n', '    minterContract = candidateContract;\n', '\n', '  }\n', '\n', '  /// @return uint32 count -  # of entries in the realWorldPlayer array\n', '  function playerCount() public view returns (uint32 count) {\n', '    return uint32(realWorldPlayers.length);\n', '  }\n', '\n', '  /// @dev Creates and adds realWorldPlayer entries, and mints a new ERC721 token for each, and puts each on\n', '  /// auction as a commissioner auction.\n', '  /// @param _md5Tokens The MD5s to be associated with the roster entries we are adding\n', '  /// @param _mintingEnabled An array (of equal length to _md5Tokens) indicating the minting status of that player\n', '  ///        (if an entry is not true, that player will not be minted and no auction created)\n', '  /// @param _startPrice The starting price for the auction we will create for the newly minted token\n', '  /// @param _endPrice The ending price for the auction we will create for the newly minted token\n', '  /// @param _duration The duration for the auction we will create for the newly minted token\n', '  function addAndMintPlayers(uint128[] _md5Tokens, bool[] _mintingEnabled, uint256 _startPrice, uint256 _endPrice, uint256 _duration) public onlyCommissioner {\n', '\n', '    // Add the real world players to the roster\n', '    addRealWorldPlayers(_md5Tokens, _mintingEnabled);\n', '\n', '    // Mint the newly added players and create commissioner auctions\n', '    minterContract.mintPlayers(_md5Tokens, _startPrice, _endPrice, _duration);\n', '\n', '  }\n', '\n', '  /// @dev Creates and adds a RealWorldPlayer entry.\n', '  /// @param _md5Tokens - An array of MD5 tokens for players to be added to our realWorldPlayers array.\n', '  /// @param _mintingEnabled - An array (of equal length to _md5Tokens) indicating the minting status of that player\n', '  function addRealWorldPlayers(uint128[] _md5Tokens, bool[] _mintingEnabled) public onlyCommissioner {\n', '    if (_md5Tokens.length != _mintingEnabled.length) {\n', '      revert();\n', '    }\n', '    for (uint32 i = 0; i < _md5Tokens.length; i++) {\n', '      // We won&#39;t try to put an md5Token duplicate by using the md5TokenToRosterIndex\n', '      // mapping (notice we need to deal with the fact that a non-existent mapping returns 0)\n', '      if ( (realWorldPlayers.length == 0) ||\n', '           ((md5TokenToRosterIndex[_md5Tokens[i]] == 0) && (realWorldPlayers[0].md5Token != _md5Tokens[i])) ) {\n', '        RealWorldPlayer memory _realWorldPlayer = RealWorldPlayer({\n', '                                                      md5Token: _md5Tokens[i],\n', '                                                      prevCommissionerSalePrice: 0,\n', '                                                      lastMintedTime: 0,\n', '                                                      mintedCount: 0,\n', '                                                      hasActiveCommissionerAuction: false,\n', '                                                      mintingEnabled: _mintingEnabled[i],\n', '                                                      metadata: ""\n', '                                                  });\n', '        uint256 _rosterIndex = realWorldPlayers.push(_realWorldPlayer) - 1;\n', '\n', '        // It&#39;s probably never going to happen, but just in case, we need\n', '        // to make sure our realWorldPlayers can be indexed by a uint32\n', '        require(_rosterIndex < 4294967295);\n', '\n', '        // Map the md5Token to its rosterIndex\n', '        md5TokenToRosterIndex[_md5Tokens[i]] = uint32(_rosterIndex);\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Sets the metadata for a real world player token that has already been added.\n', '  /// @param _md5Token The MD5 key of the token to update\n', '  /// @param _metadata The JSON string representing the metadata for the token\n', '  function setMetadata(uint128 _md5Token, string _metadata) public onlyCommissioner {\n', '      uint32 _rosterIndex = md5TokenToRosterIndex[_md5Token];\n', '      if ((_rosterIndex > 0) || ((realWorldPlayers.length > 0) && (realWorldPlayers[0].md5Token == _md5Token))) {\n', '        // Valid MD5 token\n', '        realWorldPlayers[_rosterIndex].metadata = _metadata;\n', '      }\n', '  }\n', '\n', '  /// @dev Returns the metadata for a specific token\n', '  /// @param _md5Token MD5 key for token we want the metadata for\n', '  function getMetadata(uint128 _md5Token) public view returns (string metadata) {\n', '    uint32 _rosterIndex = md5TokenToRosterIndex[_md5Token];\n', '    if ((_rosterIndex > 0) || ((realWorldPlayers.length > 0) && (realWorldPlayers[0].md5Token == _md5Token))) {\n', '      // Valid MD5 token\n', '      metadata = realWorldPlayers[_rosterIndex].metadata;\n', '    } else {\n', '      metadata = "";\n', '    }\n', '  }\n', '\n', '  /// @dev Function to remove a particular md5Token from our array of players. This function\n', '  ///   will be blocked after we are completed with development. Deleting entries would\n', '  ///   screw up the ids of realWorldPlayers held by the core contract&#39;s playerTokens structure.\n', '  /// @param _md5Token - The MD5 token of the entry to remove.\n', '  function removeRealWorldPlayer(uint128 _md5Token) public onlyCommissioner onlyUnderDevelopment  {\n', '    for (uint32 i = 0; i < uint32(realWorldPlayers.length); i++) {\n', '      RealWorldPlayer memory player = realWorldPlayers[i];\n', '      if (player.md5Token == _md5Token) {\n', '        uint32 stopAt = uint32(realWorldPlayers.length - 1);\n', '        for (uint32 j = i; j < stopAt; j++){\n', '            realWorldPlayers[j] = realWorldPlayers[j+1];\n', '            md5TokenToRosterIndex[realWorldPlayers[j].md5Token] = j;\n', '        }\n', '        delete realWorldPlayers[realWorldPlayers.length-1];\n', '        realWorldPlayers.length--;\n', '        break;\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Returns TRUE if there is an open commissioner auction for a realWorldPlayer\n', '  /// @param _md5Token - md5Token of the player of interest\n', '  function hasOpenCommissionerAuction(uint128 _md5Token) public view onlyCommissioner returns (bool) {\n', '    uint128 _rosterIndex = this.getRealWorldPlayerRosterIndex(_md5Token);\n', '    if (_rosterIndex == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n', '      revert();\n', '    } else {\n', '      return realWorldPlayers[_rosterIndex].hasActiveCommissionerAuction;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns the rosterId of the player identified with an md5Token\n', '  /// @param _md5Token = md5Token of exisiting\n', '  function getRealWorldPlayerRosterIndex(uint128 _md5Token) public view returns (uint128) {\n', '\n', '    uint32 _rosterIndex = md5TokenToRosterIndex[_md5Token];\n', '    if (_rosterIndex == 0) {\n', '      // Deal with the fact that mappings return 0 for non-existent members and 0 is\n', '      // a valid rosterIndex for the 0th (first) entry in the realWorldPlayers array.\n', '      if ((realWorldPlayers.length > 0) && (realWorldPlayers[0].md5Token == _md5Token)) {\n', '        return uint128(0);\n', '      }\n', '    } else {\n', '      return uint128(_rosterIndex);\n', '    }\n', '\n', '    // Intentionally returning an invalid rosterIndex (too big) as an indicator that\n', '    // the md5 passed was not found.\n', '    return uint128(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '  }\n', '\n', '  /// @dev Enables (or disables) minting for a particular real world player.\n', '  /// @param _md5Tokens - The md5Token of the player to be updated\n', '  /// @param _mintingEnabled - True to enable, false to disable minting for the player\n', '  function enableRealWorldPlayerMinting(uint128[] _md5Tokens, bool[] _mintingEnabled) public onlyCommissioner {\n', '    if (_md5Tokens.length != _mintingEnabled.length) {\n', '      revert();\n', '    }\n', '    for (uint32 i = 0; i < _md5Tokens.length; i++) {\n', '      uint32 _rosterIndex = md5TokenToRosterIndex[_md5Tokens[i]];\n', '      if ((_rosterIndex > 0) || ((realWorldPlayers.length > 0) && (realWorldPlayers[0].md5Token == _md5Tokens[i]))) {\n', '        // _rosterIndex is valid\n', '        realWorldPlayers[_rosterIndex].mintingEnabled = _mintingEnabled[i];\n', '      } else {\n', '        // Tried to enable/disable minting on non-existent realWorldPlayer\n', '        revert();\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Returns a boolean indicating whether or not a particular real world player is minting\n', '  /// @param _md5Token - The player to look at\n', '  function isRealWorldPlayerMintingEnabled(uint128 _md5Token) public view returns (bool) {\n', '    // Have to deal with the fact that the 0th entry is a valid one.\n', '    uint32 _rosterIndex = md5TokenToRosterIndex[_md5Token];\n', '    if ((_rosterIndex > 0) || ((realWorldPlayers.length > 0) && (realWorldPlayers[0].md5Token == _md5Token))) {\n', '      // _rosterIndex is valid\n', '      return realWorldPlayers[_rosterIndex].mintingEnabled;\n', '    } else {\n', '      // Tried to enable/disable minting on non-existent realWorldPlayer\n', '      revert();\n', '    }\n', '  }\n', '\n', '  /// @dev Updates a particular realRealWorldPlayer. Note that the md5Token is immutable. Can only be\n', '  ///   called by the core contract.\n', '  /// @param _rosterIndex - Index into realWorldPlayers of the entry to change.\n', '  /// @param _prevCommissionerSalePrice - Average of the 2 most recent sale prices in commissioner auctions\n', '  /// @param _lastMintedTime - Time this real world player was last minted\n', '  /// @param _mintedCount - The number of playerTokens that have been minted for this player\n', '  /// @param _hasActiveCommissionerAuction - Whether or not there is an active commissioner auction for this player\n', '  /// @param _mintingEnabled - Denotes whether or not we should mint this real world player\n', '  function updateRealWorldPlayer(uint32 _rosterIndex, uint128 _prevCommissionerSalePrice, uint64 _lastMintedTime, uint32 _mintedCount, bool _hasActiveCommissionerAuction, bool _mintingEnabled) public onlyCoreContract {\n', '    require(_rosterIndex < realWorldPlayers.length);\n', '    RealWorldPlayer storage _realWorldPlayer = realWorldPlayers[_rosterIndex];\n', '    _realWorldPlayer.prevCommissionerSalePrice = _prevCommissionerSalePrice;\n', '    _realWorldPlayer.lastMintedTime = _lastMintedTime;\n', '    _realWorldPlayer.mintedCount = _mintedCount;\n', '    _realWorldPlayer.hasActiveCommissionerAuction = _hasActiveCommissionerAuction;\n', '    _realWorldPlayer.mintingEnabled = _mintingEnabled;\n', '  }\n', '\n', '  /// @dev Marks a real world player record as having an active commissioner auction.\n', '  ///   Will throw if there is hasActiveCommissionerAuction was already true upon entry.\n', '  /// @param _rosterIndex - Index to the real world player record.\n', '  function setHasCommissionerAuction(uint32 _rosterIndex) public onlyCoreContract {\n', '    require(_rosterIndex < realWorldPlayers.length);\n', '    RealWorldPlayer storage _realWorldPlayer = realWorldPlayers[_rosterIndex];\n', '    require(!_realWorldPlayer.hasActiveCommissionerAuction);\n', '    _realWorldPlayer.hasActiveCommissionerAuction = true;\n', '  }\n', '\n', '  /// @param _rosterIndex - Index into our roster that we want to record the fact that there is\n', '  ///   no longer an active commissioner auction.\n', '  /// @param _price - The price we want to record\n', '  function commissionerAuctionComplete(uint32 _rosterIndex, uint128 _price) public onlyCoreContract {\n', '    require(_rosterIndex < realWorldPlayers.length);\n', '    RealWorldPlayer storage _realWorldPlayer = realWorldPlayers[_rosterIndex];\n', '    require(_realWorldPlayer.hasActiveCommissionerAuction);\n', '    if (_realWorldPlayer.prevCommissionerSalePrice == 0) {\n', '      _realWorldPlayer.prevCommissionerSalePrice = _price;\n', '    } else {\n', '      _realWorldPlayer.prevCommissionerSalePrice = (_realWorldPlayer.prevCommissionerSalePrice + _price)/2;\n', '    }\n', '    _realWorldPlayer.hasActiveCommissionerAuction = false;\n', '\n', '    // Finally, re-mint another player token for this realWorldPlayer and put him up for auction\n', '    // at the default pricing and duration (auto mint)\n', '    if (_realWorldPlayer.mintingEnabled) {\n', '      uint128[] memory _md5Tokens = new uint128[](1);\n', '      _md5Tokens[0] = _realWorldPlayer.md5Token;\n', '      minterContract.mintPlayers(_md5Tokens, 0, 0, 0);\n', '    }\n', '  }\n', '\n', '  /// @param _rosterIndex - Index into our roster that we want to record the fact that there is\n', '  ///   no longer an active commissioner auction.\n', '  function commissionerAuctionCancelled(uint32 _rosterIndex) public view onlyCoreContract {\n', '    require(_rosterIndex < realWorldPlayers.length);\n', '    RealWorldPlayer storage _realWorldPlayer = realWorldPlayers[_rosterIndex];\n', '    require(_realWorldPlayer.hasActiveCommissionerAuction);\n', '\n', '    // We do not clear the hasActiveCommissionerAuction bit on a cancel. This will\n', '    // continue to block the minting of new commissioner tokens (limiting supply).\n', '    // The only way this RWP can be back on a commissioner auction is by the commish\n', '    // putting the token corresponding to the canceled auction back on auction.\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.25;\n', '\n', '/// @title A facet of CSportsCore that holds all important constants and modifiers\n', '/// @author CryptoSports, Inc. (https://cryptosports.team))\n', '/// @dev See the CSportsCore contract documentation to understand how the various CSports contract facets are arranged.\n', 'contract CSportsConstants {\n', '\n', '    /// @dev The maximum # of marketing tokens that can ever be created\n', '    /// by the commissioner.\n', '    uint16 public MAX_MARKETING_TOKENS = 2500;\n', '\n', '    /// @dev The starting price for commissioner auctions (if the average\n', '    ///   of the last 2 is less than this, we will use this value)\n', '    ///   A finney is 1/1000 of an ether.\n', '    uint256 public COMMISSIONER_AUCTION_FLOOR_PRICE = 5 finney; // 5 finney for production, 15 for script testing and 1 finney for Rinkeby\n', '\n', '    /// @dev The duration of commissioner auctions\n', '    uint256 public COMMISSIONER_AUCTION_DURATION = 14 days; // 30 days for testing;\n', '\n', '    /// @dev Number of seconds in a week\n', '    uint32 constant WEEK_SECS = 1 weeks;\n', '\n', '}\n', '\n', "/// @title A facet of CSportsCore that manages an individual's authorized role against access privileges.\n", '/// @author CryptoSports, Inc. (https://cryptosports.team))\n', '/// @dev See the CSportsCore contract documentation to understand how the various CSports contract facets are arranged.\n', 'contract CSportsAuth is CSportsConstants {\n', '    // This facet controls access control for CryptoSports. There are four roles managed here:\n', '    //\n', '    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n', '    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n', '    //         set to the address that created the smart contract in the CSportsCore constructor.\n', '    //\n', '    //     - The CFO: The CFO can withdraw funds from CSportsCore and its auction contracts.\n', '    //\n', '    //     - The COO: The COO can perform administrative functions.\n', '    //\n', '    //     - The Commisioner can perform "oracle" functions like adding new real world players,\n', '    //       setting players active/inactive, and scoring contests.\n', '    //\n', '\n', '    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n', '    event ContractUpgrade(address newContract);\n', '\n', '    /// The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '    address public cooAddress;\n', '    address public commissionerAddress;\n', '\n', '    /// @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused = false;\n', '\n', '    /// @dev Flag that identifies whether or not we are in development and should allow development\n', '    /// only functions to be called.\n', '    bool public isDevelopment = true;\n', '\n', '    /// @dev Access modifier to allow access to development mode functions\n', '    modifier onlyUnderDevelopment() {\n', '      require(isDevelopment == true);\n', '      _;\n', '    }\n', '\n', '    /// @dev Access modifier for CEO-only functionality\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for CFO-only functionality\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for COO-only functionality\n', '    modifier onlyCOO() {\n', '        require(msg.sender == cooAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for Commissioner-only functionality\n', '    modifier onlyCommissioner() {\n', '        require(msg.sender == commissionerAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Requires any one of the C level addresses\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == cooAddress ||\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cfoAddress ||\n', '            msg.sender == commissionerAddress\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev prevents contracts from hitting the method\n', '    modifier notContract() {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '\n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0);\n', '        _;\n', '    }\n', '\n', '    /// @dev One way switch to set the contract into prodution mode. This is one\n', '    /// way in that the contract can never be set back into development mode. Calling\n', '    /// this function will block all future calls to functions that are meant for\n', '    /// access only while we are under development. It will also enable more strict\n', '    /// additional checking on various parameters and settings.\n', '    function setProduction() public onlyCEO onlyUnderDevelopment {\n', '      isDevelopment = false;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '    /// @param _newCEO The address of the new CEO\n', '    function setCEO(address _newCEO) public onlyCEO {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n', '    /// @param _newCFO The address of the new CFO\n', '    function setCFO(address _newCFO) public onlyCEO {\n', '        require(_newCFO != address(0));\n', '\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n', '    /// @param _newCOO The address of the new COO\n', '    function setCOO(address _newCOO) public onlyCEO {\n', '        require(_newCOO != address(0));\n', '\n', '        cooAddress = _newCOO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Commissioner. Only available to the current CEO.\n', '    /// @param _newCommissioner The address of the new COO\n', '    function setCommissioner(address _newCommissioner) public onlyCEO {\n', '        require(_newCommissioner != address(0));\n', '\n', '        commissionerAddress = _newCommissioner;\n', '    }\n', '\n', '    /// @dev Assigns all C-Level addresses\n', '    /// @param _ceo CEO address\n', '    /// @param _cfo CFO address\n', '    /// @param _coo COO address\n', '    /// @param _commish Commissioner address\n', '    function setCLevelAddresses(address _ceo, address _cfo, address _coo, address _commish) public onlyCEO {\n', '        require(_ceo != address(0));\n', '        require(_cfo != address(0));\n', '        require(_coo != address(0));\n', '        require(_commish != address(0));\n', '        ceoAddress = _ceo;\n', '        cfoAddress = _cfo;\n', '        cooAddress = _coo;\n', '        commissionerAddress = _commish;\n', '    }\n', '\n', '    /// @dev Transfers the balance of this contract to the CFO\n', '    function withdrawBalance() external onlyCFO {\n', '        cfoAddress.transfer(address(this).balance);\n', '    }\n', '\n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '    ///  a bug or exploit is detected and we need to limit damage.\n', '    function pause() public onlyCLevel whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '    ///  one reason we may pause the contract is when CFO or COO accounts are\n', '    ///  compromised.\n', '    function unpause() public onlyCEO whenPaused {\n', '        paused = false;\n', '    }\n', '}\n', '\n', '/// @dev Interface required by league roster contract to access\n', '/// the mintPlayers(...) function\n', 'interface CSportsMinter {\n', '\n', '    /// @dev Called by league roster contract as a sanity check\n', '    function isMinter() external pure returns (bool);\n', '\n', '    /// @dev The method called by the league roster contract to mint a new player and create its commissioner auction\n', '    function mintPlayers(uint128[] _md5Tokens, uint256 _startPrice, uint256 _endPrice, uint256 _duration) external;\n', '}\n', '/// @dev This is the data structure that holds a roster player in the CSportsLeagueRoster\n', '/// contract. Also referenced by CSportsCore.\n', '/// @author CryptoSports, Inc. (http://cryptosports.team)\n', 'contract CSportsRosterPlayer {\n', '\n', '    struct RealWorldPlayer {\n', '\n', "        // The player's certified identification. This is the md5 hash of\n", "        // {player's last name}-{player's first name}-{player's birthday in YYYY-MM-DD format}-{serial number}\n", '        // where the serial number is usually 0, but gives us an ability to deal with making\n', '        // sure all MD5s are unique.\n', '        uint128 md5Token;\n', '\n', '        // Stores the average sale price of the most recent 2 commissioner sales\n', '        uint128 prevCommissionerSalePrice;\n', '\n', '        // The last time this real world player was minted.\n', '        uint64 lastMintedTime;\n', '\n', '        // The number of PlayerTokens minted for this real world player\n', '        uint32 mintedCount;\n', '\n', '        // When true, there is an active auction for this player owned by\n', '        // the commissioner (indicating a gen0 minting auction is in progress)\n', '        bool hasActiveCommissionerAuction;\n', '\n', '        // Indicates this real world player can be actively minted\n', '        bool mintingEnabled;\n', '\n', '        // Any metadata we want to attach to this player (in JSON format)\n', '        string metadata;\n', '\n', '    }\n', '\n', '}\n', '\n', '/// @title Contract that holds all of the real world player data. This data is\n', '/// added by the commissioner and represents an on-blockchain database of\n', '/// players in the league.\n', '/// @author CryptoSports, Inc. (http://cryptosports.team)\n', 'contract CSportsLeagueRoster is CSportsAuth, CSportsRosterPlayer  {\n', '\n', '  /*** STORAGE ***/\n', '\n', '  /// @dev Holds the coreContract which supports the CSportsMinter interface\n', '  CSportsMinter public minterContract;\n', '\n', '  /// @dev Holds one entry for each real-world player available in the\n', '  /// current league (e.g. NFL). There can be a maximum of 4,294,967,295\n', '  /// entries in this array (plenty) because it is indexed by a uint32.\n', '  /// This structure is constantly updated by a commissioner. If the\n', '  /// realWorldPlayer[<whatever].mintingEnabled property is true, then playerTokens\n', '  /// tied to this realWorldPlayer entry will automatically be minted.\n', '  RealWorldPlayer[] public realWorldPlayers;\n', '\n', '  mapping (uint128 => uint32) public md5TokenToRosterIndex;\n', '\n', '  /*** MODIFIERS ***/\n', '\n', '  /// @dev Access modifier for core contract only functions\n', '  modifier onlyCoreContract() {\n', '      require(msg.sender == address(minterContract));\n', '      _;\n', '  }\n', '\n', '  /*** FUNCTIONS ***/\n', '\n', '  /// @dev Contract constructor. All "C" level authorized addresses\n', '  /// are set to the contract creator.\n', '  constructor() public {\n', '    ceoAddress = msg.sender;\n', '    cfoAddress = msg.sender;\n', '    cooAddress = msg.sender;\n', '    commissionerAddress = msg.sender;\n', '  }\n', '\n', '  /// @dev Sanity check that identifies this contract is a league roster contract\n', '  function isLeagueRosterContract() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /// @dev Returns the full player structure from the league roster contract given its index.\n', '  /// @param idx Index of player we are interested in\n', '  function realWorldPlayerFromIndex(uint128 idx) public view returns (uint128 md5Token, uint128 prevCommissionerSalePrice, uint64 lastMintedTime, uint32 mintedCount, bool hasActiveCommissionerAuction, bool mintingEnabled) {\n', '    RealWorldPlayer memory _rwp;\n', '    _rwp = realWorldPlayers[idx];\n', '    md5Token = _rwp.md5Token;\n', '    prevCommissionerSalePrice = _rwp.prevCommissionerSalePrice;\n', '    lastMintedTime = _rwp.lastMintedTime;\n', '    mintedCount = _rwp.mintedCount;\n', '    hasActiveCommissionerAuction = _rwp.hasActiveCommissionerAuction;\n', '    mintingEnabled = _rwp.mintingEnabled;\n', '  }\n', '\n', '  /// @dev Sets the coreContractAddress that will restrict access\n', '  /// to certin functions\n', '  function setCoreContractAddress(address _address) public onlyCEO {\n', '\n', '    CSportsMinter candidateContract = CSportsMinter(_address);\n', '    // NOTE: verify that a contract is what we expect (not foolproof, just\n', '    // a sanity check)\n', '    require(candidateContract.isMinter());\n', '    // Set the new contract address\n', '    minterContract = candidateContract;\n', '\n', '  }\n', '\n', '  /// @return uint32 count -  # of entries in the realWorldPlayer array\n', '  function playerCount() public view returns (uint32 count) {\n', '    return uint32(realWorldPlayers.length);\n', '  }\n', '\n', '  /// @dev Creates and adds realWorldPlayer entries, and mints a new ERC721 token for each, and puts each on\n', '  /// auction as a commissioner auction.\n', '  /// @param _md5Tokens The MD5s to be associated with the roster entries we are adding\n', '  /// @param _mintingEnabled An array (of equal length to _md5Tokens) indicating the minting status of that player\n', '  ///        (if an entry is not true, that player will not be minted and no auction created)\n', '  /// @param _startPrice The starting price for the auction we will create for the newly minted token\n', '  /// @param _endPrice The ending price for the auction we will create for the newly minted token\n', '  /// @param _duration The duration for the auction we will create for the newly minted token\n', '  function addAndMintPlayers(uint128[] _md5Tokens, bool[] _mintingEnabled, uint256 _startPrice, uint256 _endPrice, uint256 _duration) public onlyCommissioner {\n', '\n', '    // Add the real world players to the roster\n', '    addRealWorldPlayers(_md5Tokens, _mintingEnabled);\n', '\n', '    // Mint the newly added players and create commissioner auctions\n', '    minterContract.mintPlayers(_md5Tokens, _startPrice, _endPrice, _duration);\n', '\n', '  }\n', '\n', '  /// @dev Creates and adds a RealWorldPlayer entry.\n', '  /// @param _md5Tokens - An array of MD5 tokens for players to be added to our realWorldPlayers array.\n', '  /// @param _mintingEnabled - An array (of equal length to _md5Tokens) indicating the minting status of that player\n', '  function addRealWorldPlayers(uint128[] _md5Tokens, bool[] _mintingEnabled) public onlyCommissioner {\n', '    if (_md5Tokens.length != _mintingEnabled.length) {\n', '      revert();\n', '    }\n', '    for (uint32 i = 0; i < _md5Tokens.length; i++) {\n', "      // We won't try to put an md5Token duplicate by using the md5TokenToRosterIndex\n", '      // mapping (notice we need to deal with the fact that a non-existent mapping returns 0)\n', '      if ( (realWorldPlayers.length == 0) ||\n', '           ((md5TokenToRosterIndex[_md5Tokens[i]] == 0) && (realWorldPlayers[0].md5Token != _md5Tokens[i])) ) {\n', '        RealWorldPlayer memory _realWorldPlayer = RealWorldPlayer({\n', '                                                      md5Token: _md5Tokens[i],\n', '                                                      prevCommissionerSalePrice: 0,\n', '                                                      lastMintedTime: 0,\n', '                                                      mintedCount: 0,\n', '                                                      hasActiveCommissionerAuction: false,\n', '                                                      mintingEnabled: _mintingEnabled[i],\n', '                                                      metadata: ""\n', '                                                  });\n', '        uint256 _rosterIndex = realWorldPlayers.push(_realWorldPlayer) - 1;\n', '\n', "        // It's probably never going to happen, but just in case, we need\n", '        // to make sure our realWorldPlayers can be indexed by a uint32\n', '        require(_rosterIndex < 4294967295);\n', '\n', '        // Map the md5Token to its rosterIndex\n', '        md5TokenToRosterIndex[_md5Tokens[i]] = uint32(_rosterIndex);\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Sets the metadata for a real world player token that has already been added.\n', '  /// @param _md5Token The MD5 key of the token to update\n', '  /// @param _metadata The JSON string representing the metadata for the token\n', '  function setMetadata(uint128 _md5Token, string _metadata) public onlyCommissioner {\n', '      uint32 _rosterIndex = md5TokenToRosterIndex[_md5Token];\n', '      if ((_rosterIndex > 0) || ((realWorldPlayers.length > 0) && (realWorldPlayers[0].md5Token == _md5Token))) {\n', '        // Valid MD5 token\n', '        realWorldPlayers[_rosterIndex].metadata = _metadata;\n', '      }\n', '  }\n', '\n', '  /// @dev Returns the metadata for a specific token\n', '  /// @param _md5Token MD5 key for token we want the metadata for\n', '  function getMetadata(uint128 _md5Token) public view returns (string metadata) {\n', '    uint32 _rosterIndex = md5TokenToRosterIndex[_md5Token];\n', '    if ((_rosterIndex > 0) || ((realWorldPlayers.length > 0) && (realWorldPlayers[0].md5Token == _md5Token))) {\n', '      // Valid MD5 token\n', '      metadata = realWorldPlayers[_rosterIndex].metadata;\n', '    } else {\n', '      metadata = "";\n', '    }\n', '  }\n', '\n', '  /// @dev Function to remove a particular md5Token from our array of players. This function\n', '  ///   will be blocked after we are completed with development. Deleting entries would\n', "  ///   screw up the ids of realWorldPlayers held by the core contract's playerTokens structure.\n", '  /// @param _md5Token - The MD5 token of the entry to remove.\n', '  function removeRealWorldPlayer(uint128 _md5Token) public onlyCommissioner onlyUnderDevelopment  {\n', '    for (uint32 i = 0; i < uint32(realWorldPlayers.length); i++) {\n', '      RealWorldPlayer memory player = realWorldPlayers[i];\n', '      if (player.md5Token == _md5Token) {\n', '        uint32 stopAt = uint32(realWorldPlayers.length - 1);\n', '        for (uint32 j = i; j < stopAt; j++){\n', '            realWorldPlayers[j] = realWorldPlayers[j+1];\n', '            md5TokenToRosterIndex[realWorldPlayers[j].md5Token] = j;\n', '        }\n', '        delete realWorldPlayers[realWorldPlayers.length-1];\n', '        realWorldPlayers.length--;\n', '        break;\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Returns TRUE if there is an open commissioner auction for a realWorldPlayer\n', '  /// @param _md5Token - md5Token of the player of interest\n', '  function hasOpenCommissionerAuction(uint128 _md5Token) public view onlyCommissioner returns (bool) {\n', '    uint128 _rosterIndex = this.getRealWorldPlayerRosterIndex(_md5Token);\n', '    if (_rosterIndex == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n', '      revert();\n', '    } else {\n', '      return realWorldPlayers[_rosterIndex].hasActiveCommissionerAuction;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns the rosterId of the player identified with an md5Token\n', '  /// @param _md5Token = md5Token of exisiting\n', '  function getRealWorldPlayerRosterIndex(uint128 _md5Token) public view returns (uint128) {\n', '\n', '    uint32 _rosterIndex = md5TokenToRosterIndex[_md5Token];\n', '    if (_rosterIndex == 0) {\n', '      // Deal with the fact that mappings return 0 for non-existent members and 0 is\n', '      // a valid rosterIndex for the 0th (first) entry in the realWorldPlayers array.\n', '      if ((realWorldPlayers.length > 0) && (realWorldPlayers[0].md5Token == _md5Token)) {\n', '        return uint128(0);\n', '      }\n', '    } else {\n', '      return uint128(_rosterIndex);\n', '    }\n', '\n', '    // Intentionally returning an invalid rosterIndex (too big) as an indicator that\n', '    // the md5 passed was not found.\n', '    return uint128(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '  }\n', '\n', '  /// @dev Enables (or disables) minting for a particular real world player.\n', '  /// @param _md5Tokens - The md5Token of the player to be updated\n', '  /// @param _mintingEnabled - True to enable, false to disable minting for the player\n', '  function enableRealWorldPlayerMinting(uint128[] _md5Tokens, bool[] _mintingEnabled) public onlyCommissioner {\n', '    if (_md5Tokens.length != _mintingEnabled.length) {\n', '      revert();\n', '    }\n', '    for (uint32 i = 0; i < _md5Tokens.length; i++) {\n', '      uint32 _rosterIndex = md5TokenToRosterIndex[_md5Tokens[i]];\n', '      if ((_rosterIndex > 0) || ((realWorldPlayers.length > 0) && (realWorldPlayers[0].md5Token == _md5Tokens[i]))) {\n', '        // _rosterIndex is valid\n', '        realWorldPlayers[_rosterIndex].mintingEnabled = _mintingEnabled[i];\n', '      } else {\n', '        // Tried to enable/disable minting on non-existent realWorldPlayer\n', '        revert();\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Returns a boolean indicating whether or not a particular real world player is minting\n', '  /// @param _md5Token - The player to look at\n', '  function isRealWorldPlayerMintingEnabled(uint128 _md5Token) public view returns (bool) {\n', '    // Have to deal with the fact that the 0th entry is a valid one.\n', '    uint32 _rosterIndex = md5TokenToRosterIndex[_md5Token];\n', '    if ((_rosterIndex > 0) || ((realWorldPlayers.length > 0) && (realWorldPlayers[0].md5Token == _md5Token))) {\n', '      // _rosterIndex is valid\n', '      return realWorldPlayers[_rosterIndex].mintingEnabled;\n', '    } else {\n', '      // Tried to enable/disable minting on non-existent realWorldPlayer\n', '      revert();\n', '    }\n', '  }\n', '\n', '  /// @dev Updates a particular realRealWorldPlayer. Note that the md5Token is immutable. Can only be\n', '  ///   called by the core contract.\n', '  /// @param _rosterIndex - Index into realWorldPlayers of the entry to change.\n', '  /// @param _prevCommissionerSalePrice - Average of the 2 most recent sale prices in commissioner auctions\n', '  /// @param _lastMintedTime - Time this real world player was last minted\n', '  /// @param _mintedCount - The number of playerTokens that have been minted for this player\n', '  /// @param _hasActiveCommissionerAuction - Whether or not there is an active commissioner auction for this player\n', '  /// @param _mintingEnabled - Denotes whether or not we should mint this real world player\n', '  function updateRealWorldPlayer(uint32 _rosterIndex, uint128 _prevCommissionerSalePrice, uint64 _lastMintedTime, uint32 _mintedCount, bool _hasActiveCommissionerAuction, bool _mintingEnabled) public onlyCoreContract {\n', '    require(_rosterIndex < realWorldPlayers.length);\n', '    RealWorldPlayer storage _realWorldPlayer = realWorldPlayers[_rosterIndex];\n', '    _realWorldPlayer.prevCommissionerSalePrice = _prevCommissionerSalePrice;\n', '    _realWorldPlayer.lastMintedTime = _lastMintedTime;\n', '    _realWorldPlayer.mintedCount = _mintedCount;\n', '    _realWorldPlayer.hasActiveCommissionerAuction = _hasActiveCommissionerAuction;\n', '    _realWorldPlayer.mintingEnabled = _mintingEnabled;\n', '  }\n', '\n', '  /// @dev Marks a real world player record as having an active commissioner auction.\n', '  ///   Will throw if there is hasActiveCommissionerAuction was already true upon entry.\n', '  /// @param _rosterIndex - Index to the real world player record.\n', '  function setHasCommissionerAuction(uint32 _rosterIndex) public onlyCoreContract {\n', '    require(_rosterIndex < realWorldPlayers.length);\n', '    RealWorldPlayer storage _realWorldPlayer = realWorldPlayers[_rosterIndex];\n', '    require(!_realWorldPlayer.hasActiveCommissionerAuction);\n', '    _realWorldPlayer.hasActiveCommissionerAuction = true;\n', '  }\n', '\n', '  /// @param _rosterIndex - Index into our roster that we want to record the fact that there is\n', '  ///   no longer an active commissioner auction.\n', '  /// @param _price - The price we want to record\n', '  function commissionerAuctionComplete(uint32 _rosterIndex, uint128 _price) public onlyCoreContract {\n', '    require(_rosterIndex < realWorldPlayers.length);\n', '    RealWorldPlayer storage _realWorldPlayer = realWorldPlayers[_rosterIndex];\n', '    require(_realWorldPlayer.hasActiveCommissionerAuction);\n', '    if (_realWorldPlayer.prevCommissionerSalePrice == 0) {\n', '      _realWorldPlayer.prevCommissionerSalePrice = _price;\n', '    } else {\n', '      _realWorldPlayer.prevCommissionerSalePrice = (_realWorldPlayer.prevCommissionerSalePrice + _price)/2;\n', '    }\n', '    _realWorldPlayer.hasActiveCommissionerAuction = false;\n', '\n', '    // Finally, re-mint another player token for this realWorldPlayer and put him up for auction\n', '    // at the default pricing and duration (auto mint)\n', '    if (_realWorldPlayer.mintingEnabled) {\n', '      uint128[] memory _md5Tokens = new uint128[](1);\n', '      _md5Tokens[0] = _realWorldPlayer.md5Token;\n', '      minterContract.mintPlayers(_md5Tokens, 0, 0, 0);\n', '    }\n', '  }\n', '\n', '  /// @param _rosterIndex - Index into our roster that we want to record the fact that there is\n', '  ///   no longer an active commissioner auction.\n', '  function commissionerAuctionCancelled(uint32 _rosterIndex) public view onlyCoreContract {\n', '    require(_rosterIndex < realWorldPlayers.length);\n', '    RealWorldPlayer storage _realWorldPlayer = realWorldPlayers[_rosterIndex];\n', '    require(_realWorldPlayer.hasActiveCommissionerAuction);\n', '\n', '    // We do not clear the hasActiveCommissionerAuction bit on a cancel. This will\n', '    // continue to block the minting of new commissioner tokens (limiting supply).\n', '    // The only way this RWP can be back on a commissioner auction is by the commish\n', '    // putting the token corresponding to the canceled auction back on auction.\n', '  }\n', '\n', '}']
