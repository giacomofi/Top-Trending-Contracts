['pragma solidity ^0.4.15;\n', 'contract Base {\n', '    modifier only(address allowed) {\n', '        require(msg.sender == allowed);\n', '        _;\n', '    }\n', '    // *************************************************\n', '    // *          reentrancy handling                  *\n', '    // *************************************************\n', '    uint constant internal L00 = 2 ** 0;\n', '    uint constant internal L01 = 2 ** 1;\n', '    uint constant internal L02 = 2 ** 2;\n', '    uint constant internal L03 = 2 ** 3;\n', '    uint constant internal L04 = 2 ** 4;\n', '    uint constant internal L05 = 2 ** 5;\n', '    uint private bitlocks = 0;\n', '    modifier noAnyReentrancy {\n', '        var _locks = bitlocks;\n', '        require(_locks == 0);\n', '        bitlocks = uint(-1);\n', '        _;\n', '        bitlocks = _locks;\n', '    }\n', '}\n', 'contract IToken {\n', '    function mint(address _to, uint _amount);\n', '    function start();\n', '    function getTotalSupply() returns(uint);\n', '    function balanceOf(address _owner) returns(uint);\n', '    function transfer(address _to, uint _amount) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function burn(uint256 _amount, address _address)  returns (bool success);\n', '}\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', 'contract Owned is Base {\n', '    address public owner;\n', '    address newOwner;\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '    function transferOwnership(address _newOwner) only(owner) {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() only(newOwner) {\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '}\n', 'contract Crowdsale is Owned {\n', '    using SafeMath for uint;\n', '    enum State { INIT, PRESALE, PREICO, PREICO_FINISHED, ICO_FIRST, ICO_SECOND, ICO_THIRD, STOPPED, CLOSED, EMERGENCY_STOP}\n', '    uint public constant MAX_SALE_SUPPLY = 24 * (10**25);\n', '    uint public constant DECIMALS = (10**18);\n', '    State public currentState = State.INIT;\n', '    IToken public token;\n', '    uint public totalSaleSupply = 0;\n', '    uint public totalFunds = 0;\n', '    uint public tokenPrice = 1000000000000000000; //wei\n', '    uint public bonus = 50000; //50%\n', '    uint public currentPrice;\n', '    address public beneficiary;\n', '    mapping(address => uint) balances;\n', '\n', '    address public foundersWallet; //replace\n', '    uint public foundersAmount = 160000000 * DECIMALS;\n', '    uint public maxPreICOSupply = 48 * (10**24);\n', '    uint public maxICOFirstSupply = 84 * (10**24);\n', '    uint public maxICOSecondSupply = 48 * (10**24);\n', '    uint public maxICOThirdSupply = 24 * (10**24);\n', '    uint public currentRoundSupply = 0;\n', '    uint private bonusBase = 100000; //100%;\n', '    modifier inState(State _state){\n', '        require(currentState == _state);\n', '        _;\n', '    }\n', '    modifier salesRunning(){\n', '        require(currentState == State.PREICO\n', '        || currentState == State.ICO_FIRST\n', '        || currentState == State.ICO_SECOND\n', '        || currentState == State.ICO_THIRD);\n', '        _;\n', '    }\n', '    modifier minAmount(){\n', '        require(msg.value >= 0.2 ether);\n', '        _;\n', '    }\n', '\n', '    event Transfer(address indexed _to, uint _value);\n', '    function Crowdsale(address _foundersWallet, address _beneficiary){\n', '        beneficiary = _beneficiary;\n', '        foundersWallet = _foundersWallet;\n', '    }\n', '    function initialize(IToken _token)\n', '    public\n', '    only(owner)\n', '    inState(State.INIT)\n', '    {\n', '        require(_token != address(0));\n', '        token = _token;\n', '        currentPrice = tokenPrice;\n', '        _mint(foundersWallet, foundersAmount);\n', '    }\n', '    function setBonus(uint _bonus) public\n', '    only(owner)\n', '    {\n', '        bonus = _bonus;\n', '    }\n', '    function setPrice(uint _tokenPrice)\n', '    public\n', '    only(owner)\n', '    {\n', '        currentPrice = _tokenPrice;\n', '    }\n', '    function setState(State _newState)\n', '    public\n', '    only(owner)\n', '    {\n', '        require(\n', '            currentState == State.INIT && _newState == State.PRESALE\n', '            || currentState == State.PRESALE && _newState == State.PREICO\n', '            || currentState == State.PREICO && _newState == State.PREICO_FINISHED\n', '            || currentState == State.PREICO_FINISHED && _newState == State.ICO_FIRST\n', '            || currentState == State.ICO_FIRST && _newState == State.STOPPED\n', '            || currentState == State.STOPPED && _newState == State.ICO_SECOND\n', '            || currentState == State.ICO_SECOND && _newState == State.STOPPED\n', '            || currentState == State.STOPPED && _newState == State.ICO_THIRD\n', '            || currentState == State.ICO_THIRD && _newState == State.CLOSED\n', '            || _newState == State.EMERGENCY_STOP\n', '        );\n', '        currentState = _newState;\n', '        if(_newState == State.PREICO\n', '        || _newState == State.ICO_FIRST\n', '        || _newState == State.ICO_SECOND\n', '        || _newState == State.ICO_THIRD){\n', '            currentRoundSupply = 0;\n', '        }\n', '        if(_newState == State.CLOSED){\n', '            _finish();\n', '        }\n', '    }\n', '    function setStateWithBonus(State _newState, uint _bonus)\n', '    public\n', '    only(owner)\n', '    {\n', '        require(\n', '            currentState == State.INIT && _newState == State.PRESALE\n', '            || currentState == State.PRESALE && _newState == State.PREICO\n', '            || currentState == State.PREICO && _newState == State.PREICO_FINISHED\n', '            || currentState == State.PREICO_FINISHED && _newState == State.ICO_FIRST\n', '            || currentState == State.ICO_FIRST && _newState == State.STOPPED\n', '            || currentState == State.STOPPED && _newState == State.ICO_SECOND\n', '            || currentState == State.ICO_SECOND && _newState == State.STOPPED\n', '            || currentState == State.STOPPED && _newState == State.ICO_THIRD\n', '            || currentState == State.ICO_THIRD && _newState == State.CLOSED\n', '            || _newState == State.EMERGENCY_STOP\n', '        );\n', '        currentState = _newState;\n', '        bonus = _bonus;\n', '        if(_newState == State.CLOSED){\n', '            _finish();\n', '        }\n', '    }\n', '    function mintPresale(address _to, uint _amount)\n', '    public\n', '    only(owner)\n', '    inState(State.PRESALE)\n', '    {\n', '        require(totalSaleSupply.add(_amount) <= MAX_SALE_SUPPLY);\n', '        totalSaleSupply = totalSaleSupply.add(_amount);\n', '        _mint(_to, _amount);\n', '    }\n', '    function ()\n', '    public\n', '    payable\n', '    salesRunning\n', '    minAmount\n', '    {\n', '        _receiveFunds();\n', '    }\n', '\n', '\n', '\n', '    //==================== Internal Methods =================\n', '    function _receiveFunds()\n', '    internal\n', '    {\n', '        require(msg.value != 0);\n', '        uint transferTokens = msg.value.mul(DECIMALS).div(currentPrice);\n', '        require(totalSaleSupply.add(transferTokens) <= MAX_SALE_SUPPLY);\n', '        uint bonusTokens = transferTokens.mul(bonus).div(bonusBase);\n', '        transferTokens = transferTokens.add(bonusTokens);\n', '        _checkMaxRoundSupply(transferTokens);\n', '        totalSaleSupply = totalSaleSupply.add(transferTokens);\n', '        balances[msg.sender] = balances[msg.sender].add(msg.value);\n', '        totalFunds = totalFunds.add(msg.value);\n', '        _mint(msg.sender, transferTokens);\n', '        beneficiary.transfer(msg.value);\n', '        Transfer(msg.sender, transferTokens);\n', '    }\n', '    function _mint(address _to, uint _amount)\n', '    noAnyReentrancy\n', '    internal\n', '    {\n', '        token.mint(_to, _amount);\n', '    }\n', '    function _checkMaxRoundSupply(uint _amountTokens)\n', '    internal\n', '    {\n', '        if (currentState == State.PREICO) {\n', '            require(currentRoundSupply.add(_amountTokens) <= maxPreICOSupply);\n', '        } else if (currentState == State.ICO_FIRST) {\n', '            require(currentRoundSupply.add(_amountTokens) <= maxICOFirstSupply);\n', '        } else if (currentState == State.ICO_SECOND) {\n', '            require(currentRoundSupply.add(_amountTokens) <= maxICOSecondSupply);\n', '        } else if (currentState == State.ICO_THIRD) {\n', '            require(currentRoundSupply.add(_amountTokens) <= maxICOThirdSupply);\n', '        }\n', '    }\n', '\n', '    function burn(uint256 _amount, address _address) only(owner) {\n', '        require(token.burn(_amount, _address));\n', '\ttotalSaleSupply = totalSaleSupply.sub(_amount);\n', '    }\n', '\n', '    function _finish()\n', '    noAnyReentrancy\n', '    internal\n', '    {\n', '        token.start();\n', '    }\n', '}']
['pragma solidity ^0.4.15;\n', 'contract Base {\n', '    modifier only(address allowed) {\n', '        require(msg.sender == allowed);\n', '        _;\n', '    }\n', '    // *************************************************\n', '    // *          reentrancy handling                  *\n', '    // *************************************************\n', '    uint constant internal L00 = 2 ** 0;\n', '    uint constant internal L01 = 2 ** 1;\n', '    uint constant internal L02 = 2 ** 2;\n', '    uint constant internal L03 = 2 ** 3;\n', '    uint constant internal L04 = 2 ** 4;\n', '    uint constant internal L05 = 2 ** 5;\n', '    uint private bitlocks = 0;\n', '    modifier noAnyReentrancy {\n', '        var _locks = bitlocks;\n', '        require(_locks == 0);\n', '        bitlocks = uint(-1);\n', '        _;\n', '        bitlocks = _locks;\n', '    }\n', '}\n', 'contract IToken {\n', '    function mint(address _to, uint _amount);\n', '    function start();\n', '    function getTotalSupply() returns(uint);\n', '    function balanceOf(address _owner) returns(uint);\n', '    function transfer(address _to, uint _amount) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function burn(uint256 _amount, address _address)  returns (bool success);\n', '}\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', 'contract Owned is Base {\n', '    address public owner;\n', '    address newOwner;\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '    function transferOwnership(address _newOwner) only(owner) {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() only(newOwner) {\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '}\n', 'contract Crowdsale is Owned {\n', '    using SafeMath for uint;\n', '    enum State { INIT, PRESALE, PREICO, PREICO_FINISHED, ICO_FIRST, ICO_SECOND, ICO_THIRD, STOPPED, CLOSED, EMERGENCY_STOP}\n', '    uint public constant MAX_SALE_SUPPLY = 24 * (10**25);\n', '    uint public constant DECIMALS = (10**18);\n', '    State public currentState = State.INIT;\n', '    IToken public token;\n', '    uint public totalSaleSupply = 0;\n', '    uint public totalFunds = 0;\n', '    uint public tokenPrice = 1000000000000000000; //wei\n', '    uint public bonus = 50000; //50%\n', '    uint public currentPrice;\n', '    address public beneficiary;\n', '    mapping(address => uint) balances;\n', '\n', '    address public foundersWallet; //replace\n', '    uint public foundersAmount = 160000000 * DECIMALS;\n', '    uint public maxPreICOSupply = 48 * (10**24);\n', '    uint public maxICOFirstSupply = 84 * (10**24);\n', '    uint public maxICOSecondSupply = 48 * (10**24);\n', '    uint public maxICOThirdSupply = 24 * (10**24);\n', '    uint public currentRoundSupply = 0;\n', '    uint private bonusBase = 100000; //100%;\n', '    modifier inState(State _state){\n', '        require(currentState == _state);\n', '        _;\n', '    }\n', '    modifier salesRunning(){\n', '        require(currentState == State.PREICO\n', '        || currentState == State.ICO_FIRST\n', '        || currentState == State.ICO_SECOND\n', '        || currentState == State.ICO_THIRD);\n', '        _;\n', '    }\n', '    modifier minAmount(){\n', '        require(msg.value >= 0.2 ether);\n', '        _;\n', '    }\n', '\n', '    event Transfer(address indexed _to, uint _value);\n', '    function Crowdsale(address _foundersWallet, address _beneficiary){\n', '        beneficiary = _beneficiary;\n', '        foundersWallet = _foundersWallet;\n', '    }\n', '    function initialize(IToken _token)\n', '    public\n', '    only(owner)\n', '    inState(State.INIT)\n', '    {\n', '        require(_token != address(0));\n', '        token = _token;\n', '        currentPrice = tokenPrice;\n', '        _mint(foundersWallet, foundersAmount);\n', '    }\n', '    function setBonus(uint _bonus) public\n', '    only(owner)\n', '    {\n', '        bonus = _bonus;\n', '    }\n', '    function setPrice(uint _tokenPrice)\n', '    public\n', '    only(owner)\n', '    {\n', '        currentPrice = _tokenPrice;\n', '    }\n', '    function setState(State _newState)\n', '    public\n', '    only(owner)\n', '    {\n', '        require(\n', '            currentState == State.INIT && _newState == State.PRESALE\n', '            || currentState == State.PRESALE && _newState == State.PREICO\n', '            || currentState == State.PREICO && _newState == State.PREICO_FINISHED\n', '            || currentState == State.PREICO_FINISHED && _newState == State.ICO_FIRST\n', '            || currentState == State.ICO_FIRST && _newState == State.STOPPED\n', '            || currentState == State.STOPPED && _newState == State.ICO_SECOND\n', '            || currentState == State.ICO_SECOND && _newState == State.STOPPED\n', '            || currentState == State.STOPPED && _newState == State.ICO_THIRD\n', '            || currentState == State.ICO_THIRD && _newState == State.CLOSED\n', '            || _newState == State.EMERGENCY_STOP\n', '        );\n', '        currentState = _newState;\n', '        if(_newState == State.PREICO\n', '        || _newState == State.ICO_FIRST\n', '        || _newState == State.ICO_SECOND\n', '        || _newState == State.ICO_THIRD){\n', '            currentRoundSupply = 0;\n', '        }\n', '        if(_newState == State.CLOSED){\n', '            _finish();\n', '        }\n', '    }\n', '    function setStateWithBonus(State _newState, uint _bonus)\n', '    public\n', '    only(owner)\n', '    {\n', '        require(\n', '            currentState == State.INIT && _newState == State.PRESALE\n', '            || currentState == State.PRESALE && _newState == State.PREICO\n', '            || currentState == State.PREICO && _newState == State.PREICO_FINISHED\n', '            || currentState == State.PREICO_FINISHED && _newState == State.ICO_FIRST\n', '            || currentState == State.ICO_FIRST && _newState == State.STOPPED\n', '            || currentState == State.STOPPED && _newState == State.ICO_SECOND\n', '            || currentState == State.ICO_SECOND && _newState == State.STOPPED\n', '            || currentState == State.STOPPED && _newState == State.ICO_THIRD\n', '            || currentState == State.ICO_THIRD && _newState == State.CLOSED\n', '            || _newState == State.EMERGENCY_STOP\n', '        );\n', '        currentState = _newState;\n', '        bonus = _bonus;\n', '        if(_newState == State.CLOSED){\n', '            _finish();\n', '        }\n', '    }\n', '    function mintPresale(address _to, uint _amount)\n', '    public\n', '    only(owner)\n', '    inState(State.PRESALE)\n', '    {\n', '        require(totalSaleSupply.add(_amount) <= MAX_SALE_SUPPLY);\n', '        totalSaleSupply = totalSaleSupply.add(_amount);\n', '        _mint(_to, _amount);\n', '    }\n', '    function ()\n', '    public\n', '    payable\n', '    salesRunning\n', '    minAmount\n', '    {\n', '        _receiveFunds();\n', '    }\n', '\n', '\n', '\n', '    //==================== Internal Methods =================\n', '    function _receiveFunds()\n', '    internal\n', '    {\n', '        require(msg.value != 0);\n', '        uint transferTokens = msg.value.mul(DECIMALS).div(currentPrice);\n', '        require(totalSaleSupply.add(transferTokens) <= MAX_SALE_SUPPLY);\n', '        uint bonusTokens = transferTokens.mul(bonus).div(bonusBase);\n', '        transferTokens = transferTokens.add(bonusTokens);\n', '        _checkMaxRoundSupply(transferTokens);\n', '        totalSaleSupply = totalSaleSupply.add(transferTokens);\n', '        balances[msg.sender] = balances[msg.sender].add(msg.value);\n', '        totalFunds = totalFunds.add(msg.value);\n', '        _mint(msg.sender, transferTokens);\n', '        beneficiary.transfer(msg.value);\n', '        Transfer(msg.sender, transferTokens);\n', '    }\n', '    function _mint(address _to, uint _amount)\n', '    noAnyReentrancy\n', '    internal\n', '    {\n', '        token.mint(_to, _amount);\n', '    }\n', '    function _checkMaxRoundSupply(uint _amountTokens)\n', '    internal\n', '    {\n', '        if (currentState == State.PREICO) {\n', '            require(currentRoundSupply.add(_amountTokens) <= maxPreICOSupply);\n', '        } else if (currentState == State.ICO_FIRST) {\n', '            require(currentRoundSupply.add(_amountTokens) <= maxICOFirstSupply);\n', '        } else if (currentState == State.ICO_SECOND) {\n', '            require(currentRoundSupply.add(_amountTokens) <= maxICOSecondSupply);\n', '        } else if (currentState == State.ICO_THIRD) {\n', '            require(currentRoundSupply.add(_amountTokens) <= maxICOThirdSupply);\n', '        }\n', '    }\n', '\n', '    function burn(uint256 _amount, address _address) only(owner) {\n', '        require(token.burn(_amount, _address));\n', '\ttotalSaleSupply = totalSaleSupply.sub(_amount);\n', '    }\n', '\n', '    function _finish()\n', '    noAnyReentrancy\n', '    internal\n', '    {\n', '        token.start();\n', '    }\n', '}']
