['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '}\n', '\n', '/* Controls game play state and access rights for game functions\n', ' * @title Operational Control\n', ' * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\n', ' * Inspired and adapted from contract created by OpenZeppelin\n', ' * Ref: https://github.com/OpenZeppelin/zeppelin-solidity/\n', ' */\n', 'contract OperationalControl {\n', '    // Facilitates access & control for the game.\n', '    // Roles:\n', '    //  -The Game Managers (Primary/Secondary): Has universal control of all game elements (No ability to withdraw)\n', '    //  -The Banker: The Bank can withdraw funds and adjust fees / prices.\n', '\n', '    /// @dev Emited when contract is upgraded\n', '    event ContractUpgrade(address newContract);\n', '\n', '    mapping (address => bool) allowedAddressList;\n', '    \n', '\n', '    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public gameManagerPrimary;\n', '    address public gameManagerSecondary;\n', '    address public bankManager;\n', '\n', '    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused = false;\n', '\n', '    /// @dev Operation modifiers for limiting access\n', '    modifier onlyGameManager() {\n', '        require(msg.sender == gameManagerPrimary || msg.sender == gameManagerSecondary);\n', '        _;\n', '    }\n', '\n', '    /// @dev Operation modifiers for limiting access to only Banker\n', '    modifier onlyBanker() {\n', '        require(msg.sender == bankManager);\n', '        _;\n', '    }\n', '\n', '    /// @dev Operation modifiers for access to any Manager\n', '    modifier anyOperator() {\n', '        require(\n', '            msg.sender == gameManagerPrimary ||\n', '            msg.sender == gameManagerSecondary ||\n', '            msg.sender == bankManager\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the GM.\n', '    function setPrimaryGameManager(address _newGM) external onlyGameManager {\n', '        require(_newGM != address(0));\n', '\n', '        gameManagerPrimary = _newGM;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the GM.\n', '    function setSecondaryGameManager(address _newGM) external onlyGameManager {\n', '        require(_newGM != address(0));\n', '\n', '        gameManagerSecondary = _newGM;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Banker.\n', '    function setBanker(address _newBK) external onlyBanker {\n', '        require(_newBK != address(0));\n', '\n', '        bankManager = _newBK;\n', '    }\n', '\n', '    function updateAllowedAddressesList (address _newAddress, bool _value) external onlyGameManager {\n', '\n', '        require (_newAddress != address(0));\n', '\n', '        allowedAddressList[_newAddress] = _value;\n', '        \n', '    }\n', '\n', '    modifier canTransact() { \n', '        require (msg.sender == gameManagerPrimary\n', '            || msg.sender == gameManagerSecondary\n', '            || allowedAddressList[msg.sender]); \n', '        _; \n', '    }\n', '    \n', '\n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any Operator role to pause the contract.\n', '    /// Used only if a bug or exploit is discovered (Here to limit losses / damage)\n', '    function pause() external onlyGameManager whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the Game Master\n', '    /// @notice This is public rather than external so it can be called by derived contracts. \n', '    function unpause() public onlyGameManager whenPaused {\n', '        // can&#39;t unpause if contract was upgraded\n', '        paused = false;\n', '    }\n', '}\n', '\n', '/* @title Interface for MLBNFT Contract\n', ' * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\n', ' */\n', 'contract MLBNFT {\n', '    function exists(uint256 _tokenId) public view returns (bool _exists);\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function setApprovalForAll(address _to, bool _approved) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function createPromoCollectible(uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) external returns (uint256);\n', '    function createSeedCollectible(uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) public returns (uint256);\n', '    function checkIsAttached(uint256 _tokenId) public view returns (uint256);\n', '    function getTeamId(uint256 _tokenId) external view returns (uint256);\n', '    function getPlayerId(uint256 _tokenId) external view returns (uint256 playerId);\n', '    function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '}\n', '\n', '/* @title Interface for ETH Escrow Contract\n', ' * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\n', ' */\n', 'contract LSEscrow {\n', '    function escrowTransfer(address seller, address buyer, uint256 currentPrice, uint256 marketsCut) public returns(bool);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' *  from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver {\n', '    /**\n', '    * @dev Magic value to be returned upon successful reception of an NFT\n', '    *  Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`,\n', '    *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '    */\n', '    bytes4 public constant ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    /**\n', '    * @notice Handle the receipt of an NFT\n', '    * @dev The ERC721 smart contract calls this function on the recipient\n', '    *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '    *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    *  than the magic value MUST result in the transaction being reverted.\n', '    *  Note: the contract address is always the message sender.\n', '    * @param _from The sending address\n', '    * @param _tokenId The NFT identifier which is being transfered\n', '    * @param _data Additional data with no specified format\n', '    * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '    */\n', '    function onERC721Received(\n', '        address _operator,\n', '        address _from,\n', '        uint256 _tokenId,\n', '        bytes _data\n', '    )\n', '        public\n', '        returns(bytes4);\n', '}\n', '\n', 'contract ERC721Holder is ERC721Receiver {\n', '    function onERC721Received(address,address, uint256, bytes) public returns(bytes4) {\n', '        return ERC721_RECEIVED;\n', '    }\n', '}\n', '\n', '/* Contains models, variables, and internal methods for the ERC-721 sales.\n', ' * @title Sale Base\n', ' * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\n', ' */\n', 'contract SaleBase is OperationalControl, ERC721Holder {\n', '    using SafeMath for uint256;\n', '    \n', '    /// EVENTS \n', '\n', '    event SaleCreated(uint256 tokenID, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt);\n', '    event TeamSaleCreated(uint256[9] tokenIDs, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt);\n', '    event SaleWinner(uint256 tokenID, uint256 totalPrice, address winner);\n', '    event TeamSaleWinner(uint256[9] tokenIDs, uint256 totalPrice, address winner);\n', '    event SaleCancelled(uint256 tokenID, address sellerAddress);\n', '    event EtherWithdrawed(uint256 value);\n', '\n', '    /// STORAGE\n', '\n', '    /**\n', '     * @dev        Represents an Sale on MLB CryptoBaseball (ERC721)\n', '     */\n', '    struct Sale {\n', '        // Current owner of NFT (ERC721)\n', '        address seller;\n', '        // Price (in wei) at beginning of sale\n', '        uint256 startingPrice;\n', '        // Price (in wei) at end of sale\n', '        uint256 endingPrice;\n', '        // Duration (in seconds) of sale\n', '        uint256 duration;\n', '        // Time when sale started\n', '        // NOTE: 0 if this sale has been concluded\n', '        uint256 startedAt;\n', '        // ERC721 AssetID\n', '        uint256[9] tokenIds;\n', '    }\n', '\n', '    /**\n', '     * @dev        Reference to contract tracking ownership & asset details\n', '     */\n', '    MLBNFT public nonFungibleContract;\n', '\n', '    /**\n', '     * @dev        Reference to contract tracking ownership & asset details\n', '     */\n', '    LSEscrow public LSEscrowContract;\n', '\n', '    /**\n', '     * @dev   Defining a GLOBAL delay time for the auctions to start accepting bidExcess\n', '     * @notice This variable is made to delay the bid process.\n', '     */\n', '    uint256 public BID_DELAY_TIME = 0;\n', '\n', '    // Cut owner takes on each sale, measured in basis points (1/100 of a percent).\n', '    // Values 0-10,000 map to 0%-100%\n', '    uint256 public ownerCut = 500; //5%\n', '\n', '    // Map from token to their corresponding sale.\n', '    mapping (uint256 => Sale) tokenIdToSale;\n', '\n', '    /**\n', '     * @dev        Returns true if the claimant owns the token.\n', '     * @param      _claimant  The claimant\n', '     * @param      _tokenId   The token identifier\n', '     */\n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n', '    }\n', '\n', '    /**\n', '     * @dev        Internal function to ESCROW\n', '     * @notice     Escrows the ERC721 Token, assigning ownership to this contract. Throws if the escrow fails.\n', '     * @param      _owner    The owner\n', '     * @param      _tokenId  The token identifier\n', '     */\n', '    function _escrow(address _owner, uint256 _tokenId) internal {\n', '        nonFungibleContract.safeTransferFrom(_owner, this, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev        Internal Transfer function\n', '     * @notice     Transfers an ERC721 Token owned by this contract to another address. Returns true if the transfer succeeds.\n', '     * @param      _owner     The owner\n', '     * @param      _receiver  The receiver\n', '     * @param      _tokenId   The token identifier\n', '     */\n', '    function _transfer(address _owner, address _receiver, uint256 _tokenId) internal {\n', '        nonFungibleContract.transferFrom(_owner, _receiver, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev        Internal Function to add Sale, which duration check (atleast 1 min duration required)\n', '     * @notice     Adds an sale to the list of open sales. Also fires the SaleCreated event.\n', '     * @param      _tokenId  The token identifier\n', '     * @param      _sale     The sale\n', '     */\n', '    function _addSale(uint256 _tokenId, Sale _sale) internal {\n', '        // Require that all sales have a duration of\n', '        // at least one minute.\n', '        require(_sale.duration >= 1 minutes);\n', '        \n', '        tokenIdToSale[_tokenId] = _sale;\n', '\n', '        emit SaleCreated(\n', '            uint256(_tokenId),\n', '            uint256(_sale.startingPrice),\n', '            uint256(_sale.endingPrice),\n', '            uint256(_sale.duration),\n', '            uint256(_sale.startedAt)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Internal Function to add Team Sale, which duration check (atleast 1 min duration required)\n', '     * @notice     Adds an sale to the list of open sales. Also fires the SaleCreated event.\n', '     * @param      _tokenIds  The token identifiers\n', '     * @param      _sale      The sale\n', '     */\n', '    function _addTeamSale(uint256[9] _tokenIds, Sale _sale) internal {\n', '        // Require that all sales have a duration of\n', '        // at least one minute.\n', '        require(_sale.duration >= 1 minutes);\n', '        \n', '        for(uint ii = 0; ii < 9; ii++) {\n', '            require(_tokenIds[ii] != 0);\n', '            require(nonFungibleContract.exists(_tokenIds[ii]));\n', '\n', '            tokenIdToSale[_tokenIds[ii]] = _sale;\n', '        }\n', '\n', '        emit TeamSaleCreated(\n', '            _tokenIds,\n', '            uint256(_sale.startingPrice),\n', '            uint256(_sale.endingPrice),\n', '            uint256(_sale.duration),\n', '            uint256(_sale.startedAt)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Facilites Sale cancellation. Also removed the Sale from the array\n', '     * @notice     Cancels an sale (given the collectibleID is not 0). SaleCancelled Event\n', '     * @param      _tokenId  The token identifier\n', '     * @param      _seller   The seller\n', '     */\n', '    function _cancelSale(uint256 _tokenId, address _seller) internal {\n', '        Sale memory saleItem = tokenIdToSale[_tokenId];\n', '\n', '        //Check for team sale\n', '        if(saleItem.tokenIds[1] != 0) {\n', '            for(uint ii = 0; ii < 9; ii++) {\n', '                _removeSale(saleItem.tokenIds[ii]);\n', '                _transfer(address(this), _seller, saleItem.tokenIds[ii]);\n', '            }\n', '            emit SaleCancelled(_tokenId, _seller);\n', '        } else {\n', '            _removeSale(_tokenId);\n', '            _transfer(address(this), _seller, _tokenId);\n', '            emit SaleCancelled(_tokenId, _seller);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev        Computes the price and transfers winnings. Does NOT transfer ownership of token.\n', '     * @notice     Internal function, helps in making the bid and transferring asset if successful\n', '     * @param      _tokenId    The token identifier\n', '     * @param      _bidAmount  The bid amount\n', '     */\n', '    function _bid(uint256 _tokenId, uint256 _bidAmount)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        // Get a reference to the sale struct\n', '        Sale storage _sale = tokenIdToSale[_tokenId];\n', '        uint256[9] memory tokenIdsStore = tokenIdToSale[_tokenId].tokenIds;\n', '        \n', '        // Explicitly check that this sale is currently live.\n', '        require(_isOnSale(_sale));\n', '\n', '        // Check that the bid is greater than or equal to the current price\n', '        uint256 price = _currentPrice(_sale);\n', '        require(_bidAmount >= price);\n', '\n', '        // Grab a reference to the seller before the sale struct\n', '        // gets deleted.\n', '        address seller = _sale.seller;\n', '\n', '        // The bid is good! Remove the sale before sending the fees\n', '        // to the sender so we can&#39;t have a reentrancy attack.\n', '        if(tokenIdsStore[1] > 0) {\n', '            for(uint ii = 0; ii < 9; ii++) {\n', '                _removeSale(tokenIdsStore[ii]);\n', '            }\n', '        } else {\n', '            _removeSale(_tokenId);\n', '        }\n', '\n', '        // Transfer proceeds to seller (if there are any!)\n', '        if (price > 0) {\n', '            // Calculate the marketplace&#39;s cut.\n', '            // (NOTE: _computeCut() is guaranteed to return a\n', '            // value <= price)\n', '            uint256 marketsCut = _computeCut(price);\n', '            uint256 sellerProceeds = price.sub(marketsCut);\n', '\n', '            seller.transfer(sellerProceeds);\n', '        }\n', '\n', '        // Calculate any excess funds included with the bid. If the excess\n', '        // is anything worth worrying about, transfer it back to bidder.\n', '        uint256 bidExcess = _bidAmount.sub(price);\n', '\n', '        // Return the funds. Similar to the previous transfer.\n', '        msg.sender.transfer(bidExcess);\n', '\n', '        // Tell the world!\n', '        // uint256 assetID, uint256 totalPrice, address winner, uint16 generation\n', '        if(tokenIdsStore[1] > 0) {\n', '            emit TeamSaleWinner(tokenIdsStore, price, msg.sender);\n', '        } else {\n', '            emit SaleWinner(_tokenId, price, msg.sender);\n', '        }\n', '        \n', '        return price;\n', '    }\n', '\n', '    /**\n', '     * @dev        Removes an sale from the list of open sales.\n', '     * @notice     Internal Function to remove sales\n', '     * @param      _tokenId  The token identifier\n', '     */\n', '    function _removeSale(uint256 _tokenId) internal {\n', '        delete tokenIdToSale[_tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev        Returns true if the FT (ERC721) is on sale.\n', '     * @notice     Internal function to check if an\n', '     * @param      _sale  The sale\n', '     */\n', '    function _isOnSale(Sale memory _sale) internal pure returns (bool) {\n', '        return (_sale.startedAt > 0);\n', '    }\n', '\n', '    /** @dev Returns current price of an FT (ERC721) on sale. Broken into two\n', '     *  functions (this one, that computes the duration from the sale\n', '     *  structure, and the other that does the price computation) so we\n', '     *  can easily test that the price computation works correctly.\n', '     */\n', '    function _currentPrice(Sale memory _sale)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 secondsPassed = 0;\n', '\n', '        // A bit of insurance against negative values (or wraparound).\n', '        // Probably not necessary (since Ethereum guarnatees that the\n', '        // now variable doesn&#39;t ever go backwards).\n', '        if (now > _sale.startedAt.add(BID_DELAY_TIME)) {\n', '            secondsPassed = now.sub(_sale.startedAt.add(BID_DELAY_TIME));\n', '        }\n', '\n', '        return _computeCurrentPrice(\n', '            _sale.startingPrice,\n', '            _sale.endingPrice,\n', '            _sale.duration,\n', '            secondsPassed\n', '        );\n', '    }\n', '\n', '    /** @dev Computes the current price of an sale. Factored out\n', '     *  from _currentPrice so we can run extensive unit tests.\n', '     *  When testing, make this function public and turn on\n', '     *  `Current price computation` test suite.\n', '     */\n', '    function _computeCurrentPrice(\n', '        uint256 _startingPrice,\n', '        uint256 _endingPrice,\n', '        uint256 _duration,\n', '        uint256 _secondsPassed\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // NOTE: We don&#39;t use SafeMath (or similar) in this function because\n', '        //  all of our public functions carefully cap the maximum values for\n', '        //  time (at 64-bits) and currency (at 128-bits). _duration is\n', '        //  also known to be non-zero (see the require() statement in\n', '        //  _addSale())\n', '        if (_secondsPassed >= _duration) {\n', '            // We&#39;ve reached the end of the dynamic pricing portion\n', '            // of the sale, just return the end price.\n', '            return _endingPrice;\n', '        } else {\n', '            // Starting price can be higher than ending price (and often is!), so\n', '            // this delta can be negative.\n', '            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\n', '\n', '            // This multiplication can&#39;t overflow, _secondsPassed will easily fit within\n', '            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\n', '            // will always fit within 256-bits.\n', '            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\n', '\n', '            // currentPriceChange can be negative, but if so, will have a magnitude\n', '            // less that _startingPrice. Thus, this result will always end up positive.\n', '            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\n', '\n', '            return uint256(currentPrice);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev        Computes owner&#39;s cut of a sale.\n', '     * @param      _price  The price\n', '     */\n', '    function _computeCut(uint256 _price) internal view returns (uint256) {\n', '        return _price.mul(ownerCut).div(10000);\n', '    }\n', '}\n', '\n', '/* Clock sales functions and interfaces\n', ' * @title SaleManager\n', ' * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\n', ' */\n', 'contract SaleManager is SaleBase {\n', '\n', '    /// @dev MAPINGS\n', '    mapping (uint256 => uint256[3]) public lastTeamSalePrices;\n', '    mapping (uint256 => uint256) public lastSingleSalePrices;\n', '    mapping (uint256 => uint256) public seedTeamSaleCount;\n', '    uint256 public seedSingleSaleCount = 0;\n', '\n', '    /// @dev CONSTANTS\n', '    uint256 public constant SINGLE_SALE_MULTIPLIER = 35;\n', '    uint256 public constant TEAM_SALE_MULTIPLIER = 12;\n', '    uint256 public constant STARTING_PRICE = 10 finney;\n', '    uint256 public constant SALES_DURATION = 1 days;\n', '\n', '    bool public isBatchSupported = true;\n', '\n', '    /**\n', '     * @dev        Constructor creates a reference to the MLB_NFT Sale Manager contract\n', '     */\n', '    constructor() public {\n', '        require(ownerCut <= 10000); // You can&#39;t collect more than 100% silly ;)\n', '        require(msg.sender != address(0));\n', '        paused = true;\n', '        gameManagerPrimary = msg.sender;\n', '        gameManagerSecondary = msg.sender;\n', '        bankManager = msg.sender;\n', '    }\n', '\n', '    /// @dev Override unpause so it requires all external contract addresses\n', '    ///  to be set before contract can be unpaused. Also, we can&#39;t have\n', '    ///  newContractAddress set either, because then the contract was upgraded.\n', '    /// @notice This is public rather than external so we can call super.unpause\n', '    ///  without using an expensive CALL.\n', '    function unpause() public onlyGameManager whenPaused {\n', '        require(nonFungibleContract != address(0));\n', '\n', '        // Actually unpause the contract.\n', '        super.unpause();\n', '    }\n', '\n', '    /** @dev Remove all Ether from the contract, which is the owner&#39;s cuts\n', '     *  as well as any Ether sent directly to the contract address.\n', '     *  Always transfers to the NFT (ERC721) contract, but can be called either by\n', '     *  the owner or the NFT (ERC721) contract.\n', '     */\n', '    function _withdrawBalance() internal {\n', '        // We are using this boolean method to make sure that even if one fails it will still work\n', '        bankManager.transfer(address(this).balance);\n', '    }\n', '\n', '\n', '    /** @dev Reject all Ether from being sent here, unless it&#39;s from one of the\n', '     *  contracts. (Hopefully, we can prevent user accidents.)\n', '     *  @notice No tipping!\n', '     */\n', '    function() external payable {\n', '        address nftAddress = address(nonFungibleContract);\n', '        require(\n', '            msg.sender == address(this) || \n', '            msg.sender == gameManagerPrimary ||\n', '            msg.sender == gameManagerSecondary ||\n', '            msg.sender == bankManager ||\n', '            msg.sender == nftAddress ||\n', '            msg.sender == address(LSEscrowContract)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Creates and begins a new sale.\n', '     * @param      _tokenId        The token identifier\n', '     * @param      _startingPrice  The starting price\n', '     * @param      _endingPrice    The ending price\n', '     * @param      _duration       The duration\n', '     * @param      _seller         The seller\n', '     */\n', '    function _createSale(\n', '        uint256 _tokenId,\n', '        uint256 _startingPrice,\n', '        uint256 _endingPrice,\n', '        uint256 _duration,\n', '        address _seller\n', '    )\n', '        internal\n', '    {\n', '        Sale memory sale = Sale(\n', '            _seller,\n', '            _startingPrice,\n', '            _endingPrice,\n', '            _duration,\n', '            now,\n', '            [_tokenId,0,0,0,0,0,0,0,0]\n', '        );\n', '        _addSale(_tokenId, sale);\n', '    }\n', '\n', '    /**\n', '     * @dev        Internal Function, helps in creating team sale\n', '     * @param      _tokenIds       The token identifiers\n', '     * @param      _startingPrice  The starting price\n', '     * @param      _endingPrice    The ending price\n', '     * @param      _duration       The duration\n', '     * @param      _seller         The seller\n', '     */\n', '    function _createTeamSale(\n', '        uint256[9] _tokenIds,\n', '        uint256 _startingPrice,\n', '        uint256 _endingPrice,\n', '        uint256 _duration,\n', '        address _seller)\n', '        internal {\n', '\n', '        Sale memory sale = Sale(\n', '            _seller,\n', '            _startingPrice,\n', '            _endingPrice,\n', '            _duration,\n', '            now,\n', '            _tokenIds\n', '        );\n', '\n', '        /// Add sale obj to all tokens\n', '        _addTeamSale(_tokenIds, sale);\n', '    }\n', '\n', '    /** @dev            Cancels an sale that hasn&#39;t been won yet. Returns the MLBNFT (ERC721) to original owner.\n', '     *  @notice         This is a state-modifying function that can be called while the contract is paused.\n', '     */\n', '    function cancelSale(uint256 _tokenId) external whenNotPaused {\n', '        Sale memory sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        address seller = sale.seller;\n', '        require(msg.sender == seller);\n', '        _cancelSale(_tokenId, seller);\n', '    }\n', '\n', '    /** @dev        Cancels an sale that hasn&#39;t been won yet. Returns the MLBNFT (ERC721) to original owner.\n', '     *  @notice     This is a state-modifying function that can be called while the contract is paused. Can be only called by the GameManagers\n', '     */\n', '    function cancelSaleWhenPaused(uint256 _tokenId) external whenPaused onlyGameManager {\n', '        Sale memory sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        address seller = sale.seller;\n', '        _cancelSale(_tokenId, seller);\n', '    }\n', '\n', '    /** \n', '     * @dev    Returns sales info for an CSLCollectibles (ERC721) on sale.\n', '     * @notice Fetches the details related to the Sale\n', '     * @param  _tokenId    ID of the token on sale\n', '     */\n', '    function getSale(uint256 _tokenId) external view returns (address seller, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt, uint256[9] tokenIds) {\n', '        Sale memory sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        return (\n', '            sale.seller,\n', '            sale.startingPrice,\n', '            sale.endingPrice,\n', '            sale.duration,\n', '            sale.startedAt,\n', '            sale.tokenIds\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Returns the current price of an sale.\n', '     * @param      _tokenId  The token identifier\n', '     */\n', '    function getCurrentPrice(uint256 _tokenId) external view returns (uint256) {\n', '        Sale memory sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        return _currentPrice(sale);\n', '    }\n', '\n', '    /** @dev Calculates the new price for Sale Item\n', '     * @param   _saleType     Sale Type Identifier (0 - Single Sale, 1 - Team Sale)\n', '     * @param   _teamId       Team Identifier\n', '     */\n', '    function _averageSalePrice(uint256 _saleType, uint256 _teamId) internal view returns (uint256) {\n', '        uint256 _price = 0;\n', '        if(_saleType == 0) {\n', '            for(uint256 ii = 0; ii < 10; ii++) {\n', '                _price = _price.add(lastSingleSalePrices[ii]);\n', '            }\n', '            _price = _price.mul(SINGLE_SALE_MULTIPLIER).div(100);\n', '        } else {\n', '            for (uint256 i = 0; i < 3; i++) {\n', '                _price = _price.add(lastTeamSalePrices[_teamId][i]);\n', '            }\n', '        \n', '            _price = _price.mul(TEAM_SALE_MULTIPLIER).div(30);\n', '            _price = _price.mul(9);\n', '        }\n', '\n', '        return _price;\n', '    }\n', '    \n', '    /**\n', '     * @dev        Put a Collectible up for sale. Does some ownership trickery to create sale in one tx.\n', '     * @param      _tokenId        The token identifier\n', '     * @param      _startingPrice  The starting price\n', '     * @param      _endingPrice    The ending price\n', '     * @param      _duration       The duration\n', '     * @param      _owner          Owner of the token\n', '     */\n', '    function createSale(uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration, address _owner) external whenNotPaused {\n', '        require(msg.sender == address(nonFungibleContract));\n', '\n', '        // Check whether the collectible is inPlay. If inPlay cant put it on Sale\n', '        require(nonFungibleContract.checkIsAttached(_tokenId) == 0);\n', '        \n', '        _escrow(_owner, _tokenId);\n', '\n', '        // Sale throws if inputs are invalid and clears\n', '        // transfer and sire approval after escrowing the CSLCollectible.\n', '        _createSale(\n', '            _tokenId,\n', '            _startingPrice,\n', '            _endingPrice,\n', '            _duration,\n', '            _owner\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Put a Collectible up for sale. Only callable, if user approved contract for 1/All Collectibles\n', '     * @param      _tokenId        The token identifier\n', '     * @param      _startingPrice  The starting price\n', '     * @param      _endingPrice    The ending price\n', '     * @param      _duration       The duration\n', '     */\n', '    function userCreateSaleIfApproved (uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration) external whenNotPaused {\n', '        \n', '        require(nonFungibleContract.getApproved(_tokenId) == address(this) || nonFungibleContract.isApprovedForAll(msg.sender, address(this)));\n', '        \n', '        // Check whether the collectible is inPlay. If inPlay cant put it on Sale\n', '        require(nonFungibleContract.checkIsAttached(_tokenId) == 0);\n', '        \n', '        _escrow(msg.sender, _tokenId);\n', '\n', '        // Sale throws if inputs are invalid and clears\n', '        // transfer and sire approval after escrowing the CSLCollectible.\n', '        _createSale(\n', '            _tokenId,\n', '            _startingPrice,\n', '            _endingPrice,\n', '            _duration,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /** \n', '     * @dev        Transfers the balance of the sales manager contract to the CSLCollectible contract. We use two-step withdrawal to\n', '     *              prevent two transfer calls in the sale bid function.\n', '     */\n', '    function withdrawSaleManagerBalances() public onlyBanker {\n', '        _withdrawBalance();\n', '    }\n', '\n', '    /** \n', '     *  @dev Function to chnage the OwnerCut only accessible by the Owner of the contract\n', '     *  @param _newCut - Sets the ownerCut to new value\n', '     */\n', '    function setOwnerCut(uint256 _newCut) external onlyBanker {\n', '        require(_newCut <= 10000);\n', '        ownerCut = _newCut;\n', '    }\n', '    \n', '    /**\n', '     * @dev        Facilitates seed collectible auction creation. Enforces strict check on the data being passed\n', '     * @notice     Creates a new Collectible and creates an auction for it.\n', '     * @param      _teamId            The team identifier\n', '     * @param      _posId             The position identifier\n', '     * @param      _attributes        The attributes\n', '     * @param      _playerOverrideId  The player override identifier\n', '     * @param      _mlbPlayerId       The mlb player identifier\n', '     * @param      _startPrice        The start price\n', '     * @param      _endPrice          The end price\n', '     * @param      _saleDuration      The sale duration\n', '     */\n', '    function createSingleSeedAuction(\n', '        uint8 _teamId,\n', '        uint8 _posId,\n', '        uint256 _attributes,\n', '        uint256 _playerOverrideId,\n', '        uint256 _mlbPlayerId,\n', '        uint256 _startPrice,\n', '        uint256 _endPrice,\n', '        uint256 _saleDuration)\n', '        public\n', '        onlyGameManager\n', '        whenNotPaused {\n', '        // Check to see the NFT address is not 0\n', '        require(nonFungibleContract != address(0));\n', '        require(_teamId != 0);\n', '\n', '        uint256 nftId = nonFungibleContract.createSeedCollectible(_teamId,_posId,_attributes,address(this),0, _playerOverrideId, _mlbPlayerId);\n', '\n', '        uint256 startPrice = 0;\n', '        uint256 endPrice = 0;\n', '        uint256 duration = 0;\n', '        \n', '        if(_startPrice == 0) {\n', '            startPrice = _computeNextSeedPrice(0, _teamId);\n', '        } else {\n', '            startPrice = _startPrice;\n', '        }\n', '\n', '        if(_endPrice != 0) {\n', '            endPrice = _endPrice;\n', '        } else {\n', '            endPrice = 0;\n', '        }\n', '\n', '        if(_saleDuration == 0) {\n', '            duration = SALES_DURATION;\n', '        } else {\n', '            duration = _saleDuration;\n', '        }\n', '\n', '        _createSale(\n', '            nftId,\n', '            startPrice,\n', '            endPrice,\n', '            duration,\n', '            address(this)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Facilitates promo collectible auction creation. Enforces strict check on the data being passed\n', '     * @notice     Creates a new Collectible and creates an auction for it.\n', '     * @param      _teamId            The team identifier\n', '     * @param      _posId             The position identifier\n', '     * @param      _attributes        The attributes\n', '     * @param      _playerOverrideId  The player override identifier\n', '     * @param      _mlbPlayerId       The mlb player identifier\n', '     * @param      _startPrice        The start price\n', '     * @param      _endPrice          The end price\n', '     * @param      _saleDuration      The sale duration\n', '     */\n', '    function createPromoSeedAuction(\n', '        uint8 _teamId,\n', '        uint8 _posId,\n', '        uint256 _attributes,\n', '        uint256 _playerOverrideId,\n', '        uint256 _mlbPlayerId,\n', '        uint256 _startPrice,\n', '        uint256 _endPrice,\n', '        uint256 _saleDuration)\n', '        public\n', '        onlyGameManager\n', '        whenNotPaused {\n', '        // Check to see the NFT address is not 0\n', '        require(nonFungibleContract != address(0));\n', '        require(_teamId != 0);\n', '\n', '        uint256 nftId = nonFungibleContract.createPromoCollectible(_teamId, _posId, _attributes, address(this), 0, _playerOverrideId, _mlbPlayerId);\n', '\n', '        uint256 startPrice = 0;\n', '        uint256 endPrice = 0;\n', '        uint256 duration = 0;\n', '        \n', '        if(_startPrice == 0) {\n', '            startPrice = _computeNextSeedPrice(0, _teamId);\n', '        } else {\n', '            startPrice = _startPrice;\n', '        }\n', '\n', '        if(_endPrice != 0) {\n', '            endPrice = _endPrice;\n', '        } else {\n', '            endPrice = 0;\n', '        }\n', '\n', '        if(_saleDuration == 0) {\n', '            duration = SALES_DURATION;\n', '        } else {\n', '            duration = _saleDuration;\n', '        }\n', '\n', '        _createSale(\n', '            nftId,\n', '            startPrice,\n', '            endPrice,\n', '            duration,\n', '            address(this)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Creates Team Sale Auction\n', '     * @param      _teamId        The team identifier\n', '     * @param      _tokenIds      The token identifiers\n', '     * @param      _startPrice    The start price\n', '     * @param      _endPrice      The end price\n', '     * @param      _saleDuration  The sale duration\n', '     */\n', '    function createTeamSaleAuction(\n', '        uint8 _teamId,\n', '        uint256[9] _tokenIds,\n', '        uint256 _startPrice,\n', '        uint256 _endPrice,\n', '        uint256 _saleDuration)\n', '        public\n', '        onlyGameManager\n', '        whenNotPaused {\n', '\n', '        require(_teamId != 0);\n', '\n', '        // Helps in not creating sale with wrong team and player combination\n', '        for(uint ii = 0; ii < _tokenIds.length; ii++){\n', '            require(nonFungibleContract.getTeamId(_tokenIds[ii]) == _teamId);\n', '        }\n', '        \n', '        uint256 startPrice = 0;\n', '        uint256 endPrice = 0;\n', '        uint256 duration = 0;\n', '        \n', '        if(_startPrice == 0) {\n', '            startPrice = _computeNextSeedPrice(1, _teamId).mul(9);\n', '        } else {\n', '            startPrice = _startPrice;\n', '        }\n', '\n', '        if(_endPrice != 0) {\n', '            endPrice = _endPrice;\n', '        } else {\n', '            endPrice = 0;\n', '        }\n', '\n', '        if(_saleDuration == 0) {\n', '            duration = SALES_DURATION;\n', '        } else {\n', '            duration = _saleDuration;\n', '        }\n', '\n', '        _createTeamSale(\n', '            _tokenIds,\n', '            startPrice,\n', '            endPrice,\n', '            duration,\n', '            address(this)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Computes the next auction starting price\n', '     * @param      _saleType     The sale type\n', '     * @param      _teamId       The team identifier\n', '     */\n', '    function _computeNextSeedPrice(uint256 _saleType, uint256 _teamId) internal view returns (uint256) {\n', '        uint256 nextPrice = _averageSalePrice(_saleType, _teamId);\n', '\n', '        // Sanity check to ensure we don&#39;t overflow arithmetic\n', '        require(nextPrice == nextPrice);\n', '\n', '        // We never auction for less than starting price\n', '        if (nextPrice < STARTING_PRICE) {\n', '            nextPrice = STARTING_PRICE;\n', '        }\n', '\n', '        return nextPrice;\n', '    }\n', '\n', '    /**\n', '     * @dev        Sanity check that allows us to ensure that we are pointing to the right sale call.\n', '     */\n', '    bool public isSalesManager = true;\n', '\n', '    /**\n', '     * @dev        works the same as default bid method.\n', '     * @param      _tokenId  The token identifier\n', '     */\n', '    function bid(uint256 _tokenId) public whenNotPaused payable {\n', '        \n', '        Sale memory sale = tokenIdToSale[_tokenId];\n', '        address seller = sale.seller;\n', '\n', '        // This check is added to give all users a level playing field to think & bid on the player\n', '        require (now > sale.startedAt.add(BID_DELAY_TIME));\n', '        \n', '        uint256 price = _bid(_tokenId, msg.value);\n', '\n', '        //If multi token sale\n', '        if(sale.tokenIds[1] > 0) {\n', '            \n', '            for (uint256 i = 0; i < 9; i++) {\n', '                _transfer(address(this), msg.sender, sale.tokenIds[i]);\n', '            }\n', '\n', '            // Avg price\n', '            price = price.div(9);\n', '        } else {\n', '            \n', '            _transfer(address(this), msg.sender, _tokenId);\n', '        }\n', '        \n', '        // If not a seed, exit\n', '        if (seller == address(this)) {\n', '            if(sale.tokenIds[1] > 0){\n', '                uint256 _teamId = nonFungibleContract.getTeamId(_tokenId);\n', '\n', '                lastTeamSalePrices[_teamId][seedTeamSaleCount[_teamId] % 3] = price;\n', '\n', '                seedTeamSaleCount[_teamId]++;\n', '            } else {\n', '                lastSingleSalePrices[seedSingleSaleCount % 10] = price;\n', '                seedSingleSaleCount++;\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev        Sets the address for the NFT Contract\n', '     * @param      _nftAddress  The nft address\n', '     */\n', '    function setNFTContractAddress(address _nftAddress) public onlyGameManager {\n', '        require (_nftAddress != address(0));        \n', '        nonFungibleContract = MLBNFT(_nftAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev        Added this module to allow retrieve of accidental asset transfer to contract\n', '     * @param      _to       { parameter_description }\n', '     * @param      _tokenId  The token identifier\n', '     */\n', '    function assetTransfer(address _to, uint256 _tokenId) public onlyGameManager {\n', '        require(_tokenId != 0);\n', '        nonFungibleContract.transferFrom(address(this), _to, _tokenId);\n', '    }\n', '\n', '     /**\n', '     * @dev        Added this module to allow retrieve of accidental asset transfer to contract\n', '     * @param      _to       { parameter_description }\n', '     * @param      _tokenIds  The token identifiers\n', '     */\n', '    function batchAssetTransfer(address _to, uint256[] _tokenIds) public onlyGameManager {\n', '        require(isBatchSupported);\n', '        require (_tokenIds.length > 0);\n', '        \n', '        for(uint i = 0; i < _tokenIds.length; i++){\n', '            require(_tokenIds[i] != 0);\n', '            nonFungibleContract.transferFrom(address(this), _to, _tokenIds[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev        Creates new Seed Team Collectibles\n', '     * @notice     Creates a team and transfers all minted assets to SaleManager\n', '     * @param      _teamId       The team identifier\n', '     * @param      _attributes   The attributes\n', '     * @param      _mlbPlayerId  The mlb player identifier\n', '     */\n', '    function createSeedTeam(uint8 _teamId, uint256[9] _attributes, uint256[9] _mlbPlayerId) public onlyGameManager whenNotPaused {\n', '        require(_teamId != 0);\n', '        \n', '        for(uint ii = 0; ii < 9; ii++) {\n', '            nonFungibleContract.createSeedCollectible(_teamId, uint8(ii.add(1)), _attributes[ii], address(this), 0, 0, _mlbPlayerId[ii]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev            Cancels an sale that hasn&#39;t been won yet. Returns the MLBNFT (ERC721) to original owner.\n', '     * @notice         This is a state-modifying function that can be called while the contract is paused.\n', '     */\n', '    function batchCancelSale(uint256[] _tokenIds) external whenNotPaused {\n', '        require(isBatchSupported);\n', '        require(_tokenIds.length > 0);\n', '\n', '        for(uint ii = 0; ii < _tokenIds.length; ii++){\n', '            Sale memory sale = tokenIdToSale[_tokenIds[ii]];\n', '            require(_isOnSale(sale));\n', '            \n', '            address seller = sale.seller;\n', '            require(msg.sender == seller);\n', '\n', '            _cancelSale(_tokenIds[ii], seller);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev        Helps to toggle batch supported flag\n', '     * @param      _flag  The flag\n', '     */\n', '    function updateBatchSupport(bool _flag) public onlyGameManager {\n', '        isBatchSupported = _flag;\n', '    }\n', '\n', '    /**\n', '     * @dev        Batching Operation: Creates a new Collectible and creates an auction for it.\n', '     * @notice     Helps in creating single seed auctions in batches\n', '     * @param      _teamIds            The team identifier\n', '     * @param      _posIds            The position identifier\n', '     * @param      _attributes        The attributes\n', '     * @param      _playerOverrideIds  The player override identifier\n', '     * @param      _mlbPlayerIds       The mlb player identifier\n', '     * @param      _startPrice         The start price\n', '     */\n', '    function batchCreateSingleSeedAuction(\n', '        uint8[] _teamIds,\n', '        uint8[] _posIds,\n', '        uint256[] _attributes,\n', '        uint256[] _playerOverrideIds,\n', '        uint256[] _mlbPlayerIds,\n', '        uint256 _startPrice)\n', '        public\n', '        onlyGameManager\n', '        whenNotPaused {\n', '\n', '        require (isBatchSupported);\n', '\n', '        require (_teamIds.length > 0 &&\n', '            _posIds.length > 0 &&\n', '            _attributes.length > 0 &&\n', '            _playerOverrideIds.length > 0 &&\n', '            _mlbPlayerIds.length > 0 );\n', '        \n', '        // Check to see the NFT address is not 0\n', '        require(nonFungibleContract != address(0));\n', '        \n', '        uint256 nftId;\n', '\n', '        require (_startPrice != 0);\n', '\n', '        for(uint ii = 0; ii < _mlbPlayerIds.length; ii++){\n', '            require(_teamIds[ii] != 0);\n', '\n', '            nftId = nonFungibleContract.createSeedCollectible(\n', '                        _teamIds[ii],\n', '                        _posIds[ii],\n', '                        _attributes[ii],\n', '                        address(this),\n', '                        0,\n', '                        _playerOverrideIds[ii],\n', '                        _mlbPlayerIds[ii]);\n', '\n', '            _createSale(\n', '                nftId,\n', '                _startPrice,\n', '                0,\n', '                SALES_DURATION,\n', '                address(this)\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev        Helps in incrementing the delay time to start bidding for any auctions\n', '     * @notice     Function helps to update the delay time for bidding\n', '     * @param      _newDelay       The new Delay time\n', '     */\n', '    function updateDelayTime(uint256 _newDelay) public onlyGameManager whenNotPaused {\n', '\n', '        BID_DELAY_TIME = _newDelay;\n', '    }\n', '\n', '    function bidTransfer(uint256 _tokenId, address _buyer, uint256 _bidAmount) public canTransact {\n', '\n', '        Sale memory sale = tokenIdToSale[_tokenId];\n', '        address seller = sale.seller;\n', '\n', '        // This check is added to give all users a level playing field to think & bid on the player\n', '        require (now > sale.startedAt.add(BID_DELAY_TIME));\n', '        \n', '        uint256[9] memory tokenIdsStore = tokenIdToSale[_tokenId].tokenIds;\n', '        \n', '        // Explicitly check that this sale is currently live.\n', '        require(_isOnSale(sale));\n', '\n', '        // Check that the bid is greater than or equal to the current price\n', '        uint256 price = _currentPrice(sale);\n', '        require(_bidAmount >= price);\n', '\n', '        // The bid is good! Remove the sale before sending the fees\n', '        // to the sender so we can&#39;t have a reentrancy attack.\n', '        if(tokenIdsStore[1] > 0) {\n', '            for(uint ii = 0; ii < 9; ii++) {\n', '                _removeSale(tokenIdsStore[ii]);\n', '            }\n', '        } else {\n', '            _removeSale(_tokenId);\n', '        }\n', '\n', '        uint256 marketsCut = 0;\n', '        uint256 sellerProceeds = 0;\n', '\n', '        // Transfer proceeds to seller (if there are any!)\n', '        if (price > 0) {\n', '            // Calculate the marketplace&#39;s cut.\n', '            // (NOTE: _computeCut() is guaranteed to return a\n', '            // value <= price)\n', '            marketsCut = _computeCut(price);\n', '            sellerProceeds = price.sub(marketsCut);\n', '        }\n', '\n', '        //escrowTransfer(address seller, address buyer, uint256 currentPrice) public returns(bool);\n', '        require (LSEscrowContract.escrowTransfer(seller, _buyer, sellerProceeds, marketsCut));\n', '        \n', '        // Tell the world!\n', '        // uint256 assetID, uint256 totalPrice, address winner, uint16 generation\n', '        if(tokenIdsStore[1] > 0) {\n', '            emit TeamSaleWinner(tokenIdsStore, price, _buyer);\n', '        } else {\n', '            emit SaleWinner(_tokenId, price, _buyer);\n', '        }\n', '\n', '        //If multi token sale\n', '        if(sale.tokenIds[1] > 0) {\n', '            \n', '            for (uint256 i = 0; i < 9; i++) {\n', '                _transfer(address(this), _buyer, sale.tokenIds[i]);\n', '            }\n', '\n', '            // Avg price\n', '            price = price.div(9);\n', '        } else {\n', '            \n', '            _transfer(address(this), _buyer, _tokenId);\n', '        }\n', '        \n', '        // If not a seed, exit\n', '        if (seller == address(this)) {\n', '            if(sale.tokenIds[1] > 0) {\n', '                uint256 _teamId = nonFungibleContract.getTeamId(_tokenId);\n', '\n', '                lastTeamSalePrices[_teamId][seedTeamSaleCount[_teamId] % 3] = price;\n', '\n', '                seedTeamSaleCount[_teamId]++;\n', '            } else {\n', '                lastSingleSalePrices[seedSingleSaleCount % 10] = price;\n', '                seedSingleSaleCount++;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev        Sets the address for the LS Escrow Contract\n', '     * @param      _lsEscrowAddress  The nft address\n', '     */\n', '    function setLSEscrowContractAddress(address _lsEscrowAddress) public onlyGameManager {\n', '        require (_lsEscrowAddress != address(0));        \n', '        LSEscrowContract = LSEscrow(_lsEscrowAddress);\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '}\n', '\n', '/* Controls game play state and access rights for game functions\n', ' * @title Operational Control\n', ' * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\n', ' * Inspired and adapted from contract created by OpenZeppelin\n', ' * Ref: https://github.com/OpenZeppelin/zeppelin-solidity/\n', ' */\n', 'contract OperationalControl {\n', '    // Facilitates access & control for the game.\n', '    // Roles:\n', '    //  -The Game Managers (Primary/Secondary): Has universal control of all game elements (No ability to withdraw)\n', '    //  -The Banker: The Bank can withdraw funds and adjust fees / prices.\n', '\n', '    /// @dev Emited when contract is upgraded\n', '    event ContractUpgrade(address newContract);\n', '\n', '    mapping (address => bool) allowedAddressList;\n', '    \n', '\n', '    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public gameManagerPrimary;\n', '    address public gameManagerSecondary;\n', '    address public bankManager;\n', '\n', '    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused = false;\n', '\n', '    /// @dev Operation modifiers for limiting access\n', '    modifier onlyGameManager() {\n', '        require(msg.sender == gameManagerPrimary || msg.sender == gameManagerSecondary);\n', '        _;\n', '    }\n', '\n', '    /// @dev Operation modifiers for limiting access to only Banker\n', '    modifier onlyBanker() {\n', '        require(msg.sender == bankManager);\n', '        _;\n', '    }\n', '\n', '    /// @dev Operation modifiers for access to any Manager\n', '    modifier anyOperator() {\n', '        require(\n', '            msg.sender == gameManagerPrimary ||\n', '            msg.sender == gameManagerSecondary ||\n', '            msg.sender == bankManager\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the GM.\n', '    function setPrimaryGameManager(address _newGM) external onlyGameManager {\n', '        require(_newGM != address(0));\n', '\n', '        gameManagerPrimary = _newGM;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the GM.\n', '    function setSecondaryGameManager(address _newGM) external onlyGameManager {\n', '        require(_newGM != address(0));\n', '\n', '        gameManagerSecondary = _newGM;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Banker.\n', '    function setBanker(address _newBK) external onlyBanker {\n', '        require(_newBK != address(0));\n', '\n', '        bankManager = _newBK;\n', '    }\n', '\n', '    function updateAllowedAddressesList (address _newAddress, bool _value) external onlyGameManager {\n', '\n', '        require (_newAddress != address(0));\n', '\n', '        allowedAddressList[_newAddress] = _value;\n', '        \n', '    }\n', '\n', '    modifier canTransact() { \n', '        require (msg.sender == gameManagerPrimary\n', '            || msg.sender == gameManagerSecondary\n', '            || allowedAddressList[msg.sender]); \n', '        _; \n', '    }\n', '    \n', '\n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any Operator role to pause the contract.\n', '    /// Used only if a bug or exploit is discovered (Here to limit losses / damage)\n', '    function pause() external onlyGameManager whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the Game Master\n', '    /// @notice This is public rather than external so it can be called by derived contracts. \n', '    function unpause() public onlyGameManager whenPaused {\n', "        // can't unpause if contract was upgraded\n", '        paused = false;\n', '    }\n', '}\n', '\n', '/* @title Interface for MLBNFT Contract\n', ' * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\n', ' */\n', 'contract MLBNFT {\n', '    function exists(uint256 _tokenId) public view returns (bool _exists);\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function setApprovalForAll(address _to, bool _approved) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function createPromoCollectible(uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) external returns (uint256);\n', '    function createSeedCollectible(uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) public returns (uint256);\n', '    function checkIsAttached(uint256 _tokenId) public view returns (uint256);\n', '    function getTeamId(uint256 _tokenId) external view returns (uint256);\n', '    function getPlayerId(uint256 _tokenId) external view returns (uint256 playerId);\n', '    function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '}\n', '\n', '/* @title Interface for ETH Escrow Contract\n', ' * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\n', ' */\n', 'contract LSEscrow {\n', '    function escrowTransfer(address seller, address buyer, uint256 currentPrice, uint256 marketsCut) public returns(bool);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' *  from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver {\n', '    /**\n', '    * @dev Magic value to be returned upon successful reception of an NFT\n', '    *  Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`,\n', '    *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '    */\n', '    bytes4 public constant ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    /**\n', '    * @notice Handle the receipt of an NFT\n', '    * @dev The ERC721 smart contract calls this function on the recipient\n', '    *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '    *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    *  than the magic value MUST result in the transaction being reverted.\n', '    *  Note: the contract address is always the message sender.\n', '    * @param _from The sending address\n', '    * @param _tokenId The NFT identifier which is being transfered\n', '    * @param _data Additional data with no specified format\n', '    * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '    */\n', '    function onERC721Received(\n', '        address _operator,\n', '        address _from,\n', '        uint256 _tokenId,\n', '        bytes _data\n', '    )\n', '        public\n', '        returns(bytes4);\n', '}\n', '\n', 'contract ERC721Holder is ERC721Receiver {\n', '    function onERC721Received(address,address, uint256, bytes) public returns(bytes4) {\n', '        return ERC721_RECEIVED;\n', '    }\n', '}\n', '\n', '/* Contains models, variables, and internal methods for the ERC-721 sales.\n', ' * @title Sale Base\n', ' * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\n', ' */\n', 'contract SaleBase is OperationalControl, ERC721Holder {\n', '    using SafeMath for uint256;\n', '    \n', '    /// EVENTS \n', '\n', '    event SaleCreated(uint256 tokenID, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt);\n', '    event TeamSaleCreated(uint256[9] tokenIDs, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt);\n', '    event SaleWinner(uint256 tokenID, uint256 totalPrice, address winner);\n', '    event TeamSaleWinner(uint256[9] tokenIDs, uint256 totalPrice, address winner);\n', '    event SaleCancelled(uint256 tokenID, address sellerAddress);\n', '    event EtherWithdrawed(uint256 value);\n', '\n', '    /// STORAGE\n', '\n', '    /**\n', '     * @dev        Represents an Sale on MLB CryptoBaseball (ERC721)\n', '     */\n', '    struct Sale {\n', '        // Current owner of NFT (ERC721)\n', '        address seller;\n', '        // Price (in wei) at beginning of sale\n', '        uint256 startingPrice;\n', '        // Price (in wei) at end of sale\n', '        uint256 endingPrice;\n', '        // Duration (in seconds) of sale\n', '        uint256 duration;\n', '        // Time when sale started\n', '        // NOTE: 0 if this sale has been concluded\n', '        uint256 startedAt;\n', '        // ERC721 AssetID\n', '        uint256[9] tokenIds;\n', '    }\n', '\n', '    /**\n', '     * @dev        Reference to contract tracking ownership & asset details\n', '     */\n', '    MLBNFT public nonFungibleContract;\n', '\n', '    /**\n', '     * @dev        Reference to contract tracking ownership & asset details\n', '     */\n', '    LSEscrow public LSEscrowContract;\n', '\n', '    /**\n', '     * @dev   Defining a GLOBAL delay time for the auctions to start accepting bidExcess\n', '     * @notice This variable is made to delay the bid process.\n', '     */\n', '    uint256 public BID_DELAY_TIME = 0;\n', '\n', '    // Cut owner takes on each sale, measured in basis points (1/100 of a percent).\n', '    // Values 0-10,000 map to 0%-100%\n', '    uint256 public ownerCut = 500; //5%\n', '\n', '    // Map from token to their corresponding sale.\n', '    mapping (uint256 => Sale) tokenIdToSale;\n', '\n', '    /**\n', '     * @dev        Returns true if the claimant owns the token.\n', '     * @param      _claimant  The claimant\n', '     * @param      _tokenId   The token identifier\n', '     */\n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n', '    }\n', '\n', '    /**\n', '     * @dev        Internal function to ESCROW\n', '     * @notice     Escrows the ERC721 Token, assigning ownership to this contract. Throws if the escrow fails.\n', '     * @param      _owner    The owner\n', '     * @param      _tokenId  The token identifier\n', '     */\n', '    function _escrow(address _owner, uint256 _tokenId) internal {\n', '        nonFungibleContract.safeTransferFrom(_owner, this, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev        Internal Transfer function\n', '     * @notice     Transfers an ERC721 Token owned by this contract to another address. Returns true if the transfer succeeds.\n', '     * @param      _owner     The owner\n', '     * @param      _receiver  The receiver\n', '     * @param      _tokenId   The token identifier\n', '     */\n', '    function _transfer(address _owner, address _receiver, uint256 _tokenId) internal {\n', '        nonFungibleContract.transferFrom(_owner, _receiver, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev        Internal Function to add Sale, which duration check (atleast 1 min duration required)\n', '     * @notice     Adds an sale to the list of open sales. Also fires the SaleCreated event.\n', '     * @param      _tokenId  The token identifier\n', '     * @param      _sale     The sale\n', '     */\n', '    function _addSale(uint256 _tokenId, Sale _sale) internal {\n', '        // Require that all sales have a duration of\n', '        // at least one minute.\n', '        require(_sale.duration >= 1 minutes);\n', '        \n', '        tokenIdToSale[_tokenId] = _sale;\n', '\n', '        emit SaleCreated(\n', '            uint256(_tokenId),\n', '            uint256(_sale.startingPrice),\n', '            uint256(_sale.endingPrice),\n', '            uint256(_sale.duration),\n', '            uint256(_sale.startedAt)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Internal Function to add Team Sale, which duration check (atleast 1 min duration required)\n', '     * @notice     Adds an sale to the list of open sales. Also fires the SaleCreated event.\n', '     * @param      _tokenIds  The token identifiers\n', '     * @param      _sale      The sale\n', '     */\n', '    function _addTeamSale(uint256[9] _tokenIds, Sale _sale) internal {\n', '        // Require that all sales have a duration of\n', '        // at least one minute.\n', '        require(_sale.duration >= 1 minutes);\n', '        \n', '        for(uint ii = 0; ii < 9; ii++) {\n', '            require(_tokenIds[ii] != 0);\n', '            require(nonFungibleContract.exists(_tokenIds[ii]));\n', '\n', '            tokenIdToSale[_tokenIds[ii]] = _sale;\n', '        }\n', '\n', '        emit TeamSaleCreated(\n', '            _tokenIds,\n', '            uint256(_sale.startingPrice),\n', '            uint256(_sale.endingPrice),\n', '            uint256(_sale.duration),\n', '            uint256(_sale.startedAt)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Facilites Sale cancellation. Also removed the Sale from the array\n', '     * @notice     Cancels an sale (given the collectibleID is not 0). SaleCancelled Event\n', '     * @param      _tokenId  The token identifier\n', '     * @param      _seller   The seller\n', '     */\n', '    function _cancelSale(uint256 _tokenId, address _seller) internal {\n', '        Sale memory saleItem = tokenIdToSale[_tokenId];\n', '\n', '        //Check for team sale\n', '        if(saleItem.tokenIds[1] != 0) {\n', '            for(uint ii = 0; ii < 9; ii++) {\n', '                _removeSale(saleItem.tokenIds[ii]);\n', '                _transfer(address(this), _seller, saleItem.tokenIds[ii]);\n', '            }\n', '            emit SaleCancelled(_tokenId, _seller);\n', '        } else {\n', '            _removeSale(_tokenId);\n', '            _transfer(address(this), _seller, _tokenId);\n', '            emit SaleCancelled(_tokenId, _seller);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev        Computes the price and transfers winnings. Does NOT transfer ownership of token.\n', '     * @notice     Internal function, helps in making the bid and transferring asset if successful\n', '     * @param      _tokenId    The token identifier\n', '     * @param      _bidAmount  The bid amount\n', '     */\n', '    function _bid(uint256 _tokenId, uint256 _bidAmount)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        // Get a reference to the sale struct\n', '        Sale storage _sale = tokenIdToSale[_tokenId];\n', '        uint256[9] memory tokenIdsStore = tokenIdToSale[_tokenId].tokenIds;\n', '        \n', '        // Explicitly check that this sale is currently live.\n', '        require(_isOnSale(_sale));\n', '\n', '        // Check that the bid is greater than or equal to the current price\n', '        uint256 price = _currentPrice(_sale);\n', '        require(_bidAmount >= price);\n', '\n', '        // Grab a reference to the seller before the sale struct\n', '        // gets deleted.\n', '        address seller = _sale.seller;\n', '\n', '        // The bid is good! Remove the sale before sending the fees\n', "        // to the sender so we can't have a reentrancy attack.\n", '        if(tokenIdsStore[1] > 0) {\n', '            for(uint ii = 0; ii < 9; ii++) {\n', '                _removeSale(tokenIdsStore[ii]);\n', '            }\n', '        } else {\n', '            _removeSale(_tokenId);\n', '        }\n', '\n', '        // Transfer proceeds to seller (if there are any!)\n', '        if (price > 0) {\n', "            // Calculate the marketplace's cut.\n", '            // (NOTE: _computeCut() is guaranteed to return a\n', '            // value <= price)\n', '            uint256 marketsCut = _computeCut(price);\n', '            uint256 sellerProceeds = price.sub(marketsCut);\n', '\n', '            seller.transfer(sellerProceeds);\n', '        }\n', '\n', '        // Calculate any excess funds included with the bid. If the excess\n', '        // is anything worth worrying about, transfer it back to bidder.\n', '        uint256 bidExcess = _bidAmount.sub(price);\n', '\n', '        // Return the funds. Similar to the previous transfer.\n', '        msg.sender.transfer(bidExcess);\n', '\n', '        // Tell the world!\n', '        // uint256 assetID, uint256 totalPrice, address winner, uint16 generation\n', '        if(tokenIdsStore[1] > 0) {\n', '            emit TeamSaleWinner(tokenIdsStore, price, msg.sender);\n', '        } else {\n', '            emit SaleWinner(_tokenId, price, msg.sender);\n', '        }\n', '        \n', '        return price;\n', '    }\n', '\n', '    /**\n', '     * @dev        Removes an sale from the list of open sales.\n', '     * @notice     Internal Function to remove sales\n', '     * @param      _tokenId  The token identifier\n', '     */\n', '    function _removeSale(uint256 _tokenId) internal {\n', '        delete tokenIdToSale[_tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev        Returns true if the FT (ERC721) is on sale.\n', '     * @notice     Internal function to check if an\n', '     * @param      _sale  The sale\n', '     */\n', '    function _isOnSale(Sale memory _sale) internal pure returns (bool) {\n', '        return (_sale.startedAt > 0);\n', '    }\n', '\n', '    /** @dev Returns current price of an FT (ERC721) on sale. Broken into two\n', '     *  functions (this one, that computes the duration from the sale\n', '     *  structure, and the other that does the price computation) so we\n', '     *  can easily test that the price computation works correctly.\n', '     */\n', '    function _currentPrice(Sale memory _sale)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 secondsPassed = 0;\n', '\n', '        // A bit of insurance against negative values (or wraparound).\n', '        // Probably not necessary (since Ethereum guarnatees that the\n', "        // now variable doesn't ever go backwards).\n", '        if (now > _sale.startedAt.add(BID_DELAY_TIME)) {\n', '            secondsPassed = now.sub(_sale.startedAt.add(BID_DELAY_TIME));\n', '        }\n', '\n', '        return _computeCurrentPrice(\n', '            _sale.startingPrice,\n', '            _sale.endingPrice,\n', '            _sale.duration,\n', '            secondsPassed\n', '        );\n', '    }\n', '\n', '    /** @dev Computes the current price of an sale. Factored out\n', '     *  from _currentPrice so we can run extensive unit tests.\n', '     *  When testing, make this function public and turn on\n', '     *  `Current price computation` test suite.\n', '     */\n', '    function _computeCurrentPrice(\n', '        uint256 _startingPrice,\n', '        uint256 _endingPrice,\n', '        uint256 _duration,\n', '        uint256 _secondsPassed\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', "        // NOTE: We don't use SafeMath (or similar) in this function because\n", '        //  all of our public functions carefully cap the maximum values for\n', '        //  time (at 64-bits) and currency (at 128-bits). _duration is\n', '        //  also known to be non-zero (see the require() statement in\n', '        //  _addSale())\n', '        if (_secondsPassed >= _duration) {\n', "            // We've reached the end of the dynamic pricing portion\n", '            // of the sale, just return the end price.\n', '            return _endingPrice;\n', '        } else {\n', '            // Starting price can be higher than ending price (and often is!), so\n', '            // this delta can be negative.\n', '            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\n', '\n', "            // This multiplication can't overflow, _secondsPassed will easily fit within\n", '            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\n', '            // will always fit within 256-bits.\n', '            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\n', '\n', '            // currentPriceChange can be negative, but if so, will have a magnitude\n', '            // less that _startingPrice. Thus, this result will always end up positive.\n', '            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\n', '\n', '            return uint256(currentPrice);\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @dev        Computes owner's cut of a sale.\n", '     * @param      _price  The price\n', '     */\n', '    function _computeCut(uint256 _price) internal view returns (uint256) {\n', '        return _price.mul(ownerCut).div(10000);\n', '    }\n', '}\n', '\n', '/* Clock sales functions and interfaces\n', ' * @title SaleManager\n', ' * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\n', ' */\n', 'contract SaleManager is SaleBase {\n', '\n', '    /// @dev MAPINGS\n', '    mapping (uint256 => uint256[3]) public lastTeamSalePrices;\n', '    mapping (uint256 => uint256) public lastSingleSalePrices;\n', '    mapping (uint256 => uint256) public seedTeamSaleCount;\n', '    uint256 public seedSingleSaleCount = 0;\n', '\n', '    /// @dev CONSTANTS\n', '    uint256 public constant SINGLE_SALE_MULTIPLIER = 35;\n', '    uint256 public constant TEAM_SALE_MULTIPLIER = 12;\n', '    uint256 public constant STARTING_PRICE = 10 finney;\n', '    uint256 public constant SALES_DURATION = 1 days;\n', '\n', '    bool public isBatchSupported = true;\n', '\n', '    /**\n', '     * @dev        Constructor creates a reference to the MLB_NFT Sale Manager contract\n', '     */\n', '    constructor() public {\n', "        require(ownerCut <= 10000); // You can't collect more than 100% silly ;)\n", '        require(msg.sender != address(0));\n', '        paused = true;\n', '        gameManagerPrimary = msg.sender;\n', '        gameManagerSecondary = msg.sender;\n', '        bankManager = msg.sender;\n', '    }\n', '\n', '    /// @dev Override unpause so it requires all external contract addresses\n', "    ///  to be set before contract can be unpaused. Also, we can't have\n", '    ///  newContractAddress set either, because then the contract was upgraded.\n', '    /// @notice This is public rather than external so we can call super.unpause\n', '    ///  without using an expensive CALL.\n', '    function unpause() public onlyGameManager whenPaused {\n', '        require(nonFungibleContract != address(0));\n', '\n', '        // Actually unpause the contract.\n', '        super.unpause();\n', '    }\n', '\n', "    /** @dev Remove all Ether from the contract, which is the owner's cuts\n", '     *  as well as any Ether sent directly to the contract address.\n', '     *  Always transfers to the NFT (ERC721) contract, but can be called either by\n', '     *  the owner or the NFT (ERC721) contract.\n', '     */\n', '    function _withdrawBalance() internal {\n', '        // We are using this boolean method to make sure that even if one fails it will still work\n', '        bankManager.transfer(address(this).balance);\n', '    }\n', '\n', '\n', "    /** @dev Reject all Ether from being sent here, unless it's from one of the\n", '     *  contracts. (Hopefully, we can prevent user accidents.)\n', '     *  @notice No tipping!\n', '     */\n', '    function() external payable {\n', '        address nftAddress = address(nonFungibleContract);\n', '        require(\n', '            msg.sender == address(this) || \n', '            msg.sender == gameManagerPrimary ||\n', '            msg.sender == gameManagerSecondary ||\n', '            msg.sender == bankManager ||\n', '            msg.sender == nftAddress ||\n', '            msg.sender == address(LSEscrowContract)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Creates and begins a new sale.\n', '     * @param      _tokenId        The token identifier\n', '     * @param      _startingPrice  The starting price\n', '     * @param      _endingPrice    The ending price\n', '     * @param      _duration       The duration\n', '     * @param      _seller         The seller\n', '     */\n', '    function _createSale(\n', '        uint256 _tokenId,\n', '        uint256 _startingPrice,\n', '        uint256 _endingPrice,\n', '        uint256 _duration,\n', '        address _seller\n', '    )\n', '        internal\n', '    {\n', '        Sale memory sale = Sale(\n', '            _seller,\n', '            _startingPrice,\n', '            _endingPrice,\n', '            _duration,\n', '            now,\n', '            [_tokenId,0,0,0,0,0,0,0,0]\n', '        );\n', '        _addSale(_tokenId, sale);\n', '    }\n', '\n', '    /**\n', '     * @dev        Internal Function, helps in creating team sale\n', '     * @param      _tokenIds       The token identifiers\n', '     * @param      _startingPrice  The starting price\n', '     * @param      _endingPrice    The ending price\n', '     * @param      _duration       The duration\n', '     * @param      _seller         The seller\n', '     */\n', '    function _createTeamSale(\n', '        uint256[9] _tokenIds,\n', '        uint256 _startingPrice,\n', '        uint256 _endingPrice,\n', '        uint256 _duration,\n', '        address _seller)\n', '        internal {\n', '\n', '        Sale memory sale = Sale(\n', '            _seller,\n', '            _startingPrice,\n', '            _endingPrice,\n', '            _duration,\n', '            now,\n', '            _tokenIds\n', '        );\n', '\n', '        /// Add sale obj to all tokens\n', '        _addTeamSale(_tokenIds, sale);\n', '    }\n', '\n', "    /** @dev            Cancels an sale that hasn't been won yet. Returns the MLBNFT (ERC721) to original owner.\n", '     *  @notice         This is a state-modifying function that can be called while the contract is paused.\n', '     */\n', '    function cancelSale(uint256 _tokenId) external whenNotPaused {\n', '        Sale memory sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        address seller = sale.seller;\n', '        require(msg.sender == seller);\n', '        _cancelSale(_tokenId, seller);\n', '    }\n', '\n', "    /** @dev        Cancels an sale that hasn't been won yet. Returns the MLBNFT (ERC721) to original owner.\n", '     *  @notice     This is a state-modifying function that can be called while the contract is paused. Can be only called by the GameManagers\n', '     */\n', '    function cancelSaleWhenPaused(uint256 _tokenId) external whenPaused onlyGameManager {\n', '        Sale memory sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        address seller = sale.seller;\n', '        _cancelSale(_tokenId, seller);\n', '    }\n', '\n', '    /** \n', '     * @dev    Returns sales info for an CSLCollectibles (ERC721) on sale.\n', '     * @notice Fetches the details related to the Sale\n', '     * @param  _tokenId    ID of the token on sale\n', '     */\n', '    function getSale(uint256 _tokenId) external view returns (address seller, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt, uint256[9] tokenIds) {\n', '        Sale memory sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        return (\n', '            sale.seller,\n', '            sale.startingPrice,\n', '            sale.endingPrice,\n', '            sale.duration,\n', '            sale.startedAt,\n', '            sale.tokenIds\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Returns the current price of an sale.\n', '     * @param      _tokenId  The token identifier\n', '     */\n', '    function getCurrentPrice(uint256 _tokenId) external view returns (uint256) {\n', '        Sale memory sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        return _currentPrice(sale);\n', '    }\n', '\n', '    /** @dev Calculates the new price for Sale Item\n', '     * @param   _saleType     Sale Type Identifier (0 - Single Sale, 1 - Team Sale)\n', '     * @param   _teamId       Team Identifier\n', '     */\n', '    function _averageSalePrice(uint256 _saleType, uint256 _teamId) internal view returns (uint256) {\n', '        uint256 _price = 0;\n', '        if(_saleType == 0) {\n', '            for(uint256 ii = 0; ii < 10; ii++) {\n', '                _price = _price.add(lastSingleSalePrices[ii]);\n', '            }\n', '            _price = _price.mul(SINGLE_SALE_MULTIPLIER).div(100);\n', '        } else {\n', '            for (uint256 i = 0; i < 3; i++) {\n', '                _price = _price.add(lastTeamSalePrices[_teamId][i]);\n', '            }\n', '        \n', '            _price = _price.mul(TEAM_SALE_MULTIPLIER).div(30);\n', '            _price = _price.mul(9);\n', '        }\n', '\n', '        return _price;\n', '    }\n', '    \n', '    /**\n', '     * @dev        Put a Collectible up for sale. Does some ownership trickery to create sale in one tx.\n', '     * @param      _tokenId        The token identifier\n', '     * @param      _startingPrice  The starting price\n', '     * @param      _endingPrice    The ending price\n', '     * @param      _duration       The duration\n', '     * @param      _owner          Owner of the token\n', '     */\n', '    function createSale(uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration, address _owner) external whenNotPaused {\n', '        require(msg.sender == address(nonFungibleContract));\n', '\n', '        // Check whether the collectible is inPlay. If inPlay cant put it on Sale\n', '        require(nonFungibleContract.checkIsAttached(_tokenId) == 0);\n', '        \n', '        _escrow(_owner, _tokenId);\n', '\n', '        // Sale throws if inputs are invalid and clears\n', '        // transfer and sire approval after escrowing the CSLCollectible.\n', '        _createSale(\n', '            _tokenId,\n', '            _startingPrice,\n', '            _endingPrice,\n', '            _duration,\n', '            _owner\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Put a Collectible up for sale. Only callable, if user approved contract for 1/All Collectibles\n', '     * @param      _tokenId        The token identifier\n', '     * @param      _startingPrice  The starting price\n', '     * @param      _endingPrice    The ending price\n', '     * @param      _duration       The duration\n', '     */\n', '    function userCreateSaleIfApproved (uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration) external whenNotPaused {\n', '        \n', '        require(nonFungibleContract.getApproved(_tokenId) == address(this) || nonFungibleContract.isApprovedForAll(msg.sender, address(this)));\n', '        \n', '        // Check whether the collectible is inPlay. If inPlay cant put it on Sale\n', '        require(nonFungibleContract.checkIsAttached(_tokenId) == 0);\n', '        \n', '        _escrow(msg.sender, _tokenId);\n', '\n', '        // Sale throws if inputs are invalid and clears\n', '        // transfer and sire approval after escrowing the CSLCollectible.\n', '        _createSale(\n', '            _tokenId,\n', '            _startingPrice,\n', '            _endingPrice,\n', '            _duration,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /** \n', '     * @dev        Transfers the balance of the sales manager contract to the CSLCollectible contract. We use two-step withdrawal to\n', '     *              prevent two transfer calls in the sale bid function.\n', '     */\n', '    function withdrawSaleManagerBalances() public onlyBanker {\n', '        _withdrawBalance();\n', '    }\n', '\n', '    /** \n', '     *  @dev Function to chnage the OwnerCut only accessible by the Owner of the contract\n', '     *  @param _newCut - Sets the ownerCut to new value\n', '     */\n', '    function setOwnerCut(uint256 _newCut) external onlyBanker {\n', '        require(_newCut <= 10000);\n', '        ownerCut = _newCut;\n', '    }\n', '    \n', '    /**\n', '     * @dev        Facilitates seed collectible auction creation. Enforces strict check on the data being passed\n', '     * @notice     Creates a new Collectible and creates an auction for it.\n', '     * @param      _teamId            The team identifier\n', '     * @param      _posId             The position identifier\n', '     * @param      _attributes        The attributes\n', '     * @param      _playerOverrideId  The player override identifier\n', '     * @param      _mlbPlayerId       The mlb player identifier\n', '     * @param      _startPrice        The start price\n', '     * @param      _endPrice          The end price\n', '     * @param      _saleDuration      The sale duration\n', '     */\n', '    function createSingleSeedAuction(\n', '        uint8 _teamId,\n', '        uint8 _posId,\n', '        uint256 _attributes,\n', '        uint256 _playerOverrideId,\n', '        uint256 _mlbPlayerId,\n', '        uint256 _startPrice,\n', '        uint256 _endPrice,\n', '        uint256 _saleDuration)\n', '        public\n', '        onlyGameManager\n', '        whenNotPaused {\n', '        // Check to see the NFT address is not 0\n', '        require(nonFungibleContract != address(0));\n', '        require(_teamId != 0);\n', '\n', '        uint256 nftId = nonFungibleContract.createSeedCollectible(_teamId,_posId,_attributes,address(this),0, _playerOverrideId, _mlbPlayerId);\n', '\n', '        uint256 startPrice = 0;\n', '        uint256 endPrice = 0;\n', '        uint256 duration = 0;\n', '        \n', '        if(_startPrice == 0) {\n', '            startPrice = _computeNextSeedPrice(0, _teamId);\n', '        } else {\n', '            startPrice = _startPrice;\n', '        }\n', '\n', '        if(_endPrice != 0) {\n', '            endPrice = _endPrice;\n', '        } else {\n', '            endPrice = 0;\n', '        }\n', '\n', '        if(_saleDuration == 0) {\n', '            duration = SALES_DURATION;\n', '        } else {\n', '            duration = _saleDuration;\n', '        }\n', '\n', '        _createSale(\n', '            nftId,\n', '            startPrice,\n', '            endPrice,\n', '            duration,\n', '            address(this)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Facilitates promo collectible auction creation. Enforces strict check on the data being passed\n', '     * @notice     Creates a new Collectible and creates an auction for it.\n', '     * @param      _teamId            The team identifier\n', '     * @param      _posId             The position identifier\n', '     * @param      _attributes        The attributes\n', '     * @param      _playerOverrideId  The player override identifier\n', '     * @param      _mlbPlayerId       The mlb player identifier\n', '     * @param      _startPrice        The start price\n', '     * @param      _endPrice          The end price\n', '     * @param      _saleDuration      The sale duration\n', '     */\n', '    function createPromoSeedAuction(\n', '        uint8 _teamId,\n', '        uint8 _posId,\n', '        uint256 _attributes,\n', '        uint256 _playerOverrideId,\n', '        uint256 _mlbPlayerId,\n', '        uint256 _startPrice,\n', '        uint256 _endPrice,\n', '        uint256 _saleDuration)\n', '        public\n', '        onlyGameManager\n', '        whenNotPaused {\n', '        // Check to see the NFT address is not 0\n', '        require(nonFungibleContract != address(0));\n', '        require(_teamId != 0);\n', '\n', '        uint256 nftId = nonFungibleContract.createPromoCollectible(_teamId, _posId, _attributes, address(this), 0, _playerOverrideId, _mlbPlayerId);\n', '\n', '        uint256 startPrice = 0;\n', '        uint256 endPrice = 0;\n', '        uint256 duration = 0;\n', '        \n', '        if(_startPrice == 0) {\n', '            startPrice = _computeNextSeedPrice(0, _teamId);\n', '        } else {\n', '            startPrice = _startPrice;\n', '        }\n', '\n', '        if(_endPrice != 0) {\n', '            endPrice = _endPrice;\n', '        } else {\n', '            endPrice = 0;\n', '        }\n', '\n', '        if(_saleDuration == 0) {\n', '            duration = SALES_DURATION;\n', '        } else {\n', '            duration = _saleDuration;\n', '        }\n', '\n', '        _createSale(\n', '            nftId,\n', '            startPrice,\n', '            endPrice,\n', '            duration,\n', '            address(this)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Creates Team Sale Auction\n', '     * @param      _teamId        The team identifier\n', '     * @param      _tokenIds      The token identifiers\n', '     * @param      _startPrice    The start price\n', '     * @param      _endPrice      The end price\n', '     * @param      _saleDuration  The sale duration\n', '     */\n', '    function createTeamSaleAuction(\n', '        uint8 _teamId,\n', '        uint256[9] _tokenIds,\n', '        uint256 _startPrice,\n', '        uint256 _endPrice,\n', '        uint256 _saleDuration)\n', '        public\n', '        onlyGameManager\n', '        whenNotPaused {\n', '\n', '        require(_teamId != 0);\n', '\n', '        // Helps in not creating sale with wrong team and player combination\n', '        for(uint ii = 0; ii < _tokenIds.length; ii++){\n', '            require(nonFungibleContract.getTeamId(_tokenIds[ii]) == _teamId);\n', '        }\n', '        \n', '        uint256 startPrice = 0;\n', '        uint256 endPrice = 0;\n', '        uint256 duration = 0;\n', '        \n', '        if(_startPrice == 0) {\n', '            startPrice = _computeNextSeedPrice(1, _teamId).mul(9);\n', '        } else {\n', '            startPrice = _startPrice;\n', '        }\n', '\n', '        if(_endPrice != 0) {\n', '            endPrice = _endPrice;\n', '        } else {\n', '            endPrice = 0;\n', '        }\n', '\n', '        if(_saleDuration == 0) {\n', '            duration = SALES_DURATION;\n', '        } else {\n', '            duration = _saleDuration;\n', '        }\n', '\n', '        _createTeamSale(\n', '            _tokenIds,\n', '            startPrice,\n', '            endPrice,\n', '            duration,\n', '            address(this)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev        Computes the next auction starting price\n', '     * @param      _saleType     The sale type\n', '     * @param      _teamId       The team identifier\n', '     */\n', '    function _computeNextSeedPrice(uint256 _saleType, uint256 _teamId) internal view returns (uint256) {\n', '        uint256 nextPrice = _averageSalePrice(_saleType, _teamId);\n', '\n', "        // Sanity check to ensure we don't overflow arithmetic\n", '        require(nextPrice == nextPrice);\n', '\n', '        // We never auction for less than starting price\n', '        if (nextPrice < STARTING_PRICE) {\n', '            nextPrice = STARTING_PRICE;\n', '        }\n', '\n', '        return nextPrice;\n', '    }\n', '\n', '    /**\n', '     * @dev        Sanity check that allows us to ensure that we are pointing to the right sale call.\n', '     */\n', '    bool public isSalesManager = true;\n', '\n', '    /**\n', '     * @dev        works the same as default bid method.\n', '     * @param      _tokenId  The token identifier\n', '     */\n', '    function bid(uint256 _tokenId) public whenNotPaused payable {\n', '        \n', '        Sale memory sale = tokenIdToSale[_tokenId];\n', '        address seller = sale.seller;\n', '\n', '        // This check is added to give all users a level playing field to think & bid on the player\n', '        require (now > sale.startedAt.add(BID_DELAY_TIME));\n', '        \n', '        uint256 price = _bid(_tokenId, msg.value);\n', '\n', '        //If multi token sale\n', '        if(sale.tokenIds[1] > 0) {\n', '            \n', '            for (uint256 i = 0; i < 9; i++) {\n', '                _transfer(address(this), msg.sender, sale.tokenIds[i]);\n', '            }\n', '\n', '            // Avg price\n', '            price = price.div(9);\n', '        } else {\n', '            \n', '            _transfer(address(this), msg.sender, _tokenId);\n', '        }\n', '        \n', '        // If not a seed, exit\n', '        if (seller == address(this)) {\n', '            if(sale.tokenIds[1] > 0){\n', '                uint256 _teamId = nonFungibleContract.getTeamId(_tokenId);\n', '\n', '                lastTeamSalePrices[_teamId][seedTeamSaleCount[_teamId] % 3] = price;\n', '\n', '                seedTeamSaleCount[_teamId]++;\n', '            } else {\n', '                lastSingleSalePrices[seedSingleSaleCount % 10] = price;\n', '                seedSingleSaleCount++;\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev        Sets the address for the NFT Contract\n', '     * @param      _nftAddress  The nft address\n', '     */\n', '    function setNFTContractAddress(address _nftAddress) public onlyGameManager {\n', '        require (_nftAddress != address(0));        \n', '        nonFungibleContract = MLBNFT(_nftAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev        Added this module to allow retrieve of accidental asset transfer to contract\n', '     * @param      _to       { parameter_description }\n', '     * @param      _tokenId  The token identifier\n', '     */\n', '    function assetTransfer(address _to, uint256 _tokenId) public onlyGameManager {\n', '        require(_tokenId != 0);\n', '        nonFungibleContract.transferFrom(address(this), _to, _tokenId);\n', '    }\n', '\n', '     /**\n', '     * @dev        Added this module to allow retrieve of accidental asset transfer to contract\n', '     * @param      _to       { parameter_description }\n', '     * @param      _tokenIds  The token identifiers\n', '     */\n', '    function batchAssetTransfer(address _to, uint256[] _tokenIds) public onlyGameManager {\n', '        require(isBatchSupported);\n', '        require (_tokenIds.length > 0);\n', '        \n', '        for(uint i = 0; i < _tokenIds.length; i++){\n', '            require(_tokenIds[i] != 0);\n', '            nonFungibleContract.transferFrom(address(this), _to, _tokenIds[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev        Creates new Seed Team Collectibles\n', '     * @notice     Creates a team and transfers all minted assets to SaleManager\n', '     * @param      _teamId       The team identifier\n', '     * @param      _attributes   The attributes\n', '     * @param      _mlbPlayerId  The mlb player identifier\n', '     */\n', '    function createSeedTeam(uint8 _teamId, uint256[9] _attributes, uint256[9] _mlbPlayerId) public onlyGameManager whenNotPaused {\n', '        require(_teamId != 0);\n', '        \n', '        for(uint ii = 0; ii < 9; ii++) {\n', '            nonFungibleContract.createSeedCollectible(_teamId, uint8(ii.add(1)), _attributes[ii], address(this), 0, 0, _mlbPlayerId[ii]);\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @dev            Cancels an sale that hasn't been won yet. Returns the MLBNFT (ERC721) to original owner.\n", '     * @notice         This is a state-modifying function that can be called while the contract is paused.\n', '     */\n', '    function batchCancelSale(uint256[] _tokenIds) external whenNotPaused {\n', '        require(isBatchSupported);\n', '        require(_tokenIds.length > 0);\n', '\n', '        for(uint ii = 0; ii < _tokenIds.length; ii++){\n', '            Sale memory sale = tokenIdToSale[_tokenIds[ii]];\n', '            require(_isOnSale(sale));\n', '            \n', '            address seller = sale.seller;\n', '            require(msg.sender == seller);\n', '\n', '            _cancelSale(_tokenIds[ii], seller);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev        Helps to toggle batch supported flag\n', '     * @param      _flag  The flag\n', '     */\n', '    function updateBatchSupport(bool _flag) public onlyGameManager {\n', '        isBatchSupported = _flag;\n', '    }\n', '\n', '    /**\n', '     * @dev        Batching Operation: Creates a new Collectible and creates an auction for it.\n', '     * @notice     Helps in creating single seed auctions in batches\n', '     * @param      _teamIds            The team identifier\n', '     * @param      _posIds            The position identifier\n', '     * @param      _attributes        The attributes\n', '     * @param      _playerOverrideIds  The player override identifier\n', '     * @param      _mlbPlayerIds       The mlb player identifier\n', '     * @param      _startPrice         The start price\n', '     */\n', '    function batchCreateSingleSeedAuction(\n', '        uint8[] _teamIds,\n', '        uint8[] _posIds,\n', '        uint256[] _attributes,\n', '        uint256[] _playerOverrideIds,\n', '        uint256[] _mlbPlayerIds,\n', '        uint256 _startPrice)\n', '        public\n', '        onlyGameManager\n', '        whenNotPaused {\n', '\n', '        require (isBatchSupported);\n', '\n', '        require (_teamIds.length > 0 &&\n', '            _posIds.length > 0 &&\n', '            _attributes.length > 0 &&\n', '            _playerOverrideIds.length > 0 &&\n', '            _mlbPlayerIds.length > 0 );\n', '        \n', '        // Check to see the NFT address is not 0\n', '        require(nonFungibleContract != address(0));\n', '        \n', '        uint256 nftId;\n', '\n', '        require (_startPrice != 0);\n', '\n', '        for(uint ii = 0; ii < _mlbPlayerIds.length; ii++){\n', '            require(_teamIds[ii] != 0);\n', '\n', '            nftId = nonFungibleContract.createSeedCollectible(\n', '                        _teamIds[ii],\n', '                        _posIds[ii],\n', '                        _attributes[ii],\n', '                        address(this),\n', '                        0,\n', '                        _playerOverrideIds[ii],\n', '                        _mlbPlayerIds[ii]);\n', '\n', '            _createSale(\n', '                nftId,\n', '                _startPrice,\n', '                0,\n', '                SALES_DURATION,\n', '                address(this)\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev        Helps in incrementing the delay time to start bidding for any auctions\n', '     * @notice     Function helps to update the delay time for bidding\n', '     * @param      _newDelay       The new Delay time\n', '     */\n', '    function updateDelayTime(uint256 _newDelay) public onlyGameManager whenNotPaused {\n', '\n', '        BID_DELAY_TIME = _newDelay;\n', '    }\n', '\n', '    function bidTransfer(uint256 _tokenId, address _buyer, uint256 _bidAmount) public canTransact {\n', '\n', '        Sale memory sale = tokenIdToSale[_tokenId];\n', '        address seller = sale.seller;\n', '\n', '        // This check is added to give all users a level playing field to think & bid on the player\n', '        require (now > sale.startedAt.add(BID_DELAY_TIME));\n', '        \n', '        uint256[9] memory tokenIdsStore = tokenIdToSale[_tokenId].tokenIds;\n', '        \n', '        // Explicitly check that this sale is currently live.\n', '        require(_isOnSale(sale));\n', '\n', '        // Check that the bid is greater than or equal to the current price\n', '        uint256 price = _currentPrice(sale);\n', '        require(_bidAmount >= price);\n', '\n', '        // The bid is good! Remove the sale before sending the fees\n', "        // to the sender so we can't have a reentrancy attack.\n", '        if(tokenIdsStore[1] > 0) {\n', '            for(uint ii = 0; ii < 9; ii++) {\n', '                _removeSale(tokenIdsStore[ii]);\n', '            }\n', '        } else {\n', '            _removeSale(_tokenId);\n', '        }\n', '\n', '        uint256 marketsCut = 0;\n', '        uint256 sellerProceeds = 0;\n', '\n', '        // Transfer proceeds to seller (if there are any!)\n', '        if (price > 0) {\n', "            // Calculate the marketplace's cut.\n", '            // (NOTE: _computeCut() is guaranteed to return a\n', '            // value <= price)\n', '            marketsCut = _computeCut(price);\n', '            sellerProceeds = price.sub(marketsCut);\n', '        }\n', '\n', '        //escrowTransfer(address seller, address buyer, uint256 currentPrice) public returns(bool);\n', '        require (LSEscrowContract.escrowTransfer(seller, _buyer, sellerProceeds, marketsCut));\n', '        \n', '        // Tell the world!\n', '        // uint256 assetID, uint256 totalPrice, address winner, uint16 generation\n', '        if(tokenIdsStore[1] > 0) {\n', '            emit TeamSaleWinner(tokenIdsStore, price, _buyer);\n', '        } else {\n', '            emit SaleWinner(_tokenId, price, _buyer);\n', '        }\n', '\n', '        //If multi token sale\n', '        if(sale.tokenIds[1] > 0) {\n', '            \n', '            for (uint256 i = 0; i < 9; i++) {\n', '                _transfer(address(this), _buyer, sale.tokenIds[i]);\n', '            }\n', '\n', '            // Avg price\n', '            price = price.div(9);\n', '        } else {\n', '            \n', '            _transfer(address(this), _buyer, _tokenId);\n', '        }\n', '        \n', '        // If not a seed, exit\n', '        if (seller == address(this)) {\n', '            if(sale.tokenIds[1] > 0) {\n', '                uint256 _teamId = nonFungibleContract.getTeamId(_tokenId);\n', '\n', '                lastTeamSalePrices[_teamId][seedTeamSaleCount[_teamId] % 3] = price;\n', '\n', '                seedTeamSaleCount[_teamId]++;\n', '            } else {\n', '                lastSingleSalePrices[seedSingleSaleCount % 10] = price;\n', '                seedSingleSaleCount++;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev        Sets the address for the LS Escrow Contract\n', '     * @param      _lsEscrowAddress  The nft address\n', '     */\n', '    function setLSEscrowContractAddress(address _lsEscrowAddress) public onlyGameManager {\n', '        require (_lsEscrowAddress != address(0));        \n', '        LSEscrowContract = LSEscrow(_lsEscrowAddress);\n', '    }\n', '}']
