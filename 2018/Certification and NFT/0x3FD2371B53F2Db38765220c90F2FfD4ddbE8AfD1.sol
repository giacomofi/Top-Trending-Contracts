['pragma solidity ^0.4.23;\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Contactable.sol\n', '\n', '/**\n', ' * @title Contactable token\n', ' * @dev Basic version of a contactable contract, allowing the owner to provide a string with their\n', ' * contact information.\n', ' */\n', 'contract Contactable is Ownable{\n', '\n', '    string public contactInformation;\n', '\n', '    /**\n', '     * @dev Allows the owner to set a string with their contact information.\n', '     * @param info The contact information to attach to the contract.\n', '     */\n', '    function setContactInformation(string info) onlyOwner public {\n', '         contactInformation = info;\n', '     }\n', '}\n', '\n', '// File: contracts/MonethaUsersClaimStorage.sol\n', '\n', '/**\n', ' *  @title MonethaUsersClaimStorage\n', ' *\n', ' *  MonethaUsersClaimStorage is a storage contract. \n', ' *  It will be used by MonethaUsersClaimHandler to update and delete user claim. \n', ' */\n', 'contract MonethaUsersClaimStorage is Contactable {\n', '\n', '    string constant VERSION = "0.1";\n', '    \n', '    // claimedTokens stores tokens claimed by the user.\n', '    mapping (address => uint256) public claimedTokens;\n', '\n', '    event UpdatedClaim(address indexed _userAddress, uint256 _claimedTokens, bool _isDeleted);\n', '    event DeletedClaim(address indexed _userAddress, uint256 _unclaimedTokens, bool _isDeleted);\n', '\n', '    /**\n', '     *  updateUserClaim updates user claim status and adds token to his wallet\n', "     *  @param _userAddress address of user's wallet\n", "     *  @param _tokens corresponds to user's token that is to be claimed.\n", '     */\n', '    function updateUserClaim(address _userAddress, uint256 _tokens)\n', '        external onlyOwner returns (bool)\n', '    {\n', '        claimedTokens[_userAddress] = claimedTokens[_userAddress] + _tokens;\n', '\n', '        emit UpdatedClaim(_userAddress, _tokens, false);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     *  updateUserClaimInBulk updates multiple users claim status and adds token to their wallet\n', '     */\n', '    function updateUserClaimInBulk(address[] _userAddresses, uint256[] _tokens)\n', '        external onlyOwner returns (bool)\n', '    {\n', '        require(_userAddresses.length == _tokens.length);\n', '\n', '        for (uint16 i = 0; i < _userAddresses.length; i++) {\n', '            claimedTokens[_userAddresses[i]] = claimedTokens[_userAddresses[i]] + _tokens[i];\n', '\n', '            emit UpdatedClaim(_userAddresses[i], _tokens[i], false);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  deleteUserClaim deletes user account\n', "     *  @param _userAddress corresponds to address of user's wallet\n", '     */\n', '    function deleteUserClaim(address _userAddress)\n', '        external onlyOwner returns (bool)\n', '    {\n', '        delete claimedTokens[_userAddress];\n', '\n', '        emit DeletedClaim(_userAddress, 0, true);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  deleteUserClaimInBulk deletes user account in bulk\n', '     */\n', '    function deleteUserClaimInBulk(address[] _userAddresses)\n', '        external onlyOwner returns (bool)\n', '    {\n', '        for (uint16 i = 0; i < _userAddresses.length; i++) {\n', '            delete claimedTokens[_userAddresses[i]];\n', '\n', '            emit DeletedClaim(_userAddresses[i], 0, true);\n', '        }\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/MonethaUsersClaimHandler.sol\n', '\n', '/**\n', ' *  @title MonethaUsersClaimHandler\n', ' *\n', ' *  MonethaUsersClaimHandler contract is a calling contract,\n', ' *  which is used to update the storage contract MonethaUsersClaimStorage.\n', ' */\n', 'contract MonethaUsersClaimHandler is Contactable {\n', '\n', '    string constant VERSION = "0.1";\n', '    \n', '    MonethaUsersClaimStorage public storageContract;\n', '\n', '    event StorageContractOwnerChanged(address indexed _newOwner);\n', '\n', '    constructor(address _storageAddr) public {\n', '        storageContract = MonethaUsersClaimStorage(_storageAddr);\n', '    }\n', '\n', '    /**\n', "     *  claimTokens calls updateUserClaim function of MonethaUsersClaimStorage contract to update user's token claim status and assign tokens to user.\n", "     *  @param _monethaUser address of user's wallet\n", "     *  @param _tokens corresponds to user's token that is to be claimed.\n", '     */\n', '    function claimTokens(address _monethaUser, uint256 _tokens) external onlyOwner {\n', '        require(storageContract.updateUserClaim(_monethaUser, _tokens));\n', '    }\n', '\n', '    /**\n', '     *  claimTokensInBulk calls updateUserClaim function of MonethaUsersClaimStorage contract to update multiple users token claim status and assign tokens to user.\n', '     */\n', '    function claimTokensInBulk(address[] _monethaUsers, uint256[] _tokens) external onlyOwner {\n', '        require(storageContract.updateUserClaimInBulk(_monethaUsers, _tokens));\n', '    }\n', '\n', '    /**\n', "     *  deleteAccount deletes user's claimed token\n", '     *  @param _monethaUser address of users wallet\n', '     */\n', '    function deleteAccount(address _monethaUser) external onlyOwner {\n', '        require(storageContract.deleteUserClaim(_monethaUser));\n', '    }\n', '\n', '    /**\n', '     *  deleteAccountsInBulk deletes user account in bulk.\n', '     */\n', '    function deleteAccountsInBulk(address[] _monethaUsers) external onlyOwner {\n', '        require(storageContract.deleteUserClaimInBulk(_monethaUsers));\n', '    }\n', '\n', '    /**\n', '     *  changeOwnerOfMonethaUsersClaimStorage changes ownership\n', '     *  @param _newOwner address of new owner\n', '     */\n', '    function changeOwnerOfMonethaUsersClaimStorage(address _newOwner) external onlyOwner {\n', '        storageContract.transferOwnership(_newOwner);\n', '\n', '        emit StorageContractOwnerChanged(_newOwner);\n', '    }\n', '}']