['//v1.0.14\n', '//License: Apache2.0\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract TokenSpender {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\n', '}\n', '\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' * last open zepplin version used for : add sub mul div function : https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', '* commit : https://github.com/OpenZeppelin/zeppelin-solidity/commit/815d9e1f457f57cfbb1b4e889f2255c9a517f661\n', ' */\n', 'library SafeMathOZ\n', '{\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tuint256 c = a + b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tif (a == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\tuint256 c = a * b;\n', '\t\tassert(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t\tuint256 c = a / b;\n', '\t\t// assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction max(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn a >= b ? a : b;\n', '\t}\n', '\n', '\tfunction min(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn a < b ? a : b;\n', '\t}\n', '\n', '\tfunction mulByFraction(uint256 a, uint256 b, uint256 c) internal pure returns (uint256)\n', '\t{\n', '\t\treturn div(mul(a, b), c);\n', '\t}\n', '\n', '\tfunction percentage(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn mulByFraction(a, b, 100);\n', '\t}\n', '\t// Source : https://ethereum.stackexchange.com/questions/8086/logarithm-math-operation-in-solidity\n', '\tfunction log(uint x) internal pure returns (uint y)\n', '\t{\n', '\t\tassembly\n', '\t\t{\n', '\t\t\tlet arg := x\n', '\t\t\tx := sub(x,1)\n', '\t\t\tx := or(x, div(x, 0x02))\n', '\t\t\tx := or(x, div(x, 0x04))\n', '\t\t\tx := or(x, div(x, 0x10))\n', '\t\t\tx := or(x, div(x, 0x100))\n', '\t\t\tx := or(x, div(x, 0x10000))\n', '\t\t\tx := or(x, div(x, 0x100000000))\n', '\t\t\tx := or(x, div(x, 0x10000000000000000))\n', '\t\t\tx := or(x, div(x, 0x100000000000000000000000000000000))\n', '\t\t\tx := add(x, 1)\n', '\t\t\tlet m := mload(0x40)\n', '\t\t\tmstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\n', '\t\t\tmstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\n', '\t\t\tmstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\n', '\t\t\tmstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\n', '\t\t\tmstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\n', '\t\t\tmstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\n', '\t\t\tmstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\n', '\t\t\tmstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\n', '\t\t\tmstore(0x40, add(m, 0x100))\n', '\t\t\tlet magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\n', '\t\t\tlet shift := 0x100000000000000000000000000000000000000000000000000000000000000\n', '\t\t\tlet a := div(mul(x, magic), shift)\n', '\t\t\ty := div(mload(add(m,sub(255,a))), shift)\n', '\t\t\ty := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\n', '\t\t}\n', '\t}\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender == owner)\n', '      _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract OwnableOZ\n', '{\n', '\taddress public m_owner;\n', '\tbool    public m_changeable;\n', '\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\t/**\n', '\t * @dev Throws if called by any account other than the owner.\n', '\t */\n', '\tmodifier onlyOwner()\n', '\t{\n', '\t\trequire(msg.sender == m_owner);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '\t * account.\n', '\t */\n', '\tfunction OwnableOZ() public\n', '\t{\n', '\t\tm_owner      = msg.sender;\n', '\t\tm_changeable = true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '\t * @param _newOwner The address to transfer ownership to.\n', '\t */\n', '\tfunction setImmutableOwnership(address _newOwner) public onlyOwner\n', '\t{\n', '\t\trequire(m_changeable);\n', '\t\trequire(_newOwner != address(0));\n', '\t\temit OwnershipTransferred(m_owner, _newOwner);\n', '\t\tm_owner      = _newOwner;\n', '\t\tm_changeable = false;\n', '\t}\n', '\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract RLC is ERC20, SafeMath, Ownable {\n', '\n', '    /* Public variables of the token */\n', '  string public name;       //fancy name\n', '  string public symbol;\n', '  uint8 public decimals;    //How many decimals to show.\n', '  string public version = &#39;v0.1&#39;;\n', '  uint public initialSupply;\n', '  uint public totalSupply;\n', '  bool public locked;\n', '  //uint public unlockBlock;\n', '\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  // lock transfer during the ICO\n', '  modifier onlyUnlocked() {\n', '    if (msg.sender != owner && locked) throw;\n', '    _;\n', '  }\n', '\n', '  /*\n', '   *  The RLC Token created with the time at which the crowdsale end\n', '   */\n', '\n', '  function RLC() {\n', '    // lock the transfer function during the crowdsale\n', '    locked = true;\n', '    //unlockBlock=  now + 45 days; // (testnet) - for mainnet put the block number\n', '\n', '    initialSupply = 87000000000000000;\n', '    totalSupply = initialSupply;\n', '    balances[msg.sender] = initialSupply;// Give the creator all initial tokens\n', '    name = &#39;iEx.ec Network Token&#39;;        // Set the name for display purposes\n', '    symbol = &#39;RLC&#39;;                       // Set the symbol for display purposes\n', '    decimals = 9;                        // Amount of decimals for display purposes\n', '  }\n', '\n', '  function unlock() onlyOwner {\n', '    locked = false;\n', '  }\n', '\n', '  function burn(uint256 _value) returns (bool){\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value) ;\n', '    totalSupply = safeSub(totalSupply, _value);\n', '    Transfer(msg.sender, 0x0, _value);\n', '    return true;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) onlyUnlocked returns (bool) {\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) onlyUnlocked returns (bool) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '    /* Approve and then comunicate the approved contract in a single tx */\n', '  function approveAndCall(address _spender, uint256 _value, bytes _extraData){\n', '      TokenSpender spender = TokenSpender(_spender);\n', '      if (approve(_spender, _value)) {\n', '          spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '      }\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'library IexecLib\n', '{\n', '\t/***************************************************************************/\n', '\t/*                              Market Order                               */\n', '\t/***************************************************************************/\n', '\tenum MarketOrderDirectionEnum\n', '\t{\n', '\t\tUNSET,\n', '\t\tBID,\n', '\t\tASK,\n', '\t\tCLOSED\n', '\t}\n', '\tstruct MarketOrder\n', '\t{\n', '\t\tMarketOrderDirectionEnum direction;\n', '\t\tuint256 category;        // runtime selection\n', '\t\tuint256 trust;           // for PoCo\n', '\t\tuint256 value;           // value/cost/price\n', '\t\tuint256 volume;          // quantity of instances (total)\n', '\t\tuint256 remaining;       // remaining instances\n', '\t\taddress workerpool;      // BID can use null for any\n', '\t\taddress workerpoolOwner; // fix ownership if workerpool ownership change during the workorder steps\n', '\t}\n', '\n', '\t/***************************************************************************/\n', '\t/*                               Work Order                                */\n', '\t/***************************************************************************/\n', '\tenum WorkOrderStatusEnum\n', '\t{\n', '\t\tUNSET,     // Work order not yet initialized (invalid address)\n', '\t\tACTIVE,    // Marketed → constributions are open\n', '\t\tREVEALING, // Starting consensus reveal\n', '\t\tCLAIMED,   // failed consensus\n', '\t\tCOMPLETED  // Concensus achieved\n', '\t}\n', '\n', '\t/***************************************************************************/\n', '\t/*                                Consensus                                */\n', '\t/*                                   ---                                   */\n', '\t/*                         used in WorkerPool.sol                          */\n', '\t/***************************************************************************/\n', '\tstruct Consensus\n', '\t{\n', '\t\tuint256 poolReward;\n', '\t\tuint256 stakeAmount;\n', '\t\tbytes32 consensus;\n', '\t\tuint256 revealDate;\n', '\t\tuint256 revealCounter;\n', '\t\tuint256 consensusTimeout;\n', '\t\tuint256 winnerCount;\n', '\t\taddress[] contributors;\n', '\t\taddress workerpoolOwner;\n', '\t\tuint256 schedulerRewardRatioPolicy;\n', '\n', '\t}\n', '\n', '\t/***************************************************************************/\n', '\t/*                              Contribution                               */\n', '\t/*                                   ---                                   */\n', '\t/*                         used in WorkerPool.sol                          */\n', '\t/***************************************************************************/\n', '\tenum ContributionStatusEnum\n', '\t{\n', '\t\tUNSET,\n', '\t\tAUTHORIZED,\n', '\t\tCONTRIBUTED,\n', '\t\tPROVED,\n', '\t\tREJECTED\n', '\t}\n', '\tstruct Contribution\n', '\t{\n', '\t\tContributionStatusEnum status;\n', '\t\tbytes32 resultHash;\n', '\t\tbytes32 resultSign;\n', '\t\taddress enclaveChallenge;\n', '\t\tuint256 score;\n', '\t\tuint256 weight;\n', '\t}\n', '\n', '\t/***************************************************************************/\n', '\t/*                Account / ContributionHistory / Category                 */\n', '\t/*                                   ---                                   */\n', '\t/*                          used in IexecHub.sol                           */\n', '\t/***************************************************************************/\n', '\tstruct Account\n', '\t{\n', '\t\tuint256 stake;\n', '\t\tuint256 locked;\n', '\t}\n', '\n', '\tstruct ContributionHistory // for credibility computation, f = failed/total\n', '\t{\n', '\t\tuint256 success;\n', '\t\tuint256 failed;\n', '\t}\n', '\n', '\tstruct Category\n', '\t{\n', '\t\tuint256 catid;\n', '\t\tstring  name;\n', '\t\tstring  description;\n', '\t\tuint256 workClockTimeRef;\n', '\t}\n', '\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract IexecHubInterface\n', '{\n', '\tRLC public rlc;\n', '\n', '\tfunction attachContracts(\n', '\t\taddress _tokenAddress,\n', '\t\taddress _marketplaceAddress,\n', '\t\taddress _workerPoolHubAddress,\n', '\t\taddress _appHubAddress,\n', '\t\taddress _datasetHubAddress)\n', '\t\tpublic;\n', '\n', '\tfunction setCategoriesCreator(\n', '\t\taddress _categoriesCreator)\n', '\tpublic;\n', '\n', '\tfunction createCategory(\n', '\t\tstring  _name,\n', '\t\tstring  _description,\n', '\t\tuint256 _workClockTimeRef)\n', '\tpublic returns (uint256 catid);\n', '\n', '\tfunction createWorkerPool(\n', '\t\tstring  _description,\n', '\t\tuint256 _subscriptionLockStakePolicy,\n', '\t\tuint256 _subscriptionMinimumStakePolicy,\n', '\t\tuint256 _subscriptionMinimumScorePolicy)\n', '\texternal returns (address createdWorkerPool);\n', '\n', '\tfunction createApp(\n', '\t\tstring  _appName,\n', '\t\tuint256 _appPrice,\n', '\t\tstring  _appParams)\n', '\texternal returns (address createdApp);\n', '\n', '\tfunction createDataset(\n', '\t\tstring  _datasetName,\n', '\t\tuint256 _datasetPrice,\n', '\t\tstring  _datasetParams)\n', '\texternal returns (address createdDataset);\n', '\n', '\tfunction buyForWorkOrder(\n', '\t\tuint256 _marketorderIdx,\n', '\t\taddress _workerpool,\n', '\t\taddress _app,\n', '\t\taddress _dataset,\n', '\t\tstring  _params,\n', '\t\taddress _callback,\n', '\t\taddress _beneficiary)\n', '\texternal returns (address);\n', '\n', '\tfunction isWoidRegistred(\n', '\t\taddress _woid)\n', '\tpublic view returns (bool);\n', '\n', '\tfunction lockWorkOrderCost(\n', '\t\taddress _requester,\n', '\t\taddress _workerpool, // Address of a smartcontract\n', '\t\taddress _app,        // Address of a smartcontract\n', '\t\taddress _dataset)    // Address of a smartcontract\n', '\tinternal returns (uint256);\n', '\n', '\tfunction claimFailedConsensus(\n', '\t\taddress _woid)\n', '\tpublic returns (bool);\n', '\n', '\tfunction finalizeWorkOrder(\n', '\t\taddress _woid,\n', '\t\tstring  _stdout,\n', '\t\tstring  _stderr,\n', '\t\tstring  _uri)\n', '\tpublic returns (bool);\n', '\n', '\tfunction getCategoryWorkClockTimeRef(\n', '\t\tuint256 _catId)\n', '\tpublic view returns (uint256 workClockTimeRef);\n', '\n', '\tfunction existingCategory(\n', '\t\tuint256 _catId)\n', '\tpublic view  returns (bool categoryExist);\n', '\n', '\tfunction getCategory(\n', '\t\tuint256 _catId)\n', '\t\tpublic view returns (uint256 catid, string name, string  description, uint256 workClockTimeRef);\n', '\n', '\tfunction getWorkerStatus(\n', '\t\taddress _worker)\n', '\tpublic view returns (address workerPool, uint256 workerScore);\n', '\n', '\tfunction getWorkerScore(address _worker) public view returns (uint256 workerScore);\n', '\n', '\tfunction registerToPool(address _worker) public returns (bool subscribed);\n', '\n', '\tfunction unregisterFromPool(address _worker) public returns (bool unsubscribed);\n', '\n', '\tfunction evictWorker(address _worker) public returns (bool unsubscribed);\n', '\n', '\tfunction removeWorker(address _workerpool, address _worker) internal returns (bool unsubscribed);\n', '\n', '\tfunction lockForOrder(address _user, uint256 _amount) public returns (bool);\n', '\n', '\tfunction unlockForOrder(address _user, uint256 _amount) public returns (bool);\n', '\n', '\tfunction lockForWork(address _woid, address _user, uint256 _amount) public returns (bool);\n', '\n', '\tfunction unlockForWork(address _woid, address _user, uint256 _amount) public returns (bool);\n', '\n', '\tfunction rewardForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public returns (bool);\n', '\n', '\tfunction seizeForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public returns (bool);\n', '\n', '\tfunction deposit(uint256 _amount) external returns (bool);\n', '\n', '\tfunction withdraw(uint256 _amount) external returns (bool);\n', '\n', '\tfunction checkBalance(address _owner) public view returns (uint256 stake, uint256 locked);\n', '\n', '\tfunction reward(address _user, uint256 _amount) internal returns (bool);\n', '\n', '\tfunction seize(address _user, uint256 _amount) internal returns (bool);\n', '\n', '\tfunction lock(address _user, uint256 _amount) internal returns (bool);\n', '\n', '\tfunction unlock(address _user, uint256 _amount) internal returns (bool);\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract IexecHubAccessor\n', '{\n', '\tIexecHubInterface internal iexecHubInterface;\n', '\n', '\tmodifier onlyIexecHub()\n', '\t{\n', '\t\trequire(msg.sender == address(iexecHubInterface));\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction IexecHubAccessor(address _iexecHubAddress) public\n', '\t{\n', '\t\trequire(_iexecHubAddress != address(0));\n', '\t\tiexecHubInterface = IexecHubInterface(_iexecHubAddress);\n', '\t}\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', 'contract MarketplaceInterface\n', '{\n', '\tfunction createMarketOrder(\n', '\t\tIexecLib.MarketOrderDirectionEnum _direction,\n', '\t\tuint256 _category,\n', '\t\tuint256 _trust,\n', '\t\tuint256 _value,\n', '\t\taddress _workerpool,\n', '\t\tuint256 _volume)\n', '\tpublic returns (uint);\n', '\n', '\tfunction closeMarketOrder(\n', '\t\tuint256 _marketorderIdx)\n', '\tpublic returns (bool);\n', '\n', '\tfunction getMarketOrderValue(\n', '\t\tuint256 _marketorderIdx)\n', '\tpublic view returns(uint256);\n', '\n', '\tfunction getMarketOrderWorkerpoolOwner(\n', '\t\tuint256 _marketorderIdx)\n', '\tpublic view returns(address);\n', '\n', '\tfunction getMarketOrderCategory(\n', '\t\tuint256 _marketorderIdx)\n', '\tpublic view returns (uint256);\n', '\n', '\tfunction getMarketOrderTrust(\n', '\t\tuint256 _marketorderIdx)\n', '\tpublic view returns(uint256);\n', '\n', '\tfunction getMarketOrder(\n', '\t\tuint256 _marketorderIdx)\n', '\tpublic view returns(\n', '\t\tIexecLib.MarketOrderDirectionEnum direction,\n', '\t\tuint256 category,       // runtime selection\n', '\t\tuint256 trust,          // for PoCo\n', '\t\tuint256 value,          // value/cost/price\n', '\t\tuint256 volume,         // quantity of instances (total)\n', '\t\tuint256 remaining,      // remaining instances\n', '\t\taddress workerpool);    // BID can use null for any\n', '}\n', '\n', '\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract MarketplaceAccessor\n', '{\n', '\taddress              internal marketplaceAddress;\n', '\tMarketplaceInterface internal marketplaceInterface;\n', '/* not used\n', '\tmodifier onlyMarketplace()\n', '\t{\n', '\t\trequire(msg.sender == marketplaceAddress);\n', '\t\t_;\n', '\t}*/\n', '\n', '\tfunction MarketplaceAccessor(address _marketplaceAddress) public\n', '\t{\n', '\t\trequire(_marketplaceAddress != address(0));\n', '\t\tmarketplaceAddress   = _marketplaceAddress;\n', '\t\tmarketplaceInterface = MarketplaceInterface(_marketplaceAddress);\n', '\t}\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract WorkOrder\n', '{\n', '\n', '\n', '\tevent WorkOrderActivated();\n', '\tevent WorkOrderReActivated();\n', '\tevent WorkOrderRevealing();\n', '\tevent WorkOrderClaimed  ();\n', '\tevent WorkOrderCompleted();\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tIexecLib.WorkOrderStatusEnum public m_status;\n', '\n', '\tuint256 public m_marketorderIdx;\n', '\n', '\taddress public m_app;\n', '\taddress public m_dataset;\n', '\taddress public m_workerpool;\n', '\taddress public m_requester;\n', '\n', '\tuint256 public m_emitcost;\n', '\tstring  public m_params;\n', '\taddress public m_callback;\n', '\taddress public m_beneficiary;\n', '\n', '\tbytes32 public m_resultCallbackProof;\n', '\tstring  public m_stdout;\n', '\tstring  public m_stderr;\n', '\tstring  public m_uri;\n', '\n', '\taddress public m_iexecHubAddress;\n', '\n', '\tmodifier onlyIexecHub()\n', '\t{\n', '\t\trequire(msg.sender == m_iexecHubAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction WorkOrder(\n', '\t\tuint256 _marketorderIdx,\n', '\t\taddress _requester,\n', '\t\taddress _app,\n', '\t\taddress _dataset,\n', '\t\taddress _workerpool,\n', '\t\tuint256 _emitcost,\n', '\t\tstring  _params,\n', '\t\taddress _callback,\n', '\t\taddress _beneficiary)\n', '\tpublic\n', '\t{\n', '\t\tm_iexecHubAddress = msg.sender;\n', '\t\trequire(_requester != address(0));\n', '\t\tm_status         = IexecLib.WorkOrderStatusEnum.ACTIVE;\n', '\t\tm_marketorderIdx = _marketorderIdx;\n', '\t\tm_app            = _app;\n', '\t\tm_dataset        = _dataset;\n', '\t\tm_workerpool     = _workerpool;\n', '\t\tm_requester      = _requester;\n', '\t\tm_emitcost       = _emitcost;\n', '\t\tm_params         = _params;\n', '\t\tm_callback       = _callback;\n', '\t\tm_beneficiary    = _beneficiary;\n', '\t\t// needed for the scheduler to authorize api token access on this m_beneficiary address in case _requester is a smart contract.\n', '\t}\n', '\n', '\tfunction startRevealingPhase() public returns (bool)\n', '\t{\n', '\t\trequire(m_workerpool == msg.sender);\n', '\t\trequire(m_status == IexecLib.WorkOrderStatusEnum.ACTIVE);\n', '\t\tm_status = IexecLib.WorkOrderStatusEnum.REVEALING;\n', '\t\temit WorkOrderRevealing();\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction reActivate() public returns (bool)\n', '\t{\n', '\t\trequire(m_workerpool == msg.sender);\n', '\t\trequire(m_status == IexecLib.WorkOrderStatusEnum.REVEALING);\n', '\t\tm_status = IexecLib.WorkOrderStatusEnum.ACTIVE;\n', '\t\temit WorkOrderReActivated();\n', '\t\treturn true;\n', '\t}\n', '\n', '\n', '\tfunction claim() public onlyIexecHub\n', '\t{\n', '\t\trequire(m_status == IexecLib.WorkOrderStatusEnum.ACTIVE || m_status == IexecLib.WorkOrderStatusEnum.REVEALING);\n', '\t\tm_status = IexecLib.WorkOrderStatusEnum.CLAIMED;\n', '\t\temit WorkOrderClaimed();\n', '\t}\n', '\n', '\n', '\tfunction setResult(string _stdout, string _stderr, string _uri) public onlyIexecHub\n', '\t{\n', '\t\trequire(m_status == IexecLib.WorkOrderStatusEnum.REVEALING);\n', '\t\tm_status = IexecLib.WorkOrderStatusEnum.COMPLETED;\n', '\t\tm_stdout = _stdout;\n', '\t\tm_stderr = _stderr;\n', '\t\tm_uri    = _uri;\n', '\t\tm_resultCallbackProof =keccak256(_stdout,_stderr,_uri);\n', '\t\temit WorkOrderCompleted();\n', '\t}\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract IexecCallbackInterface\n', '{\n', '\n', '\tfunction workOrderCallback(\n', '\t\taddress _woid,\n', '\t\tstring  _stdout,\n', '\t\tstring  _stderr,\n', '\t\tstring  _uri) public returns (bool);\n', '\n', '\tevent WorkOrderCallback(address woid, string stdout, string stderr, string uri);\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract Marketplace is IexecHubAccessor\n', '{\n', '\tusing SafeMathOZ for uint256;\n', '\n', '\t/**\n', '\t * Marketplace\n', '\t */\n', '\tuint                                 public m_orderCount;\n', '\tmapping(uint =>IexecLib.MarketOrder) public m_orderBook;\n', '\n', '\tuint256 public constant ASK_STAKE_RATIO  = 30;\n', '\n', '\t/**\n', '\t * Events\n', '\t */\n', '\tevent MarketOrderCreated   (uint marketorderIdx);\n', '\tevent MarketOrderClosed    (uint marketorderIdx);\n', '\tevent MarketOrderAskConsume(uint marketorderIdx, address requester);\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction Marketplace(address _iexecHubAddress)\n', '\tIexecHubAccessor(_iexecHubAddress)\n', '\tpublic\n', '\t{\n', '\t}\n', '\n', '\t/**\n', '\t * Market orders\n', '\t */\n', '\tfunction createMarketOrder(\n', '\t\tIexecLib.MarketOrderDirectionEnum _direction,\n', '\t\tuint256 _category,\n', '\t\tuint256 _trust,\n', '\t\tuint256 _value,\n', '\t\taddress _workerpool,\n', '\t\tuint256 _volume)\n', '\tpublic returns (uint)\n', '\t{\n', '\t\trequire(iexecHubInterface.existingCategory(_category));\n', '\t\trequire(_volume >0);\n', '\t\tm_orderCount = m_orderCount.add(1);\n', '\t\tIexecLib.MarketOrder storage marketorder    = m_orderBook[m_orderCount];\n', '\t\tmarketorder.direction      = _direction;\n', '\t\tmarketorder.category       = _category;\n', '\t\tmarketorder.trust          = _trust;\n', '\t\tmarketorder.value          = _value;\n', '\t\tmarketorder.volume         = _volume;\n', '\t\tmarketorder.remaining      = _volume;\n', '\n', '\t\tif (_direction == IexecLib.MarketOrderDirectionEnum.ASK)\n', '\t\t{\n', '\t\t\trequire(WorkerPool(_workerpool).m_owner() == msg.sender);\n', '\n', '\t\t\trequire(iexecHubInterface.lockForOrder(msg.sender, _value.percentage(ASK_STAKE_RATIO).mul(_volume))); // mul must be done after percentage to avoid rounding errors\n', '\t\t\tmarketorder.workerpool      = _workerpool;\n', '\t\t\tmarketorder.workerpoolOwner = msg.sender;\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\t// no BID implementation\n', '\t\t\trevert();\n', '\t\t}\n', '\t\temit MarketOrderCreated(m_orderCount);\n', '\t\treturn m_orderCount;\n', '\t}\n', '\n', '\tfunction closeMarketOrder(uint256 _marketorderIdx) public returns (bool)\n', '\t{\n', '\t\tIexecLib.MarketOrder storage marketorder = m_orderBook[_marketorderIdx];\n', '\t\tif (marketorder.direction == IexecLib.MarketOrderDirectionEnum.ASK)\n', '\t\t{\n', '\t\t\trequire(marketorder.workerpoolOwner == msg.sender);\n', '\t\t\trequire(iexecHubInterface.unlockForOrder(marketorder.workerpoolOwner, marketorder.value.percentage(ASK_STAKE_RATIO).mul(marketorder.remaining))); // mul must be done after percentage to avoid rounding errors\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\t// no BID implementation\n', '\t\t\trevert();\n', '\t\t}\n', '\t\tmarketorder.direction = IexecLib.MarketOrderDirectionEnum.CLOSED;\n', '\t\temit MarketOrderClosed(_marketorderIdx);\n', '\t\treturn true;\n', '\t}\n', '\n', '\n', '\t/**\n', '\t * Assets consumption\n', '\t */\n', '\tfunction consumeMarketOrderAsk(\n', '\t\tuint256 _marketorderIdx,\n', '\t\taddress _requester,\n', '\t\taddress _workerpool)\n', '\tpublic onlyIexecHub returns (bool)\n', '\t{\n', '\t\tIexecLib.MarketOrder storage marketorder = m_orderBook[_marketorderIdx];\n', '\t\trequire(marketorder.direction  == IexecLib.MarketOrderDirectionEnum.ASK);\n', '\t\trequire(marketorder.remaining  >  0);\n', '\t\trequire(marketorder.workerpool == _workerpool);\n', '\n', '\t\tmarketorder.remaining = marketorder.remaining.sub(1);\n', '\t\tif (marketorder.remaining == 0)\n', '\t\t{\n', '\t\t\tmarketorder.direction = IexecLib.MarketOrderDirectionEnum.CLOSED;\n', '\t\t}\n', '\t\trequire(iexecHubInterface.lockForOrder(_requester, marketorder.value));\n', '\t\temit MarketOrderAskConsume(_marketorderIdx, _requester);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction existingMarketOrder(uint256 _marketorderIdx) public view  returns (bool marketOrderExist)\n', '\t{\n', '\t\treturn m_orderBook[_marketorderIdx].category > 0;\n', '\t}\n', '\n', '\t/**\n', '\t * Views\n', '\t */\n', '\tfunction getMarketOrderValue(uint256 _marketorderIdx) public view returns (uint256)\n', '\t{\n', '\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\n', '\t\treturn m_orderBook[_marketorderIdx].value;\n', '\t}\n', '\tfunction getMarketOrderWorkerpoolOwner(uint256 _marketorderIdx) public view returns (address)\n', '\t{\n', '\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\n', '\t\treturn m_orderBook[_marketorderIdx].workerpoolOwner;\n', '\t}\n', '\tfunction getMarketOrderCategory(uint256 _marketorderIdx) public view returns (uint256)\n', '\t{\n', '\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\n', '\t\treturn m_orderBook[_marketorderIdx].category;\n', '\t}\n', '\tfunction getMarketOrderTrust(uint256 _marketorderIdx) public view returns (uint256)\n', '\t{\n', '\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\n', '\t\treturn m_orderBook[_marketorderIdx].trust;\n', '\t}\n', '\tfunction getMarketOrder(uint256 _marketorderIdx) public view returns\n', '\t(\n', '\t\tIexecLib.MarketOrderDirectionEnum direction,\n', '\t\tuint256 category,       // runtime selection\n', '\t\tuint256 trust,          // for PoCo\n', '\t\tuint256 value,          // value/cost/price\n', '\t\tuint256 volume,         // quantity of instances (total)\n', '\t\tuint256 remaining,      // remaining instances\n', '\t\taddress workerpool,     // BID can use null for any\n', '\t\taddress workerpoolOwner)\n', '\t{\n', '\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\n', '\t\tIexecLib.MarketOrder storage marketorder = m_orderBook[_marketorderIdx];\n', '\t\treturn (\n', '\t\t\tmarketorder.direction,\n', '\t\t\tmarketorder.category,\n', '\t\t\tmarketorder.trust,\n', '\t\t\tmarketorder.value,\n', '\t\t\tmarketorder.volume,\n', '\t\t\tmarketorder.remaining,\n', '\t\t\tmarketorder.workerpool,\n', '\t\t\tmarketorder.workerpoolOwner\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * Callback Proof managment\n', '\t */\n', '\n', '\tevent WorkOrderCallbackProof(address indexed woid, address requester, address beneficiary,address indexed callbackTo, address indexed gasCallbackProvider,string stdout, string stderr , string uri);\n', '\n', '\t//mapping(workorder => bool)\n', '\t mapping(address => bool) m_callbackDone;\n', '\n', '\t function isCallbackDone(address _woid) public view  returns (bool callbackDone)\n', '\t {\n', '\t\t return m_callbackDone[_woid];\n', '\t }\n', '\n', '\t function workOrderCallback(address _woid,string _stdout, string _stderr, string _uri) public\n', '\t {\n', '\t\t require(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\t require(!isCallbackDone(_woid));\n', '\t\t m_callbackDone[_woid] = true;\n', '\t\t require(WorkOrder(_woid).m_status() == IexecLib.WorkOrderStatusEnum.COMPLETED);\n', '\t\t require(WorkOrder(_woid).m_resultCallbackProof() == keccak256(_stdout,_stderr,_uri));\n', '\t\t address callbackTo =WorkOrder(_woid).m_callback();\n', '\t\t require(callbackTo != address(0));\n', '\t\t require(IexecCallbackInterface(callbackTo).workOrderCallback(\n', '\t\t\t _woid,\n', '\t\t\t _stdout,\n', '\t\t\t _stderr,\n', '\t\t\t _uri\n', '\t\t ));\n', '\t\t emit WorkOrderCallbackProof(_woid,WorkOrder(_woid).m_requester(),WorkOrder(_woid).m_beneficiary(),callbackTo,tx.origin,_stdout,_stderr,_uri);\n', '\t }\n', '\n', '}\n', '\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract App is OwnableOZ, IexecHubAccessor\n', '{\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tstring        public m_appName;\n', '\tuint256       public m_appPrice;\n', '\tstring        public m_appParams;\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction App(\n', '\t\taddress _iexecHubAddress,\n', '\t\tstring  _appName,\n', '\t\tuint256 _appPrice,\n', '\t\tstring  _appParams)\n', '\tIexecHubAccessor(_iexecHubAddress)\n', '\tpublic\n', '\t{\n', '\t\t// tx.origin == owner\n', '\t\t// msg.sender == DatasetHub\n', '\t\trequire(tx.origin != msg.sender);\n', '\t\tsetImmutableOwnership(tx.origin); // owner → tx.origin\n', '\n', '\t\tm_appName   = _appName;\n', '\t\tm_appPrice  = _appPrice;\n', '\t\tm_appParams = _appParams;\n', '\n', '\t}\n', '\n', '\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', 'contract AppHub is OwnableOZ // is Owned by IexecHub\n', '{\n', '\n', '\tusing SafeMathOZ for uint256;\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tmapping(address => uint256)                     m_appCountByOwner;\n', '\tmapping(address => mapping(uint256 => address)) m_appByOwnerByIndex;\n', '\tmapping(address => bool)                        m_appRegistered;\n', '\n', '\tmapping(uint256 => address)                     m_appByIndex;\n', '\tuint256 public                                  m_totalAppCount;\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction AppHub() public\n', '\t{\n', '\t}\n', '\n', '\t/**\n', '\t * Methods\n', '\t */\n', '\tfunction isAppRegistered(address _app) public view returns (bool)\n', '\t{\n', '\t\treturn m_appRegistered[_app];\n', '\t}\n', '\tfunction getAppsCount(address _owner) public view returns (uint256)\n', '\t{\n', '\t\treturn m_appCountByOwner[_owner];\n', '\t}\n', '\tfunction getApp(address _owner, uint256 _index) public view returns (address)\n', '\t{\n', '\t\treturn m_appByOwnerByIndex[_owner][_index];\n', '\t}\n', '\tfunction getAppByIndex(uint256 _index) public view returns (address)\n', '\t{\n', '\t\treturn m_appByIndex[_index];\n', '\t}\n', '\n', '\tfunction addApp(address _owner, address _app) internal\n', '\t{\n', '\t\tuint id = m_appCountByOwner[_owner].add(1);\n', '\t\tm_totalAppCount=m_totalAppCount.add(1);\n', '\t\tm_appByIndex       [m_totalAppCount] = _app;\n', '\t\tm_appCountByOwner  [_owner]          = id;\n', '\t\tm_appByOwnerByIndex[_owner][id]      = _app;\n', '\t\tm_appRegistered    [_app]            = true;\n', '\t}\n', '\n', '\tfunction createApp(\n', '\t\tstring  _appName,\n', '\t\tuint256 _appPrice,\n', '\t\tstring  _appParams)\n', '\tpublic onlyOwner /*owner == IexecHub*/ returns (address createdApp)\n', '\t{\n', '\t\t// tx.origin == owner\n', '\t\t// msg.sender == IexecHub\n', '\t\taddress newApp = new App(\n', '\t\t\tmsg.sender,\n', '\t\t\t_appName,\n', '\t\t\t_appPrice,\n', '\t\t\t_appParams\n', '\t\t);\n', '\t\taddApp(tx.origin, newApp);\n', '\t\treturn newApp;\n', '\t}\n', '\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract Dataset is OwnableOZ, IexecHubAccessor\n', '{\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tstring            public m_datasetName;\n', '\tuint256           public m_datasetPrice;\n', '\tstring            public m_datasetParams;\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction Dataset(\n', '\t\taddress _iexecHubAddress,\n', '\t\tstring  _datasetName,\n', '\t\tuint256 _datasetPrice,\n', '\t\tstring  _datasetParams)\n', '\tIexecHubAccessor(_iexecHubAddress)\n', '\tpublic\n', '\t{\n', '\t\t// tx.origin == owner\n', '\t\t// msg.sender == DatasetHub\n', '\t\trequire(tx.origin != msg.sender);\n', '\t\tsetImmutableOwnership(tx.origin); // owner → tx.origin\n', '\n', '\t\tm_datasetName   = _datasetName;\n', '\t\tm_datasetPrice  = _datasetPrice;\n', '\t\tm_datasetParams = _datasetParams;\n', '\n', '\t}\n', '\n', '\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract DatasetHub is OwnableOZ // is Owned by IexecHub\n', '{\n', '\tusing SafeMathOZ for uint256;\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tmapping(address => uint256)                     m_datasetCountByOwner;\n', '\tmapping(address => mapping(uint256 => address)) m_datasetByOwnerByIndex;\n', '\tmapping(address => bool)                        m_datasetRegistered;\n', '\n', '\tmapping(uint256 => address)                     m_datasetByIndex;\n', '\tuint256 public                                  m_totalDatasetCount;\n', '\n', '\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction DatasetHub() public\n', '\t{\n', '\t}\n', '\n', '\t/**\n', '\t * Methods\n', '\t */\n', '\tfunction isDatasetRegistred(address _dataset) public view returns (bool)\n', '\t{\n', '\t\treturn m_datasetRegistered[_dataset];\n', '\t}\n', '\tfunction getDatasetsCount(address _owner) public view returns (uint256)\n', '\t{\n', '\t\treturn m_datasetCountByOwner[_owner];\n', '\t}\n', '\tfunction getDataset(address _owner, uint256 _index) public view returns (address)\n', '\t{\n', '\t\treturn m_datasetByOwnerByIndex[_owner][_index];\n', '\t}\n', '\tfunction getDatasetByIndex(uint256 _index) public view returns (address)\n', '\t{\n', '\t\treturn m_datasetByIndex[_index];\n', '\t}\n', '\n', '\tfunction addDataset(address _owner, address _dataset) internal\n', '\t{\n', '\t\tuint id = m_datasetCountByOwner[_owner].add(1);\n', '\t\tm_totalDatasetCount = m_totalDatasetCount.add(1);\n', '\t\tm_datasetByIndex       [m_totalDatasetCount] = _dataset;\n', '\t\tm_datasetCountByOwner  [_owner]              = id;\n', '\t\tm_datasetByOwnerByIndex[_owner][id]          = _dataset;\n', '\t\tm_datasetRegistered    [_dataset]            = true;\n', '\t}\n', '\n', '\tfunction createDataset(\n', '\t\tstring _datasetName,\n', '\t\tuint256 _datasetPrice,\n', '\t\tstring _datasetParams)\n', '\tpublic onlyOwner /*owner == IexecHub*/ returns (address createdDataset)\n', '\t{\n', '\t\t// tx.origin == owner\n', '\t\t// msg.sender == IexecHub\n', '\t\taddress newDataset = new Dataset(\n', '\t\t\tmsg.sender,\n', '\t\t\t_datasetName,\n', '\t\t\t_datasetPrice,\n', '\t\t\t_datasetParams\n', '\t\t);\n', '\t\taddDataset(tx.origin, newDataset);\n', '\t\treturn newDataset;\n', '\t}\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '/**\n', ' * @title IexecHub\n', ' */\n', '\n', 'contract IexecHub\n', '{\n', '\tusing SafeMathOZ for uint256;\n', '\n', '\t/**\n', '\t* RLC contract for token transfers.\n', '\t*/\n', '\tRLC public rlc;\n', '\n', '\tuint256 public constant STAKE_BONUS_RATIO         = 10;\n', '\tuint256 public constant STAKE_BONUS_MIN_THRESHOLD = 1000;\n', '\tuint256 public constant SCORE_UNITARY_SLASH       = 50;\n', '\n', '\t/**\n', '\t * Slaves contracts\n', '\t */\n', '\tAppHub        public appHub;\n', '\tDatasetHub    public datasetHub;\n', '\tWorkerPoolHub public workerPoolHub;\n', '\n', '\t/**\n', '\t * Market place\n', '\t */\n', '\tMarketplace public marketplace;\n', '\tmodifier onlyMarketplace()\n', '\t{\n', '\t\trequire(msg.sender == address(marketplace));\n', '\t\t_;\n', '\t}\n', '\t/**\n', '\t * Categories\n', '\t */\n', '\tmapping(uint256 => IexecLib.Category) public m_categories;\n', '\tuint256                               public m_categoriesCount;\n', '\taddress                               public m_categoriesCreator;\n', '\tmodifier onlyCategoriesCreator()\n', '\t{\n', '\t\trequire(msg.sender == m_categoriesCreator);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * Escrow\n', '\t */\n', '\tmapping(address => IexecLib.Account) public m_accounts;\n', '\n', '\n', '\t/**\n', '\t * workOrder Registered\n', '\t */\n', '\tmapping(address => bool) public m_woidRegistered;\n', '\tmodifier onlyRegisteredWoid(address _woid)\n', '\t{\n', '\t\trequire(m_woidRegistered[_woid]);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * Reputation for PoCo\n', '\t */\n', '\tmapping(address => uint256)  public m_scores;\n', '\tIexecLib.ContributionHistory public m_contributionHistory;\n', '\n', '\n', '\tevent WorkOrderActivated(address woid, address indexed workerPool);\n', '\tevent WorkOrderClaimed  (address woid, address workerPool);\n', '\tevent WorkOrderCompleted(address woid, address workerPool);\n', '\n', '\tevent CreateApp       (address indexed appOwner,        address indexed app,        string appName,     uint256 appPrice,     string appParams    );\n', '\tevent CreateDataset   (address indexed datasetOwner,    address indexed dataset,    string datasetName, uint256 datasetPrice, string datasetParams);\n', '\tevent CreateWorkerPool(address indexed workerPoolOwner, address indexed workerPool, string workerPoolDescription                                        );\n', '\n', '\tevent CreateCategory  (uint256 catid, string name, string description, uint256 workClockTimeRef);\n', '\n', '\tevent WorkerPoolSubscription  (address indexed workerPool, address worker);\n', '\tevent WorkerPoolUnsubscription(address indexed workerPool, address worker);\n', '\tevent WorkerPoolEviction      (address indexed workerPool, address worker);\n', '\n', '\tevent AccurateContribution(address woid, address indexed worker);\n', '\tevent FaultyContribution  (address woid, address indexed worker);\n', '\n', '\tevent Deposit (address owner, uint256 amount);\n', '\tevent Withdraw(address owner, uint256 amount);\n', '\tevent Reward  (address user,  uint256 amount);\n', '\tevent Seize   (address user,  uint256 amount);\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction IexecHub()\n', '\tpublic\n', '\t{\n', '\t\tm_categoriesCreator = msg.sender;\n', '\t}\n', '\n', '\tfunction attachContracts(\n', '\t\taddress _tokenAddress,\n', '\t\taddress _marketplaceAddress,\n', '\t\taddress _workerPoolHubAddress,\n', '\t\taddress _appHubAddress,\n', '\t\taddress _datasetHubAddress)\n', '\tpublic onlyCategoriesCreator\n', '\t{\n', '\t\trequire(address(rlc) == address(0));\n', '\t\trlc                = RLC          (_tokenAddress        );\n', '\t\tmarketplace        = Marketplace  (_marketplaceAddress  );\n', '\t\tworkerPoolHub      = WorkerPoolHub(_workerPoolHubAddress);\n', '\t\tappHub             = AppHub       (_appHubAddress       );\n', '\t\tdatasetHub         = DatasetHub   (_datasetHubAddress   );\n', '\n', '\t}\n', '\n', '\tfunction setCategoriesCreator(address _categoriesCreator)\n', '\tpublic onlyCategoriesCreator\n', '\t{\n', '\t\tm_categoriesCreator = _categoriesCreator;\n', '\t}\n', '\t/**\n', '\t * Factory\n', '\t */\n', '\n', '\tfunction createCategory(\n', '\t\tstring  _name,\n', '\t\tstring  _description,\n', '\t\tuint256 _workClockTimeRef)\n', '\tpublic onlyCategoriesCreator returns (uint256 catid)\n', '\t{\n', '\t\tm_categoriesCount                  = m_categoriesCount.add(1);\n', '\t\tIexecLib.Category storage category = m_categories[m_categoriesCount];\n', '\t\tcategory.catid                     = m_categoriesCount;\n', '\t\tcategory.name                      = _name;\n', '\t\tcategory.description               = _description;\n', '\t\tcategory.workClockTimeRef          = _workClockTimeRef;\n', '\t\temit CreateCategory(m_categoriesCount, _name, _description, _workClockTimeRef);\n', '\t\treturn m_categoriesCount;\n', '\t}\n', '\n', '\tfunction createWorkerPool(\n', '\t\tstring  _description,\n', '\t\tuint256 _subscriptionLockStakePolicy,\n', '\t\tuint256 _subscriptionMinimumStakePolicy,\n', '\t\tuint256 _subscriptionMinimumScorePolicy)\n', '\texternal returns (address createdWorkerPool)\n', '\t{\n', '\t\taddress newWorkerPool = workerPoolHub.createWorkerPool(\n', '\t\t\t_description,\n', '\t\t\t_subscriptionLockStakePolicy,\n', '\t\t\t_subscriptionMinimumStakePolicy,\n', '\t\t\t_subscriptionMinimumScorePolicy,\n', '\t\t\taddress(marketplace)\n', '\t\t);\n', '\t\temit CreateWorkerPool(tx.origin, newWorkerPool, _description);\n', '\t\treturn newWorkerPool;\n', '\t}\n', '\n', '\tfunction createApp(\n', '\t\tstring  _appName,\n', '\t\tuint256 _appPrice,\n', '\t\tstring  _appParams)\n', '\texternal returns (address createdApp)\n', '\t{\n', '\t\taddress newApp = appHub.createApp(\n', '\t\t\t_appName,\n', '\t\t\t_appPrice,\n', '\t\t\t_appParams\n', '\t\t);\n', '\t\temit CreateApp(tx.origin, newApp, _appName, _appPrice, _appParams);\n', '\t\treturn newApp;\n', '\t}\n', '\n', '\tfunction createDataset(\n', '\t\tstring  _datasetName,\n', '\t\tuint256 _datasetPrice,\n', '\t\tstring  _datasetParams)\n', '\texternal returns (address createdDataset)\n', '\t{\n', '\t\taddress newDataset = datasetHub.createDataset(\n', '\t\t\t_datasetName,\n', '\t\t\t_datasetPrice,\n', '\t\t\t_datasetParams\n', '\t\t\t);\n', '\t\temit CreateDataset(tx.origin, newDataset, _datasetName, _datasetPrice, _datasetParams);\n', '\t\treturn newDataset;\n', '\t}\n', '\n', '\t/**\n', '\t * WorkOrder Emission\n', '\t */\n', '\tfunction buyForWorkOrder(\n', '\t\tuint256 _marketorderIdx,\n', '\t\taddress _workerpool,\n', '\t\taddress _app,\n', '\t\taddress _dataset,\n', '\t\tstring  _params,\n', '\t\taddress _callback,\n', '\t\taddress _beneficiary)\n', '\texternal returns (address)\n', '\t{\n', '\t\taddress requester = msg.sender;\n', '\t\trequire(marketplace.consumeMarketOrderAsk(_marketorderIdx, requester, _workerpool));\n', '\n', '\t\tuint256 emitcost = lockWorkOrderCost(requester, _workerpool, _app, _dataset);\n', '\n', '\t\tWorkOrder workorder = new WorkOrder(\n', '\t\t\t_marketorderIdx,\n', '\t\t\trequester,\n', '\t\t\t_app,\n', '\t\t\t_dataset,\n', '\t\t\t_workerpool,\n', '\t\t\temitcost,\n', '\t\t\t_params,\n', '\t\t\t_callback,\n', '\t\t\t_beneficiary\n', '\t\t);\n', '\n', '\t\tm_woidRegistered[workorder] = true;\n', '\n', '\t\trequire(WorkerPool(_workerpool).emitWorkOrder(workorder, _marketorderIdx));\n', '\n', '\t\temit WorkOrderActivated(workorder, _workerpool);\n', '\t\treturn workorder;\n', '\t}\n', '\n', '\tfunction isWoidRegistred(address _woid) public view returns (bool)\n', '\t{\n', '\t\treturn m_woidRegistered[_woid];\n', '\t}\n', '\n', '\tfunction lockWorkOrderCost(\n', '\t\taddress _requester,\n', '\t\taddress _workerpool, // Address of a smartcontract\n', '\t\taddress _app,        // Address of a smartcontract\n', '\t\taddress _dataset)    // Address of a smartcontract\n', '\tinternal returns (uint256)\n', '\t{\n', '\t\t// APP\n', '\t\tApp app = App(_app);\n', '\t\trequire(appHub.isAppRegistered (_app));\n', '\t\t// initialize usercost with dapp price\n', '\t\tuint256 emitcost = app.m_appPrice();\n', '\n', '\t\t// DATASET\n', '\t\tif (_dataset != address(0)) // address(0) → no dataset\n', '\t\t{\n', '\t\t\tDataset dataset = Dataset(_dataset);\n', '\t\t\trequire(datasetHub.isDatasetRegistred(_dataset));\n', '\t\t\t// add optional datasetPrice for userCost\n', '\t\t\temitcost = emitcost.add(dataset.m_datasetPrice());\n', '\t\t}\n', '\n', '\t\t// WORKERPOOL\n', '\t\trequire(workerPoolHub.isWorkerPoolRegistered(_workerpool));\n', '\n', '\t\trequire(lock(_requester, emitcost)); // Lock funds for app + dataset payment\n', '\n', '\t\treturn emitcost;\n', '\t}\n', '\n', '\t/**\n', '\t * WorkOrder life cycle\n', '\t */\n', '\n', '\tfunction claimFailedConsensus(address _woid)\n', '\tpublic onlyRegisteredWoid(_woid) returns (bool)\n', '\t{\n', '\t\tWorkOrder  workorder  = WorkOrder(_woid);\n', '\t\trequire(workorder.m_requester() == msg.sender);\n', '\t\tWorkerPool workerpool = WorkerPool(workorder.m_workerpool());\n', '\n', '\t\tIexecLib.WorkOrderStatusEnum currentStatus = workorder.m_status();\n', '\t\trequire(currentStatus == IexecLib.WorkOrderStatusEnum.ACTIVE || currentStatus == IexecLib.WorkOrderStatusEnum.REVEALING);\n', '\t\t// Unlock stakes for all workers\n', '\t\trequire(workerpool.claimFailedConsensus(_woid));\n', '\t\tworkorder.claim(); // revert on error\n', '\n', '\t\t/* uint256 value           = marketplace.getMarketOrderValue(workorder.m_marketorderIdx()); // revert if not exist */\n', '\t\t/* address workerpoolOwner = marketplace.getMarketOrderWorkerpoolOwner(workorder.m_marketorderIdx()); // revert if not exist */\n', '\t\tuint256 value;\n', '\t\taddress workerpoolOwner;\n', '\t\t(,,,value,,,,workerpoolOwner) = marketplace.getMarketOrder(workorder.m_marketorderIdx()); // Single call cost less gas\n', '\t\tuint256 workerpoolStake = value.percentage(marketplace.ASK_STAKE_RATIO());\n', '\n', '\t\trequire(unlock (workorder.m_requester(), value.add(workorder.m_emitcost()))); // UNLOCK THE FUNDS FOR REINBURSEMENT\n', '\t\trequire(seize  (workerpoolOwner,         workerpoolStake));\n', '\t\t// put workerpoolOwner stake seize into iexecHub address for bonus for scheduler on next well finalized Task\n', '\t\trequire(reward (this,                    workerpoolStake));\n', '\t\trequire(lock   (this,                    workerpoolStake));\n', '\n', '\t\temit WorkOrderClaimed(_woid, workorder.m_workerpool());\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction finalizeWorkOrder(\n', '\t\taddress _woid,\n', '\t\tstring  _stdout,\n', '\t\tstring  _stderr,\n', '\t\tstring  _uri)\n', '\tpublic onlyRegisteredWoid(_woid) returns (bool)\n', '\t{\n', '\t\tWorkOrder workorder = WorkOrder(_woid);\n', '\t\trequire(workorder.m_workerpool() == msg.sender);\n', '\t\trequire(workorder.m_status()     == IexecLib.WorkOrderStatusEnum.REVEALING);\n', '\n', '\t\t// APP\n', '\t\tApp     app      = App(workorder.m_app());\n', '\t\tuint256 appPrice = app.m_appPrice();\n', '\t\tif (appPrice > 0)\n', '\t\t{\n', '\t\t\trequire(reward(app.m_owner(), appPrice));\n', '\t\t}\n', '\n', '\t\t// DATASET\n', '\t\tDataset dataset = Dataset(workorder.m_dataset());\n', '\t\tif (dataset != address(0))\n', '\t\t{\n', '\t\t\tuint256 datasetPrice = dataset.m_datasetPrice();\n', '\t\t\tif (datasetPrice > 0)\n', '\t\t\t{\n', '\t\t\t\trequire(reward(dataset.m_owner(), datasetPrice));\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\t// WORKERPOOL → rewarding done by the caller itself\n', '\n', '\t\t/**\n', '\t\t * seize stacked funds from requester.\n', '\t\t * reward = value: was locked at market making\n', '\t\t * emitcost: was locked at when emiting the workorder\n', '\t\t */\n', '\t\t/* uint256 value           = marketplace.getMarketOrderValue(workorder.m_marketorderIdx()); // revert if not exist */\n', '\t\t/* address workerpoolOwner = marketplace.getMarketOrderWorkerpoolOwner(workorder.m_marketorderIdx()); // revert if not exist */\n', '\t\tuint256 value;\n', '\t\taddress workerpoolOwner;\n', '\t\t(,,,value,,,,workerpoolOwner) = marketplace.getMarketOrder(workorder.m_marketorderIdx()); // Single call cost less gas\n', '\t\tuint256 workerpoolStake       = value.percentage(marketplace.ASK_STAKE_RATIO());\n', '\n', '\t\trequire(seize (workorder.m_requester(), value.add(workorder.m_emitcost()))); // seize funds for payment (market value + emitcost)\n', '\t\trequire(unlock(workerpoolOwner,         workerpoolStake)); // unlock scheduler stake\n', '\n', '\t\t// write results\n', '\t\tworkorder.setResult(_stdout, _stderr, _uri); // revert on error\n', '\n', '\t\t// Rien ne se perd, rien ne se cr&#233;e, tout se transfere\n', '\t\t// distribute bonus to scheduler. jackpot bonus come from scheduler stake loose on IexecHub contract\n', '\t\t// we reuse the varaible value for the kitty / fraction of the kitty (stack too deep)\n', '\t\t/* (,value) = checkBalance(this); // kitty is locked on `this` wallet */\n', '\t\tvalue = m_accounts[this].locked; // kitty is locked on `this` wallet\n', '\t\tif(value > 0)\n', '\t\t{\n', '\t\t\tvalue = value.min(value.percentage(STAKE_BONUS_RATIO).max(STAKE_BONUS_MIN_THRESHOLD));\n', '\t\t\trequire(seize(this,             value));\n', '\t\t\trequire(reward(workerpoolOwner, value));\n', '\t\t}\n', '\n', '\t\temit WorkOrderCompleted(_woid, workorder.m_workerpool());\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Views\n', '\t */\n', '\tfunction getCategoryWorkClockTimeRef(uint256 _catId) public view returns (uint256 workClockTimeRef)\n', '\t{\n', '\t\trequire(existingCategory(_catId));\n', '\t\treturn m_categories[_catId].workClockTimeRef;\n', '\t}\n', '\n', '\tfunction existingCategory(uint256 _catId) public view  returns (bool categoryExist)\n', '\t{\n', '\t\treturn m_categories[_catId].catid > 0;\n', '\t}\n', '\n', '\tfunction getCategory(uint256 _catId) public view returns (uint256 catid, string name, string  description, uint256 workClockTimeRef)\n', '\t{\n', '\t\trequire(existingCategory(_catId));\n', '\t\treturn (\n', '\t\t\tm_categories[_catId].catid,\n', '\t\t\tm_categories[_catId].name,\n', '\t\t\tm_categories[_catId].description,\n', '\t\t\tm_categories[_catId].workClockTimeRef\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getWorkerStatus(address _worker) public view returns (address workerPool, uint256 workerScore)\n', '\t{\n', '\t\treturn (workerPoolHub.getWorkerAffectation(_worker), m_scores[_worker]);\n', '\t}\n', '\n', '\tfunction getWorkerScore(address _worker) public view returns (uint256 workerScore)\n', '\t{\n', '\t\treturn m_scores[_worker];\n', '\t}\n', '\n', '\t/**\n', '\t * Worker subscription\n', '\t */\n', '\tfunction registerToPool(address _worker) public returns (bool subscribed)\n', '\t// msg.sender = workerPool\n', '\t{\n', '\t\tWorkerPool workerpool = WorkerPool(msg.sender);\n', '\t\t// Check credentials\n', '\t\trequire(workerPoolHub.isWorkerPoolRegistered(msg.sender));\n', '\t\t// Lock worker deposit\n', '\t\trequire(lock(_worker, workerpool.m_subscriptionLockStakePolicy()));\n', '\t\t// Check subscription policy\n', '\t\trequire(m_accounts[_worker].stake >= workerpool.m_subscriptionMinimumStakePolicy());\n', '\t\trequire(m_scores[_worker]         >= workerpool.m_subscriptionMinimumScorePolicy());\n', '\t\t// Update affectation\n', '\t\trequire(workerPoolHub.registerWorkerAffectation(msg.sender, _worker));\n', '\t\t// Trigger event notice\n', '\t\temit WorkerPoolSubscription(msg.sender, _worker);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction unregisterFromPool(address _worker) public returns (bool unsubscribed)\n', '\t// msg.sender = workerPool\n', '\t{\n', '\t\trequire(removeWorker(msg.sender, _worker));\n', '\t\t// Trigger event notice\n', '\t\temit WorkerPoolUnsubscription(msg.sender, _worker);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction evictWorker(address _worker) public returns (bool unsubscribed)\n', '\t// msg.sender = workerpool\n', '\t{\n', '\t\trequire(removeWorker(msg.sender, _worker));\n', '\t\t// Trigger event notice\n', '\t\temit WorkerPoolEviction(msg.sender, _worker);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction removeWorker(address _workerpool, address _worker) internal returns (bool unsubscribed)\n', '\t{\n', '\t\tWorkerPool workerpool = WorkerPool(_workerpool);\n', '\t\t// Check credentials\n', '\t\trequire(workerPoolHub.isWorkerPoolRegistered(_workerpool));\n', '\t\t// Unlick worker stake\n', '\t\trequire(unlock(_worker, workerpool.m_subscriptionLockStakePolicy()));\n', '\t\t// Update affectation\n', '\t\trequire(workerPoolHub.unregisterWorkerAffectation(_workerpool, _worker));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Stake, reward and penalty functions\n', '\t */\n', '\t/* Marketplace */\n', '\tfunction lockForOrder(address _user, uint256 _amount) public onlyMarketplace returns (bool)\n', '\t{\n', '\t\trequire(lock(_user, _amount));\n', '\t\treturn true;\n', '\t}\n', '\tfunction unlockForOrder(address _user, uint256 _amount) public  onlyMarketplace returns (bool)\n', '\t{\n', '\t\trequire(unlock(_user, _amount));\n', '\t\treturn true;\n', '\t}\n', '\t/* Work */\n', '\tfunction lockForWork(address _woid, address _user, uint256 _amount) public onlyRegisteredWoid(_woid) returns (bool)\n', '\t{\n', '\t\trequire(WorkOrder(_woid).m_workerpool() == msg.sender);\n', '\t\trequire(lock(_user, _amount));\n', '\t\treturn true;\n', '\t}\n', '\tfunction unlockForWork(address _woid, address _user, uint256 _amount) public onlyRegisteredWoid(_woid) returns (bool)\n', '\t{\n', '\t\trequire(WorkOrder(_woid).m_workerpool() == msg.sender);\n', '\t\trequire(unlock(_user, _amount));\n', '\t\treturn true;\n', '\t}\n', '\tfunction rewardForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public onlyRegisteredWoid(_woid) returns (bool)\n', '\t{\n', '\t\trequire(WorkOrder(_woid).m_workerpool() == msg.sender);\n', '\t\trequire(reward(_worker, _amount));\n', '\t\tif (_reputation)\n', '\t\t{\n', '\t\t\tm_contributionHistory.success = m_contributionHistory.success.add(1);\n', '\t\t\tm_scores[_worker] = m_scores[_worker].add(1);\n', '\t\t\temit AccurateContribution(_woid, _worker);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\tfunction seizeForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public onlyRegisteredWoid(_woid) returns (bool)\n', '\t{\n', '\t\trequire(WorkOrder(_woid).m_workerpool() == msg.sender);\n', '\t\trequire(seize(_worker, _amount));\n', '\t\tif (_reputation)\n', '\t\t{\n', '\t\t\tm_contributionHistory.failed = m_contributionHistory.failed.add(1);\n', '\t\t\tm_scores[_worker] = m_scores[_worker].sub(m_scores[_worker].min(SCORE_UNITARY_SLASH));\n', '\t\t\temit FaultyContribution(_woid, _worker);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\t/**\n', '\t * Wallet methods: public\n', '\t */\n', '\tfunction deposit(uint256 _amount) external returns (bool)\n', '\t{\n', '\t\trequire(rlc.transferFrom(msg.sender, address(this), _amount));\n', '\t\tm_accounts[msg.sender].stake = m_accounts[msg.sender].stake.add(_amount);\n', '\t\temit Deposit(msg.sender, _amount);\n', '\t\treturn true;\n', '\t}\n', '\tfunction withdraw(uint256 _amount) external returns (bool)\n', '\t{\n', '\t\tm_accounts[msg.sender].stake = m_accounts[msg.sender].stake.sub(_amount);\n', '\t\trequire(rlc.transfer(msg.sender, _amount));\n', '\t\temit Withdraw(msg.sender, _amount);\n', '\t\treturn true;\n', '\t}\n', '\tfunction checkBalance(address _owner) public view returns (uint256 stake, uint256 locked)\n', '\t{\n', '\t\treturn (m_accounts[_owner].stake, m_accounts[_owner].locked);\n', '\t}\n', '\t/**\n', '\t * Wallet methods: Internal\n', '\t */\n', '\tfunction reward(address _user, uint256 _amount) internal returns (bool)\n', '\t{\n', '\t\tm_accounts[_user].stake = m_accounts[_user].stake.add(_amount);\n', '\t\temit Reward(_user, _amount);\n', '\t\treturn true;\n', '\t}\n', '\tfunction seize(address _user, uint256 _amount) internal returns (bool)\n', '\t{\n', '\t\tm_accounts[_user].locked = m_accounts[_user].locked.sub(_amount);\n', '\t\temit Seize(_user, _amount);\n', '\t\treturn true;\n', '\t}\n', '\tfunction lock(address _user, uint256 _amount) internal returns (bool)\n', '\t{\n', '\t\tm_accounts[_user].stake  = m_accounts[_user].stake.sub(_amount);\n', '\t\tm_accounts[_user].locked = m_accounts[_user].locked.add(_amount);\n', '\t\treturn true;\n', '\t}\n', '\tfunction unlock(address _user, uint256 _amount) internal returns (bool)\n', '\t{\n', '\t\tm_accounts[_user].locked = m_accounts[_user].locked.sub(_amount);\n', '\t\tm_accounts[_user].stake  = m_accounts[_user].stake.add(_amount);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract WorkerPool is OwnableOZ, IexecHubAccessor, MarketplaceAccessor\n', '{\n', '\tusing SafeMathOZ for uint256;\n', '\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tstring                      public m_description;\n', '\tuint256                     public m_stakeRatioPolicy;               // % of reward to stake\n', '\tuint256                     public m_schedulerRewardRatioPolicy;     // % of reward given to scheduler\n', '\tuint256                     public m_subscriptionLockStakePolicy;    // Stake locked when in workerpool - Constant set by constructor, do not update\n', '\tuint256                     public m_subscriptionMinimumStakePolicy; // Minimum stake for subscribing\n', '\tuint256                     public m_subscriptionMinimumScorePolicy; // Minimum score for subscribing\n', '\taddress[]                   public m_workers;\n', '\tmapping(address => uint256) public m_workerIndex;\n', '\n', '\t// mapping(woid => IexecLib.Consensus)\n', '\tmapping(address => IexecLib.Consensus) public m_consensus;\n', '\t// mapping(woid => worker address => Contribution);\n', '\tmapping(address => mapping(address => IexecLib.Contribution)) public m_contributions;\n', '\n', '\tuint256 public constant REVEAL_PERIOD_DURATION_RATIO  = 2;\n', '\tuint256 public constant CONSENSUS_DURATION_RATIO      = 10;\n', '\n', '\t/**\n', '\t * Address of slave/related contracts\n', '\t */\n', '\taddress        public  m_workerPoolHubAddress;\n', '\n', '\n', '\t/**\n', '\t * Events\n', '\t */\n', '\tevent WorkerPoolPolicyUpdate(\n', '\t\tuint256 oldStakeRatioPolicy,               uint256 newStakeRatioPolicy,\n', '\t\tuint256 oldSchedulerRewardRatioPolicy,     uint256 newSchedulerRewardRatioPolicy,\n', '\t\tuint256 oldSubscriptionMinimumStakePolicy, uint256 newSubscriptionMinimumStakePolicy,\n', '\t\tuint256 oldSubscriptionMinimumScorePolicy, uint256 newSubscriptionMinimumScorePolicy);\n', '\n', '\tevent WorkOrderActive         (address indexed woid);\n', '\tevent WorkOrderClaimed        (address indexed woid);\n', '\n', '\tevent AllowWorkerToContribute (address indexed woid, address indexed worker, uint256 workerScore);\n', '\tevent Contribute              (address indexed woid, address indexed worker, bytes32 resultHash);\n', '\tevent RevealConsensus         (address indexed woid, bytes32 consensus);\n', '\tevent Reveal                  (address indexed woid, address indexed worker, bytes32 result);\n', '\tevent Reopen                  (address indexed woid);\n', '  event FinalizeWork            (address indexed woid, string stdout, string stderr, string uri);\n', '\n', '\n', '\n', '\tevent WorkerSubscribe         (address indexed worker);\n', '\tevent WorkerUnsubscribe       (address indexed worker);\n', '\tevent WorkerEviction          (address indexed worker);\n', '\n', '\t/**\n', '\t * Methods\n', '\t */\n', '\t// Constructor\n', '\tfunction WorkerPool(\n', '\t\taddress _iexecHubAddress,\n', '\t\tstring  _description,\n', '\t\tuint256 _subscriptionLockStakePolicy,\n', '\t\tuint256 _subscriptionMinimumStakePolicy,\n', '\t\tuint256 _subscriptionMinimumScorePolicy,\n', '\t\taddress _marketplaceAddress)\n', '\tIexecHubAccessor(_iexecHubAddress)\n', '\tMarketplaceAccessor(_marketplaceAddress)\n', '\tpublic\n', '\t{\n', '\t\t// tx.origin == owner\n', '\t\t// msg.sender ==  WorkerPoolHub\n', '\t\trequire(tx.origin != msg.sender);\n', '\t\tsetImmutableOwnership(tx.origin); // owner → tx.origin\n', '\n', '\t\tm_description                    = _description;\n', '\t\tm_stakeRatioPolicy               = 30; // % of the work order price to stake\n', '\t\tm_schedulerRewardRatioPolicy     = 1;  // % of the work reward going to scheduler vs workers reward\n', '\t\tm_subscriptionLockStakePolicy    = _subscriptionLockStakePolicy; // only at creation. cannot be change to respect lock/unlock of worker stake\n', '\t\tm_subscriptionMinimumStakePolicy = _subscriptionMinimumStakePolicy;\n', '\t\tm_subscriptionMinimumScorePolicy = _subscriptionMinimumScorePolicy;\n', '\t\tm_workerPoolHubAddress           = msg.sender;\n', '\n', '\t}\n', '\n', '\tfunction changeWorkerPoolPolicy(\n', '\t\tuint256 _newStakeRatioPolicy,\n', '\t\tuint256 _newSchedulerRewardRatioPolicy,\n', '\t\tuint256 _newSubscriptionMinimumStakePolicy,\n', '\t\tuint256 _newSubscriptionMinimumScorePolicy)\n', '\tpublic onlyOwner\n', '\t{\n', '\t\temit WorkerPoolPolicyUpdate(\n', '\t\t\tm_stakeRatioPolicy,               _newStakeRatioPolicy,\n', '\t\t\tm_schedulerRewardRatioPolicy,     _newSchedulerRewardRatioPolicy,\n', '\t\t\tm_subscriptionMinimumStakePolicy, _newSubscriptionMinimumStakePolicy,\n', '\t\t\tm_subscriptionMinimumScorePolicy, _newSubscriptionMinimumScorePolicy\n', '\t\t);\n', '\t\trequire(_newSchedulerRewardRatioPolicy <= 100);\n', '\t\tm_stakeRatioPolicy               = _newStakeRatioPolicy;\n', '\t\tm_schedulerRewardRatioPolicy     = _newSchedulerRewardRatioPolicy;\n', '\t\tm_subscriptionMinimumStakePolicy = _newSubscriptionMinimumStakePolicy;\n', '\t\tm_subscriptionMinimumScorePolicy = _newSubscriptionMinimumScorePolicy;\n', '\t}\n', '\n', '\t/************************* worker list management **************************/\n', '\tfunction getWorkerAddress(uint _index) public view returns (address)\n', '\t{\n', '\t\treturn m_workers[_index];\n', '\t}\n', '\tfunction getWorkerIndex(address _worker) public view returns (uint)\n', '\t{\n', '\t\tuint index = m_workerIndex[_worker];\n', '\t\trequire(m_workers[index] == _worker);\n', '\t\treturn index;\n', '\t}\n', '\tfunction getWorkersCount() public view returns (uint)\n', '\t{\n', '\t\treturn m_workers.length;\n', '\t}\n', '\n', '\tfunction subscribeToPool() public returns (bool)\n', '\t{\n', '\t\t// msg.sender = worker\n', '\t\trequire(iexecHubInterface.registerToPool(msg.sender));\n', '\t\tuint index = m_workers.push(msg.sender);\n', '\t\tm_workerIndex[msg.sender] = index.sub(1);\n', '\t\temit WorkerSubscribe(msg.sender);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction unsubscribeFromPool() public  returns (bool)\n', '\t{\n', '\t\t// msg.sender = worker\n', '\t\trequire(iexecHubInterface.unregisterFromPool(msg.sender));\n', '\t\trequire(removeWorker(msg.sender));\n', '\t\temit WorkerUnsubscribe(msg.sender);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction evictWorker(address _worker) public onlyOwner returns (bool)\n', '\t{\n', '\t\t// msg.sender = scheduler\n', '\t\trequire(iexecHubInterface.evictWorker(_worker));\n', '\t\trequire(removeWorker(_worker));\n', '\t\temit WorkerEviction(_worker);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction removeWorker(address _worker) internal returns (bool)\n', '\t{\n', '\t\tuint index = getWorkerIndex(_worker); // fails if worker not registered\n', '\t\taddress lastWorker = m_workers[m_workers.length.sub(1)];\n', '\t\tm_workers    [index     ] = lastWorker;\n', '\t\tm_workerIndex[lastWorker] = index;\n', '\t\tdelete m_workers[m_workers.length.sub(1)];\n', '\t\tm_workers.length = m_workers.length.sub(1);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction getConsensusDetails(address _woid) public view returns (\n', '\t\tuint256 c_poolReward,\n', '\t\tuint256 c_stakeAmount,\n', '\t\tbytes32 c_consensus,\n', '\t\tuint256 c_revealDate,\n', '\t\tuint256 c_revealCounter,\n', '\t\tuint256 c_consensusTimeout,\n', '\t\tuint256 c_winnerCount,\n', '\t\taddress c_workerpoolOwner)\n', '\t{\n', '\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\n', '\t\treturn (\n', '\t\t\tconsensus.poolReward,\n', '\t\t\tconsensus.stakeAmount,\n', '\t\t\tconsensus.consensus,\n', '\t\t\tconsensus.revealDate,\n', '\t\t\tconsensus.revealCounter,\n', '\t\t\tconsensus.consensusTimeout,\n', '\t\t\tconsensus.winnerCount,\n', '\t\t\tconsensus.workerpoolOwner\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getContributorsCount(address _woid) public view returns (uint256 contributorsCount)\n', '\t{\n', '\t\treturn m_consensus[_woid].contributors.length;\n', '\t}\n', '\n', '\tfunction getContributor(address _woid, uint256 index) public view returns (address contributor)\n', '\t{\n', '\t\treturn m_consensus[_woid].contributors[index];\n', '\t}\n', '\n', '\tfunction existingContribution(address _woid, address _worker) public view  returns (bool contributionExist)\n', '\t{\n', '\t\treturn m_contributions[_woid][_worker].status != IexecLib.ContributionStatusEnum.UNSET;\n', '\t}\n', '\n', '\tfunction getContribution(address _woid, address _worker) public view returns\n', '\t(\n', '\t\tIexecLib.ContributionStatusEnum status,\n', '\t\tbytes32 resultHash,\n', '\t\tbytes32 resultSign,\n', '\t\taddress enclaveChallenge,\n', '\t\tuint256 score,\n', '\t\tuint256 weight)\n', '\t{\n', '\t\trequire(existingContribution(_woid, _worker)); // no silent value returned\n', '\t\tIexecLib.Contribution storage contribution = m_contributions[_woid][_worker];\n', '\t\treturn (\n', '\t\t\tcontribution.status,\n', '\t\t\tcontribution.resultHash,\n', '\t\t\tcontribution.resultSign,\n', '\t\t\tcontribution.enclaveChallenge,\n', '\t\t\tcontribution.score,\n', '\t\t\tcontribution.weight\n', '\t\t);\n', '\t}\n', '\n', '\n', '\t/**************************** Works management *****************************/\n', '\tfunction emitWorkOrder(address _woid, uint256 _marketorderIdx) public onlyIexecHub returns (bool)\n', '\t{\n', '\t\tuint256 catid   = marketplaceInterface.getMarketOrderCategory(_marketorderIdx);\n', '\t\tuint256 timeout = iexecHubInterface.getCategoryWorkClockTimeRef(catid).mul(CONSENSUS_DURATION_RATIO).add(now);\n', '\n', '\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\n', '\t\tconsensus.poolReward                 = marketplaceInterface.getMarketOrderValue(_marketorderIdx);\n', '\t\tconsensus.workerpoolOwner            = marketplaceInterface.getMarketOrderWorkerpoolOwner(_marketorderIdx);\n', '\t\tconsensus.stakeAmount                = consensus.poolReward.percentage(m_stakeRatioPolicy);\n', '\t\tconsensus.consensusTimeout            = timeout;\n', '\t\tconsensus.schedulerRewardRatioPolicy = m_schedulerRewardRatioPolicy;\n', '\n', '\t\temit WorkOrderActive(_woid);\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction claimFailedConsensus(address _woid) public onlyIexecHub returns (bool)\n', '\t{\n', '\t  IexecLib.Consensus storage consensus = m_consensus[_woid];\n', '\t\trequire(now > consensus.consensusTimeout);\n', '\t\tuint256 i;\n', '\t\taddress w;\n', '\t\tfor (i = 0; i < consensus.contributors.length; ++i)\n', '\t\t{\n', '\t\t\tw = consensus.contributors[i];\n', '\t\t\tif (m_contributions[_woid][w].status != IexecLib.ContributionStatusEnum.AUTHORIZED)\n', '\t\t\t{\n', '\t\t\t\trequire(iexecHubInterface.unlockForWork(_woid, w, consensus.stakeAmount));\n', '\t\t\t}\n', '\t\t}\n', '\t\temit WorkOrderClaimed(_woid);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction allowWorkersToContribute(address _woid, address[] _workers, address _enclaveChallenge) public onlyOwner /*onlySheduler*/ returns (bool)\n', '\t{\n', '\t\tfor (uint i = 0; i < _workers.length; ++i)\n', '\t\t{\n', '\t\t\trequire(allowWorkerToContribute(_woid, _workers[i], _enclaveChallenge));\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction allowWorkerToContribute(address _woid, address _worker, address _enclaveChallenge) public onlyOwner /*onlySheduler*/ returns (bool)\n', '\t{\n', '\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\trequire(WorkOrder(_woid).m_status() == IexecLib.WorkOrderStatusEnum.ACTIVE);\n', '\t\tIexecLib.Contribution storage contribution = m_contributions[_woid][_worker];\n', '\t\tIexecLib.Consensus    storage consensus    = m_consensus[_woid];\n', '\t\trequire(now <= consensus.consensusTimeout);\n', '\n', '\t\taddress workerPool;\n', '\t\tuint256 workerScore;\n', '\t\t(workerPool, workerScore) = iexecHubInterface.getWorkerStatus(_worker); // workerPool, workerScore\n', '\t\trequire(workerPool == address(this));\n', '\n', '\t\trequire(contribution.status == IexecLib.ContributionStatusEnum.UNSET);\n', '\t\tcontribution.status           = IexecLib.ContributionStatusEnum.AUTHORIZED;\n', '\t\tcontribution.enclaveChallenge = _enclaveChallenge;\n', '\n', '\t\temit AllowWorkerToContribute(_woid, _worker, workerScore);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction contribute(address _woid, bytes32 _resultHash, bytes32 _resultSign, uint8 _v, bytes32 _r, bytes32 _s) public returns (uint256 workerStake)\n', '\t{\n', '\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\tIexecLib.Consensus    storage consensus    = m_consensus[_woid];\n', '\t\trequire(now <= consensus.consensusTimeout);\n', '\t\trequire(WorkOrder(_woid).m_status() == IexecLib.WorkOrderStatusEnum.ACTIVE); // can&#39;t contribute on a claimed or completed workorder\n', '\t\tIexecLib.Contribution storage contribution = m_contributions[_woid][msg.sender];\n', '\n', '\t\t// msg.sender = a worker\n', '\t\trequire(_resultHash != 0x0);\n', '\t\trequire(_resultSign != 0x0);\n', '\t\tif (contribution.enclaveChallenge != address(0))\n', '\t\t{\n', '\t\t\trequire(contribution.enclaveChallenge == ecrecover(keccak256("\\x19Ethereum Signed Message:\\n64", _resultHash, _resultSign), _v, _r, _s));\n', '\t\t}\n', '\n', '\t\trequire(contribution.status == IexecLib.ContributionStatusEnum.AUTHORIZED);\n', '\t\tcontribution.status     = IexecLib.ContributionStatusEnum.CONTRIBUTED;\n', '\t\tcontribution.resultHash = _resultHash;\n', '\t\tcontribution.resultSign = _resultSign;\n', '\t\tcontribution.score      = iexecHubInterface.getWorkerScore(msg.sender);\n', '\t\tconsensus.contributors.push(msg.sender);\n', '\n', '\t\trequire(iexecHubInterface.lockForWork(_woid, msg.sender, consensus.stakeAmount));\n', '\t\temit Contribute(_woid, msg.sender, _resultHash);\n', '\t\treturn consensus.stakeAmount;\n', '\t}\n', '\n', '\tfunction revealConsensus(address _woid, bytes32 _consensus) public onlyOwner /*onlySheduler*/ returns (bool)\n', '\t{\n', '\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\n', '\t\trequire(now <= consensus.consensusTimeout);\n', '\t\trequire(WorkOrder(_woid).startRevealingPhase());\n', '\n', '\t\tconsensus.winnerCount = 0;\n', '\t\tfor (uint256 i = 0; i<consensus.contributors.length; ++i)\n', '\t\t{\n', '\t\t\taddress w = consensus.contributors[i];\n', '\t\t\tif (\n', '\t\t\t\tm_contributions[_woid][w].resultHash == _consensus\n', '\t\t\t\t&&\n', '\t\t\t\tm_contributions[_woid][w].status == IexecLib.ContributionStatusEnum.CONTRIBUTED // REJECTED contribution must not be count\n', '\t\t\t)\n', '\t\t\t{\n', '\t\t\t\tconsensus.winnerCount = consensus.winnerCount.add(1);\n', '\t\t\t}\n', '\t\t}\n', '\t\trequire(consensus.winnerCount > 0); // you cannot revealConsensus if no worker has contributed to this hash\n', '\n', '\t\tconsensus.consensus  = _consensus;\n', '\t\tconsensus.revealDate = iexecHubInterface.getCategoryWorkClockTimeRef(marketplaceInterface.getMarketOrderCategory(WorkOrder(_woid).m_marketorderIdx())).mul(REVEAL_PERIOD_DURATION_RATIO).add(now); // is it better to store th catid ?\n', '\t\temit RevealConsensus(_woid, _consensus);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction reveal(address _woid, bytes32 _result) public returns (bool)\n', '\t{\n', '\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\tIexecLib.Consensus    storage consensus    = m_consensus[_woid];\n', '\t\trequire(now <= consensus.consensusTimeout);\n', '\t\tIexecLib.Contribution storage contribution = m_contributions[_woid][msg.sender];\n', '\n', '\t\trequire(WorkOrder(_woid).m_status() == IexecLib.WorkOrderStatusEnum.REVEALING     );\n', '\t\trequire(consensus.revealDate        >  now                                        );\n', '\t\trequire(contribution.status         == IexecLib.ContributionStatusEnum.CONTRIBUTED);\n', '\t\trequire(contribution.resultHash     == consensus.consensus                        );\n', '\t\trequire(contribution.resultHash     == keccak256(_result                        ) );\n', '\t\trequire(contribution.resultSign     == keccak256(_result ^ keccak256(msg.sender)) );\n', '\n', '\t\tcontribution.status     = IexecLib.ContributionStatusEnum.PROVED;\n', '\t\tconsensus.revealCounter = consensus.revealCounter.add(1);\n', '\n', '\t\temit Reveal(_woid, msg.sender, _result);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction reopen(address _woid) public onlyOwner /*onlySheduler*/ returns (bool)\n', '\t{\n', '\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\n', '\t\trequire(now <= consensus.consensusTimeout);\n', '\t\trequire(consensus.revealDate <= now && consensus.revealCounter == 0);\n', '\t\trequire(WorkOrder(_woid).reActivate());\n', '\n', '\t\tfor (uint256 i = 0; i < consensus.contributors.length; ++i)\n', '\t\t{\n', '\t\t\taddress w = consensus.contributors[i];\n', '\t\t\tif (m_contributions[_woid][w].resultHash == consensus.consensus)\n', '\t\t\t{\n', '\t\t\t\tm_contributions[_woid][w].status = IexecLib.ContributionStatusEnum.REJECTED;\n', '\t\t\t}\n', '\t\t}\n', '\t\t// Reset to status before revealConsensus. Must be after REJECTED traitement above because of consensus.consensus check\n', '\t\tconsensus.winnerCount = 0;\n', '\t\tconsensus.consensus   = 0x0;\n', '\t\tconsensus.revealDate  = 0;\n', '\t\temit Reopen(_woid);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// if sheduler never call finalized ? no incetive to do that. schedulermust be pay also at this time\n', '\tfunction finalizeWork(address _woid, string _stdout, string _stderr, string _uri) public onlyOwner /*onlySheduler*/ returns (bool)\n', '\t{\n', '\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\n', '\t\trequire(now <= consensus.consensusTimeout);\n', '\t\trequire((consensus.revealDate <= now && consensus.revealCounter > 0) || (consensus.revealCounter == consensus.winnerCount)); // consensus.winnerCount never 0 at this step\n', '\n', '\t\t// add penalized to the call worker to contribution and they never contribute ?\n', '\t\trequire(distributeRewards(_woid, consensus));\n', '\n', '\t\trequire(iexecHubInterface.finalizeWorkOrder(_woid, _stdout, _stderr, _uri));\n', '\t\temit FinalizeWork(_woid,_stdout,_stderr,_uri);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction distributeRewards(address _woid, IexecLib.Consensus _consensus) internal returns (bool)\n', '\t{\n', '\t\tuint256 i;\n', '\t\taddress w;\n', '\t\tuint256 workerBonus;\n', '\t\tuint256 workerWeight;\n', '\t\tuint256 totalWeight;\n', '\t\tuint256 individualWorkerReward;\n', '\t\tuint256 totalReward = _consensus.poolReward;\n', '\t\taddress[] memory contributors = _consensus.contributors;\n', '\t\tfor (i = 0; i<contributors.length; ++i)\n', '\t\t{\n', '\t\t\tw = contributors[i];\n', '\t\t\tIexecLib.Contribution storage c = m_contributions[_woid][w];\n', '\t\t\tif (c.status == IexecLib.ContributionStatusEnum.PROVED)\n', '\t\t\t{\n', '\t\t\t\tworkerBonus  = (c.enclaveChallenge != address(0)) ? 3 : 1; // TODO: bonus sgx = 3 ?\n', '\t\t\t\tworkerWeight = 1 + c.score.mul(workerBonus).log();\n', '\t\t\t\ttotalWeight  = totalWeight.add(workerWeight);\n', '\t\t\t\tc.weight     = workerWeight; // store so we don&#39;t have to recompute\n', '\t\t\t}\n', '\t\t\telse // ContributionStatusEnum.REJECT or ContributionStatusEnum.CONTRIBUTED (not revealed)\n', '\t\t\t{\n', '\t\t\t\ttotalReward = totalReward.add(_consensus.stakeAmount);\n', '\t\t\t}\n', '\t\t}\n', '\t\trequire(totalWeight > 0);\n', '\n', '\t\t// compute how much is going to the workers\n', '\t\tuint256 totalWorkersReward = totalReward.percentage(uint256(100).sub(_consensus.schedulerRewardRatioPolicy));\n', '\n', '\t\tfor (i = 0; i<contributors.length; ++i)\n', '\t\t{\n', '\t\t\tw = contributors[i];\n', '\t\t\tif (m_contributions[_woid][w].status == IexecLib.ContributionStatusEnum.PROVED)\n', '\t\t\t{\n', '\t\t\t\tindividualWorkerReward = totalWorkersReward.mulByFraction(m_contributions[_woid][w].weight, totalWeight);\n', '\t\t\t\ttotalReward  = totalReward.sub(individualWorkerReward);\n', '\t\t\t\trequire(iexecHubInterface.unlockForWork(_woid, w, _consensus.stakeAmount));\n', '\t\t\t\trequire(iexecHubInterface.rewardForWork(_woid, w, individualWorkerReward, true));\n', '\t\t\t}\n', '\t\t\telse // WorkStatusEnum.POCO_REJECT or ContributionStatusEnum.CONTRIBUTED (not revealed)\n', '\t\t\t{\n', '\t\t\t\trequire(iexecHubInterface.seizeForWork(_woid, w, _consensus.stakeAmount, true));\n', '\t\t\t\t// No Reward\n', '\t\t\t}\n', '\t\t}\n', '\t\t// totalReward now contains the scheduler share\n', '\t\trequire(iexecHubInterface.rewardForWork(_woid, _consensus.workerpoolOwner, totalReward, false));\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '}\n', '\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract WorkerPoolHub is OwnableOZ // is Owned by IexecHub\n', '{\n', '\n', '\tusing SafeMathOZ for uint256;\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\t// worker => workerPool\n', '\tmapping(address => address)                     m_workerAffectation;\n', '\t// owner => index\n', '\tmapping(address => uint256)                     m_workerPoolCountByOwner;\n', '\t// owner => index => workerPool\n', '\tmapping(address => mapping(uint256 => address)) m_workerPoolByOwnerByIndex;\n', '\t//  workerPool => owner // stored in the workerPool\n', '\t/* mapping(address => address)                     m_ownerByWorkerPool; */\n', '\tmapping(address => bool)                        m_workerPoolRegistered;\n', '\n', '\tmapping(uint256 => address)                     m_workerPoolByIndex;\n', '\tuint256 public                                  m_totalWorkerPoolCount;\n', '\n', '\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction WorkerPoolHub() public\n', '\t{\n', '\t}\n', '\n', '\t/**\n', '\t * Methods\n', '\t */\n', '\tfunction isWorkerPoolRegistered(address _workerPool) public view returns (bool)\n', '\t{\n', '\t\treturn m_workerPoolRegistered[_workerPool];\n', '\t}\n', '\tfunction getWorkerPoolsCount(address _owner) public view returns (uint256)\n', '\t{\n', '\t\treturn m_workerPoolCountByOwner[_owner];\n', '\t}\n', '\tfunction getWorkerPool(address _owner, uint256 _index) public view returns (address)\n', '\t{\n', '\t\treturn m_workerPoolByOwnerByIndex[_owner][_index];\n', '\t}\n', '\tfunction getWorkerPoolByIndex(uint256 _index) public view returns (address)\n', '\t{\n', '\t\treturn m_workerPoolByIndex[_index];\n', '\t}\n', '\tfunction getWorkerAffectation(address _worker) public view returns (address workerPool)\n', '\t{\n', '\t\treturn m_workerAffectation[_worker];\n', '\t}\n', '\n', '\tfunction addWorkerPool(address _owner, address _workerPool) internal\n', '\t{\n', '\t\tuint id = m_workerPoolCountByOwner[_owner].add(1);\n', '\t\tm_totalWorkerPoolCount = m_totalWorkerPoolCount.add(1);\n', '\t\tm_workerPoolByIndex       [m_totalWorkerPoolCount] = _workerPool;\n', '\t\tm_workerPoolCountByOwner  [_owner]                 = id;\n', '\t\tm_workerPoolByOwnerByIndex[_owner][id]             = _workerPool;\n', '\t\tm_workerPoolRegistered    [_workerPool]            = true;\n', '\t}\n', '\n', '\tfunction createWorkerPool(\n', '\t\tstring _description,\n', '\t\tuint256 _subscriptionLockStakePolicy,\n', '\t\tuint256 _subscriptionMinimumStakePolicy,\n', '\t\tuint256 _subscriptionMinimumScorePolicy,\n', '\t\taddress _marketplaceAddress)\n', '\texternal onlyOwner /*owner == IexecHub*/ returns (address createdWorkerPool)\n', '\t{\n', '\t\t// tx.origin == owner\n', '\t\t// msg.sender == IexecHub\n', '\t\t// At creating ownership is transfered to tx.origin\n', '\t\taddress newWorkerPool = new WorkerPool(\n', '\t\t\tmsg.sender, // iexecHubAddress\n', '\t\t\t_description,\n', '\t\t\t_subscriptionLockStakePolicy,\n', '\t\t\t_subscriptionMinimumStakePolicy,\n', '\t\t\t_subscriptionMinimumScorePolicy,\n', '\t\t\t_marketplaceAddress\n', '\t\t);\n', '\t\taddWorkerPool(tx.origin, newWorkerPool);\n', '\t\treturn newWorkerPool;\n', '\t}\n', '\n', '\tfunction registerWorkerAffectation(address _workerPool, address _worker) public onlyOwner /*owner == IexecHub*/ returns (bool subscribed)\n', '\t{\n', '\t\t// you must have no cuurent affectation on others worker Pool\n', '\t\trequire(m_workerAffectation[_worker] == address(0));\n', '\t\tm_workerAffectation[_worker] = _workerPool;\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction unregisterWorkerAffectation(address _workerPool, address _worker) public onlyOwner /*owner == IexecHub*/ returns (bool unsubscribed)\n', '\t{\n', '\t\trequire(m_workerAffectation[_worker] == _workerPool);\n', '\t\tm_workerAffectation[_worker] = address(0);\n', '\t\treturn true;\n', '\t}\n', '}']
['//v1.0.14\n', '//License: Apache2.0\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract TokenSpender {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\n', '}\n', '\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' * last open zepplin version used for : add sub mul div function : https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', '* commit : https://github.com/OpenZeppelin/zeppelin-solidity/commit/815d9e1f457f57cfbb1b4e889f2255c9a517f661\n', ' */\n', 'library SafeMathOZ\n', '{\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tuint256 c = a + b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tif (a == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\tuint256 c = a * b;\n', '\t\tassert(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t\tuint256 c = a / b;\n', "\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\t\treturn c;\n', '\t}\n', '\n', '\tfunction max(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn a >= b ? a : b;\n', '\t}\n', '\n', '\tfunction min(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn a < b ? a : b;\n', '\t}\n', '\n', '\tfunction mulByFraction(uint256 a, uint256 b, uint256 c) internal pure returns (uint256)\n', '\t{\n', '\t\treturn div(mul(a, b), c);\n', '\t}\n', '\n', '\tfunction percentage(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn mulByFraction(a, b, 100);\n', '\t}\n', '\t// Source : https://ethereum.stackexchange.com/questions/8086/logarithm-math-operation-in-solidity\n', '\tfunction log(uint x) internal pure returns (uint y)\n', '\t{\n', '\t\tassembly\n', '\t\t{\n', '\t\t\tlet arg := x\n', '\t\t\tx := sub(x,1)\n', '\t\t\tx := or(x, div(x, 0x02))\n', '\t\t\tx := or(x, div(x, 0x04))\n', '\t\t\tx := or(x, div(x, 0x10))\n', '\t\t\tx := or(x, div(x, 0x100))\n', '\t\t\tx := or(x, div(x, 0x10000))\n', '\t\t\tx := or(x, div(x, 0x100000000))\n', '\t\t\tx := or(x, div(x, 0x10000000000000000))\n', '\t\t\tx := or(x, div(x, 0x100000000000000000000000000000000))\n', '\t\t\tx := add(x, 1)\n', '\t\t\tlet m := mload(0x40)\n', '\t\t\tmstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\n', '\t\t\tmstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\n', '\t\t\tmstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\n', '\t\t\tmstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\n', '\t\t\tmstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\n', '\t\t\tmstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\n', '\t\t\tmstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\n', '\t\t\tmstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\n', '\t\t\tmstore(0x40, add(m, 0x100))\n', '\t\t\tlet magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\n', '\t\t\tlet shift := 0x100000000000000000000000000000000000000000000000000000000000000\n', '\t\t\tlet a := div(mul(x, magic), shift)\n', '\t\t\ty := div(mload(add(m,sub(255,a))), shift)\n', '\t\t\ty := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\n', '\t\t}\n', '\t}\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender == owner)\n', '      _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract OwnableOZ\n', '{\n', '\taddress public m_owner;\n', '\tbool    public m_changeable;\n', '\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\t/**\n', '\t * @dev Throws if called by any account other than the owner.\n', '\t */\n', '\tmodifier onlyOwner()\n', '\t{\n', '\t\trequire(msg.sender == m_owner);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '\t * account.\n', '\t */\n', '\tfunction OwnableOZ() public\n', '\t{\n', '\t\tm_owner      = msg.sender;\n', '\t\tm_changeable = true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '\t * @param _newOwner The address to transfer ownership to.\n', '\t */\n', '\tfunction setImmutableOwnership(address _newOwner) public onlyOwner\n', '\t{\n', '\t\trequire(m_changeable);\n', '\t\trequire(_newOwner != address(0));\n', '\t\temit OwnershipTransferred(m_owner, _newOwner);\n', '\t\tm_owner      = _newOwner;\n', '\t\tm_changeable = false;\n', '\t}\n', '\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract RLC is ERC20, SafeMath, Ownable {\n', '\n', '    /* Public variables of the token */\n', '  string public name;       //fancy name\n', '  string public symbol;\n', '  uint8 public decimals;    //How many decimals to show.\n', "  string public version = 'v0.1';\n", '  uint public initialSupply;\n', '  uint public totalSupply;\n', '  bool public locked;\n', '  //uint public unlockBlock;\n', '\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  // lock transfer during the ICO\n', '  modifier onlyUnlocked() {\n', '    if (msg.sender != owner && locked) throw;\n', '    _;\n', '  }\n', '\n', '  /*\n', '   *  The RLC Token created with the time at which the crowdsale end\n', '   */\n', '\n', '  function RLC() {\n', '    // lock the transfer function during the crowdsale\n', '    locked = true;\n', '    //unlockBlock=  now + 45 days; // (testnet) - for mainnet put the block number\n', '\n', '    initialSupply = 87000000000000000;\n', '    totalSupply = initialSupply;\n', '    balances[msg.sender] = initialSupply;// Give the creator all initial tokens\n', "    name = 'iEx.ec Network Token';        // Set the name for display purposes\n", "    symbol = 'RLC';                       // Set the symbol for display purposes\n", '    decimals = 9;                        // Amount of decimals for display purposes\n', '  }\n', '\n', '  function unlock() onlyOwner {\n', '    locked = false;\n', '  }\n', '\n', '  function burn(uint256 _value) returns (bool){\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value) ;\n', '    totalSupply = safeSub(totalSupply, _value);\n', '    Transfer(msg.sender, 0x0, _value);\n', '    return true;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) onlyUnlocked returns (bool) {\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) onlyUnlocked returns (bool) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '    /* Approve and then comunicate the approved contract in a single tx */\n', '  function approveAndCall(address _spender, uint256 _value, bytes _extraData){\n', '      TokenSpender spender = TokenSpender(_spender);\n', '      if (approve(_spender, _value)) {\n', '          spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '      }\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'library IexecLib\n', '{\n', '\t/***************************************************************************/\n', '\t/*                              Market Order                               */\n', '\t/***************************************************************************/\n', '\tenum MarketOrderDirectionEnum\n', '\t{\n', '\t\tUNSET,\n', '\t\tBID,\n', '\t\tASK,\n', '\t\tCLOSED\n', '\t}\n', '\tstruct MarketOrder\n', '\t{\n', '\t\tMarketOrderDirectionEnum direction;\n', '\t\tuint256 category;        // runtime selection\n', '\t\tuint256 trust;           // for PoCo\n', '\t\tuint256 value;           // value/cost/price\n', '\t\tuint256 volume;          // quantity of instances (total)\n', '\t\tuint256 remaining;       // remaining instances\n', '\t\taddress workerpool;      // BID can use null for any\n', '\t\taddress workerpoolOwner; // fix ownership if workerpool ownership change during the workorder steps\n', '\t}\n', '\n', '\t/***************************************************************************/\n', '\t/*                               Work Order                                */\n', '\t/***************************************************************************/\n', '\tenum WorkOrderStatusEnum\n', '\t{\n', '\t\tUNSET,     // Work order not yet initialized (invalid address)\n', '\t\tACTIVE,    // Marketed → constributions are open\n', '\t\tREVEALING, // Starting consensus reveal\n', '\t\tCLAIMED,   // failed consensus\n', '\t\tCOMPLETED  // Concensus achieved\n', '\t}\n', '\n', '\t/***************************************************************************/\n', '\t/*                                Consensus                                */\n', '\t/*                                   ---                                   */\n', '\t/*                         used in WorkerPool.sol                          */\n', '\t/***************************************************************************/\n', '\tstruct Consensus\n', '\t{\n', '\t\tuint256 poolReward;\n', '\t\tuint256 stakeAmount;\n', '\t\tbytes32 consensus;\n', '\t\tuint256 revealDate;\n', '\t\tuint256 revealCounter;\n', '\t\tuint256 consensusTimeout;\n', '\t\tuint256 winnerCount;\n', '\t\taddress[] contributors;\n', '\t\taddress workerpoolOwner;\n', '\t\tuint256 schedulerRewardRatioPolicy;\n', '\n', '\t}\n', '\n', '\t/***************************************************************************/\n', '\t/*                              Contribution                               */\n', '\t/*                                   ---                                   */\n', '\t/*                         used in WorkerPool.sol                          */\n', '\t/***************************************************************************/\n', '\tenum ContributionStatusEnum\n', '\t{\n', '\t\tUNSET,\n', '\t\tAUTHORIZED,\n', '\t\tCONTRIBUTED,\n', '\t\tPROVED,\n', '\t\tREJECTED\n', '\t}\n', '\tstruct Contribution\n', '\t{\n', '\t\tContributionStatusEnum status;\n', '\t\tbytes32 resultHash;\n', '\t\tbytes32 resultSign;\n', '\t\taddress enclaveChallenge;\n', '\t\tuint256 score;\n', '\t\tuint256 weight;\n', '\t}\n', '\n', '\t/***************************************************************************/\n', '\t/*                Account / ContributionHistory / Category                 */\n', '\t/*                                   ---                                   */\n', '\t/*                          used in IexecHub.sol                           */\n', '\t/***************************************************************************/\n', '\tstruct Account\n', '\t{\n', '\t\tuint256 stake;\n', '\t\tuint256 locked;\n', '\t}\n', '\n', '\tstruct ContributionHistory // for credibility computation, f = failed/total\n', '\t{\n', '\t\tuint256 success;\n', '\t\tuint256 failed;\n', '\t}\n', '\n', '\tstruct Category\n', '\t{\n', '\t\tuint256 catid;\n', '\t\tstring  name;\n', '\t\tstring  description;\n', '\t\tuint256 workClockTimeRef;\n', '\t}\n', '\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract IexecHubInterface\n', '{\n', '\tRLC public rlc;\n', '\n', '\tfunction attachContracts(\n', '\t\taddress _tokenAddress,\n', '\t\taddress _marketplaceAddress,\n', '\t\taddress _workerPoolHubAddress,\n', '\t\taddress _appHubAddress,\n', '\t\taddress _datasetHubAddress)\n', '\t\tpublic;\n', '\n', '\tfunction setCategoriesCreator(\n', '\t\taddress _categoriesCreator)\n', '\tpublic;\n', '\n', '\tfunction createCategory(\n', '\t\tstring  _name,\n', '\t\tstring  _description,\n', '\t\tuint256 _workClockTimeRef)\n', '\tpublic returns (uint256 catid);\n', '\n', '\tfunction createWorkerPool(\n', '\t\tstring  _description,\n', '\t\tuint256 _subscriptionLockStakePolicy,\n', '\t\tuint256 _subscriptionMinimumStakePolicy,\n', '\t\tuint256 _subscriptionMinimumScorePolicy)\n', '\texternal returns (address createdWorkerPool);\n', '\n', '\tfunction createApp(\n', '\t\tstring  _appName,\n', '\t\tuint256 _appPrice,\n', '\t\tstring  _appParams)\n', '\texternal returns (address createdApp);\n', '\n', '\tfunction createDataset(\n', '\t\tstring  _datasetName,\n', '\t\tuint256 _datasetPrice,\n', '\t\tstring  _datasetParams)\n', '\texternal returns (address createdDataset);\n', '\n', '\tfunction buyForWorkOrder(\n', '\t\tuint256 _marketorderIdx,\n', '\t\taddress _workerpool,\n', '\t\taddress _app,\n', '\t\taddress _dataset,\n', '\t\tstring  _params,\n', '\t\taddress _callback,\n', '\t\taddress _beneficiary)\n', '\texternal returns (address);\n', '\n', '\tfunction isWoidRegistred(\n', '\t\taddress _woid)\n', '\tpublic view returns (bool);\n', '\n', '\tfunction lockWorkOrderCost(\n', '\t\taddress _requester,\n', '\t\taddress _workerpool, // Address of a smartcontract\n', '\t\taddress _app,        // Address of a smartcontract\n', '\t\taddress _dataset)    // Address of a smartcontract\n', '\tinternal returns (uint256);\n', '\n', '\tfunction claimFailedConsensus(\n', '\t\taddress _woid)\n', '\tpublic returns (bool);\n', '\n', '\tfunction finalizeWorkOrder(\n', '\t\taddress _woid,\n', '\t\tstring  _stdout,\n', '\t\tstring  _stderr,\n', '\t\tstring  _uri)\n', '\tpublic returns (bool);\n', '\n', '\tfunction getCategoryWorkClockTimeRef(\n', '\t\tuint256 _catId)\n', '\tpublic view returns (uint256 workClockTimeRef);\n', '\n', '\tfunction existingCategory(\n', '\t\tuint256 _catId)\n', '\tpublic view  returns (bool categoryExist);\n', '\n', '\tfunction getCategory(\n', '\t\tuint256 _catId)\n', '\t\tpublic view returns (uint256 catid, string name, string  description, uint256 workClockTimeRef);\n', '\n', '\tfunction getWorkerStatus(\n', '\t\taddress _worker)\n', '\tpublic view returns (address workerPool, uint256 workerScore);\n', '\n', '\tfunction getWorkerScore(address _worker) public view returns (uint256 workerScore);\n', '\n', '\tfunction registerToPool(address _worker) public returns (bool subscribed);\n', '\n', '\tfunction unregisterFromPool(address _worker) public returns (bool unsubscribed);\n', '\n', '\tfunction evictWorker(address _worker) public returns (bool unsubscribed);\n', '\n', '\tfunction removeWorker(address _workerpool, address _worker) internal returns (bool unsubscribed);\n', '\n', '\tfunction lockForOrder(address _user, uint256 _amount) public returns (bool);\n', '\n', '\tfunction unlockForOrder(address _user, uint256 _amount) public returns (bool);\n', '\n', '\tfunction lockForWork(address _woid, address _user, uint256 _amount) public returns (bool);\n', '\n', '\tfunction unlockForWork(address _woid, address _user, uint256 _amount) public returns (bool);\n', '\n', '\tfunction rewardForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public returns (bool);\n', '\n', '\tfunction seizeForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public returns (bool);\n', '\n', '\tfunction deposit(uint256 _amount) external returns (bool);\n', '\n', '\tfunction withdraw(uint256 _amount) external returns (bool);\n', '\n', '\tfunction checkBalance(address _owner) public view returns (uint256 stake, uint256 locked);\n', '\n', '\tfunction reward(address _user, uint256 _amount) internal returns (bool);\n', '\n', '\tfunction seize(address _user, uint256 _amount) internal returns (bool);\n', '\n', '\tfunction lock(address _user, uint256 _amount) internal returns (bool);\n', '\n', '\tfunction unlock(address _user, uint256 _amount) internal returns (bool);\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract IexecHubAccessor\n', '{\n', '\tIexecHubInterface internal iexecHubInterface;\n', '\n', '\tmodifier onlyIexecHub()\n', '\t{\n', '\t\trequire(msg.sender == address(iexecHubInterface));\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction IexecHubAccessor(address _iexecHubAddress) public\n', '\t{\n', '\t\trequire(_iexecHubAddress != address(0));\n', '\t\tiexecHubInterface = IexecHubInterface(_iexecHubAddress);\n', '\t}\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', 'contract MarketplaceInterface\n', '{\n', '\tfunction createMarketOrder(\n', '\t\tIexecLib.MarketOrderDirectionEnum _direction,\n', '\t\tuint256 _category,\n', '\t\tuint256 _trust,\n', '\t\tuint256 _value,\n', '\t\taddress _workerpool,\n', '\t\tuint256 _volume)\n', '\tpublic returns (uint);\n', '\n', '\tfunction closeMarketOrder(\n', '\t\tuint256 _marketorderIdx)\n', '\tpublic returns (bool);\n', '\n', '\tfunction getMarketOrderValue(\n', '\t\tuint256 _marketorderIdx)\n', '\tpublic view returns(uint256);\n', '\n', '\tfunction getMarketOrderWorkerpoolOwner(\n', '\t\tuint256 _marketorderIdx)\n', '\tpublic view returns(address);\n', '\n', '\tfunction getMarketOrderCategory(\n', '\t\tuint256 _marketorderIdx)\n', '\tpublic view returns (uint256);\n', '\n', '\tfunction getMarketOrderTrust(\n', '\t\tuint256 _marketorderIdx)\n', '\tpublic view returns(uint256);\n', '\n', '\tfunction getMarketOrder(\n', '\t\tuint256 _marketorderIdx)\n', '\tpublic view returns(\n', '\t\tIexecLib.MarketOrderDirectionEnum direction,\n', '\t\tuint256 category,       // runtime selection\n', '\t\tuint256 trust,          // for PoCo\n', '\t\tuint256 value,          // value/cost/price\n', '\t\tuint256 volume,         // quantity of instances (total)\n', '\t\tuint256 remaining,      // remaining instances\n', '\t\taddress workerpool);    // BID can use null for any\n', '}\n', '\n', '\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract MarketplaceAccessor\n', '{\n', '\taddress              internal marketplaceAddress;\n', '\tMarketplaceInterface internal marketplaceInterface;\n', '/* not used\n', '\tmodifier onlyMarketplace()\n', '\t{\n', '\t\trequire(msg.sender == marketplaceAddress);\n', '\t\t_;\n', '\t}*/\n', '\n', '\tfunction MarketplaceAccessor(address _marketplaceAddress) public\n', '\t{\n', '\t\trequire(_marketplaceAddress != address(0));\n', '\t\tmarketplaceAddress   = _marketplaceAddress;\n', '\t\tmarketplaceInterface = MarketplaceInterface(_marketplaceAddress);\n', '\t}\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract WorkOrder\n', '{\n', '\n', '\n', '\tevent WorkOrderActivated();\n', '\tevent WorkOrderReActivated();\n', '\tevent WorkOrderRevealing();\n', '\tevent WorkOrderClaimed  ();\n', '\tevent WorkOrderCompleted();\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tIexecLib.WorkOrderStatusEnum public m_status;\n', '\n', '\tuint256 public m_marketorderIdx;\n', '\n', '\taddress public m_app;\n', '\taddress public m_dataset;\n', '\taddress public m_workerpool;\n', '\taddress public m_requester;\n', '\n', '\tuint256 public m_emitcost;\n', '\tstring  public m_params;\n', '\taddress public m_callback;\n', '\taddress public m_beneficiary;\n', '\n', '\tbytes32 public m_resultCallbackProof;\n', '\tstring  public m_stdout;\n', '\tstring  public m_stderr;\n', '\tstring  public m_uri;\n', '\n', '\taddress public m_iexecHubAddress;\n', '\n', '\tmodifier onlyIexecHub()\n', '\t{\n', '\t\trequire(msg.sender == m_iexecHubAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction WorkOrder(\n', '\t\tuint256 _marketorderIdx,\n', '\t\taddress _requester,\n', '\t\taddress _app,\n', '\t\taddress _dataset,\n', '\t\taddress _workerpool,\n', '\t\tuint256 _emitcost,\n', '\t\tstring  _params,\n', '\t\taddress _callback,\n', '\t\taddress _beneficiary)\n', '\tpublic\n', '\t{\n', '\t\tm_iexecHubAddress = msg.sender;\n', '\t\trequire(_requester != address(0));\n', '\t\tm_status         = IexecLib.WorkOrderStatusEnum.ACTIVE;\n', '\t\tm_marketorderIdx = _marketorderIdx;\n', '\t\tm_app            = _app;\n', '\t\tm_dataset        = _dataset;\n', '\t\tm_workerpool     = _workerpool;\n', '\t\tm_requester      = _requester;\n', '\t\tm_emitcost       = _emitcost;\n', '\t\tm_params         = _params;\n', '\t\tm_callback       = _callback;\n', '\t\tm_beneficiary    = _beneficiary;\n', '\t\t// needed for the scheduler to authorize api token access on this m_beneficiary address in case _requester is a smart contract.\n', '\t}\n', '\n', '\tfunction startRevealingPhase() public returns (bool)\n', '\t{\n', '\t\trequire(m_workerpool == msg.sender);\n', '\t\trequire(m_status == IexecLib.WorkOrderStatusEnum.ACTIVE);\n', '\t\tm_status = IexecLib.WorkOrderStatusEnum.REVEALING;\n', '\t\temit WorkOrderRevealing();\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction reActivate() public returns (bool)\n', '\t{\n', '\t\trequire(m_workerpool == msg.sender);\n', '\t\trequire(m_status == IexecLib.WorkOrderStatusEnum.REVEALING);\n', '\t\tm_status = IexecLib.WorkOrderStatusEnum.ACTIVE;\n', '\t\temit WorkOrderReActivated();\n', '\t\treturn true;\n', '\t}\n', '\n', '\n', '\tfunction claim() public onlyIexecHub\n', '\t{\n', '\t\trequire(m_status == IexecLib.WorkOrderStatusEnum.ACTIVE || m_status == IexecLib.WorkOrderStatusEnum.REVEALING);\n', '\t\tm_status = IexecLib.WorkOrderStatusEnum.CLAIMED;\n', '\t\temit WorkOrderClaimed();\n', '\t}\n', '\n', '\n', '\tfunction setResult(string _stdout, string _stderr, string _uri) public onlyIexecHub\n', '\t{\n', '\t\trequire(m_status == IexecLib.WorkOrderStatusEnum.REVEALING);\n', '\t\tm_status = IexecLib.WorkOrderStatusEnum.COMPLETED;\n', '\t\tm_stdout = _stdout;\n', '\t\tm_stderr = _stderr;\n', '\t\tm_uri    = _uri;\n', '\t\tm_resultCallbackProof =keccak256(_stdout,_stderr,_uri);\n', '\t\temit WorkOrderCompleted();\n', '\t}\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract IexecCallbackInterface\n', '{\n', '\n', '\tfunction workOrderCallback(\n', '\t\taddress _woid,\n', '\t\tstring  _stdout,\n', '\t\tstring  _stderr,\n', '\t\tstring  _uri) public returns (bool);\n', '\n', '\tevent WorkOrderCallback(address woid, string stdout, string stderr, string uri);\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract Marketplace is IexecHubAccessor\n', '{\n', '\tusing SafeMathOZ for uint256;\n', '\n', '\t/**\n', '\t * Marketplace\n', '\t */\n', '\tuint                                 public m_orderCount;\n', '\tmapping(uint =>IexecLib.MarketOrder) public m_orderBook;\n', '\n', '\tuint256 public constant ASK_STAKE_RATIO  = 30;\n', '\n', '\t/**\n', '\t * Events\n', '\t */\n', '\tevent MarketOrderCreated   (uint marketorderIdx);\n', '\tevent MarketOrderClosed    (uint marketorderIdx);\n', '\tevent MarketOrderAskConsume(uint marketorderIdx, address requester);\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction Marketplace(address _iexecHubAddress)\n', '\tIexecHubAccessor(_iexecHubAddress)\n', '\tpublic\n', '\t{\n', '\t}\n', '\n', '\t/**\n', '\t * Market orders\n', '\t */\n', '\tfunction createMarketOrder(\n', '\t\tIexecLib.MarketOrderDirectionEnum _direction,\n', '\t\tuint256 _category,\n', '\t\tuint256 _trust,\n', '\t\tuint256 _value,\n', '\t\taddress _workerpool,\n', '\t\tuint256 _volume)\n', '\tpublic returns (uint)\n', '\t{\n', '\t\trequire(iexecHubInterface.existingCategory(_category));\n', '\t\trequire(_volume >0);\n', '\t\tm_orderCount = m_orderCount.add(1);\n', '\t\tIexecLib.MarketOrder storage marketorder    = m_orderBook[m_orderCount];\n', '\t\tmarketorder.direction      = _direction;\n', '\t\tmarketorder.category       = _category;\n', '\t\tmarketorder.trust          = _trust;\n', '\t\tmarketorder.value          = _value;\n', '\t\tmarketorder.volume         = _volume;\n', '\t\tmarketorder.remaining      = _volume;\n', '\n', '\t\tif (_direction == IexecLib.MarketOrderDirectionEnum.ASK)\n', '\t\t{\n', '\t\t\trequire(WorkerPool(_workerpool).m_owner() == msg.sender);\n', '\n', '\t\t\trequire(iexecHubInterface.lockForOrder(msg.sender, _value.percentage(ASK_STAKE_RATIO).mul(_volume))); // mul must be done after percentage to avoid rounding errors\n', '\t\t\tmarketorder.workerpool      = _workerpool;\n', '\t\t\tmarketorder.workerpoolOwner = msg.sender;\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\t// no BID implementation\n', '\t\t\trevert();\n', '\t\t}\n', '\t\temit MarketOrderCreated(m_orderCount);\n', '\t\treturn m_orderCount;\n', '\t}\n', '\n', '\tfunction closeMarketOrder(uint256 _marketorderIdx) public returns (bool)\n', '\t{\n', '\t\tIexecLib.MarketOrder storage marketorder = m_orderBook[_marketorderIdx];\n', '\t\tif (marketorder.direction == IexecLib.MarketOrderDirectionEnum.ASK)\n', '\t\t{\n', '\t\t\trequire(marketorder.workerpoolOwner == msg.sender);\n', '\t\t\trequire(iexecHubInterface.unlockForOrder(marketorder.workerpoolOwner, marketorder.value.percentage(ASK_STAKE_RATIO).mul(marketorder.remaining))); // mul must be done after percentage to avoid rounding errors\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\t// no BID implementation\n', '\t\t\trevert();\n', '\t\t}\n', '\t\tmarketorder.direction = IexecLib.MarketOrderDirectionEnum.CLOSED;\n', '\t\temit MarketOrderClosed(_marketorderIdx);\n', '\t\treturn true;\n', '\t}\n', '\n', '\n', '\t/**\n', '\t * Assets consumption\n', '\t */\n', '\tfunction consumeMarketOrderAsk(\n', '\t\tuint256 _marketorderIdx,\n', '\t\taddress _requester,\n', '\t\taddress _workerpool)\n', '\tpublic onlyIexecHub returns (bool)\n', '\t{\n', '\t\tIexecLib.MarketOrder storage marketorder = m_orderBook[_marketorderIdx];\n', '\t\trequire(marketorder.direction  == IexecLib.MarketOrderDirectionEnum.ASK);\n', '\t\trequire(marketorder.remaining  >  0);\n', '\t\trequire(marketorder.workerpool == _workerpool);\n', '\n', '\t\tmarketorder.remaining = marketorder.remaining.sub(1);\n', '\t\tif (marketorder.remaining == 0)\n', '\t\t{\n', '\t\t\tmarketorder.direction = IexecLib.MarketOrderDirectionEnum.CLOSED;\n', '\t\t}\n', '\t\trequire(iexecHubInterface.lockForOrder(_requester, marketorder.value));\n', '\t\temit MarketOrderAskConsume(_marketorderIdx, _requester);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction existingMarketOrder(uint256 _marketorderIdx) public view  returns (bool marketOrderExist)\n', '\t{\n', '\t\treturn m_orderBook[_marketorderIdx].category > 0;\n', '\t}\n', '\n', '\t/**\n', '\t * Views\n', '\t */\n', '\tfunction getMarketOrderValue(uint256 _marketorderIdx) public view returns (uint256)\n', '\t{\n', '\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\n', '\t\treturn m_orderBook[_marketorderIdx].value;\n', '\t}\n', '\tfunction getMarketOrderWorkerpoolOwner(uint256 _marketorderIdx) public view returns (address)\n', '\t{\n', '\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\n', '\t\treturn m_orderBook[_marketorderIdx].workerpoolOwner;\n', '\t}\n', '\tfunction getMarketOrderCategory(uint256 _marketorderIdx) public view returns (uint256)\n', '\t{\n', '\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\n', '\t\treturn m_orderBook[_marketorderIdx].category;\n', '\t}\n', '\tfunction getMarketOrderTrust(uint256 _marketorderIdx) public view returns (uint256)\n', '\t{\n', '\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\n', '\t\treturn m_orderBook[_marketorderIdx].trust;\n', '\t}\n', '\tfunction getMarketOrder(uint256 _marketorderIdx) public view returns\n', '\t(\n', '\t\tIexecLib.MarketOrderDirectionEnum direction,\n', '\t\tuint256 category,       // runtime selection\n', '\t\tuint256 trust,          // for PoCo\n', '\t\tuint256 value,          // value/cost/price\n', '\t\tuint256 volume,         // quantity of instances (total)\n', '\t\tuint256 remaining,      // remaining instances\n', '\t\taddress workerpool,     // BID can use null for any\n', '\t\taddress workerpoolOwner)\n', '\t{\n', '\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\n', '\t\tIexecLib.MarketOrder storage marketorder = m_orderBook[_marketorderIdx];\n', '\t\treturn (\n', '\t\t\tmarketorder.direction,\n', '\t\t\tmarketorder.category,\n', '\t\t\tmarketorder.trust,\n', '\t\t\tmarketorder.value,\n', '\t\t\tmarketorder.volume,\n', '\t\t\tmarketorder.remaining,\n', '\t\t\tmarketorder.workerpool,\n', '\t\t\tmarketorder.workerpoolOwner\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * Callback Proof managment\n', '\t */\n', '\n', '\tevent WorkOrderCallbackProof(address indexed woid, address requester, address beneficiary,address indexed callbackTo, address indexed gasCallbackProvider,string stdout, string stderr , string uri);\n', '\n', '\t//mapping(workorder => bool)\n', '\t mapping(address => bool) m_callbackDone;\n', '\n', '\t function isCallbackDone(address _woid) public view  returns (bool callbackDone)\n', '\t {\n', '\t\t return m_callbackDone[_woid];\n', '\t }\n', '\n', '\t function workOrderCallback(address _woid,string _stdout, string _stderr, string _uri) public\n', '\t {\n', '\t\t require(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\t require(!isCallbackDone(_woid));\n', '\t\t m_callbackDone[_woid] = true;\n', '\t\t require(WorkOrder(_woid).m_status() == IexecLib.WorkOrderStatusEnum.COMPLETED);\n', '\t\t require(WorkOrder(_woid).m_resultCallbackProof() == keccak256(_stdout,_stderr,_uri));\n', '\t\t address callbackTo =WorkOrder(_woid).m_callback();\n', '\t\t require(callbackTo != address(0));\n', '\t\t require(IexecCallbackInterface(callbackTo).workOrderCallback(\n', '\t\t\t _woid,\n', '\t\t\t _stdout,\n', '\t\t\t _stderr,\n', '\t\t\t _uri\n', '\t\t ));\n', '\t\t emit WorkOrderCallbackProof(_woid,WorkOrder(_woid).m_requester(),WorkOrder(_woid).m_beneficiary(),callbackTo,tx.origin,_stdout,_stderr,_uri);\n', '\t }\n', '\n', '}\n', '\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract App is OwnableOZ, IexecHubAccessor\n', '{\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tstring        public m_appName;\n', '\tuint256       public m_appPrice;\n', '\tstring        public m_appParams;\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction App(\n', '\t\taddress _iexecHubAddress,\n', '\t\tstring  _appName,\n', '\t\tuint256 _appPrice,\n', '\t\tstring  _appParams)\n', '\tIexecHubAccessor(_iexecHubAddress)\n', '\tpublic\n', '\t{\n', '\t\t// tx.origin == owner\n', '\t\t// msg.sender == DatasetHub\n', '\t\trequire(tx.origin != msg.sender);\n', '\t\tsetImmutableOwnership(tx.origin); // owner → tx.origin\n', '\n', '\t\tm_appName   = _appName;\n', '\t\tm_appPrice  = _appPrice;\n', '\t\tm_appParams = _appParams;\n', '\n', '\t}\n', '\n', '\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', 'contract AppHub is OwnableOZ // is Owned by IexecHub\n', '{\n', '\n', '\tusing SafeMathOZ for uint256;\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tmapping(address => uint256)                     m_appCountByOwner;\n', '\tmapping(address => mapping(uint256 => address)) m_appByOwnerByIndex;\n', '\tmapping(address => bool)                        m_appRegistered;\n', '\n', '\tmapping(uint256 => address)                     m_appByIndex;\n', '\tuint256 public                                  m_totalAppCount;\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction AppHub() public\n', '\t{\n', '\t}\n', '\n', '\t/**\n', '\t * Methods\n', '\t */\n', '\tfunction isAppRegistered(address _app) public view returns (bool)\n', '\t{\n', '\t\treturn m_appRegistered[_app];\n', '\t}\n', '\tfunction getAppsCount(address _owner) public view returns (uint256)\n', '\t{\n', '\t\treturn m_appCountByOwner[_owner];\n', '\t}\n', '\tfunction getApp(address _owner, uint256 _index) public view returns (address)\n', '\t{\n', '\t\treturn m_appByOwnerByIndex[_owner][_index];\n', '\t}\n', '\tfunction getAppByIndex(uint256 _index) public view returns (address)\n', '\t{\n', '\t\treturn m_appByIndex[_index];\n', '\t}\n', '\n', '\tfunction addApp(address _owner, address _app) internal\n', '\t{\n', '\t\tuint id = m_appCountByOwner[_owner].add(1);\n', '\t\tm_totalAppCount=m_totalAppCount.add(1);\n', '\t\tm_appByIndex       [m_totalAppCount] = _app;\n', '\t\tm_appCountByOwner  [_owner]          = id;\n', '\t\tm_appByOwnerByIndex[_owner][id]      = _app;\n', '\t\tm_appRegistered    [_app]            = true;\n', '\t}\n', '\n', '\tfunction createApp(\n', '\t\tstring  _appName,\n', '\t\tuint256 _appPrice,\n', '\t\tstring  _appParams)\n', '\tpublic onlyOwner /*owner == IexecHub*/ returns (address createdApp)\n', '\t{\n', '\t\t// tx.origin == owner\n', '\t\t// msg.sender == IexecHub\n', '\t\taddress newApp = new App(\n', '\t\t\tmsg.sender,\n', '\t\t\t_appName,\n', '\t\t\t_appPrice,\n', '\t\t\t_appParams\n', '\t\t);\n', '\t\taddApp(tx.origin, newApp);\n', '\t\treturn newApp;\n', '\t}\n', '\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract Dataset is OwnableOZ, IexecHubAccessor\n', '{\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tstring            public m_datasetName;\n', '\tuint256           public m_datasetPrice;\n', '\tstring            public m_datasetParams;\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction Dataset(\n', '\t\taddress _iexecHubAddress,\n', '\t\tstring  _datasetName,\n', '\t\tuint256 _datasetPrice,\n', '\t\tstring  _datasetParams)\n', '\tIexecHubAccessor(_iexecHubAddress)\n', '\tpublic\n', '\t{\n', '\t\t// tx.origin == owner\n', '\t\t// msg.sender == DatasetHub\n', '\t\trequire(tx.origin != msg.sender);\n', '\t\tsetImmutableOwnership(tx.origin); // owner → tx.origin\n', '\n', '\t\tm_datasetName   = _datasetName;\n', '\t\tm_datasetPrice  = _datasetPrice;\n', '\t\tm_datasetParams = _datasetParams;\n', '\n', '\t}\n', '\n', '\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract DatasetHub is OwnableOZ // is Owned by IexecHub\n', '{\n', '\tusing SafeMathOZ for uint256;\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tmapping(address => uint256)                     m_datasetCountByOwner;\n', '\tmapping(address => mapping(uint256 => address)) m_datasetByOwnerByIndex;\n', '\tmapping(address => bool)                        m_datasetRegistered;\n', '\n', '\tmapping(uint256 => address)                     m_datasetByIndex;\n', '\tuint256 public                                  m_totalDatasetCount;\n', '\n', '\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction DatasetHub() public\n', '\t{\n', '\t}\n', '\n', '\t/**\n', '\t * Methods\n', '\t */\n', '\tfunction isDatasetRegistred(address _dataset) public view returns (bool)\n', '\t{\n', '\t\treturn m_datasetRegistered[_dataset];\n', '\t}\n', '\tfunction getDatasetsCount(address _owner) public view returns (uint256)\n', '\t{\n', '\t\treturn m_datasetCountByOwner[_owner];\n', '\t}\n', '\tfunction getDataset(address _owner, uint256 _index) public view returns (address)\n', '\t{\n', '\t\treturn m_datasetByOwnerByIndex[_owner][_index];\n', '\t}\n', '\tfunction getDatasetByIndex(uint256 _index) public view returns (address)\n', '\t{\n', '\t\treturn m_datasetByIndex[_index];\n', '\t}\n', '\n', '\tfunction addDataset(address _owner, address _dataset) internal\n', '\t{\n', '\t\tuint id = m_datasetCountByOwner[_owner].add(1);\n', '\t\tm_totalDatasetCount = m_totalDatasetCount.add(1);\n', '\t\tm_datasetByIndex       [m_totalDatasetCount] = _dataset;\n', '\t\tm_datasetCountByOwner  [_owner]              = id;\n', '\t\tm_datasetByOwnerByIndex[_owner][id]          = _dataset;\n', '\t\tm_datasetRegistered    [_dataset]            = true;\n', '\t}\n', '\n', '\tfunction createDataset(\n', '\t\tstring _datasetName,\n', '\t\tuint256 _datasetPrice,\n', '\t\tstring _datasetParams)\n', '\tpublic onlyOwner /*owner == IexecHub*/ returns (address createdDataset)\n', '\t{\n', '\t\t// tx.origin == owner\n', '\t\t// msg.sender == IexecHub\n', '\t\taddress newDataset = new Dataset(\n', '\t\t\tmsg.sender,\n', '\t\t\t_datasetName,\n', '\t\t\t_datasetPrice,\n', '\t\t\t_datasetParams\n', '\t\t);\n', '\t\taddDataset(tx.origin, newDataset);\n', '\t\treturn newDataset;\n', '\t}\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '/**\n', ' * @title IexecHub\n', ' */\n', '\n', 'contract IexecHub\n', '{\n', '\tusing SafeMathOZ for uint256;\n', '\n', '\t/**\n', '\t* RLC contract for token transfers.\n', '\t*/\n', '\tRLC public rlc;\n', '\n', '\tuint256 public constant STAKE_BONUS_RATIO         = 10;\n', '\tuint256 public constant STAKE_BONUS_MIN_THRESHOLD = 1000;\n', '\tuint256 public constant SCORE_UNITARY_SLASH       = 50;\n', '\n', '\t/**\n', '\t * Slaves contracts\n', '\t */\n', '\tAppHub        public appHub;\n', '\tDatasetHub    public datasetHub;\n', '\tWorkerPoolHub public workerPoolHub;\n', '\n', '\t/**\n', '\t * Market place\n', '\t */\n', '\tMarketplace public marketplace;\n', '\tmodifier onlyMarketplace()\n', '\t{\n', '\t\trequire(msg.sender == address(marketplace));\n', '\t\t_;\n', '\t}\n', '\t/**\n', '\t * Categories\n', '\t */\n', '\tmapping(uint256 => IexecLib.Category) public m_categories;\n', '\tuint256                               public m_categoriesCount;\n', '\taddress                               public m_categoriesCreator;\n', '\tmodifier onlyCategoriesCreator()\n', '\t{\n', '\t\trequire(msg.sender == m_categoriesCreator);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * Escrow\n', '\t */\n', '\tmapping(address => IexecLib.Account) public m_accounts;\n', '\n', '\n', '\t/**\n', '\t * workOrder Registered\n', '\t */\n', '\tmapping(address => bool) public m_woidRegistered;\n', '\tmodifier onlyRegisteredWoid(address _woid)\n', '\t{\n', '\t\trequire(m_woidRegistered[_woid]);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * Reputation for PoCo\n', '\t */\n', '\tmapping(address => uint256)  public m_scores;\n', '\tIexecLib.ContributionHistory public m_contributionHistory;\n', '\n', '\n', '\tevent WorkOrderActivated(address woid, address indexed workerPool);\n', '\tevent WorkOrderClaimed  (address woid, address workerPool);\n', '\tevent WorkOrderCompleted(address woid, address workerPool);\n', '\n', '\tevent CreateApp       (address indexed appOwner,        address indexed app,        string appName,     uint256 appPrice,     string appParams    );\n', '\tevent CreateDataset   (address indexed datasetOwner,    address indexed dataset,    string datasetName, uint256 datasetPrice, string datasetParams);\n', '\tevent CreateWorkerPool(address indexed workerPoolOwner, address indexed workerPool, string workerPoolDescription                                        );\n', '\n', '\tevent CreateCategory  (uint256 catid, string name, string description, uint256 workClockTimeRef);\n', '\n', '\tevent WorkerPoolSubscription  (address indexed workerPool, address worker);\n', '\tevent WorkerPoolUnsubscription(address indexed workerPool, address worker);\n', '\tevent WorkerPoolEviction      (address indexed workerPool, address worker);\n', '\n', '\tevent AccurateContribution(address woid, address indexed worker);\n', '\tevent FaultyContribution  (address woid, address indexed worker);\n', '\n', '\tevent Deposit (address owner, uint256 amount);\n', '\tevent Withdraw(address owner, uint256 amount);\n', '\tevent Reward  (address user,  uint256 amount);\n', '\tevent Seize   (address user,  uint256 amount);\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction IexecHub()\n', '\tpublic\n', '\t{\n', '\t\tm_categoriesCreator = msg.sender;\n', '\t}\n', '\n', '\tfunction attachContracts(\n', '\t\taddress _tokenAddress,\n', '\t\taddress _marketplaceAddress,\n', '\t\taddress _workerPoolHubAddress,\n', '\t\taddress _appHubAddress,\n', '\t\taddress _datasetHubAddress)\n', '\tpublic onlyCategoriesCreator\n', '\t{\n', '\t\trequire(address(rlc) == address(0));\n', '\t\trlc                = RLC          (_tokenAddress        );\n', '\t\tmarketplace        = Marketplace  (_marketplaceAddress  );\n', '\t\tworkerPoolHub      = WorkerPoolHub(_workerPoolHubAddress);\n', '\t\tappHub             = AppHub       (_appHubAddress       );\n', '\t\tdatasetHub         = DatasetHub   (_datasetHubAddress   );\n', '\n', '\t}\n', '\n', '\tfunction setCategoriesCreator(address _categoriesCreator)\n', '\tpublic onlyCategoriesCreator\n', '\t{\n', '\t\tm_categoriesCreator = _categoriesCreator;\n', '\t}\n', '\t/**\n', '\t * Factory\n', '\t */\n', '\n', '\tfunction createCategory(\n', '\t\tstring  _name,\n', '\t\tstring  _description,\n', '\t\tuint256 _workClockTimeRef)\n', '\tpublic onlyCategoriesCreator returns (uint256 catid)\n', '\t{\n', '\t\tm_categoriesCount                  = m_categoriesCount.add(1);\n', '\t\tIexecLib.Category storage category = m_categories[m_categoriesCount];\n', '\t\tcategory.catid                     = m_categoriesCount;\n', '\t\tcategory.name                      = _name;\n', '\t\tcategory.description               = _description;\n', '\t\tcategory.workClockTimeRef          = _workClockTimeRef;\n', '\t\temit CreateCategory(m_categoriesCount, _name, _description, _workClockTimeRef);\n', '\t\treturn m_categoriesCount;\n', '\t}\n', '\n', '\tfunction createWorkerPool(\n', '\t\tstring  _description,\n', '\t\tuint256 _subscriptionLockStakePolicy,\n', '\t\tuint256 _subscriptionMinimumStakePolicy,\n', '\t\tuint256 _subscriptionMinimumScorePolicy)\n', '\texternal returns (address createdWorkerPool)\n', '\t{\n', '\t\taddress newWorkerPool = workerPoolHub.createWorkerPool(\n', '\t\t\t_description,\n', '\t\t\t_subscriptionLockStakePolicy,\n', '\t\t\t_subscriptionMinimumStakePolicy,\n', '\t\t\t_subscriptionMinimumScorePolicy,\n', '\t\t\taddress(marketplace)\n', '\t\t);\n', '\t\temit CreateWorkerPool(tx.origin, newWorkerPool, _description);\n', '\t\treturn newWorkerPool;\n', '\t}\n', '\n', '\tfunction createApp(\n', '\t\tstring  _appName,\n', '\t\tuint256 _appPrice,\n', '\t\tstring  _appParams)\n', '\texternal returns (address createdApp)\n', '\t{\n', '\t\taddress newApp = appHub.createApp(\n', '\t\t\t_appName,\n', '\t\t\t_appPrice,\n', '\t\t\t_appParams\n', '\t\t);\n', '\t\temit CreateApp(tx.origin, newApp, _appName, _appPrice, _appParams);\n', '\t\treturn newApp;\n', '\t}\n', '\n', '\tfunction createDataset(\n', '\t\tstring  _datasetName,\n', '\t\tuint256 _datasetPrice,\n', '\t\tstring  _datasetParams)\n', '\texternal returns (address createdDataset)\n', '\t{\n', '\t\taddress newDataset = datasetHub.createDataset(\n', '\t\t\t_datasetName,\n', '\t\t\t_datasetPrice,\n', '\t\t\t_datasetParams\n', '\t\t\t);\n', '\t\temit CreateDataset(tx.origin, newDataset, _datasetName, _datasetPrice, _datasetParams);\n', '\t\treturn newDataset;\n', '\t}\n', '\n', '\t/**\n', '\t * WorkOrder Emission\n', '\t */\n', '\tfunction buyForWorkOrder(\n', '\t\tuint256 _marketorderIdx,\n', '\t\taddress _workerpool,\n', '\t\taddress _app,\n', '\t\taddress _dataset,\n', '\t\tstring  _params,\n', '\t\taddress _callback,\n', '\t\taddress _beneficiary)\n', '\texternal returns (address)\n', '\t{\n', '\t\taddress requester = msg.sender;\n', '\t\trequire(marketplace.consumeMarketOrderAsk(_marketorderIdx, requester, _workerpool));\n', '\n', '\t\tuint256 emitcost = lockWorkOrderCost(requester, _workerpool, _app, _dataset);\n', '\n', '\t\tWorkOrder workorder = new WorkOrder(\n', '\t\t\t_marketorderIdx,\n', '\t\t\trequester,\n', '\t\t\t_app,\n', '\t\t\t_dataset,\n', '\t\t\t_workerpool,\n', '\t\t\temitcost,\n', '\t\t\t_params,\n', '\t\t\t_callback,\n', '\t\t\t_beneficiary\n', '\t\t);\n', '\n', '\t\tm_woidRegistered[workorder] = true;\n', '\n', '\t\trequire(WorkerPool(_workerpool).emitWorkOrder(workorder, _marketorderIdx));\n', '\n', '\t\temit WorkOrderActivated(workorder, _workerpool);\n', '\t\treturn workorder;\n', '\t}\n', '\n', '\tfunction isWoidRegistred(address _woid) public view returns (bool)\n', '\t{\n', '\t\treturn m_woidRegistered[_woid];\n', '\t}\n', '\n', '\tfunction lockWorkOrderCost(\n', '\t\taddress _requester,\n', '\t\taddress _workerpool, // Address of a smartcontract\n', '\t\taddress _app,        // Address of a smartcontract\n', '\t\taddress _dataset)    // Address of a smartcontract\n', '\tinternal returns (uint256)\n', '\t{\n', '\t\t// APP\n', '\t\tApp app = App(_app);\n', '\t\trequire(appHub.isAppRegistered (_app));\n', '\t\t// initialize usercost with dapp price\n', '\t\tuint256 emitcost = app.m_appPrice();\n', '\n', '\t\t// DATASET\n', '\t\tif (_dataset != address(0)) // address(0) → no dataset\n', '\t\t{\n', '\t\t\tDataset dataset = Dataset(_dataset);\n', '\t\t\trequire(datasetHub.isDatasetRegistred(_dataset));\n', '\t\t\t// add optional datasetPrice for userCost\n', '\t\t\temitcost = emitcost.add(dataset.m_datasetPrice());\n', '\t\t}\n', '\n', '\t\t// WORKERPOOL\n', '\t\trequire(workerPoolHub.isWorkerPoolRegistered(_workerpool));\n', '\n', '\t\trequire(lock(_requester, emitcost)); // Lock funds for app + dataset payment\n', '\n', '\t\treturn emitcost;\n', '\t}\n', '\n', '\t/**\n', '\t * WorkOrder life cycle\n', '\t */\n', '\n', '\tfunction claimFailedConsensus(address _woid)\n', '\tpublic onlyRegisteredWoid(_woid) returns (bool)\n', '\t{\n', '\t\tWorkOrder  workorder  = WorkOrder(_woid);\n', '\t\trequire(workorder.m_requester() == msg.sender);\n', '\t\tWorkerPool workerpool = WorkerPool(workorder.m_workerpool());\n', '\n', '\t\tIexecLib.WorkOrderStatusEnum currentStatus = workorder.m_status();\n', '\t\trequire(currentStatus == IexecLib.WorkOrderStatusEnum.ACTIVE || currentStatus == IexecLib.WorkOrderStatusEnum.REVEALING);\n', '\t\t// Unlock stakes for all workers\n', '\t\trequire(workerpool.claimFailedConsensus(_woid));\n', '\t\tworkorder.claim(); // revert on error\n', '\n', '\t\t/* uint256 value           = marketplace.getMarketOrderValue(workorder.m_marketorderIdx()); // revert if not exist */\n', '\t\t/* address workerpoolOwner = marketplace.getMarketOrderWorkerpoolOwner(workorder.m_marketorderIdx()); // revert if not exist */\n', '\t\tuint256 value;\n', '\t\taddress workerpoolOwner;\n', '\t\t(,,,value,,,,workerpoolOwner) = marketplace.getMarketOrder(workorder.m_marketorderIdx()); // Single call cost less gas\n', '\t\tuint256 workerpoolStake = value.percentage(marketplace.ASK_STAKE_RATIO());\n', '\n', '\t\trequire(unlock (workorder.m_requester(), value.add(workorder.m_emitcost()))); // UNLOCK THE FUNDS FOR REINBURSEMENT\n', '\t\trequire(seize  (workerpoolOwner,         workerpoolStake));\n', '\t\t// put workerpoolOwner stake seize into iexecHub address for bonus for scheduler on next well finalized Task\n', '\t\trequire(reward (this,                    workerpoolStake));\n', '\t\trequire(lock   (this,                    workerpoolStake));\n', '\n', '\t\temit WorkOrderClaimed(_woid, workorder.m_workerpool());\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction finalizeWorkOrder(\n', '\t\taddress _woid,\n', '\t\tstring  _stdout,\n', '\t\tstring  _stderr,\n', '\t\tstring  _uri)\n', '\tpublic onlyRegisteredWoid(_woid) returns (bool)\n', '\t{\n', '\t\tWorkOrder workorder = WorkOrder(_woid);\n', '\t\trequire(workorder.m_workerpool() == msg.sender);\n', '\t\trequire(workorder.m_status()     == IexecLib.WorkOrderStatusEnum.REVEALING);\n', '\n', '\t\t// APP\n', '\t\tApp     app      = App(workorder.m_app());\n', '\t\tuint256 appPrice = app.m_appPrice();\n', '\t\tif (appPrice > 0)\n', '\t\t{\n', '\t\t\trequire(reward(app.m_owner(), appPrice));\n', '\t\t}\n', '\n', '\t\t// DATASET\n', '\t\tDataset dataset = Dataset(workorder.m_dataset());\n', '\t\tif (dataset != address(0))\n', '\t\t{\n', '\t\t\tuint256 datasetPrice = dataset.m_datasetPrice();\n', '\t\t\tif (datasetPrice > 0)\n', '\t\t\t{\n', '\t\t\t\trequire(reward(dataset.m_owner(), datasetPrice));\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\t// WORKERPOOL → rewarding done by the caller itself\n', '\n', '\t\t/**\n', '\t\t * seize stacked funds from requester.\n', '\t\t * reward = value: was locked at market making\n', '\t\t * emitcost: was locked at when emiting the workorder\n', '\t\t */\n', '\t\t/* uint256 value           = marketplace.getMarketOrderValue(workorder.m_marketorderIdx()); // revert if not exist */\n', '\t\t/* address workerpoolOwner = marketplace.getMarketOrderWorkerpoolOwner(workorder.m_marketorderIdx()); // revert if not exist */\n', '\t\tuint256 value;\n', '\t\taddress workerpoolOwner;\n', '\t\t(,,,value,,,,workerpoolOwner) = marketplace.getMarketOrder(workorder.m_marketorderIdx()); // Single call cost less gas\n', '\t\tuint256 workerpoolStake       = value.percentage(marketplace.ASK_STAKE_RATIO());\n', '\n', '\t\trequire(seize (workorder.m_requester(), value.add(workorder.m_emitcost()))); // seize funds for payment (market value + emitcost)\n', '\t\trequire(unlock(workerpoolOwner,         workerpoolStake)); // unlock scheduler stake\n', '\n', '\t\t// write results\n', '\t\tworkorder.setResult(_stdout, _stderr, _uri); // revert on error\n', '\n', '\t\t// Rien ne se perd, rien ne se crée, tout se transfere\n', '\t\t// distribute bonus to scheduler. jackpot bonus come from scheduler stake loose on IexecHub contract\n', '\t\t// we reuse the varaible value for the kitty / fraction of the kitty (stack too deep)\n', '\t\t/* (,value) = checkBalance(this); // kitty is locked on `this` wallet */\n', '\t\tvalue = m_accounts[this].locked; // kitty is locked on `this` wallet\n', '\t\tif(value > 0)\n', '\t\t{\n', '\t\t\tvalue = value.min(value.percentage(STAKE_BONUS_RATIO).max(STAKE_BONUS_MIN_THRESHOLD));\n', '\t\t\trequire(seize(this,             value));\n', '\t\t\trequire(reward(workerpoolOwner, value));\n', '\t\t}\n', '\n', '\t\temit WorkOrderCompleted(_woid, workorder.m_workerpool());\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Views\n', '\t */\n', '\tfunction getCategoryWorkClockTimeRef(uint256 _catId) public view returns (uint256 workClockTimeRef)\n', '\t{\n', '\t\trequire(existingCategory(_catId));\n', '\t\treturn m_categories[_catId].workClockTimeRef;\n', '\t}\n', '\n', '\tfunction existingCategory(uint256 _catId) public view  returns (bool categoryExist)\n', '\t{\n', '\t\treturn m_categories[_catId].catid > 0;\n', '\t}\n', '\n', '\tfunction getCategory(uint256 _catId) public view returns (uint256 catid, string name, string  description, uint256 workClockTimeRef)\n', '\t{\n', '\t\trequire(existingCategory(_catId));\n', '\t\treturn (\n', '\t\t\tm_categories[_catId].catid,\n', '\t\t\tm_categories[_catId].name,\n', '\t\t\tm_categories[_catId].description,\n', '\t\t\tm_categories[_catId].workClockTimeRef\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getWorkerStatus(address _worker) public view returns (address workerPool, uint256 workerScore)\n', '\t{\n', '\t\treturn (workerPoolHub.getWorkerAffectation(_worker), m_scores[_worker]);\n', '\t}\n', '\n', '\tfunction getWorkerScore(address _worker) public view returns (uint256 workerScore)\n', '\t{\n', '\t\treturn m_scores[_worker];\n', '\t}\n', '\n', '\t/**\n', '\t * Worker subscription\n', '\t */\n', '\tfunction registerToPool(address _worker) public returns (bool subscribed)\n', '\t// msg.sender = workerPool\n', '\t{\n', '\t\tWorkerPool workerpool = WorkerPool(msg.sender);\n', '\t\t// Check credentials\n', '\t\trequire(workerPoolHub.isWorkerPoolRegistered(msg.sender));\n', '\t\t// Lock worker deposit\n', '\t\trequire(lock(_worker, workerpool.m_subscriptionLockStakePolicy()));\n', '\t\t// Check subscription policy\n', '\t\trequire(m_accounts[_worker].stake >= workerpool.m_subscriptionMinimumStakePolicy());\n', '\t\trequire(m_scores[_worker]         >= workerpool.m_subscriptionMinimumScorePolicy());\n', '\t\t// Update affectation\n', '\t\trequire(workerPoolHub.registerWorkerAffectation(msg.sender, _worker));\n', '\t\t// Trigger event notice\n', '\t\temit WorkerPoolSubscription(msg.sender, _worker);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction unregisterFromPool(address _worker) public returns (bool unsubscribed)\n', '\t// msg.sender = workerPool\n', '\t{\n', '\t\trequire(removeWorker(msg.sender, _worker));\n', '\t\t// Trigger event notice\n', '\t\temit WorkerPoolUnsubscription(msg.sender, _worker);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction evictWorker(address _worker) public returns (bool unsubscribed)\n', '\t// msg.sender = workerpool\n', '\t{\n', '\t\trequire(removeWorker(msg.sender, _worker));\n', '\t\t// Trigger event notice\n', '\t\temit WorkerPoolEviction(msg.sender, _worker);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction removeWorker(address _workerpool, address _worker) internal returns (bool unsubscribed)\n', '\t{\n', '\t\tWorkerPool workerpool = WorkerPool(_workerpool);\n', '\t\t// Check credentials\n', '\t\trequire(workerPoolHub.isWorkerPoolRegistered(_workerpool));\n', '\t\t// Unlick worker stake\n', '\t\trequire(unlock(_worker, workerpool.m_subscriptionLockStakePolicy()));\n', '\t\t// Update affectation\n', '\t\trequire(workerPoolHub.unregisterWorkerAffectation(_workerpool, _worker));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Stake, reward and penalty functions\n', '\t */\n', '\t/* Marketplace */\n', '\tfunction lockForOrder(address _user, uint256 _amount) public onlyMarketplace returns (bool)\n', '\t{\n', '\t\trequire(lock(_user, _amount));\n', '\t\treturn true;\n', '\t}\n', '\tfunction unlockForOrder(address _user, uint256 _amount) public  onlyMarketplace returns (bool)\n', '\t{\n', '\t\trequire(unlock(_user, _amount));\n', '\t\treturn true;\n', '\t}\n', '\t/* Work */\n', '\tfunction lockForWork(address _woid, address _user, uint256 _amount) public onlyRegisteredWoid(_woid) returns (bool)\n', '\t{\n', '\t\trequire(WorkOrder(_woid).m_workerpool() == msg.sender);\n', '\t\trequire(lock(_user, _amount));\n', '\t\treturn true;\n', '\t}\n', '\tfunction unlockForWork(address _woid, address _user, uint256 _amount) public onlyRegisteredWoid(_woid) returns (bool)\n', '\t{\n', '\t\trequire(WorkOrder(_woid).m_workerpool() == msg.sender);\n', '\t\trequire(unlock(_user, _amount));\n', '\t\treturn true;\n', '\t}\n', '\tfunction rewardForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public onlyRegisteredWoid(_woid) returns (bool)\n', '\t{\n', '\t\trequire(WorkOrder(_woid).m_workerpool() == msg.sender);\n', '\t\trequire(reward(_worker, _amount));\n', '\t\tif (_reputation)\n', '\t\t{\n', '\t\t\tm_contributionHistory.success = m_contributionHistory.success.add(1);\n', '\t\t\tm_scores[_worker] = m_scores[_worker].add(1);\n', '\t\t\temit AccurateContribution(_woid, _worker);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\tfunction seizeForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public onlyRegisteredWoid(_woid) returns (bool)\n', '\t{\n', '\t\trequire(WorkOrder(_woid).m_workerpool() == msg.sender);\n', '\t\trequire(seize(_worker, _amount));\n', '\t\tif (_reputation)\n', '\t\t{\n', '\t\t\tm_contributionHistory.failed = m_contributionHistory.failed.add(1);\n', '\t\t\tm_scores[_worker] = m_scores[_worker].sub(m_scores[_worker].min(SCORE_UNITARY_SLASH));\n', '\t\t\temit FaultyContribution(_woid, _worker);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\t/**\n', '\t * Wallet methods: public\n', '\t */\n', '\tfunction deposit(uint256 _amount) external returns (bool)\n', '\t{\n', '\t\trequire(rlc.transferFrom(msg.sender, address(this), _amount));\n', '\t\tm_accounts[msg.sender].stake = m_accounts[msg.sender].stake.add(_amount);\n', '\t\temit Deposit(msg.sender, _amount);\n', '\t\treturn true;\n', '\t}\n', '\tfunction withdraw(uint256 _amount) external returns (bool)\n', '\t{\n', '\t\tm_accounts[msg.sender].stake = m_accounts[msg.sender].stake.sub(_amount);\n', '\t\trequire(rlc.transfer(msg.sender, _amount));\n', '\t\temit Withdraw(msg.sender, _amount);\n', '\t\treturn true;\n', '\t}\n', '\tfunction checkBalance(address _owner) public view returns (uint256 stake, uint256 locked)\n', '\t{\n', '\t\treturn (m_accounts[_owner].stake, m_accounts[_owner].locked);\n', '\t}\n', '\t/**\n', '\t * Wallet methods: Internal\n', '\t */\n', '\tfunction reward(address _user, uint256 _amount) internal returns (bool)\n', '\t{\n', '\t\tm_accounts[_user].stake = m_accounts[_user].stake.add(_amount);\n', '\t\temit Reward(_user, _amount);\n', '\t\treturn true;\n', '\t}\n', '\tfunction seize(address _user, uint256 _amount) internal returns (bool)\n', '\t{\n', '\t\tm_accounts[_user].locked = m_accounts[_user].locked.sub(_amount);\n', '\t\temit Seize(_user, _amount);\n', '\t\treturn true;\n', '\t}\n', '\tfunction lock(address _user, uint256 _amount) internal returns (bool)\n', '\t{\n', '\t\tm_accounts[_user].stake  = m_accounts[_user].stake.sub(_amount);\n', '\t\tm_accounts[_user].locked = m_accounts[_user].locked.add(_amount);\n', '\t\treturn true;\n', '\t}\n', '\tfunction unlock(address _user, uint256 _amount) internal returns (bool)\n', '\t{\n', '\t\tm_accounts[_user].locked = m_accounts[_user].locked.sub(_amount);\n', '\t\tm_accounts[_user].stake  = m_accounts[_user].stake.add(_amount);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract WorkerPool is OwnableOZ, IexecHubAccessor, MarketplaceAccessor\n', '{\n', '\tusing SafeMathOZ for uint256;\n', '\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tstring                      public m_description;\n', '\tuint256                     public m_stakeRatioPolicy;               // % of reward to stake\n', '\tuint256                     public m_schedulerRewardRatioPolicy;     // % of reward given to scheduler\n', '\tuint256                     public m_subscriptionLockStakePolicy;    // Stake locked when in workerpool - Constant set by constructor, do not update\n', '\tuint256                     public m_subscriptionMinimumStakePolicy; // Minimum stake for subscribing\n', '\tuint256                     public m_subscriptionMinimumScorePolicy; // Minimum score for subscribing\n', '\taddress[]                   public m_workers;\n', '\tmapping(address => uint256) public m_workerIndex;\n', '\n', '\t// mapping(woid => IexecLib.Consensus)\n', '\tmapping(address => IexecLib.Consensus) public m_consensus;\n', '\t// mapping(woid => worker address => Contribution);\n', '\tmapping(address => mapping(address => IexecLib.Contribution)) public m_contributions;\n', '\n', '\tuint256 public constant REVEAL_PERIOD_DURATION_RATIO  = 2;\n', '\tuint256 public constant CONSENSUS_DURATION_RATIO      = 10;\n', '\n', '\t/**\n', '\t * Address of slave/related contracts\n', '\t */\n', '\taddress        public  m_workerPoolHubAddress;\n', '\n', '\n', '\t/**\n', '\t * Events\n', '\t */\n', '\tevent WorkerPoolPolicyUpdate(\n', '\t\tuint256 oldStakeRatioPolicy,               uint256 newStakeRatioPolicy,\n', '\t\tuint256 oldSchedulerRewardRatioPolicy,     uint256 newSchedulerRewardRatioPolicy,\n', '\t\tuint256 oldSubscriptionMinimumStakePolicy, uint256 newSubscriptionMinimumStakePolicy,\n', '\t\tuint256 oldSubscriptionMinimumScorePolicy, uint256 newSubscriptionMinimumScorePolicy);\n', '\n', '\tevent WorkOrderActive         (address indexed woid);\n', '\tevent WorkOrderClaimed        (address indexed woid);\n', '\n', '\tevent AllowWorkerToContribute (address indexed woid, address indexed worker, uint256 workerScore);\n', '\tevent Contribute              (address indexed woid, address indexed worker, bytes32 resultHash);\n', '\tevent RevealConsensus         (address indexed woid, bytes32 consensus);\n', '\tevent Reveal                  (address indexed woid, address indexed worker, bytes32 result);\n', '\tevent Reopen                  (address indexed woid);\n', '  event FinalizeWork            (address indexed woid, string stdout, string stderr, string uri);\n', '\n', '\n', '\n', '\tevent WorkerSubscribe         (address indexed worker);\n', '\tevent WorkerUnsubscribe       (address indexed worker);\n', '\tevent WorkerEviction          (address indexed worker);\n', '\n', '\t/**\n', '\t * Methods\n', '\t */\n', '\t// Constructor\n', '\tfunction WorkerPool(\n', '\t\taddress _iexecHubAddress,\n', '\t\tstring  _description,\n', '\t\tuint256 _subscriptionLockStakePolicy,\n', '\t\tuint256 _subscriptionMinimumStakePolicy,\n', '\t\tuint256 _subscriptionMinimumScorePolicy,\n', '\t\taddress _marketplaceAddress)\n', '\tIexecHubAccessor(_iexecHubAddress)\n', '\tMarketplaceAccessor(_marketplaceAddress)\n', '\tpublic\n', '\t{\n', '\t\t// tx.origin == owner\n', '\t\t// msg.sender ==  WorkerPoolHub\n', '\t\trequire(tx.origin != msg.sender);\n', '\t\tsetImmutableOwnership(tx.origin); // owner → tx.origin\n', '\n', '\t\tm_description                    = _description;\n', '\t\tm_stakeRatioPolicy               = 30; // % of the work order price to stake\n', '\t\tm_schedulerRewardRatioPolicy     = 1;  // % of the work reward going to scheduler vs workers reward\n', '\t\tm_subscriptionLockStakePolicy    = _subscriptionLockStakePolicy; // only at creation. cannot be change to respect lock/unlock of worker stake\n', '\t\tm_subscriptionMinimumStakePolicy = _subscriptionMinimumStakePolicy;\n', '\t\tm_subscriptionMinimumScorePolicy = _subscriptionMinimumScorePolicy;\n', '\t\tm_workerPoolHubAddress           = msg.sender;\n', '\n', '\t}\n', '\n', '\tfunction changeWorkerPoolPolicy(\n', '\t\tuint256 _newStakeRatioPolicy,\n', '\t\tuint256 _newSchedulerRewardRatioPolicy,\n', '\t\tuint256 _newSubscriptionMinimumStakePolicy,\n', '\t\tuint256 _newSubscriptionMinimumScorePolicy)\n', '\tpublic onlyOwner\n', '\t{\n', '\t\temit WorkerPoolPolicyUpdate(\n', '\t\t\tm_stakeRatioPolicy,               _newStakeRatioPolicy,\n', '\t\t\tm_schedulerRewardRatioPolicy,     _newSchedulerRewardRatioPolicy,\n', '\t\t\tm_subscriptionMinimumStakePolicy, _newSubscriptionMinimumStakePolicy,\n', '\t\t\tm_subscriptionMinimumScorePolicy, _newSubscriptionMinimumScorePolicy\n', '\t\t);\n', '\t\trequire(_newSchedulerRewardRatioPolicy <= 100);\n', '\t\tm_stakeRatioPolicy               = _newStakeRatioPolicy;\n', '\t\tm_schedulerRewardRatioPolicy     = _newSchedulerRewardRatioPolicy;\n', '\t\tm_subscriptionMinimumStakePolicy = _newSubscriptionMinimumStakePolicy;\n', '\t\tm_subscriptionMinimumScorePolicy = _newSubscriptionMinimumScorePolicy;\n', '\t}\n', '\n', '\t/************************* worker list management **************************/\n', '\tfunction getWorkerAddress(uint _index) public view returns (address)\n', '\t{\n', '\t\treturn m_workers[_index];\n', '\t}\n', '\tfunction getWorkerIndex(address _worker) public view returns (uint)\n', '\t{\n', '\t\tuint index = m_workerIndex[_worker];\n', '\t\trequire(m_workers[index] == _worker);\n', '\t\treturn index;\n', '\t}\n', '\tfunction getWorkersCount() public view returns (uint)\n', '\t{\n', '\t\treturn m_workers.length;\n', '\t}\n', '\n', '\tfunction subscribeToPool() public returns (bool)\n', '\t{\n', '\t\t// msg.sender = worker\n', '\t\trequire(iexecHubInterface.registerToPool(msg.sender));\n', '\t\tuint index = m_workers.push(msg.sender);\n', '\t\tm_workerIndex[msg.sender] = index.sub(1);\n', '\t\temit WorkerSubscribe(msg.sender);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction unsubscribeFromPool() public  returns (bool)\n', '\t{\n', '\t\t// msg.sender = worker\n', '\t\trequire(iexecHubInterface.unregisterFromPool(msg.sender));\n', '\t\trequire(removeWorker(msg.sender));\n', '\t\temit WorkerUnsubscribe(msg.sender);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction evictWorker(address _worker) public onlyOwner returns (bool)\n', '\t{\n', '\t\t// msg.sender = scheduler\n', '\t\trequire(iexecHubInterface.evictWorker(_worker));\n', '\t\trequire(removeWorker(_worker));\n', '\t\temit WorkerEviction(_worker);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction removeWorker(address _worker) internal returns (bool)\n', '\t{\n', '\t\tuint index = getWorkerIndex(_worker); // fails if worker not registered\n', '\t\taddress lastWorker = m_workers[m_workers.length.sub(1)];\n', '\t\tm_workers    [index     ] = lastWorker;\n', '\t\tm_workerIndex[lastWorker] = index;\n', '\t\tdelete m_workers[m_workers.length.sub(1)];\n', '\t\tm_workers.length = m_workers.length.sub(1);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction getConsensusDetails(address _woid) public view returns (\n', '\t\tuint256 c_poolReward,\n', '\t\tuint256 c_stakeAmount,\n', '\t\tbytes32 c_consensus,\n', '\t\tuint256 c_revealDate,\n', '\t\tuint256 c_revealCounter,\n', '\t\tuint256 c_consensusTimeout,\n', '\t\tuint256 c_winnerCount,\n', '\t\taddress c_workerpoolOwner)\n', '\t{\n', '\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\n', '\t\treturn (\n', '\t\t\tconsensus.poolReward,\n', '\t\t\tconsensus.stakeAmount,\n', '\t\t\tconsensus.consensus,\n', '\t\t\tconsensus.revealDate,\n', '\t\t\tconsensus.revealCounter,\n', '\t\t\tconsensus.consensusTimeout,\n', '\t\t\tconsensus.winnerCount,\n', '\t\t\tconsensus.workerpoolOwner\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getContributorsCount(address _woid) public view returns (uint256 contributorsCount)\n', '\t{\n', '\t\treturn m_consensus[_woid].contributors.length;\n', '\t}\n', '\n', '\tfunction getContributor(address _woid, uint256 index) public view returns (address contributor)\n', '\t{\n', '\t\treturn m_consensus[_woid].contributors[index];\n', '\t}\n', '\n', '\tfunction existingContribution(address _woid, address _worker) public view  returns (bool contributionExist)\n', '\t{\n', '\t\treturn m_contributions[_woid][_worker].status != IexecLib.ContributionStatusEnum.UNSET;\n', '\t}\n', '\n', '\tfunction getContribution(address _woid, address _worker) public view returns\n', '\t(\n', '\t\tIexecLib.ContributionStatusEnum status,\n', '\t\tbytes32 resultHash,\n', '\t\tbytes32 resultSign,\n', '\t\taddress enclaveChallenge,\n', '\t\tuint256 score,\n', '\t\tuint256 weight)\n', '\t{\n', '\t\trequire(existingContribution(_woid, _worker)); // no silent value returned\n', '\t\tIexecLib.Contribution storage contribution = m_contributions[_woid][_worker];\n', '\t\treturn (\n', '\t\t\tcontribution.status,\n', '\t\t\tcontribution.resultHash,\n', '\t\t\tcontribution.resultSign,\n', '\t\t\tcontribution.enclaveChallenge,\n', '\t\t\tcontribution.score,\n', '\t\t\tcontribution.weight\n', '\t\t);\n', '\t}\n', '\n', '\n', '\t/**************************** Works management *****************************/\n', '\tfunction emitWorkOrder(address _woid, uint256 _marketorderIdx) public onlyIexecHub returns (bool)\n', '\t{\n', '\t\tuint256 catid   = marketplaceInterface.getMarketOrderCategory(_marketorderIdx);\n', '\t\tuint256 timeout = iexecHubInterface.getCategoryWorkClockTimeRef(catid).mul(CONSENSUS_DURATION_RATIO).add(now);\n', '\n', '\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\n', '\t\tconsensus.poolReward                 = marketplaceInterface.getMarketOrderValue(_marketorderIdx);\n', '\t\tconsensus.workerpoolOwner            = marketplaceInterface.getMarketOrderWorkerpoolOwner(_marketorderIdx);\n', '\t\tconsensus.stakeAmount                = consensus.poolReward.percentage(m_stakeRatioPolicy);\n', '\t\tconsensus.consensusTimeout            = timeout;\n', '\t\tconsensus.schedulerRewardRatioPolicy = m_schedulerRewardRatioPolicy;\n', '\n', '\t\temit WorkOrderActive(_woid);\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction claimFailedConsensus(address _woid) public onlyIexecHub returns (bool)\n', '\t{\n', '\t  IexecLib.Consensus storage consensus = m_consensus[_woid];\n', '\t\trequire(now > consensus.consensusTimeout);\n', '\t\tuint256 i;\n', '\t\taddress w;\n', '\t\tfor (i = 0; i < consensus.contributors.length; ++i)\n', '\t\t{\n', '\t\t\tw = consensus.contributors[i];\n', '\t\t\tif (m_contributions[_woid][w].status != IexecLib.ContributionStatusEnum.AUTHORIZED)\n', '\t\t\t{\n', '\t\t\t\trequire(iexecHubInterface.unlockForWork(_woid, w, consensus.stakeAmount));\n', '\t\t\t}\n', '\t\t}\n', '\t\temit WorkOrderClaimed(_woid);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction allowWorkersToContribute(address _woid, address[] _workers, address _enclaveChallenge) public onlyOwner /*onlySheduler*/ returns (bool)\n', '\t{\n', '\t\tfor (uint i = 0; i < _workers.length; ++i)\n', '\t\t{\n', '\t\t\trequire(allowWorkerToContribute(_woid, _workers[i], _enclaveChallenge));\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction allowWorkerToContribute(address _woid, address _worker, address _enclaveChallenge) public onlyOwner /*onlySheduler*/ returns (bool)\n', '\t{\n', '\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\trequire(WorkOrder(_woid).m_status() == IexecLib.WorkOrderStatusEnum.ACTIVE);\n', '\t\tIexecLib.Contribution storage contribution = m_contributions[_woid][_worker];\n', '\t\tIexecLib.Consensus    storage consensus    = m_consensus[_woid];\n', '\t\trequire(now <= consensus.consensusTimeout);\n', '\n', '\t\taddress workerPool;\n', '\t\tuint256 workerScore;\n', '\t\t(workerPool, workerScore) = iexecHubInterface.getWorkerStatus(_worker); // workerPool, workerScore\n', '\t\trequire(workerPool == address(this));\n', '\n', '\t\trequire(contribution.status == IexecLib.ContributionStatusEnum.UNSET);\n', '\t\tcontribution.status           = IexecLib.ContributionStatusEnum.AUTHORIZED;\n', '\t\tcontribution.enclaveChallenge = _enclaveChallenge;\n', '\n', '\t\temit AllowWorkerToContribute(_woid, _worker, workerScore);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction contribute(address _woid, bytes32 _resultHash, bytes32 _resultSign, uint8 _v, bytes32 _r, bytes32 _s) public returns (uint256 workerStake)\n', '\t{\n', '\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\tIexecLib.Consensus    storage consensus    = m_consensus[_woid];\n', '\t\trequire(now <= consensus.consensusTimeout);\n', "\t\trequire(WorkOrder(_woid).m_status() == IexecLib.WorkOrderStatusEnum.ACTIVE); // can't contribute on a claimed or completed workorder\n", '\t\tIexecLib.Contribution storage contribution = m_contributions[_woid][msg.sender];\n', '\n', '\t\t// msg.sender = a worker\n', '\t\trequire(_resultHash != 0x0);\n', '\t\trequire(_resultSign != 0x0);\n', '\t\tif (contribution.enclaveChallenge != address(0))\n', '\t\t{\n', '\t\t\trequire(contribution.enclaveChallenge == ecrecover(keccak256("\\x19Ethereum Signed Message:\\n64", _resultHash, _resultSign), _v, _r, _s));\n', '\t\t}\n', '\n', '\t\trequire(contribution.status == IexecLib.ContributionStatusEnum.AUTHORIZED);\n', '\t\tcontribution.status     = IexecLib.ContributionStatusEnum.CONTRIBUTED;\n', '\t\tcontribution.resultHash = _resultHash;\n', '\t\tcontribution.resultSign = _resultSign;\n', '\t\tcontribution.score      = iexecHubInterface.getWorkerScore(msg.sender);\n', '\t\tconsensus.contributors.push(msg.sender);\n', '\n', '\t\trequire(iexecHubInterface.lockForWork(_woid, msg.sender, consensus.stakeAmount));\n', '\t\temit Contribute(_woid, msg.sender, _resultHash);\n', '\t\treturn consensus.stakeAmount;\n', '\t}\n', '\n', '\tfunction revealConsensus(address _woid, bytes32 _consensus) public onlyOwner /*onlySheduler*/ returns (bool)\n', '\t{\n', '\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\n', '\t\trequire(now <= consensus.consensusTimeout);\n', '\t\trequire(WorkOrder(_woid).startRevealingPhase());\n', '\n', '\t\tconsensus.winnerCount = 0;\n', '\t\tfor (uint256 i = 0; i<consensus.contributors.length; ++i)\n', '\t\t{\n', '\t\t\taddress w = consensus.contributors[i];\n', '\t\t\tif (\n', '\t\t\t\tm_contributions[_woid][w].resultHash == _consensus\n', '\t\t\t\t&&\n', '\t\t\t\tm_contributions[_woid][w].status == IexecLib.ContributionStatusEnum.CONTRIBUTED // REJECTED contribution must not be count\n', '\t\t\t)\n', '\t\t\t{\n', '\t\t\t\tconsensus.winnerCount = consensus.winnerCount.add(1);\n', '\t\t\t}\n', '\t\t}\n', '\t\trequire(consensus.winnerCount > 0); // you cannot revealConsensus if no worker has contributed to this hash\n', '\n', '\t\tconsensus.consensus  = _consensus;\n', '\t\tconsensus.revealDate = iexecHubInterface.getCategoryWorkClockTimeRef(marketplaceInterface.getMarketOrderCategory(WorkOrder(_woid).m_marketorderIdx())).mul(REVEAL_PERIOD_DURATION_RATIO).add(now); // is it better to store th catid ?\n', '\t\temit RevealConsensus(_woid, _consensus);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction reveal(address _woid, bytes32 _result) public returns (bool)\n', '\t{\n', '\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\tIexecLib.Consensus    storage consensus    = m_consensus[_woid];\n', '\t\trequire(now <= consensus.consensusTimeout);\n', '\t\tIexecLib.Contribution storage contribution = m_contributions[_woid][msg.sender];\n', '\n', '\t\trequire(WorkOrder(_woid).m_status() == IexecLib.WorkOrderStatusEnum.REVEALING     );\n', '\t\trequire(consensus.revealDate        >  now                                        );\n', '\t\trequire(contribution.status         == IexecLib.ContributionStatusEnum.CONTRIBUTED);\n', '\t\trequire(contribution.resultHash     == consensus.consensus                        );\n', '\t\trequire(contribution.resultHash     == keccak256(_result                        ) );\n', '\t\trequire(contribution.resultSign     == keccak256(_result ^ keccak256(msg.sender)) );\n', '\n', '\t\tcontribution.status     = IexecLib.ContributionStatusEnum.PROVED;\n', '\t\tconsensus.revealCounter = consensus.revealCounter.add(1);\n', '\n', '\t\temit Reveal(_woid, msg.sender, _result);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction reopen(address _woid) public onlyOwner /*onlySheduler*/ returns (bool)\n', '\t{\n', '\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\n', '\t\trequire(now <= consensus.consensusTimeout);\n', '\t\trequire(consensus.revealDate <= now && consensus.revealCounter == 0);\n', '\t\trequire(WorkOrder(_woid).reActivate());\n', '\n', '\t\tfor (uint256 i = 0; i < consensus.contributors.length; ++i)\n', '\t\t{\n', '\t\t\taddress w = consensus.contributors[i];\n', '\t\t\tif (m_contributions[_woid][w].resultHash == consensus.consensus)\n', '\t\t\t{\n', '\t\t\t\tm_contributions[_woid][w].status = IexecLib.ContributionStatusEnum.REJECTED;\n', '\t\t\t}\n', '\t\t}\n', '\t\t// Reset to status before revealConsensus. Must be after REJECTED traitement above because of consensus.consensus check\n', '\t\tconsensus.winnerCount = 0;\n', '\t\tconsensus.consensus   = 0x0;\n', '\t\tconsensus.revealDate  = 0;\n', '\t\temit Reopen(_woid);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// if sheduler never call finalized ? no incetive to do that. schedulermust be pay also at this time\n', '\tfunction finalizeWork(address _woid, string _stdout, string _stderr, string _uri) public onlyOwner /*onlySheduler*/ returns (bool)\n', '\t{\n', '\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\n', '\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\n', '\t\trequire(now <= consensus.consensusTimeout);\n', '\t\trequire((consensus.revealDate <= now && consensus.revealCounter > 0) || (consensus.revealCounter == consensus.winnerCount)); // consensus.winnerCount never 0 at this step\n', '\n', '\t\t// add penalized to the call worker to contribution and they never contribute ?\n', '\t\trequire(distributeRewards(_woid, consensus));\n', '\n', '\t\trequire(iexecHubInterface.finalizeWorkOrder(_woid, _stdout, _stderr, _uri));\n', '\t\temit FinalizeWork(_woid,_stdout,_stderr,_uri);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction distributeRewards(address _woid, IexecLib.Consensus _consensus) internal returns (bool)\n', '\t{\n', '\t\tuint256 i;\n', '\t\taddress w;\n', '\t\tuint256 workerBonus;\n', '\t\tuint256 workerWeight;\n', '\t\tuint256 totalWeight;\n', '\t\tuint256 individualWorkerReward;\n', '\t\tuint256 totalReward = _consensus.poolReward;\n', '\t\taddress[] memory contributors = _consensus.contributors;\n', '\t\tfor (i = 0; i<contributors.length; ++i)\n', '\t\t{\n', '\t\t\tw = contributors[i];\n', '\t\t\tIexecLib.Contribution storage c = m_contributions[_woid][w];\n', '\t\t\tif (c.status == IexecLib.ContributionStatusEnum.PROVED)\n', '\t\t\t{\n', '\t\t\t\tworkerBonus  = (c.enclaveChallenge != address(0)) ? 3 : 1; // TODO: bonus sgx = 3 ?\n', '\t\t\t\tworkerWeight = 1 + c.score.mul(workerBonus).log();\n', '\t\t\t\ttotalWeight  = totalWeight.add(workerWeight);\n', "\t\t\t\tc.weight     = workerWeight; // store so we don't have to recompute\n", '\t\t\t}\n', '\t\t\telse // ContributionStatusEnum.REJECT or ContributionStatusEnum.CONTRIBUTED (not revealed)\n', '\t\t\t{\n', '\t\t\t\ttotalReward = totalReward.add(_consensus.stakeAmount);\n', '\t\t\t}\n', '\t\t}\n', '\t\trequire(totalWeight > 0);\n', '\n', '\t\t// compute how much is going to the workers\n', '\t\tuint256 totalWorkersReward = totalReward.percentage(uint256(100).sub(_consensus.schedulerRewardRatioPolicy));\n', '\n', '\t\tfor (i = 0; i<contributors.length; ++i)\n', '\t\t{\n', '\t\t\tw = contributors[i];\n', '\t\t\tif (m_contributions[_woid][w].status == IexecLib.ContributionStatusEnum.PROVED)\n', '\t\t\t{\n', '\t\t\t\tindividualWorkerReward = totalWorkersReward.mulByFraction(m_contributions[_woid][w].weight, totalWeight);\n', '\t\t\t\ttotalReward  = totalReward.sub(individualWorkerReward);\n', '\t\t\t\trequire(iexecHubInterface.unlockForWork(_woid, w, _consensus.stakeAmount));\n', '\t\t\t\trequire(iexecHubInterface.rewardForWork(_woid, w, individualWorkerReward, true));\n', '\t\t\t}\n', '\t\t\telse // WorkStatusEnum.POCO_REJECT or ContributionStatusEnum.CONTRIBUTED (not revealed)\n', '\t\t\t{\n', '\t\t\t\trequire(iexecHubInterface.seizeForWork(_woid, w, _consensus.stakeAmount, true));\n', '\t\t\t\t// No Reward\n', '\t\t\t}\n', '\t\t}\n', '\t\t// totalReward now contains the scheduler share\n', '\t\trequire(iexecHubInterface.rewardForWork(_woid, _consensus.workerpoolOwner, totalReward, false));\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '}\n', '\n', '\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract WorkerPoolHub is OwnableOZ // is Owned by IexecHub\n', '{\n', '\n', '\tusing SafeMathOZ for uint256;\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\t// worker => workerPool\n', '\tmapping(address => address)                     m_workerAffectation;\n', '\t// owner => index\n', '\tmapping(address => uint256)                     m_workerPoolCountByOwner;\n', '\t// owner => index => workerPool\n', '\tmapping(address => mapping(uint256 => address)) m_workerPoolByOwnerByIndex;\n', '\t//  workerPool => owner // stored in the workerPool\n', '\t/* mapping(address => address)                     m_ownerByWorkerPool; */\n', '\tmapping(address => bool)                        m_workerPoolRegistered;\n', '\n', '\tmapping(uint256 => address)                     m_workerPoolByIndex;\n', '\tuint256 public                                  m_totalWorkerPoolCount;\n', '\n', '\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tfunction WorkerPoolHub() public\n', '\t{\n', '\t}\n', '\n', '\t/**\n', '\t * Methods\n', '\t */\n', '\tfunction isWorkerPoolRegistered(address _workerPool) public view returns (bool)\n', '\t{\n', '\t\treturn m_workerPoolRegistered[_workerPool];\n', '\t}\n', '\tfunction getWorkerPoolsCount(address _owner) public view returns (uint256)\n', '\t{\n', '\t\treturn m_workerPoolCountByOwner[_owner];\n', '\t}\n', '\tfunction getWorkerPool(address _owner, uint256 _index) public view returns (address)\n', '\t{\n', '\t\treturn m_workerPoolByOwnerByIndex[_owner][_index];\n', '\t}\n', '\tfunction getWorkerPoolByIndex(uint256 _index) public view returns (address)\n', '\t{\n', '\t\treturn m_workerPoolByIndex[_index];\n', '\t}\n', '\tfunction getWorkerAffectation(address _worker) public view returns (address workerPool)\n', '\t{\n', '\t\treturn m_workerAffectation[_worker];\n', '\t}\n', '\n', '\tfunction addWorkerPool(address _owner, address _workerPool) internal\n', '\t{\n', '\t\tuint id = m_workerPoolCountByOwner[_owner].add(1);\n', '\t\tm_totalWorkerPoolCount = m_totalWorkerPoolCount.add(1);\n', '\t\tm_workerPoolByIndex       [m_totalWorkerPoolCount] = _workerPool;\n', '\t\tm_workerPoolCountByOwner  [_owner]                 = id;\n', '\t\tm_workerPoolByOwnerByIndex[_owner][id]             = _workerPool;\n', '\t\tm_workerPoolRegistered    [_workerPool]            = true;\n', '\t}\n', '\n', '\tfunction createWorkerPool(\n', '\t\tstring _description,\n', '\t\tuint256 _subscriptionLockStakePolicy,\n', '\t\tuint256 _subscriptionMinimumStakePolicy,\n', '\t\tuint256 _subscriptionMinimumScorePolicy,\n', '\t\taddress _marketplaceAddress)\n', '\texternal onlyOwner /*owner == IexecHub*/ returns (address createdWorkerPool)\n', '\t{\n', '\t\t// tx.origin == owner\n', '\t\t// msg.sender == IexecHub\n', '\t\t// At creating ownership is transfered to tx.origin\n', '\t\taddress newWorkerPool = new WorkerPool(\n', '\t\t\tmsg.sender, // iexecHubAddress\n', '\t\t\t_description,\n', '\t\t\t_subscriptionLockStakePolicy,\n', '\t\t\t_subscriptionMinimumStakePolicy,\n', '\t\t\t_subscriptionMinimumScorePolicy,\n', '\t\t\t_marketplaceAddress\n', '\t\t);\n', '\t\taddWorkerPool(tx.origin, newWorkerPool);\n', '\t\treturn newWorkerPool;\n', '\t}\n', '\n', '\tfunction registerWorkerAffectation(address _workerPool, address _worker) public onlyOwner /*owner == IexecHub*/ returns (bool subscribed)\n', '\t{\n', '\t\t// you must have no cuurent affectation on others worker Pool\n', '\t\trequire(m_workerAffectation[_worker] == address(0));\n', '\t\tm_workerAffectation[_worker] = _workerPool;\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction unregisterWorkerAffectation(address _workerPool, address _worker) public onlyOwner /*owner == IexecHub*/ returns (bool unsubscribed)\n', '\t{\n', '\t\trequire(m_workerAffectation[_worker] == _workerPool);\n', '\t\tm_workerAffectation[_worker] = address(0);\n', '\t\treturn true;\n', '\t}\n', '}']
