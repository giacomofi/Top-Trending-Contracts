['pragma solidity ^0.4.19;\n', '\n', '/*\n', '    Utility contract for Arby and it&#39;s various exchanges\n', '    Some of these functions originated from (and then improved upon) DeltaBalances.github.io\n', '    Check balances for multiple ERC20 tokens for multiple users in 1 batched call\n', '    Check exchange rates for many Bancor contracts in one batched call\n', '*/\n', '\n', '// WETH interface for 0x\n', 'contract WETH_0x {\n', '    // function balanceOf(address /*user*/) public view returns (uint);\n', '    function balanceOf(address userAddress) public view returns (uint);\n', '}\n', '\n', '// ERC20 interface\n', 'contract Token {\n', '    // function balanceOf(address /*tokenOwner*/) public view returns (uint /*balance*/);\n', '    // function transfer(address /*to*/, uint /*tokens*/) public returns (bool /*success*/);\n', '    // function allowance(address _owner, address _spender) constant returns (uint /*remaining*/)\n', '    function balanceOf(address tokenOwner) public view returns (uint /*balance*/);\n', '    function transfer(address toAddress, uint tokens) public returns (bool /*success*/);\n', '    function allowance(address _owner, address _spender) constant returns (uint /*remaining*/);\n', '}\n', '\n', '\n', 'contract BalanceCheckerN {\n', '\n', '    address public admin;\n', '\n', '    constructor() {\n', '        admin = 0x96670A91E1A0dbAde97fCDC0ABdDEe769C21fc8e;\n', '    }\n', '\n', '    //default function, don&#39;t accept any ETH\n', '    function() public payable {\n', '        revert();\n', '    }\n', '\n', '    //limit address to the creating address\n', '    modifier isAdmin() {\n', '        require(msg.sender == admin);\n', '         _;\n', '    }\n', '\n', '    // selfdestruct for cleanup\n', '    function destruct() public isAdmin {\n', '        selfdestruct(admin);\n', '    }\n', '\n', '    // backup withdraw, if somehow ETH gets in here\n', '    function withdraw() public isAdmin {\n', '        admin.transfer(address(this).balance);\n', '    }\n', '\n', '    // backup withdraw, if somehow ERC20 tokens get in here\n', '    function withdrawToken(address token, uint amount) public isAdmin {\n', '        require(token != address(0x0)); //use withdraw for ETH\n', '        require(Token(token).transfer(msg.sender, amount));\n', '    }\n', '\n', '  /* Check the token allowance of a wallet in a token contract\n', '     Avoids possible errors:\n', '        - returns 0 on invalid exchange contract\n', '        - return 0 on non-contract address\n', '\n', '     Mainly for internal use, but public for anyone who thinks it is useful    */\n', '   function tokenAllowance(address user, address spender, address token) public view returns (uint) {\n', '       //  check if token is actually a contract\n', '        uint256 tokenCode;\n', '        assembly { tokenCode := extcodesize(token) } // contract code size\n', '        if(tokenCode > 0)\n', '        {\n', '            Token tok = Token(token);\n', '            //  check if allowance succeeds\n', '            if(address(tok).call(bytes4(keccak256("allowance(address,address)")), user, spender)) {\n', '                return tok.allowance(user, spender);\n', '            } else {\n', '                  return 0; // not a valid allowance, return 0 instead of error\n', '            }\n', '        } else {\n', '            return 0; // not a contract, return 0 instead of error\n', '        }\n', '   }\n', '\n', '  /* Check the token balance of a wallet in a token contract\n', '     Avoids possible errors:\n', '        - returns 0 on invalid exchange contract\n', '        - return 0 on non-contract address\n', '\n', '     Mainly for internal use, but public for anyone who thinks it is useful    */\n', '   function tokenBalance(address user, address token) public view returns (uint) {\n', '       //  check if token is actually a contract\n', '        uint256 tokenCode;\n', '        assembly { tokenCode := extcodesize(token) } // contract code size\n', '        if(tokenCode > 0)\n', '        {\n', '            Token tok = Token(token);\n', '            //  check if balanceOf succeeds\n', '            if(address(tok).call(bytes4(keccak256("balanceOf(address)")), user)) {\n', '                return tok.balanceOf(user);\n', '            } else {\n', '                  return 0; // not a valid balanceOf, return 0 instead of error\n', '            }\n', '        } else {\n', '            return 0; // not a contract, return 0 instead of error\n', '        }\n', '   }\n', '\n', '    /* Check the token balances of a wallet for multiple tokens\n', '       Uses tokenBalance() to be able to return, even if a token isn&#39;t valid\n', '       Possible error throws:\n', '           - extremely large arrays (gas cost too high)\n', '\n', '       Returns array of token balances in wei units. */\n', '    function walletBalances(address user,  address[] tokens) public view returns (uint[]) {\n', '        require(tokens.length > 0);\n', '        uint[] memory balances = new uint[](tokens.length);\n', '\n', '        for(uint i = 0; i< tokens.length; i++){\n', '            if( tokens[i] != address(0x0) ) { // ETH address in Etherdelta config\n', '                balances[i] = tokenBalance(user, tokens[i]);\n', '            }\n', '            else {\n', '               balances[i] = user.balance; // eth balance\n', '            }\n', '        }\n', '        return balances;\n', '    }\n', '\n', '    /* Check the token allowances of a wallet for multiple tokens\n', '       Uses tokenBalance() to be able to return, even if a token isn&#39;t valid\n', '       Possible error throws:\n', '           - extremely large arrays (gas cost too high)\n', '\n', '       Returns array of token allowances in wei units. */\n', '    function walletAllowances(address user,  address spender, address[] tokens) public view returns (uint[]) {\n', '        require(tokens.length > 0);\n', '        uint[] memory allowances = new uint[](tokens.length);\n', '\n', '        for(uint i = 0; i< tokens.length; i++){\n', '            allowances[i] = tokenAllowance(user, spender, tokens[i]);\n', '        }\n', '        return allowances;\n', '    }\n', '\n', '    /* Similar to walletA, with the addition of supporting multiple users\n', '       When calling this funtion through Infura, it handles a large number of users/tokens before it\n', '       fails and returns 0x0 as the result. So there is some max number of arguements you can send...\n', '       */\n', '    function allAllowancesForManyAccounts(\n', '        address[] users,\n', '        address spender,\n', '        address[] tokens)\n', '    public view returns (uint[]) {\n', '        uint[] memory allowances = new uint[](tokens.length * users.length);\n', '\n', '        for(uint user = 0; user < users.length; user++){\n', '            for(uint token = 0; token < tokens.length; token++) {\n', '                    allowances[(user * tokens.length) + token] = tokenAllowance(users[user], spender, tokens[token]);\n', '          }\n', '        }\n', '        return allowances;\n', '    }\n', '\n', '    /* Similar to allBalances, with the addition of supporting multiple users\n', '       When calling this funtion through Infura, it handles a large number of users/tokens before it\n', '       fails and returns 0x0 as the result. So there is some max number of arguements you can send...\n', '       */\n', '    function allBalancesForManyAccounts(\n', '        address[] users,\n', '        address[] tokens)\n', '    public view returns (uint[]) {\n', '        uint[] memory balances = new uint[](tokens.length * users.length);\n', '\n', '        for(uint user = 0; user < users.length; user++){\n', '            for(uint token = 0; token < tokens.length; token++){\n', '                if( tokens[token] != address(0x0) ) { // ETH address in Etherdelta config\n', '                    balances[(user * tokens.length) + token] = tokenBalance(users[user], tokens[token]);\n', '                } else {\n', '                   balances[(user * tokens.length) + token] =  users[user].balance;\n', '                }\n', '            }\n', '        }\n', '        return balances;\n', '    }\n', '\n', '    /* Check the balances of many address&#39; WETH (which is a 0x ETH wrapper for 0x exchanges)\n', '       */\n', '    function allWETHbalances(\n', '        address wethAddress,\n', '        address[] users\n', '    ) public view returns (uint[]) {\n', '        WETH_0x weth = WETH_0x(wethAddress);\n', '        uint[] memory balances = new uint[](users.length);\n', '        for(uint k = 0; k < users.length; k++){\n', '            balances[k] = weth.balanceOf(users[k]);\n', '        }\n', '        return balances;\n', '    }\n', '}']