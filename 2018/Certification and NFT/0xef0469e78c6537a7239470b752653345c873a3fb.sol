['pragma solidity 0.4.23;\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Stoppable\n', ' * @dev Base contract which allows children to implement final irreversible stop mechanism.\n', ' */\n', 'contract Stoppable is Pausable {\n', '  event Stop();\n', '\n', '  bool public stopped = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not stopped.\n', '   */\n', '  modifier whenNotStopped() {\n', '    require(!stopped);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is stopped.\n', '   */\n', '  modifier whenStopped() {\n', '    require(stopped);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function stop() public onlyOwner whenNotStopped {\n', '    stopped = true;\n', '    emit Stop();\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Eth2Phone Escrow Contract\n', ' * @dev Contract allows to send ether through verifier (owner of contract).\n', ' * \n', ' * Only verifier can initiate withdrawal to recipient&#39;s address. \n', ' * Verifier cannot choose recipient&#39;s address without \n', ' * transit private key generated by sender. \n', ' * \n', ' * Sender is responsible to provide transit private key\n', ' * to recipient off-chain.\n', ' * \n', ' * Recepient signs address to receive with transit private key and \n', ' * provides signed address to verification server. \n', ' * (See VerifyTransferSignature method for details.)\n', ' * \n', ' * Verifier verifies off-chain the recipient in accordance with verification \n', ' * conditions (e.g., phone ownership via SMS authentication) and initiates\n', ' * withdrawal to the address provided by recipient.\n', ' * (See withdraw method for details.)\n', ' * \n', ' * Verifier charges commission for it&#39;s services.\n', ' * \n', ' * Sender is able to cancel transfer if it&#39;s not yet cancelled or withdrawn\n', ' * by recipient.\n', ' * (See cancelTransfer method for details.)\n', ' */\n', 'contract e2pEscrow is Stoppable, SafeMath {\n', '\n', '  // fixed amount of wei accrued to verifier with each transfer\n', '  uint public commissionFee;\n', '\n', '  // verifier can withdraw this amount from smart-contract\n', '  uint public commissionToWithdraw; // in wei\n', '\n', '  // verifier&#39;s address\n', '  address public verifier;\n', '    \n', '  /*\n', '   * EVENTS\n', '   */\n', '  event LogDeposit(\n', '\t\t   address indexed sender,\n', '\t\t   address indexed transitAddress,\n', '\t\t   uint amount,\n', '\t\t      uint commission\n', '\t\t   );\n', '\n', '  event LogCancel(\n', '\t\t  address indexed sender,\n', '\t\t  address indexed transitAddress\n', '\t\t  );\n', '\n', '  event LogWithdraw(\n', '\t\t    address indexed sender,\n', '\t\t    address indexed transitAddress,\n', '\t\t    address indexed recipient,\n', '\t\t    uint amount\n', '\t\t    );\n', '\n', '  event LogWithdrawCommission(uint commissionAmount);\n', '\n', '  event LogChangeFixedCommissionFee(\n', '\t\t\t\t    uint oldCommissionFee,\n', '\t\t\t\t    uint newCommissionFee\n', '\t\t\t\t    );\n', '  \n', '  event LogChangeVerifier(\n', '\t\t\t  address oldVerifier,\n', '\t\t\t  address newVerifier\n', '\t\t\t  );  \n', '  \n', '  struct Transfer {\n', '    address from;\n', '    uint amount; // in wei\n', '  }\n', '\n', '  // Mappings of transitAddress => Transfer Struct\n', '  mapping (address => Transfer) transferDct;\n', '\n', '\n', '  /**\n', '   * @dev Contructor that sets msg.sender as owner (verifier) in Ownable\n', '   * and sets verifier&#39;s fixed commission fee.\n', '   * @param _commissionFee uint Verifier&#39;s fixed commission for each transfer\n', '   */\n', '  constructor(uint _commissionFee, address _verifier) public {\n', '    commissionFee = _commissionFee;\n', '    verifier = _verifier;\n', '  }\n', '\n', '\n', '  modifier onlyVerifier() {\n', '    require(msg.sender == verifier);\n', '    _;\n', '  }\n', '  \n', '  /**\n', '   * @dev Deposit ether to smart-contract and create transfer.\n', '   * Transit address is assigned to transfer by sender. \n', '   * Recipient should sign withrawal address with the transit private key \n', '   * \n', '   * @param _transitAddress transit address assigned to transfer.\n', '   * @return True if success.\n', '   */\n', '  function deposit(address _transitAddress)\n', '                            public\n', '                            whenNotPaused\n', '                            whenNotStopped\n', '                            payable\n', '    returns(bool)\n', '  {\n', '    // can not override existing transfer\n', '    require(transferDct[_transitAddress].amount == 0);\n', '\n', '    require(msg.value > commissionFee);\n', '\n', '    // saving transfer details\n', '    transferDct[_transitAddress] = Transfer(\n', '\t\t\t\t\t    msg.sender,\n', '\t\t\t\t\t    safeSub(msg.value, commissionFee)//amount = msg.value - comission\n', '\t\t\t\t\t    );\n', '\n', '    // accrue verifier&#39;s commission\n', '    commissionToWithdraw = safeAdd(commissionToWithdraw, commissionFee);\n', '\n', '    // log deposit event\n', '    emit LogDeposit(msg.sender, _transitAddress, msg.value, commissionFee);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Change verifier&#39;s fixed commission fee.\n', '   * Only owner can change commision fee.\n', '   * \n', '   * @param _newCommissionFee uint New verifier&#39;s fixed commission\n', '   * @return True if success.\n', '   */\n', '  function changeFixedCommissionFee(uint _newCommissionFee)\n', '                          public\n', '                          whenNotPaused\n', '                          whenNotStopped\n', '                          onlyOwner\n', '    returns(bool success)\n', '  {\n', '    uint oldCommissionFee = commissionFee;\n', '    commissionFee = _newCommissionFee;\n', '    emit LogChangeFixedCommissionFee(oldCommissionFee, commissionFee);\n', '    return true;\n', '  }\n', '\n', '  \n', '  /**\n', '   * @dev Change verifier&#39;s address.\n', '   * Only owner can change verifier&#39;s address.\n', '   * \n', '   * @param _newVerifier address New verifier&#39;s address\n', '   * @return True if success.\n', '   */\n', '  function changeVerifier(address _newVerifier)\n', '                          public\n', '                          whenNotPaused\n', '                          whenNotStopped\n', '                          onlyOwner\n', '    returns(bool success)\n', '  {\n', '    address oldVerifier = verifier;\n', '    verifier = _newVerifier;\n', '    emit LogChangeVerifier(oldVerifier, verifier);\n', '    return true;\n', '  }\n', '\n', '  \n', '  /**\n', '   * @dev Transfer accrued commission to verifier&#39;s address.\n', '   * @return True if success.\n', '   */\n', '  function withdrawCommission()\n', '                        public\n', '                        whenNotPaused\n', '    returns(bool success)\n', '  {\n', '    uint commissionToTransfer = commissionToWithdraw;\n', '    commissionToWithdraw = 0;\n', '    owner.transfer(commissionToTransfer); // owner is verifier\n', '\n', '    emit LogWithdrawCommission(commissionToTransfer);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Get transfer details.\n', '   * @param _transitAddress transit address assigned to transfer\n', '   * @return Transfer details (id, sender, amount)\n', '   */\n', '  function getTransfer(address _transitAddress)\n', '            public\n', '            constant\n', '    returns (\n', '\t     address id,\n', '\t     address from, // transfer sender\n', '\t     uint amount) // in wei\n', '  {\n', '    Transfer memory transfer = transferDct[_transitAddress];\n', '    return (\n', '\t    _transitAddress,\n', '\t    transfer.from,\n', '\t        transfer.amount\n', '\t    );\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Cancel transfer and get sent ether back. Only transfer sender can\n', '   * cancel transfer.\n', '   * @param _transitAddress transit address assigned to transfer\n', '   * @return True if success.\n', '   */\n', '  function cancelTransfer(address _transitAddress) public returns (bool success) {\n', '    Transfer memory transferOrder = transferDct[_transitAddress];\n', '\n', '    // only sender can cancel transfer;\n', '    require(msg.sender == transferOrder.from);\n', '\n', '    delete transferDct[_transitAddress];\n', '    \n', '    // transfer ether to recipient&#39;s address\n', '    msg.sender.transfer(transferOrder.amount);\n', '\n', '    // log cancel event\n', '    emit LogCancel(msg.sender, _transitAddress);\n', '    \n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Verify that address is signed with correct verification private key.\n', '   * @param _transitAddress transit address assigned to transfer\n', '   * @param _recipient address Signed address.\n', '   * @param _v ECDSA signature parameter v.\n', '   * @param _r ECDSA signature parameters r.\n', '   * @param _s ECDSA signature parameters s.\n', '   * @return True if signature is correct.\n', '   */\n', '  function verifySignature(\n', '\t\t\t   address _transitAddress,\n', '\t\t\t   address _recipient,\n', '\t\t\t   uint8 _v,\n', '\t\t\t   bytes32 _r,\n', '\t\t\t   bytes32 _s)\n', '    public pure returns(bool success)\n', '  {\n', '    bytes32 prefixedHash = keccak256("\\x19Ethereum Signed Message:\\n32", _recipient);\n', '    address retAddr = ecrecover(prefixedHash, _v, _r, _s);\n', '    return retAddr == _transitAddress;\n', '  }\n', '\n', '  /**\n', '   * @dev Verify that address is signed with correct private key for\n', '   * verification public key assigned to transfer.\n', '   * @param _transitAddress transit address assigned to transfer\n', '   * @param _recipient address Signed address.\n', '   * @param _v ECDSA signature parameter v.\n', '   * @param _r ECDSA signature parameters r.\n', '   * @param _s ECDSA signature parameters s.\n', '   * @return True if signature is correct.\n', '   */\n', '  function verifyTransferSignature(\n', '\t\t\t\t   address _transitAddress,\n', '\t\t\t\t   address _recipient,\n', '\t\t\t\t   uint8 _v,\n', '\t\t\t\t   bytes32 _r,\n', '\t\t\t\t   bytes32 _s)\n', '    public pure returns(bool success)\n', '  {\n', '    return (verifySignature(_transitAddress,\n', '\t\t\t    _recipient, _v, _r, _s));\n', '  }\n', '\n', '  /**\n', '   * @dev Withdraw transfer to recipient&#39;s address if it is correctly signed\n', '   * with private key for verification public key assigned to transfer.\n', '   * \n', '   * @param _transitAddress transit address assigned to transfer\n', '   * @param _recipient address Signed address.\n', '   * @param _v ECDSA signature parameter v.\n', '   * @param _r ECDSA signature parameters r.\n', '   * @param _s ECDSA signature parameters s.\n', '   * @return True if success.\n', '   */\n', '  function withdraw(\n', '\t\t    address _transitAddress,\n', '\t\t    address _recipient,\n', '\t\t    uint8 _v,\n', '\t\t    bytes32 _r,\n', '\t\t    bytes32 _s\n', '\t\t    )\n', '    public\n', '    onlyVerifier // only through verifier can withdraw transfer;\n', '    whenNotPaused\n', '    whenNotStopped\n', '    returns (bool success)\n', '  {\n', '    Transfer memory transferOrder = transferDct[_transitAddress];\n', '\n', '    // verifying signature\n', '    (verifySignature(_transitAddress,\n', '\t\t     _recipient, _v, _r, _s ));\n', '\n', '    delete transferDct[_transitAddress];\n', '\n', '    // transfer ether to recipient&#39;s address\n', '    _recipient.transfer(transferOrder.amount);\n', '\n', '    // log withdraw event\n', '    emit LogWithdraw(transferOrder.from, _transitAddress, _recipient, transferOrder.amount);\n', '\n', '    return true;\n', '  }\n', '\n', '  // fallback function - do not receive ether by default\n', '  function() public payable {\n', '    revert();\n', '  }\n', '}']
['pragma solidity 0.4.23;\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Stoppable\n', ' * @dev Base contract which allows children to implement final irreversible stop mechanism.\n', ' */\n', 'contract Stoppable is Pausable {\n', '  event Stop();\n', '\n', '  bool public stopped = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not stopped.\n', '   */\n', '  modifier whenNotStopped() {\n', '    require(!stopped);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is stopped.\n', '   */\n', '  modifier whenStopped() {\n', '    require(stopped);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function stop() public onlyOwner whenNotStopped {\n', '    stopped = true;\n', '    emit Stop();\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Eth2Phone Escrow Contract\n', ' * @dev Contract allows to send ether through verifier (owner of contract).\n', ' * \n', " * Only verifier can initiate withdrawal to recipient's address. \n", " * Verifier cannot choose recipient's address without \n", ' * transit private key generated by sender. \n', ' * \n', ' * Sender is responsible to provide transit private key\n', ' * to recipient off-chain.\n', ' * \n', ' * Recepient signs address to receive with transit private key and \n', ' * provides signed address to verification server. \n', ' * (See VerifyTransferSignature method for details.)\n', ' * \n', ' * Verifier verifies off-chain the recipient in accordance with verification \n', ' * conditions (e.g., phone ownership via SMS authentication) and initiates\n', ' * withdrawal to the address provided by recipient.\n', ' * (See withdraw method for details.)\n', ' * \n', " * Verifier charges commission for it's services.\n", ' * \n', " * Sender is able to cancel transfer if it's not yet cancelled or withdrawn\n", ' * by recipient.\n', ' * (See cancelTransfer method for details.)\n', ' */\n', 'contract e2pEscrow is Stoppable, SafeMath {\n', '\n', '  // fixed amount of wei accrued to verifier with each transfer\n', '  uint public commissionFee;\n', '\n', '  // verifier can withdraw this amount from smart-contract\n', '  uint public commissionToWithdraw; // in wei\n', '\n', "  // verifier's address\n", '  address public verifier;\n', '    \n', '  /*\n', '   * EVENTS\n', '   */\n', '  event LogDeposit(\n', '\t\t   address indexed sender,\n', '\t\t   address indexed transitAddress,\n', '\t\t   uint amount,\n', '\t\t      uint commission\n', '\t\t   );\n', '\n', '  event LogCancel(\n', '\t\t  address indexed sender,\n', '\t\t  address indexed transitAddress\n', '\t\t  );\n', '\n', '  event LogWithdraw(\n', '\t\t    address indexed sender,\n', '\t\t    address indexed transitAddress,\n', '\t\t    address indexed recipient,\n', '\t\t    uint amount\n', '\t\t    );\n', '\n', '  event LogWithdrawCommission(uint commissionAmount);\n', '\n', '  event LogChangeFixedCommissionFee(\n', '\t\t\t\t    uint oldCommissionFee,\n', '\t\t\t\t    uint newCommissionFee\n', '\t\t\t\t    );\n', '  \n', '  event LogChangeVerifier(\n', '\t\t\t  address oldVerifier,\n', '\t\t\t  address newVerifier\n', '\t\t\t  );  \n', '  \n', '  struct Transfer {\n', '    address from;\n', '    uint amount; // in wei\n', '  }\n', '\n', '  // Mappings of transitAddress => Transfer Struct\n', '  mapping (address => Transfer) transferDct;\n', '\n', '\n', '  /**\n', '   * @dev Contructor that sets msg.sender as owner (verifier) in Ownable\n', "   * and sets verifier's fixed commission fee.\n", "   * @param _commissionFee uint Verifier's fixed commission for each transfer\n", '   */\n', '  constructor(uint _commissionFee, address _verifier) public {\n', '    commissionFee = _commissionFee;\n', '    verifier = _verifier;\n', '  }\n', '\n', '\n', '  modifier onlyVerifier() {\n', '    require(msg.sender == verifier);\n', '    _;\n', '  }\n', '  \n', '  /**\n', '   * @dev Deposit ether to smart-contract and create transfer.\n', '   * Transit address is assigned to transfer by sender. \n', '   * Recipient should sign withrawal address with the transit private key \n', '   * \n', '   * @param _transitAddress transit address assigned to transfer.\n', '   * @return True if success.\n', '   */\n', '  function deposit(address _transitAddress)\n', '                            public\n', '                            whenNotPaused\n', '                            whenNotStopped\n', '                            payable\n', '    returns(bool)\n', '  {\n', '    // can not override existing transfer\n', '    require(transferDct[_transitAddress].amount == 0);\n', '\n', '    require(msg.value > commissionFee);\n', '\n', '    // saving transfer details\n', '    transferDct[_transitAddress] = Transfer(\n', '\t\t\t\t\t    msg.sender,\n', '\t\t\t\t\t    safeSub(msg.value, commissionFee)//amount = msg.value - comission\n', '\t\t\t\t\t    );\n', '\n', "    // accrue verifier's commission\n", '    commissionToWithdraw = safeAdd(commissionToWithdraw, commissionFee);\n', '\n', '    // log deposit event\n', '    emit LogDeposit(msg.sender, _transitAddress, msg.value, commissionFee);\n', '    return true;\n', '  }\n', '\n', '  /**\n', "   * @dev Change verifier's fixed commission fee.\n", '   * Only owner can change commision fee.\n', '   * \n', "   * @param _newCommissionFee uint New verifier's fixed commission\n", '   * @return True if success.\n', '   */\n', '  function changeFixedCommissionFee(uint _newCommissionFee)\n', '                          public\n', '                          whenNotPaused\n', '                          whenNotStopped\n', '                          onlyOwner\n', '    returns(bool success)\n', '  {\n', '    uint oldCommissionFee = commissionFee;\n', '    commissionFee = _newCommissionFee;\n', '    emit LogChangeFixedCommissionFee(oldCommissionFee, commissionFee);\n', '    return true;\n', '  }\n', '\n', '  \n', '  /**\n', "   * @dev Change verifier's address.\n", "   * Only owner can change verifier's address.\n", '   * \n', "   * @param _newVerifier address New verifier's address\n", '   * @return True if success.\n', '   */\n', '  function changeVerifier(address _newVerifier)\n', '                          public\n', '                          whenNotPaused\n', '                          whenNotStopped\n', '                          onlyOwner\n', '    returns(bool success)\n', '  {\n', '    address oldVerifier = verifier;\n', '    verifier = _newVerifier;\n', '    emit LogChangeVerifier(oldVerifier, verifier);\n', '    return true;\n', '  }\n', '\n', '  \n', '  /**\n', "   * @dev Transfer accrued commission to verifier's address.\n", '   * @return True if success.\n', '   */\n', '  function withdrawCommission()\n', '                        public\n', '                        whenNotPaused\n', '    returns(bool success)\n', '  {\n', '    uint commissionToTransfer = commissionToWithdraw;\n', '    commissionToWithdraw = 0;\n', '    owner.transfer(commissionToTransfer); // owner is verifier\n', '\n', '    emit LogWithdrawCommission(commissionToTransfer);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Get transfer details.\n', '   * @param _transitAddress transit address assigned to transfer\n', '   * @return Transfer details (id, sender, amount)\n', '   */\n', '  function getTransfer(address _transitAddress)\n', '            public\n', '            constant\n', '    returns (\n', '\t     address id,\n', '\t     address from, // transfer sender\n', '\t     uint amount) // in wei\n', '  {\n', '    Transfer memory transfer = transferDct[_transitAddress];\n', '    return (\n', '\t    _transitAddress,\n', '\t    transfer.from,\n', '\t        transfer.amount\n', '\t    );\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Cancel transfer and get sent ether back. Only transfer sender can\n', '   * cancel transfer.\n', '   * @param _transitAddress transit address assigned to transfer\n', '   * @return True if success.\n', '   */\n', '  function cancelTransfer(address _transitAddress) public returns (bool success) {\n', '    Transfer memory transferOrder = transferDct[_transitAddress];\n', '\n', '    // only sender can cancel transfer;\n', '    require(msg.sender == transferOrder.from);\n', '\n', '    delete transferDct[_transitAddress];\n', '    \n', "    // transfer ether to recipient's address\n", '    msg.sender.transfer(transferOrder.amount);\n', '\n', '    // log cancel event\n', '    emit LogCancel(msg.sender, _transitAddress);\n', '    \n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Verify that address is signed with correct verification private key.\n', '   * @param _transitAddress transit address assigned to transfer\n', '   * @param _recipient address Signed address.\n', '   * @param _v ECDSA signature parameter v.\n', '   * @param _r ECDSA signature parameters r.\n', '   * @param _s ECDSA signature parameters s.\n', '   * @return True if signature is correct.\n', '   */\n', '  function verifySignature(\n', '\t\t\t   address _transitAddress,\n', '\t\t\t   address _recipient,\n', '\t\t\t   uint8 _v,\n', '\t\t\t   bytes32 _r,\n', '\t\t\t   bytes32 _s)\n', '    public pure returns(bool success)\n', '  {\n', '    bytes32 prefixedHash = keccak256("\\x19Ethereum Signed Message:\\n32", _recipient);\n', '    address retAddr = ecrecover(prefixedHash, _v, _r, _s);\n', '    return retAddr == _transitAddress;\n', '  }\n', '\n', '  /**\n', '   * @dev Verify that address is signed with correct private key for\n', '   * verification public key assigned to transfer.\n', '   * @param _transitAddress transit address assigned to transfer\n', '   * @param _recipient address Signed address.\n', '   * @param _v ECDSA signature parameter v.\n', '   * @param _r ECDSA signature parameters r.\n', '   * @param _s ECDSA signature parameters s.\n', '   * @return True if signature is correct.\n', '   */\n', '  function verifyTransferSignature(\n', '\t\t\t\t   address _transitAddress,\n', '\t\t\t\t   address _recipient,\n', '\t\t\t\t   uint8 _v,\n', '\t\t\t\t   bytes32 _r,\n', '\t\t\t\t   bytes32 _s)\n', '    public pure returns(bool success)\n', '  {\n', '    return (verifySignature(_transitAddress,\n', '\t\t\t    _recipient, _v, _r, _s));\n', '  }\n', '\n', '  /**\n', "   * @dev Withdraw transfer to recipient's address if it is correctly signed\n", '   * with private key for verification public key assigned to transfer.\n', '   * \n', '   * @param _transitAddress transit address assigned to transfer\n', '   * @param _recipient address Signed address.\n', '   * @param _v ECDSA signature parameter v.\n', '   * @param _r ECDSA signature parameters r.\n', '   * @param _s ECDSA signature parameters s.\n', '   * @return True if success.\n', '   */\n', '  function withdraw(\n', '\t\t    address _transitAddress,\n', '\t\t    address _recipient,\n', '\t\t    uint8 _v,\n', '\t\t    bytes32 _r,\n', '\t\t    bytes32 _s\n', '\t\t    )\n', '    public\n', '    onlyVerifier // only through verifier can withdraw transfer;\n', '    whenNotPaused\n', '    whenNotStopped\n', '    returns (bool success)\n', '  {\n', '    Transfer memory transferOrder = transferDct[_transitAddress];\n', '\n', '    // verifying signature\n', '    (verifySignature(_transitAddress,\n', '\t\t     _recipient, _v, _r, _s ));\n', '\n', '    delete transferDct[_transitAddress];\n', '\n', "    // transfer ether to recipient's address\n", '    _recipient.transfer(transferOrder.amount);\n', '\n', '    // log withdraw event\n', '    emit LogWithdraw(transferOrder.from, _transitAddress, _recipient, transferOrder.amount);\n', '\n', '    return true;\n', '  }\n', '\n', '  // fallback function - do not receive ether by default\n', '  function() public payable {\n', '    revert();\n', '  }\n', '}']
