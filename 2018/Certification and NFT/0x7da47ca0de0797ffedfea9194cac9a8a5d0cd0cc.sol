['pragma solidity ^0.4.13;\n', '\n', 'interface ERC721Metadata {\n', '\n', '    /// @dev ERC-165 (draft) interface signature for ERC721\n', '    // bytes4 internal constant INTERFACE_SIGNATURE_ERC721Metadata = // 0x2a786f11\n', '    //     bytes4(keccak256(&#39;name()&#39;)) ^\n', '    //     bytes4(keccak256(&#39;symbol()&#39;)) ^\n', '    //     bytes4(keccak256(&#39;deedUri(uint256)&#39;));\n', '\n', '    /// @notice A descriptive name for a collection of deeds managed by this\n', '    ///  contract\n', '    /// @dev Wallets and exchanges MAY display this to the end user.\n', '    function name() external pure returns (string _name);\n', '\n', '    /// @notice An abbreviated name for deeds managed by this contract\n', '    /// @dev Wallets and exchanges MAY display this to the end user.\n', '    function symbol() external pure returns (string _symbol);\n', '\n', '    /// @notice A distinct name for a deed managed by this contract\n', '    /// @dev Wallets and exchanges MAY display this to the end user.\n', '    function deedName(uint256 _deedId) external pure returns (string _deedName);\n', '\n', '    /// @notice A distinct URI (RFC 3986) for a given token.\n', '    /// @dev If:\n', '    ///  * The URI is a URL\n', '    ///  * The URL is accessible\n', '    ///  * The URL points to a valid JSON file format (ECMA-404 2nd ed.)\n', '    ///  * The JSON base element is an object\n', '    ///  then these names of the base element SHALL have special meaning:\n', '    ///  * "name": A string identifying the item to which `_deedId` grants\n', '    ///    ownership\n', '    ///  * "description": A string detailing the item to which `_deedId` grants\n', '    ///    ownership\n', '    ///  * "image": A URI pointing to a file of image/* mime type representing\n', '    ///    the item to which `_deedId` grants ownership\n', '    ///  Wallets and exchanges MAY display this to the end user.\n', '    ///  Consider making any images at a width between 320 and 1080 pixels and\n', '    ///  aspect ratio between 1.91:1 and 4:5 inclusive.\n', '    function deedUri(uint256 _deedId) external view returns (string _deedUri);\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancy_lock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancy_lock);\n', '    reentrancy_lock = true;\n', '    _;\n', '    reentrancy_lock = false;\n', '  }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', 'interface ERC721 {\n', '\n', '    // COMPLIANCE WITH ERC-165 (DRAFT) /////////////////////////////////////////\n', '\n', '    /// @dev ERC-165 (draft) interface signature for itself\n', '    // bytes4 internal constant INTERFACE_SIGNATURE_ERC165 = // 0x01ffc9a7\n', '    //     bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));\n', '\n', '    /// @dev ERC-165 (draft) interface signature for ERC721\n', '    // bytes4 internal constant INTERFACE_SIGNATURE_ERC721 = // 0xda671b9b\n', '    //     bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) ^\n', '    //     bytes4(keccak256(&#39;countOfDeeds()&#39;)) ^\n', '    //     bytes4(keccak256(&#39;countOfDeedsByOwner(address)&#39;)) ^\n', '    //     bytes4(keccak256(&#39;deedOfOwnerByIndex(address,uint256)&#39;)) ^\n', '    //     bytes4(keccak256(&#39;approve(address,uint256)&#39;)) ^\n', '    //     bytes4(keccak256(&#39;takeOwnership(uint256)&#39;));\n', '\n', '    /// @notice Query a contract to see if it supports a certain interface\n', '    /// @dev Returns `true` the interface is supported and `false` otherwise,\n', '    ///  returns `true` for INTERFACE_SIGNATURE_ERC165 and\n', '    ///  INTERFACE_SIGNATURE_ERC721, see ERC-165 for other interface signatures.\n', '    function supportsInterface(bytes4 _interfaceID) external pure returns (bool);\n', '\n', '    // PUBLIC QUERY FUNCTIONS //////////////////////////////////////////////////\n', '\n', '    /// @notice Find the owner of a deed\n', '    /// @param _deedId The identifier for a deed we are inspecting\n', '    /// @dev Deeds assigned to zero address are considered invalid, and\n', '    ///  queries about them do throw.\n', '    /// @return The non-zero address of the owner of deed `_deedId`, or `throw`\n', '    ///  if deed `_deedId` is not tracked by this contract\n', '    function ownerOf(uint256 _deedId) external view returns (address _owner);\n', '\n', '    /// @notice Count deeds tracked by this contract\n', '    /// @return A count of valid deeds tracked by this contract, where each one of\n', '    ///  them has an assigned and queryable owner not equal to the zero address\n', '    function countOfDeeds() external view returns (uint256 _count);\n', '\n', '    /// @notice Count all deeds assigned to an owner\n', '    /// @dev Throws if `_owner` is the zero address, representing invalid deeds.\n', '    /// @param _owner An address where we are interested in deeds owned by them\n', '    /// @return The number of deeds owned by `_owner`, possibly zero\n', '    function countOfDeedsByOwner(address _owner) external view returns (uint256 _count);\n', '\n', '    /// @notice Enumerate deeds assigned to an owner\n', '    /// @dev Throws if `_index` >= `countOfDeedsByOwner(_owner)` or if\n', '    ///  `_owner` is the zero address, representing invalid deeds.\n', '    /// @param _owner An address where we are interested in deeds owned by them\n', '    /// @param _index A counter less than `countOfDeedsByOwner(_owner)`\n', '    /// @return The identifier for the `_index`th deed assigned to `_owner`,\n', '    ///   (sort order not specified)\n', '    function deedOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _deedId);\n', '\n', '    // TRANSFER MECHANISM //////////////////////////////////////////////////////\n', '\n', '    /// @dev This event emits when ownership of any deed changes by any\n', '    ///  mechanism. This event emits when deeds are created (`from` == 0) and\n', '    ///  destroyed (`to` == 0). Exception: during contract creation, any\n', '    ///  transfers may occur without emitting `Transfer`. At the time of any transfer,\n', '    ///  the "approved taker" is implicitly reset to the zero address.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _deedId);\n', '\n', '    /// @dev The Approve event emits to log the "approved taker" for a deed -- whether\n', '    ///  set for the first time, reaffirmed by setting the same value, or setting to\n', '    ///  a new value. The "approved taker" is the zero address if nobody can take the\n', '    ///  deed now or it is an address if that address can call `takeOwnership` to attempt\n', '    ///  taking the deed. Any change to the "approved taker" for a deed SHALL cause\n', '    ///  Approve to emit. However, an exception, the Approve event will not emit when\n', '    ///  Transfer emits, this is because Transfer implicitly denotes the "approved taker"\n', '    ///  is reset to the zero address.\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _deedId);\n', '\n', '    /// @notice Set the "approved taker" for your deed, or revoke approval by\n', '    ///  setting the zero address. You may `approve` any number of times while\n', '    ///  the deed is assigned to you, only the most recent approval matters. Emits\n', '    ///  an Approval event.\n', '    /// @dev Throws if `msg.sender` does not own deed `_deedId` or if `_to` ==\n', '    ///  `msg.sender` or if `_deedId` is not a valid deed.\n', '    /// @param _deedId The deed for which you are granting approval\n', '    function approve(address _to, uint256 _deedId) external payable;\n', '\n', '    /// @notice Become owner of a deed for which you are currently approved\n', '    /// @dev Throws if `msg.sender` is not approved to become the owner of\n', '    ///  `deedId` or if `msg.sender` currently owns `_deedId` or if `_deedId is not a\n', '    ///  valid deed.\n', '    /// @param _deedId The deed that is being transferred\n', '    function takeOwnership(uint256 _deedId) external payable;\n', '}\n', '\n', 'contract ERC721Deed is ERC721 {\n', '  using SafeMath for uint256;\n', '\n', '  // Total amount of deeds\n', '  uint256 private totalDeeds;\n', '\n', '  // Mapping from deed ID to owner\n', '  mapping (uint256 => address) private deedOwner;\n', '\n', '  // Mapping from deed ID to approved address\n', '  mapping (uint256 => address) private deedApprovedFor;\n', '\n', '  // Mapping from owner to list of owned deed IDs\n', '  mapping (address => uint256[]) private ownedDeeds;\n', '\n', '  // Mapping from deed ID to index of the owner deeds list\n', '  mapping(uint256 => uint256) private ownedDeedsIndex;\n', '\n', '  /**\n', '  * @dev Guarantees msg.sender is owner of the given deed\n', '  * @param _deedId uint256 ID of the deed to validate its ownership belongs to msg.sender\n', '  */\n', '  modifier onlyOwnerOf(uint256 _deedId) {\n', '    require(deedOwner[_deedId] == msg.sender);\n', '    _;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the owner of the specified deed ID\n', '  * @param _deedId uint256 ID of the deed to query the owner of\n', '  * @return owner address currently marked as the owner of the given deed ID\n', '  */\n', '  function ownerOf(uint256 _deedId)\n', '  external view returns (address _owner) {\n', '    require(deedOwner[_deedId] != address(0));\n', '    _owner = deedOwner[_deedId];\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the total amount of deeds stored by the contract\n', '  * @return uint256 representing the total amount of deeds\n', '  */\n', '  function countOfDeeds()\n', '  external view returns (uint256) {\n', '    return totalDeeds;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the number of deeds of the specified address\n', '  * @param _owner address to query the number of deeds\n', '  * @return uint256 representing the number of deeds owned by the passed address\n', '  */\n', '  function countOfDeedsByOwner(address _owner)\n', '  external view returns (uint256 _count) {\n', '    require(_owner != address(0));\n', '    _count = ownedDeeds[_owner].length;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the deed ID of the specified address at the specified index\n', '  * @param _owner address for the deed&#39;s owner\n', '  * @param _index uint256 for the n-th deed in the list of deeds owned by this owner\n', '  * @return uint256 representing the ID of the deed\n', '  */\n', '  function deedOfOwnerByIndex(address _owner, uint256 _index)\n', '  external view returns (uint256 _deedId) {\n', '    require(_owner != address(0));\n', '    require(_index < ownedDeeds[_owner].length);\n', '    _deedId = ownedDeeds[_owner][_index];\n', '  }\n', '\n', '  /**\n', '  * @dev Gets all deed IDs of the specified address\n', '  * @param _owner address for the deed&#39;s owner\n', '  * @return uint256[] representing all deed IDs owned by the passed address\n', '  */\n', '  function deedsOf(address _owner)\n', '  external view returns (uint256[] _ownedDeedIds) {\n', '    require(_owner != address(0));\n', '    _ownedDeedIds = ownedDeeds[_owner];\n', '  }\n', '\n', '  /**\n', '  * @dev Approves another address to claim for the ownership of the given deed ID\n', '  * @param _to address to be approved for the given deed ID\n', '  * @param _deedId uint256 ID of the deed to be approved\n', '  */\n', '  function approve(address _to, uint256 _deedId)\n', '  external onlyOwnerOf(_deedId) payable {\n', '    require(msg.value == 0);\n', '    require(_to != msg.sender);\n', '    if(_to != address(0) || approvedFor(_deedId) != address(0)) {\n', '      emit Approval(msg.sender, _to, _deedId);\n', '    }\n', '    deedApprovedFor[_deedId] = _to;\n', '  }\n', '\n', '  /**\n', '  * @dev Claims the ownership of a given deed ID\n', '  * @param _deedId uint256 ID of the deed being claimed by the msg.sender\n', '  */\n', '  function takeOwnership(uint256 _deedId)\n', '  external payable {\n', '    require(approvedFor(_deedId) == msg.sender);\n', '    clearApprovalAndTransfer(deedOwner[_deedId], msg.sender, _deedId);\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the approved address to take ownership of a given deed ID\n', '   * @param _deedId uint256 ID of the deed to query the approval of\n', '   * @return address currently approved to take ownership of the given deed ID\n', '   */\n', '  function approvedFor(uint256 _deedId)\n', '  public view returns (address) {\n', '    return deedApprovedFor[_deedId];\n', '  }\n', '\n', '  /**\n', '  * @dev Transfers the ownership of a given deed ID to another address\n', '  * @param _to address to receive the ownership of the given deed ID\n', '  * @param _deedId uint256 ID of the deed to be transferred\n', '  */\n', '  function transfer(address _to, uint256 _deedId)\n', '  public onlyOwnerOf(_deedId) {\n', '    clearApprovalAndTransfer(msg.sender, _to, _deedId);\n', '  }\n', '\n', '  /**\n', '  * @dev Mint deed function\n', '  * @param _to The address that will own the minted deed\n', '  */\n', '  function _mint(address _to, uint256 _deedId)\n', '  internal {\n', '    require(_to != address(0));\n', '    addDeed(_to, _deedId);\n', '    emit Transfer(0x0, _to, _deedId);\n', '  }\n', '\n', '  /**\n', '  * @dev Burns a specific deed\n', '  * @param _deedId uint256 ID of the deed being burned by the msg.sender\n', '  * Removed because Factbars cannot be destroyed\n', '  */\n', '  // function _burn(uint256 _deedId) onlyOwnerOf(_deedId)\n', '  // internal {\n', '  //   if (approvedFor(_deedId) != 0) {\n', '  //     clearApproval(msg.sender, _deedId);\n', '  //   }\n', '  //   removeDeed(msg.sender, _deedId);\n', '  //   emit Transfer(msg.sender, 0x0, _deedId);\n', '  // }\n', '\n', '  /**\n', '  * @dev Internal function to clear current approval and transfer the ownership of a given deed ID\n', '  * @param _from address which you want to send deeds from\n', '  * @param _to address which you want to transfer the deed to\n', '  * @param _deedId uint256 ID of the deed to be transferred\n', '  */\n', '  function clearApprovalAndTransfer(address _from, address _to, uint256 _deedId)\n', '  internal {\n', '    require(_to != address(0));\n', '    require(_to != _from);\n', '    require(deedOwner[_deedId] == _from);\n', '\n', '    clearApproval(_from, _deedId);\n', '    removeDeed(_from, _deedId);\n', '    addDeed(_to, _deedId);\n', '    emit Transfer(_from, _to, _deedId);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to clear current approval of a given deed ID\n', '  * @param _deedId uint256 ID of the deed to be transferred\n', '  */\n', '  function clearApproval(address _owner, uint256 _deedId)\n', '  private {\n', '    require(deedOwner[_deedId] == _owner);\n', '    deedApprovedFor[_deedId] = 0;\n', '    emit Approval(_owner, 0, _deedId);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to add a deed ID to the list of a given address\n', '  * @param _to address representing the new owner of the given deed ID\n', '  * @param _deedId uint256 ID of the deed to be added to the deeds list of the given address\n', '  */\n', '  function addDeed(address _to, uint256 _deedId)\n', '  private {\n', '    require(deedOwner[_deedId] == address(0));\n', '    deedOwner[_deedId] = _to;\n', '    uint256 length = ownedDeeds[_to].length;\n', '    ownedDeeds[_to].push(_deedId);\n', '    ownedDeedsIndex[_deedId] = length;\n', '    totalDeeds = totalDeeds.add(1);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to remove a deed ID from the list of a given address\n', '  * @param _from address representing the previous owner of the given deed ID\n', '  * @param _deedId uint256 ID of the deed to be removed from the deeds list of the given address\n', '  */\n', '  function removeDeed(address _from, uint256 _deedId)\n', '  private {\n', '    require(deedOwner[_deedId] == _from);\n', '\n', '    uint256 deedIndex = ownedDeedsIndex[_deedId];\n', '    uint256 lastDeedIndex = ownedDeeds[_from].length.sub(1);\n', '    uint256 lastDeed = ownedDeeds[_from][lastDeedIndex];\n', '\n', '    deedOwner[_deedId] = 0;\n', '    ownedDeeds[_from][deedIndex] = lastDeed;\n', '    ownedDeeds[_from][lastDeedIndex] = 0;\n', '    // Note that this will handle single-element arrays. In that case, both deedIndex and lastDeedIndex are going to\n', '    // be zero. Then we can make sure that we will remove _deedId from the ownedDeeds list since we are first swapping\n', '    // the lastDeed to the first position, and then dropping the element placed in the last position of the list\n', '\n', '    ownedDeeds[_from].length--;\n', '    ownedDeedsIndex[_deedId] = 0;\n', '    ownedDeedsIndex[lastDeed] = deedIndex;\n', '    totalDeeds = totalDeeds.sub(1);\n', '  }\n', '}\n', '\n', 'contract PullPayment {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) public payments;\n', '  uint256 public totalPayments;\n', '\n', '  /**\n', '  * @dev Withdraw accumulated balance, called by payee.\n', '  */\n', '  function withdrawPayments() public {\n', '    address payee = msg.sender;\n', '    uint256 payment = payments[payee];\n', '\n', '    require(payment != 0);\n', '    require(address(this).balance >= payment);\n', '\n', '    totalPayments = totalPayments.sub(payment);\n', '    payments[payee] = 0;\n', '\n', '    payee.transfer(payment);\n', '  }\n', '\n', '  /**\n', '  * @dev Called by the payer to store the sent amount as credit to be pulled.\n', '  * @param dest The destination address of the funds.\n', '  * @param amount The amount to transfer.\n', '  */\n', '  function asyncSend(address dest, uint256 amount) internal {\n', '    payments[dest] = payments[dest].add(amount);\n', '    totalPayments = totalPayments.add(amount);\n', '  }\n', '}\n', '\n', 'contract FactbarDeed is ERC721Deed, Pausable, PullPayment, ReentrancyGuard {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  /* Events */\n', '  // When a deed is created by the contract owner.\n', '  event Creation(uint256 indexed id, bytes32 indexed name, address factTeam);\n', '\n', '  // When a deed is appropriated, the ownership of the deed is transferred to the new owner.\n', '  // The old owner is reimbursed, and he gets the new price minus the transfer fee.\n', '  event Appropriation(uint256 indexed id, address indexed oldOwner, \n', '  address indexed newOwner, uint256 oldPrice, uint256 newPrice,\n', '  uint256 transferFeeAmount, uint256 excess,  uint256 oldOwnerPaymentAmount );\n', '\n', '  // Payments to the deed&#39;s fee address via PullPayment are also supported by this contract.\n', '  event Payment(uint256 indexed id, address indexed sender, address \n', '  indexed factTeam, uint256 amount);\n', '\n', '  // Factbars, like facts, cannot be destroyed. So we have removed \n', '  // all the deletion and desctruction features\n', '\n', '  // The data structure of the Factbar deed\n', '  \n', '  struct Factbar {\n', '    bytes32 name;\n', '    address factTeam;\n', '    uint256 price;\n', '    uint256 created;\n', '  }\n', '\n', '  // Mapping from _deedId to Factbar\n', '  mapping (uint256 => Factbar) private deeds;\n', '\n', '  // Mapping from deed name to boolean indicating if the name is already taken\n', '  mapping (bytes32 => bool) private deedNameExists;\n', '\n', '  // Needed to make all deeds discoverable. The length of this array also serves as our deed ID.\n', '  uint256[] private deedIds;\n', '\n', '  // These are the admins who have the power to create deeds.\n', '  mapping (address => bool) private admins;\n', '\n', '  /* Variables in control of owner */\n', '\n', '  // The contract owner can change the initial price of deeds at Creation.\n', '  uint256 private creationPrice = 0.0005 ether; \n', '\n', '  // The contract owner can change the base URL, in case it becomes necessary. It is needed for Metadata.\n', '  string public url = "https://fact-bar.org/facts/";\n', '\n', '  // ERC-165 Metadata\n', '  bytes4 internal constant INTERFACE_SIGNATURE_ERC165 = // 0x01ffc9a7\n', '      bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));\n', '\n', '  bytes4 internal constant INTERFACE_SIGNATURE_ERC721 = // 0xda671b9b\n', '      bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) ^\n', '      bytes4(keccak256(&#39;countOfDeeds()&#39;)) ^\n', '      bytes4(keccak256(&#39;countOfDeedsByOwner(address)&#39;)) ^\n', '      bytes4(keccak256(&#39;deedOfOwnerByIndex(address,uint256)&#39;)) ^\n', '      bytes4(keccak256(&#39;approve(address,uint256)&#39;)) ^\n', '      bytes4(keccak256(&#39;takeOwnership(uint256)&#39;));\n', '\n', '  bytes4 internal constant INTERFACE_SIGNATURE_ERC721Metadata = // 0x2a786f11\n', '      bytes4(keccak256(&#39;name()&#39;)) ^\n', '      bytes4(keccak256(&#39;symbol()&#39;)) ^\n', '      bytes4(keccak256(&#39;deedUri(uint256)&#39;));\n', '\n', '\n', '  function FactbarDeed() public {}\n', '\n', '  // payable removed from fallback function following audit\n', '  function() public {}\n', '\n', '  modifier onlyExistingNames(uint256 _deedId) {\n', '    require(deedNameExists[deeds[_deedId].name]);\n', '    _;\n', '  }\n', '\n', '  modifier noExistingNames(bytes32 _name) {\n', '    require(!deedNameExists[_name]);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyAdmins() {\n', '    require(admins[msg.sender]);\n', '    _;\n', '  }\n', '\n', '\n', '   /* ERC721Metadata */\n', '\n', '  function name()\n', '  external pure returns (string) {\n', '    return "Factbar";\n', '  }\n', '\n', '  function symbol()\n', '  external pure returns (string) {\n', '    return "FTBR";\n', '  }\n', '\n', '  function supportsInterface(bytes4 _interfaceID)\n', '  external pure returns (bool) {\n', '    return (\n', '      _interfaceID == INTERFACE_SIGNATURE_ERC165\n', '      || _interfaceID == INTERFACE_SIGNATURE_ERC721\n', '      || _interfaceID == INTERFACE_SIGNATURE_ERC721Metadata\n', '    );\n', '  }\n', '\n', '  function deedUri(uint256 _deedId)\n', '  external view onlyExistingNames(_deedId) returns (string _uri) {\n', '    _uri = _strConcat(url, _bytes32ToString(deeds[_deedId].name));\n', '  }\n', '\n', '  function deedName(uint256 _deedId)\n', '  external view onlyExistingNames(_deedId) returns (string _name) {\n', '    _name = _bytes32ToString(deeds[_deedId].name);\n', '  }\n', '\n', '\n', '  // get pending payments to address, generated from appropriations\n', '  function getPendingPaymentAmount(address _account)\n', '  external view returns (uint256 _balance) {\n', '     uint256 payment = payments[_account];\n', '    _balance = payment;\n', '  }\n', '\n', '  // get Ids of all deeds  \n', '  function getDeedIds()\n', '  external view returns (uint256[]) {\n', '    return deedIds;\n', '  }\n', ' \n', '  /// Logic for pricing of deeds\n', '  function nextPriceOf (uint256 _deedId) public view returns (uint256 _nextPrice) {\n', '    return calculateNextPrice(priceOf(_deedId));\n', '  }\n', '\n', '  uint256 private increaseLimit1 = 0.02 ether;\n', '  uint256 private increaseLimit2 = 0.5 ether;\n', '  uint256 private increaseLimit3 = 2.0 ether;\n', '  uint256 private increaseLimit4 = 5.0 ether;\n', '\n', '  function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {\n', '    if (_price < increaseLimit1) {\n', '      return _price.mul(200).div(100);\n', '    } else if (_price < increaseLimit2) {\n', '      return _price.mul(135).div(100);\n', '    } else if (_price < increaseLimit3) {\n', '      return _price.mul(125).div(100);\n', '    } else if (_price < increaseLimit4) {\n', '      return _price.mul(117).div(100);\n', '    } else {\n', '      return _price.mul(115).div(100);\n', '    }\n', '  }\n', '\n', '  function calculateTransferFee (uint256 _price) public view returns (uint256 _devCut) {\n', '    if (_price < increaseLimit1) {\n', '      return _price.mul(5).div(100); // 5%\n', '    } else if (_price < increaseLimit2) {\n', '      return _price.mul(4).div(100); // 4%\n', '    } else if (_price < increaseLimit3) {\n', '      return _price.mul(3).div(100); // 3%\n', '    } else if (_price < increaseLimit4) {\n', '      return _price.mul(3).div(100); // 3%\n', '    } else {\n', '      return _price.mul(3).div(100); // 3%\n', '    }\n', '  }\n', '\n', '\n', '  // Forces the transfer of the deed to a new owner, \n', '  // if a higher price was paid. This functionality can be paused by the owner.\n', '  function appropriate(uint256 _deedId)\n', '  external whenNotPaused nonReentrant payable {\n', '\n', '    // Get current price of deed\n', '    uint256 price = priceOf(_deedId);\n', '\n', '     // The current owner is forbidden to appropriate himself.\n', '    address oldOwner = this.ownerOf(_deedId);\n', '    address newOwner = msg.sender;\n', '    require(oldOwner != newOwner);\n', '    \n', '    // price must be more than zero\n', '    require(priceOf(_deedId) > 0); \n', '    \n', '    // offered price must be more than or equal to the current price\n', '    require(msg.value >= price); \n', '\n', '    /// Any over-payment by the buyer will be sent back to him/her\n', '    uint256 excess = msg.value.sub(price);\n', '\n', '    // Clear any outstanding approvals and transfer the deed.*/\n', '    clearApprovalAndTransfer(oldOwner, newOwner, _deedId);\n', '    uint256 nextPrice = nextPriceOf(_deedId);\n', '    deeds[_deedId].price = nextPrice;\n', '    \n', '    // transfer fee is calculated\n', '    uint256 transferFee = calculateTransferFee(price);\n', '\n', '    /// previous owner gets entire new payment minus the transfer fee\n', '    uint256 oldOwnerPayment = price.sub(transferFee);\n', '\n', '    /// using Pullpayment for safety\n', '    asyncSend(factTeamOf(_deedId), transferFee);\n', '    asyncSend(oldOwner, oldOwnerPayment);\n', '\n', '    if (excess > 0) {\n', '       asyncSend(newOwner, excess);\n', '    }\n', '\n', '    emit Appropriation(_deedId, oldOwner, newOwner, price, nextPrice,\n', '    transferFee, excess, oldOwnerPayment);\n', '  }\n', '\n', '  // these events can be turned on to make up for Solidity&#39;s horrifying logging situation\n', '  // event logUint(address add, string text, uint256 value);\n', '  // event simpleLogUint(string text, uint256 value);\n', '\n', '  // Send a PullPayment.\n', '  function pay(uint256 _deedId)\n', '  external nonReentrant payable {\n', '    address factTeam = factTeamOf(_deedId);\n', '    asyncSend(factTeam, msg.value);\n', '    emit Payment(_deedId, msg.sender, factTeam, msg.value);\n', '  }\n', '\n', '  // The owner can only withdraw what has not been assigned to the transfer fee address as PullPayments.\n', '  function withdraw()\n', '  external nonReentrant {\n', '    withdrawPayments();\n', '    if (msg.sender == owner) {\n', '      // The contract&#39;s balance MUST stay backing the outstanding withdrawals.\n', '      //  Only the surplus not needed for any backing can be withdrawn by the owner.\n', '      uint256 surplus = address(this).balance.sub(totalPayments);\n', '      if (surplus > 0) {\n', '        owner.transfer(surplus);\n', '      }\n', '    }\n', '  }\n', '\n', '  /* Owner Functions */\n', '\n', '  // The contract owner creates deeds. Newly created deeds are\n', '  // initialised with a name and a transfer fee address\n', '  // only Admins can create deeds\n', '  function create(bytes32 _name, address _factTeam)\n', '  public onlyAdmins noExistingNames(_name) {\n', '    deedNameExists[_name] = true;\n', '    uint256 deedId = deedIds.length;\n', '    deedIds.push(deedId);\n', '    super._mint(owner, deedId);\n', '    deeds[deedId] = Factbar({\n', '      name: _name,\n', '      factTeam: _factTeam,\n', '      price: creationPrice,\n', '      created: now\n', '      // deleted: 0\n', '    });\n', '    emit Creation(deedId, _name, owner);\n', '  }\n', '\n', '  // the owner can add and remove admins as per his/her whim\n', '\n', '  function addAdmin(address _admin)  \n', '  public onlyOwner{\n', '    admins[_admin] = true;\n', '  }\n', '\n', '  function removeAdmin (address _admin)  \n', '  public onlyOwner{\n', '    delete admins[_admin];\n', '  }\n', '\n', '  // the owner can set the creation price \n', '\n', '  function setCreationPrice(uint256 _price)\n', '  public onlyOwner {\n', '    creationPrice = _price;\n', '  }\n', '\n', '  function setUrl(string _url)\n', '  public onlyOwner {\n', '    url = _url;\n', '  }\n', '\n', '  /* Other publicly available functions */\n', '\n', '  // Returns the last paid price for this deed.\n', '  function priceOf(uint256 _deedId)\n', '  public view returns (uint256 _price) {\n', '    _price = deeds[_deedId].price;\n', '  }\n', '\n', '  // Returns the current transfer fee address\n', '  function factTeamOf(uint256 _deedId)\n', '  public view returns (address _factTeam) {\n', '    _factTeam = deeds[_deedId].factTeam;\n', '  }\n', '\n', '\n', '  /* Private helper functions */        \n', '\n', '  function _bytes32ToString(bytes32 _bytes32)\n', '  private pure returns (string) {\n', '    bytes memory bytesString = new bytes(32);\n', '    uint charCount = 0;\n', '    for (uint j = 0; j < 32; j++) {\n', '      byte char = byte(bytes32(uint(_bytes32) * 2 ** (8 * j)));\n', '      if (char != 0) {\n', '        bytesString[charCount] = char;\n', '        charCount++;\n', '      }\n', '    }\n', '    bytes memory bytesStringTrimmed = new bytes(charCount);\n', '    for (j = 0; j < charCount; j++) {\n', '      bytesStringTrimmed[j] = bytesString[j];\n', '    }\n', '\n', '    return string(bytesStringTrimmed);\n', '  }\n', '\n', '  function _strConcat(string _a, string _b)\n', '  private pure returns (string) {\n', '    bytes memory _ba = bytes(_a);\n', '    bytes memory _bb = bytes(_b);\n', '    string memory ab = new string(_ba.length + _bb.length);\n', '    bytes memory bab = bytes(ab);\n', '    uint k = 0;\n', '    for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\n', '    for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\n', '    return string(bab);\n', '  }\n', '\n', '}\n', '\n', '// The MIT License (MIT)\n', '// Copyright (c) 2018 Factbar\n', '// Copyright (c) 2016 Smart Contract Solutions, Inc.\n', '\n', '// Permission is hereby granted, free of charge, \n', '// to any person obtaining a copy of this software and \n', '// associated documentation files (the "Software"), to \n', '// deal in the Software without restriction, including \n', '// without limitation the rights to use, copy, modify, \n', '// merge, publish, distribute, sublicense, and/or sell \n', '// copies of the Software, and to permit persons to whom \n', '// the Software is furnished to do so, \n', '// subject to the following conditions:\n', '\n', '// The above copyright notice and this permission notice \n', '// shall be included in all copies or substantial portions of the Software.\n', '\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, \n', '// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES \n', '// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n', '// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR \n', '// ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n', '// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n', '// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.']
['pragma solidity ^0.4.13;\n', '\n', 'interface ERC721Metadata {\n', '\n', '    /// @dev ERC-165 (draft) interface signature for ERC721\n', '    // bytes4 internal constant INTERFACE_SIGNATURE_ERC721Metadata = // 0x2a786f11\n', "    //     bytes4(keccak256('name()')) ^\n", "    //     bytes4(keccak256('symbol()')) ^\n", "    //     bytes4(keccak256('deedUri(uint256)'));\n", '\n', '    /// @notice A descriptive name for a collection of deeds managed by this\n', '    ///  contract\n', '    /// @dev Wallets and exchanges MAY display this to the end user.\n', '    function name() external pure returns (string _name);\n', '\n', '    /// @notice An abbreviated name for deeds managed by this contract\n', '    /// @dev Wallets and exchanges MAY display this to the end user.\n', '    function symbol() external pure returns (string _symbol);\n', '\n', '    /// @notice A distinct name for a deed managed by this contract\n', '    /// @dev Wallets and exchanges MAY display this to the end user.\n', '    function deedName(uint256 _deedId) external pure returns (string _deedName);\n', '\n', '    /// @notice A distinct URI (RFC 3986) for a given token.\n', '    /// @dev If:\n', '    ///  * The URI is a URL\n', '    ///  * The URL is accessible\n', '    ///  * The URL points to a valid JSON file format (ECMA-404 2nd ed.)\n', '    ///  * The JSON base element is an object\n', '    ///  then these names of the base element SHALL have special meaning:\n', '    ///  * "name": A string identifying the item to which `_deedId` grants\n', '    ///    ownership\n', '    ///  * "description": A string detailing the item to which `_deedId` grants\n', '    ///    ownership\n', '    ///  * "image": A URI pointing to a file of image/* mime type representing\n', '    ///    the item to which `_deedId` grants ownership\n', '    ///  Wallets and exchanges MAY display this to the end user.\n', '    ///  Consider making any images at a width between 320 and 1080 pixels and\n', '    ///  aspect ratio between 1.91:1 and 4:5 inclusive.\n', '    function deedUri(uint256 _deedId) external view returns (string _deedUri);\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancy_lock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancy_lock);\n', '    reentrancy_lock = true;\n', '    _;\n', '    reentrancy_lock = false;\n', '  }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', 'interface ERC721 {\n', '\n', '    // COMPLIANCE WITH ERC-165 (DRAFT) /////////////////////////////////////////\n', '\n', '    /// @dev ERC-165 (draft) interface signature for itself\n', '    // bytes4 internal constant INTERFACE_SIGNATURE_ERC165 = // 0x01ffc9a7\n', "    //     bytes4(keccak256('supportsInterface(bytes4)'));\n", '\n', '    /// @dev ERC-165 (draft) interface signature for ERC721\n', '    // bytes4 internal constant INTERFACE_SIGNATURE_ERC721 = // 0xda671b9b\n', "    //     bytes4(keccak256('ownerOf(uint256)')) ^\n", "    //     bytes4(keccak256('countOfDeeds()')) ^\n", "    //     bytes4(keccak256('countOfDeedsByOwner(address)')) ^\n", "    //     bytes4(keccak256('deedOfOwnerByIndex(address,uint256)')) ^\n", "    //     bytes4(keccak256('approve(address,uint256)')) ^\n", "    //     bytes4(keccak256('takeOwnership(uint256)'));\n", '\n', '    /// @notice Query a contract to see if it supports a certain interface\n', '    /// @dev Returns `true` the interface is supported and `false` otherwise,\n', '    ///  returns `true` for INTERFACE_SIGNATURE_ERC165 and\n', '    ///  INTERFACE_SIGNATURE_ERC721, see ERC-165 for other interface signatures.\n', '    function supportsInterface(bytes4 _interfaceID) external pure returns (bool);\n', '\n', '    // PUBLIC QUERY FUNCTIONS //////////////////////////////////////////////////\n', '\n', '    /// @notice Find the owner of a deed\n', '    /// @param _deedId The identifier for a deed we are inspecting\n', '    /// @dev Deeds assigned to zero address are considered invalid, and\n', '    ///  queries about them do throw.\n', '    /// @return The non-zero address of the owner of deed `_deedId`, or `throw`\n', '    ///  if deed `_deedId` is not tracked by this contract\n', '    function ownerOf(uint256 _deedId) external view returns (address _owner);\n', '\n', '    /// @notice Count deeds tracked by this contract\n', '    /// @return A count of valid deeds tracked by this contract, where each one of\n', '    ///  them has an assigned and queryable owner not equal to the zero address\n', '    function countOfDeeds() external view returns (uint256 _count);\n', '\n', '    /// @notice Count all deeds assigned to an owner\n', '    /// @dev Throws if `_owner` is the zero address, representing invalid deeds.\n', '    /// @param _owner An address where we are interested in deeds owned by them\n', '    /// @return The number of deeds owned by `_owner`, possibly zero\n', '    function countOfDeedsByOwner(address _owner) external view returns (uint256 _count);\n', '\n', '    /// @notice Enumerate deeds assigned to an owner\n', '    /// @dev Throws if `_index` >= `countOfDeedsByOwner(_owner)` or if\n', '    ///  `_owner` is the zero address, representing invalid deeds.\n', '    /// @param _owner An address where we are interested in deeds owned by them\n', '    /// @param _index A counter less than `countOfDeedsByOwner(_owner)`\n', '    /// @return The identifier for the `_index`th deed assigned to `_owner`,\n', '    ///   (sort order not specified)\n', '    function deedOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _deedId);\n', '\n', '    // TRANSFER MECHANISM //////////////////////////////////////////////////////\n', '\n', '    /// @dev This event emits when ownership of any deed changes by any\n', '    ///  mechanism. This event emits when deeds are created (`from` == 0) and\n', '    ///  destroyed (`to` == 0). Exception: during contract creation, any\n', '    ///  transfers may occur without emitting `Transfer`. At the time of any transfer,\n', '    ///  the "approved taker" is implicitly reset to the zero address.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _deedId);\n', '\n', '    /// @dev The Approve event emits to log the "approved taker" for a deed -- whether\n', '    ///  set for the first time, reaffirmed by setting the same value, or setting to\n', '    ///  a new value. The "approved taker" is the zero address if nobody can take the\n', '    ///  deed now or it is an address if that address can call `takeOwnership` to attempt\n', '    ///  taking the deed. Any change to the "approved taker" for a deed SHALL cause\n', '    ///  Approve to emit. However, an exception, the Approve event will not emit when\n', '    ///  Transfer emits, this is because Transfer implicitly denotes the "approved taker"\n', '    ///  is reset to the zero address.\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _deedId);\n', '\n', '    /// @notice Set the "approved taker" for your deed, or revoke approval by\n', '    ///  setting the zero address. You may `approve` any number of times while\n', '    ///  the deed is assigned to you, only the most recent approval matters. Emits\n', '    ///  an Approval event.\n', '    /// @dev Throws if `msg.sender` does not own deed `_deedId` or if `_to` ==\n', '    ///  `msg.sender` or if `_deedId` is not a valid deed.\n', '    /// @param _deedId The deed for which you are granting approval\n', '    function approve(address _to, uint256 _deedId) external payable;\n', '\n', '    /// @notice Become owner of a deed for which you are currently approved\n', '    /// @dev Throws if `msg.sender` is not approved to become the owner of\n', '    ///  `deedId` or if `msg.sender` currently owns `_deedId` or if `_deedId is not a\n', '    ///  valid deed.\n', '    /// @param _deedId The deed that is being transferred\n', '    function takeOwnership(uint256 _deedId) external payable;\n', '}\n', '\n', 'contract ERC721Deed is ERC721 {\n', '  using SafeMath for uint256;\n', '\n', '  // Total amount of deeds\n', '  uint256 private totalDeeds;\n', '\n', '  // Mapping from deed ID to owner\n', '  mapping (uint256 => address) private deedOwner;\n', '\n', '  // Mapping from deed ID to approved address\n', '  mapping (uint256 => address) private deedApprovedFor;\n', '\n', '  // Mapping from owner to list of owned deed IDs\n', '  mapping (address => uint256[]) private ownedDeeds;\n', '\n', '  // Mapping from deed ID to index of the owner deeds list\n', '  mapping(uint256 => uint256) private ownedDeedsIndex;\n', '\n', '  /**\n', '  * @dev Guarantees msg.sender is owner of the given deed\n', '  * @param _deedId uint256 ID of the deed to validate its ownership belongs to msg.sender\n', '  */\n', '  modifier onlyOwnerOf(uint256 _deedId) {\n', '    require(deedOwner[_deedId] == msg.sender);\n', '    _;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the owner of the specified deed ID\n', '  * @param _deedId uint256 ID of the deed to query the owner of\n', '  * @return owner address currently marked as the owner of the given deed ID\n', '  */\n', '  function ownerOf(uint256 _deedId)\n', '  external view returns (address _owner) {\n', '    require(deedOwner[_deedId] != address(0));\n', '    _owner = deedOwner[_deedId];\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the total amount of deeds stored by the contract\n', '  * @return uint256 representing the total amount of deeds\n', '  */\n', '  function countOfDeeds()\n', '  external view returns (uint256) {\n', '    return totalDeeds;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the number of deeds of the specified address\n', '  * @param _owner address to query the number of deeds\n', '  * @return uint256 representing the number of deeds owned by the passed address\n', '  */\n', '  function countOfDeedsByOwner(address _owner)\n', '  external view returns (uint256 _count) {\n', '    require(_owner != address(0));\n', '    _count = ownedDeeds[_owner].length;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the deed ID of the specified address at the specified index\n', "  * @param _owner address for the deed's owner\n", '  * @param _index uint256 for the n-th deed in the list of deeds owned by this owner\n', '  * @return uint256 representing the ID of the deed\n', '  */\n', '  function deedOfOwnerByIndex(address _owner, uint256 _index)\n', '  external view returns (uint256 _deedId) {\n', '    require(_owner != address(0));\n', '    require(_index < ownedDeeds[_owner].length);\n', '    _deedId = ownedDeeds[_owner][_index];\n', '  }\n', '\n', '  /**\n', '  * @dev Gets all deed IDs of the specified address\n', "  * @param _owner address for the deed's owner\n", '  * @return uint256[] representing all deed IDs owned by the passed address\n', '  */\n', '  function deedsOf(address _owner)\n', '  external view returns (uint256[] _ownedDeedIds) {\n', '    require(_owner != address(0));\n', '    _ownedDeedIds = ownedDeeds[_owner];\n', '  }\n', '\n', '  /**\n', '  * @dev Approves another address to claim for the ownership of the given deed ID\n', '  * @param _to address to be approved for the given deed ID\n', '  * @param _deedId uint256 ID of the deed to be approved\n', '  */\n', '  function approve(address _to, uint256 _deedId)\n', '  external onlyOwnerOf(_deedId) payable {\n', '    require(msg.value == 0);\n', '    require(_to != msg.sender);\n', '    if(_to != address(0) || approvedFor(_deedId) != address(0)) {\n', '      emit Approval(msg.sender, _to, _deedId);\n', '    }\n', '    deedApprovedFor[_deedId] = _to;\n', '  }\n', '\n', '  /**\n', '  * @dev Claims the ownership of a given deed ID\n', '  * @param _deedId uint256 ID of the deed being claimed by the msg.sender\n', '  */\n', '  function takeOwnership(uint256 _deedId)\n', '  external payable {\n', '    require(approvedFor(_deedId) == msg.sender);\n', '    clearApprovalAndTransfer(deedOwner[_deedId], msg.sender, _deedId);\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the approved address to take ownership of a given deed ID\n', '   * @param _deedId uint256 ID of the deed to query the approval of\n', '   * @return address currently approved to take ownership of the given deed ID\n', '   */\n', '  function approvedFor(uint256 _deedId)\n', '  public view returns (address) {\n', '    return deedApprovedFor[_deedId];\n', '  }\n', '\n', '  /**\n', '  * @dev Transfers the ownership of a given deed ID to another address\n', '  * @param _to address to receive the ownership of the given deed ID\n', '  * @param _deedId uint256 ID of the deed to be transferred\n', '  */\n', '  function transfer(address _to, uint256 _deedId)\n', '  public onlyOwnerOf(_deedId) {\n', '    clearApprovalAndTransfer(msg.sender, _to, _deedId);\n', '  }\n', '\n', '  /**\n', '  * @dev Mint deed function\n', '  * @param _to The address that will own the minted deed\n', '  */\n', '  function _mint(address _to, uint256 _deedId)\n', '  internal {\n', '    require(_to != address(0));\n', '    addDeed(_to, _deedId);\n', '    emit Transfer(0x0, _to, _deedId);\n', '  }\n', '\n', '  /**\n', '  * @dev Burns a specific deed\n', '  * @param _deedId uint256 ID of the deed being burned by the msg.sender\n', '  * Removed because Factbars cannot be destroyed\n', '  */\n', '  // function _burn(uint256 _deedId) onlyOwnerOf(_deedId)\n', '  // internal {\n', '  //   if (approvedFor(_deedId) != 0) {\n', '  //     clearApproval(msg.sender, _deedId);\n', '  //   }\n', '  //   removeDeed(msg.sender, _deedId);\n', '  //   emit Transfer(msg.sender, 0x0, _deedId);\n', '  // }\n', '\n', '  /**\n', '  * @dev Internal function to clear current approval and transfer the ownership of a given deed ID\n', '  * @param _from address which you want to send deeds from\n', '  * @param _to address which you want to transfer the deed to\n', '  * @param _deedId uint256 ID of the deed to be transferred\n', '  */\n', '  function clearApprovalAndTransfer(address _from, address _to, uint256 _deedId)\n', '  internal {\n', '    require(_to != address(0));\n', '    require(_to != _from);\n', '    require(deedOwner[_deedId] == _from);\n', '\n', '    clearApproval(_from, _deedId);\n', '    removeDeed(_from, _deedId);\n', '    addDeed(_to, _deedId);\n', '    emit Transfer(_from, _to, _deedId);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to clear current approval of a given deed ID\n', '  * @param _deedId uint256 ID of the deed to be transferred\n', '  */\n', '  function clearApproval(address _owner, uint256 _deedId)\n', '  private {\n', '    require(deedOwner[_deedId] == _owner);\n', '    deedApprovedFor[_deedId] = 0;\n', '    emit Approval(_owner, 0, _deedId);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to add a deed ID to the list of a given address\n', '  * @param _to address representing the new owner of the given deed ID\n', '  * @param _deedId uint256 ID of the deed to be added to the deeds list of the given address\n', '  */\n', '  function addDeed(address _to, uint256 _deedId)\n', '  private {\n', '    require(deedOwner[_deedId] == address(0));\n', '    deedOwner[_deedId] = _to;\n', '    uint256 length = ownedDeeds[_to].length;\n', '    ownedDeeds[_to].push(_deedId);\n', '    ownedDeedsIndex[_deedId] = length;\n', '    totalDeeds = totalDeeds.add(1);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to remove a deed ID from the list of a given address\n', '  * @param _from address representing the previous owner of the given deed ID\n', '  * @param _deedId uint256 ID of the deed to be removed from the deeds list of the given address\n', '  */\n', '  function removeDeed(address _from, uint256 _deedId)\n', '  private {\n', '    require(deedOwner[_deedId] == _from);\n', '\n', '    uint256 deedIndex = ownedDeedsIndex[_deedId];\n', '    uint256 lastDeedIndex = ownedDeeds[_from].length.sub(1);\n', '    uint256 lastDeed = ownedDeeds[_from][lastDeedIndex];\n', '\n', '    deedOwner[_deedId] = 0;\n', '    ownedDeeds[_from][deedIndex] = lastDeed;\n', '    ownedDeeds[_from][lastDeedIndex] = 0;\n', '    // Note that this will handle single-element arrays. In that case, both deedIndex and lastDeedIndex are going to\n', '    // be zero. Then we can make sure that we will remove _deedId from the ownedDeeds list since we are first swapping\n', '    // the lastDeed to the first position, and then dropping the element placed in the last position of the list\n', '\n', '    ownedDeeds[_from].length--;\n', '    ownedDeedsIndex[_deedId] = 0;\n', '    ownedDeedsIndex[lastDeed] = deedIndex;\n', '    totalDeeds = totalDeeds.sub(1);\n', '  }\n', '}\n', '\n', 'contract PullPayment {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) public payments;\n', '  uint256 public totalPayments;\n', '\n', '  /**\n', '  * @dev Withdraw accumulated balance, called by payee.\n', '  */\n', '  function withdrawPayments() public {\n', '    address payee = msg.sender;\n', '    uint256 payment = payments[payee];\n', '\n', '    require(payment != 0);\n', '    require(address(this).balance >= payment);\n', '\n', '    totalPayments = totalPayments.sub(payment);\n', '    payments[payee] = 0;\n', '\n', '    payee.transfer(payment);\n', '  }\n', '\n', '  /**\n', '  * @dev Called by the payer to store the sent amount as credit to be pulled.\n', '  * @param dest The destination address of the funds.\n', '  * @param amount The amount to transfer.\n', '  */\n', '  function asyncSend(address dest, uint256 amount) internal {\n', '    payments[dest] = payments[dest].add(amount);\n', '    totalPayments = totalPayments.add(amount);\n', '  }\n', '}\n', '\n', 'contract FactbarDeed is ERC721Deed, Pausable, PullPayment, ReentrancyGuard {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  /* Events */\n', '  // When a deed is created by the contract owner.\n', '  event Creation(uint256 indexed id, bytes32 indexed name, address factTeam);\n', '\n', '  // When a deed is appropriated, the ownership of the deed is transferred to the new owner.\n', '  // The old owner is reimbursed, and he gets the new price minus the transfer fee.\n', '  event Appropriation(uint256 indexed id, address indexed oldOwner, \n', '  address indexed newOwner, uint256 oldPrice, uint256 newPrice,\n', '  uint256 transferFeeAmount, uint256 excess,  uint256 oldOwnerPaymentAmount );\n', '\n', "  // Payments to the deed's fee address via PullPayment are also supported by this contract.\n", '  event Payment(uint256 indexed id, address indexed sender, address \n', '  indexed factTeam, uint256 amount);\n', '\n', '  // Factbars, like facts, cannot be destroyed. So we have removed \n', '  // all the deletion and desctruction features\n', '\n', '  // The data structure of the Factbar deed\n', '  \n', '  struct Factbar {\n', '    bytes32 name;\n', '    address factTeam;\n', '    uint256 price;\n', '    uint256 created;\n', '  }\n', '\n', '  // Mapping from _deedId to Factbar\n', '  mapping (uint256 => Factbar) private deeds;\n', '\n', '  // Mapping from deed name to boolean indicating if the name is already taken\n', '  mapping (bytes32 => bool) private deedNameExists;\n', '\n', '  // Needed to make all deeds discoverable. The length of this array also serves as our deed ID.\n', '  uint256[] private deedIds;\n', '\n', '  // These are the admins who have the power to create deeds.\n', '  mapping (address => bool) private admins;\n', '\n', '  /* Variables in control of owner */\n', '\n', '  // The contract owner can change the initial price of deeds at Creation.\n', '  uint256 private creationPrice = 0.0005 ether; \n', '\n', '  // The contract owner can change the base URL, in case it becomes necessary. It is needed for Metadata.\n', '  string public url = "https://fact-bar.org/facts/";\n', '\n', '  // ERC-165 Metadata\n', '  bytes4 internal constant INTERFACE_SIGNATURE_ERC165 = // 0x01ffc9a7\n', "      bytes4(keccak256('supportsInterface(bytes4)'));\n", '\n', '  bytes4 internal constant INTERFACE_SIGNATURE_ERC721 = // 0xda671b9b\n', "      bytes4(keccak256('ownerOf(uint256)')) ^\n", "      bytes4(keccak256('countOfDeeds()')) ^\n", "      bytes4(keccak256('countOfDeedsByOwner(address)')) ^\n", "      bytes4(keccak256('deedOfOwnerByIndex(address,uint256)')) ^\n", "      bytes4(keccak256('approve(address,uint256)')) ^\n", "      bytes4(keccak256('takeOwnership(uint256)'));\n", '\n', '  bytes4 internal constant INTERFACE_SIGNATURE_ERC721Metadata = // 0x2a786f11\n', "      bytes4(keccak256('name()')) ^\n", "      bytes4(keccak256('symbol()')) ^\n", "      bytes4(keccak256('deedUri(uint256)'));\n", '\n', '\n', '  function FactbarDeed() public {}\n', '\n', '  // payable removed from fallback function following audit\n', '  function() public {}\n', '\n', '  modifier onlyExistingNames(uint256 _deedId) {\n', '    require(deedNameExists[deeds[_deedId].name]);\n', '    _;\n', '  }\n', '\n', '  modifier noExistingNames(bytes32 _name) {\n', '    require(!deedNameExists[_name]);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyAdmins() {\n', '    require(admins[msg.sender]);\n', '    _;\n', '  }\n', '\n', '\n', '   /* ERC721Metadata */\n', '\n', '  function name()\n', '  external pure returns (string) {\n', '    return "Factbar";\n', '  }\n', '\n', '  function symbol()\n', '  external pure returns (string) {\n', '    return "FTBR";\n', '  }\n', '\n', '  function supportsInterface(bytes4 _interfaceID)\n', '  external pure returns (bool) {\n', '    return (\n', '      _interfaceID == INTERFACE_SIGNATURE_ERC165\n', '      || _interfaceID == INTERFACE_SIGNATURE_ERC721\n', '      || _interfaceID == INTERFACE_SIGNATURE_ERC721Metadata\n', '    );\n', '  }\n', '\n', '  function deedUri(uint256 _deedId)\n', '  external view onlyExistingNames(_deedId) returns (string _uri) {\n', '    _uri = _strConcat(url, _bytes32ToString(deeds[_deedId].name));\n', '  }\n', '\n', '  function deedName(uint256 _deedId)\n', '  external view onlyExistingNames(_deedId) returns (string _name) {\n', '    _name = _bytes32ToString(deeds[_deedId].name);\n', '  }\n', '\n', '\n', '  // get pending payments to address, generated from appropriations\n', '  function getPendingPaymentAmount(address _account)\n', '  external view returns (uint256 _balance) {\n', '     uint256 payment = payments[_account];\n', '    _balance = payment;\n', '  }\n', '\n', '  // get Ids of all deeds  \n', '  function getDeedIds()\n', '  external view returns (uint256[]) {\n', '    return deedIds;\n', '  }\n', ' \n', '  /// Logic for pricing of deeds\n', '  function nextPriceOf (uint256 _deedId) public view returns (uint256 _nextPrice) {\n', '    return calculateNextPrice(priceOf(_deedId));\n', '  }\n', '\n', '  uint256 private increaseLimit1 = 0.02 ether;\n', '  uint256 private increaseLimit2 = 0.5 ether;\n', '  uint256 private increaseLimit3 = 2.0 ether;\n', '  uint256 private increaseLimit4 = 5.0 ether;\n', '\n', '  function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {\n', '    if (_price < increaseLimit1) {\n', '      return _price.mul(200).div(100);\n', '    } else if (_price < increaseLimit2) {\n', '      return _price.mul(135).div(100);\n', '    } else if (_price < increaseLimit3) {\n', '      return _price.mul(125).div(100);\n', '    } else if (_price < increaseLimit4) {\n', '      return _price.mul(117).div(100);\n', '    } else {\n', '      return _price.mul(115).div(100);\n', '    }\n', '  }\n', '\n', '  function calculateTransferFee (uint256 _price) public view returns (uint256 _devCut) {\n', '    if (_price < increaseLimit1) {\n', '      return _price.mul(5).div(100); // 5%\n', '    } else if (_price < increaseLimit2) {\n', '      return _price.mul(4).div(100); // 4%\n', '    } else if (_price < increaseLimit3) {\n', '      return _price.mul(3).div(100); // 3%\n', '    } else if (_price < increaseLimit4) {\n', '      return _price.mul(3).div(100); // 3%\n', '    } else {\n', '      return _price.mul(3).div(100); // 3%\n', '    }\n', '  }\n', '\n', '\n', '  // Forces the transfer of the deed to a new owner, \n', '  // if a higher price was paid. This functionality can be paused by the owner.\n', '  function appropriate(uint256 _deedId)\n', '  external whenNotPaused nonReentrant payable {\n', '\n', '    // Get current price of deed\n', '    uint256 price = priceOf(_deedId);\n', '\n', '     // The current owner is forbidden to appropriate himself.\n', '    address oldOwner = this.ownerOf(_deedId);\n', '    address newOwner = msg.sender;\n', '    require(oldOwner != newOwner);\n', '    \n', '    // price must be more than zero\n', '    require(priceOf(_deedId) > 0); \n', '    \n', '    // offered price must be more than or equal to the current price\n', '    require(msg.value >= price); \n', '\n', '    /// Any over-payment by the buyer will be sent back to him/her\n', '    uint256 excess = msg.value.sub(price);\n', '\n', '    // Clear any outstanding approvals and transfer the deed.*/\n', '    clearApprovalAndTransfer(oldOwner, newOwner, _deedId);\n', '    uint256 nextPrice = nextPriceOf(_deedId);\n', '    deeds[_deedId].price = nextPrice;\n', '    \n', '    // transfer fee is calculated\n', '    uint256 transferFee = calculateTransferFee(price);\n', '\n', '    /// previous owner gets entire new payment minus the transfer fee\n', '    uint256 oldOwnerPayment = price.sub(transferFee);\n', '\n', '    /// using Pullpayment for safety\n', '    asyncSend(factTeamOf(_deedId), transferFee);\n', '    asyncSend(oldOwner, oldOwnerPayment);\n', '\n', '    if (excess > 0) {\n', '       asyncSend(newOwner, excess);\n', '    }\n', '\n', '    emit Appropriation(_deedId, oldOwner, newOwner, price, nextPrice,\n', '    transferFee, excess, oldOwnerPayment);\n', '  }\n', '\n', "  // these events can be turned on to make up for Solidity's horrifying logging situation\n", '  // event logUint(address add, string text, uint256 value);\n', '  // event simpleLogUint(string text, uint256 value);\n', '\n', '  // Send a PullPayment.\n', '  function pay(uint256 _deedId)\n', '  external nonReentrant payable {\n', '    address factTeam = factTeamOf(_deedId);\n', '    asyncSend(factTeam, msg.value);\n', '    emit Payment(_deedId, msg.sender, factTeam, msg.value);\n', '  }\n', '\n', '  // The owner can only withdraw what has not been assigned to the transfer fee address as PullPayments.\n', '  function withdraw()\n', '  external nonReentrant {\n', '    withdrawPayments();\n', '    if (msg.sender == owner) {\n', "      // The contract's balance MUST stay backing the outstanding withdrawals.\n", '      //  Only the surplus not needed for any backing can be withdrawn by the owner.\n', '      uint256 surplus = address(this).balance.sub(totalPayments);\n', '      if (surplus > 0) {\n', '        owner.transfer(surplus);\n', '      }\n', '    }\n', '  }\n', '\n', '  /* Owner Functions */\n', '\n', '  // The contract owner creates deeds. Newly created deeds are\n', '  // initialised with a name and a transfer fee address\n', '  // only Admins can create deeds\n', '  function create(bytes32 _name, address _factTeam)\n', '  public onlyAdmins noExistingNames(_name) {\n', '    deedNameExists[_name] = true;\n', '    uint256 deedId = deedIds.length;\n', '    deedIds.push(deedId);\n', '    super._mint(owner, deedId);\n', '    deeds[deedId] = Factbar({\n', '      name: _name,\n', '      factTeam: _factTeam,\n', '      price: creationPrice,\n', '      created: now\n', '      // deleted: 0\n', '    });\n', '    emit Creation(deedId, _name, owner);\n', '  }\n', '\n', '  // the owner can add and remove admins as per his/her whim\n', '\n', '  function addAdmin(address _admin)  \n', '  public onlyOwner{\n', '    admins[_admin] = true;\n', '  }\n', '\n', '  function removeAdmin (address _admin)  \n', '  public onlyOwner{\n', '    delete admins[_admin];\n', '  }\n', '\n', '  // the owner can set the creation price \n', '\n', '  function setCreationPrice(uint256 _price)\n', '  public onlyOwner {\n', '    creationPrice = _price;\n', '  }\n', '\n', '  function setUrl(string _url)\n', '  public onlyOwner {\n', '    url = _url;\n', '  }\n', '\n', '  /* Other publicly available functions */\n', '\n', '  // Returns the last paid price for this deed.\n', '  function priceOf(uint256 _deedId)\n', '  public view returns (uint256 _price) {\n', '    _price = deeds[_deedId].price;\n', '  }\n', '\n', '  // Returns the current transfer fee address\n', '  function factTeamOf(uint256 _deedId)\n', '  public view returns (address _factTeam) {\n', '    _factTeam = deeds[_deedId].factTeam;\n', '  }\n', '\n', '\n', '  /* Private helper functions */        \n', '\n', '  function _bytes32ToString(bytes32 _bytes32)\n', '  private pure returns (string) {\n', '    bytes memory bytesString = new bytes(32);\n', '    uint charCount = 0;\n', '    for (uint j = 0; j < 32; j++) {\n', '      byte char = byte(bytes32(uint(_bytes32) * 2 ** (8 * j)));\n', '      if (char != 0) {\n', '        bytesString[charCount] = char;\n', '        charCount++;\n', '      }\n', '    }\n', '    bytes memory bytesStringTrimmed = new bytes(charCount);\n', '    for (j = 0; j < charCount; j++) {\n', '      bytesStringTrimmed[j] = bytesString[j];\n', '    }\n', '\n', '    return string(bytesStringTrimmed);\n', '  }\n', '\n', '  function _strConcat(string _a, string _b)\n', '  private pure returns (string) {\n', '    bytes memory _ba = bytes(_a);\n', '    bytes memory _bb = bytes(_b);\n', '    string memory ab = new string(_ba.length + _bb.length);\n', '    bytes memory bab = bytes(ab);\n', '    uint k = 0;\n', '    for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\n', '    for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\n', '    return string(bab);\n', '  }\n', '\n', '}\n', '\n', '// The MIT License (MIT)\n', '// Copyright (c) 2018 Factbar\n', '// Copyright (c) 2016 Smart Contract Solutions, Inc.\n', '\n', '// Permission is hereby granted, free of charge, \n', '// to any person obtaining a copy of this software and \n', '// associated documentation files (the "Software"), to \n', '// deal in the Software without restriction, including \n', '// without limitation the rights to use, copy, modify, \n', '// merge, publish, distribute, sublicense, and/or sell \n', '// copies of the Software, and to permit persons to whom \n', '// the Software is furnished to do so, \n', '// subject to the following conditions:\n', '\n', '// The above copyright notice and this permission notice \n', '// shall be included in all copies or substantial portions of the Software.\n', '\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, \n', '// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES \n', '// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n', '// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR \n', '// ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n', '// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n', '// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.']
