['contract META {\n', '\n', '    string public name = "Dunaton Metacurrency 3.0";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "META";\n', '\n', '    address public _owner;\n', '    address public dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c;\n', '    uint256 public _tokePerEth = 359;\n', '\n', '    // testing\n', '    uint256 public weiAmount;\n', '    uint256 incomingValueAsEth;\n', '    uint256 _calcToken;\n', '    uint256 _tokePerWei;\n', '\n', '    uint256 public _totalSupply = 21000000 * 1 ether;\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    // Storage\n', '    mapping (address => uint256) public balances;\n', '\n', '    function META() {\n', '        _owner = msg.sender;\n', '        balances[_owner] = 5800000 * 1 ether;    // premine 5.8m tokens to _owner\n', '        Transfer(this, _owner, (5800000 * 1 ether));\n', '        _totalSupply = sub(_totalSupply,balances[_owner]);\n', '    }\n', '\n', '    function transfer(address _to, uint _value, bytes _data) public {\n', '        // sender must have enough tokens to transfer\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        uint codeLength;\n', '\n', '        assembly {\n', '        // Retrieve the size of the code on target address, this needs assembly .\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '        balances[_to] = add(balances[_to], _value);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public {\n', '        // sender must have enough tokens to transfer\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        uint codeLength;\n', '\n', '        assembly {\n', '        // Retrieve the size of the code on target address, this needs assembly .\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '        balances[_to] = add(balances[_to], _value);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    // fallback to receive ETH into contract and send tokens back based on current exchange rate\n', '    function () payable public {\n', '        require(msg.value > 0);\n', '\n', '        // we need to calculate tokens per wei\n', '//        _tokePerWei = div(_tokePerEth, 1 ether);\n', '        _tokePerWei = _tokePerEth;\n', '        _calcToken = mul(msg.value,_tokePerWei); // value of payment in tokens\n', '\n', '        require(_totalSupply >= _calcToken);\n', '        _totalSupply = sub(_totalSupply, _calcToken);\n', '\n', '        balances[msg.sender] = add(balances[msg.sender], _calcToken);\n', '\n', '        Transfer(this, msg.sender, _calcToken);\n', '    }\n', '\n', '    function changePayRate(uint256 _newRate) public {\n', '        require((msg.sender == _owner) && (_newRate >= 0));\n', '//        _tokePerEth = _newRate * 1 ether;\n', '        _tokePerEth = _newRate;\n', '    }\n', '\n', '    function safeWithdrawal(address _receiver, uint256 _value) public {\n', '        require((msg.sender == _owner));\n', '        uint256 valueAsEth = mul(_value,1 ether);\n', '        require(valueAsEth < this.balance);\n', '        _receiver.send(valueAsEth);\n', '    }\n', '\n', '    function balanceOf(address _receiver) public constant returns (uint balance) {\n', '        return balances[_receiver];\n', '    }\n', '\n', '    function changeOwner(address _receiver) public {\n', '        require(msg.sender == _owner);\n', '        _owner = _receiver;\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function updateTokenBalance(uint256 newBalance) public {\n', '        require(msg.sender == _owner);\n', '        _totalSupply = add(_totalSupply,newBalance);\n', '    }\n', '\n', '    // testing\n', '    function getWeiAmount() public constant returns (uint256) {\n', '        return weiAmount;\n', '    }\n', '    function getIncomingValueAsEth() public constant returns (uint256) {\n', '        return incomingValueAsEth;\n', '    }\n', '    function getCalcToken() public constant returns (uint256) {\n', '        return _calcToken;\n', '    }\n', '    function getTokePerWei() public constant returns (uint256) {\n', '        return _tokePerWei;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '}']
['contract META {\n', '\n', '    string public name = "Dunaton Metacurrency 3.0";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "META";\n', '\n', '    address public _owner;\n', '    address public dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c;\n', '    uint256 public _tokePerEth = 359;\n', '\n', '    // testing\n', '    uint256 public weiAmount;\n', '    uint256 incomingValueAsEth;\n', '    uint256 _calcToken;\n', '    uint256 _tokePerWei;\n', '\n', '    uint256 public _totalSupply = 21000000 * 1 ether;\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    // Storage\n', '    mapping (address => uint256) public balances;\n', '\n', '    function META() {\n', '        _owner = msg.sender;\n', '        balances[_owner] = 5800000 * 1 ether;    // premine 5.8m tokens to _owner\n', '        Transfer(this, _owner, (5800000 * 1 ether));\n', '        _totalSupply = sub(_totalSupply,balances[_owner]);\n', '    }\n', '\n', '    function transfer(address _to, uint _value, bytes _data) public {\n', '        // sender must have enough tokens to transfer\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        uint codeLength;\n', '\n', '        assembly {\n', '        // Retrieve the size of the code on target address, this needs assembly .\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '        balances[_to] = add(balances[_to], _value);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public {\n', '        // sender must have enough tokens to transfer\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        uint codeLength;\n', '\n', '        assembly {\n', '        // Retrieve the size of the code on target address, this needs assembly .\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '        balances[_to] = add(balances[_to], _value);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    // fallback to receive ETH into contract and send tokens back based on current exchange rate\n', '    function () payable public {\n', '        require(msg.value > 0);\n', '\n', '        // we need to calculate tokens per wei\n', '//        _tokePerWei = div(_tokePerEth, 1 ether);\n', '        _tokePerWei = _tokePerEth;\n', '        _calcToken = mul(msg.value,_tokePerWei); // value of payment in tokens\n', '\n', '        require(_totalSupply >= _calcToken);\n', '        _totalSupply = sub(_totalSupply, _calcToken);\n', '\n', '        balances[msg.sender] = add(balances[msg.sender], _calcToken);\n', '\n', '        Transfer(this, msg.sender, _calcToken);\n', '    }\n', '\n', '    function changePayRate(uint256 _newRate) public {\n', '        require((msg.sender == _owner) && (_newRate >= 0));\n', '//        _tokePerEth = _newRate * 1 ether;\n', '        _tokePerEth = _newRate;\n', '    }\n', '\n', '    function safeWithdrawal(address _receiver, uint256 _value) public {\n', '        require((msg.sender == _owner));\n', '        uint256 valueAsEth = mul(_value,1 ether);\n', '        require(valueAsEth < this.balance);\n', '        _receiver.send(valueAsEth);\n', '    }\n', '\n', '    function balanceOf(address _receiver) public constant returns (uint balance) {\n', '        return balances[_receiver];\n', '    }\n', '\n', '    function changeOwner(address _receiver) public {\n', '        require(msg.sender == _owner);\n', '        _owner = _receiver;\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function updateTokenBalance(uint256 newBalance) public {\n', '        require(msg.sender == _owner);\n', '        _totalSupply = add(_totalSupply,newBalance);\n', '    }\n', '\n', '    // testing\n', '    function getWeiAmount() public constant returns (uint256) {\n', '        return weiAmount;\n', '    }\n', '    function getIncomingValueAsEth() public constant returns (uint256) {\n', '        return incomingValueAsEth;\n', '    }\n', '    function getCalcToken() public constant returns (uint256) {\n', '        return _calcToken;\n', '    }\n', '    function getTokePerWei() public constant returns (uint256) {\n', '        return _tokePerWei;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '}']
