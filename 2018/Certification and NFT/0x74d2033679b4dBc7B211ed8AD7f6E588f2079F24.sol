['pragma solidity ^0.4.17;\n', '\n', '/*\n', '    Utilities & Common Modifiers\n', '*/\n', 'contract Utils {\n', '    /**\n', '        constructor\n', '    */\n', '    function Utils() public {\n', '    }\n', '\n', '    // verifies that an amount is greater than zero\n', '    modifier greaterThanZero(uint256 _amount) {\n', '        require(_amount > 0);\n', '        _;\n', '    }\n', '\n', '    // validates an address - currently only checks that it isn&#39;t null\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    // Overflow protected math functions\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', 'contract IOwned {\n', '    // this function isn&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function owner() public pure returns (address) {}\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '\n', '/*\n', '    owned 是一个管理者\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address _prevOwner, address _newOwner);\n', '\n', '    /**\n', '     * 初始化构造函数\n', '     */\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * 判断当前合约调用者是否是管理员\n', '     */\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * 指派一个新的管理员\n', '     * @param  _newOwner address 新的管理员帐户地址\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', 'contract IToken {\n', '    // these functions aren&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function name() public pure returns (string) {}\n', '    function symbol() public pure returns (string) {}\n', '    function decimals() public pure returns (uint8) {}\n', '    function totalSupply() public pure returns (uint256) {}\n', '    function balanceOf(address _owner) public pure returns (uint256) { _owner; }\n', '    function allowance(address _owner, address _spender) public pure returns (uint256) { _owner; _spender; }\n', '\n', '    function _transfer(address _from, address _to, uint256 _value) internal;\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '}\n', '\n', '\n', 'contract Token is IToken, Owned, Utils {\n', '    /* 公共变量 */\n', '    string public standard = &#39;&#39;;\n', '    string public name = &#39;&#39;; //代币名称\n', '    string public symbol = &#39;&#39;; //代币符号比如&#39;$&#39;\n', '    uint8 public decimals = 0;  //代币单位\n', '    uint256 public totalSupply = 0; //代币总量\n', '\n', '    /*记录所有余额的映射*/\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    /* 在区块链上创建一个事件，用以通知客户端*/\n', '    event Transfer(address indexed from, address indexed to, uint256 value);  //转帐通知事件\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value); //设置允许用户支付最大金额通知\n', '\n', '    function Token() public \n', '    {\n', '        name = &#39;YaoDun Chain&#39;;\n', '        symbol = &#39;YAODUN&#39;;\n', '        decimals = 8;\n', '        totalSupply = 2000000000 * 10 ** uint256(decimals);\n', '\n', '        balanceOf[owner] = totalSupply;\n', '    }\n', '\n', '\n', '    /**\n', '     * 私有方法从一个帐户发送给另一个帐户代币\n', '     * @param  _from address 发送代币的地址\n', '     * @param  _to address 接受代币的地址\n', '     * @param  _value uint256 接受代币的数量\n', '     */\n', '    function _transfer(address _from, address _to, uint256 _value)\n', '      internal\n', '      validAddress(_from)\n', '      validAddress(_to)\n', '    {\n', '\n', '\n', '      //检查发送者是否拥有足够余额\n', '      require(balanceOf[_from] >= _value);\n', '\n', '      //检查是否溢出\n', '      require(balanceOf[_to] + _value > balanceOf[_to]);\n', '\n', '      //保存数据用于后面的判断\n', '      uint previousBalances = safeAdd(balanceOf[_from], balanceOf[_to]);\n', '\n', '      //从发送者减掉发送额\n', '      balanceOf[_from] = safeSub(balanceOf[_from], _value);\n', '\n', '      //给接收者加上相同的量\n', '      balanceOf[_to] += safeAdd(balanceOf[_to], _value);\n', '\n', '      //通知任何监听该交易的客户端\n', '      emit Transfer(_from, _to, _value);\n', '\n', '      //判断买、卖双方的数据是否和转换前一致\n', '      assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '\n', '    }\n', '\n', '    /**\n', '     * 从主帐户合约调用者发送给别人代币\n', '     * @param  _to address 接受代币的地址\n', '     * @param  _value uint256 接受代币的数量\n', '     */\n', '    function transfer(address _to, uint256 _value)\n', '      public\n', '      validAddress(_to)\n', '      returns (bool)\n', '    {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * 从某个指定的帐户中，向另一个帐户发送代币\n', '     *\n', '     * 调用过程，会检查设置的允许最大交易额\n', '     *\n', '     * @param  _from address 发送者地址\n', '     * @param  _to address 接受者地址\n', '     * @param  _value uint256 要转移的代币数量\n', '     * @return        是否交易成功\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        validAddress(_from)\n', '        validAddress(_to)\n', '        returns (bool)\n', '    {\n', '        //检查发送者是否拥有足够余额支出的设置\n', '        require(_value <= allowance[_from][msg.sender]);   // Check allowance\n', '\n', '        allowance[_from][msg.sender] -= safeSub(allowance[_from][msg.sender], _value);\n', '\n', '        _transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * 设置帐户允许支付的最大金额\n', '     *\n', '     * 一般在智能合约的时候，避免支付过多，造成风险\n', '     *\n', '     * @param _spender 帐户地址\n', '     * @param _value 金额\n', '     */\n', '    function approve(address _spender, uint256 _value)\n', '        public\n', '        validAddress(_spender)\n', '        returns (bool success)\n', '    {\n', '\n', '        require(_value == 0 || allowance[msg.sender][_spender] == 0);\n', '\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract IYaoDun {\n', '\n', '    function _transfer(address _from, address _to, uint256 _value) internal;\n', '    function mintToken(address target, uint256 mintedAmount) public;\n', '    function freezeAccount(address target, bool freeze) public;\n', '    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public;\n', '    function buy() payable public;\n', '    function sell(uint256 amount) public;\n', '}\n', '\n', '\n', 'contract SmartToken is Owned, Token {\n', '\n', '    string public version = &#39;0.1&#39;;\n', '\n', '    // triggered when a smart token is deployed - the _token address is defined for forward compatibility, in case we want to trigger the event from a factory\n', '    event NewSmartToken(address _token);\n', '\n', '    /* 初始化合约，并且把初始的所有代币都给这合约的创建者\n', '     * @param tokenName 代币名称\n', '     * @param tokenSymbol 代币符号\n', '     * @param tokenTotal 代币总量\n', '     * @param decimalsUnits 代币后面的单位，小数点后面多少个0，以太币一样后面是是18个0\n', '     */\n', '    function SmartToken()\n', '        public\n', '        Token ()\n', '    {\n', '        emit NewSmartToken(address(this));\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract YaoDun is IYaoDun, Token {\n', '\n', '    //卖出的汇率,一个代币，可以卖出多少个以太币，单位是wei\n', '    uint256 public sellPrice;\n', '\n', '    //买入的汇率,1个以太币，可以买几个代币\n', '    uint256 public buyPrice;\n', '\n', '    //是否冻结帐户的列表\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    //定义一个事件，当有资产被冻结的时候，通知正在监听事件的客户端\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    // triggered when a smart token is deployed - the _token address is defined for forward compatibility, in case we want to trigger the event from a factory\n', '    event NewSmartToken(address _token);\n', '\n', '\n', '    function YaoDun()\n', '      public\n', '      Token ()\n', '    {\n', '        sellPrice = 2;     //设置1个单位的代币(单位是wei)，能够卖出2个以太币\n', '        buyPrice = 4;      //设置1个以太币，可以买0.25个代币\n', '        emit NewSmartToken(address(this));\n', '    }\n', '\n', '\n', '    function _transfer(address _from, address _to, uint _value)\n', '        validAddress(_from)\n', '        validAddress(_to)\n', '        internal\n', '    {\n', '        //检查发送者是否拥有足够余额\n', '        require (balanceOf[_from] > _value);\n', '\n', '        //检查是否溢出\n', '        require (balanceOf[_to] + _value > balanceOf[_to]);\n', '\n', '        //检查 冻结帐户\n', '        require(!frozenAccount[_from]);\n', '        require(!frozenAccount[_to]);\n', '\n', '\n', '\n', '        //从发送者减掉发送额\n', '        balanceOf[_from] = safeSub(balanceOf[_from], _value);\n', '\n', '        //给接收者加上相同的量\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n', '\n', '        //通知任何监听该交易的客户端\n', '        emit Transfer(_from, _to, _value);\n', '\n', '    }\n', '\n', '    /**\n', '     * 账户挖矿\n', '     * @param  target address 帐户地址\n', '     * @param  mintedAmount uint256 增加的金额(单位是wei)\n', '     */\n', '    function mintToken(address target, uint256 mintedAmount)\n', '        validAddress(target)\n', '        public\n', '        onlyOwner\n', '    {\n', '\n', '        //给指定地址增加代币，同时总量也相加\n', '        balanceOf[target] += mintedAmount;\n', '        totalSupply += mintedAmount;\n', '\n', '\n', '        emit Transfer(0, this, mintedAmount);\n', '        emit Transfer(this, target, mintedAmount);\n', '    }\n', '\n', '    /**\n', '     * 增加冻结帐户名称\n', '     *\n', '     * 你可能需要监管功能以便你能控制谁可以/谁不可以使用你创建的代币合约\n', '     *\n', '     * @param  target address 帐户地址\n', '     * @param  freeze bool    是否冻结\n', '     */\n', '    function freezeAccount(address target, bool freeze)\n', '        validAddress(target)\n', '        public\n', '        onlyOwner\n', '    {\n', '        frozenAccount[target] = freeze;\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '\n', '    /**\n', '     * 设置买卖价格\n', '     *\n', '     * 如果你想让ether(或其他代币)为你的代币进行背书,以便可以市场价自动化买卖代币,我们可以这么做。如果要使用浮动的价格，也可以在这里设置\n', '     *\n', '     * @param newSellPrice 新的卖出价格\n', '     * @param newBuyPrice 新的买入价格\n', '     */\n', '    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public onlyOwner {\n', '        sellPrice = newSellPrice;\n', '        buyPrice = newBuyPrice;\n', '    }\n', '\n', '    /**\n', '     * 使用以太币购买代币\n', '     */\n', '    function buy() payable public {\n', '      uint amount = msg.value / buyPrice;\n', '\n', '      _transfer(this, msg.sender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev 卖出代币\n', '     * @return 要卖出的数量(单位是wei)\n', '     */\n', '    function sell(uint256 amount) public {\n', '\n', '        //检查合约的余额是否充足\n', '        require(balanceOf[address(this)] >= amount * sellPrice);\n', '\n', '        _transfer(msg.sender, this, amount);\n', '\n', '        msg.sender.transfer(amount * sellPrice);\n', '    }\n', '}']