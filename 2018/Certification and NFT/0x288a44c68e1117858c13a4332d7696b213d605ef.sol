['pragma solidity 0.4.21;\n', '\n', 'contract Crowdsale{\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    enum TokenSaleType {round1, round2}\n', '    enum Roles {beneficiary, accountant, manager, observer, bounty, team, company, fees}\n', '    \n', '    address public token;\n', '    address public feesStrategy;\n', '    \n', '    address public creator;\n', '    address public vault;\n', '    address public lockedAllocation;\n', '    \n', '    bool public isFinalized;\n', '    bool public isInitialized;\n', '    bool public isPausedCrowdsale;\n', '    bool public isFirstInit;\n', '    \n', '    bool public team;\n', '    \n', '    address[8] public wallets = [\n', '        0x70DAB28d0dbdaD9d4035289AB2e0AEDB31711E00,\n', '        0x2708b92867eD0369cED09096c8453eeDD17EA7Eb,\n', '        msg.sender,\n', '        0x492e0A8aEb2Ed621D27F512FDda7c808902080CD,\n', '        0xffefdbdd6AB5E157eC20241d77cA2fe0F18E907B,\n', '        0xa9E7a001148E6135D8EAE0415211682546b6Eb4f,\n', '        0xFc2193697D5b3D0121A65Ca202d60371719e3adF\n', '    ];\n', '    \n', '    struct Profit{\n', '\t    uint256 min;    // percent from 0 to 50\n', '\t    uint256 max;    // percent from 0 to 50\n', '\t    uint256 step;   // percent step, from 1 to 50 (please, read doc!)\n', '\t    uint256 maxAllProfit; \n', '    }\n', '    struct Bonus {\n', '\t    uint256 value;\n', '\t    uint256 procent;\n', '\t    uint256 freezeTime;\n', '    }\n', '    \n', '    Bonus[] public bonuses;\n', '\n', '    Profit public profit = Profit(0, 25, 5, 50);\n', '    \n', '    uint256 public startTime \t\t= 1521104400; // 15 Apr\n', '    uint256 public endDiscountTime \t= 1522486800; // 31 May\n', '    uint256 public endTime \t\t\t= 1522486800; // 31 May\n', '    \n', '    uint256 public exchange = 1000 ether;\n', '    \n', '    uint256 public rate = 100000 ether;\n', '    uint256 public softCap = 0 ether;\n', '    uint256 public hardCap = 12000 ether;\n', '    uint256 public overLimit = 20 ether;\n', '    uint256 public minPay = 100 finney; \n', '    uint256 public ethWeiRaised;\n', '    uint256 public nonEthWeiRaised;\n', '    uint256 public weiRound1;\n', '    uint256 public tokenReserved;\n', '    \n', '    uint256 public allToken;\n', '    TokenSaleType TokenSale = TokenSaleType.round1;\n', '    \n', '    event ExchangeChanged(uint256 indexed newExchange, uint256 indexed oldExchange, uint256 rate, uint256 softCap, uint256 hardCap);\n', '    \n', '    function changeValues1(bool _isFinalized, bool _isInitialized, bool _isPausedCrowdsale, bool _isFirstInit, bool _team,\n', '    uint256 _minProfit, uint256 _maxProfit, uint256 _stepProfit, uint256 _maxAllProfit, uint256 _startTime,\n', '    uint256 _endDiscountTime, uint256 _endTime, uint256 _exchange, uint256 _rate) public {\n', '        isFinalized = _isFinalized;\n', '        isInitialized = _isInitialized;\n', '        isPausedCrowdsale = _isPausedCrowdsale;\n', '        isFirstInit = _isFirstInit;\n', '        team = _team;\n', '        profit = Profit(_minProfit, _maxProfit, _stepProfit, _maxAllProfit);\n', '        startTime = _startTime;\n', '        endDiscountTime = _endDiscountTime;\n', '        endTime = _endTime;\n', '        exchange = _exchange;\n', '        rate = _rate;\n', '    }\n', '    \n', '    function changeValues2(\n', '    uint256 _softCap, uint256 _hardcap, uint256 _overLimit, uint256 _minPay, uint256 _ethWeiRaised, \n', '    uint256 _nonEthWeiRaised, uint256 _weiRound1, uint256 _tokenReserved, uint256 _allToken, TokenSaleType _TokenSale, \n', '    uint256[] _value, uint256[] _procent, uint256[] _freezeTime) public {\n', '        _softCap = _softCap;\n', '        _hardcap = _hardcap;\n', '        _overLimit = _overLimit;\n', '        _minPay = _minPay;\n', '        _ethWeiRaised = _ethWeiRaised;\n', '        _nonEthWeiRaised = _nonEthWeiRaised;\n', '        _weiRound1 = _weiRound1; \n', '        _tokenReserved = _tokenReserved;\n', '        _allToken = _allToken;\n', '        _TokenSale = _TokenSale;\n', '        bonuses.length = 0;\n', '        for (uint8 i = 0; i < _value.length; i++){\n', '            bonuses.push(Bonus(_value[i],_procent[i],_freezeTime[i]));\n', '        }\n', '    }\n', '    \n', '    \n', '    function changeExchange(uint256 _ETHUSD) public {\n', '\t\trequire(_ETHUSD >= 1 ether); \n', '\n', '\t\tsoftCap=softCap.mul(exchange).div(_ETHUSD);  \t\t\t// QUINTILLIONS\n', '\t\thardCap=hardCap.mul(exchange).div(_ETHUSD);  \t\t\t// QUINTILLIONS\n', '\t\tminPay=minPay.mul(exchange).div(_ETHUSD);    \t\t   \t// QUINTILLIONS\n', '\t\t//TODO TaxValues[0]=TaxValues[0].mul(exchange).div(_ETHUSD);  \t// QUINTILLIONS\n', '\t\t//TODO TaxValues[1]=TaxValues[1].mul(exchange).div(_ETHUSD);  \t// QUINTILLIONS\n', '\n', '\t\trate=rate.mul(_ETHUSD).div(exchange);        \t\t\t// QUINTILLIONS\n', '\t\t\n', '\t\temit ExchangeChanged(_ETHUSD, exchange, rate, softCap, hardCap);\n', '\n', '\t    for (uint16 i = 0; i < bonuses.length; i++) {\n', '\t        bonuses[i].value=bonuses[i].value.mul(exchange).div(_ETHUSD);   // QUINTILLIONS\n', '\t    }\n', '\t    \n', '\t    exchange=_ETHUSD;\n', '\t    \n', '\t    \n', '\n', '    }\n', '    \n', '    function getTokenSaleType()  external constant returns(string){\n', '        return (TokenSale == TokenSaleType.round1)?&#39;round1&#39;:&#39;round2&#39;;\n', '    }\n', '    \n', '    \n', '    function hasEnded() public constant returns (bool) {\n', '\n', '        bool timeReached = now > endTime;\n', '\n', '        bool capReached = weiRaised() >= hardCap;\n', '\n', '        return (timeReached || capReached) && isInitialized;\n', '    }\n', '    \n', '    function goalReached() public constant returns (bool) {\n', '        return weiRaised() >= softCap;\n', '    }\n', '    \n', '    // Collected funds for the current round. Constant.\n', '    function weiRaised() public constant returns(uint256){\n', '        return ethWeiRaised.add(nonEthWeiRaised);\n', '    }\n', '\n', '    // Returns the amount of fees for both phases. Constant.\n', '    function weiTotalRaised() external constant returns(uint256){\n', '        return weiRound1.add(weiRaised());\n', '    }\n', '\n', '    // Returns the percentage of the bonus on the current date. Constant.\n', '    function getProfitPercent() public constant returns (uint256){\n', '        return getProfitPercentForData(now);\n', '    }\n', '\n', '\n', '    // Returns the percentage of the bonus on the given date. Constant.\n', '    function getProfitPercentForData(uint256 timeNow) public constant returns (uint256){\n', '        // if the discount is 0 or zero steps, or the round does not start, we return the minimum discount\n', '        if (profit.max == 0 || profit.step == 0 || timeNow > endDiscountTime){\n', '            return profit.min;\n', '        }\n', '\n', '        // if the round is over - the maximum\n', '        if (timeNow<=startTime){\n', '            return profit.max;\n', '        }\n', '\n', '        // bonus period\n', '        uint256 range = endDiscountTime.sub(startTime);\n', '\n', '        // delta bonus percentage\n', '        uint256 profitRange = profit.max.sub(profit.min);\n', '\n', '        // Time left\n', '        uint256 timeRest = endDiscountTime.sub(timeNow);\n', '\n', '        // Divide the delta of time into\n', '        uint256 profitProcent = profitRange.div(profit.step).mul(timeRest.mul(profit.step.add(1)).div(range));\n', '        return profitProcent.add(profit.min);\n', '    }\n', '\n', '    function getBonuses(uint256 _value) public constant returns(uint256 procent, uint256 _dateUnfreeze){\n', '        if(bonuses.length == 0 || bonuses[0].value > _value){\n', '            return (0,0);\n', '        }\n', '        uint16 i = 1;\n', '        for(i; i < bonuses.length; i++){\n', '            if(bonuses[i].value > _value){\n', '                break;\n', '            }\n', '        }\n', '        return (bonuses[i-1].procent,bonuses[i-1].freezeTime);\n', '    }\n', '    \n', '    \n', '}\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this does not hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']