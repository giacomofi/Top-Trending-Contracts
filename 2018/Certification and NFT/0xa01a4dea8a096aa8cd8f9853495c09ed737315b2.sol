['pragma solidity 0.4.24;\n', '\n', '\n', '/**\n', ' * \n', ' * This contract is used to set admin to the contract  which has some additional features such as minting , burning etc\n', ' * \n', ' */\n', '    contract Owned {\n', '        address public owner;\n', '\n', '        function owned() public {\n', '            owner = msg.sender;\n', '        }\n', '\n', '        modifier onlyOwner {\n', '            require(msg.sender == owner);\n', '            _;\n', '        }\n', '        \n', '        /* This function is used to transfer adminship to new owner\n', '         * @param  _newOwner - address of new admin or owner        \n', '         */\n', '\n', '        function transferOwnership(address _newOwner) onlyOwner public {\n', '            owner = _newOwner;\n', '        }          \n', '    }\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' This is interface to transfer Railz tokens , created by Railz token contract\n', ' */\n', 'interface RailzToken {\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * This is the main Railz Token Sale contract\n', ' */\n', 'contract RailzTokenSale is Owned {\n', '\tusing SafeMath for uint256;\n', '\n', '\tmapping (address=> uint256) contributors;\n', '\tmapping (address=> uint256) public tokensAllocated;\n', '    \n', '\t// start and end timestamps when contributions are allowed  (both inclusive)\n', '\tuint256 public presalestartTime =1528099200 ;     //4th June 8:00 am UTC\n', '\tuint256 public presaleendTime = 1530489599;       //1st July 23:59 pm UTC\n', '\tuint256 public publicsalestartTime = 1530518400;  //2nd July 8:00 am UTC\n', '\tuint256 public publicsalesendTime = 1532908799;   //29th July 23:59 pm UTC\n', '\n', '\n', '\t//token caps for each round\n', '\tuint256 public presalesCap = 120000000 * (1e18);\n', '\tuint256 public publicsalesCap = 350000000 * (1e18);\n', '\n', '\t//token price for each round\n', '\tuint256 public presalesTokenPriceInWei =  80000000000000 ; // 0.00008 ether;\n', '\tuint256 public publicsalesTokenPriceInWei = 196000000000000 ;// 0.000196 ether;\n', '\n', '\t// address where all funds collected from token sale are stored , this will ideally be address of MutliSig wallet\n', '\taddress wallet;\n', '\n', '\t// amount of raised money in wei\n', '\tuint256 public weiRaised=0;\n', '\n', '\t//amount of tokens sold\n', '\tuint256 public numberOfTokensAllocated=0;\n', '\n', '\t// maximum gas price for contribution transactions - 60 GWEI\n', '\tuint256 public maxGasPrice = 60000000000  wei;  \n', '\n', '\t// The token being sold\n', '\tRailzToken public token;\n', '\n', '\tbool hasPreTokenSalesCapReached = false;\n', '\tbool hasTokenSalesCapReached = false;\n', '\n', '\t// events for funds received and tokens\n', '\tevent ContributionReceived(address indexed contributor, uint256 value, uint256 numberOfTokens);\n', '\tevent TokensTransferred(address indexed contributor, uint256 numberOfTokensTransferred);\n', '\tevent ManualTokensTransferred(address indexed contributor, uint256 numberOfTokensTransferred);\n', '\tevent PreTokenSalesCapReached(address indexed contributor);\n', '\tevent TokenSalesCapReached(address indexed contributor);\n', '\n', '\tfunction RailzTokenSale(RailzToken _addressOfRewardToken, address _wallet) public {        \n', '  \t\trequire(presalestartTime >= now); \n', '  \t\trequire(_wallet != address(0));   \n', '        \n', '  \t\ttoken = RailzToken (_addressOfRewardToken);\n', '  \t\twallet = _wallet;\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\t// verifies that the gas price is lower than max gas price\n', '\tmodifier validGasPrice() {\n', '\t\tassert(tx.gasprice <= maxGasPrice);\n', '\t\t_;\n', '\t}\n', '\n', '\t// fallback function  used to buy tokens , this function is called when anyone sends ether to this contract\n', '\tfunction ()  payable public validGasPrice {  \n', '\t\trequire(msg.sender != address(0));                      //contributor&#39;s address should not be zero00/80\n', '\t\trequire(msg.value != 0);                                //amount should be greater then zero            \n', '        require(msg.value>=0.1 ether);                          //minimum contribution is 0.1 eth\n', '\t\trequire(isContributionAllowed());                       //Valid time of contribution and cap has not been reached 11\n', '\t\n', '\t\t// Add to mapping of contributor\n', '\t\tcontributors[msg.sender] = contributors[msg.sender].add(msg.value);\n', '\t\tweiRaised = weiRaised.add(msg.value);\n', '\t\tuint256 numberOfTokens = 0;\n', '\n', '\t\t//calculate number of tokens to be given\n', '\t\tif (isPreTokenSaleActive()) {\n', '\t\t\tnumberOfTokens = msg.value/presalesTokenPriceInWei;\n', '            numberOfTokens = numberOfTokens * (1e18);\n', '\t\t\trequire((numberOfTokens + numberOfTokensAllocated) <= presalesCap);\t\t\t//Check whether remaining tokens are greater than tokens to allocate\n', '\n', '\t\t\ttokensAllocated[msg.sender] = tokensAllocated[msg.sender].add(numberOfTokens);\n', '\t\t\tnumberOfTokensAllocated = numberOfTokensAllocated.add(numberOfTokens);\n', '\t\t\t\n', '\t\t\t//forward fund received to Railz multisig Account\n', '\t\t    forwardFunds(); \n', '\n', '\t\t\t//Notify server that an contribution has been received\n', '\t\t\temit ContributionReceived(msg.sender, msg.value, numberOfTokens);\n', '\n', '\t\t} else if (isTokenSaleActive()) {\n', '\t\t\tnumberOfTokens = msg.value/publicsalesTokenPriceInWei;\n', '\t\t\tnumberOfTokens = numberOfTokens * (1e18);\n', '\t\t\trequire((numberOfTokens + numberOfTokensAllocated) <= (presalesCap + publicsalesCap));\t//Check whether remaining tokens are greater than tokens to allocate\n', '\n', '\t\t\ttokensAllocated[msg.sender] = tokensAllocated[msg.sender].add(numberOfTokens);\n', '\t\t\tnumberOfTokensAllocated = numberOfTokensAllocated.add(numberOfTokens);\n', '\n', '            //forward fund received to Railz multisig Account\n', '\t\t    forwardFunds();\n', '\n', '\t\t\t//Notify server that an contribution has been received\n', '\t\t    emit ContributionReceived(msg.sender, msg.value, numberOfTokens);\n', '\t\t}        \n', '\n', '\t\t// check if hard cap has been reached or not , if it has reached close the contract\n', '\t\tcheckifCapHasReached();\n', '\t}\n', '\n', '\t/**\n', '\t* This function is used to check if an contribution is allowed or not\n', '\t*/\n', '\tfunction isContributionAllowed() public view returns (bool) {    \n', '\t\tif (isPreTokenSaleActive())\n', '\t\t\treturn  (!hasPreTokenSalesCapReached);\n', '\t\telse if (isTokenSaleActive())\n', '\t\t\treturn (!hasTokenSalesCapReached);\n', '\t\telse\n', '\t\t\treturn false;\n', '\t}\n', '\n', '\t// send ether to the fund collection wallet  , this ideally would be an multisig wallet\n', '\tfunction forwardFunds() internal {\n', '\t\twallet.transfer(msg.value);\n', '\t}\n', '\n', '\t//Pre Token Sale time\n', '\tfunction isPreTokenSaleActive() internal view returns (bool) {\n', '\t\treturn ((now >= presalestartTime) && (now <= presaleendTime));  \n', '\t}\n', '\n', '\t//Token Sale time\n', '\tfunction isTokenSaleActive() internal view returns (bool) {\n', '\t\treturn (now >= (publicsalestartTime) && (now <= publicsalesendTime));  \n', '\t}\n', '\n', '\t// Called by owner when preico token cap has been reached\n', '\tfunction preTokenSalesCapReached() internal {\n', '\t\thasPreTokenSalesCapReached = true;\n', '\t\temit PreTokenSalesCapReached(msg.sender);\n', '\t}\n', '\n', '\t// Called by owner when ico token cap has been reached\n', '\tfunction tokenSalesCapReached() internal {\n', '\t\thasTokenSalesCapReached = true;\n', '\t\temit TokenSalesCapReached(msg.sender);\n', '\t}\n', '\n', '\t//This function is used to transfer token to contributor after successful audit\n', '\tfunction transferToken(address _contributor) public onlyOwner {\n', '\t\trequire(_contributor != 0);\n', '        uint256 numberOfTokens = tokensAllocated[_contributor];\n', '        tokensAllocated[_contributor] = 0;    \n', '\t\ttoken.transfer(_contributor, numberOfTokens);\n', '\t\temit TokensTransferred(_contributor, numberOfTokens);\n', '\t}\n', '\n', '\n', '\t//This function is used to do bulk transfer token to contributor after successful audit manually\n', '\t function manualBatchTransferToken(uint256[] amount, address[] wallets) public onlyOwner {\n', '        for (uint256 i = 0; i < wallets.length; i++) {\n', '            token.transfer(wallets[i], amount[i]);\n', '\t\t\temit TokensTransferred(wallets[i], amount[i]);\n', '        }\n', '    }\n', '\n', '\t//This function is used to do bulk transfer token to contributor after successful audit\n', '\t function batchTransferToken(address[] wallets) public onlyOwner {\n', '        for (uint256 i = 0; i < wallets.length; i++) {\n', '\t\t\tuint256 amountOfTokens = tokensAllocated[wallets[i]];\n', '\t\t\trequire(amountOfTokens > 0);\n', '\t\t\ttokensAllocated[wallets[i]]=0;\n', '            token.transfer(wallets[i], amountOfTokens);\n', '\t\t\temit TokensTransferred(wallets[i], amountOfTokens);\n', '        }\n', '    }\n', '\t\n', '\t//This function is used refund contribution of a contributor in case soft cap is not reached or audit of an contributor failed\n', '\tfunction refundContribution(address _contributor, uint256 _weiAmount) public onlyOwner returns (bool) {\n', '\t\trequire(_contributor != 0);                                                                                                                                     \n', '\t\tif (!_contributor.send(_weiAmount)) {\n', '\t\t\treturn false;\n', '\t\t} else {\n', '\t\t\tcontributors[_contributor] = 0;\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\n', '\t// This function check whether ICO is currently active or not\n', '    function checkifCapHasReached() internal {\n', '    \tif (isPreTokenSaleActive() && (numberOfTokensAllocated > presalesCap))  \n', '        \thasPreTokenSalesCapReached = true;\n', '     \telse if (isTokenSaleActive() && (numberOfTokensAllocated > (presalesCap + publicsalesCap)))     \n', '        \thasTokenSalesCapReached = true;     \t\n', '    }\n', '\n', '  \t//This function allows the owner to update the gas price limit public onlyOwner     \n', '    function setGasPrice(uint256 _gasPrice) public onlyOwner {\n', '    \tmaxGasPrice = _gasPrice;\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '\n', '/**\n', ' * \n', ' * This contract is used to set admin to the contract  which has some additional features such as minting , burning etc\n', ' * \n', ' */\n', '    contract Owned {\n', '        address public owner;\n', '\n', '        function owned() public {\n', '            owner = msg.sender;\n', '        }\n', '\n', '        modifier onlyOwner {\n', '            require(msg.sender == owner);\n', '            _;\n', '        }\n', '        \n', '        /* This function is used to transfer adminship to new owner\n', '         * @param  _newOwner - address of new admin or owner        \n', '         */\n', '\n', '        function transferOwnership(address _newOwner) onlyOwner public {\n', '            owner = _newOwner;\n', '        }          \n', '    }\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' This is interface to transfer Railz tokens , created by Railz token contract\n', ' */\n', 'interface RailzToken {\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * This is the main Railz Token Sale contract\n', ' */\n', 'contract RailzTokenSale is Owned {\n', '\tusing SafeMath for uint256;\n', '\n', '\tmapping (address=> uint256) contributors;\n', '\tmapping (address=> uint256) public tokensAllocated;\n', '    \n', '\t// start and end timestamps when contributions are allowed  (both inclusive)\n', '\tuint256 public presalestartTime =1528099200 ;     //4th June 8:00 am UTC\n', '\tuint256 public presaleendTime = 1530489599;       //1st July 23:59 pm UTC\n', '\tuint256 public publicsalestartTime = 1530518400;  //2nd July 8:00 am UTC\n', '\tuint256 public publicsalesendTime = 1532908799;   //29th July 23:59 pm UTC\n', '\n', '\n', '\t//token caps for each round\n', '\tuint256 public presalesCap = 120000000 * (1e18);\n', '\tuint256 public publicsalesCap = 350000000 * (1e18);\n', '\n', '\t//token price for each round\n', '\tuint256 public presalesTokenPriceInWei =  80000000000000 ; // 0.00008 ether;\n', '\tuint256 public publicsalesTokenPriceInWei = 196000000000000 ;// 0.000196 ether;\n', '\n', '\t// address where all funds collected from token sale are stored , this will ideally be address of MutliSig wallet\n', '\taddress wallet;\n', '\n', '\t// amount of raised money in wei\n', '\tuint256 public weiRaised=0;\n', '\n', '\t//amount of tokens sold\n', '\tuint256 public numberOfTokensAllocated=0;\n', '\n', '\t// maximum gas price for contribution transactions - 60 GWEI\n', '\tuint256 public maxGasPrice = 60000000000  wei;  \n', '\n', '\t// The token being sold\n', '\tRailzToken public token;\n', '\n', '\tbool hasPreTokenSalesCapReached = false;\n', '\tbool hasTokenSalesCapReached = false;\n', '\n', '\t// events for funds received and tokens\n', '\tevent ContributionReceived(address indexed contributor, uint256 value, uint256 numberOfTokens);\n', '\tevent TokensTransferred(address indexed contributor, uint256 numberOfTokensTransferred);\n', '\tevent ManualTokensTransferred(address indexed contributor, uint256 numberOfTokensTransferred);\n', '\tevent PreTokenSalesCapReached(address indexed contributor);\n', '\tevent TokenSalesCapReached(address indexed contributor);\n', '\n', '\tfunction RailzTokenSale(RailzToken _addressOfRewardToken, address _wallet) public {        \n', '  \t\trequire(presalestartTime >= now); \n', '  \t\trequire(_wallet != address(0));   \n', '        \n', '  \t\ttoken = RailzToken (_addressOfRewardToken);\n', '  \t\twallet = _wallet;\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\t// verifies that the gas price is lower than max gas price\n', '\tmodifier validGasPrice() {\n', '\t\tassert(tx.gasprice <= maxGasPrice);\n', '\t\t_;\n', '\t}\n', '\n', '\t// fallback function  used to buy tokens , this function is called when anyone sends ether to this contract\n', '\tfunction ()  payable public validGasPrice {  \n', "\t\trequire(msg.sender != address(0));                      //contributor's address should not be zero00/80\n", '\t\trequire(msg.value != 0);                                //amount should be greater then zero            \n', '        require(msg.value>=0.1 ether);                          //minimum contribution is 0.1 eth\n', '\t\trequire(isContributionAllowed());                       //Valid time of contribution and cap has not been reached 11\n', '\t\n', '\t\t// Add to mapping of contributor\n', '\t\tcontributors[msg.sender] = contributors[msg.sender].add(msg.value);\n', '\t\tweiRaised = weiRaised.add(msg.value);\n', '\t\tuint256 numberOfTokens = 0;\n', '\n', '\t\t//calculate number of tokens to be given\n', '\t\tif (isPreTokenSaleActive()) {\n', '\t\t\tnumberOfTokens = msg.value/presalesTokenPriceInWei;\n', '            numberOfTokens = numberOfTokens * (1e18);\n', '\t\t\trequire((numberOfTokens + numberOfTokensAllocated) <= presalesCap);\t\t\t//Check whether remaining tokens are greater than tokens to allocate\n', '\n', '\t\t\ttokensAllocated[msg.sender] = tokensAllocated[msg.sender].add(numberOfTokens);\n', '\t\t\tnumberOfTokensAllocated = numberOfTokensAllocated.add(numberOfTokens);\n', '\t\t\t\n', '\t\t\t//forward fund received to Railz multisig Account\n', '\t\t    forwardFunds(); \n', '\n', '\t\t\t//Notify server that an contribution has been received\n', '\t\t\temit ContributionReceived(msg.sender, msg.value, numberOfTokens);\n', '\n', '\t\t} else if (isTokenSaleActive()) {\n', '\t\t\tnumberOfTokens = msg.value/publicsalesTokenPriceInWei;\n', '\t\t\tnumberOfTokens = numberOfTokens * (1e18);\n', '\t\t\trequire((numberOfTokens + numberOfTokensAllocated) <= (presalesCap + publicsalesCap));\t//Check whether remaining tokens are greater than tokens to allocate\n', '\n', '\t\t\ttokensAllocated[msg.sender] = tokensAllocated[msg.sender].add(numberOfTokens);\n', '\t\t\tnumberOfTokensAllocated = numberOfTokensAllocated.add(numberOfTokens);\n', '\n', '            //forward fund received to Railz multisig Account\n', '\t\t    forwardFunds();\n', '\n', '\t\t\t//Notify server that an contribution has been received\n', '\t\t    emit ContributionReceived(msg.sender, msg.value, numberOfTokens);\n', '\t\t}        \n', '\n', '\t\t// check if hard cap has been reached or not , if it has reached close the contract\n', '\t\tcheckifCapHasReached();\n', '\t}\n', '\n', '\t/**\n', '\t* This function is used to check if an contribution is allowed or not\n', '\t*/\n', '\tfunction isContributionAllowed() public view returns (bool) {    \n', '\t\tif (isPreTokenSaleActive())\n', '\t\t\treturn  (!hasPreTokenSalesCapReached);\n', '\t\telse if (isTokenSaleActive())\n', '\t\t\treturn (!hasTokenSalesCapReached);\n', '\t\telse\n', '\t\t\treturn false;\n', '\t}\n', '\n', '\t// send ether to the fund collection wallet  , this ideally would be an multisig wallet\n', '\tfunction forwardFunds() internal {\n', '\t\twallet.transfer(msg.value);\n', '\t}\n', '\n', '\t//Pre Token Sale time\n', '\tfunction isPreTokenSaleActive() internal view returns (bool) {\n', '\t\treturn ((now >= presalestartTime) && (now <= presaleendTime));  \n', '\t}\n', '\n', '\t//Token Sale time\n', '\tfunction isTokenSaleActive() internal view returns (bool) {\n', '\t\treturn (now >= (publicsalestartTime) && (now <= publicsalesendTime));  \n', '\t}\n', '\n', '\t// Called by owner when preico token cap has been reached\n', '\tfunction preTokenSalesCapReached() internal {\n', '\t\thasPreTokenSalesCapReached = true;\n', '\t\temit PreTokenSalesCapReached(msg.sender);\n', '\t}\n', '\n', '\t// Called by owner when ico token cap has been reached\n', '\tfunction tokenSalesCapReached() internal {\n', '\t\thasTokenSalesCapReached = true;\n', '\t\temit TokenSalesCapReached(msg.sender);\n', '\t}\n', '\n', '\t//This function is used to transfer token to contributor after successful audit\n', '\tfunction transferToken(address _contributor) public onlyOwner {\n', '\t\trequire(_contributor != 0);\n', '        uint256 numberOfTokens = tokensAllocated[_contributor];\n', '        tokensAllocated[_contributor] = 0;    \n', '\t\ttoken.transfer(_contributor, numberOfTokens);\n', '\t\temit TokensTransferred(_contributor, numberOfTokens);\n', '\t}\n', '\n', '\n', '\t//This function is used to do bulk transfer token to contributor after successful audit manually\n', '\t function manualBatchTransferToken(uint256[] amount, address[] wallets) public onlyOwner {\n', '        for (uint256 i = 0; i < wallets.length; i++) {\n', '            token.transfer(wallets[i], amount[i]);\n', '\t\t\temit TokensTransferred(wallets[i], amount[i]);\n', '        }\n', '    }\n', '\n', '\t//This function is used to do bulk transfer token to contributor after successful audit\n', '\t function batchTransferToken(address[] wallets) public onlyOwner {\n', '        for (uint256 i = 0; i < wallets.length; i++) {\n', '\t\t\tuint256 amountOfTokens = tokensAllocated[wallets[i]];\n', '\t\t\trequire(amountOfTokens > 0);\n', '\t\t\ttokensAllocated[wallets[i]]=0;\n', '            token.transfer(wallets[i], amountOfTokens);\n', '\t\t\temit TokensTransferred(wallets[i], amountOfTokens);\n', '        }\n', '    }\n', '\t\n', '\t//This function is used refund contribution of a contributor in case soft cap is not reached or audit of an contributor failed\n', '\tfunction refundContribution(address _contributor, uint256 _weiAmount) public onlyOwner returns (bool) {\n', '\t\trequire(_contributor != 0);                                                                                                                                     \n', '\t\tif (!_contributor.send(_weiAmount)) {\n', '\t\t\treturn false;\n', '\t\t} else {\n', '\t\t\tcontributors[_contributor] = 0;\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\n', '\t// This function check whether ICO is currently active or not\n', '    function checkifCapHasReached() internal {\n', '    \tif (isPreTokenSaleActive() && (numberOfTokensAllocated > presalesCap))  \n', '        \thasPreTokenSalesCapReached = true;\n', '     \telse if (isTokenSaleActive() && (numberOfTokensAllocated > (presalesCap + publicsalesCap)))     \n', '        \thasTokenSalesCapReached = true;     \t\n', '    }\n', '\n', '  \t//This function allows the owner to update the gas price limit public onlyOwner     \n', '    function setGasPrice(uint256 _gasPrice) public onlyOwner {\n', '    \tmaxGasPrice = _gasPrice;\n', '    }\n', '}']
