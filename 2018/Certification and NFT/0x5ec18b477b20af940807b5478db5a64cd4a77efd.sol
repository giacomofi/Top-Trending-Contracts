['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Pausable token\n', ' * @dev StandardToken modified with pausable transfers.\n', ' **/\n', 'contract PausableToken is StandardToken, Pausable {\n', '\n', '  function transfer(\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  function approve(\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.approve(_spender, _value);\n', '  }\n', '\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool success)\n', '  {\n', '    return super.increaseApproval(_spender, _addedValue);\n', '  }\n', '\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool success)\n', '  {\n', '    return super.decreaseApproval(_spender, _subtractedValue);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) public {\n', '    _burn(msg.sender, _value);\n', '  }\n', '\n', '  function _burn(address _who, uint256 _value) internal {\n', '    require(_value <= balances[_who]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', '    // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '    balances[_who] = balances[_who].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    emit Burn(_who, _value);\n', '    emit Transfer(_who, address(0), _value);\n', '  }\n', '}\n', '\n', 'contract RepublicToken is PausableToken, BurnableToken {\n', '\n', '    string public constant name = "Republic Token";\n', '    string public constant symbol = "REN";\n', '    uint8 public constant decimals = 18;\n', '    uint256 public constant INITIAL_SUPPLY = 1000000000 * 10**uint256(decimals);\n', '\n', '    /// @notice The RepublicToken Constructor.\n', '    constructor() public {\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '    }\n', '\n', '    function transferTokens(address beneficiary, uint256 amount) public onlyOwner returns (bool) {\n', '        /* solium-disable error-reason */\n', '        require(amount > 0);\n', '\n', '        balances[owner] = balances[owner].sub(amount);\n', '        balances[beneficiary] = balances[beneficiary].add(amount);\n', '        emit Transfer(owner, beneficiary, amount);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @notice LinkedList is a library for a circular double linked list.\n', ' */\n', 'library LinkedList {\n', '\n', '    /*\n', '    * @notice A permanent NULL node (0x0) in the circular double linked list.\n', '    * NULL.next is the head, and NULL.previous is the tail.\n', '    */\n', '    address public constant NULL = 0x0;\n', '\n', '    /**\n', '    * @notice A node points to the node before it, and the node after it. If\n', '    * node.previous = NULL, then the node is the head of the list. If\n', '    * node.next = NULL, then the node is the tail of the list.\n', '    */\n', '    struct Node {\n', '        bool inList;\n', '        address previous;\n', '        address next;\n', '    }\n', '\n', '    /**\n', '    * @notice LinkedList uses a mapping from address to nodes. Each address\n', '    * uniquely identifies a node, and in this way they are used like pointers.\n', '    */\n', '    struct List {\n', '        mapping (address => Node) list;\n', '    }\n', '\n', '    /**\n', '    * @notice Insert a new node before an existing node.\n', '    *\n', '    * @param self The list being used.\n', '    * @param target The existing node in the list.\n', '    * @param newNode The next node to insert before the target.\n', '    */\n', '    function insertBefore(List storage self, address target, address newNode) internal {\n', '        require(!isInList(self, newNode), "already in list");\n', '        require(isInList(self, target) || target == NULL, "not in list");\n', '\n', '        // It is expected that this value is sometimes NULL.\n', '        address prev = self.list[target].previous;\n', '\n', '        self.list[newNode].next = target;\n', '        self.list[newNode].previous = prev;\n', '        self.list[target].previous = newNode;\n', '        self.list[prev].next = newNode;\n', '\n', '        self.list[newNode].inList = true;\n', '    }\n', '\n', '    /**\n', '    * @notice Insert a new node after an existing node.\n', '    *\n', '    * @param self The list being used.\n', '    * @param target The existing node in the list.\n', '    * @param newNode The next node to insert after the target.\n', '    */\n', '    function insertAfter(List storage self, address target, address newNode) internal {\n', '        require(!isInList(self, newNode), "already in list");\n', '        require(isInList(self, target) || target == NULL, "not in list");\n', '\n', '        // It is expected that this value is sometimes NULL.\n', '        address n = self.list[target].next;\n', '\n', '        self.list[newNode].previous = target;\n', '        self.list[newNode].next = n;\n', '        self.list[target].next = newNode;\n', '        self.list[n].previous = newNode;\n', '\n', '        self.list[newNode].inList = true;\n', '    }\n', '\n', '    /**\n', '    * @notice Remove a node from the list, and fix the previous and next\n', '    * pointers that are pointing to the removed node. Removing anode that is not\n', '    * in the list will do nothing.\n', '    *\n', '    * @param self The list being using.\n', '    * @param node The node in the list to be removed.\n', '    */\n', '    function remove(List storage self, address node) internal {\n', '        require(isInList(self, node), "not in list");\n', '        if (node == NULL) {\n', '            return;\n', '        }\n', '        address p = self.list[node].previous;\n', '        address n = self.list[node].next;\n', '\n', '        self.list[p].next = n;\n', '        self.list[n].previous = p;\n', '\n', '        // Deleting the node should set this value to false, but we set it here for\n', '        // explicitness.\n', '        self.list[node].inList = false;\n', '        delete self.list[node];\n', '    }\n', '\n', '    /**\n', '    * @notice Insert a node at the beginning of the list.\n', '    *\n', '    * @param self The list being used.\n', '    * @param node The node to insert at the beginning of the list.\n', '    */\n', '    function prepend(List storage self, address node) internal {\n', '        // isInList(node) is checked in insertBefore\n', '\n', '        insertBefore(self, begin(self), node);\n', '    }\n', '\n', '    /**\n', '    * @notice Insert a node at the end of the list.\n', '    *\n', '    * @param self The list being used.\n', '    * @param node The node to insert at the end of the list.\n', '    */\n', '    function append(List storage self, address node) internal {\n', '        // isInList(node) is checked in insertBefore\n', '\n', '        insertAfter(self, end(self), node);\n', '    }\n', '\n', '    function swap(List storage self, address left, address right) internal {\n', '        // isInList(left) and isInList(right) are checked in remove\n', '\n', '        address previousRight = self.list[right].previous;\n', '        remove(self, right);\n', '        insertAfter(self, left, right);\n', '        remove(self, left);\n', '        insertAfter(self, previousRight, left);\n', '    }\n', '\n', '    function isInList(List storage self, address node) internal view returns (bool) {\n', '        return self.list[node].inList;\n', '    }\n', '\n', '    /**\n', '    * @notice Get the node at the beginning of a double linked list.\n', '    *\n', '    * @param self The list being used.\n', '    *\n', '    * @return A address identifying the node at the beginning of the double\n', '    * linked list.\n', '    */\n', '    function begin(List storage self) internal view returns (address) {\n', '        return self.list[NULL].next;\n', '    }\n', '\n', '    /**\n', '    * @notice Get the node at the end of a double linked list.\n', '    *\n', '    * @param self The list being used.\n', '    *\n', '    * @return A address identifying the node at the end of the double linked\n', '    * list.\n', '    */\n', '    function end(List storage self) internal view returns (address) {\n', '        return self.list[NULL].previous;\n', '    }\n', '\n', '    function next(List storage self, address node) internal view returns (address) {\n', '        require(isInList(self, node), "not in list");\n', '        return self.list[node].next;\n', '    }\n', '\n', '    function previous(List storage self, address node) internal view returns (address) {\n', '        require(isInList(self, node), "not in list");\n', '        return self.list[node].previous;\n', '    }\n', '\n', '}\n', '\n', '/// @notice This contract stores data and funds for the DarknodeRegistry\n', '/// contract. The data / fund logic and storage have been separated to improve\n', '/// upgradability.\n', 'contract DarknodeRegistryStore is Ownable {\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    /// @notice Darknodes are stored in the darknode struct. The owner is the\n', '    /// address that registered the darknode, the bond is the amount of REN that\n', '    /// was transferred during registration, and the public key is the\n', '    /// encryption key that should be used when sending sensitive information to\n', '    /// the darknode.\n', '    struct Darknode {\n', '        // The owner of a Darknode is the address that called the register\n', '        // function. The owner is the only address that is allowed to\n', '        // deregister the Darknode, unless the Darknode is slashed for\n', '        // malicious behavior.\n', '        address owner;\n', '\n', '        // The bond is the amount of REN submitted as a bond by the Darknode.\n', '        // This amount is reduced when the Darknode is slashed for malicious\n', '        // behavior.\n', '        uint256 bond;\n', '\n', '        // The block number at which the Darknode is considered registered.\n', '        uint256 registeredAt;\n', '\n', '        // The block number at which the Darknode is considered deregistered.\n', '        uint256 deregisteredAt;\n', '\n', '        // The public key used by this Darknode for encrypting sensitive data\n', '        // off chain. It is assumed that the Darknode has access to the\n', '        // respective private key, and that there is an agreement on the format\n', '        // of the public key.\n', '        bytes publicKey;\n', '    }\n', '\n', '    /// Registry data.\n', '    mapping(address => Darknode) private darknodeRegistry;\n', '    LinkedList.List private darknodes;\n', '\n', '    // RepublicToken.\n', '    RepublicToken public ren;\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _ren The address of the RepublicToken contract.\n', '    constructor(\n', '        string _VERSION,\n', '        RepublicToken _ren\n', '    ) public {\n', '        VERSION = _VERSION;\n', '        ren = _ren;\n', '    }\n', '\n', '    /// @notice Instantiates a darknode and appends it to the darknodes\n', '    /// linked-list.\n', '    ///\n', '    /// @param _darknodeID The darknode&#39;s ID.\n', '    /// @param _darknodeOwner The darknode&#39;s owner&#39;s address\n', '    /// @param _bond The darknode&#39;s bond value\n', '    /// @param _publicKey The darknode&#39;s public key\n', '    /// @param _registeredAt The time stamp when the darknode is registered.\n', '    /// @param _deregisteredAt The time stamp when the darknode is deregistered.\n', '    function appendDarknode(\n', '        address _darknodeID,\n', '        address _darknodeOwner,\n', '        uint256 _bond,\n', '        bytes _publicKey,\n', '        uint256 _registeredAt,\n', '        uint256 _deregisteredAt\n', '    ) external onlyOwner {\n', '        Darknode memory darknode = Darknode({\n', '            owner: _darknodeOwner,\n', '            bond: _bond,\n', '            publicKey: _publicKey,\n', '            registeredAt: _registeredAt,\n', '            deregisteredAt: _deregisteredAt\n', '        });\n', '        darknodeRegistry[_darknodeID] = darknode;\n', '        LinkedList.append(darknodes, _darknodeID);\n', '    }\n', '\n', '    /// @notice Returns the address of the first darknode in the store\n', '    function begin() external view onlyOwner returns(address) {\n', '        return LinkedList.begin(darknodes);\n', '    }\n', '\n', '    /// @notice Returns the address of the next darknode in the store after the\n', '    /// given address.\n', '    function next(address darknodeID) external view onlyOwner returns(address) {\n', '        return LinkedList.next(darknodes, darknodeID);\n', '    }\n', '\n', '    /// @notice Removes a darknode from the store and transfers its bond to the\n', '    /// owner of this contract.\n', '    function removeDarknode(address darknodeID) external onlyOwner {\n', '        uint256 bond = darknodeRegistry[darknodeID].bond;\n', '        delete darknodeRegistry[darknodeID];\n', '        LinkedList.remove(darknodes, darknodeID);\n', '        require(ren.transfer(owner, bond), "bond transfer failed");\n', '    }\n', '\n', '    /// @notice Updates the bond of the darknode. If the bond is being\n', '    /// decreased, the difference is sent to the owner of this contract.\n', '    function updateDarknodeBond(address darknodeID, uint256 bond) external onlyOwner {\n', '        uint256 previousBond = darknodeRegistry[darknodeID].bond;\n', '        darknodeRegistry[darknodeID].bond = bond;\n', '        if (previousBond > bond) {\n', '            require(ren.transfer(owner, previousBond - bond), "cannot transfer bond");\n', '        }\n', '    }\n', '\n', '    /// @notice Updates the deregistration timestamp of a darknode.\n', '    function updateDarknodeDeregisteredAt(address darknodeID, uint256 deregisteredAt) external onlyOwner {\n', '        darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt;\n', '    }\n', '\n', '    /// @notice Returns the owner of a given darknode.\n', '    function darknodeOwner(address darknodeID) external view onlyOwner returns (address) {\n', '        return darknodeRegistry[darknodeID].owner;\n', '    }\n', '\n', '    /// @notice Returns the bond of a given darknode.\n', '    function darknodeBond(address darknodeID) external view onlyOwner returns (uint256) {\n', '        return darknodeRegistry[darknodeID].bond;\n', '    }\n', '\n', '    /// @notice Returns the registration time of a given darknode.\n', '    function darknodeRegisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\n', '        return darknodeRegistry[darknodeID].registeredAt;\n', '    }\n', '\n', '    /// @notice Returns the deregistration time of a given darknode.\n', '    function darknodeDeregisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\n', '        return darknodeRegistry[darknodeID].deregisteredAt;\n', '    }\n', '\n', '    /// @notice Returns the encryption public key of a given darknode.\n', '    function darknodePublicKey(address darknodeID) external view onlyOwner returns (bytes) {\n', '        return darknodeRegistry[darknodeID].publicKey;\n', '    }\n', '}\n', '\n', '/// @notice DarknodeRegistry is responsible for the registration and\n', '/// deregistration of Darknodes.\n', 'contract DarknodeRegistry is Ownable {\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    /// @notice Darknode pods are shuffled after a fixed number of blocks.\n', '    /// An Epoch stores an epoch hash used as an (insecure) RNG seed, and the\n', '    /// blocknumber which restricts when the next epoch can be called.\n', '    struct Epoch {\n', '        uint256 epochhash;\n', '        uint256 blocknumber;\n', '    }\n', '\n', '    uint256 public numDarknodes;\n', '    uint256 public numDarknodesNextEpoch;\n', '    uint256 public numDarknodesPreviousEpoch;\n', '\n', '    /// Variables used to parameterize behavior.\n', '    uint256 public minimumBond;\n', '    uint256 public minimumPodSize;\n', '    uint256 public minimumEpochInterval;\n', '    address public slasher;\n', '\n', '    /// When one of the above variables is modified, it is only updated when the\n', '    /// next epoch is called. These variables store the values for the next epoch.\n', '    uint256 public nextMinimumBond;\n', '    uint256 public nextMinimumPodSize;\n', '    uint256 public nextMinimumEpochInterval;\n', '    address public nextSlasher;\n', '\n', '    /// The current and previous epoch\n', '    Epoch public currentEpoch;\n', '    Epoch public previousEpoch;\n', '\n', '    /// Republic ERC20 token contract used to transfer bonds.\n', '    RepublicToken public ren;\n', '\n', '    /// Darknode Registry Store is the storage contract for darknodes.\n', '    DarknodeRegistryStore public store;\n', '\n', '    /// @notice Emitted when a darknode is registered.\n', '    /// @param _darknodeID The darknode ID that was registered.\n', '    /// @param _bond The amount of REN that was transferred as bond.\n', '    event LogDarknodeRegistered(address _darknodeID, uint256 _bond);\n', '\n', '    /// @notice Emitted when a darknode is deregistered.\n', '    /// @param _darknodeID The darknode ID that was deregistered.\n', '    event LogDarknodeDeregistered(address _darknodeID);\n', '\n', '    /// @notice Emitted when a refund has been made.\n', '    /// @param _owner The address that was refunded.\n', '    /// @param _amount The amount of REN that was refunded.\n', '    event LogDarknodeOwnerRefunded(address _owner, uint256 _amount);\n', '\n', '    /// @notice Emitted when a new epoch has begun.\n', '    event LogNewEpoch();\n', '\n', '    /// @notice Emitted when a constructor parameter has been updated.\n', '    event LogMinimumBondUpdated(uint256 previousMinimumBond, uint256 nextMinimumBond);\n', '    event LogMinimumPodSizeUpdated(uint256 previousMinimumPodSize, uint256 nextMinimumPodSize);\n', '    event LogMinimumEpochIntervalUpdated(uint256 previousMinimumEpochInterval, uint256 nextMinimumEpochInterval);\n', '    event LogSlasherUpdated(address previousSlasher, address nextSlasher);\n', '\n', '    /// @notice Only allow the owner that registered the darknode to pass.\n', '    modifier onlyDarknodeOwner(address _darknodeID) {\n', '        require(store.darknodeOwner(_darknodeID) == msg.sender, "must be darknode owner");\n', '        _;\n', '    }\n', '\n', '    /// @notice Only allow unregistered darknodes.\n', '    modifier onlyRefunded(address _darknodeID) {\n', '        require(isRefunded(_darknodeID), "must be refunded or never registered");\n', '        _;\n', '    }\n', '\n', '    /// @notice Only allow refundable darknodes.\n', '    modifier onlyRefundable(address _darknodeID) {\n', '        require(isRefundable(_darknodeID), "must be deregistered for at least one epoch");\n', '        _;\n', '    }\n', '\n', '    /// @notice Only allowed registered nodes without a pending deregistration to\n', '    /// deregister\n', '    modifier onlyDeregisterable(address _darknodeID) {\n', '        require(isDeregisterable(_darknodeID), "must be deregisterable");\n', '        _;\n', '    }\n', '\n', '    /// @notice Only allow the Slasher contract.\n', '    modifier onlySlasher() {\n', '        require(slasher == msg.sender, "must be slasher");\n', '        _;\n', '    }\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _renAddress The address of the RepublicToken contract.\n', '    /// @param _storeAddress The address of the DarknodeRegistryStore contract.\n', '    /// @param _minimumBond The minimum bond amount that can be submitted by a\n', '    ///        Darknode.\n', '    /// @param _minimumPodSize The minimum size of a Darknode pod.\n', '    /// @param _minimumEpochInterval The minimum number of blocks between\n', '    ///        epochs.\n', '    constructor(\n', '        string _VERSION,\n', '        RepublicToken _renAddress,\n', '        DarknodeRegistryStore _storeAddress,\n', '        uint256 _minimumBond,\n', '        uint256 _minimumPodSize,\n', '        uint256 _minimumEpochInterval\n', '    ) public {\n', '        VERSION = _VERSION;\n', '\n', '        store = _storeAddress;\n', '        ren = _renAddress;\n', '\n', '        minimumBond = _minimumBond;\n', '        nextMinimumBond = minimumBond;\n', '\n', '        minimumPodSize = _minimumPodSize;\n', '        nextMinimumPodSize = minimumPodSize;\n', '\n', '        minimumEpochInterval = _minimumEpochInterval;\n', '        nextMinimumEpochInterval = minimumEpochInterval;\n', '\n', '        currentEpoch = Epoch({\n', '            epochhash: uint256(blockhash(block.number - 1)),\n', '            blocknumber: block.number\n', '        });\n', '        numDarknodes = 0;\n', '        numDarknodesNextEpoch = 0;\n', '        numDarknodesPreviousEpoch = 0;\n', '    }\n', '\n', '    /// @notice Register a darknode and transfer the bond to this contract. The\n', '    /// caller must provide a public encryption key for the darknode as well as\n', '    /// a bond in REN. The bond must be provided as an ERC20 allowance. The dark\n', '    /// node will remain pending registration until the next epoch. Only after\n', '    /// this period can the darknode be deregistered. The caller of this method\n', '    /// will be stored as the owner of the darknode.\n', '    ///\n', '    /// @param _darknodeID The darknode ID that will be registered.\n', '    /// @param _publicKey The public key of the darknode. It is stored to allow\n', '    ///        other darknodes and traders to encrypt messages to the trader.\n', '    /// @param _bond The bond that will be paid. It must be greater than, or\n', '    ///        equal to, the minimum bond.\n', '    function register(address _darknodeID, bytes _publicKey, uint256 _bond) external onlyRefunded(_darknodeID) {\n', '        // REN allowance\n', '        require(_bond >= minimumBond, "insufficient bond");\n', '        // require(ren.allowance(msg.sender, address(this)) >= _bond);\n', '        require(ren.transferFrom(msg.sender, address(this), _bond), "bond transfer failed");\n', '        ren.transfer(address(store), _bond);\n', '\n', '        // Flag this darknode for registration\n', '        store.appendDarknode(\n', '            _darknodeID,\n', '            msg.sender,\n', '            _bond,\n', '            _publicKey,\n', '            currentEpoch.blocknumber + minimumEpochInterval,\n', '            0\n', '        );\n', '\n', '        numDarknodesNextEpoch += 1;\n', '\n', '        // Emit an event.\n', '        emit LogDarknodeRegistered(_darknodeID, _bond);\n', '    }\n', '\n', '    /// @notice Deregister a darknode. The darknode will not be deregistered\n', '    /// until the end of the epoch. After another epoch, the bond can be\n', '    /// refunded by calling the refund method.\n', '    /// @param _darknodeID The darknode ID that will be deregistered. The caller\n', '    ///        of this method store.darknodeRegisteredAt(_darknodeID) must be\n', '    //         the owner of this darknode.\n', '    function deregister(address _darknodeID) external onlyDeregisterable(_darknodeID) onlyDarknodeOwner(_darknodeID) {\n', '        // Flag the darknode for deregistration\n', '        store.updateDarknodeDeregisteredAt(_darknodeID, currentEpoch.blocknumber + minimumEpochInterval);\n', '        numDarknodesNextEpoch -= 1;\n', '\n', '        // Emit an event\n', '        emit LogDarknodeDeregistered(_darknodeID);\n', '    }\n', '\n', '    /// @notice Progress the epoch if it is possible to do so. This captures\n', '    /// the current timestamp and current blockhash and overrides the current\n', '    /// epoch.\n', '    function epoch() external {\n', '        if (previousEpoch.blocknumber == 0) {\n', '            // The first epoch must be called by the owner of the contract\n', '            require(msg.sender == owner, "not authorized (first epochs)");\n', '        }\n', '\n', '        // Require that the epoch interval has passed\n', '        require(block.number >= currentEpoch.blocknumber + minimumEpochInterval, "epoch interval has not passed");\n', '        uint256 epochhash = uint256(blockhash(block.number - 1));\n', '\n', '        // Update the epoch hash and timestamp\n', '        previousEpoch = currentEpoch;\n', '        currentEpoch = Epoch({\n', '            epochhash: epochhash,\n', '            blocknumber: block.number\n', '        });\n', '\n', '        // Update the registry information\n', '        numDarknodesPreviousEpoch = numDarknodes;\n', '        numDarknodes = numDarknodesNextEpoch;\n', '\n', '        // If any update functions have been called, update the values now\n', '        if (nextMinimumBond != minimumBond) {\n', '            minimumBond = nextMinimumBond;\n', '            emit LogMinimumBondUpdated(minimumBond, nextMinimumBond);\n', '        }\n', '        if (nextMinimumPodSize != minimumPodSize) {\n', '            minimumPodSize = nextMinimumPodSize;\n', '            emit LogMinimumPodSizeUpdated(minimumPodSize, nextMinimumPodSize);\n', '        }\n', '        if (nextMinimumEpochInterval != minimumEpochInterval) {\n', '            minimumEpochInterval = nextMinimumEpochInterval;\n', '            emit LogMinimumEpochIntervalUpdated(minimumEpochInterval, nextMinimumEpochInterval);\n', '        }\n', '        if (nextSlasher != slasher) {\n', '            slasher = nextSlasher;\n', '            emit LogSlasherUpdated(slasher, nextSlasher);\n', '        }\n', '\n', '        // Emit an event\n', '        emit LogNewEpoch();\n', '    }\n', '\n', '    /// @notice Allows the contract owner to transfer ownership of the\n', '    /// DarknodeRegistryStore.\n', '    /// @param _newOwner The address to transfer the ownership to.\n', '    function transferStoreOwnership(address _newOwner) external onlyOwner {\n', '        store.transferOwnership(_newOwner);\n', '    }\n', '\n', '    /// @notice Allows the contract owner to update the minimum bond.\n', '    /// @param _nextMinimumBond The minimum bond amount that can be submitted by\n', '    ///        a darknode.\n', '    function updateMinimumBond(uint256 _nextMinimumBond) external onlyOwner {\n', '        // Will be updated next epoch\n', '        nextMinimumBond = _nextMinimumBond;\n', '    }\n', '\n', '    /// @notice Allows the contract owner to update the minimum pod size.\n', '    /// @param _nextMinimumPodSize The minimum size of a pod.\n', '    function updateMinimumPodSize(uint256 _nextMinimumPodSize) external onlyOwner {\n', '        // Will be updated next epoch\n', '        nextMinimumPodSize = _nextMinimumPodSize;\n', '    }\n', '\n', '    /// @notice Allows the contract owner to update the minimum epoch interval.\n', '    /// @param _nextMinimumEpochInterval The minimum number of blocks between epochs.\n', '    function updateMinimumEpochInterval(uint256 _nextMinimumEpochInterval) external onlyOwner {\n', '        // Will be updated next epoch\n', '        nextMinimumEpochInterval = _nextMinimumEpochInterval;\n', '    }\n', '\n', '    /// @notice Allow the contract owner to update the DarknodeSlasher contract\n', '    /// address.\n', '    /// @param _slasher The new slasher address.\n', '    function updateSlasher(address _slasher) external onlyOwner {\n', '        nextSlasher = _slasher;\n', '    }\n', '\n', '    /// @notice Allow the DarknodeSlasher contract to slash half of a darknode&#39;s\n', '    /// bond and deregister it. The bond is distributed as follows:\n', '    ///   1/2 is kept by the guilty prover\n', '    ///   1/8 is rewarded to the first challenger\n', '    ///   1/8 is rewarded to the second challenger\n', '    ///   1/4 becomes unassigned\n', '    /// @param _prover The guilty prover whose bond is being slashed\n', '    /// @param _challenger1 The first of the two darknodes who submitted the challenge\n', '    /// @param _challenger2 The second of the two darknodes who submitted the challenge\n', '    function slash(address _prover, address _challenger1, address _challenger2)\n', '        external\n', '        onlySlasher\n', '    {\n', '        uint256 penalty = store.darknodeBond(_prover) / 2;\n', '        uint256 reward = penalty / 4;\n', '\n', '        // Slash the bond of the failed prover in half\n', '        store.updateDarknodeBond(_prover, penalty);\n', '\n', '        // If the darknode has not been deregistered then deregister it\n', '        if (isDeregisterable(_prover)) {\n', '            store.updateDarknodeDeregisteredAt(_prover, currentEpoch.blocknumber + minimumEpochInterval);\n', '            numDarknodesNextEpoch -= 1;\n', '            emit LogDarknodeDeregistered(_prover);\n', '        }\n', '\n', '        // Reward the challengers with less than the penalty so that it is not\n', '        // worth challenging yourself\n', '        ren.transfer(store.darknodeOwner(_challenger1), reward);\n', '        ren.transfer(store.darknodeOwner(_challenger2), reward);\n', '    }\n', '\n', '    /// @notice Refund the bond of a deregistered darknode. This will make the\n', '    /// darknode available for registration again. Anyone can call this function\n', '    /// but the bond will always be refunded to the darknode owner.\n', '    ///\n', '    /// @param _darknodeID The darknode ID that will be refunded. The caller\n', '    ///        of this method must be the owner of this darknode.\n', '    function refund(address _darknodeID) external onlyRefundable(_darknodeID) {\n', '        address darknodeOwner = store.darknodeOwner(_darknodeID);\n', '\n', '        // Remember the bond amount\n', '        uint256 amount = store.darknodeBond(_darknodeID);\n', '\n', '        // Erase the darknode from the registry\n', '        store.removeDarknode(_darknodeID);\n', '\n', '        // Refund the owner by transferring REN\n', '        ren.transfer(darknodeOwner, amount);\n', '\n', '        // Emit an event.\n', '        emit LogDarknodeOwnerRefunded(darknodeOwner, amount);\n', '    }\n', '\n', '    /// @notice Retrieves the address of the account that registered a darknode.\n', '    /// @param _darknodeID The ID of the darknode to retrieve the owner for.\n', '    function getDarknodeOwner(address _darknodeID) external view returns (address) {\n', '        return store.darknodeOwner(_darknodeID);\n', '    }\n', '\n', '    /// @notice Retrieves the bond amount of a darknode in 10^-18 REN.\n', '    /// @param _darknodeID The ID of the darknode to retrieve the bond for.\n', '    function getDarknodeBond(address _darknodeID) external view returns (uint256) {\n', '        return store.darknodeBond(_darknodeID);\n', '    }\n', '\n', '    /// @notice Retrieves the encryption public key of the darknode.\n', '    /// @param _darknodeID The ID of the darknode to retrieve the public key for.\n', '    function getDarknodePublicKey(address _darknodeID) external view returns (bytes) {\n', '        return store.darknodePublicKey(_darknodeID);\n', '    }\n', '\n', '    /// @notice Retrieves a list of darknodes which are registered for the\n', '    /// current epoch.\n', '    /// @param _start A darknode ID used as an offset for the list. If _start is\n', '    ///        0x0, the first dark node will be used. _start won&#39;t be\n', '    ///        included it is not registered for the epoch.\n', '    /// @param _count The number of darknodes to retrieve starting from _start.\n', '    ///        If _count is 0, all of the darknodes from _start are\n', '    ///        retrieved. If _count is more than the remaining number of\n', '    ///        registered darknodes, the rest of the list will contain\n', '    ///        0x0s.\n', '    function getDarknodes(address _start, uint256 _count) external view returns (address[]) {\n', '        uint256 count = _count;\n', '        if (count == 0) {\n', '            count = numDarknodes;\n', '        }\n', '        return getDarknodesFromEpochs(_start, count, false);\n', '    }\n', '\n', '    /// @notice Retrieves a list of darknodes which were registered for the\n', '    /// previous epoch. See `getDarknodes` for the parameter documentation.\n', '    function getPreviousDarknodes(address _start, uint256 _count) external view returns (address[]) {\n', '        uint256 count = _count;\n', '        if (count == 0) {\n', '            count = numDarknodesPreviousEpoch;\n', '        }\n', '        return getDarknodesFromEpochs(_start, count, true);\n', '    }\n', '\n', '    /// @notice Returns whether a darknode is scheduled to become registered\n', '    /// at next epoch.\n', '    /// @param _darknodeID The ID of the darknode to return\n', '    function isPendingRegistration(address _darknodeID) external view returns (bool) {\n', '        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\n', '        return registeredAt != 0 && registeredAt > currentEpoch.blocknumber;\n', '    }\n', '\n', '    /// @notice Returns if a darknode is in the pending deregistered state. In\n', '    /// this state a darknode is still considered registered.\n', '    function isPendingDeregistration(address _darknodeID) external view returns (bool) {\n', '        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n', '        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocknumber;\n', '    }\n', '\n', '    /// @notice Returns if a darknode is in the deregistered state.\n', '    function isDeregistered(address _darknodeID) public view returns (bool) {\n', '        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n', '        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocknumber;\n', '    }\n', '\n', '    /// @notice Returns if a darknode can be deregistered. This is true if the\n', '    /// darknodes is in the registered state and has not attempted to\n', '    /// deregister yet.\n', '    function isDeregisterable(address _darknodeID) public view returns (bool) {\n', '        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n', '        // The Darknode is currently in the registered state and has not been\n', '        // transitioned to the pending deregistration, or deregistered, state\n', '        return isRegistered(_darknodeID) && deregisteredAt == 0;\n', '    }\n', '\n', '    /// @notice Returns if a darknode is in the refunded state. This is true\n', '    /// for darknodes that have never been registered, or darknodes that have\n', '    /// been deregistered and refunded.\n', '    function isRefunded(address _darknodeID) public view returns (bool) {\n', '        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\n', '        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n', '        return registeredAt == 0 && deregisteredAt == 0;\n', '    }\n', '\n', '    /// @notice Returns if a darknode is refundable. This is true for darknodes\n', '    /// that have been in the deregistered state for one full epoch.\n', '    function isRefundable(address _darknodeID) public view returns (bool) {\n', '        return isDeregistered(_darknodeID) && store.darknodeDeregisteredAt(_darknodeID) <= previousEpoch.blocknumber;\n', '    }\n', '\n', '    /// @notice Returns if a darknode is in the registered state.\n', '    function isRegistered(address _darknodeID) public view returns (bool) {\n', '        return isRegisteredInEpoch(_darknodeID, currentEpoch);\n', '    }\n', '\n', '    /// @notice Returns if a darknode was in the registered state last epoch.\n', '    function isRegisteredInPreviousEpoch(address _darknodeID) public view returns (bool) {\n', '        return isRegisteredInEpoch(_darknodeID, previousEpoch);\n', '    }\n', '\n', '    /// @notice Returns if a darknode was in the registered state for a given\n', '    /// epoch.\n', '    /// @param _darknodeID The ID of the darknode\n', '    /// @param _epoch One of currentEpoch, previousEpoch\n', '    function isRegisteredInEpoch(address _darknodeID, Epoch _epoch) private view returns (bool) {\n', '        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\n', '        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n', '        bool registered = registeredAt != 0 && registeredAt <= _epoch.blocknumber;\n', '        bool notDeregistered = deregisteredAt == 0 || deregisteredAt > _epoch.blocknumber;\n', '        // The Darknode has been registered and has not yet been deregistered,\n', '        // although it might be pending deregistration\n', '        return registered && notDeregistered;\n', '    }\n', '\n', '    /// @notice Returns a list of darknodes registered for either the current\n', '    /// or the previous epoch. See `getDarknodes` for documentation on the\n', '    /// parameters `_start` and `_count`.\n', '    /// @param _usePreviousEpoch If true, use the previous epoch, otherwise use\n', '    ///        the current epoch.\n', '    function getDarknodesFromEpochs(address _start, uint256 _count, bool _usePreviousEpoch) private view returns (address[]) {\n', '        uint256 count = _count;\n', '        if (count == 0) {\n', '            count = numDarknodes;\n', '        }\n', '\n', '        address[] memory nodes = new address[](count);\n', '\n', '        // Begin with the first node in the list\n', '        uint256 n = 0;\n', '        address next = _start;\n', '        if (next == 0x0) {\n', '            next = store.begin();\n', '        }\n', '\n', '        // Iterate until all registered Darknodes have been collected\n', '        while (n < count) {\n', '            if (next == 0x0) {\n', '                break;\n', '            }\n', '            // Only include Darknodes that are currently registered\n', '            bool includeNext;\n', '            if (_usePreviousEpoch) {\n', '                includeNext = isRegisteredInPreviousEpoch(next);\n', '            } else {\n', '                includeNext = isRegistered(next);\n', '            }\n', '            if (!includeNext) {\n', '                next = store.next(next);\n', '                continue;\n', '            }\n', '            nodes[n] = next;\n', '            next = store.next(next);\n', '            n += 1;\n', '        }\n', '        return nodes;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '/// @notice Implements safeTransfer, safeTransferFrom and\n', '/// safeApprove for CompatibleERC20.\n', '///\n', '/// See https://github.com/ethereum/solidity/issues/4116\n', '///\n', '/// This library allows interacting with ERC20 tokens that implement any of\n', '/// these interfaces:\n', '///\n', '/// (1) transfer returns true on success, false on failure\n', '/// (2) transfer returns true on success, reverts on failure\n', '/// (3) transfer returns nothing on success, reverts on failure\n', '///\n', '/// Additionally, safeTransferFromWithFees will return the final token\n', '/// value received after accounting for token fees.\n', 'library CompatibleERC20Functions {\n', '    using SafeMath for uint256;\n', '\n', '    /// @notice Calls transfer on the token and reverts if the call fails.\n', '    function safeTransfer(address token, address to, uint256 amount) internal {\n', '        CompatibleERC20(token).transfer(to, amount);\n', '        require(previousReturnValue(), "transfer failed");\n', '    }\n', '\n', '    /// @notice Calls transferFrom on the token and reverts if the call fails.\n', '    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n', '        CompatibleERC20(token).transferFrom(from, to, amount);\n', '        require(previousReturnValue(), "transferFrom failed");\n', '    }\n', '\n', '    /// @notice Calls approve on the token and reverts if the call fails.\n', '    function safeApprove(address token, address spender, uint256 amount) internal {\n', '        CompatibleERC20(token).approve(spender, amount);\n', '        require(previousReturnValue(), "approve failed");\n', '    }\n', '\n', '    /// @notice Calls transferFrom on the token, reverts if the call fails and\n', '    /// returns the value transferred after fees.\n', '    function safeTransferFromWithFees(address token, address from, address to, uint256 amount) internal returns (uint256) {\n', '        uint256 balancesBefore = CompatibleERC20(token).balanceOf(to);\n', '        CompatibleERC20(token).transferFrom(from, to, amount);\n', '        require(previousReturnValue(), "transferFrom failed");\n', '        uint256 balancesAfter = CompatibleERC20(token).balanceOf(to);\n', '        return Math.min256(amount, balancesAfter.sub(balancesBefore));\n', '    }\n', '\n', '    /// @notice Checks the return value of the previous function. Returns true\n', '    /// if the previous function returned 32 non-zero bytes or returned zero\n', '    /// bytes.\n', '    function previousReturnValue() private pure returns (bool)\n', '    {\n', '        uint256 returnData = 0;\n', '\n', '        assembly { /* solium-disable-line security/no-inline-assembly */\n', '            // Switch on the number of bytes returned by the previous call\n', '            switch returndatasize\n', '\n', '            // 0 bytes: ERC20 of type (3), did not throw\n', '            case 0 {\n', '                returnData := 1\n', '            }\n', '\n', '            // 32 bytes: ERC20 of types (1) or (2)\n', '            case 32 {\n', '                // Copy the return data into scratch space\n', '                returndatacopy(0x0, 0x0, 32)\n', '\n', '                // Load  the return data into returnData\n', '                returnData := mload(0x0)\n', '            }\n', '\n', '            // Other return size: return false\n', '            default { }\n', '        }\n', '\n', '        return returnData != 0;\n', '    }\n', '}\n', '\n', '/// @notice ERC20 interface which doesn&#39;t specify the return type for transfer,\n', '/// transferFrom and approve.\n', 'interface CompatibleERC20 {\n', '    // Modified to not return boolean\n', '    function transfer(address to, uint256 value) external;\n', '    function transferFrom(address from, address to, uint256 value) external;\n', '    function approve(address spender, uint256 value) external;\n', '\n', '    // Not modifier\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/// @notice The DarknodeRewardVault contract is responsible for holding fees\n', '/// for darknodes for settling orders. Fees can be withdrawn to the address of\n', '/// the darknode&#39;s operator. Fees can be in ETH or in ERC20 tokens.\n', '/// Docs: https://github.com/republicprotocol/republic-sol/blob/master/docs/02-darknode-reward-vault.md\n', 'contract DarknodeRewardVault is Ownable {\n', '    using SafeMath for uint256;\n', '    using CompatibleERC20Functions for CompatibleERC20;\n', '\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    /// @notice The special address for Ether.\n', '    address constant public ETHEREUM = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '\n', '    DarknodeRegistry public darknodeRegistry;\n', '\n', '    mapping(address => mapping(address => uint256)) public darknodeBalances;\n', '\n', '    event LogDarknodeRegistryUpdated(DarknodeRegistry previousDarknodeRegistry, DarknodeRegistry nextDarknodeRegistry);\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _darknodeRegistry The DarknodeRegistry contract that is used by\n', '    ///        the vault to lookup Darknode owners.\n', '    constructor(string _VERSION, DarknodeRegistry _darknodeRegistry) public {\n', '        VERSION = _VERSION;\n', '        darknodeRegistry = _darknodeRegistry;\n', '    }\n', '\n', '    function updateDarknodeRegistry(DarknodeRegistry _newDarknodeRegistry) public onlyOwner {\n', '        emit LogDarknodeRegistryUpdated(darknodeRegistry, _newDarknodeRegistry);\n', '        darknodeRegistry = _newDarknodeRegistry;\n', '    }\n', '\n', '    /// @notice Deposit fees into the vault for a Darknode. The Darknode\n', '    /// registration is not checked (to reduce gas fees); the caller must be\n', '    /// careful not to call this function for a Darknode that is not registered\n', '    /// otherwise any fees deposited to that Darknode can be withdrawn by a\n', '    /// malicious adversary (by registering the Darknode before the honest\n', '    /// party and claiming ownership).\n', '    ///\n', '    /// @param _darknode The address of the Darknode that will receive the\n', '    ///        fees.\n', '    /// @param _token The address of the ERC20 token being used to pay the fee.\n', '    ///        A special address is used for Ether.\n', '    /// @param _value The amount of fees in the smallest unit of the token.\n', '    function deposit(address _darknode, ERC20 _token, uint256 _value) public payable {\n', '        uint256 receivedValue = _value;\n', '        if (address(_token) == ETHEREUM) {\n', '            require(msg.value == _value, "mismatched ether value");\n', '        } else {\n', '            require(msg.value == 0, "unexpected ether value");\n', '            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(msg.sender, address(this), _value);\n', '        }\n', '        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(receivedValue);\n', '    }\n', '\n', '    /// @notice Withdraw fees earned by a Darknode. The fees will be sent to\n', '    /// the owner of the Darknode. If a Darknode is not registered the fees\n', '    /// cannot be withdrawn.\n', '    ///\n', '    /// @param _darknode The address of the Darknode whose fees are being\n', '    ///        withdrawn. The owner of this Darknode will receive the fees.\n', '    /// @param _token The address of the ERC20 token to withdraw.\n', '    function withdraw(address _darknode, ERC20 _token) public {\n', '        address darknodeOwner = darknodeRegistry.getDarknodeOwner(address(_darknode));\n', '\n', '        require(darknodeOwner != 0x0, "invalid darknode owner");\n', '\n', '        uint256 value = darknodeBalances[_darknode][_token];\n', '        darknodeBalances[_darknode][_token] = 0;\n', '\n', '        if (address(_token) == ETHEREUM) {\n', '            darknodeOwner.transfer(value);\n', '        } else {\n', '            CompatibleERC20(_token).safeTransfer(darknodeOwner, value);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/// @notice The BrokerVerifier interface defines the functions that a settlement\n', '/// layer&#39;s broker verifier contract must implement.\n', 'interface BrokerVerifier {\n', '\n', '    /// @notice The function signature that will be called when a trader opens\n', '    /// an order.\n', '    ///\n', '    /// @param _trader The trader requesting the withdrawal.\n', '    /// @param _signature The 65-byte signature from the broker.\n', '    /// @param _orderID The 32-byte order ID.\n', '    function verifyOpenSignature(\n', '        address _trader,\n', '        bytes _signature,\n', '        bytes32 _orderID\n', '    ) external returns (bool);\n', '}\n', '\n', '/// @notice The Settlement interface defines the functions that a settlement\n', '/// layer must implement.\n', '/// Docs: https://github.com/republicprotocol/republic-sol/blob/nightly/docs/05-settlement.md\n', 'interface Settlement {\n', '    function submitOrder(\n', '        bytes _details,\n', '        uint64 _settlementID,\n', '        uint64 _tokens,\n', '        uint256 _price,\n', '        uint256 _volume,\n', '        uint256 _minimumVolume\n', '    ) external;\n', '\n', '    function submissionGasPriceLimit() external view returns (uint256);\n', '\n', '    function settle(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID\n', '    ) external;\n', '\n', '    /// @notice orderStatus should return the status of the order, which should\n', '    /// be:\n', '    ///     0  - Order not seen before\n', '    ///     1  - Order details submitted\n', '    ///     >1 - Order settled, or settlement no longer possible\n', '    function orderStatus(bytes32 _orderID) external view returns (uint8);\n', '}\n', '\n', '/// @notice SettlementRegistry allows a Settlement layer to register the\n', '/// contracts used for match settlement and for broker signature verification.\n', 'contract SettlementRegistry is Ownable {\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    struct SettlementDetails {\n', '        bool registered;\n', '        Settlement settlementContract;\n', '        BrokerVerifier brokerVerifierContract;\n', '    }\n', '\n', '    // Settlement IDs are 64-bit unsigned numbers\n', '    mapping(uint64 => SettlementDetails) public settlementDetails;\n', '\n', '    // Events\n', '    event LogSettlementRegistered(uint64 settlementID, Settlement settlementContract, BrokerVerifier brokerVerifierContract);\n', '    event LogSettlementUpdated(uint64 settlementID, Settlement settlementContract, BrokerVerifier brokerVerifierContract);\n', '    event LogSettlementDeregistered(uint64 settlementID);\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    constructor(string _VERSION) public {\n', '        VERSION = _VERSION;\n', '    }\n', '\n', '    /// @notice Returns the settlement contract of a settlement layer.\n', '    function settlementRegistration(uint64 _settlementID) external view returns (bool) {\n', '        return settlementDetails[_settlementID].registered;\n', '    }\n', '\n', '    /// @notice Returns the settlement contract of a settlement layer.\n', '    function settlementContract(uint64 _settlementID) external view returns (Settlement) {\n', '        return settlementDetails[_settlementID].settlementContract;\n', '    }\n', '\n', '    /// @notice Returns the broker verifier contract of a settlement layer.\n', '    function brokerVerifierContract(uint64 _settlementID) external view returns (BrokerVerifier) {\n', '        return settlementDetails[_settlementID].brokerVerifierContract;\n', '    }\n', '\n', '    /// @param _settlementID A unique 64-bit settlement identifier.\n', '    /// @param _settlementContract The address to use for settling matches.\n', '    /// @param _brokerVerifierContract The decimals to use for verifying\n', '    ///        broker signatures.\n', '    function registerSettlement(uint64 _settlementID, Settlement _settlementContract, BrokerVerifier _brokerVerifierContract) public onlyOwner {\n', '        bool alreadyRegistered = settlementDetails[_settlementID].registered;\n', '        \n', '        settlementDetails[_settlementID] = SettlementDetails({\n', '            registered: true,\n', '            settlementContract: _settlementContract,\n', '            brokerVerifierContract: _brokerVerifierContract\n', '        });\n', '\n', '        if (alreadyRegistered) {\n', '            emit LogSettlementUpdated(_settlementID, _settlementContract, _brokerVerifierContract);\n', '        } else {\n', '            emit LogSettlementRegistered(_settlementID, _settlementContract, _brokerVerifierContract);\n', '        }\n', '    }\n', '\n', '    /// @notice Deregisteres a settlement layer, clearing the details.\n', '    /// @param _settlementID The unique 64-bit settlement identifier.\n', '    function deregisterSettlement(uint64 _settlementID) external onlyOwner {\n', '        require(settlementDetails[_settlementID].registered, "not registered");\n', '\n', '        delete settlementDetails[_settlementID];\n', '\n', '        emit LogSettlementDeregistered(_settlementID);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    // Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(\n', '      abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)\n', '    );\n', '  }\n', '}\n', '\n', 'library Utils {\n', '\n', '    /**\n', '     * @notice Converts a number to its string/bytes representation\n', '     *\n', '     * @param _v the uint to convert\n', '     */\n', '    function uintToBytes(uint256 _v) internal pure returns (bytes) {\n', '        uint256 v = _v;\n', '        if (v == 0) {\n', '            return "0";\n', '        }\n', '\n', '        uint256 digits = 0;\n', '        uint256 v2 = v;\n', '        while (v2 > 0) {\n', '            v2 /= 10;\n', '            digits += 1;\n', '        }\n', '\n', '        bytes memory result = new bytes(digits);\n', '\n', '        for (uint256 i = 0; i < digits; i++) {\n', '            result[digits - i - 1] = bytes1((v % 10) + 48);\n', '            v /= 10;\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * @notice Retrieves the address from a signature\n', '     *\n', '     * @param _hash the message that was signed (any length of bytes)\n', '     * @param _signature the signature (65 bytes)\n', '     */\n', '    function addr(bytes _hash, bytes _signature) internal pure returns (address) {\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n";\n', '        bytes memory encoded = abi.encodePacked(prefix, uintToBytes(_hash.length), _hash);\n', '        bytes32 prefixedHash = keccak256(encoded);\n', '\n', '        return ECRecovery.recover(prefixedHash, _signature);\n', '    }\n', '\n', '}\n', '\n', '/// @notice The Orderbook contract stores the state and priority of orders and\n', '/// allows the Darknodes to easily reach consensus. Eventually, this contract\n', '/// will only store a subset of order states, such as cancellation, to improve\n', '/// the throughput of orders.\n', 'contract Orderbook is Ownable {\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    /// @notice OrderState enumerates the possible states of an order. All\n', '    /// orders default to the Undefined state.\n', '    enum OrderState {Undefined, Open, Confirmed, Canceled}\n', '\n', '    /// @notice Order stores a subset of the public data associated with an order.\n', '    struct Order {\n', '        OrderState state;     // State of the order\n', '        address trader;       // Trader that owns the order\n', '        address confirmer;    // Darknode that confirmed the order in a match\n', '        uint64 settlementID;  // The settlement that signed the order opening\n', '        uint256 priority;     // Logical time priority of this order\n', '        uint256 blockNumber;  // Block number of the most recent state change\n', '        bytes32 matchedOrder; // Order confirmed in a match with this order\n', '    }\n', '\n', '    DarknodeRegistry public darknodeRegistry;\n', '    SettlementRegistry public settlementRegistry;\n', '\n', '    bytes32[] private orderbook;\n', '\n', '    // Order details are exposed through directly accessing this mapping, or\n', '    // through the getter functions below for each of the order&#39;s fields.\n', '    mapping(bytes32 => Order) public orders;\n', '\n', '    event LogFeeUpdated(uint256 previousFee, uint256 nextFee);\n', '    event LogDarknodeRegistryUpdated(DarknodeRegistry previousDarknodeRegistry, DarknodeRegistry nextDarknodeRegistry);\n', '\n', '    /// @notice Only allow registered dark nodes.\n', '    modifier onlyDarknode(address _sender) {\n', '        require(darknodeRegistry.isRegistered(address(_sender)), "must be registered darknode");\n', '        _;\n', '    }\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _darknodeRegistry The address of the DarknodeRegistry contract.\n', '    /// @param _settlementRegistry The address of the SettlementRegistry\n', '    ///        contract.\n', '    constructor(\n', '        string _VERSION,\n', '        DarknodeRegistry _darknodeRegistry,\n', '        SettlementRegistry _settlementRegistry\n', '    ) public {\n', '        VERSION = _VERSION;\n', '        darknodeRegistry = _darknodeRegistry;\n', '        settlementRegistry = _settlementRegistry;\n', '    }\n', '\n', '    /// @notice Allows the owner to update the address of the DarknodeRegistry\n', '    /// contract.\n', '    function updateDarknodeRegistry(DarknodeRegistry _newDarknodeRegistry) external onlyOwner {\n', '        emit LogDarknodeRegistryUpdated(darknodeRegistry, _newDarknodeRegistry);\n', '        darknodeRegistry = _newDarknodeRegistry;\n', '    }\n', '\n', '    /// @notice Open an order in the orderbook. The order must be in the\n', '    /// Undefined state.\n', '    ///\n', '    /// @param _signature Signature of the message that defines the trader. The\n', '    ///        message is "Republic Protocol: open: {orderId}".\n', '    /// @param _orderID The hash of the order.\n', '    function openOrder(uint64 _settlementID, bytes _signature, bytes32 _orderID) external {\n', '        require(orders[_orderID].state == OrderState.Undefined, "invalid order status");\n', '\n', '        address trader = msg.sender;\n', '\n', '        // Verify the order signature\n', '        require(settlementRegistry.settlementRegistration(_settlementID), "settlement not registered");\n', '        BrokerVerifier brokerVerifier = settlementRegistry.brokerVerifierContract(_settlementID);\n', '        require(brokerVerifier.verifyOpenSignature(trader, _signature, _orderID), "invalid broker signature");\n', '\n', '        orders[_orderID] = Order({\n', '            state: OrderState.Open,\n', '            trader: trader,\n', '            confirmer: 0x0,\n', '            settlementID: _settlementID,\n', '            priority: orderbook.length + 1,\n', '            blockNumber: block.number,\n', '            matchedOrder: 0x0\n', '        });\n', '\n', '        orderbook.push(_orderID);\n', '    }\n', '\n', '    /// @notice Confirm an order match between orders. The confirmer must be a\n', '    /// registered Darknode and the orders must be in the Open state. A\n', '    /// malicious confirmation by a Darknode will result in a bond slash of the\n', '    /// Darknode.\n', '    ///\n', '    /// @param _orderID The hash of the order.\n', '    /// @param _matchedOrderID The hashes of the matching order.\n', '    function confirmOrder(bytes32 _orderID, bytes32 _matchedOrderID) external onlyDarknode(msg.sender) {\n', '        require(orders[_orderID].state == OrderState.Open, "invalid order status");\n', '        require(orders[_matchedOrderID].state == OrderState.Open, "invalid order status");\n', '\n', '        orders[_orderID].state = OrderState.Confirmed;\n', '        orders[_orderID].confirmer = msg.sender;\n', '        orders[_orderID].matchedOrder = _matchedOrderID;\n', '        orders[_orderID].blockNumber = block.number;\n', '\n', '        orders[_matchedOrderID].state = OrderState.Confirmed;\n', '        orders[_matchedOrderID].confirmer = msg.sender;\n', '        orders[_matchedOrderID].matchedOrder = _orderID;\n', '        orders[_matchedOrderID].blockNumber = block.number;\n', '    }\n', '\n', '    /// @notice Cancel an open order in the orderbook. An order can be cancelled\n', '    /// by the trader who opened the order, or by the broker verifier contract.\n', '    /// This allows the settlement layer to implement their own logic for\n', '    /// cancelling orders without trader interaction (e.g. to ban a trader from\n', '    /// a specific darkpool, or to use multiple order-matching platforms)\n', '    ///\n', '    /// @param _orderID The hash of the order.\n', '    function cancelOrder(bytes32 _orderID) external {\n', '        require(orders[_orderID].state == OrderState.Open, "invalid order state");\n', '\n', '        // Require the msg.sender to be the trader or the broker verifier\n', '        address brokerVerifier = address(settlementRegistry.brokerVerifierContract(orders[_orderID].settlementID));\n', '        require(msg.sender == orders[_orderID].trader || msg.sender == brokerVerifier, "not authorized");\n', '\n', '        orders[_orderID].state = OrderState.Canceled;\n', '        orders[_orderID].blockNumber = block.number;\n', '    }\n', '\n', '    /// @notice returns status of the given orderID.\n', '    function orderState(bytes32 _orderID) external view returns (OrderState) {\n', '        return orders[_orderID].state;\n', '    }\n', '\n', '    /// @notice returns a list of matched orders to the given orderID.\n', '    function orderMatch(bytes32 _orderID) external view returns (bytes32) {\n', '        return orders[_orderID].matchedOrder;\n', '    }\n', '\n', '    /// @notice returns the priority of the given orderID.\n', '    /// The priority is the index of the order in the orderbook.\n', '    function orderPriority(bytes32 _orderID) external view returns (uint256) {\n', '        return orders[_orderID].priority;\n', '    }\n', '\n', '    /// @notice returns the trader of the given orderID.\n', '    /// Trader is the one who signs the message and does the actual trading.\n', '    function orderTrader(bytes32 _orderID) external view returns (address) {\n', '        return orders[_orderID].trader;\n', '    }\n', '\n', '    /// @notice returns the darknode address which confirms the given orderID.\n', '    function orderConfirmer(bytes32 _orderID) external view returns (address) {\n', '        return orders[_orderID].confirmer;\n', '    }\n', '\n', '    /// @notice returns the block number when the order being last modified.\n', '    function orderBlockNumber(bytes32 _orderID) external view returns (uint256) {\n', '        return orders[_orderID].blockNumber;\n', '    }\n', '\n', '    /// @notice returns the block depth of the orderId\n', '    function orderDepth(bytes32 _orderID) external view returns (uint256) {\n', '        if (orders[_orderID].blockNumber == 0) {\n', '            return 0;\n', '        }\n', '        return (block.number - orders[_orderID].blockNumber);\n', '    }\n', '\n', '    /// @notice returns the number of orders in the orderbook\n', '    function ordersCount() external view returns (uint256) {\n', '        return orderbook.length;\n', '    }\n', '\n', '    /// @notice returns order details of the orders starting from the offset.\n', '    function getOrders(uint256 _offset, uint256 _limit) external view returns (bytes32[], address[], uint8[]) {\n', '        if (_offset >= orderbook.length) {\n', '            return;\n', '        }\n', '\n', '        // If the provided limit is more than the number of orders after the offset,\n', '        // decrease the limit\n', '        uint256 limit = _limit;\n', '        if (_offset + limit > orderbook.length) {\n', '            limit = orderbook.length - _offset;\n', '        }\n', '\n', '        bytes32[] memory orderIDs = new bytes32[](limit);\n', '        address[] memory traderAddresses = new address[](limit);\n', '        uint8[] memory states = new uint8[](limit);\n', '\n', '        for (uint256 i = 0; i < limit; i++) {\n', '            bytes32 order = orderbook[i + _offset];\n', '            orderIDs[i] = order;\n', '            traderAddresses[i] = orders[order].trader;\n', '            states[i] = uint8(orders[order].state);\n', '        }\n', '\n', '        return (orderIDs, traderAddresses, states);\n', '    }\n', '}\n', '\n', '/// @notice A library for calculating and verifying order match details\n', 'library SettlementUtils {\n', '\n', '    struct OrderDetails {\n', '        uint64 settlementID;\n', '        uint64 tokens;\n', '        uint256 price;\n', '        uint256 volume;\n', '        uint256 minimumVolume;\n', '    }\n', '\n', '    /// @notice Calculates the ID of the order.\n', '    /// @param details Order details that are not required for settlement\n', '    ///        execution. They are combined as a single byte array.\n', '    /// @param order The order details required for settlement execution.\n', '    function hashOrder(bytes details, OrderDetails memory order) internal pure returns (bytes32) {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                details,\n', '                order.settlementID,\n', '                order.tokens,\n', '                order.price,\n', '                order.volume,\n', '                order.minimumVolume\n', '            )\n', '        );\n', '    }\n', '\n', '    /// @notice Verifies that two orders match when considering the tokens,\n', '    /// price, volumes / minimum volumes and settlement IDs. verifyMatchDetails is used\n', '    /// my the DarknodeSlasher to verify challenges. Settlement layers may also\n', '    /// use this function.\n', '    /// @dev When verifying two orders for settlement, you should also:\n', '    ///   1) verify the orders have been confirmed together\n', '    ///   2) verify the orders&#39; traders are distinct\n', '    /// @param _buy The buy order details.\n', '    /// @param _sell The sell order details.\n', '    function verifyMatchDetails(OrderDetails memory _buy, OrderDetails memory _sell) internal pure returns (bool) {\n', '\n', '        // Buy and sell tokens should match\n', '        if (!verifyTokens(_buy.tokens, _sell.tokens)) {\n', '            return false;\n', '        }\n', '\n', '        // Buy price should be greater than sell price\n', '        if (_buy.price < _sell.price) {\n', '            return false;\n', '        }\n', '\n', '        // // Buy volume should be greater than sell minimum volume\n', '        if (_buy.volume < _sell.minimumVolume) {\n', '            return false;\n', '        }\n', '\n', '        // Sell volume should be greater than buy minimum volume\n', '        if (_sell.volume < _buy.minimumVolume) {\n', '            return false;\n', '        }\n', '\n', '        // Require that the orders were submitted to the same settlement layer\n', '        if (_buy.settlementID != _sell.settlementID) {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Verifies that two token requirements can be matched and that the\n', '    /// tokens are formatted correctly.\n', '    /// @param _buyTokens The buy token details.\n', '    /// @param _sellToken The sell token details.\n', '    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) internal pure returns (bool) {\n', '        return ((\n', '                uint32(_buyTokens) == uint32(_sellToken >> 32)) && (\n', '                uint32(_sellToken) == uint32(_buyTokens >> 32)) && (\n', '                uint32(_buyTokens >> 32) <= uint32(_buyTokens))\n', '        );\n', '    }\n', '}\n', '\n', '/// @notice RenExTokens is a registry of tokens that can be traded on RenEx.\n', 'contract RenExTokens is Ownable {\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    struct TokenDetails {\n', '        address addr;\n', '        uint8 decimals;\n', '        bool registered;\n', '    }\n', '\n', '    // Storage\n', '    mapping(uint32 => TokenDetails) public tokens;\n', '    mapping(uint32 => bool) private detailsSubmitted;\n', '\n', '    // Events\n', '    event LogTokenRegistered(uint32 tokenCode, address tokenAddress, uint8 tokenDecimals);\n', '    event LogTokenDeregistered(uint32 tokenCode);\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    constructor(string _VERSION) public {\n', '        VERSION = _VERSION;\n', '    }\n', '\n', '    /// @notice Allows the owner to register and the details for a token.\n', '    /// Once details have been submitted, they cannot be overwritten.\n', '    /// To re-register the same token with different details (e.g. if the address\n', '    /// has changed), a different token identifier should be used and the\n', '    /// previous token identifier should be deregistered.\n', '    /// If a token is not Ethereum-based, the address will be set to 0x0.\n', '    ///\n', '    /// @param _tokenCode A unique 32-bit token identifier.\n', '    /// @param _tokenAddress The address of the token.\n', '    /// @param _tokenDecimals The decimals to use for the token.\n', '    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {\n', '        require(!tokens[_tokenCode].registered, "already registered");\n', '\n', '        // If a token is being re-registered, the same details must be provided.\n', '        if (detailsSubmitted[_tokenCode]) {\n', '            require(tokens[_tokenCode].addr == _tokenAddress, "different address");\n', '            require(tokens[_tokenCode].decimals == _tokenDecimals, "different decimals");\n', '        } else {\n', '            detailsSubmitted[_tokenCode] = true;\n', '        }\n', '\n', '        tokens[_tokenCode] = TokenDetails({\n', '            addr: _tokenAddress,\n', '            decimals: _tokenDecimals,\n', '            registered: true\n', '        });\n', '\n', '        emit LogTokenRegistered(_tokenCode, _tokenAddress, _tokenDecimals);\n', '    }\n', '\n', '    /// @notice Sets a token as being deregistered. The details are still stored\n', '    /// to prevent the token from being re-registered with different details.\n', '    ///\n', '    /// @param _tokenCode The unique 32-bit token identifier.\n', '    function deregisterToken(uint32 _tokenCode) external onlyOwner {\n', '        require(tokens[_tokenCode].registered, "not registered");\n', '\n', '        tokens[_tokenCode].registered = false;\n', '\n', '        emit LogTokenDeregistered(_tokenCode);\n', '    }\n', '}\n', '\n', '/// @notice RenExSettlement implements the Settlement interface. It implements\n', '/// the on-chain settlement for the RenEx settlement layer, and the fee payment\n', '/// for the RenExAtomic settlement layer.\n', 'contract RenExSettlement is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    // This contract handles the settlements with ID 1 and 2.\n', '    uint32 constant public RENEX_SETTLEMENT_ID = 1;\n', '    uint32 constant public RENEX_ATOMIC_SETTLEMENT_ID = 2;\n', '\n', '    // Fees in RenEx are 0.2%. To represent this as integers, it is broken into\n', '    // a numerator and denominator.\n', '    uint256 constant public DARKNODE_FEES_NUMERATOR = 2;\n', '    uint256 constant public DARKNODE_FEES_DENOMINATOR = 1000;\n', '\n', '    // Constants used in the price / volume inputs.\n', '    int16 constant private PRICE_OFFSET = 12;\n', '    int16 constant private VOLUME_OFFSET = 12;\n', '\n', '    // Constructor parameters, updatable by the owner\n', '    Orderbook public orderbookContract;\n', '    RenExTokens public renExTokensContract;\n', '    RenExBalances public renExBalancesContract;\n', '    address public slasherAddress;\n', '    uint256 public submissionGasPriceLimit;\n', '\n', '    enum OrderStatus {None, Submitted, Settled, Slashed}\n', '\n', '    struct TokenPair {\n', '        RenExTokens.TokenDetails priorityToken;\n', '        RenExTokens.TokenDetails secondaryToken;\n', '    }\n', '\n', '    // A uint256 tuple representing a value and an associated fee\n', '    struct ValueWithFees {\n', '        uint256 value;\n', '        uint256 fees;\n', '    }\n', '\n', '    // A uint256 tuple representing a fraction\n', '    struct Fraction {\n', '        uint256 numerator;\n', '        uint256 denominator;\n', '    }\n', '\n', '    // We use left and right because the tokens do not always represent the\n', '    // priority and secondary tokens.\n', '    struct SettlementDetails {\n', '        uint256 leftVolume;\n', '        uint256 rightVolume;\n', '        uint256 leftTokenFee;\n', '        uint256 rightTokenFee;\n', '        address leftTokenAddress;\n', '        address rightTokenAddress;\n', '    }\n', '\n', '    // Events\n', '    event LogOrderbookUpdated(Orderbook previousOrderbook, Orderbook nextOrderbook);\n', '    event LogRenExTokensUpdated(RenExTokens previousRenExTokens, RenExTokens nextRenExTokens);\n', '    event LogRenExBalancesUpdated(RenExBalances previousRenExBalances, RenExBalances nextRenExBalances);\n', '    event LogSubmissionGasPriceLimitUpdated(uint256 previousSubmissionGasPriceLimit, uint256 nextSubmissionGasPriceLimit);\n', '    event LogSlasherUpdated(address previousSlasher, address nextSlasher);\n', '\n', '    // Order Storage\n', '    mapping(bytes32 => SettlementUtils.OrderDetails) public orderDetails;\n', '    mapping(bytes32 => address) public orderSubmitter;\n', '    mapping(bytes32 => OrderStatus) public orderStatus;\n', '\n', '    // Match storage (match details are indexed by [buyID][sellID])\n', '    mapping(bytes32 => mapping(bytes32 => uint256)) public matchTimestamp;\n', '\n', '    /// @notice Prevents a function from being called with a gas price higher\n', '    /// than the specified limit.\n', '    ///\n', '    /// @param _gasPriceLimit The gas price upper-limit in Wei.\n', '    modifier withGasPriceLimit(uint256 _gasPriceLimit) {\n', '        require(tx.gasprice <= _gasPriceLimit, "gas price too high");\n', '        _;\n', '    }\n', '\n', '    /// @notice Restricts a function to only being called by the slasher\n', '    /// address.\n', '    modifier onlySlasher() {\n', '        require(msg.sender == slasherAddress, "unauthorized");\n', '        _;\n', '    }\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _orderbookContract The address of the Orderbook contract.\n', '    /// @param _renExBalancesContract The address of the RenExBalances\n', '    ///        contract.\n', '    /// @param _renExTokensContract The address of the RenExTokens contract.\n', '    constructor(\n', '        string _VERSION,\n', '        Orderbook _orderbookContract,\n', '        RenExTokens _renExTokensContract,\n', '        RenExBalances _renExBalancesContract,\n', '        address _slasherAddress,\n', '        uint256 _submissionGasPriceLimit\n', '    ) public {\n', '        VERSION = _VERSION;\n', '        orderbookContract = _orderbookContract;\n', '        renExTokensContract = _renExTokensContract;\n', '        renExBalancesContract = _renExBalancesContract;\n', '        slasherAddress = _slasherAddress;\n', '        submissionGasPriceLimit = _submissionGasPriceLimit;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the Orderbook address.\n', '    /// @param _newOrderbookContract The address of the new Orderbook contract.\n', '    function updateOrderbook(Orderbook _newOrderbookContract) external onlyOwner {\n', '        emit LogOrderbookUpdated(orderbookContract, _newOrderbookContract);\n', '        orderbookContract = _newOrderbookContract;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the RenExTokens address.\n', '    /// @param _newRenExTokensContract The address of the new RenExTokens\n', '    ///       contract.\n', '    function updateRenExTokens(RenExTokens _newRenExTokensContract) external onlyOwner {\n', '        emit LogRenExTokensUpdated(renExTokensContract, _newRenExTokensContract);\n', '        renExTokensContract = _newRenExTokensContract;\n', '    }\n', '    \n', '    /// @notice The owner of the contract can update the RenExBalances address.\n', '    /// @param _newRenExBalancesContract The address of the new RenExBalances\n', '    ///       contract.\n', '    function updateRenExBalances(RenExBalances _newRenExBalancesContract) external onlyOwner {\n', '        emit LogRenExBalancesUpdated(renExBalancesContract, _newRenExBalancesContract);\n', '        renExBalancesContract = _newRenExBalancesContract;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the order submission gas\n', '    /// price limit.\n', '    /// @param _newSubmissionGasPriceLimit The new gas price limit.\n', '    function updateSubmissionGasPriceLimit(uint256 _newSubmissionGasPriceLimit) external onlyOwner {\n', '        emit LogSubmissionGasPriceLimitUpdated(submissionGasPriceLimit, _newSubmissionGasPriceLimit);\n', '        submissionGasPriceLimit = _newSubmissionGasPriceLimit;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the slasher address.\n', '    /// @param _newSlasherAddress The new slasher address.\n', '    function updateSlasher(address _newSlasherAddress) external onlyOwner {\n', '        emit LogSlasherUpdated(slasherAddress, _newSlasherAddress);\n', '        slasherAddress = _newSlasherAddress;\n', '    }\n', '\n', '    /// @notice Stores the details of an order.\n', '    ///\n', '    /// @param _prefix The miscellaneous details of the order required for\n', '    ///        calculating the order id.\n', '    /// @param _settlementID The settlement identifier.\n', '    /// @param _tokens The encoding of the token pair (buy token is encoded as\n', '    ///        the first 32 bytes and sell token is encoded as the last 32\n', '    ///        bytes).\n', '    /// @param _price The price of the order. Interpreted as the cost for 1\n', '    ///        standard unit of the non-priority token, in 1e12 (i.e.\n', '    ///        PRICE_OFFSET) units of the priority token).\n', '    /// @param _volume The volume of the order. Interpreted as the maximum\n', '    ///        number of 1e-12 (i.e. VOLUME_OFFSET) units of the non-priority\n', '    ///        token that can be traded by this order.\n', '    /// @param _minimumVolume The minimum volume the trader is willing to\n', '    ///        accept. Encoded the same as the volume.\n', '    function submitOrder(\n', '        bytes _prefix,\n', '        uint64 _settlementID,\n', '        uint64 _tokens,\n', '        uint256 _price,\n', '        uint256 _volume,\n', '        uint256 _minimumVolume\n', '    ) external withGasPriceLimit(submissionGasPriceLimit) {\n', '\n', '        SettlementUtils.OrderDetails memory order = SettlementUtils.OrderDetails({\n', '            settlementID: _settlementID,\n', '            tokens: _tokens,\n', '            price: _price,\n', '            volume: _volume,\n', '            minimumVolume: _minimumVolume\n', '        });\n', '        bytes32 orderID = SettlementUtils.hashOrder(_prefix, order);\n', '\n', '        require(orderStatus[orderID] == OrderStatus.None, "order already submitted");\n', '        require(orderbookContract.orderState(orderID) == Orderbook.OrderState.Confirmed, "unconfirmed order");\n', '\n', '        orderSubmitter[orderID] = msg.sender;\n', '        orderStatus[orderID] = OrderStatus.Submitted;\n', '        orderDetails[orderID] = order;\n', '    }\n', '\n', '    /// @notice Settles two orders that are matched. `submitOrder` must have been\n', '    /// called for each order before this function is called.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    function settle(bytes32 _buyID, bytes32 _sellID) external {\n', '        require(orderStatus[_buyID] == OrderStatus.Submitted, "invalid buy status");\n', '        require(orderStatus[_sellID] == OrderStatus.Submitted, "invalid sell status");\n', '\n', '        // Check the settlement ID (only have to check for one, since\n', '        // `verifyMatchDetails` checks that they are the same)\n', '        require(\n', '            orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID ||\n', '            orderDetails[_buyID].settlementID == RENEX_SETTLEMENT_ID,\n', '            "invalid settlement id"\n', '        );\n', '\n', '        // Verify that the two order details are compatible.\n', '        require(SettlementUtils.verifyMatchDetails(orderDetails[_buyID], orderDetails[_sellID]), "incompatible orders");\n', '\n', '        // Verify that the two orders have been confirmed to one another.\n', '        require(orderbookContract.orderMatch(_buyID) == _sellID, "unconfirmed orders");\n', '\n', '        // Retrieve token details.\n', '        TokenPair memory tokens = getTokenDetails(orderDetails[_buyID].tokens);\n', '\n', '        // Require that the tokens have been registered.\n', '        require(tokens.priorityToken.registered, "unregistered priority token");\n', '        require(tokens.secondaryToken.registered, "unregistered secondary token");\n', '\n', '        address buyer = orderbookContract.orderTrader(_buyID);\n', '        address seller = orderbookContract.orderTrader(_sellID);\n', '\n', '        require(buyer != seller, "orders from same trader");\n', '\n', '        execute(_buyID, _sellID, buyer, seller, tokens);\n', '\n', '        /* solium-disable-next-line security/no-block-members */\n', '        matchTimestamp[_buyID][_sellID] = now;\n', '\n', '        // Store that the orders have been settled.\n', '        orderStatus[_buyID] = OrderStatus.Settled;\n', '        orderStatus[_sellID] = OrderStatus.Settled;\n', '    }\n', '\n', '    /// @notice Slashes the bond of a guilty trader. This is called when an\n', '    /// atomic swap is not executed successfully.\n', '    /// To open an atomic order, a trader must have a balance equivalent to\n', '    /// 0.6% of the trade in the Ethereum-based token. 0.2% is always paid in\n', '    /// darknode fees when the order is matched. If the remaining amount is\n', '    /// is slashed, it is distributed as follows:\n', '    ///   1) 0.2% goes to the other trader, covering their fee\n', '    ///   2) 0.2% goes to the slasher address\n', '    /// Only one order in a match can be slashed.\n', '    ///\n', '    /// @param _guiltyOrderID The 32 byte ID of the order of the guilty trader.\n', '    function slash(bytes32 _guiltyOrderID) external onlySlasher {\n', '        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, "slashing non-atomic trade");\n', '\n', '        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);\n', '\n', '        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, "invalid order status");\n', '        require(orderStatus[innocentOrderID] == OrderStatus.Settled, "invalid order status");\n', '        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;\n', '\n', '        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ?\n', '            (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);\n', '\n', '        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);\n', '\n', '        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);\n', '\n', '        // Transfer the fee amount to the other trader\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            orderbookContract.orderTrader(_guiltyOrderID),\n', '            orderbookContract.orderTrader(innocentOrderID),\n', '            settlementDetails.leftTokenAddress,\n', '            settlementDetails.leftTokenFee,\n', '            0,\n', '            0x0\n', '        );\n', '\n', '        // Transfer the fee amount to the slasher\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            orderbookContract.orderTrader(_guiltyOrderID),\n', '            slasherAddress,\n', '            settlementDetails.leftTokenAddress,\n', '            settlementDetails.leftTokenFee,\n', '            0,\n', '            0x0\n', '        );\n', '    }\n', '\n', '    /// @notice Retrieves the settlement details of an order.\n', '    /// For atomic swaps, it returns the full volumes, not the settled fees.\n', '    ///\n', '    /// @param _orderID The order to lookup the details of. Can be the ID of a\n', '    ///        buy or a sell order.\n', '    /// @return [\n', '    ///     a boolean representing whether or not the order has been settled,\n', '    ///     a boolean representing whether or not the order is a buy\n', '    ///     the 32-byte order ID of the matched order\n', '    ///     the volume of the priority token,\n', '    ///     the volume of the secondary token,\n', '    ///     the fee paid in the priority token,\n', '    ///     the fee paid in the secondary token,\n', '    ///     the token code of the priority token,\n', '    ///     the token code of the secondary token\n', '    /// ]\n', '    function getMatchDetails(bytes32 _orderID)\n', '    external view returns (\n', '        bool settled,\n', '        bool orderIsBuy,\n', '        bytes32 matchedID,\n', '        uint256 priorityVolume,\n', '        uint256 secondaryVolume,\n', '        uint256 priorityFee,\n', '        uint256 secondaryFee,\n', '        uint32 priorityToken,\n', '        uint32 secondaryToken\n', '    ) {\n', '        matchedID = orderbookContract.orderMatch(_orderID);\n', '\n', '        orderIsBuy = isBuyOrder(_orderID);\n', '\n', '        (bytes32 buyID, bytes32 sellID) = orderIsBuy ?\n', '            (_orderID, matchedID) : (matchedID, _orderID);\n', '\n', '        SettlementDetails memory settlementDetails = calculateSettlementDetails(\n', '            buyID,\n', '            sellID,\n', '            getTokenDetails(orderDetails[buyID].tokens)\n', '        );\n', '\n', '        return (\n', '            orderStatus[_orderID] == OrderStatus.Settled || orderStatus[_orderID] == OrderStatus.Slashed,\n', '            orderIsBuy,\n', '            matchedID,\n', '            settlementDetails.leftVolume,\n', '            settlementDetails.rightVolume,\n', '            settlementDetails.leftTokenFee,\n', '            settlementDetails.rightTokenFee,\n', '            uint32(orderDetails[buyID].tokens >> 32),\n', '            uint32(orderDetails[buyID].tokens)\n', '        );\n', '    }\n', '\n', '    /// @notice Exposes the hashOrder function for computing a hash of an\n', '    /// order&#39;s details. An order hash is used as its ID. See `submitOrder`\n', '    /// for the parameter descriptions.\n', '    ///\n', '    /// @return The 32-byte hash of the order.\n', '    function hashOrder(\n', '        bytes _prefix,\n', '        uint64 _settlementID,\n', '        uint64 _tokens,\n', '        uint256 _price,\n', '        uint256 _volume,\n', '        uint256 _minimumVolume\n', '    ) external pure returns (bytes32) {\n', '        return SettlementUtils.hashOrder(_prefix, SettlementUtils.OrderDetails({\n', '            settlementID: _settlementID,\n', '            tokens: _tokens,\n', '            price: _price,\n', '            volume: _volume,\n', '            minimumVolume: _minimumVolume\n', '        }));\n', '    }\n', '\n', '    /// @notice Called by `settle`, executes the settlement for a RenEx order\n', '    /// or distributes the fees for a RenExAtomic swap.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    /// @param _buyer The address of the buy trader.\n', '    /// @param _seller The address of the sell trader.\n', '    /// @param _tokens The details of the priority and secondary tokens.\n', '    function execute(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID,\n', '        address _buyer,\n', '        address _seller,\n', '        TokenPair memory _tokens\n', '    ) private {\n', '        // Calculate the fees for atomic swaps, and the settlement details\n', '        // otherwise.\n', '        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ?\n', '            settlementDetails = calculateAtomicFees(_buyID, _sellID, _tokens) :\n', '            settlementDetails = calculateSettlementDetails(_buyID, _sellID, _tokens);\n', '\n', '        // Transfer priority token value\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            _buyer,\n', '            _seller,\n', '            settlementDetails.leftTokenAddress,\n', '            settlementDetails.leftVolume,\n', '            settlementDetails.leftTokenFee,\n', '            orderSubmitter[_buyID]\n', '        );\n', '\n', '        // Transfer secondary token value\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            _seller,\n', '            _buyer,\n', '            settlementDetails.rightTokenAddress,\n', '            settlementDetails.rightVolume,\n', '            settlementDetails.rightTokenFee,\n', '            orderSubmitter[_sellID]\n', '        );\n', '    }\n', '\n', '    /// @notice Calculates the details required to execute two matched orders.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    /// @param _tokens The details of the priority and secondary tokens.\n', '    /// @return A struct containing the settlement details.\n', '    function calculateSettlementDetails(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID,\n', '        TokenPair memory _tokens\n', '    ) private view returns (SettlementDetails memory) {\n', '\n', '        // Calculate the mid-price (using numerator and denominator to not loose\n', '        // precision).\n', '        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\n', '\n', '        // Calculate the lower of the two max volumes of each trader\n', '        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\n', '\n', '        uint256 priorityTokenVolume = joinFraction(\n', '            commonVolume.mul(midPrice.numerator),\n', '            midPrice.denominator,\n', '            int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\n', '        );\n', '        uint256 secondaryTokenVolume = joinFraction(\n', '            commonVolume,\n', '            1,\n', '            int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\n', '        );\n', '\n', '        // Calculate darknode fees\n', '        ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\n', '        ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\n', '\n', '        return SettlementDetails({\n', '            leftVolume: priorityVwF.value,\n', '            rightVolume: secondaryVwF.value,\n', '            leftTokenFee: priorityVwF.fees,\n', '            rightTokenFee: secondaryVwF.fees,\n', '            leftTokenAddress: _tokens.priorityToken.addr,\n', '            rightTokenAddress: _tokens.secondaryToken.addr\n', '        });\n', '    }\n', '\n', '    /// @notice Calculates the fees to be transferred for an atomic swap.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    /// @param _tokens The details of the priority and secondary tokens.\n', '    /// @return A struct containing the fee details.\n', '    function calculateAtomicFees(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID,\n', '        TokenPair memory _tokens\n', '    ) private view returns (SettlementDetails memory) {\n', '\n', '        // Calculate the mid-price (using numerator and denominator to not loose\n', '        // precision).\n', '        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\n', '\n', '        // Calculate the lower of the two max volumes of each trader\n', '        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\n', '\n', '        if (isEthereumBased(_tokens.secondaryToken.addr)) {\n', '            uint256 secondaryTokenVolume = joinFraction(\n', '                commonVolume,\n', '                1,\n', '                int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\n', '            );\n', '\n', '            // Calculate darknode fees\n', '            ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\n', '\n', '            return SettlementDetails({\n', '                leftVolume: 0,\n', '                rightVolume: 0,\n', '                leftTokenFee: secondaryVwF.fees,\n', '                rightTokenFee: secondaryVwF.fees,\n', '                leftTokenAddress: _tokens.secondaryToken.addr,\n', '                rightTokenAddress: _tokens.secondaryToken.addr\n', '            });\n', '        } else if (isEthereumBased(_tokens.priorityToken.addr)) {\n', '            uint256 priorityTokenVolume = joinFraction(\n', '                commonVolume.mul(midPrice.numerator),\n', '                midPrice.denominator,\n', '                int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\n', '            );\n', '\n', '            // Calculate darknode fees\n', '            ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\n', '\n', '            return SettlementDetails({\n', '                leftVolume: 0,\n', '                rightVolume: 0,\n', '                leftTokenFee: priorityVwF.fees,\n', '                rightTokenFee: priorityVwF.fees,\n', '                leftTokenAddress: _tokens.priorityToken.addr,\n', '                rightTokenAddress: _tokens.priorityToken.addr\n', '            });\n', '        } else {\n', '            // Currently, at least one token must be Ethereum-based.\n', '            // This will be implemented in the future.\n', '            revert("non-eth atomic swaps are not supported");\n', '        }\n', '    }\n', '\n', '    /// @notice Order parity is set by the order tokens are listed. This returns\n', '    /// whether an order is a buy or a sell.\n', '    /// @return true if _orderID is a buy order.\n', '    function isBuyOrder(bytes32 _orderID) private view returns (bool) {\n', '        uint64 tokens = orderDetails[_orderID].tokens;\n', '        uint32 firstToken = uint32(tokens >> 32);\n', '        uint32 secondaryToken = uint32(tokens);\n', '        return (firstToken < secondaryToken);\n', '    }\n', '\n', '    /// @return (value - fee, fee) where fee is 0.2% of value\n', '    function subtractDarknodeFee(uint256 _value) private pure returns (ValueWithFees memory) {\n', '        uint256 newValue = (_value * (DARKNODE_FEES_DENOMINATOR - DARKNODE_FEES_NUMERATOR)) / DARKNODE_FEES_DENOMINATOR;\n', '        return ValueWithFees(newValue, _value - newValue);\n', '    }\n', '\n', '    /// @notice Gets the order details of the priority and secondary token from\n', '    /// the RenExTokens contract and returns them as a single struct.\n', '    ///\n', '    /// @param _tokens The 64-bit combined token identifiers.\n', '    /// @return A TokenPair struct containing two TokenDetails structs.\n', '    function getTokenDetails(uint64 _tokens) private view returns (TokenPair memory) {\n', '        (\n', '            address priorityAddress,\n', '            uint8 priorityDecimals,\n', '            bool priorityRegistered\n', '        ) = renExTokensContract.tokens(uint32(_tokens >> 32));\n', '\n', '        (\n', '            address secondaryAddress,\n', '            uint8 secondaryDecimals,\n', '            bool secondaryRegistered\n', '        ) = renExTokensContract.tokens(uint32(_tokens));\n', '\n', '        return TokenPair({\n', '            priorityToken: RenExTokens.TokenDetails(priorityAddress, priorityDecimals, priorityRegistered),\n', '            secondaryToken: RenExTokens.TokenDetails(secondaryAddress, secondaryDecimals, secondaryRegistered)\n', '        });\n', '    }\n', '\n', '    /// @return true if _tokenAddress is 0x0, representing a token that is not\n', '    /// on Ethereum\n', '    function isEthereumBased(address _tokenAddress) private pure returns (bool) {\n', '        return (_tokenAddress != address(0x0));\n', '    }\n', '\n', '    /// @notice Computes (_numerator / _denominator) * 10 ** _scale\n', '    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) private pure returns (uint256) {\n', '        if (_scale >= 0) {\n', '            // Check that (10**_scale) doesn&#39;t overflow\n', '            assert(_scale <= 77); // log10(2**256) = 77.06\n', '            return _numerator.mul(10 ** uint256(_scale)) / _denominator;\n', '        } else {\n', '            /// @dev If _scale is less than -77, 10**-_scale would overflow.\n', '            // For now, -_scale > -24 (when a token has 0 decimals and\n', '            // VOLUME_OFFSET and PRICE_OFFSET are each 12). It is unlikely these\n', '            // will be increased to add to more than 77.\n', '            // assert((-_scale) <= 77); // log10(2**256) = 77.06\n', '            return (_numerator / _denominator) / 10 ** uint256(-_scale);\n', '        }\n', '    }\n', '}\n', '\n', '/// @notice RenExBrokerVerifier implements the BrokerVerifier contract,\n', '/// verifying broker signatures for order opening and fund withdrawal.\n', 'contract RenExBrokerVerifier is Ownable {\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    // Events\n', '    event LogBalancesContractUpdated(address previousBalancesContract, address nextBalancesContract);\n', '    event LogBrokerRegistered(address broker);\n', '    event LogBrokerDeregistered(address broker);\n', '\n', '    // Storage\n', '    mapping(address => bool) public brokers;\n', '    mapping(address => uint256) public traderNonces;\n', '\n', '    address public balancesContract;\n', '\n', '    modifier onlyBalancesContract() {\n', '        require(msg.sender == balancesContract, "not authorized");\n', '        _;\n', '    }\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    constructor(string _VERSION) public {\n', '        VERSION = _VERSION;\n', '    }\n', '\n', '    /// @notice Allows the owner of the contract to update the address of the\n', '    /// RenExBalances contract.\n', '    ///\n', '    /// @param _balancesContract The address of the new balances contract\n', '    function updateBalancesContract(address _balancesContract) external onlyOwner {\n', '        emit LogBalancesContractUpdated(balancesContract, _balancesContract);\n', '\n', '        balancesContract = _balancesContract;\n', '    }\n', '\n', '    /// @notice Approved an address to sign order-opening and withdrawals.\n', '    /// @param _broker The address of the broker.\n', '    function registerBroker(address _broker) external onlyOwner {\n', '        require(!brokers[_broker], "already registered");\n', '        brokers[_broker] = true;\n', '        emit LogBrokerRegistered(_broker);\n', '    }\n', '\n', '    /// @notice Reverts the a broker&#39;s registration.\n', '    /// @param _broker The address of the broker.\n', '    function deregisterBroker(address _broker) external onlyOwner {\n', '        require(brokers[_broker], "not registered");\n', '        brokers[_broker] = false;\n', '        emit LogBrokerDeregistered(_broker);\n', '    }\n', '\n', '    /// @notice Verifies a broker&#39;s signature for an order opening.\n', '    /// The data signed by the broker is a prefixed message and the order ID.\n', '    ///\n', '    /// @param _trader The trader requesting the withdrawal.\n', '    /// @param _signature The 65-byte signature from the broker.\n', '    /// @param _orderID The 32-byte order ID.\n', '    /// @return True if the signature is valid, false otherwise.\n', '    function verifyOpenSignature(\n', '        address _trader,\n', '        bytes _signature,\n', '        bytes32 _orderID\n', '    ) external view returns (bool) {\n', '        bytes memory data = abi.encodePacked("Republic Protocol: open: ", _trader, _orderID);\n', '        address signer = Utils.addr(data, _signature);\n', '        return (brokers[signer] == true);\n', '    }\n', '\n', '    /// @notice Verifies a broker&#39;s signature for a trader withdrawal.\n', '    /// The data signed by the broker is a prefixed message, the trader address\n', '    /// and a 256-bit trader nonce, which is incremented every time a valid\n', '    /// signature is checked.\n', '    ///\n', '    /// @param _trader The trader requesting the withdrawal.\n', '    /// @param _signature 65-byte signature from the broker.\n', '    /// @return True if the signature is valid, false otherwise.\n', '    function verifyWithdrawSignature(\n', '        address _trader,\n', '        bytes _signature\n', '    ) external onlyBalancesContract returns (bool) {\n', '        bytes memory data = abi.encodePacked("Republic Protocol: withdraw: ", _trader, traderNonces[_trader]);\n', '        address signer = Utils.addr(data, _signature);\n', '        if (brokers[signer]) {\n', '            traderNonces[_trader] += 1;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '}\n', '\n', '/// @notice RenExBalances is responsible for holding RenEx trader funds.\n', 'contract RenExBalances is Ownable {\n', '    using SafeMath for uint256;\n', '    using CompatibleERC20Functions for CompatibleERC20;\n', '\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    RenExSettlement public settlementContract;\n', '    RenExBrokerVerifier public brokerVerifierContract;\n', '    DarknodeRewardVault public rewardVaultContract;\n', '\n', '    /// @dev Should match the address in the DarknodeRewardVault\n', '    address constant public ETHEREUM = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n', '    \n', '    // Delay between a trader calling `withdrawSignal` and being able to call\n', '    // `withdraw` without a broker signature.\n', '    uint256 constant public SIGNAL_DELAY = 48 hours;\n', '\n', '    // Events\n', '    event LogBalanceDecreased(address trader, ERC20 token, uint256 value);\n', '    event LogBalanceIncreased(address trader, ERC20 token, uint256 value);\n', '    event LogRenExSettlementContractUpdated(address previousRenExSettlementContract, address newRenExSettlementContract);\n', '    event LogRewardVaultContractUpdated(address previousRewardVaultContract, address newRewardVaultContract);\n', '    event LogBrokerVerifierContractUpdated(address previousBrokerVerifierContract, address newBrokerVerifierContract);\n', '\n', '    // Storage\n', '    mapping(address => mapping(address => uint256)) public traderBalances;\n', '    mapping(address => mapping(address => uint256)) public traderWithdrawalSignals;\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _rewardVaultContract The address of the RewardVault contract.\n', '    constructor(\n', '        string _VERSION,\n', '        DarknodeRewardVault _rewardVaultContract,\n', '        RenExBrokerVerifier _brokerVerifierContract\n', '    ) public {\n', '        VERSION = _VERSION;\n', '        rewardVaultContract = _rewardVaultContract;\n', '        brokerVerifierContract = _brokerVerifierContract;\n', '    }\n', '\n', '    /// @notice Restricts a function to only being called by the RenExSettlement\n', '    /// contract.\n', '    modifier onlyRenExSettlementContract() {\n', '        require(msg.sender == address(settlementContract), "not authorized");\n', '        _;\n', '    }\n', '\n', '    /// @notice Restricts trader withdrawing to be called if a signature from a\n', '    /// RenEx broker is provided, or if a certain amount of time has passed\n', '    /// since a trader has called `signalBackupWithdraw`.\n', '    /// @dev If the trader is withdrawing after calling `signalBackupWithdraw`,\n', '    /// this will reset the time to zero, writing to storage.\n', '    modifier withBrokerSignatureOrSignal(address _token, bytes _signature) {\n', '        address trader = msg.sender;\n', '\n', '        // If a signature has been provided, verify it - otherwise, verify that\n', '        // the user has signalled the withdraw\n', '        if (_signature.length > 0) {\n', '            require (brokerVerifierContract.verifyWithdrawSignature(trader, _signature), "invalid signature");\n', '        } else  {\n', '            require(traderWithdrawalSignals[trader][_token] != 0, "not signalled");\n', '            /* solium-disable-next-line security/no-block-members */\n', '            require((now - traderWithdrawalSignals[trader][_token]) > SIGNAL_DELAY, "signal time remaining");\n', '            traderWithdrawalSignals[trader][_token] = 0;\n', '        }\n', '        _;\n', '    }\n', '\n', '    /// @notice Allows the owner of the contract to update the address of the\n', '    /// RenExSettlement contract.\n', '    ///\n', '    /// @param _newSettlementContract the address of the new settlement contract\n', '    function updateRenExSettlementContract(RenExSettlement _newSettlementContract) external onlyOwner {\n', '        emit LogRenExSettlementContractUpdated(settlementContract, _newSettlementContract);\n', '        settlementContract = _newSettlementContract;\n', '    }\n', '\n', '    /// @notice Allows the owner of the contract to update the address of the\n', '    /// DarknodeRewardVault contract.\n', '    ///\n', '    /// @param _newRewardVaultContract the address of the new reward vault contract\n', '    function updateRewardVaultContract(DarknodeRewardVault _newRewardVaultContract) external onlyOwner {\n', '        emit LogRewardVaultContractUpdated(rewardVaultContract, _newRewardVaultContract);\n', '        rewardVaultContract = _newRewardVaultContract;\n', '    }\n', '\n', '    /// @notice Allows the owner of the contract to update the address of the\n', '    /// RenExBrokerVerifier contract.\n', '    ///\n', '    /// @param _newBrokerVerifierContract the address of the new broker verifier contract\n', '    function updateBrokerVerifierContract(RenExBrokerVerifier _newBrokerVerifierContract) external onlyOwner {\n', '        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);\n', '        brokerVerifierContract = _newBrokerVerifierContract;\n', '    }\n', '\n', '    /// @notice Transfer a token value from one trader to another, transferring\n', '    /// a fee to the RewardVault. Can only be called by the RenExSettlement\n', '    /// contract.\n', '    ///\n', '    /// @param _traderFrom The address of the trader to decrement the balance of.\n', '    /// @param _traderTo The address of the trader to increment the balance of.\n', '    /// @param _token The token&#39;s address.\n', '    /// @param _value The number of tokens to decrement the balance by (in the\n', '    ///        token&#39;s smallest unit).\n', '    /// @param _fee The fee amount to forward on to the RewardVault.\n', '    /// @param _feePayee The recipient of the fee.\n', '    function transferBalanceWithFee(address _traderFrom, address _traderTo, address _token, uint256 _value, uint256 _fee, address _feePayee)\n', '    external onlyRenExSettlementContract {\n', '        require(traderBalances[_traderFrom][_token] >= _fee, "insufficient funds for fee");\n', '\n', '        if (address(_token) == ETHEREUM) {\n', '            rewardVaultContract.deposit.value(_fee)(_feePayee, ERC20(_token), _fee);\n', '        } else {\n', '            CompatibleERC20(_token).safeApprove(rewardVaultContract, _fee);\n', '            rewardVaultContract.deposit(_feePayee, ERC20(_token), _fee);\n', '        }\n', '        privateDecrementBalance(_traderFrom, ERC20(_token), _value + _fee);\n', '        if (_value > 0) {\n', '            privateIncrementBalance(_traderTo, ERC20(_token), _value);\n', '        }\n', '    }\n', '\n', '    /// @notice Deposits ETH or an ERC20 token into the contract.\n', '    ///\n', '    /// @param _token The token&#39;s address (must be a registered token).\n', '    /// @param _value The amount to deposit in the token&#39;s smallest unit.\n', '    function deposit(ERC20 _token, uint256 _value) external payable {\n', '        address trader = msg.sender;\n', '\n', '        uint256 receivedValue = _value;\n', '        if (address(_token) == ETHEREUM) {\n', '            require(msg.value == _value, "mismatched value parameter and tx value");\n', '        } else {\n', '            require(msg.value == 0, "unexpected ether transfer");\n', '            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(trader, this, _value);\n', '        }\n', '        privateIncrementBalance(trader, _token, receivedValue);\n', '    }\n', '\n', '    /// @notice Withdraws ETH or an ERC20 token from the contract. A broker\n', '    /// signature is required to guarantee that the trader has a sufficient\n', '    /// balance after accounting for open orders. As a trustless backup,\n', '    /// traders can withdraw 48 hours after calling `signalBackupWithdraw`.\n', '    ///\n', '    /// @param _token The token&#39;s address.\n', '    /// @param _value The amount to withdraw in the token&#39;s smallest unit.\n', '    /// @param _signature The broker signature\n', '    function withdraw(ERC20 _token, uint256 _value, bytes _signature) external withBrokerSignatureOrSignal(_token, _signature) {\n', '        address trader = msg.sender;\n', '\n', '        privateDecrementBalance(trader, _token, _value);\n', '        if (address(_token) == ETHEREUM) {\n', '            trader.transfer(_value);\n', '        } else {\n', '            CompatibleERC20(_token).safeTransfer(trader, _value);\n', '        }\n', '    }\n', '\n', '    /// @notice A trader can withdraw without needing a broker signature if they\n', '    /// first call `signalBackupWithdraw` for the token they want to withdraw.\n', '    /// The trader can only withdraw the particular token once for each call to\n', '    /// this function. Traders can signal the intent to withdraw multiple\n', '    /// tokens.\n', '    /// Once this function is called, brokers will not sign order-opens for the\n', '    /// trader until the trader has withdrawn, guaranteeing that they won&#39;t have\n', '    /// orders open for the particular token.\n', '    function signalBackupWithdraw(address _token) external {\n', '        /* solium-disable-next-line security/no-block-members */\n', '        traderWithdrawalSignals[msg.sender][_token] = now;\n', '    }\n', '\n', '    function privateIncrementBalance(address _trader, ERC20 _token, uint256 _value) private {\n', '        traderBalances[_trader][_token] = traderBalances[_trader][_token].add(_value);\n', '\n', '        emit LogBalanceIncreased(_trader, _token, _value);\n', '    }\n', '\n', '    function privateDecrementBalance(address _trader, ERC20 _token, uint256 _value) private {\n', '        require(traderBalances[_trader][_token] >= _value, "insufficient funds");\n', '        traderBalances[_trader][_token] = traderBalances[_trader][_token].sub(_value);\n', '\n', '        emit LogBalanceDecreased(_trader, _token, _value);\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Pausable token\n', ' * @dev StandardToken modified with pausable transfers.\n', ' **/\n', 'contract PausableToken is StandardToken, Pausable {\n', '\n', '  function transfer(\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  function approve(\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.approve(_spender, _value);\n', '  }\n', '\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool success)\n', '  {\n', '    return super.increaseApproval(_spender, _addedValue);\n', '  }\n', '\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool success)\n', '  {\n', '    return super.decreaseApproval(_spender, _subtractedValue);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) public {\n', '    _burn(msg.sender, _value);\n', '  }\n', '\n', '  function _burn(address _who, uint256 _value) internal {\n', '    require(_value <= balances[_who]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', "    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '\n', '    balances[_who] = balances[_who].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    emit Burn(_who, _value);\n', '    emit Transfer(_who, address(0), _value);\n', '  }\n', '}\n', '\n', 'contract RepublicToken is PausableToken, BurnableToken {\n', '\n', '    string public constant name = "Republic Token";\n', '    string public constant symbol = "REN";\n', '    uint8 public constant decimals = 18;\n', '    uint256 public constant INITIAL_SUPPLY = 1000000000 * 10**uint256(decimals);\n', '\n', '    /// @notice The RepublicToken Constructor.\n', '    constructor() public {\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '    }\n', '\n', '    function transferTokens(address beneficiary, uint256 amount) public onlyOwner returns (bool) {\n', '        /* solium-disable error-reason */\n', '        require(amount > 0);\n', '\n', '        balances[owner] = balances[owner].sub(amount);\n', '        balances[beneficiary] = balances[beneficiary].add(amount);\n', '        emit Transfer(owner, beneficiary, amount);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @notice LinkedList is a library for a circular double linked list.\n', ' */\n', 'library LinkedList {\n', '\n', '    /*\n', '    * @notice A permanent NULL node (0x0) in the circular double linked list.\n', '    * NULL.next is the head, and NULL.previous is the tail.\n', '    */\n', '    address public constant NULL = 0x0;\n', '\n', '    /**\n', '    * @notice A node points to the node before it, and the node after it. If\n', '    * node.previous = NULL, then the node is the head of the list. If\n', '    * node.next = NULL, then the node is the tail of the list.\n', '    */\n', '    struct Node {\n', '        bool inList;\n', '        address previous;\n', '        address next;\n', '    }\n', '\n', '    /**\n', '    * @notice LinkedList uses a mapping from address to nodes. Each address\n', '    * uniquely identifies a node, and in this way they are used like pointers.\n', '    */\n', '    struct List {\n', '        mapping (address => Node) list;\n', '    }\n', '\n', '    /**\n', '    * @notice Insert a new node before an existing node.\n', '    *\n', '    * @param self The list being used.\n', '    * @param target The existing node in the list.\n', '    * @param newNode The next node to insert before the target.\n', '    */\n', '    function insertBefore(List storage self, address target, address newNode) internal {\n', '        require(!isInList(self, newNode), "already in list");\n', '        require(isInList(self, target) || target == NULL, "not in list");\n', '\n', '        // It is expected that this value is sometimes NULL.\n', '        address prev = self.list[target].previous;\n', '\n', '        self.list[newNode].next = target;\n', '        self.list[newNode].previous = prev;\n', '        self.list[target].previous = newNode;\n', '        self.list[prev].next = newNode;\n', '\n', '        self.list[newNode].inList = true;\n', '    }\n', '\n', '    /**\n', '    * @notice Insert a new node after an existing node.\n', '    *\n', '    * @param self The list being used.\n', '    * @param target The existing node in the list.\n', '    * @param newNode The next node to insert after the target.\n', '    */\n', '    function insertAfter(List storage self, address target, address newNode) internal {\n', '        require(!isInList(self, newNode), "already in list");\n', '        require(isInList(self, target) || target == NULL, "not in list");\n', '\n', '        // It is expected that this value is sometimes NULL.\n', '        address n = self.list[target].next;\n', '\n', '        self.list[newNode].previous = target;\n', '        self.list[newNode].next = n;\n', '        self.list[target].next = newNode;\n', '        self.list[n].previous = newNode;\n', '\n', '        self.list[newNode].inList = true;\n', '    }\n', '\n', '    /**\n', '    * @notice Remove a node from the list, and fix the previous and next\n', '    * pointers that are pointing to the removed node. Removing anode that is not\n', '    * in the list will do nothing.\n', '    *\n', '    * @param self The list being using.\n', '    * @param node The node in the list to be removed.\n', '    */\n', '    function remove(List storage self, address node) internal {\n', '        require(isInList(self, node), "not in list");\n', '        if (node == NULL) {\n', '            return;\n', '        }\n', '        address p = self.list[node].previous;\n', '        address n = self.list[node].next;\n', '\n', '        self.list[p].next = n;\n', '        self.list[n].previous = p;\n', '\n', '        // Deleting the node should set this value to false, but we set it here for\n', '        // explicitness.\n', '        self.list[node].inList = false;\n', '        delete self.list[node];\n', '    }\n', '\n', '    /**\n', '    * @notice Insert a node at the beginning of the list.\n', '    *\n', '    * @param self The list being used.\n', '    * @param node The node to insert at the beginning of the list.\n', '    */\n', '    function prepend(List storage self, address node) internal {\n', '        // isInList(node) is checked in insertBefore\n', '\n', '        insertBefore(self, begin(self), node);\n', '    }\n', '\n', '    /**\n', '    * @notice Insert a node at the end of the list.\n', '    *\n', '    * @param self The list being used.\n', '    * @param node The node to insert at the end of the list.\n', '    */\n', '    function append(List storage self, address node) internal {\n', '        // isInList(node) is checked in insertBefore\n', '\n', '        insertAfter(self, end(self), node);\n', '    }\n', '\n', '    function swap(List storage self, address left, address right) internal {\n', '        // isInList(left) and isInList(right) are checked in remove\n', '\n', '        address previousRight = self.list[right].previous;\n', '        remove(self, right);\n', '        insertAfter(self, left, right);\n', '        remove(self, left);\n', '        insertAfter(self, previousRight, left);\n', '    }\n', '\n', '    function isInList(List storage self, address node) internal view returns (bool) {\n', '        return self.list[node].inList;\n', '    }\n', '\n', '    /**\n', '    * @notice Get the node at the beginning of a double linked list.\n', '    *\n', '    * @param self The list being used.\n', '    *\n', '    * @return A address identifying the node at the beginning of the double\n', '    * linked list.\n', '    */\n', '    function begin(List storage self) internal view returns (address) {\n', '        return self.list[NULL].next;\n', '    }\n', '\n', '    /**\n', '    * @notice Get the node at the end of a double linked list.\n', '    *\n', '    * @param self The list being used.\n', '    *\n', '    * @return A address identifying the node at the end of the double linked\n', '    * list.\n', '    */\n', '    function end(List storage self) internal view returns (address) {\n', '        return self.list[NULL].previous;\n', '    }\n', '\n', '    function next(List storage self, address node) internal view returns (address) {\n', '        require(isInList(self, node), "not in list");\n', '        return self.list[node].next;\n', '    }\n', '\n', '    function previous(List storage self, address node) internal view returns (address) {\n', '        require(isInList(self, node), "not in list");\n', '        return self.list[node].previous;\n', '    }\n', '\n', '}\n', '\n', '/// @notice This contract stores data and funds for the DarknodeRegistry\n', '/// contract. The data / fund logic and storage have been separated to improve\n', '/// upgradability.\n', 'contract DarknodeRegistryStore is Ownable {\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    /// @notice Darknodes are stored in the darknode struct. The owner is the\n', '    /// address that registered the darknode, the bond is the amount of REN that\n', '    /// was transferred during registration, and the public key is the\n', '    /// encryption key that should be used when sending sensitive information to\n', '    /// the darknode.\n', '    struct Darknode {\n', '        // The owner of a Darknode is the address that called the register\n', '        // function. The owner is the only address that is allowed to\n', '        // deregister the Darknode, unless the Darknode is slashed for\n', '        // malicious behavior.\n', '        address owner;\n', '\n', '        // The bond is the amount of REN submitted as a bond by the Darknode.\n', '        // This amount is reduced when the Darknode is slashed for malicious\n', '        // behavior.\n', '        uint256 bond;\n', '\n', '        // The block number at which the Darknode is considered registered.\n', '        uint256 registeredAt;\n', '\n', '        // The block number at which the Darknode is considered deregistered.\n', '        uint256 deregisteredAt;\n', '\n', '        // The public key used by this Darknode for encrypting sensitive data\n', '        // off chain. It is assumed that the Darknode has access to the\n', '        // respective private key, and that there is an agreement on the format\n', '        // of the public key.\n', '        bytes publicKey;\n', '    }\n', '\n', '    /// Registry data.\n', '    mapping(address => Darknode) private darknodeRegistry;\n', '    LinkedList.List private darknodes;\n', '\n', '    // RepublicToken.\n', '    RepublicToken public ren;\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _ren The address of the RepublicToken contract.\n', '    constructor(\n', '        string _VERSION,\n', '        RepublicToken _ren\n', '    ) public {\n', '        VERSION = _VERSION;\n', '        ren = _ren;\n', '    }\n', '\n', '    /// @notice Instantiates a darknode and appends it to the darknodes\n', '    /// linked-list.\n', '    ///\n', "    /// @param _darknodeID The darknode's ID.\n", "    /// @param _darknodeOwner The darknode's owner's address\n", "    /// @param _bond The darknode's bond value\n", "    /// @param _publicKey The darknode's public key\n", '    /// @param _registeredAt The time stamp when the darknode is registered.\n', '    /// @param _deregisteredAt The time stamp when the darknode is deregistered.\n', '    function appendDarknode(\n', '        address _darknodeID,\n', '        address _darknodeOwner,\n', '        uint256 _bond,\n', '        bytes _publicKey,\n', '        uint256 _registeredAt,\n', '        uint256 _deregisteredAt\n', '    ) external onlyOwner {\n', '        Darknode memory darknode = Darknode({\n', '            owner: _darknodeOwner,\n', '            bond: _bond,\n', '            publicKey: _publicKey,\n', '            registeredAt: _registeredAt,\n', '            deregisteredAt: _deregisteredAt\n', '        });\n', '        darknodeRegistry[_darknodeID] = darknode;\n', '        LinkedList.append(darknodes, _darknodeID);\n', '    }\n', '\n', '    /// @notice Returns the address of the first darknode in the store\n', '    function begin() external view onlyOwner returns(address) {\n', '        return LinkedList.begin(darknodes);\n', '    }\n', '\n', '    /// @notice Returns the address of the next darknode in the store after the\n', '    /// given address.\n', '    function next(address darknodeID) external view onlyOwner returns(address) {\n', '        return LinkedList.next(darknodes, darknodeID);\n', '    }\n', '\n', '    /// @notice Removes a darknode from the store and transfers its bond to the\n', '    /// owner of this contract.\n', '    function removeDarknode(address darknodeID) external onlyOwner {\n', '        uint256 bond = darknodeRegistry[darknodeID].bond;\n', '        delete darknodeRegistry[darknodeID];\n', '        LinkedList.remove(darknodes, darknodeID);\n', '        require(ren.transfer(owner, bond), "bond transfer failed");\n', '    }\n', '\n', '    /// @notice Updates the bond of the darknode. If the bond is being\n', '    /// decreased, the difference is sent to the owner of this contract.\n', '    function updateDarknodeBond(address darknodeID, uint256 bond) external onlyOwner {\n', '        uint256 previousBond = darknodeRegistry[darknodeID].bond;\n', '        darknodeRegistry[darknodeID].bond = bond;\n', '        if (previousBond > bond) {\n', '            require(ren.transfer(owner, previousBond - bond), "cannot transfer bond");\n', '        }\n', '    }\n', '\n', '    /// @notice Updates the deregistration timestamp of a darknode.\n', '    function updateDarknodeDeregisteredAt(address darknodeID, uint256 deregisteredAt) external onlyOwner {\n', '        darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt;\n', '    }\n', '\n', '    /// @notice Returns the owner of a given darknode.\n', '    function darknodeOwner(address darknodeID) external view onlyOwner returns (address) {\n', '        return darknodeRegistry[darknodeID].owner;\n', '    }\n', '\n', '    /// @notice Returns the bond of a given darknode.\n', '    function darknodeBond(address darknodeID) external view onlyOwner returns (uint256) {\n', '        return darknodeRegistry[darknodeID].bond;\n', '    }\n', '\n', '    /// @notice Returns the registration time of a given darknode.\n', '    function darknodeRegisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\n', '        return darknodeRegistry[darknodeID].registeredAt;\n', '    }\n', '\n', '    /// @notice Returns the deregistration time of a given darknode.\n', '    function darknodeDeregisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\n', '        return darknodeRegistry[darknodeID].deregisteredAt;\n', '    }\n', '\n', '    /// @notice Returns the encryption public key of a given darknode.\n', '    function darknodePublicKey(address darknodeID) external view onlyOwner returns (bytes) {\n', '        return darknodeRegistry[darknodeID].publicKey;\n', '    }\n', '}\n', '\n', '/// @notice DarknodeRegistry is responsible for the registration and\n', '/// deregistration of Darknodes.\n', 'contract DarknodeRegistry is Ownable {\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    /// @notice Darknode pods are shuffled after a fixed number of blocks.\n', '    /// An Epoch stores an epoch hash used as an (insecure) RNG seed, and the\n', '    /// blocknumber which restricts when the next epoch can be called.\n', '    struct Epoch {\n', '        uint256 epochhash;\n', '        uint256 blocknumber;\n', '    }\n', '\n', '    uint256 public numDarknodes;\n', '    uint256 public numDarknodesNextEpoch;\n', '    uint256 public numDarknodesPreviousEpoch;\n', '\n', '    /// Variables used to parameterize behavior.\n', '    uint256 public minimumBond;\n', '    uint256 public minimumPodSize;\n', '    uint256 public minimumEpochInterval;\n', '    address public slasher;\n', '\n', '    /// When one of the above variables is modified, it is only updated when the\n', '    /// next epoch is called. These variables store the values for the next epoch.\n', '    uint256 public nextMinimumBond;\n', '    uint256 public nextMinimumPodSize;\n', '    uint256 public nextMinimumEpochInterval;\n', '    address public nextSlasher;\n', '\n', '    /// The current and previous epoch\n', '    Epoch public currentEpoch;\n', '    Epoch public previousEpoch;\n', '\n', '    /// Republic ERC20 token contract used to transfer bonds.\n', '    RepublicToken public ren;\n', '\n', '    /// Darknode Registry Store is the storage contract for darknodes.\n', '    DarknodeRegistryStore public store;\n', '\n', '    /// @notice Emitted when a darknode is registered.\n', '    /// @param _darknodeID The darknode ID that was registered.\n', '    /// @param _bond The amount of REN that was transferred as bond.\n', '    event LogDarknodeRegistered(address _darknodeID, uint256 _bond);\n', '\n', '    /// @notice Emitted when a darknode is deregistered.\n', '    /// @param _darknodeID The darknode ID that was deregistered.\n', '    event LogDarknodeDeregistered(address _darknodeID);\n', '\n', '    /// @notice Emitted when a refund has been made.\n', '    /// @param _owner The address that was refunded.\n', '    /// @param _amount The amount of REN that was refunded.\n', '    event LogDarknodeOwnerRefunded(address _owner, uint256 _amount);\n', '\n', '    /// @notice Emitted when a new epoch has begun.\n', '    event LogNewEpoch();\n', '\n', '    /// @notice Emitted when a constructor parameter has been updated.\n', '    event LogMinimumBondUpdated(uint256 previousMinimumBond, uint256 nextMinimumBond);\n', '    event LogMinimumPodSizeUpdated(uint256 previousMinimumPodSize, uint256 nextMinimumPodSize);\n', '    event LogMinimumEpochIntervalUpdated(uint256 previousMinimumEpochInterval, uint256 nextMinimumEpochInterval);\n', '    event LogSlasherUpdated(address previousSlasher, address nextSlasher);\n', '\n', '    /// @notice Only allow the owner that registered the darknode to pass.\n', '    modifier onlyDarknodeOwner(address _darknodeID) {\n', '        require(store.darknodeOwner(_darknodeID) == msg.sender, "must be darknode owner");\n', '        _;\n', '    }\n', '\n', '    /// @notice Only allow unregistered darknodes.\n', '    modifier onlyRefunded(address _darknodeID) {\n', '        require(isRefunded(_darknodeID), "must be refunded or never registered");\n', '        _;\n', '    }\n', '\n', '    /// @notice Only allow refundable darknodes.\n', '    modifier onlyRefundable(address _darknodeID) {\n', '        require(isRefundable(_darknodeID), "must be deregistered for at least one epoch");\n', '        _;\n', '    }\n', '\n', '    /// @notice Only allowed registered nodes without a pending deregistration to\n', '    /// deregister\n', '    modifier onlyDeregisterable(address _darknodeID) {\n', '        require(isDeregisterable(_darknodeID), "must be deregisterable");\n', '        _;\n', '    }\n', '\n', '    /// @notice Only allow the Slasher contract.\n', '    modifier onlySlasher() {\n', '        require(slasher == msg.sender, "must be slasher");\n', '        _;\n', '    }\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _renAddress The address of the RepublicToken contract.\n', '    /// @param _storeAddress The address of the DarknodeRegistryStore contract.\n', '    /// @param _minimumBond The minimum bond amount that can be submitted by a\n', '    ///        Darknode.\n', '    /// @param _minimumPodSize The minimum size of a Darknode pod.\n', '    /// @param _minimumEpochInterval The minimum number of blocks between\n', '    ///        epochs.\n', '    constructor(\n', '        string _VERSION,\n', '        RepublicToken _renAddress,\n', '        DarknodeRegistryStore _storeAddress,\n', '        uint256 _minimumBond,\n', '        uint256 _minimumPodSize,\n', '        uint256 _minimumEpochInterval\n', '    ) public {\n', '        VERSION = _VERSION;\n', '\n', '        store = _storeAddress;\n', '        ren = _renAddress;\n', '\n', '        minimumBond = _minimumBond;\n', '        nextMinimumBond = minimumBond;\n', '\n', '        minimumPodSize = _minimumPodSize;\n', '        nextMinimumPodSize = minimumPodSize;\n', '\n', '        minimumEpochInterval = _minimumEpochInterval;\n', '        nextMinimumEpochInterval = minimumEpochInterval;\n', '\n', '        currentEpoch = Epoch({\n', '            epochhash: uint256(blockhash(block.number - 1)),\n', '            blocknumber: block.number\n', '        });\n', '        numDarknodes = 0;\n', '        numDarknodesNextEpoch = 0;\n', '        numDarknodesPreviousEpoch = 0;\n', '    }\n', '\n', '    /// @notice Register a darknode and transfer the bond to this contract. The\n', '    /// caller must provide a public encryption key for the darknode as well as\n', '    /// a bond in REN. The bond must be provided as an ERC20 allowance. The dark\n', '    /// node will remain pending registration until the next epoch. Only after\n', '    /// this period can the darknode be deregistered. The caller of this method\n', '    /// will be stored as the owner of the darknode.\n', '    ///\n', '    /// @param _darknodeID The darknode ID that will be registered.\n', '    /// @param _publicKey The public key of the darknode. It is stored to allow\n', '    ///        other darknodes and traders to encrypt messages to the trader.\n', '    /// @param _bond The bond that will be paid. It must be greater than, or\n', '    ///        equal to, the minimum bond.\n', '    function register(address _darknodeID, bytes _publicKey, uint256 _bond) external onlyRefunded(_darknodeID) {\n', '        // REN allowance\n', '        require(_bond >= minimumBond, "insufficient bond");\n', '        // require(ren.allowance(msg.sender, address(this)) >= _bond);\n', '        require(ren.transferFrom(msg.sender, address(this), _bond), "bond transfer failed");\n', '        ren.transfer(address(store), _bond);\n', '\n', '        // Flag this darknode for registration\n', '        store.appendDarknode(\n', '            _darknodeID,\n', '            msg.sender,\n', '            _bond,\n', '            _publicKey,\n', '            currentEpoch.blocknumber + minimumEpochInterval,\n', '            0\n', '        );\n', '\n', '        numDarknodesNextEpoch += 1;\n', '\n', '        // Emit an event.\n', '        emit LogDarknodeRegistered(_darknodeID, _bond);\n', '    }\n', '\n', '    /// @notice Deregister a darknode. The darknode will not be deregistered\n', '    /// until the end of the epoch. After another epoch, the bond can be\n', '    /// refunded by calling the refund method.\n', '    /// @param _darknodeID The darknode ID that will be deregistered. The caller\n', '    ///        of this method store.darknodeRegisteredAt(_darknodeID) must be\n', '    //         the owner of this darknode.\n', '    function deregister(address _darknodeID) external onlyDeregisterable(_darknodeID) onlyDarknodeOwner(_darknodeID) {\n', '        // Flag the darknode for deregistration\n', '        store.updateDarknodeDeregisteredAt(_darknodeID, currentEpoch.blocknumber + minimumEpochInterval);\n', '        numDarknodesNextEpoch -= 1;\n', '\n', '        // Emit an event\n', '        emit LogDarknodeDeregistered(_darknodeID);\n', '    }\n', '\n', '    /// @notice Progress the epoch if it is possible to do so. This captures\n', '    /// the current timestamp and current blockhash and overrides the current\n', '    /// epoch.\n', '    function epoch() external {\n', '        if (previousEpoch.blocknumber == 0) {\n', '            // The first epoch must be called by the owner of the contract\n', '            require(msg.sender == owner, "not authorized (first epochs)");\n', '        }\n', '\n', '        // Require that the epoch interval has passed\n', '        require(block.number >= currentEpoch.blocknumber + minimumEpochInterval, "epoch interval has not passed");\n', '        uint256 epochhash = uint256(blockhash(block.number - 1));\n', '\n', '        // Update the epoch hash and timestamp\n', '        previousEpoch = currentEpoch;\n', '        currentEpoch = Epoch({\n', '            epochhash: epochhash,\n', '            blocknumber: block.number\n', '        });\n', '\n', '        // Update the registry information\n', '        numDarknodesPreviousEpoch = numDarknodes;\n', '        numDarknodes = numDarknodesNextEpoch;\n', '\n', '        // If any update functions have been called, update the values now\n', '        if (nextMinimumBond != minimumBond) {\n', '            minimumBond = nextMinimumBond;\n', '            emit LogMinimumBondUpdated(minimumBond, nextMinimumBond);\n', '        }\n', '        if (nextMinimumPodSize != minimumPodSize) {\n', '            minimumPodSize = nextMinimumPodSize;\n', '            emit LogMinimumPodSizeUpdated(minimumPodSize, nextMinimumPodSize);\n', '        }\n', '        if (nextMinimumEpochInterval != minimumEpochInterval) {\n', '            minimumEpochInterval = nextMinimumEpochInterval;\n', '            emit LogMinimumEpochIntervalUpdated(minimumEpochInterval, nextMinimumEpochInterval);\n', '        }\n', '        if (nextSlasher != slasher) {\n', '            slasher = nextSlasher;\n', '            emit LogSlasherUpdated(slasher, nextSlasher);\n', '        }\n', '\n', '        // Emit an event\n', '        emit LogNewEpoch();\n', '    }\n', '\n', '    /// @notice Allows the contract owner to transfer ownership of the\n', '    /// DarknodeRegistryStore.\n', '    /// @param _newOwner The address to transfer the ownership to.\n', '    function transferStoreOwnership(address _newOwner) external onlyOwner {\n', '        store.transferOwnership(_newOwner);\n', '    }\n', '\n', '    /// @notice Allows the contract owner to update the minimum bond.\n', '    /// @param _nextMinimumBond The minimum bond amount that can be submitted by\n', '    ///        a darknode.\n', '    function updateMinimumBond(uint256 _nextMinimumBond) external onlyOwner {\n', '        // Will be updated next epoch\n', '        nextMinimumBond = _nextMinimumBond;\n', '    }\n', '\n', '    /// @notice Allows the contract owner to update the minimum pod size.\n', '    /// @param _nextMinimumPodSize The minimum size of a pod.\n', '    function updateMinimumPodSize(uint256 _nextMinimumPodSize) external onlyOwner {\n', '        // Will be updated next epoch\n', '        nextMinimumPodSize = _nextMinimumPodSize;\n', '    }\n', '\n', '    /// @notice Allows the contract owner to update the minimum epoch interval.\n', '    /// @param _nextMinimumEpochInterval The minimum number of blocks between epochs.\n', '    function updateMinimumEpochInterval(uint256 _nextMinimumEpochInterval) external onlyOwner {\n', '        // Will be updated next epoch\n', '        nextMinimumEpochInterval = _nextMinimumEpochInterval;\n', '    }\n', '\n', '    /// @notice Allow the contract owner to update the DarknodeSlasher contract\n', '    /// address.\n', '    /// @param _slasher The new slasher address.\n', '    function updateSlasher(address _slasher) external onlyOwner {\n', '        nextSlasher = _slasher;\n', '    }\n', '\n', "    /// @notice Allow the DarknodeSlasher contract to slash half of a darknode's\n", '    /// bond and deregister it. The bond is distributed as follows:\n', '    ///   1/2 is kept by the guilty prover\n', '    ///   1/8 is rewarded to the first challenger\n', '    ///   1/8 is rewarded to the second challenger\n', '    ///   1/4 becomes unassigned\n', '    /// @param _prover The guilty prover whose bond is being slashed\n', '    /// @param _challenger1 The first of the two darknodes who submitted the challenge\n', '    /// @param _challenger2 The second of the two darknodes who submitted the challenge\n', '    function slash(address _prover, address _challenger1, address _challenger2)\n', '        external\n', '        onlySlasher\n', '    {\n', '        uint256 penalty = store.darknodeBond(_prover) / 2;\n', '        uint256 reward = penalty / 4;\n', '\n', '        // Slash the bond of the failed prover in half\n', '        store.updateDarknodeBond(_prover, penalty);\n', '\n', '        // If the darknode has not been deregistered then deregister it\n', '        if (isDeregisterable(_prover)) {\n', '            store.updateDarknodeDeregisteredAt(_prover, currentEpoch.blocknumber + minimumEpochInterval);\n', '            numDarknodesNextEpoch -= 1;\n', '            emit LogDarknodeDeregistered(_prover);\n', '        }\n', '\n', '        // Reward the challengers with less than the penalty so that it is not\n', '        // worth challenging yourself\n', '        ren.transfer(store.darknodeOwner(_challenger1), reward);\n', '        ren.transfer(store.darknodeOwner(_challenger2), reward);\n', '    }\n', '\n', '    /// @notice Refund the bond of a deregistered darknode. This will make the\n', '    /// darknode available for registration again. Anyone can call this function\n', '    /// but the bond will always be refunded to the darknode owner.\n', '    ///\n', '    /// @param _darknodeID The darknode ID that will be refunded. The caller\n', '    ///        of this method must be the owner of this darknode.\n', '    function refund(address _darknodeID) external onlyRefundable(_darknodeID) {\n', '        address darknodeOwner = store.darknodeOwner(_darknodeID);\n', '\n', '        // Remember the bond amount\n', '        uint256 amount = store.darknodeBond(_darknodeID);\n', '\n', '        // Erase the darknode from the registry\n', '        store.removeDarknode(_darknodeID);\n', '\n', '        // Refund the owner by transferring REN\n', '        ren.transfer(darknodeOwner, amount);\n', '\n', '        // Emit an event.\n', '        emit LogDarknodeOwnerRefunded(darknodeOwner, amount);\n', '    }\n', '\n', '    /// @notice Retrieves the address of the account that registered a darknode.\n', '    /// @param _darknodeID The ID of the darknode to retrieve the owner for.\n', '    function getDarknodeOwner(address _darknodeID) external view returns (address) {\n', '        return store.darknodeOwner(_darknodeID);\n', '    }\n', '\n', '    /// @notice Retrieves the bond amount of a darknode in 10^-18 REN.\n', '    /// @param _darknodeID The ID of the darknode to retrieve the bond for.\n', '    function getDarknodeBond(address _darknodeID) external view returns (uint256) {\n', '        return store.darknodeBond(_darknodeID);\n', '    }\n', '\n', '    /// @notice Retrieves the encryption public key of the darknode.\n', '    /// @param _darknodeID The ID of the darknode to retrieve the public key for.\n', '    function getDarknodePublicKey(address _darknodeID) external view returns (bytes) {\n', '        return store.darknodePublicKey(_darknodeID);\n', '    }\n', '\n', '    /// @notice Retrieves a list of darknodes which are registered for the\n', '    /// current epoch.\n', '    /// @param _start A darknode ID used as an offset for the list. If _start is\n', "    ///        0x0, the first dark node will be used. _start won't be\n", '    ///        included it is not registered for the epoch.\n', '    /// @param _count The number of darknodes to retrieve starting from _start.\n', '    ///        If _count is 0, all of the darknodes from _start are\n', '    ///        retrieved. If _count is more than the remaining number of\n', '    ///        registered darknodes, the rest of the list will contain\n', '    ///        0x0s.\n', '    function getDarknodes(address _start, uint256 _count) external view returns (address[]) {\n', '        uint256 count = _count;\n', '        if (count == 0) {\n', '            count = numDarknodes;\n', '        }\n', '        return getDarknodesFromEpochs(_start, count, false);\n', '    }\n', '\n', '    /// @notice Retrieves a list of darknodes which were registered for the\n', '    /// previous epoch. See `getDarknodes` for the parameter documentation.\n', '    function getPreviousDarknodes(address _start, uint256 _count) external view returns (address[]) {\n', '        uint256 count = _count;\n', '        if (count == 0) {\n', '            count = numDarknodesPreviousEpoch;\n', '        }\n', '        return getDarknodesFromEpochs(_start, count, true);\n', '    }\n', '\n', '    /// @notice Returns whether a darknode is scheduled to become registered\n', '    /// at next epoch.\n', '    /// @param _darknodeID The ID of the darknode to return\n', '    function isPendingRegistration(address _darknodeID) external view returns (bool) {\n', '        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\n', '        return registeredAt != 0 && registeredAt > currentEpoch.blocknumber;\n', '    }\n', '\n', '    /// @notice Returns if a darknode is in the pending deregistered state. In\n', '    /// this state a darknode is still considered registered.\n', '    function isPendingDeregistration(address _darknodeID) external view returns (bool) {\n', '        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n', '        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocknumber;\n', '    }\n', '\n', '    /// @notice Returns if a darknode is in the deregistered state.\n', '    function isDeregistered(address _darknodeID) public view returns (bool) {\n', '        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n', '        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocknumber;\n', '    }\n', '\n', '    /// @notice Returns if a darknode can be deregistered. This is true if the\n', '    /// darknodes is in the registered state and has not attempted to\n', '    /// deregister yet.\n', '    function isDeregisterable(address _darknodeID) public view returns (bool) {\n', '        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n', '        // The Darknode is currently in the registered state and has not been\n', '        // transitioned to the pending deregistration, or deregistered, state\n', '        return isRegistered(_darknodeID) && deregisteredAt == 0;\n', '    }\n', '\n', '    /// @notice Returns if a darknode is in the refunded state. This is true\n', '    /// for darknodes that have never been registered, or darknodes that have\n', '    /// been deregistered and refunded.\n', '    function isRefunded(address _darknodeID) public view returns (bool) {\n', '        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\n', '        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n', '        return registeredAt == 0 && deregisteredAt == 0;\n', '    }\n', '\n', '    /// @notice Returns if a darknode is refundable. This is true for darknodes\n', '    /// that have been in the deregistered state for one full epoch.\n', '    function isRefundable(address _darknodeID) public view returns (bool) {\n', '        return isDeregistered(_darknodeID) && store.darknodeDeregisteredAt(_darknodeID) <= previousEpoch.blocknumber;\n', '    }\n', '\n', '    /// @notice Returns if a darknode is in the registered state.\n', '    function isRegistered(address _darknodeID) public view returns (bool) {\n', '        return isRegisteredInEpoch(_darknodeID, currentEpoch);\n', '    }\n', '\n', '    /// @notice Returns if a darknode was in the registered state last epoch.\n', '    function isRegisteredInPreviousEpoch(address _darknodeID) public view returns (bool) {\n', '        return isRegisteredInEpoch(_darknodeID, previousEpoch);\n', '    }\n', '\n', '    /// @notice Returns if a darknode was in the registered state for a given\n', '    /// epoch.\n', '    /// @param _darknodeID The ID of the darknode\n', '    /// @param _epoch One of currentEpoch, previousEpoch\n', '    function isRegisteredInEpoch(address _darknodeID, Epoch _epoch) private view returns (bool) {\n', '        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\n', '        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n', '        bool registered = registeredAt != 0 && registeredAt <= _epoch.blocknumber;\n', '        bool notDeregistered = deregisteredAt == 0 || deregisteredAt > _epoch.blocknumber;\n', '        // The Darknode has been registered and has not yet been deregistered,\n', '        // although it might be pending deregistration\n', '        return registered && notDeregistered;\n', '    }\n', '\n', '    /// @notice Returns a list of darknodes registered for either the current\n', '    /// or the previous epoch. See `getDarknodes` for documentation on the\n', '    /// parameters `_start` and `_count`.\n', '    /// @param _usePreviousEpoch If true, use the previous epoch, otherwise use\n', '    ///        the current epoch.\n', '    function getDarknodesFromEpochs(address _start, uint256 _count, bool _usePreviousEpoch) private view returns (address[]) {\n', '        uint256 count = _count;\n', '        if (count == 0) {\n', '            count = numDarknodes;\n', '        }\n', '\n', '        address[] memory nodes = new address[](count);\n', '\n', '        // Begin with the first node in the list\n', '        uint256 n = 0;\n', '        address next = _start;\n', '        if (next == 0x0) {\n', '            next = store.begin();\n', '        }\n', '\n', '        // Iterate until all registered Darknodes have been collected\n', '        while (n < count) {\n', '            if (next == 0x0) {\n', '                break;\n', '            }\n', '            // Only include Darknodes that are currently registered\n', '            bool includeNext;\n', '            if (_usePreviousEpoch) {\n', '                includeNext = isRegisteredInPreviousEpoch(next);\n', '            } else {\n', '                includeNext = isRegistered(next);\n', '            }\n', '            if (!includeNext) {\n', '                next = store.next(next);\n', '                continue;\n', '            }\n', '            nodes[n] = next;\n', '            next = store.next(next);\n', '            n += 1;\n', '        }\n', '        return nodes;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '/// @notice Implements safeTransfer, safeTransferFrom and\n', '/// safeApprove for CompatibleERC20.\n', '///\n', '/// See https://github.com/ethereum/solidity/issues/4116\n', '///\n', '/// This library allows interacting with ERC20 tokens that implement any of\n', '/// these interfaces:\n', '///\n', '/// (1) transfer returns true on success, false on failure\n', '/// (2) transfer returns true on success, reverts on failure\n', '/// (3) transfer returns nothing on success, reverts on failure\n', '///\n', '/// Additionally, safeTransferFromWithFees will return the final token\n', '/// value received after accounting for token fees.\n', 'library CompatibleERC20Functions {\n', '    using SafeMath for uint256;\n', '\n', '    /// @notice Calls transfer on the token and reverts if the call fails.\n', '    function safeTransfer(address token, address to, uint256 amount) internal {\n', '        CompatibleERC20(token).transfer(to, amount);\n', '        require(previousReturnValue(), "transfer failed");\n', '    }\n', '\n', '    /// @notice Calls transferFrom on the token and reverts if the call fails.\n', '    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n', '        CompatibleERC20(token).transferFrom(from, to, amount);\n', '        require(previousReturnValue(), "transferFrom failed");\n', '    }\n', '\n', '    /// @notice Calls approve on the token and reverts if the call fails.\n', '    function safeApprove(address token, address spender, uint256 amount) internal {\n', '        CompatibleERC20(token).approve(spender, amount);\n', '        require(previousReturnValue(), "approve failed");\n', '    }\n', '\n', '    /// @notice Calls transferFrom on the token, reverts if the call fails and\n', '    /// returns the value transferred after fees.\n', '    function safeTransferFromWithFees(address token, address from, address to, uint256 amount) internal returns (uint256) {\n', '        uint256 balancesBefore = CompatibleERC20(token).balanceOf(to);\n', '        CompatibleERC20(token).transferFrom(from, to, amount);\n', '        require(previousReturnValue(), "transferFrom failed");\n', '        uint256 balancesAfter = CompatibleERC20(token).balanceOf(to);\n', '        return Math.min256(amount, balancesAfter.sub(balancesBefore));\n', '    }\n', '\n', '    /// @notice Checks the return value of the previous function. Returns true\n', '    /// if the previous function returned 32 non-zero bytes or returned zero\n', '    /// bytes.\n', '    function previousReturnValue() private pure returns (bool)\n', '    {\n', '        uint256 returnData = 0;\n', '\n', '        assembly { /* solium-disable-line security/no-inline-assembly */\n', '            // Switch on the number of bytes returned by the previous call\n', '            switch returndatasize\n', '\n', '            // 0 bytes: ERC20 of type (3), did not throw\n', '            case 0 {\n', '                returnData := 1\n', '            }\n', '\n', '            // 32 bytes: ERC20 of types (1) or (2)\n', '            case 32 {\n', '                // Copy the return data into scratch space\n', '                returndatacopy(0x0, 0x0, 32)\n', '\n', '                // Load  the return data into returnData\n', '                returnData := mload(0x0)\n', '            }\n', '\n', '            // Other return size: return false\n', '            default { }\n', '        }\n', '\n', '        return returnData != 0;\n', '    }\n', '}\n', '\n', "/// @notice ERC20 interface which doesn't specify the return type for transfer,\n", '/// transferFrom and approve.\n', 'interface CompatibleERC20 {\n', '    // Modified to not return boolean\n', '    function transfer(address to, uint256 value) external;\n', '    function transferFrom(address from, address to, uint256 value) external;\n', '    function approve(address spender, uint256 value) external;\n', '\n', '    // Not modifier\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/// @notice The DarknodeRewardVault contract is responsible for holding fees\n', '/// for darknodes for settling orders. Fees can be withdrawn to the address of\n', "/// the darknode's operator. Fees can be in ETH or in ERC20 tokens.\n", '/// Docs: https://github.com/republicprotocol/republic-sol/blob/master/docs/02-darknode-reward-vault.md\n', 'contract DarknodeRewardVault is Ownable {\n', '    using SafeMath for uint256;\n', '    using CompatibleERC20Functions for CompatibleERC20;\n', '\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    /// @notice The special address for Ether.\n', '    address constant public ETHEREUM = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '\n', '    DarknodeRegistry public darknodeRegistry;\n', '\n', '    mapping(address => mapping(address => uint256)) public darknodeBalances;\n', '\n', '    event LogDarknodeRegistryUpdated(DarknodeRegistry previousDarknodeRegistry, DarknodeRegistry nextDarknodeRegistry);\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _darknodeRegistry The DarknodeRegistry contract that is used by\n', '    ///        the vault to lookup Darknode owners.\n', '    constructor(string _VERSION, DarknodeRegistry _darknodeRegistry) public {\n', '        VERSION = _VERSION;\n', '        darknodeRegistry = _darknodeRegistry;\n', '    }\n', '\n', '    function updateDarknodeRegistry(DarknodeRegistry _newDarknodeRegistry) public onlyOwner {\n', '        emit LogDarknodeRegistryUpdated(darknodeRegistry, _newDarknodeRegistry);\n', '        darknodeRegistry = _newDarknodeRegistry;\n', '    }\n', '\n', '    /// @notice Deposit fees into the vault for a Darknode. The Darknode\n', '    /// registration is not checked (to reduce gas fees); the caller must be\n', '    /// careful not to call this function for a Darknode that is not registered\n', '    /// otherwise any fees deposited to that Darknode can be withdrawn by a\n', '    /// malicious adversary (by registering the Darknode before the honest\n', '    /// party and claiming ownership).\n', '    ///\n', '    /// @param _darknode The address of the Darknode that will receive the\n', '    ///        fees.\n', '    /// @param _token The address of the ERC20 token being used to pay the fee.\n', '    ///        A special address is used for Ether.\n', '    /// @param _value The amount of fees in the smallest unit of the token.\n', '    function deposit(address _darknode, ERC20 _token, uint256 _value) public payable {\n', '        uint256 receivedValue = _value;\n', '        if (address(_token) == ETHEREUM) {\n', '            require(msg.value == _value, "mismatched ether value");\n', '        } else {\n', '            require(msg.value == 0, "unexpected ether value");\n', '            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(msg.sender, address(this), _value);\n', '        }\n', '        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(receivedValue);\n', '    }\n', '\n', '    /// @notice Withdraw fees earned by a Darknode. The fees will be sent to\n', '    /// the owner of the Darknode. If a Darknode is not registered the fees\n', '    /// cannot be withdrawn.\n', '    ///\n', '    /// @param _darknode The address of the Darknode whose fees are being\n', '    ///        withdrawn. The owner of this Darknode will receive the fees.\n', '    /// @param _token The address of the ERC20 token to withdraw.\n', '    function withdraw(address _darknode, ERC20 _token) public {\n', '        address darknodeOwner = darknodeRegistry.getDarknodeOwner(address(_darknode));\n', '\n', '        require(darknodeOwner != 0x0, "invalid darknode owner");\n', '\n', '        uint256 value = darknodeBalances[_darknode][_token];\n', '        darknodeBalances[_darknode][_token] = 0;\n', '\n', '        if (address(_token) == ETHEREUM) {\n', '            darknodeOwner.transfer(value);\n', '        } else {\n', '            CompatibleERC20(_token).safeTransfer(darknodeOwner, value);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/// @notice The BrokerVerifier interface defines the functions that a settlement\n', "/// layer's broker verifier contract must implement.\n", 'interface BrokerVerifier {\n', '\n', '    /// @notice The function signature that will be called when a trader opens\n', '    /// an order.\n', '    ///\n', '    /// @param _trader The trader requesting the withdrawal.\n', '    /// @param _signature The 65-byte signature from the broker.\n', '    /// @param _orderID The 32-byte order ID.\n', '    function verifyOpenSignature(\n', '        address _trader,\n', '        bytes _signature,\n', '        bytes32 _orderID\n', '    ) external returns (bool);\n', '}\n', '\n', '/// @notice The Settlement interface defines the functions that a settlement\n', '/// layer must implement.\n', '/// Docs: https://github.com/republicprotocol/republic-sol/blob/nightly/docs/05-settlement.md\n', 'interface Settlement {\n', '    function submitOrder(\n', '        bytes _details,\n', '        uint64 _settlementID,\n', '        uint64 _tokens,\n', '        uint256 _price,\n', '        uint256 _volume,\n', '        uint256 _minimumVolume\n', '    ) external;\n', '\n', '    function submissionGasPriceLimit() external view returns (uint256);\n', '\n', '    function settle(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID\n', '    ) external;\n', '\n', '    /// @notice orderStatus should return the status of the order, which should\n', '    /// be:\n', '    ///     0  - Order not seen before\n', '    ///     1  - Order details submitted\n', '    ///     >1 - Order settled, or settlement no longer possible\n', '    function orderStatus(bytes32 _orderID) external view returns (uint8);\n', '}\n', '\n', '/// @notice SettlementRegistry allows a Settlement layer to register the\n', '/// contracts used for match settlement and for broker signature verification.\n', 'contract SettlementRegistry is Ownable {\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    struct SettlementDetails {\n', '        bool registered;\n', '        Settlement settlementContract;\n', '        BrokerVerifier brokerVerifierContract;\n', '    }\n', '\n', '    // Settlement IDs are 64-bit unsigned numbers\n', '    mapping(uint64 => SettlementDetails) public settlementDetails;\n', '\n', '    // Events\n', '    event LogSettlementRegistered(uint64 settlementID, Settlement settlementContract, BrokerVerifier brokerVerifierContract);\n', '    event LogSettlementUpdated(uint64 settlementID, Settlement settlementContract, BrokerVerifier brokerVerifierContract);\n', '    event LogSettlementDeregistered(uint64 settlementID);\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    constructor(string _VERSION) public {\n', '        VERSION = _VERSION;\n', '    }\n', '\n', '    /// @notice Returns the settlement contract of a settlement layer.\n', '    function settlementRegistration(uint64 _settlementID) external view returns (bool) {\n', '        return settlementDetails[_settlementID].registered;\n', '    }\n', '\n', '    /// @notice Returns the settlement contract of a settlement layer.\n', '    function settlementContract(uint64 _settlementID) external view returns (Settlement) {\n', '        return settlementDetails[_settlementID].settlementContract;\n', '    }\n', '\n', '    /// @notice Returns the broker verifier contract of a settlement layer.\n', '    function brokerVerifierContract(uint64 _settlementID) external view returns (BrokerVerifier) {\n', '        return settlementDetails[_settlementID].brokerVerifierContract;\n', '    }\n', '\n', '    /// @param _settlementID A unique 64-bit settlement identifier.\n', '    /// @param _settlementContract The address to use for settling matches.\n', '    /// @param _brokerVerifierContract The decimals to use for verifying\n', '    ///        broker signatures.\n', '    function registerSettlement(uint64 _settlementID, Settlement _settlementContract, BrokerVerifier _brokerVerifierContract) public onlyOwner {\n', '        bool alreadyRegistered = settlementDetails[_settlementID].registered;\n', '        \n', '        settlementDetails[_settlementID] = SettlementDetails({\n', '            registered: true,\n', '            settlementContract: _settlementContract,\n', '            brokerVerifierContract: _brokerVerifierContract\n', '        });\n', '\n', '        if (alreadyRegistered) {\n', '            emit LogSettlementUpdated(_settlementID, _settlementContract, _brokerVerifierContract);\n', '        } else {\n', '            emit LogSettlementRegistered(_settlementID, _settlementContract, _brokerVerifierContract);\n', '        }\n', '    }\n', '\n', '    /// @notice Deregisteres a settlement layer, clearing the details.\n', '    /// @param _settlementID The unique 64-bit settlement identifier.\n', '    function deregisterSettlement(uint64 _settlementID) external onlyOwner {\n', '        require(settlementDetails[_settlementID].registered, "not registered");\n', '\n', '        delete settlementDetails[_settlementID];\n', '\n', '        emit LogSettlementDeregistered(_settlementID);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    // Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(\n', '      abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)\n', '    );\n', '  }\n', '}\n', '\n', 'library Utils {\n', '\n', '    /**\n', '     * @notice Converts a number to its string/bytes representation\n', '     *\n', '     * @param _v the uint to convert\n', '     */\n', '    function uintToBytes(uint256 _v) internal pure returns (bytes) {\n', '        uint256 v = _v;\n', '        if (v == 0) {\n', '            return "0";\n', '        }\n', '\n', '        uint256 digits = 0;\n', '        uint256 v2 = v;\n', '        while (v2 > 0) {\n', '            v2 /= 10;\n', '            digits += 1;\n', '        }\n', '\n', '        bytes memory result = new bytes(digits);\n', '\n', '        for (uint256 i = 0; i < digits; i++) {\n', '            result[digits - i - 1] = bytes1((v % 10) + 48);\n', '            v /= 10;\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * @notice Retrieves the address from a signature\n', '     *\n', '     * @param _hash the message that was signed (any length of bytes)\n', '     * @param _signature the signature (65 bytes)\n', '     */\n', '    function addr(bytes _hash, bytes _signature) internal pure returns (address) {\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n";\n', '        bytes memory encoded = abi.encodePacked(prefix, uintToBytes(_hash.length), _hash);\n', '        bytes32 prefixedHash = keccak256(encoded);\n', '\n', '        return ECRecovery.recover(prefixedHash, _signature);\n', '    }\n', '\n', '}\n', '\n', '/// @notice The Orderbook contract stores the state and priority of orders and\n', '/// allows the Darknodes to easily reach consensus. Eventually, this contract\n', '/// will only store a subset of order states, such as cancellation, to improve\n', '/// the throughput of orders.\n', 'contract Orderbook is Ownable {\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    /// @notice OrderState enumerates the possible states of an order. All\n', '    /// orders default to the Undefined state.\n', '    enum OrderState {Undefined, Open, Confirmed, Canceled}\n', '\n', '    /// @notice Order stores a subset of the public data associated with an order.\n', '    struct Order {\n', '        OrderState state;     // State of the order\n', '        address trader;       // Trader that owns the order\n', '        address confirmer;    // Darknode that confirmed the order in a match\n', '        uint64 settlementID;  // The settlement that signed the order opening\n', '        uint256 priority;     // Logical time priority of this order\n', '        uint256 blockNumber;  // Block number of the most recent state change\n', '        bytes32 matchedOrder; // Order confirmed in a match with this order\n', '    }\n', '\n', '    DarknodeRegistry public darknodeRegistry;\n', '    SettlementRegistry public settlementRegistry;\n', '\n', '    bytes32[] private orderbook;\n', '\n', '    // Order details are exposed through directly accessing this mapping, or\n', "    // through the getter functions below for each of the order's fields.\n", '    mapping(bytes32 => Order) public orders;\n', '\n', '    event LogFeeUpdated(uint256 previousFee, uint256 nextFee);\n', '    event LogDarknodeRegistryUpdated(DarknodeRegistry previousDarknodeRegistry, DarknodeRegistry nextDarknodeRegistry);\n', '\n', '    /// @notice Only allow registered dark nodes.\n', '    modifier onlyDarknode(address _sender) {\n', '        require(darknodeRegistry.isRegistered(address(_sender)), "must be registered darknode");\n', '        _;\n', '    }\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _darknodeRegistry The address of the DarknodeRegistry contract.\n', '    /// @param _settlementRegistry The address of the SettlementRegistry\n', '    ///        contract.\n', '    constructor(\n', '        string _VERSION,\n', '        DarknodeRegistry _darknodeRegistry,\n', '        SettlementRegistry _settlementRegistry\n', '    ) public {\n', '        VERSION = _VERSION;\n', '        darknodeRegistry = _darknodeRegistry;\n', '        settlementRegistry = _settlementRegistry;\n', '    }\n', '\n', '    /// @notice Allows the owner to update the address of the DarknodeRegistry\n', '    /// contract.\n', '    function updateDarknodeRegistry(DarknodeRegistry _newDarknodeRegistry) external onlyOwner {\n', '        emit LogDarknodeRegistryUpdated(darknodeRegistry, _newDarknodeRegistry);\n', '        darknodeRegistry = _newDarknodeRegistry;\n', '    }\n', '\n', '    /// @notice Open an order in the orderbook. The order must be in the\n', '    /// Undefined state.\n', '    ///\n', '    /// @param _signature Signature of the message that defines the trader. The\n', '    ///        message is "Republic Protocol: open: {orderId}".\n', '    /// @param _orderID The hash of the order.\n', '    function openOrder(uint64 _settlementID, bytes _signature, bytes32 _orderID) external {\n', '        require(orders[_orderID].state == OrderState.Undefined, "invalid order status");\n', '\n', '        address trader = msg.sender;\n', '\n', '        // Verify the order signature\n', '        require(settlementRegistry.settlementRegistration(_settlementID), "settlement not registered");\n', '        BrokerVerifier brokerVerifier = settlementRegistry.brokerVerifierContract(_settlementID);\n', '        require(brokerVerifier.verifyOpenSignature(trader, _signature, _orderID), "invalid broker signature");\n', '\n', '        orders[_orderID] = Order({\n', '            state: OrderState.Open,\n', '            trader: trader,\n', '            confirmer: 0x0,\n', '            settlementID: _settlementID,\n', '            priority: orderbook.length + 1,\n', '            blockNumber: block.number,\n', '            matchedOrder: 0x0\n', '        });\n', '\n', '        orderbook.push(_orderID);\n', '    }\n', '\n', '    /// @notice Confirm an order match between orders. The confirmer must be a\n', '    /// registered Darknode and the orders must be in the Open state. A\n', '    /// malicious confirmation by a Darknode will result in a bond slash of the\n', '    /// Darknode.\n', '    ///\n', '    /// @param _orderID The hash of the order.\n', '    /// @param _matchedOrderID The hashes of the matching order.\n', '    function confirmOrder(bytes32 _orderID, bytes32 _matchedOrderID) external onlyDarknode(msg.sender) {\n', '        require(orders[_orderID].state == OrderState.Open, "invalid order status");\n', '        require(orders[_matchedOrderID].state == OrderState.Open, "invalid order status");\n', '\n', '        orders[_orderID].state = OrderState.Confirmed;\n', '        orders[_orderID].confirmer = msg.sender;\n', '        orders[_orderID].matchedOrder = _matchedOrderID;\n', '        orders[_orderID].blockNumber = block.number;\n', '\n', '        orders[_matchedOrderID].state = OrderState.Confirmed;\n', '        orders[_matchedOrderID].confirmer = msg.sender;\n', '        orders[_matchedOrderID].matchedOrder = _orderID;\n', '        orders[_matchedOrderID].blockNumber = block.number;\n', '    }\n', '\n', '    /// @notice Cancel an open order in the orderbook. An order can be cancelled\n', '    /// by the trader who opened the order, or by the broker verifier contract.\n', '    /// This allows the settlement layer to implement their own logic for\n', '    /// cancelling orders without trader interaction (e.g. to ban a trader from\n', '    /// a specific darkpool, or to use multiple order-matching platforms)\n', '    ///\n', '    /// @param _orderID The hash of the order.\n', '    function cancelOrder(bytes32 _orderID) external {\n', '        require(orders[_orderID].state == OrderState.Open, "invalid order state");\n', '\n', '        // Require the msg.sender to be the trader or the broker verifier\n', '        address brokerVerifier = address(settlementRegistry.brokerVerifierContract(orders[_orderID].settlementID));\n', '        require(msg.sender == orders[_orderID].trader || msg.sender == brokerVerifier, "not authorized");\n', '\n', '        orders[_orderID].state = OrderState.Canceled;\n', '        orders[_orderID].blockNumber = block.number;\n', '    }\n', '\n', '    /// @notice returns status of the given orderID.\n', '    function orderState(bytes32 _orderID) external view returns (OrderState) {\n', '        return orders[_orderID].state;\n', '    }\n', '\n', '    /// @notice returns a list of matched orders to the given orderID.\n', '    function orderMatch(bytes32 _orderID) external view returns (bytes32) {\n', '        return orders[_orderID].matchedOrder;\n', '    }\n', '\n', '    /// @notice returns the priority of the given orderID.\n', '    /// The priority is the index of the order in the orderbook.\n', '    function orderPriority(bytes32 _orderID) external view returns (uint256) {\n', '        return orders[_orderID].priority;\n', '    }\n', '\n', '    /// @notice returns the trader of the given orderID.\n', '    /// Trader is the one who signs the message and does the actual trading.\n', '    function orderTrader(bytes32 _orderID) external view returns (address) {\n', '        return orders[_orderID].trader;\n', '    }\n', '\n', '    /// @notice returns the darknode address which confirms the given orderID.\n', '    function orderConfirmer(bytes32 _orderID) external view returns (address) {\n', '        return orders[_orderID].confirmer;\n', '    }\n', '\n', '    /// @notice returns the block number when the order being last modified.\n', '    function orderBlockNumber(bytes32 _orderID) external view returns (uint256) {\n', '        return orders[_orderID].blockNumber;\n', '    }\n', '\n', '    /// @notice returns the block depth of the orderId\n', '    function orderDepth(bytes32 _orderID) external view returns (uint256) {\n', '        if (orders[_orderID].blockNumber == 0) {\n', '            return 0;\n', '        }\n', '        return (block.number - orders[_orderID].blockNumber);\n', '    }\n', '\n', '    /// @notice returns the number of orders in the orderbook\n', '    function ordersCount() external view returns (uint256) {\n', '        return orderbook.length;\n', '    }\n', '\n', '    /// @notice returns order details of the orders starting from the offset.\n', '    function getOrders(uint256 _offset, uint256 _limit) external view returns (bytes32[], address[], uint8[]) {\n', '        if (_offset >= orderbook.length) {\n', '            return;\n', '        }\n', '\n', '        // If the provided limit is more than the number of orders after the offset,\n', '        // decrease the limit\n', '        uint256 limit = _limit;\n', '        if (_offset + limit > orderbook.length) {\n', '            limit = orderbook.length - _offset;\n', '        }\n', '\n', '        bytes32[] memory orderIDs = new bytes32[](limit);\n', '        address[] memory traderAddresses = new address[](limit);\n', '        uint8[] memory states = new uint8[](limit);\n', '\n', '        for (uint256 i = 0; i < limit; i++) {\n', '            bytes32 order = orderbook[i + _offset];\n', '            orderIDs[i] = order;\n', '            traderAddresses[i] = orders[order].trader;\n', '            states[i] = uint8(orders[order].state);\n', '        }\n', '\n', '        return (orderIDs, traderAddresses, states);\n', '    }\n', '}\n', '\n', '/// @notice A library for calculating and verifying order match details\n', 'library SettlementUtils {\n', '\n', '    struct OrderDetails {\n', '        uint64 settlementID;\n', '        uint64 tokens;\n', '        uint256 price;\n', '        uint256 volume;\n', '        uint256 minimumVolume;\n', '    }\n', '\n', '    /// @notice Calculates the ID of the order.\n', '    /// @param details Order details that are not required for settlement\n', '    ///        execution. They are combined as a single byte array.\n', '    /// @param order The order details required for settlement execution.\n', '    function hashOrder(bytes details, OrderDetails memory order) internal pure returns (bytes32) {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                details,\n', '                order.settlementID,\n', '                order.tokens,\n', '                order.price,\n', '                order.volume,\n', '                order.minimumVolume\n', '            )\n', '        );\n', '    }\n', '\n', '    /// @notice Verifies that two orders match when considering the tokens,\n', '    /// price, volumes / minimum volumes and settlement IDs. verifyMatchDetails is used\n', '    /// my the DarknodeSlasher to verify challenges. Settlement layers may also\n', '    /// use this function.\n', '    /// @dev When verifying two orders for settlement, you should also:\n', '    ///   1) verify the orders have been confirmed together\n', "    ///   2) verify the orders' traders are distinct\n", '    /// @param _buy The buy order details.\n', '    /// @param _sell The sell order details.\n', '    function verifyMatchDetails(OrderDetails memory _buy, OrderDetails memory _sell) internal pure returns (bool) {\n', '\n', '        // Buy and sell tokens should match\n', '        if (!verifyTokens(_buy.tokens, _sell.tokens)) {\n', '            return false;\n', '        }\n', '\n', '        // Buy price should be greater than sell price\n', '        if (_buy.price < _sell.price) {\n', '            return false;\n', '        }\n', '\n', '        // // Buy volume should be greater than sell minimum volume\n', '        if (_buy.volume < _sell.minimumVolume) {\n', '            return false;\n', '        }\n', '\n', '        // Sell volume should be greater than buy minimum volume\n', '        if (_sell.volume < _buy.minimumVolume) {\n', '            return false;\n', '        }\n', '\n', '        // Require that the orders were submitted to the same settlement layer\n', '        if (_buy.settlementID != _sell.settlementID) {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Verifies that two token requirements can be matched and that the\n', '    /// tokens are formatted correctly.\n', '    /// @param _buyTokens The buy token details.\n', '    /// @param _sellToken The sell token details.\n', '    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) internal pure returns (bool) {\n', '        return ((\n', '                uint32(_buyTokens) == uint32(_sellToken >> 32)) && (\n', '                uint32(_sellToken) == uint32(_buyTokens >> 32)) && (\n', '                uint32(_buyTokens >> 32) <= uint32(_buyTokens))\n', '        );\n', '    }\n', '}\n', '\n', '/// @notice RenExTokens is a registry of tokens that can be traded on RenEx.\n', 'contract RenExTokens is Ownable {\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    struct TokenDetails {\n', '        address addr;\n', '        uint8 decimals;\n', '        bool registered;\n', '    }\n', '\n', '    // Storage\n', '    mapping(uint32 => TokenDetails) public tokens;\n', '    mapping(uint32 => bool) private detailsSubmitted;\n', '\n', '    // Events\n', '    event LogTokenRegistered(uint32 tokenCode, address tokenAddress, uint8 tokenDecimals);\n', '    event LogTokenDeregistered(uint32 tokenCode);\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    constructor(string _VERSION) public {\n', '        VERSION = _VERSION;\n', '    }\n', '\n', '    /// @notice Allows the owner to register and the details for a token.\n', '    /// Once details have been submitted, they cannot be overwritten.\n', '    /// To re-register the same token with different details (e.g. if the address\n', '    /// has changed), a different token identifier should be used and the\n', '    /// previous token identifier should be deregistered.\n', '    /// If a token is not Ethereum-based, the address will be set to 0x0.\n', '    ///\n', '    /// @param _tokenCode A unique 32-bit token identifier.\n', '    /// @param _tokenAddress The address of the token.\n', '    /// @param _tokenDecimals The decimals to use for the token.\n', '    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {\n', '        require(!tokens[_tokenCode].registered, "already registered");\n', '\n', '        // If a token is being re-registered, the same details must be provided.\n', '        if (detailsSubmitted[_tokenCode]) {\n', '            require(tokens[_tokenCode].addr == _tokenAddress, "different address");\n', '            require(tokens[_tokenCode].decimals == _tokenDecimals, "different decimals");\n', '        } else {\n', '            detailsSubmitted[_tokenCode] = true;\n', '        }\n', '\n', '        tokens[_tokenCode] = TokenDetails({\n', '            addr: _tokenAddress,\n', '            decimals: _tokenDecimals,\n', '            registered: true\n', '        });\n', '\n', '        emit LogTokenRegistered(_tokenCode, _tokenAddress, _tokenDecimals);\n', '    }\n', '\n', '    /// @notice Sets a token as being deregistered. The details are still stored\n', '    /// to prevent the token from being re-registered with different details.\n', '    ///\n', '    /// @param _tokenCode The unique 32-bit token identifier.\n', '    function deregisterToken(uint32 _tokenCode) external onlyOwner {\n', '        require(tokens[_tokenCode].registered, "not registered");\n', '\n', '        tokens[_tokenCode].registered = false;\n', '\n', '        emit LogTokenDeregistered(_tokenCode);\n', '    }\n', '}\n', '\n', '/// @notice RenExSettlement implements the Settlement interface. It implements\n', '/// the on-chain settlement for the RenEx settlement layer, and the fee payment\n', '/// for the RenExAtomic settlement layer.\n', 'contract RenExSettlement is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    // This contract handles the settlements with ID 1 and 2.\n', '    uint32 constant public RENEX_SETTLEMENT_ID = 1;\n', '    uint32 constant public RENEX_ATOMIC_SETTLEMENT_ID = 2;\n', '\n', '    // Fees in RenEx are 0.2%. To represent this as integers, it is broken into\n', '    // a numerator and denominator.\n', '    uint256 constant public DARKNODE_FEES_NUMERATOR = 2;\n', '    uint256 constant public DARKNODE_FEES_DENOMINATOR = 1000;\n', '\n', '    // Constants used in the price / volume inputs.\n', '    int16 constant private PRICE_OFFSET = 12;\n', '    int16 constant private VOLUME_OFFSET = 12;\n', '\n', '    // Constructor parameters, updatable by the owner\n', '    Orderbook public orderbookContract;\n', '    RenExTokens public renExTokensContract;\n', '    RenExBalances public renExBalancesContract;\n', '    address public slasherAddress;\n', '    uint256 public submissionGasPriceLimit;\n', '\n', '    enum OrderStatus {None, Submitted, Settled, Slashed}\n', '\n', '    struct TokenPair {\n', '        RenExTokens.TokenDetails priorityToken;\n', '        RenExTokens.TokenDetails secondaryToken;\n', '    }\n', '\n', '    // A uint256 tuple representing a value and an associated fee\n', '    struct ValueWithFees {\n', '        uint256 value;\n', '        uint256 fees;\n', '    }\n', '\n', '    // A uint256 tuple representing a fraction\n', '    struct Fraction {\n', '        uint256 numerator;\n', '        uint256 denominator;\n', '    }\n', '\n', '    // We use left and right because the tokens do not always represent the\n', '    // priority and secondary tokens.\n', '    struct SettlementDetails {\n', '        uint256 leftVolume;\n', '        uint256 rightVolume;\n', '        uint256 leftTokenFee;\n', '        uint256 rightTokenFee;\n', '        address leftTokenAddress;\n', '        address rightTokenAddress;\n', '    }\n', '\n', '    // Events\n', '    event LogOrderbookUpdated(Orderbook previousOrderbook, Orderbook nextOrderbook);\n', '    event LogRenExTokensUpdated(RenExTokens previousRenExTokens, RenExTokens nextRenExTokens);\n', '    event LogRenExBalancesUpdated(RenExBalances previousRenExBalances, RenExBalances nextRenExBalances);\n', '    event LogSubmissionGasPriceLimitUpdated(uint256 previousSubmissionGasPriceLimit, uint256 nextSubmissionGasPriceLimit);\n', '    event LogSlasherUpdated(address previousSlasher, address nextSlasher);\n', '\n', '    // Order Storage\n', '    mapping(bytes32 => SettlementUtils.OrderDetails) public orderDetails;\n', '    mapping(bytes32 => address) public orderSubmitter;\n', '    mapping(bytes32 => OrderStatus) public orderStatus;\n', '\n', '    // Match storage (match details are indexed by [buyID][sellID])\n', '    mapping(bytes32 => mapping(bytes32 => uint256)) public matchTimestamp;\n', '\n', '    /// @notice Prevents a function from being called with a gas price higher\n', '    /// than the specified limit.\n', '    ///\n', '    /// @param _gasPriceLimit The gas price upper-limit in Wei.\n', '    modifier withGasPriceLimit(uint256 _gasPriceLimit) {\n', '        require(tx.gasprice <= _gasPriceLimit, "gas price too high");\n', '        _;\n', '    }\n', '\n', '    /// @notice Restricts a function to only being called by the slasher\n', '    /// address.\n', '    modifier onlySlasher() {\n', '        require(msg.sender == slasherAddress, "unauthorized");\n', '        _;\n', '    }\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _orderbookContract The address of the Orderbook contract.\n', '    /// @param _renExBalancesContract The address of the RenExBalances\n', '    ///        contract.\n', '    /// @param _renExTokensContract The address of the RenExTokens contract.\n', '    constructor(\n', '        string _VERSION,\n', '        Orderbook _orderbookContract,\n', '        RenExTokens _renExTokensContract,\n', '        RenExBalances _renExBalancesContract,\n', '        address _slasherAddress,\n', '        uint256 _submissionGasPriceLimit\n', '    ) public {\n', '        VERSION = _VERSION;\n', '        orderbookContract = _orderbookContract;\n', '        renExTokensContract = _renExTokensContract;\n', '        renExBalancesContract = _renExBalancesContract;\n', '        slasherAddress = _slasherAddress;\n', '        submissionGasPriceLimit = _submissionGasPriceLimit;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the Orderbook address.\n', '    /// @param _newOrderbookContract The address of the new Orderbook contract.\n', '    function updateOrderbook(Orderbook _newOrderbookContract) external onlyOwner {\n', '        emit LogOrderbookUpdated(orderbookContract, _newOrderbookContract);\n', '        orderbookContract = _newOrderbookContract;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the RenExTokens address.\n', '    /// @param _newRenExTokensContract The address of the new RenExTokens\n', '    ///       contract.\n', '    function updateRenExTokens(RenExTokens _newRenExTokensContract) external onlyOwner {\n', '        emit LogRenExTokensUpdated(renExTokensContract, _newRenExTokensContract);\n', '        renExTokensContract = _newRenExTokensContract;\n', '    }\n', '    \n', '    /// @notice The owner of the contract can update the RenExBalances address.\n', '    /// @param _newRenExBalancesContract The address of the new RenExBalances\n', '    ///       contract.\n', '    function updateRenExBalances(RenExBalances _newRenExBalancesContract) external onlyOwner {\n', '        emit LogRenExBalancesUpdated(renExBalancesContract, _newRenExBalancesContract);\n', '        renExBalancesContract = _newRenExBalancesContract;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the order submission gas\n', '    /// price limit.\n', '    /// @param _newSubmissionGasPriceLimit The new gas price limit.\n', '    function updateSubmissionGasPriceLimit(uint256 _newSubmissionGasPriceLimit) external onlyOwner {\n', '        emit LogSubmissionGasPriceLimitUpdated(submissionGasPriceLimit, _newSubmissionGasPriceLimit);\n', '        submissionGasPriceLimit = _newSubmissionGasPriceLimit;\n', '    }\n', '\n', '    /// @notice The owner of the contract can update the slasher address.\n', '    /// @param _newSlasherAddress The new slasher address.\n', '    function updateSlasher(address _newSlasherAddress) external onlyOwner {\n', '        emit LogSlasherUpdated(slasherAddress, _newSlasherAddress);\n', '        slasherAddress = _newSlasherAddress;\n', '    }\n', '\n', '    /// @notice Stores the details of an order.\n', '    ///\n', '    /// @param _prefix The miscellaneous details of the order required for\n', '    ///        calculating the order id.\n', '    /// @param _settlementID The settlement identifier.\n', '    /// @param _tokens The encoding of the token pair (buy token is encoded as\n', '    ///        the first 32 bytes and sell token is encoded as the last 32\n', '    ///        bytes).\n', '    /// @param _price The price of the order. Interpreted as the cost for 1\n', '    ///        standard unit of the non-priority token, in 1e12 (i.e.\n', '    ///        PRICE_OFFSET) units of the priority token).\n', '    /// @param _volume The volume of the order. Interpreted as the maximum\n', '    ///        number of 1e-12 (i.e. VOLUME_OFFSET) units of the non-priority\n', '    ///        token that can be traded by this order.\n', '    /// @param _minimumVolume The minimum volume the trader is willing to\n', '    ///        accept. Encoded the same as the volume.\n', '    function submitOrder(\n', '        bytes _prefix,\n', '        uint64 _settlementID,\n', '        uint64 _tokens,\n', '        uint256 _price,\n', '        uint256 _volume,\n', '        uint256 _minimumVolume\n', '    ) external withGasPriceLimit(submissionGasPriceLimit) {\n', '\n', '        SettlementUtils.OrderDetails memory order = SettlementUtils.OrderDetails({\n', '            settlementID: _settlementID,\n', '            tokens: _tokens,\n', '            price: _price,\n', '            volume: _volume,\n', '            minimumVolume: _minimumVolume\n', '        });\n', '        bytes32 orderID = SettlementUtils.hashOrder(_prefix, order);\n', '\n', '        require(orderStatus[orderID] == OrderStatus.None, "order already submitted");\n', '        require(orderbookContract.orderState(orderID) == Orderbook.OrderState.Confirmed, "unconfirmed order");\n', '\n', '        orderSubmitter[orderID] = msg.sender;\n', '        orderStatus[orderID] = OrderStatus.Submitted;\n', '        orderDetails[orderID] = order;\n', '    }\n', '\n', '    /// @notice Settles two orders that are matched. `submitOrder` must have been\n', '    /// called for each order before this function is called.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    function settle(bytes32 _buyID, bytes32 _sellID) external {\n', '        require(orderStatus[_buyID] == OrderStatus.Submitted, "invalid buy status");\n', '        require(orderStatus[_sellID] == OrderStatus.Submitted, "invalid sell status");\n', '\n', '        // Check the settlement ID (only have to check for one, since\n', '        // `verifyMatchDetails` checks that they are the same)\n', '        require(\n', '            orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID ||\n', '            orderDetails[_buyID].settlementID == RENEX_SETTLEMENT_ID,\n', '            "invalid settlement id"\n', '        );\n', '\n', '        // Verify that the two order details are compatible.\n', '        require(SettlementUtils.verifyMatchDetails(orderDetails[_buyID], orderDetails[_sellID]), "incompatible orders");\n', '\n', '        // Verify that the two orders have been confirmed to one another.\n', '        require(orderbookContract.orderMatch(_buyID) == _sellID, "unconfirmed orders");\n', '\n', '        // Retrieve token details.\n', '        TokenPair memory tokens = getTokenDetails(orderDetails[_buyID].tokens);\n', '\n', '        // Require that the tokens have been registered.\n', '        require(tokens.priorityToken.registered, "unregistered priority token");\n', '        require(tokens.secondaryToken.registered, "unregistered secondary token");\n', '\n', '        address buyer = orderbookContract.orderTrader(_buyID);\n', '        address seller = orderbookContract.orderTrader(_sellID);\n', '\n', '        require(buyer != seller, "orders from same trader");\n', '\n', '        execute(_buyID, _sellID, buyer, seller, tokens);\n', '\n', '        /* solium-disable-next-line security/no-block-members */\n', '        matchTimestamp[_buyID][_sellID] = now;\n', '\n', '        // Store that the orders have been settled.\n', '        orderStatus[_buyID] = OrderStatus.Settled;\n', '        orderStatus[_sellID] = OrderStatus.Settled;\n', '    }\n', '\n', '    /// @notice Slashes the bond of a guilty trader. This is called when an\n', '    /// atomic swap is not executed successfully.\n', '    /// To open an atomic order, a trader must have a balance equivalent to\n', '    /// 0.6% of the trade in the Ethereum-based token. 0.2% is always paid in\n', '    /// darknode fees when the order is matched. If the remaining amount is\n', '    /// is slashed, it is distributed as follows:\n', '    ///   1) 0.2% goes to the other trader, covering their fee\n', '    ///   2) 0.2% goes to the slasher address\n', '    /// Only one order in a match can be slashed.\n', '    ///\n', '    /// @param _guiltyOrderID The 32 byte ID of the order of the guilty trader.\n', '    function slash(bytes32 _guiltyOrderID) external onlySlasher {\n', '        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, "slashing non-atomic trade");\n', '\n', '        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);\n', '\n', '        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, "invalid order status");\n', '        require(orderStatus[innocentOrderID] == OrderStatus.Settled, "invalid order status");\n', '        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;\n', '\n', '        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ?\n', '            (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);\n', '\n', '        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);\n', '\n', '        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);\n', '\n', '        // Transfer the fee amount to the other trader\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            orderbookContract.orderTrader(_guiltyOrderID),\n', '            orderbookContract.orderTrader(innocentOrderID),\n', '            settlementDetails.leftTokenAddress,\n', '            settlementDetails.leftTokenFee,\n', '            0,\n', '            0x0\n', '        );\n', '\n', '        // Transfer the fee amount to the slasher\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            orderbookContract.orderTrader(_guiltyOrderID),\n', '            slasherAddress,\n', '            settlementDetails.leftTokenAddress,\n', '            settlementDetails.leftTokenFee,\n', '            0,\n', '            0x0\n', '        );\n', '    }\n', '\n', '    /// @notice Retrieves the settlement details of an order.\n', '    /// For atomic swaps, it returns the full volumes, not the settled fees.\n', '    ///\n', '    /// @param _orderID The order to lookup the details of. Can be the ID of a\n', '    ///        buy or a sell order.\n', '    /// @return [\n', '    ///     a boolean representing whether or not the order has been settled,\n', '    ///     a boolean representing whether or not the order is a buy\n', '    ///     the 32-byte order ID of the matched order\n', '    ///     the volume of the priority token,\n', '    ///     the volume of the secondary token,\n', '    ///     the fee paid in the priority token,\n', '    ///     the fee paid in the secondary token,\n', '    ///     the token code of the priority token,\n', '    ///     the token code of the secondary token\n', '    /// ]\n', '    function getMatchDetails(bytes32 _orderID)\n', '    external view returns (\n', '        bool settled,\n', '        bool orderIsBuy,\n', '        bytes32 matchedID,\n', '        uint256 priorityVolume,\n', '        uint256 secondaryVolume,\n', '        uint256 priorityFee,\n', '        uint256 secondaryFee,\n', '        uint32 priorityToken,\n', '        uint32 secondaryToken\n', '    ) {\n', '        matchedID = orderbookContract.orderMatch(_orderID);\n', '\n', '        orderIsBuy = isBuyOrder(_orderID);\n', '\n', '        (bytes32 buyID, bytes32 sellID) = orderIsBuy ?\n', '            (_orderID, matchedID) : (matchedID, _orderID);\n', '\n', '        SettlementDetails memory settlementDetails = calculateSettlementDetails(\n', '            buyID,\n', '            sellID,\n', '            getTokenDetails(orderDetails[buyID].tokens)\n', '        );\n', '\n', '        return (\n', '            orderStatus[_orderID] == OrderStatus.Settled || orderStatus[_orderID] == OrderStatus.Slashed,\n', '            orderIsBuy,\n', '            matchedID,\n', '            settlementDetails.leftVolume,\n', '            settlementDetails.rightVolume,\n', '            settlementDetails.leftTokenFee,\n', '            settlementDetails.rightTokenFee,\n', '            uint32(orderDetails[buyID].tokens >> 32),\n', '            uint32(orderDetails[buyID].tokens)\n', '        );\n', '    }\n', '\n', '    /// @notice Exposes the hashOrder function for computing a hash of an\n', "    /// order's details. An order hash is used as its ID. See `submitOrder`\n", '    /// for the parameter descriptions.\n', '    ///\n', '    /// @return The 32-byte hash of the order.\n', '    function hashOrder(\n', '        bytes _prefix,\n', '        uint64 _settlementID,\n', '        uint64 _tokens,\n', '        uint256 _price,\n', '        uint256 _volume,\n', '        uint256 _minimumVolume\n', '    ) external pure returns (bytes32) {\n', '        return SettlementUtils.hashOrder(_prefix, SettlementUtils.OrderDetails({\n', '            settlementID: _settlementID,\n', '            tokens: _tokens,\n', '            price: _price,\n', '            volume: _volume,\n', '            minimumVolume: _minimumVolume\n', '        }));\n', '    }\n', '\n', '    /// @notice Called by `settle`, executes the settlement for a RenEx order\n', '    /// or distributes the fees for a RenExAtomic swap.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    /// @param _buyer The address of the buy trader.\n', '    /// @param _seller The address of the sell trader.\n', '    /// @param _tokens The details of the priority and secondary tokens.\n', '    function execute(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID,\n', '        address _buyer,\n', '        address _seller,\n', '        TokenPair memory _tokens\n', '    ) private {\n', '        // Calculate the fees for atomic swaps, and the settlement details\n', '        // otherwise.\n', '        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ?\n', '            settlementDetails = calculateAtomicFees(_buyID, _sellID, _tokens) :\n', '            settlementDetails = calculateSettlementDetails(_buyID, _sellID, _tokens);\n', '\n', '        // Transfer priority token value\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            _buyer,\n', '            _seller,\n', '            settlementDetails.leftTokenAddress,\n', '            settlementDetails.leftVolume,\n', '            settlementDetails.leftTokenFee,\n', '            orderSubmitter[_buyID]\n', '        );\n', '\n', '        // Transfer secondary token value\n', '        renExBalancesContract.transferBalanceWithFee(\n', '            _seller,\n', '            _buyer,\n', '            settlementDetails.rightTokenAddress,\n', '            settlementDetails.rightVolume,\n', '            settlementDetails.rightTokenFee,\n', '            orderSubmitter[_sellID]\n', '        );\n', '    }\n', '\n', '    /// @notice Calculates the details required to execute two matched orders.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    /// @param _tokens The details of the priority and secondary tokens.\n', '    /// @return A struct containing the settlement details.\n', '    function calculateSettlementDetails(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID,\n', '        TokenPair memory _tokens\n', '    ) private view returns (SettlementDetails memory) {\n', '\n', '        // Calculate the mid-price (using numerator and denominator to not loose\n', '        // precision).\n', '        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\n', '\n', '        // Calculate the lower of the two max volumes of each trader\n', '        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\n', '\n', '        uint256 priorityTokenVolume = joinFraction(\n', '            commonVolume.mul(midPrice.numerator),\n', '            midPrice.denominator,\n', '            int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\n', '        );\n', '        uint256 secondaryTokenVolume = joinFraction(\n', '            commonVolume,\n', '            1,\n', '            int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\n', '        );\n', '\n', '        // Calculate darknode fees\n', '        ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\n', '        ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\n', '\n', '        return SettlementDetails({\n', '            leftVolume: priorityVwF.value,\n', '            rightVolume: secondaryVwF.value,\n', '            leftTokenFee: priorityVwF.fees,\n', '            rightTokenFee: secondaryVwF.fees,\n', '            leftTokenAddress: _tokens.priorityToken.addr,\n', '            rightTokenAddress: _tokens.secondaryToken.addr\n', '        });\n', '    }\n', '\n', '    /// @notice Calculates the fees to be transferred for an atomic swap.\n', '    ///\n', '    /// @param _buyID The 32 byte ID of the buy order.\n', '    /// @param _sellID The 32 byte ID of the sell order.\n', '    /// @param _tokens The details of the priority and secondary tokens.\n', '    /// @return A struct containing the fee details.\n', '    function calculateAtomicFees(\n', '        bytes32 _buyID,\n', '        bytes32 _sellID,\n', '        TokenPair memory _tokens\n', '    ) private view returns (SettlementDetails memory) {\n', '\n', '        // Calculate the mid-price (using numerator and denominator to not loose\n', '        // precision).\n', '        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\n', '\n', '        // Calculate the lower of the two max volumes of each trader\n', '        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\n', '\n', '        if (isEthereumBased(_tokens.secondaryToken.addr)) {\n', '            uint256 secondaryTokenVolume = joinFraction(\n', '                commonVolume,\n', '                1,\n', '                int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\n', '            );\n', '\n', '            // Calculate darknode fees\n', '            ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\n', '\n', '            return SettlementDetails({\n', '                leftVolume: 0,\n', '                rightVolume: 0,\n', '                leftTokenFee: secondaryVwF.fees,\n', '                rightTokenFee: secondaryVwF.fees,\n', '                leftTokenAddress: _tokens.secondaryToken.addr,\n', '                rightTokenAddress: _tokens.secondaryToken.addr\n', '            });\n', '        } else if (isEthereumBased(_tokens.priorityToken.addr)) {\n', '            uint256 priorityTokenVolume = joinFraction(\n', '                commonVolume.mul(midPrice.numerator),\n', '                midPrice.denominator,\n', '                int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\n', '            );\n', '\n', '            // Calculate darknode fees\n', '            ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\n', '\n', '            return SettlementDetails({\n', '                leftVolume: 0,\n', '                rightVolume: 0,\n', '                leftTokenFee: priorityVwF.fees,\n', '                rightTokenFee: priorityVwF.fees,\n', '                leftTokenAddress: _tokens.priorityToken.addr,\n', '                rightTokenAddress: _tokens.priorityToken.addr\n', '            });\n', '        } else {\n', '            // Currently, at least one token must be Ethereum-based.\n', '            // This will be implemented in the future.\n', '            revert("non-eth atomic swaps are not supported");\n', '        }\n', '    }\n', '\n', '    /// @notice Order parity is set by the order tokens are listed. This returns\n', '    /// whether an order is a buy or a sell.\n', '    /// @return true if _orderID is a buy order.\n', '    function isBuyOrder(bytes32 _orderID) private view returns (bool) {\n', '        uint64 tokens = orderDetails[_orderID].tokens;\n', '        uint32 firstToken = uint32(tokens >> 32);\n', '        uint32 secondaryToken = uint32(tokens);\n', '        return (firstToken < secondaryToken);\n', '    }\n', '\n', '    /// @return (value - fee, fee) where fee is 0.2% of value\n', '    function subtractDarknodeFee(uint256 _value) private pure returns (ValueWithFees memory) {\n', '        uint256 newValue = (_value * (DARKNODE_FEES_DENOMINATOR - DARKNODE_FEES_NUMERATOR)) / DARKNODE_FEES_DENOMINATOR;\n', '        return ValueWithFees(newValue, _value - newValue);\n', '    }\n', '\n', '    /// @notice Gets the order details of the priority and secondary token from\n', '    /// the RenExTokens contract and returns them as a single struct.\n', '    ///\n', '    /// @param _tokens The 64-bit combined token identifiers.\n', '    /// @return A TokenPair struct containing two TokenDetails structs.\n', '    function getTokenDetails(uint64 _tokens) private view returns (TokenPair memory) {\n', '        (\n', '            address priorityAddress,\n', '            uint8 priorityDecimals,\n', '            bool priorityRegistered\n', '        ) = renExTokensContract.tokens(uint32(_tokens >> 32));\n', '\n', '        (\n', '            address secondaryAddress,\n', '            uint8 secondaryDecimals,\n', '            bool secondaryRegistered\n', '        ) = renExTokensContract.tokens(uint32(_tokens));\n', '\n', '        return TokenPair({\n', '            priorityToken: RenExTokens.TokenDetails(priorityAddress, priorityDecimals, priorityRegistered),\n', '            secondaryToken: RenExTokens.TokenDetails(secondaryAddress, secondaryDecimals, secondaryRegistered)\n', '        });\n', '    }\n', '\n', '    /// @return true if _tokenAddress is 0x0, representing a token that is not\n', '    /// on Ethereum\n', '    function isEthereumBased(address _tokenAddress) private pure returns (bool) {\n', '        return (_tokenAddress != address(0x0));\n', '    }\n', '\n', '    /// @notice Computes (_numerator / _denominator) * 10 ** _scale\n', '    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) private pure returns (uint256) {\n', '        if (_scale >= 0) {\n', "            // Check that (10**_scale) doesn't overflow\n", '            assert(_scale <= 77); // log10(2**256) = 77.06\n', '            return _numerator.mul(10 ** uint256(_scale)) / _denominator;\n', '        } else {\n', '            /// @dev If _scale is less than -77, 10**-_scale would overflow.\n', '            // For now, -_scale > -24 (when a token has 0 decimals and\n', '            // VOLUME_OFFSET and PRICE_OFFSET are each 12). It is unlikely these\n', '            // will be increased to add to more than 77.\n', '            // assert((-_scale) <= 77); // log10(2**256) = 77.06\n', '            return (_numerator / _denominator) / 10 ** uint256(-_scale);\n', '        }\n', '    }\n', '}\n', '\n', '/// @notice RenExBrokerVerifier implements the BrokerVerifier contract,\n', '/// verifying broker signatures for order opening and fund withdrawal.\n', 'contract RenExBrokerVerifier is Ownable {\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    // Events\n', '    event LogBalancesContractUpdated(address previousBalancesContract, address nextBalancesContract);\n', '    event LogBrokerRegistered(address broker);\n', '    event LogBrokerDeregistered(address broker);\n', '\n', '    // Storage\n', '    mapping(address => bool) public brokers;\n', '    mapping(address => uint256) public traderNonces;\n', '\n', '    address public balancesContract;\n', '\n', '    modifier onlyBalancesContract() {\n', '        require(msg.sender == balancesContract, "not authorized");\n', '        _;\n', '    }\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    constructor(string _VERSION) public {\n', '        VERSION = _VERSION;\n', '    }\n', '\n', '    /// @notice Allows the owner of the contract to update the address of the\n', '    /// RenExBalances contract.\n', '    ///\n', '    /// @param _balancesContract The address of the new balances contract\n', '    function updateBalancesContract(address _balancesContract) external onlyOwner {\n', '        emit LogBalancesContractUpdated(balancesContract, _balancesContract);\n', '\n', '        balancesContract = _balancesContract;\n', '    }\n', '\n', '    /// @notice Approved an address to sign order-opening and withdrawals.\n', '    /// @param _broker The address of the broker.\n', '    function registerBroker(address _broker) external onlyOwner {\n', '        require(!brokers[_broker], "already registered");\n', '        brokers[_broker] = true;\n', '        emit LogBrokerRegistered(_broker);\n', '    }\n', '\n', "    /// @notice Reverts the a broker's registration.\n", '    /// @param _broker The address of the broker.\n', '    function deregisterBroker(address _broker) external onlyOwner {\n', '        require(brokers[_broker], "not registered");\n', '        brokers[_broker] = false;\n', '        emit LogBrokerDeregistered(_broker);\n', '    }\n', '\n', "    /// @notice Verifies a broker's signature for an order opening.\n", '    /// The data signed by the broker is a prefixed message and the order ID.\n', '    ///\n', '    /// @param _trader The trader requesting the withdrawal.\n', '    /// @param _signature The 65-byte signature from the broker.\n', '    /// @param _orderID The 32-byte order ID.\n', '    /// @return True if the signature is valid, false otherwise.\n', '    function verifyOpenSignature(\n', '        address _trader,\n', '        bytes _signature,\n', '        bytes32 _orderID\n', '    ) external view returns (bool) {\n', '        bytes memory data = abi.encodePacked("Republic Protocol: open: ", _trader, _orderID);\n', '        address signer = Utils.addr(data, _signature);\n', '        return (brokers[signer] == true);\n', '    }\n', '\n', "    /// @notice Verifies a broker's signature for a trader withdrawal.\n", '    /// The data signed by the broker is a prefixed message, the trader address\n', '    /// and a 256-bit trader nonce, which is incremented every time a valid\n', '    /// signature is checked.\n', '    ///\n', '    /// @param _trader The trader requesting the withdrawal.\n', '    /// @param _signature 65-byte signature from the broker.\n', '    /// @return True if the signature is valid, false otherwise.\n', '    function verifyWithdrawSignature(\n', '        address _trader,\n', '        bytes _signature\n', '    ) external onlyBalancesContract returns (bool) {\n', '        bytes memory data = abi.encodePacked("Republic Protocol: withdraw: ", _trader, traderNonces[_trader]);\n', '        address signer = Utils.addr(data, _signature);\n', '        if (brokers[signer]) {\n', '            traderNonces[_trader] += 1;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '}\n', '\n', '/// @notice RenExBalances is responsible for holding RenEx trader funds.\n', 'contract RenExBalances is Ownable {\n', '    using SafeMath for uint256;\n', '    using CompatibleERC20Functions for CompatibleERC20;\n', '\n', '    string public VERSION; // Passed in as a constructor parameter.\n', '\n', '    RenExSettlement public settlementContract;\n', '    RenExBrokerVerifier public brokerVerifierContract;\n', '    DarknodeRewardVault public rewardVaultContract;\n', '\n', '    /// @dev Should match the address in the DarknodeRewardVault\n', '    address constant public ETHEREUM = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n', '    \n', '    // Delay between a trader calling `withdrawSignal` and being able to call\n', '    // `withdraw` without a broker signature.\n', '    uint256 constant public SIGNAL_DELAY = 48 hours;\n', '\n', '    // Events\n', '    event LogBalanceDecreased(address trader, ERC20 token, uint256 value);\n', '    event LogBalanceIncreased(address trader, ERC20 token, uint256 value);\n', '    event LogRenExSettlementContractUpdated(address previousRenExSettlementContract, address newRenExSettlementContract);\n', '    event LogRewardVaultContractUpdated(address previousRewardVaultContract, address newRewardVaultContract);\n', '    event LogBrokerVerifierContractUpdated(address previousBrokerVerifierContract, address newBrokerVerifierContract);\n', '\n', '    // Storage\n', '    mapping(address => mapping(address => uint256)) public traderBalances;\n', '    mapping(address => mapping(address => uint256)) public traderWithdrawalSignals;\n', '\n', '    /// @notice The contract constructor.\n', '    ///\n', '    /// @param _VERSION A string defining the contract version.\n', '    /// @param _rewardVaultContract The address of the RewardVault contract.\n', '    constructor(\n', '        string _VERSION,\n', '        DarknodeRewardVault _rewardVaultContract,\n', '        RenExBrokerVerifier _brokerVerifierContract\n', '    ) public {\n', '        VERSION = _VERSION;\n', '        rewardVaultContract = _rewardVaultContract;\n', '        brokerVerifierContract = _brokerVerifierContract;\n', '    }\n', '\n', '    /// @notice Restricts a function to only being called by the RenExSettlement\n', '    /// contract.\n', '    modifier onlyRenExSettlementContract() {\n', '        require(msg.sender == address(settlementContract), "not authorized");\n', '        _;\n', '    }\n', '\n', '    /// @notice Restricts trader withdrawing to be called if a signature from a\n', '    /// RenEx broker is provided, or if a certain amount of time has passed\n', '    /// since a trader has called `signalBackupWithdraw`.\n', '    /// @dev If the trader is withdrawing after calling `signalBackupWithdraw`,\n', '    /// this will reset the time to zero, writing to storage.\n', '    modifier withBrokerSignatureOrSignal(address _token, bytes _signature) {\n', '        address trader = msg.sender;\n', '\n', '        // If a signature has been provided, verify it - otherwise, verify that\n', '        // the user has signalled the withdraw\n', '        if (_signature.length > 0) {\n', '            require (brokerVerifierContract.verifyWithdrawSignature(trader, _signature), "invalid signature");\n', '        } else  {\n', '            require(traderWithdrawalSignals[trader][_token] != 0, "not signalled");\n', '            /* solium-disable-next-line security/no-block-members */\n', '            require((now - traderWithdrawalSignals[trader][_token]) > SIGNAL_DELAY, "signal time remaining");\n', '            traderWithdrawalSignals[trader][_token] = 0;\n', '        }\n', '        _;\n', '    }\n', '\n', '    /// @notice Allows the owner of the contract to update the address of the\n', '    /// RenExSettlement contract.\n', '    ///\n', '    /// @param _newSettlementContract the address of the new settlement contract\n', '    function updateRenExSettlementContract(RenExSettlement _newSettlementContract) external onlyOwner {\n', '        emit LogRenExSettlementContractUpdated(settlementContract, _newSettlementContract);\n', '        settlementContract = _newSettlementContract;\n', '    }\n', '\n', '    /// @notice Allows the owner of the contract to update the address of the\n', '    /// DarknodeRewardVault contract.\n', '    ///\n', '    /// @param _newRewardVaultContract the address of the new reward vault contract\n', '    function updateRewardVaultContract(DarknodeRewardVault _newRewardVaultContract) external onlyOwner {\n', '        emit LogRewardVaultContractUpdated(rewardVaultContract, _newRewardVaultContract);\n', '        rewardVaultContract = _newRewardVaultContract;\n', '    }\n', '\n', '    /// @notice Allows the owner of the contract to update the address of the\n', '    /// RenExBrokerVerifier contract.\n', '    ///\n', '    /// @param _newBrokerVerifierContract the address of the new broker verifier contract\n', '    function updateBrokerVerifierContract(RenExBrokerVerifier _newBrokerVerifierContract) external onlyOwner {\n', '        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);\n', '        brokerVerifierContract = _newBrokerVerifierContract;\n', '    }\n', '\n', '    /// @notice Transfer a token value from one trader to another, transferring\n', '    /// a fee to the RewardVault. Can only be called by the RenExSettlement\n', '    /// contract.\n', '    ///\n', '    /// @param _traderFrom The address of the trader to decrement the balance of.\n', '    /// @param _traderTo The address of the trader to increment the balance of.\n', "    /// @param _token The token's address.\n", '    /// @param _value The number of tokens to decrement the balance by (in the\n', "    ///        token's smallest unit).\n", '    /// @param _fee The fee amount to forward on to the RewardVault.\n', '    /// @param _feePayee The recipient of the fee.\n', '    function transferBalanceWithFee(address _traderFrom, address _traderTo, address _token, uint256 _value, uint256 _fee, address _feePayee)\n', '    external onlyRenExSettlementContract {\n', '        require(traderBalances[_traderFrom][_token] >= _fee, "insufficient funds for fee");\n', '\n', '        if (address(_token) == ETHEREUM) {\n', '            rewardVaultContract.deposit.value(_fee)(_feePayee, ERC20(_token), _fee);\n', '        } else {\n', '            CompatibleERC20(_token).safeApprove(rewardVaultContract, _fee);\n', '            rewardVaultContract.deposit(_feePayee, ERC20(_token), _fee);\n', '        }\n', '        privateDecrementBalance(_traderFrom, ERC20(_token), _value + _fee);\n', '        if (_value > 0) {\n', '            privateIncrementBalance(_traderTo, ERC20(_token), _value);\n', '        }\n', '    }\n', '\n', '    /// @notice Deposits ETH or an ERC20 token into the contract.\n', '    ///\n', "    /// @param _token The token's address (must be a registered token).\n", "    /// @param _value The amount to deposit in the token's smallest unit.\n", '    function deposit(ERC20 _token, uint256 _value) external payable {\n', '        address trader = msg.sender;\n', '\n', '        uint256 receivedValue = _value;\n', '        if (address(_token) == ETHEREUM) {\n', '            require(msg.value == _value, "mismatched value parameter and tx value");\n', '        } else {\n', '            require(msg.value == 0, "unexpected ether transfer");\n', '            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(trader, this, _value);\n', '        }\n', '        privateIncrementBalance(trader, _token, receivedValue);\n', '    }\n', '\n', '    /// @notice Withdraws ETH or an ERC20 token from the contract. A broker\n', '    /// signature is required to guarantee that the trader has a sufficient\n', '    /// balance after accounting for open orders. As a trustless backup,\n', '    /// traders can withdraw 48 hours after calling `signalBackupWithdraw`.\n', '    ///\n', "    /// @param _token The token's address.\n", "    /// @param _value The amount to withdraw in the token's smallest unit.\n", '    /// @param _signature The broker signature\n', '    function withdraw(ERC20 _token, uint256 _value, bytes _signature) external withBrokerSignatureOrSignal(_token, _signature) {\n', '        address trader = msg.sender;\n', '\n', '        privateDecrementBalance(trader, _token, _value);\n', '        if (address(_token) == ETHEREUM) {\n', '            trader.transfer(_value);\n', '        } else {\n', '            CompatibleERC20(_token).safeTransfer(trader, _value);\n', '        }\n', '    }\n', '\n', '    /// @notice A trader can withdraw without needing a broker signature if they\n', '    /// first call `signalBackupWithdraw` for the token they want to withdraw.\n', '    /// The trader can only withdraw the particular token once for each call to\n', '    /// this function. Traders can signal the intent to withdraw multiple\n', '    /// tokens.\n', '    /// Once this function is called, brokers will not sign order-opens for the\n', "    /// trader until the trader has withdrawn, guaranteeing that they won't have\n", '    /// orders open for the particular token.\n', '    function signalBackupWithdraw(address _token) external {\n', '        /* solium-disable-next-line security/no-block-members */\n', '        traderWithdrawalSignals[msg.sender][_token] = now;\n', '    }\n', '\n', '    function privateIncrementBalance(address _trader, ERC20 _token, uint256 _value) private {\n', '        traderBalances[_trader][_token] = traderBalances[_trader][_token].add(_value);\n', '\n', '        emit LogBalanceIncreased(_trader, _token, _value);\n', '    }\n', '\n', '    function privateDecrementBalance(address _trader, ERC20 _token, uint256 _value) private {\n', '        require(traderBalances[_trader][_token] >= _value, "insufficient funds");\n', '        traderBalances[_trader][_token] = traderBalances[_trader][_token].sub(_value);\n', '\n', '        emit LogBalanceDecreased(_trader, _token, _value);\n', '    }\n', '}']
