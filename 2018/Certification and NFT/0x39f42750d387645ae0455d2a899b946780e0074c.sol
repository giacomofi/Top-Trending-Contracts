['pragma solidity ^0.4.24;\n', '\n', 'contract Approvable {\n', '\n', '    mapping(address => bool) public approved;\n', '\n', '    constructor () public {\n', '        approved[msg.sender] = true;\n', '    }\n', '\n', '    function approve(address _address) public onlyApproved {\n', '        require(_address != address(0));\n', '        approved[_address] = true;\n', '    }\n', '\n', '    function revokeApproval(address _address) public onlyApproved {\n', '        require(_address != address(0));\n', '        approved[_address] = false;\n', '    }\n', '\n', '    modifier onlyApproved() {\n', '        require(approved[msg.sender]);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract DIDToken is Approvable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    event LogIssueDID(address indexed to, uint256 numDID);\n', '    event LogDecrementDID(address indexed to, uint256 numDID);\n', '    event LogExchangeDIDForEther(address indexed to, uint256 numDID);\n', '    event LogInvestEtherForDID(address indexed to, uint256 numWei);\n', '\n', '    address[] public DIDHoldersArray;\n', '\n', '    address public PullRequestsAddress;\n', '    address public DistenseAddress;\n', '\n', '    uint256 public investmentLimitAggregate  = 100000 ether;  // This is the max DID all addresses can receive from depositing ether\n', '    uint256 public investmentLimitAddress = 100 ether;  // This is the max DID any address can receive from Ether deposit\n', '    uint256 public investedAggregate = 1 ether;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    struct DIDHolder {\n', '        uint256 balance;\n', '        uint256 netContributionsDID;    // essentially the number of DID remaining for calculating how much ether an account may invest\n', '        uint256 DIDHoldersIndex;\n', '        uint256 weiInvested;\n', '        uint256 tasksCompleted;\n', '    }\n', '    mapping (address => DIDHolder) public DIDHolders;\n', '\n', '    constructor () public {\n', '        name = "Distense DID";\n', '        symbol = "DID";\n', '        totalSupply = 0;\n', '        decimals = 18;\n', '    }\n', '\n', '    function issueDID(address _recipient, uint256 _numDID) public onlyApproved returns (bool) {\n', '        require(_recipient != address(0));\n', '        require(_numDID > 0);\n', '\n', '        _numDID = _numDID * 1 ether;\n', '        totalSupply = SafeMath.add(totalSupply, _numDID);\n', '        \n', '        uint256 balance = DIDHolders[_recipient].balance;\n', '        DIDHolders[_recipient].balance = SafeMath.add(balance, _numDID);\n', '\n', '        //  If is a new DIDHolder, set their position in DIDHoldersArray\n', '        if (DIDHolders[_recipient].DIDHoldersIndex == 0) {\n', '            uint256 index = DIDHoldersArray.push(_recipient) - 1;\n', '            DIDHolders[_recipient].DIDHoldersIndex = index;\n', '        }\n', '\n', '        emit LogIssueDID(_recipient, _numDID);\n', '\n', '        return true;\n', '    }\n', '\n', '    function decrementDID(address _address, uint256 _numDID) external onlyApproved returns (uint256) {\n', '        require(_address != address(0));\n', '        require(_numDID > 0);\n', '\n', '        uint256 numDID = _numDID * 1 ether;\n', '        require(SafeMath.sub(DIDHolders[_address].balance, numDID) >= 0);\n', '        require(SafeMath.sub(totalSupply, numDID ) >= 0);\n', '\n', '        totalSupply = SafeMath.sub(totalSupply, numDID);\n', '        DIDHolders[_address].balance = SafeMath.sub(DIDHolders[_address].balance, numDID);\n', '\n', '        //  If DIDHolder has exchanged all of their DID remove from DIDHoldersArray\n', '        //  For minimizing blockchain size and later client query performance\n', '        if (DIDHolders[_address].balance == 0) {\n', '            deleteDIDHolderWhenBalanceZero(_address);\n', '        }\n', '\n', '        emit LogDecrementDID(_address, numDID);\n', '\n', '        return DIDHolders[_address].balance;\n', '    }\n', '\n', '    function exchangeDIDForEther(uint256 _numDIDToExchange)\n', '        external\n', '    returns (uint256) {\n', '\n', '        uint256 numDIDToExchange = _numDIDToExchange * 1 ether;\n', '        uint256 netContributionsDID = getNumContributionsDID(msg.sender);\n', '        require(netContributionsDID >= numDIDToExchange);\n', '\n', '        Distense distense = Distense(DistenseAddress);\n', '        uint256 DIDPerEther = distense.getParameterValueByTitle(distense.didPerEtherParameterTitle());\n', '\n', '        require(numDIDToExchange < totalSupply);\n', '\n', '        uint256 numWeiToIssue = calculateNumWeiToIssue(numDIDToExchange, DIDPerEther);\n', '        address contractAddress = this;\n', '        require(contractAddress.balance >= numWeiToIssue, "DIDToken contract must have sufficient wei");\n', '\n', '        //  Adjust number of DID owned first\n', '        DIDHolders[msg.sender].balance = SafeMath.sub(DIDHolders[msg.sender].balance, numDIDToExchange);\n', '        DIDHolders[msg.sender].netContributionsDID = SafeMath.sub(DIDHolders[msg.sender].netContributionsDID, numDIDToExchange);\n', '        totalSupply = SafeMath.sub(totalSupply, numDIDToExchange);\n', '\n', '        msg.sender.transfer(numWeiToIssue);\n', '\n', '        if (DIDHolders[msg.sender].balance == 0) {\n', '            deleteDIDHolderWhenBalanceZero(msg.sender);\n', '        }\n', '        emit LogExchangeDIDForEther(msg.sender, numDIDToExchange);\n', '\n', '        return DIDHolders[msg.sender].balance;\n', '    }\n', '\n', '    function investEtherForDID() external payable returns (uint256) {\n', '        require(getNumWeiAddressMayInvest(msg.sender) >= msg.value);\n', '        require(investedAggregate < investmentLimitAggregate);\n', '\n', '        Distense distense = Distense(DistenseAddress);\n', '        uint256 DIDPerEther = SafeMath.div(distense.getParameterValueByTitle(distense.didPerEtherParameterTitle()), 1 ether);\n', '\n', '        uint256 numDIDToIssue = calculateNumDIDToIssue(msg.value, DIDPerEther);\n', '        require(DIDHolders[msg.sender].netContributionsDID >= numDIDToIssue);\n', '        totalSupply = SafeMath.add(totalSupply, numDIDToIssue);\n', '        DIDHolders[msg.sender].balance = SafeMath.add(DIDHolders[msg.sender].balance, numDIDToIssue);\n', '        DIDHolders[msg.sender].netContributionsDID = SafeMath.sub(DIDHolders[msg.sender].netContributionsDID, numDIDToIssue);\n', '\n', '        DIDHolders[msg.sender].weiInvested += msg.value;\n', '        investedAggregate = investedAggregate + msg.value;\n', '\n', '        emit LogIssueDID(msg.sender, numDIDToIssue);\n', '        emit LogInvestEtherForDID(msg.sender, msg.value);\n', '\n', '        return DIDHolders[msg.sender].balance;\n', '    }\n', '\n', '    function incrementDIDFromContributions(address _contributor, uint256 _reward) onlyApproved public {\n', '        uint256 weiReward = _reward * 1 ether;\n', '        DIDHolders[_contributor].netContributionsDID = SafeMath.add(DIDHolders[_contributor].netContributionsDID, weiReward);\n', '    }\n', '\n', '    function incrementTasksCompleted(address _contributor) onlyApproved public returns (bool) {\n', '        DIDHolders[_contributor].tasksCompleted++;\n', '        return true;\n', '    }\n', '\n', '    function pctDIDOwned(address _address) external view returns (uint256) {\n', '        return SafeMath.percent(DIDHolders[_address].balance, totalSupply, 20);\n', '    }\n', '\n', '    function getNumWeiAddressMayInvest(address _contributor) public view returns (uint256) {\n', '\n', '        uint256 DIDFromContributions = DIDHolders[_contributor].netContributionsDID;\n', '        require(DIDFromContributions > 0);\n', '        uint256 netUninvestedEther = SafeMath.sub(investmentLimitAddress, DIDHolders[_contributor].weiInvested);\n', '        require(netUninvestedEther > 0);\n', '\n', '        Distense distense = Distense(DistenseAddress);\n', '        uint256 DIDPerEther = distense.getParameterValueByTitle(distense.didPerEtherParameterTitle());\n', '\n', '        return (DIDFromContributions * 1 ether) / DIDPerEther;\n', '    }\n', '\n', '    function rewardContributor(address _contributor, uint256 _reward) external onlyApproved returns (bool) {\n', '        uint256 reward = SafeMath.div(_reward, 1 ether);\n', '        bool issued = issueDID(_contributor, reward);\n', '        if (issued) incrementDIDFromContributions(_contributor, reward);\n', '        incrementTasksCompleted(_contributor);\n', '    }\n', '\n', '    function getWeiAggregateMayInvest() public view returns (uint256) {\n', '        return SafeMath.sub(investmentLimitAggregate, investedAggregate);\n', '    }\n', '\n', '    function getNumDIDHolders() external view returns (uint256) {\n', '        return DIDHoldersArray.length;\n', '    }\n', '\n', '    function getAddressBalance(address _address) public view returns (uint256) {\n', '        return DIDHolders[_address].balance;\n', '    }\n', '\n', '    function getNumContributionsDID(address _address) public view returns (uint256) {\n', '        return DIDHolders[_address].netContributionsDID;\n', '    }\n', '\n', '    function getWeiInvested(address _address) public view returns (uint256) {\n', '        return DIDHolders[_address].weiInvested;\n', '    }\n', '\n', '    function calculateNumDIDToIssue(uint256 msgValue, uint256 DIDPerEther) public pure returns (uint256) {\n', '        return SafeMath.mul(msgValue, DIDPerEther);\n', '    }\n', '\n', '    function calculateNumWeiToIssue(uint256 _numDIDToExchange, uint256 _DIDPerEther) public pure returns (uint256) {\n', '        _numDIDToExchange = _numDIDToExchange * 1 ether;\n', '        return SafeMath.div(_numDIDToExchange, _DIDPerEther);\n', '    }\n', '\n', '    function deleteDIDHolderWhenBalanceZero(address holder) internal {\n', '        if (DIDHoldersArray.length > 1) {\n', '            address lastElement = DIDHoldersArray[DIDHoldersArray.length - 1];\n', '            DIDHoldersArray[DIDHolders[holder].DIDHoldersIndex] = lastElement;\n', '            DIDHoldersArray.length--;\n', '            delete DIDHolders[holder];\n', '        }\n', '    }\n', '\n', '    function deleteDIDHolder(address holder) public onlyApproved {\n', '        if (DIDHoldersArray.length > 1) {\n', '            address lastElement = DIDHoldersArray[DIDHoldersArray.length - 1];\n', '            DIDHoldersArray[DIDHolders[holder].DIDHoldersIndex] = lastElement;\n', '            DIDHoldersArray.length--;\n', '            delete DIDHolders[holder];\n', '        }\n', '    }\n', '\n', '    function setDistenseAddress(address _distenseAddress) onlyApproved public  {\n', '        DistenseAddress = _distenseAddress;\n', '    }\n', '\n', '}\n', '\n', 'contract Distense is Approvable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    address public DIDTokenAddress;\n', '\n', '    /*\n', '      Distense&#39; votable parameters\n', '      Parameter is the perfect word` for these: "a numerical or other measurable factor forming one of a set\n', '      that defines a system or sets the conditions of its operation".\n', '    */\n', '\n', '    //  Titles are what uniquely identify parameters, so query by titles when iterating with clients\n', '    bytes32[] public parameterTitles;\n', '\n', '    struct Parameter {\n', '        bytes32 title;\n', '        uint256 value;\n', '        mapping(address => Vote) votes;\n', '    }\n', '\n', '    struct Vote {\n', '        address voter;\n', '        uint256 lastVoted;\n', '    }\n', '\n', '    mapping(bytes32 => Parameter) public parameters;\n', '\n', '    Parameter public votingIntervalParameter;\n', '    bytes32 public votingIntervalParameterTitle = &#39;votingInterval&#39;;\n', '\n', '    Parameter public pctDIDToDetermineTaskRewardParameter;\n', '    bytes32 public pctDIDToDetermineTaskRewardParameterTitle = &#39;pctDIDToDetermineTaskReward&#39;;\n', '\n', '    Parameter public pctDIDRequiredToMergePullRequest;\n', '    bytes32 public pctDIDRequiredToMergePullRequestTitle = &#39;pctDIDRequiredToMergePullRequest&#39;;\n', '\n', '    Parameter public maxRewardParameter;\n', '    bytes32 public maxRewardParameterTitle = &#39;maxReward&#39;;\n', '\n', '    Parameter public numDIDRequiredToApproveVotePullRequestParameter;\n', '    bytes32 public numDIDRequiredToApproveVotePullRequestParameterTitle = &#39;numDIDReqApproveVotePullRequest&#39;;\n', '\n', '    Parameter public numDIDRequiredToTaskRewardVoteParameter;\n', '    bytes32 public numDIDRequiredToTaskRewardVoteParameterTitle = &#39;numDIDRequiredToTaskRewardVote&#39;;\n', '\n', '    Parameter public minNumberOfTaskRewardVotersParameter;\n', '    bytes32 public minNumberOfTaskRewardVotersParameterTitle = &#39;minNumberOfTaskRewardVoters&#39;;\n', '\n', '    Parameter public numDIDRequiredToAddTaskParameter;\n', '    bytes32 public numDIDRequiredToAddTaskParameterTitle = &#39;numDIDRequiredToAddTask&#39;;\n', '\n', '    Parameter public defaultRewardParameter;\n', '    bytes32 public defaultRewardParameterTitle = &#39;defaultReward&#39;;\n', '\n', '    Parameter public didPerEtherParameter;\n', '    bytes32 public didPerEtherParameterTitle = &#39;didPerEther&#39;;\n', '\n', '    Parameter public votingPowerLimitParameter;\n', '    bytes32 public votingPowerLimitParameterTitle = &#39;votingPowerLimit&#39;;\n', '\n', '    event LogParameterValueUpdate(bytes32 title, uint256 value);\n', '\n', '    constructor (address _DIDTokenAddress) public {\n', '\n', '        DIDTokenAddress = _DIDTokenAddress;\n', '\n', '        // Launch Distense with some votable parameters\n', '        // that can be later updated by contributors\n', '        // Current values can be found at https://disten.se/parameters\n', '\n', '        // Percentage of DID that must vote on a proposal for it to be approved and payable\n', '        pctDIDToDetermineTaskRewardParameter = Parameter({\n', '            title : pctDIDToDetermineTaskRewardParameterTitle,\n', '            //     Every hard-coded int except for dates and numbers (not percentages) pertaining to ether or DID are decimals to two decimal places\n', '            //     So this is 15.00%\n', '            value: 15 * 1 ether\n', '        });\n', '        parameters[pctDIDToDetermineTaskRewardParameterTitle] = pctDIDToDetermineTaskRewardParameter;\n', '        parameterTitles.push(pctDIDToDetermineTaskRewardParameterTitle);\n', '\n', '\n', '        pctDIDRequiredToMergePullRequest = Parameter({\n', '            title : pctDIDRequiredToMergePullRequestTitle,\n', '            value: 10 * 1 ether\n', '        });\n', '        parameters[pctDIDRequiredToMergePullRequestTitle] = pctDIDRequiredToMergePullRequest;\n', '        parameterTitles.push(pctDIDRequiredToMergePullRequestTitle);\n', '\n', '\n', '        votingIntervalParameter = Parameter({\n', '            title : votingIntervalParameterTitle,\n', '            value: 1296000 * 1 ether// 15 * 86400 = 1.296e+6\n', '        });\n', '        parameters[votingIntervalParameterTitle] = votingIntervalParameter;\n', '        parameterTitles.push(votingIntervalParameterTitle);\n', '\n', '\n', '        maxRewardParameter = Parameter({\n', '            title : maxRewardParameterTitle,\n', '            value: 2000 * 1 ether\n', '        });\n', '        parameters[maxRewardParameterTitle] = maxRewardParameter;\n', '        parameterTitles.push(maxRewardParameterTitle);\n', '\n', '\n', '        numDIDRequiredToApproveVotePullRequestParameter = Parameter({\n', '            title : numDIDRequiredToApproveVotePullRequestParameterTitle,\n', '            //     100 DID\n', '            value: 100 * 1 ether\n', '        });\n', '        parameters[numDIDRequiredToApproveVotePullRequestParameterTitle] = numDIDRequiredToApproveVotePullRequestParameter;\n', '        parameterTitles.push(numDIDRequiredToApproveVotePullRequestParameterTitle);\n', '\n', '\n', '        // This parameter is the number of DID an account must own to vote on a task&#39;s reward\n', '        // The task reward is the number of DID payable upon successful completion and approval of a task\n', '\n', '        // This parameter mostly exists to get the percentage of DID that have voted higher per voter\n', '        //   as looping through voters to determineReward()s is gas-expensive.\n', '\n', '        // This parameter also limits attacks by noobs that want to mess with Distense.\n', '        numDIDRequiredToTaskRewardVoteParameter = Parameter({\n', '            title : numDIDRequiredToTaskRewardVoteParameterTitle,\n', '            // 100\n', '            value: 100 * 1 ether\n', '        });\n', '        parameters[numDIDRequiredToTaskRewardVoteParameterTitle] = numDIDRequiredToTaskRewardVoteParameter;\n', '        parameterTitles.push(numDIDRequiredToTaskRewardVoteParameterTitle);\n', '\n', '\n', '        minNumberOfTaskRewardVotersParameter = Parameter({\n', '            title : minNumberOfTaskRewardVotersParameterTitle,\n', '            //     7\n', '            value: 7 * 1 ether\n', '        });\n', '        parameters[minNumberOfTaskRewardVotersParameterTitle] = minNumberOfTaskRewardVotersParameter;\n', '        parameterTitles.push(minNumberOfTaskRewardVotersParameterTitle);\n', '\n', '\n', '        numDIDRequiredToAddTaskParameter = Parameter({\n', '            title : numDIDRequiredToAddTaskParameterTitle,\n', '            //     100\n', '            value: 100 * 1 ether\n', '        });\n', '        parameters[numDIDRequiredToAddTaskParameterTitle] = numDIDRequiredToAddTaskParameter;\n', '        parameterTitles.push(numDIDRequiredToAddTaskParameterTitle);\n', '\n', '\n', '        defaultRewardParameter = Parameter({\n', '            title : defaultRewardParameterTitle,\n', '            //     100\n', '            value: 100 * 1 ether\n', '        });\n', '        parameters[defaultRewardParameterTitle] = defaultRewardParameter;\n', '        parameterTitles.push(defaultRewardParameterTitle);\n', '\n', '\n', '        didPerEtherParameter = Parameter({\n', '            title : didPerEtherParameterTitle,\n', '            //     1000\n', '            value: 200 * 1 ether\n', '        });\n', '        parameters[didPerEtherParameterTitle] = didPerEtherParameter;\n', '        parameterTitles.push(didPerEtherParameterTitle);\n', '\n', '        votingPowerLimitParameter = Parameter({\n', '            title : votingPowerLimitParameterTitle,\n', '            //     20.00%\n', '            value: 20 * 1 ether\n', '        });\n', '        parameters[votingPowerLimitParameterTitle] = votingPowerLimitParameter;\n', '        parameterTitles.push(votingPowerLimitParameterTitle);\n', '\n', '    }\n', '\n', '    function getParameterValueByTitle(bytes32 _title) public view returns (uint256) {\n', '        return parameters[_title].value;\n', '    }\n', '\n', '    /**\n', '        Function called when contributors vote on parameters at /parameters url\n', '        In the client there are: max and min buttons and a text input\n', '\n', '        @param _title name of parameter title the DID holder is voting on.  This must be one of the hardcoded titles in this file.\n', '        @param _voteValue integer in percentage effect.  For example if the current value of a parameter is 20, and the voter votes 24, _voteValue\n', '        would be 20, for a 20% increase.\n', '\n', '        If _voteValue is 1 it&#39;s a max upvote, if -1 max downvote. Maximum votes, as just mentioned, affect parameter values by\n', '        max(percentage of DID owned by the voter, value of the votingLimit parameter).\n', '        If _voteValue has a higher absolute value than 1, the user has voted a specific value not maximum up or downvote.\n', '        In that case we update the value to the voted value if the value would affect the parameter value less than their percentage DID ownership.\n', '          If they voted a value that would affect the parameter&#39;s value by more than their percentage DID ownership we affect the value by their percentage DID ownership.\n', '    */\n', '    function voteOnParameter(bytes32 _title, int256 _voteValue)\n', '        public\n', '        votingIntervalReached(msg.sender, _title)\n', '        returns\n', '    (uint256) {\n', '\n', '        DIDToken didToken = DIDToken(DIDTokenAddress);\n', '        uint256 votersDIDPercent = didToken.pctDIDOwned(msg.sender);\n', '        require(votersDIDPercent > 0);\n', '\n', '        uint256 currentValue = getParameterValueByTitle(_title);\n', '\n', '        //  For voting power purposes, limit the pctDIDOwned to the maximum of the Voting Power Limit parameter or the voter&#39;s percentage ownership\n', '        //  of DID\n', '        uint256 votingPowerLimit = getParameterValueByTitle(votingPowerLimitParameterTitle);\n', '\n', '        uint256 limitedVotingPower = votersDIDPercent > votingPowerLimit ? votingPowerLimit : votersDIDPercent;\n', '\n', '        uint256 update;\n', '        if (\n', '            _voteValue == 1 ||  // maximum upvote\n', '            _voteValue == - 1 || // minimum downvote\n', '            _voteValue > int(limitedVotingPower) || // vote value greater than votingPowerLimit\n', '            _voteValue < - int(limitedVotingPower)  // vote value greater than votingPowerLimit absolute value\n', '        ) {\n', '            update = (limitedVotingPower * currentValue) / (100 * 1 ether);\n', '        } else if (_voteValue > 0) {\n', '            update = SafeMath.div((uint(_voteValue) * currentValue), (1 ether * 100));\n', '        } else if (_voteValue < 0) {\n', '            int256 adjustedVoteValue = (-_voteValue); // make the voteValue positive and convert to on-chain decimals\n', '            update = uint((adjustedVoteValue * int(currentValue))) / (100 * 1 ether);\n', '        } else revert(); //  If _voteValue is 0 refund gas to voter\n', '\n', '        if (_voteValue > 0)\n', '            currentValue = SafeMath.add(currentValue, update);\n', '        else\n', '            currentValue = SafeMath.sub(currentValue, update);\n', '\n', '        updateParameterValue(_title, currentValue);\n', '        updateLastVotedOnParameter(_title, msg.sender);\n', '        emit LogParameterValueUpdate(_title, currentValue);\n', '\n', '        return currentValue;\n', '    }\n', '\n', '    function getParameterByTitle(bytes32 _title) public view returns (bytes32, uint256) {\n', '        Parameter memory param = parameters[_title];\n', '        return (param.title, param.value);\n', '    }\n', '\n', '    function getNumParameters() public view returns (uint256) {\n', '        return parameterTitles.length;\n', '    }\n', '\n', '    function updateParameterValue(bytes32 _title, uint256 _newValue) internal returns (uint256) {\n', '        Parameter storage parameter = parameters[_title];\n', '        parameter.value = _newValue;\n', '        return parameter.value;\n', '    }\n', '\n', '    function updateLastVotedOnParameter(bytes32 _title, address voter) internal returns (bool) {\n', '        Parameter storage parameter = parameters[_title];\n', '        parameter.votes[voter].lastVoted = now;\n', '    }\n', '\n', '    function setDIDTokenAddress(address _didTokenAddress) public onlyApproved {\n', '        DIDTokenAddress = _didTokenAddress;\n', '    }\n', '\n', '    modifier votingIntervalReached(address _voter, bytes32 _title) {\n', '        Parameter storage parameter = parameters[_title];\n', '        uint256 lastVotedOnParameter = parameter.votes[_voter].lastVoted * 1 ether;\n', '        require((now * 1 ether) >= lastVotedOnParameter + getParameterValueByTitle(votingIntervalParameterTitle));\n', '        _;\n', '    }\n', '}\n', '\n', 'contract PullRequests is Approvable {\n', '\n', '    address public DIDTokenAddress;\n', '    address public DistenseAddress;\n', '    address public TasksAddress;\n', '\n', '    struct PullRequest {\n', '        address contributor;\n', '        bytes32 taskId;\n', '        uint128 prNum;\n', '        uint256 pctDIDApproved;\n', '        mapping(address => bool) voted;\n', '    }\n', '\n', '    bytes32[] public pullRequestIds;\n', '\n', '    mapping(bytes32 => PullRequest) pullRequests;\n', '\n', '    event LogAddPullRequest(bytes32 _prId, bytes32 taskId, uint128 prNum);\n', '    event LogPullRequestApprovalVote(bytes32 _prId, uint256 pctDIDApproved);\n', '    event LogRewardPullRequest(bytes32 _prId, bytes32 taskId, uint128 prNum);\n', '\n', '    constructor (\n', '        address _DIDTokenAddress,\n', '        address _DistenseAddress,\n', '        address _TasksAddress\n', '    ) public {\n', '        DIDTokenAddress = _DIDTokenAddress;\n', '        DistenseAddress = _DistenseAddress;\n', '        TasksAddress = _TasksAddress;\n', '    }\n', '\n', '    function addPullRequest(bytes32 _prId, bytes32 _taskId, uint128 _prNum) external returns (bool) {\n', '        pullRequests[_prId].contributor = msg.sender;\n', '        pullRequests[_prId].taskId = _taskId;\n', '        pullRequests[_prId].prNum = _prNum;\n', '        pullRequestIds.push(_prId);\n', '\n', '        emit LogAddPullRequest(_prId, _taskId, _prNum);\n', '\n', '        return true;\n', '    }\n', '\n', '    function getPullRequestById(bytes32 _prId) external view returns (address, bytes32, uint128, uint256) {\n', '        PullRequest memory pr = pullRequests[_prId];\n', '        return (pr.contributor, pr.taskId, pr.prNum, pr.pctDIDApproved);\n', '    }\n', '\n', '    function getNumPullRequests() external view returns (uint256) {\n', '        return pullRequestIds.length;\n', '    }\n', '\n', '    function approvePullRequest(bytes32 _prId)\n', '        hasEnoughDIDToApprovePR\n', '        external\n', '    returns (uint256) {\n', '\n', '        require(pullRequests[_prId].voted[msg.sender] == false, "voter already voted on this PR");\n', '        require(pullRequests[_prId].contributor != msg.sender, "contributor voted on their PR");\n', '        Distense distense = Distense(DistenseAddress);\n', '        DIDToken didToken = DIDToken(DIDTokenAddress);\n', '\n', '        PullRequest storage _pr = pullRequests[_prId];\n', '\n', '        //  Record approval vote to prevent multiple voting\n', '        _pr.voted[msg.sender] = true;\n', '\n', '        //  This is not very gas efficient at all but the stack was too deep.  Need to refactor/research ways to improve\n', '        //  Increment _pr.pctDIDApproved by the lower of the votingPowerLimitParameter or the voters pctDIDOwned\n', '        _pr.pctDIDApproved += didToken.pctDIDOwned(msg.sender) > distense.getParameterValueByTitle(\n', '            distense.votingPowerLimitParameterTitle()\n', '        ) ? distense.getParameterValueByTitle(\n', '            distense.votingPowerLimitParameterTitle()\n', '        ) : didToken.pctDIDOwned(msg.sender);\n', '\n', '        if (\n', '            _pr.pctDIDApproved > distense.getParameterValueByTitle(\n', '                distense.pctDIDRequiredToMergePullRequestTitle()\n', '            )\n', '        ) {\n', '            Tasks tasks = Tasks(TasksAddress);\n', '\n', '            uint256 reward;\n', '            Tasks.RewardStatus rewardStatus;\n', '            (reward, rewardStatus) = tasks.getTaskRewardAndStatus(_pr.taskId);\n', '\n', '            require(rewardStatus != Tasks.RewardStatus.PAID);\n', '            Tasks.RewardStatus updatedRewardStatus = tasks.setTaskRewardPaid(_pr.taskId);\n', '\n', '            //  Only issueDID after we confirm taskRewardPaid\n', '            require(updatedRewardStatus == Tasks.RewardStatus.PAID);\n', '            didToken.rewardContributor(_pr.contributor, reward);\n', '\n', '            emit LogRewardPullRequest(_prId, _pr.taskId, _pr.prNum);\n', '        }\n', '\n', '        emit LogPullRequestApprovalVote(_prId, _pr.pctDIDApproved);\n', '        return _pr.pctDIDApproved;\n', '    }\n', '\n', '    modifier hasEnoughDIDToApprovePR() {\n', '\n', '        Distense distense = Distense(DistenseAddress);\n', '        uint256 threshold = distense.getParameterValueByTitle(\n', '            distense.numDIDRequiredToApproveVotePullRequestParameterTitle()\n', '        );\n', '\n', '        DIDToken didToken = DIDToken(DIDTokenAddress);\n', '\n', '        require(didToken.getNumContributionsDID(msg.sender) > threshold);\n', '        _;\n', '    }\n', '\n', '    function setDIDTokenAddress(address _DIDTokenAddress) public onlyApproved {\n', '        DIDTokenAddress = _DIDTokenAddress;\n', '    }\n', '\n', '    function setDistenseAddress(address _DistenseAddress) public onlyApproved {\n', '        DistenseAddress = _DistenseAddress;\n', '    }\n', '\n', '    function setTasksAddress(address _TasksAddress) public onlyApproved {\n', '        TasksAddress = _TasksAddress;\n', '    }\n', '}\n', '\n', 'contract Tasks is Approvable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    address public DIDTokenAddress;\n', '    address public DistenseAddress;\n', '\n', '    bytes32[] public taskIds;\n', '\n', '    enum RewardStatus { TENTATIVE, DETERMINED, PAID }\n', '\n', '    struct Task {\n', '        string title;\n', '        address createdBy;\n', '        uint256 reward;\n', '        RewardStatus rewardStatus;\n', '        uint256 pctDIDVoted;\n', '        uint64 numVotes;\n', '        mapping(address => bool) rewardVotes;\n', '        uint256 taskIdsIndex;   // for easy later deletion to minimize query time and blockchain size\n', '    }\n', '\n', '    mapping(bytes32 => Task) tasks;\n', '    mapping(bytes32 => bool) tasksTitles;\n', '\n', '    event LogAddTask(bytes32 taskId, string title);\n', '    event LogTaskRewardVote(bytes32 taskId, uint256 reward, uint256 pctDIDVoted);\n', '    event LogTaskRewardDetermined(bytes32 taskId, uint256 reward);\n', '\n', '    constructor (address _DIDTokenAddress, address _DistenseAddress) public {\n', '        DIDTokenAddress = _DIDTokenAddress;\n', '        DistenseAddress = _DistenseAddress;\n', '    }\n', '\n', '    function addTask(bytes32 _taskId, string _title) external hasEnoughDIDToAddTask returns\n', '        (bool) {\n', '\n', '        bytes32 titleBytes32 = keccak256(abi.encodePacked(_title));\n', '        require(!tasksTitles[titleBytes32], "Task title already exists");\n', '\n', '        Distense distense = Distense(DistenseAddress);\n', '\n', '        tasks[_taskId].createdBy = msg.sender;\n', '        tasks[_taskId].title = _title;\n', '        tasks[_taskId].reward = distense.getParameterValueByTitle(distense.defaultRewardParameterTitle());\n', '        tasks[_taskId].rewardStatus = RewardStatus.TENTATIVE;\n', '\n', '        taskIds.push(_taskId);\n', '        tasksTitles[titleBytes32] = true;\n', '        tasks[_taskId].taskIdsIndex = taskIds.length - 1;\n', '        emit LogAddTask(_taskId, _title);\n', '\n', '        return true;\n', '    }\n', '\n', '    function getTaskById(bytes32 _taskId) external view returns (\n', '        string,\n', '        address,\n', '        uint256,\n', '        Tasks.RewardStatus,\n', '        uint256,\n', '        uint64\n', '    ) {\n', '\n', '        Task memory task = tasks[_taskId];\n', '        return (\n', '            task.title,\n', '            task.createdBy,\n', '            task.reward,\n', '            task.rewardStatus,\n', '            task.pctDIDVoted,\n', '            task.numVotes\n', '        );\n', '\n', '    }\n', '\n', '    function taskExists(bytes32 _taskId) external view returns (bool) {\n', '        return tasks[_taskId].createdBy != 0;\n', '    }\n', '\n', '    function getNumTasks() external view returns (uint256) {\n', '        return taskIds.length;\n', '    }\n', '\n', '    function taskRewardVote(bytes32 _taskId, uint256 _reward) external returns (bool) {\n', '\n', '        DIDToken didToken = DIDToken(DIDTokenAddress);\n', '        uint256 balance = didToken.getAddressBalance(msg.sender);\n', '        Distense distense = Distense(DistenseAddress);\n', '\n', '        Task storage task = tasks[_taskId];\n', '\n', '        require(_reward >= 0);\n', '\n', '        //  Essentially refund the remaining gas if user&#39;s vote will have no effect\n', '        require(task.reward != (_reward * 1 ether));\n', '\n', '        // Don&#39;t let the voter vote if the reward has already been determined\n', '        require(task.rewardStatus != RewardStatus.DETERMINED);\n', '\n', '        //  Has the voter already voted on this task?\n', '        require(!task.rewardVotes[msg.sender]);\n', '\n', '        //  Does the voter own at least as many DID as the reward their voting for?\n', '        //  This ensures new contributors don&#39;t have too much sway over the issuance of new DID.\n', '        require(balance > distense.getParameterValueByTitle(distense.numDIDRequiredToTaskRewardVoteParameterTitle()));\n', '\n', '        //  Require the reward to be less than or equal to the maximum reward parameter,\n', '        //  which basically is a hard, floating limit on the number of DID that can be issued for any single task\n', '        require((_reward * 1 ether) <= distense.getParameterValueByTitle(distense.maxRewardParameterTitle()));\n', '\n', '        task.rewardVotes[msg.sender] = true;\n', '\n', '        uint256 pctDIDOwned = didToken.pctDIDOwned(msg.sender);\n', '        task.pctDIDVoted = task.pctDIDVoted + pctDIDOwned;\n', '\n', '        //  Get the current votingPowerLimit\n', '        uint256 votingPowerLimit = distense.getParameterValueByTitle(distense.votingPowerLimitParameterTitle());\n', '        //  For voting purposes, limit the pctDIDOwned\n', '        uint256 limitedVotingPower = pctDIDOwned > votingPowerLimit ? votingPowerLimit : pctDIDOwned;\n', '\n', '        uint256 difference;\n', '        uint256 update;\n', '\n', '        if ((_reward * 1 ether) > task.reward) {\n', '            difference = SafeMath.sub((_reward * 1 ether), task.reward);\n', '            update = (limitedVotingPower * difference) / (1 ether * 100);\n', '            task.reward += update;\n', '        } else {\n', '            difference = SafeMath.sub(task.reward, (_reward * 1 ether));\n', '            update = (limitedVotingPower * difference) / (1 ether * 100);\n', '            task.reward -= update;\n', '        }\n', '\n', '        task.numVotes++;\n', '\n', '        uint256 pctDIDVotedThreshold = distense.getParameterValueByTitle(\n', '            distense.pctDIDToDetermineTaskRewardParameterTitle()\n', '        );\n', '\n', '        uint256 minNumVoters = distense.getParameterValueByTitle(\n', '            distense.minNumberOfTaskRewardVotersParameterTitle()\n', '        );\n', '\n', '        if (task.pctDIDVoted > pctDIDVotedThreshold || task.numVotes > SafeMath.div(minNumVoters, 1 ether)) {\n', '            emit LogTaskRewardDetermined(_taskId, task.reward);\n', '            task.rewardStatus = RewardStatus.DETERMINED;\n', '        }\n', '\n', '        return true;\n', '\n', '    }\n', '\n', '    function getTaskReward(bytes32 _taskId) external view returns (uint256) {\n', '        return tasks[_taskId].reward;\n', '    }\n', '\n', '    function getTaskRewardAndStatus(bytes32 _taskId) external view returns (uint256, RewardStatus) {\n', '        return (\n', '            tasks[_taskId].reward,\n', '            tasks[_taskId].rewardStatus\n', '        );\n', '    }\n', '\n', '    function setTaskRewardPaid(bytes32 _taskId) external onlyApproved returns (RewardStatus) {\n', '        tasks[_taskId].rewardStatus = RewardStatus.PAID;\n', '        return tasks[_taskId].rewardStatus;\n', '    }\n', '\n', '    //  Allow deleting of PAID taskIds to minimize blockchain size & query time on client\n', '    //  taskIds are memorialized in the form of events/logs, so this doesn&#39;t truly delete them,\n', '    //  it just prevents them from slowing down query times\n', '    function deleteTask(bytes32 _taskId) external onlyApproved returns (bool) {\n', '        Task storage task = tasks[_taskId];\n', '\n', '        if (task.rewardStatus == RewardStatus.PAID) {\n', '            uint256 index = tasks[_taskId].taskIdsIndex;\n', '            delete taskIds[index];\n', '            delete tasks[_taskId];\n', '\n', '            // Move the last element to the deleted index.  If we don&#39;t do this there are no efficiencies and the index will still still be\n', '            // iterated over on the client\n', '            uint256 taskIdsLength = taskIds.length;\n', '            if (taskIdsLength > 1) {\n', '                bytes32 lastElement = taskIds[taskIdsLength - 1];\n', '                taskIds[index] = lastElement;\n', '                taskIds.length--;\n', '            }\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    modifier hasEnoughDIDToAddTask() {\n', '        DIDToken didToken = DIDToken(DIDTokenAddress);\n', '        uint256 balance = didToken.getAddressBalance(msg.sender);\n', '\n', '        Distense distense = Distense(DistenseAddress);\n', '        uint256 numDIDRequiredToAddTask = distense.getParameterValueByTitle(\n', '            distense.numDIDRequiredToAddTaskParameterTitle()\n', '        );\n', '        require(balance >= numDIDRequiredToAddTask);\n', '        _;\n', '    }\n', '\n', '    function setDIDTokenAddress(address _DIDTokenAddress) public onlyApproved {\n', '        DIDTokenAddress = _DIDTokenAddress;\n', '    }\n', '\n', '    function setDistenseAddress(address _DistenseAddress) public onlyApproved {\n', '        DistenseAddress = _DistenseAddress;\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '\n', '  function percent(uint numerator, uint denominator, uint precision) public pure\n', '  returns(uint quotient) {\n', '\n', '    // caution, check safe-to-multiply here\n', '    uint _numerator  = numerator * 10 ** (precision + 1);\n', '\n', '    // with rounding of last digit\n', '    uint _quotient =  ((_numerator / denominator) + 5) / 10;\n', '    return _quotient;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract Approvable {\n', '\n', '    mapping(address => bool) public approved;\n', '\n', '    constructor () public {\n', '        approved[msg.sender] = true;\n', '    }\n', '\n', '    function approve(address _address) public onlyApproved {\n', '        require(_address != address(0));\n', '        approved[_address] = true;\n', '    }\n', '\n', '    function revokeApproval(address _address) public onlyApproved {\n', '        require(_address != address(0));\n', '        approved[_address] = false;\n', '    }\n', '\n', '    modifier onlyApproved() {\n', '        require(approved[msg.sender]);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract DIDToken is Approvable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    event LogIssueDID(address indexed to, uint256 numDID);\n', '    event LogDecrementDID(address indexed to, uint256 numDID);\n', '    event LogExchangeDIDForEther(address indexed to, uint256 numDID);\n', '    event LogInvestEtherForDID(address indexed to, uint256 numWei);\n', '\n', '    address[] public DIDHoldersArray;\n', '\n', '    address public PullRequestsAddress;\n', '    address public DistenseAddress;\n', '\n', '    uint256 public investmentLimitAggregate  = 100000 ether;  // This is the max DID all addresses can receive from depositing ether\n', '    uint256 public investmentLimitAddress = 100 ether;  // This is the max DID any address can receive from Ether deposit\n', '    uint256 public investedAggregate = 1 ether;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    struct DIDHolder {\n', '        uint256 balance;\n', '        uint256 netContributionsDID;    // essentially the number of DID remaining for calculating how much ether an account may invest\n', '        uint256 DIDHoldersIndex;\n', '        uint256 weiInvested;\n', '        uint256 tasksCompleted;\n', '    }\n', '    mapping (address => DIDHolder) public DIDHolders;\n', '\n', '    constructor () public {\n', '        name = "Distense DID";\n', '        symbol = "DID";\n', '        totalSupply = 0;\n', '        decimals = 18;\n', '    }\n', '\n', '    function issueDID(address _recipient, uint256 _numDID) public onlyApproved returns (bool) {\n', '        require(_recipient != address(0));\n', '        require(_numDID > 0);\n', '\n', '        _numDID = _numDID * 1 ether;\n', '        totalSupply = SafeMath.add(totalSupply, _numDID);\n', '        \n', '        uint256 balance = DIDHolders[_recipient].balance;\n', '        DIDHolders[_recipient].balance = SafeMath.add(balance, _numDID);\n', '\n', '        //  If is a new DIDHolder, set their position in DIDHoldersArray\n', '        if (DIDHolders[_recipient].DIDHoldersIndex == 0) {\n', '            uint256 index = DIDHoldersArray.push(_recipient) - 1;\n', '            DIDHolders[_recipient].DIDHoldersIndex = index;\n', '        }\n', '\n', '        emit LogIssueDID(_recipient, _numDID);\n', '\n', '        return true;\n', '    }\n', '\n', '    function decrementDID(address _address, uint256 _numDID) external onlyApproved returns (uint256) {\n', '        require(_address != address(0));\n', '        require(_numDID > 0);\n', '\n', '        uint256 numDID = _numDID * 1 ether;\n', '        require(SafeMath.sub(DIDHolders[_address].balance, numDID) >= 0);\n', '        require(SafeMath.sub(totalSupply, numDID ) >= 0);\n', '\n', '        totalSupply = SafeMath.sub(totalSupply, numDID);\n', '        DIDHolders[_address].balance = SafeMath.sub(DIDHolders[_address].balance, numDID);\n', '\n', '        //  If DIDHolder has exchanged all of their DID remove from DIDHoldersArray\n', '        //  For minimizing blockchain size and later client query performance\n', '        if (DIDHolders[_address].balance == 0) {\n', '            deleteDIDHolderWhenBalanceZero(_address);\n', '        }\n', '\n', '        emit LogDecrementDID(_address, numDID);\n', '\n', '        return DIDHolders[_address].balance;\n', '    }\n', '\n', '    function exchangeDIDForEther(uint256 _numDIDToExchange)\n', '        external\n', '    returns (uint256) {\n', '\n', '        uint256 numDIDToExchange = _numDIDToExchange * 1 ether;\n', '        uint256 netContributionsDID = getNumContributionsDID(msg.sender);\n', '        require(netContributionsDID >= numDIDToExchange);\n', '\n', '        Distense distense = Distense(DistenseAddress);\n', '        uint256 DIDPerEther = distense.getParameterValueByTitle(distense.didPerEtherParameterTitle());\n', '\n', '        require(numDIDToExchange < totalSupply);\n', '\n', '        uint256 numWeiToIssue = calculateNumWeiToIssue(numDIDToExchange, DIDPerEther);\n', '        address contractAddress = this;\n', '        require(contractAddress.balance >= numWeiToIssue, "DIDToken contract must have sufficient wei");\n', '\n', '        //  Adjust number of DID owned first\n', '        DIDHolders[msg.sender].balance = SafeMath.sub(DIDHolders[msg.sender].balance, numDIDToExchange);\n', '        DIDHolders[msg.sender].netContributionsDID = SafeMath.sub(DIDHolders[msg.sender].netContributionsDID, numDIDToExchange);\n', '        totalSupply = SafeMath.sub(totalSupply, numDIDToExchange);\n', '\n', '        msg.sender.transfer(numWeiToIssue);\n', '\n', '        if (DIDHolders[msg.sender].balance == 0) {\n', '            deleteDIDHolderWhenBalanceZero(msg.sender);\n', '        }\n', '        emit LogExchangeDIDForEther(msg.sender, numDIDToExchange);\n', '\n', '        return DIDHolders[msg.sender].balance;\n', '    }\n', '\n', '    function investEtherForDID() external payable returns (uint256) {\n', '        require(getNumWeiAddressMayInvest(msg.sender) >= msg.value);\n', '        require(investedAggregate < investmentLimitAggregate);\n', '\n', '        Distense distense = Distense(DistenseAddress);\n', '        uint256 DIDPerEther = SafeMath.div(distense.getParameterValueByTitle(distense.didPerEtherParameterTitle()), 1 ether);\n', '\n', '        uint256 numDIDToIssue = calculateNumDIDToIssue(msg.value, DIDPerEther);\n', '        require(DIDHolders[msg.sender].netContributionsDID >= numDIDToIssue);\n', '        totalSupply = SafeMath.add(totalSupply, numDIDToIssue);\n', '        DIDHolders[msg.sender].balance = SafeMath.add(DIDHolders[msg.sender].balance, numDIDToIssue);\n', '        DIDHolders[msg.sender].netContributionsDID = SafeMath.sub(DIDHolders[msg.sender].netContributionsDID, numDIDToIssue);\n', '\n', '        DIDHolders[msg.sender].weiInvested += msg.value;\n', '        investedAggregate = investedAggregate + msg.value;\n', '\n', '        emit LogIssueDID(msg.sender, numDIDToIssue);\n', '        emit LogInvestEtherForDID(msg.sender, msg.value);\n', '\n', '        return DIDHolders[msg.sender].balance;\n', '    }\n', '\n', '    function incrementDIDFromContributions(address _contributor, uint256 _reward) onlyApproved public {\n', '        uint256 weiReward = _reward * 1 ether;\n', '        DIDHolders[_contributor].netContributionsDID = SafeMath.add(DIDHolders[_contributor].netContributionsDID, weiReward);\n', '    }\n', '\n', '    function incrementTasksCompleted(address _contributor) onlyApproved public returns (bool) {\n', '        DIDHolders[_contributor].tasksCompleted++;\n', '        return true;\n', '    }\n', '\n', '    function pctDIDOwned(address _address) external view returns (uint256) {\n', '        return SafeMath.percent(DIDHolders[_address].balance, totalSupply, 20);\n', '    }\n', '\n', '    function getNumWeiAddressMayInvest(address _contributor) public view returns (uint256) {\n', '\n', '        uint256 DIDFromContributions = DIDHolders[_contributor].netContributionsDID;\n', '        require(DIDFromContributions > 0);\n', '        uint256 netUninvestedEther = SafeMath.sub(investmentLimitAddress, DIDHolders[_contributor].weiInvested);\n', '        require(netUninvestedEther > 0);\n', '\n', '        Distense distense = Distense(DistenseAddress);\n', '        uint256 DIDPerEther = distense.getParameterValueByTitle(distense.didPerEtherParameterTitle());\n', '\n', '        return (DIDFromContributions * 1 ether) / DIDPerEther;\n', '    }\n', '\n', '    function rewardContributor(address _contributor, uint256 _reward) external onlyApproved returns (bool) {\n', '        uint256 reward = SafeMath.div(_reward, 1 ether);\n', '        bool issued = issueDID(_contributor, reward);\n', '        if (issued) incrementDIDFromContributions(_contributor, reward);\n', '        incrementTasksCompleted(_contributor);\n', '    }\n', '\n', '    function getWeiAggregateMayInvest() public view returns (uint256) {\n', '        return SafeMath.sub(investmentLimitAggregate, investedAggregate);\n', '    }\n', '\n', '    function getNumDIDHolders() external view returns (uint256) {\n', '        return DIDHoldersArray.length;\n', '    }\n', '\n', '    function getAddressBalance(address _address) public view returns (uint256) {\n', '        return DIDHolders[_address].balance;\n', '    }\n', '\n', '    function getNumContributionsDID(address _address) public view returns (uint256) {\n', '        return DIDHolders[_address].netContributionsDID;\n', '    }\n', '\n', '    function getWeiInvested(address _address) public view returns (uint256) {\n', '        return DIDHolders[_address].weiInvested;\n', '    }\n', '\n', '    function calculateNumDIDToIssue(uint256 msgValue, uint256 DIDPerEther) public pure returns (uint256) {\n', '        return SafeMath.mul(msgValue, DIDPerEther);\n', '    }\n', '\n', '    function calculateNumWeiToIssue(uint256 _numDIDToExchange, uint256 _DIDPerEther) public pure returns (uint256) {\n', '        _numDIDToExchange = _numDIDToExchange * 1 ether;\n', '        return SafeMath.div(_numDIDToExchange, _DIDPerEther);\n', '    }\n', '\n', '    function deleteDIDHolderWhenBalanceZero(address holder) internal {\n', '        if (DIDHoldersArray.length > 1) {\n', '            address lastElement = DIDHoldersArray[DIDHoldersArray.length - 1];\n', '            DIDHoldersArray[DIDHolders[holder].DIDHoldersIndex] = lastElement;\n', '            DIDHoldersArray.length--;\n', '            delete DIDHolders[holder];\n', '        }\n', '    }\n', '\n', '    function deleteDIDHolder(address holder) public onlyApproved {\n', '        if (DIDHoldersArray.length > 1) {\n', '            address lastElement = DIDHoldersArray[DIDHoldersArray.length - 1];\n', '            DIDHoldersArray[DIDHolders[holder].DIDHoldersIndex] = lastElement;\n', '            DIDHoldersArray.length--;\n', '            delete DIDHolders[holder];\n', '        }\n', '    }\n', '\n', '    function setDistenseAddress(address _distenseAddress) onlyApproved public  {\n', '        DistenseAddress = _distenseAddress;\n', '    }\n', '\n', '}\n', '\n', 'contract Distense is Approvable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    address public DIDTokenAddress;\n', '\n', '    /*\n', "      Distense' votable parameters\n", '      Parameter is the perfect word` for these: "a numerical or other measurable factor forming one of a set\n', '      that defines a system or sets the conditions of its operation".\n', '    */\n', '\n', '    //  Titles are what uniquely identify parameters, so query by titles when iterating with clients\n', '    bytes32[] public parameterTitles;\n', '\n', '    struct Parameter {\n', '        bytes32 title;\n', '        uint256 value;\n', '        mapping(address => Vote) votes;\n', '    }\n', '\n', '    struct Vote {\n', '        address voter;\n', '        uint256 lastVoted;\n', '    }\n', '\n', '    mapping(bytes32 => Parameter) public parameters;\n', '\n', '    Parameter public votingIntervalParameter;\n', "    bytes32 public votingIntervalParameterTitle = 'votingInterval';\n", '\n', '    Parameter public pctDIDToDetermineTaskRewardParameter;\n', "    bytes32 public pctDIDToDetermineTaskRewardParameterTitle = 'pctDIDToDetermineTaskReward';\n", '\n', '    Parameter public pctDIDRequiredToMergePullRequest;\n', "    bytes32 public pctDIDRequiredToMergePullRequestTitle = 'pctDIDRequiredToMergePullRequest';\n", '\n', '    Parameter public maxRewardParameter;\n', "    bytes32 public maxRewardParameterTitle = 'maxReward';\n", '\n', '    Parameter public numDIDRequiredToApproveVotePullRequestParameter;\n', "    bytes32 public numDIDRequiredToApproveVotePullRequestParameterTitle = 'numDIDReqApproveVotePullRequest';\n", '\n', '    Parameter public numDIDRequiredToTaskRewardVoteParameter;\n', "    bytes32 public numDIDRequiredToTaskRewardVoteParameterTitle = 'numDIDRequiredToTaskRewardVote';\n", '\n', '    Parameter public minNumberOfTaskRewardVotersParameter;\n', "    bytes32 public minNumberOfTaskRewardVotersParameterTitle = 'minNumberOfTaskRewardVoters';\n", '\n', '    Parameter public numDIDRequiredToAddTaskParameter;\n', "    bytes32 public numDIDRequiredToAddTaskParameterTitle = 'numDIDRequiredToAddTask';\n", '\n', '    Parameter public defaultRewardParameter;\n', "    bytes32 public defaultRewardParameterTitle = 'defaultReward';\n", '\n', '    Parameter public didPerEtherParameter;\n', "    bytes32 public didPerEtherParameterTitle = 'didPerEther';\n", '\n', '    Parameter public votingPowerLimitParameter;\n', "    bytes32 public votingPowerLimitParameterTitle = 'votingPowerLimit';\n", '\n', '    event LogParameterValueUpdate(bytes32 title, uint256 value);\n', '\n', '    constructor (address _DIDTokenAddress) public {\n', '\n', '        DIDTokenAddress = _DIDTokenAddress;\n', '\n', '        // Launch Distense with some votable parameters\n', '        // that can be later updated by contributors\n', '        // Current values can be found at https://disten.se/parameters\n', '\n', '        // Percentage of DID that must vote on a proposal for it to be approved and payable\n', '        pctDIDToDetermineTaskRewardParameter = Parameter({\n', '            title : pctDIDToDetermineTaskRewardParameterTitle,\n', '            //     Every hard-coded int except for dates and numbers (not percentages) pertaining to ether or DID are decimals to two decimal places\n', '            //     So this is 15.00%\n', '            value: 15 * 1 ether\n', '        });\n', '        parameters[pctDIDToDetermineTaskRewardParameterTitle] = pctDIDToDetermineTaskRewardParameter;\n', '        parameterTitles.push(pctDIDToDetermineTaskRewardParameterTitle);\n', '\n', '\n', '        pctDIDRequiredToMergePullRequest = Parameter({\n', '            title : pctDIDRequiredToMergePullRequestTitle,\n', '            value: 10 * 1 ether\n', '        });\n', '        parameters[pctDIDRequiredToMergePullRequestTitle] = pctDIDRequiredToMergePullRequest;\n', '        parameterTitles.push(pctDIDRequiredToMergePullRequestTitle);\n', '\n', '\n', '        votingIntervalParameter = Parameter({\n', '            title : votingIntervalParameterTitle,\n', '            value: 1296000 * 1 ether// 15 * 86400 = 1.296e+6\n', '        });\n', '        parameters[votingIntervalParameterTitle] = votingIntervalParameter;\n', '        parameterTitles.push(votingIntervalParameterTitle);\n', '\n', '\n', '        maxRewardParameter = Parameter({\n', '            title : maxRewardParameterTitle,\n', '            value: 2000 * 1 ether\n', '        });\n', '        parameters[maxRewardParameterTitle] = maxRewardParameter;\n', '        parameterTitles.push(maxRewardParameterTitle);\n', '\n', '\n', '        numDIDRequiredToApproveVotePullRequestParameter = Parameter({\n', '            title : numDIDRequiredToApproveVotePullRequestParameterTitle,\n', '            //     100 DID\n', '            value: 100 * 1 ether\n', '        });\n', '        parameters[numDIDRequiredToApproveVotePullRequestParameterTitle] = numDIDRequiredToApproveVotePullRequestParameter;\n', '        parameterTitles.push(numDIDRequiredToApproveVotePullRequestParameterTitle);\n', '\n', '\n', "        // This parameter is the number of DID an account must own to vote on a task's reward\n", '        // The task reward is the number of DID payable upon successful completion and approval of a task\n', '\n', '        // This parameter mostly exists to get the percentage of DID that have voted higher per voter\n', '        //   as looping through voters to determineReward()s is gas-expensive.\n', '\n', '        // This parameter also limits attacks by noobs that want to mess with Distense.\n', '        numDIDRequiredToTaskRewardVoteParameter = Parameter({\n', '            title : numDIDRequiredToTaskRewardVoteParameterTitle,\n', '            // 100\n', '            value: 100 * 1 ether\n', '        });\n', '        parameters[numDIDRequiredToTaskRewardVoteParameterTitle] = numDIDRequiredToTaskRewardVoteParameter;\n', '        parameterTitles.push(numDIDRequiredToTaskRewardVoteParameterTitle);\n', '\n', '\n', '        minNumberOfTaskRewardVotersParameter = Parameter({\n', '            title : minNumberOfTaskRewardVotersParameterTitle,\n', '            //     7\n', '            value: 7 * 1 ether\n', '        });\n', '        parameters[minNumberOfTaskRewardVotersParameterTitle] = minNumberOfTaskRewardVotersParameter;\n', '        parameterTitles.push(minNumberOfTaskRewardVotersParameterTitle);\n', '\n', '\n', '        numDIDRequiredToAddTaskParameter = Parameter({\n', '            title : numDIDRequiredToAddTaskParameterTitle,\n', '            //     100\n', '            value: 100 * 1 ether\n', '        });\n', '        parameters[numDIDRequiredToAddTaskParameterTitle] = numDIDRequiredToAddTaskParameter;\n', '        parameterTitles.push(numDIDRequiredToAddTaskParameterTitle);\n', '\n', '\n', '        defaultRewardParameter = Parameter({\n', '            title : defaultRewardParameterTitle,\n', '            //     100\n', '            value: 100 * 1 ether\n', '        });\n', '        parameters[defaultRewardParameterTitle] = defaultRewardParameter;\n', '        parameterTitles.push(defaultRewardParameterTitle);\n', '\n', '\n', '        didPerEtherParameter = Parameter({\n', '            title : didPerEtherParameterTitle,\n', '            //     1000\n', '            value: 200 * 1 ether\n', '        });\n', '        parameters[didPerEtherParameterTitle] = didPerEtherParameter;\n', '        parameterTitles.push(didPerEtherParameterTitle);\n', '\n', '        votingPowerLimitParameter = Parameter({\n', '            title : votingPowerLimitParameterTitle,\n', '            //     20.00%\n', '            value: 20 * 1 ether\n', '        });\n', '        parameters[votingPowerLimitParameterTitle] = votingPowerLimitParameter;\n', '        parameterTitles.push(votingPowerLimitParameterTitle);\n', '\n', '    }\n', '\n', '    function getParameterValueByTitle(bytes32 _title) public view returns (uint256) {\n', '        return parameters[_title].value;\n', '    }\n', '\n', '    /**\n', '        Function called when contributors vote on parameters at /parameters url\n', '        In the client there are: max and min buttons and a text input\n', '\n', '        @param _title name of parameter title the DID holder is voting on.  This must be one of the hardcoded titles in this file.\n', '        @param _voteValue integer in percentage effect.  For example if the current value of a parameter is 20, and the voter votes 24, _voteValue\n', '        would be 20, for a 20% increase.\n', '\n', "        If _voteValue is 1 it's a max upvote, if -1 max downvote. Maximum votes, as just mentioned, affect parameter values by\n", '        max(percentage of DID owned by the voter, value of the votingLimit parameter).\n', '        If _voteValue has a higher absolute value than 1, the user has voted a specific value not maximum up or downvote.\n', '        In that case we update the value to the voted value if the value would affect the parameter value less than their percentage DID ownership.\n', "          If they voted a value that would affect the parameter's value by more than their percentage DID ownership we affect the value by their percentage DID ownership.\n", '    */\n', '    function voteOnParameter(bytes32 _title, int256 _voteValue)\n', '        public\n', '        votingIntervalReached(msg.sender, _title)\n', '        returns\n', '    (uint256) {\n', '\n', '        DIDToken didToken = DIDToken(DIDTokenAddress);\n', '        uint256 votersDIDPercent = didToken.pctDIDOwned(msg.sender);\n', '        require(votersDIDPercent > 0);\n', '\n', '        uint256 currentValue = getParameterValueByTitle(_title);\n', '\n', "        //  For voting power purposes, limit the pctDIDOwned to the maximum of the Voting Power Limit parameter or the voter's percentage ownership\n", '        //  of DID\n', '        uint256 votingPowerLimit = getParameterValueByTitle(votingPowerLimitParameterTitle);\n', '\n', '        uint256 limitedVotingPower = votersDIDPercent > votingPowerLimit ? votingPowerLimit : votersDIDPercent;\n', '\n', '        uint256 update;\n', '        if (\n', '            _voteValue == 1 ||  // maximum upvote\n', '            _voteValue == - 1 || // minimum downvote\n', '            _voteValue > int(limitedVotingPower) || // vote value greater than votingPowerLimit\n', '            _voteValue < - int(limitedVotingPower)  // vote value greater than votingPowerLimit absolute value\n', '        ) {\n', '            update = (limitedVotingPower * currentValue) / (100 * 1 ether);\n', '        } else if (_voteValue > 0) {\n', '            update = SafeMath.div((uint(_voteValue) * currentValue), (1 ether * 100));\n', '        } else if (_voteValue < 0) {\n', '            int256 adjustedVoteValue = (-_voteValue); // make the voteValue positive and convert to on-chain decimals\n', '            update = uint((adjustedVoteValue * int(currentValue))) / (100 * 1 ether);\n', '        } else revert(); //  If _voteValue is 0 refund gas to voter\n', '\n', '        if (_voteValue > 0)\n', '            currentValue = SafeMath.add(currentValue, update);\n', '        else\n', '            currentValue = SafeMath.sub(currentValue, update);\n', '\n', '        updateParameterValue(_title, currentValue);\n', '        updateLastVotedOnParameter(_title, msg.sender);\n', '        emit LogParameterValueUpdate(_title, currentValue);\n', '\n', '        return currentValue;\n', '    }\n', '\n', '    function getParameterByTitle(bytes32 _title) public view returns (bytes32, uint256) {\n', '        Parameter memory param = parameters[_title];\n', '        return (param.title, param.value);\n', '    }\n', '\n', '    function getNumParameters() public view returns (uint256) {\n', '        return parameterTitles.length;\n', '    }\n', '\n', '    function updateParameterValue(bytes32 _title, uint256 _newValue) internal returns (uint256) {\n', '        Parameter storage parameter = parameters[_title];\n', '        parameter.value = _newValue;\n', '        return parameter.value;\n', '    }\n', '\n', '    function updateLastVotedOnParameter(bytes32 _title, address voter) internal returns (bool) {\n', '        Parameter storage parameter = parameters[_title];\n', '        parameter.votes[voter].lastVoted = now;\n', '    }\n', '\n', '    function setDIDTokenAddress(address _didTokenAddress) public onlyApproved {\n', '        DIDTokenAddress = _didTokenAddress;\n', '    }\n', '\n', '    modifier votingIntervalReached(address _voter, bytes32 _title) {\n', '        Parameter storage parameter = parameters[_title];\n', '        uint256 lastVotedOnParameter = parameter.votes[_voter].lastVoted * 1 ether;\n', '        require((now * 1 ether) >= lastVotedOnParameter + getParameterValueByTitle(votingIntervalParameterTitle));\n', '        _;\n', '    }\n', '}\n', '\n', 'contract PullRequests is Approvable {\n', '\n', '    address public DIDTokenAddress;\n', '    address public DistenseAddress;\n', '    address public TasksAddress;\n', '\n', '    struct PullRequest {\n', '        address contributor;\n', '        bytes32 taskId;\n', '        uint128 prNum;\n', '        uint256 pctDIDApproved;\n', '        mapping(address => bool) voted;\n', '    }\n', '\n', '    bytes32[] public pullRequestIds;\n', '\n', '    mapping(bytes32 => PullRequest) pullRequests;\n', '\n', '    event LogAddPullRequest(bytes32 _prId, bytes32 taskId, uint128 prNum);\n', '    event LogPullRequestApprovalVote(bytes32 _prId, uint256 pctDIDApproved);\n', '    event LogRewardPullRequest(bytes32 _prId, bytes32 taskId, uint128 prNum);\n', '\n', '    constructor (\n', '        address _DIDTokenAddress,\n', '        address _DistenseAddress,\n', '        address _TasksAddress\n', '    ) public {\n', '        DIDTokenAddress = _DIDTokenAddress;\n', '        DistenseAddress = _DistenseAddress;\n', '        TasksAddress = _TasksAddress;\n', '    }\n', '\n', '    function addPullRequest(bytes32 _prId, bytes32 _taskId, uint128 _prNum) external returns (bool) {\n', '        pullRequests[_prId].contributor = msg.sender;\n', '        pullRequests[_prId].taskId = _taskId;\n', '        pullRequests[_prId].prNum = _prNum;\n', '        pullRequestIds.push(_prId);\n', '\n', '        emit LogAddPullRequest(_prId, _taskId, _prNum);\n', '\n', '        return true;\n', '    }\n', '\n', '    function getPullRequestById(bytes32 _prId) external view returns (address, bytes32, uint128, uint256) {\n', '        PullRequest memory pr = pullRequests[_prId];\n', '        return (pr.contributor, pr.taskId, pr.prNum, pr.pctDIDApproved);\n', '    }\n', '\n', '    function getNumPullRequests() external view returns (uint256) {\n', '        return pullRequestIds.length;\n', '    }\n', '\n', '    function approvePullRequest(bytes32 _prId)\n', '        hasEnoughDIDToApprovePR\n', '        external\n', '    returns (uint256) {\n', '\n', '        require(pullRequests[_prId].voted[msg.sender] == false, "voter already voted on this PR");\n', '        require(pullRequests[_prId].contributor != msg.sender, "contributor voted on their PR");\n', '        Distense distense = Distense(DistenseAddress);\n', '        DIDToken didToken = DIDToken(DIDTokenAddress);\n', '\n', '        PullRequest storage _pr = pullRequests[_prId];\n', '\n', '        //  Record approval vote to prevent multiple voting\n', '        _pr.voted[msg.sender] = true;\n', '\n', '        //  This is not very gas efficient at all but the stack was too deep.  Need to refactor/research ways to improve\n', '        //  Increment _pr.pctDIDApproved by the lower of the votingPowerLimitParameter or the voters pctDIDOwned\n', '        _pr.pctDIDApproved += didToken.pctDIDOwned(msg.sender) > distense.getParameterValueByTitle(\n', '            distense.votingPowerLimitParameterTitle()\n', '        ) ? distense.getParameterValueByTitle(\n', '            distense.votingPowerLimitParameterTitle()\n', '        ) : didToken.pctDIDOwned(msg.sender);\n', '\n', '        if (\n', '            _pr.pctDIDApproved > distense.getParameterValueByTitle(\n', '                distense.pctDIDRequiredToMergePullRequestTitle()\n', '            )\n', '        ) {\n', '            Tasks tasks = Tasks(TasksAddress);\n', '\n', '            uint256 reward;\n', '            Tasks.RewardStatus rewardStatus;\n', '            (reward, rewardStatus) = tasks.getTaskRewardAndStatus(_pr.taskId);\n', '\n', '            require(rewardStatus != Tasks.RewardStatus.PAID);\n', '            Tasks.RewardStatus updatedRewardStatus = tasks.setTaskRewardPaid(_pr.taskId);\n', '\n', '            //  Only issueDID after we confirm taskRewardPaid\n', '            require(updatedRewardStatus == Tasks.RewardStatus.PAID);\n', '            didToken.rewardContributor(_pr.contributor, reward);\n', '\n', '            emit LogRewardPullRequest(_prId, _pr.taskId, _pr.prNum);\n', '        }\n', '\n', '        emit LogPullRequestApprovalVote(_prId, _pr.pctDIDApproved);\n', '        return _pr.pctDIDApproved;\n', '    }\n', '\n', '    modifier hasEnoughDIDToApprovePR() {\n', '\n', '        Distense distense = Distense(DistenseAddress);\n', '        uint256 threshold = distense.getParameterValueByTitle(\n', '            distense.numDIDRequiredToApproveVotePullRequestParameterTitle()\n', '        );\n', '\n', '        DIDToken didToken = DIDToken(DIDTokenAddress);\n', '\n', '        require(didToken.getNumContributionsDID(msg.sender) > threshold);\n', '        _;\n', '    }\n', '\n', '    function setDIDTokenAddress(address _DIDTokenAddress) public onlyApproved {\n', '        DIDTokenAddress = _DIDTokenAddress;\n', '    }\n', '\n', '    function setDistenseAddress(address _DistenseAddress) public onlyApproved {\n', '        DistenseAddress = _DistenseAddress;\n', '    }\n', '\n', '    function setTasksAddress(address _TasksAddress) public onlyApproved {\n', '        TasksAddress = _TasksAddress;\n', '    }\n', '}\n', '\n', 'contract Tasks is Approvable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    address public DIDTokenAddress;\n', '    address public DistenseAddress;\n', '\n', '    bytes32[] public taskIds;\n', '\n', '    enum RewardStatus { TENTATIVE, DETERMINED, PAID }\n', '\n', '    struct Task {\n', '        string title;\n', '        address createdBy;\n', '        uint256 reward;\n', '        RewardStatus rewardStatus;\n', '        uint256 pctDIDVoted;\n', '        uint64 numVotes;\n', '        mapping(address => bool) rewardVotes;\n', '        uint256 taskIdsIndex;   // for easy later deletion to minimize query time and blockchain size\n', '    }\n', '\n', '    mapping(bytes32 => Task) tasks;\n', '    mapping(bytes32 => bool) tasksTitles;\n', '\n', '    event LogAddTask(bytes32 taskId, string title);\n', '    event LogTaskRewardVote(bytes32 taskId, uint256 reward, uint256 pctDIDVoted);\n', '    event LogTaskRewardDetermined(bytes32 taskId, uint256 reward);\n', '\n', '    constructor (address _DIDTokenAddress, address _DistenseAddress) public {\n', '        DIDTokenAddress = _DIDTokenAddress;\n', '        DistenseAddress = _DistenseAddress;\n', '    }\n', '\n', '    function addTask(bytes32 _taskId, string _title) external hasEnoughDIDToAddTask returns\n', '        (bool) {\n', '\n', '        bytes32 titleBytes32 = keccak256(abi.encodePacked(_title));\n', '        require(!tasksTitles[titleBytes32], "Task title already exists");\n', '\n', '        Distense distense = Distense(DistenseAddress);\n', '\n', '        tasks[_taskId].createdBy = msg.sender;\n', '        tasks[_taskId].title = _title;\n', '        tasks[_taskId].reward = distense.getParameterValueByTitle(distense.defaultRewardParameterTitle());\n', '        tasks[_taskId].rewardStatus = RewardStatus.TENTATIVE;\n', '\n', '        taskIds.push(_taskId);\n', '        tasksTitles[titleBytes32] = true;\n', '        tasks[_taskId].taskIdsIndex = taskIds.length - 1;\n', '        emit LogAddTask(_taskId, _title);\n', '\n', '        return true;\n', '    }\n', '\n', '    function getTaskById(bytes32 _taskId) external view returns (\n', '        string,\n', '        address,\n', '        uint256,\n', '        Tasks.RewardStatus,\n', '        uint256,\n', '        uint64\n', '    ) {\n', '\n', '        Task memory task = tasks[_taskId];\n', '        return (\n', '            task.title,\n', '            task.createdBy,\n', '            task.reward,\n', '            task.rewardStatus,\n', '            task.pctDIDVoted,\n', '            task.numVotes\n', '        );\n', '\n', '    }\n', '\n', '    function taskExists(bytes32 _taskId) external view returns (bool) {\n', '        return tasks[_taskId].createdBy != 0;\n', '    }\n', '\n', '    function getNumTasks() external view returns (uint256) {\n', '        return taskIds.length;\n', '    }\n', '\n', '    function taskRewardVote(bytes32 _taskId, uint256 _reward) external returns (bool) {\n', '\n', '        DIDToken didToken = DIDToken(DIDTokenAddress);\n', '        uint256 balance = didToken.getAddressBalance(msg.sender);\n', '        Distense distense = Distense(DistenseAddress);\n', '\n', '        Task storage task = tasks[_taskId];\n', '\n', '        require(_reward >= 0);\n', '\n', "        //  Essentially refund the remaining gas if user's vote will have no effect\n", '        require(task.reward != (_reward * 1 ether));\n', '\n', "        // Don't let the voter vote if the reward has already been determined\n", '        require(task.rewardStatus != RewardStatus.DETERMINED);\n', '\n', '        //  Has the voter already voted on this task?\n', '        require(!task.rewardVotes[msg.sender]);\n', '\n', '        //  Does the voter own at least as many DID as the reward their voting for?\n', "        //  This ensures new contributors don't have too much sway over the issuance of new DID.\n", '        require(balance > distense.getParameterValueByTitle(distense.numDIDRequiredToTaskRewardVoteParameterTitle()));\n', '\n', '        //  Require the reward to be less than or equal to the maximum reward parameter,\n', '        //  which basically is a hard, floating limit on the number of DID that can be issued for any single task\n', '        require((_reward * 1 ether) <= distense.getParameterValueByTitle(distense.maxRewardParameterTitle()));\n', '\n', '        task.rewardVotes[msg.sender] = true;\n', '\n', '        uint256 pctDIDOwned = didToken.pctDIDOwned(msg.sender);\n', '        task.pctDIDVoted = task.pctDIDVoted + pctDIDOwned;\n', '\n', '        //  Get the current votingPowerLimit\n', '        uint256 votingPowerLimit = distense.getParameterValueByTitle(distense.votingPowerLimitParameterTitle());\n', '        //  For voting purposes, limit the pctDIDOwned\n', '        uint256 limitedVotingPower = pctDIDOwned > votingPowerLimit ? votingPowerLimit : pctDIDOwned;\n', '\n', '        uint256 difference;\n', '        uint256 update;\n', '\n', '        if ((_reward * 1 ether) > task.reward) {\n', '            difference = SafeMath.sub((_reward * 1 ether), task.reward);\n', '            update = (limitedVotingPower * difference) / (1 ether * 100);\n', '            task.reward += update;\n', '        } else {\n', '            difference = SafeMath.sub(task.reward, (_reward * 1 ether));\n', '            update = (limitedVotingPower * difference) / (1 ether * 100);\n', '            task.reward -= update;\n', '        }\n', '\n', '        task.numVotes++;\n', '\n', '        uint256 pctDIDVotedThreshold = distense.getParameterValueByTitle(\n', '            distense.pctDIDToDetermineTaskRewardParameterTitle()\n', '        );\n', '\n', '        uint256 minNumVoters = distense.getParameterValueByTitle(\n', '            distense.minNumberOfTaskRewardVotersParameterTitle()\n', '        );\n', '\n', '        if (task.pctDIDVoted > pctDIDVotedThreshold || task.numVotes > SafeMath.div(minNumVoters, 1 ether)) {\n', '            emit LogTaskRewardDetermined(_taskId, task.reward);\n', '            task.rewardStatus = RewardStatus.DETERMINED;\n', '        }\n', '\n', '        return true;\n', '\n', '    }\n', '\n', '    function getTaskReward(bytes32 _taskId) external view returns (uint256) {\n', '        return tasks[_taskId].reward;\n', '    }\n', '\n', '    function getTaskRewardAndStatus(bytes32 _taskId) external view returns (uint256, RewardStatus) {\n', '        return (\n', '            tasks[_taskId].reward,\n', '            tasks[_taskId].rewardStatus\n', '        );\n', '    }\n', '\n', '    function setTaskRewardPaid(bytes32 _taskId) external onlyApproved returns (RewardStatus) {\n', '        tasks[_taskId].rewardStatus = RewardStatus.PAID;\n', '        return tasks[_taskId].rewardStatus;\n', '    }\n', '\n', '    //  Allow deleting of PAID taskIds to minimize blockchain size & query time on client\n', "    //  taskIds are memorialized in the form of events/logs, so this doesn't truly delete them,\n", '    //  it just prevents them from slowing down query times\n', '    function deleteTask(bytes32 _taskId) external onlyApproved returns (bool) {\n', '        Task storage task = tasks[_taskId];\n', '\n', '        if (task.rewardStatus == RewardStatus.PAID) {\n', '            uint256 index = tasks[_taskId].taskIdsIndex;\n', '            delete taskIds[index];\n', '            delete tasks[_taskId];\n', '\n', "            // Move the last element to the deleted index.  If we don't do this there are no efficiencies and the index will still still be\n", '            // iterated over on the client\n', '            uint256 taskIdsLength = taskIds.length;\n', '            if (taskIdsLength > 1) {\n', '                bytes32 lastElement = taskIds[taskIdsLength - 1];\n', '                taskIds[index] = lastElement;\n', '                taskIds.length--;\n', '            }\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    modifier hasEnoughDIDToAddTask() {\n', '        DIDToken didToken = DIDToken(DIDTokenAddress);\n', '        uint256 balance = didToken.getAddressBalance(msg.sender);\n', '\n', '        Distense distense = Distense(DistenseAddress);\n', '        uint256 numDIDRequiredToAddTask = distense.getParameterValueByTitle(\n', '            distense.numDIDRequiredToAddTaskParameterTitle()\n', '        );\n', '        require(balance >= numDIDRequiredToAddTask);\n', '        _;\n', '    }\n', '\n', '    function setDIDTokenAddress(address _DIDTokenAddress) public onlyApproved {\n', '        DIDTokenAddress = _DIDTokenAddress;\n', '    }\n', '\n', '    function setDistenseAddress(address _DistenseAddress) public onlyApproved {\n', '        DistenseAddress = _DistenseAddress;\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '\n', '  function percent(uint numerator, uint denominator, uint precision) public pure\n', '  returns(uint quotient) {\n', '\n', '    // caution, check safe-to-multiply here\n', '    uint _numerator  = numerator * 10 ** (precision + 1);\n', '\n', '    // with rounding of last digit\n', '    uint _quotient =  ((_numerator / denominator) + 5) / 10;\n', '    return _quotient;\n', '  }\n', '\n', '}']
