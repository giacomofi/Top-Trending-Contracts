['pragma solidity ^0.4.23;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Roles\n', ' * @author Francisco Giordano (@frangio)\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' *      See RBAC.sol for example usage.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address&#39; access to this role\n', '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title RBAC (Role-Based Access Control)\n', ' * @author Matt Condon (@Shrugs)\n', ' * @dev Stores and provides setters and getters for roles and addresses.\n', ' * @dev Supports unlimited numbers of roles and addresses.\n', ' * @dev See //contracts/mocks/RBACMock.sol for an example of usage.\n', ' * This RBAC method uses strings to key roles. It may be beneficial\n', ' *  for you to write your own implementation of this interface using Enums or similar.\n', ' * It&#39;s also recommended that you define constants in the contract, like ROLE_ADMIN below,\n', ' *  to avoid typos.\n', ' */\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    emit RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    emit RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', '\n', '/**\n', ' * @title Whitelist\n', ' * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n', ' * @dev This simplifies the implementation of "user permissions".\n', ' */\n', 'contract Whitelist is Ownable, RBAC {\n', '  event WhitelistedAddressAdded(address addr);\n', '  event WhitelistedAddressRemoved(address addr);\n', '\n', '  string public constant ROLE_WHITELISTED = "whitelist";\n', '\n', '  /**\n', '   * @dev Throws if called by any account that&#39;s not whitelisted.\n', '   */\n', '  modifier onlyWhitelisted() {\n', '    checkRole(msg.sender, ROLE_WHITELISTED);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param addr address\n', '   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '   */\n', '  function addAddressToWhitelist(address addr)\n', '    onlyOwner\n', '    public\n', '  {\n', '    addRole(addr, ROLE_WHITELISTED);\n', '    emit WhitelistedAddressAdded(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev getter to determine if address is in whitelist\n', '   */\n', '  function whitelist(address addr)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return hasRole(addr, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev add addresses to the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was added to the whitelist,\n', '   * false if all addresses were already in the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] addrs)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      addAddressToWhitelist(addrs[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param addr address\n', '   * @return true if the address was removed from the whitelist,\n', '   * false if the address wasn&#39;t in the whitelist in the first place\n', '   */\n', '  function removeAddressFromWhitelist(address addr)\n', '    onlyOwner\n', '    public\n', '  {\n', '    removeRole(addr, ROLE_WHITELISTED);\n', '    emit WhitelistedAddressRemoved(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev remove addresses from the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was removed from the whitelist,\n', '   * false if all addresses weren&#39;t in the whitelist in the first place\n', '   */\n', '  function removeAddressesFromWhitelist(address[] addrs)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      removeAddressFromWhitelist(addrs[i]);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    require(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 token,\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    internal\n', '  {\n', '    require(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    require(token.approve(spender, value));\n', '  }\n', '}\n', '\n', '\n', 'contract PresaleSecond is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '\n', '    uint256 public maxcap;      // sale hardcap\n', '    uint256 public exceed;      // indivisual hardcap\n', '    uint256 public minimum;     // indivisual softcap\n', '    uint256 public rate;        // exchange rate\n', '\n', '    bool public paused = false;   // is sale paused?\n', '    bool public ignited = false;  // is sale started?\n', '    uint256 public weiRaised = 0; // check sale status\n', '\n', '    address public wallet;      // wallet for withdrawal\n', '    address public distributor; // contract for release, refund\n', '    Whitelist public List;      // whitelist\n', '    ERC20 public Token;         // token\n', '\n', '    constructor (\n', '        uint256 _maxcap,\n', '        uint256 _exceed,\n', '        uint256 _minimum,\n', '        uint256 _rate,\n', '        address _wallet,\n', '        address _distributor,\n', '        address _whitelist,\n', '        address _token\n', '    )\n', '        public\n', '    {\n', '        require(_wallet != address(0));\n', '        require(_whitelist != address(0));\n', '        require(_distributor != address(0));\n', '        require(_token != address(0));\n', '\n', '        maxcap = _maxcap;\n', '        exceed = _exceed;\n', '        minimum = _minimum;\n', '        rate = _rate;\n', '\n', '        wallet = _wallet;\n', '        distributor = _distributor;\n', '\n', '        Token = ERC20(_token);\n', '        List = Whitelist(_whitelist);\n', '    }\n', '\n', '    /* fallback function */\n', '    function () external payable {\n', '        collect();\n', '    }\n', '\n', '//  address\n', '    event Change(address _addr, string _name);\n', '\n', '    function setWhitelist(address _whitelist) external onlyOwner {\n', '        require(_whitelist != address(0));\n', '\n', '        List = Whitelist(_whitelist);\n', '        emit Change(_whitelist, "whitelist");\n', '    }\n', '\n', '    function setDistributor(address _distributor) external onlyOwner {\n', '        require(_distributor != address(0));\n', '\n', '        distributor = _distributor;\n', '        emit Change(_distributor, "distributor");\n', '\n', '    }\n', '\n', '    function setWallet(address _wallet) external onlyOwner {\n', '        require(_wallet != address(0));\n', '\n', '        wallet = _wallet;\n', '        emit Change(_wallet, "wallet");\n', '    }\n', '\n', '//  sale controller\n', '    event Pause();\n', '    event Resume();\n', '    event Ignite();\n', '    event Extinguish();\n', '\n', '    function pause() external onlyOwner {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    function resume() external onlyOwner {\n', '        paused = false;\n', '        emit Resume();\n', '    }\n', '\n', '    function ignite() external onlyOwner {\n', '        ignited = true;\n', '        emit Ignite();\n', '    }\n', '\n', '    function extinguish() external onlyOwner {\n', '        ignited = false;\n', '        emit Extinguish();\n', '    }\n', '\n', '//  collect eth\n', '    event Purchase(address indexed _buyer, uint256 _purchased, uint256 _refund, uint256 _tokens);\n', '\n', '    mapping (address => uint256) public buyers;\n', '\n', '    function collect() public payable {\n', '        address buyer = msg.sender;\n', '        uint256 amount = msg.value;\n', '\n', '        require(ignited && !paused);\n', '        require(List.whitelist(buyer));\n', '        require(buyer != address(0));\n', '        require(buyers[buyer].add(amount) >= minimum);\n', '        require(buyers[buyer] < exceed);\n', '        require(weiRaised < maxcap);\n', '\n', '        uint256 purchase;\n', '        uint256 refund;\n', '\n', '        (purchase, refund) = getPurchaseAmount(buyer, amount);\n', '\n', '        weiRaised = weiRaised.add(purchase);\n', '\n', '        if(weiRaised >= maxcap) ignited = false;\n', '\n', '        buyers[buyer] = buyers[buyer].add(purchase);\n', '        emit Purchase(buyer, purchase, refund, purchase.mul(rate));\n', '\n', '        buyer.transfer(refund);\n', '    }\n', '\n', '//  util functions for collect\n', '    function getPurchaseAmount(address _buyer, uint256 _amount)\n', '        private\n', '        view\n', '        returns (uint256, uint256)\n', '    {\n', '        uint256 d1 = maxcap.sub(weiRaised);\n', '        uint256 d2 = exceed.sub(buyers[_buyer]);\n', '\n', '        uint256 d = (d1 > d2) ? d2 : d1;\n', '\n', '        return (_amount > d) ? (d, _amount.sub(d)) : (_amount, 0);\n', '    }\n', '\n', '//  finalize\n', '    bool public finalized = false;\n', '\n', '    function finalize() external onlyOwner {\n', '        require(!ignited && !finalized);\n', '\n', '        withdrawEther();\n', '        withdrawToken();\n', '\n', '        finalized = true;\n', '    }\n', '\n', '//  release & release\n', '    event Release(address indexed _to, uint256 _amount);\n', '    event Refund(address indexed _to, uint256 _amount);\n', '\n', '    function release(address _addr)\n', '        external\n', '        returns (bool)\n', '    {\n', '        require(!ignited && !finalized);\n', '        require(msg.sender == distributor); // only for distributor\n', '        require(_addr != address(0));\n', '\n', '        if(buyers[_addr] == 0) return false;\n', '\n', '        uint256 releaseAmount = buyers[_addr].mul(rate);\n', '        buyers[_addr] = 0;\n', '\n', '        Token.safeTransfer(_addr, releaseAmount);\n', '        emit Release(_addr, releaseAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    // 어떤 모종의 이유로 환불 절차를 밟아야 하는 경우를 상정하여 만들어놓은 안전장치입니다.\n', '    // This exists for safety when we have to run refund process by some reason.\n', '    function refund(address _addr)\n', '        external\n', '        returns (bool)\n', '    {\n', '        require(!ignited && !finalized);\n', '        require(msg.sender == distributor); // only for distributor\n', '        require(_addr != address(0));\n', '\n', '        if(buyers[_addr] == 0) return false;\n', '\n', '        uint256 refundAmount = buyers[_addr];\n', '        buyers[_addr] = 0;\n', '\n', '        _addr.transfer(refundAmount);\n', '        emit Refund(_addr, refundAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '//  withdraw\n', '    event WithdrawToken(address indexed _from, uint256 _amount);\n', '    event WithdrawEther(address indexed _from, uint256 _amount);\n', '\n', '    function withdrawToken() public onlyOwner {\n', '        require(!ignited);\n', '        Token.safeTransfer(wallet, Token.balanceOf(address(this)));\n', '        emit WithdrawToken(wallet, Token.balanceOf(address(this)));\n', '    }\n', '\n', '    function withdrawEther() public onlyOwner {\n', '        require(!ignited);\n', '        wallet.transfer(address(this).balance);\n', '        emit WithdrawEther(wallet, address(this).balance);\n', '    }\n', '}\n', '\n', '\n', 'contract SaleManager is Ownable {\n', '    PresaleSecond public Sale;\n', '\n', '    constructor(address _sale) public {\n', '        require(_sale != address(0));\n', '        Sale = PresaleSecond(_sale);\n', '    }\n', '\n', '    function setSaleAddress(address _addr) external onlyOwner {\n', '        require(_addr != address(0));\n', '        Sale = PresaleSecond(_addr);\n', '    }\n', '\n', '    event Fail(address indexed _addr);\n', '\n', '    function releaseMany(address[] _addrs) external onlyOwner {\n', '        require(_addrs.length < 30);\n', '\n', '        for(uint256 i = 0; i < _addrs.length; i++)\n', '            if (!Sale.release(_addrs[i]))\n', '                emit Fail(_addrs[i]);\n', '    }\n', '\n', '    function refundMany(address[] _addrs) external onlyOwner {\n', '        require(_addrs.length < 30);\n', '\n', '        for(uint256 i = 0; i < _addrs.length; i++)\n', '            if (!Sale.refund(_addrs[i]))\n', '                emit Fail(_addrs[i]);\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Roles\n', ' * @author Francisco Giordano (@frangio)\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' *      See RBAC.sol for example usage.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', "   * @dev remove an address' access to this role\n", '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title RBAC (Role-Based Access Control)\n', ' * @author Matt Condon (@Shrugs)\n', ' * @dev Stores and provides setters and getters for roles and addresses.\n', ' * @dev Supports unlimited numbers of roles and addresses.\n', ' * @dev See //contracts/mocks/RBACMock.sol for an example of usage.\n', ' * This RBAC method uses strings to key roles. It may be beneficial\n', ' *  for you to write your own implementation of this interface using Enums or similar.\n', " * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\n", ' *  to avoid typos.\n', ' */\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    emit RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    emit RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', '\n', '/**\n', ' * @title Whitelist\n', ' * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n', ' * @dev This simplifies the implementation of "user permissions".\n', ' */\n', 'contract Whitelist is Ownable, RBAC {\n', '  event WhitelistedAddressAdded(address addr);\n', '  event WhitelistedAddressRemoved(address addr);\n', '\n', '  string public constant ROLE_WHITELISTED = "whitelist";\n', '\n', '  /**\n', "   * @dev Throws if called by any account that's not whitelisted.\n", '   */\n', '  modifier onlyWhitelisted() {\n', '    checkRole(msg.sender, ROLE_WHITELISTED);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param addr address\n', '   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '   */\n', '  function addAddressToWhitelist(address addr)\n', '    onlyOwner\n', '    public\n', '  {\n', '    addRole(addr, ROLE_WHITELISTED);\n', '    emit WhitelistedAddressAdded(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev getter to determine if address is in whitelist\n', '   */\n', '  function whitelist(address addr)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return hasRole(addr, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev add addresses to the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was added to the whitelist,\n', '   * false if all addresses were already in the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] addrs)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      addAddressToWhitelist(addrs[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param addr address\n', '   * @return true if the address was removed from the whitelist,\n', "   * false if the address wasn't in the whitelist in the first place\n", '   */\n', '  function removeAddressFromWhitelist(address addr)\n', '    onlyOwner\n', '    public\n', '  {\n', '    removeRole(addr, ROLE_WHITELISTED);\n', '    emit WhitelistedAddressRemoved(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev remove addresses from the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was removed from the whitelist,\n', "   * false if all addresses weren't in the whitelist in the first place\n", '   */\n', '  function removeAddressesFromWhitelist(address[] addrs)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      removeAddressFromWhitelist(addrs[i]);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    require(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 token,\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    internal\n', '  {\n', '    require(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    require(token.approve(spender, value));\n', '  }\n', '}\n', '\n', '\n', 'contract PresaleSecond is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '\n', '    uint256 public maxcap;      // sale hardcap\n', '    uint256 public exceed;      // indivisual hardcap\n', '    uint256 public minimum;     // indivisual softcap\n', '    uint256 public rate;        // exchange rate\n', '\n', '    bool public paused = false;   // is sale paused?\n', '    bool public ignited = false;  // is sale started?\n', '    uint256 public weiRaised = 0; // check sale status\n', '\n', '    address public wallet;      // wallet for withdrawal\n', '    address public distributor; // contract for release, refund\n', '    Whitelist public List;      // whitelist\n', '    ERC20 public Token;         // token\n', '\n', '    constructor (\n', '        uint256 _maxcap,\n', '        uint256 _exceed,\n', '        uint256 _minimum,\n', '        uint256 _rate,\n', '        address _wallet,\n', '        address _distributor,\n', '        address _whitelist,\n', '        address _token\n', '    )\n', '        public\n', '    {\n', '        require(_wallet != address(0));\n', '        require(_whitelist != address(0));\n', '        require(_distributor != address(0));\n', '        require(_token != address(0));\n', '\n', '        maxcap = _maxcap;\n', '        exceed = _exceed;\n', '        minimum = _minimum;\n', '        rate = _rate;\n', '\n', '        wallet = _wallet;\n', '        distributor = _distributor;\n', '\n', '        Token = ERC20(_token);\n', '        List = Whitelist(_whitelist);\n', '    }\n', '\n', '    /* fallback function */\n', '    function () external payable {\n', '        collect();\n', '    }\n', '\n', '//  address\n', '    event Change(address _addr, string _name);\n', '\n', '    function setWhitelist(address _whitelist) external onlyOwner {\n', '        require(_whitelist != address(0));\n', '\n', '        List = Whitelist(_whitelist);\n', '        emit Change(_whitelist, "whitelist");\n', '    }\n', '\n', '    function setDistributor(address _distributor) external onlyOwner {\n', '        require(_distributor != address(0));\n', '\n', '        distributor = _distributor;\n', '        emit Change(_distributor, "distributor");\n', '\n', '    }\n', '\n', '    function setWallet(address _wallet) external onlyOwner {\n', '        require(_wallet != address(0));\n', '\n', '        wallet = _wallet;\n', '        emit Change(_wallet, "wallet");\n', '    }\n', '\n', '//  sale controller\n', '    event Pause();\n', '    event Resume();\n', '    event Ignite();\n', '    event Extinguish();\n', '\n', '    function pause() external onlyOwner {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    function resume() external onlyOwner {\n', '        paused = false;\n', '        emit Resume();\n', '    }\n', '\n', '    function ignite() external onlyOwner {\n', '        ignited = true;\n', '        emit Ignite();\n', '    }\n', '\n', '    function extinguish() external onlyOwner {\n', '        ignited = false;\n', '        emit Extinguish();\n', '    }\n', '\n', '//  collect eth\n', '    event Purchase(address indexed _buyer, uint256 _purchased, uint256 _refund, uint256 _tokens);\n', '\n', '    mapping (address => uint256) public buyers;\n', '\n', '    function collect() public payable {\n', '        address buyer = msg.sender;\n', '        uint256 amount = msg.value;\n', '\n', '        require(ignited && !paused);\n', '        require(List.whitelist(buyer));\n', '        require(buyer != address(0));\n', '        require(buyers[buyer].add(amount) >= minimum);\n', '        require(buyers[buyer] < exceed);\n', '        require(weiRaised < maxcap);\n', '\n', '        uint256 purchase;\n', '        uint256 refund;\n', '\n', '        (purchase, refund) = getPurchaseAmount(buyer, amount);\n', '\n', '        weiRaised = weiRaised.add(purchase);\n', '\n', '        if(weiRaised >= maxcap) ignited = false;\n', '\n', '        buyers[buyer] = buyers[buyer].add(purchase);\n', '        emit Purchase(buyer, purchase, refund, purchase.mul(rate));\n', '\n', '        buyer.transfer(refund);\n', '    }\n', '\n', '//  util functions for collect\n', '    function getPurchaseAmount(address _buyer, uint256 _amount)\n', '        private\n', '        view\n', '        returns (uint256, uint256)\n', '    {\n', '        uint256 d1 = maxcap.sub(weiRaised);\n', '        uint256 d2 = exceed.sub(buyers[_buyer]);\n', '\n', '        uint256 d = (d1 > d2) ? d2 : d1;\n', '\n', '        return (_amount > d) ? (d, _amount.sub(d)) : (_amount, 0);\n', '    }\n', '\n', '//  finalize\n', '    bool public finalized = false;\n', '\n', '    function finalize() external onlyOwner {\n', '        require(!ignited && !finalized);\n', '\n', '        withdrawEther();\n', '        withdrawToken();\n', '\n', '        finalized = true;\n', '    }\n', '\n', '//  release & release\n', '    event Release(address indexed _to, uint256 _amount);\n', '    event Refund(address indexed _to, uint256 _amount);\n', '\n', '    function release(address _addr)\n', '        external\n', '        returns (bool)\n', '    {\n', '        require(!ignited && !finalized);\n', '        require(msg.sender == distributor); // only for distributor\n', '        require(_addr != address(0));\n', '\n', '        if(buyers[_addr] == 0) return false;\n', '\n', '        uint256 releaseAmount = buyers[_addr].mul(rate);\n', '        buyers[_addr] = 0;\n', '\n', '        Token.safeTransfer(_addr, releaseAmount);\n', '        emit Release(_addr, releaseAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    // 어떤 모종의 이유로 환불 절차를 밟아야 하는 경우를 상정하여 만들어놓은 안전장치입니다.\n', '    // This exists for safety when we have to run refund process by some reason.\n', '    function refund(address _addr)\n', '        external\n', '        returns (bool)\n', '    {\n', '        require(!ignited && !finalized);\n', '        require(msg.sender == distributor); // only for distributor\n', '        require(_addr != address(0));\n', '\n', '        if(buyers[_addr] == 0) return false;\n', '\n', '        uint256 refundAmount = buyers[_addr];\n', '        buyers[_addr] = 0;\n', '\n', '        _addr.transfer(refundAmount);\n', '        emit Refund(_addr, refundAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '//  withdraw\n', '    event WithdrawToken(address indexed _from, uint256 _amount);\n', '    event WithdrawEther(address indexed _from, uint256 _amount);\n', '\n', '    function withdrawToken() public onlyOwner {\n', '        require(!ignited);\n', '        Token.safeTransfer(wallet, Token.balanceOf(address(this)));\n', '        emit WithdrawToken(wallet, Token.balanceOf(address(this)));\n', '    }\n', '\n', '    function withdrawEther() public onlyOwner {\n', '        require(!ignited);\n', '        wallet.transfer(address(this).balance);\n', '        emit WithdrawEther(wallet, address(this).balance);\n', '    }\n', '}\n', '\n', '\n', 'contract SaleManager is Ownable {\n', '    PresaleSecond public Sale;\n', '\n', '    constructor(address _sale) public {\n', '        require(_sale != address(0));\n', '        Sale = PresaleSecond(_sale);\n', '    }\n', '\n', '    function setSaleAddress(address _addr) external onlyOwner {\n', '        require(_addr != address(0));\n', '        Sale = PresaleSecond(_addr);\n', '    }\n', '\n', '    event Fail(address indexed _addr);\n', '\n', '    function releaseMany(address[] _addrs) external onlyOwner {\n', '        require(_addrs.length < 30);\n', '\n', '        for(uint256 i = 0; i < _addrs.length; i++)\n', '            if (!Sale.release(_addrs[i]))\n', '                emit Fail(_addrs[i]);\n', '    }\n', '\n', '    function refundMany(address[] _addrs) external onlyOwner {\n', '        require(_addrs.length < 30);\n', '\n', '        for(uint256 i = 0; i < _addrs.length; i++)\n', '            if (!Sale.refund(_addrs[i]))\n', '                emit Fail(_addrs[i]);\n', '    }\n', '}']
