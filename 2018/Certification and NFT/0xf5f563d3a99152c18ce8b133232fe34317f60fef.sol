['pragma solidity ^0.4.21;\n', '\n', '/* \n', '    Contract for DeltaBalances.github.io V2\n', '    Check balances for multiple ERC20 tokens in 1 batched request.\n', '    For the previous version, see 0x3150954EAE1a8a5e5EE1F1B8E8444Fe16EA9F94C\n', '    \n', '    // address 0x0 is used to indicate ETH\n', '*/\n', '\n', '// Exchange contract Interface for EtherDelta and forks\n', 'contract Exchange {\n', '  function balanceOf(address /*token*/, address /*user*/) public view returns (uint);\n', '}\n', '\n', '// ERC20 contract interface\n', 'contract Token {\n', '  function balanceOf(address /*tokenOwner*/) public view returns (uint /*balance*/);\n', '  function transfer(address /*to*/, uint /*tokens*/) public returns (bool /*success*/);\n', '}\n', '\n', 'contract DeltaBalances {\n', '    \n', '  address public admin; \n', '\n', '  function DeltaBalances() public {\n', '    admin = msg.sender;\n', '  }\n', '\n', '  // Fallback function, don&#39;t accept any ETH\n', '  function() public payable {\n', '    revert();\n', '  }\n', '\n', '  // Limit withdrawals to the contract creator\n', '  modifier isAdmin() {\n', '    require(msg.sender == admin);\n', '    _;\n', '  }\n', '\n', '  // Backup withdraw, in case ETH gets in here\n', '  function withdraw() external isAdmin {\n', '    admin.transfer(address(this).balance);\n', '  }\n', '\n', '  // Backup withdraw, in case ERC20 tokens get in here\n', '  function withdrawToken(address token, uint amount) external isAdmin {\n', '    require(token != address(0x0) && Token(token).transfer(msg.sender, amount));\n', '  }\n', '\n', '  /* Get multiple token balances on EtherDelta (or similar exchange)\n', '    Possible error throws:\n', '        - invalid exchange contract \n', '        - using an extremely large array (gas cost too high?)\n', '        \n', '    Returns array of token balances in wei units. */\n', '  function deltaBalances(address exchange, address user,  address[] tokens) external view returns (uint[]) {\n', '    Exchange ex = Exchange(exchange);\n', '    uint[] memory balances = new uint[](tokens.length);\n', '    \n', '    for(uint i = 0; i < tokens.length; i++) {\n', '      balances[i] = ex.balanceOf(tokens[i], user);\n', '    }    \n', '    return balances;\n', '  }\n', '\n', '  /* Get multiple token balances on EtherDelta (or similar exchange)\n', '    Possible error throws:\n', '        - invalid exchange contract \n', '        - using extremely large arrays (gas cost too high?)\n', '        \n', '    Returns array of token balances in wei units.\n', '    Balances in token-first order [token0ex0, token0ex1, token0ex2, token1ex0, token1ex1 ...] */\n', '  function multiDeltaBalances(address[] exchanges, address user,  address[] tokens) external view returns (uint[]) {\n', '    uint[] memory balances = new uint[](tokens.length * exchanges.length);\n', '    \n', '    for(uint i = 0; i < exchanges.length; i++) {\n', '      Exchange ex = Exchange(exchanges[i]);\n', '        \n', '      for(uint j = 0; j < tokens.length; j++) {\n', '        balances[(j * exchanges.length) + i] = ex.balanceOf(tokens[j], user);\n', '      }\n', '    }\n', '    return balances;\n', '  }\n', '\n', ' /* Check the token balance of a wallet in a token contract\n', '    Avoids possible errors:\n', '    - returns 0 on invalid exchange contract \n', '    - return 0 on non-contract address \n', '    \n', '    Mainly for internal use, but public for anyone who thinks it is useful    */\n', '  function tokenBalance(address user, address token) public view returns (uint) {\n', '    // check if token is actually a contract\n', '    uint256 tokenCode;\n', '    assembly { tokenCode := extcodesize(token) } // contract code size\n', '   \n', '   // is it a contract and does it implement balanceOf\n', '    if(tokenCode > 0 && token.call(bytes4(keccak256("balanceOf(address)")), user)) {\n', '      return Token(token).balanceOf(user);\n', '    } else {\n', '      return 0; // not a valid token, return 0 instead of error\n', '    }\n', '  }\n', '\n', ' /* Check the token balances of a wallet for multiple tokens\n', '    Uses tokenBalance() to be able to return, even if a token isn&#39;t valid \n', '    Possible error throws:\n', '        - extremely large arrays (gas cost too high) \n', '        \n', '    Returns array of token balances in wei units. */\n', '  function walletBalances(address user,  address[] tokens) external view returns (uint[]) {\n', '    require(tokens.length > 0);\n', '    uint[] memory balances = new uint[](tokens.length);\n', '    \n', '    for(uint i = 0; i < tokens.length; i++) {\n', '      if(tokens[i] != address(0x0)) { \n', '        balances[i] = tokenBalance(user, tokens[i]);\n', '      } else {\n', '        balances[i] = user.balance; // ETH balance    \n', '      }\n', '    }    \n', '    return balances;\n', '  }\n', '\n', ' /* Combine walletBalances() and deltaBalances() to get both exchange and wallet balances for multiple tokens.\n', '    Possible error throws:\n', '        - extremely large arrays (gas cost too high) \n', '        \n', '    Returns array of token balances in wei units, 2* input length.\n', '    even index [0] is exchange balance, odd [1] is wallet balance\n', '    [tok0ex, tok0, tok1ex, tok1, .. ] */\n', '  function allBalances(address exchange, address user,  address[] tokens) external view returns (uint[]) {\n', '    Exchange ex = Exchange(exchange);\n', '    uint[] memory balances = new uint[](tokens.length * 2);\n', '    \n', '    for(uint i = 0; i < tokens.length; i++) {\n', '      uint j = i * 2;\n', '      balances[j] = ex.balanceOf(tokens[i], user);\n', '      if(tokens[i] != address(0x0)) {\n', '        balances[j + 1] = tokenBalance(user, tokens[i]);\n', '      } else {\n', '        balances[j + 1] = user.balance; // ETH balance    \n', '      }\n', '    }\n', '    return balances; \n', '  }\n', '  \n', '}']