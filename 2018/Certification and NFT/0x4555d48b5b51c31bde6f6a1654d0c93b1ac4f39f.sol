['pragma solidity 0.4.24;\n', '\n', '// (c) SecureVote 2018\n', '// github.com/secure-vote/sv-light-smart-contracts\n', '\n', 'interface BBFarmIface {\n', '    /* events */\n', '\n', '    event BBFarmInit(bytes4 namespace);\n', '    event BallotCreatedWithID(uint ballotId);\n', '\n', '    /* from permissioned */\n', '\n', '    function upgradeMe(address newSC) external;\n', '\n', '    /* global bbfarm getters */\n', '\n', '    function getNamespace() external view returns (bytes4);\n', '    function getVersion() external view returns (uint);\n', '    function getBBLibVersion() external view returns (uint256);\n', '    function getNBallots() external view returns (uint256);\n', '\n', '    /* init a ballot */\n', '\n', '    // note that the ballotId returned INCLUDES the namespace.\n', '    function initBallot( bytes32 specHash\n', '                       , uint256 packed\n', '                       , IxIface ix\n', '                       , address bbAdmin\n', '                       , bytes24 extraData\n', '                       ) external returns (uint ballotId);\n', '\n', '    /* Sponsorship of ballots */\n', '\n', '    function sponsor(uint ballotId) external payable;\n', '\n', '    /* Voting functions */\n', '\n', '    function submitVote(uint ballotId, bytes32 vote, bytes extra) external;\n', '    function submitProxyVote(bytes32[5] proxyReq, bytes extra) external;\n', '\n', '    /* Ballot Getters */\n', '\n', '    function getDetails(uint ballotId, address voter) external view returns\n', '            ( bool hasVoted\n', '            , uint nVotesCast\n', '            , bytes32 secKey\n', '            , uint16 submissionBits\n', '            , uint64 startTime\n', '            , uint64 endTime\n', '            , bytes32 specHash\n', '            , bool deprecated\n', '            , address ballotOwner\n', '            , bytes16 extraData);\n', '\n', '    function getVote(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra);\n', '    function getTotalSponsorship(uint ballotId) external view returns (uint);\n', '    function getSponsorsN(uint ballotId) external view returns (uint);\n', '    function getSponsor(uint ballotId, uint sponsorN) external view returns (address sender, uint amount);\n', '    function getCreationTs(uint ballotId) external view returns (uint);\n', '\n', '    /* Admin on ballots */\n', '    function revealSeckey(uint ballotId, bytes32 sk) external;\n', '    function setEndTime(uint ballotId, uint64 newEndTime) external;  // note: testing only\n', '    function setDeprecated(uint ballotId) external;\n', '    function setBallotOwner(uint ballotId, address newOwner) external;\n', '}\n', '\n', 'library BBLib {\n', '    using BytesLib for bytes;\n', '\n', '    // ballot meta\n', '    uint256 constant BB_VERSION = 5;\n', '\n', '    // voting settings\n', '    uint16 constant USE_ETH = 1;          // 2^0\n', '    uint16 constant USE_SIGNED = 2;       // 2^1\n', '    uint16 constant USE_NO_ENC = 4;       // 2^2\n', '    uint16 constant USE_ENC = 8;          // 2^3\n', '\n', '    // ballot settings\n', '    uint16 constant IS_BINDING = 8192;    // 2^13\n', '    uint16 constant IS_OFFICIAL = 16384;  // 2^14\n', '    uint16 constant USE_TESTING = 32768;  // 2^15\n', '\n', '    // other consts\n', '    uint32 constant MAX_UINT32 = 0xFFFFFFFF;\n', '\n', '    //// ** Storage Variables\n', '\n', '    // struct for ballot\n', '    struct Vote {\n', '        bytes32 voteData;\n', '        bytes32 castTsAndSender;\n', '        bytes extra;\n', '    }\n', '\n', '    struct Sponsor {\n', '        address sender;\n', '        uint amount;\n', '    }\n', '\n', '    //// ** Events\n', '    event CreatedBallot(bytes32 _specHash, uint64 startTs, uint64 endTs, uint16 submissionBits);\n', '    event SuccessfulVote(address indexed voter, uint voteId);\n', '    event SeckeyRevealed(bytes32 secretKey);\n', '    event TestingEnabled();\n', '    event DeprecatedContract();\n', '\n', '\n', '    // The big database struct\n', '\n', '\n', '    struct DB {\n', '        // Maps to store ballots, along with corresponding log of voters.\n', '        // Should only be modified through internal functions\n', '        mapping (uint256 => Vote) votes;\n', '        uint256 nVotesCast;\n', '\n', '        // we need replay protection for proxy ballots - this will let us check against a sequence number\n', '        // note: votes directly from a user ALWAYS take priority b/c they do not have sequence numbers\n', '        // (sequencing is done by Ethereum itself via the tx nonce).\n', '        mapping (address => uint32) sequenceNumber;\n', '\n', '        // NOTE - We don&#39;t actually want to include the encryption PublicKey because _it&#39;s included in the ballotSpec_.\n', '        // It&#39;s better to ensure ppl actually have the ballot spec by not including it in the contract.\n', '        // Plus we&#39;re already storing the hash of the ballotSpec anyway...\n', '\n', '        // Private key to be set after ballot conclusion - curve25519\n', '        bytes32 ballotEncryptionSeckey;\n', '\n', '        // packed contains:\n', '        // 1. Timestamps for start and end of ballot (UTC)\n', '        // 2. bits used to decide which options are enabled or disabled for submission of ballots\n', '        uint256 packed;\n', '\n', '        // specHash by which to validate the ballots integrity\n', '        bytes32 specHash;\n', '        // extradata if we need it - allows us to upgrade spechash format, etc\n', '        bytes16 extraData;\n', '\n', '        // allow tracking of sponsorship for this ballot & connection to index\n', '        Sponsor[] sponsors;\n', '        IxIface index;\n', '\n', '        // deprecation flag - doesn&#39;t actually do anything besides signal that this contract is deprecated;\n', '        bool deprecated;\n', '\n', '        address ballotOwner;\n', '        uint256 creationTs;\n', '    }\n', '\n', '\n', '    // ** Modifiers -- note, these are functions here to allow use as a lib\n', '    function requireBallotClosed(DB storage db) internal view {\n', '        require(now > BPackedUtils.packedToEndTime(db.packed), "!b-closed");\n', '    }\n', '\n', '    function requireBallotOpen(DB storage db) internal view {\n', '        uint64 _n = uint64(now);\n', '        uint64 startTs;\n', '        uint64 endTs;\n', '        (, startTs, endTs) = BPackedUtils.unpackAll(db.packed);\n', '        require(_n >= startTs && _n < endTs, "!b-open");\n', '        require(db.deprecated == false, "b-deprecated");\n', '    }\n', '\n', '    function requireBallotOwner(DB storage db) internal view {\n', '        require(msg.sender == db.ballotOwner, "!b-owner");\n', '    }\n', '\n', '    function requireTesting(DB storage db) internal view {\n', '        require(isTesting(BPackedUtils.packedToSubmissionBits(db.packed)), "!testing");\n', '    }\n', '\n', '    /* Library meta */\n', '\n', '    function getVersion() external view returns (uint) {\n', '        // even though this is constant we want to make sure that it&#39;s actually\n', '        // callable on Ethereum so we don&#39;t accidentally package the constant code\n', '        // in with an SC using BBLib. This function _must_ be external.\n', '        return BB_VERSION;\n', '    }\n', '\n', '    /* Functions */\n', '\n', '    // "Constructor" function - init core params on deploy\n', '    // timestampts are uint64s to give us plenty of room for millennia\n', '    function init(DB storage db, bytes32 _specHash, uint256 _packed, IxIface ix, address ballotOwner, bytes16 extraData) external {\n', '        db.index = ix;\n', '        db.ballotOwner = ballotOwner;\n', '\n', '        uint64 startTs;\n', '        uint64 endTs;\n', '        uint16 sb;\n', '        (sb, startTs, endTs) = BPackedUtils.unpackAll(_packed);\n', '\n', '        bool _testing = isTesting(sb);\n', '        if (_testing) {\n', '            emit TestingEnabled();\n', '        } else {\n', '            require(endTs > now, "bad-end-time");\n', '\n', '            // 0x1ff2 is 0001111111110010 in binary\n', '            // by ANDing with subBits we make sure that only bits in positions 0,2,3,13,14,15\n', '            // can be used. these correspond to the option flags at the top, and ETH ballots\n', '            // that are enc&#39;d or plaintext.\n', '            require(sb & 0x1ff2 == 0, "bad-sb");\n', '\n', '            // if we give bad submission bits (e.g. all 0s) then refuse to deploy ballot\n', '            bool okaySubmissionBits = 1 == (isEthNoEnc(sb) ? 1 : 0) + (isEthWithEnc(sb) ? 1 : 0);\n', '            require(okaySubmissionBits, "!valid-sb");\n', '\n', '            // take the max of the start time provided and the blocks timestamp to avoid a DoS against recent token holders\n', '            // (which someone might be able to do if they could set the timestamp in the past)\n', '            startTs = startTs > now ? startTs : uint64(now);\n', '        }\n', '        require(db.specHash == bytes32(0), "b-exists");\n', '        require(_specHash != bytes32(0), "null-specHash");\n', '        db.specHash = _specHash;\n', '\n', '        db.packed = BPackedUtils.pack(sb, startTs, endTs);\n', '        db.creationTs = now;\n', '\n', '        if (extraData != bytes16(0)) {\n', '            db.extraData = extraData;\n', '        }\n', '\n', '        emit CreatedBallot(db.specHash, startTs, endTs, sb);\n', '    }\n', '\n', '    /* sponsorship */\n', '\n', '    function logSponsorship(DB storage db, uint value) internal {\n', '        db.sponsors.push(Sponsor(msg.sender, value));\n', '    }\n', '\n', '    /* getters */\n', '\n', '    function getVote(DB storage db, uint id) internal view returns (bytes32 voteData, address sender, bytes extra, uint castTs) {\n', '        return (db.votes[id].voteData, address(db.votes[id].castTsAndSender), db.votes[id].extra, uint(db.votes[id].castTsAndSender) >> 160);\n', '    }\n', '\n', '    function getSequenceNumber(DB storage db, address voter) internal view returns (uint32) {\n', '        return db.sequenceNumber[voter];\n', '    }\n', '\n', '    function getTotalSponsorship(DB storage db) internal view returns (uint total) {\n', '        for (uint i = 0; i < db.sponsors.length; i++) {\n', '            total += db.sponsors[i].amount;\n', '        }\n', '    }\n', '\n', '    function getSponsor(DB storage db, uint i) external view returns (address sender, uint amount) {\n', '        sender = db.sponsors[i].sender;\n', '        amount = db.sponsors[i].amount;\n', '    }\n', '\n', '    /* ETH BALLOTS */\n', '\n', '    // Ballot submission\n', '    // note: if USE_ENC then curve25519 keys should be generated for\n', '    // each ballot (then thrown away).\n', '    // the curve25519 PKs go in the extra param\n', '    function submitVote(DB storage db, bytes32 voteData, bytes extra) external {\n', '        _addVote(db, voteData, msg.sender, extra);\n', '        // set the sequence number to max uint32 to disable proxy submitted ballots\n', '        // after a voter submits a transaction personally - effectivley disables proxy\n', '        // ballots. You can _always_ submit a new vote _personally_ with this scheme.\n', '        if (db.sequenceNumber[msg.sender] != MAX_UINT32) {\n', '            // using an IF statement here let&#39;s us save 4800 gas on repeat votes at the cost of 20k extra gas initially\n', '            db.sequenceNumber[msg.sender] = MAX_UINT32;\n', '        }\n', '    }\n', '\n', '    // Boundaries for constructing the msg we&#39;ll validate the signature of\n', '    function submitProxyVote(DB storage db, bytes32[5] proxyReq, bytes extra) external {\n', '        // a proxy vote (where the vote is submitted (i.e. tx fee paid by someone else)\n', '        // docs for datastructs: https://github.com/secure-vote/tokenvote/blob/master/Docs/DataStructs.md\n', '\n', '        bytes32 r = proxyReq[0];\n', '        bytes32 s = proxyReq[1];\n', '        uint8 v = uint8(proxyReq[2][0]);\n', '        // converting to uint248 will truncate the first byte, and we can then convert it to a bytes31.\n', '        bytes31 proxyReq2 = bytes31(uint248(proxyReq[2]));\n', '        // proxyReq[3] is ballotId - required for verifying sig but not used for anything else\n', '        bytes32 ballotId = proxyReq[3];\n', '        bytes32 voteData = proxyReq[4];\n', '\n', '        // using abi.encodePacked is much cheaper than making bytes in other ways...\n', '        bytes memory signed = abi.encodePacked(proxyReq2, ballotId, voteData, extra);\n', '        bytes32 msgHash = keccak256(signed);\n', '        // need to be sure we are signing the entire ballot and any extra data that comes with it\n', '        address voter = ecrecover(msgHash, v, r, s);\n', '\n', '        // we need to make sure that this is the most recent vote the voter made, and that it has\n', '        // not been seen before. NOTE: we&#39;ve already validated the BBFarm namespace before this, so\n', '        // we know it&#39;s meant for _this_ ballot.\n', '        uint32 sequence = uint32(proxyReq2);  // last 4 bytes of proxyReq2 - the sequence number\n', '        _proxyReplayProtection(db, voter, sequence);\n', '\n', '        _addVote(db, voteData, voter, extra);\n', '    }\n', '\n', '    function _addVote(DB storage db, bytes32 voteData, address sender, bytes extra) internal returns (uint256 id) {\n', '        requireBallotOpen(db);\n', '\n', '        id = db.nVotesCast;\n', '        db.votes[id].voteData = voteData;\n', '        // pack the casting ts right next to the sender\n', '        db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);\n', '        if (extra.length > 0) {\n', '            db.votes[id].extra = extra;\n', '        }\n', '        db.nVotesCast += 1;\n', '        emit SuccessfulVote(sender, id);\n', '    }\n', '\n', '    function _proxyReplayProtection(DB storage db, address voter, uint32 sequence) internal {\n', '        // we want the replay protection sequence number to be STRICTLY MORE than what\n', '        // is stored in the mapping. This means we can set sequence to MAX_UINT32 to disable\n', '        // any future votes.\n', '        require(db.sequenceNumber[voter] < sequence, "bad-sequence-n");\n', '        db.sequenceNumber[voter] = sequence;\n', '    }\n', '\n', '    /* Admin */\n', '\n', '    function setEndTime(DB storage db, uint64 newEndTime) external {\n', '        uint16 sb;\n', '        uint64 sTs;\n', '        (sb, sTs,) = BPackedUtils.unpackAll(db.packed);\n', '        db.packed = BPackedUtils.pack(sb, sTs, newEndTime);\n', '    }\n', '\n', '    function revealSeckey(DB storage db, bytes32 sk) internal {\n', '        db.ballotEncryptionSeckey = sk;\n', '        emit SeckeyRevealed(sk);\n', '    }\n', '\n', '    /* Submission Bits (Ballot Classifications) */\n', '\n', '    // do (bits & SETTINGS_MASK) to get just operational bits (as opposed to testing or official flag)\n', '    uint16 constant SETTINGS_MASK = 0xFFFF ^ USE_TESTING ^ IS_OFFICIAL ^ IS_BINDING;\n', '\n', '    function isEthNoEnc(uint16 submissionBits) pure internal returns (bool) {\n', '        return checkFlags(submissionBits, USE_ETH | USE_NO_ENC);\n', '    }\n', '\n', '    function isEthWithEnc(uint16 submissionBits) pure internal returns (bool) {\n', '        return checkFlags(submissionBits, USE_ETH | USE_ENC);\n', '    }\n', '\n', '    function isOfficial(uint16 submissionBits) pure internal returns (bool) {\n', '        return (submissionBits & IS_OFFICIAL) == IS_OFFICIAL;\n', '    }\n', '\n', '    function isBinding(uint16 submissionBits) pure internal returns (bool) {\n', '        return (submissionBits & IS_BINDING) == IS_BINDING;\n', '    }\n', '\n', '    function isTesting(uint16 submissionBits) pure internal returns (bool) {\n', '        return (submissionBits & USE_TESTING) == USE_TESTING;\n', '    }\n', '\n', '    function qualifiesAsCommunityBallot(uint16 submissionBits) pure internal returns (bool) {\n', '        // if submissionBits AND any of the bits that make this _not_ a community\n', '        // ballot is equal to zero that means none of those bits were active, so\n', '        // it could be a community ballot\n', '        return (submissionBits & (IS_BINDING | IS_OFFICIAL | USE_ENC)) == 0;\n', '    }\n', '\n', '    function checkFlags(uint16 submissionBits, uint16 expected) pure internal returns (bool) {\n', '        // this should ignore ONLY the testing/flag bits - all other bits are significant\n', '        uint16 sBitsNoSettings = submissionBits & SETTINGS_MASK;\n', '        // then we want ONLY expected\n', '        return sBitsNoSettings == expected;\n', '    }\n', '}\n', '\n', 'library BPackedUtils {\n', '\n', '    // the uint16 ending at 128 bits should be 0s\n', '    uint256 constant sbMask        = 0xffffffffffffffffffffffffffff0000ffffffffffffffffffffffffffffffff;\n', '    uint256 constant startTimeMask = 0xffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff;\n', '    uint256 constant endTimeMask   = 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000;\n', '\n', '    function packedToSubmissionBits(uint256 packed) internal pure returns (uint16) {\n', '        return uint16(packed >> 128);\n', '    }\n', '\n', '    function packedToStartTime(uint256 packed) internal pure returns (uint64) {\n', '        return uint64(packed >> 64);\n', '    }\n', '\n', '    function packedToEndTime(uint256 packed) internal pure returns (uint64) {\n', '        return uint64(packed);\n', '    }\n', '\n', '    function unpackAll(uint256 packed) internal pure returns (uint16 submissionBits, uint64 startTime, uint64 endTime) {\n', '        submissionBits = uint16(packed >> 128);\n', '        startTime = uint64(packed >> 64);\n', '        endTime = uint64(packed);\n', '    }\n', '\n', '    function pack(uint16 sb, uint64 st, uint64 et) internal pure returns (uint256 packed) {\n', '        return uint256(sb) << 128 | uint256(st) << 64 | uint256(et);\n', '    }\n', '\n', '    function setSB(uint256 packed, uint16 newSB) internal pure returns (uint256) {\n', '        return (packed & sbMask) | uint256(newSB) << 128;\n', '    }\n', '\n', '    // function setStartTime(uint256 packed, uint64 startTime) internal pure returns (uint256) {\n', '    //     return (packed & startTimeMask) | uint256(startTime) << 64;\n', '    // }\n', '\n', '    // function setEndTime(uint256 packed, uint64 endTime) internal pure returns (uint256) {\n', '    //     return (packed & endTimeMask) | uint256(endTime);\n', '    // }\n', '}\n', '\n', 'interface BallotBoxIface {\n', '    function getVersion() external pure returns (uint256);\n', '\n', '    function getVote(uint256) external view returns (bytes32 voteData, address sender, bytes32 encPK);\n', '\n', '    function getDetails(address voter) external view returns (\n', '        bool hasVoted,\n', '        uint nVotesCast,\n', '        bytes32 secKey,\n', '        uint16 submissionBits,\n', '        uint64 startTime,\n', '        uint64 endTime,\n', '        bytes32 specHash,\n', '        bool deprecated,\n', '        address ballotOwner);\n', '\n', '    function getTotalSponsorship() external view returns (uint);\n', '\n', '    function submitVote(bytes32 voteData, bytes32 encPK) external;\n', '\n', '    function revealSeckey(bytes32 sk) external;\n', '    function setEndTime(uint64 newEndTime) external;\n', '    function setDeprecated() external;\n', '\n', '    function setOwner(address) external;\n', '    function getOwner() external view returns (address);\n', '\n', '    event CreatedBallot(bytes32 specHash, uint64 startTs, uint64 endTs, uint16 submissionBits);\n', '    event SuccessfulVote(address indexed voter, uint voteId);\n', '    event SeckeyRevealed(bytes32 secretKey);\n', '}\n', '\n', 'interface BBAuxIface {\n', '    function isTesting(BallotBoxIface bb) external view returns (bool);\n', '    function isOfficial(BallotBoxIface bb) external view returns (bool);\n', '    function isBinding(BallotBoxIface bb) external view returns (bool);\n', '    function qualifiesAsCommunityBallot(BallotBoxIface bb) external view returns (bool);\n', '\n', '\n', '    function isDeprecated(BallotBoxIface bb) external view returns (bool);\n', '    function getEncSeckey(BallotBoxIface bb) external view returns (bytes32);\n', '    function getSpecHash(BallotBoxIface bb) external view returns (bytes32);\n', '    function getSubmissionBits(BallotBoxIface bb) external view returns (uint16);\n', '    function getStartTime(BallotBoxIface bb) external view returns (uint64);\n', '    function getEndTime(BallotBoxIface bb) external view returns (uint64);\n', '    function getNVotesCast(BallotBoxIface bb) external view returns (uint256 nVotesCast);\n', '\n', '    function hasVoted(BallotBoxIface bb, address voter) external view returns (bool hv);\n', '}\n', '\n', 'interface IxIface {\n', '    function doUpgrade(address) external;\n', '\n', '    function addBBFarm(BBFarmIface bbFarm) external returns (uint8 bbFarmId);\n', '    function emergencySetABackend(bytes32 toSet, address newSC) external;\n', '    function emergencySetBBFarm(uint8 bbFarmId, address _bbFarm) external;\n', '    function emergencySetDAdmin(bytes32 democHash, address newAdmin) external;\n', '\n', '    function getPayments() external view returns (IxPaymentsIface);\n', '    function getBackend() external view returns (IxBackendIface);\n', '    function getBBFarm(uint8 bbFarmId) external view returns (BBFarmIface);\n', '    function getBBFarmID(bytes4 bbNamespace) external view returns (uint8 bbFarmId);\n', '\n', '    function getVersion() external view returns (uint256);\n', '\n', '    function dInit(address defualtErc20) external payable returns (bytes32);\n', '\n', '    function setDErc20(bytes32 democHash, address newErc20) external;\n', '    function dAddCategory(bytes32 democHash, bytes32 categoryName, bool hasParent, uint parent) external returns (uint);\n', '    function dDeprecateCategory(bytes32 democHash, uint categoryId) external;\n', '    function dUpgradeToPremium(bytes32 democHash) external;\n', '    function dDowngradeToBasic(bytes32 democHash) external;\n', '    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external;\n', '\n', '    /* democ getters (that used to be here) should be called on either backend or payments directly */\n', '    /* use IxLib for convenience functions from other SCs */\n', '\n', '    /* ballot deployment */\n', '    // only ix owner - used for adding past or special ballots\n', '    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed) external;\n', '    function dDeployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint256 packed) external payable returns (uint);\n', '\n', '\n', '    /* events */\n', '    event PaymentMade(uint[2] valAndRemainder);\n', '    event Emergency(bytes32 setWhat);\n', '    event EmergencyDemocAdmin(bytes32 democHash, address newAdmin);\n', '    event EmergencyBBFarm(uint16 bbFarmId);\n', '    event AddedBBFarm(uint16 bbFarmId);\n', '    event ManuallyAddedBallot(bytes32 democHash, uint256 ballotId, uint256 packed);\n', '    // from backend\n', '    event NewBallot(bytes32 indexed democHash, uint ballotN);\n', '    event NewDemoc(bytes32 democHash);\n', '    event DemocAdminSet(bytes32 indexed democHash, address admin);\n', '    // from BBFarm\n', '    event BallotCreatedWithID(uint ballotId);\n', '}\n', '\n', 'interface IxPaymentsIface {\n', '    function upgradeMe(address) external;\n', '\n', '    function payoutAll() external;\n', '\n', '    function setPayTo(address) external;\n', '    function getPayTo() external view returns (address);\n', '    function setMinorEditsAddr(address) external;\n', '\n', '    function getCommunityBallotCentsPrice() external view returns (uint);\n', '    function setCommunityBallotCentsPrice(uint) external;\n', '    function getCommunityBallotWeiPrice() external view returns (uint);\n', '\n', '    function setBasicCentsPricePer30Days(uint amount) external;\n', '    function getBasicCentsPricePer30Days() external view returns(uint);\n', '    function getBasicExtraBallotFeeWei() external view returns (uint);\n', '    function getBasicBallotsPer30Days() external view returns (uint);\n', '    function setBasicBallotsPer30Days(uint amount) external;\n', '    function setPremiumMultiplier(uint8 amount) external;\n', '    function getPremiumMultiplier() external view returns (uint8);\n', '    function getPremiumCentsPricePer30Days() external view returns (uint);\n', '    function setWeiPerCent(uint) external;\n', '    function setFreeExtension(bytes32 democHash, bool hasFreeExt) external;\n', '    function getWeiPerCent() external view returns (uint weiPerCent);\n', '    function getUsdEthExchangeRate() external view returns (uint centsPerEth);\n', '\n', '    function weiBuysHowManySeconds(uint amount) external view returns (uint secs);\n', '\n', '    function downgradeToBasic(bytes32 democHash) external;\n', '    function upgradeToPremium(bytes32 democHash) external;\n', '    function doFreeExtension(bytes32 democHash) external;\n', '\n', '    function payForDemocracy(bytes32 democHash) external payable;\n', '    function accountInGoodStanding(bytes32 democHash) external view returns (bool);\n', '    function getSecondsRemaining(bytes32 democHash) external view returns (uint);\n', '    function getPremiumStatus(bytes32 democHash) external view returns (bool);\n', '    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension);\n', '    function getFreeExtension(bytes32 democHash) external view returns (bool);\n', '\n', '    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) external;\n', '\n', '    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) external;\n', '    function getDenyPremium(bytes32 democHash) external view returns (bool);\n', '\n', '    function getPaymentLogN() external view returns (uint);\n', '    function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue);\n', '\n', '    event UpgradedToPremium(bytes32 indexed democHash);\n', '    event GrantedAccountTime(bytes32 indexed democHash, uint additionalSeconds, bytes32 ref);\n', '    event AccountPayment(bytes32 indexed democHash, uint additionalSeconds);\n', '    event SetCommunityBallotFee(uint amount);\n', '    event SetBasicCentsPricePer30Days(uint amount);\n', '    event SetPremiumMultiplier(uint8 multiplier);\n', '    event DowngradeToBasic(bytes32 indexed democHash);\n', '    event UpgradeToPremium(bytes32 indexed democHash);\n', '    event SetExchangeRate(uint weiPerCent);\n', '    event FreeExtension(bytes32 democHash);\n', '}\n', '\n', 'interface IxBackendIface {\n', '    function upgradeMe(address) external;\n', '\n', '    /* global getters */\n', '    function getGDemocsN() external view returns (uint);\n', '    function getGDemoc(uint id) external view returns (bytes32);\n', '    function getGErc20ToDemocs(address erc20) external view returns (bytes32[] democHashes);\n', '\n', '    /* democ admin */\n', '    function dInit(address defaultErc20) external returns (bytes32);\n', '    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed, bool recordTowardsBasicLimit) external;\n', '    function dAddCategory(bytes32 democHash, bytes32 categoryName, bool hasParent, uint parent) external returns (uint);\n', '    function dDeprecateCategory(bytes32 democHash, uint categoryId) external;\n', '    function setDAdmin(bytes32 democHash, address newAdmin) external;\n', '    function setDErc20(bytes32 democHash, address newErc20) external;\n', '    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external;\n', '\n', '    /* global democ getters */\n', '    function getDInfo(bytes32 democHash) external view returns (address erc20, address admin, uint256 nBallots);\n', '    function getDErc20(bytes32 democHash) external view returns (address);\n', '    function getDAdmin(bytes32 democHash) external view returns (address);\n', '    function getDArbitraryData(bytes32 democHash, bytes key) external view returns (bytes value);\n', '\n', '    function getDBallotsN(bytes32 democHash) external view returns (uint256);\n', '    function getDBallotID(bytes32 democHash, uint n) external view returns (uint ballotId);\n', '    function getDCountedBasicBallotsN(bytes32 democHash) external view returns (uint256);\n', '    function getDCountedBasicBallotID(bytes32 democHash, uint256 n) external view returns (uint256);\n', '\n', '    function getDCategoriesN(bytes32 democHash) external view returns (uint);\n', '    function getDCategory(bytes32 democHash, uint categoryId) external view returns (bool deprecated, bytes32 name, bool hasParent, uint parent);\n', '\n', '    /* just for prefix stuff */\n', '    function getDHash(bytes13 prefix) external view returns (bytes32);\n', '\n', '    /* events */\n', '    event NewBallot(bytes32 indexed democHash, uint ballotN);\n', '    event NewDemoc(bytes32 democHash);\n', '    event DemocAdminSet(bytes32 indexed democHash, address admin);\n', '}\n', '\n', 'contract SVBallotConsts {\n', '    // voting settings\n', '    uint16 constant USE_ETH = 1;          // 2^0\n', '    uint16 constant USE_SIGNED = 2;       // 2^1\n', '    uint16 constant USE_NO_ENC = 4;       // 2^2\n', '    uint16 constant USE_ENC = 8;          // 2^3\n', '\n', '    // ballot settings\n', '    uint16 constant IS_BINDING = 8192;    // 2^13\n', '    uint16 constant IS_OFFICIAL = 16384;  // 2^14\n', '    uint16 constant USE_TESTING = 32768;  // 2^15\n', '}\n', '\n', 'contract safeSend {\n', '    bool private txMutex3847834;\n', '\n', '    // we want to be able to call outside contracts (e.g. the admin proxy contract)\n', '    // but reentrency is bad, so here&#39;s a mutex.\n', '    function doSafeSend(address toAddr, uint amount) internal {\n', '        doSafeSendWData(toAddr, "", amount);\n', '    }\n', '\n', '    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\n', '        require(txMutex3847834 == false, "ss-guard");\n', '        txMutex3847834 = true;\n', '        // we need to use address.call.value(v)() because we want\n', '        // to be able to send to other contracts, even with no data,\n', '        // which might use more than 2300 gas in their fallback function.\n', '        require(toAddr.call.value(amount)(data), "ss-failed");\n', '        txMutex3847834 = false;\n', '    }\n', '}\n', '\n', 'contract payoutAllC is safeSend {\n', '    address _payTo;\n', '\n', '    constructor() public {\n', '        _payTo = msg.sender;\n', '    }\n', '\n', '    function payoutAll() external {\n', '        doSafeSend(_payTo, address(this).balance);\n', '    }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address newOwner);\n', '\n', '    modifier only_owner() {\n', '        require(msg.sender == owner, "only_owner: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address newOwner) only_owner() external {\n', '        owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '}\n', '\n', 'contract hasAdmins is owned {\n', '    mapping (uint => mapping (address => bool)) admins;\n', '    uint public currAdminEpoch = 0;\n', '    bool public adminsDisabledForever = false;\n', '    address[] adminLog;\n', '\n', '    event AdminAdded(address indexed newAdmin);\n', '    event AdminRemoved(address indexed oldAdmin);\n', '    event AdminEpochInc();\n', '    event AdminDisabledForever();\n', '\n', '    modifier only_admin() {\n', '        require(adminsDisabledForever == false, "admins must not be disabled");\n', '        require(isAdmin(msg.sender), "only_admin: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        _setAdmin(msg.sender, true);\n', '    }\n', '\n', '    function isAdmin(address a) view public returns (bool) {\n', '        return admins[currAdminEpoch][a];\n', '    }\n', '\n', '    function getAdminLogN() view external returns (uint) {\n', '        return adminLog.length;\n', '    }\n', '\n', '    function getAdminLog(uint n) view external returns (address) {\n', '        return adminLog[n];\n', '    }\n', '\n', '    function upgradeMeAdmin(address newAdmin) only_admin() external {\n', '        // note: already checked msg.sender has admin with `only_admin` modifier\n', '        require(msg.sender != owner, "owner cannot upgrade self");\n', '        _setAdmin(msg.sender, false);\n', '        _setAdmin(newAdmin, true);\n', '    }\n', '\n', '    function setAdmin(address a, bool _givePerms) only_admin() external {\n', '        require(a != msg.sender && a != owner, "cannot change your own (or owner&#39;s) permissions");\n', '        _setAdmin(a, _givePerms);\n', '    }\n', '\n', '    function _setAdmin(address a, bool _givePerms) internal {\n', '        admins[currAdminEpoch][a] = _givePerms;\n', '        if (_givePerms) {\n', '            emit AdminAdded(a);\n', '            adminLog.push(a);\n', '        } else {\n', '            emit AdminRemoved(a);\n', '        }\n', '    }\n', '\n', '    // safety feature if admins go bad or something\n', '    function incAdminEpoch() only_owner() external {\n', '        currAdminEpoch++;\n', '        admins[currAdminEpoch][msg.sender] = true;\n', '        emit AdminEpochInc();\n', '    }\n', '\n', '    // this is internal so contracts can all it, but not exposed anywhere in this\n', '    // contract.\n', '    function disableAdminForever() internal {\n', '        currAdminEpoch++;\n', '        adminsDisabledForever = true;\n', '        emit AdminDisabledForever();\n', '    }\n', '}\n', '\n', 'contract permissioned is owned, hasAdmins {\n', '    mapping (address => bool) editAllowed;\n', '    bool public adminLockdown = false;\n', '\n', '    event PermissionError(address editAddr);\n', '    event PermissionGranted(address editAddr);\n', '    event PermissionRevoked(address editAddr);\n', '    event PermissionsUpgraded(address oldSC, address newSC);\n', '    event SelfUpgrade(address oldSC, address newSC);\n', '    event AdminLockdown();\n', '\n', '    modifier only_editors() {\n', '        require(editAllowed[msg.sender], "only_editors: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier no_lockdown() {\n', '        require(adminLockdown == false, "no_lockdown: check failed");\n', '        _;\n', '    }\n', '\n', '\n', '    constructor() owned() hasAdmins() public {\n', '    }\n', '\n', '\n', '    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\n', '        editAllowed[e] = _editPerms;\n', '        if (_editPerms)\n', '            emit PermissionGranted(e);\n', '        else\n', '            emit PermissionRevoked(e);\n', '    }\n', '\n', '    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\n', '        editAllowed[oldSC] = false;\n', '        editAllowed[newSC] = true;\n', '        emit PermissionsUpgraded(oldSC, newSC);\n', '    }\n', '\n', '    // always allow SCs to upgrade themselves, even after lockdown\n', '    function upgradeMe(address newSC) only_editors() external {\n', '        editAllowed[msg.sender] = false;\n', '        editAllowed[newSC] = true;\n', '        emit SelfUpgrade(msg.sender, newSC);\n', '    }\n', '\n', '    function hasPermissions(address a) public view returns (bool) {\n', '        return editAllowed[a];\n', '    }\n', '\n', '    function doLockdown() external only_owner() no_lockdown() {\n', '        disableAdminForever();\n', '        adminLockdown = true;\n', '        emit AdminLockdown();\n', '    }\n', '}\n', '\n', 'contract upgradePtr {\n', '    address ptr = address(0);\n', '\n', '    modifier not_upgraded() {\n', '        require(ptr == address(0), "upgrade pointer is non-zero");\n', '        _;\n', '    }\n', '\n', '    function getUpgradePointer() view external returns (address) {\n', '        return ptr;\n', '    }\n', '\n', '    function doUpgradeInternal(address nextSC) internal {\n', '        ptr = nextSC;\n', '    }\n', '}\n', '\n', 'interface ERC20Interface {\n', '    // Get the total token supply\n', '    function totalSupply() constant external returns (uint256 _totalSupply);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'library BytesLib {\n', '    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) {\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            // Get a location of some free memory and store it in tempBytes as\n', '            // Solidity does for memory variables.\n', '            tempBytes := mload(0x40)\n', '\n', '            // Store the length of the first bytes array at the beginning of\n', '            // the memory for tempBytes.\n', '            let length := mload(_preBytes)\n', '            mstore(tempBytes, length)\n', '\n', '            // Maintain a memory counter for the current write location in the\n', '            // temp bytes array by adding the 32 bytes for the array length to\n', '            // the starting location.\n', '            let mc := add(tempBytes, 0x20)\n', '            // Stop copying when the memory counter reaches the length of the\n', '            // first bytes array.\n', '            let end := add(mc, length)\n', '\n', '            for {\n', '                // Initialize a copy counter to the start of the _preBytes data,\n', '                // 32 bytes into its memory.\n', '                let cc := add(_preBytes, 0x20)\n', '            } lt(mc, end) {\n', '                // Increase both counters by 32 bytes each iteration.\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                // Write the _preBytes data into the tempBytes memory 32 bytes\n', '                // at a time.\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Add the length of _postBytes to the current length of tempBytes\n', '            // and store it as the new length in the first 32 bytes of the\n', '            // tempBytes memory.\n', '            length := mload(_postBytes)\n', '            mstore(tempBytes, add(length, mload(tempBytes)))\n', '\n', '            // Move the memory counter back from a multiple of 0x20 to the\n', '            // actual end of the _preBytes data.\n', '            mc := end\n', '            // Stop copying when the memory counter reaches the new combined\n', '            // length of the arrays.\n', '            end := add(mc, length)\n', '\n', '            for {\n', '                let cc := add(_postBytes, 0x20)\n', '            } lt(mc, end) {\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Update the free-memory pointer by padding our last write location\n', '            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n', '            // next 32 byte block, then round down to the nearest multiple of\n', '            // 32. If the sum of the length of the two arrays is zero then add\n', '            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n', '            mstore(0x40, and(\n', '              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n', '              not(31) // Round down to the nearest 32 bytes.\n', '            ))\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n', '        assembly {\n', '            // Read the first 32 bytes of _preBytes storage, which is the length\n', '            // of the array. (We don&#39;t need to use the offset into the slot\n', '            // because arrays use the entire slot.)\n', '            let fslot := sload(_preBytes_slot)\n', '            // Arrays of 31 bytes or less have an even value in their slot,\n', '            // while longer arrays have an odd value. The actual length is\n', '            // the slot divided by two for odd values, and the lowest order\n', '            // byte divided by two for even values.\n', '            // If the slot is even, bitwise and the slot with 255 and divide by\n', '            // two to get the length. If the slot is odd, bitwise and the slot\n', '            // with -1 and divide by two.\n', '            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n', '            let mlength := mload(_postBytes)\n', '            let newlength := add(slength, mlength)\n', '            // slength can contain both the length and contents of the array\n', '            // if length < 32 bytes so let&#39;s prepare for that\n', '            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n', '            switch add(lt(slength, 32), lt(newlength, 32))\n', '            case 2 {\n', '                // Since the new array still fits in the slot, we just need to\n', '                // update the contents of the slot.\n', '                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n', '                sstore(\n', '                    _preBytes_slot,\n', '                    // all the modifications to the slot are inside this\n', '                    // next block\n', '                    add(\n', '                        // we can just add to the slot contents because the\n', '                        // bytes we want to change are the LSBs\n', '                        fslot,\n', '                        add(\n', '                            mul(\n', '                                div(\n', '                                    // load the bytes from memory\n', '                                    mload(add(_postBytes, 0x20)),\n', '                                    // zero all bytes to the right\n', '                                    exp(0x100, sub(32, mlength))\n', '                                ),\n', '                                // and now shift left the number of bytes to\n', '                                // leave space for the length in the slot\n', '                                exp(0x100, sub(32, newlength))\n', '                            ),\n', '                            // increase length by the double of the memory\n', '                            // bytes length\n', '                            mul(mlength, 2)\n', '                        )\n', '                    )\n', '                )\n', '            }\n', '            case 1 {\n', '                // The stored value fits in the slot, but the combined value\n', '                // will exceed it.\n', '                // get the keccak hash to get the contents of the array\n', '                mstore(0x0, _preBytes_slot)\n', '                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n', '\n', '                // save new length\n', '                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n', '\n', '                // The contents of the _postBytes array start 32 bytes into\n', '                // the structure. Our first read should obtain the `submod`\n', '                // bytes that can fit into the unused space in the last word\n', '                // of the stored array. To get this, we read 32 bytes starting\n', '                // from `submod`, so the data we read overlaps with the array\n', '                // contents by `submod` bytes. Masking the lowest-order\n', '                // `submod` bytes allows us to add that value directly to the\n', '                // stored value.\n', '\n', '                let submod := sub(32, slength)\n', '                let mc := add(_postBytes, submod)\n', '                let end := add(_postBytes, mlength)\n', '                let mask := sub(exp(0x100, submod), 1)\n', '\n', '                sstore(\n', '                    sc,\n', '                    add(\n', '                        and(\n', '                            fslot,\n', '                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n', '                        ),\n', '                        and(mload(mc), mask)\n', '                    )\n', '                )\n', '\n', '                for {\n', '                    mc := add(mc, 0x20)\n', '                    sc := add(sc, 1)\n', '                } lt(mc, end) {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } {\n', '                    sstore(sc, mload(mc))\n', '                }\n', '\n', '                mask := exp(0x100, sub(mc, end))\n', '\n', '                sstore(sc, mul(div(mload(mc), mask), mask))\n', '            }\n', '            default {\n', '                // get the keccak hash to get the contents of the array\n', '                mstore(0x0, _preBytes_slot)\n', '                // Start copying to the last used word of the stored array.\n', '                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n', '\n', '                // save new length\n', '                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n', '\n', '                // Copy over the first `submod` bytes of the new data as in\n', '                // case 1 above.\n', '                let slengthmod := mod(slength, 32)\n', '                let mlengthmod := mod(mlength, 32)\n', '                let submod := sub(32, slengthmod)\n', '                let mc := add(_postBytes, submod)\n', '                let end := add(_postBytes, mlength)\n', '                let mask := sub(exp(0x100, submod), 1)\n', '\n', '                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n', '\n', '                for {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } lt(mc, end) {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } {\n', '                    sstore(sc, mload(mc))\n', '                }\n', '\n', '                mask := exp(0x100, sub(mc, end))\n', '\n', '                sstore(sc, mul(div(mload(mc), mask), mask))\n', '            }\n', '        }\n', '    }\n', '\n', '    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {\n', '        require(_bytes.length >= (_start + _length));\n', '\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            switch iszero(_length)\n', '            case 0 {\n', '                // Get a location of some free memory and store it in tempBytes as\n', '                // Solidity does for memory variables.\n', '                tempBytes := mload(0x40)\n', '\n', '                // The first word of the slice result is potentially a partial\n', '                // word read from the original array. To read it, we calculate\n', '                // the length of that partial word and start copying that many\n', '                // bytes into the array. The first word we copy will start with\n', '                // data we don&#39;t care about, but the last `lengthmod` bytes will\n', '                // land at the beginning of the contents of the new array. When\n', '                // we&#39;re done copying, we overwrite the full first word with\n', '                // the actual length of the slice.\n', '                let lengthmod := and(_length, 31)\n', '\n', '                // The multiplication in the next line is necessary\n', '                // because when slicing multiples of 32 bytes (lengthmod == 0)\n', '                // the following copy loop was copying the origin&#39;s length\n', '                // and then ending prematurely not copying everything it should.\n', '                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n', '                let end := add(mc, _length)\n', '\n', '                for {\n', '                    // The multiplication in the next line has the same exact purpose\n', '                    // as the one above.\n', '                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n', '                } lt(mc, end) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    mstore(mc, mload(cc))\n', '                }\n', '\n', '                mstore(tempBytes, _length)\n', '\n', '                //update free-memory pointer\n', '                //allocating the array padded to 32 bytes like the compiler does now\n', '                mstore(0x40, and(add(mc, 31), not(31)))\n', '            }\n', '            //if we want a zero-length slice let&#39;s just return a zero-length array\n', '            default {\n', '                tempBytes := mload(0x40)\n', '\n', '                mstore(0x40, add(tempBytes, 0x20))\n', '            }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function toAddress(bytes _bytes, uint _start) internal  pure returns (address) {\n', '        require(_bytes.length >= (_start + 20));\n', '        address tempAddress;\n', '\n', '        assembly {\n', '            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '\n', '    function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) {\n', '        require(_bytes.length >= (_start + 32));\n', '        uint256 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n', '        bool success = true;\n', '\n', '        assembly {\n', '            let length := mload(_preBytes)\n', '\n', '            // if lengths don&#39;t match the arrays are not equal\n', '            switch eq(length, mload(_postBytes))\n', '            case 1 {\n', '                // cb is a circuit breaker in the for loop since there&#39;s\n', '                //  no said feature for inline assembly loops\n', '                // cb = 1 - don&#39;t breaker\n', '                // cb = 0 - break\n', '                let cb := 1\n', '\n', '                let mc := add(_preBytes, 0x20)\n', '                let end := add(mc, length)\n', '\n', '                for {\n', '                    let cc := add(_postBytes, 0x20)\n', '                // the next line is the loop condition:\n', '                // while(uint(mc < end) + cb == 2)\n', '                } eq(add(lt(mc, end), cb), 2) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    // if any of these checks fails then arrays are not equal\n', '                    if iszero(eq(mload(mc), mload(cc))) {\n', '                        // unsuccess:\n', '                        success := 0\n', '                        cb := 0\n', '                    }\n', '                }\n', '            }\n', '            default {\n', '                // unsuccess:\n', '                success := 0\n', '            }\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n', '        bool success = true;\n', '\n', '        assembly {\n', '            // we know _preBytes_offset is 0\n', '            let fslot := sload(_preBytes_slot)\n', '            // Decode the length of the stored array like in concatStorage().\n', '            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n', '            let mlength := mload(_postBytes)\n', '\n', '            // if lengths don&#39;t match the arrays are not equal\n', '            switch eq(slength, mlength)\n', '            case 1 {\n', '                // slength can contain both the length and contents of the array\n', '                // if length < 32 bytes so let&#39;s prepare for that\n', '                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n', '                if iszero(iszero(slength)) {\n', '                    switch lt(slength, 32)\n', '                    case 1 {\n', '                        // blank the last byte which is the length\n', '                        fslot := mul(div(fslot, 0x100), 0x100)\n', '\n', '                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n', '                            // unsuccess:\n', '                            success := 0\n', '                        }\n', '                    }\n', '                    default {\n', '                        // cb is a circuit breaker in the for loop since there&#39;s\n', '                        //  no said feature for inline assembly loops\n', '                        // cb = 1 - don&#39;t breaker\n', '                        // cb = 0 - break\n', '                        let cb := 1\n', '\n', '                        // get the keccak hash to get the contents of the array\n', '                        mstore(0x0, _preBytes_slot)\n', '                        let sc := keccak256(0x0, 0x20)\n', '\n', '                        let mc := add(_postBytes, 0x20)\n', '                        let end := add(mc, mlength)\n', '\n', '                        // the next line is the loop condition:\n', '                        // while(uint(mc < end) + cb == 2)\n', '                        for {} eq(add(lt(mc, end), cb), 2) {\n', '                            sc := add(sc, 1)\n', '                            mc := add(mc, 0x20)\n', '                        } {\n', '                            if iszero(eq(sload(sc), mload(mc))) {\n', '                                // unsuccess:\n', '                                success := 0\n', '                                cb := 0\n', '                            }\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '            default {\n', '                // unsuccess:\n', '                success := 0\n', '            }\n', '        }\n', '\n', '        return success;\n', '    }\n', '}\n', '\n', 'library MemArrApp {\n', '\n', '    // A simple library to allow appending to memory arrays.\n', '\n', '    function appendUint256(uint256[] memory arr, uint256 val) internal pure returns (uint256[] memory toRet) {\n', '        toRet = new uint256[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendUint128(uint128[] memory arr, uint128 val) internal pure returns (uint128[] memory toRet) {\n', '        toRet = new uint128[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendUint64(uint64[] memory arr, uint64 val) internal pure returns (uint64[] memory toRet) {\n', '        toRet = new uint64[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendUint32(uint32[] memory arr, uint32 val) internal pure returns (uint32[] memory toRet) {\n', '        toRet = new uint32[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendUint16(uint16[] memory arr, uint16 val) internal pure returns (uint16[] memory toRet) {\n', '        toRet = new uint16[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendBool(bool[] memory arr, bool val) internal pure returns (bool[] memory toRet) {\n', '        toRet = new bool[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendBytes32(bytes32[] memory arr, bytes32 val) internal pure returns (bytes32[] memory toRet) {\n', '        toRet = new bytes32[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendBytes32Pair(bytes32[2][] memory arr, bytes32[2] val) internal pure returns (bytes32[2][] memory toRet) {\n', '        toRet = new bytes32[2][](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendBytes(bytes[] memory arr, bytes val) internal pure returns (bytes[] memory toRet) {\n', '        toRet = new bytes[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendAddress(address[] memory arr, address val) internal pure returns (address[] memory toRet) {\n', '        toRet = new address[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '}']