['pragma solidity ^0.4.23;\n', '\n', 'library StringUtils {\n', '    struct slice {\n', '        uint _len;\n', '        uint _ptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire string.\n', '     * @param self The string to make a slice from.\n', '     * @return A newly allocated slice containing the entire string.\n', '     */\n', '    function toSlice(string self) internal pure returns (slice) {\n', '        uint ptr;\n', '        assembly {\n', '            ptr := add(self, 0x20)\n', '        }\n', '        return slice(bytes(self).length, ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a new slice containing the same data as the current slice.\n', '     * @param self The slice to copy.\n', '     * @return A new slice containing the same data as `self`.\n', '     */\n', '    function copy(slice self) internal pure returns (slice) {\n', '        return slice(self._len, self._ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Copies a slice to a new string.\n', '     * @param self The slice to copy.\n', '     * @return A newly allocated string containing the slice&#39;s text.\n', '     */\n', '    function toString(slice self) internal pure returns (string) {\n', '        string memory ret = new string(self._len);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '\n', '        memcpy(retptr, self._ptr, self._len);\n', '        return ret;\n', '    }\n', '\n', '    /**\n', '    * Lower\n', '    *\n', '    * Converts all the values of a string to their corresponding lower case\n', '    * value.\n', '    *\n', '    * @param _base When being used for a data type this is the extended object\n', '    *              otherwise this is the string base to convert to lower case\n', '    * @return string\n', '    */\n', '    function lower(string _base) internal pure returns (string) {\n', '        bytes memory _baseBytes = bytes(_base);\n', '        for (uint i = 0; i < _baseBytes.length; i++) {\n', '            _baseBytes[i] = _lower(_baseBytes[i]);\n', '        }\n', '        return string(_baseBytes);\n', '    }\n', '\n', '    /**\n', '    * Lower\n', '    *\n', '    * Convert an alphabetic character to lower case and return the original\n', '    * value when not alphabetic\n', '    *\n', '    * @param _b1 The byte to be converted to lower case\n', '    * @return bytes1 The converted value if the passed value was alphabetic\n', '    *                and in a upper case otherwise returns the original value\n', '    */\n', '    function _lower(bytes1 _b1) internal pure returns (bytes1) {\n', '        if (_b1 >= 0x41 && _b1 <= 0x5A) {\n', '            return bytes1(uint8(_b1) + 32);\n', '        }\n', '        return _b1;\n', '    }\n', '\n', '    function memcpy(uint dest, uint src, uint len) private pure {\n', '        // Copy word-length chunks while possible\n', '        for (; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract Withdrawable is Ownable {\n', '    // Allows owner to withdraw ether from the contract\n', '    function withdrawEther(address to) public onlyOwner {\n', '        to.transfer(address(this).balance);\n', '    }\n', '\n', '    // Allows owner to withdraw ERC20 tokens from the contract\n', '    function withdrawERC20Token(address tokenAddress, address to) public onlyOwner {\n', '        ERC20Basic token = ERC20Basic(tokenAddress);\n', '        token.transfer(to, token.balanceOf(address(this)));\n', '    }\n', '}\n', '\n', '\n', 'contract RaindropClient is Withdrawable {\n', '    // attach the StringUtils library\n', '    using StringUtils for string;\n', '    using StringUtils for StringUtils.slice;\n', '    // Events for when a user signs up for Raindrop Client and when their account is deleted\n', '    event UserSignUp(string casedUserName, address userAddress, bool delegated);\n', '    event UserDeleted(string casedUserName);\n', '\n', '    // Variables allowing this contract to interact with the Hydro token\n', '    address public hydroTokenAddress;\n', '    uint public minimumHydroStakeUser;\n', '    uint public minimumHydroStakeDelegatedUser;\n', '\n', '    // User account template\n', '    struct User {\n', '        string casedUserName;\n', '        address userAddress;\n', '        bool delegated;\n', '        bool _initialized;\n', '    }\n', '\n', '    // Mapping from hashed uncased names to users (primary User directory)\n', '    mapping (bytes32 => User) internal userDirectory;\n', '    // Mapping from addresses to hashed uncased names (secondary directory for account recovery based on address)\n', '    mapping (address => bytes32) internal nameDirectory;\n', '\n', '    // Requires an address to have a minimum number of Hydro\n', '    modifier requireStake(address _address, uint stake) {\n', '        ERC20Basic hydro = ERC20Basic(hydroTokenAddress);\n', '        require(hydro.balanceOf(_address) >= stake);\n', '        _;\n', '    }\n', '\n', '    // Allows applications to sign up users on their behalf iff users signed their permission\n', '    function signUpDelegatedUser(string casedUserName, address userAddress, uint8 v, bytes32 r, bytes32 s)\n', '        public\n', '        requireStake(msg.sender, minimumHydroStakeDelegatedUser)\n', '    {\n', '        require(isSigned(userAddress, keccak256("Create RaindropClient Hydro Account"), v, r, s));\n', '        _userSignUp(casedUserName, userAddress, true);\n', '    }\n', '\n', '    // Allows users to sign up with their own address\n', '    function signUpUser(string casedUserName) public requireStake(msg.sender, minimumHydroStakeUser) {\n', '        return _userSignUp(casedUserName, msg.sender, false);\n', '    }\n', '\n', '    // Allows users to delete their accounts\n', '    function deleteUser() public {\n', '        bytes32 uncasedUserNameHash = nameDirectory[msg.sender];\n', '        require(userDirectory[uncasedUserNameHash]._initialized);\n', '\n', '        string memory casedUserName = userDirectory[uncasedUserNameHash].casedUserName;\n', '\n', '        delete nameDirectory[msg.sender];\n', '        delete userDirectory[uncasedUserNameHash];\n', '\n', '        emit UserDeleted(casedUserName);\n', '    }\n', '\n', '    // Allows the Hydro API to link to the Hydro token\n', '    function setHydroTokenAddress(address _hydroTokenAddress) public onlyOwner {\n', '        hydroTokenAddress = _hydroTokenAddress;\n', '    }\n', '\n', '    // Allows the Hydro API to set minimum hydro balances required for sign ups\n', '    function setMinimumHydroStakes(uint newMinimumHydroStakeUser, uint newMinimumHydroStakeDelegatedUser)\n', '        public onlyOwner\n', '    {\n', '        ERC20Basic hydro = ERC20Basic(hydroTokenAddress);\n', '        require(newMinimumHydroStakeUser <= (hydro.totalSupply() / 100 / 100)); // <= .01% of total supply\n', '        require(newMinimumHydroStakeDelegatedUser <= (hydro.totalSupply() / 100 / 2)); // <= .5% of total supply\n', '        minimumHydroStakeUser = newMinimumHydroStakeUser;\n', '        minimumHydroStakeDelegatedUser = newMinimumHydroStakeDelegatedUser;\n', '    }\n', '\n', '    // Returns a bool indicated whether a given userName has been claimed (either exactly or as any case-variant)\n', '    function userNameTaken(string userName) public view returns (bool taken) {\n', '        bytes32 uncasedUserNameHash = keccak256(userName.lower());\n', '        return userDirectory[uncasedUserNameHash]._initialized;\n', '    }\n', '\n', '    // Returns user details (including cased username) by any cased/uncased user name that maps to a particular user\n', '    function getUserByName(string userName) public view\n', '        returns (string casedUserName, address userAddress, bool delegated)\n', '    {\n', '        bytes32 uncasedUserNameHash = keccak256(userName.lower());\n', '        User storage _user = userDirectory[uncasedUserNameHash];\n', '        require(_user._initialized);\n', '\n', '        return (_user.casedUserName, _user.userAddress, _user.delegated);\n', '    }\n', '\n', '    // Returns user details by user address\n', '    function getUserByAddress(address _address) public view returns (string casedUserName, bool delegated) {\n', '        bytes32 uncasedUserNameHash = nameDirectory[_address];\n', '        User storage _user = userDirectory[uncasedUserNameHash];\n', '        require(_user._initialized);\n', '\n', '        return (_user.casedUserName, _user.delegated);\n', '    }\n', '\n', '    // Checks whether the provided (v, r, s) signature was created by the private key associated with _address\n', '    function isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s) public pure returns (bool) {\n', '        return (_isSigned(_address, messageHash, v, r, s) || _isSignedPrefixed(_address, messageHash, v, r, s));\n', '    }\n', '\n', '    // Checks unprefixed signatures\n', '    function _isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return ecrecover(messageHash, v, r, s) == _address;\n', '    }\n', '\n', '    // Checks prefixed signatures (e.g. those created with web3.eth.sign)\n', '    function _isSignedPrefixed(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        bytes32 prefixedMessageHash = keccak256(prefix, messageHash);\n', '\n', '        return ecrecover(prefixedMessageHash, v, r, s) == _address;\n', '    }\n', '\n', '    // Common internal logic for all user signups\n', '    function _userSignUp(string casedUserName, address userAddress, bool delegated) internal {\n', '        require(bytes(casedUserName).length < 50);\n', '\n', '        bytes32 uncasedUserNameHash = keccak256(casedUserName.toSlice().copy().toString().lower());\n', '        require(!userDirectory[uncasedUserNameHash]._initialized);\n', '\n', '        userDirectory[uncasedUserNameHash] = User(casedUserName, userAddress, delegated, true);\n', '        nameDirectory[userAddress] = uncasedUserNameHash;\n', '\n', '        emit UserSignUp(casedUserName, userAddress, delegated);\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'library StringUtils {\n', '    struct slice {\n', '        uint _len;\n', '        uint _ptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire string.\n', '     * @param self The string to make a slice from.\n', '     * @return A newly allocated slice containing the entire string.\n', '     */\n', '    function toSlice(string self) internal pure returns (slice) {\n', '        uint ptr;\n', '        assembly {\n', '            ptr := add(self, 0x20)\n', '        }\n', '        return slice(bytes(self).length, ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a new slice containing the same data as the current slice.\n', '     * @param self The slice to copy.\n', '     * @return A new slice containing the same data as `self`.\n', '     */\n', '    function copy(slice self) internal pure returns (slice) {\n', '        return slice(self._len, self._ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Copies a slice to a new string.\n', '     * @param self The slice to copy.\n', "     * @return A newly allocated string containing the slice's text.\n", '     */\n', '    function toString(slice self) internal pure returns (string) {\n', '        string memory ret = new string(self._len);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '\n', '        memcpy(retptr, self._ptr, self._len);\n', '        return ret;\n', '    }\n', '\n', '    /**\n', '    * Lower\n', '    *\n', '    * Converts all the values of a string to their corresponding lower case\n', '    * value.\n', '    *\n', '    * @param _base When being used for a data type this is the extended object\n', '    *              otherwise this is the string base to convert to lower case\n', '    * @return string\n', '    */\n', '    function lower(string _base) internal pure returns (string) {\n', '        bytes memory _baseBytes = bytes(_base);\n', '        for (uint i = 0; i < _baseBytes.length; i++) {\n', '            _baseBytes[i] = _lower(_baseBytes[i]);\n', '        }\n', '        return string(_baseBytes);\n', '    }\n', '\n', '    /**\n', '    * Lower\n', '    *\n', '    * Convert an alphabetic character to lower case and return the original\n', '    * value when not alphabetic\n', '    *\n', '    * @param _b1 The byte to be converted to lower case\n', '    * @return bytes1 The converted value if the passed value was alphabetic\n', '    *                and in a upper case otherwise returns the original value\n', '    */\n', '    function _lower(bytes1 _b1) internal pure returns (bytes1) {\n', '        if (_b1 >= 0x41 && _b1 <= 0x5A) {\n', '            return bytes1(uint8(_b1) + 32);\n', '        }\n', '        return _b1;\n', '    }\n', '\n', '    function memcpy(uint dest, uint src, uint len) private pure {\n', '        // Copy word-length chunks while possible\n', '        for (; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract Withdrawable is Ownable {\n', '    // Allows owner to withdraw ether from the contract\n', '    function withdrawEther(address to) public onlyOwner {\n', '        to.transfer(address(this).balance);\n', '    }\n', '\n', '    // Allows owner to withdraw ERC20 tokens from the contract\n', '    function withdrawERC20Token(address tokenAddress, address to) public onlyOwner {\n', '        ERC20Basic token = ERC20Basic(tokenAddress);\n', '        token.transfer(to, token.balanceOf(address(this)));\n', '    }\n', '}\n', '\n', '\n', 'contract RaindropClient is Withdrawable {\n', '    // attach the StringUtils library\n', '    using StringUtils for string;\n', '    using StringUtils for StringUtils.slice;\n', '    // Events for when a user signs up for Raindrop Client and when their account is deleted\n', '    event UserSignUp(string casedUserName, address userAddress, bool delegated);\n', '    event UserDeleted(string casedUserName);\n', '\n', '    // Variables allowing this contract to interact with the Hydro token\n', '    address public hydroTokenAddress;\n', '    uint public minimumHydroStakeUser;\n', '    uint public minimumHydroStakeDelegatedUser;\n', '\n', '    // User account template\n', '    struct User {\n', '        string casedUserName;\n', '        address userAddress;\n', '        bool delegated;\n', '        bool _initialized;\n', '    }\n', '\n', '    // Mapping from hashed uncased names to users (primary User directory)\n', '    mapping (bytes32 => User) internal userDirectory;\n', '    // Mapping from addresses to hashed uncased names (secondary directory for account recovery based on address)\n', '    mapping (address => bytes32) internal nameDirectory;\n', '\n', '    // Requires an address to have a minimum number of Hydro\n', '    modifier requireStake(address _address, uint stake) {\n', '        ERC20Basic hydro = ERC20Basic(hydroTokenAddress);\n', '        require(hydro.balanceOf(_address) >= stake);\n', '        _;\n', '    }\n', '\n', '    // Allows applications to sign up users on their behalf iff users signed their permission\n', '    function signUpDelegatedUser(string casedUserName, address userAddress, uint8 v, bytes32 r, bytes32 s)\n', '        public\n', '        requireStake(msg.sender, minimumHydroStakeDelegatedUser)\n', '    {\n', '        require(isSigned(userAddress, keccak256("Create RaindropClient Hydro Account"), v, r, s));\n', '        _userSignUp(casedUserName, userAddress, true);\n', '    }\n', '\n', '    // Allows users to sign up with their own address\n', '    function signUpUser(string casedUserName) public requireStake(msg.sender, minimumHydroStakeUser) {\n', '        return _userSignUp(casedUserName, msg.sender, false);\n', '    }\n', '\n', '    // Allows users to delete their accounts\n', '    function deleteUser() public {\n', '        bytes32 uncasedUserNameHash = nameDirectory[msg.sender];\n', '        require(userDirectory[uncasedUserNameHash]._initialized);\n', '\n', '        string memory casedUserName = userDirectory[uncasedUserNameHash].casedUserName;\n', '\n', '        delete nameDirectory[msg.sender];\n', '        delete userDirectory[uncasedUserNameHash];\n', '\n', '        emit UserDeleted(casedUserName);\n', '    }\n', '\n', '    // Allows the Hydro API to link to the Hydro token\n', '    function setHydroTokenAddress(address _hydroTokenAddress) public onlyOwner {\n', '        hydroTokenAddress = _hydroTokenAddress;\n', '    }\n', '\n', '    // Allows the Hydro API to set minimum hydro balances required for sign ups\n', '    function setMinimumHydroStakes(uint newMinimumHydroStakeUser, uint newMinimumHydroStakeDelegatedUser)\n', '        public onlyOwner\n', '    {\n', '        ERC20Basic hydro = ERC20Basic(hydroTokenAddress);\n', '        require(newMinimumHydroStakeUser <= (hydro.totalSupply() / 100 / 100)); // <= .01% of total supply\n', '        require(newMinimumHydroStakeDelegatedUser <= (hydro.totalSupply() / 100 / 2)); // <= .5% of total supply\n', '        minimumHydroStakeUser = newMinimumHydroStakeUser;\n', '        minimumHydroStakeDelegatedUser = newMinimumHydroStakeDelegatedUser;\n', '    }\n', '\n', '    // Returns a bool indicated whether a given userName has been claimed (either exactly or as any case-variant)\n', '    function userNameTaken(string userName) public view returns (bool taken) {\n', '        bytes32 uncasedUserNameHash = keccak256(userName.lower());\n', '        return userDirectory[uncasedUserNameHash]._initialized;\n', '    }\n', '\n', '    // Returns user details (including cased username) by any cased/uncased user name that maps to a particular user\n', '    function getUserByName(string userName) public view\n', '        returns (string casedUserName, address userAddress, bool delegated)\n', '    {\n', '        bytes32 uncasedUserNameHash = keccak256(userName.lower());\n', '        User storage _user = userDirectory[uncasedUserNameHash];\n', '        require(_user._initialized);\n', '\n', '        return (_user.casedUserName, _user.userAddress, _user.delegated);\n', '    }\n', '\n', '    // Returns user details by user address\n', '    function getUserByAddress(address _address) public view returns (string casedUserName, bool delegated) {\n', '        bytes32 uncasedUserNameHash = nameDirectory[_address];\n', '        User storage _user = userDirectory[uncasedUserNameHash];\n', '        require(_user._initialized);\n', '\n', '        return (_user.casedUserName, _user.delegated);\n', '    }\n', '\n', '    // Checks whether the provided (v, r, s) signature was created by the private key associated with _address\n', '    function isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s) public pure returns (bool) {\n', '        return (_isSigned(_address, messageHash, v, r, s) || _isSignedPrefixed(_address, messageHash, v, r, s));\n', '    }\n', '\n', '    // Checks unprefixed signatures\n', '    function _isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return ecrecover(messageHash, v, r, s) == _address;\n', '    }\n', '\n', '    // Checks prefixed signatures (e.g. those created with web3.eth.sign)\n', '    function _isSignedPrefixed(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        bytes32 prefixedMessageHash = keccak256(prefix, messageHash);\n', '\n', '        return ecrecover(prefixedMessageHash, v, r, s) == _address;\n', '    }\n', '\n', '    // Common internal logic for all user signups\n', '    function _userSignUp(string casedUserName, address userAddress, bool delegated) internal {\n', '        require(bytes(casedUserName).length < 50);\n', '\n', '        bytes32 uncasedUserNameHash = keccak256(casedUserName.toSlice().copy().toString().lower());\n', '        require(!userDirectory[uncasedUserNameHash]._initialized);\n', '\n', '        userDirectory[uncasedUserNameHash] = User(casedUserName, userAddress, delegated, true);\n', '        nameDirectory[userAddress] = uncasedUserNameHash;\n', '\n', '        emit UserSignUp(casedUserName, userAddress, delegated);\n', '    }\n', '}']
