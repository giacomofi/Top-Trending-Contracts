['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/upgradable/ProxyStorage.sol\n', '\n', 'contract ProxyStorage {\n', '\n', '  /**\n', '   * Current contract to which we are proxing\n', '   */\n', '  address public currentContract;\n', '  address public proxyOwner;\n', '}\n', '\n', '// File: contracts/upgradable/OwnableStorage.sol\n', '\n', 'contract OwnableStorage {\n', '\n', '  address public owner;\n', '\n', '  constructor() internal {\n', '    owner = msg.sender;\n', '  }\n', '\n', '}\n', '\n', '// File: erc821/contracts/AssetRegistryStorage.sol\n', '\n', 'contract AssetRegistryStorage {\n', '\n', '  string internal _name;\n', '  string internal _symbol;\n', '  string internal _description;\n', '\n', '  /**\n', '   * Stores the total count of assets managed by this registry\n', '   */\n', '  uint256 internal _count;\n', '\n', '  /**\n', '   * Stores an array of assets owned by a given account\n', '   */\n', '  mapping(address => uint256[]) internal _assetsOf;\n', '\n', '  /**\n', '   * Stores the current holder of an asset\n', '   */\n', '  mapping(uint256 => address) internal _holderOf;\n', '\n', '  /**\n', '   * Stores the index of an asset in the `_assetsOf` array of its holder\n', '   */\n', '  mapping(uint256 => uint256) internal _indexOfAsset;\n', '\n', '  /**\n', '   * Stores the data associated with an asset\n', '   */\n', '  mapping(uint256 => string) internal _assetData;\n', '\n', '  /**\n', '   * For a given account, for a given operator, store whether that operator is\n', '   * allowed to transfer and modify assets on behalf of them.\n', '   */\n', '  mapping(address => mapping(address => bool)) internal _operators;\n', '\n', '  /**\n', '   * Approval array\n', '   */\n', '  mapping(uint256 => address) internal _approval;\n', '}\n', '\n', '// File: contracts/estate/IEstateRegistry.sol\n', '\n', 'contract IEstateRegistry {\n', '  function mint(address to, string metadata) external returns (uint256);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner); // from ERC721\n', '\n', '  // Events\n', '\n', '  event CreateEstate(\n', '    address indexed _owner,\n', '    uint256 indexed _estateId,\n', '    string _data\n', '  );\n', '\n', '  event AddLand(\n', '    uint256 indexed _estateId,\n', '    uint256 indexed _landId\n', '  );\n', '\n', '  event RemoveLand(\n', '    uint256 indexed _estateId,\n', '    uint256 indexed _landId,\n', '    address indexed _destinatary\n', '  );\n', '\n', '  event Update(\n', '    uint256 indexed _assetId,\n', '    address indexed _holder,\n', '    address indexed _operator,\n', '    string _data\n', '  );\n', '\n', '  event UpdateOperator(\n', '    uint256 indexed _estateId,\n', '    address indexed _operator\n', '  );\n', '\n', '  event SetLANDRegistry(\n', '    address indexed _registry\n', '  );\n', '}\n', '\n', '// File: contracts/land/LANDStorage.sol\n', '\n', 'contract LANDStorage {\n', '  mapping (address => uint) public latestPing;\n', '\n', '  uint256 constant clearLow = 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000;\n', '  uint256 constant clearHigh = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\n', '  uint256 constant factor = 0x100000000000000000000000000000000;\n', '\n', '  mapping (address => bool) public authorizedDeploy;\n', '\n', '  mapping (uint256 => address) public updateOperator;\n', '\n', '  IEstateRegistry public estateRegistry;\n', '}\n', '\n', '// File: contracts/Storage.sol\n', '\n', 'contract Storage is ProxyStorage, OwnableStorage, AssetRegistryStorage, LANDStorage {\n', '}\n', '\n', '// File: contracts/upgradable/Ownable.sol\n', '\n', 'contract Ownable is Storage {\n', '\n', '  event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '  modifier onlyOwner {\n', '    assert(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != owner, "Cannot transfer to yourself");\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/upgradable/IApplication.sol\n', '\n', 'contract IApplication {\n', '  function initialize(bytes data) public;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: erc821/contracts/IERC721Base.sol\n', '\n', 'interface IERC721Base {\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  // function exists(uint256 assetId) external view returns (bool);\n', '  function ownerOf(uint256 assetId) external view returns (address);\n', '\n', '  function balanceOf(address holder) external view returns (uint256);\n', '\n', '  function safeTransferFrom(address from, address to, uint256 assetId) external;\n', '  function safeTransferFrom(address from, address to, uint256 assetId, bytes userData) external;\n', '\n', '  function transferFrom(address from, address to, uint256 assetId) external;\n', '\n', '  function approve(address operator, uint256 assetId) external;\n', '  function setApprovalForAll(address operator, bool authorized) external;\n', '\n', '  function getApprovedAddress(uint256 assetId) external view returns (address);\n', '  function isApprovedForAll(address assetHolder, address operator) external view returns (bool);\n', '\n', '  function isAuthorized(address operator, uint256 assetId) external view returns (bool);\n', '\n', '  /**\n', '   * @dev Deprecated transfer event. Now we use the standard with three parameters\n', '   * It is only used in the ABI to get old transfer events. Do not remove\n', '   */\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 indexed assetId,\n', '    address operator,\n', '    bytes userData\n', '  );\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 indexed assetId\n', '  );\n', '  event ApprovalForAll(\n', '    address indexed operator,\n', '    address indexed holder,\n', '    bool authorized\n', '  );\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed operator,\n', '    uint256 indexed assetId\n', '  );\n', '}\n', '\n', '// File: erc821/contracts/IERC721Receiver.sol\n', '\n', 'interface IERC721Receiver {\n', '  function onERC721Received(\n', '    address _operator,\n', '    address _from,\n', '    uint256 _tokenId,\n', '    bytes   _userData\n', '  ) external returns (bytes4);\n', '}\n', '\n', '// File: erc821/contracts/ERC165.sol\n', '\n', 'interface ERC165 {\n', '  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', '// File: erc821/contracts/ERC721Base.sol\n', '\n', 'contract ERC721Base is AssetRegistryStorage, IERC721Base, ERC165 {\n', '  using SafeMath for uint256;\n', '\n', '  // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '  bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\n', '\n', '  bytes4 private constant InterfaceId_ERC165 = 0x01ffc9a7;\n', '  /*\n', '   * 0x01ffc9a7 ===\n', '   *   bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;))\n', '   */\n', '\n', '  bytes4 private constant Old_InterfaceId_ERC721 = 0x7c0633c6;\n', '  bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd;\n', '   /*\n', '   * 0x80ac58cd ===\n', '   *   bytes4(keccak256(&#39;balanceOf(address)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;approve(address,uint256)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;getApproved(uint256)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;setApprovalForAll(address,bool)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;isApprovedForAll(address,address)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;transferFrom(address,address,uint256)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;safeTransferFrom(address,address,uint256)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;safeTransferFrom(address,address,uint256,bytes)&#39;))\n', '   */\n', '\n', '  //\n', '  // Global Getters\n', '  //\n', '\n', '  /**\n', '   * @dev Gets the total amount of assets stored by the contract\n', '   * @return uint256 representing the total amount of assets\n', '   */\n', '  function totalSupply() external view returns (uint256) {\n', '    return _totalSupply();\n', '  }\n', '  function _totalSupply() internal view returns (uint256) {\n', '    return _count;\n', '  }\n', '\n', '  //\n', '  // Asset-centric getter functions\n', '  //\n', '\n', '  /**\n', '   * @dev Queries what address owns an asset. This method does not throw.\n', '   * In order to check if the asset exists, use the `exists` function or check if the\n', '   * return value of this call is `0`.\n', '   * @return uint256 the assetId\n', '   */\n', '  function ownerOf(uint256 assetId) external view returns (address) {\n', '    return _ownerOf(assetId);\n', '  }\n', '  function _ownerOf(uint256 assetId) internal view returns (address) {\n', '    return _holderOf[assetId];\n', '  }\n', '\n', '  //\n', '  // Holder-centric getter functions\n', '  //\n', '  /**\n', '   * @dev Gets the balance of the specified address\n', '   * @param owner address to query the balance of\n', '   * @return uint256 representing the amount owned by the passed address\n', '   */\n', '  function balanceOf(address owner) external view returns (uint256) {\n', '    return _balanceOf(owner);\n', '  }\n', '  function _balanceOf(address owner) internal view returns (uint256) {\n', '    return _assetsOf[owner].length;\n', '  }\n', '\n', '  //\n', '  // Authorization getters\n', '  //\n', '\n', '  /**\n', '   * @dev Query whether an address has been authorized to move any assets on behalf of someone else\n', '   * @param operator the address that might be authorized\n', '   * @param assetHolder the address that provided the authorization\n', '   * @return bool true if the operator has been authorized to move any assets\n', '   */\n', '  function isApprovedForAll(address assetHolder, address operator)\n', '    external view returns (bool)\n', '  {\n', '    return _isApprovedForAll(assetHolder, operator);\n', '  }\n', '  function _isApprovedForAll(address assetHolder, address operator)\n', '    internal view returns (bool)\n', '  {\n', '    return _operators[assetHolder][operator];\n', '  }\n', '\n', '  /**\n', '   * @dev Query what address has been particularly authorized to move an asset\n', '   * @param assetId the asset to be queried for\n', '   * @return bool true if the asset has been approved by the holder\n', '   */\n', '  function getApproved(uint256 assetId) external view returns (address) {\n', '    return _getApprovedAddress(assetId);\n', '  }\n', '  function getApprovedAddress(uint256 assetId) external view returns (address) {\n', '    return _getApprovedAddress(assetId);\n', '  }\n', '  function _getApprovedAddress(uint256 assetId) internal view returns (address) {\n', '    return _approval[assetId];\n', '  }\n', '\n', '  /**\n', '   * @dev Query if an operator can move an asset.\n', '   * @param operator the address that might be authorized\n', '   * @param assetId the asset that has been `approved` for transfer\n', '   * @return bool true if the asset has been approved by the holder\n', '   */\n', '  function isAuthorized(address operator, uint256 assetId) external view returns (bool) {\n', '    return _isAuthorized(operator, assetId);\n', '  }\n', '  function _isAuthorized(address operator, uint256 assetId) internal view returns (bool)\n', '  {\n', '    require(operator != 0);\n', '    address owner = _ownerOf(assetId);\n', '    if (operator == owner) {\n', '      return true;\n', '    }\n', '    return _isApprovedForAll(owner, operator) || _getApprovedAddress(assetId) == operator;\n', '  }\n', '\n', '  //\n', '  // Authorization\n', '  //\n', '\n', '  /**\n', '   * @dev Authorize a third party operator to manage (send) msg.sender&#39;s asset\n', '   * @param operator address to be approved\n', '   * @param authorized bool set to true to authorize, false to withdraw authorization\n', '   */\n', '  function setApprovalForAll(address operator, bool authorized) external {\n', '    return _setApprovalForAll(operator, authorized);\n', '  }\n', '  function _setApprovalForAll(address operator, bool authorized) internal {\n', '    if (authorized) {\n', '      require(!_isApprovedForAll(msg.sender, operator));\n', '      _addAuthorization(operator, msg.sender);\n', '    } else {\n', '      require(_isApprovedForAll(msg.sender, operator));\n', '      _clearAuthorization(operator, msg.sender);\n', '    }\n', '    emit ApprovalForAll(msg.sender, operator, authorized);\n', '  }\n', '\n', '  /**\n', '   * @dev Authorize a third party operator to manage one particular asset\n', '   * @param operator address to be approved\n', '   * @param assetId asset to approve\n', '   */\n', '  function approve(address operator, uint256 assetId) external {\n', '    address holder = _ownerOf(assetId);\n', '    require(msg.sender == holder || _isApprovedForAll(msg.sender, holder));\n', '    require(operator != holder);\n', '\n', '    if (_getApprovedAddress(assetId) != operator) {\n', '      _approval[assetId] = operator;\n', '      emit Approval(holder, operator, assetId);\n', '    }\n', '  }\n', '\n', '  function _addAuthorization(address operator, address holder) private {\n', '    _operators[holder][operator] = true;\n', '  }\n', '\n', '  function _clearAuthorization(address operator, address holder) private {\n', '    _operators[holder][operator] = false;\n', '  }\n', '\n', '  //\n', '  // Internal Operations\n', '  //\n', '\n', '  function _addAssetTo(address to, uint256 assetId) internal {\n', '    _holderOf[assetId] = to;\n', '\n', '    uint256 length = _balanceOf(to);\n', '\n', '    _assetsOf[to].push(assetId);\n', '\n', '    _indexOfAsset[assetId] = length;\n', '\n', '    _count = _count.add(1);\n', '  }\n', '\n', '  function _removeAssetFrom(address from, uint256 assetId) internal {\n', '    uint256 assetIndex = _indexOfAsset[assetId];\n', '    uint256 lastAssetIndex = _balanceOf(from).sub(1);\n', '    uint256 lastAssetId = _assetsOf[from][lastAssetIndex];\n', '\n', '    _holderOf[assetId] = 0;\n', '\n', '    // Insert the last asset into the position previously occupied by the asset to be removed\n', '    _assetsOf[from][assetIndex] = lastAssetId;\n', '\n', '    // Resize the array\n', '    _assetsOf[from][lastAssetIndex] = 0;\n', '    _assetsOf[from].length--;\n', '\n', '    // Remove the array if no more assets are owned to prevent pollution\n', '    if (_assetsOf[from].length == 0) {\n', '      delete _assetsOf[from];\n', '    }\n', '\n', '    // Update the index of positions for the asset\n', '    _indexOfAsset[assetId] = 0;\n', '    _indexOfAsset[lastAssetId] = assetIndex;\n', '\n', '    _count = _count.sub(1);\n', '  }\n', '\n', '  function _clearApproval(address holder, uint256 assetId) internal {\n', '    if (_ownerOf(assetId) == holder && _approval[assetId] != 0) {\n', '      _approval[assetId] = 0;\n', '      emit Approval(holder, 0, assetId);\n', '    }\n', '  }\n', '\n', '  //\n', '  // Supply-altering functions\n', '  //\n', '\n', '  function _generate(uint256 assetId, address beneficiary) internal {\n', '    require(_holderOf[assetId] == 0);\n', '\n', '    _addAssetTo(beneficiary, assetId);\n', '\n', '    emit Transfer(0, beneficiary, assetId);\n', '  }\n', '\n', '  function _destroy(uint256 assetId) internal {\n', '    address holder = _holderOf[assetId];\n', '    require(holder != 0);\n', '\n', '    _removeAssetFrom(holder, assetId);\n', '\n', '    emit Transfer(holder, 0, assetId);\n', '  }\n', '\n', '  //\n', '  // Transaction related operations\n', '  //\n', '\n', '  modifier onlyHolder(uint256 assetId) {\n', '    require(_ownerOf(assetId) == msg.sender);\n', '    _;\n', '  }\n', '\n', '  modifier onlyAuthorized(uint256 assetId) {\n', '    require(_isAuthorized(msg.sender, assetId));\n', '    _;\n', '  }\n', '\n', '  modifier isCurrentOwner(address from, uint256 assetId) {\n', '    require(_ownerOf(assetId) == from);\n', '    _;\n', '  }\n', '\n', '  modifier isDestinataryDefined(address destinatary) {\n', '    require(destinatary != 0);\n', '    _;\n', '  }\n', '\n', '  modifier destinataryIsNotHolder(uint256 assetId, address to) {\n', '    require(_ownerOf(assetId) != to);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Alias of `safeTransferFrom(from, to, assetId, &#39;&#39;)`\n', '   *\n', '   * @param from address that currently owns an asset\n', '   * @param to address to receive the ownership of the asset\n', '   * @param assetId uint256 ID of the asset to be transferred\n', '   */\n', '  function safeTransferFrom(address from, address to, uint256 assetId) external {\n', '    return _doTransferFrom(from, to, assetId, &#39;&#39;, true);\n', '  }\n', '\n', '  /**\n', '   * @dev Securely transfers the ownership of a given asset from one address to\n', '   * another address, calling the method `onNFTReceived` on the target address if\n', '   * there&#39;s code associated with it\n', '   *\n', '   * @param from address that currently owns an asset\n', '   * @param to address to receive the ownership of the asset\n', '   * @param assetId uint256 ID of the asset to be transferred\n', '   * @param userData bytes arbitrary user information to attach to this transfer\n', '   */\n', '  function safeTransferFrom(address from, address to, uint256 assetId, bytes userData) external {\n', '    return _doTransferFrom(from, to, assetId, userData, true);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of a given asset from one address to another address\n', '   * Warning! This function does not attempt to verify that the target address can send\n', '   * tokens.\n', '   *\n', '   * @param from address sending the asset\n', '   * @param to address to receive the ownership of the asset\n', '   * @param assetId uint256 ID of the asset to be transferred\n', '   */\n', '  function transferFrom(address from, address to, uint256 assetId) external {\n', '    return _doTransferFrom(from, to, assetId, &#39;&#39;, false);\n', '  }\n', '\n', '  function _doTransferFrom(\n', '    address from,\n', '    address to,\n', '    uint256 assetId,\n', '    bytes userData,\n', '    bool doCheck\n', '  )\n', '    onlyAuthorized(assetId)\n', '    internal\n', '  {\n', '    _moveToken(from, to, assetId, userData, doCheck);\n', '  }\n', '\n', '  function _moveToken(\n', '    address from,\n', '    address to,\n', '    uint256 assetId,\n', '    bytes userData,\n', '    bool doCheck\n', '  )\n', '    isDestinataryDefined(to)\n', '    destinataryIsNotHolder(assetId, to)\n', '    isCurrentOwner(from, assetId)\n', '    internal\n', '  {\n', '    address holder = _holderOf[assetId];\n', '    _removeAssetFrom(holder, assetId);\n', '    _clearApproval(holder, assetId);\n', '    _addAssetTo(to, assetId);\n', '\n', '    if (doCheck && _isContract(to)) {\n', '      // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))\n', '      require(\n', '        IERC721Receiver(to).onERC721Received(\n', '          msg.sender, holder, assetId, userData\n', '        ) == ERC721_RECEIVED\n', '      );\n', '    }\n', '\n', '    emit Transfer(holder, to, assetId);\n', '  }\n', '\n', '  /**\n', '   * Internal function that moves an asset from one holder to another\n', '   */\n', '\n', '  /**\n', '   * @dev Returns `true` if the contract implements `interfaceID` and `interfaceID` is not 0xffffffff, `false` otherwise\n', '   * @param  _interfaceID The interface identifier, as specified in ERC-165\n', '   */\n', '  function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n', '\n', '    if (_interfaceID == 0xffffffff) {\n', '      return false;\n', '    }\n', '    return _interfaceID == InterfaceId_ERC165 || _interfaceID == Old_InterfaceId_ERC721 || _interfaceID == InterfaceId_ERC721;\n', '  }\n', '\n', '  //\n', '  // Utilities\n', '  //\n', '\n', '  function _isContract(address addr) internal view returns (bool) {\n', '    uint size;\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '}\n', '\n', '// File: erc821/contracts/IERC721Enumerable.sol\n', '\n', 'contract IERC721Enumerable {\n', '\n', '  /**\n', '   * @notice Enumerate active tokens\n', '   * @dev Throws if `index` >= `totalSupply()`, otherwise SHALL NOT throw.\n', '   * @param index A counter less than `totalSupply()`\n', '   * @return The identifier for the `index`th asset, (sort order not\n', '   *  specified)\n', '   */\n', '  // TODO (eordano): Not implemented\n', '  // function tokenByIndex(uint256 index) public view returns (uint256 _assetId);\n', '\n', '  /**\n', '   * @notice Count of owners which own at least one asset\n', '   *  Must not throw.\n', '   * @return A count of the number of owners which own asset\n', '   */\n', '  // TODO (eordano): Not implemented\n', '  // function countOfOwners() public view returns (uint256 _count);\n', '\n', '  /**\n', '   * @notice Enumerate owners\n', '   * @dev Throws if `index` >= `countOfOwners()`, otherwise must not throw.\n', '   * @param index A counter less than `countOfOwners()`\n', '   * @return The address of the `index`th owner (sort order not specified)\n', '   */\n', '  // TODO (eordano): Not implemented\n', '  // function ownerByIndex(uint256 index) public view returns (address owner);\n', '\n', '  /**\n', '   * @notice Get all tokens of a given address\n', '   * @dev This is not intended to be used on-chain\n', '   * @param owner address of the owner to query\n', '   * @return a list of all assetIds of a user\n', '   */\n', '  function tokensOf(address owner) external view returns (uint256[]);\n', '\n', '  /**\n', '   * @notice Enumerate tokens assigned to an owner\n', '   * @dev Throws if `index` >= `balanceOf(owner)` or if\n', '   *  `owner` is the zero address, representing invalid assets.\n', '   *  Otherwise this must not throw.\n', '   * @param owner An address where we are interested in assets owned by them\n', '   * @param index A counter less than `balanceOf(owner)`\n', '   * @return The identifier for the `index`th asset assigned to `owner`,\n', '   *   (sort order not specified)\n', '   */\n', '  function tokenOfOwnerByIndex(\n', '    address owner, uint256 index\n', '  ) external view returns (uint256 tokenId);\n', '}\n', '\n', '// File: erc821/contracts/ERC721Enumerable.sol\n', '\n', 'contract ERC721Enumerable is AssetRegistryStorage, IERC721Enumerable {\n', '\n', '  /**\n', '   * @notice Get all tokens of a given address\n', '   * @dev This is not intended to be used on-chain\n', '   * @param owner address of the owner to query\n', '   * @return a list of all assetIds of a user\n', '   */\n', '  function tokensOf(address owner) external view returns (uint256[]) {\n', '    return _assetsOf[owner];\n', '  }\n', '\n', '  /**\n', '   * @notice Enumerate tokens assigned to an owner\n', '   * @dev Throws if `index` >= `balanceOf(owner)` or if\n', '   *  `owner` is the zero address, representing invalid assets.\n', '   *  Otherwise this must not throw.\n', '   * @param owner An address where we are interested in assets owned by them\n', '   * @param index A counter less than `balanceOf(owner)`\n', '   * @return The identifier for the `index`th asset assigned to `owner`,\n', '   *   (sort order not specified)\n', '   */\n', '  function tokenOfOwnerByIndex(\n', '    address owner, uint256 index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256 assetId)\n', '  {\n', '    require(index < _assetsOf[owner].length);\n', '    require(index < (1<<127));\n', '    return _assetsOf[owner][index];\n', '  }\n', '\n', '}\n', '\n', '// File: erc821/contracts/IERC721Metadata.sol\n', '\n', 'contract IERC721Metadata {\n', '\n', '  /**\n', '   * @notice A descriptive name for a collection of NFTs in this contract\n', '   */\n', '  function name() external view returns (string);\n', '\n', '  /**\n', '   * @notice An abbreviated name for NFTs in this contract\n', '   */\n', '  function symbol() external view returns (string);\n', '\n', '  /**\n', '   * @notice A description of what this DAR is used for\n', '   */\n', '  function description() external view returns (string);\n', '\n', '  /**\n', '   * Stores arbitrary info about a token\n', '   */\n', '  function tokenMetadata(uint256 assetId) external view returns (string);\n', '}\n', '\n', '// File: erc821/contracts/ERC721Metadata.sol\n', '\n', 'contract ERC721Metadata is AssetRegistryStorage, IERC721Metadata {\n', '  function name() external view returns (string) {\n', '    return _name;\n', '  }\n', '  function symbol() external view returns (string) {\n', '    return _symbol;\n', '  }\n', '  function description() external view returns (string) {\n', '    return _description;\n', '  }\n', '  function tokenMetadata(uint256 assetId) external view returns (string) {\n', '    return _assetData[assetId];\n', '  }\n', '  function _update(uint256 assetId, string data) internal {\n', '    _assetData[assetId] = data;\n', '  }\n', '}\n', '\n', '// File: erc821/contracts/FullAssetRegistry.sol\n', '\n', 'contract FullAssetRegistry is ERC721Base, ERC721Enumerable, ERC721Metadata {\n', '  constructor() public {\n', '  }\n', '\n', '  /**\n', '   * @dev Method to check if an asset identified by the given id exists under this DAR.\n', '   * @return uint256 the assetId\n', '   */\n', '  function exists(uint256 assetId) external view returns (bool) {\n', '    return _exists(assetId);\n', '  }\n', '  function _exists(uint256 assetId) internal view returns (bool) {\n', '    return _holderOf[assetId] != 0;\n', '  }\n', '\n', '  function decimals() external pure returns (uint256) {\n', '    return 0;\n', '  }\n', '}\n', '\n', '// File: contracts/land/ILANDRegistry.sol\n', '\n', 'interface ILANDRegistry {\n', '\n', '  // LAND can be assigned by the owner\n', '  function assignNewParcel(int x, int y, address beneficiary) external;\n', '  function assignMultipleParcels(int[] x, int[] y, address beneficiary) external;\n', '\n', '  // After one year, LAND can be claimed from an inactive public key\n', '  function ping() external;\n', '\n', '  // LAND-centric getters\n', '  function encodeTokenId(int x, int y) external pure returns (uint256);\n', '  function decodeTokenId(uint value) external pure returns (int, int);\n', '  function exists(int x, int y) external view returns (bool);\n', '  function ownerOfLand(int x, int y) external view returns (address);\n', '  function ownerOfLandMany(int[] x, int[] y) external view returns (address[]);\n', '  function landOf(address owner) external view returns (int[], int[]);\n', '  function landData(int x, int y) external view returns (string);\n', '\n', '  // Transfer LAND\n', '  function transferLand(int x, int y, address to) external;\n', '  function transferManyLand(int[] x, int[] y, address to) external;\n', '\n', '  // Update LAND\n', '  function updateLandData(int x, int y, string data) external;\n', '  function updateManyLandData(int[] x, int[] y, string data) external;\n', '\n', '  // Events\n', '\n', '  event Update(\n', '    uint256 indexed assetId,\n', '    address indexed holder,\n', '    address indexed operator,\n', '    string data\n', '  );\n', '\n', '  event UpdateOperator(\n', '    uint256 indexed assetId,\n', '    address indexed operator\n', '  );\n', '}\n', '\n', '// File: contracts/metadata/IMetadataHolder.sol\n', '\n', 'contract IMetadataHolder is ERC165 {\n', '  function getMetadata(uint256 /* assetId */) external view returns (string);\n', '}\n', '\n', '// File: contracts/land/LANDRegistry.sol\n', '\n', '/* solium-disable function-order */\n', 'contract LANDRegistry is Storage, Ownable, FullAssetRegistry, ILANDRegistry {\n', '  bytes4 constant public GET_METADATA = bytes4(keccak256("getMetadata(uint256)"));\n', '\n', '  function initialize(bytes) external {\n', '    _name = "Decentraland LAND";\n', '    _symbol = "LAND";\n', '    _description = "Contract that stores the Decentraland LAND registry";\n', '  }\n', '\n', '  modifier onlyProxyOwner() {\n', '    require(msg.sender == proxyOwner, "This function can only be called by the proxy owner");\n', '    _;\n', '  }\n', '\n', '  //\n', '  // LAND Create and destroy\n', '  //\n', '\n', '  modifier onlyOwnerOf(uint256 assetId) {\n', '    require(\n', '      msg.sender == _ownerOf(assetId),\n', '      "This function can only be called by the owner of the asset"\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier onlyUpdateAuthorized(uint256 tokenId) {\n', '    require(\n', '      msg.sender == _ownerOf(tokenId) || _isUpdateAuthorized(msg.sender, tokenId),\n', '      "msg.sender is not authorized to update"\n', '    );\n', '    _;\n', '  }\n', '\n', '  function isUpdateAuthorized(address operator, uint256 assetId) external view returns (bool) {\n', '    return _isUpdateAuthorized(operator, assetId);\n', '  }\n', '\n', '  function _isUpdateAuthorized(address operator, uint256 assetId) internal view returns (bool) {\n', '    return operator == _ownerOf(assetId) || updateOperator[assetId] == operator;\n', '  }\n', '\n', '  function authorizeDeploy(address beneficiary) external onlyProxyOwner {\n', '    authorizedDeploy[beneficiary] = true;\n', '  }\n', '\n', '  function forbidDeploy(address beneficiary) external onlyProxyOwner {\n', '    authorizedDeploy[beneficiary] = false;\n', '  }\n', '\n', '  function assignNewParcel(int x, int y, address beneficiary) external onlyProxyOwner {\n', '    _generate(_encodeTokenId(x, y), beneficiary);\n', '  }\n', '\n', '  function assignMultipleParcels(int[] x, int[] y, address beneficiary) external onlyProxyOwner {\n', '    for (uint i = 0; i < x.length; i++) {\n', '      _generate(_encodeTokenId(x[i], y[i]), beneficiary);\n', '    }\n', '  }\n', '\n', '  //\n', '  // Inactive keys after 1 year lose ownership\n', '  //\n', '\n', '  function ping() external {\n', '    // solium-disable-next-line security/no-block-members\n', '    latestPing[msg.sender] = block.timestamp;\n', '  }\n', '\n', '  function setLatestToNow(address user) external {\n', '    require(msg.sender == proxyOwner || _isApprovedForAll(msg.sender, user), "Unauthorized user");\n', '    // solium-disable-next-line security/no-block-members\n', '    latestPing[user] = block.timestamp;\n', '  }\n', '\n', '  //\n', '  // LAND Getters\n', '  //\n', '\n', '  function encodeTokenId(int x, int y) external pure returns (uint) {\n', '    return _encodeTokenId(x, y);\n', '  }\n', '\n', '  function _encodeTokenId(int x, int y) internal pure returns (uint result) {\n', '    require(\n', '      -1000000 < x && x < 1000000 && -1000000 < y && y < 1000000,\n', '      "The coordinates should be inside bounds"\n', '    );\n', '    return _unsafeEncodeTokenId(x, y);\n', '  }\n', '\n', '  function _unsafeEncodeTokenId(int x, int y) internal pure returns (uint) {\n', '    return ((uint(x) * factor) & clearLow) | (uint(y) & clearHigh);\n', '  }\n', '\n', '  function decodeTokenId(uint value) external pure returns (int, int) {\n', '    return _decodeTokenId(value);\n', '  }\n', '\n', '  function _unsafeDecodeTokenId(uint value) internal pure returns (int x, int y) {\n', '    x = expandNegative128BitCast((value & clearLow) >> 128);\n', '    y = expandNegative128BitCast(value & clearHigh);\n', '  }\n', '\n', '  function _decodeTokenId(uint value) internal pure returns (int x, int y) {\n', '    (x, y) = _unsafeDecodeTokenId(value);\n', '    require(\n', '      -1000000 < x && x < 1000000 && -1000000 < y && y < 1000000,\n', '      "The coordinates should be inside bounds"\n', '    );\n', '  }\n', '\n', '  function expandNegative128BitCast(uint value) internal pure returns (int) {\n', '    if (value & (1<<127) != 0) {\n', '      return int(value | clearLow);\n', '    }\n', '    return int(value);\n', '  }\n', '\n', '  function exists(int x, int y) external view returns (bool) {\n', '    return _exists(x, y);\n', '  }\n', '\n', '  function _exists(int x, int y) internal view returns (bool) {\n', '    return _exists(_encodeTokenId(x, y));\n', '  }\n', '\n', '  function ownerOfLand(int x, int y) external view returns (address) {\n', '    return _ownerOfLand(x, y);\n', '  }\n', '\n', '  function _ownerOfLand(int x, int y) internal view returns (address) {\n', '    return _ownerOf(_encodeTokenId(x, y));\n', '  }\n', '\n', '  function ownerOfLandMany(int[] x, int[] y) external view returns (address[]) {\n', '    require(x.length > 0, "You should supply at least one coordinate");\n', '    require(x.length == y.length, "The coordinates should have the same length");\n', '\n', '    address[] memory addrs = new address[](x.length);\n', '    for (uint i = 0; i < x.length; i++) {\n', '      addrs[i] = _ownerOfLand(x[i], y[i]);\n', '    }\n', '\n', '    return addrs;\n', '  }\n', '\n', '  function landOf(address owner) external view returns (int[], int[]) {\n', '    uint256 len = _assetsOf[owner].length;\n', '    int[] memory x = new int[](len);\n', '    int[] memory y = new int[](len);\n', '\n', '    int assetX;\n', '    int assetY;\n', '    for (uint i = 0; i < len; i++) {\n', '      (assetX, assetY) = _decodeTokenId(_assetsOf[owner][i]);\n', '      x[i] = assetX;\n', '      y[i] = assetY;\n', '    }\n', '\n', '    return (x, y);\n', '  }\n', '\n', '  function tokenMetadata(uint256 assetId) external view returns (string) {\n', '    return _tokenMetadata(assetId);\n', '  }\n', '\n', '  function _tokenMetadata(uint256 assetId) internal view returns (string) {\n', '    address _owner = _ownerOf(assetId);\n', '    if (_isContract(_owner) && _owner != address(estateRegistry)) {\n', '      if ((ERC165(_owner)).supportsInterface(GET_METADATA)) {\n', '        return IMetadataHolder(_owner).getMetadata(assetId);\n', '      }\n', '    }\n', '    return _assetData[assetId];\n', '  }\n', '\n', '  function landData(int x, int y) external view returns (string) {\n', '    return _tokenMetadata(_encodeTokenId(x, y));\n', '  }\n', '\n', '  //\n', '  // LAND Transfer\n', '  //\n', '\n', '  function transferFrom(address from, address to, uint256 assetId) external {\n', '    require(to != address(estateRegistry), "EstateRegistry unsafe transfers are not allowed");\n', '    return _doTransferFrom(\n', '      from,\n', '      to,\n', '      assetId,\n', '      "",\n', '      false\n', '    );\n', '  }\n', '\n', '  function transferLand(int x, int y, address to) external {\n', '    uint256 tokenId = _encodeTokenId(x, y);\n', '    _doTransferFrom(\n', '      _ownerOf(tokenId),\n', '      to,\n', '      tokenId,\n', '      "",\n', '      true\n', '    );\n', '  }\n', '\n', '  function transferManyLand(int[] x, int[] y, address to) external {\n', '    require(x.length > 0, "You should supply at least one coordinate");\n', '    require(x.length == y.length, "The coordinates should have the same length");\n', '\n', '    for (uint i = 0; i < x.length; i++) {\n', '      uint256 tokenId = _encodeTokenId(x[i], y[i]);\n', '      _doTransferFrom(\n', '        _ownerOf(tokenId),\n', '        to,\n', '        tokenId,\n', '        "",\n', '        true\n', '      );\n', '    }\n', '  }\n', '\n', '  function transferLandToEstate(int x, int y, uint256 estateId) external {\n', '    require(\n', '      estateRegistry.ownerOf(estateId) == msg.sender,\n', '      "You must own the Estate you want to transfer to"\n', '    );\n', '\n', '    uint256 tokenId = _encodeTokenId(x, y);\n', '    _doTransferFrom(\n', '      _ownerOf(tokenId),\n', '      address(estateRegistry),\n', '      tokenId,\n', '      toBytes(estateId),\n', '      true\n', '    );\n', '  }\n', '\n', '  function transferManyLandToEstate(int[] x, int[] y, uint256 estateId) external {\n', '    require(x.length > 0, "You should supply at least one coordinate");\n', '    require(x.length == y.length, "The coordinates should have the same length");\n', '    require(\n', '      estateRegistry.ownerOf(estateId) == msg.sender,\n', '      "You must own the Estate you want to transfer to"\n', '    );\n', '\n', '    for (uint i = 0; i < x.length; i++) {\n', '      uint256 tokenId = _encodeTokenId(x[i], y[i]);\n', '      _doTransferFrom(\n', '        _ownerOf(tokenId),\n', '        address(estateRegistry),\n', '        tokenId,\n', '        toBytes(estateId),\n', '        true\n', '      );\n', '    }\n', '  }\n', '\n', '  function setUpdateOperator(uint256 assetId, address operator) external onlyOwnerOf(assetId) {\n', '    updateOperator[assetId] = operator;\n', '    emit UpdateOperator(assetId, operator);\n', '  }\n', '\n', '  //\n', '  // Estate generation\n', '  //\n', '\n', '  event EstateRegistrySet(address indexed registry);\n', '\n', '  function setEstateRegistry(address registry) external onlyProxyOwner {\n', '    estateRegistry = IEstateRegistry(registry);\n', '    emit EstateRegistrySet(registry);\n', '  }\n', '\n', '  function createEstate(int[] x, int[] y, address beneficiary) external returns (uint256) {\n', '    // solium-disable-next-line arg-overflow\n', '    return _createEstate(x, y, beneficiary, "");\n', '  }\n', '\n', '  function createEstateWithMetadata(\n', '    int[] x,\n', '    int[] y,\n', '    address beneficiary,\n', '    string metadata\n', '  )\n', '    external\n', '    returns (uint256)\n', '  {\n', '    // solium-disable-next-line arg-overflow\n', '    return _createEstate(x, y, beneficiary, metadata);\n', '  }\n', '\n', '  function _createEstate(\n', '    int[] x,\n', '    int[] y,\n', '    address beneficiary,\n', '    string metadata\n', '  )\n', '    internal\n', '    returns (uint256)\n', '  {\n', '    require(x.length > 0, "You should supply at least one coordinate");\n', '    require(x.length == y.length, "The coordinates should have the same length");\n', '    require(address(estateRegistry) != 0, "The Estate registry should be set");\n', '\n', '    uint256 estateTokenId = estateRegistry.mint(beneficiary, metadata);\n', '    bytes memory estateTokenIdBytes = toBytes(estateTokenId);\n', '\n', '    for (uint i = 0; i < x.length; i++) {\n', '      uint256 tokenId = _encodeTokenId(x[i], y[i]);\n', '      _doTransferFrom(\n', '        _ownerOf(tokenId),\n', '        address(estateRegistry),\n', '        tokenId,\n', '        estateTokenIdBytes,\n', '        true\n', '      );\n', '    }\n', '\n', '    return estateTokenId;\n', '  }\n', '\n', '  function toBytes(uint256 x) internal pure returns (bytes b) {\n', '    b = new bytes(32);\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { mstore(add(b, 32), x) }\n', '  }\n', '\n', '  //\n', '  // LAND Update\n', '  //\n', '\n', '  function updateLandData(\n', '    int x,\n', '    int y,\n', '    string data\n', '  )\n', '    external\n', '    onlyUpdateAuthorized(_encodeTokenId(x, y))\n', '  {\n', '    return _updateLandData(x, y, data);\n', '  }\n', '\n', '  function _updateLandData(\n', '    int x,\n', '    int y,\n', '    string data\n', '  )\n', '    internal\n', '    onlyUpdateAuthorized(_encodeTokenId(x, y))\n', '  {\n', '    uint256 assetId = _encodeTokenId(x, y);\n', '    address owner = _holderOf[assetId];\n', '\n', '    _update(assetId, data);\n', '\n', '    emit Update(\n', '      assetId,\n', '      owner,\n', '      msg.sender,\n', '      data\n', '    );\n', '  }\n', '\n', '  function updateManyLandData(int[] x, int[] y, string data) external {\n', '    require(x.length > 0, "You should supply at least one coordinate");\n', '    require(x.length == y.length, "The coordinates should have the same length");\n', '    for (uint i = 0; i < x.length; i++) {\n', '      _updateLandData(x[i], y[i], data);\n', '    }\n', '  }\n', '\n', '  function _doTransferFrom(\n', '    address from,\n', '    address to,\n', '    uint256 assetId,\n', '    bytes userData,\n', '    bool doCheck\n', '  )\n', '    internal\n', '  {\n', '    updateOperator[assetId] = address(0);\n', '\n', '    super._doTransferFrom(\n', '      from,\n', '      to,\n', '      assetId,\n', '      userData,\n', '      doCheck\n', '    );\n', '  }\n', '\n', '  function _isContract(address addr) internal view returns (bool) {\n', '    uint size;\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '}']