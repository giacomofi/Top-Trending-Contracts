['// CryptoGods Copyright (c) 2018. All rights reserved.\n', '\n', 'pragma solidity ^0.4.20;\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '}\n', 'contract Owned {\n', '    address public ceoAddress;\n', '    address public cooAddress;\n', '    address private newCeoAddress;\n', '    address private newCooAddress;\n', '    function Owned() public {\n', '        ceoAddress = msg.sender;\n', '        cooAddress = msg.sender;\n', '    }\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '    modifier onlyCOO() {\n', '        require(msg.sender == cooAddress);\n', '        _;\n', '    }\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cooAddress\n', '        );\n', '        _;\n', '    }\n', '    function setCEO(address _newCEO) public onlyCEO {\n', '        require(_newCEO != address(0));\n', '        newCeoAddress = _newCEO;\n', '    }\n', '    function setCOO(address _newCOO) public onlyCEO {\n', '        require(_newCOO != address(0));\n', '        newCooAddress = _newCOO;\n', '    }\n', '    function acceptCeoOwnership() public {\n', '        require(msg.sender == newCeoAddress);\n', '        require(address(0) != newCeoAddress);\n', '        ceoAddress = newCeoAddress;\n', '        newCeoAddress = address(0);\n', '    }\n', '    function acceptCooOwnership() public {\n', '        require(msg.sender == newCooAddress);\n', '        require(address(0) != newCooAddress);\n', '        cooAddress = newCooAddress;\n', '        newCooAddress = address(0);\n', '    }\n', '}\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', 'contract ERC20 is ERC20Interface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    string public constant symbol = "GPC";\n', '    string public constant name = "God Power Coin";\n', '    uint8 public constant decimals = 18;\n', '    uint constant WAD = 10 ** 18;\n', '    uint public _totalSupply = (10 ** 9) * WAD;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    \n', '    function totalSupply() public constant returns (uint) {\n', '        return _totalSupply  - balances[address(0)];\n', '    }\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        balances[from] = balances[from].sub(tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '    function () public payable {\n', '        revert();\n', '    }\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyCLevel returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(ceoAddress, tokens);\n', '    }\n', '    \n', '    // Payout\n', '    function payout(uint amount) public onlyCLevel {\n', '        if (amount > this.balance)\n', '            amount = this.balance;\n', '        ceoAddress.transfer(amount);\n', '    }\n', '}\n', '\n', 'contract ERC721 is ERC20 {\n', '\n', '    function _addressNotNull(address _to) private pure returns(bool) {\n', '        return _to != address(0);\n', '    }\n', '    function _approved(address _to, uint _tokenId) private view returns(bool) {\n', '        return token[_tokenId].approved == _to;\n', '    }\n', '    function _ownsToken(address user, uint _tokenId) public view returns(bool) {\n', '        return user == token[_tokenId].owner;\n', '    }\n', '    function _transferToken(address _from, address _to, uint _tokenId) internal {\n', '        token[_tokenId].owner = _to;\n', '        token[_tokenId].approved = address(0);\n', '        TransferToken(_from, _to, _tokenId);\n', '    }\n', '\n', '    uint[] public tokenList;\n', '    \n', '    struct TOKEN {\n', '        \n', '        address owner;\n', '        address approved;\n', '        \n', '        uint price;\n', '        uint lastPrice;\n', '        \n', '        uint mSpeed;\n', '\n', '        uint mLastPayoutBlock;\n', '    }\n', '\n', '    mapping(uint => TOKEN) public token;\n', '    \n', '    event Birth(uint indexed tokenId, uint startPrice);\n', '    event TokenSold(uint indexed tokenId, uint price, address indexed prevOwner, address indexed winner);\n', '    event TransferToken(address indexed from, address indexed to, uint indexed tokenId);\n', '    event ApprovalToken(address indexed owner, address indexed approved, uint indexed tokenId);\n', '    \n', '    function approveToken(address _to, uint _tokenId) public {\n', '        require(_ownsToken(msg.sender, _tokenId));\n', '        token[_tokenId].approved = _to;\n', '        ApprovalToken(msg.sender, _to, _tokenId);\n', '    }\n', '    function getTotalTokenSupply() public view returns(uint) {\n', '        return tokenList.length;\n', '    }\n', '    function ownerOf(uint _tokenId) public view returns (address owner) {\n', '        owner = token[_tokenId].owner;\n', '    }\n', '    function priceOf(uint _tokenId) public view returns (uint price) {\n', '        price = token[_tokenId].price;\n', '    }\n', '    function takeOwnership(uint _tokenId) public {\n', '        address newOwner = msg.sender;\n', '        address oldOwner = token[_tokenId].owner;\n', '\n', '        require(_addressNotNull(newOwner));\n', '        require(_approved(newOwner, _tokenId));\n', '\n', '        _transferToken(oldOwner, newOwner, _tokenId);\n', '    }\n', '    function transferToken(address _to, uint _tokenId) public {\n', '        require(_ownsToken(msg.sender, _tokenId));\n', '        require(_addressNotNull(_to));\n', '        _transferToken(msg.sender, _to, _tokenId);\n', '    }\n', '    function transferTokenFrom(address _from, address _to, uint _tokenId) public {\n', '        require(_ownsToken(_from, _tokenId));\n', '        require(_approved(_to, _tokenId));\n', '        require(_addressNotNull(_to));\n', '        _transferToken(_from, _to, _tokenId);\n', '    }\n', '    function tokenBalanceOf(address _owner) public view returns(uint result) {\n', '        uint totalTokens = tokenList.length;\n', '        uint tokenIndex;\n', '        uint tokenId;\n', '        result = 0;\n', '        for (tokenIndex = 0; tokenIndex < totalTokens; tokenIndex++) {\n', '            tokenId = tokenList[tokenIndex];\n', '            if (token[tokenId].owner == _owner) {\n', '                result = result.add(1);\n', '            }\n', '        }\n', '        return result;\n', '    }\n', '    function tokensOfOwner(address _owner) public view returns(uint[] ownerTokens) {\n', '        uint tokenCount = tokenBalanceOf(_owner);\n', '        \n', '        if (tokenCount == 0) return new uint[](0);\n', '\n', '        uint[] memory result = new uint[](tokenCount);\n', '        uint totalTokens = tokenList.length;\n', '        uint resultIndex = 0;\n', '        uint tokenIndex;\n', '        uint tokenId;\n', '        \n', '        for (tokenIndex = 0; tokenIndex < totalTokens; tokenIndex++) {\n', '            tokenId = tokenList[tokenIndex];\n', '            if (token[tokenId].owner == _owner) {\n', '                result[resultIndex] = tokenId;\n', '                resultIndex = resultIndex.add(1);\n', '            }\n', '        }\n', '        return result;\n', '    }\n', '    function getTokenIds() public view returns(uint[]) {\n', '        return tokenList;\n', '    }\n', '\n', '    // MIN(A * PRICE, MAX(B * PRICE, 100*PRICE + C)) / 100\n', '    \n', '    uint public priceFactorA = 200;\n', '    uint public priceFactorB = 120;\n', '    uint public priceFactorC = 16 * (10**18);\n', '    \n', '    function changePriceFactor(uint a_, uint b_, uint c_) public onlyCLevel {\n', '        priceFactorA = a_;\n', '        priceFactorB = b_;\n', '        priceFactorC = c_;\n', '    }\n', '    \n', '    function getMaxPrice(uint _tokenId) public view returns (uint) {\n', '        uint price = token[_tokenId].lastPrice.mul(priceFactorB);\n', '        uint priceLow = token[_tokenId].lastPrice.mul(100).add(priceFactorC);\n', '        uint priceHigh = token[_tokenId].lastPrice.mul(priceFactorA);\n', '        if (price < priceLow)\n', '            price = priceLow;\n', '        if (price > priceHigh)\n', '            price = priceHigh;\n', '            \n', '        price = price / (10**18);\n', '        price = price.mul(10**16); // round to x.xx ETH\n', '        \n', '        return price;\n', '    }\n', '    \n', '    function changeTokenPrice(uint newPrice, uint _tokenId) public {\n', '        require(\n', '            (_ownsToken(msg.sender, _tokenId))\n', '            || \n', '            ((_ownsToken(address(0), _tokenId)) && ((msg.sender == ceoAddress) || (msg.sender == cooAddress)))\n', '        );\n', '        \n', '        newPrice = newPrice / (10**16);\n', '        newPrice = newPrice.mul(10**16); // round to x.xx ETH\n', '        \n', '        require(newPrice > 0);\n', '\n', '        require(newPrice <= getMaxPrice(_tokenId));\n', '        token[_tokenId].price = newPrice;\n', '    }\n', '}\n', '\n', 'contract GodPowerCoin is ERC721 {\n', '    \n', '    function GodPowerCoin() public {\n', '        balances[msg.sender] = _totalSupply;\n', '        Transfer(address(0), msg.sender, _totalSupply);\n', '    }\n', '    \n', '    uint public divCutPool = 0;\n', '    uint public divCutMaster = 10; // to master card\n', '    uint public divCutAdmin = 30;\n', '    \n', '    uint public divPoolAmt = 0;\n', '    uint public divMasterAmt = 0;\n', '    \n', '    mapping(address => uint) public dividend;\n', '    \n', '    function withdrawDividend() public {\n', '        require(dividend[msg.sender] > 0);\n', '        msg.sender.transfer(dividend[msg.sender]);\n', '        dividend[msg.sender] = 0;\n', '    }\n', '    \n', '    function setCut(uint admin_, uint pool_, uint master_) public onlyCLevel {\n', '        divCutAdmin = admin_;\n', '        divCutPool = pool_;\n', '        divCutMaster = master_;\n', '    }\n', '    \n', '    function purchase(uint _tokenId, uint _newPrice) public payable {\n', '        address oldOwner = token[_tokenId].owner;\n', '        uint sellingPrice = token[_tokenId].price;\n', '        \n', '        require(oldOwner != msg.sender);\n', '        require(msg.sender != address(0));\n', '\n', "        require(sellingPrice > 0); // can't purchase unreleased token\n", '\n', '        require(msg.value >= sellingPrice);\n', '        uint purchaseExcess = msg.value.sub(sellingPrice);\n', '\n', '        payoutMining(_tokenId); // must happen before owner change!!\n', '\n', '        uint payment = sellingPrice.mul(1000 - divCutPool - divCutAdmin - divCutMaster) / 1000;\n', '        if (divCutPool > 0)\n', '            divPoolAmt = divPoolAmt.add(sellingPrice.mul(divCutPool) / 1000);\n', '        \n', '        divMasterAmt = divMasterAmt.add(sellingPrice.mul(divCutMaster) / 1000);\n', '        \n', '        token[_tokenId].lastPrice = sellingPrice;\n', '\n', '        uint maxPrice = getMaxPrice(_tokenId);\n', '        if ((_newPrice > maxPrice) || (_newPrice == 0))\n', '            _newPrice = maxPrice;\n', '            \n', '        token[_tokenId].price = _newPrice;\n', '\n', '        _transferToken(oldOwner, msg.sender, _tokenId);\n', '        \n', '        if (_tokenId % 10000 > 0) {\n', '            address MASTER = token[(_tokenId / 10000).mul(10000)].owner;\n', '            dividend[MASTER] = dividend[MASTER].add(sellingPrice.mul(divCutMaster) / 1000);\n', '        }\n', '        \n', '        oldOwner.transfer(payment);\n', '\n', '        if (purchaseExcess > 0)\n', '            msg.sender.transfer(purchaseExcess);\n', '\n', '        TokenSold(_tokenId, sellingPrice, oldOwner, msg.sender);\n', '    }\n', '    \n', '    function _createToken(uint tokenId, uint _price, address _owner, uint _mBaseSpeed) internal {\n', '        \n', '        token[tokenId].owner = _owner;\n', '        token[tokenId].price = _price;\n', '        token[tokenId].lastPrice = _price;\n', '        \n', '        token[tokenId].mSpeed = _mBaseSpeed;\n', '\n', '        token[tokenId].mLastPayoutBlock = block.number;\n', '        \n', '        mSumRawSpeed = mSumRawSpeed.add(getMiningRawSpeed(tokenId));\n', '        \n', '        Birth(tokenId, _price);\n', '        tokenList.push(tokenId);\n', '    }\n', '    function createToken(uint tokenId, uint _price, address _owner, uint _mBaseSpeed) public onlyCLevel {\n', '        require(_price != 0);\n', '        if (_owner == address(0))\n', '            _owner = ceoAddress;\n', '\n', '        require(token[tokenId].price == 0);\n', '        _createToken(tokenId, _price, _owner, _mBaseSpeed);\n', '        TransferToken(0, _owner, tokenId);\n', '    }\n', '    function createSimilarTokens(uint[] tokenId, uint _price, address _owner, uint _mBaseSpeed) public onlyCLevel {\n', '        require(_price != 0);\n', '        if (_owner == address(0))\n', '            _owner = ceoAddress;\n', '\n', '        for (uint i = 0; i < tokenId.length; i++) {\n', '            require(token[tokenId[i]].price == 0);\n', '            _createToken(tokenId[i], _price, _owner, _mBaseSpeed);\n', '            TransferToken(0, _owner, tokenId[i]);\n', '        }\n', '    }\n', '    function createMultipleTokens(uint[] tokenId, uint[] _price, address _owner, uint[] _mBaseSpeed) public onlyCLevel {\n', '        if (_owner == address(0))\n', '            _owner = ceoAddress;\n', '\n', '        for (uint i = 0; i < tokenId.length; i++) {\n', '            require(_price[i] != 0);\n', '            require(token[tokenId[i]].price == 0);\n', '            _createToken(tokenId[i], _price[i], _owner, _mBaseSpeed[i]);\n', '            TransferToken(0, _owner, tokenId[i]);\n', '        }\n', '    }\n', '    \n', '    event MiningUpgrade(address indexed sender, uint indexed token, uint newLevelSpeed);\n', '\n', '    // ETH: 6000 blocks per day, 5 ETH per block\n', '    \n', '    uint public mSumRawSpeed = 0;\n', '\n', '    uint public mCoinPerBlock = 50;\n', '    \n', '    uint public mUpgradeCostFactor = mCoinPerBlock * 6000 * WAD;\n', '    uint public mUpgradeSpeedup = 1040; // = * 1.04\n', '    \n', '    function adminSetMining(uint mCoinPerBlock_, uint mUpgradeCostFactor_, uint mUpgradeSpeedup_) public onlyCLevel {\n', '        mCoinPerBlock = mCoinPerBlock_;\n', '        mUpgradeCostFactor = mUpgradeCostFactor_;\n', '        mUpgradeSpeedup = mUpgradeSpeedup_;\n', '    }\n', '    \n', '    function getMiningRawSpeed(uint id) public view returns (uint) {\n', '        return token[id].mSpeed;\n', '    }\n', '    function getMiningRealSpeed(uint id) public view returns (uint) {\n', '        return getMiningRawSpeed(id).mul(mCoinPerBlock) / mSumRawSpeed;\n', '    }\n', '    function getMiningUpgradeCost(uint id) public view returns (uint) {\n', '        return getMiningRawSpeed(id).mul(mUpgradeCostFactor) / mSumRawSpeed;\n', '    }\n', '    function upgradeMining(uint id) public {\n', '        uint cost = getMiningUpgradeCost(id);\n', '        balances[msg.sender] = balances[msg.sender].sub(cost);\n', '        _totalSupply = _totalSupply.sub(cost);\n', '        \n', '        mSumRawSpeed = mSumRawSpeed.sub(getMiningRawSpeed(id));\n', '        token[id].mSpeed = token[id].mSpeed.mul(mUpgradeSpeedup) / 1000;\n', '        mSumRawSpeed = mSumRawSpeed.add(getMiningRawSpeed(id));\n', '        \n', '        MiningUpgrade(msg.sender, id, token[id].mSpeed);\n', '    }\n', '    function upgradeMiningMultipleTimes(uint id, uint n) public {\n', '        for (uint i = 0; i < n; i++) {\n', '            uint cost = getMiningUpgradeCost(id);\n', '            balances[msg.sender] = balances[msg.sender].sub(cost);\n', '            _totalSupply = _totalSupply.sub(cost);\n', '        \n', '            mSumRawSpeed = mSumRawSpeed.sub(getMiningRawSpeed(id));\n', '            token[id].mSpeed = token[id].mSpeed.mul(mUpgradeSpeedup) / 1000;\n', '            mSumRawSpeed = mSumRawSpeed.add(getMiningRawSpeed(id));\n', '        }\n', '        MiningUpgrade(msg.sender, id, token[id].mSpeed);\n', '    }\n', '    function payoutMiningAll(address owner, uint[] list) public {\n', '        uint sum = 0;\n', '        for (uint i = 0; i < list.length; i++) {\n', '            uint id = list[i];\n', '            require(token[id].owner == owner);\n', '            uint blocks = block.number.sub(token[id].mLastPayoutBlock);\n', '            token[id].mLastPayoutBlock = block.number;\n', '            sum = sum.add(getMiningRawSpeed(id).mul(mCoinPerBlock).mul(blocks).mul(WAD) / mSumRawSpeed); // mul WAD !\n', '        }\n', '        balances[owner] = balances[owner].add(sum);\n', '        _totalSupply = _totalSupply.add(sum);\n', '    }\n', '    function payoutMining(uint id) public {\n', '        require(token[id].mLastPayoutBlock > 0);\n', '        uint blocks = block.number.sub(token[id].mLastPayoutBlock);\n', '        token[id].mLastPayoutBlock = block.number;\n', '        address owner = token[id].owner;\n', '        uint coinsMined = getMiningRawSpeed(id).mul(mCoinPerBlock).mul(blocks).mul(WAD) / mSumRawSpeed; // mul WAD !\n', '        \n', '        balances[owner] = balances[owner].add(coinsMined);\n', '        _totalSupply = _totalSupply.add(coinsMined);\n', '    }\n', '}']