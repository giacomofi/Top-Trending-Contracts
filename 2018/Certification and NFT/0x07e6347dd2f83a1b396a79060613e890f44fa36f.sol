['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', ' /**\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', ' contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '  \n', '  function transferFromContract(address _to, uint256 _value) internal returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[address(this)]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[address(this)] = balances[address(this)].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(address(this), _to, _value);\n', '    return true;\n', '  }  \n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) internal {\n', '    require(_value <= balances[msg.sender]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', '    // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '    address burner = msg.sender;\n', '    balances[burner] = balances[burner].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    emit Burn(burner, _value);\n', '    emit Transfer(burner, address(0), _value);\n', '  }\n', '}\n', '\n', '\n', 'contract MintableToken is BasicToken {\n', ' /**\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */ \n', '  event Mint(address indexed to, uint256 amount);\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) internal returns (bool) {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '  \n', '} \n', '\n', 'contract EFToken is MintableToken, BurnableToken, Ownable {\n', '  string public constant name = "EtherFactoryToken"; \n', '  string public constant symbol = "EFT"; \n', '  uint8 public constant decimals = 0;  \n', '  \n', '  uint256 internal presellStart = now;\n', '  \n', '  mapping(uint256 => address) internal InviterAddress; \n', '  mapping(address => uint256) public InviterToID; \n', ' \n', '  uint256 private InviterID = 0;\n', '  \n', '  function sellTokens(uint256 _value) public gameStarted {\n', '  \n', '    require (balances[msg.sender] >= _value && _value > 0);\n', '\tuint256 balance = address(this).balance;\n', '\trequire (balance > 0);\n', '\t\n', '    uint256 total = totalSupply();\n', '\tuint256 sellRate = uint256( balance.div( total ) );\n', '\tuint256 ethValue = sellRate.mul(_value);\n', '\tmsg.sender.transfer(ethValue);\n', '\tburn(_value);\n', '\t\n', '  } \n', '  \n', '  function buyTokens() public gameStarted payable {\n', '    \n', '\tuint256 eth = msg.value;\n', '    require ( msg.value>0 );\n', '\tuint256 tokensAmount = balances[address(this)];\n', '\tuint256 balance = uint256(SafeMath.sub(address(this).balance,msg.value));\n', '\tif (balance < 0.1 ether)\n', '\t\tbalance = 0.1 ether;\n', '    uint256 total = totalSupply();\n', '\tuint256 sellRate = uint256( balance.div( total ) );\n', '\tuint256 eftValue = uint256(eth.div(sellRate));\n', '\trequire ( eftValue <= tokensAmount && eftValue > 0 );\n', '\t\n', '\ttransferFromContract(msg.sender, eftValue);\n', '\n', '\tuint256 fee = uint256(SafeMath.div(msg.value, 10)); \n', '\t// dev fee 10%\n', '\towner.transfer(fee); \t\n', '  } \n', '\n', '  function inviterReg() public {\n', '\trequire (msg.sender != address(0) && InviterToID[msg.sender] == 0);\n', '\t\n', '\tInviterID++;\n', '\tInviterAddress[InviterID] = msg.sender;\n', '\tInviterToID[msg.sender] = InviterID;\n', '  }\n', '  \n', '  function tokensRate() public view returns (uint256 rate, uint256 yourEFT, uint256 totalEFT, uint256 ethBalance, uint256 eftBalance) {\n', '    yourEFT = balanceOf (msg.sender);\n', '    totalEFT = totalSupply();\n', '\tethBalance = address(this).balance;\n', '\trate = uint256(ethBalance.div(totalEFT));\n', '\teftBalance = balances[address(this)];\n', '  }\n', '  \n', '  //views\n', '  function presellTimer() public view returns (uint256 presellLeft) {\n', '\tpresellLeft = uint256(SafeMath.div(now.sub(presellStart), 60));\n', '  }\n', '  \n', '  //modifiers\n', '  modifier gameStarted() {\n', '    require(now - presellStart >= 604800); // 604800 sec = one  week\n', '    _;\n', '  }\n', '    \n', '}\n', '\n', 'contract EtherFactory is EFToken {\n', '\n', '  //FactoryID -> workers qualification (depends on factory level) -> workers amount\n', '  mapping(uint256 => mapping(uint8 => uint256)) internal FactoryPersonal; \n', '  \n', '  //FactoryID -> owner address\n', '  mapping(uint256 => address) internal FactoryOwner; \n', '  \n', '  //FactoryID -> start work date (timestamp). For profit calculate;\n', '  mapping(uint256 => uint256) internal FactoryWorkStart; \n', '  \n', '  //FactoryID -> factory level;\n', '  mapping(uint256 => uint8) internal FactoryLevel; \n', '  \n', '   //FactoryID -> factory eth price;\n', '  mapping(uint256 => uint256) internal FactoryPrice; \n', '\n', '   //FactoryID -> factory name;\n', '  mapping(uint256 => string) internal FactoryName; \n', '  \n', '  //Worker -> qualification\n', '  mapping(address => uint8) internal WorkerQualification; \n', '  \n', '  //Worker -> FactoryID\n', '  mapping(address => uint256) internal WorkerFactory; \n', '  \n', '  //Worker -> start work date (timestamp). For profit calculate;\n', '  mapping(address => uint256) internal WorkerWorkStart;   \n', '  \n', '  uint256 FactoryID = 0;\n', '  \n', '  //Factories core\n', '  \n', '  function setFactoryName(uint256 _FactoryID, string _Name) public {\n', '\trequire (FactoryOwner[_FactoryID] == msg.sender);\t\n', '\trequire(bytes(_Name).length <= 50);\n', '\tFactoryName[_FactoryID] = _Name; \n', '  }\n', '  \n', '  function getFactoryProfit(uint256 _FactoryID, address _FactoryOwner) public gameStarted {\n', '\trequire (FactoryOwner[_FactoryID] == _FactoryOwner);\n', '\t\n', '\t//Factory profit equal to the earnings of all workers.\n', '\tuint256 profitMinutes = uint256(SafeMath.div(SafeMath.sub(now, FactoryWorkStart[_FactoryID]), 60));\n', '\tif (profitMinutes > 0) {\n', '\t\tuint256 profit = 0;\n', '\t\t\n', '\t\tfor (uint8 level=1; level<=FactoryLevel[_FactoryID]; level++) {\n', '\t\t   profit += SafeMath.mul(SafeMath.mul(uint256(level),profitMinutes), FactoryPersonal[_FactoryID][level]);\n', '\t\t}\n', '\t\t\n', '\t\tif (profit > 0) {\n', '\t\t\tmint(_FactoryOwner,profit);\n', '\t\t\tFactoryWorkStart[_FactoryID] = now;\n', '\t\t}\n', '\t}\n', '\t\n', '  }\n', '\n', '  function buildFactory(uint8 _level, uint256 _inviterID) public payable {\n', '  \n', '    require (_level>0 && _level<=100);\n', '\t\n', '    uint256 buildCost = uint256(_level).mul( getFactoryPrice() );\n', '\trequire (msg.value == buildCost);\n', '\t\n', '\tFactoryID++;\n', '\tFactoryOwner[FactoryID] = msg.sender;\n', '\tFactoryLevel[FactoryID] = _level;\n', '\tFactoryPrice[FactoryID] = SafeMath.mul(0.15 ether, _level);\n', '\t\n', '\t//for EFT-ETH rate balance\n', '\tmint(address(this), SafeMath.mul(1000000, _level));\n', '\t\n', '\t\n', '\taddress Inviter = InviterAddress[_inviterID];\n', '\n', '\tuint256 fee = uint256(SafeMath.div(msg.value, 20)); \n', '\t\n', '\tif ( Inviter != address(0)) {\n', '\t\t//bounty for invite -> 5% from payment\n', '\t\tInviter.transfer(fee); \n', '\t} else {\n', '\t    //no inviter, dev fee - 10%\n', '\t\tfee = fee.mul(2);\n', '\t}\n', '\t\n', '\t// dev fee\n', '\towner.transfer(fee); \t\n', '  }  \n', '  \n', '  function upgradeFactory(uint256 _FactoryID) public payable {\n', '  \n', '    require (FactoryOwner[_FactoryID] == msg.sender);\n', '\trequire (FactoryLevel[_FactoryID] < 100);\n', '\t\n', '\trequire (msg.value == getFactoryPrice() );\n', '\n', '\tFactoryLevel[_FactoryID]++ ;\n', '\tFactoryPrice[FactoryID] += 0.15 ether;\n', '\t\n', '\t//for EFT-ETH rate balance\n', '\tmint(address(this), 1000000);\n', '\t\n', '\tuint256 fee = uint256(SafeMath.div(msg.value, 10)); \n', '\t// dev fee 10%\n', '\towner.transfer(fee); \n', '\t\n', '  }    \n', '  \n', '  function buyExistFactory(uint256 _FactoryID) public payable {\n', '  \n', '    address factoryOwner = FactoryOwner[_FactoryID];\n', '\t\n', '    require ( factoryOwner != address(0) && factoryOwner != msg.sender && msg.sender != address(0) );\n', '\n', '    uint256 factoryPrice = FactoryPrice[_FactoryID];\n', '    require(msg.value >= factoryPrice);\n', '\t\n', '\t//new owner\n', '\tFactoryOwner[_FactoryID] = msg.sender;\n', '\t\n', '\t//90% to previous factory owner\n', '\tuint256 Payment90percent = uint256(SafeMath.div(SafeMath.mul(factoryPrice, 9), 10)); \n', '\n', '\t//5% dev fee\n', '\tuint256 fee = uint256(SafeMath.div(SafeMath.mul(factoryPrice, 5), 100)); \n', '\t\n', '\t//new price +50%\n', '\tFactoryPrice[_FactoryID] = uint256(SafeMath.div(SafeMath.mul(factoryPrice, 3), 2)); \n', '\n', '\t\n', '    factoryOwner.transfer(Payment90percent); \n', '\towner.transfer(fee); \n', '\t\n', '\t//return excess pay\n', '    if (msg.value > factoryPrice) { \n', '\t\tmsg.sender.transfer(msg.value - factoryPrice);\n', '\t}\n', '  }   \n', '  \n', '  function increaseMarketValue(uint256 _FactoryID, uint256 _tokens) public gameStarted {\n', '  \n', '\tuint256 eftTOethRATE = 200000000000;\n', '\t\n', '\trequire (FactoryOwner[_FactoryID] == msg.sender);\n', '\trequire (balances[msg.sender] >= _tokens && _tokens>0);\n', '\t\n', '\tFactoryPrice[_FactoryID] = FactoryPrice[_FactoryID] + _tokens*eftTOethRATE;\n', '\tburn(_tokens);\n', '  }\n', '  \n', '  \n', '  \n', '  //workers core\n', '  \n', '  function findJob(uint256 _FactoryID) public gameStarted {\n', '    \n', '    require (WorkerFactory[msg.sender] != _FactoryID);\n', '  \n', '\tif (WorkerQualification[msg.sender] == 0) {\n', '\t\tWorkerQualification[msg.sender] = 1;\n', '\t}\n', '\n', '\tuint8 qualification = WorkerQualification[msg.sender];\n', '\t\t\n', '\trequire (FactoryLevel[_FactoryID] >= qualification);\n', '\t\n', '\t//100 is limit for each worker qualificationon on the factory\n', '\trequire (FactoryPersonal[_FactoryID][qualification] < 100);\n', '\t\n', '\t//reset factory and worker profit timer\n', '\tif (WorkerFactory[msg.sender]>0) {\n', '\t\tgetFactoryProfit(_FactoryID, FactoryOwner[_FactoryID]);\n', '\t\tgetWorkerProfit();\n', '\t} else {\n', '\t\tWorkerWorkStart[msg.sender] = now;\n', '\t}\n', '\t\n', '\t//previous factory lost worker\n', '\tif (WorkerFactory[msg.sender] > 0 ) {\n', '\t   FactoryPersonal[WorkerFactory[msg.sender]][qualification]--;\n', '\t}\n', '\t\n', '\tWorkerFactory[msg.sender] = _FactoryID;\n', '\t\n', '\tFactoryPersonal[_FactoryID][qualification]++;\n', '\t\n', '\tif (FactoryWorkStart[_FactoryID] ==0)\n', '\t\tFactoryWorkStart[_FactoryID] = now;\n', '\t\n', '  } \n', '  \n', '  function getWorkerProfit() public gameStarted {\n', '\trequire (WorkerFactory[msg.sender] > 0);\n', '\t\n', '\t//Worker with qualification "ONE" earn 1 token per minute, "TWO" earn 2 tokens, etc...\n', '\tuint256 profitMinutes = uint256(SafeMath.div(SafeMath.sub(now, WorkerWorkStart[msg.sender]), 60));\n', '\tif (profitMinutes > 0) {\n', '\t\tuint8 qualification = WorkerQualification[msg.sender];\n', '\t\t\n', '\t\tuint256 profitEFT = SafeMath.mul(uint256(qualification),profitMinutes);\n', '\t\t\n', '\t\trequire (profitEFT > 0);\n', '\t\t\n', '\t\tmint(msg.sender,profitEFT);\n', '\t\t\n', '\t\tWorkerWorkStart[msg.sender] = now;\n', '\t}\n', '\t\n', '  }  \n', '  \n', '  function upgradeQualificationByTokens() public gameStarted {\n', '\t\n', '\trequire (WorkerQualification[msg.sender]<100);\n', '\t\n', '    uint256 upgradeCost = 10000;\n', '\trequire (balances[msg.sender] >= upgradeCost);\n', '\t\n', '\tif (WorkerFactory[msg.sender] > 0)\n', '\t\tgetWorkerProfit();\n', '    \n', '\tuint8 oldQualification = WorkerQualification[msg.sender];\n', '\t\n', '\tuint256 WorkerFactoryID = WorkerFactory[msg.sender];\n', '\n', '\tif (WorkerQualification[msg.sender]==0) \n', '\t\tWorkerQualification[msg.sender]=2;\n', '\telse \n', '\t\tWorkerQualification[msg.sender]++;\n', '\t\n', '\tif (WorkerFactoryID > 0) {\n', '\t\tgetFactoryProfit(WorkerFactoryID, FactoryOwner[WorkerFactoryID]);\n', '\t\tFactoryPersonal[WorkerFactoryID][oldQualification]--;\n', '\t\n', '\t\tif (FactoryLevel[WorkerFactoryID] >= oldQualification+1) {\n', '\t\t\tFactoryPersonal[WorkerFactoryID][oldQualification+1]++;\n', '\t\t} else {\n', '\t\t\t//will unemployed\n', '\t\t\tWorkerFactory[msg.sender] = 0;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// burn tokens\n', '\tburn(upgradeCost);\n', '\t\n', '  }   \n', '  \n', '  function upgradeQualificationByEther(uint256 _inviterID) public payable {\n', '\t\n', '\trequire (WorkerQualification[msg.sender]<100);\n', '\t\n', '\t//0.001 ether or 0.00075 presell\n', '\trequire ( msg.value == SafeMath.div(getFactoryPrice(),100) );\n', '\t\n', '\tuint256 fee = uint256(SafeMath.div(msg.value, 20)); //5%\n', '\t\n', '\taddress Inviter = InviterAddress[_inviterID];\n', '\n', '\tif ( Inviter != address(0)) {\n', '\t\t//bounty for invite -> 5% from payment\n', '\t\tInviter.transfer(fee); \n', '\t} else {\n', '\t    //no inviter, dev fee - 10%\n', '\t\tfee = fee.mul(2);\n', '\t}\n', '\t\n', '\t// dev fee\n', '\towner.transfer(fee); \n', '\t\n', '\tif (WorkerFactory[msg.sender] > 0)\n', '\t\tgetWorkerProfit();\n', '    \n', '\tuint8 oldQualification = WorkerQualification[msg.sender];\n', '\t\n', '\tuint256 WorkerFactoryID = WorkerFactory[msg.sender];\n', '\t\n', '\tif (WorkerQualification[msg.sender]==0) \n', '\t\tWorkerQualification[msg.sender]=2;\n', '\telse \n', '\t\tWorkerQualification[msg.sender]++;\n', '\t\n', '\t\n', '\t\n', '\tif (WorkerFactoryID > 0) {\n', '\t\tgetFactoryProfit(WorkerFactoryID, FactoryOwner[WorkerFactoryID]);\n', '\t\tFactoryPersonal[WorkerFactoryID][oldQualification]--;\n', '\t\n', '\t\tif (FactoryLevel[WorkerFactoryID] >= oldQualification+1) {\n', '\t\t\tFactoryPersonal[WorkerFactoryID][oldQualification+1]++;\n', '\t\t} else {\n', '\t\t\t//will unemployed\n', '\t\t\tWorkerFactory[msg.sender] = 0;\n', '\t\t}\n', '\t}\n', '\t\n', '\t\n', '  }  \n', '  \n', '  function getFactoryPrice() internal view returns (uint256 price) {\n', '\tif (now - presellStart >= 604800)\n', '\t\tprice = 0.1 ether;\n', '\telse \n', '\t\tprice = 0.075 ether;\n', '  }\n', '  \n', '  \n', '  //views\n', '\n', '  function allFactories() public constant returns(address[] owner, uint256[] profitMinutes, uint256[] price, uint8[] level) {    \n', '\n', '    //FactoryID is count of factories\n', '\tprice = new uint256[](FactoryID);\n', '\tprofitMinutes = new uint256[](FactoryID);\n', '\towner = new address[](FactoryID);\n', '\tlevel = new uint8[](FactoryID);\n', '\n', '\tfor (uint256 index=1; index<=FactoryID; index++) {\n', '\t\tprice[index-1] = FactoryPrice[index];\n', '\t\tprofitMinutes[index-1] = uint256(SafeMath.div(now - FactoryWorkStart[index],60));\n', '\t\towner[index-1] = FactoryOwner[index];\n', '\t\tlevel[index-1] = FactoryLevel[index];\n', '\t}\n', '\t\n', '  }\n', '  \n', '  function aboutFactoryWorkers(uint256 _FactoryID)  public constant returns(uint256[] workers, string factoryName) {    \n', '\tuint8 factoryLevel = FactoryLevel[_FactoryID];\n', '\tfactoryName = FactoryName[_FactoryID];\n', '\t\n', '\tworkers = new uint256[](factoryLevel+1);\n', '\tfor (uint8 qualification=1; qualification<=factoryLevel; qualification++)\n', '\t\tworkers[qualification] = FactoryPersonal[_FactoryID][qualification];\n', '\t\n', '  }  \n', '  \n', '  function aboutWorker(address _worker) public constant returns(uint8 qualification, uint256 factoryId, uint256 profitMinutes, uint8 factoryLevel) {    \n', '\tqualification = WorkerQualification[_worker];\t\n', '\tif (qualification==0)\n', '\t\tqualification=1;\n', '\tfactoryId = WorkerFactory[_worker];\t\n', '\tfactoryLevel = FactoryLevel[factoryId];\n', '\tprofitMinutes = uint256(SafeMath.div(now - WorkerWorkStart[_worker],60));\n', '  }\n', '  \n', '  function contractBalance() public constant returns(uint256 ethBalance) {    \n', '\tethBalance = address(this).balance;\n', '  }  \n', '  \n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', ' /**\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', ' contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '  \n', '  function transferFromContract(address _to, uint256 _value) internal returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[address(this)]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[address(this)] = balances[address(this)].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(address(this), _to, _value);\n', '    return true;\n', '  }  \n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) internal {\n', '    require(_value <= balances[msg.sender]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', "    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '\n', '    address burner = msg.sender;\n', '    balances[burner] = balances[burner].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    emit Burn(burner, _value);\n', '    emit Transfer(burner, address(0), _value);\n', '  }\n', '}\n', '\n', '\n', 'contract MintableToken is BasicToken {\n', ' /**\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */ \n', '  event Mint(address indexed to, uint256 amount);\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) internal returns (bool) {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '  \n', '} \n', '\n', 'contract EFToken is MintableToken, BurnableToken, Ownable {\n', '  string public constant name = "EtherFactoryToken"; \n', '  string public constant symbol = "EFT"; \n', '  uint8 public constant decimals = 0;  \n', '  \n', '  uint256 internal presellStart = now;\n', '  \n', '  mapping(uint256 => address) internal InviterAddress; \n', '  mapping(address => uint256) public InviterToID; \n', ' \n', '  uint256 private InviterID = 0;\n', '  \n', '  function sellTokens(uint256 _value) public gameStarted {\n', '  \n', '    require (balances[msg.sender] >= _value && _value > 0);\n', '\tuint256 balance = address(this).balance;\n', '\trequire (balance > 0);\n', '\t\n', '    uint256 total = totalSupply();\n', '\tuint256 sellRate = uint256( balance.div( total ) );\n', '\tuint256 ethValue = sellRate.mul(_value);\n', '\tmsg.sender.transfer(ethValue);\n', '\tburn(_value);\n', '\t\n', '  } \n', '  \n', '  function buyTokens() public gameStarted payable {\n', '    \n', '\tuint256 eth = msg.value;\n', '    require ( msg.value>0 );\n', '\tuint256 tokensAmount = balances[address(this)];\n', '\tuint256 balance = uint256(SafeMath.sub(address(this).balance,msg.value));\n', '\tif (balance < 0.1 ether)\n', '\t\tbalance = 0.1 ether;\n', '    uint256 total = totalSupply();\n', '\tuint256 sellRate = uint256( balance.div( total ) );\n', '\tuint256 eftValue = uint256(eth.div(sellRate));\n', '\trequire ( eftValue <= tokensAmount && eftValue > 0 );\n', '\t\n', '\ttransferFromContract(msg.sender, eftValue);\n', '\n', '\tuint256 fee = uint256(SafeMath.div(msg.value, 10)); \n', '\t// dev fee 10%\n', '\towner.transfer(fee); \t\n', '  } \n', '\n', '  function inviterReg() public {\n', '\trequire (msg.sender != address(0) && InviterToID[msg.sender] == 0);\n', '\t\n', '\tInviterID++;\n', '\tInviterAddress[InviterID] = msg.sender;\n', '\tInviterToID[msg.sender] = InviterID;\n', '  }\n', '  \n', '  function tokensRate() public view returns (uint256 rate, uint256 yourEFT, uint256 totalEFT, uint256 ethBalance, uint256 eftBalance) {\n', '    yourEFT = balanceOf (msg.sender);\n', '    totalEFT = totalSupply();\n', '\tethBalance = address(this).balance;\n', '\trate = uint256(ethBalance.div(totalEFT));\n', '\teftBalance = balances[address(this)];\n', '  }\n', '  \n', '  //views\n', '  function presellTimer() public view returns (uint256 presellLeft) {\n', '\tpresellLeft = uint256(SafeMath.div(now.sub(presellStart), 60));\n', '  }\n', '  \n', '  //modifiers\n', '  modifier gameStarted() {\n', '    require(now - presellStart >= 604800); // 604800 sec = one  week\n', '    _;\n', '  }\n', '    \n', '}\n', '\n', 'contract EtherFactory is EFToken {\n', '\n', '  //FactoryID -> workers qualification (depends on factory level) -> workers amount\n', '  mapping(uint256 => mapping(uint8 => uint256)) internal FactoryPersonal; \n', '  \n', '  //FactoryID -> owner address\n', '  mapping(uint256 => address) internal FactoryOwner; \n', '  \n', '  //FactoryID -> start work date (timestamp). For profit calculate;\n', '  mapping(uint256 => uint256) internal FactoryWorkStart; \n', '  \n', '  //FactoryID -> factory level;\n', '  mapping(uint256 => uint8) internal FactoryLevel; \n', '  \n', '   //FactoryID -> factory eth price;\n', '  mapping(uint256 => uint256) internal FactoryPrice; \n', '\n', '   //FactoryID -> factory name;\n', '  mapping(uint256 => string) internal FactoryName; \n', '  \n', '  //Worker -> qualification\n', '  mapping(address => uint8) internal WorkerQualification; \n', '  \n', '  //Worker -> FactoryID\n', '  mapping(address => uint256) internal WorkerFactory; \n', '  \n', '  //Worker -> start work date (timestamp). For profit calculate;\n', '  mapping(address => uint256) internal WorkerWorkStart;   \n', '  \n', '  uint256 FactoryID = 0;\n', '  \n', '  //Factories core\n', '  \n', '  function setFactoryName(uint256 _FactoryID, string _Name) public {\n', '\trequire (FactoryOwner[_FactoryID] == msg.sender);\t\n', '\trequire(bytes(_Name).length <= 50);\n', '\tFactoryName[_FactoryID] = _Name; \n', '  }\n', '  \n', '  function getFactoryProfit(uint256 _FactoryID, address _FactoryOwner) public gameStarted {\n', '\trequire (FactoryOwner[_FactoryID] == _FactoryOwner);\n', '\t\n', '\t//Factory profit equal to the earnings of all workers.\n', '\tuint256 profitMinutes = uint256(SafeMath.div(SafeMath.sub(now, FactoryWorkStart[_FactoryID]), 60));\n', '\tif (profitMinutes > 0) {\n', '\t\tuint256 profit = 0;\n', '\t\t\n', '\t\tfor (uint8 level=1; level<=FactoryLevel[_FactoryID]; level++) {\n', '\t\t   profit += SafeMath.mul(SafeMath.mul(uint256(level),profitMinutes), FactoryPersonal[_FactoryID][level]);\n', '\t\t}\n', '\t\t\n', '\t\tif (profit > 0) {\n', '\t\t\tmint(_FactoryOwner,profit);\n', '\t\t\tFactoryWorkStart[_FactoryID] = now;\n', '\t\t}\n', '\t}\n', '\t\n', '  }\n', '\n', '  function buildFactory(uint8 _level, uint256 _inviterID) public payable {\n', '  \n', '    require (_level>0 && _level<=100);\n', '\t\n', '    uint256 buildCost = uint256(_level).mul( getFactoryPrice() );\n', '\trequire (msg.value == buildCost);\n', '\t\n', '\tFactoryID++;\n', '\tFactoryOwner[FactoryID] = msg.sender;\n', '\tFactoryLevel[FactoryID] = _level;\n', '\tFactoryPrice[FactoryID] = SafeMath.mul(0.15 ether, _level);\n', '\t\n', '\t//for EFT-ETH rate balance\n', '\tmint(address(this), SafeMath.mul(1000000, _level));\n', '\t\n', '\t\n', '\taddress Inviter = InviterAddress[_inviterID];\n', '\n', '\tuint256 fee = uint256(SafeMath.div(msg.value, 20)); \n', '\t\n', '\tif ( Inviter != address(0)) {\n', '\t\t//bounty for invite -> 5% from payment\n', '\t\tInviter.transfer(fee); \n', '\t} else {\n', '\t    //no inviter, dev fee - 10%\n', '\t\tfee = fee.mul(2);\n', '\t}\n', '\t\n', '\t// dev fee\n', '\towner.transfer(fee); \t\n', '  }  \n', '  \n', '  function upgradeFactory(uint256 _FactoryID) public payable {\n', '  \n', '    require (FactoryOwner[_FactoryID] == msg.sender);\n', '\trequire (FactoryLevel[_FactoryID] < 100);\n', '\t\n', '\trequire (msg.value == getFactoryPrice() );\n', '\n', '\tFactoryLevel[_FactoryID]++ ;\n', '\tFactoryPrice[FactoryID] += 0.15 ether;\n', '\t\n', '\t//for EFT-ETH rate balance\n', '\tmint(address(this), 1000000);\n', '\t\n', '\tuint256 fee = uint256(SafeMath.div(msg.value, 10)); \n', '\t// dev fee 10%\n', '\towner.transfer(fee); \n', '\t\n', '  }    \n', '  \n', '  function buyExistFactory(uint256 _FactoryID) public payable {\n', '  \n', '    address factoryOwner = FactoryOwner[_FactoryID];\n', '\t\n', '    require ( factoryOwner != address(0) && factoryOwner != msg.sender && msg.sender != address(0) );\n', '\n', '    uint256 factoryPrice = FactoryPrice[_FactoryID];\n', '    require(msg.value >= factoryPrice);\n', '\t\n', '\t//new owner\n', '\tFactoryOwner[_FactoryID] = msg.sender;\n', '\t\n', '\t//90% to previous factory owner\n', '\tuint256 Payment90percent = uint256(SafeMath.div(SafeMath.mul(factoryPrice, 9), 10)); \n', '\n', '\t//5% dev fee\n', '\tuint256 fee = uint256(SafeMath.div(SafeMath.mul(factoryPrice, 5), 100)); \n', '\t\n', '\t//new price +50%\n', '\tFactoryPrice[_FactoryID] = uint256(SafeMath.div(SafeMath.mul(factoryPrice, 3), 2)); \n', '\n', '\t\n', '    factoryOwner.transfer(Payment90percent); \n', '\towner.transfer(fee); \n', '\t\n', '\t//return excess pay\n', '    if (msg.value > factoryPrice) { \n', '\t\tmsg.sender.transfer(msg.value - factoryPrice);\n', '\t}\n', '  }   \n', '  \n', '  function increaseMarketValue(uint256 _FactoryID, uint256 _tokens) public gameStarted {\n', '  \n', '\tuint256 eftTOethRATE = 200000000000;\n', '\t\n', '\trequire (FactoryOwner[_FactoryID] == msg.sender);\n', '\trequire (balances[msg.sender] >= _tokens && _tokens>0);\n', '\t\n', '\tFactoryPrice[_FactoryID] = FactoryPrice[_FactoryID] + _tokens*eftTOethRATE;\n', '\tburn(_tokens);\n', '  }\n', '  \n', '  \n', '  \n', '  //workers core\n', '  \n', '  function findJob(uint256 _FactoryID) public gameStarted {\n', '    \n', '    require (WorkerFactory[msg.sender] != _FactoryID);\n', '  \n', '\tif (WorkerQualification[msg.sender] == 0) {\n', '\t\tWorkerQualification[msg.sender] = 1;\n', '\t}\n', '\n', '\tuint8 qualification = WorkerQualification[msg.sender];\n', '\t\t\n', '\trequire (FactoryLevel[_FactoryID] >= qualification);\n', '\t\n', '\t//100 is limit for each worker qualificationon on the factory\n', '\trequire (FactoryPersonal[_FactoryID][qualification] < 100);\n', '\t\n', '\t//reset factory and worker profit timer\n', '\tif (WorkerFactory[msg.sender]>0) {\n', '\t\tgetFactoryProfit(_FactoryID, FactoryOwner[_FactoryID]);\n', '\t\tgetWorkerProfit();\n', '\t} else {\n', '\t\tWorkerWorkStart[msg.sender] = now;\n', '\t}\n', '\t\n', '\t//previous factory lost worker\n', '\tif (WorkerFactory[msg.sender] > 0 ) {\n', '\t   FactoryPersonal[WorkerFactory[msg.sender]][qualification]--;\n', '\t}\n', '\t\n', '\tWorkerFactory[msg.sender] = _FactoryID;\n', '\t\n', '\tFactoryPersonal[_FactoryID][qualification]++;\n', '\t\n', '\tif (FactoryWorkStart[_FactoryID] ==0)\n', '\t\tFactoryWorkStart[_FactoryID] = now;\n', '\t\n', '  } \n', '  \n', '  function getWorkerProfit() public gameStarted {\n', '\trequire (WorkerFactory[msg.sender] > 0);\n', '\t\n', '\t//Worker with qualification "ONE" earn 1 token per minute, "TWO" earn 2 tokens, etc...\n', '\tuint256 profitMinutes = uint256(SafeMath.div(SafeMath.sub(now, WorkerWorkStart[msg.sender]), 60));\n', '\tif (profitMinutes > 0) {\n', '\t\tuint8 qualification = WorkerQualification[msg.sender];\n', '\t\t\n', '\t\tuint256 profitEFT = SafeMath.mul(uint256(qualification),profitMinutes);\n', '\t\t\n', '\t\trequire (profitEFT > 0);\n', '\t\t\n', '\t\tmint(msg.sender,profitEFT);\n', '\t\t\n', '\t\tWorkerWorkStart[msg.sender] = now;\n', '\t}\n', '\t\n', '  }  \n', '  \n', '  function upgradeQualificationByTokens() public gameStarted {\n', '\t\n', '\trequire (WorkerQualification[msg.sender]<100);\n', '\t\n', '    uint256 upgradeCost = 10000;\n', '\trequire (balances[msg.sender] >= upgradeCost);\n', '\t\n', '\tif (WorkerFactory[msg.sender] > 0)\n', '\t\tgetWorkerProfit();\n', '    \n', '\tuint8 oldQualification = WorkerQualification[msg.sender];\n', '\t\n', '\tuint256 WorkerFactoryID = WorkerFactory[msg.sender];\n', '\n', '\tif (WorkerQualification[msg.sender]==0) \n', '\t\tWorkerQualification[msg.sender]=2;\n', '\telse \n', '\t\tWorkerQualification[msg.sender]++;\n', '\t\n', '\tif (WorkerFactoryID > 0) {\n', '\t\tgetFactoryProfit(WorkerFactoryID, FactoryOwner[WorkerFactoryID]);\n', '\t\tFactoryPersonal[WorkerFactoryID][oldQualification]--;\n', '\t\n', '\t\tif (FactoryLevel[WorkerFactoryID] >= oldQualification+1) {\n', '\t\t\tFactoryPersonal[WorkerFactoryID][oldQualification+1]++;\n', '\t\t} else {\n', '\t\t\t//will unemployed\n', '\t\t\tWorkerFactory[msg.sender] = 0;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// burn tokens\n', '\tburn(upgradeCost);\n', '\t\n', '  }   \n', '  \n', '  function upgradeQualificationByEther(uint256 _inviterID) public payable {\n', '\t\n', '\trequire (WorkerQualification[msg.sender]<100);\n', '\t\n', '\t//0.001 ether or 0.00075 presell\n', '\trequire ( msg.value == SafeMath.div(getFactoryPrice(),100) );\n', '\t\n', '\tuint256 fee = uint256(SafeMath.div(msg.value, 20)); //5%\n', '\t\n', '\taddress Inviter = InviterAddress[_inviterID];\n', '\n', '\tif ( Inviter != address(0)) {\n', '\t\t//bounty for invite -> 5% from payment\n', '\t\tInviter.transfer(fee); \n', '\t} else {\n', '\t    //no inviter, dev fee - 10%\n', '\t\tfee = fee.mul(2);\n', '\t}\n', '\t\n', '\t// dev fee\n', '\towner.transfer(fee); \n', '\t\n', '\tif (WorkerFactory[msg.sender] > 0)\n', '\t\tgetWorkerProfit();\n', '    \n', '\tuint8 oldQualification = WorkerQualification[msg.sender];\n', '\t\n', '\tuint256 WorkerFactoryID = WorkerFactory[msg.sender];\n', '\t\n', '\tif (WorkerQualification[msg.sender]==0) \n', '\t\tWorkerQualification[msg.sender]=2;\n', '\telse \n', '\t\tWorkerQualification[msg.sender]++;\n', '\t\n', '\t\n', '\t\n', '\tif (WorkerFactoryID > 0) {\n', '\t\tgetFactoryProfit(WorkerFactoryID, FactoryOwner[WorkerFactoryID]);\n', '\t\tFactoryPersonal[WorkerFactoryID][oldQualification]--;\n', '\t\n', '\t\tif (FactoryLevel[WorkerFactoryID] >= oldQualification+1) {\n', '\t\t\tFactoryPersonal[WorkerFactoryID][oldQualification+1]++;\n', '\t\t} else {\n', '\t\t\t//will unemployed\n', '\t\t\tWorkerFactory[msg.sender] = 0;\n', '\t\t}\n', '\t}\n', '\t\n', '\t\n', '  }  \n', '  \n', '  function getFactoryPrice() internal view returns (uint256 price) {\n', '\tif (now - presellStart >= 604800)\n', '\t\tprice = 0.1 ether;\n', '\telse \n', '\t\tprice = 0.075 ether;\n', '  }\n', '  \n', '  \n', '  //views\n', '\n', '  function allFactories() public constant returns(address[] owner, uint256[] profitMinutes, uint256[] price, uint8[] level) {    \n', '\n', '    //FactoryID is count of factories\n', '\tprice = new uint256[](FactoryID);\n', '\tprofitMinutes = new uint256[](FactoryID);\n', '\towner = new address[](FactoryID);\n', '\tlevel = new uint8[](FactoryID);\n', '\n', '\tfor (uint256 index=1; index<=FactoryID; index++) {\n', '\t\tprice[index-1] = FactoryPrice[index];\n', '\t\tprofitMinutes[index-1] = uint256(SafeMath.div(now - FactoryWorkStart[index],60));\n', '\t\towner[index-1] = FactoryOwner[index];\n', '\t\tlevel[index-1] = FactoryLevel[index];\n', '\t}\n', '\t\n', '  }\n', '  \n', '  function aboutFactoryWorkers(uint256 _FactoryID)  public constant returns(uint256[] workers, string factoryName) {    \n', '\tuint8 factoryLevel = FactoryLevel[_FactoryID];\n', '\tfactoryName = FactoryName[_FactoryID];\n', '\t\n', '\tworkers = new uint256[](factoryLevel+1);\n', '\tfor (uint8 qualification=1; qualification<=factoryLevel; qualification++)\n', '\t\tworkers[qualification] = FactoryPersonal[_FactoryID][qualification];\n', '\t\n', '  }  \n', '  \n', '  function aboutWorker(address _worker) public constant returns(uint8 qualification, uint256 factoryId, uint256 profitMinutes, uint8 factoryLevel) {    \n', '\tqualification = WorkerQualification[_worker];\t\n', '\tif (qualification==0)\n', '\t\tqualification=1;\n', '\tfactoryId = WorkerFactory[_worker];\t\n', '\tfactoryLevel = FactoryLevel[factoryId];\n', '\tprofitMinutes = uint256(SafeMath.div(now - WorkerWorkStart[_worker],60));\n', '  }\n', '  \n', '  function contractBalance() public constant returns(uint256 ethBalance) {    \n', '\tethBalance = address(this).balance;\n', '  }  \n', '  \n', '\n', '}']
