['pragma solidity ^0.4.24;\n', '\n', '//----------------------------------------------------------------------------\n', '//Welcome to Dissidia of Contract PreSale\n', '//欢迎来到契约纷争预售\n', '//----------------------------------------------------------------------------\n', '\n', 'contract SafeMath{\n', '    function safeAdd(uint a, uint b) public pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint a, uint b) public pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) public pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint a, uint b) public pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract Administration is SafeMath{\n', '    event Pause();\n', '    event Unpause();\n', '    event PriceRaise();\n', '    event PriceStop();\n', '\n', '    address public CEOAddress;\n', '    address public CTOAddress;\n', '    \n', '    uint oneEth = 1 ether;\n', '    uint public feeUnit = 1 finney;\n', '    uint public preSaleDurance = 45 days;\n', '\n', '    bool public paused = false;\n', '    bool public pricePause = true;\n', '    \n', '    uint public startTime;\n', '    uint public endTime;\n', '    \n', '    uint[3] raiseIndex = [\n', '        2,\n', '        3,\n', '        3\n', '    ];\n', '    \n', '    uint[3] rewardPercent = [\n', '        10,\n', '        15,\n', '        18\n', '    ];\n', '\n', '    modifier onlyCEO() {\n', '        require(msg.sender == CEOAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == CEOAddress || msg.sender == CTOAddress);\n', '        _;\n', '    }\n', '\n', '    function setCTO(address _newAdmin) public onlyCEO {\n', '        require(_newAdmin != address(0));\n', '        CTOAddress = _newAdmin;\n', '    }\n', '\n', '    function withdrawBalanceAll() external onlyAdmin {\n', '        CEOAddress.transfer(address(this).balance);\n', '    }\n', '    \n', '    function withdrawBalance(uint _amount) external onlyAdmin {\n', '        CEOAddress.transfer(_amount);\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() public onlyCEO whenNotPaused returns(bool) {\n', '        paused = true;\n', '        emit Pause();\n', '        return true;\n', '    }\n', '\n', '    function unpause() public onlyCEO whenPaused returns(bool) {\n', '        paused = false;\n', '        emit Unpause();\n', '        return true;\n', '    }\n', '\n', '    function _random(uint _lower, uint _range, uint _jump) internal view returns (uint) {\n', '        uint number = uint(blockhash(block.number - _jump)) % _range;\n', '        if (number < _lower) {\n', '            number = _lower;\n', '        }\n', '        return number;\n', '    }\n', '\n', '    function setFeeUnit(uint _fee) public onlyCEO {\n', '        feeUnit = _fee;\n', '    }\n', '    \n', '    function setPreSaleDurance(uint _durance) public onlyCEO {\n', '        preSaleDurance = _durance;\n', '    }\n', '    \n', '    function unPausePriceRaise() public onlyCEO {\n', '        require(pricePause == true);\n', '        pricePause = false;\n', '        startTime = uint(now);\n', '        emit PriceRaise();\n', '    }\n', '    \n', '    function pausePriceRaise() public onlyCEO {\n', '        require(pricePause == false);\n', '        pricePause = true;\n', '        endTime = uint(now);\n', '        emit PriceStop();\n', '    }\n', '    \n', '    function _computePrice(uint _startPrice, uint _endPrice, uint _totalDurance, uint _timePass) internal pure returns (uint) {\n', '        if (_timePass >= _totalDurance) {\n', '            return _endPrice;\n', '        } else {\n', '            uint totalPriceChange = safeSub(_endPrice, _startPrice);\n', '            uint currentPriceChange = totalPriceChange * uint(_timePass) / uint(_totalDurance);\n', '            uint currentPrice = uint(_startPrice) + currentPriceChange;\n', '\n', '            return uint(currentPrice);\n', '        }\n', '    }\n', '    \n', '    function computePrice(uint _startPrice, uint _raiseIndex) public view returns (uint) {\n', '        if(pricePause == false) {\n', '            uint timePass = safeSub(uint(now), startTime);\n', '            return _computePrice(_startPrice, _startPrice*raiseIndex[_raiseIndex], preSaleDurance, timePass);\n', '        } else {\n', '            return _startPrice;\n', '        }\n', '    }\n', '    \n', '    function WhoIsTheContractMaster() public pure returns (string) {\n', '        return "Alexander The Exlosion";\n', '    }\n', '}\n', '\n', 'contract Broker is Administration {\n', '    // ----------------------------------------------------------------------------\n', '    // Events\n', '    // ----------------------------------------------------------------------------\n', '    event BrokerRegistered(uint indexed brokerId, address indexed broker);\n', '    event AppendSubBroker(uint indexed brokerId, uint indexed subBrokerId, address indexed subBroker);\n', '    event BrokerTransfer(address indexed newBroker, uint indexed brokerId, uint indexed subBrokerId);\n', '    event BrokerFeeDistrubution(uint brokerId, address indexed vipBroker, uint indexed vipShare, uint subBrokerId, address indexed broker, uint share);\n', '    event BrokerFeeClaim(address indexed broker, uint indexed fee);\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Mappings\n', '    // ----------------------------------------------------------------------------\n', '    mapping (uint => address[]) BrokerIdToBrokers;\n', '    mapping (uint => uint) BrokerIdToSpots;\n', '    mapping (address => uint) BrokerIncoming;\n', '    mapping (address => bool) UserToIfBroker;\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Variables\n', '    // ----------------------------------------------------------------------------\n', '    uint public vipBrokerFee = 1.8 ether;\n', '    uint public brokerFee = 0.38 ether;\n', '    uint public vipBrokerNum = 100;\n', '    uint public subBrokerNum = 5;\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Modifier\n', '    // ----------------------------------------------------------------------------\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Internal Function\n', '    // ----------------------------------------------------------------------------\n', '    function _brokerFeeDistribute(uint _price, uint _type, uint _brokerId, uint _subBrokerId) internal {\n', '        address vipBroker = getBrokerAddress(_brokerId, 0);\n', '        address broker = getBrokerAddress(_brokerId, _subBrokerId);\n', '        require(vipBroker != address(0) && broker != address(0));\n', '        uint totalShare = _price*rewardPercent[_type]/100;\n', '        BrokerIncoming[vipBroker] = BrokerIncoming[vipBroker] + totalShare*15/100;\n', '        BrokerIncoming[broker] = BrokerIncoming[broker] + totalShare*85/100;\n', '        \n', '        emit BrokerFeeDistrubution(_brokerId, vipBroker, totalShare*15/100, _subBrokerId, broker, totalShare*85/100);\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Public Function\n', '    // ----------------------------------------------------------------------------\n', '    function registerBroker() public payable returns (uint) {\n', '        require(vipBrokerNum > 0);\n', '        require(msg.value >= vipBrokerFee);\n', '        require(UserToIfBroker[msg.sender] == false);\n', '        UserToIfBroker[msg.sender] = true;\n', '        vipBrokerNum--;\n', '        uint brokerId = 100 - vipBrokerNum;\n', '        BrokerIdToBrokers[brokerId].push(msg.sender);\n', '        BrokerIdToSpots[brokerId] = subBrokerNum;\n', '        emit BrokerRegistered(brokerId, msg.sender);\n', '        return brokerId;\n', '    }\n', '    \n', '    function assignSubBroker(uint _brokerId, address _broker) public payable {\n', '        require(msg.sender == BrokerIdToBrokers[_brokerId][0]);\n', '        require(msg.value >= brokerFee);\n', '        require(UserToIfBroker[_broker] == false);\n', '        UserToIfBroker[_broker] = true;\n', '        require(BrokerIdToSpots[_brokerId] > 0);\n', '        uint newSubBrokerId = BrokerIdToBrokers[_brokerId].push(_broker) - 1;\n', '        BrokerIdToSpots[_brokerId]--;\n', '        \n', '        emit AppendSubBroker(_brokerId, newSubBrokerId, _broker);\n', '    }\n', '    \n', '    function transferBroker(address _newBroker, uint _brokerId, uint _subBrokerId) public whenNotPaused {\n', '        require(_brokerId > 0 && _brokerId <= 100);\n', '        require(_subBrokerId >= 0 && _subBrokerId <= 5);\n', '        require(UserToIfBroker[msg.sender] == true);\n', '        UserToIfBroker[msg.sender] = false;\n', '        require(BrokerIdToBrokers[_brokerId][_subBrokerId] == msg.sender);\n', '        BrokerIdToBrokers[_brokerId][_subBrokerId] = _newBroker;\n', '        \n', '        emit BrokerTransfer(_newBroker, _brokerId, _subBrokerId);\n', '    }\n', '\n', '    function claimBrokerFee() public whenNotPaused {\n', '        uint fee = BrokerIncoming[msg.sender];\n', '        require(fee > 0);\n', '        msg.sender.transfer(fee);\n', '        BrokerIncoming[msg.sender] = 0;\n', '        emit BrokerFeeClaim(msg.sender, fee);\n', '    }\n', '    \n', '    function getBrokerIncoming(address _broker) public view returns (uint) {\n', '        return BrokerIncoming[_broker];\n', '    } \n', '    \n', '    function getBrokerInfo(uint _brokerId) public view returns (\n', '        address broker,\n', '        uint subSpot\n', '    ) { \n', '        broker = BrokerIdToBrokers[_brokerId][0];\n', '        subSpot = BrokerIdToSpots[_brokerId];\n', '    }\n', '    \n', '    function getBrokerAddress(uint _brokerId, uint _subBrokerId) public view returns (address) {\n', '        return BrokerIdToBrokers[_brokerId][_subBrokerId];\n', '    }\n', '    \n', '    function getVipBrokerNum() public view returns (uint) {\n', '        return safeSub(100, vipBrokerNum);\n', '    }\n', '}\n', '\n', 'contract PreSaleRealm is Broker {\n', '    // ----------------------------------------------------------------------------\n', '    // Events\n', '    // ----------------------------------------------------------------------------\n', '    event RealmSaleCreate(uint indexed saleId, uint indexed realmId, uint indexed price);\n', '    event BuyRealm(uint indexed saleId, uint realmId, address indexed buyer, uint indexed currentPrice);\n', '    event RealmOfferSubmit(uint indexed saleId, uint realmId, address indexed bidder, uint indexed price);\n', '    event RealmOfferAccept(uint indexed saleId, uint realmId, address indexed newOwner, uint indexed newPrice);\n', '    event SetRealmSale(uint indexed saleId, uint indexed price);\n', '    \n', '    event RealmAuctionCreate(uint indexed auctionId, uint indexed realmId, uint indexed startPrice);\n', '    event RealmAuctionBid(uint indexed auctionId, address indexed bidder, uint indexed offer);\n', '    \n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Mappings\n', '    // ----------------------------------------------------------------------------\n', '    mapping (uint => address) public RealmSaleToBuyer;\n', '    mapping (uint => bool) RealmIdToIfCreated;\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Variables\n', '    // ----------------------------------------------------------------------------\n', '    struct RealmSale {\n', '        uint realmId;\n', '        uint price;\n', '        bool ifSold;\n', '        address bidder;\n', '        uint offerPrice;\n', '        uint timestamp;\n', '    }\n', '    \n', '    RealmSale[] realmSales;\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Modifier\n', '    // ----------------------------------------------------------------------------\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Internal Function\n', '    // ----------------------------------------------------------------------------\n', '    function _generateRealmSale(uint _realmId, uint _price) internal returns (uint) {\n', '        require(RealmIdToIfCreated[_realmId] == false);\n', '        RealmIdToIfCreated[_realmId] = true;\n', '        RealmSale memory _RealmSale = RealmSale({\n', '            realmId: _realmId,\n', '            price: _price,\n', '            ifSold: false,\n', '            bidder: address(0),\n', '            offerPrice: 0,\n', '            timestamp: 0\n', '        });\n', '        uint realmSaleId = realmSales.push(_RealmSale) - 1;\n', '        emit RealmSaleCreate(realmSaleId, _realmId, _price);\n', '        \n', '        return realmSaleId;\n', '    }\n', '    // ----------------------------------------------------------------------------\n', '    // Public Function\n', '    // ----------------------------------------------------------------------------\n', '    function createRealmSale(uint _num, uint _startId, uint _price) public onlyAdmin {\n', '        for(uint i = 0; i<_num; i++) {\n', '            _generateRealmSale(_startId + i, _price);\n', '        }\n', '    }\n', '    \n', '    function buyRealm(uint _realmSaleId, uint _brokerId, uint _subBrokerId) public payable whenNotPaused {\n', '        RealmSale storage _realmSale = realmSales[_realmSaleId];\n', '        require(RealmSaleToBuyer[_realmSale.realmId] == address(0));\n', '        require(_realmSale.ifSold == false);\n', '        uint currentPrice;\n', '        if(pricePause == true) {\n', '            if(_realmSale.timestamp != 0 && _realmSale.timestamp != endTime) {\n', '                uint timePass = safeSub(endTime, startTime);\n', '                _realmSale.price = _computePrice(_realmSale.price, _realmSale.price*raiseIndex[0], preSaleDurance, timePass);\n', '                _realmSale.timestamp = endTime;\n', '            }\n', '            _brokerFeeDistribute(_realmSale.price, 0, _brokerId, _subBrokerId);\n', '            require(msg.value >= _realmSale.price);\n', '            currentPrice = _realmSale.price;\n', '        } else {\n', '            if(_realmSale.timestamp == 0) {\n', '                _realmSale.timestamp = uint(now);\n', '            }\n', '            currentPrice = _computePrice(_realmSale.price, _realmSale.price*raiseIndex[0], preSaleDurance, safeSub(uint(now), startTime));\n', '            _brokerFeeDistribute(currentPrice, 0, _brokerId, _subBrokerId);\n', '            require(msg.value >= currentPrice);\n', '            _realmSale.price = currentPrice;\n', '        }\n', '        RealmSaleToBuyer[_realmSale.realmId] = msg.sender;\n', '        _realmSale.ifSold = true;\n', '        emit BuyRealm(_realmSaleId, _realmSale.realmId, msg.sender, currentPrice);\n', '    }\n', '    \n', '    function offlineRealmSold(uint _realmSaleId, address _buyer, uint _price) public onlyAdmin {\n', '        RealmSale storage _realmSale = realmSales[_realmSaleId];\n', '        require(_realmSale.ifSold == false);\n', '        RealmSaleToBuyer[_realmSale.realmId] = _buyer;\n', '        _realmSale.ifSold = true;\n', '        emit BuyRealm(_realmSaleId, _realmSale.realmId, _buyer, _price);\n', '    }\n', '    \n', '    function OfferToRealm(uint _realmSaleId, uint _price) public payable whenNotPaused {\n', '        RealmSale storage _realmSale = realmSales[_realmSaleId];\n', '        require(_realmSale.ifSold == true);\n', '        require(_price >= _realmSale.offerPrice*11/10);\n', '        require(msg.value >= _price);\n', '        \n', '        if(_realmSale.bidder == address(0)) {\n', '            _realmSale.bidder = msg.sender;\n', '            _realmSale.offerPrice = _price;\n', '        } else {\n', '            address lastBidder = _realmSale.bidder;\n', '            uint lastOffer = _realmSale.price;\n', '            lastBidder.transfer(lastOffer);\n', '            \n', '            _realmSale.bidder = msg.sender;\n', '            _realmSale.offerPrice = _price;\n', '        }\n', '        \n', '        emit RealmOfferSubmit(_realmSaleId, _realmSale.realmId, msg.sender, _price);\n', '    }\n', '    \n', '    function AcceptRealmOffer(uint _realmSaleId) public whenNotPaused {\n', '        RealmSale storage _realmSale = realmSales[_realmSaleId];\n', '        require(RealmSaleToBuyer[_realmSale.realmId] == msg.sender);\n', '        require(_realmSale.bidder != address(0) && _realmSale.offerPrice > 0);\n', '        msg.sender.transfer(_realmSale.offerPrice);\n', '        RealmSaleToBuyer[_realmSale.realmId] = _realmSale.bidder;\n', '        _realmSale.price = _realmSale.offerPrice;\n', '        \n', '        emit RealmOfferAccept(_realmSaleId, _realmSale.realmId, _realmSale.bidder, _realmSale.offerPrice);\n', '        \n', '        _realmSale.bidder = address(0);\n', '        _realmSale.offerPrice = 0;\n', '    }\n', '    \n', '    function setRealmSale(uint _realmSaleId, uint _price) public onlyAdmin {\n', '        RealmSale storage _realmSale = realmSales[_realmSaleId];\n', '        require(_realmSale.ifSold == false);\n', '        _realmSale.price = _price;\n', '        emit SetRealmSale(_realmSaleId, _price);\n', '    }\n', '    \n', '    function getRealmSale(uint _realmSaleId) public view returns (\n', '        address owner,\n', '        uint realmId,\n', '        uint price,\n', '        bool ifSold,\n', '        address bidder,\n', '        uint offerPrice,\n', '        uint timestamp\n', '    ) {\n', '        RealmSale memory _RealmSale = realmSales[_realmSaleId];\n', '        owner = RealmSaleToBuyer[_RealmSale.realmId];\n', '        realmId = _RealmSale.realmId;\n', '        price = _RealmSale.price;\n', '        ifSold =_RealmSale.ifSold;\n', '        bidder = _RealmSale.bidder;\n', '        offerPrice = _RealmSale.offerPrice;\n', '        timestamp = _RealmSale.timestamp;\n', '    }\n', '    \n', '    function getRealmNum() public view returns (uint) {\n', '        return realmSales.length;\n', '    }\n', '}\n', '\n', 'contract PreSaleCastle is PreSaleRealm {\n', '    // ----------------------------------------------------------------------------\n', '    // Events\n', '    // ----------------------------------------------------------------------------\n', '    event CastleSaleCreate(uint indexed saleId, uint indexed castleId, uint indexed price, uint realmId, uint rarity);\n', '    event BuyCastle(uint indexed saleId, uint castleId, address indexed buyer, uint indexed currentPrice);\n', '    event CastleOfferSubmit(uint indexed saleId, uint castleId, address indexed bidder, uint indexed price);\n', '    event CastleOfferAccept(uint indexed saleId, uint castleId, address indexed newOwner, uint indexed newPrice);\n', '    event SetCastleSale(uint indexed saleId, uint indexed price, uint realmId, uint rarity);\n', '    \n', '    event CastleAuctionCreate(uint indexed auctionId, uint indexed castleId, uint indexed startPrice, uint realmId, uint rarity);\n', '    event CastleAuctionBid(uint indexed auctionId, address indexed bidder, uint indexed offer);\n', '    \n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Mappings\n', '    // ----------------------------------------------------------------------------\n', '    mapping (uint => address) public CastleSaleToBuyer;\n', '    mapping (uint => bool) CastleIdToIfCreated;\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Variables\n', '    // ----------------------------------------------------------------------------\n', '    struct CastleSale {\n', '        uint castleId;\n', '        uint realmId;\n', '        uint rarity;\n', '        uint price;\n', '        bool ifSold;\n', '        address bidder;\n', '        uint offerPrice;\n', '        uint timestamp;\n', '    }\n', '\n', '    CastleSale[] castleSales;\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Modifier\n', '    // ----------------------------------------------------------------------------\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Internal Function\n', '    // ----------------------------------------------------------------------------\n', '    function _generateCastleSale(uint _castleId, uint _realmId, uint _rarity, uint _price) internal returns (uint) {\n', '        require(CastleIdToIfCreated[_castleId] == false);\n', '        CastleIdToIfCreated[_castleId] = true;\n', '        CastleSale memory _CastleSale = CastleSale({\n', '            castleId: _castleId,\n', '            realmId: _realmId,\n', '            rarity: _rarity,\n', '            price: _price,\n', '            ifSold: false,\n', '            bidder: address(0),\n', '            offerPrice: 0,\n', '            timestamp: 0\n', '        });\n', '        uint castleSaleId = castleSales.push(_CastleSale) - 1;\n', '        emit CastleSaleCreate(castleSaleId, _castleId, _price, _realmId, _rarity);\n', '        \n', '        return castleSaleId;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Public Function\n', '    // ----------------------------------------------------------------------------\n', '    function createCastleSale(uint _num, uint _startId, uint _realmId, uint _rarity, uint _price) public onlyAdmin {\n', '        for(uint i = 0; i<_num; i++) {\n', '            _generateCastleSale(_startId + i, _realmId, _rarity, _price);\n', '        }\n', '    }\n', '    \n', '    function buyCastle(uint _castleSaleId, uint _brokerId, uint _subBrokerId) public payable whenNotPaused {\n', '        CastleSale storage _castleSale = castleSales[_castleSaleId];\n', '        require(CastleSaleToBuyer[_castleSale.castleId] == address(0));\n', '        require(_castleSale.ifSold == false);\n', '        uint currentPrice;\n', '        if(pricePause == true) {\n', '            if(_castleSale.timestamp != 0 && _castleSale.timestamp != endTime) {\n', '                uint timePass = safeSub(endTime, startTime);\n', '                _castleSale.price = _computePrice(_castleSale.price, _castleSale.price*raiseIndex[0], preSaleDurance, timePass);\n', '                _castleSale.timestamp = endTime;\n', '            }\n', '            _brokerFeeDistribute(_castleSale.price, 0, _brokerId, _subBrokerId);\n', '            require(msg.value >= _castleSale.price);\n', '            currentPrice = _castleSale.price;\n', '        } else {\n', '            if(_castleSale.timestamp == 0) {\n', '                _castleSale.timestamp = uint(now);\n', '            }\n', '            currentPrice = _computePrice(_castleSale.price, _castleSale.price*raiseIndex[0], preSaleDurance, safeSub(uint(now), startTime));\n', '            _brokerFeeDistribute(currentPrice, 0, _brokerId, _subBrokerId);\n', '            require(msg.value >= currentPrice);\n', '            _castleSale.price = currentPrice;\n', '        }\n', '        CastleSaleToBuyer[_castleSale.castleId] = msg.sender;\n', '        _castleSale.ifSold = true;\n', '        emit BuyCastle(_castleSaleId, _castleSale.castleId, msg.sender, currentPrice);\n', '    }\n', '    \n', '    function OfflineCastleSold(uint _castleSaleId, address _buyer, uint _price) public onlyAdmin {\n', '        CastleSale storage _castleSale = castleSales[_castleSaleId];\n', '        require(_castleSale.ifSold == false);\n', '        CastleSaleToBuyer[_castleSale.castleId] = _buyer;\n', '        _castleSale.ifSold = true;\n', '        emit BuyCastle(_castleSaleId, _castleSale.castleId, _buyer, _price);\n', '    }\n', '    \n', '    function OfferToCastle(uint _castleSaleId, uint _price) public payable whenNotPaused {\n', '        CastleSale storage _castleSale = castleSales[_castleSaleId];\n', '        require(_castleSale.ifSold == true);\n', '        require(_price >= _castleSale.offerPrice*11/10);\n', '        require(msg.value >= _price);\n', '        \n', '        if(_castleSale.bidder == address(0)) {\n', '            _castleSale.bidder = msg.sender;\n', '            _castleSale.offerPrice = _price;\n', '        } else {\n', '            address lastBidder = _castleSale.bidder;\n', '            uint lastOffer = _castleSale.price;\n', '            lastBidder.transfer(lastOffer);\n', '            \n', '            _castleSale.bidder = msg.sender;\n', '            _castleSale.offerPrice = _price;\n', '        }\n', '        \n', '        emit CastleOfferSubmit(_castleSaleId, _castleSale.castleId, msg.sender, _price);\n', '    }\n', '    \n', '    function AcceptCastleOffer(uint _castleSaleId) public whenNotPaused {\n', '        CastleSale storage _castleSale = castleSales[_castleSaleId];\n', '        require(CastleSaleToBuyer[_castleSale.castleId] == msg.sender);\n', '        require(_castleSale.bidder != address(0) && _castleSale.offerPrice > 0);\n', '        msg.sender.transfer(_castleSale.offerPrice);\n', '        CastleSaleToBuyer[_castleSale.castleId] = _castleSale.bidder;\n', '        _castleSale.price = _castleSale.offerPrice;\n', '        \n', '        emit CastleOfferAccept(_castleSaleId, _castleSale.castleId, _castleSale.bidder, _castleSale.offerPrice);\n', '        \n', '        _castleSale.bidder = address(0);\n', '        _castleSale.offerPrice = 0;\n', '    }\n', '    \n', '    function setCastleSale(uint _castleSaleId, uint _price, uint _realmId, uint _rarity) public onlyAdmin {\n', '        CastleSale storage _castleSale = castleSales[_castleSaleId];\n', '        require(_castleSale.ifSold == false);\n', '        _castleSale.price = _price;\n', '        _castleSale.realmId = _realmId;\n', '        _castleSale.rarity = _rarity;\n', '        emit SetCastleSale(_castleSaleId, _price, _realmId, _rarity);\n', '    }\n', '    \n', '    function getCastleSale(uint _castleSaleId) public view returns (\n', '        address owner,\n', '        uint castleId,\n', '        uint realmId,\n', '        uint rarity,\n', '        uint price,\n', '        bool ifSold,\n', '        address bidder,\n', '        uint offerPrice,\n', '        uint timestamp\n', '    ) {\n', '        CastleSale memory _CastleSale = castleSales[_castleSaleId];\n', '        owner = CastleSaleToBuyer[_CastleSale.castleId];\n', '        castleId = _CastleSale.castleId;\n', '        realmId = _CastleSale.realmId;\n', '        rarity = _CastleSale.rarity;\n', '        price = _CastleSale.price;\n', '        ifSold =_CastleSale.ifSold;\n', '        bidder = _CastleSale.bidder;\n', '        offerPrice = _CastleSale.offerPrice;\n', '        timestamp = _CastleSale.timestamp;\n', '    }\n', '    \n', '    function getCastleNum() public view returns (uint) {\n', '        return castleSales.length;\n', '    }\n', '}\n', '\n', 'contract PreSaleGuardian is PreSaleCastle {\n', '    // ----------------------------------------------------------------------------\n', '    // Events\n', '    // ----------------------------------------------------------------------------\n', '    event GuardianSaleCreate(uint indexed saleId, uint indexed guardianId, uint indexed price, uint race, uint level, uint starRate);\n', '    event BuyGuardian(uint indexed saleId, uint guardianId, address indexed buyer, uint indexed currentPrice);\n', '    event GuardianOfferSubmit(uint indexed saleId, uint guardianId, address indexed bidder, uint indexed price);\n', '    event GuardianOfferAccept(uint indexed saleId, uint guardianId, address indexed newOwner, uint indexed newPrice);\n', '    event SetGuardianSale(uint indexed saleId, uint indexed price, uint race, uint starRate, uint level);\n', '    \n', '    event GuardianAuctionCreate(uint indexed auctionId, uint indexed guardianId, uint indexed startPrice, uint race, uint level, uint starRate);\n', '    event GuardianAuctionBid(uint indexed auctionId, address indexed bidder, uint indexed offer);\n', '    \n', '    event VendingGuardian(uint indexed vendingId, address indexed buyer);\n', '    event GuardianVendOffer(uint indexed vendingId, address indexed bidder, uint indexed offer);\n', '    event GuardianVendAccept(uint indexed vendingId, address indexed newOwner, uint indexed newPrice);\n', '    event SetGuardianVend(uint indexed priceId, uint indexed price);\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Mappings\n', '    // ----------------------------------------------------------------------------\n', '    mapping (uint => address) public GuardianSaleToBuyer;\n', '    mapping (uint => bool) GuardianIdToIfCreated;\n', '    \n', '    mapping (uint => uint) public GuardianVendToOffer;\n', '    mapping (uint => address) public GuardianVendToBidder;\n', '    mapping (uint => uint) public GuardianVendToTime;\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Variables\n', '    // ----------------------------------------------------------------------------\n', '    struct GuardianSale {\n', '        uint guardianId;\n', '        uint race;\n', '        uint starRate;\n', '        uint level;\n', '        uint price;\n', '        bool ifSold;\n', '        address bidder;\n', '        uint offerPrice;\n', '        uint timestamp;\n', '    }\n', '    \n', '    GuardianSale[] guardianSales;\n', '\n', '    uint[5] GuardianVending = [\n', '        0.5 ether,\n', '        0.35 ether,\n', '        0.20 ether,\n', '        0.15 ether,\n', '        0.1 ether\n', '    ];\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Modifier\n', '    // ----------------------------------------------------------------------------\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Internal Function\n', '    // ----------------------------------------------------------------------------\n', '    function _generateGuardianSale(uint _guardianId, uint _race, uint _starRate, uint _level, uint _price) internal returns (uint) {\n', '        require(GuardianIdToIfCreated[_guardianId] == false);\n', '        GuardianIdToIfCreated[_guardianId] = true;\n', '        GuardianSale memory _GuardianSale = GuardianSale({\n', '            guardianId: _guardianId,\n', '            race: _race,\n', '            starRate: _starRate,\n', '            level: _level,\n', '            price: _price,\n', '            ifSold: false,\n', '            bidder: address(0),\n', '            offerPrice: 0,\n', '            timestamp: 0\n', '        });\n', '        uint guardianSaleId = guardianSales.push(_GuardianSale) - 1;\n', '        emit GuardianSaleCreate(guardianSaleId, _guardianId, _price, _race, _level, _starRate);\n', '        \n', '        return guardianSaleId;\n', '    }\n', '    \n', '    function _guardianVendPrice(uint _guardianId , uint _level) internal returns (uint) {\n', '        if(pricePause == true) {\n', '            if(GuardianVendToTime[_guardianId] != 0 && GuardianVendToTime[_guardianId] != endTime) {\n', '                uint timePass = safeSub(endTime, startTime);\n', '                GuardianVending[_level] = _computePrice(GuardianVending[_level], GuardianVending[_level]*raiseIndex[1], preSaleDurance, timePass);\n', '                GuardianVendToTime[_guardianId] = endTime;\n', '            }\n', '            return GuardianVending[_level];\n', '        } else {\n', '            if(GuardianVendToTime[_guardianId] == 0) {\n', '                GuardianVendToTime[_guardianId] = uint(now);\n', '            }\n', '            uint currentPrice = _computePrice(GuardianVending[_level], GuardianVending[_level]*raiseIndex[1], preSaleDurance, safeSub(uint(now), startTime));\n', '            return currentPrice;\n', '        }\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Public Function\n', '    // ----------------------------------------------------------------------------\n', '    function createGuardianSale(uint _num, uint _startId, uint _race, uint _starRate, uint _level, uint _price) public onlyAdmin {\n', '        for(uint i = 0; i<_num; i++) {\n', '            _generateGuardianSale(_startId + i, _race, _starRate, _level, _price);\n', '        }\n', '    }\n', '    \n', '    function buyGuardian(uint _guardianSaleId, uint _brokerId, uint _subBrokerId) public payable whenNotPaused {\n', '        GuardianSale storage _guardianSale = guardianSales[_guardianSaleId];\n', '        require(GuardianSaleToBuyer[_guardianSale.guardianId] == address(0));\n', '        require(_guardianSale.ifSold == false);\n', '        uint currentPrice;\n', '        if(pricePause == true) {\n', '            if(_guardianSale.timestamp != 0 && _guardianSale.timestamp != endTime) {\n', '                uint timePass = safeSub(endTime, startTime);\n', '                _guardianSale.price = _computePrice(_guardianSale.price, _guardianSale.price*raiseIndex[1], preSaleDurance, timePass);\n', '                _guardianSale.timestamp = endTime;\n', '            }\n', '            _brokerFeeDistribute(_guardianSale.price, 1, _brokerId, _subBrokerId);\n', '            require(msg.value >= _guardianSale.price);\n', '            currentPrice = _guardianSale.price;\n', '        } else {\n', '            if(_guardianSale.timestamp == 0) {\n', '                _guardianSale.timestamp = uint(now);\n', '            }\n', '            currentPrice = _computePrice(_guardianSale.price, _guardianSale.price*raiseIndex[1], preSaleDurance, safeSub(uint(now), startTime));\n', '            _brokerFeeDistribute(currentPrice, 1, _brokerId, _subBrokerId);\n', '            require(msg.value >= currentPrice);\n', '            _guardianSale.price = currentPrice;\n', '        }\n', '        GuardianSaleToBuyer[_guardianSale.guardianId] = msg.sender;\n', '        _guardianSale.ifSold = true;\n', '        emit BuyGuardian(_guardianSaleId, _guardianSale.guardianId, msg.sender, currentPrice);\n', '    }\n', '    \n', '    function offlineGuardianSold(uint _guardianSaleId, address _buyer, uint _price) public onlyAdmin {\n', '        GuardianSale storage _guardianSale = guardianSales[_guardianSaleId];\n', '        require(_guardianSale.ifSold == false);\n', '        GuardianSaleToBuyer[_guardianSale.guardianId] = _buyer;\n', '        _guardianSale.ifSold = true;\n', '        emit BuyGuardian(_guardianSaleId, _guardianSale.guardianId, _buyer, _price);\n', '    }\n', '    \n', '    function OfferToGuardian(uint _guardianSaleId, uint _price) public payable whenNotPaused {\n', '        GuardianSale storage _guardianSale = guardianSales[_guardianSaleId];\n', '        require(_guardianSale.ifSold == true);\n', '        require(_price > _guardianSale.offerPrice*11/10);\n', '        require(msg.value >= _price);\n', '        \n', '        if(_guardianSale.bidder == address(0)) {\n', '            _guardianSale.bidder = msg.sender;\n', '            _guardianSale.offerPrice = _price;\n', '        } else {\n', '            address lastBidder = _guardianSale.bidder;\n', '            uint lastOffer = _guardianSale.price;\n', '            lastBidder.transfer(lastOffer);\n', '            \n', '            _guardianSale.bidder = msg.sender;\n', '            _guardianSale.offerPrice = _price;\n', '        }\n', '        \n', '        emit GuardianOfferSubmit(_guardianSaleId, _guardianSale.guardianId, msg.sender, _price);\n', '    }\n', '    \n', '    function AcceptGuardianOffer(uint _guardianSaleId) public whenNotPaused {\n', '        GuardianSale storage _guardianSale = guardianSales[_guardianSaleId];\n', '        require(GuardianSaleToBuyer[_guardianSale.guardianId] == msg.sender);\n', '        require(_guardianSale.bidder != address(0) && _guardianSale.offerPrice > 0);\n', '        msg.sender.transfer(_guardianSale.offerPrice);\n', '        GuardianSaleToBuyer[_guardianSale.guardianId] = _guardianSale.bidder;\n', '        _guardianSale.price = _guardianSale.offerPrice;\n', '        \n', '        emit GuardianOfferAccept(_guardianSaleId, _guardianSale.guardianId, _guardianSale.bidder, _guardianSale.price);\n', '        \n', '        _guardianSale.bidder = address(0);\n', '        _guardianSale.offerPrice = 0;\n', '    }\n', '    \n', '    function setGuardianSale(uint _guardianSaleId, uint _price, uint _race, uint _starRate, uint _level) public onlyAdmin {\n', '        GuardianSale storage _guardianSale = guardianSales[_guardianSaleId];\n', '        require(_guardianSale.ifSold == false);\n', '        _guardianSale.price = _price;\n', '        _guardianSale.race = _race;\n', '        _guardianSale.starRate = _starRate;\n', '        _guardianSale.level = _level;\n', '        emit SetGuardianSale(_guardianSaleId, _price, _race, _starRate, _level);\n', '    }\n', '    \n', '    function getGuardianSale(uint _guardianSaleId) public view returns (\n', '        address owner,\n', '        uint guardianId,\n', '        uint race,\n', '        uint starRate,\n', '        uint level,\n', '        uint price,\n', '        bool ifSold,\n', '        address bidder,\n', '        uint offerPrice,\n', '        uint timestamp\n', '    ) {\n', '        GuardianSale memory _GuardianSale = guardianSales[_guardianSaleId];\n', '        owner = GuardianSaleToBuyer[_GuardianSale.guardianId];\n', '        guardianId = _GuardianSale.guardianId;\n', '        race = _GuardianSale.race;\n', '        starRate = _GuardianSale.starRate;\n', '        level = _GuardianSale.level;\n', '        price = _GuardianSale.price;\n', '        ifSold =_GuardianSale.ifSold;\n', '        bidder = _GuardianSale.bidder;\n', '        offerPrice = _GuardianSale.offerPrice;\n', '        timestamp = _GuardianSale.timestamp;\n', '    }\n', '    \n', '    function getGuardianNum() public view returns (uint) {\n', '        return guardianSales.length;\n', '    }\n', '\n', '    function vendGuardian(uint _guardianId) public payable whenNotPaused {\n', '        require(_guardianId > 1000 && _guardianId <= 6000);\n', '        if(_guardianId > 1000 && _guardianId <= 2000) {\n', '            require(GuardianSaleToBuyer[_guardianId] == address(0));\n', '            require(msg.value >= _guardianVendPrice(_guardianId, 0));\n', '            GuardianSaleToBuyer[_guardianId] = msg.sender;\n', '            GuardianVendToOffer[_guardianId] = GuardianVending[0];\n', '        } else if (_guardianId > 2000 && _guardianId <= 3000) {\n', '            require(GuardianSaleToBuyer[_guardianId] == address(0));\n', '            require(msg.value >= _guardianVendPrice(_guardianId, 1));\n', '            GuardianSaleToBuyer[_guardianId] = msg.sender;\n', '            GuardianVendToOffer[_guardianId] = GuardianVending[1];\n', '        } else if (_guardianId > 3000 && _guardianId <= 4000) {\n', '            require(GuardianSaleToBuyer[_guardianId] == address(0));\n', '            require(msg.value >= _guardianVendPrice(_guardianId, 2));\n', '            GuardianSaleToBuyer[_guardianId] = msg.sender;\n', '            GuardianVendToOffer[_guardianId] = GuardianVending[2];\n', '        } else if (_guardianId > 4000 && _guardianId <= 5000) {\n', '            require(GuardianSaleToBuyer[_guardianId] == address(0));\n', '            require(msg.value >= _guardianVendPrice(_guardianId, 3));\n', '            GuardianSaleToBuyer[_guardianId] = msg.sender;\n', '            GuardianVendToOffer[_guardianId] = GuardianVending[3];\n', '        } else if (_guardianId > 5000 && _guardianId <= 6000) {\n', '            require(GuardianSaleToBuyer[_guardianId] == address(0));\n', '            require(msg.value >= _guardianVendPrice(_guardianId, 4));\n', '            GuardianSaleToBuyer[_guardianId] = msg.sender;\n', '            GuardianVendToOffer[_guardianId] = GuardianVending[4];\n', '        }\n', '        emit VendingGuardian(_guardianId, msg.sender);\n', '    }\n', '    \n', '    function offerGuardianVend(uint _guardianId, uint _offer) public payable whenNotPaused {\n', '        require(GuardianSaleToBuyer[_guardianId] != address(0));\n', '        require(_offer >= GuardianVendToOffer[_guardianId]*11/10);\n', '        require(msg.value >= _offer);\n', '        address lastBidder = GuardianVendToBidder[_guardianId];\n', '        if(lastBidder != address(0)){\n', '            lastBidder.transfer(GuardianVendToOffer[_guardianId]);\n', '        }\n', '        GuardianVendToBidder[_guardianId] = msg.sender;\n', '        GuardianVendToOffer[_guardianId] = _offer;\n', '        emit GuardianVendOffer(_guardianId, msg.sender, _offer);\n', '    }\n', '    \n', '    function acceptGuardianVend(uint _guardianId) public whenNotPaused {\n', '        require(GuardianSaleToBuyer[_guardianId] == msg.sender);\n', '        address bidder = GuardianVendToBidder[_guardianId];\n', '        uint offer = GuardianVendToOffer[_guardianId];\n', '        require(bidder != address(0) && offer > 0);\n', '        msg.sender.transfer(offer);\n', '        GuardianSaleToBuyer[_guardianId] = bidder;\n', '        GuardianVendToBidder[_guardianId] = address(0);\n', '        GuardianVendToOffer[_guardianId] = 0;\n', '        emit GuardianVendAccept(_guardianId, bidder, offer);\n', '    }\n', '    \n', '    function setGuardianVend(uint _num, uint _price) public onlyAdmin {\n', '        GuardianVending[_num] = _price;\n', '        emit SetGuardianVend(_num, _price);\n', '    }\n', '    \n', '    function getGuardianVend(uint _guardianId) public view returns (\n', '        address owner,\n', '        address bidder,\n', '        uint offer\n', '    ) {\n', '        owner = GuardianSaleToBuyer[_guardianId];\n', '        bidder = GuardianVendToBidder[_guardianId];\n', '        offer = GuardianVendToOffer[_guardianId];\n', '    }\n', '}\n', '\n', 'contract PreSaleDisciple is PreSaleGuardian {\n', '    // ----------------------------------------------------------------------------\n', '    // Events\n', '    // ----------------------------------------------------------------------------\n', '    event DiscipleSaleCreate(uint indexed saleId, uint indexed discipleId, uint indexed price, uint occupation, uint level);\n', '    event BuyDisciple(uint indexed saleId, uint discipleId, address indexed buyer, uint indexed currentPrice);\n', '    event DiscipleOfferSubmit(uint indexed saleId, uint discipleId, address indexed bidder, uint indexed price);\n', '    event DiscipleOfferAccept(uint indexed saleId, uint discipleId, address indexed newOwner, uint indexed newPrice);\n', '    event SetDiscipleSale(uint indexed saleId, uint indexed price, uint occupation, uint level);\n', '    \n', '    event DiscipleAuctionCreate(uint indexed auctionId, uint indexed discipleId, uint indexed startPrice, uint occupation, uint level);\n', '    event DiscipleAuctionBid(uint indexed auctionId, address indexed bidder, uint indexed offer);\n', '    \n', '    event VendingDisciple(uint indexed vendingId, address indexed buyer);\n', '    event DiscipleVendOffer(uint indexed vendingId, address indexed bidder, uint indexed offer);\n', '    event DiscipleVendAccept(uint indexed vendingId, address indexed newOwner, uint indexed newPrice);\n', '    event SetDiscipleVend(uint indexed priceId, uint indexed price);\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Mappings\n', '    // ----------------------------------------------------------------------------\n', '    mapping (uint => address) public DiscipleSaleToBuyer;\n', '    mapping (uint => bool) DiscipleIdToIfCreated;\n', '    \n', '    mapping (uint => uint) public DiscipleVendToOffer;\n', '    mapping (uint => address) public DiscipleVendToBidder;\n', '    mapping (uint => uint) public DiscipleVendToTime;\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Variables\n', '    // ----------------------------------------------------------------------------\n', '    struct DiscipleSale {\n', '        uint discipleId;\n', '        uint occupation;\n', '        uint level;\n', '        uint price;\n', '        bool ifSold;\n', '        address bidder;\n', '        uint offerPrice;\n', '        uint timestamp;\n', '    }\n', '    \n', '    DiscipleSale[] discipleSales;\n', '\n', '    uint[5] DiscipleVending = [\n', '        0.3 ether,\n', '        0.2 ether,\n', '        0.15 ether,\n', '        0.1 ether,\n', '        0.05 ether\n', '    ];\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Modifier\n', '    // ----------------------------------------------------------------------------\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Internal Function\n', '    // ----------------------------------------------------------------------------\n', '    function _generateDiscipleSale(uint _discipleId, uint _occupation, uint _level, uint _price) internal returns (uint) {\n', '        require(DiscipleIdToIfCreated[_discipleId] == false);\n', '        DiscipleIdToIfCreated[_discipleId] = true;\n', '        DiscipleSale memory _DiscipleSale = DiscipleSale({\n', '            discipleId: _discipleId,\n', '            occupation: _occupation,\n', '            level: _level,\n', '            price: _price,\n', '            ifSold: false,\n', '            bidder: address(0),\n', '            offerPrice: 0,\n', '            timestamp: 0\n', '        });\n', '        uint discipleSaleId = discipleSales.push(_DiscipleSale) - 1;\n', '        emit DiscipleSaleCreate(discipleSaleId, _discipleId, _price, _occupation, _level);\n', '        \n', '        return discipleSaleId;\n', '    }\n', '    \n', '    function _discipleVendPrice(uint _discipleId , uint _level) internal returns (uint) {\n', '        if(pricePause == true) {\n', '            if(DiscipleVendToTime[_discipleId] != 0 && DiscipleVendToTime[_discipleId] != endTime) {\n', '                uint timePass = safeSub(endTime, startTime);\n', '                DiscipleVending[_level] = _computePrice(DiscipleVending[_level], DiscipleVending[_level]*raiseIndex[1], preSaleDurance, timePass);\n', '                DiscipleVendToTime[_discipleId] = endTime;\n', '            }\n', '            return DiscipleVending[_level];\n', '        } else {\n', '            if(DiscipleVendToTime[_discipleId] == 0) {\n', '                DiscipleVendToTime[_discipleId] = uint(now);\n', '            }\n', '            uint currentPrice = _computePrice(DiscipleVending[_level], DiscipleVending[_level]*raiseIndex[1], preSaleDurance, safeSub(uint(now), startTime));\n', '            return currentPrice;\n', '        }\n', '    }\n', '    // ----------------------------------------------------------------------------\n', '    // Public Function\n', '    // ----------------------------------------------------------------------------\n', '    function createDiscipleSale(uint _num, uint _startId, uint _occupation, uint _level, uint _price) public onlyAdmin {\n', '        for(uint i = 0; i<_num; i++) {\n', '            _generateDiscipleSale(_startId + i, _occupation, _level, _price);\n', '        }\n', '    }\n', '    \n', '    function buyDisciple(uint _discipleSaleId, uint _brokerId, uint _subBrokerId) public payable whenNotPaused {\n', '        DiscipleSale storage _discipleSale = discipleSales[_discipleSaleId];\n', '        require(DiscipleSaleToBuyer[_discipleSale.discipleId] == address(0));\n', '        require(_discipleSale.ifSold == false);\n', '        uint currentPrice;\n', '        if(pricePause == true) {\n', '            if(_discipleSale.timestamp != 0 && _discipleSale.timestamp != endTime) {\n', '                uint timePass = safeSub(endTime, startTime);\n', '                _discipleSale.price = _computePrice(_discipleSale.price, _discipleSale.price*raiseIndex[1], preSaleDurance, timePass);\n', '                _discipleSale.timestamp = endTime;\n', '            }\n', '            _brokerFeeDistribute(_discipleSale.price, 1, _brokerId, _subBrokerId);\n', '            require(msg.value >= _discipleSale.price);\n', '            currentPrice = _discipleSale.price;\n', '        } else {\n', '            if(_discipleSale.timestamp == 0) {\n', '                _discipleSale.timestamp = uint(now);\n', '            }\n', '            currentPrice = _computePrice(_discipleSale.price, _discipleSale.price*raiseIndex[1], preSaleDurance, safeSub(uint(now), startTime));\n', '            _brokerFeeDistribute(currentPrice, 1, _brokerId, _subBrokerId);\n', '            require(msg.value >= currentPrice);\n', '            _discipleSale.price = currentPrice;\n', '        }\n', '        DiscipleSaleToBuyer[_discipleSale.discipleId] = msg.sender;\n', '        _discipleSale.ifSold = true;\n', '        emit BuyDisciple(_discipleSaleId, _discipleSale.discipleId, msg.sender, currentPrice);\n', '    }\n', '    \n', '    function offlineDiscipleSold(uint _discipleSaleId, address _buyer, uint _price) public onlyAdmin {\n', '        DiscipleSale storage _discipleSale = discipleSales[_discipleSaleId];\n', '        require(_discipleSale.ifSold == false);\n', '        DiscipleSaleToBuyer[_discipleSale.discipleId] = _buyer;\n', '        _discipleSale.ifSold = true;\n', '        emit BuyDisciple(_discipleSaleId, _discipleSale.discipleId, _buyer, _price);\n', '    }\n', '    \n', '    function OfferToDisciple(uint _discipleSaleId, uint _price) public payable whenNotPaused {\n', '        DiscipleSale storage _discipleSale = discipleSales[_discipleSaleId];\n', '        require(_discipleSale.ifSold == true);\n', '        require(_price > _discipleSale.offerPrice*11/10);\n', '        require(msg.value >= _price);\n', '        \n', '        if(_discipleSale.bidder == address(0)) {\n', '            _discipleSale.bidder = msg.sender;\n', '            _discipleSale.offerPrice = _price;\n', '        } else {\n', '            address lastBidder = _discipleSale.bidder;\n', '            uint lastOffer = _discipleSale.price;\n', '            lastBidder.transfer(lastOffer);\n', '            \n', '            _discipleSale.bidder = msg.sender;\n', '            _discipleSale.offerPrice = _price;\n', '        }\n', '        \n', '        emit DiscipleOfferSubmit(_discipleSaleId, _discipleSale.discipleId, msg.sender, _price);\n', '    }\n', '    \n', '    function AcceptDiscipleOffer(uint _discipleSaleId) public whenNotPaused {\n', '        DiscipleSale storage _discipleSale = discipleSales[_discipleSaleId];\n', '        require(DiscipleSaleToBuyer[_discipleSale.discipleId] == msg.sender);\n', '        require(_discipleSale.bidder != address(0) && _discipleSale.offerPrice > 0);\n', '        msg.sender.transfer(_discipleSale.offerPrice);\n', '        DiscipleSaleToBuyer[_discipleSale.discipleId] = _discipleSale.bidder;\n', '        _discipleSale.price = _discipleSale.offerPrice;\n', '        \n', '        emit DiscipleOfferAccept(_discipleSaleId, _discipleSale.discipleId, _discipleSale.bidder, _discipleSale.price);\n', '        \n', '        _discipleSale.bidder = address(0);\n', '        _discipleSale.offerPrice = 0;\n', '    }\n', '    \n', '    function setDiscipleSale(uint _discipleSaleId, uint _price, uint _occupation, uint _level) public onlyAdmin {\n', '        DiscipleSale storage _discipleSale = discipleSales[_discipleSaleId];\n', '        require(_discipleSale.ifSold == false);\n', '        _discipleSale.price = _price;\n', '        _discipleSale.occupation = _occupation;\n', '        _discipleSale.level = _level;\n', '        emit SetDiscipleSale(_discipleSaleId, _price, _occupation, _level);\n', '    }\n', '    \n', '    function getDiscipleSale(uint _discipleSaleId) public view returns (\n', '        address owner,\n', '        uint discipleId,\n', '        uint occupation,\n', '        uint level,\n', '        uint price,\n', '        bool ifSold,\n', '        address bidder,\n', '        uint offerPrice,\n', '        uint timestamp\n', '    ) {\n', '        DiscipleSale memory _DiscipleSale = discipleSales[_discipleSaleId];\n', '        owner = DiscipleSaleToBuyer[_DiscipleSale.discipleId];\n', '        discipleId = _DiscipleSale.discipleId;\n', '        occupation = _DiscipleSale.occupation;\n', '        level = _DiscipleSale.level;\n', '        price = _DiscipleSale.price;\n', '        ifSold =_DiscipleSale.ifSold;\n', '        bidder = _DiscipleSale.bidder;\n', '        offerPrice = _DiscipleSale.offerPrice;\n', '        timestamp = _DiscipleSale.timestamp;\n', '    }\n', '    \n', '    function getDiscipleNum() public view returns(uint) {\n', '        return discipleSales.length;\n', '    }\n', '    \n', '    function vendDisciple(uint _discipleId) public payable whenNotPaused {\n', '        require(_discipleId > 1000 && _discipleId <= 10000);\n', '        if(_discipleId > 1000 && _discipleId <= 2000) {\n', '            require(DiscipleSaleToBuyer[_discipleId] == address(0));\n', '            require(msg.value >= _discipleVendPrice(_discipleId, 0));\n', '            DiscipleSaleToBuyer[_discipleId] = msg.sender;\n', '            DiscipleVendToOffer[_discipleId] = DiscipleVending[0];\n', '        } else if (_discipleId > 2000 && _discipleId <= 4000) {\n', '            require(DiscipleSaleToBuyer[_discipleId] == address(0));\n', '            require(msg.value >= _discipleVendPrice(_discipleId, 1));\n', '            DiscipleSaleToBuyer[_discipleId] = msg.sender;\n', '            DiscipleVendToOffer[_discipleId] = DiscipleVending[1];\n', '        } else if (_discipleId > 4000 && _discipleId <= 6000) {\n', '            require(DiscipleSaleToBuyer[_discipleId] == address(0));\n', '            require(msg.value >= _discipleVendPrice(_discipleId, 2));\n', '            DiscipleSaleToBuyer[_discipleId] = msg.sender;\n', '            DiscipleVendToOffer[_discipleId] = DiscipleVending[2];\n', '        } else if (_discipleId > 6000 && _discipleId <= 8000) {\n', '            require(DiscipleSaleToBuyer[_discipleId] == address(0));\n', '            require(msg.value >= _discipleVendPrice(_discipleId, 3));\n', '            DiscipleSaleToBuyer[_discipleId] = msg.sender;\n', '            DiscipleVendToOffer[_discipleId] = DiscipleVending[3];\n', '        } else if (_discipleId > 8000 && _discipleId <= 10000) {\n', '            require(DiscipleSaleToBuyer[_discipleId] == address(0));\n', '            require(msg.value >= _discipleVendPrice(_discipleId, 4));\n', '            DiscipleSaleToBuyer[_discipleId] = msg.sender;\n', '            DiscipleVendToOffer[_discipleId] = DiscipleVending[4];\n', '        }\n', '        emit VendingDisciple(_discipleId, msg.sender);\n', '    }\n', '    \n', '    function offerDiscipleVend(uint _discipleId, uint _offer) public payable whenNotPaused {\n', '        require(DiscipleSaleToBuyer[_discipleId] != address(0));\n', '        require(_offer >= DiscipleVendToOffer[_discipleId]*11/10);\n', '        require(msg.value >= _offer);\n', '        address lastBidder = DiscipleVendToBidder[_discipleId];\n', '        if(lastBidder != address(0)){\n', '            lastBidder.transfer(DiscipleVendToOffer[_discipleId]);\n', '        }\n', '        DiscipleVendToBidder[_discipleId] = msg.sender;\n', '        DiscipleVendToOffer[_discipleId] = _offer;\n', '        emit DiscipleVendOffer(_discipleId, msg.sender, _offer);\n', '    }\n', '    \n', '    function acceptDiscipleVend(uint _discipleId) public whenNotPaused {\n', '        require(DiscipleSaleToBuyer[_discipleId] == msg.sender);\n', '        address bidder = DiscipleVendToBidder[_discipleId];\n', '        uint offer = DiscipleVendToOffer[_discipleId];\n', '        require(bidder != address(0) && offer > 0);\n', '        msg.sender.transfer(offer);\n', '        DiscipleSaleToBuyer[_discipleId] = bidder;\n', '        DiscipleVendToBidder[_discipleId] = address(0);\n', '        DiscipleVendToOffer[_discipleId] = 0;\n', '        emit DiscipleVendAccept(_discipleId, bidder, offer);\n', '    }\n', '    \n', '    function setDiscipleVend(uint _num, uint _price) public onlyAdmin {\n', '        DiscipleVending[_num] = _price;\n', '        emit SetDiscipleVend(_num, _price);\n', '    }\n', '    \n', '    function getDiscipleVend(uint _discipleId) public view returns (\n', '        address owner,\n', '        address bidder,\n', '        uint offer\n', '    ) {\n', '        owner = DiscipleSaleToBuyer[_discipleId];\n', '        bidder = DiscipleVendToBidder[_discipleId];\n', '        offer = DiscipleVendToOffer[_discipleId];\n', '    }\n', '}\n', '\n', 'contract PreSaleAssets is PreSaleDisciple {\n', '    // ----------------------------------------------------------------------------\n', '    // Events\n', '    // ----------------------------------------------------------------------------\n', '    event BuyDiscipleItem(address indexed buyer, uint indexed rarity, uint indexed number, uint currentPrice);\n', '    event BuyGuardianRune(address indexed buyer, uint indexed rarity, uint indexed number, uint currentPrice);\n', '    \n', '    event SetDiscipleItem(uint indexed rarity, uint indexed price);\n', '    event SetGuardianRune(uint indexed rarity, uint indexed price);\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Mappings\n', '    // ----------------------------------------------------------------------------\n', '    mapping (address => uint) PlayerOwnRareItem;\n', '    mapping (address => uint) PlayerOwnEpicItem;\n', '    mapping (address => uint) PlayerOwnLegendaryItem;\n', '    mapping (address => uint) PlayerOwnUniqueItem;\n', '    \n', '    mapping (address => uint) PlayerOwnRareRune;\n', '    mapping (address => uint) PlayerOwnEpicRune;\n', '    mapping (address => uint) PlayerOwnLegendaryRune;\n', '    mapping (address => uint) PlayerOwnUniqueRune;\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Variables\n', '    // ----------------------------------------------------------------------------\n', '    uint[4] public DiscipleItem = [\n', '        0.1 ether,\n', '        0.88 ether,\n', '        2.88 ether,\n', '        9.98 ether\n', '    ];\n', '    \n', '    uint[4] public GuardianRune = [\n', '        0.18 ether,\n', '        1.18 ether,\n', '        3.88 ether,\n', '        10.88 ether\n', '    ];\n', '    \n', '    uint itemTimeStamp;\n', '    uint runeTimeStamp;\n', '    // ----------------------------------------------------------------------------\n', '    // Modifier\n', '    // ----------------------------------------------------------------------------\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Internal Function\n', '    // ----------------------------------------------------------------------------\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // Public Function\n', '    // ----------------------------------------------------------------------------\n', '    function buyDiscipleItem(uint _rarity, uint _num, uint _brokerId, uint _subBrokerId) public payable whenNotPaused {\n', '        require(_rarity >= 0 && _rarity <= 3);\n', '        uint currentPrice;\n', '        if(pricePause == true) {\n', '            if(itemTimeStamp != 0 && itemTimeStamp != endTime) {\n', '                uint timePass = safeSub(endTime, startTime);\n', '                DiscipleItem[0] = _computePrice(DiscipleItem[0], DiscipleItem[0]*raiseIndex[2], preSaleDurance, timePass);\n', '                DiscipleItem[1] = _computePrice(DiscipleItem[1], DiscipleItem[1]*raiseIndex[2], preSaleDurance, timePass);\n', '                DiscipleItem[2] = _computePrice(DiscipleItem[2], DiscipleItem[2]*raiseIndex[2], preSaleDurance, timePass);\n', '                DiscipleItem[3] = _computePrice(DiscipleItem[3], DiscipleItem[3]*raiseIndex[2], preSaleDurance, timePass);\n', '                itemTimeStamp = endTime;\n', '            }\n', '            require(msg.value >= DiscipleItem[_rarity]*_num);\n', '            currentPrice = DiscipleItem[_rarity]*_num;\n', '            _brokerFeeDistribute(currentPrice, 2, _brokerId, _subBrokerId);\n', '        } else {\n', '            if(itemTimeStamp == 0) {\n', '                itemTimeStamp = uint(now);\n', '            }\n', '            currentPrice = _computePrice(DiscipleItem[_rarity], DiscipleItem[_rarity]*raiseIndex[2], preSaleDurance, safeSub(uint(now), startTime));\n', '            require(msg.value >= currentPrice*_num);\n', '            currentPrice = currentPrice*_num;\n', '            _brokerFeeDistribute(currentPrice, 2, _brokerId, _subBrokerId);\n', '        }\n', '        if(_rarity == 0) {\n', '            PlayerOwnRareItem[msg.sender] = safeAdd(PlayerOwnRareItem[msg.sender], _num);\n', '        } else if (_rarity == 1) {\n', '            PlayerOwnEpicItem[msg.sender] = safeAdd(PlayerOwnEpicItem[msg.sender], _num);\n', '        } else if (_rarity == 2) {\n', '            PlayerOwnLegendaryItem[msg.sender] = safeAdd(PlayerOwnLegendaryItem[msg.sender], _num);\n', '        } else if (_rarity == 3) {\n', '            PlayerOwnUniqueItem[msg.sender] = safeAdd(PlayerOwnUniqueItem[msg.sender], _num);\n', '        }\n', '        emit BuyDiscipleItem(msg.sender, _rarity, _num, currentPrice);\n', '    }   \n', '    \n', '    function buyGuardianRune(uint _rarity, uint _num, uint _brokerId, uint _subBrokerId) public payable whenNotPaused {\n', '        require(_rarity >= 0 && _rarity <= 3);\n', '        uint currentPrice;\n', '        if(pricePause == true) {\n', '            if(runeTimeStamp != 0 && runeTimeStamp != endTime) {\n', '                uint timePass = safeSub(endTime, startTime);\n', '                GuardianRune[0] = _computePrice(GuardianRune[0], GuardianRune[0]*raiseIndex[2], preSaleDurance, timePass);\n', '                GuardianRune[1] = _computePrice(GuardianRune[1], GuardianRune[1]*raiseIndex[2], preSaleDurance, timePass);\n', '                GuardianRune[2] = _computePrice(GuardianRune[2], GuardianRune[2]*raiseIndex[2], preSaleDurance, timePass);\n', '                GuardianRune[3] = _computePrice(GuardianRune[3], GuardianRune[3]*raiseIndex[2], preSaleDurance, timePass);\n', '                runeTimeStamp = endTime;\n', '            }\n', '            require(msg.value >= GuardianRune[_rarity]*_num);\n', '            currentPrice = GuardianRune[_rarity]*_num;\n', '            _brokerFeeDistribute(currentPrice, 2, _brokerId, _subBrokerId);\n', '        } else {\n', '            if(runeTimeStamp == 0) {\n', '                runeTimeStamp = uint(now);\n', '            }\n', '            currentPrice = _computePrice(GuardianRune[_rarity], GuardianRune[_rarity]*raiseIndex[2], preSaleDurance, safeSub(uint(now), startTime));\n', '            require(msg.value >= currentPrice*_num);\n', '            currentPrice = currentPrice*_num;\n', '            _brokerFeeDistribute(currentPrice, 2, _brokerId, _subBrokerId);\n', '        }\n', '        if(_rarity == 0) {\n', '            PlayerOwnRareRune[msg.sender] = safeAdd(PlayerOwnRareRune[msg.sender], _num);\n', '        } else if (_rarity == 1) {\n', '            PlayerOwnEpicRune[msg.sender] = safeAdd(PlayerOwnEpicRune[msg.sender], _num);\n', '        } else if (_rarity == 2) {\n', '            PlayerOwnLegendaryRune[msg.sender] = safeAdd(PlayerOwnLegendaryRune[msg.sender], _num);\n', '        } else if (_rarity == 3) {\n', '            PlayerOwnUniqueRune[msg.sender] = safeAdd(PlayerOwnUniqueRune[msg.sender], _num);\n', '        }\n', '        emit BuyGuardianRune(msg.sender, _rarity, _num, currentPrice);\n', '    }\n', '    \n', '    function setDiscipleItem(uint _rarity, uint _price) public onlyAdmin {\n', '        DiscipleItem[_rarity] = _price;\n', '        emit SetDiscipleItem(_rarity, _price);\n', '    }\n', '    \n', '    function setGuardianRune(uint _rarity, uint _price) public onlyAdmin {\n', '        GuardianRune[_rarity] = _price;\n', '        emit SetDiscipleItem(_rarity, _price);\n', '    }\n', '    \n', '    function getPlayerInventory(address _player) public view returns (\n', '        uint rareItem,\n', '        uint epicItem,\n', '        uint legendaryItem,\n', '        uint uniqueItem,\n', '        uint rareRune,\n', '        uint epicRune,\n', '        uint legendaryRune,\n', '        uint uniqueRune\n', '    ) {\n', '        rareItem = PlayerOwnRareItem[_player];\n', '        epicItem = PlayerOwnEpicItem[_player];\n', '        legendaryItem = PlayerOwnLegendaryItem[_player];\n', '        uniqueItem = PlayerOwnUniqueItem[_player];\n', '        rareRune = PlayerOwnRareRune[_player];\n', '        epicRune = PlayerOwnEpicRune[_player];\n', '        legendaryRune = PlayerOwnLegendaryRune[_player];\n', '        uniqueRune = PlayerOwnUniqueRune[_player];\n', '    }\n', '}\n', '\n', 'contract PreSale is PreSaleAssets {\n', '    constructor() public {\n', '        CEOAddress = msg.sender;\n', '        BrokerIdToBrokers[0].push(msg.sender);\n', '    }\n', '}']