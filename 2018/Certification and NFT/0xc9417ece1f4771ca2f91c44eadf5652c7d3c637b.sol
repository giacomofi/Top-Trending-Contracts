['pragma solidity ^0.4.18;\n', '\n', 'contract Manager {\n', '    address public ceo;\n', '    address public cfo;\n', '    address public coo;\n', '    address public cao;\n', '\n', '    event OwnershipTransferred(address previousCeo, address newCeo);\n', '    event Pause();\n', '    event Unpause();\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Manager() public {\n', '        coo = msg.sender; \n', '        cfo = 0x7810704C6197aFA95e940eF6F719dF32657AD5af;\n', '        ceo = 0x96C0815aF056c5294Ad368e3FBDb39a1c9Ae4e2B;\n', '        cao = 0xC4888491B404FfD15cA7F599D624b12a9D845725;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceo);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCOO() {\n', '        require(msg.sender == coo);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCAO() {\n', '        require(msg.sender == cao);\n', '        _;\n', '    }\n', '    \n', '    bool allowTransfer = false;\n', '    \n', '    function changeAllowTransferState() public onlyCOO {\n', '        if (allowTransfer) {\n', '            allowTransfer = false;\n', '        } else {\n', '            allowTransfer = true;\n', '        }\n', '    }\n', '    \n', '    modifier whenTransferAllowed() {\n', '        require(allowTransfer);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newCeo.\n', '    * @param newCeo The address to transfer ownership to.\n', '    */\n', '    function demiseCEO(address newCeo) public onlyCEO {\n', '        require(newCeo != address(0));\n', '        emit OwnershipTransferred(ceo, newCeo);\n', '        ceo = newCeo;\n', '    }\n', '\n', '    function setCFO(address newCfo) public onlyCEO {\n', '        require(newCfo != address(0));\n', '        cfo = newCfo;\n', '    }\n', '\n', '    function setCOO(address newCoo) public onlyCEO {\n', '        require(newCoo != address(0));\n', '        coo = newCoo;\n', '    }\n', '\n', '    function setCAO(address newCao) public onlyCEO {\n', '        require(newCao != address(0));\n', '        cao = newCao;\n', '    }\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    */\n', '    function pause() onlyCAO whenNotPaused public {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to unpause, returns to normal state\n', '    */\n', '    function unpause() onlyCAO whenPaused public {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', '\n', 'contract AlchemyBase is Manager {\n', '\n', '    // Assets of each account\n', '    mapping (address => bytes32[8]) assets;\n', '\n', '    // Event\n', '    event Transfer(address from, address to);\n', '\n', '    // Get all assets of a particular account\n', '    function assetOf(address account) public view returns(bytes32[8]) {\n', '        return assets[account];\n', '    }\n', '\n', '    function _checkAndAdd(bytes32 x, bytes32 y) internal pure returns(bytes32) {\n', '        bytes32 mask = bytes32(255); // 0x11111111\n', '\n', '        bytes32 result;\n', '\n', '        uint maskedX;\n', '        uint maskedY;\n', '        uint maskedResult;\n', '\n', '        for (uint i = 0; i < 31; i++) {\n', '            // Get current mask\n', '            if (i > 0) {\n', '                mask = mask << 8;\n', '            }\n', '\n', '            // Get masked values\n', '            maskedX = uint(x & mask);\n', '            maskedY = uint(y & mask);\n', '            maskedResult = maskedX + maskedY;\n', '\n', '            // Prevent overflow\n', '            require(maskedResult < (2 ** (8 * (i + 1))));\n', '\n', '            // Clear result digits in masked position\n', '            result = (result ^ mask) & result;\n', '\n', '            // Write to result\n', '            result = result | bytes32(maskedResult);\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    function _checkAndSub(bytes32 x, bytes32 y) internal pure returns(bytes32) {\n', '        bytes32 mask = bytes32(255); // 0x11111111\n', '\n', '        bytes32 result;\n', '\n', '        uint maskedX;\n', '        uint maskedY;\n', '        uint maskedResult;\n', '\n', '        for (uint i = 0; i < 31; i++) {\n', '            // Get current mask\n', '            if (i > 0) {\n', '                mask = mask << 8;\n', '            }\n', '\n', '            // Get masked values\n', '            maskedX = uint(x & mask);\n', '            maskedY = uint(y & mask);\n', '\n', '            // Ensure x >= y\n', '            require(maskedX >= maskedY);\n', '\n', '            // Calculate result\n', '            maskedResult = maskedX - maskedY;\n', '\n', '            // Clear result digits in masked position\n', '            result = (result ^ mask) & result;\n', '\n', '            // Write to result\n', '            result = result | bytes32(maskedResult);\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    // Transfer assets from one account to another\n', '    function transfer(address to, bytes32[8] value) public whenNotPaused whenTransferAllowed {\n', '        // One can not transfer assets to self\n', '        require(msg.sender != to);\n', '        bytes32[8] memory assetFrom = assets[msg.sender];\n', '        bytes32[8] memory assetTo = assets[to];\n', '\n', '        for (uint256 i = 0; i < 8; i++) {\n', '            assetFrom[i] = _checkAndSub(assetFrom[i], value[i]);\n', '            assetTo[i] = _checkAndAdd(assetTo[i], value[i]);\n', '        }\n', '\n', '        assets[msg.sender] = assetFrom;\n', '        assets[to] = assetTo;\n', '\n', '        // Emit the transfer event\n', '        emit Transfer(msg.sender, to);\n', '    }\n', '\n', '    // Withdraw ETH to the owner account. Ownable-->Pausable-->AlchemyBase\n', '    function withdrawETH() external onlyCAO {\n', '        cfo.transfer(address(this).balance);\n', '    }\n', '}\n', '\n', '\n', 'contract AlchemyPatent is AlchemyBase {\n', '\n', '    // patent struct\n', '    struct Patent {\n', '        // current patent owner\n', '        address patentOwner;\n', '        // the time when owner get the patent\n', '        uint256 beginTime;\n', '        // whether this patent is on sale\n', '        bool onSale; \n', '        // the sale price\n', '        uint256 price;\n', '        // last deal price\n', '        uint256 lastPrice;\n', '        // the time when this sale is put on\n', '        uint256 sellTime;\n', '    }\n', '\n', '    // Creator of each kind of asset\n', '    mapping (uint16 => Patent) public patents;\n', '\n', '    // patent fee ratio\n', '    // Values 0-10,000 map to 0%-100%\n', '    uint256 public feeRatio = 9705;\n', '\n', '    uint256 public patentValidTime = 2 days;\n', '    uint256 public patentSaleTimeDelay = 2 hours;\n', '\n', '    // Event\n', '    event RegisterCreator(address account, uint16 kind);\n', '    event SellPatent(uint16 assetId, uint256 sellPrice);\n', '    event ChangePatentSale(uint16 assetId, uint256 newPrice);\n', '    event BuyPatent(uint16 assetId, address buyer);\n', '\n', '    // set the patent fee ratio\n', '    function setPatentFee(uint256 newFeeRatio) external onlyCOO {\n', '        require(newFeeRatio <= 10000);\n', '        feeRatio = newFeeRatio;\n', '    }\n', '\n', '    // sell the patent\n', '    function sellPatent(uint16 assetId, uint256 sellPrice) public whenNotPaused {\n', '        Patent memory patent = patents[assetId];\n', '        require(patent.patentOwner == msg.sender);\n', '        require(sellPrice <= 2 * patent.lastPrice);\n', '        require(!patent.onSale);\n', '\n', '        patent.onSale = true;\n', '        patent.price = sellPrice;\n', '        patent.sellTime = now;\n', '\n', '        patents[assetId] = patent;\n', '\n', '        // Emit the event\n', '        emit SellPatent(assetId, sellPrice);\n', '    }\n', '\n', '    function publicSell(uint16 assetId) public whenNotPaused {\n', '        Patent memory patent = patents[assetId];\n', '        require(patent.patentOwner != address(0));  // this is a valid patent\n', '        require(!patent.onSale);\n', '        require(patent.beginTime + patentValidTime < now);\n', '\n', '        patent.onSale = true;\n', '        patent.price = patent.lastPrice;\n', '        patent.sellTime = now;\n', '\n', '        patents[assetId] = patent;\n', '\n', '        // Emit the event\n', '        emit SellPatent(assetId, patent.lastPrice);\n', '    }\n', '\n', '    // change sell price\n', '    function changePatentSale(uint16 assetId, uint256 newPrice) external whenNotPaused {\n', '        Patent memory patent = patents[assetId];\n', '        require(patent.patentOwner == msg.sender);\n', '        require(newPrice <= 2 * patent.lastPrice);\n', '        require(patent.onSale == true);\n', '\n', '        patent.price = newPrice;\n', '\n', '        patents[assetId] = patent;\n', '\n', '        // Emit the event\n', '        emit ChangePatentSale(assetId, newPrice);\n', '    }\n', '\n', '    // buy patent\n', '    function buyPatent(uint16 assetId) external payable whenNotPaused {\n', '        Patent memory patent = patents[assetId];\n', '        require(patent.patentOwner != address(0));  // this is a valid patent\n', '        require(patent.patentOwner != msg.sender);\n', '        require(patent.onSale);\n', '        require(msg.value >= patent.price);\n', '        require(now >= patent.sellTime + patentSaleTimeDelay);\n', '\n', '        patent.patentOwner.transfer(patent.price / 10000 * feeRatio);\n', '        patent.patentOwner = msg.sender;\n', '        patent.beginTime = now;\n', '        patent.onSale = false;\n', '        patent.lastPrice = patent.price;\n', '\n', '        patents[assetId] = patent;\n', '\n', '        //Emit the event\n', '        emit BuyPatent(assetId, msg.sender);\n', '    }\n', '}\n', '\n', 'contract ChemistryInterface {\n', '    function isChemistry() public pure returns (bool);\n', '\n', '    // function turnOnFurnace(bytes32 x0, bytes32 x1, bytes32 x2, bytes32 x3) public returns (bytes32 r0, bytes32 r1, bytes32 r2, bytes32 r3);\n', '    function turnOnFurnace(uint16[5] inputAssets, uint128 addition) public returns (uint16[5]);\n', '\n', '    function computeCooldownTime(uint128 typeAdd, uint256 baseTime) public returns (uint256);\n', '}\n', '\n', '\n', '\n', 'contract SkinInterface {\n', '    function getActiveSkin(address account) public view returns (uint128);\n', '}\n', '\n', '\n', '\n', 'contract AlchemySynthesize is AlchemyPatent {\n', '\n', '    // Synthesize formula\n', '    ChemistryInterface public chemistry;\n', '    SkinInterface public skinContract;\n', '\n', '    // Cooldown after submit a after submit a transformation request\n', '    uint256[9] public cooldownLevels = [\n', '        5 minutes,\n', '        10 minutes,\n', '        15 minutes,\n', '        20 minutes,\n', '        25 minutes,\n', '        30 minutes,\n', '        35 minutes,\n', '        40 minutes,\n', '        45 minutes\n', '    ];\n', '\n', '    // patent fee for each level \n', '    uint256[9] public pFees = [\n', '        0,\n', '        10 finney,\n', '        15 finney,\n', '        20 finney,\n', '        25 finney,\n', '        30 finney,\n', '        35 finney,\n', '        40 finney,\n', '        45 finney\n', '    ];\n', '\n', '    // alchemy furnace struct\n', '    struct Furnace {\n', '        // the pending assets for synthesize\n', '        uint16[5] pendingAssets;\n', '        // cooldown end time of synthesise\n', '        uint256 cooldownEndTime;\n', '        // whether this furnace is using\n', '        bool inSynthesization;\n', '    }\n', '\n', '    // furnace of each account\n', '    mapping (address => Furnace) public accountsToFurnace;\n', '\n', '    // alchemy level of each asset\n', '    mapping (uint16 => uint256) public assetLevel;\n', '\n', '    // Pre-paid ether for synthesization, will be returned to user if the synthesization failed (minus gas).\n', '    uint256 public prePaidFee = 1000000 * 3000000000; // (1million gas * 3 gwei)\n', '\n', '    bool public isSynthesizeAllowed = false;\n', '\n', '    // When a synthesization request starts, our daemon needs to call getSynthesizationResult() after cooldown.\n', '    // event SynthesizeStart(address account);\n', '    event AutoSynthesize(address account, uint256 cooldownEndTime);\n', '    event SynthesizeSuccess(address account);\n', '\n', '    // Initialize the asset level\n', '    function initializeLevel() public onlyCOO {\n', '        // Level of assets\n', '        uint8[9] memory levelSplits = [4,     // end of level 0. start of level is 0\n', '                                          19,    // end of level 1\n', '                                          46,    // end of level 2\n', '                                          82,    // end of level 3\n', '                                          125,   // end of level 4\n', '                                          156,\n', '                                          180,\n', '                                          195,\n', '                                          198];  // end of level 8\n', '        uint256 currentLevel = 0;\n', '        for (uint8 i = 0; i < 198; i ++) {\n', '            if (i == levelSplits[currentLevel]) {\n', '                currentLevel ++;\n', '            }\n', '            assetLevel[uint16(i)] = currentLevel;\n', '        }\n', '    }\n', '\n', '    function setAssetLevel(uint16 assetId, uint256 level) public onlyCOO {\n', '        assetLevel[assetId] = level;\n', '    }\n', '\n', '    function changeSynthesizeAllowed(bool newState) external onlyCOO {\n', '        isSynthesizeAllowed = newState;\n', '    }\n', '\n', '    // Get furnace information\n', '    function getFurnace(address account) public view returns (uint16[5], uint256, bool) {\n', '        return (accountsToFurnace[account].pendingAssets, accountsToFurnace[account].cooldownEndTime, accountsToFurnace[account].inSynthesization);\n', '    }\n', '\n', '    // Set chemistry science contract address\n', '    function setChemistryAddress(address chemistryAddress) external onlyCOO {\n', '        ChemistryInterface candidateContract = ChemistryInterface(chemistryAddress);\n', '\n', '        require(candidateContract.isChemistry());\n', '\n', '        chemistry = candidateContract;\n', '    }\n', '\n', '    // Set skin contract address\n', '    function setSkinContract(address skinAddress) external onlyCOO {\n', '        skinContract = SkinInterface(skinAddress);\n', '    }\n', '\n', '    // setPrePaidFee: set advance amount, only owner can call this\n', '    function setPrePaidFee(uint256 newPrePaidFee) external onlyCOO {\n', '        prePaidFee = newPrePaidFee;\n', '    }\n', '\n', '    // _isCooldownReady: check whether cooldown period has been passed\n', '    function _isCooldownReady(address account) internal view returns (bool) {\n', '        return (accountsToFurnace[account].cooldownEndTime <= now);\n', '    }\n', '\n', '    // synthesize: call _isCooldownReady, pending assets, fire SynthesizeStart event\n', '    function synthesize(uint16[5] inputAssets) public payable whenNotPaused {\n', '        require(isSynthesizeAllowed == true);\n', '        // Check msg.sender is not in another synthesizing process\n', '        require(accountsToFurnace[msg.sender].inSynthesization == false);\n', '\n', '        // Check whether assets are valid\n', '        bytes32[8] memory asset = assets[msg.sender];\n', '\n', '        bytes32 mask; // 0x11111111\n', '        uint256 maskedValue;\n', '        uint256 count;\n', '        bytes32 _asset;\n', '        uint256 pos;\n', '        uint256 maxLevel = 0;\n', '        uint256 totalFee = 0;\n', '        uint256 _assetLevel;\n', '        Patent memory _patent;\n', '        uint16 currentAsset;\n', '        \n', '        for (uint256 i = 0; i < 5; i++) {\n', '            currentAsset = inputAssets[i];\n', '            if (currentAsset < 248) {\n', '                _asset = asset[currentAsset / 31];\n', '                pos = currentAsset % 31;\n', '                mask = bytes32(255) << (8 * pos);\n', '                maskedValue = uint256(_asset & mask);\n', '\n', '                require(maskedValue >= (uint256(1) << (8*pos)));\n', '                maskedValue -= (uint256(1) << (8*pos));\n', '                _asset = ((_asset ^ mask) & _asset) | bytes32(maskedValue); \n', '                asset[currentAsset / 31] = _asset;\n', '                count += 1;\n', '\n', '                // handle patent fee\n', '                _assetLevel = assetLevel[currentAsset];\n', '                if (_assetLevel > maxLevel) {\n', '                    maxLevel = _assetLevel;\n', '                }\n', '\n', '                if (_assetLevel > 0) {\n', '                    _patent = patents[currentAsset];\n', '                    if (_patent.patentOwner != address(0) && _patent.patentOwner != msg.sender && !_patent.onSale && (_patent.beginTime + patentValidTime > now)) {\n', '                        _patent.patentOwner.transfer(pFees[_assetLevel] / 10000 * feeRatio);\n', '                        totalFee += pFees[_assetLevel];\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        require(msg.value >= prePaidFee + totalFee); \n', '\n', '        require(count >= 2 && count <= 5);\n', '\n', '        // Check whether cooldown has ends\n', '        require(_isCooldownReady(msg.sender));\n', '\n', '        uint128 skinType = skinContract.getActiveSkin(msg.sender);\n', '        uint256 _cooldownTime = chemistry.computeCooldownTime(skinType, cooldownLevels[maxLevel]);\n', '\n', '        accountsToFurnace[msg.sender].pendingAssets = inputAssets;\n', '        accountsToFurnace[msg.sender].cooldownEndTime = now + _cooldownTime;\n', '        accountsToFurnace[msg.sender].inSynthesization = true;         \n', '        assets[msg.sender] = asset;\n', '\n', '        // Emit SnthesizeStart event\n', '        // SynthesizeStart(msg.sender);\n', '        emit AutoSynthesize(msg.sender, accountsToFurnace[msg.sender].cooldownEndTime);\n', '    }\n', '\n', '    function getPatentFee(address account, uint16[5] inputAssets) external view returns (uint256) {\n', '\n', '        uint256 totalFee = 0;\n', '        uint256 _assetLevel;\n', '        Patent memory _patent;\n', '        uint16 currentAsset;\n', '        \n', '        for (uint256 i = 0; i < 5; i++) {\n', '            currentAsset = inputAssets[i];\n', '            if (currentAsset < 248) {\n', '\n', '                // handle patent fee\n', '                _assetLevel = assetLevel[currentAsset];\n', '                if (_assetLevel > 0) {\n', '                    _patent = patents[currentAsset];\n', '                    if (_patent.patentOwner != address(0) && _patent.patentOwner != account && !_patent.onSale && (_patent.beginTime + patentValidTime > now)) {\n', '                        totalFee += pFees[_assetLevel];\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        return totalFee;\n', '    }\n', '\n', '    // getSynthesizationResult: auto synthesize daemin call this. if cooldown time has passed, give final result\n', '    // Anyone can call this function, if they are willing to pay the gas\n', '    function getSynthesizationResult(address account) external whenNotPaused {\n', '\n', '        // Make sure this account is in synthesization\n', '        require(accountsToFurnace[account].inSynthesization);\n', '\n', '        // Make sure the cooldown has ends\n', '        require(_isCooldownReady(account));\n', '\n', '        // Get result using pending assets        \n', '        uint16[5] memory _pendingAssets = accountsToFurnace[account].pendingAssets;\n', '        uint128 skinType = skinContract.getActiveSkin(account);\n', '        uint16[5] memory resultAssets = chemistry.turnOnFurnace(_pendingAssets, skinType);\n', '\n', '        // Write result\n', '        bytes32[8] memory asset = assets[account];\n', '\n', '        bytes32 mask; // 0x11111111\n', '        uint256 maskedValue;\n', '        uint256 j;\n', '        uint256 pos;   \n', '\n', '        for (uint256 i = 0; i < 5; i++) {\n', '            if (resultAssets[i] < 248) {\n', '                j = resultAssets[i] / 31;\n', '                pos = resultAssets[i] % 31;\n', '                mask = bytes32(255) << (8 * pos);\n', '                maskedValue = uint256(asset[j] & mask);\n', '\n', '                require(maskedValue < (uint256(255) << (8*pos)));\n', '                maskedValue += (uint256(1) << (8*pos));\n', '                asset[j] = ((asset[j] ^ mask) & asset[j]) | bytes32(maskedValue); \n', '\n', '                // handle patent\n', '                if (resultAssets[i] > 3 && patents[resultAssets[i]].patentOwner == address(0)) {\n', '                    patents[resultAssets[i]] = Patent({patentOwner: account,\n', '                                                       beginTime: now,\n', '                                                       onSale: false,\n', '                                                       price: 0,\n', '                                                       lastPrice: 10 finney,\n', '                                                       sellTime: 0});\n', '                    // Emit the event\n', '                    emit RegisterCreator(account, resultAssets[i]);\n', '                }\n', '            }\n', '        }\n', '\n', '        // Mark this synthesization as finished\n', '        accountsToFurnace[account].inSynthesization = false;\n', '        assets[account] = asset;\n', '\n', '        emit SynthesizeSuccess(account);\n', '    }\n', '}\n', '\n', 'contract AlchemyMinting is AlchemySynthesize {\n', '\n', '    // Limit the nubmer of zero order assets the owner can create every day\n', '    uint256 public zoDailyLimit = 2500; // we can create 4 * 2500 = 10000 0-order asset each day\n', '    uint256[4] public zoCreated;\n', '    \n', '    // Limit the number each account can buy every day\n', '    mapping(address => bytes32) public accountsBoughtZoAsset;\n', '    mapping(address => uint256) public accountsZoLastRefreshTime;\n', '\n', '    // Price of zero order assets\n', '    uint256 public zoPrice = 1 finney;\n', '\n', '    // Last daily limit refresh time\n', '    uint256 public zoLastRefreshTime = now;\n', '\n', '    // Event\n', '    event BuyZeroOrderAsset(address account, bytes32 values);\n', '\n', '    // To ensure scarcity, we are unable to change the max numbers of zo assets every day.\n', '    // We are only able to modify the price\n', '    function setZoPrice(uint256 newPrice) external onlyCOO {\n', '        zoPrice = newPrice;\n', '    }\n', '\n', '    // Buy zo assets from us\n', '    function buyZoAssets(bytes32 values) external payable whenNotPaused {\n', '        // Check whether we need to refresh the daily limit\n', '        bytes32 history = accountsBoughtZoAsset[msg.sender];\n', '        if (accountsZoLastRefreshTime[msg.sender] == uint256(0)) {\n', '            // This account&#39;s first time to buy zo asset, we do not need to clear accountsBoughtZoAsset\n', '            accountsZoLastRefreshTime[msg.sender] = zoLastRefreshTime;\n', '        } else {\n', '            if (accountsZoLastRefreshTime[msg.sender] < zoLastRefreshTime) {\n', '                history = bytes32(0);\n', '                accountsZoLastRefreshTime[msg.sender] = zoLastRefreshTime;\n', '            }\n', '        }\n', ' \n', '        uint256 currentCount = 0;\n', '        uint256 count = 0;\n', '\n', '        bytes32 mask = bytes32(255); // 0x11111111\n', '        uint256 maskedValue;\n', '        uint256 maskedResult;\n', '\n', '        bytes32 asset = assets[msg.sender][0];\n', '\n', '        for (uint256 i = 0; i < 4; i++) {\n', '            if (i > 0) {\n', '                mask = mask << 8;\n', '            }\n', '            maskedValue = uint256(values & mask);\n', '            currentCount = maskedValue / 2 ** (8 * i);\n', '            count += currentCount;\n', '\n', '            // Check whether this account has bought too many assets\n', '            maskedResult = uint256(history & mask); \n', '            maskedResult += maskedValue;\n', '            require(maskedResult < (2 ** (8 * (i + 1))));\n', '\n', '            // Update account bought history\n', '            history = ((history ^ mask) & history) | bytes32(maskedResult);\n', '\n', '            // Check whether this account will have too many assets\n', '            maskedResult = uint256(asset & mask);\n', '            maskedResult += maskedValue;\n', '            require(maskedResult < (2 ** (8 * (i + 1))));\n', '\n', '            // Update user asset\n', '            asset = ((asset ^ mask) & asset) | bytes32(maskedResult);\n', '\n', '            // Check whether we have enough assets to sell\n', '            require(zoCreated[i] + currentCount <= zoDailyLimit);\n', '\n', '            // Update our creation history\n', '            zoCreated[i] += currentCount;\n', '        }\n', '\n', '        // Ensure this account buy at least one zo asset\n', '        require(count > 0);\n', '\n', '        // Check whether there are enough money for payment\n', '        require(msg.value >= count * zoPrice);\n', '\n', '        // Write updated user asset\n', '        assets[msg.sender][0] = asset;\n', '\n', '        // Write updated history\n', '        accountsBoughtZoAsset[msg.sender] = history;\n', '        \n', '        // Emit BuyZeroOrderAsset event\n', '        emit BuyZeroOrderAsset(msg.sender, values);\n', '\n', '    }\n', '\n', '    // Our daemon will refresh daily limit\n', '    function clearZoDailyLimit() external onlyCOO {\n', '        uint256 nextDay = zoLastRefreshTime + 1 days;\n', '        if (now > nextDay) {\n', '            zoLastRefreshTime = nextDay;\n', '            for (uint256 i = 0; i < 4; i++) {\n', '                zoCreated[i] =0;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract AlchemyMarket is AlchemyMinting {\n', '\n', '    // Sale order struct\n', '    struct SaleOrder {\n', '        // Asset id to be sold\n', '        uint64 assetId;\n', '        // Sale amount\n', '        uint64 amount;\n', '        // Desired price\n', '        uint128 desiredPrice;\n', '        // Seller\n', '        address seller; \n', '    }\n', '\n', '    // Max number of sale orders of each account \n', '    uint128 public maxSaleNum = 20;\n', '\n', '    // Cut ratio for a transaction\n', '    // Values 0-10,000 map to 0%-100%\n', '    uint256 public trCut = 275;\n', '\n', '    // Next sale id\n', '    uint256 public nextSaleId = 1;\n', '\n', '    // Sale orders list \n', '    mapping (uint256 => SaleOrder) public saleOrderList;\n', '\n', '    // Sale information of each account\n', '    mapping (address => uint256) public accountToSaleNum;\n', '\n', '    // events\n', '    event PutOnSale(address account, uint256 saleId);\n', '    event WithdrawSale(address account, uint256 saleId);\n', '    event ChangeSale(address account, uint256 saleId);\n', '    event BuyInMarket(address buyer, uint256 saleId, uint256 amount);\n', '    event SaleClear(uint256 saleId);\n', '\n', '    // functions\n', '    function setTrCut(uint256 newCut) public onlyCOO {\n', '        trCut = newCut;\n', '    }\n', '\n', '    // Put asset on sale\n', '    function putOnSale(uint256 assetId, uint256 amount, uint256 price) external whenNotPaused {\n', '        // One account can have no more than maxSaleNum sale orders\n', '        require(accountToSaleNum[msg.sender] < maxSaleNum);\n', '\n', '        // check whether zero order asset is to be sold \n', '        // which is not allowed\n', '        require(assetId > 3 && assetId < 248);\n', '        require(amount > 0 && amount < 256);\n', '\n', '        uint256 assetFloor = assetId / 31;\n', '        uint256 assetPos = assetId - 31 * assetFloor;\n', '        bytes32 allAsset = assets[msg.sender][assetFloor];\n', '\n', '        bytes32 mask = bytes32(255) << (8 * assetPos); // 0x11111111\n', '        uint256 maskedValue;\n', '        uint256 maskedResult;\n', '        uint256 addAmount = amount << (8 * assetPos);\n', '\n', '        // check whether there are enough unpending assets to sell\n', '        maskedValue = uint256(allAsset & mask);\n', '        require(addAmount <= maskedValue);\n', '\n', '        // Remove assets to be sold from owner\n', '        maskedResult = maskedValue - addAmount;\n', '        allAsset = ((allAsset ^ mask) & allAsset) | bytes32(maskedResult);\n', '\n', '        assets[msg.sender][assetFloor] = allAsset;\n', '\n', '        // Put on sale\n', '        SaleOrder memory saleorder = SaleOrder(\n', '            uint64(assetId),\n', '            uint64(amount),\n', '            uint128(price),\n', '            msg.sender\n', '        );\n', '\n', '        saleOrderList[nextSaleId] = saleorder;\n', '        nextSaleId += 1;\n', '\n', '        accountToSaleNum[msg.sender] += 1;\n', '\n', '        // Emit the Approval event\n', '        emit PutOnSale(msg.sender, nextSaleId-1);\n', '    }\n', '  \n', '    // Withdraw an sale order\n', '    function withdrawSale(uint256 saleId) external whenNotPaused {\n', '        // Can only withdraw self&#39;s sale order\n', '        require(saleOrderList[saleId].seller == msg.sender);\n', '\n', '        uint256 assetId = uint256(saleOrderList[saleId].assetId);\n', '        uint256 assetFloor = assetId / 31;\n', '        uint256 assetPos = assetId - 31 * assetFloor;\n', '        bytes32 allAsset = assets[msg.sender][assetFloor];\n', '\n', '        bytes32 mask = bytes32(255) << (8 * assetPos); // 0x11111111\n', '        uint256 maskedValue;\n', '        uint256 maskedResult;\n', '        uint256 addAmount = uint256(saleOrderList[saleId].amount) << (8 * assetPos);\n', '\n', '        // check whether this account will have too many assets\n', '        maskedValue = uint256(allAsset & mask);\n', '        require(addAmount + maskedValue < 2**(8 * (assetPos + 1)));\n', '\n', '        // Retransfer asset to be sold from owner\n', '        maskedResult = maskedValue + addAmount;\n', '        allAsset = ((allAsset ^ mask) & allAsset) | bytes32(maskedResult);\n', '\n', '        assets[msg.sender][assetFloor] = allAsset;\n', '\n', '        // Delete sale order\n', '        delete saleOrderList[saleId];\n', '\n', '        accountToSaleNum[msg.sender] -= 1;\n', '\n', '        // Emit the cancel event\n', '        emit WithdrawSale(msg.sender, saleId);\n', '    }\n', ' \n', '//     // Change sale order\n', '//     function changeSale(uint256 assetId, uint256 amount, uint256 price, uint256 saleId) external whenNotPaused {\n', '//         // Check if msg sender is the seller\n', '//         require(msg.sender == saleOrderList[saleId].seller);\n', '// \n', '//     }\n', ' \n', '    // Buy assets in market\n', '    function buyInMarket(uint256 saleId, uint256 amount) external payable whenNotPaused {\n', '        address seller = saleOrderList[saleId].seller;\n', '        // Check whether the saleId is a valid sale order\n', '        require(seller != address(0));\n', '\n', '        // Check the sender isn&#39;t the seller\n', '        require(msg.sender != seller);\n', '\n', '        require(saleOrderList[saleId].amount >= uint64(amount));\n', '\n', '        // Check whether pay value is enough\n', '        require(msg.value / saleOrderList[saleId].desiredPrice >= amount);\n', '\n', '        uint256 totalprice = amount * saleOrderList[saleId].desiredPrice;\n', '\n', '        uint64 assetId = saleOrderList[saleId].assetId;\n', '\n', '        uint256 assetFloor = assetId / 31;\n', '        uint256 assetPos = assetId - 31 * assetFloor;\n', '        bytes32 allAsset = assets[msg.sender][assetFloor];\n', '\n', '        bytes32 mask = bytes32(255) << (8 * assetPos); // 0x11111111\n', '        uint256 maskedValue;\n', '        uint256 maskedResult;\n', '        uint256 addAmount = amount << (8 * assetPos);\n', '\n', '        // check whether this account will have too many assets\n', '        maskedValue = uint256(allAsset & mask);\n', '        require(addAmount + maskedValue < 2**(8 * (assetPos + 1)));\n', '\n', '        // Transfer assets to buyer\n', '        maskedResult = maskedValue + addAmount;\n', '        allAsset = ((allAsset ^ mask) & allAsset) | bytes32(maskedResult);\n', '\n', '        assets[msg.sender][assetFloor] = allAsset;\n', '\n', '        saleOrderList[saleId].amount -= uint64(amount);\n', '\n', '        // Cut and then send the proceeds to seller\n', '        uint256 sellerProceeds = totalprice - _computeCut(totalprice);\n', '\n', '        seller.transfer(sellerProceeds);\n', '\n', '        // Emit the buy event\n', '        emit BuyInMarket(msg.sender, saleId, amount);\n', '\n', '        // If the sale has complete, clear this order\n', '        if (saleOrderList[saleId].amount == 0) {\n', '            accountToSaleNum[seller] -= 1;\n', '            delete saleOrderList[saleId];\n', '\n', '            // Emit the clear event\n', '            emit SaleClear(saleId);\n', '        }\n', '    }\n', '\n', '    // Compute the marketCut\n', '    function _computeCut(uint256 _price) internal view returns (uint256) {\n', '        return _price / 10000 * trCut;\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract Manager {\n', '    address public ceo;\n', '    address public cfo;\n', '    address public coo;\n', '    address public cao;\n', '\n', '    event OwnershipTransferred(address previousCeo, address newCeo);\n', '    event Pause();\n', '    event Unpause();\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Manager() public {\n', '        coo = msg.sender; \n', '        cfo = 0x7810704C6197aFA95e940eF6F719dF32657AD5af;\n', '        ceo = 0x96C0815aF056c5294Ad368e3FBDb39a1c9Ae4e2B;\n', '        cao = 0xC4888491B404FfD15cA7F599D624b12a9D845725;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceo);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCOO() {\n', '        require(msg.sender == coo);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCAO() {\n', '        require(msg.sender == cao);\n', '        _;\n', '    }\n', '    \n', '    bool allowTransfer = false;\n', '    \n', '    function changeAllowTransferState() public onlyCOO {\n', '        if (allowTransfer) {\n', '            allowTransfer = false;\n', '        } else {\n', '            allowTransfer = true;\n', '        }\n', '    }\n', '    \n', '    modifier whenTransferAllowed() {\n', '        require(allowTransfer);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newCeo.\n', '    * @param newCeo The address to transfer ownership to.\n', '    */\n', '    function demiseCEO(address newCeo) public onlyCEO {\n', '        require(newCeo != address(0));\n', '        emit OwnershipTransferred(ceo, newCeo);\n', '        ceo = newCeo;\n', '    }\n', '\n', '    function setCFO(address newCfo) public onlyCEO {\n', '        require(newCfo != address(0));\n', '        cfo = newCfo;\n', '    }\n', '\n', '    function setCOO(address newCoo) public onlyCEO {\n', '        require(newCoo != address(0));\n', '        coo = newCoo;\n', '    }\n', '\n', '    function setCAO(address newCao) public onlyCEO {\n', '        require(newCao != address(0));\n', '        cao = newCao;\n', '    }\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    */\n', '    function pause() onlyCAO whenNotPaused public {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to unpause, returns to normal state\n', '    */\n', '    function unpause() onlyCAO whenPaused public {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', '\n', 'contract AlchemyBase is Manager {\n', '\n', '    // Assets of each account\n', '    mapping (address => bytes32[8]) assets;\n', '\n', '    // Event\n', '    event Transfer(address from, address to);\n', '\n', '    // Get all assets of a particular account\n', '    function assetOf(address account) public view returns(bytes32[8]) {\n', '        return assets[account];\n', '    }\n', '\n', '    function _checkAndAdd(bytes32 x, bytes32 y) internal pure returns(bytes32) {\n', '        bytes32 mask = bytes32(255); // 0x11111111\n', '\n', '        bytes32 result;\n', '\n', '        uint maskedX;\n', '        uint maskedY;\n', '        uint maskedResult;\n', '\n', '        for (uint i = 0; i < 31; i++) {\n', '            // Get current mask\n', '            if (i > 0) {\n', '                mask = mask << 8;\n', '            }\n', '\n', '            // Get masked values\n', '            maskedX = uint(x & mask);\n', '            maskedY = uint(y & mask);\n', '            maskedResult = maskedX + maskedY;\n', '\n', '            // Prevent overflow\n', '            require(maskedResult < (2 ** (8 * (i + 1))));\n', '\n', '            // Clear result digits in masked position\n', '            result = (result ^ mask) & result;\n', '\n', '            // Write to result\n', '            result = result | bytes32(maskedResult);\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    function _checkAndSub(bytes32 x, bytes32 y) internal pure returns(bytes32) {\n', '        bytes32 mask = bytes32(255); // 0x11111111\n', '\n', '        bytes32 result;\n', '\n', '        uint maskedX;\n', '        uint maskedY;\n', '        uint maskedResult;\n', '\n', '        for (uint i = 0; i < 31; i++) {\n', '            // Get current mask\n', '            if (i > 0) {\n', '                mask = mask << 8;\n', '            }\n', '\n', '            // Get masked values\n', '            maskedX = uint(x & mask);\n', '            maskedY = uint(y & mask);\n', '\n', '            // Ensure x >= y\n', '            require(maskedX >= maskedY);\n', '\n', '            // Calculate result\n', '            maskedResult = maskedX - maskedY;\n', '\n', '            // Clear result digits in masked position\n', '            result = (result ^ mask) & result;\n', '\n', '            // Write to result\n', '            result = result | bytes32(maskedResult);\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    // Transfer assets from one account to another\n', '    function transfer(address to, bytes32[8] value) public whenNotPaused whenTransferAllowed {\n', '        // One can not transfer assets to self\n', '        require(msg.sender != to);\n', '        bytes32[8] memory assetFrom = assets[msg.sender];\n', '        bytes32[8] memory assetTo = assets[to];\n', '\n', '        for (uint256 i = 0; i < 8; i++) {\n', '            assetFrom[i] = _checkAndSub(assetFrom[i], value[i]);\n', '            assetTo[i] = _checkAndAdd(assetTo[i], value[i]);\n', '        }\n', '\n', '        assets[msg.sender] = assetFrom;\n', '        assets[to] = assetTo;\n', '\n', '        // Emit the transfer event\n', '        emit Transfer(msg.sender, to);\n', '    }\n', '\n', '    // Withdraw ETH to the owner account. Ownable-->Pausable-->AlchemyBase\n', '    function withdrawETH() external onlyCAO {\n', '        cfo.transfer(address(this).balance);\n', '    }\n', '}\n', '\n', '\n', 'contract AlchemyPatent is AlchemyBase {\n', '\n', '    // patent struct\n', '    struct Patent {\n', '        // current patent owner\n', '        address patentOwner;\n', '        // the time when owner get the patent\n', '        uint256 beginTime;\n', '        // whether this patent is on sale\n', '        bool onSale; \n', '        // the sale price\n', '        uint256 price;\n', '        // last deal price\n', '        uint256 lastPrice;\n', '        // the time when this sale is put on\n', '        uint256 sellTime;\n', '    }\n', '\n', '    // Creator of each kind of asset\n', '    mapping (uint16 => Patent) public patents;\n', '\n', '    // patent fee ratio\n', '    // Values 0-10,000 map to 0%-100%\n', '    uint256 public feeRatio = 9705;\n', '\n', '    uint256 public patentValidTime = 2 days;\n', '    uint256 public patentSaleTimeDelay = 2 hours;\n', '\n', '    // Event\n', '    event RegisterCreator(address account, uint16 kind);\n', '    event SellPatent(uint16 assetId, uint256 sellPrice);\n', '    event ChangePatentSale(uint16 assetId, uint256 newPrice);\n', '    event BuyPatent(uint16 assetId, address buyer);\n', '\n', '    // set the patent fee ratio\n', '    function setPatentFee(uint256 newFeeRatio) external onlyCOO {\n', '        require(newFeeRatio <= 10000);\n', '        feeRatio = newFeeRatio;\n', '    }\n', '\n', '    // sell the patent\n', '    function sellPatent(uint16 assetId, uint256 sellPrice) public whenNotPaused {\n', '        Patent memory patent = patents[assetId];\n', '        require(patent.patentOwner == msg.sender);\n', '        require(sellPrice <= 2 * patent.lastPrice);\n', '        require(!patent.onSale);\n', '\n', '        patent.onSale = true;\n', '        patent.price = sellPrice;\n', '        patent.sellTime = now;\n', '\n', '        patents[assetId] = patent;\n', '\n', '        // Emit the event\n', '        emit SellPatent(assetId, sellPrice);\n', '    }\n', '\n', '    function publicSell(uint16 assetId) public whenNotPaused {\n', '        Patent memory patent = patents[assetId];\n', '        require(patent.patentOwner != address(0));  // this is a valid patent\n', '        require(!patent.onSale);\n', '        require(patent.beginTime + patentValidTime < now);\n', '\n', '        patent.onSale = true;\n', '        patent.price = patent.lastPrice;\n', '        patent.sellTime = now;\n', '\n', '        patents[assetId] = patent;\n', '\n', '        // Emit the event\n', '        emit SellPatent(assetId, patent.lastPrice);\n', '    }\n', '\n', '    // change sell price\n', '    function changePatentSale(uint16 assetId, uint256 newPrice) external whenNotPaused {\n', '        Patent memory patent = patents[assetId];\n', '        require(patent.patentOwner == msg.sender);\n', '        require(newPrice <= 2 * patent.lastPrice);\n', '        require(patent.onSale == true);\n', '\n', '        patent.price = newPrice;\n', '\n', '        patents[assetId] = patent;\n', '\n', '        // Emit the event\n', '        emit ChangePatentSale(assetId, newPrice);\n', '    }\n', '\n', '    // buy patent\n', '    function buyPatent(uint16 assetId) external payable whenNotPaused {\n', '        Patent memory patent = patents[assetId];\n', '        require(patent.patentOwner != address(0));  // this is a valid patent\n', '        require(patent.patentOwner != msg.sender);\n', '        require(patent.onSale);\n', '        require(msg.value >= patent.price);\n', '        require(now >= patent.sellTime + patentSaleTimeDelay);\n', '\n', '        patent.patentOwner.transfer(patent.price / 10000 * feeRatio);\n', '        patent.patentOwner = msg.sender;\n', '        patent.beginTime = now;\n', '        patent.onSale = false;\n', '        patent.lastPrice = patent.price;\n', '\n', '        patents[assetId] = patent;\n', '\n', '        //Emit the event\n', '        emit BuyPatent(assetId, msg.sender);\n', '    }\n', '}\n', '\n', 'contract ChemistryInterface {\n', '    function isChemistry() public pure returns (bool);\n', '\n', '    // function turnOnFurnace(bytes32 x0, bytes32 x1, bytes32 x2, bytes32 x3) public returns (bytes32 r0, bytes32 r1, bytes32 r2, bytes32 r3);\n', '    function turnOnFurnace(uint16[5] inputAssets, uint128 addition) public returns (uint16[5]);\n', '\n', '    function computeCooldownTime(uint128 typeAdd, uint256 baseTime) public returns (uint256);\n', '}\n', '\n', '\n', '\n', 'contract SkinInterface {\n', '    function getActiveSkin(address account) public view returns (uint128);\n', '}\n', '\n', '\n', '\n', 'contract AlchemySynthesize is AlchemyPatent {\n', '\n', '    // Synthesize formula\n', '    ChemistryInterface public chemistry;\n', '    SkinInterface public skinContract;\n', '\n', '    // Cooldown after submit a after submit a transformation request\n', '    uint256[9] public cooldownLevels = [\n', '        5 minutes,\n', '        10 minutes,\n', '        15 minutes,\n', '        20 minutes,\n', '        25 minutes,\n', '        30 minutes,\n', '        35 minutes,\n', '        40 minutes,\n', '        45 minutes\n', '    ];\n', '\n', '    // patent fee for each level \n', '    uint256[9] public pFees = [\n', '        0,\n', '        10 finney,\n', '        15 finney,\n', '        20 finney,\n', '        25 finney,\n', '        30 finney,\n', '        35 finney,\n', '        40 finney,\n', '        45 finney\n', '    ];\n', '\n', '    // alchemy furnace struct\n', '    struct Furnace {\n', '        // the pending assets for synthesize\n', '        uint16[5] pendingAssets;\n', '        // cooldown end time of synthesise\n', '        uint256 cooldownEndTime;\n', '        // whether this furnace is using\n', '        bool inSynthesization;\n', '    }\n', '\n', '    // furnace of each account\n', '    mapping (address => Furnace) public accountsToFurnace;\n', '\n', '    // alchemy level of each asset\n', '    mapping (uint16 => uint256) public assetLevel;\n', '\n', '    // Pre-paid ether for synthesization, will be returned to user if the synthesization failed (minus gas).\n', '    uint256 public prePaidFee = 1000000 * 3000000000; // (1million gas * 3 gwei)\n', '\n', '    bool public isSynthesizeAllowed = false;\n', '\n', '    // When a synthesization request starts, our daemon needs to call getSynthesizationResult() after cooldown.\n', '    // event SynthesizeStart(address account);\n', '    event AutoSynthesize(address account, uint256 cooldownEndTime);\n', '    event SynthesizeSuccess(address account);\n', '\n', '    // Initialize the asset level\n', '    function initializeLevel() public onlyCOO {\n', '        // Level of assets\n', '        uint8[9] memory levelSplits = [4,     // end of level 0. start of level is 0\n', '                                          19,    // end of level 1\n', '                                          46,    // end of level 2\n', '                                          82,    // end of level 3\n', '                                          125,   // end of level 4\n', '                                          156,\n', '                                          180,\n', '                                          195,\n', '                                          198];  // end of level 8\n', '        uint256 currentLevel = 0;\n', '        for (uint8 i = 0; i < 198; i ++) {\n', '            if (i == levelSplits[currentLevel]) {\n', '                currentLevel ++;\n', '            }\n', '            assetLevel[uint16(i)] = currentLevel;\n', '        }\n', '    }\n', '\n', '    function setAssetLevel(uint16 assetId, uint256 level) public onlyCOO {\n', '        assetLevel[assetId] = level;\n', '    }\n', '\n', '    function changeSynthesizeAllowed(bool newState) external onlyCOO {\n', '        isSynthesizeAllowed = newState;\n', '    }\n', '\n', '    // Get furnace information\n', '    function getFurnace(address account) public view returns (uint16[5], uint256, bool) {\n', '        return (accountsToFurnace[account].pendingAssets, accountsToFurnace[account].cooldownEndTime, accountsToFurnace[account].inSynthesization);\n', '    }\n', '\n', '    // Set chemistry science contract address\n', '    function setChemistryAddress(address chemistryAddress) external onlyCOO {\n', '        ChemistryInterface candidateContract = ChemistryInterface(chemistryAddress);\n', '\n', '        require(candidateContract.isChemistry());\n', '\n', '        chemistry = candidateContract;\n', '    }\n', '\n', '    // Set skin contract address\n', '    function setSkinContract(address skinAddress) external onlyCOO {\n', '        skinContract = SkinInterface(skinAddress);\n', '    }\n', '\n', '    // setPrePaidFee: set advance amount, only owner can call this\n', '    function setPrePaidFee(uint256 newPrePaidFee) external onlyCOO {\n', '        prePaidFee = newPrePaidFee;\n', '    }\n', '\n', '    // _isCooldownReady: check whether cooldown period has been passed\n', '    function _isCooldownReady(address account) internal view returns (bool) {\n', '        return (accountsToFurnace[account].cooldownEndTime <= now);\n', '    }\n', '\n', '    // synthesize: call _isCooldownReady, pending assets, fire SynthesizeStart event\n', '    function synthesize(uint16[5] inputAssets) public payable whenNotPaused {\n', '        require(isSynthesizeAllowed == true);\n', '        // Check msg.sender is not in another synthesizing process\n', '        require(accountsToFurnace[msg.sender].inSynthesization == false);\n', '\n', '        // Check whether assets are valid\n', '        bytes32[8] memory asset = assets[msg.sender];\n', '\n', '        bytes32 mask; // 0x11111111\n', '        uint256 maskedValue;\n', '        uint256 count;\n', '        bytes32 _asset;\n', '        uint256 pos;\n', '        uint256 maxLevel = 0;\n', '        uint256 totalFee = 0;\n', '        uint256 _assetLevel;\n', '        Patent memory _patent;\n', '        uint16 currentAsset;\n', '        \n', '        for (uint256 i = 0; i < 5; i++) {\n', '            currentAsset = inputAssets[i];\n', '            if (currentAsset < 248) {\n', '                _asset = asset[currentAsset / 31];\n', '                pos = currentAsset % 31;\n', '                mask = bytes32(255) << (8 * pos);\n', '                maskedValue = uint256(_asset & mask);\n', '\n', '                require(maskedValue >= (uint256(1) << (8*pos)));\n', '                maskedValue -= (uint256(1) << (8*pos));\n', '                _asset = ((_asset ^ mask) & _asset) | bytes32(maskedValue); \n', '                asset[currentAsset / 31] = _asset;\n', '                count += 1;\n', '\n', '                // handle patent fee\n', '                _assetLevel = assetLevel[currentAsset];\n', '                if (_assetLevel > maxLevel) {\n', '                    maxLevel = _assetLevel;\n', '                }\n', '\n', '                if (_assetLevel > 0) {\n', '                    _patent = patents[currentAsset];\n', '                    if (_patent.patentOwner != address(0) && _patent.patentOwner != msg.sender && !_patent.onSale && (_patent.beginTime + patentValidTime > now)) {\n', '                        _patent.patentOwner.transfer(pFees[_assetLevel] / 10000 * feeRatio);\n', '                        totalFee += pFees[_assetLevel];\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        require(msg.value >= prePaidFee + totalFee); \n', '\n', '        require(count >= 2 && count <= 5);\n', '\n', '        // Check whether cooldown has ends\n', '        require(_isCooldownReady(msg.sender));\n', '\n', '        uint128 skinType = skinContract.getActiveSkin(msg.sender);\n', '        uint256 _cooldownTime = chemistry.computeCooldownTime(skinType, cooldownLevels[maxLevel]);\n', '\n', '        accountsToFurnace[msg.sender].pendingAssets = inputAssets;\n', '        accountsToFurnace[msg.sender].cooldownEndTime = now + _cooldownTime;\n', '        accountsToFurnace[msg.sender].inSynthesization = true;         \n', '        assets[msg.sender] = asset;\n', '\n', '        // Emit SnthesizeStart event\n', '        // SynthesizeStart(msg.sender);\n', '        emit AutoSynthesize(msg.sender, accountsToFurnace[msg.sender].cooldownEndTime);\n', '    }\n', '\n', '    function getPatentFee(address account, uint16[5] inputAssets) external view returns (uint256) {\n', '\n', '        uint256 totalFee = 0;\n', '        uint256 _assetLevel;\n', '        Patent memory _patent;\n', '        uint16 currentAsset;\n', '        \n', '        for (uint256 i = 0; i < 5; i++) {\n', '            currentAsset = inputAssets[i];\n', '            if (currentAsset < 248) {\n', '\n', '                // handle patent fee\n', '                _assetLevel = assetLevel[currentAsset];\n', '                if (_assetLevel > 0) {\n', '                    _patent = patents[currentAsset];\n', '                    if (_patent.patentOwner != address(0) && _patent.patentOwner != account && !_patent.onSale && (_patent.beginTime + patentValidTime > now)) {\n', '                        totalFee += pFees[_assetLevel];\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        return totalFee;\n', '    }\n', '\n', '    // getSynthesizationResult: auto synthesize daemin call this. if cooldown time has passed, give final result\n', '    // Anyone can call this function, if they are willing to pay the gas\n', '    function getSynthesizationResult(address account) external whenNotPaused {\n', '\n', '        // Make sure this account is in synthesization\n', '        require(accountsToFurnace[account].inSynthesization);\n', '\n', '        // Make sure the cooldown has ends\n', '        require(_isCooldownReady(account));\n', '\n', '        // Get result using pending assets        \n', '        uint16[5] memory _pendingAssets = accountsToFurnace[account].pendingAssets;\n', '        uint128 skinType = skinContract.getActiveSkin(account);\n', '        uint16[5] memory resultAssets = chemistry.turnOnFurnace(_pendingAssets, skinType);\n', '\n', '        // Write result\n', '        bytes32[8] memory asset = assets[account];\n', '\n', '        bytes32 mask; // 0x11111111\n', '        uint256 maskedValue;\n', '        uint256 j;\n', '        uint256 pos;   \n', '\n', '        for (uint256 i = 0; i < 5; i++) {\n', '            if (resultAssets[i] < 248) {\n', '                j = resultAssets[i] / 31;\n', '                pos = resultAssets[i] % 31;\n', '                mask = bytes32(255) << (8 * pos);\n', '                maskedValue = uint256(asset[j] & mask);\n', '\n', '                require(maskedValue < (uint256(255) << (8*pos)));\n', '                maskedValue += (uint256(1) << (8*pos));\n', '                asset[j] = ((asset[j] ^ mask) & asset[j]) | bytes32(maskedValue); \n', '\n', '                // handle patent\n', '                if (resultAssets[i] > 3 && patents[resultAssets[i]].patentOwner == address(0)) {\n', '                    patents[resultAssets[i]] = Patent({patentOwner: account,\n', '                                                       beginTime: now,\n', '                                                       onSale: false,\n', '                                                       price: 0,\n', '                                                       lastPrice: 10 finney,\n', '                                                       sellTime: 0});\n', '                    // Emit the event\n', '                    emit RegisterCreator(account, resultAssets[i]);\n', '                }\n', '            }\n', '        }\n', '\n', '        // Mark this synthesization as finished\n', '        accountsToFurnace[account].inSynthesization = false;\n', '        assets[account] = asset;\n', '\n', '        emit SynthesizeSuccess(account);\n', '    }\n', '}\n', '\n', 'contract AlchemyMinting is AlchemySynthesize {\n', '\n', '    // Limit the nubmer of zero order assets the owner can create every day\n', '    uint256 public zoDailyLimit = 2500; // we can create 4 * 2500 = 10000 0-order asset each day\n', '    uint256[4] public zoCreated;\n', '    \n', '    // Limit the number each account can buy every day\n', '    mapping(address => bytes32) public accountsBoughtZoAsset;\n', '    mapping(address => uint256) public accountsZoLastRefreshTime;\n', '\n', '    // Price of zero order assets\n', '    uint256 public zoPrice = 1 finney;\n', '\n', '    // Last daily limit refresh time\n', '    uint256 public zoLastRefreshTime = now;\n', '\n', '    // Event\n', '    event BuyZeroOrderAsset(address account, bytes32 values);\n', '\n', '    // To ensure scarcity, we are unable to change the max numbers of zo assets every day.\n', '    // We are only able to modify the price\n', '    function setZoPrice(uint256 newPrice) external onlyCOO {\n', '        zoPrice = newPrice;\n', '    }\n', '\n', '    // Buy zo assets from us\n', '    function buyZoAssets(bytes32 values) external payable whenNotPaused {\n', '        // Check whether we need to refresh the daily limit\n', '        bytes32 history = accountsBoughtZoAsset[msg.sender];\n', '        if (accountsZoLastRefreshTime[msg.sender] == uint256(0)) {\n', "            // This account's first time to buy zo asset, we do not need to clear accountsBoughtZoAsset\n", '            accountsZoLastRefreshTime[msg.sender] = zoLastRefreshTime;\n', '        } else {\n', '            if (accountsZoLastRefreshTime[msg.sender] < zoLastRefreshTime) {\n', '                history = bytes32(0);\n', '                accountsZoLastRefreshTime[msg.sender] = zoLastRefreshTime;\n', '            }\n', '        }\n', ' \n', '        uint256 currentCount = 0;\n', '        uint256 count = 0;\n', '\n', '        bytes32 mask = bytes32(255); // 0x11111111\n', '        uint256 maskedValue;\n', '        uint256 maskedResult;\n', '\n', '        bytes32 asset = assets[msg.sender][0];\n', '\n', '        for (uint256 i = 0; i < 4; i++) {\n', '            if (i > 0) {\n', '                mask = mask << 8;\n', '            }\n', '            maskedValue = uint256(values & mask);\n', '            currentCount = maskedValue / 2 ** (8 * i);\n', '            count += currentCount;\n', '\n', '            // Check whether this account has bought too many assets\n', '            maskedResult = uint256(history & mask); \n', '            maskedResult += maskedValue;\n', '            require(maskedResult < (2 ** (8 * (i + 1))));\n', '\n', '            // Update account bought history\n', '            history = ((history ^ mask) & history) | bytes32(maskedResult);\n', '\n', '            // Check whether this account will have too many assets\n', '            maskedResult = uint256(asset & mask);\n', '            maskedResult += maskedValue;\n', '            require(maskedResult < (2 ** (8 * (i + 1))));\n', '\n', '            // Update user asset\n', '            asset = ((asset ^ mask) & asset) | bytes32(maskedResult);\n', '\n', '            // Check whether we have enough assets to sell\n', '            require(zoCreated[i] + currentCount <= zoDailyLimit);\n', '\n', '            // Update our creation history\n', '            zoCreated[i] += currentCount;\n', '        }\n', '\n', '        // Ensure this account buy at least one zo asset\n', '        require(count > 0);\n', '\n', '        // Check whether there are enough money for payment\n', '        require(msg.value >= count * zoPrice);\n', '\n', '        // Write updated user asset\n', '        assets[msg.sender][0] = asset;\n', '\n', '        // Write updated history\n', '        accountsBoughtZoAsset[msg.sender] = history;\n', '        \n', '        // Emit BuyZeroOrderAsset event\n', '        emit BuyZeroOrderAsset(msg.sender, values);\n', '\n', '    }\n', '\n', '    // Our daemon will refresh daily limit\n', '    function clearZoDailyLimit() external onlyCOO {\n', '        uint256 nextDay = zoLastRefreshTime + 1 days;\n', '        if (now > nextDay) {\n', '            zoLastRefreshTime = nextDay;\n', '            for (uint256 i = 0; i < 4; i++) {\n', '                zoCreated[i] =0;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract AlchemyMarket is AlchemyMinting {\n', '\n', '    // Sale order struct\n', '    struct SaleOrder {\n', '        // Asset id to be sold\n', '        uint64 assetId;\n', '        // Sale amount\n', '        uint64 amount;\n', '        // Desired price\n', '        uint128 desiredPrice;\n', '        // Seller\n', '        address seller; \n', '    }\n', '\n', '    // Max number of sale orders of each account \n', '    uint128 public maxSaleNum = 20;\n', '\n', '    // Cut ratio for a transaction\n', '    // Values 0-10,000 map to 0%-100%\n', '    uint256 public trCut = 275;\n', '\n', '    // Next sale id\n', '    uint256 public nextSaleId = 1;\n', '\n', '    // Sale orders list \n', '    mapping (uint256 => SaleOrder) public saleOrderList;\n', '\n', '    // Sale information of each account\n', '    mapping (address => uint256) public accountToSaleNum;\n', '\n', '    // events\n', '    event PutOnSale(address account, uint256 saleId);\n', '    event WithdrawSale(address account, uint256 saleId);\n', '    event ChangeSale(address account, uint256 saleId);\n', '    event BuyInMarket(address buyer, uint256 saleId, uint256 amount);\n', '    event SaleClear(uint256 saleId);\n', '\n', '    // functions\n', '    function setTrCut(uint256 newCut) public onlyCOO {\n', '        trCut = newCut;\n', '    }\n', '\n', '    // Put asset on sale\n', '    function putOnSale(uint256 assetId, uint256 amount, uint256 price) external whenNotPaused {\n', '        // One account can have no more than maxSaleNum sale orders\n', '        require(accountToSaleNum[msg.sender] < maxSaleNum);\n', '\n', '        // check whether zero order asset is to be sold \n', '        // which is not allowed\n', '        require(assetId > 3 && assetId < 248);\n', '        require(amount > 0 && amount < 256);\n', '\n', '        uint256 assetFloor = assetId / 31;\n', '        uint256 assetPos = assetId - 31 * assetFloor;\n', '        bytes32 allAsset = assets[msg.sender][assetFloor];\n', '\n', '        bytes32 mask = bytes32(255) << (8 * assetPos); // 0x11111111\n', '        uint256 maskedValue;\n', '        uint256 maskedResult;\n', '        uint256 addAmount = amount << (8 * assetPos);\n', '\n', '        // check whether there are enough unpending assets to sell\n', '        maskedValue = uint256(allAsset & mask);\n', '        require(addAmount <= maskedValue);\n', '\n', '        // Remove assets to be sold from owner\n', '        maskedResult = maskedValue - addAmount;\n', '        allAsset = ((allAsset ^ mask) & allAsset) | bytes32(maskedResult);\n', '\n', '        assets[msg.sender][assetFloor] = allAsset;\n', '\n', '        // Put on sale\n', '        SaleOrder memory saleorder = SaleOrder(\n', '            uint64(assetId),\n', '            uint64(amount),\n', '            uint128(price),\n', '            msg.sender\n', '        );\n', '\n', '        saleOrderList[nextSaleId] = saleorder;\n', '        nextSaleId += 1;\n', '\n', '        accountToSaleNum[msg.sender] += 1;\n', '\n', '        // Emit the Approval event\n', '        emit PutOnSale(msg.sender, nextSaleId-1);\n', '    }\n', '  \n', '    // Withdraw an sale order\n', '    function withdrawSale(uint256 saleId) external whenNotPaused {\n', "        // Can only withdraw self's sale order\n", '        require(saleOrderList[saleId].seller == msg.sender);\n', '\n', '        uint256 assetId = uint256(saleOrderList[saleId].assetId);\n', '        uint256 assetFloor = assetId / 31;\n', '        uint256 assetPos = assetId - 31 * assetFloor;\n', '        bytes32 allAsset = assets[msg.sender][assetFloor];\n', '\n', '        bytes32 mask = bytes32(255) << (8 * assetPos); // 0x11111111\n', '        uint256 maskedValue;\n', '        uint256 maskedResult;\n', '        uint256 addAmount = uint256(saleOrderList[saleId].amount) << (8 * assetPos);\n', '\n', '        // check whether this account will have too many assets\n', '        maskedValue = uint256(allAsset & mask);\n', '        require(addAmount + maskedValue < 2**(8 * (assetPos + 1)));\n', '\n', '        // Retransfer asset to be sold from owner\n', '        maskedResult = maskedValue + addAmount;\n', '        allAsset = ((allAsset ^ mask) & allAsset) | bytes32(maskedResult);\n', '\n', '        assets[msg.sender][assetFloor] = allAsset;\n', '\n', '        // Delete sale order\n', '        delete saleOrderList[saleId];\n', '\n', '        accountToSaleNum[msg.sender] -= 1;\n', '\n', '        // Emit the cancel event\n', '        emit WithdrawSale(msg.sender, saleId);\n', '    }\n', ' \n', '//     // Change sale order\n', '//     function changeSale(uint256 assetId, uint256 amount, uint256 price, uint256 saleId) external whenNotPaused {\n', '//         // Check if msg sender is the seller\n', '//         require(msg.sender == saleOrderList[saleId].seller);\n', '// \n', '//     }\n', ' \n', '    // Buy assets in market\n', '    function buyInMarket(uint256 saleId, uint256 amount) external payable whenNotPaused {\n', '        address seller = saleOrderList[saleId].seller;\n', '        // Check whether the saleId is a valid sale order\n', '        require(seller != address(0));\n', '\n', "        // Check the sender isn't the seller\n", '        require(msg.sender != seller);\n', '\n', '        require(saleOrderList[saleId].amount >= uint64(amount));\n', '\n', '        // Check whether pay value is enough\n', '        require(msg.value / saleOrderList[saleId].desiredPrice >= amount);\n', '\n', '        uint256 totalprice = amount * saleOrderList[saleId].desiredPrice;\n', '\n', '        uint64 assetId = saleOrderList[saleId].assetId;\n', '\n', '        uint256 assetFloor = assetId / 31;\n', '        uint256 assetPos = assetId - 31 * assetFloor;\n', '        bytes32 allAsset = assets[msg.sender][assetFloor];\n', '\n', '        bytes32 mask = bytes32(255) << (8 * assetPos); // 0x11111111\n', '        uint256 maskedValue;\n', '        uint256 maskedResult;\n', '        uint256 addAmount = amount << (8 * assetPos);\n', '\n', '        // check whether this account will have too many assets\n', '        maskedValue = uint256(allAsset & mask);\n', '        require(addAmount + maskedValue < 2**(8 * (assetPos + 1)));\n', '\n', '        // Transfer assets to buyer\n', '        maskedResult = maskedValue + addAmount;\n', '        allAsset = ((allAsset ^ mask) & allAsset) | bytes32(maskedResult);\n', '\n', '        assets[msg.sender][assetFloor] = allAsset;\n', '\n', '        saleOrderList[saleId].amount -= uint64(amount);\n', '\n', '        // Cut and then send the proceeds to seller\n', '        uint256 sellerProceeds = totalprice - _computeCut(totalprice);\n', '\n', '        seller.transfer(sellerProceeds);\n', '\n', '        // Emit the buy event\n', '        emit BuyInMarket(msg.sender, saleId, amount);\n', '\n', '        // If the sale has complete, clear this order\n', '        if (saleOrderList[saleId].amount == 0) {\n', '            accountToSaleNum[seller] -= 1;\n', '            delete saleOrderList[saleId];\n', '\n', '            // Emit the clear event\n', '            emit SaleClear(saleId);\n', '        }\n', '    }\n', '\n', '    // Compute the marketCut\n', '    function _computeCut(uint256 _price) internal view returns (uint256) {\n', '        return _price / 10000 * trCut;\n', '    }\n', '}']
