['//File: contracts/lib/ens/AbstractENS.sol\n', 'pragma solidity ^0.4.15;\n', '\n', '\n', 'interface AbstractENS {\n', '    function owner(bytes32 _node) constant returns (address);\n', '    function resolver(bytes32 _node) constant returns (address);\n', '    function ttl(bytes32 _node) constant returns (uint64);\n', '    function setOwner(bytes32 _node, address _owner);\n', '    function setSubnodeOwner(bytes32 _node, bytes32 label, address _owner);\n', '    function setResolver(bytes32 _node, address _resolver);\n', '    function setTTL(bytes32 _node, uint64 _ttl);\n', '\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed _node, bytes32 indexed _label, address _owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed _node, address _owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed _node, address _resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed _node, uint64 _ttl);\n', '}\n', '\n', '//File: contracts/lib/ens/PublicResolver.sol\n', 'pragma solidity ^0.4.0;\n', '\n', '\n', '\n', '/**\n', ' * A simple resolver anyone can use; only allows the owner of a node to set its\n', ' * address.\n', ' */\n', 'contract PublicResolver {\n', '    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n', '    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n', '    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n', '    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n', '    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n', '    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n', '    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n', '\n', '    event AddrChanged(bytes32 indexed node, address a);\n', '    event ContentChanged(bytes32 indexed node, bytes32 hash);\n', '    event NameChanged(bytes32 indexed node, string name);\n', '    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n', '    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n', '    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\n', '\n', '    struct PublicKey {\n', '        bytes32 x;\n', '        bytes32 y;\n', '    }\n', '\n', '    struct Record {\n', '        address addr;\n', '        bytes32 content;\n', '        string name;\n', '        PublicKey pubkey;\n', '        mapping(string=>string) text;\n', '        mapping(uint256=>bytes) abis;\n', '    }\n', '\n', '    AbstractENS ens;\n', '    mapping(bytes32=>Record) records;\n', '\n', '    modifier only_owner(bytes32 node) {\n', '        if (ens.owner(node) != msg.sender) throw;\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Constructor.\n', '     * @param ensAddr The ENS registrar contract.\n', '     */\n', '    function PublicResolver(AbstractENS ensAddr) {\n', '        ens = ensAddr;\n', '    }\n', '\n', '    /**\n', '     * Returns true if the resolver implements the interface specified by the provided hash.\n', '     * @param interfaceID The ID of the interface to check for.\n', '     * @return True if the contract implements the requested interface.\n', '     */\n', '    function supportsInterface(bytes4 interfaceID) constant returns (bool) {\n', '        return interfaceID == ADDR_INTERFACE_ID ||\n', '               interfaceID == CONTENT_INTERFACE_ID ||\n', '               interfaceID == NAME_INTERFACE_ID ||\n', '               interfaceID == ABI_INTERFACE_ID ||\n', '               interfaceID == PUBKEY_INTERFACE_ID ||\n', '               interfaceID == TEXT_INTERFACE_ID ||\n', '               interfaceID == INTERFACE_META_ID;\n', '    }\n', '\n', '    /**\n', '     * Returns the address associated with an ENS node.\n', '     * @param node The ENS node to query.\n', '     * @return The associated address.\n', '     */\n', '    function addr(bytes32 node) constant returns (address ret) {\n', '        ret = records[node].addr;\n', '    }\n', '\n', '    /**\n', '     * Sets the address associated with an ENS node.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * @param node The node to update.\n', '     * @param addr The address to set.\n', '     */\n', '    function setAddr(bytes32 node, address addr) only_owner(node) {\n', '        records[node].addr = addr;\n', '        AddrChanged(node, addr);\n', '    }\n', '\n', '    /**\n', '     * Returns the content hash associated with an ENS node.\n', '     * Note that this resource type is not standardized, and will likely change\n', '     * in future to a resource type based on multihash.\n', '     * @param node The ENS node to query.\n', '     * @return The associated content hash.\n', '     */\n', '    function content(bytes32 node) constant returns (bytes32 ret) {\n', '        ret = records[node].content;\n', '    }\n', '\n', '    /**\n', '     * Sets the content hash associated with an ENS node.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * Note that this resource type is not standardized, and will likely change\n', '     * in future to a resource type based on multihash.\n', '     * @param node The node to update.\n', '     * @param hash The content hash to set\n', '     */\n', '    function setContent(bytes32 node, bytes32 hash) only_owner(node) {\n', '        records[node].content = hash;\n', '        ContentChanged(node, hash);\n', '    }\n', '\n', '    /**\n', '     * Returns the name associated with an ENS node, for reverse records.\n', '     * Defined in EIP181.\n', '     * @param node The ENS node to query.\n', '     * @return The associated name.\n', '     */\n', '    function name(bytes32 node) constant returns (string ret) {\n', '        ret = records[node].name;\n', '    }\n', '\n', '    /**\n', '     * Sets the name associated with an ENS node, for reverse records.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * @param node The node to update.\n', '     * @param name The name to set.\n', '     */\n', '    function setName(bytes32 node, string name) only_owner(node) {\n', '        records[node].name = name;\n', '        NameChanged(node, name);\n', '    }\n', '\n', '    /**\n', '     * Returns the ABI associated with an ENS node.\n', '     * Defined in EIP205.\n', '     * @param node The ENS node to query\n', '     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n', '     * @return contentType The content type of the return value\n', '     * @return data The ABI data\n', '     */\n', '    function ABI(bytes32 node, uint256 contentTypes) constant returns (uint256 contentType, bytes data) {\n', '        var record = records[node];\n', '        for(contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n', '            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n', '                data = record.abis[contentType];\n', '                return;\n', '            }\n', '        }\n', '        contentType = 0;\n', '    }\n', '\n', '    /**\n', '     * Sets the ABI associated with an ENS node.\n', '     * Nodes may have one ABI of each content type. To remove an ABI, set it to\n', '     * the empty string.\n', '     * @param node The node to update.\n', '     * @param contentType The content type of the ABI\n', '     * @param data The ABI data.\n', '     */\n', '    function setABI(bytes32 node, uint256 contentType, bytes data) only_owner(node) {\n', '        // Content types must be powers of 2\n', '        if (((contentType - 1) & contentType) != 0) throw;\n', '\n', '        records[node].abis[contentType] = data;\n', '        ABIChanged(node, contentType);\n', '    }\n', '\n', '    /**\n', '     * Returns the SECP256k1 public key associated with an ENS node.\n', '     * Defined in EIP 619.\n', '     * @param node The ENS node to query\n', '     * @return x, y the X and Y coordinates of the curve point for the public key.\n', '     */\n', '    function pubkey(bytes32 node) constant returns (bytes32 x, bytes32 y) {\n', '        return (records[node].pubkey.x, records[node].pubkey.y);\n', '    }\n', '\n', '    /**\n', '     * Sets the SECP256k1 public key associated with an ENS node.\n', '     * @param node The ENS node to query\n', '     * @param x the X coordinate of the curve point for the public key.\n', '     * @param y the Y coordinate of the curve point for the public key.\n', '     */\n', '    function setPubkey(bytes32 node, bytes32 x, bytes32 y) only_owner(node) {\n', '        records[node].pubkey = PublicKey(x, y);\n', '        PubkeyChanged(node, x, y);\n', '    }\n', '\n', '    /**\n', '     * Returns the text data associated with an ENS node and key.\n', '     * @param node The ENS node to query.\n', '     * @param key The text data key to query.\n', '     * @return The associated text data.\n', '     */\n', '    function text(bytes32 node, string key) constant returns (string ret) {\n', '        ret = records[node].text[key];\n', '    }\n', '\n', '    /**\n', '     * Sets the text data associated with an ENS node and key.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * @param node The node to update.\n', '     * @param key The key to set.\n', '     * @param value The text data value to set.\n', '     */\n', '    function setText(bytes32 node, string key, string value) only_owner(node) {\n', '        records[node].text[key] = value;\n', '        TextChanged(node, key, key);\n', '    }\n', '}\n', '\n', '//File: contracts/ens/ENSConstants.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', 'contract ENSConstants {\n', '    bytes32 constant public ENS_ROOT = bytes32(0);\n', '    bytes32 constant public ETH_TLD_LABEL = keccak256("eth");\n', '    bytes32 constant public ETH_TLD_NODE = keccak256(ENS_ROOT, ETH_TLD_LABEL);\n', '    bytes32 constant public PUBLIC_RESOLVER_LABEL = keccak256("resolver");\n', '    bytes32 constant public PUBLIC_RESOLVER_NODE = keccak256(ETH_TLD_NODE, PUBLIC_RESOLVER_LABEL);\n', '}\n', '\n', '//File: contracts/acl/IACL.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', 'interface IACL {\n', '    function initialize(address permissionsCreator) public;\n', '    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n', '}\n', '\n', '//File: contracts/kernel/IKernel.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', 'interface IKernel {\n', '    event SetApp(bytes32 indexed namespace, bytes32 indexed name, bytes32 indexed id, address app);\n', '\n', '    function acl() public view returns (IACL);\n', '    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n', '\n', '    function setApp(bytes32 namespace, bytes32 name, address app) public returns (bytes32 id);\n', '    function getApp(bytes32 id) public view returns (address);\n', '}\n', '//File: contracts/apps/AppStorage.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', 'contract AppStorage {\n', '    IKernel public kernel;\n', '    bytes32 public appId;\n', '    address internal pinnedCode; // used by Proxy Pinned\n', '    uint256 internal initializationBlock; // used by Initializable\n', '    uint256[95] private storageOffset; // forces App storage to start at after 100 slots\n', '    uint256 private offset;\n', '}\n', '\n', '//File: contracts/common/Initializable.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', 'contract Initializable is AppStorage {\n', '    modifier onlyInit {\n', '        require(initializationBlock == 0);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @return Block number in which the contract was initialized\n', '    */\n', '    function getInitializationBlock() public view returns (uint256) {\n', '        return initializationBlock;\n', '    }\n', '\n', '    /**\n', '    * @dev Function to be called by top level contract after initialization has finished.\n', '    */\n', '    function initialized() internal onlyInit {\n', '        initializationBlock = getBlockNumber();\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the current block number.\n', '    *      Using a function rather than `block.number` allows us to easily mock the block number in\n', '    *      tests.\n', '    */\n', '    function getBlockNumber() internal view returns (uint256) {\n', '        return block.number;\n', '    }\n', '}\n', '\n', '//File: contracts/evmscript/IEVMScriptExecutor.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', 'interface IEVMScriptExecutor {\n', '    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n', '}\n', '\n', '//File: contracts/evmscript/IEVMScriptRegistry.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', 'contract EVMScriptRegistryConstants {\n', '    bytes32 constant public EVMSCRIPT_REGISTRY_APP_ID = keccak256("evmreg.aragonpm.eth");\n', '    bytes32 constant public EVMSCRIPT_REGISTRY_APP = keccak256(keccak256("app"), EVMSCRIPT_REGISTRY_APP_ID);\n', '}\n', '\n', '\n', 'interface IEVMScriptRegistry {\n', '    function addScriptExecutor(address executor) external returns (uint id);\n', '    function disableScriptExecutor(uint256 executorId) external;\n', '\n', '    function getScriptExecutor(bytes script) public view returns (address);\n', '}\n', '//File: contracts/evmscript/ScriptHelpers.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', 'library ScriptHelpers {\n', '    // To test with JS and compare with actual encoder. Maintaining for reference.\n', '    // t = function() { return IEVMScriptExecutor.at(&#39;0x4bcdd59d6c77774ee7317fc1095f69ec84421e49&#39;).contract.execScript.getData(...[].slice.call(arguments)).slice(10).match(/.{1,64}/g) }\n', '    // run = function() { return ScriptHelpers.new().then(sh => { sh.abiEncode.call(...[].slice.call(arguments)).then(a => console.log(a.slice(2).match(/.{1,64}/g)) ) }) }\n', '    // This is truly not beautiful but lets no daydream to the day solidity gets reflection features\n', '\n', '    function abiEncode(bytes _a, bytes _b, address[] _c) public pure returns (bytes d) {\n', '        return encode(_a, _b, _c);\n', '    }\n', '\n', '    function encode(bytes memory _a, bytes memory _b, address[] memory _c) internal pure returns (bytes memory d) {\n', '        // A is positioned after the 3 position words\n', '        uint256 aPosition = 0x60;\n', '        uint256 bPosition = aPosition + 32 * abiLength(_a);\n', '        uint256 cPosition = bPosition + 32 * abiLength(_b);\n', '        uint256 length = cPosition + 32 * abiLength(_c);\n', '\n', '        d = new bytes(length);\n', '        assembly {\n', '            // Store positions\n', '            mstore(add(d, 0x20), aPosition)\n', '            mstore(add(d, 0x40), bPosition)\n', '            mstore(add(d, 0x60), cPosition)\n', '        }\n', '\n', '        // Copy memory to correct position\n', '        copy(d, getPtr(_a), aPosition, _a.length);\n', '        copy(d, getPtr(_b), bPosition, _b.length);\n', '        copy(d, getPtr(_c), cPosition, _c.length * 32); // 1 word per address\n', '    }\n', '\n', '    function abiLength(bytes memory _a) internal pure returns (uint256) {\n', '        // 1 for length +\n', '        // memory words + 1 if not divisible for 32 to offset word\n', '        return 1 + (_a.length / 32) + (_a.length % 32 > 0 ? 1 : 0);\n', '    }\n', '\n', '    function abiLength(address[] _a) internal pure returns (uint256) {\n', '        // 1 for length + 1 per item\n', '        return 1 + _a.length;\n', '    }\n', '\n', '    function copy(bytes _d, uint256 _src, uint256 _pos, uint256 _length) internal pure {\n', '        uint dest;\n', '        assembly {\n', '            dest := add(add(_d, 0x20), _pos)\n', '        }\n', '        memcpy(dest, _src, _length + 32);\n', '    }\n', '\n', '    function getPtr(bytes memory _x) internal pure returns (uint256 ptr) {\n', '        assembly {\n', '            ptr := _x\n', '        }\n', '    }\n', '\n', '    function getPtr(address[] memory _x) internal pure returns (uint256 ptr) {\n', '        assembly {\n', '            ptr := _x\n', '        }\n', '    }\n', '\n', '    function getSpecId(bytes _script) internal pure returns (uint32) {\n', '        return uint32At(_script, 0);\n', '    }\n', '\n', '    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n', '        assembly {\n', '            result := mload(add(_data, add(0x20, _location)))\n', '        }\n', '    }\n', '\n', '    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {\n', '        uint256 word = uint256At(_data, _location);\n', '\n', '        assembly {\n', '            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\n', '            0x1000000000000000000000000)\n', '        }\n', '    }\n', '\n', '    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {\n', '        uint256 word = uint256At(_data, _location);\n', '\n', '        assembly {\n', '            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),\n', '            0x100000000000000000000000000000000000000000000000000000000)\n', '        }\n', '    }\n', '\n', '    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n', '        assembly {\n', '            result := add(_data, add(0x20, _location))\n', '        }\n', '    }\n', '\n', '    function toBytes(bytes4 _sig) internal pure returns (bytes) {\n', '        bytes memory payload = new bytes(4);\n', '        payload[0] = bytes1(_sig);\n', '        payload[1] = bytes1(_sig << 8);\n', '        payload[2] = bytes1(_sig << 16);\n', '        payload[3] = bytes1(_sig << 24);\n', '        return payload;\n', '    }\n', '\n', '    function memcpy(uint _dest, uint _src, uint _len) public pure {\n', '        uint256 src = _src;\n', '        uint256 dest = _dest;\n', '        uint256 len = _len;\n', '\n', '        // Copy word-length chunks while possible\n', '        for (; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '}\n', '//File: contracts/evmscript/EVMScriptRunner.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract EVMScriptRunner is AppStorage, EVMScriptRegistryConstants {\n', '    using ScriptHelpers for bytes;\n', '\n', '    function runScript(bytes _script, bytes _input, address[] _blacklist) protectState internal returns (bytes output) {\n', '        // TODO: Too much data flying around, maybe extracting spec id here is cheaper\n', '        address executorAddr = getExecutor(_script);\n', '        require(executorAddr != address(0));\n', '\n', '        bytes memory calldataArgs = _script.encode(_input, _blacklist);\n', '        bytes4 sig = IEVMScriptExecutor(0).execScript.selector;\n', '\n', '        require(executorAddr.delegatecall(sig, calldataArgs));\n', '\n', '        return returnedDataDecoded();\n', '    }\n', '\n', '    function getExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n', '        return IEVMScriptExecutor(getExecutorRegistry().getScriptExecutor(_script));\n', '    }\n', '\n', '    // TODO: Internal\n', '    function getExecutorRegistry() internal view returns (IEVMScriptRegistry) {\n', '        address registryAddr = kernel.getApp(EVMSCRIPT_REGISTRY_APP);\n', '        return IEVMScriptRegistry(registryAddr);\n', '    }\n', '\n', '    /**\n', '    * @dev copies and returns last&#39;s call data. Needs to ABI decode first\n', '    */\n', '    function returnedDataDecoded() internal view returns (bytes ret) {\n', '        assembly {\n', '            let size := returndatasize\n', '            switch size\n', '            case 0 {}\n', '            default {\n', '                ret := mload(0x40) // free mem ptr get\n', '                mstore(0x40, add(ret, add(size, 0x20))) // free mem ptr set\n', '                returndatacopy(ret, 0x20, sub(size, 0x20)) // copy return data\n', '            }\n', '        }\n', '        return ret;\n', '    }\n', '\n', '    modifier protectState {\n', '        address preKernel = kernel;\n', '        bytes32 preAppId = appId;\n', '        _; // exec\n', '        require(kernel == preKernel);\n', '        require(appId == preAppId);\n', '    }\n', '}\n', '//File: contracts/acl/ACLSyntaxSugar.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', 'contract ACLSyntaxSugar {\n', '    function arr() internal pure returns (uint256[] r) {}\n', '\n', '    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a));\n', '    }\n', '\n', '    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b));\n', '    }\n', '\n', '    function arr(address _a) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a));\n', '    }\n', '\n', '    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b));\n', '    }\n', '\n', '    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), _b, _c);\n', '    }\n', '\n', '    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b));\n', '    }\n', '\n', '    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n', '    }\n', '\n', '    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b), uint256(_c));\n', '    }\n', '\n', '    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b), uint256(_c));\n', '    }\n', '\n', '    function arr(uint256 _a) internal pure returns (uint256[] r) {\n', '        r = new uint256[](1);\n', '        r[0] = _a;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n', '        r = new uint256[](2);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n', '        r = new uint256[](3);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '        r[2] = _c;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n', '        r = new uint256[](4);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '        r[2] = _c;\n', '        r[3] = _d;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n', '        r = new uint256[](5);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '        r[2] = _c;\n', '        r[3] = _d;\n', '        r[4] = _e;\n', '    }\n', '}\n', '\n', '\n', 'contract ACLHelpers {\n', '    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n', '        return uint8(_x >> (8 * 30));\n', '    }\n', '\n', '    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n', '        return uint8(_x >> (8 * 31));\n', '    }\n', '\n', '    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n', '        a = uint32(_x);\n', '        b = uint32(_x >> (8 * 4));\n', '        c = uint32(_x >> (8 * 8));\n', '    }\n', '}\n', '\n', '//File: contracts/apps/AragonApp.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract AragonApp is AppStorage, Initializable, ACLSyntaxSugar, EVMScriptRunner {\n', '    modifier auth(bytes32 _role) {\n', '        require(canPerform(msg.sender, _role, new uint256[](0)));\n', '        _;\n', '    }\n', '\n', '    modifier authP(bytes32 _role, uint256[] params) {\n', '        require(canPerform(msg.sender, _role, params));\n', '        _;\n', '    }\n', '\n', '    function canPerform(address _sender, bytes32 _role, uint256[] params) public view returns (bool) {\n', '        bytes memory how; // no need to init memory as it is never used\n', '        if (params.length > 0) {\n', '            uint256 byteLength = params.length * 32;\n', '            assembly {\n', '                how := params // forced casting\n', '                mstore(how, byteLength)\n', '            }\n', '        }\n', '        return address(kernel) == 0 || kernel.hasPermission(_sender, address(this), _role, how);\n', '    }\n', '}\n', '\n', '//File: contracts/ens/ENSSubdomainRegistrar.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ENSSubdomainRegistrar is AragonApp, ENSConstants {\n', '    bytes32 constant public CREATE_NAME_ROLE = bytes32(1);\n', '    bytes32 constant public DELETE_NAME_ROLE = bytes32(2);\n', '    bytes32 constant public POINT_ROOTNODE_ROLE = bytes32(3);\n', '\n', '    AbstractENS public ens;\n', '    bytes32 public rootNode;\n', '\n', '    event NewName(bytes32 indexed node, bytes32 indexed label);\n', '    event DeleteName(bytes32 indexed node, bytes32 indexed label);\n', '\n', '    function initialize(AbstractENS _ens, bytes32 _rootNode) onlyInit public {\n', '        initialized();\n', '\n', '        // We need ownership to create subnodes\n', '        require(_ens.owner(_rootNode) == address(this));\n', '\n', '        ens = _ens;\n', '        rootNode = _rootNode;\n', '    }\n', '\n', '    function createName(bytes32 _label, address _owner) auth(CREATE_NAME_ROLE) external returns (bytes32 node) {\n', '        return _createName(_label, _owner);\n', '    }\n', '\n', '    function createNameAndPoint(bytes32 _label, address _target) auth(CREATE_NAME_ROLE) external returns (bytes32 node) {\n', '        node = _createName(_label, this);\n', '        _pointToResolverAndResolve(node, _target);\n', '    }\n', '\n', '    function deleteName(bytes32 _label) auth(DELETE_NAME_ROLE) external {\n', '        bytes32 node = keccak256(rootNode, _label);\n', '\n', '        address currentOwner = ens.owner(node);\n', '\n', '        require(currentOwner != address(0)); // fail if deleting unset name\n', '\n', '        if (currentOwner != address(this)) { // needs to reclaim ownership so it can set resolver\n', '            ens.setSubnodeOwner(rootNode, _label, this);\n', '        }\n', '\n', '        ens.setResolver(node, address(0)); // remove resolver so it ends resolving\n', '        ens.setOwner(node, address(0));\n', '\n', '        DeleteName(node, _label);\n', '    }\n', '\n', '    function pointRootNode(address _target) auth(POINT_ROOTNODE_ROLE) external {\n', '        _pointToResolverAndResolve(rootNode, _target);\n', '    }\n', '\n', '    function _createName(bytes32 _label, address _owner) internal returns (bytes32 node) {\n', '        node = keccak256(rootNode, _label);\n', '        require(ens.owner(node) == address(0)); // avoid name reset\n', '\n', '        ens.setSubnodeOwner(rootNode, _label, _owner);\n', '\n', '        NewName(node, _label);\n', '    }\n', '\n', '    function _pointToResolverAndResolve(bytes32 _node, address _target) internal {\n', '        address publicResolver = getAddr(PUBLIC_RESOLVER_NODE);\n', '        ens.setResolver(_node, publicResolver);\n', '\n', '        PublicResolver(publicResolver).setAddr(_node, _target);\n', '    }\n', '\n', '    function getAddr(bytes32 node) internal view returns (address) {\n', '        address resolver = ens.resolver(node);\n', '        return PublicResolver(resolver).addr(node);\n', '    }\n', '}\n', '\n', '//File: contracts/apps/IAppProxy.sol\n', 'pragma solidity 0.4.18;\n', '\n', 'interface IAppProxy {\n', '    function isUpgradeable() public pure returns (bool);\n', '    function getCode() public view returns (address);\n', '}\n', '\n', '//File: contracts/common/DelegateProxy.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', 'contract DelegateProxy {\n', '    /**\n', '    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n', '    * @param _dst Destination address to perform the delegatecall\n', '    * @param _calldata Calldata for the delegatecall\n', '    */\n', '    function delegatedFwd(address _dst, bytes _calldata) internal {\n', '        require(isContract(_dst));\n', '        assembly {\n', '            let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n', '            let size := returndatasize\n', '\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n', '            // if the call returned error data, forward it\n', '            switch result case 0 { revert(ptr, size) }\n', '            default { return(ptr, size) }\n', '        }\n', '    }\n', '\n', '    function isContract(address _target) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(_target) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '//File: contracts/kernel/KernelStorage.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', 'contract KernelConstants {\n', '    bytes32 constant public CORE_NAMESPACE = keccak256("core");\n', '    bytes32 constant public APP_BASES_NAMESPACE = keccak256("base");\n', '    bytes32 constant public APP_ADDR_NAMESPACE = keccak256("app");\n', '\n', '    bytes32 constant public KERNEL_APP_ID = keccak256("kernel.aragonpm.eth");\n', '    bytes32 constant public KERNEL_APP = keccak256(CORE_NAMESPACE, KERNEL_APP_ID);\n', '\n', '    bytes32 constant public ACL_APP_ID = keccak256("acl.aragonpm.eth");\n', '    bytes32 constant public ACL_APP = keccak256(APP_ADDR_NAMESPACE, ACL_APP_ID);\n', '}\n', '\n', '\n', 'contract KernelStorage is KernelConstants {\n', '    mapping (bytes32 => address) public apps;\n', '}\n', '\n', '//File: contracts/apps/AppProxyBase.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract AppProxyBase is IAppProxy, AppStorage, DelegateProxy, KernelConstants {\n', '    /**\n', '    * @dev Initialize AppProxy\n', '    * @param _kernel Reference to organization kernel for the app\n', '    * @param _appId Identifier for app\n', '    * @param _initializePayload Payload for call to be made after setup to initialize\n', '    */\n', '    function AppProxyBase(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public {\n', '        kernel = _kernel;\n', '        appId = _appId;\n', '\n', '        // Implicit check that kernel is actually a Kernel\n', '        // The EVM doesn&#39;t actually provide a way for us to make sure, but we can force a revert to\n', '        // occur if the kernel is set to 0x0 or a non-code address when we try to call a method on\n', '        // it.\n', '        address appCode = getAppBase(appId);\n', '\n', '        // If initialize payload is provided, it will be executed\n', '        if (_initializePayload.length > 0) {\n', '            require(isContract(appCode));\n', '            // Cannot make delegatecall as a delegateproxy.delegatedFwd as it\n', '            // returns ending execution context and halts contract deployment\n', '            require(appCode.delegatecall(_initializePayload));\n', '        }\n', '    }\n', '\n', '    function getAppBase(bytes32 _appId) internal view returns (address) {\n', '        return kernel.getApp(keccak256(APP_BASES_NAMESPACE, _appId));\n', '    }\n', '\n', '    function () payable public {\n', '        address target = getCode();\n', '        require(target != 0); // if app code hasn&#39;t been set yet, don&#39;t call\n', '        delegatedFwd(target, msg.data);\n', '    }\n', '}\n', '//File: contracts/apps/AppProxyUpgradeable.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', 'contract AppProxyUpgradeable is AppProxyBase {\n', '    address public pinnedCode;\n', '\n', '    /**\n', '    * @dev Initialize AppProxyUpgradeable (makes it an upgradeable Aragon app)\n', '    * @param _kernel Reference to organization kernel for the app\n', '    * @param _appId Identifier for app\n', '    * @param _initializePayload Payload for call to be made after setup to initialize\n', '    */\n', '    function AppProxyUpgradeable(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n', '             AppProxyBase(_kernel, _appId, _initializePayload) public\n', '    {\n', '\n', '    }\n', '\n', '    function getCode() public view returns (address) {\n', '        return getAppBase(appId);\n', '    }\n', '\n', '    function isUpgradeable() public pure returns (bool) {\n', '        return true;\n', '    }\n', '}\n', '\n', '//File: contracts/apps/AppProxyPinned.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', 'contract AppProxyPinned is AppProxyBase {\n', '    /**\n', '    * @dev Initialize AppProxyPinned (makes it an un-upgradeable Aragon app)\n', '    * @param _kernel Reference to organization kernel for the app\n', '    * @param _appId Identifier for app\n', '    * @param _initializePayload Payload for call to be made after setup to initialize\n', '    */\n', '    function AppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n', '             AppProxyBase(_kernel, _appId, _initializePayload) public\n', '    {\n', '        pinnedCode = getAppBase(appId);\n', '        require(pinnedCode != address(0));\n', '    }\n', '\n', '    function getCode() public view returns (address) {\n', '        return pinnedCode;\n', '    }\n', '\n', '    function isUpgradeable() public pure returns (bool) {\n', '        return false;\n', '    }\n', '\n', '    function () payable public {\n', '        delegatedFwd(getCode(), msg.data);\n', '    }\n', '}\n', '//File: contracts/factory/AppProxyFactory.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', 'contract AppProxyFactory {\n', '    event NewAppProxy(address proxy);\n', '\n', '    function newAppProxy(IKernel _kernel, bytes32 _appId) public returns (AppProxyUpgradeable) {\n', '        return newAppProxy(_kernel, _appId, new bytes(0));\n', '    }\n', '\n', '    function newAppProxy(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyUpgradeable) {\n', '        AppProxyUpgradeable proxy = new AppProxyUpgradeable(_kernel, _appId, _initializePayload);\n', '        NewAppProxy(address(proxy));\n', '        return proxy;\n', '    }\n', '\n', '    function newAppProxyPinned(IKernel _kernel, bytes32 _appId) public returns (AppProxyPinned) {\n', '        return newAppProxyPinned(_kernel, _appId, new bytes(0));\n', '    }\n', '\n', '    function newAppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyPinned) {\n', '        AppProxyPinned proxy = new AppProxyPinned(_kernel, _appId, _initializePayload);\n', '        NewAppProxy(address(proxy));\n', '        return proxy;\n', '    }\n', '}\n', '\n', '//File: contracts/acl/ACL.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'interface ACLOracle {\n', '    function canPerform(address who, address where, bytes32 what) public view returns (bool);\n', '}\n', '\n', '\n', 'contract ACL is IACL, AragonApp, ACLHelpers {\n', '    bytes32 constant public CREATE_PERMISSIONS_ROLE = keccak256("CREATE_PERMISSIONS_ROLE");\n', '\n', '    // whether a certain entity has a permission\n', '    mapping (bytes32 => bytes32) permissions; // 0 for no permission, or parameters id\n', '    mapping (bytes32 => Param[]) public permissionParams;\n', '\n', '    // who is the manager of a permission\n', '    mapping (bytes32 => address) permissionManager;\n', '\n', '    enum Op { NONE, EQ, NEQ, GT, LT, GTE, LTE, NOT, AND, OR, XOR, IF_ELSE, RET } // op types\n', '\n', '    struct Param {\n', '        uint8 id;\n', '        uint8 op;\n', '        uint240 value; // even though value is an uint240 it can store addresses\n', '        // in the case of 32 byte hashes losing 2 bytes precision isn&#39;t a huge deal\n', '        // op and id take less than 1 byte each so it can be kept in 1 sstore\n', '    }\n', '\n', '    uint8 constant BLOCK_NUMBER_PARAM_ID = 200;\n', '    uint8 constant TIMESTAMP_PARAM_ID    = 201;\n', '    uint8 constant SENDER_PARAM_ID       = 202;\n', '    uint8 constant ORACLE_PARAM_ID       = 203;\n', '    uint8 constant LOGIC_OP_PARAM_ID     = 204;\n', '    uint8 constant PARAM_VALUE_PARAM_ID  = 205;\n', '    // TODO: Add execution times param type?\n', '\n', '    bytes32 constant public EMPTY_PARAM_HASH = keccak256(uint256(0));\n', '    address constant ANY_ENTITY = address(-1);\n', '\n', '    modifier onlyPermissionManager(address _app, bytes32 _role) {\n', '        require(msg.sender == getPermissionManager(_app, _role));\n', '        _;\n', '    }\n', '\n', '    event SetPermission(address indexed entity, address indexed app, bytes32 indexed role, bool allowed);\n', '    event ChangePermissionManager(address indexed app, bytes32 indexed role, address indexed manager);\n', '\n', '    /**\n', '    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n', '    * @notice Initializes an ACL instance and sets `_permissionsCreator` as the entity that can create other permissions\n', '    * @param _permissionsCreator Entity that will be given permission over createPermission\n', '    */\n', '    function initialize(address _permissionsCreator) onlyInit public {\n', '        initialized();\n', '        require(msg.sender == address(kernel));\n', '\n', '        _createPermission(_permissionsCreator, this, CREATE_PERMISSIONS_ROLE, _permissionsCreator);\n', '    }\n', '\n', '    /**\n', '    * @dev Creates a permission that wasn&#39;t previously set. Access is limited by the ACL.\n', '    *      If a created permission is removed it is possible to reset it with createPermission.\n', '    * @notice Create a new permission granting `_entity` the ability to perform actions of role `_role` on `_app` (setting `_manager` as the permission manager)\n', '    * @param _entity Address of the whitelisted entity that will be able to perform the role\n', '    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n', '    * @param _role Identifier for the group of actions in app given access to perform\n', '    * @param _manager Address of the entity that will be able to grant and revoke the permission further.\n', '    */\n', '    function createPermission(address _entity, address _app, bytes32 _role, address _manager) external {\n', '        require(hasPermission(msg.sender, address(this), CREATE_PERMISSIONS_ROLE));\n', '\n', '        _createPermission(_entity, _app, _role, _manager);\n', '    }\n', '\n', '    /**\n', '    * @dev Grants permission if allowed. This requires `msg.sender` to be the permission manager\n', '    * @notice Grants `_entity` the ability to perform actions of role `_role` on `_app`\n', '    * @param _entity Address of the whitelisted entity that will be able to perform the role\n', '    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n', '    * @param _role Identifier for the group of actions in app given access to perform\n', '    */\n', '    function grantPermission(address _entity, address _app, bytes32 _role)\n', '        external\n', '    {\n', '        grantPermissionP(_entity, _app, _role, new uint256[](0));\n', '    }\n', '\n', '    /**\n', '    * @dev Grants a permission with parameters if allowed. This requires `msg.sender` to be the permission manager\n', '    * @notice Grants `_entity` the ability to perform actions of role `_role` on `_app`\n', '    * @param _entity Address of the whitelisted entity that will be able to perform the role\n', '    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n', '    * @param _role Identifier for the group of actions in app given access to perform\n', '    * @param _params Permission parameters\n', '    */\n', '    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] _params)\n', '        onlyPermissionManager(_app, _role)\n', '        public\n', '    {\n', '        require(!hasPermission(_entity, _app, _role));\n', '\n', '        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;\n', '        _setPermission(_entity, _app, _role, paramsHash);\n', '    }\n', '\n', '    /**\n', '    * @dev Revokes permission if allowed. This requires `msg.sender` to be the the permission manager\n', '    * @notice Revokes `_entity` the ability to perform actions of role `_role` on `_app`\n', '    * @param _entity Address of the whitelisted entity to revoke access from\n', '    * @param _app Address of the app in which the role will be revoked\n', '    * @param _role Identifier for the group of actions in app being revoked\n', '    */\n', '    function revokePermission(address _entity, address _app, bytes32 _role)\n', '        onlyPermissionManager(_app, _role)\n', '        external\n', '    {\n', '        require(hasPermission(_entity, _app, _role));\n', '\n', '        _setPermission(_entity, _app, _role, bytes32(0));\n', '    }\n', '\n', '    /**\n', '    * @notice Sets `_newManager` as the manager of the permission `_role` in `_app`\n', '    * @param _newManager Address for the new manager\n', '    * @param _app Address of the app in which the permission management is being transferred\n', '    * @param _role Identifier for the group of actions being transferred\n', '    */\n', '    function setPermissionManager(address _newManager, address _app, bytes32 _role)\n', '        onlyPermissionManager(_app, _role)\n', '        external\n', '    {\n', '        _setPermissionManager(_newManager, _app, _role);\n', '    }\n', '\n', '    /**\n', '    * @dev Get manager for permission\n', '    * @param _app Address of the app\n', '    * @param _role Identifier for a group of actions in app\n', '    * @return address of the manager for the permission\n', '    */\n', '    function getPermissionManager(address _app, bytes32 _role) public view returns (address) {\n', '        return permissionManager[roleHash(_app, _role)];\n', '    }\n', '\n', '    /**\n', '    * @dev Function called by apps to check ACL on kernel or to check permission statu\n', '    * @param _who Sender of the original call\n', '    * @param _where Address of the app\n', '    * @param _where Identifier for a group of actions in app\n', '    * @param _how Permission parameters\n', '    * @return boolean indicating whether the ACL allows the role or not\n', '    */\n', '    function hasPermission(address _who, address _where, bytes32 _what, bytes memory _how) public view returns (bool) {\n', '        uint256[] memory how;\n', '        uint256 intsLength = _how.length / 32;\n', '        assembly {\n', '            how := _how // forced casting\n', '            mstore(how, intsLength)\n', '        }\n', '        // _how is invalid from this point fwd\n', '        return hasPermission(_who, _where, _what, how);\n', '    }\n', '\n', '    function hasPermission(address _who, address _where, bytes32 _what, uint256[] memory _how) public view returns (bool) {\n', '        bytes32 whoParams = permissions[permissionHash(_who, _where, _what)];\n', '        if (whoParams != bytes32(0) && evalParams(whoParams, _who, _where, _what, _how)) {\n', '            return true;\n', '        }\n', '\n', '        bytes32 anyParams = permissions[permissionHash(ANY_ENTITY, _where, _what)];\n', '        if (anyParams != bytes32(0) && evalParams(anyParams, ANY_ENTITY, _where, _what, _how)) {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function hasPermission(address _who, address _where, bytes32 _what) public view returns (bool) {\n', '        uint256[] memory empty = new uint256[](0);\n', '        return hasPermission(_who, _where, _what, empty);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal createPermission for access inside the kernel (on instantiation)\n', '    */\n', '    function _createPermission(address _entity, address _app, bytes32 _role, address _manager) internal {\n', '        // only allow permission creation (or re-creation) when there is no manager\n', '        require(getPermissionManager(_app, _role) == address(0));\n', '\n', '        _setPermission(_entity, _app, _role, EMPTY_PARAM_HASH);\n', '        _setPermissionManager(_manager, _app, _role);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function called to actually save the permission\n', '    */\n', '    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {\n', '        permissions[permissionHash(_entity, _app, _role)] = _paramsHash;\n', '\n', '        SetPermission(_entity, _app, _role, _paramsHash != bytes32(0));\n', '    }\n', '\n', '    function _saveParams(uint256[] _encodedParams) internal returns (bytes32) {\n', '        bytes32 paramHash = keccak256(_encodedParams);\n', '        Param[] storage params = permissionParams[paramHash];\n', '\n', '        if (params.length == 0) { // params not saved before\n', '            for (uint256 i = 0; i < _encodedParams.length; i++) {\n', '                uint256 encodedParam = _encodedParams[i];\n', '                Param memory param = Param(decodeParamId(encodedParam), decodeParamOp(encodedParam), uint240(encodedParam));\n', '                params.push(param);\n', '            }\n', '        }\n', '\n', '        return paramHash;\n', '    }\n', '\n', '    function evalParams(\n', '        bytes32 _paramsHash,\n', '        address _who,\n', '        address _where,\n', '        bytes32 _what,\n', '        uint256[] _how\n', '    ) internal view returns (bool)\n', '    {\n', '        if (_paramsHash == EMPTY_PARAM_HASH) {\n', '            return true;\n', '        }\n', '\n', '        return evalParam(_paramsHash, 0, _who, _where, _what, _how);\n', '    }\n', '\n', '    function evalParam(\n', '        bytes32 _paramsHash,\n', '        uint32 _paramId,\n', '        address _who,\n', '        address _where,\n', '        bytes32 _what,\n', '        uint256[] _how\n', '    ) internal view returns (bool)\n', '    {\n', '        if (_paramId >= permissionParams[_paramsHash].length) {\n', '            return false; // out of bounds\n', '        }\n', '\n', '        Param memory param = permissionParams[_paramsHash][_paramId];\n', '\n', '        if (param.id == LOGIC_OP_PARAM_ID) {\n', '            return evalLogic(param, _paramsHash, _who, _where, _what, _how);\n', '        }\n', '\n', '        uint256 value;\n', '        uint256 comparedTo = uint256(param.value);\n', '\n', '        // get value\n', '        if (param.id == ORACLE_PARAM_ID) {\n', '            value = ACLOracle(param.value).canPerform(_who, _where, _what) ? 1 : 0;\n', '            comparedTo = 1;\n', '        } else if (param.id == BLOCK_NUMBER_PARAM_ID) {\n', '            value = blockN();\n', '        } else if (param.id == TIMESTAMP_PARAM_ID) {\n', '            value = time();\n', '        } else if (param.id == SENDER_PARAM_ID) {\n', '            value = uint256(msg.sender);\n', '        } else if (param.id == PARAM_VALUE_PARAM_ID) {\n', '            value = uint256(param.value);\n', '        } else {\n', '            if (param.id >= _how.length) {\n', '                return false;\n', '            }\n', '            value = uint256(uint240(_how[param.id])); // force lost precision\n', '        }\n', '\n', '        if (Op(param.op) == Op.RET) {\n', '            return uint256(value) > 0;\n', '        }\n', '\n', '        return compare(value, Op(param.op), comparedTo);\n', '    }\n', '\n', '    function evalLogic(Param _param, bytes32 _paramsHash, address _who, address _where, bytes32 _what, uint256[] _how) internal view returns (bool) {\n', '        if (Op(_param.op) == Op.IF_ELSE) {\n', '            var (condition, success, failure) = decodeParamsList(uint256(_param.value));\n', '            bool result = evalParam(_paramsHash, condition, _who, _where, _what, _how);\n', '\n', '            return evalParam(_paramsHash, result ? success : failure, _who, _where, _what, _how);\n', '        }\n', '\n', '        var (v1, v2,) = decodeParamsList(uint256(_param.value));\n', '        bool r1 = evalParam(_paramsHash, v1, _who, _where, _what, _how);\n', '\n', '        if (Op(_param.op) == Op.NOT) {\n', '            return !r1;\n', '        }\n', '\n', '        if (r1 && Op(_param.op) == Op.OR) {\n', '            return true;\n', '        }\n', '\n', '        if (!r1 && Op(_param.op) == Op.AND) {\n', '            return false;\n', '        }\n', '\n', '        bool r2 = evalParam(_paramsHash, v2, _who, _where, _what, _how);\n', '\n', '        if (Op(_param.op) == Op.XOR) {\n', '            return (r1 && !r2) || (!r1 && r2);\n', '        }\n', '\n', '        return r2; // both or and and depend on result of r2 after checks\n', '    }\n', '\n', '    function compare(uint256 _a, Op _op, uint256 _b) internal pure returns (bool) {\n', '        if (_op == Op.EQ)  return _a == _b;                              // solium-disable-line lbrace\n', '        if (_op == Op.NEQ) return _a != _b;                              // solium-disable-line lbrace\n', '        if (_op == Op.GT)  return _a > _b;                               // solium-disable-line lbrace\n', '        if (_op == Op.LT)  return _a < _b;                               // solium-disable-line lbrace\n', '        if (_op == Op.GTE) return _a >= _b;                              // solium-disable-line lbrace\n', '        if (_op == Op.LTE) return _a <= _b;                              // solium-disable-line lbrace\n', '        return false;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function that sets management\n', '    */\n', '    function _setPermissionManager(address _newManager, address _app, bytes32 _role) internal {\n', '        permissionManager[roleHash(_app, _role)] = _newManager;\n', '        ChangePermissionManager(_app, _role, _newManager);\n', '    }\n', '\n', '    function roleHash(address _where, bytes32 _what) pure internal returns (bytes32) {\n', '        return keccak256(uint256(1), _where, _what);\n', '    }\n', '\n', '    function permissionHash(address _who, address _where, bytes32 _what) pure internal returns (bytes32) {\n', '        return keccak256(uint256(2), _who, _where, _what);\n', '    }\n', '\n', '    function time() internal view returns (uint64) { return uint64(block.timestamp); } // solium-disable-line security/no-block-members\n', '\n', '    function blockN() internal view returns (uint256) { return block.number; }\n', '}\n', '\n', '//File: contracts/apm/Repo.sol\n', 'pragma solidity ^0.4.15;\n', '\n', '\n', '\n', '\n', 'contract Repo is AragonApp {\n', '    struct Version {\n', '        uint16[3] semanticVersion;\n', '        address contractAddress;\n', '        bytes contentURI;\n', '    }\n', '\n', '    Version[] versions;\n', '    mapping (bytes32 => uint256) versionIdForSemantic;\n', '    mapping (address => uint256) latestVersionIdForContract;\n', '\n', '    bytes32 constant public CREATE_VERSION_ROLE = bytes32(1);\n', '\n', '    event NewVersion(uint256 versionId, uint16[3] semanticVersion);\n', '\n', '    /**\n', '    * @notice Create new version for repo\n', '    * @param _newSemanticVersion Semantic version for new repo version\n', '    * @param _contractAddress address for smart contract logic for version (if set to 0, it uses last versions&#39; contractAddress)\n', '    * @param _contentURI External URI for fetching new version&#39;s content\n', '    */\n', '    function newVersion(\n', '        uint16[3] _newSemanticVersion,\n', '        address _contractAddress,\n', '        bytes _contentURI\n', '    ) auth(CREATE_VERSION_ROLE) public\n', '    {\n', '        address contractAddress = _contractAddress;\n', '        if (versions.length > 0) {\n', '            Version storage lastVersion = versions[versions.length - 1];\n', '            require(isValidBump(lastVersion.semanticVersion, _newSemanticVersion));\n', '            if (contractAddress == 0) {\n', '                contractAddress = lastVersion.contractAddress;\n', '            }\n', '            // Only allows smart contract change on major version bumps\n', '            require(lastVersion.contractAddress == contractAddress || _newSemanticVersion[0] > lastVersion.semanticVersion[0]);\n', '        } else {\n', '            versions.length += 1;\n', '            uint16[3] memory zeroVersion;\n', '            require(isValidBump(zeroVersion, _newSemanticVersion));\n', '        }\n', '\n', '        uint versionId = versions.push(Version(_newSemanticVersion, contractAddress, _contentURI)) - 1;\n', '        versionIdForSemantic[semanticVersionHash(_newSemanticVersion)] = versionId;\n', '        latestVersionIdForContract[contractAddress] = versionId;\n', '\n', '        NewVersion(versionId, _newSemanticVersion);\n', '    }\n', '\n', '    function getLatest() public view returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI) {\n', '        return getByVersionId(versions.length - 1);\n', '    }\n', '\n', '    function getLatestForContractAddress(address _contractAddress) public view returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI) {\n', '        return getByVersionId(latestVersionIdForContract[_contractAddress]);\n', '    }\n', '\n', '    function getBySemanticVersion(uint16[3] _semanticVersion) public view returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI) {\n', '        return getByVersionId(versionIdForSemantic[semanticVersionHash(_semanticVersion)]);\n', '    }\n', '\n', '    function getByVersionId(uint _versionId) public view returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI) {\n', '        require(_versionId > 0);\n', '        Version storage version = versions[_versionId];\n', '        return (version.semanticVersion, version.contractAddress, version.contentURI);\n', '    }\n', '\n', '    function getVersionsCount() public view returns (uint256) {\n', '        uint256 len = versions.length;\n', '        return len > 0 ? len - 1 : 0;\n', '    }\n', '\n', '    function isValidBump(uint16[3] _oldVersion, uint16[3] _newVersion) public pure returns (bool) {\n', '        bool hasBumped;\n', '        uint i = 0;\n', '        while (i < 3) {\n', '            if (hasBumped) {\n', '                if (_newVersion[i] != 0) {\n', '                    return false;\n', '                }\n', '            } else if (_newVersion[i] != _oldVersion[i]) {\n', '                if (_oldVersion[i] > _newVersion[i] || _newVersion[i] - _oldVersion[i] != 1) {\n', '                    return false;\n', '                }\n', '                hasBumped = true;\n', '            }\n', '            i++;\n', '        }\n', '        return hasBumped;\n', '    }\n', '\n', '    function semanticVersionHash(uint16[3] version) internal pure returns (bytes32) {\n', '        return keccak256(version[0], version[1], version[2]);\n', '    }\n', '}\n', '\n', '//File: contracts/apm/APMRegistry.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract APMRegistryConstants {\n', '    // Cant have a regular APM appId because it is used to build APM\n', '    // TODO: recheck this\n', '    string constant public APM_APP_NAME = "apm-registry";\n', '    string constant public REPO_APP_NAME = "apm-repo";\n', '    string constant public ENS_SUB_APP_NAME = "apm-enssub";\n', '}\n', '\n', '\n', 'contract APMRegistry is AragonApp, AppProxyFactory, APMRegistryConstants {\n', '    AbstractENS ens;\n', '    ENSSubdomainRegistrar public registrar;\n', '\n', '    bytes32 constant public CREATE_REPO_ROLE = bytes32(1);\n', '\n', '    event NewRepo(bytes32 id, string name, address repo);\n', '\n', '    /**\n', '    * NEEDS CREATE_NAME_ROLE and POINT_ROOTNODE_ROLE permissions on registrar\n', '    * @param _registrar ENSSubdomainRegistrar instance that holds registry root node ownership\n', '    */\n', '    function initialize(ENSSubdomainRegistrar _registrar) onlyInit public {\n', '        initialized();\n', '\n', '        registrar = _registrar;\n', '        ens = registrar.ens();\n', '\n', '        registrar.pointRootNode(this);\n', '\n', '        // Check APM has all permissions it needss\n', '        ACL acl = ACL(kernel.acl());\n', '        require(acl.hasPermission(this, registrar, registrar.CREATE_NAME_ROLE()));\n', '        require(acl.hasPermission(this, acl, acl.CREATE_PERMISSIONS_ROLE()));\n', '    }\n', '\n', '    /**\n', '    * @notice Create new repo in registry with `_name`\n', '    * @param _name Repo name, must be ununsed\n', '    * @param _dev Address that will be given permission to create versions\n', '    */\n', '    function newRepo(string _name, address _dev) auth(CREATE_REPO_ROLE) public returns (Repo) {\n', '        return _newRepo(_name, _dev);\n', '    }\n', '\n', '    /**\n', '    * @notice Create new repo in registry with `_name` and first repo version\n', '    * @param _name Repo name\n', '    * @param _dev Address that will be given permission to create versions\n', '    * @param _initialSemanticVersion Semantic version for new repo version\n', '    * @param _contractAddress address for smart contract logic for version (if set to 0, it uses last versions&#39; contractAddress)\n', '    * @param _contentURI External URI for fetching new version&#39;s content\n', '    */\n', '    function newRepoWithVersion(\n', '        string _name,\n', '        address _dev,\n', '        uint16[3] _initialSemanticVersion,\n', '        address _contractAddress,\n', '        bytes _contentURI\n', '    ) auth(CREATE_REPO_ROLE) public returns (Repo)\n', '    {\n', '        Repo repo = _newRepo(_name, this); // need to have permissions to create version\n', '        repo.newVersion(_initialSemanticVersion, _contractAddress, _contentURI);\n', '\n', '        // Give permissions to _dev\n', '        ACL acl = ACL(kernel.acl());\n', '        acl.revokePermission(this, repo, repo.CREATE_VERSION_ROLE());\n', '        acl.grantPermission(_dev, repo, repo.CREATE_VERSION_ROLE());\n', '        acl.setPermissionManager(_dev, repo, repo.CREATE_VERSION_ROLE());\n', '        return repo;\n', '    }\n', '\n', '    function _newRepo(string _name, address _dev) internal returns (Repo) {\n', '        require(bytes(_name).length > 0);\n', '\n', '        Repo repo = newClonedRepo();\n', '\n', '        ACL(kernel.acl()).createPermission(_dev, repo, repo.CREATE_VERSION_ROLE(), _dev);\n', '\n', '        // Creates [name] subdomain in the rootNode and sets registry as resolver\n', '        // This will fail if repo name already exists\n', '        bytes32 node = registrar.createNameAndPoint(keccak256(_name), repo);\n', '\n', '        NewRepo(node, _name, repo);\n', '\n', '        return repo;\n', '    }\n', '\n', '    function newClonedRepo() internal returns (Repo) {\n', '        return Repo(newAppProxy(kernel, repoAppId()));\n', '    }\n', '\n', '    function repoAppId() internal view returns (bytes32) {\n', '        return keccak256(registrar.rootNode(), keccak256(REPO_APP_NAME));\n', '    }\n', '}']