['/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title AccessMint\n', ' * @dev Adds grant/revoke functions to the contract.\n', ' */\n', 'contract AccessMint is Claimable {\n', '\n', '  // Access for minting new tokens.\n', '  mapping(address => bool) private mintAccess;\n', '\n', '  // Modifier for accessibility to define new hero types.\n', '  modifier onlyAccessMint {\n', '    require(msg.sender == owner || mintAccess[msg.sender] == true);\n', '    _;\n', '  }\n', '\n', '  // @dev Grant acess to mint heroes.\n', '  function grantAccessMint(address _address)\n', '    onlyOwner\n', '    public\n', '  {\n', '    mintAccess[_address] = true;\n', '  }\n', '\n', '  // @dev Revoke acess to mint heroes.\n', '  function revokeAccessMint(address _address)\n', '    onlyOwner\n', '    public\n', '  {\n', '    mintAccess[_address] = false;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title AccessDeploy\n', ' * @dev Adds grant/revoke functions to the contract.\n', ' */\n', 'contract AccessDeploy is Claimable {\n', '\n', '  // Access for deploying heroes.\n', '  mapping(address => bool) private deployAccess;\n', '\n', '  // Modifier for accessibility to deploy a hero on a location.\n', '  modifier onlyAccessDeploy {\n', '    require(msg.sender == owner || deployAccess[msg.sender] == true);\n', '    _;\n', '  }\n', '\n', '  // @dev Grant acess to deploy heroes.\n', '  function grantAccessDeploy(address _address)\n', '    onlyOwner\n', '    public\n', '  {\n', '    deployAccess[_address] = true;\n', '  }\n', '\n', '  // @dev Revoke acess to deploy heroes.\n', '  function revokeAccessDeploy(address _address)\n', '    onlyOwner\n', '    public\n', '  {\n', '    deployAccess[_address] = false;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CryptoSagaDungeonProgress\n', ' * @dev Storage contract for progress of dungeons.\n', ' */\n', 'contract CryptoSagaDungeonProgress is Claimable, AccessDeploy {\n', '\n', '  // The progress of the player in dungeons.\n', '  mapping(address => uint32[25]) public addressToProgress;\n', '\n', '  // @dev Get progress.\n', '  function getProgressOfAddressAndId(address _address, uint32 _id)\n', '    external view\n', '    returns (uint32)\n', '  {\n', '    var _progressList = addressToProgress[_address];\n', '    return _progressList[_id];\n', '  }\n', '\n', '  // @dev Increment progress.\n', '  function incrementProgressOfAddressAndId(address _address, uint32 _id)\n', '    onlyAccessDeploy\n', '    public\n', '  {\n', '    var _progressList = addressToProgress[_address];\n', '    _progressList[_id]++;\n', '    addressToProgress[_address] = _progressList;\n', '  }\n', '}']
['/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title AccessMint\n', ' * @dev Adds grant/revoke functions to the contract.\n', ' */\n', 'contract AccessMint is Claimable {\n', '\n', '  // Access for minting new tokens.\n', '  mapping(address => bool) private mintAccess;\n', '\n', '  // Modifier for accessibility to define new hero types.\n', '  modifier onlyAccessMint {\n', '    require(msg.sender == owner || mintAccess[msg.sender] == true);\n', '    _;\n', '  }\n', '\n', '  // @dev Grant acess to mint heroes.\n', '  function grantAccessMint(address _address)\n', '    onlyOwner\n', '    public\n', '  {\n', '    mintAccess[_address] = true;\n', '  }\n', '\n', '  // @dev Revoke acess to mint heroes.\n', '  function revokeAccessMint(address _address)\n', '    onlyOwner\n', '    public\n', '  {\n', '    mintAccess[_address] = false;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title AccessDeploy\n', ' * @dev Adds grant/revoke functions to the contract.\n', ' */\n', 'contract AccessDeploy is Claimable {\n', '\n', '  // Access for deploying heroes.\n', '  mapping(address => bool) private deployAccess;\n', '\n', '  // Modifier for accessibility to deploy a hero on a location.\n', '  modifier onlyAccessDeploy {\n', '    require(msg.sender == owner || deployAccess[msg.sender] == true);\n', '    _;\n', '  }\n', '\n', '  // @dev Grant acess to deploy heroes.\n', '  function grantAccessDeploy(address _address)\n', '    onlyOwner\n', '    public\n', '  {\n', '    deployAccess[_address] = true;\n', '  }\n', '\n', '  // @dev Revoke acess to deploy heroes.\n', '  function revokeAccessDeploy(address _address)\n', '    onlyOwner\n', '    public\n', '  {\n', '    deployAccess[_address] = false;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title CryptoSagaDungeonProgress\n', ' * @dev Storage contract for progress of dungeons.\n', ' */\n', 'contract CryptoSagaDungeonProgress is Claimable, AccessDeploy {\n', '\n', '  // The progress of the player in dungeons.\n', '  mapping(address => uint32[25]) public addressToProgress;\n', '\n', '  // @dev Get progress.\n', '  function getProgressOfAddressAndId(address _address, uint32 _id)\n', '    external view\n', '    returns (uint32)\n', '  {\n', '    var _progressList = addressToProgress[_address];\n', '    return _progressList[_id];\n', '  }\n', '\n', '  // @dev Increment progress.\n', '  function incrementProgressOfAddressAndId(address _address, uint32 _id)\n', '    onlyAccessDeploy\n', '    public\n', '  {\n', '    var _progressList = addressToProgress[_address];\n', '    _progressList[_id]++;\n', '    addressToProgress[_address] = _progressList;\n', '  }\n', '}']
