['pragma solidity ^0.4.16;\n', '\n', 'interface Game {\n', '    event GameStarted(uint betAmount);\n', '    event NewPlayerAdded(uint numPlayers, uint prizeAmount);\n', '    event GameFinished(address winner);\n', '\n', '    function () public payable;                                   //Participate in game. Proxy for play method\n', '    function getPrizeAmount() public constant returns (uint);     //Get potential or actual prize amount\n', '    function getNumWinners() public constant returns(uint, uint);\n', '    function getPlayers() public constant returns(address[]);           //Get full list of players\n', '    function getWinners() public view returns(address[] memory players,\n', '                                                uint[] memory prizes);  //Get winners. Accessable only when finished\n', '    function getStat() public constant returns(uint, uint, uint);       //Short stat on game\n', '\n', '    function calcaultePrizes() public returns (uint[]);\n', '\n', '    function finish() public;                        //Closes game chooses winner\n', '\n', '    function revoke() public;                        //Stop game and return money to players\n', '    // function move(address nextGame);              //Move players bets to another game\n', '}\n', '\n', 'library TicketLib {\n', '    struct Ticket {\n', '        uint40 block_number;\n', '        uint32 block_time;\n', '        uint prize;\n', '    }\n', '}\n', '\n', 'contract UnilotPrizeCalculator {\n', '    //Calculation constants\n', '    uint64  constant accuracy                   = 1000000000000000000;\n', '    uint8  constant MAX_X_FOR_Y                = 195;  // 19.5\n', '\n', '    uint8  constant minPrizeCoeficent          = 1;\n', '    uint8  constant percentOfWinners           = 5;    // 5%\n', '    uint8  constant percentOfFixedPrizeWinners = 20;   // 20%\n', '    uint8  constant gameCommision              = 20;   // 20%\n', '    uint8  constant bonusGameCommision         = 5;    // 5%\n', '    uint8  constant tokenHolerGameCommision    = 5;    // 5%\n', '    // End Calculation constants\n', '\n', '    event Debug(uint);\n', '\n', '    function getPrizeAmount(uint totalAmount)\n', '        public\n', '        pure\n', '        returns (uint result)\n', '    {\n', '        uint totalCommision = gameCommision\n', '                            + bonusGameCommision\n', '                            + tokenHolerGameCommision;\n', '\n', '        //Calculation is odd on purpose.  It is a sort of ceiling effect to\n', '        // maximize amount of prize\n', '        result = ( totalAmount - ( ( totalAmount * totalCommision) / 100) );\n', '\n', '        return result;\n', '    }\n', '\n', '    function getNumWinners(uint numPlayers)\n', '        public\n', '        pure\n', '        returns (uint16 numWinners, uint16 numFixedAmountWinners)\n', '    {\n', '        // Calculation is odd on purpose. It is a sort of ceiling effect to\n', '        // maximize number of winners\n', '        uint16 totaNumlWinners = uint16( numPlayers - ( (numPlayers * ( 100 - percentOfWinners ) ) / 100 ) );\n', '\n', '\n', '        numFixedAmountWinners = uint16( (totaNumlWinners * percentOfFixedPrizeWinners) / 100 );\n', '        numWinners = uint16( totaNumlWinners - numFixedAmountWinners );\n', '\n', '        return (numWinners, numFixedAmountWinners);\n', '    }\n', '\n', '    function calcaultePrizes(uint bet, uint numPlayers)\n', '        public\n', '        pure\n', '        returns (uint[50] memory prizes)\n', '    {\n', '        var (numWinners, numFixedAmountWinners) = getNumWinners(numPlayers);\n', '\n', '        require( uint(numWinners + numFixedAmountWinners) <= prizes.length );\n', '\n', '        uint[] memory y = new uint[]((numWinners - 1));\n', '        uint z = 0; // Sum of all Y values\n', '\n', '        if ( numWinners == 1 ) {\n', '            prizes[0] = getPrizeAmount(uint(bet*numPlayers));\n', '\n', '            return prizes;\n', '        } else if ( numWinners < 1 ) {\n', '            return prizes;\n', '        }\n', '\n', '        for (uint i = 0; i < y.length; i++) {\n', '            y[i] = formula( (calculateStep(numWinners) * i) );\n', '            z += y[i];\n', '        }\n', '\n', '        bool stop = false;\n', '\n', '        for (i = 0; i < 10; i++) {\n', '            uint[5] memory chunk = distributePrizeCalculation(\n', '                i, z, y, numPlayers, bet);\n', '\n', '            for ( uint j = 0; j < chunk.length; j++ ) {\n', '                if ( ( (i * chunk.length) + j ) >= ( numWinners + numFixedAmountWinners ) ) {\n', '                    stop = true;\n', '                    break;\n', '                }\n', '\n', '                prizes[ (i * chunk.length) + j ] = chunk[j];\n', '            }\n', '\n', '            if ( stop ) {\n', '                break;\n', '            }\n', '        }\n', '\n', '        return prizes;\n', '    }\n', '\n', '    function distributePrizeCalculation (uint chunkNumber, uint z, uint[] memory y, uint totalNumPlayers, uint bet)\n', '        private\n', '        pure\n', '        returns (uint[5] memory prizes)\n', '    {\n', '        var(numWinners, numFixedAmountWinners) = getNumWinners(totalNumPlayers);\n', '        uint prizeAmountForDeligation = getPrizeAmount( (totalNumPlayers * bet) );\n', '        prizeAmountForDeligation -= uint( ( bet * minPrizeCoeficent ) * uint( numWinners + numFixedAmountWinners ) );\n', '\n', '        uint mainWinnerBaseAmount = ( (prizeAmountForDeligation * accuracy) / ( ( ( z * accuracy ) / ( 2 * y[0] ) ) + ( 1 * accuracy ) ) );\n', '        uint undeligatedAmount    = prizeAmountForDeligation;\n', '\n', '        uint startPoint = chunkNumber * prizes.length;\n', '\n', '        for ( uint i = 0; i < prizes.length; i++ ) {\n', '            if ( i >= uint(numWinners + numFixedAmountWinners) ) {\n', '                break;\n', '            }\n', '            prizes[ i ] = (bet * minPrizeCoeficent);\n', '            uint extraPrize = 0;\n', '\n', '            if ( i == ( numWinners - 1 ) ) {\n', '                extraPrize = undeligatedAmount;\n', '            } else if ( i == 0 && chunkNumber == 0 ) {\n', '                extraPrize = mainWinnerBaseAmount;\n', '            } else if ( ( startPoint + i ) < numWinners ) {\n', '                extraPrize = ( ( y[ ( startPoint + i ) - 1 ] * (prizeAmountForDeligation - mainWinnerBaseAmount) ) / z);\n', '            }\n', '\n', '            prizes[ i ] += extraPrize;\n', '            undeligatedAmount -= extraPrize;\n', '        }\n', '\n', '        return prizes;\n', '    }\n', '\n', '    function formula(uint x)\n', '        public\n', '        pure\n', '        returns (uint y)\n', '    {\n', '        y = ( (1 * accuracy**2) / (x + (5*accuracy/10))) - ((5 * accuracy) / 100);\n', '\n', '        return y;\n', '    }\n', '\n', '    function calculateStep(uint numWinners)\n', '        public\n', '        pure\n', '        returns(uint step)\n', '    {\n', '        step = ( MAX_X_FOR_Y * accuracy / 10 ) / numWinners;\n', '\n', '        return step;\n', '    }\n', '}\n', '\n', 'contract BaseUnilotGame is Game {\n', '    enum State {\n', '        ACTIVE,\n', '        ENDED,\n', '        REVOKING,\n', '        REVOKED,\n', '        MOVED\n', '    }\n', '\n', '    event PrizeResultCalculated(uint size, uint[] prizes);\n', '\n', '    State state;\n', '    address administrator;\n', '    uint bet;\n', '\n', '    mapping (address => TicketLib.Ticket) internal tickets;\n', '    address[] internal ticketIndex;\n', '\n', '    UnilotPrizeCalculator calculator;\n', '\n', '    //Modifiers\n', '    modifier onlyAdministrator() {\n', '        require(msg.sender == administrator);\n', '        _;\n', '    }\n', '\n', '    modifier onlyPlayer() {\n', '        require(msg.sender != administrator);\n', '        _;\n', '    }\n', '\n', '    modifier validBet() {\n', '        require(msg.value == bet);\n', '        _;\n', '    }\n', '\n', '    modifier activeGame() {\n', '        require(state == State.ACTIVE);\n', '        _;\n', '    }\n', '\n', '    modifier inactiveGame() {\n', '        require(state != State.ACTIVE);\n', '        _;\n', '    }\n', '\n', '    modifier finishedGame() {\n', '        require(state == State.ENDED);\n', '        _;\n', '    }\n', '\n', '    //Private methods\n', '\n', '    function getState()\n', '        public\n', '        view\n', '        returns(State)\n', '    {\n', '        return state;\n', '    }\n', '\n', '    function getBet()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return bet;\n', '    }\n', '\n', '    function getPlayers()\n', '        public\n', '        constant\n', '        returns(address[])\n', '    {\n', '        return ticketIndex;\n', '    }\n', '\n', '    function getPlayerDetails(address player)\n', '        public\n', '        view\n', '        inactiveGame\n', '        returns (uint, uint, uint)\n', '    {\n', '        TicketLib.Ticket memory ticket = tickets[player];\n', '\n', '        return (ticket.block_number, ticket.block_time, ticket.prize);\n', '    }\n', '\n', '    function getNumWinners()\n', '        public\n', '        constant\n', '        returns (uint, uint)\n', '    {\n', '        var(numWinners, numFixedAmountWinners) = calculator.getNumWinners(ticketIndex.length);\n', '\n', '        return (numWinners, numFixedAmountWinners);\n', '    }\n', '\n', '    function getPrizeAmount()\n', '        public\n', '        constant\n', '        returns (uint result)\n', '    {\n', '        uint totalAmount = this.balance;\n', '\n', '        if ( state == State.ENDED ) {\n', '            totalAmount = bet * ticketIndex.length;\n', '        }\n', '\n', '        result = calculator.getPrizeAmount(totalAmount);\n', '\n', '        return result;\n', '    }\n', '\n', '    function getStat()\n', '        public\n', '        constant\n', '        returns ( uint, uint, uint )\n', '    {\n', '        var (numWinners, numFixedAmountWinners) = getNumWinners();\n', '        return (ticketIndex.length, getPrizeAmount(), uint(numWinners + numFixedAmountWinners));\n', '    }\n', '\n', '    function calcaultePrizes()\n', '        public\n', '        returns(uint[] memory result)\n', '    {\n', '        var(numWinners, numFixedAmountWinners) = getNumWinners();\n', '        uint16 totalNumWinners = uint16( numWinners + numFixedAmountWinners );\n', '        result = new uint[]( totalNumWinners );\n', '\n', '\n', '        uint[50] memory prizes = calculator.calcaultePrizes(\n', '        bet, ticketIndex.length);\n', '\n', '        for (uint16 i = 0; i < totalNumWinners; i++) {\n', '            result[i] = prizes[i];\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    function revoke()\n', '        public\n', '        onlyAdministrator\n', '        activeGame\n', '    {\n', '        for (uint24 i = 0; i < ticketIndex.length; i++) {\n', '            ticketIndex[i].transfer(bet);\n', '        }\n', '\n', '        state = State.REVOKED;\n', '    }\n', '}\n', '\n', '\n', 'contract UnilotTailEther is BaseUnilotGame {\n', '\n', '    uint64 winnerIndex;\n', '\n', '    //Public methods\n', '    function UnilotTailEther(uint betAmount, address calculatorContractAddress)\n', '        public\n', '    {\n', '        state = State.ACTIVE;\n', '        administrator = msg.sender;\n', '        bet = betAmount;\n', '\n', '        calculator = UnilotPrizeCalculator(calculatorContractAddress);\n', '\n', '        GameStarted(betAmount);\n', '    }\n', '\n', '    function getWinners()\n', '        public\n', '        view\n', '        finishedGame\n', '        returns(address[] memory players, uint[] memory prizes)\n', '    {\n', '        var(numWinners, numFixedAmountWinners) = getNumWinners();\n', '        uint totalNumWinners = numWinners + numFixedAmountWinners;\n', '\n', '        players = new address[](totalNumWinners);\n', '        prizes = new uint[](totalNumWinners);\n', '\n', '        uint index;\n', '\n', '        for (uint i = 0; i < totalNumWinners; i++) {\n', '            if ( i > winnerIndex ) {\n', '                index = ( ( players.length ) - ( i - winnerIndex ) );\n', '            } else {\n', '                index = ( winnerIndex - i );\n', '            }\n', '\n', '            players[i] = ticketIndex[index];\n', '            prizes[i] = tickets[players[i]].prize;\n', '        }\n', '\n', '        return (players, prizes);\n', '    }\n', '\n', '    function ()\n', '        public\n', '        payable\n', '        validBet\n', '        onlyPlayer\n', '    {\n', '        require(tickets[msg.sender].block_number == 0);\n', '        require(ticketIndex.length <= 1000);\n', '\n', '        tickets[msg.sender].block_number = uint40(block.number);\n', '        tickets[msg.sender].block_time   = uint32(block.timestamp);\n', '\n', '        ticketIndex.push(msg.sender);\n', '\n', '        NewPlayerAdded(ticketIndex.length, getPrizeAmount());\n', '    }\n', '\n', '    function finish()\n', '        public\n', '        onlyAdministrator\n', '        activeGame\n', '    {\n', '        uint64 max_votes;\n', '        uint64[] memory num_votes = new uint64[](ticketIndex.length);\n', '\n', '        for (uint i = 0; i < ticketIndex.length; i++) {\n', '            TicketLib.Ticket memory ticket = tickets[ticketIndex[i]];\n', '            uint64 vote = uint64( ( ( ticket.block_number * ticket.block_time ) + uint( ticketIndex[i]) ) % ticketIndex.length );\n', '\n', '            num_votes[vote] += 1;\n', '\n', '            if ( num_votes[vote] > max_votes ) {\n', '                max_votes = num_votes[vote];\n', '                winnerIndex = vote;\n', '            }\n', '        }\n', '\n', '        uint[] memory prizes = calcaultePrizes();\n', '\n', '        uint lastId = winnerIndex;\n', '\n', '        for ( i = 0; i < prizes.length; i++ ) {\n', '            tickets[ticketIndex[lastId]].prize = prizes[i];\n', '            ticketIndex[lastId].transfer(prizes[i]);\n', '\n', '            if ( lastId <= 0 ) {\n', '                lastId = ticketIndex.length;\n', '            }\n', '\n', '            lastId -= 1;\n', '        }\n', '\n', '        administrator.transfer(this.balance);\n', '\n', '        state = State.ENDED;\n', '\n', '        GameFinished(ticketIndex[winnerIndex]);\n', '    }\n', '}']