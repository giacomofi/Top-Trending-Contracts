['/**\n', ' * The edgeless casino contract v2 holds the players&#39;s funds and provides state channel functionality.\n', ' * The casino has at no time control over the players&#39;s funds.\n', ' * State channels can be updated and closed from both parties: the player and the casino.\n', ' * author: Julia Altenried\n', ' **/\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract SafeMath {\n', '\n', '\tfunction safeSub(uint a, uint b) pure internal returns(uint) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\t\n', '\tfunction safeSub(int a, int b) pure internal returns(int) {\n', '\t\tif(b < 0) assert(a - b > a);\n', '\t\telse assert(a - b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction safeAdd(uint a, uint b) pure internal returns(uint) {\n', '\t\tuint c = a + b;\n', '\t\tassert(c >= a && c >= b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction safeMul(uint a, uint b) pure internal returns (uint) {\n', '\t\tuint c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', '\n', 'contract Token {\n', '\tfunction transferFrom(address sender, address receiver, uint amount) public returns(bool success);\n', '\n', '\tfunction transfer(address receiver, uint amount) public returns(bool success);\n', '\n', '\tfunction balanceOf(address holder) public view returns(uint);\n', '}\n', '\n', 'contract Owned {\n', '  address public owner;\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function Owned() public{\n', '    owner = msg.sender;\n', '  }\n', '\n', '}\n', '\n', '/** owner should be able to close the contract is nobody has been using it for at least 30 days */\n', 'contract Mortal is Owned {\n', '\t/** contract can be closed by the owner anytime after this timestamp if non-zero */\n', '\tuint public closeAt;\n', '\t/** the edgeless token contract */\n', '\tToken edg;\n', '\t\n', '\tfunction Mortal(address tokenContract) internal{\n', '\t\tedg = Token(tokenContract);\n', '\t}\n', '\t/**\n', '\t* lets the owner close the contract if there are no player funds on it or if nobody has been using it for at least 30 days\n', '\t*/\n', '  function closeContract(uint playerBalance) internal{\n', '\t\tif(closeAt == 0) closeAt = now + 30 days;\n', '\t\tif(closeAt < now || playerBalance == 0){\n', '\t\t\tedg.transfer(owner, edg.balanceOf(address(this)));\n', '\t\t\tselfdestruct(owner);\n', '\t\t} \n', '  }\n', '\n', '\t/**\n', '\t* in case close has been called accidentally.\n', '\t**/\n', '\tfunction open() onlyOwner public{\n', '\t\tcloseAt = 0;\n', '\t}\n', '\n', '\t/**\n', '\t* make sure the contract is not in process of being closed.\n', '\t**/\n', '\tmodifier isAlive {\n', '\t\trequire(closeAt == 0);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* delays the time of closing.\n', '\t**/\n', '\tmodifier keepAlive {\n', '\t\tif(closeAt > 0) closeAt = now + 30 days;\n', '\t\t_;\n', '\t}\n', '}\n', '\n', 'contract RequiringAuthorization is Mortal {\n', '\t/** indicates if an address is authorized to act in the casino&#39;s name  */\n', '\tmapping(address => bool) public authorized;\n', '\t/** tells if an address is allowed to receive funds from the bankroll **/\n', '\tmapping(address => bool) public allowedReceiver;\n', '\n', '\tmodifier onlyAuthorized {\n', '\t\trequire(authorized[msg.sender]);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * Constructor. Authorize the owner.\n', '\t * */\n', '\tfunction RequiringAuthorization() internal {\n', '\t\tauthorized[msg.sender] = true;\n', '\t\tallowedReceiver[msg.sender] = true;\n', '\t}\n', '\n', '\t/**\n', '\t * authorize a address to call game functions and set configs.\n', '\t * @param addr the address to be authorized\n', '\t **/\n', '\tfunction authorize(address addr) public onlyOwner {\n', '\t\tauthorized[addr] = true;\n', '\t}\n', '\n', '\t/**\n', '\t * deauthorize a address to call game functions and set configs.\n', '\t * @param addr the address to be deauthorized\n', '\t **/\n', '\tfunction deauthorize(address addr) public onlyOwner {\n', '\t\tauthorized[addr] = false;\n', '\t}\n', '\n', '\t/**\n', '\t * allow authorized wallets to withdraw funds from the bonkroll to this address\n', '\t * @param receiver the receiver&#39;s address\n', '\t * */\n', '\tfunction allowReceiver(address receiver) public onlyOwner {\n', '\t\tallowedReceiver[receiver] = true;\n', '\t}\n', '\n', '\t/**\n', '\t * disallow authorized wallets to withdraw funds from the bonkroll to this address\n', '\t * @param receiver the receiver&#39;s address\n', '\t * */\n', '\tfunction disallowReceiver(address receiver) public onlyOwner {\n', '\t\tallowedReceiver[receiver] = false;\n', '\t}\n', '\n', '\t/**\n', '\t * changes the owner of the contract. revokes authorization of the old owner and authorizes the new one.\n', '\t * @param newOwner the address of the new owner\n', '\t * */\n', '\tfunction changeOwner(address newOwner) public onlyOwner {\n', '\t\tdeauthorize(owner);\n', '\t\tauthorize(newOwner);\n', '\t\tdisallowReceiver(owner);\n', '\t\tallowReceiver(newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '}\n', '\n', 'contract ChargingGas is RequiringAuthorization, SafeMath {\n', '\t/** 1 EDG has 5 decimals **/\n', '\tuint public constant oneEDG = 100000;\n', '\t/** the price per kgas and GWei in tokens (with decimals) */\n', '\tuint public gasPrice;\n', '\t/** the amount of gas used per transaction in kGas */\n', '\tmapping(bytes4 => uint) public gasPerTx;\n', '\t/** the number of tokens (5 decimals) payed by the users to cover the gas cost */\n', '\tuint public gasPayback;\n', '\t\n', '\tfunction ChargingGas(uint kGasPrice) internal{\n', '\t\t//deposit, withdrawFor, updateChannel, updateBatch, transferToNewContract\n', '\t    bytes4[5] memory signatures = [bytes4(0x3edd1128),0x9607610a, 0xde48ff52, 0xc97b6d1f, 0x6bf06fde];\n', '\t    //amount of gas consumed by the above methods in GWei\n', '\t    uint[5] memory gasUsage = [uint(146), 100, 65, 50, 85];\n', '\t    setGasUsage(signatures, gasUsage);\n', '\t    setGasPrice(kGasPrice);\n', '\t}\n', '\t/**\n', '\t * sets the amount of gas consumed by methods with the given sigantures.\n', '\t * only called from the edgeless casino constructor.\n', '\t * @param signatures an array of method-signatures\n', '\t *        gasNeeded  the amount of gas consumed by these methods\n', '\t * */\n', '\tfunction setGasUsage(bytes4[5] signatures, uint[5] gasNeeded) public onlyOwner {\n', '\t\trequire(signatures.length == gasNeeded.length);\n', '\t\tfor (uint8 i = 0; i < signatures.length; i++)\n', '\t\t\tgasPerTx[signatures[i]] = gasNeeded[i];\n', '\t}\n', '\n', '\t/**\n', '\t * updates the price per 1000 gas in EDG.\n', '\t * @param price the new gas price (with decimals, max 0.1 EDG)\n', '\t **/\n', '\tfunction setGasPrice(uint price) public onlyAuthorized {\n', '\t\trequire(price < oneEDG/10);\n', '\t\tgasPrice = price;\n', '\t}\n', '\n', '\t/**\n', '\t * returns the gas cost of the called function.\n', '\t * */\n', '\tfunction getGasCost() internal view returns(uint) {\n', '\t\treturn safeMul(safeMul(gasPerTx[msg.sig], gasPrice), tx.gasprice) / 1000000000;\n', '\t}\n', '\n', '}\n', '\n', '\n', 'contract CasinoBank is ChargingGas {\n', '\t/** the total balance of all players with virtual decimals **/\n', '\tuint public playerBalance;\n', '\t/** the balance per player in edgeless tokens with virtual decimals */\n', '\tmapping(address => uint) public balanceOf;\n', '\t/** in case the user wants/needs to call the withdraw function from his own wallet, he first needs to request a withdrawal */\n', '\tmapping(address => uint) public withdrawAfter;\n', '\t/** a number to count withdrawal signatures to ensure each signature is different even if withdrawing the same amount to the same address */\n', '\tmapping(address => uint) public withdrawCount;\n', '\t/** the maximum amount of tokens the user is allowed to deposit (with decimals) */\n', '\tuint public maxDeposit;\n', '\t/** the maximum withdrawal of tokens the user is allowed to withdraw on one day (only enforced when the tx is not sent from an authorized wallet) **/\n', '\tuint public maxWithdrawal;\n', '\t/** waiting time for withdrawal if not requested via the server **/\n', '\tuint public waitingTime;\n', '\t/** the address of the predecessor **/\n', '\taddress public predecessor;\n', '\n', '\t/** informs listeners how many tokens were deposited for a player */\n', '\tevent Deposit(address _player, uint _numTokens, uint _gasCost);\n', '\t/** informs listeners how many tokens were withdrawn from the player to the receiver address */\n', '\tevent Withdrawal(address _player, address _receiver, uint _numTokens, uint _gasCost);\n', '\t\n', '\t\n', '\t/**\n', '\t * Constructor.\n', '\t * @param depositLimit    the maximum deposit allowed\n', '\t *\t\t  predecessorAddr the address of the predecessing contract\n', '\t * */\n', '\tfunction CasinoBank(uint depositLimit, address predecessorAddr) internal {\n', '\t\tmaxDeposit = depositLimit * oneEDG;\n', '\t\tmaxWithdrawal = maxDeposit;\n', '\t\twaitingTime = 24 hours;\n', '\t\tpredecessor = predecessorAddr;\n', '\t}\n', '\n', '\t/**\n', '\t * accepts deposits for an arbitrary address.\n', '\t * retrieves tokens from the message sender and adds them to the balance of the specified address.\n', '\t * edgeless tokens do not have any decimals, but are represented on this contract with decimals.\n', '\t * @param receiver  address of the receiver\n', '\t *        numTokens number of tokens to deposit (0 decimals)\n', '\t *\t\t\t\t chargeGas indicates if the gas cost is subtracted from the user&#39;s edgeless token balance\n', '\t **/\n', '\tfunction deposit(address receiver, uint numTokens, bool chargeGas) public isAlive {\n', '\t\trequire(numTokens > 0);\n', '\t\tuint value = safeMul(numTokens, oneEDG);\n', '\t\tuint gasCost;\n', '\t\tif (chargeGas) {\n', '\t\t\tgasCost = getGasCost();\n', '\t\t\tvalue = safeSub(value, gasCost);\n', '\t\t\tgasPayback = safeAdd(gasPayback, gasCost);\n', '\t\t}\n', '\t\tuint newBalance = safeAdd(balanceOf[receiver], value);\n', '\t\trequire(newBalance <= maxDeposit);\n', '\t\tassert(edg.transferFrom(msg.sender, address(this), numTokens));\n', '\t\tbalanceOf[receiver] = newBalance;\n', '\t\tplayerBalance = safeAdd(playerBalance, value);\n', '\t\temit Deposit(receiver, numTokens, gasCost);\n', '\t}\n', '\n', '\t/**\n', '\t * If the user wants/needs to withdraw his funds himself, he needs to request the withdrawal first.\n', '\t * This method sets the earliest possible withdrawal date to &#39;waitingTime from now (default 90m, but up to 24h).\n', '\t * Reason: The user should not be able to withdraw his funds, while the the last game methods have not yet been mined.\n', '\t **/\n', '\tfunction requestWithdrawal() public {\n', '\t\twithdrawAfter[msg.sender] = now + waitingTime;\n', '\t}\n', '\n', '\t/**\n', '\t * In case the user requested a withdrawal and changes his mind.\n', '\t * Necessary to be able to continue playing.\n', '\t **/\n', '\tfunction cancelWithdrawalRequest() public {\n', '\t\twithdrawAfter[msg.sender] = 0;\n', '\t}\n', '\n', '\t/**\n', '\t * withdraws an amount from the user balance if the waiting time passed since the request.\n', '\t * @param amount the amount of tokens to withdraw\n', '\t **/\n', '\tfunction withdraw(uint amount) public keepAlive {\n', '\t\trequire(amount <= maxWithdrawal);\n', '\t\trequire(withdrawAfter[msg.sender] > 0 && now > withdrawAfter[msg.sender]);\n', '\t\twithdrawAfter[msg.sender] = 0;\n', '\t\tuint value = safeMul(amount, oneEDG);\n', '\t\tbalanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value);\n', '\t\tplayerBalance = safeSub(playerBalance, value);\n', '\t\tassert(edg.transfer(msg.sender, amount));\n', '\t\temit Withdrawal(msg.sender, msg.sender, amount, 0);\n', '\t}\n', '\n', '\t/**\n', '\t * lets the owner withdraw from the bankroll\n', '\t * @param receiver the receiver&#39;s address\n', '\t *\t\t\t\tnumTokens the number of tokens to withdraw (0 decimals)\n', '\t **/\n', '\tfunction withdrawBankroll(address receiver, uint numTokens) public onlyAuthorized {\n', '\t\trequire(numTokens <= bankroll());\n', '\t\trequire(allowedReceiver[receiver]);\n', '\t\tassert(edg.transfer(receiver, numTokens));\n', '\t}\n', '\n', '\t/**\n', '\t * withdraw the gas payback to the owner\n', '\t **/\n', '\tfunction withdrawGasPayback() public onlyAuthorized {\n', '\t\tuint payback = gasPayback / oneEDG;\n', '\t\tassert(payback > 0);\n', '\t\tgasPayback = safeSub(gasPayback, payback * oneEDG);\n', '\t\tassert(edg.transfer(owner, payback));\n', '\t}\n', '\n', '\t/**\n', '\t * returns the current bankroll in tokens with 0 decimals\n', '\t **/\n', '\tfunction bankroll() view public returns(uint) {\n', '\t\treturn safeSub(edg.balanceOf(address(this)), safeAdd(playerBalance, gasPayback) / oneEDG);\n', '\t}\n', '\n', '\n', '\t/**\n', '\t * updates the maximum deposit.\n', '\t * @param newMax the new maximum deposit (0 decimals)\n', '\t **/\n', '\tfunction setMaxDeposit(uint newMax) public onlyAuthorized {\n', '\t\tmaxDeposit = newMax * oneEDG;\n', '\t}\n', '\t\n', '\t/**\n', '\t * updates the maximum withdrawal.\n', '\t * @param newMax the new maximum withdrawal (0 decimals)\n', '\t **/\n', '\tfunction setMaxWithdrawal(uint newMax) public onlyAuthorized {\n', '\t\tmaxWithdrawal = newMax * oneEDG;\n', '\t}\n', '\n', '\t/**\n', '\t * sets the time the player has to wait for his funds to be unlocked before withdrawal (if not withdrawing with help of the casino server).\n', '\t * the time may not be longer than 24 hours.\n', '\t * @param newWaitingTime the new waiting time in seconds\n', '\t * */\n', '\tfunction setWaitingTime(uint newWaitingTime) public onlyAuthorized  {\n', '\t\trequire(newWaitingTime <= 24 hours);\n', '\t\twaitingTime = newWaitingTime;\n', '\t}\n', '\n', '\t/**\n', '\t * transfers an amount from the contract balance to the owner&#39;s wallet.\n', '\t * @param receiver the receiver address\n', '\t *\t\t\t\t amount   the amount of tokens to withdraw (0 decimals)\n', '\t *\t\t\t\t v,r,s \t\tthe signature of the player\n', '\t **/\n', '\tfunction withdrawFor(address receiver, uint amount, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized keepAlive {\n', '\t\taddress player = ecrecover(keccak256(receiver, amount, withdrawCount[receiver]), v, r, s);\n', '\t\twithdrawCount[receiver]++;\n', '\t\tuint gasCost = getGasCost();\n', '\t\tuint value = safeAdd(safeMul(amount, oneEDG), gasCost);\n', '\t\tgasPayback = safeAdd(gasPayback, gasCost);\n', '\t\tbalanceOf[player] = safeSub(balanceOf[player], value);\n', '\t\tplayerBalance = safeSub(playerBalance, value);\n', '\t\tassert(edg.transfer(receiver, amount));\n', '\t\temit Withdrawal(player, receiver, amount, gasCost);\n', '\t}\n', '\t\n', '\t/**\n', '\t * transfers the player&#39;s tokens directly to the new casino contract after an update.\n', '\t * @param newCasino the address of the new casino contract\n', '\t *\t\t  v, r, s   the signature of the player\n', '\t *\t\t  chargeGas indicates if the gas cost is payed by the player.\n', '\t * */\n', '\tfunction transferToNewContract(address newCasino, uint8 v, bytes32 r, bytes32 s, bool chargeGas) public onlyAuthorized keepAlive {\n', '\t\taddress player = ecrecover(keccak256(address(this), newCasino), v, r, s);\n', '\t\tuint gasCost = 0;\n', '\t\tif(chargeGas) gasCost = getGasCost();\n', '\t\tuint value = safeSub(balanceOf[player], gasCost);\n', '\t\trequire(value > oneEDG);\n', '\t\t//fractions of one EDG cannot be withdrawn \n', '\t\tvalue /= oneEDG;\n', '\t\tplayerBalance = safeSub(playerBalance, balanceOf[player]);\n', '\t\tbalanceOf[player] = 0;\n', '\t\tassert(edg.transfer(newCasino, value));\n', '\t\temit Withdrawal(player, newCasino, value, gasCost);\n', '\t\tCasinoBank cb = CasinoBank(newCasino);\n', '\t\tassert(cb.credit(player, value));\n', '\t}\n', '\t\n', '\t/**\n', '\t * receive a player balance from the predecessor contract.\n', '\t * @param player the address of the player to credit the value for\n', '\t *\t\t\t\tvalue  the number of tokens to credit (0 decimals)\n', '\t * */\n', '\tfunction credit(address player, uint value) public returns(bool) {\n', '\t\trequire(msg.sender == predecessor);\n', '\t\tuint valueWithDecimals = safeMul(value, oneEDG);\n', '\t\tbalanceOf[player] = safeAdd(balanceOf[player], valueWithDecimals);\n', '\t\tplayerBalance = safeAdd(playerBalance, valueWithDecimals);\n', '\t\temit Deposit(player, value, 0);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * lets the owner close the contract if there are no player funds on it or if nobody has been using it for at least 30 days\n', '\t * */\n', '\tfunction close() public onlyOwner {\n', '\t\tcloseContract(playerBalance);\n', '\t}\n', '}\n', '\n', '\n', 'contract EdgelessCasino is CasinoBank{\n', '\t/** the most recent known state of a state channel */\n', '\tmapping(address => State) public lastState;\n', '\t/** fired when the state is updated */\n', '\tevent StateUpdate(address player, uint128 count, int128 winBalance, int difference, uint gasCost);\n', '  /** fired if one of the parties chooses to log the seeds and results */\n', '  event GameData(address player, bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint gasCost);\n', '  \n', '\tstruct State{\n', '\t\tuint128 count;\n', '\t\tint128 winBalance;\n', '\t}\n', '\n', '\n', '  /**\n', '  * creates a new edgeless casino contract.\n', '  * @param predecessorAddress the address of the predecessing contract\n', '\t*\t\t\t\t tokenContract      the address of the Edgeless token contract\n', '\t* \t\t\t depositLimit       the maximum deposit allowed\n', '\t* \t\t\t kGasPrice\t\t\t\t  the price per kGas in WEI\n', '  **/\n', '  function EdgelessCasino(address predecessorAddress, address tokenContract, uint depositLimit, uint kGasPrice) CasinoBank(depositLimit, predecessorAddress) Mortal(tokenContract) ChargingGas(kGasPrice) public{\n', '\n', '  }\n', '  \n', '  /**\n', '   * updates several state channels at once. can be called by authorized wallets only.\n', '   * 1. determines the player address from the signature.\n', '   * 2. verifies if the signed game-count is higher than the last known game-count of this channel.\n', '   * 3. updates the balances accordingly. This means: It checks the already performed updates for this channel and computes\n', '   *    the new balance difference to add or subtract from the player‘s balance.\n', '   * @param winBalances array of the current wins or losses\n', '   *\t\t\t\tgameCounts  array of the numbers of signed game moves\n', '   *\t\t\t\tv,r,s       array of the players&#39;s signatures\n', '   *        chargeGas   indicates if the gas costs should be subtracted from the players&#39;s balances\n', '   * */\n', '  function updateBatch(int128[] winBalances,  uint128[] gameCounts, uint8[] v, bytes32[] r, bytes32[] s, bool chargeGas) public onlyAuthorized{\n', '    require(winBalances.length == gameCounts.length);\n', '    require(winBalances.length == v.length);\n', '    require(winBalances.length == r.length);\n', '    require(winBalances.length == s.length);\n', '    require(winBalances.length <= 50);\n', '    address player;\n', '    uint gasCost = 0;\n', '    if(chargeGas) \n', '      gasCost = getGasCost();\n', '    gasPayback = safeAdd(gasPayback, safeMul(gasCost, winBalances.length));\n', '    for(uint8 i = 0; i < winBalances.length; i++){\n', '      player = ecrecover(keccak256(winBalances[i], gameCounts[i]), v[i], r[i], s[i]);\n', '      _updateState(player, winBalances[i], gameCounts[i], gasCost);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * updates a state channel. can be called by both parties.\n', '   * 1. verifies the signature.\n', '   * 2. verifies if the signed game-count is higher than the last known game-count of this channel.\n', '   * 3. updates the balances accordingly. This means: It checks the already performed updates for this channel and computes\n', '   *    the new balance difference to add or subtract from the player‘s balance.\n', '   * @param winBalance the current win or loss\n', '   *\t\t\t\tgameCount  the number of signed game moves\n', '   *\t\t\t\tv,r,s      the signature of either the casino or the player\n', '   *        chargeGas  indicates if the gas costs should be subtracted from the player&#39;s balance\n', '   * */\n', '  function updateState(int128 winBalance,  uint128 gameCount, uint8 v, bytes32 r, bytes32 s, bool chargeGas) public{\n', '  \taddress player = determinePlayer(winBalance, gameCount, v, r, s);\n', '  \tuint gasCost = 0;\n', '  \tif(player == msg.sender)//if the player closes the state channel himself, make sure the signer is a casino wallet\n', '  \t\trequire(authorized[ecrecover(keccak256(player, winBalance, gameCount), v, r, s)]);\n', '  \telse if (chargeGas){//subtract the gas costs from the player balance only if the casino wallet is the sender\n', '  \t\tgasCost = getGasCost();\n', '  \t\tgasPayback = safeAdd(gasPayback, gasCost);\n', '  \t}\n', '  \t_updateState(player, winBalance, gameCount, gasCost);\n', '  }\n', '  \n', '  /**\n', '   * internal method to perform the actual state update.\n', '   * @param player the player address\n', '   *        winBalance the player&#39;s win balance\n', '   *        gameCount  the player&#39;s game count\n', '   * */\n', '  function _updateState(address player, int128 winBalance,  uint128 gameCount, uint gasCost) internal {\n', '    State storage last = lastState[player];\n', '  \trequire(gameCount > last.count);\n', '  \tint difference = updatePlayerBalance(player, winBalance, last.winBalance, gasCost);\n', '  \tlastState[player] = State(gameCount, winBalance);\n', '  \temit StateUpdate(player, gameCount, winBalance, difference, gasCost);\n', '  }\n', '\n', '  /**\n', '   * determines if the msg.sender or the signer of the passed signature is the player. returns the player&#39;s address\n', '   * @param winBalance the current winBalance, used to calculate the msg hash\n', '   *\t\t\t\tgameCount  the current gameCount, used to calculate the msg.hash\n', '   *\t\t\t\tv, r, s    the signature of the non-sending party\n', '   * */\n', '  function determinePlayer(int128 winBalance, uint128 gameCount, uint8 v, bytes32 r, bytes32 s) view internal returns(address){\n', '  \tif (authorized[msg.sender])//casino is the sender -> player is the signer\n', '  \t\treturn ecrecover(keccak256(winBalance, gameCount), v, r, s);\n', '  \telse\n', '  \t\treturn msg.sender;\n', '  }\n', '\n', '\t/**\n', '\t * computes the difference of the win balance relative to the last known state and adds it to the player&#39;s balance.\n', '\t * in case the casino is the sender, the gas cost in EDG gets subtracted from the player&#39;s balance.\n', '\t * @param player the address of the player\n', '\t *\t\t\t\twinBalance the current win-balance\n', '\t *\t\t\t\tlastWinBalance the win-balance of the last known state\n', '\t *\t\t\t\tgasCost the gas cost of the tx\n', '\t * */\n', '  function updatePlayerBalance(address player, int128 winBalance, int128 lastWinBalance, uint gasCost) internal returns(int difference){\n', '  \tdifference = safeSub(winBalance, lastWinBalance);\n', '  \tint outstanding = safeSub(difference, int(gasCost));\n', '  \tuint outs;\n', '  \tif(outstanding < 0){\n', '  \t\touts = uint256(outstanding * (-1));\n', '  \t\tplayerBalance = safeSub(playerBalance, outs);\n', '  \t\tbalanceOf[player] = safeSub(balanceOf[player], outs);\n', '  \t}\n', '  \telse{\n', '  \t\touts = uint256(outstanding);\n', '  \t\tassert(bankroll() * oneEDG > outs);\n', '  \t  playerBalance = safeAdd(playerBalance, outs);\n', '  \t  balanceOf[player] = safeAdd(balanceOf[player], outs);\n', '  \t}\n', '  }\n', '  \n', '  /**\n', '   * logs some seeds and game results for players wishing to have their game history logged by the contract\n', '   * @param serverSeeds array containing the server seeds\n', '   *        clientSeeds array containing the client seeds\n', '   *        results     array containing the results\n', '   *        v, r, s     the signature of the non-sending party (to make sure the correct results are logged)\n', '   * */\n', '  function logGameData(bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint8 v, bytes32 r, bytes32 s) public{\n', '    address player = determinePlayer(serverSeeds, clientSeeds, results, v, r, s);\n', '    uint gasCost;\n', '    //charge gas in case the server is logging the results for the player\n', '    if(player != msg.sender){\n', '      gasCost = (57 + 768 * serverSeeds.length / 1000)*gasPrice;\n', '      balanceOf[player] = safeSub(balanceOf[player], gasCost);\n', '      playerBalance = safeSub(playerBalance, gasCost);\n', '      gasPayback = safeAdd(gasPayback, gasCost);\n', '    }\n', '    emit GameData(player, serverSeeds, clientSeeds, results, gasCost);\n', '  }\n', '  \n', '  /**\n', '   * determines if the msg.sender or the signer of the passed signature is the player. returns the player&#39;s address\n', '   * @param serverSeeds array containing the server seeds\n', '   *        clientSeeds array containing the client seeds\n', '   *        results     array containing the results\n', '   *\t\t\t\tv, r, s    the signature of the non-sending party\n', '   * */\n', '  function determinePlayer(bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint8 v, bytes32 r, bytes32 s) view internal returns(address){\n', '  \taddress signer = ecrecover(keccak256(serverSeeds, clientSeeds, results), v, r, s);\n', '  \tif (authorized[msg.sender])//casino is the sender -> player is the signer\n', '  \t\treturn signer;\n', '  \telse if (authorized[signer])\n', '  \t\treturn msg.sender;\n', '  \telse \n', '  \t  revert();\n', '  }\n', '\n', '}']
['/**\n', " * The edgeless casino contract v2 holds the players's funds and provides state channel functionality.\n", " * The casino has at no time control over the players's funds.\n", ' * State channels can be updated and closed from both parties: the player and the casino.\n', ' * author: Julia Altenried\n', ' **/\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract SafeMath {\n', '\n', '\tfunction safeSub(uint a, uint b) pure internal returns(uint) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\t\n', '\tfunction safeSub(int a, int b) pure internal returns(int) {\n', '\t\tif(b < 0) assert(a - b > a);\n', '\t\telse assert(a - b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction safeAdd(uint a, uint b) pure internal returns(uint) {\n', '\t\tuint c = a + b;\n', '\t\tassert(c >= a && c >= b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction safeMul(uint a, uint b) pure internal returns (uint) {\n', '\t\tuint c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', '\n', 'contract Token {\n', '\tfunction transferFrom(address sender, address receiver, uint amount) public returns(bool success);\n', '\n', '\tfunction transfer(address receiver, uint amount) public returns(bool success);\n', '\n', '\tfunction balanceOf(address holder) public view returns(uint);\n', '}\n', '\n', 'contract Owned {\n', '  address public owner;\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function Owned() public{\n', '    owner = msg.sender;\n', '  }\n', '\n', '}\n', '\n', '/** owner should be able to close the contract is nobody has been using it for at least 30 days */\n', 'contract Mortal is Owned {\n', '\t/** contract can be closed by the owner anytime after this timestamp if non-zero */\n', '\tuint public closeAt;\n', '\t/** the edgeless token contract */\n', '\tToken edg;\n', '\t\n', '\tfunction Mortal(address tokenContract) internal{\n', '\t\tedg = Token(tokenContract);\n', '\t}\n', '\t/**\n', '\t* lets the owner close the contract if there are no player funds on it or if nobody has been using it for at least 30 days\n', '\t*/\n', '  function closeContract(uint playerBalance) internal{\n', '\t\tif(closeAt == 0) closeAt = now + 30 days;\n', '\t\tif(closeAt < now || playerBalance == 0){\n', '\t\t\tedg.transfer(owner, edg.balanceOf(address(this)));\n', '\t\t\tselfdestruct(owner);\n', '\t\t} \n', '  }\n', '\n', '\t/**\n', '\t* in case close has been called accidentally.\n', '\t**/\n', '\tfunction open() onlyOwner public{\n', '\t\tcloseAt = 0;\n', '\t}\n', '\n', '\t/**\n', '\t* make sure the contract is not in process of being closed.\n', '\t**/\n', '\tmodifier isAlive {\n', '\t\trequire(closeAt == 0);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* delays the time of closing.\n', '\t**/\n', '\tmodifier keepAlive {\n', '\t\tif(closeAt > 0) closeAt = now + 30 days;\n', '\t\t_;\n', '\t}\n', '}\n', '\n', 'contract RequiringAuthorization is Mortal {\n', "\t/** indicates if an address is authorized to act in the casino's name  */\n", '\tmapping(address => bool) public authorized;\n', '\t/** tells if an address is allowed to receive funds from the bankroll **/\n', '\tmapping(address => bool) public allowedReceiver;\n', '\n', '\tmodifier onlyAuthorized {\n', '\t\trequire(authorized[msg.sender]);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * Constructor. Authorize the owner.\n', '\t * */\n', '\tfunction RequiringAuthorization() internal {\n', '\t\tauthorized[msg.sender] = true;\n', '\t\tallowedReceiver[msg.sender] = true;\n', '\t}\n', '\n', '\t/**\n', '\t * authorize a address to call game functions and set configs.\n', '\t * @param addr the address to be authorized\n', '\t **/\n', '\tfunction authorize(address addr) public onlyOwner {\n', '\t\tauthorized[addr] = true;\n', '\t}\n', '\n', '\t/**\n', '\t * deauthorize a address to call game functions and set configs.\n', '\t * @param addr the address to be deauthorized\n', '\t **/\n', '\tfunction deauthorize(address addr) public onlyOwner {\n', '\t\tauthorized[addr] = false;\n', '\t}\n', '\n', '\t/**\n', '\t * allow authorized wallets to withdraw funds from the bonkroll to this address\n', "\t * @param receiver the receiver's address\n", '\t * */\n', '\tfunction allowReceiver(address receiver) public onlyOwner {\n', '\t\tallowedReceiver[receiver] = true;\n', '\t}\n', '\n', '\t/**\n', '\t * disallow authorized wallets to withdraw funds from the bonkroll to this address\n', "\t * @param receiver the receiver's address\n", '\t * */\n', '\tfunction disallowReceiver(address receiver) public onlyOwner {\n', '\t\tallowedReceiver[receiver] = false;\n', '\t}\n', '\n', '\t/**\n', '\t * changes the owner of the contract. revokes authorization of the old owner and authorizes the new one.\n', '\t * @param newOwner the address of the new owner\n', '\t * */\n', '\tfunction changeOwner(address newOwner) public onlyOwner {\n', '\t\tdeauthorize(owner);\n', '\t\tauthorize(newOwner);\n', '\t\tdisallowReceiver(owner);\n', '\t\tallowReceiver(newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '}\n', '\n', 'contract ChargingGas is RequiringAuthorization, SafeMath {\n', '\t/** 1 EDG has 5 decimals **/\n', '\tuint public constant oneEDG = 100000;\n', '\t/** the price per kgas and GWei in tokens (with decimals) */\n', '\tuint public gasPrice;\n', '\t/** the amount of gas used per transaction in kGas */\n', '\tmapping(bytes4 => uint) public gasPerTx;\n', '\t/** the number of tokens (5 decimals) payed by the users to cover the gas cost */\n', '\tuint public gasPayback;\n', '\t\n', '\tfunction ChargingGas(uint kGasPrice) internal{\n', '\t\t//deposit, withdrawFor, updateChannel, updateBatch, transferToNewContract\n', '\t    bytes4[5] memory signatures = [bytes4(0x3edd1128),0x9607610a, 0xde48ff52, 0xc97b6d1f, 0x6bf06fde];\n', '\t    //amount of gas consumed by the above methods in GWei\n', '\t    uint[5] memory gasUsage = [uint(146), 100, 65, 50, 85];\n', '\t    setGasUsage(signatures, gasUsage);\n', '\t    setGasPrice(kGasPrice);\n', '\t}\n', '\t/**\n', '\t * sets the amount of gas consumed by methods with the given sigantures.\n', '\t * only called from the edgeless casino constructor.\n', '\t * @param signatures an array of method-signatures\n', '\t *        gasNeeded  the amount of gas consumed by these methods\n', '\t * */\n', '\tfunction setGasUsage(bytes4[5] signatures, uint[5] gasNeeded) public onlyOwner {\n', '\t\trequire(signatures.length == gasNeeded.length);\n', '\t\tfor (uint8 i = 0; i < signatures.length; i++)\n', '\t\t\tgasPerTx[signatures[i]] = gasNeeded[i];\n', '\t}\n', '\n', '\t/**\n', '\t * updates the price per 1000 gas in EDG.\n', '\t * @param price the new gas price (with decimals, max 0.1 EDG)\n', '\t **/\n', '\tfunction setGasPrice(uint price) public onlyAuthorized {\n', '\t\trequire(price < oneEDG/10);\n', '\t\tgasPrice = price;\n', '\t}\n', '\n', '\t/**\n', '\t * returns the gas cost of the called function.\n', '\t * */\n', '\tfunction getGasCost() internal view returns(uint) {\n', '\t\treturn safeMul(safeMul(gasPerTx[msg.sig], gasPrice), tx.gasprice) / 1000000000;\n', '\t}\n', '\n', '}\n', '\n', '\n', 'contract CasinoBank is ChargingGas {\n', '\t/** the total balance of all players with virtual decimals **/\n', '\tuint public playerBalance;\n', '\t/** the balance per player in edgeless tokens with virtual decimals */\n', '\tmapping(address => uint) public balanceOf;\n', '\t/** in case the user wants/needs to call the withdraw function from his own wallet, he first needs to request a withdrawal */\n', '\tmapping(address => uint) public withdrawAfter;\n', '\t/** a number to count withdrawal signatures to ensure each signature is different even if withdrawing the same amount to the same address */\n', '\tmapping(address => uint) public withdrawCount;\n', '\t/** the maximum amount of tokens the user is allowed to deposit (with decimals) */\n', '\tuint public maxDeposit;\n', '\t/** the maximum withdrawal of tokens the user is allowed to withdraw on one day (only enforced when the tx is not sent from an authorized wallet) **/\n', '\tuint public maxWithdrawal;\n', '\t/** waiting time for withdrawal if not requested via the server **/\n', '\tuint public waitingTime;\n', '\t/** the address of the predecessor **/\n', '\taddress public predecessor;\n', '\n', '\t/** informs listeners how many tokens were deposited for a player */\n', '\tevent Deposit(address _player, uint _numTokens, uint _gasCost);\n', '\t/** informs listeners how many tokens were withdrawn from the player to the receiver address */\n', '\tevent Withdrawal(address _player, address _receiver, uint _numTokens, uint _gasCost);\n', '\t\n', '\t\n', '\t/**\n', '\t * Constructor.\n', '\t * @param depositLimit    the maximum deposit allowed\n', '\t *\t\t  predecessorAddr the address of the predecessing contract\n', '\t * */\n', '\tfunction CasinoBank(uint depositLimit, address predecessorAddr) internal {\n', '\t\tmaxDeposit = depositLimit * oneEDG;\n', '\t\tmaxWithdrawal = maxDeposit;\n', '\t\twaitingTime = 24 hours;\n', '\t\tpredecessor = predecessorAddr;\n', '\t}\n', '\n', '\t/**\n', '\t * accepts deposits for an arbitrary address.\n', '\t * retrieves tokens from the message sender and adds them to the balance of the specified address.\n', '\t * edgeless tokens do not have any decimals, but are represented on this contract with decimals.\n', '\t * @param receiver  address of the receiver\n', '\t *        numTokens number of tokens to deposit (0 decimals)\n', "\t *\t\t\t\t chargeGas indicates if the gas cost is subtracted from the user's edgeless token balance\n", '\t **/\n', '\tfunction deposit(address receiver, uint numTokens, bool chargeGas) public isAlive {\n', '\t\trequire(numTokens > 0);\n', '\t\tuint value = safeMul(numTokens, oneEDG);\n', '\t\tuint gasCost;\n', '\t\tif (chargeGas) {\n', '\t\t\tgasCost = getGasCost();\n', '\t\t\tvalue = safeSub(value, gasCost);\n', '\t\t\tgasPayback = safeAdd(gasPayback, gasCost);\n', '\t\t}\n', '\t\tuint newBalance = safeAdd(balanceOf[receiver], value);\n', '\t\trequire(newBalance <= maxDeposit);\n', '\t\tassert(edg.transferFrom(msg.sender, address(this), numTokens));\n', '\t\tbalanceOf[receiver] = newBalance;\n', '\t\tplayerBalance = safeAdd(playerBalance, value);\n', '\t\temit Deposit(receiver, numTokens, gasCost);\n', '\t}\n', '\n', '\t/**\n', '\t * If the user wants/needs to withdraw his funds himself, he needs to request the withdrawal first.\n', "\t * This method sets the earliest possible withdrawal date to 'waitingTime from now (default 90m, but up to 24h).\n", '\t * Reason: The user should not be able to withdraw his funds, while the the last game methods have not yet been mined.\n', '\t **/\n', '\tfunction requestWithdrawal() public {\n', '\t\twithdrawAfter[msg.sender] = now + waitingTime;\n', '\t}\n', '\n', '\t/**\n', '\t * In case the user requested a withdrawal and changes his mind.\n', '\t * Necessary to be able to continue playing.\n', '\t **/\n', '\tfunction cancelWithdrawalRequest() public {\n', '\t\twithdrawAfter[msg.sender] = 0;\n', '\t}\n', '\n', '\t/**\n', '\t * withdraws an amount from the user balance if the waiting time passed since the request.\n', '\t * @param amount the amount of tokens to withdraw\n', '\t **/\n', '\tfunction withdraw(uint amount) public keepAlive {\n', '\t\trequire(amount <= maxWithdrawal);\n', '\t\trequire(withdrawAfter[msg.sender] > 0 && now > withdrawAfter[msg.sender]);\n', '\t\twithdrawAfter[msg.sender] = 0;\n', '\t\tuint value = safeMul(amount, oneEDG);\n', '\t\tbalanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value);\n', '\t\tplayerBalance = safeSub(playerBalance, value);\n', '\t\tassert(edg.transfer(msg.sender, amount));\n', '\t\temit Withdrawal(msg.sender, msg.sender, amount, 0);\n', '\t}\n', '\n', '\t/**\n', '\t * lets the owner withdraw from the bankroll\n', "\t * @param receiver the receiver's address\n", '\t *\t\t\t\tnumTokens the number of tokens to withdraw (0 decimals)\n', '\t **/\n', '\tfunction withdrawBankroll(address receiver, uint numTokens) public onlyAuthorized {\n', '\t\trequire(numTokens <= bankroll());\n', '\t\trequire(allowedReceiver[receiver]);\n', '\t\tassert(edg.transfer(receiver, numTokens));\n', '\t}\n', '\n', '\t/**\n', '\t * withdraw the gas payback to the owner\n', '\t **/\n', '\tfunction withdrawGasPayback() public onlyAuthorized {\n', '\t\tuint payback = gasPayback / oneEDG;\n', '\t\tassert(payback > 0);\n', '\t\tgasPayback = safeSub(gasPayback, payback * oneEDG);\n', '\t\tassert(edg.transfer(owner, payback));\n', '\t}\n', '\n', '\t/**\n', '\t * returns the current bankroll in tokens with 0 decimals\n', '\t **/\n', '\tfunction bankroll() view public returns(uint) {\n', '\t\treturn safeSub(edg.balanceOf(address(this)), safeAdd(playerBalance, gasPayback) / oneEDG);\n', '\t}\n', '\n', '\n', '\t/**\n', '\t * updates the maximum deposit.\n', '\t * @param newMax the new maximum deposit (0 decimals)\n', '\t **/\n', '\tfunction setMaxDeposit(uint newMax) public onlyAuthorized {\n', '\t\tmaxDeposit = newMax * oneEDG;\n', '\t}\n', '\t\n', '\t/**\n', '\t * updates the maximum withdrawal.\n', '\t * @param newMax the new maximum withdrawal (0 decimals)\n', '\t **/\n', '\tfunction setMaxWithdrawal(uint newMax) public onlyAuthorized {\n', '\t\tmaxWithdrawal = newMax * oneEDG;\n', '\t}\n', '\n', '\t/**\n', '\t * sets the time the player has to wait for his funds to be unlocked before withdrawal (if not withdrawing with help of the casino server).\n', '\t * the time may not be longer than 24 hours.\n', '\t * @param newWaitingTime the new waiting time in seconds\n', '\t * */\n', '\tfunction setWaitingTime(uint newWaitingTime) public onlyAuthorized  {\n', '\t\trequire(newWaitingTime <= 24 hours);\n', '\t\twaitingTime = newWaitingTime;\n', '\t}\n', '\n', '\t/**\n', "\t * transfers an amount from the contract balance to the owner's wallet.\n", '\t * @param receiver the receiver address\n', '\t *\t\t\t\t amount   the amount of tokens to withdraw (0 decimals)\n', '\t *\t\t\t\t v,r,s \t\tthe signature of the player\n', '\t **/\n', '\tfunction withdrawFor(address receiver, uint amount, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized keepAlive {\n', '\t\taddress player = ecrecover(keccak256(receiver, amount, withdrawCount[receiver]), v, r, s);\n', '\t\twithdrawCount[receiver]++;\n', '\t\tuint gasCost = getGasCost();\n', '\t\tuint value = safeAdd(safeMul(amount, oneEDG), gasCost);\n', '\t\tgasPayback = safeAdd(gasPayback, gasCost);\n', '\t\tbalanceOf[player] = safeSub(balanceOf[player], value);\n', '\t\tplayerBalance = safeSub(playerBalance, value);\n', '\t\tassert(edg.transfer(receiver, amount));\n', '\t\temit Withdrawal(player, receiver, amount, gasCost);\n', '\t}\n', '\t\n', '\t/**\n', "\t * transfers the player's tokens directly to the new casino contract after an update.\n", '\t * @param newCasino the address of the new casino contract\n', '\t *\t\t  v, r, s   the signature of the player\n', '\t *\t\t  chargeGas indicates if the gas cost is payed by the player.\n', '\t * */\n', '\tfunction transferToNewContract(address newCasino, uint8 v, bytes32 r, bytes32 s, bool chargeGas) public onlyAuthorized keepAlive {\n', '\t\taddress player = ecrecover(keccak256(address(this), newCasino), v, r, s);\n', '\t\tuint gasCost = 0;\n', '\t\tif(chargeGas) gasCost = getGasCost();\n', '\t\tuint value = safeSub(balanceOf[player], gasCost);\n', '\t\trequire(value > oneEDG);\n', '\t\t//fractions of one EDG cannot be withdrawn \n', '\t\tvalue /= oneEDG;\n', '\t\tplayerBalance = safeSub(playerBalance, balanceOf[player]);\n', '\t\tbalanceOf[player] = 0;\n', '\t\tassert(edg.transfer(newCasino, value));\n', '\t\temit Withdrawal(player, newCasino, value, gasCost);\n', '\t\tCasinoBank cb = CasinoBank(newCasino);\n', '\t\tassert(cb.credit(player, value));\n', '\t}\n', '\t\n', '\t/**\n', '\t * receive a player balance from the predecessor contract.\n', '\t * @param player the address of the player to credit the value for\n', '\t *\t\t\t\tvalue  the number of tokens to credit (0 decimals)\n', '\t * */\n', '\tfunction credit(address player, uint value) public returns(bool) {\n', '\t\trequire(msg.sender == predecessor);\n', '\t\tuint valueWithDecimals = safeMul(value, oneEDG);\n', '\t\tbalanceOf[player] = safeAdd(balanceOf[player], valueWithDecimals);\n', '\t\tplayerBalance = safeAdd(playerBalance, valueWithDecimals);\n', '\t\temit Deposit(player, value, 0);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * lets the owner close the contract if there are no player funds on it or if nobody has been using it for at least 30 days\n', '\t * */\n', '\tfunction close() public onlyOwner {\n', '\t\tcloseContract(playerBalance);\n', '\t}\n', '}\n', '\n', '\n', 'contract EdgelessCasino is CasinoBank{\n', '\t/** the most recent known state of a state channel */\n', '\tmapping(address => State) public lastState;\n', '\t/** fired when the state is updated */\n', '\tevent StateUpdate(address player, uint128 count, int128 winBalance, int difference, uint gasCost);\n', '  /** fired if one of the parties chooses to log the seeds and results */\n', '  event GameData(address player, bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint gasCost);\n', '  \n', '\tstruct State{\n', '\t\tuint128 count;\n', '\t\tint128 winBalance;\n', '\t}\n', '\n', '\n', '  /**\n', '  * creates a new edgeless casino contract.\n', '  * @param predecessorAddress the address of the predecessing contract\n', '\t*\t\t\t\t tokenContract      the address of the Edgeless token contract\n', '\t* \t\t\t depositLimit       the maximum deposit allowed\n', '\t* \t\t\t kGasPrice\t\t\t\t  the price per kGas in WEI\n', '  **/\n', '  function EdgelessCasino(address predecessorAddress, address tokenContract, uint depositLimit, uint kGasPrice) CasinoBank(depositLimit, predecessorAddress) Mortal(tokenContract) ChargingGas(kGasPrice) public{\n', '\n', '  }\n', '  \n', '  /**\n', '   * updates several state channels at once. can be called by authorized wallets only.\n', '   * 1. determines the player address from the signature.\n', '   * 2. verifies if the signed game-count is higher than the last known game-count of this channel.\n', '   * 3. updates the balances accordingly. This means: It checks the already performed updates for this channel and computes\n', '   *    the new balance difference to add or subtract from the player‘s balance.\n', '   * @param winBalances array of the current wins or losses\n', '   *\t\t\t\tgameCounts  array of the numbers of signed game moves\n', "   *\t\t\t\tv,r,s       array of the players's signatures\n", "   *        chargeGas   indicates if the gas costs should be subtracted from the players's balances\n", '   * */\n', '  function updateBatch(int128[] winBalances,  uint128[] gameCounts, uint8[] v, bytes32[] r, bytes32[] s, bool chargeGas) public onlyAuthorized{\n', '    require(winBalances.length == gameCounts.length);\n', '    require(winBalances.length == v.length);\n', '    require(winBalances.length == r.length);\n', '    require(winBalances.length == s.length);\n', '    require(winBalances.length <= 50);\n', '    address player;\n', '    uint gasCost = 0;\n', '    if(chargeGas) \n', '      gasCost = getGasCost();\n', '    gasPayback = safeAdd(gasPayback, safeMul(gasCost, winBalances.length));\n', '    for(uint8 i = 0; i < winBalances.length; i++){\n', '      player = ecrecover(keccak256(winBalances[i], gameCounts[i]), v[i], r[i], s[i]);\n', '      _updateState(player, winBalances[i], gameCounts[i], gasCost);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * updates a state channel. can be called by both parties.\n', '   * 1. verifies the signature.\n', '   * 2. verifies if the signed game-count is higher than the last known game-count of this channel.\n', '   * 3. updates the balances accordingly. This means: It checks the already performed updates for this channel and computes\n', '   *    the new balance difference to add or subtract from the player‘s balance.\n', '   * @param winBalance the current win or loss\n', '   *\t\t\t\tgameCount  the number of signed game moves\n', '   *\t\t\t\tv,r,s      the signature of either the casino or the player\n', "   *        chargeGas  indicates if the gas costs should be subtracted from the player's balance\n", '   * */\n', '  function updateState(int128 winBalance,  uint128 gameCount, uint8 v, bytes32 r, bytes32 s, bool chargeGas) public{\n', '  \taddress player = determinePlayer(winBalance, gameCount, v, r, s);\n', '  \tuint gasCost = 0;\n', '  \tif(player == msg.sender)//if the player closes the state channel himself, make sure the signer is a casino wallet\n', '  \t\trequire(authorized[ecrecover(keccak256(player, winBalance, gameCount), v, r, s)]);\n', '  \telse if (chargeGas){//subtract the gas costs from the player balance only if the casino wallet is the sender\n', '  \t\tgasCost = getGasCost();\n', '  \t\tgasPayback = safeAdd(gasPayback, gasCost);\n', '  \t}\n', '  \t_updateState(player, winBalance, gameCount, gasCost);\n', '  }\n', '  \n', '  /**\n', '   * internal method to perform the actual state update.\n', '   * @param player the player address\n', "   *        winBalance the player's win balance\n", "   *        gameCount  the player's game count\n", '   * */\n', '  function _updateState(address player, int128 winBalance,  uint128 gameCount, uint gasCost) internal {\n', '    State storage last = lastState[player];\n', '  \trequire(gameCount > last.count);\n', '  \tint difference = updatePlayerBalance(player, winBalance, last.winBalance, gasCost);\n', '  \tlastState[player] = State(gameCount, winBalance);\n', '  \temit StateUpdate(player, gameCount, winBalance, difference, gasCost);\n', '  }\n', '\n', '  /**\n', "   * determines if the msg.sender or the signer of the passed signature is the player. returns the player's address\n", '   * @param winBalance the current winBalance, used to calculate the msg hash\n', '   *\t\t\t\tgameCount  the current gameCount, used to calculate the msg.hash\n', '   *\t\t\t\tv, r, s    the signature of the non-sending party\n', '   * */\n', '  function determinePlayer(int128 winBalance, uint128 gameCount, uint8 v, bytes32 r, bytes32 s) view internal returns(address){\n', '  \tif (authorized[msg.sender])//casino is the sender -> player is the signer\n', '  \t\treturn ecrecover(keccak256(winBalance, gameCount), v, r, s);\n', '  \telse\n', '  \t\treturn msg.sender;\n', '  }\n', '\n', '\t/**\n', "\t * computes the difference of the win balance relative to the last known state and adds it to the player's balance.\n", "\t * in case the casino is the sender, the gas cost in EDG gets subtracted from the player's balance.\n", '\t * @param player the address of the player\n', '\t *\t\t\t\twinBalance the current win-balance\n', '\t *\t\t\t\tlastWinBalance the win-balance of the last known state\n', '\t *\t\t\t\tgasCost the gas cost of the tx\n', '\t * */\n', '  function updatePlayerBalance(address player, int128 winBalance, int128 lastWinBalance, uint gasCost) internal returns(int difference){\n', '  \tdifference = safeSub(winBalance, lastWinBalance);\n', '  \tint outstanding = safeSub(difference, int(gasCost));\n', '  \tuint outs;\n', '  \tif(outstanding < 0){\n', '  \t\touts = uint256(outstanding * (-1));\n', '  \t\tplayerBalance = safeSub(playerBalance, outs);\n', '  \t\tbalanceOf[player] = safeSub(balanceOf[player], outs);\n', '  \t}\n', '  \telse{\n', '  \t\touts = uint256(outstanding);\n', '  \t\tassert(bankroll() * oneEDG > outs);\n', '  \t  playerBalance = safeAdd(playerBalance, outs);\n', '  \t  balanceOf[player] = safeAdd(balanceOf[player], outs);\n', '  \t}\n', '  }\n', '  \n', '  /**\n', '   * logs some seeds and game results for players wishing to have their game history logged by the contract\n', '   * @param serverSeeds array containing the server seeds\n', '   *        clientSeeds array containing the client seeds\n', '   *        results     array containing the results\n', '   *        v, r, s     the signature of the non-sending party (to make sure the correct results are logged)\n', '   * */\n', '  function logGameData(bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint8 v, bytes32 r, bytes32 s) public{\n', '    address player = determinePlayer(serverSeeds, clientSeeds, results, v, r, s);\n', '    uint gasCost;\n', '    //charge gas in case the server is logging the results for the player\n', '    if(player != msg.sender){\n', '      gasCost = (57 + 768 * serverSeeds.length / 1000)*gasPrice;\n', '      balanceOf[player] = safeSub(balanceOf[player], gasCost);\n', '      playerBalance = safeSub(playerBalance, gasCost);\n', '      gasPayback = safeAdd(gasPayback, gasCost);\n', '    }\n', '    emit GameData(player, serverSeeds, clientSeeds, results, gasCost);\n', '  }\n', '  \n', '  /**\n', "   * determines if the msg.sender or the signer of the passed signature is the player. returns the player's address\n", '   * @param serverSeeds array containing the server seeds\n', '   *        clientSeeds array containing the client seeds\n', '   *        results     array containing the results\n', '   *\t\t\t\tv, r, s    the signature of the non-sending party\n', '   * */\n', '  function determinePlayer(bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint8 v, bytes32 r, bytes32 s) view internal returns(address){\n', '  \taddress signer = ecrecover(keccak256(serverSeeds, clientSeeds, results), v, r, s);\n', '  \tif (authorized[msg.sender])//casino is the sender -> player is the signer\n', '  \t\treturn signer;\n', '  \telse if (authorized[signer])\n', '  \t\treturn msg.sender;\n', '  \telse \n', '  \t  revert();\n', '  }\n', '\n', '}']
