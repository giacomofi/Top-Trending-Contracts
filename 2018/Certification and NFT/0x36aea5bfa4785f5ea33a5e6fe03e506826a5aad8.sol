['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '    function transfer (address _beneficiary, uint256 _tokenAmount) external returns (bool);\n', '    function mintFromICO(address _to, uint256 _amount) external  returns(bool);\n', '}\n', '\n', 'contract Ownable {\n', '    \n', '    address public owner;\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract MainSale is Ownable {\n', '    \n', '    ERC20 public token;\n', '    \n', '    using SafeMath for uint;\n', '    \n', '    address public backEndOperator = msg.sender;\n', '    \n', '    address team = 0x7DDA135cDAa44Ad3D7D79AAbE562c4cEA9DEB41d; // 25% all\n', '    \n', '    address reserve = 0x34bef601666D7b2E719Ff919A04266dD07706a79; // 15% all\n', '    \n', '    mapping(address=>bool) public whitelist;\n', '    \n', '    mapping(address => uint256) public investedEther;\n', '    \n', '    uint256 public startSale = 1537228801; // Tuesday, 18-Sep-18 00:00:01 UTC\n', '    \n', '    uint256 public endSale = 1545177599; // Tuesday, 18-Dec-18 23:59:59 UTC\n', '    \n', '    uint256 public investors;\n', '    \n', '    uint256 public weisRaised;\n', '    \n', '    uint256 public dollarRaised; // collected USD\n', '    \n', '    uint256 public softCap = 2000000000*1e18; // 20,000,000 USD\n', '    \n', '    uint256 public hardCap = 7000000000*1e18; // 70,000,000 USD\n', '    \n', '    uint256 public buyPrice; //0.01 USD\n', '    \n', '    uint256 public dollarPrice;\n', '    \n', '    uint256 public soldTokens;\n', '    \n', '    uint256 step1Sum = 3000000*1e18; // 3 mln $\n', '    \n', '    uint256 step2Sum = 10000000*1e18; // 10 mln $\n', '    \n', '    uint256 step3Sum = 20000000*1e18; // 20 mln $\n', '    \n', '    uint256 step4Sum = 30000000*1e18; // 30 mln $\n', '    \n', '    \n', '    event Authorized(address wlCandidate, uint timestamp);\n', '    \n', '    event Revoked(address wlCandidate, uint timestamp);\n', '    \n', '    event Refund(uint rate, address investor);\n', '    \n', '    \n', '    modifier isUnderHardCap() {\n', '        require(weisRaised <= hardCap);\n', '        _;\n', '    }\n', '    \n', '    modifier backEnd() {\n', '        require(msg.sender == backEndOperator || msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    \n', '    constructor(uint256 _dollareth) public {\n', '        dollarPrice = _dollareth;\n', '        buyPrice = 1e16/dollarPrice; // 16 decimals because 1 cent\n', '        hardCap = 7500000000*buyPrice;\n', '    }\n', '    \n', '    \n', '    function setToken (ERC20 _token) public onlyOwner {\n', '        token = _token;\n', '    }\n', '    \n', '    function setDollarRate(uint256 _usdether) public onlyOwner {\n', '        dollarPrice = _usdether;\n', '        buyPrice = 1e16/dollarPrice; // 16 decimals because 1 cent\n', '        hardCap = 7500000000*buyPrice;\n', '    }\n', '    \n', '    \n', '    function setPrice(uint256 newBuyPrice) public onlyOwner {\n', '        buyPrice = newBuyPrice;\n', '    }\n', '    \n', '    function setStartSale(uint256 newStartSale) public onlyOwner {\n', '        startSale = newStartSale;\n', '    }\n', '    \n', '    function setEndSale(uint256 newEndSaled) public onlyOwner {\n', '        endSale = newEndSaled;\n', '    }\n', '    \n', '    function setBackEndAddress(address newBackEndOperator) public onlyOwner {\n', '        backEndOperator = newBackEndOperator;\n', '    }\n', '    \n', '    /*******************************************************************************\n', '     * Whitelist&#39;s section */\n', '    \n', '    function authorize(address wlCandidate) public backEnd {\n', '        require(wlCandidate != address(0x0));\n', '        require(!isWhitelisted(wlCandidate));\n', '        whitelist[wlCandidate] = true;\n', '        investors++;\n', '        emit Authorized(wlCandidate, now);\n', '    }\n', '    \n', '    function revoke(address wlCandidate) public  onlyOwner {\n', '        whitelist[wlCandidate] = false;\n', '        investors--;\n', '        emit Revoked(wlCandidate, now);\n', '    }\n', '    \n', '    function isWhitelisted(address wlCandidate) public view returns(bool) {\n', '        return whitelist[wlCandidate];\n', '    }\n', '    \n', '    /*******************************************************************************\n', '     * Payable&#39;s section */\n', '    \n', '    function isMainSale() public constant returns(bool) {\n', '        return now >= startSale && now <= endSale;\n', '    }\n', '    \n', '    function () public payable isUnderHardCap {\n', '        require(isMainSale());\n', '        require(isWhitelisted(msg.sender));\n', '        require(msg.value >= 10000000000000000);\n', '        mainSale(msg.sender, msg.value);\n', '        investedEther[msg.sender] = investedEther[msg.sender].add(msg.value);\n', '    }\n', '    \n', '    function mainSale(address _investor, uint256 _value) internal {\n', '        uint256 tokens = _value.mul(1e18).div(buyPrice);\n', '        uint256 tokensSum = tokens.mul(discountSum(msg.value)).div(100);\n', '        uint256 tokensCollect = tokens.mul(discountCollect()).div(100);\n', '        tokens = tokens.add(tokensSum).add(tokensCollect);\n', '        token.mintFromICO(_investor, tokens);\n', '        uint256 tokensFounders = tokens.mul(5).div(12);\n', '        token.mintFromICO(team, tokensFounders);\n', '        uint256 tokensDevelopers = tokens.div(4);\n', '        token.mintFromICO(reserve, tokensDevelopers);\n', '        weisRaised = weisRaised.add(msg.value);\n', '        uint256 valueInUSD = msg.value.mul(dollarPrice);\n', '        dollarRaised = dollarRaised.add(valueInUSD);\n', '        soldTokens = soldTokens.add(tokens);\n', '    }\n', '    \n', '    \n', '    function discountSum(uint256 _tokens) pure private returns(uint256) {\n', '        if(_tokens >= 10000000*1e18) { // > 100k$ = 10,000,000 TAL\n', '            return 7;\n', '        }\n', '        if(_tokens >= 5000000*1e18) { // 50-100k$ = 5,000,000 TAL\n', '            return 5;\n', '        }\n', '        if(_tokens >= 1000000*1e18) { // 10-50k$ = 1,000,000 TAL\n', '            return 3;\n', '        } else\n', '            return 0;\n', '    }\n', '    \n', '    \n', '    function discountCollect() view private returns(uint256) {\n', '        // 20% bonus, if collected sum < 3 mln $\n', '        if(dollarRaised <= step1Sum) {\n', '            return 20;\n', '        } // 15% bonus, if collected sum < 10 mln $\n', '        if(dollarRaised <= step2Sum) {\n', '            return 15;\n', '        } // 10% bonus, if collected sum < 20 mln $\n', '        if(dollarRaised <= step3Sum) {\n', '            return 10;\n', '        } // 5% bonus, if collected sum < 30 mln $\n', '        if(dollarRaised <= step4Sum) {\n', '            return 5;\n', '        }\n', '        return 0;\n', '    }\n', '    \n', '    \n', '    function mintManual(address _investor, uint256 _value) public onlyOwner {\n', '        token.mintFromICO(_investor, _value);\n', '        uint256 tokensFounders = _value.mul(5).div(12);\n', '        token.mintFromICO(team, tokensFounders);\n', '        uint256 tokensDevelopers = _value.div(4);\n', '        token.mintFromICO(reserve, tokensDevelopers);\n', '    }\n', '    \n', '    \n', '    function transferEthFromContract(address _to, uint256 amount) public onlyOwner {\n', '        require(amount != 0);\n', '        require(_to != 0x0);\n', '        _to.transfer(amount);\n', '    }\n', '    \n', '    \n', '    function refundSale() public {\n', '        require(soldTokens < softCap && now > endSale);\n', '        uint256 rate = investedEther[msg.sender];\n', '        require(investedEther[msg.sender] >= 0);\n', '        investedEther[msg.sender] = 0;\n', '        msg.sender.transfer(rate);\n', '        weisRaised = weisRaised.sub(rate);\n', '        emit Refund(rate, msg.sender);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '    function transfer (address _beneficiary, uint256 _tokenAmount) external returns (bool);\n', '    function mintFromICO(address _to, uint256 _amount) external  returns(bool);\n', '}\n', '\n', 'contract Ownable {\n', '    \n', '    address public owner;\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract MainSale is Ownable {\n', '    \n', '    ERC20 public token;\n', '    \n', '    using SafeMath for uint;\n', '    \n', '    address public backEndOperator = msg.sender;\n', '    \n', '    address team = 0x7DDA135cDAa44Ad3D7D79AAbE562c4cEA9DEB41d; // 25% all\n', '    \n', '    address reserve = 0x34bef601666D7b2E719Ff919A04266dD07706a79; // 15% all\n', '    \n', '    mapping(address=>bool) public whitelist;\n', '    \n', '    mapping(address => uint256) public investedEther;\n', '    \n', '    uint256 public startSale = 1537228801; // Tuesday, 18-Sep-18 00:00:01 UTC\n', '    \n', '    uint256 public endSale = 1545177599; // Tuesday, 18-Dec-18 23:59:59 UTC\n', '    \n', '    uint256 public investors;\n', '    \n', '    uint256 public weisRaised;\n', '    \n', '    uint256 public dollarRaised; // collected USD\n', '    \n', '    uint256 public softCap = 2000000000*1e18; // 20,000,000 USD\n', '    \n', '    uint256 public hardCap = 7000000000*1e18; // 70,000,000 USD\n', '    \n', '    uint256 public buyPrice; //0.01 USD\n', '    \n', '    uint256 public dollarPrice;\n', '    \n', '    uint256 public soldTokens;\n', '    \n', '    uint256 step1Sum = 3000000*1e18; // 3 mln $\n', '    \n', '    uint256 step2Sum = 10000000*1e18; // 10 mln $\n', '    \n', '    uint256 step3Sum = 20000000*1e18; // 20 mln $\n', '    \n', '    uint256 step4Sum = 30000000*1e18; // 30 mln $\n', '    \n', '    \n', '    event Authorized(address wlCandidate, uint timestamp);\n', '    \n', '    event Revoked(address wlCandidate, uint timestamp);\n', '    \n', '    event Refund(uint rate, address investor);\n', '    \n', '    \n', '    modifier isUnderHardCap() {\n', '        require(weisRaised <= hardCap);\n', '        _;\n', '    }\n', '    \n', '    modifier backEnd() {\n', '        require(msg.sender == backEndOperator || msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    \n', '    constructor(uint256 _dollareth) public {\n', '        dollarPrice = _dollareth;\n', '        buyPrice = 1e16/dollarPrice; // 16 decimals because 1 cent\n', '        hardCap = 7500000000*buyPrice;\n', '    }\n', '    \n', '    \n', '    function setToken (ERC20 _token) public onlyOwner {\n', '        token = _token;\n', '    }\n', '    \n', '    function setDollarRate(uint256 _usdether) public onlyOwner {\n', '        dollarPrice = _usdether;\n', '        buyPrice = 1e16/dollarPrice; // 16 decimals because 1 cent\n', '        hardCap = 7500000000*buyPrice;\n', '    }\n', '    \n', '    \n', '    function setPrice(uint256 newBuyPrice) public onlyOwner {\n', '        buyPrice = newBuyPrice;\n', '    }\n', '    \n', '    function setStartSale(uint256 newStartSale) public onlyOwner {\n', '        startSale = newStartSale;\n', '    }\n', '    \n', '    function setEndSale(uint256 newEndSaled) public onlyOwner {\n', '        endSale = newEndSaled;\n', '    }\n', '    \n', '    function setBackEndAddress(address newBackEndOperator) public onlyOwner {\n', '        backEndOperator = newBackEndOperator;\n', '    }\n', '    \n', '    /*******************************************************************************\n', "     * Whitelist's section */\n", '    \n', '    function authorize(address wlCandidate) public backEnd {\n', '        require(wlCandidate != address(0x0));\n', '        require(!isWhitelisted(wlCandidate));\n', '        whitelist[wlCandidate] = true;\n', '        investors++;\n', '        emit Authorized(wlCandidate, now);\n', '    }\n', '    \n', '    function revoke(address wlCandidate) public  onlyOwner {\n', '        whitelist[wlCandidate] = false;\n', '        investors--;\n', '        emit Revoked(wlCandidate, now);\n', '    }\n', '    \n', '    function isWhitelisted(address wlCandidate) public view returns(bool) {\n', '        return whitelist[wlCandidate];\n', '    }\n', '    \n', '    /*******************************************************************************\n', "     * Payable's section */\n", '    \n', '    function isMainSale() public constant returns(bool) {\n', '        return now >= startSale && now <= endSale;\n', '    }\n', '    \n', '    function () public payable isUnderHardCap {\n', '        require(isMainSale());\n', '        require(isWhitelisted(msg.sender));\n', '        require(msg.value >= 10000000000000000);\n', '        mainSale(msg.sender, msg.value);\n', '        investedEther[msg.sender] = investedEther[msg.sender].add(msg.value);\n', '    }\n', '    \n', '    function mainSale(address _investor, uint256 _value) internal {\n', '        uint256 tokens = _value.mul(1e18).div(buyPrice);\n', '        uint256 tokensSum = tokens.mul(discountSum(msg.value)).div(100);\n', '        uint256 tokensCollect = tokens.mul(discountCollect()).div(100);\n', '        tokens = tokens.add(tokensSum).add(tokensCollect);\n', '        token.mintFromICO(_investor, tokens);\n', '        uint256 tokensFounders = tokens.mul(5).div(12);\n', '        token.mintFromICO(team, tokensFounders);\n', '        uint256 tokensDevelopers = tokens.div(4);\n', '        token.mintFromICO(reserve, tokensDevelopers);\n', '        weisRaised = weisRaised.add(msg.value);\n', '        uint256 valueInUSD = msg.value.mul(dollarPrice);\n', '        dollarRaised = dollarRaised.add(valueInUSD);\n', '        soldTokens = soldTokens.add(tokens);\n', '    }\n', '    \n', '    \n', '    function discountSum(uint256 _tokens) pure private returns(uint256) {\n', '        if(_tokens >= 10000000*1e18) { // > 100k$ = 10,000,000 TAL\n', '            return 7;\n', '        }\n', '        if(_tokens >= 5000000*1e18) { // 50-100k$ = 5,000,000 TAL\n', '            return 5;\n', '        }\n', '        if(_tokens >= 1000000*1e18) { // 10-50k$ = 1,000,000 TAL\n', '            return 3;\n', '        } else\n', '            return 0;\n', '    }\n', '    \n', '    \n', '    function discountCollect() view private returns(uint256) {\n', '        // 20% bonus, if collected sum < 3 mln $\n', '        if(dollarRaised <= step1Sum) {\n', '            return 20;\n', '        } // 15% bonus, if collected sum < 10 mln $\n', '        if(dollarRaised <= step2Sum) {\n', '            return 15;\n', '        } // 10% bonus, if collected sum < 20 mln $\n', '        if(dollarRaised <= step3Sum) {\n', '            return 10;\n', '        } // 5% bonus, if collected sum < 30 mln $\n', '        if(dollarRaised <= step4Sum) {\n', '            return 5;\n', '        }\n', '        return 0;\n', '    }\n', '    \n', '    \n', '    function mintManual(address _investor, uint256 _value) public onlyOwner {\n', '        token.mintFromICO(_investor, _value);\n', '        uint256 tokensFounders = _value.mul(5).div(12);\n', '        token.mintFromICO(team, tokensFounders);\n', '        uint256 tokensDevelopers = _value.div(4);\n', '        token.mintFromICO(reserve, tokensDevelopers);\n', '    }\n', '    \n', '    \n', '    function transferEthFromContract(address _to, uint256 amount) public onlyOwner {\n', '        require(amount != 0);\n', '        require(_to != 0x0);\n', '        _to.transfer(amount);\n', '    }\n', '    \n', '    \n', '    function refundSale() public {\n', '        require(soldTokens < softCap && now > endSale);\n', '        uint256 rate = investedEther[msg.sender];\n', '        require(investedEther[msg.sender] >= 0);\n', '        investedEther[msg.sender] = 0;\n', '        msg.sender.transfer(rate);\n', '        weisRaised = weisRaised.sub(rate);\n', '        emit Refund(rate, msg.sender);\n', '    }\n', '}']
