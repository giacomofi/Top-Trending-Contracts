['/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', 'pragma solidity 0.4.21;\n', '/// @title Utility Functions for uint8\n', '/// @author Kongliang Zhong - <<span class="__cf_email__" data-cfemail="cba0a4a5aca7a2aaa5ac8ba7a4a4bbb9a2a5ace5a4b9ac">[email&#160;protected]</span>>,\n', '/// @author Daniel Wang - <<span class="__cf_email__" data-cfemail="1074717e79757c507c7f7f6062797e773e7f6277">[email&#160;protected]</span>>.\n', 'library MathUint8 {\n', '    function xorReduce(\n', '        uint8[] arr,\n', '        uint    len\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint8 res)\n', '    {\n', '        res = arr[0];\n', '        for (uint i = 1; i < len; i++) {\n', '            res ^= arr[i];\n', '        }\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <<span class="__cf_email__" data-cfemail="1d797c737478715d7172726d6f74737a33726f7a">[email&#160;protected]</span>>\n', 'library MathUint {\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function tolerantSub(uint a, uint b) internal pure returns (uint c) {\n', '        return (a >= b) ? a - b : 0;\n', '    }\n', '    /// @dev calculate the square of Coefficient of Variation (CV)\n', '    /// https://en.wikipedia.org/wiki/Coefficient_of_variation\n', '    function cvsquare(\n', '        uint[] arr,\n', '        uint scale\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        uint len = arr.length;\n', '        require(len > 1);\n', '        require(scale > 0);\n', '        uint avg = 0;\n', '        for (uint i = 0; i < len; i++) {\n', '            avg += arr[i];\n', '        }\n', '        avg = avg / len;\n', '        if (avg == 0) {\n', '            return 0;\n', '        }\n', '        uint cvs = 0;\n', '        uint s;\n', '        uint item;\n', '        for (i = 0; i < len; i++) {\n', '            item = arr[i];\n', '            s = item > avg ? item - avg : avg - item;\n', '            cvs += mul(s, s);\n', '        }\n', '        return ((mul(mul(cvs, scale), scale) / avg) / avg) / (len - 1);\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Utility Functions for byte32\n', '/// @author Kongliang Zhong - <<span class="__cf_email__" data-cfemail="c6ada9a8a1aaafa7a8a186aaa9a9b6b4afa8a1e8a9b4a1">[email&#160;protected]</span>>,\n', '/// @author Daniel Wang - <<span class="__cf_email__" data-cfemail="7014111e19151c301c1f1f0002191e175e1f0217">[email&#160;protected]</span>>.\n', 'library MathBytes32 {\n', '    function xorReduce(\n', '        bytes32[]   arr,\n', '        uint        len\n', '        )\n', '        internal\n', '        pure\n', '        returns (bytes32 res)\n', '    {\n', '        res = arr[0];\n', '        for (uint i = 1; i < len; i++) {\n', '            res ^= arr[i];\n', '        }\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Utility Functions for address\n', '/// @author Daniel Wang - <<span class="__cf_email__" data-cfemail="fb9f9a95929e97bb9794948b8992959cd594899c">[email&#160;protected]</span>>\n', 'library AddressUtil {\n', '    function isContract(address addr)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (addr == 0x0) {\n', '            return false;\n', '        } else {\n', '            uint size;\n', '            assembly { size := extcodesize(addr) }\n', '            return size > 0;\n', '        }\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <<span class="__cf_email__" data-cfemail="eb8f8a85828e87ab8784849b9982858cc584998c">[email&#160;protected]</span>>\n', 'contract ERC20 {\n', '    function balanceOf(address who) view public returns (uint256);\n', '    function allowance(address owner, address spender) view public returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Loopring Token Exchange Protocol Contract Interface\n', '/// @author Daniel Wang - <<span class="__cf_email__" data-cfemail="690d0807000c0529050606191b00070e47061b0e">[email&#160;protected]</span>>\n', '/// @author Kongliang Zhong - <<span class="__cf_email__" data-cfemail="b3d8dcddd4dfdad2ddd4f3dfdcdcc3c1daddd49ddcc1d4">[email&#160;protected]</span>>\n', 'contract LoopringProtocol {\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Constants                                                            ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    uint8   public constant MARGIN_SPLIT_PERCENTAGE_BASE = 100;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Events                                                               ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Event to emit if a ring is successfully mined.\n', '    /// _amountsList is an array of:\n', '    /// [_amountS, _amountB, _lrcReward, _lrcFee, splitS, splitB].\n', '    event RingMined(\n', '        uint                _ringIndex,\n', '        bytes32     indexed _ringHash,\n', '        address             _miner,\n', '        address             _feeRecipient,\n', '        bytes32[]           _orderHashList,\n', '        uint[6][]           _amountsList\n', '    );\n', '    event OrderCancelled(\n', '        bytes32     indexed _orderHash,\n', '        uint                _amountCancelled\n', '    );\n', '    event AllOrdersCancelled(\n', '        address     indexed _address,\n', '        uint                _cutoff\n', '    );\n', '    event OrdersCancelled(\n', '        address     indexed _address,\n', '        address             _token1,\n', '        address             _token2,\n', '        uint                _cutoff\n', '    );\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Functions                                                            ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Cancel a order. cancel amount(amountS or amountB) can be specified\n', '    ///      in orderValues.\n', '    /// @param addresses          owner, tokenS, tokenB, authAddr\n', '    /// @param orderValues        amountS, amountB, validSince (second),\n', '    ///                           validUntil (second), lrcFee, walletId, and\n', '    ///                           cancelAmount.\n', '    /// @param buyNoMoreThanAmountB -\n', '    ///                           This indicates when a order should be considered\n', '    ///                           as &#39;completely filled&#39;.\n', '    /// @param marginSplitPercentage -\n', '    ///                           Percentage of margin split to share with miner.\n', '    /// @param v                  Order ECDSA signature parameter v.\n', '    /// @param r                  Order ECDSA signature parameters r.\n', '    /// @param s                  Order ECDSA signature parameters s.\n', '    function cancelOrder(\n', '        address[4] addresses,\n', '        uint[7]    orderValues,\n', '        bool       buyNoMoreThanAmountB,\n', '        uint8      marginSplitPercentage,\n', '        uint8      v,\n', '        bytes32    r,\n', '        bytes32    s\n', '        ) external;\n', '    /// @dev   Set a cutoff timestamp to invalidate all orders whose timestamp\n', '    ///        is smaller than or equal to the new value of the address&#39;s cutoff\n', '    ///        timestamp, for a specific trading pair.\n', '    /// @param cutoff The cutoff timestamp, will default to `block.timestamp`\n', '    ///        if it is 0.\n', '    function cancelAllOrdersByTradingPair(\n', '        address token1,\n', '        address token2,\n', '        uint cutoff\n', '        ) external;\n', '    /// @dev   Set a cutoff timestamp to invalidate all orders whose timestamp\n', '    ///        is smaller than or equal to the new value of the address&#39;s cutoff\n', '    ///        timestamp.\n', '    /// @param cutoff The cutoff timestamp, will default to `block.timestamp`\n', '    ///        if it is 0.\n', '    function cancelAllOrders(uint cutoff) external;\n', '    /// @dev Submit a order-ring for validation and settlement.\n', '    /// @param addressList  List of each order&#39;s owner, tokenS, and authAddr.\n', '    ///                     Note that next order&#39;s `tokenS` equals this order&#39;s\n', '    ///                     `tokenB`.\n', '    /// @param uintArgsList List of uint-type arguments in this order:\n', '    ///                     amountS, amountB, validSince (second),\n', '    ///                     validUntil (second), lrcFee, rateAmountS, and walletId.\n', '    /// @param uint8ArgsList -\n', '    ///                     List of unit8-type arguments, in this order:\n', '    ///                     marginSplitPercentageList.\n', '    /// @param buyNoMoreThanAmountBList -\n', '    ///                     This indicates when a order should be considered\n', '    /// @param vList        List of v for each order. This list is 1-larger than\n', '    ///                     the previous lists, with the last element being the\n', '    ///                     v value of the ring signature.\n', '    /// @param rList        List of r for each order. This list is 1-larger than\n', '    ///                     the previous lists, with the last element being the\n', '    ///                     r value of the ring signature.\n', '    /// @param sList        List of s for each order. This list is 1-larger than\n', '    ///                     the previous lists, with the last element being the\n', '    ///                     s value of the ring signature.\n', '    /// @param minerId      The address pair that miner registered in NameRegistry.\n', '    ///                     The address pair contains a signer address and a fee\n', '    ///                     recipient address.\n', '    ///                     The signer address is used for sign this tx.\n', '    ///                     The Recipient address for fee collection. If this is\n', '    ///                     &#39;0x0&#39;, all fees will be paid to the address who had\n', '    ///                     signed this transaction, not `msg.sender`. Noted if\n', '    ///                     LRC need to be paid back to order owner as the result\n', '    ///                     of fee selection model, LRC will also be sent from\n', '    ///                     this address.\n', '    /// @param feeSelections -\n', '    ///                     Bits to indicate fee selections. `1` represents margin\n', '    ///                     split and `0` represents LRC as fee.\n', '    function submitRing(\n', '        address[3][]    addressList,\n', '        uint[7][]       uintArgsList,\n', '        uint8[1][]      uint8ArgsList,\n', '        bool[]          buyNoMoreThanAmountBList,\n', '        uint8[]         vList,\n', '        bytes32[]       rList,\n', '        bytes32[]       sList,\n', '        uint            minerId,\n', '        uint16          feeSelections\n', '        ) public;\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Ethereum Address Register Contract\n', '/// @dev This contract maintains a name service for addresses and miner.\n', '/// @author Kongliang Zhong - <<span class="__cf_email__" data-cfemail="12797d7c757e7b737c75527e7d7d62607b7c753c7d6075">[email&#160;protected]</span>>,\n', '/// @author Daniel Wang - <<span class="__cf_email__" data-cfemail="88ece9e6e1ede4c8e4e7e7f8fae1e6efa6e7faef">[email&#160;protected]</span>>,\n', 'contract NameRegistry {\n', '    uint public nextId = 0;\n', '    mapping (uint    => Participant) public participantMap;\n', '    mapping (address => NameInfo)    public nameInfoMap;\n', '    mapping (bytes12 => address)     public ownerMap;\n', '    mapping (address => string)      public nameMap;\n', '    struct NameInfo {\n', '        bytes12  name;\n', '        uint[]   participantIds;\n', '    }\n', '    struct Participant {\n', '        address feeRecipient;\n', '        address signer;\n', '        bytes12 name;\n', '        address owner;\n', '    }\n', '    event NameRegistered (\n', '        string            name,\n', '        address   indexed owner\n', '    );\n', '    event NameUnregistered (\n', '        string             name,\n', '        address    indexed owner\n', '    );\n', '    event OwnershipTransfered (\n', '        bytes12            name,\n', '        address            oldOwner,\n', '        address            newOwner\n', '    );\n', '    event ParticipantRegistered (\n', '        bytes12           name,\n', '        address   indexed owner,\n', '        uint      indexed participantId,\n', '        address           singer,\n', '        address           feeRecipient\n', '    );\n', '    event ParticipantUnregistered (\n', '        uint    participantId,\n', '        address owner\n', '    );\n', '    function registerName(string name)\n', '        external\n', '    {\n', '        require(isNameValid(name));\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        require(ownerMap[nameBytes] == 0x0);\n', '        require(stringToBytes12(nameMap[msg.sender]) == bytes12(0x0));\n', '        nameInfoMap[msg.sender] = NameInfo(nameBytes, new uint[](0));\n', '        ownerMap[nameBytes] = msg.sender;\n', '        nameMap[msg.sender] = name;\n', '        emit NameRegistered(name, msg.sender);\n', '    }\n', '    function unregisterName(string name)\n', '        external\n', '    {\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        uint[] storage participantIds = nameInfo.participantIds;\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        require(nameInfo.name == nameBytes);\n', '        for (uint i = 0; i < participantIds.length; i++) {\n', '            delete participantMap[participantIds[i]];\n', '        }\n', '        delete nameInfoMap[msg.sender];\n', '        delete nameMap[msg.sender];\n', '        delete ownerMap[nameBytes];\n', '        emit NameUnregistered(name, msg.sender);\n', '    }\n', '    function transferOwnership(address newOwner)\n', '        external\n', '    {\n', '        require(newOwner != 0x0);\n', '        require(nameInfoMap[newOwner].name.length == 0);\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        string storage name = nameMap[msg.sender];\n', '        uint[] memory participantIds = nameInfo.participantIds;\n', '        for (uint i = 0; i < participantIds.length; i ++) {\n', '            Participant storage p = participantMap[participantIds[i]];\n', '            p.owner = newOwner;\n', '        }\n', '        delete nameInfoMap[msg.sender];\n', '        delete nameMap[msg.sender];\n', '        nameInfoMap[newOwner] = nameInfo;\n', '        nameMap[newOwner] = name;\n', '        emit OwnershipTransfered(nameInfo.name, msg.sender, newOwner);\n', '    }\n', '    /* function addParticipant(address feeRecipient) */\n', '    /*     external */\n', '    /*     returns (uint) */\n', '    /* { */\n', '    /*     return addParticipant(feeRecipient, feeRecipient); */\n', '    /* } */\n', '    function addParticipant(\n', '        address feeRecipient,\n', '        address singer\n', '        )\n', '        external\n', '        returns (uint)\n', '    {\n', '        require(feeRecipient != 0x0 && singer != 0x0);\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        bytes12 name = nameInfo.name;\n', '        require(name.length > 0);\n', '        Participant memory participant = Participant(\n', '            feeRecipient,\n', '            singer,\n', '            name,\n', '            msg.sender\n', '        );\n', '        uint participantId = ++nextId;\n', '        participantMap[participantId] = participant;\n', '        nameInfo.participantIds.push(participantId);\n', '        emit ParticipantRegistered(\n', '            name,\n', '            msg.sender,\n', '            participantId,\n', '            singer,\n', '            feeRecipient\n', '        );\n', '        return participantId;\n', '    }\n', '    function removeParticipant(uint participantId)\n', '        external\n', '    {\n', '        require(msg.sender == participantMap[participantId].owner);\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        uint[] storage participantIds = nameInfo.participantIds;\n', '        delete participantMap[participantId];\n', '        uint len = participantIds.length;\n', '        for (uint i = 0; i < len; i ++) {\n', '            if (participantId == participantIds[i]) {\n', '                participantIds[i] = participantIds[len - 1];\n', '                participantIds.length -= 1;\n', '            }\n', '        }\n', '        emit ParticipantUnregistered(participantId, msg.sender);\n', '    }\n', '    function getParticipantById(uint id)\n', '        external\n', '        view\n', '        returns (address feeRecipient, address signer)\n', '    {\n', '        Participant storage addressSet = participantMap[id];\n', '        feeRecipient = addressSet.feeRecipient;\n', '        signer = addressSet.signer;\n', '    }\n', '    function getFeeRecipientById(uint id)\n', '        external\n', '        view\n', '        returns (address feeRecipient)\n', '    {\n', '        Participant storage addressSet = participantMap[id];\n', '        feeRecipient = addressSet.feeRecipient;\n', '    }\n', '    function getParticipantIds(string name, uint start, uint count)\n', '        external\n', '        view\n', '        returns (uint[] idList)\n', '    {\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        address owner = ownerMap[nameBytes];\n', '        require(owner != 0x0);\n', '        NameInfo storage nameInfo = nameInfoMap[owner];\n', '        uint[] storage pIds = nameInfo.participantIds;\n', '        uint len = pIds.length;\n', '        if (start >= len) {\n', '            return;\n', '        }\n', '        uint end = start + count;\n', '        if (end > len) {\n', '            end = len;\n', '        }\n', '        if (start == end) {\n', '            return;\n', '        }\n', '        idList = new uint[](end - start);\n', '        for (uint i = start; i < end; i ++) {\n', '            idList[i - start] = pIds[i];\n', '        }\n', '    }\n', '    function getOwner(string name)\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        return ownerMap[nameBytes];\n', '    }\n', '    function isNameValid(string name)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        bytes memory temp = bytes(name);\n', '        return temp.length >= 6 && temp.length <= 12;\n', '    }\n', '    function stringToBytes12(string str)\n', '        internal\n', '        pure\n', '        returns (bytes12 result)\n', '    {\n', '        assembly {\n', '            result := mload(add(str, 32))\n', '        }\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      newOwner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != 0x0);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '/// @title Claimable\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable {\n', '    address public pendingOwner;\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != 0x0 && newOwner != owner);\n', '        pendingOwner = newOwner;\n', '    }\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership() onlyPendingOwner public {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = 0x0;\n', '    }\n', '}\n', '/// @title Token Register Contract\n', '/// @dev This contract maintains a list of tokens the Protocol supports.\n', '/// @author Kongliang Zhong - <<span class="__cf_email__" data-cfemail="91fafefff6fdf8f0fff6d1fdfefee1e3f8fff6bffee3f6">[email&#160;protected]</span>>,\n', '/// @author Daniel Wang - <<span class="__cf_email__" data-cfemail="c3a7a2adaaa6af83afacacb3b1aaada4edacb1a4">[email&#160;protected]</span>>.\n', 'contract TokenRegistry is Claimable {\n', '    using AddressUtil for address;\n', '    address tokenMintAddr;\n', '    address[] public addresses;\n', '    mapping (address => TokenInfo) addressMap;\n', '    mapping (string => address) symbolMap;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Structs                                                              ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    struct TokenInfo {\n', '        uint   pos;      // 0 mens unregistered; if > 0, pos + 1 is the\n', '                         // token&#39;s position in `addresses`.\n', '        string symbol;   // Symbol of the token\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Events                                                               ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    event TokenRegistered(address addr, string symbol);\n', '    event TokenUnregistered(address addr, string symbol);\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Public Functions                                                     ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Disable default function.\n', '    function () payable public {\n', '        revert();\n', '    }\n', '    function TokenRegistry(address _tokenMintAddr) public\n', '    {\n', '        require(_tokenMintAddr.isContract());\n', '        tokenMintAddr = _tokenMintAddr;\n', '    }\n', '    function registerToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external\n', '        onlyOwner\n', '    {\n', '        registerTokenInternal(addr, symbol);\n', '    }\n', '    function registerMintedToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external\n', '    {\n', '        require(msg.sender == tokenMintAddr);\n', '        registerTokenInternal(addr, symbol);\n', '    }\n', '    function unregisterToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(addr != 0x0);\n', '        require(symbolMap[symbol] == addr);\n', '        delete symbolMap[symbol];\n', '        uint pos = addressMap[addr].pos;\n', '        require(pos != 0);\n', '        delete addressMap[addr];\n', '        // We will replace the token we need to unregister with the last token\n', '        // Only the pos of the last token will need to be updated\n', '        address lastToken = addresses[addresses.length - 1];\n', '        // Don&#39;t do anything if the last token is the one we want to delete\n', '        if (addr != lastToken) {\n', '            // Swap with the last token and update the pos\n', '            addresses[pos - 1] = lastToken;\n', '            addressMap[lastToken].pos = pos;\n', '        }\n', '        addresses.length--;\n', '        emit TokenUnregistered(addr, symbol);\n', '    }\n', '    function areAllTokensRegistered(address[] addressList)\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        for (uint i = 0; i < addressList.length; i++) {\n', '            if (addressMap[addressList[i]].pos == 0) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    function getAddressBySymbol(string symbol)\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return symbolMap[symbol];\n', '    }\n', '    function isTokenRegisteredBySymbol(string symbol)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return symbolMap[symbol] != 0x0;\n', '    }\n', '    function isTokenRegistered(address addr)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return addressMap[addr].pos != 0;\n', '    }\n', '    function getTokens(\n', '        uint start,\n', '        uint count\n', '        )\n', '        public\n', '        view\n', '        returns (address[] addressList)\n', '    {\n', '        uint num = addresses.length;\n', '        if (start >= num) {\n', '            return;\n', '        }\n', '        uint end = start + count;\n', '        if (end > num) {\n', '            end = num;\n', '        }\n', '        if (start == num) {\n', '            return;\n', '        }\n', '        addressList = new address[](end - start);\n', '        for (uint i = start; i < end; i++) {\n', '            addressList[i - start] = addresses[i];\n', '        }\n', '    }\n', '    function registerTokenInternal(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        internal\n', '    {\n', '        require(0x0 != addr);\n', '        require(bytes(symbol).length > 0);\n', '        require(0x0 == symbolMap[symbol]);\n', '        require(0 == addressMap[addr].pos);\n', '        addresses.push(addr);\n', '        symbolMap[symbol] = addr;\n', '        addressMap[addr] = TokenInfo(addresses.length, symbol);\n', '        emit TokenRegistered(addr, symbol);\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title TokenTransferDelegate\n', '/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different\n', '/// versions of Loopring protocol to avoid ERC20 re-authorization.\n', '/// @author Daniel Wang - <<span class="__cf_email__" data-cfemail="5b3f3a35323e371b3734342b2932353c7534293c">[email&#160;protected]</span>>.\n', 'contract TokenTransferDelegate is Claimable {\n', '    using MathUint for uint;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Variables                                                            ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    mapping(address => AddressInfo) private addressInfos;\n', '    address public latestAddress;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Structs                                                              ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    struct AddressInfo {\n', '        address previous;\n', '        uint32  index;\n', '        bool    authorized;\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Modifiers                                                            ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    modifier onlyAuthorized() {\n', '        require(addressInfos[msg.sender].authorized);\n', '        _;\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Events                                                               ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    event AddressAuthorized(address indexed addr, uint32 number);\n', '    event AddressDeauthorized(address indexed addr, uint32 number);\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Public Functions                                                     ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Disable default function.\n', '    function () payable public {\n', '        revert();\n', '    }\n', '    /// @dev Add a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function authorizeAddress(address addr)\n', '        onlyOwner\n', '        external\n', '    {\n', '        AddressInfo storage addrInfo = addressInfos[addr];\n', '        if (addrInfo.index != 0) { // existing\n', '            if (addrInfo.authorized == false) { // re-authorize\n', '                addrInfo.authorized = true;\n', '                emit AddressAuthorized(addr, addrInfo.index);\n', '            }\n', '        } else {\n', '            address prev = latestAddress;\n', '            if (prev == 0x0) {\n', '                addrInfo.index = 1;\n', '                addrInfo.authorized = true;\n', '            } else {\n', '                addrInfo.previous = prev;\n', '                addrInfo.index = addressInfos[prev].index + 1;\n', '            }\n', '            addrInfo.authorized = true;\n', '            latestAddress = addr;\n', '            emit AddressAuthorized(addr, addrInfo.index);\n', '        }\n', '    }\n', '    /// @dev Remove a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function deauthorizeAddress(address addr)\n', '        onlyOwner\n', '        external\n', '    {\n', '        uint32 index = addressInfos[addr].index;\n', '        if (index != 0) {\n', '            addressInfos[addr].authorized = false;\n', '            emit AddressDeauthorized(addr, index);\n', '        }\n', '    }\n', '    function getLatestAuthorizedAddresses(uint max)\n', '        external\n', '        view\n', '        returns (address[] addresses)\n', '    {\n', '        addresses = new address[](max);\n', '        address addr = latestAddress;\n', '        AddressInfo memory addrInfo;\n', '        uint count = 0;\n', '        while (addr != 0x0 && count < max) {\n', '            addrInfo = addressInfos[addr];\n', '            if (addrInfo.index == 0) {\n', '                break;\n', '            }\n', '            addresses[count++] = addr;\n', '            addr = addrInfo.previous;\n', '        }\n', '    }\n', '    /// @dev Invoke ERC20 transferFrom method.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    function transferToken(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value)\n', '        onlyAuthorized\n', '        external\n', '    {\n', '        if (value > 0 && from != to && to != 0x0) {\n', '            require(\n', '                ERC20(token).transferFrom(from, to, value)\n', '            );\n', '        }\n', '    }\n', '    function batchTransferToken(\n', '        address lrcTokenAddress,\n', '        address minerFeeRecipient,\n', '        uint8 walletSplitPercentage,\n', '        bytes32[] batch)\n', '        onlyAuthorized\n', '        external\n', '    {\n', '        uint len = batch.length;\n', '        require(len % 7 == 0);\n', '        require(walletSplitPercentage > 0 && walletSplitPercentage < 100);\n', '        ERC20 lrc = ERC20(lrcTokenAddress);\n', '        for (uint i = 0; i < len; i += 7) {\n', '            address owner = address(batch[i]);\n', '            address prevOwner = address(batch[(i + len - 7) % len]);\n', '            // Pay token to previous order, or to miner as previous order&#39;s\n', '            // margin split or/and this order&#39;s margin split.\n', '            ERC20 token = ERC20(address(batch[i + 1]));\n', '            // Here batch[i + 2] has been checked not to be 0.\n', '            if (owner != prevOwner) {\n', '                require(\n', '                    token.transferFrom(\n', '                        owner,\n', '                        prevOwner,\n', '                        uint(batch[i + 2])\n', '                    )\n', '                );\n', '            }\n', '            // Miner pays LRx fee to order owner\n', '            uint lrcReward = uint(batch[i + 4]);\n', '            if (lrcReward != 0 && minerFeeRecipient != owner) {\n', '                require(\n', '                    lrc.transferFrom(\n', '                        minerFeeRecipient,\n', '                        owner,\n', '                        lrcReward\n', '                    )\n', '                );\n', '            }\n', '            // Split margin-split income between miner and wallet\n', '            splitPayFee(\n', '                token,\n', '                uint(batch[i + 3]),\n', '                owner,\n', '                minerFeeRecipient,\n', '                address(batch[i + 6]),\n', '                walletSplitPercentage\n', '            );\n', '            // Split LRx fee income between miner and wallet\n', '            splitPayFee(\n', '                lrc,\n', '                uint(batch[i + 5]),\n', '                owner,\n', '                minerFeeRecipient,\n', '                address(batch[i + 6]),\n', '                walletSplitPercentage\n', '            );\n', '        }\n', '    }\n', '    function isAddressAuthorized(address addr)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return addressInfos[addr].authorized;\n', '    }\n', '    function splitPayFee(\n', '        ERC20   token,\n', '        uint    fee,\n', '        address owner,\n', '        address minerFeeRecipient,\n', '        address walletFeeRecipient,\n', '        uint    walletSplitPercentage\n', '        )\n', '        internal\n', '    {\n', '        if (fee == 0) {\n', '            return;\n', '        }\n', '        uint walletFee = (walletFeeRecipient == 0x0) ? 0 : fee.mul(walletSplitPercentage) / 100;\n', '        uint minerFee = fee - walletFee;\n', '        if (walletFee > 0 && walletFeeRecipient != owner) {\n', '            require(\n', '                token.transferFrom(\n', '                    owner,\n', '                    walletFeeRecipient,\n', '                    walletFee\n', '                )\n', '            );\n', '        }\n', '        if (minerFee > 0 && minerFeeRecipient != 0x0 && minerFeeRecipient != owner) {\n', '            require(\n', '                token.transferFrom(\n', '                    owner,\n', '                    minerFeeRecipient,\n', '                    minerFee\n', '                )\n', '            );\n', '        }\n', '    }\n', '}\n', '/// @title Loopring Token Exchange Protocol Implementation Contract\n', '/// @author Daniel Wang - <<span class="__cf_email__" data-cfemail="0a6e6b64636f664a6665657a7863646d2465786d">[email&#160;protected]</span>>,\n', '/// @author Kongliang Zhong - <<span class="__cf_email__" data-cfemail="4e2521202922272f20290e2221213e3c27202960213c29">[email&#160;protected]</span>>\n', '///\n', '/// Recognized contributing developers from the community:\n', '///     https://github.com/Brechtpd\n', '///     https://github.com/rainydio\n', '///     https://github.com/BenjaminPrice\n', '///     https://github.com/jonasshen\n', 'contract LoopringProtocolImpl is LoopringProtocol {\n', '    using AddressUtil   for address;\n', '    using MathBytes32   for bytes32[];\n', '    using MathUint      for uint;\n', '    using MathUint8     for uint8[];\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Variables                                                            ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    address public  lrcTokenAddress             = 0xEF68e7C694F40c8202821eDF525dE3782458639f;\n', '    address public  tokenRegistryAddress        = 0xaD3407deDc56A1F69389Edc191b770F0c935Ea37;\n', '    address public  delegateAddress             = 0x7b126ab811f278f288bf1d62d47334351dA20d1d;\n', '    address public  nameRegistryAddress         = 0xC897816C1A6DB4A2923b7D75d9B812e2f62cF504;\n', '    uint64  public  ringIndex                   = 0;\n', '    uint8   public  walletSplitPercentage       = 20;\n', '    // Exchange rate (rate) is the amount to sell or sold divided by the amount\n', '    // to buy or bought.\n', '    //\n', '    // Rate ratio is the ratio between executed rate and an order&#39;s original\n', '    // rate.\n', '    //\n', '    // To require all orders&#39; rate ratios to have coefficient ofvariation (CV)\n', '    // smaller than 2.5%, for an example , rateRatioCVSThreshold should be:\n', '    //     `(0.025 * RATE_RATIO_SCALE)^2` or 62500.\n', '    uint    public constant rateRatioCVSThreshold        = 62500;\n', '\n', '    uint    public constant MAX_RING_SIZE       = 16;\n', '    uint    public constant RATE_RATIO_SCALE    = 10000;\n', '    uint64  public constant ENTERED_MASK        = 1 << 63;\n', '    // The following map is used to keep trace of order fill and cancellation\n', '    // history.\n', '    mapping (bytes32 => uint) public cancelledOrFilled;\n', '    // This map is used to keep trace of order&#39;s cancellation history.\n', '    mapping (bytes32 => uint) public cancelled;\n', '    // A map from address to its cutoff timestamp.\n', '    mapping (address => uint) public cutoffs;\n', '    // A map from address to its trading-pair cutoff timestamp.\n', '    mapping (address => mapping (bytes20 => uint)) public tradingPairCutoffs;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Structs                                                              ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    struct Rate {\n', '        uint amountS;\n', '        uint amountB;\n', '    }\n', '    /// @param tokenS       Token to sell.\n', '    /// @param tokenB       Token to buy.\n', '    /// @param amountS      Maximum amount of tokenS to sell.\n', '    /// @param amountB      Minimum amount of tokenB to buy if all amountS sold.\n', '    /// @param authAddr     An address to verify miner has access to the order&#39;s\n', '    ///                     auth private-key.\n', '    /// @param validSince   Indicating when this order should be treated as\n', '    ///                     valid for trading, in second.\n', '    /// @param validUntil   Indicating when this order should be treated as\n', '    ///                     expired, in second.\n', '    /// @param lrcFee       Max amount of LRC to pay for miner. The real amount\n', '    ///                     to pay is proportional to fill amount.\n', '    /// @param buyNoMoreThanAmountB -\n', '    ///                     If true, this order does not accept buying more\n', '    ///                     than `amountB`.\n', '    /// @param walletId     The id of the wallet that generated this order.\n', '    /// @param marginSplitPercentage -\n', '    ///                     The percentage of margin paid to miner.\n', '    /// @param v            ECDSA signature parameter v.\n', '    /// @param r            ECDSA signature parameters r.\n', '    /// @param s            ECDSA signature parameters s.\n', '    struct Order {\n', '        address owner;\n', '        address tokenS;\n', '        address tokenB;\n', '        address authAddr;\n', '        uint    validSince;\n', '        uint    validUntil;\n', '        uint    amountS;\n', '        uint    amountB;\n', '        uint    lrcFee;\n', '        bool    buyNoMoreThanAmountB;\n', '        uint    walletId;\n', '        uint8   marginSplitPercentage;\n', '    }\n', '    /// @param order        The original order\n', '    /// @param orderHash    The order&#39;s hash\n', '    /// @param feeSelection -\n', '    ///                     A miner-supplied value indicating if LRC (value = 0)\n', '    ///                     or margin split is choosen by the miner (value = 1).\n', '    ///                     We may support more fee model in the future.\n', '    /// @param rate         Exchange rate provided by miner.\n', '    /// @param fillAmountS  Amount of tokenS to sell, calculated by protocol.\n', '    /// @param lrcReward    The amount of LRC paid by miner to order owner in\n', '    ///                     exchange for margin split.\n', '    /// @param lrcFee       The amount of LR paid by order owner to miner.\n', '    /// @param splitS      TokenS paid to miner.\n', '    /// @param splitB      TokenB paid to miner.\n', '    struct OrderState {\n', '        Order   order;\n', '        bytes32 orderHash;\n', '        bool    marginSplitAsFee;\n', '        Rate    rate;\n', '        uint    fillAmountS;\n', '        uint    lrcReward;\n', '        uint    lrcFee;\n', '        uint    splitS;\n', '        uint    splitB;\n', '    }\n', '    /// @dev A struct to capture parameters passed to submitRing method and\n', '    ///      various of other variables used across the submitRing core logics.\n', '    struct RingParams {\n', '        address[3][]  addressList;\n', '        uint[7][]     uintArgsList;\n', '        uint8[1][]    uint8ArgsList;\n', '        bool[]        buyNoMoreThanAmountBList;\n', '        uint8[]       vList;\n', '        bytes32[]     rList;\n', '        bytes32[]     sList;\n', '        uint          minerId;\n', '        uint          ringSize;         // computed\n', '        uint16        feeSelections;\n', '        address       ringMiner;        // queried\n', '        address       feeRecipient;     // queried\n', '        bytes32       ringHash;         // computed\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Constructor                                                          ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Public Functions                                                     ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Disable default function.\n', '    function () payable public {\n', '        revert();\n', '    }\n', '    function cancelOrder(\n', '        address[4] addresses,\n', '        uint[7]    orderValues,\n', '        bool       buyNoMoreThanAmountB,\n', '        uint8      marginSplitPercentage,\n', '        uint8      v,\n', '        bytes32    r,\n', '        bytes32    s\n', '        )\n', '        external\n', '    {\n', '        uint cancelAmount = orderValues[6];\n', '        require(cancelAmount > 0); // "amount to cancel is zero");\n', '        Order memory order = Order(\n', '            addresses[0],\n', '            addresses[1],\n', '            addresses[2],\n', '            addresses[3],\n', '            orderValues[2],\n', '            orderValues[3],\n', '            orderValues[0],\n', '            orderValues[1],\n', '            orderValues[4],\n', '            buyNoMoreThanAmountB,\n', '            orderValues[5],\n', '            marginSplitPercentage\n', '        );\n', '        require(msg.sender == order.owner); // "cancelOrder not submitted by order owner");\n', '        bytes32 orderHash = calculateOrderHash(order);\n', '        verifySignature(\n', '            order.owner,\n', '            orderHash,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '        cancelled[orderHash] = cancelled[orderHash].add(cancelAmount);\n', '        cancelledOrFilled[orderHash] = cancelledOrFilled[orderHash].add(cancelAmount);\n', '        emit OrderCancelled(orderHash, cancelAmount);\n', '    }\n', '    function cancelAllOrdersByTradingPair(\n', '        address token1,\n', '        address token2,\n', '        uint    cutoff\n', '        )\n', '        external\n', '    {\n', '        uint t = (cutoff == 0 || cutoff >= block.timestamp) ? block.timestamp : cutoff;\n', '        bytes20 tokenPair = bytes20(token1) ^ bytes20(token2);\n', '        require(tradingPairCutoffs[msg.sender][tokenPair] < t); // "attempted to set cutoff to a smaller value"\n', '        tradingPairCutoffs[msg.sender][tokenPair] = t;\n', '        emit OrdersCancelled(\n', '            msg.sender,\n', '            token1,\n', '            token2,\n', '            t\n', '        );\n', '    }\n', '    function cancelAllOrders(uint cutoff)\n', '        external\n', '    {\n', '        uint t = (cutoff == 0 || cutoff >= block.timestamp) ? block.timestamp : cutoff;\n', '        require(cutoffs[msg.sender] < t); // "attempted to set cutoff to a smaller value"\n', '        cutoffs[msg.sender] = t;\n', '        emit AllOrdersCancelled(msg.sender, t);\n', '    }\n', '    function submitRing(\n', '        address[3][]  addressList,\n', '        uint[7][]     uintArgsList,\n', '        uint8[1][]    uint8ArgsList,\n', '        bool[]        buyNoMoreThanAmountBList,\n', '        uint8[]       vList,\n', '        bytes32[]     rList,\n', '        bytes32[]     sList,\n', '        uint          minerId,\n', '        uint16        feeSelections\n', '        )\n', '        public\n', '    {\n', '        // Check if the highest bit of ringIndex is &#39;1&#39;.\n', '        require(ringIndex & ENTERED_MASK != ENTERED_MASK); // "attempted to re-ent submitRing function");\n', '        // Set the highest bit of ringIndex to &#39;1&#39;.\n', '        ringIndex |= ENTERED_MASK;\n', '        RingParams memory params = RingParams(\n', '            addressList,\n', '            uintArgsList,\n', '            uint8ArgsList,\n', '            buyNoMoreThanAmountBList,\n', '            vList,\n', '            rList,\n', '            sList,\n', '            minerId,\n', '            addressList.length,\n', '            feeSelections,\n', '            0x0,        // ringMiner\n', '            0x0,        // feeRecipient\n', '            0x0         // ringHash\n', '        );\n', '        verifyInputDataIntegrity(params);\n', '        updateFeeRecipient(params);\n', '        // Assemble input data into structs so we can pass them to other functions.\n', '        // This method also calculates ringHash, therefore it must be called before\n', '        // calling `verifyRingSignatures`.\n', '        OrderState[] memory orders = assembleOrders(params);\n', '        verifyRingSignatures(params);\n', '        verifyTokensRegistered(params);\n', '        handleRing(params, orders);\n', '        ringIndex = (ringIndex ^ ENTERED_MASK) + 1;\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Internal & Private Functions                                         ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Validate a ring.\n', '    function verifyRingHasNoSubRing(\n', '        uint          ringSize,\n', '        OrderState[]  orders\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        // Check the ring has no sub-ring.\n', '        for (uint i = 0; i < ringSize - 1; i++) {\n', '            address tokenS = orders[i].order.tokenS;\n', '            for (uint j = i + 1; j < ringSize; j++) {\n', '                require(tokenS != orders[j].order.tokenS); // "found sub-ring");\n', '            }\n', '        }\n', '    }\n', '    /// @dev Verify the ringHash has been signed with each order&#39;s auth private\n', '    ///      keys as well as the miner&#39;s private key.\n', '    function verifyRingSignatures(RingParams params)\n', '        private\n', '        pure\n', '    {\n', '        uint j;\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            j = i + params.ringSize;\n', '            verifySignature(\n', '                params.addressList[i][2],  // authAddr\n', '                params.ringHash,\n', '                params.vList[j],\n', '                params.rList[j],\n', '                params.sList[j]\n', '            );\n', '        }\n', '        if (params.ringMiner != 0x0) {\n', '            j++;\n', '            verifySignature(\n', '                params.ringMiner,\n', '                params.ringHash,\n', '                params.vList[j],\n', '                params.rList[j],\n', '                params.sList[j]\n', '            );\n', '        }\n', '    }\n', '    function verifyTokensRegistered(RingParams params)\n', '        private\n', '        view\n', '    {\n', '        // Extract the token addresses\n', '        address[] memory tokens = new address[](params.ringSize);\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            tokens[i] = params.addressList[i][1];\n', '        }\n', '        // Test all token addresses at once\n', '        require(\n', '            TokenRegistry(tokenRegistryAddress).areAllTokensRegistered(tokens)\n', '        ); // "token not registered");\n', '    }\n', '    function updateFeeRecipient(RingParams params)\n', '        private\n', '        view\n', '    {\n', '        if (params.minerId == 0) {\n', '            params.feeRecipient = msg.sender;\n', '        } else {\n', '            (params.feeRecipient, params.ringMiner) = NameRegistry(\n', '                nameRegistryAddress\n', '            ).getParticipantById(\n', '                params.minerId\n', '            );\n', '            if (params.feeRecipient == 0x0) {\n', '                params.feeRecipient = msg.sender;\n', '            }\n', '        }\n', '        uint sigSize = params.ringSize * 2;\n', '        if (params.ringMiner != 0x0) {\n', '            sigSize += 1;\n', '        }\n', '        require(sigSize == params.vList.length); // "ring data is inconsistent - vList");\n', '        require(sigSize == params.rList.length); // "ring data is inconsistent - rList");\n', '        require(sigSize == params.sList.length); // "ring data is inconsistent - sList");\n', '    }\n', '    function handleRing(\n', '        RingParams    params,\n', '        OrderState[]  orders\n', '        )\n', '        private\n', '    {\n', '        uint64 _ringIndex = ringIndex ^ ENTERED_MASK;\n', '        address _lrcTokenAddress = lrcTokenAddress;\n', '        TokenTransferDelegate delegate = TokenTransferDelegate(delegateAddress);\n', '        // Do the hard work.\n', '        verifyRingHasNoSubRing(params.ringSize, orders);\n', '        // Exchange rates calculation are performed by ring-miners as solidity\n', '        // cannot get power-of-1/n operation, therefore we have to verify\n', '        // these rates are correct.\n', '        verifyMinerSuppliedFillRates(params.ringSize, orders);\n', '        // Scale down each order independently by substracting amount-filled and\n', '        // amount-cancelled. Order owner&#39;s current balance and allowance are\n', '        // not taken into consideration in these operations.\n', '        scaleRingBasedOnHistoricalRecords(delegate, params.ringSize, orders);\n', '        // Based on the already verified exchange rate provided by ring-miners,\n', '        // we can furthur scale down orders based on token balance and allowance,\n', '        // then find the smallest order of the ring, then calculate each order&#39;s\n', '        // `fillAmountS`.\n', '        calculateRingFillAmount(params.ringSize, orders);\n', '        // Calculate each order&#39;s `lrcFee` and `lrcRewrard` and splict how much\n', '        // of `fillAmountS` shall be paid to matching order or miner as margin\n', '        // split.\n', '        calculateRingFees(\n', '            delegate,\n', '            params.ringSize,\n', '            orders,\n', '            params.feeRecipient,\n', '            _lrcTokenAddress\n', '        );\n', '        /// Make transfers.\n', '        bytes32[] memory orderHashList;\n', '        uint[6][] memory amountsList;\n', '        (orderHashList, amountsList) = settleRing(\n', '            delegate,\n', '            params.ringSize,\n', '            orders,\n', '            params.feeRecipient,\n', '            _lrcTokenAddress\n', '        );\n', '        emit RingMined(\n', '            _ringIndex,\n', '            params.ringHash,\n', '            params.ringMiner,\n', '            params.feeRecipient,\n', '            orderHashList,\n', '            amountsList\n', '        );\n', '    }\n', '    function settleRing(\n', '        TokenTransferDelegate delegate,\n', '        uint          ringSize,\n', '        OrderState[]  orders,\n', '        address       feeRecipient,\n', '        address       _lrcTokenAddress\n', '        )\n', '        private\n', '        returns (\n', '        bytes32[] memory orderHashList,\n', '        uint[6][] memory amountsList)\n', '    {\n', '        bytes32[] memory batch = new bytes32[](ringSize * 7); // ringSize * (owner + tokenS + 4 amounts + walletAddrress)\n', '        orderHashList = new bytes32[](ringSize);\n', '        amountsList = new uint[6][](ringSize);\n', '        uint p = 0;\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            OrderState memory state = orders[i];\n', '            Order memory order = state.order;\n', '            uint prevSplitB = orders[(i + ringSize - 1) % ringSize].splitB;\n', '            uint nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;\n', '            // Store owner and tokenS of every order\n', '            batch[p] = bytes32(order.owner);\n', '            batch[p + 1] = bytes32(order.tokenS);\n', '            // Store all amounts\n', '            batch[p + 2] = bytes32(state.fillAmountS - prevSplitB);\n', '            batch[p + 3] = bytes32(prevSplitB + state.splitS);\n', '            batch[p + 4] = bytes32(state.lrcReward);\n', '            batch[p + 5] = bytes32(state.lrcFee);\n', '            if (order.walletId != 0) {\n', '                batch[p + 6] = bytes32(NameRegistry(nameRegistryAddress).getFeeRecipientById(order.walletId));\n', '            } else {\n', '                batch[p + 6] = bytes32(0x0);\n', '            }\n', '            p += 7;\n', '            // Update fill records\n', '            if (order.buyNoMoreThanAmountB) {\n', '                cancelledOrFilled[state.orderHash] += nextFillAmountS;\n', '            } else {\n', '                cancelledOrFilled[state.orderHash] += state.fillAmountS;\n', '            }\n', '            orderHashList[i] = state.orderHash;\n', '            amountsList[i][0] = state.fillAmountS + state.splitS;\n', '            amountsList[i][1] = nextFillAmountS - state.splitB;\n', '            amountsList[i][2] = state.lrcReward;\n', '            amountsList[i][3] = state.lrcFee;\n', '            amountsList[i][4] = state.splitS;\n', '            amountsList[i][5] = state.splitB;\n', '        }\n', '        // Do all transactions\n', '        delegate.batchTransferToken(\n', '            _lrcTokenAddress,\n', '            feeRecipient,\n', '            walletSplitPercentage,\n', '            batch\n', '        );\n', '    }\n', '    /// @dev Verify miner has calculte the rates correctly.\n', '    function verifyMinerSuppliedFillRates(\n', '        uint          ringSize,\n', '        OrderState[]  orders\n', '        )\n', '        private\n', '        view\n', '    {\n', '        uint[] memory rateRatios = new uint[](ringSize);\n', '        uint _rateRatioScale = RATE_RATIO_SCALE;\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            uint s1b0 = orders[i].rate.amountS.mul(orders[i].order.amountB);\n', '            uint s0b1 = orders[i].order.amountS.mul(orders[i].rate.amountB);\n', '            require(s1b0 <= s0b1); // "miner supplied exchange rate provides invalid discount");\n', '            rateRatios[i] = _rateRatioScale.mul(s1b0) / s0b1;\n', '        }\n', '        uint cvs = MathUint.cvsquare(rateRatios, _rateRatioScale);\n', '        require(cvs <= rateRatioCVSThreshold); // "miner supplied exchange rate is not evenly discounted");\n', '    }\n', '    /// @dev Calculate each order&#39;s fee or LRC reward.\n', '    function calculateRingFees(\n', '        TokenTransferDelegate delegate,\n', '        uint            ringSize,\n', '        OrderState[]    orders,\n', '        address         feeRecipient,\n', '        address         _lrcTokenAddress\n', '        )\n', '        private\n', '        view\n', '    {\n', '        bool checkedMinerLrcSpendable = false;\n', '        uint minerLrcSpendable = 0;\n', '        uint8 _marginSplitPercentageBase = MARGIN_SPLIT_PERCENTAGE_BASE;\n', '        uint nextFillAmountS;\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            OrderState memory state = orders[i];\n', '            uint lrcReceiable = 0;\n', '            if (state.lrcFee == 0) {\n', '                // When an order&#39;s LRC fee is 0 or smaller than the specified fee,\n', '                // we help miner automatically select margin-split.\n', '                state.marginSplitAsFee = true;\n', '                state.order.marginSplitPercentage = _marginSplitPercentageBase;\n', '            } else {\n', '                uint lrcSpendable = getSpendable(\n', '                    delegate,\n', '                    _lrcTokenAddress,\n', '                    state.order.owner\n', '                );\n', '                // If the order is selling LRC, we need to calculate how much LRC\n', '                // is left that can be used as fee.\n', '                if (state.order.tokenS == _lrcTokenAddress) {\n', '                    lrcSpendable -= state.fillAmountS;\n', '                }\n', '                // If the order is buyign LRC, it will has more to pay as fee.\n', '                if (state.order.tokenB == _lrcTokenAddress) {\n', '                    nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;\n', '                    lrcReceiable = nextFillAmountS;\n', '                }\n', '                uint lrcTotal = lrcSpendable + lrcReceiable;\n', '                // If order doesn&#39;t have enough LRC, set margin split to 100%.\n', '                if (lrcTotal < state.lrcFee) {\n', '                    state.lrcFee = lrcTotal;\n', '                    state.order.marginSplitPercentage = _marginSplitPercentageBase;\n', '                }\n', '                if (state.lrcFee == 0) {\n', '                    state.marginSplitAsFee = true;\n', '                }\n', '            }\n', '            if (!state.marginSplitAsFee) {\n', '                if (lrcReceiable > 0) {\n', '                    if (lrcReceiable >= state.lrcFee) {\n', '                        state.splitB = state.lrcFee;\n', '                        state.lrcFee = 0;\n', '                    } else {\n', '                        state.splitB = lrcReceiable;\n', '                        state.lrcFee -= lrcReceiable;\n', '                    }\n', '                }\n', '            } else {\n', '                // Only check the available miner balance when absolutely needed\n', '                if (!checkedMinerLrcSpendable && minerLrcSpendable < state.lrcFee) {\n', '                    checkedMinerLrcSpendable = true;\n', '                    minerLrcSpendable = getSpendable(delegate, _lrcTokenAddress, feeRecipient);\n', '                }\n', '                // Only calculate split when miner has enough LRC;\n', '                // otherwise all splits are 0.\n', '                if (minerLrcSpendable >= state.lrcFee) {\n', '                    nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;\n', '                    uint split;\n', '                    if (state.order.buyNoMoreThanAmountB) {\n', '                        split = (nextFillAmountS.mul(\n', '                            state.order.amountS\n', '                        ) / state.order.amountB).sub(\n', '                            state.fillAmountS\n', '                        );\n', '                    } else {\n', '                        split = nextFillAmountS.sub(\n', '                            state.fillAmountS.mul(\n', '                                state.order.amountB\n', '                            ) / state.order.amountS\n', '                        );\n', '                    }\n', '                    if (state.order.marginSplitPercentage != _marginSplitPercentageBase) {\n', '                        split = split.mul(\n', '                            state.order.marginSplitPercentage\n', '                        ) / _marginSplitPercentageBase;\n', '                    }\n', '                    if (state.order.buyNoMoreThanAmountB) {\n', '                        state.splitS = split;\n', '                    } else {\n', '                        state.splitB = split;\n', '                    }\n', '                    // This implicits order with smaller index in the ring will\n', '                    // be paid LRC reward first, so the orders in the ring does\n', '                    // mater.\n', '                    if (split > 0) {\n', '                        minerLrcSpendable -= state.lrcFee;\n', '                        state.lrcReward = state.lrcFee;\n', '                    }\n', '                }\n', '                state.lrcFee = 0;\n', '            }\n', '        }\n', '    }\n', '    /// @dev Calculate each order&#39;s fill amount.\n', '    function calculateRingFillAmount(\n', '        uint          ringSize,\n', '        OrderState[]  orders\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        uint smallestIdx = 0;\n', '        uint i;\n', '        uint j;\n', '        for (i = 0; i < ringSize; i++) {\n', '            j = (i + 1) % ringSize;\n', '            smallestIdx = calculateOrderFillAmount(\n', '                orders[i],\n', '                orders[j],\n', '                i,\n', '                j,\n', '                smallestIdx\n', '            );\n', '        }\n', '        for (i = 0; i < smallestIdx; i++) {\n', '            calculateOrderFillAmount(\n', '                orders[i],\n', '                orders[(i + 1) % ringSize],\n', '                0,               // Not needed\n', '                0,               // Not needed\n', '                0                // Not needed\n', '            );\n', '        }\n', '    }\n', '    /// @return The smallest order&#39;s index.\n', '    function calculateOrderFillAmount(\n', '        OrderState        state,\n', '        OrderState        next,\n', '        uint              i,\n', '        uint              j,\n', '        uint              smallestIdx\n', '        )\n', '        private\n', '        pure\n', '        returns (uint newSmallestIdx)\n', '    {\n', '        // Default to the same smallest index\n', '        newSmallestIdx = smallestIdx;\n', '        uint fillAmountB = state.fillAmountS.mul(\n', '            state.rate.amountB\n', '        ) / state.rate.amountS;\n', '        if (state.order.buyNoMoreThanAmountB) {\n', '            if (fillAmountB > state.order.amountB) {\n', '                fillAmountB = state.order.amountB;\n', '                state.fillAmountS = fillAmountB.mul(\n', '                    state.rate.amountS\n', '                ) / state.rate.amountB;\n', '                newSmallestIdx = i;\n', '            }\n', '            state.lrcFee = state.order.lrcFee.mul(\n', '                fillAmountB\n', '            ) / state.order.amountB;\n', '        } else {\n', '            state.lrcFee = state.order.lrcFee.mul(\n', '                state.fillAmountS\n', '            ) / state.order.amountS;\n', '        }\n', '        if (fillAmountB <= next.fillAmountS) {\n', '            next.fillAmountS = fillAmountB;\n', '        } else {\n', '            newSmallestIdx = j;\n', '        }\n', '    }\n', '    /// @dev Scale down all orders based on historical fill or cancellation\n', '    ///      stats but key the order&#39;s original exchange rate.\n', '    function scaleRingBasedOnHistoricalRecords(\n', '        TokenTransferDelegate delegate,\n', '        uint ringSize,\n', '        OrderState[] orders\n', '        )\n', '        private\n', '        view\n', '    {\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            OrderState memory state = orders[i];\n', '            Order memory order = state.order;\n', '            uint amount;\n', '            if (order.buyNoMoreThanAmountB) {\n', '                amount = order.amountB.tolerantSub(\n', '                    cancelledOrFilled[state.orderHash]\n', '                );\n', '                order.amountS = amount.mul(order.amountS) / order.amountB;\n', '                order.lrcFee = amount.mul(order.lrcFee) / order.amountB;\n', '                order.amountB = amount;\n', '            } else {\n', '                amount = order.amountS.tolerantSub(\n', '                    cancelledOrFilled[state.orderHash]\n', '                );\n', '                order.amountB = amount.mul(order.amountB) / order.amountS;\n', '                order.lrcFee = amount.mul(order.lrcFee) / order.amountS;\n', '                order.amountS = amount;\n', '            }\n', '            require(order.amountS > 0); // "amountS is zero");\n', '            require(order.amountB > 0); // "amountB is zero");\n', '            uint availableAmountS = getSpendable(delegate, order.tokenS, order.owner);\n', '            require(availableAmountS > 0); // "order spendable amountS is zero");\n', '            state.fillAmountS = (\n', '                order.amountS < availableAmountS ?\n', '                order.amountS : availableAmountS\n', '            );\n', '        }\n', '    }\n', '    /// @return Amount of ERC20 token that can be spent by this contract.\n', '    function getSpendable(\n', '        TokenTransferDelegate delegate,\n', '        address tokenAddress,\n', '        address tokenOwner\n', '        )\n', '        private\n', '        view\n', '        returns (uint)\n', '    {\n', '        ERC20 token = ERC20(tokenAddress);\n', '        uint allowance = token.allowance(\n', '            tokenOwner,\n', '            address(delegate)\n', '        );\n', '        uint balance = token.balanceOf(tokenOwner);\n', '        return (allowance < balance ? allowance : balance);\n', '    }\n', '    /// @dev verify input data&#39;s basic integrity.\n', '    function verifyInputDataIntegrity(RingParams params)\n', '        private\n', '        pure\n', '    {\n', '        require(params.ringSize == params.addressList.length); // "ring data is inconsistent - addressList");\n', '        require(params.ringSize == params.uintArgsList.length); // "ring data is inconsistent - uintArgsList");\n', '        require(params.ringSize == params.uint8ArgsList.length); // "ring data is inconsistent - uint8ArgsList");\n', '        require(params.ringSize == params.buyNoMoreThanAmountBList.length); // "ring data is inconsistent - buyNoMoreThanAmountBList");\n', '        // Validate ring-mining related arguments.\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            require(params.uintArgsList[i][5] > 0); // "order rateAmountS is zero");\n', '        }\n', '        //Check ring size\n', '        require(params.ringSize > 1 && params.ringSize <= MAX_RING_SIZE); // "invalid ring size");\n', '    }\n', '    /// @dev        assmble order parameters into Order struct.\n', '    /// @return     A list of orders.\n', '    function assembleOrders(RingParams params)\n', '        private\n', '        view\n', '        returns (OrderState[] memory orders)\n', '    {\n', '        orders = new OrderState[](params.ringSize);\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            Order memory order = Order(\n', '                params.addressList[i][0],\n', '                params.addressList[i][1],\n', '                params.addressList[(i + 1) % params.ringSize][1],\n', '                params.addressList[i][2],\n', '                params.uintArgsList[i][2],\n', '                params.uintArgsList[i][3],\n', '                params.uintArgsList[i][0],\n', '                params.uintArgsList[i][1],\n', '                params.uintArgsList[i][4],\n', '                params.buyNoMoreThanAmountBList[i],\n', '                params.uintArgsList[i][6],\n', '                params.uint8ArgsList[i][0]\n', '            );\n', '            validateOrder(order);\n', '            bytes32 orderHash = calculateOrderHash(order);\n', '            verifySignature(\n', '                order.owner,\n', '                orderHash,\n', '                params.vList[i],\n', '                params.rList[i],\n', '                params.sList[i]\n', '            );\n', '            bool marginSplitAsFee = (params.feeSelections & (uint16(1) << i)) > 0;\n', '            orders[i] = OrderState(\n', '                order,\n', '                orderHash,\n', '                marginSplitAsFee,\n', '                Rate(params.uintArgsList[i][5], order.amountB),\n', '                0,   // fillAmountS\n', '                0,   // lrcReward\n', '                0,   // lrcFee\n', '                0,   // splitS\n', '                0    // splitB\n', '            );\n', '            params.ringHash ^= orderHash;\n', '        }\n', '        params.ringHash = keccak256(\n', '            params.ringHash,\n', '            params.minerId,\n', '            params.feeSelections\n', '        );\n', '    }\n', '    /// @dev validate order&#39;s parameters are OK.\n', '    function validateOrder(Order order)\n', '        private\n', '        view\n', '    {\n', '        require(order.owner != 0x0); // invalid order owner\n', '        require(order.tokenS != 0x0); // invalid order tokenS\n', '        require(order.tokenB != 0x0); // invalid order tokenB\n', '        require(order.amountS != 0); // invalid order amountS\n', '        require(order.amountB != 0); // invalid order amountB\n', '        require(order.marginSplitPercentage <= MARGIN_SPLIT_PERCENTAGE_BASE); // invalid order marginSplitPercentage\n', '        require(order.validSince <= block.timestamp); // order is too early to match\n', '        require(order.validUntil > block.timestamp); // order is expired\n', '        bytes20 tradingPair = bytes20(order.tokenS) ^ bytes20(order.tokenB);\n', '        require(order.validSince > tradingPairCutoffs[order.owner][tradingPair]); // order trading pair is cut off\n', '        require(order.validSince > cutoffs[order.owner]); // order is cut off\n', '    }\n', '    /// @dev Get the Keccak-256 hash of order with specified parameters.\n', '    function calculateOrderHash(Order order)\n', '        private\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            address(this),\n', '            order.owner,\n', '            order.tokenS,\n', '            order.tokenB,\n', '            order.authAddr,\n', '            order.amountS,\n', '            order.amountB,\n', '            order.validSince,\n', '            order.validUntil,\n', '            order.lrcFee,\n', '            order.buyNoMoreThanAmountB,\n', '            order.walletId,\n', '            order.marginSplitPercentage\n', '        );\n', '    }\n', '    /// @dev Verify signer&#39;s signature.\n', '    function verifySignature(\n', '        address signer,\n', '        bytes32 hash,\n', '        uint8   v,\n', '        bytes32 r,\n', '        bytes32 s\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        require(\n', '            signer == ecrecover(\n', '                keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '                v,\n', '                r,\n', '                s\n', '            )\n', '        ); // "invalid signature");\n', '    }\n', '    function getTradingPairCutoffs(address orderOwner, address token1, address token2)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        bytes20 tokenPair = bytes20(token1) ^ bytes20(token2);\n', '        return tradingPairCutoffs[orderOwner][tokenPair];\n', '    }\n', '}']
['/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', 'pragma solidity 0.4.21;\n', '/// @title Utility Functions for uint8\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>,\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'library MathUint8 {\n', '    function xorReduce(\n', '        uint8[] arr,\n', '        uint    len\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint8 res)\n', '    {\n', '        res = arr[0];\n', '        for (uint i = 1; i < len; i++) {\n', '            res ^= arr[i];\n', '        }\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library MathUint {\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function tolerantSub(uint a, uint b) internal pure returns (uint c) {\n', '        return (a >= b) ? a - b : 0;\n', '    }\n', '    /// @dev calculate the square of Coefficient of Variation (CV)\n', '    /// https://en.wikipedia.org/wiki/Coefficient_of_variation\n', '    function cvsquare(\n', '        uint[] arr,\n', '        uint scale\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        uint len = arr.length;\n', '        require(len > 1);\n', '        require(scale > 0);\n', '        uint avg = 0;\n', '        for (uint i = 0; i < len; i++) {\n', '            avg += arr[i];\n', '        }\n', '        avg = avg / len;\n', '        if (avg == 0) {\n', '            return 0;\n', '        }\n', '        uint cvs = 0;\n', '        uint s;\n', '        uint item;\n', '        for (i = 0; i < len; i++) {\n', '            item = arr[i];\n', '            s = item > avg ? item - avg : avg - item;\n', '            cvs += mul(s, s);\n', '        }\n', '        return ((mul(mul(cvs, scale), scale) / avg) / avg) / (len - 1);\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Utility Functions for byte32\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>,\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'library MathBytes32 {\n', '    function xorReduce(\n', '        bytes32[]   arr,\n', '        uint        len\n', '        )\n', '        internal\n', '        pure\n', '        returns (bytes32 res)\n', '    {\n', '        res = arr[0];\n', '        for (uint i = 1; i < len; i++) {\n', '            res ^= arr[i];\n', '        }\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Utility Functions for address\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library AddressUtil {\n', '    function isContract(address addr)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (addr == 0x0) {\n', '            return false;\n', '        } else {\n', '            uint size;\n', '            assembly { size := extcodesize(addr) }\n', '            return size > 0;\n', '        }\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract ERC20 {\n', '    function balanceOf(address who) view public returns (uint256);\n', '    function allowance(address owner, address spender) view public returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Loopring Token Exchange Protocol Contract Interface\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>\n', 'contract LoopringProtocol {\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Constants                                                            ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    uint8   public constant MARGIN_SPLIT_PERCENTAGE_BASE = 100;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Events                                                               ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Event to emit if a ring is successfully mined.\n', '    /// _amountsList is an array of:\n', '    /// [_amountS, _amountB, _lrcReward, _lrcFee, splitS, splitB].\n', '    event RingMined(\n', '        uint                _ringIndex,\n', '        bytes32     indexed _ringHash,\n', '        address             _miner,\n', '        address             _feeRecipient,\n', '        bytes32[]           _orderHashList,\n', '        uint[6][]           _amountsList\n', '    );\n', '    event OrderCancelled(\n', '        bytes32     indexed _orderHash,\n', '        uint                _amountCancelled\n', '    );\n', '    event AllOrdersCancelled(\n', '        address     indexed _address,\n', '        uint                _cutoff\n', '    );\n', '    event OrdersCancelled(\n', '        address     indexed _address,\n', '        address             _token1,\n', '        address             _token2,\n', '        uint                _cutoff\n', '    );\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Functions                                                            ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Cancel a order. cancel amount(amountS or amountB) can be specified\n', '    ///      in orderValues.\n', '    /// @param addresses          owner, tokenS, tokenB, authAddr\n', '    /// @param orderValues        amountS, amountB, validSince (second),\n', '    ///                           validUntil (second), lrcFee, walletId, and\n', '    ///                           cancelAmount.\n', '    /// @param buyNoMoreThanAmountB -\n', '    ///                           This indicates when a order should be considered\n', "    ///                           as 'completely filled'.\n", '    /// @param marginSplitPercentage -\n', '    ///                           Percentage of margin split to share with miner.\n', '    /// @param v                  Order ECDSA signature parameter v.\n', '    /// @param r                  Order ECDSA signature parameters r.\n', '    /// @param s                  Order ECDSA signature parameters s.\n', '    function cancelOrder(\n', '        address[4] addresses,\n', '        uint[7]    orderValues,\n', '        bool       buyNoMoreThanAmountB,\n', '        uint8      marginSplitPercentage,\n', '        uint8      v,\n', '        bytes32    r,\n', '        bytes32    s\n', '        ) external;\n', '    /// @dev   Set a cutoff timestamp to invalidate all orders whose timestamp\n', "    ///        is smaller than or equal to the new value of the address's cutoff\n", '    ///        timestamp, for a specific trading pair.\n', '    /// @param cutoff The cutoff timestamp, will default to `block.timestamp`\n', '    ///        if it is 0.\n', '    function cancelAllOrdersByTradingPair(\n', '        address token1,\n', '        address token2,\n', '        uint cutoff\n', '        ) external;\n', '    /// @dev   Set a cutoff timestamp to invalidate all orders whose timestamp\n', "    ///        is smaller than or equal to the new value of the address's cutoff\n", '    ///        timestamp.\n', '    /// @param cutoff The cutoff timestamp, will default to `block.timestamp`\n', '    ///        if it is 0.\n', '    function cancelAllOrders(uint cutoff) external;\n', '    /// @dev Submit a order-ring for validation and settlement.\n', "    /// @param addressList  List of each order's owner, tokenS, and authAddr.\n", "    ///                     Note that next order's `tokenS` equals this order's\n", '    ///                     `tokenB`.\n', '    /// @param uintArgsList List of uint-type arguments in this order:\n', '    ///                     amountS, amountB, validSince (second),\n', '    ///                     validUntil (second), lrcFee, rateAmountS, and walletId.\n', '    /// @param uint8ArgsList -\n', '    ///                     List of unit8-type arguments, in this order:\n', '    ///                     marginSplitPercentageList.\n', '    /// @param buyNoMoreThanAmountBList -\n', '    ///                     This indicates when a order should be considered\n', '    /// @param vList        List of v for each order. This list is 1-larger than\n', '    ///                     the previous lists, with the last element being the\n', '    ///                     v value of the ring signature.\n', '    /// @param rList        List of r for each order. This list is 1-larger than\n', '    ///                     the previous lists, with the last element being the\n', '    ///                     r value of the ring signature.\n', '    /// @param sList        List of s for each order. This list is 1-larger than\n', '    ///                     the previous lists, with the last element being the\n', '    ///                     s value of the ring signature.\n', '    /// @param minerId      The address pair that miner registered in NameRegistry.\n', '    ///                     The address pair contains a signer address and a fee\n', '    ///                     recipient address.\n', '    ///                     The signer address is used for sign this tx.\n', '    ///                     The Recipient address for fee collection. If this is\n', "    ///                     '0x0', all fees will be paid to the address who had\n", '    ///                     signed this transaction, not `msg.sender`. Noted if\n', '    ///                     LRC need to be paid back to order owner as the result\n', '    ///                     of fee selection model, LRC will also be sent from\n', '    ///                     this address.\n', '    /// @param feeSelections -\n', '    ///                     Bits to indicate fee selections. `1` represents margin\n', '    ///                     split and `0` represents LRC as fee.\n', '    function submitRing(\n', '        address[3][]    addressList,\n', '        uint[7][]       uintArgsList,\n', '        uint8[1][]      uint8ArgsList,\n', '        bool[]          buyNoMoreThanAmountBList,\n', '        uint8[]         vList,\n', '        bytes32[]       rList,\n', '        bytes32[]       sList,\n', '        uint            minerId,\n', '        uint16          feeSelections\n', '        ) public;\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Ethereum Address Register Contract\n', '/// @dev This contract maintains a name service for addresses and miner.\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>,\n', '/// @author Daniel Wang - <daniel@loopring.org>,\n', 'contract NameRegistry {\n', '    uint public nextId = 0;\n', '    mapping (uint    => Participant) public participantMap;\n', '    mapping (address => NameInfo)    public nameInfoMap;\n', '    mapping (bytes12 => address)     public ownerMap;\n', '    mapping (address => string)      public nameMap;\n', '    struct NameInfo {\n', '        bytes12  name;\n', '        uint[]   participantIds;\n', '    }\n', '    struct Participant {\n', '        address feeRecipient;\n', '        address signer;\n', '        bytes12 name;\n', '        address owner;\n', '    }\n', '    event NameRegistered (\n', '        string            name,\n', '        address   indexed owner\n', '    );\n', '    event NameUnregistered (\n', '        string             name,\n', '        address    indexed owner\n', '    );\n', '    event OwnershipTransfered (\n', '        bytes12            name,\n', '        address            oldOwner,\n', '        address            newOwner\n', '    );\n', '    event ParticipantRegistered (\n', '        bytes12           name,\n', '        address   indexed owner,\n', '        uint      indexed participantId,\n', '        address           singer,\n', '        address           feeRecipient\n', '    );\n', '    event ParticipantUnregistered (\n', '        uint    participantId,\n', '        address owner\n', '    );\n', '    function registerName(string name)\n', '        external\n', '    {\n', '        require(isNameValid(name));\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        require(ownerMap[nameBytes] == 0x0);\n', '        require(stringToBytes12(nameMap[msg.sender]) == bytes12(0x0));\n', '        nameInfoMap[msg.sender] = NameInfo(nameBytes, new uint[](0));\n', '        ownerMap[nameBytes] = msg.sender;\n', '        nameMap[msg.sender] = name;\n', '        emit NameRegistered(name, msg.sender);\n', '    }\n', '    function unregisterName(string name)\n', '        external\n', '    {\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        uint[] storage participantIds = nameInfo.participantIds;\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        require(nameInfo.name == nameBytes);\n', '        for (uint i = 0; i < participantIds.length; i++) {\n', '            delete participantMap[participantIds[i]];\n', '        }\n', '        delete nameInfoMap[msg.sender];\n', '        delete nameMap[msg.sender];\n', '        delete ownerMap[nameBytes];\n', '        emit NameUnregistered(name, msg.sender);\n', '    }\n', '    function transferOwnership(address newOwner)\n', '        external\n', '    {\n', '        require(newOwner != 0x0);\n', '        require(nameInfoMap[newOwner].name.length == 0);\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        string storage name = nameMap[msg.sender];\n', '        uint[] memory participantIds = nameInfo.participantIds;\n', '        for (uint i = 0; i < participantIds.length; i ++) {\n', '            Participant storage p = participantMap[participantIds[i]];\n', '            p.owner = newOwner;\n', '        }\n', '        delete nameInfoMap[msg.sender];\n', '        delete nameMap[msg.sender];\n', '        nameInfoMap[newOwner] = nameInfo;\n', '        nameMap[newOwner] = name;\n', '        emit OwnershipTransfered(nameInfo.name, msg.sender, newOwner);\n', '    }\n', '    /* function addParticipant(address feeRecipient) */\n', '    /*     external */\n', '    /*     returns (uint) */\n', '    /* { */\n', '    /*     return addParticipant(feeRecipient, feeRecipient); */\n', '    /* } */\n', '    function addParticipant(\n', '        address feeRecipient,\n', '        address singer\n', '        )\n', '        external\n', '        returns (uint)\n', '    {\n', '        require(feeRecipient != 0x0 && singer != 0x0);\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        bytes12 name = nameInfo.name;\n', '        require(name.length > 0);\n', '        Participant memory participant = Participant(\n', '            feeRecipient,\n', '            singer,\n', '            name,\n', '            msg.sender\n', '        );\n', '        uint participantId = ++nextId;\n', '        participantMap[participantId] = participant;\n', '        nameInfo.participantIds.push(participantId);\n', '        emit ParticipantRegistered(\n', '            name,\n', '            msg.sender,\n', '            participantId,\n', '            singer,\n', '            feeRecipient\n', '        );\n', '        return participantId;\n', '    }\n', '    function removeParticipant(uint participantId)\n', '        external\n', '    {\n', '        require(msg.sender == participantMap[participantId].owner);\n', '        NameInfo storage nameInfo = nameInfoMap[msg.sender];\n', '        uint[] storage participantIds = nameInfo.participantIds;\n', '        delete participantMap[participantId];\n', '        uint len = participantIds.length;\n', '        for (uint i = 0; i < len; i ++) {\n', '            if (participantId == participantIds[i]) {\n', '                participantIds[i] = participantIds[len - 1];\n', '                participantIds.length -= 1;\n', '            }\n', '        }\n', '        emit ParticipantUnregistered(participantId, msg.sender);\n', '    }\n', '    function getParticipantById(uint id)\n', '        external\n', '        view\n', '        returns (address feeRecipient, address signer)\n', '    {\n', '        Participant storage addressSet = participantMap[id];\n', '        feeRecipient = addressSet.feeRecipient;\n', '        signer = addressSet.signer;\n', '    }\n', '    function getFeeRecipientById(uint id)\n', '        external\n', '        view\n', '        returns (address feeRecipient)\n', '    {\n', '        Participant storage addressSet = participantMap[id];\n', '        feeRecipient = addressSet.feeRecipient;\n', '    }\n', '    function getParticipantIds(string name, uint start, uint count)\n', '        external\n', '        view\n', '        returns (uint[] idList)\n', '    {\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        address owner = ownerMap[nameBytes];\n', '        require(owner != 0x0);\n', '        NameInfo storage nameInfo = nameInfoMap[owner];\n', '        uint[] storage pIds = nameInfo.participantIds;\n', '        uint len = pIds.length;\n', '        if (start >= len) {\n', '            return;\n', '        }\n', '        uint end = start + count;\n', '        if (end > len) {\n', '            end = len;\n', '        }\n', '        if (start == end) {\n', '            return;\n', '        }\n', '        idList = new uint[](end - start);\n', '        for (uint i = start; i < end; i ++) {\n', '            idList[i - start] = pIds[i];\n', '        }\n', '    }\n', '    function getOwner(string name)\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        bytes12 nameBytes = stringToBytes12(name);\n', '        return ownerMap[nameBytes];\n', '    }\n', '    function isNameValid(string name)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        bytes memory temp = bytes(name);\n', '        return temp.length >= 6 && temp.length <= 12;\n', '    }\n', '    function stringToBytes12(string str)\n', '        internal\n', '        pure\n', '        returns (bytes12 result)\n', '    {\n', '        assembly {\n', '            result := mload(add(str, 32))\n', '        }\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      newOwner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != 0x0);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '/// @title Claimable\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable {\n', '    address public pendingOwner;\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != 0x0 && newOwner != owner);\n', '        pendingOwner = newOwner;\n', '    }\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership() onlyPendingOwner public {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = 0x0;\n', '    }\n', '}\n', '/// @title Token Register Contract\n', '/// @dev This contract maintains a list of tokens the Protocol supports.\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>,\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'contract TokenRegistry is Claimable {\n', '    using AddressUtil for address;\n', '    address tokenMintAddr;\n', '    address[] public addresses;\n', '    mapping (address => TokenInfo) addressMap;\n', '    mapping (string => address) symbolMap;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Structs                                                              ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    struct TokenInfo {\n', '        uint   pos;      // 0 mens unregistered; if > 0, pos + 1 is the\n', "                         // token's position in `addresses`.\n", '        string symbol;   // Symbol of the token\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Events                                                               ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    event TokenRegistered(address addr, string symbol);\n', '    event TokenUnregistered(address addr, string symbol);\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Public Functions                                                     ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Disable default function.\n', '    function () payable public {\n', '        revert();\n', '    }\n', '    function TokenRegistry(address _tokenMintAddr) public\n', '    {\n', '        require(_tokenMintAddr.isContract());\n', '        tokenMintAddr = _tokenMintAddr;\n', '    }\n', '    function registerToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external\n', '        onlyOwner\n', '    {\n', '        registerTokenInternal(addr, symbol);\n', '    }\n', '    function registerMintedToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external\n', '    {\n', '        require(msg.sender == tokenMintAddr);\n', '        registerTokenInternal(addr, symbol);\n', '    }\n', '    function unregisterToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(addr != 0x0);\n', '        require(symbolMap[symbol] == addr);\n', '        delete symbolMap[symbol];\n', '        uint pos = addressMap[addr].pos;\n', '        require(pos != 0);\n', '        delete addressMap[addr];\n', '        // We will replace the token we need to unregister with the last token\n', '        // Only the pos of the last token will need to be updated\n', '        address lastToken = addresses[addresses.length - 1];\n', "        // Don't do anything if the last token is the one we want to delete\n", '        if (addr != lastToken) {\n', '            // Swap with the last token and update the pos\n', '            addresses[pos - 1] = lastToken;\n', '            addressMap[lastToken].pos = pos;\n', '        }\n', '        addresses.length--;\n', '        emit TokenUnregistered(addr, symbol);\n', '    }\n', '    function areAllTokensRegistered(address[] addressList)\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        for (uint i = 0; i < addressList.length; i++) {\n', '            if (addressMap[addressList[i]].pos == 0) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    function getAddressBySymbol(string symbol)\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return symbolMap[symbol];\n', '    }\n', '    function isTokenRegisteredBySymbol(string symbol)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return symbolMap[symbol] != 0x0;\n', '    }\n', '    function isTokenRegistered(address addr)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return addressMap[addr].pos != 0;\n', '    }\n', '    function getTokens(\n', '        uint start,\n', '        uint count\n', '        )\n', '        public\n', '        view\n', '        returns (address[] addressList)\n', '    {\n', '        uint num = addresses.length;\n', '        if (start >= num) {\n', '            return;\n', '        }\n', '        uint end = start + count;\n', '        if (end > num) {\n', '            end = num;\n', '        }\n', '        if (start == num) {\n', '            return;\n', '        }\n', '        addressList = new address[](end - start);\n', '        for (uint i = start; i < end; i++) {\n', '            addressList[i - start] = addresses[i];\n', '        }\n', '    }\n', '    function registerTokenInternal(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        internal\n', '    {\n', '        require(0x0 != addr);\n', '        require(bytes(symbol).length > 0);\n', '        require(0x0 == symbolMap[symbol]);\n', '        require(0 == addressMap[addr].pos);\n', '        addresses.push(addr);\n', '        symbolMap[symbol] = addr;\n', '        addressMap[addr] = TokenInfo(addresses.length, symbol);\n', '        emit TokenRegistered(addr, symbol);\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title TokenTransferDelegate\n', '/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different\n', '/// versions of Loopring protocol to avoid ERC20 re-authorization.\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'contract TokenTransferDelegate is Claimable {\n', '    using MathUint for uint;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Variables                                                            ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    mapping(address => AddressInfo) private addressInfos;\n', '    address public latestAddress;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Structs                                                              ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    struct AddressInfo {\n', '        address previous;\n', '        uint32  index;\n', '        bool    authorized;\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Modifiers                                                            ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    modifier onlyAuthorized() {\n', '        require(addressInfos[msg.sender].authorized);\n', '        _;\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Events                                                               ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    event AddressAuthorized(address indexed addr, uint32 number);\n', '    event AddressDeauthorized(address indexed addr, uint32 number);\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Public Functions                                                     ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Disable default function.\n', '    function () payable public {\n', '        revert();\n', '    }\n', '    /// @dev Add a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function authorizeAddress(address addr)\n', '        onlyOwner\n', '        external\n', '    {\n', '        AddressInfo storage addrInfo = addressInfos[addr];\n', '        if (addrInfo.index != 0) { // existing\n', '            if (addrInfo.authorized == false) { // re-authorize\n', '                addrInfo.authorized = true;\n', '                emit AddressAuthorized(addr, addrInfo.index);\n', '            }\n', '        } else {\n', '            address prev = latestAddress;\n', '            if (prev == 0x0) {\n', '                addrInfo.index = 1;\n', '                addrInfo.authorized = true;\n', '            } else {\n', '                addrInfo.previous = prev;\n', '                addrInfo.index = addressInfos[prev].index + 1;\n', '            }\n', '            addrInfo.authorized = true;\n', '            latestAddress = addr;\n', '            emit AddressAuthorized(addr, addrInfo.index);\n', '        }\n', '    }\n', '    /// @dev Remove a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function deauthorizeAddress(address addr)\n', '        onlyOwner\n', '        external\n', '    {\n', '        uint32 index = addressInfos[addr].index;\n', '        if (index != 0) {\n', '            addressInfos[addr].authorized = false;\n', '            emit AddressDeauthorized(addr, index);\n', '        }\n', '    }\n', '    function getLatestAuthorizedAddresses(uint max)\n', '        external\n', '        view\n', '        returns (address[] addresses)\n', '    {\n', '        addresses = new address[](max);\n', '        address addr = latestAddress;\n', '        AddressInfo memory addrInfo;\n', '        uint count = 0;\n', '        while (addr != 0x0 && count < max) {\n', '            addrInfo = addressInfos[addr];\n', '            if (addrInfo.index == 0) {\n', '                break;\n', '            }\n', '            addresses[count++] = addr;\n', '            addr = addrInfo.previous;\n', '        }\n', '    }\n', '    /// @dev Invoke ERC20 transferFrom method.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    function transferToken(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value)\n', '        onlyAuthorized\n', '        external\n', '    {\n', '        if (value > 0 && from != to && to != 0x0) {\n', '            require(\n', '                ERC20(token).transferFrom(from, to, value)\n', '            );\n', '        }\n', '    }\n', '    function batchTransferToken(\n', '        address lrcTokenAddress,\n', '        address minerFeeRecipient,\n', '        uint8 walletSplitPercentage,\n', '        bytes32[] batch)\n', '        onlyAuthorized\n', '        external\n', '    {\n', '        uint len = batch.length;\n', '        require(len % 7 == 0);\n', '        require(walletSplitPercentage > 0 && walletSplitPercentage < 100);\n', '        ERC20 lrc = ERC20(lrcTokenAddress);\n', '        for (uint i = 0; i < len; i += 7) {\n', '            address owner = address(batch[i]);\n', '            address prevOwner = address(batch[(i + len - 7) % len]);\n', "            // Pay token to previous order, or to miner as previous order's\n", "            // margin split or/and this order's margin split.\n", '            ERC20 token = ERC20(address(batch[i + 1]));\n', '            // Here batch[i + 2] has been checked not to be 0.\n', '            if (owner != prevOwner) {\n', '                require(\n', '                    token.transferFrom(\n', '                        owner,\n', '                        prevOwner,\n', '                        uint(batch[i + 2])\n', '                    )\n', '                );\n', '            }\n', '            // Miner pays LRx fee to order owner\n', '            uint lrcReward = uint(batch[i + 4]);\n', '            if (lrcReward != 0 && minerFeeRecipient != owner) {\n', '                require(\n', '                    lrc.transferFrom(\n', '                        minerFeeRecipient,\n', '                        owner,\n', '                        lrcReward\n', '                    )\n', '                );\n', '            }\n', '            // Split margin-split income between miner and wallet\n', '            splitPayFee(\n', '                token,\n', '                uint(batch[i + 3]),\n', '                owner,\n', '                minerFeeRecipient,\n', '                address(batch[i + 6]),\n', '                walletSplitPercentage\n', '            );\n', '            // Split LRx fee income between miner and wallet\n', '            splitPayFee(\n', '                lrc,\n', '                uint(batch[i + 5]),\n', '                owner,\n', '                minerFeeRecipient,\n', '                address(batch[i + 6]),\n', '                walletSplitPercentage\n', '            );\n', '        }\n', '    }\n', '    function isAddressAuthorized(address addr)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return addressInfos[addr].authorized;\n', '    }\n', '    function splitPayFee(\n', '        ERC20   token,\n', '        uint    fee,\n', '        address owner,\n', '        address minerFeeRecipient,\n', '        address walletFeeRecipient,\n', '        uint    walletSplitPercentage\n', '        )\n', '        internal\n', '    {\n', '        if (fee == 0) {\n', '            return;\n', '        }\n', '        uint walletFee = (walletFeeRecipient == 0x0) ? 0 : fee.mul(walletSplitPercentage) / 100;\n', '        uint minerFee = fee - walletFee;\n', '        if (walletFee > 0 && walletFeeRecipient != owner) {\n', '            require(\n', '                token.transferFrom(\n', '                    owner,\n', '                    walletFeeRecipient,\n', '                    walletFee\n', '                )\n', '            );\n', '        }\n', '        if (minerFee > 0 && minerFeeRecipient != 0x0 && minerFeeRecipient != owner) {\n', '            require(\n', '                token.transferFrom(\n', '                    owner,\n', '                    minerFeeRecipient,\n', '                    minerFee\n', '                )\n', '            );\n', '        }\n', '    }\n', '}\n', '/// @title Loopring Token Exchange Protocol Implementation Contract\n', '/// @author Daniel Wang - <daniel@loopring.org>,\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>\n', '///\n', '/// Recognized contributing developers from the community:\n', '///     https://github.com/Brechtpd\n', '///     https://github.com/rainydio\n', '///     https://github.com/BenjaminPrice\n', '///     https://github.com/jonasshen\n', 'contract LoopringProtocolImpl is LoopringProtocol {\n', '    using AddressUtil   for address;\n', '    using MathBytes32   for bytes32[];\n', '    using MathUint      for uint;\n', '    using MathUint8     for uint8[];\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Variables                                                            ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    address public  lrcTokenAddress             = 0xEF68e7C694F40c8202821eDF525dE3782458639f;\n', '    address public  tokenRegistryAddress        = 0xaD3407deDc56A1F69389Edc191b770F0c935Ea37;\n', '    address public  delegateAddress             = 0x7b126ab811f278f288bf1d62d47334351dA20d1d;\n', '    address public  nameRegistryAddress         = 0xC897816C1A6DB4A2923b7D75d9B812e2f62cF504;\n', '    uint64  public  ringIndex                   = 0;\n', '    uint8   public  walletSplitPercentage       = 20;\n', '    // Exchange rate (rate) is the amount to sell or sold divided by the amount\n', '    // to buy or bought.\n', '    //\n', "    // Rate ratio is the ratio between executed rate and an order's original\n", '    // rate.\n', '    //\n', "    // To require all orders' rate ratios to have coefficient ofvariation (CV)\n", '    // smaller than 2.5%, for an example , rateRatioCVSThreshold should be:\n', '    //     `(0.025 * RATE_RATIO_SCALE)^2` or 62500.\n', '    uint    public constant rateRatioCVSThreshold        = 62500;\n', '\n', '    uint    public constant MAX_RING_SIZE       = 16;\n', '    uint    public constant RATE_RATIO_SCALE    = 10000;\n', '    uint64  public constant ENTERED_MASK        = 1 << 63;\n', '    // The following map is used to keep trace of order fill and cancellation\n', '    // history.\n', '    mapping (bytes32 => uint) public cancelledOrFilled;\n', "    // This map is used to keep trace of order's cancellation history.\n", '    mapping (bytes32 => uint) public cancelled;\n', '    // A map from address to its cutoff timestamp.\n', '    mapping (address => uint) public cutoffs;\n', '    // A map from address to its trading-pair cutoff timestamp.\n', '    mapping (address => mapping (bytes20 => uint)) public tradingPairCutoffs;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Structs                                                              ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    struct Rate {\n', '        uint amountS;\n', '        uint amountB;\n', '    }\n', '    /// @param tokenS       Token to sell.\n', '    /// @param tokenB       Token to buy.\n', '    /// @param amountS      Maximum amount of tokenS to sell.\n', '    /// @param amountB      Minimum amount of tokenB to buy if all amountS sold.\n', "    /// @param authAddr     An address to verify miner has access to the order's\n", '    ///                     auth private-key.\n', '    /// @param validSince   Indicating when this order should be treated as\n', '    ///                     valid for trading, in second.\n', '    /// @param validUntil   Indicating when this order should be treated as\n', '    ///                     expired, in second.\n', '    /// @param lrcFee       Max amount of LRC to pay for miner. The real amount\n', '    ///                     to pay is proportional to fill amount.\n', '    /// @param buyNoMoreThanAmountB -\n', '    ///                     If true, this order does not accept buying more\n', '    ///                     than `amountB`.\n', '    /// @param walletId     The id of the wallet that generated this order.\n', '    /// @param marginSplitPercentage -\n', '    ///                     The percentage of margin paid to miner.\n', '    /// @param v            ECDSA signature parameter v.\n', '    /// @param r            ECDSA signature parameters r.\n', '    /// @param s            ECDSA signature parameters s.\n', '    struct Order {\n', '        address owner;\n', '        address tokenS;\n', '        address tokenB;\n', '        address authAddr;\n', '        uint    validSince;\n', '        uint    validUntil;\n', '        uint    amountS;\n', '        uint    amountB;\n', '        uint    lrcFee;\n', '        bool    buyNoMoreThanAmountB;\n', '        uint    walletId;\n', '        uint8   marginSplitPercentage;\n', '    }\n', '    /// @param order        The original order\n', "    /// @param orderHash    The order's hash\n", '    /// @param feeSelection -\n', '    ///                     A miner-supplied value indicating if LRC (value = 0)\n', '    ///                     or margin split is choosen by the miner (value = 1).\n', '    ///                     We may support more fee model in the future.\n', '    /// @param rate         Exchange rate provided by miner.\n', '    /// @param fillAmountS  Amount of tokenS to sell, calculated by protocol.\n', '    /// @param lrcReward    The amount of LRC paid by miner to order owner in\n', '    ///                     exchange for margin split.\n', '    /// @param lrcFee       The amount of LR paid by order owner to miner.\n', '    /// @param splitS      TokenS paid to miner.\n', '    /// @param splitB      TokenB paid to miner.\n', '    struct OrderState {\n', '        Order   order;\n', '        bytes32 orderHash;\n', '        bool    marginSplitAsFee;\n', '        Rate    rate;\n', '        uint    fillAmountS;\n', '        uint    lrcReward;\n', '        uint    lrcFee;\n', '        uint    splitS;\n', '        uint    splitB;\n', '    }\n', '    /// @dev A struct to capture parameters passed to submitRing method and\n', '    ///      various of other variables used across the submitRing core logics.\n', '    struct RingParams {\n', '        address[3][]  addressList;\n', '        uint[7][]     uintArgsList;\n', '        uint8[1][]    uint8ArgsList;\n', '        bool[]        buyNoMoreThanAmountBList;\n', '        uint8[]       vList;\n', '        bytes32[]     rList;\n', '        bytes32[]     sList;\n', '        uint          minerId;\n', '        uint          ringSize;         // computed\n', '        uint16        feeSelections;\n', '        address       ringMiner;        // queried\n', '        address       feeRecipient;     // queried\n', '        bytes32       ringHash;         // computed\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Constructor                                                          ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Public Functions                                                     ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Disable default function.\n', '    function () payable public {\n', '        revert();\n', '    }\n', '    function cancelOrder(\n', '        address[4] addresses,\n', '        uint[7]    orderValues,\n', '        bool       buyNoMoreThanAmountB,\n', '        uint8      marginSplitPercentage,\n', '        uint8      v,\n', '        bytes32    r,\n', '        bytes32    s\n', '        )\n', '        external\n', '    {\n', '        uint cancelAmount = orderValues[6];\n', '        require(cancelAmount > 0); // "amount to cancel is zero");\n', '        Order memory order = Order(\n', '            addresses[0],\n', '            addresses[1],\n', '            addresses[2],\n', '            addresses[3],\n', '            orderValues[2],\n', '            orderValues[3],\n', '            orderValues[0],\n', '            orderValues[1],\n', '            orderValues[4],\n', '            buyNoMoreThanAmountB,\n', '            orderValues[5],\n', '            marginSplitPercentage\n', '        );\n', '        require(msg.sender == order.owner); // "cancelOrder not submitted by order owner");\n', '        bytes32 orderHash = calculateOrderHash(order);\n', '        verifySignature(\n', '            order.owner,\n', '            orderHash,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '        cancelled[orderHash] = cancelled[orderHash].add(cancelAmount);\n', '        cancelledOrFilled[orderHash] = cancelledOrFilled[orderHash].add(cancelAmount);\n', '        emit OrderCancelled(orderHash, cancelAmount);\n', '    }\n', '    function cancelAllOrdersByTradingPair(\n', '        address token1,\n', '        address token2,\n', '        uint    cutoff\n', '        )\n', '        external\n', '    {\n', '        uint t = (cutoff == 0 || cutoff >= block.timestamp) ? block.timestamp : cutoff;\n', '        bytes20 tokenPair = bytes20(token1) ^ bytes20(token2);\n', '        require(tradingPairCutoffs[msg.sender][tokenPair] < t); // "attempted to set cutoff to a smaller value"\n', '        tradingPairCutoffs[msg.sender][tokenPair] = t;\n', '        emit OrdersCancelled(\n', '            msg.sender,\n', '            token1,\n', '            token2,\n', '            t\n', '        );\n', '    }\n', '    function cancelAllOrders(uint cutoff)\n', '        external\n', '    {\n', '        uint t = (cutoff == 0 || cutoff >= block.timestamp) ? block.timestamp : cutoff;\n', '        require(cutoffs[msg.sender] < t); // "attempted to set cutoff to a smaller value"\n', '        cutoffs[msg.sender] = t;\n', '        emit AllOrdersCancelled(msg.sender, t);\n', '    }\n', '    function submitRing(\n', '        address[3][]  addressList,\n', '        uint[7][]     uintArgsList,\n', '        uint8[1][]    uint8ArgsList,\n', '        bool[]        buyNoMoreThanAmountBList,\n', '        uint8[]       vList,\n', '        bytes32[]     rList,\n', '        bytes32[]     sList,\n', '        uint          minerId,\n', '        uint16        feeSelections\n', '        )\n', '        public\n', '    {\n', "        // Check if the highest bit of ringIndex is '1'.\n", '        require(ringIndex & ENTERED_MASK != ENTERED_MASK); // "attempted to re-ent submitRing function");\n', "        // Set the highest bit of ringIndex to '1'.\n", '        ringIndex |= ENTERED_MASK;\n', '        RingParams memory params = RingParams(\n', '            addressList,\n', '            uintArgsList,\n', '            uint8ArgsList,\n', '            buyNoMoreThanAmountBList,\n', '            vList,\n', '            rList,\n', '            sList,\n', '            minerId,\n', '            addressList.length,\n', '            feeSelections,\n', '            0x0,        // ringMiner\n', '            0x0,        // feeRecipient\n', '            0x0         // ringHash\n', '        );\n', '        verifyInputDataIntegrity(params);\n', '        updateFeeRecipient(params);\n', '        // Assemble input data into structs so we can pass them to other functions.\n', '        // This method also calculates ringHash, therefore it must be called before\n', '        // calling `verifyRingSignatures`.\n', '        OrderState[] memory orders = assembleOrders(params);\n', '        verifyRingSignatures(params);\n', '        verifyTokensRegistered(params);\n', '        handleRing(params, orders);\n', '        ringIndex = (ringIndex ^ ENTERED_MASK) + 1;\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Internal & Private Functions                                         ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Validate a ring.\n', '    function verifyRingHasNoSubRing(\n', '        uint          ringSize,\n', '        OrderState[]  orders\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        // Check the ring has no sub-ring.\n', '        for (uint i = 0; i < ringSize - 1; i++) {\n', '            address tokenS = orders[i].order.tokenS;\n', '            for (uint j = i + 1; j < ringSize; j++) {\n', '                require(tokenS != orders[j].order.tokenS); // "found sub-ring");\n', '            }\n', '        }\n', '    }\n', "    /// @dev Verify the ringHash has been signed with each order's auth private\n", "    ///      keys as well as the miner's private key.\n", '    function verifyRingSignatures(RingParams params)\n', '        private\n', '        pure\n', '    {\n', '        uint j;\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            j = i + params.ringSize;\n', '            verifySignature(\n', '                params.addressList[i][2],  // authAddr\n', '                params.ringHash,\n', '                params.vList[j],\n', '                params.rList[j],\n', '                params.sList[j]\n', '            );\n', '        }\n', '        if (params.ringMiner != 0x0) {\n', '            j++;\n', '            verifySignature(\n', '                params.ringMiner,\n', '                params.ringHash,\n', '                params.vList[j],\n', '                params.rList[j],\n', '                params.sList[j]\n', '            );\n', '        }\n', '    }\n', '    function verifyTokensRegistered(RingParams params)\n', '        private\n', '        view\n', '    {\n', '        // Extract the token addresses\n', '        address[] memory tokens = new address[](params.ringSize);\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            tokens[i] = params.addressList[i][1];\n', '        }\n', '        // Test all token addresses at once\n', '        require(\n', '            TokenRegistry(tokenRegistryAddress).areAllTokensRegistered(tokens)\n', '        ); // "token not registered");\n', '    }\n', '    function updateFeeRecipient(RingParams params)\n', '        private\n', '        view\n', '    {\n', '        if (params.minerId == 0) {\n', '            params.feeRecipient = msg.sender;\n', '        } else {\n', '            (params.feeRecipient, params.ringMiner) = NameRegistry(\n', '                nameRegistryAddress\n', '            ).getParticipantById(\n', '                params.minerId\n', '            );\n', '            if (params.feeRecipient == 0x0) {\n', '                params.feeRecipient = msg.sender;\n', '            }\n', '        }\n', '        uint sigSize = params.ringSize * 2;\n', '        if (params.ringMiner != 0x0) {\n', '            sigSize += 1;\n', '        }\n', '        require(sigSize == params.vList.length); // "ring data is inconsistent - vList");\n', '        require(sigSize == params.rList.length); // "ring data is inconsistent - rList");\n', '        require(sigSize == params.sList.length); // "ring data is inconsistent - sList");\n', '    }\n', '    function handleRing(\n', '        RingParams    params,\n', '        OrderState[]  orders\n', '        )\n', '        private\n', '    {\n', '        uint64 _ringIndex = ringIndex ^ ENTERED_MASK;\n', '        address _lrcTokenAddress = lrcTokenAddress;\n', '        TokenTransferDelegate delegate = TokenTransferDelegate(delegateAddress);\n', '        // Do the hard work.\n', '        verifyRingHasNoSubRing(params.ringSize, orders);\n', '        // Exchange rates calculation are performed by ring-miners as solidity\n', '        // cannot get power-of-1/n operation, therefore we have to verify\n', '        // these rates are correct.\n', '        verifyMinerSuppliedFillRates(params.ringSize, orders);\n', '        // Scale down each order independently by substracting amount-filled and\n', "        // amount-cancelled. Order owner's current balance and allowance are\n", '        // not taken into consideration in these operations.\n', '        scaleRingBasedOnHistoricalRecords(delegate, params.ringSize, orders);\n', '        // Based on the already verified exchange rate provided by ring-miners,\n', '        // we can furthur scale down orders based on token balance and allowance,\n', "        // then find the smallest order of the ring, then calculate each order's\n", '        // `fillAmountS`.\n', '        calculateRingFillAmount(params.ringSize, orders);\n', "        // Calculate each order's `lrcFee` and `lrcRewrard` and splict how much\n", '        // of `fillAmountS` shall be paid to matching order or miner as margin\n', '        // split.\n', '        calculateRingFees(\n', '            delegate,\n', '            params.ringSize,\n', '            orders,\n', '            params.feeRecipient,\n', '            _lrcTokenAddress\n', '        );\n', '        /// Make transfers.\n', '        bytes32[] memory orderHashList;\n', '        uint[6][] memory amountsList;\n', '        (orderHashList, amountsList) = settleRing(\n', '            delegate,\n', '            params.ringSize,\n', '            orders,\n', '            params.feeRecipient,\n', '            _lrcTokenAddress\n', '        );\n', '        emit RingMined(\n', '            _ringIndex,\n', '            params.ringHash,\n', '            params.ringMiner,\n', '            params.feeRecipient,\n', '            orderHashList,\n', '            amountsList\n', '        );\n', '    }\n', '    function settleRing(\n', '        TokenTransferDelegate delegate,\n', '        uint          ringSize,\n', '        OrderState[]  orders,\n', '        address       feeRecipient,\n', '        address       _lrcTokenAddress\n', '        )\n', '        private\n', '        returns (\n', '        bytes32[] memory orderHashList,\n', '        uint[6][] memory amountsList)\n', '    {\n', '        bytes32[] memory batch = new bytes32[](ringSize * 7); // ringSize * (owner + tokenS + 4 amounts + walletAddrress)\n', '        orderHashList = new bytes32[](ringSize);\n', '        amountsList = new uint[6][](ringSize);\n', '        uint p = 0;\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            OrderState memory state = orders[i];\n', '            Order memory order = state.order;\n', '            uint prevSplitB = orders[(i + ringSize - 1) % ringSize].splitB;\n', '            uint nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;\n', '            // Store owner and tokenS of every order\n', '            batch[p] = bytes32(order.owner);\n', '            batch[p + 1] = bytes32(order.tokenS);\n', '            // Store all amounts\n', '            batch[p + 2] = bytes32(state.fillAmountS - prevSplitB);\n', '            batch[p + 3] = bytes32(prevSplitB + state.splitS);\n', '            batch[p + 4] = bytes32(state.lrcReward);\n', '            batch[p + 5] = bytes32(state.lrcFee);\n', '            if (order.walletId != 0) {\n', '                batch[p + 6] = bytes32(NameRegistry(nameRegistryAddress).getFeeRecipientById(order.walletId));\n', '            } else {\n', '                batch[p + 6] = bytes32(0x0);\n', '            }\n', '            p += 7;\n', '            // Update fill records\n', '            if (order.buyNoMoreThanAmountB) {\n', '                cancelledOrFilled[state.orderHash] += nextFillAmountS;\n', '            } else {\n', '                cancelledOrFilled[state.orderHash] += state.fillAmountS;\n', '            }\n', '            orderHashList[i] = state.orderHash;\n', '            amountsList[i][0] = state.fillAmountS + state.splitS;\n', '            amountsList[i][1] = nextFillAmountS - state.splitB;\n', '            amountsList[i][2] = state.lrcReward;\n', '            amountsList[i][3] = state.lrcFee;\n', '            amountsList[i][4] = state.splitS;\n', '            amountsList[i][5] = state.splitB;\n', '        }\n', '        // Do all transactions\n', '        delegate.batchTransferToken(\n', '            _lrcTokenAddress,\n', '            feeRecipient,\n', '            walletSplitPercentage,\n', '            batch\n', '        );\n', '    }\n', '    /// @dev Verify miner has calculte the rates correctly.\n', '    function verifyMinerSuppliedFillRates(\n', '        uint          ringSize,\n', '        OrderState[]  orders\n', '        )\n', '        private\n', '        view\n', '    {\n', '        uint[] memory rateRatios = new uint[](ringSize);\n', '        uint _rateRatioScale = RATE_RATIO_SCALE;\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            uint s1b0 = orders[i].rate.amountS.mul(orders[i].order.amountB);\n', '            uint s0b1 = orders[i].order.amountS.mul(orders[i].rate.amountB);\n', '            require(s1b0 <= s0b1); // "miner supplied exchange rate provides invalid discount");\n', '            rateRatios[i] = _rateRatioScale.mul(s1b0) / s0b1;\n', '        }\n', '        uint cvs = MathUint.cvsquare(rateRatios, _rateRatioScale);\n', '        require(cvs <= rateRatioCVSThreshold); // "miner supplied exchange rate is not evenly discounted");\n', '    }\n', "    /// @dev Calculate each order's fee or LRC reward.\n", '    function calculateRingFees(\n', '        TokenTransferDelegate delegate,\n', '        uint            ringSize,\n', '        OrderState[]    orders,\n', '        address         feeRecipient,\n', '        address         _lrcTokenAddress\n', '        )\n', '        private\n', '        view\n', '    {\n', '        bool checkedMinerLrcSpendable = false;\n', '        uint minerLrcSpendable = 0;\n', '        uint8 _marginSplitPercentageBase = MARGIN_SPLIT_PERCENTAGE_BASE;\n', '        uint nextFillAmountS;\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            OrderState memory state = orders[i];\n', '            uint lrcReceiable = 0;\n', '            if (state.lrcFee == 0) {\n', "                // When an order's LRC fee is 0 or smaller than the specified fee,\n", '                // we help miner automatically select margin-split.\n', '                state.marginSplitAsFee = true;\n', '                state.order.marginSplitPercentage = _marginSplitPercentageBase;\n', '            } else {\n', '                uint lrcSpendable = getSpendable(\n', '                    delegate,\n', '                    _lrcTokenAddress,\n', '                    state.order.owner\n', '                );\n', '                // If the order is selling LRC, we need to calculate how much LRC\n', '                // is left that can be used as fee.\n', '                if (state.order.tokenS == _lrcTokenAddress) {\n', '                    lrcSpendable -= state.fillAmountS;\n', '                }\n', '                // If the order is buyign LRC, it will has more to pay as fee.\n', '                if (state.order.tokenB == _lrcTokenAddress) {\n', '                    nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;\n', '                    lrcReceiable = nextFillAmountS;\n', '                }\n', '                uint lrcTotal = lrcSpendable + lrcReceiable;\n', "                // If order doesn't have enough LRC, set margin split to 100%.\n", '                if (lrcTotal < state.lrcFee) {\n', '                    state.lrcFee = lrcTotal;\n', '                    state.order.marginSplitPercentage = _marginSplitPercentageBase;\n', '                }\n', '                if (state.lrcFee == 0) {\n', '                    state.marginSplitAsFee = true;\n', '                }\n', '            }\n', '            if (!state.marginSplitAsFee) {\n', '                if (lrcReceiable > 0) {\n', '                    if (lrcReceiable >= state.lrcFee) {\n', '                        state.splitB = state.lrcFee;\n', '                        state.lrcFee = 0;\n', '                    } else {\n', '                        state.splitB = lrcReceiable;\n', '                        state.lrcFee -= lrcReceiable;\n', '                    }\n', '                }\n', '            } else {\n', '                // Only check the available miner balance when absolutely needed\n', '                if (!checkedMinerLrcSpendable && minerLrcSpendable < state.lrcFee) {\n', '                    checkedMinerLrcSpendable = true;\n', '                    minerLrcSpendable = getSpendable(delegate, _lrcTokenAddress, feeRecipient);\n', '                }\n', '                // Only calculate split when miner has enough LRC;\n', '                // otherwise all splits are 0.\n', '                if (minerLrcSpendable >= state.lrcFee) {\n', '                    nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;\n', '                    uint split;\n', '                    if (state.order.buyNoMoreThanAmountB) {\n', '                        split = (nextFillAmountS.mul(\n', '                            state.order.amountS\n', '                        ) / state.order.amountB).sub(\n', '                            state.fillAmountS\n', '                        );\n', '                    } else {\n', '                        split = nextFillAmountS.sub(\n', '                            state.fillAmountS.mul(\n', '                                state.order.amountB\n', '                            ) / state.order.amountS\n', '                        );\n', '                    }\n', '                    if (state.order.marginSplitPercentage != _marginSplitPercentageBase) {\n', '                        split = split.mul(\n', '                            state.order.marginSplitPercentage\n', '                        ) / _marginSplitPercentageBase;\n', '                    }\n', '                    if (state.order.buyNoMoreThanAmountB) {\n', '                        state.splitS = split;\n', '                    } else {\n', '                        state.splitB = split;\n', '                    }\n', '                    // This implicits order with smaller index in the ring will\n', '                    // be paid LRC reward first, so the orders in the ring does\n', '                    // mater.\n', '                    if (split > 0) {\n', '                        minerLrcSpendable -= state.lrcFee;\n', '                        state.lrcReward = state.lrcFee;\n', '                    }\n', '                }\n', '                state.lrcFee = 0;\n', '            }\n', '        }\n', '    }\n', "    /// @dev Calculate each order's fill amount.\n", '    function calculateRingFillAmount(\n', '        uint          ringSize,\n', '        OrderState[]  orders\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        uint smallestIdx = 0;\n', '        uint i;\n', '        uint j;\n', '        for (i = 0; i < ringSize; i++) {\n', '            j = (i + 1) % ringSize;\n', '            smallestIdx = calculateOrderFillAmount(\n', '                orders[i],\n', '                orders[j],\n', '                i,\n', '                j,\n', '                smallestIdx\n', '            );\n', '        }\n', '        for (i = 0; i < smallestIdx; i++) {\n', '            calculateOrderFillAmount(\n', '                orders[i],\n', '                orders[(i + 1) % ringSize],\n', '                0,               // Not needed\n', '                0,               // Not needed\n', '                0                // Not needed\n', '            );\n', '        }\n', '    }\n', "    /// @return The smallest order's index.\n", '    function calculateOrderFillAmount(\n', '        OrderState        state,\n', '        OrderState        next,\n', '        uint              i,\n', '        uint              j,\n', '        uint              smallestIdx\n', '        )\n', '        private\n', '        pure\n', '        returns (uint newSmallestIdx)\n', '    {\n', '        // Default to the same smallest index\n', '        newSmallestIdx = smallestIdx;\n', '        uint fillAmountB = state.fillAmountS.mul(\n', '            state.rate.amountB\n', '        ) / state.rate.amountS;\n', '        if (state.order.buyNoMoreThanAmountB) {\n', '            if (fillAmountB > state.order.amountB) {\n', '                fillAmountB = state.order.amountB;\n', '                state.fillAmountS = fillAmountB.mul(\n', '                    state.rate.amountS\n', '                ) / state.rate.amountB;\n', '                newSmallestIdx = i;\n', '            }\n', '            state.lrcFee = state.order.lrcFee.mul(\n', '                fillAmountB\n', '            ) / state.order.amountB;\n', '        } else {\n', '            state.lrcFee = state.order.lrcFee.mul(\n', '                state.fillAmountS\n', '            ) / state.order.amountS;\n', '        }\n', '        if (fillAmountB <= next.fillAmountS) {\n', '            next.fillAmountS = fillAmountB;\n', '        } else {\n', '            newSmallestIdx = j;\n', '        }\n', '    }\n', '    /// @dev Scale down all orders based on historical fill or cancellation\n', "    ///      stats but key the order's original exchange rate.\n", '    function scaleRingBasedOnHistoricalRecords(\n', '        TokenTransferDelegate delegate,\n', '        uint ringSize,\n', '        OrderState[] orders\n', '        )\n', '        private\n', '        view\n', '    {\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            OrderState memory state = orders[i];\n', '            Order memory order = state.order;\n', '            uint amount;\n', '            if (order.buyNoMoreThanAmountB) {\n', '                amount = order.amountB.tolerantSub(\n', '                    cancelledOrFilled[state.orderHash]\n', '                );\n', '                order.amountS = amount.mul(order.amountS) / order.amountB;\n', '                order.lrcFee = amount.mul(order.lrcFee) / order.amountB;\n', '                order.amountB = amount;\n', '            } else {\n', '                amount = order.amountS.tolerantSub(\n', '                    cancelledOrFilled[state.orderHash]\n', '                );\n', '                order.amountB = amount.mul(order.amountB) / order.amountS;\n', '                order.lrcFee = amount.mul(order.lrcFee) / order.amountS;\n', '                order.amountS = amount;\n', '            }\n', '            require(order.amountS > 0); // "amountS is zero");\n', '            require(order.amountB > 0); // "amountB is zero");\n', '            uint availableAmountS = getSpendable(delegate, order.tokenS, order.owner);\n', '            require(availableAmountS > 0); // "order spendable amountS is zero");\n', '            state.fillAmountS = (\n', '                order.amountS < availableAmountS ?\n', '                order.amountS : availableAmountS\n', '            );\n', '        }\n', '    }\n', '    /// @return Amount of ERC20 token that can be spent by this contract.\n', '    function getSpendable(\n', '        TokenTransferDelegate delegate,\n', '        address tokenAddress,\n', '        address tokenOwner\n', '        )\n', '        private\n', '        view\n', '        returns (uint)\n', '    {\n', '        ERC20 token = ERC20(tokenAddress);\n', '        uint allowance = token.allowance(\n', '            tokenOwner,\n', '            address(delegate)\n', '        );\n', '        uint balance = token.balanceOf(tokenOwner);\n', '        return (allowance < balance ? allowance : balance);\n', '    }\n', "    /// @dev verify input data's basic integrity.\n", '    function verifyInputDataIntegrity(RingParams params)\n', '        private\n', '        pure\n', '    {\n', '        require(params.ringSize == params.addressList.length); // "ring data is inconsistent - addressList");\n', '        require(params.ringSize == params.uintArgsList.length); // "ring data is inconsistent - uintArgsList");\n', '        require(params.ringSize == params.uint8ArgsList.length); // "ring data is inconsistent - uint8ArgsList");\n', '        require(params.ringSize == params.buyNoMoreThanAmountBList.length); // "ring data is inconsistent - buyNoMoreThanAmountBList");\n', '        // Validate ring-mining related arguments.\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            require(params.uintArgsList[i][5] > 0); // "order rateAmountS is zero");\n', '        }\n', '        //Check ring size\n', '        require(params.ringSize > 1 && params.ringSize <= MAX_RING_SIZE); // "invalid ring size");\n', '    }\n', '    /// @dev        assmble order parameters into Order struct.\n', '    /// @return     A list of orders.\n', '    function assembleOrders(RingParams params)\n', '        private\n', '        view\n', '        returns (OrderState[] memory orders)\n', '    {\n', '        orders = new OrderState[](params.ringSize);\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            Order memory order = Order(\n', '                params.addressList[i][0],\n', '                params.addressList[i][1],\n', '                params.addressList[(i + 1) % params.ringSize][1],\n', '                params.addressList[i][2],\n', '                params.uintArgsList[i][2],\n', '                params.uintArgsList[i][3],\n', '                params.uintArgsList[i][0],\n', '                params.uintArgsList[i][1],\n', '                params.uintArgsList[i][4],\n', '                params.buyNoMoreThanAmountBList[i],\n', '                params.uintArgsList[i][6],\n', '                params.uint8ArgsList[i][0]\n', '            );\n', '            validateOrder(order);\n', '            bytes32 orderHash = calculateOrderHash(order);\n', '            verifySignature(\n', '                order.owner,\n', '                orderHash,\n', '                params.vList[i],\n', '                params.rList[i],\n', '                params.sList[i]\n', '            );\n', '            bool marginSplitAsFee = (params.feeSelections & (uint16(1) << i)) > 0;\n', '            orders[i] = OrderState(\n', '                order,\n', '                orderHash,\n', '                marginSplitAsFee,\n', '                Rate(params.uintArgsList[i][5], order.amountB),\n', '                0,   // fillAmountS\n', '                0,   // lrcReward\n', '                0,   // lrcFee\n', '                0,   // splitS\n', '                0    // splitB\n', '            );\n', '            params.ringHash ^= orderHash;\n', '        }\n', '        params.ringHash = keccak256(\n', '            params.ringHash,\n', '            params.minerId,\n', '            params.feeSelections\n', '        );\n', '    }\n', "    /// @dev validate order's parameters are OK.\n", '    function validateOrder(Order order)\n', '        private\n', '        view\n', '    {\n', '        require(order.owner != 0x0); // invalid order owner\n', '        require(order.tokenS != 0x0); // invalid order tokenS\n', '        require(order.tokenB != 0x0); // invalid order tokenB\n', '        require(order.amountS != 0); // invalid order amountS\n', '        require(order.amountB != 0); // invalid order amountB\n', '        require(order.marginSplitPercentage <= MARGIN_SPLIT_PERCENTAGE_BASE); // invalid order marginSplitPercentage\n', '        require(order.validSince <= block.timestamp); // order is too early to match\n', '        require(order.validUntil > block.timestamp); // order is expired\n', '        bytes20 tradingPair = bytes20(order.tokenS) ^ bytes20(order.tokenB);\n', '        require(order.validSince > tradingPairCutoffs[order.owner][tradingPair]); // order trading pair is cut off\n', '        require(order.validSince > cutoffs[order.owner]); // order is cut off\n', '    }\n', '    /// @dev Get the Keccak-256 hash of order with specified parameters.\n', '    function calculateOrderHash(Order order)\n', '        private\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            address(this),\n', '            order.owner,\n', '            order.tokenS,\n', '            order.tokenB,\n', '            order.authAddr,\n', '            order.amountS,\n', '            order.amountB,\n', '            order.validSince,\n', '            order.validUntil,\n', '            order.lrcFee,\n', '            order.buyNoMoreThanAmountB,\n', '            order.walletId,\n', '            order.marginSplitPercentage\n', '        );\n', '    }\n', "    /// @dev Verify signer's signature.\n", '    function verifySignature(\n', '        address signer,\n', '        bytes32 hash,\n', '        uint8   v,\n', '        bytes32 r,\n', '        bytes32 s\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        require(\n', '            signer == ecrecover(\n', '                keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '                v,\n', '                r,\n', '                s\n', '            )\n', '        ); // "invalid signature");\n', '    }\n', '    function getTradingPairCutoffs(address orderOwner, address token1, address token2)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        bytes20 tokenPair = bytes20(token1) ^ bytes20(token2);\n', '        return tradingPairCutoffs[orderOwner][tokenPair];\n', '    }\n', '}']
