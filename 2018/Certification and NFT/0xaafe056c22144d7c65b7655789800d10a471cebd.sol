['/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract Whitelist is Ownable {\n', '    mapping (address => uint128) whitelist;\n', '\n', '    event Whitelisted(address who, uint128 nonce);\n', '\n', '    function Whitelist() Ownable() {\n', '      // This is here for our verification code only\n', '    }\n', '\n', '    function setWhitelisting(address who, uint128 nonce) internal {\n', '        whitelist[who] = nonce;\n', '\n', '        Whitelisted(who, nonce);\n', '    }\n', '\n', '    function whitelistUser(address who, uint128 nonce) external onlyOwner {\n', '        setWhitelisting(who, nonce);\n', '    }\n', '\n', '    function whitelistMe(uint128 nonce, uint8 v, bytes32 r, bytes32 s) external {\n', '        bytes32 hash = keccak256(msg.sender, nonce);\n', '        require(ecrecover(hash, v, r, s) == owner);\n', '        require(whitelist[msg.sender] == 0);\n', '\n', '        setWhitelisting(msg.sender, nonce);\n', '    }\n', '\n', '    function isWhitelisted(address who) external view returns(bool) {\n', '        return whitelist[who] > 0;\n', '    }\n', '}']