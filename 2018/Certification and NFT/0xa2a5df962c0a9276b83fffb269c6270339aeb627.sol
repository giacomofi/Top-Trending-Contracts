['// produced by the Solididy File Flattener (c) David Appleton 2018\n', '// contact : dave@akomba.com\n', '// released under Apache 2.0 licence\n', '// input  C:\\Projects\\BANKEX\\bankex-arbitration-service\\smart-contract\\contracts\\Board.sol\n', '// flattened :  Wednesday, 05-Dec-18 11:16:27 UTC\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract EIP20 {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name  \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value); \n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract BkxToken is EIP20 {\n', '    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n', '    function decreaseApproval (address _spender, uint _subtractedValue)public returns (bool success);\n', '}\n', '\n', 'library Utils {\n', "     /* Not secured random number generation, but it's enough for the perpose of implementaion particular case*/\n", '    function almostRnd(uint min, uint max) internal view returns(uint)\n', '    {\n', '        return uint(keccak256(block.timestamp, block.blockhash(block.number))) % (max - min) + min;\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '\n', '    function transfer(address to, uint256 value) public returns (bool success);\n', '\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool success);\n', '\n', '    function approve(address spender, uint256 value) public returns (bool success);\n', '\n', '    function allowance(address owner, address spender) public view returns (uint256 remaining);\n', '}\n', '\n', 'contract EternalStorage {\n', '\n', '    /**** Storage Types *******/\n', '\n', '    address public owner;\n', '\n', '    mapping(bytes32 => uint256)    private uIntStorage;\n', '    mapping(bytes32 => uint8)      private uInt8Storage;\n', '    mapping(bytes32 => string)     private stringStorage;\n', '    mapping(bytes32 => address)    private addressStorage;\n', '    mapping(bytes32 => bytes)      private bytesStorage;\n', '    mapping(bytes32 => bool)       private boolStorage;\n', '    mapping(bytes32 => int256)     private intStorage;\n', '    mapping(bytes32 => bytes32)    private bytes32Storage;\n', '\n', '\n', '    /*** Modifiers ************/\n', '\n', '    /// @dev Only allow access from the latest version of a contract in the Rocket Pool network after deployment\n', '    modifier onlyLatestContract() {\n', '        require(addressStorage[keccak256("contract.address", msg.sender)] != 0x0 || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /// @dev constructor\n', '    function EternalStorage() public {\n', '        owner = msg.sender;\n', '        addressStorage[keccak256("contract.address", msg.sender)] = msg.sender;\n', '    }\n', '\n', '    function setOwner() public {\n', '        require(msg.sender == owner);\n', '        addressStorage[keccak256("contract.address", owner)] = 0x0;\n', '        owner = msg.sender;\n', '        addressStorage[keccak256("contract.address", msg.sender)] = msg.sender;\n', '    }\n', '\n', '    /**** Get Methods ***********/\n', '\n', '    /// @param _key The key for the record\n', '    function getAddress(bytes32 _key) external view returns (address) {\n', '        return addressStorage[_key];\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function getUint(bytes32 _key) external view returns (uint) {\n', '        return uIntStorage[_key];\n', '    }\n', '\n', '      /// @param _key The key for the record\n', '    function getUint8(bytes32 _key) external view returns (uint8) {\n', '        return uInt8Storage[_key];\n', '    }\n', '\n', '\n', '    /// @param _key The key for the record\n', '    function getString(bytes32 _key) external view returns (string) {\n', '        return stringStorage[_key];\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function getBytes(bytes32 _key) external view returns (bytes) {\n', '        return bytesStorage[_key];\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function getBytes32(bytes32 _key) external view returns (bytes32) {\n', '        return bytes32Storage[_key];\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function getBool(bytes32 _key) external view returns (bool) {\n', '        return boolStorage[_key];\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function getInt(bytes32 _key) external view returns (int) {\n', '        return intStorage[_key];\n', '    }\n', '\n', '    /**** Set Methods ***********/\n', '\n', '    /// @param _key The key for the record\n', '    function setAddress(bytes32 _key, address _value) onlyLatestContract external {\n', '        addressStorage[_key] = _value;\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function setUint(bytes32 _key, uint _value) onlyLatestContract external {\n', '        uIntStorage[_key] = _value;\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function setUint8(bytes32 _key, uint8 _value) onlyLatestContract external {\n', '        uInt8Storage[_key] = _value;\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function setString(bytes32 _key, string _value) onlyLatestContract external {\n', '        stringStorage[_key] = _value;\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function setBytes(bytes32 _key, bytes _value) onlyLatestContract external {\n', '        bytesStorage[_key] = _value;\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestContract external {\n', '        bytes32Storage[_key] = _value;\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function setBool(bytes32 _key, bool _value) onlyLatestContract external {\n', '        boolStorage[_key] = _value;\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function setInt(bytes32 _key, int _value) onlyLatestContract external {\n', '        intStorage[_key] = _value;\n', '    }\n', '\n', '    /**** Delete Methods ***********/\n', '\n', '    /// @param _key The key for the record\n', '    function deleteAddress(bytes32 _key) onlyLatestContract external {\n', '        delete addressStorage[_key];\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function deleteUint(bytes32 _key) onlyLatestContract external {\n', '        delete uIntStorage[_key];\n', '    }\n', '\n', '     /// @param _key The key for the record\n', '    function deleteUint8(bytes32 _key) onlyLatestContract external {\n', '        delete uInt8Storage[_key];\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function deleteString(bytes32 _key) onlyLatestContract external {\n', '        delete stringStorage[_key];\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function deleteBytes(bytes32 _key) onlyLatestContract external {\n', '        delete bytesStorage[_key];\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function deleteBytes32(bytes32 _key) onlyLatestContract external {\n', '        delete bytes32Storage[_key];\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function deleteBool(bytes32 _key) onlyLatestContract external {\n', '        delete boolStorage[_key];\n', '    }\n', '\n', '    /// @param _key The key for the record\n', '    function deleteInt(bytes32 _key) onlyLatestContract external {\n', '        delete intStorage[_key];\n', '    }\n', '}\n', '\n', 'library RefereeCasesLib {\n', '\n', '    function setRefereesToCase(address storageAddress, address[] referees, bytes32 caseId) public {\n', '        for (uint i = 0; i < referees.length; i++) {\n', '            setRefereeToCase(storageAddress, referees[i], caseId, i);\n', '        }\n', '        setRefereeCountForCase(storageAddress, caseId, referees.length);\n', '    }\n', '\n', '    function isRefereeVoted(address storageAddress, address referee, bytes32 caseId) public view returns (bool) {\n', '        return EternalStorage(storageAddress).getBool(keccak256("case.referees.voted", caseId, referee));\n', '    }\n', '\n', '    function setRefereeVote(address storageAddress, bytes32 caseId, address referee, bool forApplicant) public {\n', '        uint index = getRefereeVotesFor(storageAddress, caseId, forApplicant);\n', '        EternalStorage(storageAddress).setAddress(keccak256("case.referees.vote", caseId, forApplicant, index), referee);\n', '        setRefereeVotesFor(storageAddress, caseId,  forApplicant, index + 1);\n', '    }\n', '\n', '    function getRefereeVoteForByIndex(address storageAddress, bytes32 caseId, bool forApplicant, uint index) public view returns (address) {\n', '        return EternalStorage(storageAddress).getAddress(keccak256("case.referees.vote", caseId, forApplicant, index));\n', '    }\n', '\n', '    function getRefereeVotesFor(address storageAddress, bytes32 caseId, bool forApplicant) public view returns (uint) {\n', '        return EternalStorage(storageAddress).getUint(keccak256("case.referees.votes.count", caseId, forApplicant));\n', '    }\n', '\n', '    function setRefereeVotesFor(address storageAddress, bytes32 caseId, bool forApplicant, uint votes) public {\n', '        EternalStorage(storageAddress).setUint(keccak256("case.referees.votes.count", caseId, forApplicant), votes);\n', '    }\n', '\n', '    function getRefereeCountByCase(address storageAddress, bytes32 caseId) public view returns (uint) {\n', '        return EternalStorage(storageAddress).getUint(keccak256("case.referees.count", caseId));\n', '    }\n', '\n', '    function setRefereeCountForCase(address storageAddress, bytes32 caseId, uint value) public {\n', '        EternalStorage(storageAddress).setUint(keccak256("case.referees.count", caseId), value);\n', '    }\n', '\n', '    function getRefereeByCase(address storageAddress, bytes32 caseId, uint index) public view returns (address) {\n', '        return EternalStorage(storageAddress).getAddress(keccak256("case.referees", caseId, index));\n', '    }\n', '\n', '    function isRefereeSetToCase(address storageAddress, address referee, bytes32 caseId) public view returns(bool) {\n', '        return EternalStorage(storageAddress).getBool(keccak256("case.referees", caseId, referee));\n', '    }\n', '    \n', '    function setRefereeToCase(address storageAddress, address referee, bytes32 caseId, uint index) public {\n', '        EternalStorage st = EternalStorage(storageAddress);\n', '        st.setAddress(keccak256("case.referees", caseId, index), referee);\n', '        st.setBool(keccak256("case.referees", caseId, referee), true);\n', '    }\n', '\n', '    function getRefereeVoteHash(address storageAddress, bytes32 caseId, address referee) public view returns (bytes32) {\n', '        return EternalStorage(storageAddress).getBytes32(keccak256("case.referees.vote.hash", caseId, referee));\n', '    }\n', '\n', '    function setRefereeVoteHash(address storageAddress, bytes32 caseId, address referee, bytes32 voteHash) public {\n', '        uint caseCount = getRefereeVoteHashCount(storageAddress, caseId);\n', '        EternalStorage(storageAddress).setBool(keccak256("case.referees.voted", caseId, referee), true);\n', '        EternalStorage(storageAddress).setBytes32(keccak256("case.referees.vote.hash", caseId, referee), voteHash);\n', '        EternalStorage(storageAddress).setUint(keccak256("case.referees.vote.hash.count", caseId), caseCount + 1);\n', '    }\n', '\n', '    function getRefereeVoteHashCount(address storageAddress, bytes32 caseId) public view returns(uint) {\n', '        return EternalStorage(storageAddress).getUint(keccak256("case.referees.vote.hash.count", caseId));\n', '    }\n', '\n', '    function getRefereesFor(address storageAddress, bytes32 caseId, bool forApplicant)\n', '    public view returns(address[]) {\n', '        uint n = getRefereeVotesFor(storageAddress, caseId, forApplicant);\n', '        address[] memory referees = new address[](n);\n', '        for (uint i = 0; i < n; i++) {\n', '            referees[i] = getRefereeVoteForByIndex(storageAddress, caseId, forApplicant, i);\n', '        }\n', '        return referees;\n', '    }\n', '\n', '    function getRefereesByCase(address storageAddress, bytes32 caseId)\n', '    public view returns (address[]) {\n', '        uint n = getRefereeCountByCase(storageAddress, caseId);\n', '        address[] memory referees = new address[](n);\n', '        for (uint i = 0; i < n; i++) {\n', '            referees[i] = getRefereeByCase(storageAddress, caseId, i);\n', '        }\n', '        return referees;\n', '    }\n', '\n', '}\n', '\n', 'library VoteTokenLib  {\n', '\n', '    function getVotes(address storageAddress, address account) public view returns(uint) {\n', '        return EternalStorage(storageAddress).getUint(keccak256("vote.token.balance", account));\n', '    }\n', '\n', '    function increaseVotes(address storageAddress, address account, uint256 diff) public {\n', '        setVotes(storageAddress, account, getVotes(storageAddress, account) + diff);\n', '    }\n', '\n', '    function decreaseVotes(address storageAddress, address account, uint256 diff) public {\n', '        setVotes(storageAddress, account, getVotes(storageAddress, account) - diff);\n', '    }\n', '\n', '    function setVotes(address storageAddress, address account, uint256 value) public {\n', '        EternalStorage(storageAddress).setUint(keccak256("vote.token.balance", account), value);\n', '    }\n', '\n', '}\n', '\n', 'library RefereesLib {\n', '\n', '    struct Referees {\n', '        address[] addresses;\n', '    }\n', '\n', '    function addReferee(address storageAddress, address referee) public {\n', '        uint id = getRefereeCount(storageAddress);\n', '        setReferee(storageAddress, referee, id, true);\n', '        setRefereeCount(storageAddress, id + 1);\n', '    }\n', '\n', '    function getRefereeCount(address storageAddress) public view returns(uint) {\n', '        return EternalStorage(storageAddress).getUint(keccak256("referee.count"));\n', '    }\n', '\n', '    function setRefereeCount(address storageAddress, uint value) public {\n', '        EternalStorage(storageAddress).setUint(keccak256("referee.count"), value);\n', '    }\n', '\n', '    function setReferee(address storageAddress, address referee, uint id, bool applied) public {\n', '        EternalStorage st = EternalStorage(storageAddress);\n', '        st.setBool(keccak256("referee.applied", referee), applied);\n', '        st.setAddress(keccak256("referee.address", id), referee);\n', '    }\n', '\n', '    function isRefereeApplied(address storageAddress, address referee) public view returns(bool) {\n', '        return EternalStorage(storageAddress).getBool(keccak256("referee.applied", referee));\n', '    }\n', '\n', '    function setRefereeApplied(address storageAddress, address referee, bool applied) public {\n', '        EternalStorage(storageAddress).setBool(keccak256("referee.applied", referee), applied);\n', '    }\n', '\n', '    function getRefereeAddress(address storageAddress, uint id) public view returns(address) {\n', '        return EternalStorage(storageAddress).getAddress(keccak256("referee.address", id));\n', '    }\n', '    \n', '    function getRandomRefereesToCase(address storageAddress, address applicant, address respondent, uint256 targetCount) \n', '    public view returns(address[] foundReferees)  {\n', '        uint refereesCount = getRefereeCount(storageAddress);\n', '        require(refereesCount >= targetCount);\n', '        foundReferees = new address[](targetCount);\n', '        uint id = Utils.almostRnd(0, refereesCount);\n', '        uint found = 0;\n', '        for (uint i = 0; i < refereesCount; i++) {\n', '            address referee = getRefereeAddress(storageAddress, id);\n', '            id = id + 1;\n', '            id = id % refereesCount;\n', '            uint voteBalance = VoteTokenLib.getVotes(storageAddress, referee);\n', '            if (referee != applicant && referee != respondent && voteBalance > 0) {\n', '                foundReferees[found] = referee;\n', '                found++;\n', '            }\n', '            if (found == targetCount) {\n', '                break;\n', '            }\n', '        }\n', '        require(found == targetCount);\n', '    }\n', '}\n', '\n', 'contract IBoard is Ownable {\n', '\n', '    event CaseOpened(bytes32 caseId, address applicant, address respondent, bytes32 deal, uint amount, uint refereeAward, bytes32 title, string applicantDescription, uint[] dates, uint refereeCountNeed, bool isEthRefereeAward);\n', '    event CaseCommentedByRespondent(bytes32 caseId, address respondent, string comment);\n', '    event CaseVoting(bytes32 caseId);\n', '    event CaseVoteCommitted(bytes32 caseId, address referee, bytes32 voteHash);\n', '    event CaseRevealingVotes(bytes32 caseId);\n', '    event CaseVoteRevealed(bytes32 caseId, address referee, uint8 voteOption, bytes32 salt);\n', '    event CaseClosed(bytes32 caseId, bool won);\n', '    event CaseCanceled(bytes32 caseId, uint8 causeCode);\n', '\n', '    event RefereesAssignedToCase(bytes32 caseId, address[] referees);\n', '    event RefereeVoteBalanceChanged(address referee, uint balance);\n', '    event RefereeAwarded(address referee, bytes32 caseId, uint award);\n', '\n', '    address public lib;\n', '    uint public version;\n', '    IBoardConfig public config;\n', '    BkxToken public bkxToken;\n', '    address public admin;\n', '    address public paymentHolder;\n', '    address public refereePaymentHolder;\n', '\n', '    modifier onlyOwnerOrAdmin() {\n', '        require(msg.sender == admin || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function withdrawEth(uint value) external;\n', '\n', '    function withdrawBkx(uint value) external;\n', '\n', '    function setStorageAddress(address storageAddress) external;\n', '\n', '    function setConfigAddress(address configAddress) external;\n', '\n', '    function setBkxToken(address tokenAddress) external;\n', '\n', '    function setPaymentHolder(address paymentHolder) external;\n', '\n', '    function setRefereePaymentHolder(address referePaymentHolder) external;\n', '\n', '    function setAdmin(address admin) external;\n', '\n', '    function applyForReferee() external;\n', '\n', '    function addVoteTokens(address referee) external;\n', '\n', '    function openCase(address respondent, bytes32 deal, uint amount, uint refereeAward, bytes32 title, string description) external payable;\n', '\n', '    function setRespondentDescription(bytes32 caseId, string description) external;\n', '\n', '    function startVotingCase(bytes32 caseId) external;\n', '\n', '    function createVoteHash(uint8 voteOption, bytes32 salt) public view returns(bytes32);\n', '\n', '    function commitVote(bytes32 caseId, bytes32 voteHash) external;\n', '\n', '    function verifyVote(bytes32 caseId, address referee, uint8 voteOption, bytes32 salt) public view returns(bool);\n', '\n', '    function startRevealingVotes(bytes32 caseId) external;\n', '\n', '    function revealVote(bytes32 caseId, address referee, uint8 voteOption, bytes32 salt) external;\n', '\n', '    function revealVotes(bytes32 caseId, address[] referees, uint8[] voteOptions, bytes32[] salts) external;\n', '\n', '    function verdict(bytes32 caseId) external;\n', '}\n', '\n', 'contract Withdrawable is Ownable {\n', '    function withdrawEth(uint value) external onlyOwner {\n', '        require(address(this).balance >= value);\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    function withdrawToken(address token, uint value) external onlyOwner {\n', '        require(Token(token).balanceOf(address(this)) >= value, "Not enough tokens");\n', '        require(Token(token).transfer(msg.sender, value));\n', '    }\n', '}\n', '\n', 'library CasesLib {\n', '\n', '    enum CaseStatus {OPENED, VOTING, REVEALING, CLOSED, CANCELED}\n', '    enum CaseCanceledCode { NOT_ENOUGH_VOTES, EQUAL_NUMBER_OF_VOTES }\n', '\n', '    function getCase(address storageAddress, bytes32 caseId)\n', '    public view returns ( address applicant, address respondent,\n', '        bytes32 deal, uint amount,\n', '        uint refereeAward,\n', '        bytes32 title, uint8 status, uint8 canceledCode,\n', '        bool won, bytes32 applicantDescriptionHash,\n', '        bytes32 respondentDescriptionHash, bool isEthRefereeAward)\n', '    {\n', '        EternalStorage st = EternalStorage(storageAddress);\n', '        applicant = st.getAddress(keccak256("case.applicant", caseId));\n', '        respondent = st.getAddress(keccak256("case.respondent", caseId));\n', '        deal = st.getBytes32(keccak256("case.deal", caseId));\n', '        amount = st.getUint(keccak256("case.amount", caseId));\n', '        won = st.getBool(keccak256("case.won", caseId));\n', '        status = st.getUint8(keccak256("case.status", caseId));\n', '        canceledCode = st.getUint8(keccak256("case.canceled.cause.code", caseId));\n', '        refereeAward = st.getUint(keccak256("case.referee.award", caseId));\n', '        title = st.getBytes32(keccak256("case.title", caseId));\n', '        applicantDescriptionHash = st.getBytes32(keccak256("case.applicant.description", caseId));\n', '        respondentDescriptionHash = st.getBytes32(keccak256("case.respondent.description", caseId));\n', '        isEthRefereeAward = st.getBool(keccak256("case.referee.award.eth", caseId));\n', '    }\n', '\n', '    function getCaseDates(address storageAddress, bytes32 caseId)\n', '    public view returns (uint date, uint votingDate, uint revealingDate, uint closeDate)\n', '    {\n', '        EternalStorage st = EternalStorage(storageAddress);\n', '        date = st.getUint(keccak256("case.date", caseId));\n', '        votingDate = st.getUint(keccak256("case.date.voting", caseId));\n', '        revealingDate = st.getUint(keccak256("case.date.revealing", caseId));\n', '        closeDate = st.getUint(keccak256("case.date.close", caseId));\n', '    }\n', '\n', '    function addCase(\n', '        address storageAddress, address applicant, \n', '        address respondent, bytes32 deal, \n', '        uint amount, uint refereeAward,\n', '        bytes32 title, string applicantDescription,\n', '        uint[] dates, uint refereeCountNeed, bool isEthRefereeAward\n', '    )\n', '    public returns(bytes32 caseId)\n', '    {\n', '        EternalStorage st = EternalStorage(storageAddress);\n', '        caseId = keccak256(applicant, respondent, deal, dates[0], title, amount);\n', '        st.setAddress(keccak256("case.applicant", caseId), applicant);\n', '        st.setAddress(keccak256("case.respondent", caseId), respondent);\n', '        st.setBytes32(keccak256("case.deal", caseId), deal);\n', '        st.setUint(keccak256("case.amount", caseId), amount);\n', '        st.setUint(keccak256("case.date", caseId), dates[0]);\n', '        st.setUint(keccak256("case.date.voting", caseId), dates[1]);\n', '        st.setUint(keccak256("case.date.revealing", caseId), dates[2]);\n', '        st.setUint(keccak256("case.date.close", caseId), dates[3]);\n', '        st.setUint8(keccak256("case.status", caseId), 0);//OPENED\n', '        st.setUint(keccak256("case.referee.award", caseId), refereeAward);\n', '        st.setBytes32(keccak256("case.title", caseId), title);\n', '        st.setBytes32(keccak256("case.applicant.description", caseId), keccak256(applicantDescription));\n', '        st.setBool(keccak256("case.referee.award.eth", caseId), isEthRefereeAward);\n', '        st.setUint(keccak256("case.referee.count.need", caseId), refereeCountNeed);\n', '    }\n', '\n', '    function setCaseWon(address storageAddress, bytes32 caseId, bool won) public\n', '    {\n', '        EternalStorage st = EternalStorage(storageAddress);\n', '        st.setBool(keccak256("case.won", caseId), won);\n', '    }\n', '\n', '    function setCaseStatus(address storageAddress, bytes32 caseId, CaseStatus status) public\n', '    {\n', '        uint8 statusCode = uint8(status);\n', '        require(statusCode >= 0 && statusCode <= uint8(CaseStatus.CANCELED));\n', '        EternalStorage(storageAddress).setUint8(keccak256("case.status", caseId), statusCode);\n', '    }\n', '\n', '    function getCaseStatus(address storageAddress, bytes32 caseId) public view returns(CaseStatus) {\n', '        return CaseStatus(EternalStorage(storageAddress).getUint8(keccak256("case.status", caseId)));\n', '    }\n', '\n', '    function setCaseCanceledCode(address storageAddress, bytes32 caseId, CaseCanceledCode cause) public\n', '    {\n', '        uint8 causeCode = uint8(cause);\n', '        require(causeCode >= 0 && causeCode <= uint8(CaseCanceledCode.EQUAL_NUMBER_OF_VOTES));\n', '        EternalStorage(storageAddress).setUint8(keccak256("case.canceled.cause.code", caseId), causeCode);\n', '    }\n', '\n', '    function getCaseDate(address storageAddress, bytes32 caseId) public view returns(uint) {\n', '        return EternalStorage(storageAddress).getUint(keccak256("case.date", caseId));\n', '    }\n', '\n', '    function getRespondentDescription(address storageAddress, bytes32 caseId) public view returns(bytes32) {\n', '        return EternalStorage(storageAddress).getBytes32(keccak256("case.respondent.description", caseId));\n', '    }\n', '\n', '    function setRespondentDescription(address storageAddress, bytes32 caseId, string description) public {\n', '        EternalStorage(storageAddress).setBytes32(keccak256("case.respondent.description", caseId), keccak256(description));\n', '    }\n', '\n', '    function getApplicant(address storageAddress, bytes32 caseId) public view returns(address) {\n', '        return EternalStorage(storageAddress).getAddress(keccak256("case.applicant", caseId));\n', '    }\n', '\n', '    function getRespondent(address storageAddress, bytes32 caseId) public view returns(address) {\n', '        return EternalStorage(storageAddress).getAddress(keccak256("case.respondent", caseId));\n', '    }\n', '\n', '    function getRefereeAward(address storageAddress, bytes32 caseId) public view returns(uint) {\n', '        return EternalStorage(storageAddress).getUint(keccak256("case.referee.award", caseId));\n', '    }\n', '\n', '    function getVotingDate(address storageAddress, bytes32 caseId) public view returns(uint) {\n', '        return EternalStorage(storageAddress).getUint(keccak256("case.date.voting", caseId));\n', '    }\n', '\n', '    function getRevealingDate(address storageAddress, bytes32 caseId) public view returns(uint) {\n', '        return EternalStorage(storageAddress).getUint(keccak256("case.date.revealing", caseId));\n', '    }\n', '\n', '    function getCloseDate(address storageAddress, bytes32 caseId) public view returns(uint) {\n', '        return EternalStorage(storageAddress).getUint(keccak256("case.date.close", caseId));\n', '    }\n', '\n', '    function getRefereeCountNeed(address storageAddress, bytes32 caseId) public view returns(uint) {\n', '        return EternalStorage(storageAddress).getUint(keccak256("case.referee.count.need", caseId));\n', '    }\n', '\n', '    function isEthRefereeAward(address storageAddress, bytes32 caseId) public view returns(bool) {\n', '        return EternalStorage(storageAddress).getBool(keccak256("case.referee.award.eth", caseId));\n', '    }\n', '}\n', '\n', 'contract IBoardConfig is Ownable {\n', '\n', '    uint constant decimals = 10 ** uint(18);\n', '    uint8 public version;\n', '\n', '    function resetValuesToDefault() external;\n', '\n', '    function setStorageAddress(address storageAddress) external;\n', '\n', '    function getRefereeFee() external view returns (uint);\n', '    function getRefereeFeeEth() external view returns(uint);\n', '\n', '    function getVoteTokenPrice() external view returns (uint);\n', '    function setVoteTokenPrice(uint value) external;\n', '\n', '    function getVoteTokenPriceEth() external view returns (uint);\n', '    function setVoteTokenPriceEth(uint value) external;\n', '\n', '    function getVoteTokensPerRequest() external view returns (uint);\n', '    function setVoteTokensPerRequest(uint voteTokens) external;\n', '\n', '    function getTimeToStartVotingCase() external view returns (uint);\n', '    function setTimeToStartVotingCase(uint value) external;\n', '\n', '    function getTimeToRevealVotesCase() external view returns (uint);\n', '    function setTimeToRevealVotesCase(uint value) external;\n', '\n', '    function getTimeToCloseCase() external view returns (uint);\n', '    function setTimeToCloseCase(uint value) external;\n', '\n', '    function getRefereeCountPerCase() external view returns(uint);\n', '    function setRefereeCountPerCase(uint refereeCount) external;\n', '\n', '    function getRefereeNeedCountPerCase() external view returns(uint);\n', '    function setRefereeNeedCountPerCase(uint refereeCount) external;\n', '\n', '    function getFullConfiguration()\n', '    external view returns(\n', '        uint voteTokenPrice, uint voteTokenPriceEth, uint voteTokenPerRequest,\n', '        uint refereeCountPerCase, uint refereeNeedCountPerCase,\n', '        uint timeToStartVoting, uint timeToRevealVotes, uint timeToClose\n', '    );\n', '\n', '    function getCaseDatesFromNow() public view returns(uint[] dates);\n', '\n', '}\n', '\n', 'contract PaymentHolder is Ownable {\n', '\n', '    modifier onlyAllowed() {\n', '        require(allowed[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyUpdater() {\n', '        require(msg.sender == updater);\n', '        _;\n', '    }\n', '\n', '    mapping(address => bool) public allowed;\n', '    address public updater;\n', '\n', '    /*-----------------MAINTAIN METHODS------------------*/\n', '\n', '    function setUpdater(address _updater)\n', '    external onlyOwner {\n', '        updater = _updater;\n', '    }\n', '\n', '    function migrate(address newHolder, address[] tokens, address[] _allowed)\n', '    external onlyOwner {\n', '        require(PaymentHolder(newHolder).update.value(address(this).balance)(_allowed));\n', '        for (uint256 i = 0; i < tokens.length; i++) {\n', '            address token = tokens[i];\n', '            uint256 balance = Token(token).balanceOf(this);\n', '            if (balance > 0) {\n', '                require(Token(token).transfer(newHolder, balance));\n', '            }\n', '        }\n', '    }\n', '\n', '    function update(address[] _allowed)\n', '    external payable onlyUpdater returns(bool) {\n', '        for (uint256 i = 0; i < _allowed.length; i++) {\n', '            allowed[_allowed[i]] = true;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /*-----------------OWNER FLOW------------------*/\n', '\n', '    function allow(address to) \n', '    external onlyOwner { allowed[to] = true; }\n', '\n', '    function prohibit(address to)\n', '    external onlyOwner { allowed[to] = false; }\n', '\n', '    /*-----------------ALLOWED FLOW------------------*/\n', '\n', '    function depositEth()\n', '    public payable onlyAllowed returns (bool) {\n', '        //Default function to receive eth\n', '        return true;\n', '    }\n', '\n', '    function withdrawEth(address to, uint256 amount)\n', '    public onlyAllowed returns(bool) {\n', '        require(address(this).balance >= amount, "Not enough ETH balance");\n', '        to.transfer(amount);\n', '        return true;\n', '    }\n', '\n', '    function withdrawToken(address to, uint256 amount, address token)\n', '    public onlyAllowed returns(bool) {\n', '        require(Token(token).balanceOf(this) >= amount, "Not enough token balance");\n', '        require(Token(token).transfer(to, amount));\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract Board is IBoard {\n', '\n', '    using SafeMath for uint;\n', '    using VoteTokenLib for address;\n', '    using CasesLib for address;\n', '    using RefereesLib for address;\n', '    using RefereeCasesLib for address;\n', '\n', '    modifier onlyRespondent(bytes32 caseId) {\n', '        require(msg.sender == lib.getRespondent(caseId));\n', '        _;\n', '    }\n', '\n', '    modifier hasStatus(bytes32 caseId, CasesLib.CaseStatus state) {\n', '        require(state == lib.getCaseStatus(caseId));\n', '        _;\n', '    }\n', '\n', '    modifier before(uint date) {\n', '        require(now <= date);\n', '        _;\n', '    }\n', '\n', '    modifier laterOn(uint date) {\n', '        require(now >= date);\n', '        _;\n', '    }\n', '\n', '    function Board(address storageAddress, address configAddress, address _paymentHolder) public {\n', '        version = 2;\n', '        config = IBoardConfig(configAddress);\n', '        lib = storageAddress;\n', '        //check real BKX address https://etherscan.io/token/0x45245bc59219eeaAF6cD3f382e078A461FF9De7B\n', '        bkxToken = BkxToken(0x45245bc59219eeaAF6cD3f382e078A461FF9De7B);\n', '        admin = 0xE0b6C095D722961C2C11E55b97fCd0C8bd7a1cD2;\n', '        paymentHolder = _paymentHolder;\n', '        refereePaymentHolder = msg.sender;\n', '    }\n', '\n', '    function withdrawEth(uint value) external onlyOwner {\n', '        require(address(this).balance >= value);\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    function withdrawBkx(uint value) external onlyOwner {\n', '        require(bkxToken.balanceOf(address(this)) >= value);\n', '        require(bkxToken.transfer(msg.sender, value));\n', '    }\n', '\n', '    /* configuration */\n', '    function setStorageAddress(address storageAddress) external onlyOwner {\n', '        lib = storageAddress;\n', '    }\n', '\n', '    function setConfigAddress(address configAddress) external onlyOwner {\n', '        config = IBoardConfig(configAddress);\n', '    }\n', '\n', '    /* dependency tokens */\n', '    function setBkxToken(address tokenAddress) external onlyOwner {\n', '        bkxToken = BkxToken(tokenAddress);\n', '    }\n', '\n', '    function setPaymentHolder(address _paymentHolder) external onlyOwner {\n', '        paymentHolder = _paymentHolder;\n', '    }\n', '\n', '    function setRefereePaymentHolder(address _refereePaymentHolder) external onlyOwner {\n', '        refereePaymentHolder = _refereePaymentHolder;\n', '    }\n', '\n', '    function setAdmin(address newAdmin) external onlyOwner {\n', '        admin = newAdmin;\n', '    }\n', '\n', '    function applyForReferee() external {\n', '        uint refereeFee = config.getRefereeFee();\n', '        require(bkxToken.allowance(msg.sender, address(this)) >= refereeFee);\n', '        require(bkxToken.balanceOf(msg.sender) >= refereeFee);\n', '        require(bkxToken.transferFrom(msg.sender, refereePaymentHolder, refereeFee));\n', '        addVotes(msg.sender);\n', '    }\n', '\n', '    function addVoteTokens(address referee) external onlyOwnerOrAdmin {\n', '        addVotes(referee);\n', '    }\n', '\n', '    function addVotes(address referee) private {\n', '        uint refereeTokens = config.getVoteTokensPerRequest();\n', '        if (!lib.isRefereeApplied(referee)) {\n', '            lib.addReferee(referee);\n', '        }\n', '        uint balance = refereeTokens.add(lib.getVotes(referee));\n', '        lib.setVotes(referee, balance);\n', '        emit RefereeVoteBalanceChanged(referee, balance);\n', '    }\n', '\n', '    function openCase(address respondent, bytes32 deal, uint amount, uint refereeAward, bytes32 title, string description)\n', '    external payable {\n', '        require(msg.sender != respondent);\n', '        withdrawPayment(refereeAward);\n', '        uint[] memory dates = config.getCaseDatesFromNow();\n', '        uint refereeCountNeed = config.getRefereeNeedCountPerCase();\n', '        bytes32 caseId = lib.addCase(msg.sender, respondent, deal, amount, refereeAward, title, description, dates, refereeCountNeed, msg.value != 0);\n', '        emit CaseOpened(caseId, msg.sender, respondent, deal, amount, refereeAward, title, description, dates, refereeCountNeed, msg.value != 0);\n', '        assignRefereesToCase(caseId, msg.sender, respondent);\n', '    }\n', '\n', '    function withdrawPayment(uint256 amount) private {\n', '        if(msg.value != 0) {\n', '            require(msg.value == amount, "ETH amount must be equal amount");\n', '            require(PaymentHolder(paymentHolder).depositEth.value(msg.value)());\n', '        } else {\n', '            require(bkxToken.allowance(msg.sender, address(this)) >= amount);\n', '            require(bkxToken.balanceOf(msg.sender) >= amount);\n', '            require(bkxToken.transferFrom(msg.sender, paymentHolder, amount));\n', '        }\n', '    }\n', '\n', '    function assignRefereesToCase(bytes32 caseId, address applicant, address respondent) private  {\n', '        uint targetCount = config.getRefereeCountPerCase();\n', '        address[] memory foundReferees = lib.getRandomRefereesToCase(applicant, respondent, targetCount);\n', '        for (uint i = 0; i < foundReferees.length; i++) {\n', '            address referee = foundReferees[i];\n', '            uint voteBalance = lib.getVotes(referee);\n', '            voteBalance -= 1;\n', '            lib.setVotes(referee, voteBalance);\n', '            emit RefereeVoteBalanceChanged(referee, voteBalance);\n', '        }\n', '        lib.setRefereesToCase(foundReferees, caseId);\n', '        emit RefereesAssignedToCase(caseId, foundReferees);\n', '    }\n', '\n', '    function setRespondentDescription(bytes32 caseId, string description)\n', '    external onlyRespondent(caseId) hasStatus(caseId, CasesLib.CaseStatus.OPENED) before(lib.getVotingDate(caseId)) {\n', '        require(lib.getRespondentDescription(caseId) == 0);\n', '        lib.setRespondentDescription(caseId, description);\n', '        lib.setCaseStatus(caseId, CasesLib.CaseStatus.VOTING);\n', '        emit CaseCommentedByRespondent(caseId, msg.sender, description);\n', '        emit CaseVoting(caseId);\n', '    }\n', '\n', '    function startVotingCase(bytes32 caseId)\n', '    external hasStatus(caseId, CasesLib.CaseStatus.OPENED) laterOn(lib.getVotingDate(caseId)) {\n', '        lib.setCaseStatus(caseId, CasesLib.CaseStatus.VOTING);\n', '        emit CaseVoting(caseId);\n', '    }\n', '\n', '    function commitVote(bytes32 caseId, bytes32 voteHash)\n', '    external hasStatus(caseId, CasesLib.CaseStatus.VOTING) before(lib.getRevealingDate(caseId))\n', '    {\n', '        require(lib.isRefereeSetToCase(msg.sender, caseId)); //referee must be set to case\n', '        require(!lib.isRefereeVoted(msg.sender, caseId)); //referee can not vote twice\n', '        lib.setRefereeVoteHash(caseId, msg.sender, voteHash);\n', '        emit CaseVoteCommitted(caseId, msg.sender, voteHash);\n', '        if (lib.getRefereeVoteHashCount(caseId) == lib.getRefereeCountByCase(caseId)) {\n', '            lib.setCaseStatus(caseId, CasesLib.CaseStatus.REVEALING);\n', '            emit CaseRevealingVotes(caseId);\n', '        }\n', '    }\n', '\n', '    function startRevealingVotes(bytes32 caseId)\n', '    external hasStatus(caseId, CasesLib.CaseStatus.VOTING) laterOn(lib.getRevealingDate(caseId))\n', '    {\n', '        lib.setCaseStatus(caseId, CasesLib.CaseStatus.REVEALING);\n', '        emit CaseRevealingVotes(caseId);\n', '    }\n', '\n', '    function revealVote(bytes32 caseId, address referee, uint8 voteOption, bytes32 salt)\n', '    external hasStatus(caseId, CasesLib.CaseStatus.REVEALING) before(lib.getCloseDate(caseId))\n', '    {\n', '        doRevealVote(caseId, referee, voteOption, salt);\n', '        checkShouldMakeVerdict(caseId);\n', '    }\n', '\n', '    function revealVotes(bytes32 caseId, address[] referees, uint8[] voteOptions, bytes32[] salts)\n', '    external hasStatus(caseId, CasesLib.CaseStatus.REVEALING) before(lib.getCloseDate(caseId))\n', '    {\n', '        require((referees.length == voteOptions.length) && (referees.length == salts.length));\n', '        for (uint i = 0; i < referees.length; i++) {\n', '            doRevealVote(caseId, referees[i], voteOptions[i], salts[i]);\n', '        }\n', '        checkShouldMakeVerdict(caseId);\n', '    }\n', '\n', '    function checkShouldMakeVerdict(bytes32 caseId)\n', '    private {\n', '        if (lib.getRefereeVotesFor(caseId, true) + lib.getRefereeVotesFor(caseId, false) == lib.getRefereeVoteHashCount(caseId)) {\n', '            makeVerdict(caseId);\n', '        }\n', '    }\n', '\n', '    function doRevealVote(bytes32 caseId, address referee, uint8 voteOption, bytes32 salt) private {\n', '        require(verifyVote(caseId, referee, voteOption, salt));\n', '        lib.setRefereeVote(caseId, referee,  voteOption == 0);\n', '        emit CaseVoteRevealed(caseId, referee, voteOption, salt);\n', '    }\n', '\n', '    function createVoteHash(uint8 voteOption, bytes32 salt)\n', '    public view returns(bytes32) {\n', '        return keccak256(voteOption, salt);\n', '    }\n', '\n', '    function verifyVote(bytes32 caseId, address referee, uint8 voteOption, bytes32 salt)\n', '    public view returns(bool){\n', '        return lib.getRefereeVoteHash(caseId, referee) == keccak256(voteOption, salt);\n', '    }\n', '\n', '    function verdict(bytes32 caseId)\n', '    external hasStatus(caseId, CasesLib.CaseStatus.REVEALING) laterOn(lib.getCloseDate(caseId)) {\n', '        makeVerdict(caseId);\n', '    }\n', '\n', '    function makeVerdict(bytes32 caseId)\n', '    private {\n', '        uint forApplicant = lib.getRefereeVotesFor(caseId, true);\n', '        uint forRespondent = lib.getRefereeVotesFor(caseId, false);\n', '        uint refereeAward = lib.getRefereeAward(caseId);\n', '        bool isNotEnoughVotes = (forApplicant + forRespondent) < lib.getRefereeCountNeed(caseId);\n', '        bool isEthRefereeAward = lib.isEthRefereeAward(caseId);\n', '        if (isNotEnoughVotes || (forApplicant == forRespondent)) {\n', '            withdrawTo(isEthRefereeAward, lib.getApplicant(caseId), refereeAward);\n', '            lib.setCaseStatus(caseId, CasesLib.CaseStatus.CANCELED);\n', '            CasesLib.CaseCanceledCode causeCode = isNotEnoughVotes ?\n', '                CasesLib.CaseCanceledCode.NOT_ENOUGH_VOTES : CasesLib.CaseCanceledCode.EQUAL_NUMBER_OF_VOTES;\n', '            lib.setCaseCanceledCode(caseId, causeCode);\n', '            emit CaseCanceled(caseId, uint8(causeCode));\n', '            withdrawAllRefereeVotes(caseId);\n', '            return;\n', '        }\n', '        bool won = false;\n', '        uint awardPerReferee;\n', '        if (forApplicant > forRespondent) {\n', '            won = true;\n', '            awardPerReferee = refereeAward / forApplicant;\n', '        } else {\n', '            awardPerReferee = refereeAward / forRespondent;\n', '        }\n', '        lib.setCaseStatus(caseId, CasesLib.CaseStatus.CLOSED);\n', '        lib.setCaseWon(caseId, won);\n', '        emit CaseClosed(caseId, won);\n', '        address[] memory wonReferees = lib.getRefereesFor(caseId, won);\n', '        for (uint i = 0; i < wonReferees.length; i++) {\n', '            withdrawTo(isEthRefereeAward, wonReferees[i], awardPerReferee);\n', '            emit RefereeAwarded(wonReferees[i], caseId, awardPerReferee);\n', '        }\n', '        withdrawRefereeVotes(caseId);\n', '    }\n', '\n', '    function withdrawTo(bool isEth, address to, uint amount) private {\n', '        if (isEth) {\n', '            require(PaymentHolder(paymentHolder).withdrawEth(to, amount));\n', '        } else {\n', '            require(PaymentHolder(paymentHolder).withdrawToken(to, amount, address(bkxToken)));\n', '        }\n', '    } \n', '\n', '    function withdrawAllRefereeVotes(bytes32 caseId) private {\n', '        address[] memory referees = lib.getRefereesByCase(caseId);\n', '        for (uint i = 0; i < referees.length; i++) {\n', '            withdrawRefereeVote(referees[i]);\n', '        }\n', '    }\n', '\n', '    function withdrawRefereeVotes(bytes32 caseId)\n', '    private {\n', '        address[] memory referees = lib.getRefereesByCase(caseId);\n', '        for (uint i = 0; i < referees.length; i++) {\n', '            if (!lib.isRefereeVoted(referees[i], caseId)) {\n', '                withdrawRefereeVote(referees[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    function withdrawRefereeVote(address referee)\n', '    private {\n', '        uint voteBalance = lib.getVotes(referee);\n', '        voteBalance += 1;\n', '        lib.setVotes(referee, voteBalance);\n', '        emit RefereeVoteBalanceChanged(referee, voteBalance);\n', '    }\n', '}']