['//A BurnablePayment is instantiated with one "opening agent" (Payer or Worker), a title, an initial deposit, a commitThreshold, and an autoreleaseInterval.\n', '//If the opening agent is the payer:\n', '//    The contract starts in the PayerOpened state.\n', '//    Payer is expected to request some service via the title and additional statements.\n', '//    The initial deposit represents the amount Payer will pay for the service.\n', '//    Another user can claim the job by calling commit() and becoming the worker.\n', '//If the opening agent is the worker:\n', '//    The contract starts in the WorkerOpened state.\n', '//    Worker is expected to offer some service via the title and additional statements.\n', '//    The initial deposit serves as collateral that a payer will have control over.\n', '//    Another user can claim the service by calling commit() and becoming the payer.\n', '\n', '//While in either Open state,\n', '//    The opening agent can call recover() to destroy the contract and refund all deposited funds.\n', '//    The opening agent can log statements to add additional details, clarifications, or corrections.\n', '//    Anyone can enter the contract as the open role by contributing the commitThreshold with commit();\n', '//        this changes the state to Committed.\n', '\n', '//Upon changing from either Open state -> Committed:\n', '//    AutoreleaseTime is set to (now + autoreleaseInterval).\n', '\n', '//In the Committed state:\n', '//    Both roles are permanent.\n', '//    Both Payer and Worker can log statements.\n', '//    Payer can at any time choose to burn() or release() to Worker any amount of funds.\n', '//    Payer can delayAutorelease(), setting the autoreleaseTime to (now + autoreleaseInterval), any number of times.\n', '//    If autoreleaseTime comes, Worker can triggerAutorelease() to claim all ether remaining in the payment.\n', '//    Once the balance of the payment is 0, the state changes to Closed.\n', '\n', '//In the Closed state:\n', '//    Payer and Worker can still log statements.\n', '//    If addFunds() is called, the contract returns to the Committed state.\n', '\n', 'pragma solidity ^ 0.4.2;\n', '\n', 'contract BurnablePaymentFactory {\n', '    \n', '    //contract address array\n', '    address[]public BPs;\n', '\n', '    event NewBurnablePayment(\n', '        address indexed bpAddress, \n', '        bool payerOpened, \n', '        address creator, \n', '        uint deposited, \n', '        uint commitThreshold, \n', '        uint autoreleaseInterval, \n', '        string title, \n', '        string initialStatement\n', '    );  \n', '\n', '    function newBP(bool payerOpened, address creator, uint commitThreshold, uint autoreleaseInterval, string title, string initialStatement)\n', '    public\n', '    payable\n', '    returns (address newBPAddr) \n', '    {\n', '        //pass along any ether to the constructor\n', '        newBPAddr = (new BurnablePayment).value(msg.value)(payerOpened, creator, commitThreshold, autoreleaseInterval, title, initialStatement);\n', '        NewBurnablePayment(newBPAddr, payerOpened, creator, msg.value, commitThreshold, autoreleaseInterval, title, initialStatement);\n', '\n', '        BPs.push(newBPAddr);\n', '\n', '        return newBPAddr;\n', '    }\n', '\n', '    function getBPCount()\n', '    public\n', '    constant\n', '    returns(uint) \n', '    {\n', '        return BPs.length;\n', '    }\n', '}\n', '\n', 'contract BurnablePayment {\n', '    //title will never change\n', '    string public title;\n', '    \n', '    //BP will start with a payer or a worker but not both\n', '    address public payer;\n', '    address public worker;\n', '    address constant BURN_ADDRESS = 0x0;\n', '    \n', '    //Set to true if fundsRecovered is called\n', '    bool recovered = false;\n', '\n', '    //Note that these will track, but not influence the BP logic.\n', '    uint public amountDeposited;\n', '    uint public amountBurned;\n', '    uint public amountReleased;\n', '\n', '    //Amount of ether that must be deposited via commit() to become the second party of the BP.\n', '    uint public commitThreshold;\n', '\n', '    //How long should we wait before allowing the default release to be called?\n', '    uint public autoreleaseInterval;\n', '\n', '    //Calculated from autoreleaseInterval in commit(),\n', '    //and recaluclated whenever the payer (or possibly the worker) calls delayhasDefaultRelease()\n', '    //After this time, auto-release can be called by the Worker.\n', '    uint public autoreleaseTime;\n', '\n', '    //Most action happens in the Committed state.\n', '    enum State {\n', '        PayerOpened,\n', '        WorkerOpened,\n', '        Committed,\n', '        Closed\n', '    }\n', '\n', '    //Note that a BP cannot go from Committed back to either Open state, but it can go from Closed back to Committed\n', '    //Search for Closed and Unclosed events to see how this works.\n', '    State public state;\n', '\n', '    modifier inState(State s) {\n', '        require(s == state);\n', '        _;\n', '    }\n', '    modifier inOpenState() {\n', '        require(state == State.PayerOpened || state == State.WorkerOpened);\n', '        _;\n', '    }\n', '    modifier onlyPayer() {\n', '        require(msg.sender == payer);\n', '        _;\n', '    }\n', '    modifier onlyWorker() {\n', '        require(msg.sender == worker);\n', '        _;\n', '    }\n', '    modifier onlyPayerOrWorker() {\n', '        require((msg.sender == payer) || (msg.sender == worker));\n', '        _;\n', '    }\n', '    modifier onlyCreatorWhileOpen() {\n', '        if (state == State.PayerOpened) {\n', '            require(msg.sender == payer);\n', '        } else if (state == State.WorkerOpened) {\n', '            require(msg.sender == worker);\n', '        } else {\n', '            revert();        \n', '        }\n', '        _;\n', '    }\n', '\n', '    event Created(address indexed contractAddress, bool payerOpened, address creator, uint commitThreshold, uint autoreleaseInterval, string title);\n', '    event FundsAdded(address from, uint amount); //The payer has added funds to the BP.\n', '    event PayerStatement(string statement);\n', '    event WorkerStatement(string statement);\n', '    event FundsRecovered();\n', '    event Committed(address committer);\n', '    event FundsBurned(uint amount);\n', '    event FundsReleased(uint amount);\n', '    event Closed();\n', '    event Unclosed();\n', '    event AutoreleaseDelayed();\n', '    event AutoreleaseTriggered();\n', '\n', '    function BurnablePayment(bool payerIsOpening, address creator, uint _commitThreshold, uint _autoreleaseInterval, string _title, string initialStatement)\n', '    public\n', '    payable \n', '    {\n', '        Created(this, payerIsOpening, creator, _commitThreshold, autoreleaseInterval, title);\n', '\n', '        if (msg.value > 0) {\n', '            //Here we use tx.origin instead of msg.sender (msg.sender is just the factory contract)\n', '            FundsAdded(tx.origin, msg.value);\n', '            amountDeposited += msg.value;\n', '        }\n', '        \n', '        title = _title;\n', '\n', '        if (payerIsOpening) {\n', '            state = State.PayerOpened;\n', '            payer = creator;\n', '        } else {\n', '            state = State.WorkerOpened;\n', '            worker = creator;\n', '        }\n', '\n', '        commitThreshold = _commitThreshold;\n', '        autoreleaseInterval = _autoreleaseInterval;\n', '\n', '        if (bytes(initialStatement).length > 0) {\n', '            if (payerIsOpening) {\n', '                PayerStatement(initialStatement);\n', '            } else {\n', '                WorkerStatement(initialStatement);              \n', '            }\n', '        }\n', '    }\n', '\n', '    function addFunds()\n', '    public\n', '    payable\n', '    onlyPayerOrWorker()\n', '    {\n', '        require(msg.value > 0);\n', '\n', '        FundsAdded(msg.sender, msg.value);\n', '        amountDeposited += msg.value;\n', '        if (state == State.Closed) {\n', '            state = State.Committed;\n', '            Unclosed();\n', '        }\n', '    }\n', '\n', '    function recoverFunds()\n', '    public\n', '    onlyCreatorWhileOpen()\n', '    {\n', '        recovered = true;\n', '        FundsRecovered();\n', '        \n', '        if (state == State.PayerOpened)\n', '            selfdestruct(payer);\n', '        else if (state == State.WorkerOpened)\n', '            selfdestruct(worker);\n', '    }\n', '\n', '    function commit()\n', '    public\n', '    inOpenState()\n', '    payable \n', '    {\n', '        require(msg.value == commitThreshold);\n', '\n', '        if (msg.value > 0) {\n', '            FundsAdded(msg.sender, msg.value);\n', '            amountDeposited += msg.value;\n', '        }\n', '\n', '        if (state == State.PayerOpened)\n', '            worker = msg.sender;\n', '        else\n', '            payer = msg.sender;\n', '        state = State.Committed;\n', '        \n', '        Committed(msg.sender);\n', '\n', '        autoreleaseTime = now + autoreleaseInterval;\n', '    }\n', '\n', '    function internalBurn(uint amount)\n', '    private \n', '    {\n', '        BURN_ADDRESS.transfer(amount);\n', '\n', '        amountBurned += amount;\n', '        FundsBurned(amount);\n', '\n', '        if (this.balance == 0) {\n', '            state = State.Closed;\n', '            Closed();\n', '        }\n', '    }\n', '\n', '    function burn(uint amount)\n', '    public\n', '    inState(State.Committed)\n', '    onlyPayer() \n', '    {\n', '        internalBurn(amount);\n', '    }\n', '\n', '    function internalRelease(uint amount)\n', '    private \n', '    {\n', '        worker.transfer(amount);\n', '\n', '        amountReleased += amount;\n', '        FundsReleased(amount);\n', '\n', '        if (this.balance == 0) {\n', '            state = State.Closed;\n', '            Closed();\n', '        }\n', '    }\n', '\n', '    function release(uint amount)\n', '    public\n', '    inState(State.Committed)\n', '    onlyPayer() \n', '    {\n', '        internalRelease(amount);\n', '    }\n', '\n', '    function logPayerStatement(string statement)\n', '    public\n', '    onlyPayer() \n', '    {\n', '        PayerStatement(statement);\n', '    }\n', '\n', '    function logWorkerStatement(string statement)\n', '    public\n', '    onlyWorker() \n', '    {\n', '        WorkerStatement(statement);\n', '    }\n', '\n', '    function delayAutorelease()\n', '    public\n', '    onlyPayer()\n', '    inState(State.Committed) \n', '    {\n', '        autoreleaseTime = now + autoreleaseInterval;\n', '        AutoreleaseDelayed();\n', '    }\n', '\n', '    function triggerAutorelease()\n', '    public\n', '    onlyWorker()\n', '    inState(State.Committed) \n', '    {\n', '        require(now >= autoreleaseTime);\n', '\n', '        AutoreleaseTriggered();\n', '        internalRelease(this.balance);\n', '    }\n', '    \n', '    function getFullState()\n', '    public\n', '    constant\n', '    returns(State, address, address, string, uint, uint, uint, uint, uint, uint, uint) {\n', '        return (state, payer, worker, title, this.balance, commitThreshold, amountDeposited, amountBurned, amountReleased, autoreleaseInterval, autoreleaseTime);\n', '    }\n', '}']
['//A BurnablePayment is instantiated with one "opening agent" (Payer or Worker), a title, an initial deposit, a commitThreshold, and an autoreleaseInterval.\n', '//If the opening agent is the payer:\n', '//    The contract starts in the PayerOpened state.\n', '//    Payer is expected to request some service via the title and additional statements.\n', '//    The initial deposit represents the amount Payer will pay for the service.\n', '//    Another user can claim the job by calling commit() and becoming the worker.\n', '//If the opening agent is the worker:\n', '//    The contract starts in the WorkerOpened state.\n', '//    Worker is expected to offer some service via the title and additional statements.\n', '//    The initial deposit serves as collateral that a payer will have control over.\n', '//    Another user can claim the service by calling commit() and becoming the payer.\n', '\n', '//While in either Open state,\n', '//    The opening agent can call recover() to destroy the contract and refund all deposited funds.\n', '//    The opening agent can log statements to add additional details, clarifications, or corrections.\n', '//    Anyone can enter the contract as the open role by contributing the commitThreshold with commit();\n', '//        this changes the state to Committed.\n', '\n', '//Upon changing from either Open state -> Committed:\n', '//    AutoreleaseTime is set to (now + autoreleaseInterval).\n', '\n', '//In the Committed state:\n', '//    Both roles are permanent.\n', '//    Both Payer and Worker can log statements.\n', '//    Payer can at any time choose to burn() or release() to Worker any amount of funds.\n', '//    Payer can delayAutorelease(), setting the autoreleaseTime to (now + autoreleaseInterval), any number of times.\n', '//    If autoreleaseTime comes, Worker can triggerAutorelease() to claim all ether remaining in the payment.\n', '//    Once the balance of the payment is 0, the state changes to Closed.\n', '\n', '//In the Closed state:\n', '//    Payer and Worker can still log statements.\n', '//    If addFunds() is called, the contract returns to the Committed state.\n', '\n', 'pragma solidity ^ 0.4.2;\n', '\n', 'contract BurnablePaymentFactory {\n', '    \n', '    //contract address array\n', '    address[]public BPs;\n', '\n', '    event NewBurnablePayment(\n', '        address indexed bpAddress, \n', '        bool payerOpened, \n', '        address creator, \n', '        uint deposited, \n', '        uint commitThreshold, \n', '        uint autoreleaseInterval, \n', '        string title, \n', '        string initialStatement\n', '    );  \n', '\n', '    function newBP(bool payerOpened, address creator, uint commitThreshold, uint autoreleaseInterval, string title, string initialStatement)\n', '    public\n', '    payable\n', '    returns (address newBPAddr) \n', '    {\n', '        //pass along any ether to the constructor\n', '        newBPAddr = (new BurnablePayment).value(msg.value)(payerOpened, creator, commitThreshold, autoreleaseInterval, title, initialStatement);\n', '        NewBurnablePayment(newBPAddr, payerOpened, creator, msg.value, commitThreshold, autoreleaseInterval, title, initialStatement);\n', '\n', '        BPs.push(newBPAddr);\n', '\n', '        return newBPAddr;\n', '    }\n', '\n', '    function getBPCount()\n', '    public\n', '    constant\n', '    returns(uint) \n', '    {\n', '        return BPs.length;\n', '    }\n', '}\n', '\n', 'contract BurnablePayment {\n', '    //title will never change\n', '    string public title;\n', '    \n', '    //BP will start with a payer or a worker but not both\n', '    address public payer;\n', '    address public worker;\n', '    address constant BURN_ADDRESS = 0x0;\n', '    \n', '    //Set to true if fundsRecovered is called\n', '    bool recovered = false;\n', '\n', '    //Note that these will track, but not influence the BP logic.\n', '    uint public amountDeposited;\n', '    uint public amountBurned;\n', '    uint public amountReleased;\n', '\n', '    //Amount of ether that must be deposited via commit() to become the second party of the BP.\n', '    uint public commitThreshold;\n', '\n', '    //How long should we wait before allowing the default release to be called?\n', '    uint public autoreleaseInterval;\n', '\n', '    //Calculated from autoreleaseInterval in commit(),\n', '    //and recaluclated whenever the payer (or possibly the worker) calls delayhasDefaultRelease()\n', '    //After this time, auto-release can be called by the Worker.\n', '    uint public autoreleaseTime;\n', '\n', '    //Most action happens in the Committed state.\n', '    enum State {\n', '        PayerOpened,\n', '        WorkerOpened,\n', '        Committed,\n', '        Closed\n', '    }\n', '\n', '    //Note that a BP cannot go from Committed back to either Open state, but it can go from Closed back to Committed\n', '    //Search for Closed and Unclosed events to see how this works.\n', '    State public state;\n', '\n', '    modifier inState(State s) {\n', '        require(s == state);\n', '        _;\n', '    }\n', '    modifier inOpenState() {\n', '        require(state == State.PayerOpened || state == State.WorkerOpened);\n', '        _;\n', '    }\n', '    modifier onlyPayer() {\n', '        require(msg.sender == payer);\n', '        _;\n', '    }\n', '    modifier onlyWorker() {\n', '        require(msg.sender == worker);\n', '        _;\n', '    }\n', '    modifier onlyPayerOrWorker() {\n', '        require((msg.sender == payer) || (msg.sender == worker));\n', '        _;\n', '    }\n', '    modifier onlyCreatorWhileOpen() {\n', '        if (state == State.PayerOpened) {\n', '            require(msg.sender == payer);\n', '        } else if (state == State.WorkerOpened) {\n', '            require(msg.sender == worker);\n', '        } else {\n', '            revert();        \n', '        }\n', '        _;\n', '    }\n', '\n', '    event Created(address indexed contractAddress, bool payerOpened, address creator, uint commitThreshold, uint autoreleaseInterval, string title);\n', '    event FundsAdded(address from, uint amount); //The payer has added funds to the BP.\n', '    event PayerStatement(string statement);\n', '    event WorkerStatement(string statement);\n', '    event FundsRecovered();\n', '    event Committed(address committer);\n', '    event FundsBurned(uint amount);\n', '    event FundsReleased(uint amount);\n', '    event Closed();\n', '    event Unclosed();\n', '    event AutoreleaseDelayed();\n', '    event AutoreleaseTriggered();\n', '\n', '    function BurnablePayment(bool payerIsOpening, address creator, uint _commitThreshold, uint _autoreleaseInterval, string _title, string initialStatement)\n', '    public\n', '    payable \n', '    {\n', '        Created(this, payerIsOpening, creator, _commitThreshold, autoreleaseInterval, title);\n', '\n', '        if (msg.value > 0) {\n', '            //Here we use tx.origin instead of msg.sender (msg.sender is just the factory contract)\n', '            FundsAdded(tx.origin, msg.value);\n', '            amountDeposited += msg.value;\n', '        }\n', '        \n', '        title = _title;\n', '\n', '        if (payerIsOpening) {\n', '            state = State.PayerOpened;\n', '            payer = creator;\n', '        } else {\n', '            state = State.WorkerOpened;\n', '            worker = creator;\n', '        }\n', '\n', '        commitThreshold = _commitThreshold;\n', '        autoreleaseInterval = _autoreleaseInterval;\n', '\n', '        if (bytes(initialStatement).length > 0) {\n', '            if (payerIsOpening) {\n', '                PayerStatement(initialStatement);\n', '            } else {\n', '                WorkerStatement(initialStatement);              \n', '            }\n', '        }\n', '    }\n', '\n', '    function addFunds()\n', '    public\n', '    payable\n', '    onlyPayerOrWorker()\n', '    {\n', '        require(msg.value > 0);\n', '\n', '        FundsAdded(msg.sender, msg.value);\n', '        amountDeposited += msg.value;\n', '        if (state == State.Closed) {\n', '            state = State.Committed;\n', '            Unclosed();\n', '        }\n', '    }\n', '\n', '    function recoverFunds()\n', '    public\n', '    onlyCreatorWhileOpen()\n', '    {\n', '        recovered = true;\n', '        FundsRecovered();\n', '        \n', '        if (state == State.PayerOpened)\n', '            selfdestruct(payer);\n', '        else if (state == State.WorkerOpened)\n', '            selfdestruct(worker);\n', '    }\n', '\n', '    function commit()\n', '    public\n', '    inOpenState()\n', '    payable \n', '    {\n', '        require(msg.value == commitThreshold);\n', '\n', '        if (msg.value > 0) {\n', '            FundsAdded(msg.sender, msg.value);\n', '            amountDeposited += msg.value;\n', '        }\n', '\n', '        if (state == State.PayerOpened)\n', '            worker = msg.sender;\n', '        else\n', '            payer = msg.sender;\n', '        state = State.Committed;\n', '        \n', '        Committed(msg.sender);\n', '\n', '        autoreleaseTime = now + autoreleaseInterval;\n', '    }\n', '\n', '    function internalBurn(uint amount)\n', '    private \n', '    {\n', '        BURN_ADDRESS.transfer(amount);\n', '\n', '        amountBurned += amount;\n', '        FundsBurned(amount);\n', '\n', '        if (this.balance == 0) {\n', '            state = State.Closed;\n', '            Closed();\n', '        }\n', '    }\n', '\n', '    function burn(uint amount)\n', '    public\n', '    inState(State.Committed)\n', '    onlyPayer() \n', '    {\n', '        internalBurn(amount);\n', '    }\n', '\n', '    function internalRelease(uint amount)\n', '    private \n', '    {\n', '        worker.transfer(amount);\n', '\n', '        amountReleased += amount;\n', '        FundsReleased(amount);\n', '\n', '        if (this.balance == 0) {\n', '            state = State.Closed;\n', '            Closed();\n', '        }\n', '    }\n', '\n', '    function release(uint amount)\n', '    public\n', '    inState(State.Committed)\n', '    onlyPayer() \n', '    {\n', '        internalRelease(amount);\n', '    }\n', '\n', '    function logPayerStatement(string statement)\n', '    public\n', '    onlyPayer() \n', '    {\n', '        PayerStatement(statement);\n', '    }\n', '\n', '    function logWorkerStatement(string statement)\n', '    public\n', '    onlyWorker() \n', '    {\n', '        WorkerStatement(statement);\n', '    }\n', '\n', '    function delayAutorelease()\n', '    public\n', '    onlyPayer()\n', '    inState(State.Committed) \n', '    {\n', '        autoreleaseTime = now + autoreleaseInterval;\n', '        AutoreleaseDelayed();\n', '    }\n', '\n', '    function triggerAutorelease()\n', '    public\n', '    onlyWorker()\n', '    inState(State.Committed) \n', '    {\n', '        require(now >= autoreleaseTime);\n', '\n', '        AutoreleaseTriggered();\n', '        internalRelease(this.balance);\n', '    }\n', '    \n', '    function getFullState()\n', '    public\n', '    constant\n', '    returns(State, address, address, string, uint, uint, uint, uint, uint, uint, uint) {\n', '        return (state, payer, worker, title, this.balance, commitThreshold, amountDeposited, amountBurned, amountReleased, autoreleaseInterval, autoreleaseTime);\n', '    }\n', '}']
