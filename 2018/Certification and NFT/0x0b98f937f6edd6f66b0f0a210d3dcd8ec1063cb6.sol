['pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/*\n', '\n', 'This is a King Of The Hill contract which requires Proof of Work (hashpower) to set the king\n', '\n', 'This global non-owned contract proxy-mints 0xBTC through a personally-owned mintHelper contract (MintHelper.sol)\n', '\n', '*/\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', 'contract ERC918Interface {\n', '\n', '  function epochCount() public constant returns (uint);\n', '\n', '  function totalSupply() public constant returns (uint);\n', '  function getMiningDifficulty() public constant returns (uint);\n', '  function getMiningTarget() public constant returns (uint);\n', '  function getMiningReward() public constant returns (uint);\n', '  function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '\n', '  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '\n', '  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '}\n', '\n', 'contract mintForwarderInterface\n', '{\n', '  function mintForwarder(uint256 nonce, bytes32 challenge_digest, address[] proxyMintArray) public returns (bool success);\n', '}\n', '\n', 'contract proxyMinterInterface\n', '{\n', '  function proxyMint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '}\n', '\n', '\n', 'contract MiningKing   {\n', '\n', '\n', '  using SafeMath for uint;\n', '\n', '\n', '   address public miningKing;\n', '\n', '   address public minedToken;\n', '\n', '\n', '   event TransferKing(address from, address to);\n', '\n', '   // 0xBTC is 0xb6ed7644c69416d67b522e20bc294a9a9b405b31;\n', '  constructor(address mintableToken) public  {\n', '    minedToken = mintableToken;\n', '  }\n', '\n', '\n', '  //do not allow ether to enter\n', '  function() public payable {\n', '      revert();\n', '  }\n', '\n', '  function getKing() view public returns (address king)\n', '  {\n', '    return miningKing;\n', '  }\n', '\n', '   function transferKing(address newKing) public   {\n', '\n', '       require(msg.sender == miningKing);\n', '\n', '       miningKing = newKing;\n', '\n', '       emit TransferKing(msg.sender, newKing);\n', '\n', '   }\n', '\n', '\n', '/**\n', 'Set the king to the Ethereum Address which is encoded as 160 bits of the 256 bit mining nonce\n', '\n', '\n', '**/\n', '\n', '//proxyMintWithKing\n', '   function mintForwarder(uint256 nonce, bytes32 challenge_digest, address[] proxyMintArray) public returns (bool)\n', '   {\n', '\n', '      require(proxyMintArray.length > 0);\n', '\n', '\n', '      uint previousEpochCount = ERC918Interface(minedToken).epochCount();\n', '\n', '      address proxyMinter = proxyMintArray[0];\n', '\n', '      if(proxyMintArray.length == 1)\n', '      {\n', '        //Forward to the last proxyMint contract, typically a pool&#39;s owned  mint contract\n', '        require(proxyMinterInterface(proxyMinter).proxyMint(nonce, challenge_digest));\n', '      }else{\n', '        //if array length is greater than 1, pop the proxyMinter from the front of the array and keep cascading down the chain...\n', '        address[] memory remainingProxyMintArray = popFirstFromArray(proxyMintArray);\n', '\n', '        require(mintForwarderInterface(proxyMinter).mintForwarder(nonce, challenge_digest,remainingProxyMintArray));\n', '      }\n', '\n', '     //make sure that the minedToken really was proxy minted through the proxyMint delegate call chain\n', '      require( ERC918Interface(minedToken).epochCount() == previousEpochCount.add(1) );\n', '\n', '\n', '\n', '\n', '      // UNIQUE CONTRACT ACTION SPACE \n', '      bytes memory nonceBytes = uintToBytesForAddress(nonce);\n', '\n', '      address newKing = bytesToAddress(nonceBytes);\n', '      \n', '      miningKing = newKing;\n', '      // --------\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '  function popFirstFromArray(address[] array) pure public returns (address[] memory)\n', '  {\n', '    address[] memory newArray = new address[](array.length-1);\n', '\n', '    for (uint i=0; i < array.length-1; i++) {\n', '      newArray[i] =  array[i+1]  ;\n', '    }\n', '\n', '    return newArray;\n', '  }\n', '\n', ' function uintToBytesForAddress(uint256 x) pure public returns (bytes b) {\n', '\n', '      b = new bytes(20);\n', '      for (uint i = 0; i < 20; i++) {\n', '          b[i] = byte(uint8(x / (2**(8*(31 - i)))));\n', '      }\n', '\n', '      return b;\n', '    }\n', '\n', '\n', ' function bytesToAddress (bytes b) pure public returns (address) {\n', '     uint result = 0;\n', '     for (uint i = b.length-1; i+1 > 0; i--) {\n', '       uint c = uint(b[i]);\n', '       uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\n', '       result += to_inc;\n', '     }\n', '     return address(result);\n', ' }\n', '\n', '\n', '\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/*\n', '\n', 'This is a King Of The Hill contract which requires Proof of Work (hashpower) to set the king\n', '\n', 'This global non-owned contract proxy-mints 0xBTC through a personally-owned mintHelper contract (MintHelper.sol)\n', '\n', '*/\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', 'contract ERC918Interface {\n', '\n', '  function epochCount() public constant returns (uint);\n', '\n', '  function totalSupply() public constant returns (uint);\n', '  function getMiningDifficulty() public constant returns (uint);\n', '  function getMiningTarget() public constant returns (uint);\n', '  function getMiningReward() public constant returns (uint);\n', '  function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '\n', '  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '\n', '  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '}\n', '\n', 'contract mintForwarderInterface\n', '{\n', '  function mintForwarder(uint256 nonce, bytes32 challenge_digest, address[] proxyMintArray) public returns (bool success);\n', '}\n', '\n', 'contract proxyMinterInterface\n', '{\n', '  function proxyMint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '}\n', '\n', '\n', 'contract MiningKing   {\n', '\n', '\n', '  using SafeMath for uint;\n', '\n', '\n', '   address public miningKing;\n', '\n', '   address public minedToken;\n', '\n', '\n', '   event TransferKing(address from, address to);\n', '\n', '   // 0xBTC is 0xb6ed7644c69416d67b522e20bc294a9a9b405b31;\n', '  constructor(address mintableToken) public  {\n', '    minedToken = mintableToken;\n', '  }\n', '\n', '\n', '  //do not allow ether to enter\n', '  function() public payable {\n', '      revert();\n', '  }\n', '\n', '  function getKing() view public returns (address king)\n', '  {\n', '    return miningKing;\n', '  }\n', '\n', '   function transferKing(address newKing) public   {\n', '\n', '       require(msg.sender == miningKing);\n', '\n', '       miningKing = newKing;\n', '\n', '       emit TransferKing(msg.sender, newKing);\n', '\n', '   }\n', '\n', '\n', '/**\n', 'Set the king to the Ethereum Address which is encoded as 160 bits of the 256 bit mining nonce\n', '\n', '\n', '**/\n', '\n', '//proxyMintWithKing\n', '   function mintForwarder(uint256 nonce, bytes32 challenge_digest, address[] proxyMintArray) public returns (bool)\n', '   {\n', '\n', '      require(proxyMintArray.length > 0);\n', '\n', '\n', '      uint previousEpochCount = ERC918Interface(minedToken).epochCount();\n', '\n', '      address proxyMinter = proxyMintArray[0];\n', '\n', '      if(proxyMintArray.length == 1)\n', '      {\n', "        //Forward to the last proxyMint contract, typically a pool's owned  mint contract\n", '        require(proxyMinterInterface(proxyMinter).proxyMint(nonce, challenge_digest));\n', '      }else{\n', '        //if array length is greater than 1, pop the proxyMinter from the front of the array and keep cascading down the chain...\n', '        address[] memory remainingProxyMintArray = popFirstFromArray(proxyMintArray);\n', '\n', '        require(mintForwarderInterface(proxyMinter).mintForwarder(nonce, challenge_digest,remainingProxyMintArray));\n', '      }\n', '\n', '     //make sure that the minedToken really was proxy minted through the proxyMint delegate call chain\n', '      require( ERC918Interface(minedToken).epochCount() == previousEpochCount.add(1) );\n', '\n', '\n', '\n', '\n', '      // UNIQUE CONTRACT ACTION SPACE \n', '      bytes memory nonceBytes = uintToBytesForAddress(nonce);\n', '\n', '      address newKing = bytesToAddress(nonceBytes);\n', '      \n', '      miningKing = newKing;\n', '      // --------\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '  function popFirstFromArray(address[] array) pure public returns (address[] memory)\n', '  {\n', '    address[] memory newArray = new address[](array.length-1);\n', '\n', '    for (uint i=0; i < array.length-1; i++) {\n', '      newArray[i] =  array[i+1]  ;\n', '    }\n', '\n', '    return newArray;\n', '  }\n', '\n', ' function uintToBytesForAddress(uint256 x) pure public returns (bytes b) {\n', '\n', '      b = new bytes(20);\n', '      for (uint i = 0; i < 20; i++) {\n', '          b[i] = byte(uint8(x / (2**(8*(31 - i)))));\n', '      }\n', '\n', '      return b;\n', '    }\n', '\n', '\n', ' function bytesToAddress (bytes b) pure public returns (address) {\n', '     uint result = 0;\n', '     for (uint i = b.length-1; i+1 > 0; i--) {\n', '       uint c = uint(b[i]);\n', '       uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\n', '       result += to_inc;\n', '     }\n', '     return address(result);\n', ' }\n', '\n', '\n', '\n', '\n', '}']
