['pragma solidity 0.4.25;\n', '\n', '\n', '/**\n', '* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\n', '* \n', '* Web              - https://333eth.io\n', '* \n', '* Twitter          - https://twitter.com/333eth_io\n', '* \n', '* Telegram_channel - https://t.me/Ethereum333\n', '* \n', '* EN  Telegram_chat: https://t.me/Ethereum333_chat_en\n', '* \n', '* RU  Telegram_chat: https://t.me/Ethereum333_chat_ru\n', '* \n', '* KOR Telegram_chat: https://t.me/Ethereum333_chat_kor\n', '* \n', '* Email:             mailto:support(at sign)333eth.io\n', '* \n', '* \n', '* \n', '* When the timer reaches zero then latest bettor takes the bank. Each bet restart a timer again.\n', '* \n', '* Bet 0.01 ETH - if balance < 100 ETH\n', '* Bet 0.02 ETH - if 100 ETH <= balance <= 200 ETH\n', '* Bet 0.03 ETH - if 200 ETH < balance\n', '* \n', '* The timer turns on for 5 minutes always. \n', '*    \n', '* You need to send such bet`s amounts. If more was sent, then contract will return the difference to the wallet. For example, sending 0.03 ETH system will perceive as a contribution to 0.01 ETH and difference 0.02\n', '* \n', '* The game does not have a fraudulent Ponzi scheme. No fraudulent referral programs.\n', '* \n', '* In the contract of the game realized the refusal of ownership. It is impossible to stop the flow of bets. Bet from smart contracts is prohibited.\n', '* \n', '* Eth distribution:\n', '* 50% paid to the winner.\n', '* 33% is transferred to the next level of the game with the same rules and so on.\n', '* 17% commission.\n', '* \n', '* RECOMMENDED GAS LIMIT: 150000\n', '* \n', '* RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', '*/\n', '\n', '\n', '\n', 'library Percent {\n', '  // Solidity automatically throws when dividing by 0\n', '  struct percent {\n', '    uint num;\n', '    uint den;\n', '  }\n', '  \n', '  // storage\n', '  function mul(percent storage p, uint a) internal view returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    return a*p.num/p.den;\n', '  }\n', '\n', '  function div(percent storage p, uint a) internal view returns (uint) {\n', '    return a/p.num*p.den;\n', '  }\n', '\n', '  function sub(percent storage p, uint a) internal view returns (uint) {\n', '    uint b = mul(p, a);\n', '    if (b >= a) {\n', '      return 0;\n', '    }\n', '    return a - b;\n', '  }\n', '\n', '  function add(percent storage p, uint a) internal view returns (uint) {\n', '    return a + mul(p, a);\n', '  }\n', '\n', '  function toMemory(percent storage p) internal view returns (Percent.percent memory) {\n', '    return Percent.percent(p.num, p.den);\n', '  }\n', '\n', '  // memory \n', '  function mmul(percent memory p, uint a) internal pure returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    return a*p.num/p.den;\n', '  }\n', '\n', '  function mdiv(percent memory p, uint a) internal pure returns (uint) {\n', '    return a/p.num*p.den;\n', '  }\n', '\n', '  function msub(percent memory p, uint a) internal pure returns (uint) {\n', '    uint b = mmul(p, a);\n', '    if (b >= a) {\n', '      return 0;\n', '    }\n', '    return a - b;\n', '  }\n', '\n', '  function madd(percent memory p, uint a) internal pure returns (uint) {\n', '    return a + mmul(p, a);\n', '  }\n', '}\n', '\n', '\n', 'contract Accessibility {\n', '  enum AccessRank { None, PayIn, Manager, Full }\n', '  mapping(address => AccessRank) public admins;\n', '  modifier onlyAdmin(AccessRank  r) {\n', '    require(\n', '      admins[msg.sender] == r || admins[msg.sender] == AccessRank.Full,\n', '      "access denied"\n', '    );\n', '    _;\n', '  }\n', '  event LogProvideAccess(address indexed whom, AccessRank rank, uint when);\n', '\n', '  constructor() public {\n', '    admins[msg.sender] = AccessRank.Full;\n', '    emit LogProvideAccess(msg.sender, AccessRank.Full, now);\n', '  }\n', '\n', '  function provideAccess(address addr, AccessRank rank) public onlyAdmin(AccessRank.Manager) {\n', '    require(rank <= AccessRank.Manager, "cannot to give full access rank");\n', '    if (admins[addr] != rank) {\n', '      admins[addr] = rank;\n', '      emit LogProvideAccess(addr, rank, now);\n', '    }\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', '\n', 'library Timer {\n', '  struct timer {\n', '    uint startup;\n', '    uint duration;\n', '  }\n', '  function start(timer storage t, uint duration) internal {\n', '    t.startup = now;\n', '    t.duration = duration;\n', '  }\n', '\n', '  function timeLeft(timer storage t) internal view returns (uint) {\n', '    if (now >= t.startup + t.duration) {\n', '      return 0;\n', '    }\n', '    return t.startup + t.duration - now;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', 'contract LastHero is Accessibility {\n', '  using Percent for Percent.percent;\n', '  using Timer for Timer.timer;\n', '  \n', '  Percent.percent public bankPercent = Percent.percent(50, 100);\n', '  Percent.percent public nextLevelPercent = Percent.percent(33, 100);\n', '  Percent.percent public adminsPercent = Percent.percent(17, 100);\n', '\n', '  bool public isActive;\n', '  uint public nextLevelBankAmount;\n', '  uint private m_bankAmount;\n', '  uint public jackpot;\n', '  uint public level;\n', '  uint public constant betDuration = 5 minutes;\n', '  address public adminsAddress;\n', '  address public bettor;\n', '  Timer.timer public timer;\n', '\n', '  modifier notFromContract() {\n', '    require(msg.sender == tx.origin, "only externally accounts");\n', '    _;\n', '\n', "    // we can use 'transfer' for all bettors with it - no thx\n", '  }\n', '\n', '  event LogSendExcessOfEther(address indexed addr, uint excess, uint when);\n', '  event LogNewWinner(address indexed addr, uint indexed level, uint amount, uint when);\n', '  event LogNewLevel(uint indexed level, uint bankAmount, uint when);\n', '  event LogNewBet(address indexed addr, uint indexed amount, uint duration, uint indexed level, uint when);\n', '\n', '\n', '  constructor() public {\n', '    adminsAddress = msg.sender;\n', '    timer.duration = uint(-1); // 2^256 - 1\n', '    nextLevel();\n', '  }\n', '\n', '  function() external payable {\n', '    if (admins[msg.sender] == AccessRank.PayIn) {\n', '      if (level <= 3) {\n', '        increaseJackpot();\n', '      } else {\n', '        increaseBank();\n', '      }\n', '      return ;\n', '    }\n', '\n', '    bet();\n', '  }\n', '\n', '  function timeLeft() external view returns(uint duration) {\n', '    duration = timer.timeLeft();\n', '  }\n', '\n', '  function setAdminsAddress(address addr) external onlyAdmin(AccessRank.Full) {\n', '    require(addr != address(0), "require not zero address");\n', '    adminsAddress = addr;\n', '  }\n', '\n', '  function activate() external onlyAdmin(AccessRank.Full) {\n', '    isActive = true;\n', '  }\n', '\n', '  function betAmountAtNow() public view returns(uint amount) {\n', '    uint balance = address(this).balance;\n', '\n', '    // (1) 0.01 ETH - if balance < 100 ETH\n', '    // (2) 0.02 ETH - if 100 ETH <= balance <= 200 ETH\n', '    // (3) 0.03 ETH - if 200 ETH < balance\n', '\n', '    if (balance < 100 ether) {\n', '      amount = 0.01 ether;\n', '    } else if (100 ether <= balance && balance <= 200 ether) {\n', '      amount = 0.02 ether;\n', '    } else {\n', '      amount = 0.03 ether;\n', '    }\n', '  }\n', '  \n', '  function bankAmount() public view returns(uint) {\n', '    if (level <= 3) {\n', '      return jackpot;\n', '    }\n', '    return m_bankAmount;\n', '  }\n', '\n', '  function bet() public payable notFromContract {\n', '    require(isActive, "game is not active");\n', '\n', '    if (timer.timeLeft() == 0) {\n', '      uint win = bankAmount();\n', '      if (bettor.send(win)) {\n', '        emit LogNewWinner(bettor, level, win, now);\n', '      }\n', '\n', '      if (level > 3) {\n', '        m_bankAmount = nextLevelBankAmount;\n', '        nextLevelBankAmount = 0;\n', '      }\n', '\n', '      nextLevel();\n', '    }\n', '\n', '    uint betAmount = betAmountAtNow();\n', '    require(msg.value >= betAmount, "too low msg value");\n', '    timer.start(betDuration);\n', '    bettor = msg.sender;\n', '\n', '    uint excess = msg.value - betAmount;\n', '    if (excess > 0) {\n', '      if (bettor.send(excess)) {\n', '        emit LogSendExcessOfEther(bettor, excess, now);\n', '      }\n', '    }\n', ' \n', '    nextLevelBankAmount += nextLevelPercent.mul(betAmount);\n', '    m_bankAmount += bankPercent.mul(betAmount);\n', '    adminsAddress.send(adminsPercent.mul(betAmount));\n', '\n', '    emit LogNewBet(bettor, betAmount, betDuration, level, now);\n', '  }\n', '\n', '  function increaseJackpot() public payable onlyAdmin(AccessRank.PayIn) {\n', '    require(level <= 3, "jackpots only on first three levels");\n', '    jackpot += msg.value / (4 - level); // add for remained levels\n', '  }\n', '\n', '  function increaseBank() public payable onlyAdmin(AccessRank.PayIn) {\n', '    require(level > 3, "bank amount only above three level");\n', '    m_bankAmount += msg.value;\n', '    if (jackpot > 0) {\n', '      m_bankAmount += jackpot;\n', '      jackpot = 0;\n', '    }\n', '  }\n', '\n', '  function nextLevel() private {\n', '    level++;\n', '    emit LogNewLevel(level, m_bankAmount, now);\n', '  }\n', '}']