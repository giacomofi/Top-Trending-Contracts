['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC223Compliant {\n', '    function tokenFallback(address _from, uint _value, bytes _data) {}\n', '}\n', '\n', 'contract EtheraffleLOT is ERC223Compliant {\n', '    using SafeMath for uint;\n', '\n', '    string    public name;\n', '    string    public symbol;\n', '    bool      public frozen;\n', '    uint8     public decimals;\n', '    address[] public freezers;\n', '    address   public etheraffle;\n', '    uint      public totalSupply;\n', '\n', '    mapping (address => uint) public balances;\n', '    mapping (address => bool) public canFreeze;\n', '\n', '    event LogFrozenStatus(bool status, uint atTime);\n', '    event LogFreezerAddition(address newFreezer, uint atTime);\n', '    event LogFreezerRemoval(address freezerRemoved, uint atTime);\n', '    event LogEtheraffleChange(address prevER, address newER, uint atTime);\n', '    event LogTransfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '\n', '    /**\n', '     * @dev   Modifier function to prepend to methods rendering them only callable\n', '     *        by the Etheraffle MultiSig wallet.\n', '     */\n', '    modifier onlyEtheraffle() {\n', '        require(msg.sender == etheraffle);\n', '        _;\n', '    }\n', '    /**\n', '     * @dev   Modifier function to prepend to methods rendering them only callable\n', '     *        by address approved for freezing.\n', '     */\n', '    modifier onlyFreezers() {\n', '        require(canFreeze[msg.sender]);\n', '        _;\n', '    }\n', '    /**\n', '     * @dev   Modifier function to prepend to methods to render them only callable\n', '     *        when the frozen toggle is false\n', '     */\n', '    modifier onlyIfNotFrozen() {\n', '        require(!frozen);\n', '        _;\n', '    }\n', '    /**\n', '     * @dev   Constructor: Sets the meta data for the token and gives the intial supply to the\n', '     *        Etheraffle ICO.\n', '     *\n', "     * @param _etheraffle   Address of the Etheraffle's multisig wallet, the only\n", '     *                      address via which the frozen/unfrozen state of the\n', '     *                      token transfers can be toggled.\n', '     * @param _supply       Total numner of LOT to mint on contract creation.\n', '\n', '     */\n', '    function EtheraffleLOT(address _etheraffle, uint _supply) {\n', '        freezers.push(_etheraffle);\n', '        name                   = "Etheraffle LOT";\n', '        symbol                 = "LOT";\n', '        decimals               = 6;\n', '        etheraffle             = _etheraffle;\n', '        totalSupply            = _supply * 10 ** uint256(decimals);\n', '        balances[_etheraffle]  = totalSupply;\n', '        canFreeze[_etheraffle] = true;\n', '    }\n', '    /**\n', '     * ERC223 Standard functions:\n', '     *\n', '     * @dev Transfer the specified amount of LOT to the specified address.\n', '     *      Invokes the `tokenFallback` function if the recipient is a contract.\n', '     *      The token transfer fails if the recipient is a contract\n', '     *      but does not implement the `tokenFallback` function\n', '     *      or the fallback function to receive funds.\n', '     *\n', '     * @param _to     Receiver address.\n', '     * @param _value  Amount of LOT to be transferred.\n', '     * @param _data   Transaction metadata.\n', '     */\n', '    function transfer(address _to, uint _value, bytes _data) onlyIfNotFrozen external {\n', '        uint codeLength;\n', '        assembly {\n', '            codeLength := extcodesize(_to)\n', '        }\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to]        = balances[_to].add(_value);\n', '        if(codeLength > 0) {\n', '            ERC223Compliant receiver = ERC223Compliant(_to);\n', '            receiver.tokenFallback(msg.sender, _value, _data);\n', '        }\n', '        LogTransfer(msg.sender, _to, _value, _data);\n', '    }\n', '    /**\n', '     * @dev   Transfer the specified amount of LOT to the specified address.\n', '     *        Standard function transfer similar to ERC20 transfer with no\n', '     *        _data param. Added due to backwards compatibility reasons.\n', '     *\n', '     * @param _to     Receiver address.\n', '     * @param _value  Amount of LOT to be transferred.\n', '     */\n', '    function transfer(address _to, uint _value) onlyIfNotFrozen external {\n', '        uint codeLength;\n', '        bytes memory empty;\n', '        assembly {\n', '            codeLength := extcodesize(_to)\n', '        }\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to]        = balances[_to].add(_value);\n', '        if(codeLength > 0) {\n', '            ERC223Compliant receiver = ERC223Compliant(_to);\n', '            receiver.tokenFallback(msg.sender, _value, empty);\n', '        }\n', '        LogTransfer(msg.sender, _to, _value, empty);\n', '    }\n', '    /**\n', '     * @dev     Returns balance of the `_owner`.\n', '     * @param _owner    The address whose balance will be returned.\n', '     * @return balance  Balance of the `_owner`.\n', '     */\n', '    function balanceOf(address _owner) constant external returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '    /**\n', '     * @dev   Change the frozen status of the LOT token.\n', '     *\n', '     * @param _status   Desired status of the frozen bool\n', '     */\n', '    function setFrozen(bool _status) external onlyFreezers returns (bool) {\n', '        frozen = _status;\n', '        LogFrozenStatus(frozen, now);\n', '        return frozen;\n', '    }\n', '    /**\n', '     * @dev     Allow addition of freezers to allow future contracts to\n', '     *          use the role.\n', '     *\n', '     * @param _new  New freezer address.\n', '     */\n', '    function addFreezer(address _new) external onlyEtheraffle {\n', '        freezers.push(_new);\n', '        canFreeze[_new] = true;\n', '        LogFreezerAddition(_new, now);\n', '    }\n', '    /**\n', '     * @dev     Remove a freezer should they no longer require or need the\n', '     *          the privilege.\n', '     *\n', '     * @param _freezer    The desired address to be removed.\n', '     */\n', '    function removeFreezer(address _freezer) external onlyEtheraffle {\n', '        require(canFreeze[_freezer]);\n', '        canFreeze[_freezer] = false;\n', '        for(uint i = 0; i < freezers.length - 1; i++)\n', '            if(freezers[i] == _freezer) {\n', '                freezers[i] = freezers[freezers.length - 1];\n', '                break;\n', '            }\n', '        freezers.length--;\n', '        LogFreezerRemoval(_freezer, now);\n', '    }\n', '    /**\n', '     * @dev   Allow changing of contract ownership ready for future upgrades/\n', '     *        changes in management structure.\n', '     *\n', '     * @param _new  New owner/controller address.\n', '     */\n', '    function setEtheraffle(address _new) external onlyEtheraffle {\n', '        LogEtheraffleChange(etheraffle, _new, now);\n', '        etheraffle = _new;\n', '    }\n', '    /**\n', '     * @dev   Fallback in case of accidental ether transfer\n', '     */\n', '    function () external payable {\n', '        revert();\n', '    }\n', '    /**\n', '     * @dev   Housekeeping- called in the event this contract is no\n', '     *        longer needed, after a LOT upgrade for example. Deletes\n', '     *        the code from the blockchain. Only callable by the\n', '     *        Etheraffle address.\n', '     */\n', '    function selfDestruct() external onlyEtheraffle {\n', '        require(frozen);\n', '        selfdestruct(etheraffle);\n', '    }\n', '}']