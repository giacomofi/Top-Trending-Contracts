['/*\n', 'file:   depositoffer.sol\n', 'ver:    0.1.2\n', 'author: Chris Kwan\n', 'date:   28-OCT-2017/11-March-2018/2-April-2018\n', 'email:  ecorpnu AT gmail.com\n', '\n', 'A collated contract set for a token sale specific to the requirments of\n', 'Depositoffer (DOT) token product.\n', '\n', 'This software is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \n', 'See MIT Licence for further details.\n', '<https://opensource.org/licenses/MIT>.\n', '\n', '*/\n', '\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', '/*-----------------------------------------------------------------------------\\\n', '\n', ' depositoffer token sale configuration\n', '\n', '\\*----------------------------------------------------------------------------*/\n', '\n', '// Contains token sale parameters\n', 'contract depositofferTokenConfig\n', '{\n', '    // ERC20 trade name and symbol\n', '    string public           name            = "USPat7376612 depositoffer";\n', '    string public           symbol          = "DO";\n', '\n', '    // Owner has power to abort, discount addresses, sweep successful funds,\n', '    // change owner, sweep alien tokens.\n', '    address public          owner           = 0xB353cF41A0CAa38D6597A7a1337debf0b09dd8ae; // Primary address checksummed\n', '    \n', '    // Fund wallet should also be audited prior to deployment\n', '    // NOTE: Must be checksummed address!\n', '    //address public          fundWallet      = 0xE4Be3157DBD71Acd7Ad5667db00AA111C0088195; // multiSig address checksummed\n', '     address public           fundWallet      = 0x46FF7006F8EA5AD7570A84D7BE0ed78224D3ab5e; // main\n', '    //address public          fundWallet = 0x0f097fA3Dc319C5ec299eA33F941744fC5ccE3ec; //ropster test\n', '    \n', '    //you cannot use regular address, you need to create a contract wallet and need to make it checkedsummed search net  \n', '    \n', '    // Tokens awarded per USD contributed\n', '    uint public constant    TOKENS_PER_USD  = 2;\n', '\n', '    // Ether market price in USD\n', '    uint public constant    USD_PER_ETH     = 380; // approx 7 day average High Low as at 29th OCT 2017\n', '    \n', '    // Minimum and maximum target in USD\n', '    uint public constant    MIN_USD_FUND    = 1;  // $1\n', '    uint public constant    MAX_USD_FUND    = 2000000; // $2 mio\n', '    \n', '    // Non-KYC contribution limit in USD\n', '    uint public constant    KYC_USD_LMT     = 50000;\n', '    \n', '    // There will be exactly 4000000 tokens regardless of number sold\n', '    // Unsold tokens are put given to the Founder on Trust to fund operations of the Project\n', '    uint public constant    MAX_TOKENS      = 4000000; // 4 mio\n', '    \n', '    // Funding begins on 30th OCT 2017\n', '    \n', '    //uint public constant    START_DATE      = 1509318001; // 30.10.2017 10 AM and 1 Sec Sydney Time\n', '      uint public constant    START_DATE      = 1520776337; // Monday March 12, 2018 00:52:17 (am) in time zone Australia/Sydney (AEDT)\n', '      \n', '    // Period for fundraising\n', '    uint public constant    FUNDING_PERIOD  = 180 days;\n', '}\n', '\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', 'contract ReentryProtected\n', '{\n', '    // The reentry protection state mutex.\n', '    bool __reMutex;\n', '\n', '    // Sets and resets mutex in order to block functin reentry\n', '    modifier preventReentry() {\n', '        require(!__reMutex);\n', '        __reMutex = true;\n', '        _;\n', '        delete __reMutex;\n', '    }\n', '\n', '    // Blocks function entry if mutex is set\n', '    modifier noReentry() {\n', '        require(!__reMutex);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract ERC20Token\n', '{\n', '    using SafeMath for uint;\n', '\n', '/* Constants */\n', '\n', '    // none\n', '    \n', '/* State variable */\n', '\n', '    /// @return The Total supply of tokens\n', '    uint public totalSupply;\n', '    \n', '    /// @return Token symbol\n', '    string public symbol;\n', '    \n', '    // Token ownership mapping\n', '    mapping (address => uint) balances;\n', '    \n', '    // Allowances mapping\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '/* Events */\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(\n', '        address indexed _from,\n', '        address indexed _to,\n', '        uint256 _amount);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _amount) is called.\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _spender,\n', '        uint256 _amount);\n', '\n', '/* Modifiers */\n', '\n', '    // none\n', '    \n', '/* Functions */\n', '\n', '    // Using an explicit getter allows for function overloading    \n', '    function balanceOf(address _addr)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return balances[_addr];\n', '    }\n', '    \n', '    // Using an explicit getter allows for function overloading    \n', '    function allowance(address _owner, address _spender)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _amount)\n', '        public\n', '        returns (bool)\n', '    {\n', '        return xfer(msg.sender, _to, _amount);\n', '    }\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _amount)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(_amount <= allowed[_from][msg.sender]);\n', '        \n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        return xfer(_from, _to, _amount);\n', '    }\n', '\n', '    // Process a transfer internally.\n', '    function xfer(address _from, address _to, uint _amount)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        require(_amount <= balances[_from]);\n', '\n', '        Transfer(_from, _to, _amount);\n', '        \n', '        // avoid wasting gas on 0 token transfers\n', '        if(_amount == 0) return true;\n', '        \n', '        balances[_from] = balances[_from].sub(_amount);\n', '        balances[_to]   = balances[_to].add(_amount);\n', '        \n', '        return true;\n', '    }\n', '\n', '    // Approves a third-party spender\n', '    function approve(address _spender, uint256 _amount)\n', '        public\n', '        returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '\n', '/*-----------------------------------------------------------------------------\\\n', '\n', '## Conditional Entry Table\n', '\n', 'Functions must throw on F conditions\n', '\n', 'Conditional Entry Table (functions must throw on F conditions)\n', '\n', 'renetry prevention on all public mutating functions\n', 'Reentry mutex set in moveFundsToWallet(), refund()\n', '\n', '|function                |<START_DATE|<END_DATE |fundFailed  |fundSucceeded|icoSucceeded\n', '|------------------------|:---------:|:--------:|:----------:|:-----------:|:---------:|\n', '|()                      |KYC        |T         |F           |T            |F          |\n', '|abort()                 |T          |T         |T           |T            |F          |\n', '|proxyPurchase()         |KYC        |T         |F           |T            |F          |\n', '|addKycAddress()         |T          |T         |F           |T            |T          |\n', '|finaliseICO()           |F          |F         |F           |T            |T          |\n', '|refund()                |F          |F         |T           |F            |F          |\n', '|transfer()              |F          |F         |F           |F            |T          |\n', '|transferFrom()          |F          |F         |F           |F            |T          |\n', '|approve()               |F          |F         |F           |F            |T          |\n', '|changeOwner()           |T          |T         |T           |T            |T          |\n', '|acceptOwnership()       |T          |T         |T           |T            |T          |\n', '|changedeposito()          |T          |T         |T           |T            |T          |\n', '|destroy()               |F          |F         |!__abortFuse|F            |F          |\n', '|transferAnyERC20Tokens()|T          |T         |T           |T            |T          |\n', '\n', '\\*----------------------------------------------------------------------------*/\n', '\n', 'contract depositofferTokenAbstract\n', '{\n', '// TODO comment events\n', '\n', '// Logged when funder exceeds the KYC limit\n', '    event KYCAddress(address indexed _addr, bool indexed _kyc);\n', '\n', '// Logged upon refund\n', '    event Refunded(address indexed _addr, uint indexed _value);\n', '\n', '// Logged when new owner accepts ownership\n', '    event ChangedOwner(address indexed _from, address indexed _to);\n', '    \n', '// Logged when owner initiates a change of ownership\n', '    event ChangeOwnerTo(address indexed _to);\n', '\n', '// Logged when ICO ether funds are transferred to an address\n', '    event FundsTransferred(address indexed _wallet, uint indexed _value);\n', '\n', '\n', '    // This fuse blows upon calling abort() which forces a fail state\n', '    bool public __abortFuse = true;\n', '    \n', '    // Set to true after the fund is swept to the fund wallet, allows token\n', '    // transfers and prevents abort()\n', '    bool public icoSuccessful;\n', '\n', '    // Token conversion factors are calculated with decimal places at parity with ether\n', '    uint8 public constant decimals = 18;\n', '\n', '    // An address authorised to take ownership\n', '    address public newOwner;\n', '    \n', '    // The deposito smart contract address\n', '    address public deposito;\n', '    \n', '    // Total ether raised during funding\n', '    uint public etherRaised;\n', '    \n', '    // Preauthorized tranch discount addresses\n', '    // holder => discount\n', '    mapping (address => bool) public kycAddresses;\n', '    \n', '    // Record of ether paid per address\n', '    mapping (address => uint) public etherContributed;\n', '\n', '    // Return `true` if MIN_FUNDS were raised\n', '    function fundSucceeded() public constant returns (bool);\n', '    \n', '    // Return `true` if MIN_FUNDS were not raised before END_DATE\n', '    function fundFailed() public constant returns (bool);\n', '\n', '    // Returns USD raised for set ETH/USD rate\n', '    function usdRaised() public constant returns (uint);\n', '\n', '    // Returns an amount in eth equivilent to USD at the set rate\n', '    function usdToEth(uint) public constant returns(uint);\n', '    \n', '    // Returns the USD value of ether at the set USD/ETH rate\n', '    function ethToUsd(uint _wei) public constant returns (uint);\n', '\n', '    // Returns token/ether conversion given ether value and address. \n', '    function ethToTokens(uint _eth)\n', '        public constant returns (uint);\n', '\n', '    // Processes a token purchase for a given address\n', '    function proxyPurchase(address _addr) payable returns (bool);\n', '\n', '    // Owner can move funds of successful fund to fundWallet \n', '    function finaliseICO() public returns (bool);\n', '    \n', '    // Registers a discounted address\n', '    function addKycAddress(address _addr, bool _kyc)\n', '        public returns (bool);\n', '\n', '    // Refund on failed or aborted sale \n', '    function refund(address _addr) public returns (bool);\n', '\n', '    // To cancel token sale prior to START_DATE\n', '    function abort() public returns (bool);\n', '    \n', '    // Change the deposito backend contract address\n', '    function changedeposito(address _addr) public returns (bool);\n', '    \n', '    // For owner to salvage tokens sent to contract\n', '    function transferAnyERC20Token(address tokenAddress, uint amount)\n', '        returns (bool);\n', '}\n', '\n', '\n', '/*-----------------------------------------------------------------------------\\\n', '\n', ' depositoffer token implimentation\n', '\n', '\\*----------------------------------------------------------------------------*/\n', '\n', 'contract depositofferToken is \n', '    ReentryProtected,\n', '    ERC20Token,\n', '    depositofferTokenAbstract,\n', '    depositofferTokenConfig\n', '{\n', '    using SafeMath for uint;\n', '\n', '//\n', '// Constants\n', '//\n', '\n', '    // USD to ether conversion factors calculated from `depositofferTokenConfig` constants \n', '    uint public constant TOKENS_PER_ETH = TOKENS_PER_USD * USD_PER_ETH;\n', '    uint public constant MIN_ETH_FUND   = 1 ether * MIN_USD_FUND / USD_PER_ETH;\n', '    uint public constant MAX_ETH_FUND   = 1 ether * MAX_USD_FUND / USD_PER_ETH;\n', '    uint public constant KYC_ETH_LMT    = 1 ether * KYC_USD_LMT  / USD_PER_ETH;\n', '\n', '    // General funding opens LEAD_IN_PERIOD after deployment (timestamps can&#39;t be constant)\n', '    uint public END_DATE  = START_DATE + FUNDING_PERIOD;\n', '\n', '//\n', '// Modifiers\n', '//\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '//\n', '// Functions\n', '//\n', '\n', '    // Constructor\n', '    function depositofferToken()\n', '    {\n', '        // ICO parameters are set in depositofferTSConfig\n', '        // Invalid configuration catching here\n', '        require(bytes(symbol).length > 0);\n', '        require(bytes(name).length > 0);\n', '        require(owner != 0x0);\n', '        require(fundWallet != 0x0);\n', '        require(TOKENS_PER_USD > 0);\n', '        require(USD_PER_ETH > 0);\n', '        require(MIN_USD_FUND > 0);\n', '        require(MAX_USD_FUND > MIN_USD_FUND);\n', '        require(START_DATE > 0);\n', '        require(FUNDING_PERIOD > 0);\n', '        \n', '        // Setup and allocate token supply to 18 decimal places\n', '        totalSupply = MAX_TOKENS * 1e18;\n', '        balances[fundWallet] = totalSupply;\n', '        Transfer(0x0, fundWallet, totalSupply);\n', '    }\n', '    \n', '    // Default function\n', '    function ()\n', '        payable\n', '    {\n', '        // Pass through to purchasing function. Will throw on failed or\n', '        // successful ICO\n', '        proxyPurchase(msg.sender);\n', '    }\n', '\n', '//\n', '// Getters\n', '//\n', '\n', '    // ICO fails if aborted or minimum funds are not raised by the end date\n', '    function fundFailed() public constant returns (bool)\n', '    {\n', '        return !__abortFuse\n', '            || (now > END_DATE && etherRaised < MIN_ETH_FUND);\n', '    }\n', '    \n', '    // Funding succeeds if not aborted, minimum funds are raised before end date\n', '    function fundSucceeded() public constant returns (bool)\n', '    {\n', '        return !fundFailed()\n', '            && etherRaised >= MIN_ETH_FUND;\n', '    }\n', '\n', '    // Returns the USD value of ether at the set USD/ETH rate\n', '    function ethToUsd(uint _wei) public constant returns (uint)\n', '    {\n', '        return USD_PER_ETH.mul(_wei).div(1 ether);\n', '    }\n', '    \n', '    // Returns the ether value of USD at the set USD/ETH rate\n', '    function usdToEth(uint _usd) public constant returns (uint)\n', '    {\n', '        return _usd.mul(1 ether).div(USD_PER_ETH);\n', '    }\n', '    \n', '    // Returns the USD value of ether raised at the set USD/ETH rate\n', '    function usdRaised() public constant returns (uint)\n', '    {\n', '        return ethToUsd(etherRaised);\n', '    }\n', '    \n', '    // Returns the number of tokens for given amount of ether for an address \n', '    function ethToTokens(uint _wei) public constant returns (uint)\n', '    {\n', '        uint usd = ethToUsd(_wei);\n', '        \n', '        // Percent bonus funding tiers for USD funding\n', '        uint bonus = 0;\n', '    //        usd >= 2000000 ? 35 :\n', '    //        usd >= 500000  ? 30 :\n', '    //        usd >= 100000  ? 20 :\n', '    //        usd >= 25000   ? 15 :\n', '    //        usd >= 10000   ? 10 :\n', '    //        usd >= 5000    ? 5  :\n', '    //        usd >= 1000    ? 1  :                    \n', '        \n', '        // using n.2 fixed point decimal for whole number percentage.\n', '        return _wei.mul(TOKENS_PER_ETH).mul(bonus + 100).div(100);\n', '    }\n', '\n', '//\n', '// ICO functions\n', '//\n', '\n', '    // The fundraising can be aborted any time before funds are swept to the\n', '    // fundWallet.\n', '    // This will force a fail state and allow refunds to be collected.\n', '    function abort()\n', '        public\n', '        noReentry\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        require(!icoSuccessful);\n', '        delete __abortFuse;\n', '        return true;\n', '    }\n', '    \n', '    // General addresses can purchase tokens during funding\n', '    function proxyPurchase(address _addr)\n', '        payable\n', '        noReentry\n', '        returns (bool)\n', '    {\n', '        require(!fundFailed());\n', '        require(!icoSuccessful);\n', '        require(now <= END_DATE);\n', '        require(msg.value > 0);\n', '        \n', '        // Non-KYC&#39;ed funders can only contribute up to $10000 after prefund period\n', '        if(!kycAddresses[_addr])\n', '        {\n', '            require(now >= START_DATE);\n', '            require((etherContributed[_addr].add(msg.value)) <= KYC_ETH_LMT);\n', '        }\n', '\n', '        // Get ether to token conversion\n', '        uint tokens = ethToTokens(msg.value);\n', '        \n', '        // transfer tokens from fund wallet\n', '        \n', '        xfer(fundWallet, _addr, tokens);\n', '        \n', '        // Update holder payments\n', '        etherContributed[_addr] = etherContributed[_addr].add(msg.value);\n', '        \n', '        // Update funds raised\n', '        etherRaised = etherRaised.add(msg.value);\n', '        \n', '        // Bail if this pushes the fund over the USD cap or Token cap\n', '        require(etherRaised <= MAX_ETH_FUND);\n', '\n', '        return true;\n', '    }\n', '    \n', '    // Owner can KYC (or revoke) addresses until close of funding\n', '    function addKycAddress(address _addr, bool _kyc)\n', '    public\n', '        noReentry\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '       require(!fundFailed());\n', '\n', '        kycAddresses[_addr] = _kyc;\n', '        KYCAddress(_addr, _kyc);\n', '      return true;\n', '    }\n', '    \n', '    // Owner can sweep a successful funding to the fundWallet\n', '    // Contract can be aborted up until this action.\n', '    // Effective once but can be called multiple time to withdraw edge case\n', '    // funds recieved by contract which can selfdestruct to this address\n', ' \n', '    \n', '    function finaliseICO()\n', '        public\n', '        onlyOwner\n', '        preventReentry()\n', '        returns (bool)\n', '    {\n', '        require(fundSucceeded());\n', '\n', '        icoSuccessful = true;\n', '\n', '        FundsTransferred(fundWallet, this.balance);\n', '        fundWallet.transfer(this.balance);\n', '        return true;\n', '    }\n', '    \n', '    // Refunds can be claimed from a failed ICO\n', '    function refund(address _addr)\n', '        public\n', '        preventReentry()\n', '        returns (bool)\n', '    {\n', '        require(fundFailed());\n', '        \n', '        uint value = etherContributed[_addr];\n', '\n', '        // Transfer tokens back to origin\n', '        // (Not really necessary but looking for graceful exit)\n', '        xfer(_addr, fundWallet, balances[_addr]);\n', '\n', '        // garbage collect\n', '        delete etherContributed[_addr];\n', '        delete kycAddresses[_addr];\n', '        \n', '        Refunded(_addr, value);\n', '        if (value > 0) {\n', '            _addr.transfer(value);\n', '        }\n', '        return true;\n', '    }\n', '\n', '//\n', '// ERC20 overloaded functions\n', '//\n', '\n', '    function transfer(address _to, uint _amount)\n', '        public\n', '        preventReentry\n', '        returns (bool)\n', '    {\n', '        // ICO must be successful\n', '        require(icoSuccessful);\n', '        super.transfer(_to, _amount);\n', '\n', '        if (_to == deposito)\n', '            // Notify the deposito contract it has been sent tokens\n', '            require(Notify(deposito).notify(msg.sender, _amount));\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _amount)\n', '        public\n', '        preventReentry\n', '        returns (bool)\n', '    {\n', '        // ICO must be successful\n', '        require(icoSuccessful);\n', '        super.transferFrom(_from, _to, _amount);\n', '\n', '        if (_to == deposito)\n', '            // Notify the deposito contract it has been sent tokens\n', '            require(Notify(deposito).notify(msg.sender, _amount));\n', '        return true;\n', '    }\n', '    \n', '    function approve(address _spender, uint _amount)\n', '        public\n', '        noReentry\n', '        returns (bool)\n', '    {\n', '        // ICO must be successful\n', '        require(icoSuccessful);\n', '        super.approve(_spender, _amount);\n', '        return true;\n', '    }\n', '\n', '//\n', '// Contract managment functions\n', '//\n', '\n', '    // To initiate an ownership change\n', '    function changeOwner(address _newOwner)\n', '        public\n', '        noReentry\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        ChangeOwnerTo(_newOwner);\n', '        newOwner = _newOwner;\n', '        return true;\n', '    }\n', '\n', '    // To accept ownership. Required to prove new address can call the contract.\n', '    function acceptOwnership()\n', '        public\n', '        noReentry\n', '        returns (bool)\n', '    {\n', '        require(msg.sender == newOwner);\n', '        ChangedOwner(owner, newOwner);\n', '        owner = newOwner;\n', '        return true;\n', '    }\n', '\n', '    // Change the address of the deposito contract address. The contract\n', '    // must impliment the `Notify` interface.\n', '    function changedeposito(address _addr)\n', '        public\n', '        noReentry\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        deposito = _addr;\n', '        return true;\n', '    }\n', '    \n', '    // The contract can be selfdestructed after abort and ether balance is 0.\n', '    function destroy()\n', '        public\n', '        noReentry\n', '        onlyOwner\n', '    {\n', '        require(!__abortFuse);\n', '        require(this.balance == 0);\n', '        selfdestruct(owner);\n', '    }\n', '    \n', '    // Owner can salvage ANYTYPE ERC20 tokens that may have been sent to the account by accident \n', '    function transferAnyERC20Token(address tokenAddress, uint amount)\n', '        public\n', '        onlyOwner\n', '        preventReentry\n', '        returns (bool) \n', '    {\n', '        require(ERC20Token(tokenAddress).transfer(owner, amount));\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'interface Notify\n', '{\n', '    event Notified(address indexed _from, uint indexed _amount);\n', '    \n', '    function notify(address _from, uint _amount) public returns (bool);\n', '}\n', '\n', '\n', 'contract depositoTest is Notify\n', '{\n', '    address public dot;\n', '    \n', '    function setdot(address _addr) { dot = _addr; }\n', '    \n', '    function notify(address _from, uint _amount) public returns (bool)\n', '    {\n', '        require(msg.sender == dot);\n', '        Notified(_from, _amount);\n', '        return true;\n', '    }\n', '}']
['/*\n', 'file:   depositoffer.sol\n', 'ver:    0.1.2\n', 'author: Chris Kwan\n', 'date:   28-OCT-2017/11-March-2018/2-April-2018\n', 'email:  ecorpnu AT gmail.com\n', '\n', 'A collated contract set for a token sale specific to the requirments of\n', 'Depositoffer (DOT) token product.\n', '\n', 'This software is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \n', 'See MIT Licence for further details.\n', '<https://opensource.org/licenses/MIT>.\n', '\n', '*/\n', '\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', '/*-----------------------------------------------------------------------------\\\n', '\n', ' depositoffer token sale configuration\n', '\n', '\\*----------------------------------------------------------------------------*/\n', '\n', '// Contains token sale parameters\n', 'contract depositofferTokenConfig\n', '{\n', '    // ERC20 trade name and symbol\n', '    string public           name            = "USPat7376612 depositoffer";\n', '    string public           symbol          = "DO";\n', '\n', '    // Owner has power to abort, discount addresses, sweep successful funds,\n', '    // change owner, sweep alien tokens.\n', '    address public          owner           = 0xB353cF41A0CAa38D6597A7a1337debf0b09dd8ae; // Primary address checksummed\n', '    \n', '    // Fund wallet should also be audited prior to deployment\n', '    // NOTE: Must be checksummed address!\n', '    //address public          fundWallet      = 0xE4Be3157DBD71Acd7Ad5667db00AA111C0088195; // multiSig address checksummed\n', '     address public           fundWallet      = 0x46FF7006F8EA5AD7570A84D7BE0ed78224D3ab5e; // main\n', '    //address public          fundWallet = 0x0f097fA3Dc319C5ec299eA33F941744fC5ccE3ec; //ropster test\n', '    \n', '    //you cannot use regular address, you need to create a contract wallet and need to make it checkedsummed search net  \n', '    \n', '    // Tokens awarded per USD contributed\n', '    uint public constant    TOKENS_PER_USD  = 2;\n', '\n', '    // Ether market price in USD\n', '    uint public constant    USD_PER_ETH     = 380; // approx 7 day average High Low as at 29th OCT 2017\n', '    \n', '    // Minimum and maximum target in USD\n', '    uint public constant    MIN_USD_FUND    = 1;  // $1\n', '    uint public constant    MAX_USD_FUND    = 2000000; // $2 mio\n', '    \n', '    // Non-KYC contribution limit in USD\n', '    uint public constant    KYC_USD_LMT     = 50000;\n', '    \n', '    // There will be exactly 4000000 tokens regardless of number sold\n', '    // Unsold tokens are put given to the Founder on Trust to fund operations of the Project\n', '    uint public constant    MAX_TOKENS      = 4000000; // 4 mio\n', '    \n', '    // Funding begins on 30th OCT 2017\n', '    \n', '    //uint public constant    START_DATE      = 1509318001; // 30.10.2017 10 AM and 1 Sec Sydney Time\n', '      uint public constant    START_DATE      = 1520776337; // Monday March 12, 2018 00:52:17 (am) in time zone Australia/Sydney (AEDT)\n', '      \n', '    // Period for fundraising\n', '    uint public constant    FUNDING_PERIOD  = 180 days;\n', '}\n', '\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', 'contract ReentryProtected\n', '{\n', '    // The reentry protection state mutex.\n', '    bool __reMutex;\n', '\n', '    // Sets and resets mutex in order to block functin reentry\n', '    modifier preventReentry() {\n', '        require(!__reMutex);\n', '        __reMutex = true;\n', '        _;\n', '        delete __reMutex;\n', '    }\n', '\n', '    // Blocks function entry if mutex is set\n', '    modifier noReentry() {\n', '        require(!__reMutex);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract ERC20Token\n', '{\n', '    using SafeMath for uint;\n', '\n', '/* Constants */\n', '\n', '    // none\n', '    \n', '/* State variable */\n', '\n', '    /// @return The Total supply of tokens\n', '    uint public totalSupply;\n', '    \n', '    /// @return Token symbol\n', '    string public symbol;\n', '    \n', '    // Token ownership mapping\n', '    mapping (address => uint) balances;\n', '    \n', '    // Allowances mapping\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '/* Events */\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(\n', '        address indexed _from,\n', '        address indexed _to,\n', '        uint256 _amount);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _amount) is called.\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _spender,\n', '        uint256 _amount);\n', '\n', '/* Modifiers */\n', '\n', '    // none\n', '    \n', '/* Functions */\n', '\n', '    // Using an explicit getter allows for function overloading    \n', '    function balanceOf(address _addr)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return balances[_addr];\n', '    }\n', '    \n', '    // Using an explicit getter allows for function overloading    \n', '    function allowance(address _owner, address _spender)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _amount)\n', '        public\n', '        returns (bool)\n', '    {\n', '        return xfer(msg.sender, _to, _amount);\n', '    }\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _amount)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(_amount <= allowed[_from][msg.sender]);\n', '        \n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        return xfer(_from, _to, _amount);\n', '    }\n', '\n', '    // Process a transfer internally.\n', '    function xfer(address _from, address _to, uint _amount)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        require(_amount <= balances[_from]);\n', '\n', '        Transfer(_from, _to, _amount);\n', '        \n', '        // avoid wasting gas on 0 token transfers\n', '        if(_amount == 0) return true;\n', '        \n', '        balances[_from] = balances[_from].sub(_amount);\n', '        balances[_to]   = balances[_to].add(_amount);\n', '        \n', '        return true;\n', '    }\n', '\n', '    // Approves a third-party spender\n', '    function approve(address _spender, uint256 _amount)\n', '        public\n', '        returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '\n', '/*-----------------------------------------------------------------------------\\\n', '\n', '## Conditional Entry Table\n', '\n', 'Functions must throw on F conditions\n', '\n', 'Conditional Entry Table (functions must throw on F conditions)\n', '\n', 'renetry prevention on all public mutating functions\n', 'Reentry mutex set in moveFundsToWallet(), refund()\n', '\n', '|function                |<START_DATE|<END_DATE |fundFailed  |fundSucceeded|icoSucceeded\n', '|------------------------|:---------:|:--------:|:----------:|:-----------:|:---------:|\n', '|()                      |KYC        |T         |F           |T            |F          |\n', '|abort()                 |T          |T         |T           |T            |F          |\n', '|proxyPurchase()         |KYC        |T         |F           |T            |F          |\n', '|addKycAddress()         |T          |T         |F           |T            |T          |\n', '|finaliseICO()           |F          |F         |F           |T            |T          |\n', '|refund()                |F          |F         |T           |F            |F          |\n', '|transfer()              |F          |F         |F           |F            |T          |\n', '|transferFrom()          |F          |F         |F           |F            |T          |\n', '|approve()               |F          |F         |F           |F            |T          |\n', '|changeOwner()           |T          |T         |T           |T            |T          |\n', '|acceptOwnership()       |T          |T         |T           |T            |T          |\n', '|changedeposito()          |T          |T         |T           |T            |T          |\n', '|destroy()               |F          |F         |!__abortFuse|F            |F          |\n', '|transferAnyERC20Tokens()|T          |T         |T           |T            |T          |\n', '\n', '\\*----------------------------------------------------------------------------*/\n', '\n', 'contract depositofferTokenAbstract\n', '{\n', '// TODO comment events\n', '\n', '// Logged when funder exceeds the KYC limit\n', '    event KYCAddress(address indexed _addr, bool indexed _kyc);\n', '\n', '// Logged upon refund\n', '    event Refunded(address indexed _addr, uint indexed _value);\n', '\n', '// Logged when new owner accepts ownership\n', '    event ChangedOwner(address indexed _from, address indexed _to);\n', '    \n', '// Logged when owner initiates a change of ownership\n', '    event ChangeOwnerTo(address indexed _to);\n', '\n', '// Logged when ICO ether funds are transferred to an address\n', '    event FundsTransferred(address indexed _wallet, uint indexed _value);\n', '\n', '\n', '    // This fuse blows upon calling abort() which forces a fail state\n', '    bool public __abortFuse = true;\n', '    \n', '    // Set to true after the fund is swept to the fund wallet, allows token\n', '    // transfers and prevents abort()\n', '    bool public icoSuccessful;\n', '\n', '    // Token conversion factors are calculated with decimal places at parity with ether\n', '    uint8 public constant decimals = 18;\n', '\n', '    // An address authorised to take ownership\n', '    address public newOwner;\n', '    \n', '    // The deposito smart contract address\n', '    address public deposito;\n', '    \n', '    // Total ether raised during funding\n', '    uint public etherRaised;\n', '    \n', '    // Preauthorized tranch discount addresses\n', '    // holder => discount\n', '    mapping (address => bool) public kycAddresses;\n', '    \n', '    // Record of ether paid per address\n', '    mapping (address => uint) public etherContributed;\n', '\n', '    // Return `true` if MIN_FUNDS were raised\n', '    function fundSucceeded() public constant returns (bool);\n', '    \n', '    // Return `true` if MIN_FUNDS were not raised before END_DATE\n', '    function fundFailed() public constant returns (bool);\n', '\n', '    // Returns USD raised for set ETH/USD rate\n', '    function usdRaised() public constant returns (uint);\n', '\n', '    // Returns an amount in eth equivilent to USD at the set rate\n', '    function usdToEth(uint) public constant returns(uint);\n', '    \n', '    // Returns the USD value of ether at the set USD/ETH rate\n', '    function ethToUsd(uint _wei) public constant returns (uint);\n', '\n', '    // Returns token/ether conversion given ether value and address. \n', '    function ethToTokens(uint _eth)\n', '        public constant returns (uint);\n', '\n', '    // Processes a token purchase for a given address\n', '    function proxyPurchase(address _addr) payable returns (bool);\n', '\n', '    // Owner can move funds of successful fund to fundWallet \n', '    function finaliseICO() public returns (bool);\n', '    \n', '    // Registers a discounted address\n', '    function addKycAddress(address _addr, bool _kyc)\n', '        public returns (bool);\n', '\n', '    // Refund on failed or aborted sale \n', '    function refund(address _addr) public returns (bool);\n', '\n', '    // To cancel token sale prior to START_DATE\n', '    function abort() public returns (bool);\n', '    \n', '    // Change the deposito backend contract address\n', '    function changedeposito(address _addr) public returns (bool);\n', '    \n', '    // For owner to salvage tokens sent to contract\n', '    function transferAnyERC20Token(address tokenAddress, uint amount)\n', '        returns (bool);\n', '}\n', '\n', '\n', '/*-----------------------------------------------------------------------------\\\n', '\n', ' depositoffer token implimentation\n', '\n', '\\*----------------------------------------------------------------------------*/\n', '\n', 'contract depositofferToken is \n', '    ReentryProtected,\n', '    ERC20Token,\n', '    depositofferTokenAbstract,\n', '    depositofferTokenConfig\n', '{\n', '    using SafeMath for uint;\n', '\n', '//\n', '// Constants\n', '//\n', '\n', '    // USD to ether conversion factors calculated from `depositofferTokenConfig` constants \n', '    uint public constant TOKENS_PER_ETH = TOKENS_PER_USD * USD_PER_ETH;\n', '    uint public constant MIN_ETH_FUND   = 1 ether * MIN_USD_FUND / USD_PER_ETH;\n', '    uint public constant MAX_ETH_FUND   = 1 ether * MAX_USD_FUND / USD_PER_ETH;\n', '    uint public constant KYC_ETH_LMT    = 1 ether * KYC_USD_LMT  / USD_PER_ETH;\n', '\n', "    // General funding opens LEAD_IN_PERIOD after deployment (timestamps can't be constant)\n", '    uint public END_DATE  = START_DATE + FUNDING_PERIOD;\n', '\n', '//\n', '// Modifiers\n', '//\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '//\n', '// Functions\n', '//\n', '\n', '    // Constructor\n', '    function depositofferToken()\n', '    {\n', '        // ICO parameters are set in depositofferTSConfig\n', '        // Invalid configuration catching here\n', '        require(bytes(symbol).length > 0);\n', '        require(bytes(name).length > 0);\n', '        require(owner != 0x0);\n', '        require(fundWallet != 0x0);\n', '        require(TOKENS_PER_USD > 0);\n', '        require(USD_PER_ETH > 0);\n', '        require(MIN_USD_FUND > 0);\n', '        require(MAX_USD_FUND > MIN_USD_FUND);\n', '        require(START_DATE > 0);\n', '        require(FUNDING_PERIOD > 0);\n', '        \n', '        // Setup and allocate token supply to 18 decimal places\n', '        totalSupply = MAX_TOKENS * 1e18;\n', '        balances[fundWallet] = totalSupply;\n', '        Transfer(0x0, fundWallet, totalSupply);\n', '    }\n', '    \n', '    // Default function\n', '    function ()\n', '        payable\n', '    {\n', '        // Pass through to purchasing function. Will throw on failed or\n', '        // successful ICO\n', '        proxyPurchase(msg.sender);\n', '    }\n', '\n', '//\n', '// Getters\n', '//\n', '\n', '    // ICO fails if aborted or minimum funds are not raised by the end date\n', '    function fundFailed() public constant returns (bool)\n', '    {\n', '        return !__abortFuse\n', '            || (now > END_DATE && etherRaised < MIN_ETH_FUND);\n', '    }\n', '    \n', '    // Funding succeeds if not aborted, minimum funds are raised before end date\n', '    function fundSucceeded() public constant returns (bool)\n', '    {\n', '        return !fundFailed()\n', '            && etherRaised >= MIN_ETH_FUND;\n', '    }\n', '\n', '    // Returns the USD value of ether at the set USD/ETH rate\n', '    function ethToUsd(uint _wei) public constant returns (uint)\n', '    {\n', '        return USD_PER_ETH.mul(_wei).div(1 ether);\n', '    }\n', '    \n', '    // Returns the ether value of USD at the set USD/ETH rate\n', '    function usdToEth(uint _usd) public constant returns (uint)\n', '    {\n', '        return _usd.mul(1 ether).div(USD_PER_ETH);\n', '    }\n', '    \n', '    // Returns the USD value of ether raised at the set USD/ETH rate\n', '    function usdRaised() public constant returns (uint)\n', '    {\n', '        return ethToUsd(etherRaised);\n', '    }\n', '    \n', '    // Returns the number of tokens for given amount of ether for an address \n', '    function ethToTokens(uint _wei) public constant returns (uint)\n', '    {\n', '        uint usd = ethToUsd(_wei);\n', '        \n', '        // Percent bonus funding tiers for USD funding\n', '        uint bonus = 0;\n', '    //        usd >= 2000000 ? 35 :\n', '    //        usd >= 500000  ? 30 :\n', '    //        usd >= 100000  ? 20 :\n', '    //        usd >= 25000   ? 15 :\n', '    //        usd >= 10000   ? 10 :\n', '    //        usd >= 5000    ? 5  :\n', '    //        usd >= 1000    ? 1  :                    \n', '        \n', '        // using n.2 fixed point decimal for whole number percentage.\n', '        return _wei.mul(TOKENS_PER_ETH).mul(bonus + 100).div(100);\n', '    }\n', '\n', '//\n', '// ICO functions\n', '//\n', '\n', '    // The fundraising can be aborted any time before funds are swept to the\n', '    // fundWallet.\n', '    // This will force a fail state and allow refunds to be collected.\n', '    function abort()\n', '        public\n', '        noReentry\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        require(!icoSuccessful);\n', '        delete __abortFuse;\n', '        return true;\n', '    }\n', '    \n', '    // General addresses can purchase tokens during funding\n', '    function proxyPurchase(address _addr)\n', '        payable\n', '        noReentry\n', '        returns (bool)\n', '    {\n', '        require(!fundFailed());\n', '        require(!icoSuccessful);\n', '        require(now <= END_DATE);\n', '        require(msg.value > 0);\n', '        \n', "        // Non-KYC'ed funders can only contribute up to $10000 after prefund period\n", '        if(!kycAddresses[_addr])\n', '        {\n', '            require(now >= START_DATE);\n', '            require((etherContributed[_addr].add(msg.value)) <= KYC_ETH_LMT);\n', '        }\n', '\n', '        // Get ether to token conversion\n', '        uint tokens = ethToTokens(msg.value);\n', '        \n', '        // transfer tokens from fund wallet\n', '        \n', '        xfer(fundWallet, _addr, tokens);\n', '        \n', '        // Update holder payments\n', '        etherContributed[_addr] = etherContributed[_addr].add(msg.value);\n', '        \n', '        // Update funds raised\n', '        etherRaised = etherRaised.add(msg.value);\n', '        \n', '        // Bail if this pushes the fund over the USD cap or Token cap\n', '        require(etherRaised <= MAX_ETH_FUND);\n', '\n', '        return true;\n', '    }\n', '    \n', '    // Owner can KYC (or revoke) addresses until close of funding\n', '    function addKycAddress(address _addr, bool _kyc)\n', '    public\n', '        noReentry\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '       require(!fundFailed());\n', '\n', '        kycAddresses[_addr] = _kyc;\n', '        KYCAddress(_addr, _kyc);\n', '      return true;\n', '    }\n', '    \n', '    // Owner can sweep a successful funding to the fundWallet\n', '    // Contract can be aborted up until this action.\n', '    // Effective once but can be called multiple time to withdraw edge case\n', '    // funds recieved by contract which can selfdestruct to this address\n', ' \n', '    \n', '    function finaliseICO()\n', '        public\n', '        onlyOwner\n', '        preventReentry()\n', '        returns (bool)\n', '    {\n', '        require(fundSucceeded());\n', '\n', '        icoSuccessful = true;\n', '\n', '        FundsTransferred(fundWallet, this.balance);\n', '        fundWallet.transfer(this.balance);\n', '        return true;\n', '    }\n', '    \n', '    // Refunds can be claimed from a failed ICO\n', '    function refund(address _addr)\n', '        public\n', '        preventReentry()\n', '        returns (bool)\n', '    {\n', '        require(fundFailed());\n', '        \n', '        uint value = etherContributed[_addr];\n', '\n', '        // Transfer tokens back to origin\n', '        // (Not really necessary but looking for graceful exit)\n', '        xfer(_addr, fundWallet, balances[_addr]);\n', '\n', '        // garbage collect\n', '        delete etherContributed[_addr];\n', '        delete kycAddresses[_addr];\n', '        \n', '        Refunded(_addr, value);\n', '        if (value > 0) {\n', '            _addr.transfer(value);\n', '        }\n', '        return true;\n', '    }\n', '\n', '//\n', '// ERC20 overloaded functions\n', '//\n', '\n', '    function transfer(address _to, uint _amount)\n', '        public\n', '        preventReentry\n', '        returns (bool)\n', '    {\n', '        // ICO must be successful\n', '        require(icoSuccessful);\n', '        super.transfer(_to, _amount);\n', '\n', '        if (_to == deposito)\n', '            // Notify the deposito contract it has been sent tokens\n', '            require(Notify(deposito).notify(msg.sender, _amount));\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _amount)\n', '        public\n', '        preventReentry\n', '        returns (bool)\n', '    {\n', '        // ICO must be successful\n', '        require(icoSuccessful);\n', '        super.transferFrom(_from, _to, _amount);\n', '\n', '        if (_to == deposito)\n', '            // Notify the deposito contract it has been sent tokens\n', '            require(Notify(deposito).notify(msg.sender, _amount));\n', '        return true;\n', '    }\n', '    \n', '    function approve(address _spender, uint _amount)\n', '        public\n', '        noReentry\n', '        returns (bool)\n', '    {\n', '        // ICO must be successful\n', '        require(icoSuccessful);\n', '        super.approve(_spender, _amount);\n', '        return true;\n', '    }\n', '\n', '//\n', '// Contract managment functions\n', '//\n', '\n', '    // To initiate an ownership change\n', '    function changeOwner(address _newOwner)\n', '        public\n', '        noReentry\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        ChangeOwnerTo(_newOwner);\n', '        newOwner = _newOwner;\n', '        return true;\n', '    }\n', '\n', '    // To accept ownership. Required to prove new address can call the contract.\n', '    function acceptOwnership()\n', '        public\n', '        noReentry\n', '        returns (bool)\n', '    {\n', '        require(msg.sender == newOwner);\n', '        ChangedOwner(owner, newOwner);\n', '        owner = newOwner;\n', '        return true;\n', '    }\n', '\n', '    // Change the address of the deposito contract address. The contract\n', '    // must impliment the `Notify` interface.\n', '    function changedeposito(address _addr)\n', '        public\n', '        noReentry\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        deposito = _addr;\n', '        return true;\n', '    }\n', '    \n', '    // The contract can be selfdestructed after abort and ether balance is 0.\n', '    function destroy()\n', '        public\n', '        noReentry\n', '        onlyOwner\n', '    {\n', '        require(!__abortFuse);\n', '        require(this.balance == 0);\n', '        selfdestruct(owner);\n', '    }\n', '    \n', '    // Owner can salvage ANYTYPE ERC20 tokens that may have been sent to the account by accident \n', '    function transferAnyERC20Token(address tokenAddress, uint amount)\n', '        public\n', '        onlyOwner\n', '        preventReentry\n', '        returns (bool) \n', '    {\n', '        require(ERC20Token(tokenAddress).transfer(owner, amount));\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'interface Notify\n', '{\n', '    event Notified(address indexed _from, uint indexed _amount);\n', '    \n', '    function notify(address _from, uint _amount) public returns (bool);\n', '}\n', '\n', '\n', 'contract depositoTest is Notify\n', '{\n', '    address public dot;\n', '    \n', '    function setdot(address _addr) { dot = _addr; }\n', '    \n', '    function notify(address _from, uint _amount) public returns (bool)\n', '    {\n', '        require(msg.sender == dot);\n', '        Notified(_from, _amount);\n', '        return true;\n', '    }\n', '}']
