['pragma solidity ^0.4.20;\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    string public name;\n', '    string public symbol;\n', '    uint32 public decimals;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  function transfer(address _to, uint256 _amount) public returns (bool) {\n', '    uint256 _value = _amount;\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '  \n', '    \n', '\n', '}\n', '\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require( newOwner != address(0) );\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract AthCrowdsaleInterface\n', '{\n', '    function investorsCount() public constant returns( uint256 );\n', '    \n', '    function investorsAddress( uint256 _i ) public constant returns( address );\n', '    \n', '    function investorsInfo( address _a ) public constant returns( uint256, uint256 );\n', '    \n', '    function investorsStockInfo( address _a ) public constant returns( uint256 );\n', '    \n', '    function getOwners(uint8) public constant returns( address );\n', '}\n', ' \n', ' \n', '\n', '\n', 'contract AthTokenBase is Ownable, StandardToken{\n', '    \n', '    address crowdsale;\n', '    AthCrowdsaleInterface crowdsaleInterface;\n', '    \n', '    \n', '    uint256 public redemptionFund = 0;\n', '    uint256 public redemptionFundTotal = 0;\n', '    uint256 public redemptionPrice = 0;\n', '    \n', '    modifier onlyCrowdsale() {\n', '        require(msg.sender == crowdsale);\n', '        _;\n', '    }\n', '    \n', '    function AthTokenBase() public \n', '    {\n', '        name                    = "Ethereum Anonymizer";\n', '        symbol                  = "ATH";\n', '        decimals                = 18;\n', '        totalSupply             = 21000000 ether;\n', '        balances[address(this)] = totalSupply;\n', '    }\n', '    \n', '    \n', '    \n', '    function setCrowdsale( address _a ) public onlyOwner returns( bool )\n', '    {\n', '        crowdsale = _a;\n', '        crowdsaleInterface = AthCrowdsaleInterface( _a );\n', '    }\n', '    \n', '\n', '    function delivery( address _to, uint256 _amount ) public onlyCrowdsale returns( bool )\n', '    {\n', '        require( _to != address(0) );\n', '        require(_amount <= balances[address(this)] );\n', '        balances[address(this)] = balances[address(this)].sub( _amount );\n', '        balances[_to] = balances[_to].add( _amount );\n', '        \n', '        emit Transfer( address(this), _to, _amount );\n', '        \n', '    }\n', '    \n', '    function currentBalance() public constant returns( uint256 )\n', '    {\n', '        return balances[ address(this) ];\n', '    }\n', '    \n', '    function afterIco( uint256 _redemptionPrice ) public onlyCrowdsale returns( bool )\n', '    {\n', '        totalSupply = totalSupply.sub( balances[ address(this) ] );\n', '        balances[address(this)] = 0;\n', '        redemptionPrice = _redemptionPrice;\n', '    }\n', '    \n', '\n', '   \n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Helper{\n', '    function generatePASS1( address ) public pure returns( bytes32 );\n', '    function generatePASS2( bytes32, address ) public pure returns( bytes32 );\n', '    function generatePASS3( bytes32 ) public pure returns( bytes32 );\n', '    function generateNUMERIC(uint) public constant returns( uint );\n', '    function encryptCounter( uint count ) public constant returns( uint );\n', '    function encodeAmount(uint, uint) public constant returns( uint );\n', '    function decodeAmount(uint, uint) public constant returns( uint );\n', '}\n', '\n', '\n', '\n', 'contract AthToken is AthTokenBase{\n', '    \n', '    Helper helper;\n', '    \n', '    \n', '    \n', '    uint256 private _encryptCounter = 1;\n', '    \n', '    uint8 public ethPriceIn  = 98;\n', '    // uint8 public tokenPriceIn  = 98;\n', '    \n', '    uint256 public ransom = 0;\n', '    \n', '    mapping( address => uint256 ) ethBalances;\n', '    mapping( address => mapping( address => uint256 ) ) tokenBalances;\n', '    \n', '    \n', '    struct Invoice{\n', '        address buyer;\n', '        address seller;\n', '        uint256 tokenNumeric;\n', '        uint256 tokens;\n', '        bytes1 state;\n', '        bytes1 method;\n', '        address token;\n', '    }\n', '    \n', '    \n', '    \n', '    uint constant invoicesStackLimit = 50;\n', '    bytes32[50] invoicesStack;\n', '    uint public invoicesStackCount;\n', '    \n', '    \n', '    \n', '    mapping( bytes32 => Invoice ) invoices;\n', '    mapping( address => bytes32 ) buyersPASS1;\n', '    mapping( address => bytes32 ) buyersPASS3;\n', '    mapping( bytes32 => bytes32 ) PASS3toPASS1;\n', '    mapping( bytes32 => bytes32 ) sellersPASS2;\n', '    \n', '    \n', '    \n', '   \n', '   \n', '   function sellAth( uint256 _amount ) public returns( bool )\n', '   {    //investors\n', '      require( redemptionFund >= _amount && redemptionPrice > 0 && crowdsaleInterface.investorsStockInfo( msg.sender ) > 0 );\n', '       \n', '       uint256 tmp =  _amount.mul( redemptionPrice ) ;\n', '       msg.sender.transfer( tmp );\n', '       balances[ msg.sender ] = balances[ msg.sender ].sub( _amount );\n', '       \n', '       redemptionFund = redemptionFund.sub( tmp );\n', '       \n', '      balances[crowdsaleInterface.getOwners( 0 )] = balances[crowdsaleInterface.getOwners( 0 )].add( _amount.div(2) );\n', '      balances[crowdsaleInterface.getOwners( 1 )] = balances[crowdsaleInterface.getOwners( 1 )].add( _amount.div(2) );\n', '   }\n', '   \n', '   \n', '   \n', '   function replenishEth() public payable\n', '   {\n', '    \n', '       uint tmp = msg.value.mul( ethPriceIn ).div( 100 );\n', '       \n', '       ethBalances[msg.sender]+= tmp;\n', '       \n', '       uint256 remainder = msg.value.sub( tmp );\n', '       \n', '       \n', '       if( redemptionFundTotal < totalSupply ){\n', '           \n', '           redemptionFund = redemptionFund.add( remainder );\n', '           redemptionFundTotal = redemptionFundTotal.add( remainder );\n', '           \n', '       } else {\n', '           \n', '           for( uint256 i = 0; i <= crowdsaleInterface.investorsCount() - 1; i++ ){\n', '               crowdsaleInterface.investorsAddress(i).transfer(  remainder.mul( crowdsaleInterface.investorsStockInfo(crowdsaleInterface.investorsAddress(i)) ).div( 200 )  );\n', '           }\n', '           \n', '           crowdsaleInterface.getOwners( 0 ).transfer( remainder.div( 4 ) );\n', '           crowdsaleInterface.getOwners( 1 ).transfer( remainder.div( 4 ) );\n', '           \n', '       }\n', '       \n', '       \n', '       \n', '       \n', '       \n', '   }\n', '   \n', '\n', '   \n', '   function replenishTokens(address _a, uint256 _amount) public\n', '   {\n', '       StandardToken token = StandardToken( _a );\n', '       require( _amount <= token.balanceOf( msg.sender ) );\n', '       token.transferFrom( msg.sender, this, _amount);\n', '       \n', '       tokenBalances[msg.sender][_a] = tokenBalances[msg.sender][_a].add( _amount );\n', '       \n', '   }\n', '   \n', '   function tokenBalance(address _a) public constant returns(uint256)\n', '   {\n', '       return ( tokenBalances[msg.sender][_a] );\n', '   }\n', '   \n', '   function ethBalance(address _a) public constant returns(uint256)\n', '   {\n', '       return ( ethBalances[_a] );\n', '   }\n', '   function ethContractBalance() public constant returns(uint256)\n', '   {\n', '       return address(this).balance;\n', '   }\n', '   function ethBaseBalance(address _a) public constant returns(uint256)\n', '   {\n', '       return ( _a.balance );\n', '   }\n', '   function withdrawEth( uint256 _amount ) public\n', '   {\n', '       require( _amount <= ethBalances[msg.sender] );\n', '       \n', '       ethBalances[msg.sender] = ethBalances[msg.sender].sub( _amount );\n', '       msg.sender.transfer( _amount );\n', '   }\n', '\n', '    function withdrawToken( address _a, uint256 _amount ) public\n', '   {\n', '       require( _amount <= tokenBalances[msg.sender][_a] );\n', '       \n', '       StandardToken token = StandardToken( _a );\n', '       \n', '       tokenBalances[msg.sender][_a] = tokenBalances[msg.sender][_a].sub( _amount );\n', '       token.transfer( msg.sender, _amount );\n', '   }\n', '    \n', '   function setEthPricies(uint8 _in) public onlyOwner\n', '   {\n', '       ethPriceIn  = _in;\n', '   }\n', '    \n', '    \n', '    \n', '    function SELLER_STEP_1_OPEN() public returns( bool )\n', '    {\n', '        address sender = msg.sender;\n', '        \n', '        _encryptCounter = helper.encryptCounter( _encryptCounter );\n', '        \n', '        bytes32 PASS1 = helper.generatePASS1( sender );\n', '        bytes32 PASS3 = helper.generatePASS3( PASS1 );\n', '        \n', '        invoicesStack[invoicesStackCount] = PASS1;\n', '    \n', '        \n', '        invoicesStackCount++;\n', '        if( invoicesStackCount >= invoicesStackLimit ) invoicesStackCount = 0;\n', '        \n', '        invoices[ PASS1 ].seller     = sender;\n', '        invoices[ PASS1 ].state      = 0x1;\n', '        buyersPASS1[sender]          = PASS1;\n', '        buyersPASS3[sender]          = PASS3;\n', '        PASS3toPASS1[PASS3]          = PASS1;\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function SELLER_STEP_2_GET_PASS() public constant returns( bytes32,bytes32 )\n', '    {\n', '        return ( buyersPASS1[msg.sender], buyersPASS3[msg.sender]);\n', '    }\n', '    \n', '\n', '\n', '\n', '\n', '\n', '    \n', '    function SELLER_STEP_4_ACCEPT( bytes32 PASS3 ) public\n', '    {\n', '        require( invoices[ PASS3toPASS1[ PASS3 ] ].seller == msg.sender );\n', '        \n', '        if( invoices[ PASS3toPASS1[ PASS3 ] ].method == 0x1 ) {\n', '            \n', '            balances[msg.sender] = balances[msg.sender].add( invoices[ PASS3toPASS1[ PASS3 ] ].tokens );\n', '            invoices[ PASS3toPASS1[ PASS3 ] ].tokens = 0;\n', '            invoices[ PASS3toPASS1[ PASS3 ] ].state = 0x5;\n', '            \n', '        }\n', '            \n', '        if( invoices[ PASS3toPASS1[ PASS3 ] ].method == 0x2 ) {\n', '            \n', '            msg.sender.transfer( invoices[ PASS3toPASS1[ PASS3 ] ].tokens );\n', '            invoices[ PASS3toPASS1[ PASS3 ] ].tokens = 0;\n', '            invoices[ PASS3toPASS1[ PASS3 ] ].state = 0x5;\n', '            \n', '        }\n', '        \n', '        if( invoices[ PASS3toPASS1[ PASS3 ] ].method == 0x3 ) {\n', '            \n', '            tokenBalances[msg.sender][invoices[ PASS3toPASS1[ PASS3 ] ].token] = tokenBalances[msg.sender][invoices[ PASS3toPASS1[ PASS3 ] ].token].add( invoices[ PASS3toPASS1[ PASS3 ] ].tokens );\n', '            invoices[ PASS3toPASS1[ PASS3 ] ].tokens = 0;\n', '            invoices[ PASS3toPASS1[ PASS3 ] ].state = 0x5;\n', '            \n', '        }\n', '        \n', '        \n', '    }\n', '\n', '    \n', '    function BUYER_STEP_1( bytes32 PASS1 ) public constant returns( bytes32 )\n', '    {\n', '        return helper.generatePASS2( PASS1, msg.sender );\n', '    }\n', '    \n', '    \n', '    function BUYER_STEP_2( bytes32 PASS2 ) public\n', '    {\n', '        address buyer = msg.sender;\n', '        bool find = false;\n', '        \n', '        for( uint i = 0; i < invoicesStack.length; i++ ){\n', '            if( helper.generatePASS2( invoicesStack[i], buyer ) == PASS2 ) {\n', '                find = true;\n', '                break;\n', '            }\n', '        }\n', '        require( find );\n', '        \n', '        sellersPASS2[ PASS2 ] = invoicesStack[i];\n', '        invoices[ sellersPASS2[ PASS2 ] ].tokenNumeric = helper.generateNUMERIC( _encryptCounter );\n', '        invoices[ sellersPASS2[ PASS2 ] ].buyer = buyer;\n', '        invoices[ sellersPASS2[ PASS2 ] ].state = 0x2;\n', '    }\n', '    \n', '    \n', '    function BUYER_STEP_3( bytes32 PASS2, uint _amount) public constant returns( uint )\n', '    {\n', '        require( invoices[ sellersPASS2[ PASS2 ] ].buyer == msg.sender );\n', '        \n', '        return ( helper.encodeAmount( invoices[ sellersPASS2[ PASS2 ] ].tokenNumeric, _amount ) );\n', '    }\n', '    \n', '    \n', '    \n', '    \n', '    function BUYER_STEP_4( bytes32 PASS2, uint _amount, bytes1 _method, address _token ) public payable\n', '    {\n', '        require( invoices[ sellersPASS2[ PASS2 ] ].buyer == msg.sender );\n', '        \n', '        uint amount = helper.decodeAmount( _amount, invoices[ sellersPASS2[ PASS2 ] ].tokenNumeric );\n', '        \n', '        //ath\n', '        if( _method == 0x1 ) {\n', '            \n', '            require( amount <= balances[msg.sender] );\n', '            balances[msg.sender] = balances[msg.sender].sub(amount);\n', '            invoices[ sellersPASS2[ PASS2 ] ].tokens = amount;\n', '            invoices[ sellersPASS2[ PASS2 ] ].method = 0x1;\n', '        }\n', '        \n', '        //ether\n', '        if( _method == 0x2 ) {\n', '            \n', '            require( amount <= ethBalances[msg.sender] );\n', '            ethBalances[msg.sender] = ethBalances[msg.sender].sub(amount);\n', '            invoices[ sellersPASS2[ PASS2 ] ].tokens = amount;\n', '            invoices[ sellersPASS2[ PASS2 ] ].method = 0x2;\n', '            \n', '        }\n', '        \n', '        //any token\n', '        if( _method == 0x3 ) {\n', '            \n', '            require( amount <= tokenBalances[msg.sender][_token] );\n', '            tokenBalances[msg.sender][_token] = tokenBalances[msg.sender][_token].sub(amount);\n', '            invoices[ sellersPASS2[ PASS2 ] ].tokens = amount;\n', '            invoices[ sellersPASS2[ PASS2 ] ].token = _token;\n', '            invoices[ sellersPASS2[ PASS2 ] ].method = 0x3;\n', '            \n', '        }\n', '        \n', '        invoices[ sellersPASS2[ PASS2 ] ].state = 0x3;\n', '        \n', '    }\n', '\n', '    \n', '    function BUYER_STEP_5_CANCEL( bytes32 PASS2 ) public\n', '    {\n', '        require( invoices[ sellersPASS2[ PASS2 ] ].buyer == msg.sender );\n', '        \n', '        if( invoices[ sellersPASS2[ PASS2 ] ].method == 0x1 ){\n', '            \n', '            balances[msg.sender] = balances[msg.sender].add( invoices[ sellersPASS2[ PASS2 ] ].tokens );\n', '            \n', '        }\n', '        if( invoices[ sellersPASS2[ PASS2 ] ].method == 0x2 ){\n', '            \n', '            ethBalances[msg.sender] = ethBalances[msg.sender].add(invoices[ sellersPASS2[ PASS2 ] ].tokens);\n', '            \n', '        }\n', '        if( invoices[ sellersPASS2[ PASS2 ] ].method == 0x3 ){\n', '            \n', '            tokenBalances[msg.sender][invoices[ sellersPASS2[ PASS2 ] ].token] = tokenBalances[msg.sender][invoices[ sellersPASS2[ PASS2 ] ].token].add(invoices[ sellersPASS2[ PASS2 ] ].tokens);\n', '            \n', '        }\n', '        invoices[ sellersPASS2[ PASS2 ] ].tokens = 0;\n', '        invoices[ sellersPASS2[ PASS2 ] ].state = 0x4;\n', '    }\n', '    \n', '    function SELLER_CHECK_STEP( bytes32 PASS3 ) public constant returns( bytes1, bytes1, address, uint256 )\n', '    {\n', '        require( invoices[ PASS3toPASS1[ PASS3 ] ].seller == msg.sender );\n', '        return ( invoices[ PASS3toPASS1[ PASS3 ] ].state, invoices[ PASS3toPASS1[ PASS3 ] ].method, invoices[ PASS3toPASS1[ PASS3 ] ].token, invoices[ PASS3toPASS1[ PASS3 ] ].tokens ); \n', '    }\n', '    \n', '    function BUYER_CHECK_STEP( bytes32 PASS2 ) public constant returns( bytes1, bytes1, address, uint256  )\n', '    {\n', '        require( invoices[ sellersPASS2[ PASS2 ] ].buyer == msg.sender );\n', '        return ( invoices[ sellersPASS2[ PASS2 ] ].state, invoices[ sellersPASS2[ PASS2 ] ].method, invoices[ sellersPASS2[ PASS2 ] ].token, invoices[ sellersPASS2[ PASS2 ] ].tokens );\n', '    }\n', '    \n', '    \n', '    function setEncryptContract( address _a ) public onlyOwner\n', '    {\n', '         helper = Helper( _a );\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.20;\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    string public name;\n', '    string public symbol;\n', '    uint32 public decimals;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  function transfer(address _to, uint256 _amount) public returns (bool) {\n', '    uint256 _value = _amount;\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '  \n', '    \n', '\n', '}\n', '\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require( newOwner != address(0) );\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract AthCrowdsaleInterface\n', '{\n', '    function investorsCount() public constant returns( uint256 );\n', '    \n', '    function investorsAddress( uint256 _i ) public constant returns( address );\n', '    \n', '    function investorsInfo( address _a ) public constant returns( uint256, uint256 );\n', '    \n', '    function investorsStockInfo( address _a ) public constant returns( uint256 );\n', '    \n', '    function getOwners(uint8) public constant returns( address );\n', '}\n', ' \n', ' \n', '\n', '\n', 'contract AthTokenBase is Ownable, StandardToken{\n', '    \n', '    address crowdsale;\n', '    AthCrowdsaleInterface crowdsaleInterface;\n', '    \n', '    \n', '    uint256 public redemptionFund = 0;\n', '    uint256 public redemptionFundTotal = 0;\n', '    uint256 public redemptionPrice = 0;\n', '    \n', '    modifier onlyCrowdsale() {\n', '        require(msg.sender == crowdsale);\n', '        _;\n', '    }\n', '    \n', '    function AthTokenBase() public \n', '    {\n', '        name                    = "Ethereum Anonymizer";\n', '        symbol                  = "ATH";\n', '        decimals                = 18;\n', '        totalSupply             = 21000000 ether;\n', '        balances[address(this)] = totalSupply;\n', '    }\n', '    \n', '    \n', '    \n', '    function setCrowdsale( address _a ) public onlyOwner returns( bool )\n', '    {\n', '        crowdsale = _a;\n', '        crowdsaleInterface = AthCrowdsaleInterface( _a );\n', '    }\n', '    \n', '\n', '    function delivery( address _to, uint256 _amount ) public onlyCrowdsale returns( bool )\n', '    {\n', '        require( _to != address(0) );\n', '        require(_amount <= balances[address(this)] );\n', '        balances[address(this)] = balances[address(this)].sub( _amount );\n', '        balances[_to] = balances[_to].add( _amount );\n', '        \n', '        emit Transfer( address(this), _to, _amount );\n', '        \n', '    }\n', '    \n', '    function currentBalance() public constant returns( uint256 )\n', '    {\n', '        return balances[ address(this) ];\n', '    }\n', '    \n', '    function afterIco( uint256 _redemptionPrice ) public onlyCrowdsale returns( bool )\n', '    {\n', '        totalSupply = totalSupply.sub( balances[ address(this) ] );\n', '        balances[address(this)] = 0;\n', '        redemptionPrice = _redemptionPrice;\n', '    }\n', '    \n', '\n', '   \n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Helper{\n', '    function generatePASS1( address ) public pure returns( bytes32 );\n', '    function generatePASS2( bytes32, address ) public pure returns( bytes32 );\n', '    function generatePASS3( bytes32 ) public pure returns( bytes32 );\n', '    function generateNUMERIC(uint) public constant returns( uint );\n', '    function encryptCounter( uint count ) public constant returns( uint );\n', '    function encodeAmount(uint, uint) public constant returns( uint );\n', '    function decodeAmount(uint, uint) public constant returns( uint );\n', '}\n', '\n', '\n', '\n', 'contract AthToken is AthTokenBase{\n', '    \n', '    Helper helper;\n', '    \n', '    \n', '    \n', '    uint256 private _encryptCounter = 1;\n', '    \n', '    uint8 public ethPriceIn  = 98;\n', '    // uint8 public tokenPriceIn  = 98;\n', '    \n', '    uint256 public ransom = 0;\n', '    \n', '    mapping( address => uint256 ) ethBalances;\n', '    mapping( address => mapping( address => uint256 ) ) tokenBalances;\n', '    \n', '    \n', '    struct Invoice{\n', '        address buyer;\n', '        address seller;\n', '        uint256 tokenNumeric;\n', '        uint256 tokens;\n', '        bytes1 state;\n', '        bytes1 method;\n', '        address token;\n', '    }\n', '    \n', '    \n', '    \n', '    uint constant invoicesStackLimit = 50;\n', '    bytes32[50] invoicesStack;\n', '    uint public invoicesStackCount;\n', '    \n', '    \n', '    \n', '    mapping( bytes32 => Invoice ) invoices;\n', '    mapping( address => bytes32 ) buyersPASS1;\n', '    mapping( address => bytes32 ) buyersPASS3;\n', '    mapping( bytes32 => bytes32 ) PASS3toPASS1;\n', '    mapping( bytes32 => bytes32 ) sellersPASS2;\n', '    \n', '    \n', '    \n', '   \n', '   \n', '   function sellAth( uint256 _amount ) public returns( bool )\n', '   {    //investors\n', '      require( redemptionFund >= _amount && redemptionPrice > 0 && crowdsaleInterface.investorsStockInfo( msg.sender ) > 0 );\n', '       \n', '       uint256 tmp =  _amount.mul( redemptionPrice ) ;\n', '       msg.sender.transfer( tmp );\n', '       balances[ msg.sender ] = balances[ msg.sender ].sub( _amount );\n', '       \n', '       redemptionFund = redemptionFund.sub( tmp );\n', '       \n', '      balances[crowdsaleInterface.getOwners( 0 )] = balances[crowdsaleInterface.getOwners( 0 )].add( _amount.div(2) );\n', '      balances[crowdsaleInterface.getOwners( 1 )] = balances[crowdsaleInterface.getOwners( 1 )].add( _amount.div(2) );\n', '   }\n', '   \n', '   \n', '   \n', '   function replenishEth() public payable\n', '   {\n', '    \n', '       uint tmp = msg.value.mul( ethPriceIn ).div( 100 );\n', '       \n', '       ethBalances[msg.sender]+= tmp;\n', '       \n', '       uint256 remainder = msg.value.sub( tmp );\n', '       \n', '       \n', '       if( redemptionFundTotal < totalSupply ){\n', '           \n', '           redemptionFund = redemptionFund.add( remainder );\n', '           redemptionFundTotal = redemptionFundTotal.add( remainder );\n', '           \n', '       } else {\n', '           \n', '           for( uint256 i = 0; i <= crowdsaleInterface.investorsCount() - 1; i++ ){\n', '               crowdsaleInterface.investorsAddress(i).transfer(  remainder.mul( crowdsaleInterface.investorsStockInfo(crowdsaleInterface.investorsAddress(i)) ).div( 200 )  );\n', '           }\n', '           \n', '           crowdsaleInterface.getOwners( 0 ).transfer( remainder.div( 4 ) );\n', '           crowdsaleInterface.getOwners( 1 ).transfer( remainder.div( 4 ) );\n', '           \n', '       }\n', '       \n', '       \n', '       \n', '       \n', '       \n', '   }\n', '   \n', '\n', '   \n', '   function replenishTokens(address _a, uint256 _amount) public\n', '   {\n', '       StandardToken token = StandardToken( _a );\n', '       require( _amount <= token.balanceOf( msg.sender ) );\n', '       token.transferFrom( msg.sender, this, _amount);\n', '       \n', '       tokenBalances[msg.sender][_a] = tokenBalances[msg.sender][_a].add( _amount );\n', '       \n', '   }\n', '   \n', '   function tokenBalance(address _a) public constant returns(uint256)\n', '   {\n', '       return ( tokenBalances[msg.sender][_a] );\n', '   }\n', '   \n', '   function ethBalance(address _a) public constant returns(uint256)\n', '   {\n', '       return ( ethBalances[_a] );\n', '   }\n', '   function ethContractBalance() public constant returns(uint256)\n', '   {\n', '       return address(this).balance;\n', '   }\n', '   function ethBaseBalance(address _a) public constant returns(uint256)\n', '   {\n', '       return ( _a.balance );\n', '   }\n', '   function withdrawEth( uint256 _amount ) public\n', '   {\n', '       require( _amount <= ethBalances[msg.sender] );\n', '       \n', '       ethBalances[msg.sender] = ethBalances[msg.sender].sub( _amount );\n', '       msg.sender.transfer( _amount );\n', '   }\n', '\n', '    function withdrawToken( address _a, uint256 _amount ) public\n', '   {\n', '       require( _amount <= tokenBalances[msg.sender][_a] );\n', '       \n', '       StandardToken token = StandardToken( _a );\n', '       \n', '       tokenBalances[msg.sender][_a] = tokenBalances[msg.sender][_a].sub( _amount );\n', '       token.transfer( msg.sender, _amount );\n', '   }\n', '    \n', '   function setEthPricies(uint8 _in) public onlyOwner\n', '   {\n', '       ethPriceIn  = _in;\n', '   }\n', '    \n', '    \n', '    \n', '    function SELLER_STEP_1_OPEN() public returns( bool )\n', '    {\n', '        address sender = msg.sender;\n', '        \n', '        _encryptCounter = helper.encryptCounter( _encryptCounter );\n', '        \n', '        bytes32 PASS1 = helper.generatePASS1( sender );\n', '        bytes32 PASS3 = helper.generatePASS3( PASS1 );\n', '        \n', '        invoicesStack[invoicesStackCount] = PASS1;\n', '    \n', '        \n', '        invoicesStackCount++;\n', '        if( invoicesStackCount >= invoicesStackLimit ) invoicesStackCount = 0;\n', '        \n', '        invoices[ PASS1 ].seller     = sender;\n', '        invoices[ PASS1 ].state      = 0x1;\n', '        buyersPASS1[sender]          = PASS1;\n', '        buyersPASS3[sender]          = PASS3;\n', '        PASS3toPASS1[PASS3]          = PASS1;\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function SELLER_STEP_2_GET_PASS() public constant returns( bytes32,bytes32 )\n', '    {\n', '        return ( buyersPASS1[msg.sender], buyersPASS3[msg.sender]);\n', '    }\n', '    \n', '\n', '\n', '\n', '\n', '\n', '    \n', '    function SELLER_STEP_4_ACCEPT( bytes32 PASS3 ) public\n', '    {\n', '        require( invoices[ PASS3toPASS1[ PASS3 ] ].seller == msg.sender );\n', '        \n', '        if( invoices[ PASS3toPASS1[ PASS3 ] ].method == 0x1 ) {\n', '            \n', '            balances[msg.sender] = balances[msg.sender].add( invoices[ PASS3toPASS1[ PASS3 ] ].tokens );\n', '            invoices[ PASS3toPASS1[ PASS3 ] ].tokens = 0;\n', '            invoices[ PASS3toPASS1[ PASS3 ] ].state = 0x5;\n', '            \n', '        }\n', '            \n', '        if( invoices[ PASS3toPASS1[ PASS3 ] ].method == 0x2 ) {\n', '            \n', '            msg.sender.transfer( invoices[ PASS3toPASS1[ PASS3 ] ].tokens );\n', '            invoices[ PASS3toPASS1[ PASS3 ] ].tokens = 0;\n', '            invoices[ PASS3toPASS1[ PASS3 ] ].state = 0x5;\n', '            \n', '        }\n', '        \n', '        if( invoices[ PASS3toPASS1[ PASS3 ] ].method == 0x3 ) {\n', '            \n', '            tokenBalances[msg.sender][invoices[ PASS3toPASS1[ PASS3 ] ].token] = tokenBalances[msg.sender][invoices[ PASS3toPASS1[ PASS3 ] ].token].add( invoices[ PASS3toPASS1[ PASS3 ] ].tokens );\n', '            invoices[ PASS3toPASS1[ PASS3 ] ].tokens = 0;\n', '            invoices[ PASS3toPASS1[ PASS3 ] ].state = 0x5;\n', '            \n', '        }\n', '        \n', '        \n', '    }\n', '\n', '    \n', '    function BUYER_STEP_1( bytes32 PASS1 ) public constant returns( bytes32 )\n', '    {\n', '        return helper.generatePASS2( PASS1, msg.sender );\n', '    }\n', '    \n', '    \n', '    function BUYER_STEP_2( bytes32 PASS2 ) public\n', '    {\n', '        address buyer = msg.sender;\n', '        bool find = false;\n', '        \n', '        for( uint i = 0; i < invoicesStack.length; i++ ){\n', '            if( helper.generatePASS2( invoicesStack[i], buyer ) == PASS2 ) {\n', '                find = true;\n', '                break;\n', '            }\n', '        }\n', '        require( find );\n', '        \n', '        sellersPASS2[ PASS2 ] = invoicesStack[i];\n', '        invoices[ sellersPASS2[ PASS2 ] ].tokenNumeric = helper.generateNUMERIC( _encryptCounter );\n', '        invoices[ sellersPASS2[ PASS2 ] ].buyer = buyer;\n', '        invoices[ sellersPASS2[ PASS2 ] ].state = 0x2;\n', '    }\n', '    \n', '    \n', '    function BUYER_STEP_3( bytes32 PASS2, uint _amount) public constant returns( uint )\n', '    {\n', '        require( invoices[ sellersPASS2[ PASS2 ] ].buyer == msg.sender );\n', '        \n', '        return ( helper.encodeAmount( invoices[ sellersPASS2[ PASS2 ] ].tokenNumeric, _amount ) );\n', '    }\n', '    \n', '    \n', '    \n', '    \n', '    function BUYER_STEP_4( bytes32 PASS2, uint _amount, bytes1 _method, address _token ) public payable\n', '    {\n', '        require( invoices[ sellersPASS2[ PASS2 ] ].buyer == msg.sender );\n', '        \n', '        uint amount = helper.decodeAmount( _amount, invoices[ sellersPASS2[ PASS2 ] ].tokenNumeric );\n', '        \n', '        //ath\n', '        if( _method == 0x1 ) {\n', '            \n', '            require( amount <= balances[msg.sender] );\n', '            balances[msg.sender] = balances[msg.sender].sub(amount);\n', '            invoices[ sellersPASS2[ PASS2 ] ].tokens = amount;\n', '            invoices[ sellersPASS2[ PASS2 ] ].method = 0x1;\n', '        }\n', '        \n', '        //ether\n', '        if( _method == 0x2 ) {\n', '            \n', '            require( amount <= ethBalances[msg.sender] );\n', '            ethBalances[msg.sender] = ethBalances[msg.sender].sub(amount);\n', '            invoices[ sellersPASS2[ PASS2 ] ].tokens = amount;\n', '            invoices[ sellersPASS2[ PASS2 ] ].method = 0x2;\n', '            \n', '        }\n', '        \n', '        //any token\n', '        if( _method == 0x3 ) {\n', '            \n', '            require( amount <= tokenBalances[msg.sender][_token] );\n', '            tokenBalances[msg.sender][_token] = tokenBalances[msg.sender][_token].sub(amount);\n', '            invoices[ sellersPASS2[ PASS2 ] ].tokens = amount;\n', '            invoices[ sellersPASS2[ PASS2 ] ].token = _token;\n', '            invoices[ sellersPASS2[ PASS2 ] ].method = 0x3;\n', '            \n', '        }\n', '        \n', '        invoices[ sellersPASS2[ PASS2 ] ].state = 0x3;\n', '        \n', '    }\n', '\n', '    \n', '    function BUYER_STEP_5_CANCEL( bytes32 PASS2 ) public\n', '    {\n', '        require( invoices[ sellersPASS2[ PASS2 ] ].buyer == msg.sender );\n', '        \n', '        if( invoices[ sellersPASS2[ PASS2 ] ].method == 0x1 ){\n', '            \n', '            balances[msg.sender] = balances[msg.sender].add( invoices[ sellersPASS2[ PASS2 ] ].tokens );\n', '            \n', '        }\n', '        if( invoices[ sellersPASS2[ PASS2 ] ].method == 0x2 ){\n', '            \n', '            ethBalances[msg.sender] = ethBalances[msg.sender].add(invoices[ sellersPASS2[ PASS2 ] ].tokens);\n', '            \n', '        }\n', '        if( invoices[ sellersPASS2[ PASS2 ] ].method == 0x3 ){\n', '            \n', '            tokenBalances[msg.sender][invoices[ sellersPASS2[ PASS2 ] ].token] = tokenBalances[msg.sender][invoices[ sellersPASS2[ PASS2 ] ].token].add(invoices[ sellersPASS2[ PASS2 ] ].tokens);\n', '            \n', '        }\n', '        invoices[ sellersPASS2[ PASS2 ] ].tokens = 0;\n', '        invoices[ sellersPASS2[ PASS2 ] ].state = 0x4;\n', '    }\n', '    \n', '    function SELLER_CHECK_STEP( bytes32 PASS3 ) public constant returns( bytes1, bytes1, address, uint256 )\n', '    {\n', '        require( invoices[ PASS3toPASS1[ PASS3 ] ].seller == msg.sender );\n', '        return ( invoices[ PASS3toPASS1[ PASS3 ] ].state, invoices[ PASS3toPASS1[ PASS3 ] ].method, invoices[ PASS3toPASS1[ PASS3 ] ].token, invoices[ PASS3toPASS1[ PASS3 ] ].tokens ); \n', '    }\n', '    \n', '    function BUYER_CHECK_STEP( bytes32 PASS2 ) public constant returns( bytes1, bytes1, address, uint256  )\n', '    {\n', '        require( invoices[ sellersPASS2[ PASS2 ] ].buyer == msg.sender );\n', '        return ( invoices[ sellersPASS2[ PASS2 ] ].state, invoices[ sellersPASS2[ PASS2 ] ].method, invoices[ sellersPASS2[ PASS2 ] ].token, invoices[ sellersPASS2[ PASS2 ] ].tokens );\n', '    }\n', '    \n', '    \n', '    function setEncryptContract( address _a ) public onlyOwner\n', '    {\n', '         helper = Helper( _a );\n', '    }\n', '    \n', '}']
