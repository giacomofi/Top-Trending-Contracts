['pragma solidity ^0.4.18;\n', '\n', '\n', '//\n', '// AddressWars\n', '// (http://beta.addresswars.io/)\n', '// Public Beta v1.1\n', '//\n', '//\n', '//     .d8888b.                                    .d8888b.          \n', '//    d88P  Y88b                                  d88P  Y88b         \n', '//    888    888                                  888    888         \n', '//    888    888888  888     888  888.d8888b      888    888888  888 \n', '//    888    888`Y8bd8P&#39;     888  88888K          888    888`Y8bd8P&#39; \n', '//    888    888  X88K       Y88  88P"Y8888b.     888    888  X88K   \n', '//    Y88b  d88P.d8""8b.      Y8bd8P      X88     Y88b  d88P.d8""8b. \n', '//     "Y8888P" 888  888       Y88P   88888P&#39;      "Y8888P" 888  888 \n', '//\n', '//\n', '// ******************************\n', '//  Welcome to AddressWars Beta!\n', '// ******************************\n', '//\n', '// This contract is currently in a state of being tested and bug hunted,\n', '// as this is the beta, there will be no fees for enlisting or wagering.\n', '// This will encourage anyone to come and try out AddressWars for free\n', '// before deciding to play the live version (when released) as well as\n', '// making it so that the contract is tested to the fullest ability before\n', '// the live version is deployed. The website is currently under development\n', '// and will be continually improved as time goes on, once the live version\n', '// is deployed, you can access it&#39;s contract and data through the root url\n', '// (https://addresswars.io/) and there will always be a copy of the website\n', '// on a subdomain that you can visit in order to view and interact with this\n', '// contract at any time in the future.\n', '//\n', '// This contract is pushing the limits of the current Ethereum blockchain as\n', '// there are quite a lot of variables that it needs to keep track of as well\n', '// as being able to handle the statistical generation of key numbers. As a\n', '// result, the estimated gas cost to deploy this contract is 7.5M whereas\n', '// the current block gas limit is only 8M so this contract will take up\n', '// almost a whole block! Another problem with complex contracts is the fact\n', '// that there is a 16 local variable limit per function and in a few cases,\n', '// the functions needed access to a lot more than that so a lot of filtering\n', '// functions have been developed to handle the calculation internally then\n', '// simply return the useful parts.\n', '//\n', '//\n', '// **************************\n', '//  How to play AddressWars!\n', '// **************************\n', '//\n', '// Enlisting\n', '// In order to start playing AddressWars, you must first have an Ethereum\n', '// wallet address which you can issue transactions from but only non-contract \n', '// addresses (ie addresses where you can issue a transaction directly) can play.\n', '// From here, you can simply call the enlist() function and send the relevant\n', '// fee (in the beta it&#39;s 0 ETH, for the live it will be 0.01 ETH). After the\n', '// transaction succeeds, you will have your very own, randomly generated\n', '// address card that you can now put up for wager or use to attempt to claim\n', '// other address cards with!\n', '//\n', '// Wagering\n', '// You can choose to wager any card you own assuming you are not already \n', '// wagering a copy of that card. For your own address, you can provide a\n', '// maximum of 10 other copies to any other addresses (by either transferring \n', '// or wagering), once 10 copies of your own address are circulating, you will\n', '// no longer be able to transfer or wager your own address (although you can\n', '// still use it to claim other addresses). It is important to note that there\n', '// is no way to &#39;destroy&#39; a copy of a card in circulation and your own address\n', '// card cannot be transferred back to you (and you can&#39;t attempt to claim your\n', '// own address card).\n', '// To wager a card, simply call the wagerCardForAmount() function and send\n', '// the relevant fee (in the beta it&#39;s 0 ETH, for the live it will be 0.005 ETH)\n', '// as well as the address of the card you wish to wager and the amount you are\n', '// willing to wager it for (in wei). From this point, any other address can\n', '// attempt to claim the address card you listed but the card that will be put up\n', '// for claim will be the one with the lowest claim price (this may not be yours \n', '// at the time but as soon as a successful claim happens and you are the next\n', '// cheapest price, the next time someone attempts to claim that address, you\n', '// will receive the wager and your card may be claimed and taken from you).\n', '//\n', '// Claiming\n', '// Assuming your address has already enlisted, you are free to attempt to\n', '// claim any card that has a current wager on it. You can only store up to\n', '// 8 unique card addresses (your own address + 7 others) in your inventory\n', '// and you cannot claim if you are already at this limit (unless you already own\n', '// that card). You can claim as many copies of a card you own as you like but you\n', '// can only get rid of them by wagering off one at a time. As mentioned above,\n', '// the claim contender will be the owner of the cheapest claim wager. You cannot \n', '// claim a card if you are the current claim contender or if the card address is \n', '// the same as your address (ie you enlisted and got that card).\n', '// To attempt to claim, you need to first assemble an army of 3 address cards\n', '// (these cards don&#39;t have to be unique but you do have to own them) and send the \n', '// current cheapest wager price to the attemptToClaimCard() function. This function  \n', '// will do all of the calculation work for you and determine if you managed to claim\n', '// the card or not. The first thing that happens is the contract randomly picks \n', '// your claim contenders cards ensuring that at least one of the cards is the card\n', '// address you are attempting to claim and the rest are from their inventory.\n', '// After this point, all of the complex maths happens and the final attack\n', '// and defence numbers will be calculated based on all of the cards types,\n', '// modifiers and the base attack and defence stats.\n', '// From here it&#39;s simply a matter of determining how many hits got through\n', '// on both claimer and claim contender, it&#39;s calculated as follows;\n', '// opponentsHits = yourCard[attack] - opponentsCard[defence]\n', '//  ^ will be 0 if opponentsCard[defence] > yourCard[attack]\n', '// This is totalled up for both the claimer and the claim contender and the\n', '// one with the least amount of hits wins!\n', '//\n', '// Claim Outcomes\n', '// There are 3 situations that can result from a claim attempt;\n', '// 1. The total hits for both the claimer and the claim contender are equal\n', '//    - this means that you have drawn with your opponent, the wager will\n', '//      then be distributed;\n', '//      98% -> the claimer (you get most of the wager back)\n', '//      2% -> the dev\n', '// 2. The claimer has more hits than the claim contender\n', '//    - this means that you have lost against your opponent as they ended\n', '//      up taking less hits than you, the wager will then be distributed;\n', '//      98% -> the claim contender (they get most of the wager)\n', '//      2% -> the dev\n', '// 3. The claimer has less hits than the claim contender\n', '//    - this means that you have succeeded in claiming the card and hence\n', '//      that card address will be transferred from the claim contender\n', '//      to the claimer. in this case, both claimer and claim contender\n', '//      receive a portion of the wager as follow;\n', '//      50% -> the claimer (you get half of the wager back)\n', '//      48% -> the claim contender (they get about half of the wager)\n', '//      2% -> the dev\n', '//\n', '// Transferring\n', '// You are free to transfer any card you own to another address that has\n', '// already enlisted. Upon transfer, only one copy of the card will be removed\n', '// from your inventory so if you have multiple copies of that card, it will\n', '// not be completely removed from your inventory. If you only had one copy\n', '// though, that address will be removed from your inventory and you will\n', '// be able to claim/receive another address in its place.\n', '// There are some restrictions when transferring a card; \n', '//   1. you cannot be currently wagering the card\n', '//   2. the address you are transferring to must already be enlisted\n', '//   3. the address you are transferring the card to must have less than \n', '//      8 unique cards already (or they must already own the card)\n', '//   4. you cannot transfer a card back to it&#39;s original address\n', '//   5. if you are gifting your own address card, the claim limit will apply\n', '//      and if 10 copies already exist, you will not be able to gift your card.\n', '//\n', '// Withdrawing\n', '// All ETH transferred to the contract will stay in there until an\n', '// address wishes to withdraw from their account. Balances are tracked\n', '// per address and you can either withdraw an amount (assuming you have\n', '// a balance higher than that amount) or you can just withdraw it all.\n', '// For both of these cases there will be no fees associated with withdrawing\n', '// from the contract and after you choose to withdraw, your balance will\n', '// update accordingly.\n', '//\n', '//\n', '// Have fun and good luck claiming!\n', '//\n', '\n', '\n', 'contract AddressWarsBeta {\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Constants\n', '\n', '\n', '  // dev\n', '  address public dev;\n', '  uint256 constant devTax = 2; // 2% of all wagers\n', '\n', '  // fees\n', '  // in the live version the;\n', '  // enlistingFee will be 0.01 ether and the\n', '  // wageringFee will be 0.005 ether\n', '  uint256 constant enlistingFee = 0;\n', '  uint256 constant wageringFee = 0;\n', '\n', '  // limits\n', '\n', '  // the claim limit represents how many times an address can\n', '  // wager/trasnfer their own address. in this case the limit\n', '  // is set to 10 which means there can only ever be 10 other\n', '  // copies of your address out there. once you have wagered\n', '  // all 10 copies, you will no longer be able to wager your\n', '  // own address card (although you can still use it in play).\n', '  uint256 constant CLAIM_LIMIT = 10;\n', '\n', '  // this will limit how many unique addresses you can own at\n', '  // one time. you can own multiple copies of a unique address\n', '  // but you can only own a total of 8 unique addresses (your\n', '  // own address + 7 others) at a time. you can choose to wager\n', '  // any address but if you wager one, the current claim price is the\n', '  // lowest price offered from all owners. upon a successful claim,\n', '  // one copy will transfer from your inventory and if you have no\n', '  // copies remaining, it will remove that address card and you will\n', '  // have another free slot.\n', '  uint256 constant MAX_UNIQUE_CARDS_PER_ADDRESS = 8;\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Statistical Variables\n', '\n', '\n', '  // this is used to calculate all of the statistics and random choices\n', '  // within AddressWars\n', '  // see the shuffleSeed() and querySeed() methods for more information.\n', '  uint256 private _seed;\n', '\n', '  // the type will determine a cards bonus numbers;\n', '  // normal cards do not get any type advantage bonuses\n', '  // fire gets 1.25x att and def when versing nature\n', '  // water gets 1.25x att and def when versing fire\n', '  // nature gets 1.25x att and def when versing water\n', '  // *type advantages are applied after all modifiers\n', '  // that use addition are calculated\n', '  enum TYPE { NORMAL, FIRE, WATER, NATURE }\n', '  uint256[] private typeChances = [ 6, 7, 7, 7 ];\n', '  uint256 constant typeSum = 27;\n', '\n', '  // the modifier will act like a bonus for your card(s)\n', '  // NONE: no bonus will be applied\n', '  // ALL_: if all cards are of the same type, they all get\n', '  //       bonus att/def/att+def numbers\n', '  // V_: if a versing card is of a certain type, your card\n', '  //     will get bonus att/def numbers\n', '  // V_SWAP: this will swap the versing cards att and def\n', '  //         numbers after they&#39;ve been modified by any\n', '  //         other active modifiers\n', '  // R_V: your card resists the type advantages of the versing card,\n', '  //      normal type cards cannot receive this modifier\n', '  // A_I: your cards type advantage increases from 1.25x to 1.5x,\n', '  //      normal type cards cannot receive this modifier\n', '  enum MODIFIER {\n', '    NONE,\n', '    ALL_ATT, ALL_DEF, ALL_ATT_DEF,\n', '    V_ATT, V_DEF,\n', '    V_SWAP,\n', '    R_V,\n', '    A_I\n', '  }\n', '  uint256[] private modifierChances = [\n', '    55,\n', '    5, 6, 1,\n', '    12, 14,\n', '    3,\n', '    7,\n', '    4\n', '  ];\n', '  uint256 constant modifierSum = 107;\n', '\n', '  // below are the chances for the bonus stats of the modifiers,\n', '  // the seed will first choose a value between 0 and the sum, it will\n', '  // then cumulatively count up until it reaches the index with the\n', '  // matched roll\n', '  // for example;\n', '  // if your data was = [ 2, 3, 4, 2, 1 ], your cumulative total is 12,\n', '  // from there a number will be rolled and it will add up all the values\n', '  // until the cumulative total is greater than the number rolled\n', '  // if we rolled a 9, 2(0) + 3(1) + 4(2) + 2(3) = 11 > 9 so the index\n', '  // you matched in this case would be 3\n', '  // the final value will be;\n', '  // bonusMinimum + indexOf(cumulativeRoll)\n', '  uint256 constant cardBonusMinimum = 1;\n', '  uint256[] private modifierAttBonusChances = [ 2, 5, 8, 7, 3, 2, 1, 1 ]; // range: 1 - 8\n', '  uint256 constant modifierAttBonusSum = 29;\n', '  uint256[] private modifierDefBonusChances = [ 2, 3, 6, 8, 6, 5, 3, 2, 1, 1 ];  // range: 1 - 10\n', '  uint256 constant modifierDefBonusSum = 37;\n', '\n', '  // below are the distribution of the attack and defence numbers,\n', '  // in general, the attack average should be slightly higher than the\n', '  // defence average and defence should have a wider spread of values \n', '  // compared to attack which should be a tighter set of numbers\n', '  // the final value will be;\n', '  // cardMinimum + indexOf(cumulativeRoll)\n', '  uint256 constant cardAttackMinimum = 10;\n', '  uint256[] private cardAttackChances = [ 2, 2, 3, 5, 8, 9, 15, 17, 13, 11, 6, 5, 3, 2, 1, 1 ]; // range: 10 - 25\n', '  uint256 constant cardAttackSum = 103;\n', '  uint256 constant cardDefenceMinimum = 5;\n', '  uint256[] private cardDefenceChances = [ 1, 1, 2, 3, 5, 6, 11, 15, 19, 14, 12, 11, 9, 8, 7, 6, 5, 4, 3, 2, 2, 2, 2, 1, 1, 1 ]; // range: 5 - 30\n', '  uint256 constant cardDefenceSum = 153;\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Registry Variables\n', '\n', '\n', '  // overall address card tracking\n', '  mapping (address => bool) _exists;\n', '  mapping (address => uint256) _indexOf;\n', '  mapping (address => address[]) _ownersOf;\n', '  mapping (address => uint256[]) _ownersClaimPriceOf;\n', '  struct AddressCard {\n', '      address _cardAddress;\n', '      uint8 _cardType;\n', '      uint8 _cardModifier;\n', '      uint8 _modifierPrimarayVal;\n', '      uint8 _modifierSecondaryVal;\n', '      uint8 _attack;\n', '      uint8 _defence;\n', '      uint8 _claimed;\n', '      uint8 _forClaim;\n', '      uint256 _lowestPrice;\n', '      address _claimContender;\n', '  }\n', '  AddressCard[] private _addressCards;\n', '\n', '  // owner and balance tracking\n', '  mapping (address => uint256) _balanceOf;\n', '  mapping (address => address[]) _cardsOf;\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Events\n', '\n', '\n', '  event AddressDidEnlist(\n', '    address enlistedAddress);\n', '  event AddressCardWasWagered(\n', '    address addressCard, \n', '    address owner, \n', '    uint256 wagerAmount);\n', '  event AddressCardWagerWasCancelled(\n', '    address addressCard, \n', '    address owner);\n', '  event AddressCardWasTransferred(\n', '    address addressCard, \n', '    address fromAddress, \n', '    address toAddress);\n', '  event ClaimAttempt(\n', '    bool wasSuccessful, \n', '    address addressCard, \n', '    address claimer, \n', '    address claimContender, \n', '    address[3] claimerChoices, \n', '    address[3] claimContenderChoices, \n', '    uint256[3][2] allFinalAttackValues,\n', '    uint256[3][2] allFinalDefenceValues);\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Main Functions\n', '\n', '\n', '  // start up the contract!\n', '  function AddressWarsBeta() public {\n', '\n', '    // set our dev\n', '    dev = msg.sender;\n', '    // now use the dev address as the initial seed mix\n', '    shuffleSeed(uint256(dev));\n', '\n', '  }\n', '\n', '  // any non-contract address can call this function and begin playing AddressWars!\n', '  // please note that as there are a lot of write to storage operations, this function\n', '  // will be quite expensive in terms of gas so keep that in mind when sending your\n', '  // transaction to the network!\n', '  // 350k gas should be enough to handle all of the storage operations but MetaMask\n', '  // will give a good estimate when you initialize the transaction\n', '  // in order to enlist in AddressWars, you must first pay the enlistingFee (free for beta!)\n', '  function enlist() public payable {\n', '\n', '    require(cardAddressExists(msg.sender) == false);\n', '    require(msg.value == enlistingFee);\n', '    require(msg.sender == tx.origin); // this prevents contracts from enlisting,\n', '    // only normal addresses (ie ones that can send a request) can play AddressWars.\n', '\n', '    // first shuffle the main seed with the sender address as input\n', '    uint256 tmpSeed = tmpShuffleSeed(_seed, uint256(msg.sender));\n', '    uint256 tmpModulus;\n', '    // from this point on, tmpSeed will shuffle every time tmpQuerySeed()\n', '    // is called. it is used recursively so it will mutate upon each\n', '    // call of that function and finally at the end we will update\n', '    // the overall seed to save on gas fees\n', '\n', '    // now we can query the different attributes of the card\n', '    // first lets determine the card type\n', '    (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, typeSum);\n', '    uint256 cardType = cumulativeIndexOf(typeChances, tmpModulus);\n', '\n', '    // now to get the modifier\n', '    // special logic to handle normal type cards\n', '    uint256 adjustedModifierSum = modifierSum;\n', '    if (cardType == uint256(TYPE.NORMAL)) {\n', '      // normal cards cannot have the advantage increase modifier (the last in the array)\n', '      adjustedModifierSum -= modifierChances[modifierChances.length - 1];\n', '      // normal cards cannot have the resistance versing modifier (second last in the array)\n', '      adjustedModifierSum -= modifierChances[modifierChances.length - 2];\n', '    }\n', '    (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, adjustedModifierSum);\n', '    uint256 cardModifier = cumulativeIndexOf(modifierChances, tmpModulus);\n', '\n', '    // now we need to find our attack and defence values\n', '    (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, cardAttackSum);\n', '    uint256 cardAttack = cardAttackMinimum + cumulativeIndexOf(cardAttackChances, tmpModulus);\n', '    (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, cardDefenceSum);\n', '    uint256 cardDefence = cardDefenceMinimum + cumulativeIndexOf(cardDefenceChances, tmpModulus);\n', '\n', '    // finally handle our modifier values\n', '    uint256 primaryModifierVal = 0;\n', '    uint256 secondaryModifierVal = 0;\n', '    uint256 bonusAttackPenalty = 0;\n', '    uint256 bonusDefencePenalty = 0;\n', '    // handle the logic of our modifiers\n', '    if (cardModifier == uint256(MODIFIER.ALL_ATT)) { // all of the same type attack bonus\n', '\n', '      // the primary modifier value will hold our attack bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\n', '      primaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\n', '      // now for the attack penalty\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\n', '      bonusAttackPenalty = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\n', '      // penalty is doubled\n', '      bonusAttackPenalty *= 2;\n', '\n', '    } else if (cardModifier == uint256(MODIFIER.ALL_DEF)) { // all of the same type defence bonus\n', '\n', '      // the primary modifier value will hold our defence bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\n', '      primaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\n', '      // now for the defence penalty\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\n', '      bonusDefencePenalty = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\n', '      // penalty is doubled\n', '      bonusDefencePenalty *= 2;\n', '\n', '    } else if (cardModifier == uint256(MODIFIER.ALL_ATT_DEF)) { // all of the same type attack and defence bonus\n', '\n', '      // the primary modifier value will hold our attack bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\n', '      primaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\n', '      // now for the attack penalty\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\n', '      bonusAttackPenalty = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\n', '      // penalty is doubled\n', '      bonusAttackPenalty *= 2;\n', '\n', '      // the secondary modifier value will hold our defence bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\n', '      secondaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\n', '      // now for the defence penalty\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\n', '      bonusDefencePenalty = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\n', '      // penalty is doubled\n', '      bonusDefencePenalty *= 2;\n', '\n', '    } else if (cardModifier == uint256(MODIFIER.V_ATT)) { // versing a certain type attack bonus\n', '\n', '      // the primary modifier value will hold type we need to verse in order to get our bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, typeSum);\n', '      primaryModifierVal = cumulativeIndexOf(typeChances, tmpModulus);\n', '\n', '      // the secondary modifier value will hold our attack bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\n', '      secondaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\n', '      // now for the attack penalty\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\n', '      bonusAttackPenalty = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\n', '\n', '    } else if (cardModifier == uint256(MODIFIER.V_DEF)) { // versing a certain type defence bonus\n', '\n', '      // the primary modifier value will hold type we need to verse in order to get our bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, typeSum);\n', '      primaryModifierVal = cumulativeIndexOf(typeChances, tmpModulus);\n', '\n', '      // the secondary modifier value will hold our defence bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\n', '      secondaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\n', '      // now for the defence penalty\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\n', '      bonusDefencePenalty = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\n', '\n', '    }\n', '\n', '    // now apply the penalties\n', '    if (bonusAttackPenalty >= cardAttack) {\n', '      cardAttack = 0;\n', '    } else {\n', '      cardAttack -= bonusAttackPenalty;\n', '    }\n', '    if (bonusDefencePenalty >= cardDefence) {\n', '      cardDefence = 0;\n', '    } else {\n', '      cardDefence -= bonusDefencePenalty;\n', '    }\n', '\n', '\n', '    // now to add it to the registry\n', '    _exists[msg.sender] = true;\n', '    _indexOf[msg.sender] = uint256(_addressCards.length);\n', '    _ownersOf[msg.sender] = [ msg.sender ];\n', '    _ownersClaimPriceOf[msg.sender] = [ uint256(0) ];\n', '    _addressCards.push(AddressCard({\n', '      _cardAddress: msg.sender,\n', '      _cardType: uint8(cardType),\n', '      _cardModifier: uint8(cardModifier),\n', '      _modifierPrimarayVal: uint8(primaryModifierVal),\n', '      _modifierSecondaryVal: uint8(secondaryModifierVal),\n', '      _attack: uint8(cardAttack),\n', '      _defence: uint8(cardDefence),\n', '      _claimed: uint8(0),\n', '      _forClaim: uint8(0),\n', '      _lowestPrice: uint256(0),\n', '      _claimContender: address(0)\n', '    }));\n', '\n', '    // ...and now start your own collection!\n', '    _cardsOf[msg.sender] = [ msg.sender ];\n', '\n', '    // dev receives the enlisting fee\n', '    _balanceOf[dev] = SafeMath.add(_balanceOf[dev], enlistingFee);\n', '\n', '    // finally we need to update the main seed and as we initially started with\n', '    // the current main seed, tmpSeed will be the current representation of the seed\n', '    _seed = tmpSeed;\n', '\n', '    // now that we&#39;re done, it&#39;s time to log the event\n', '    AddressDidEnlist(msg.sender);\n', '\n', '  }\n', '\n', '  // this is where you can wager one of your addresses for a certain amount.\n', '  // any other player can then attempt to claim your address off you, if the\n', '  // address is your own address, you will simply give them a copy (limited to 10\n', '  // total copies) but otherwise the player will take that address off you if they\n', '  // are successful.\n', '  // here&#39;s what can happen when you wager;\n', '  // 1. if an opponent is successful in claiming your card, they will receive 50%\n', '  //    of the wager amount back, the dev gets 2% and you get 48%\n', '  // 2. if an opponent is unsuccessful in claiming your card, you will receive\n', '  //    98% of the wager amount and the dev will get 2%\n', '  // 3. if an opponent is draws with you when claiming your card, they will receive\n', '  //    98% of the wager amount back and the dev will get 2%\n', '  // your wager will remain available for anyone to claim up until either you cancel\n', '  // the wager or an opponent is successful in claiming your card\n', '  // in order to wager in AddressWars, you must first pay the wageringFee (free for beta!)\n', '  function wagerCardForAmount(address cardAddress, uint256 amount) public payable {\n', '\n', '    require(amount > 0);\n', '\n', '    require(cardAddressExists(msg.sender));\n', '    require(msg.value == wageringFee);\n', '\n', '    uint256 firstMatchedIndex;\n', '    bool isAlreadyWagered;\n', '    (firstMatchedIndex, isAlreadyWagered, , , ) = getOwnerOfCardsCheapestWager(msg.sender, cardAddress);\n', '    // calling the above method will automatically reinforce the check that the cardAddress exists\n', '    // as well as the sender actually owning the card\n', '    // we cannot wager a card if we are already wagering it\n', '    require(isAlreadyWagered == false);\n', '    // double check to make sure the card is actually owned by the sender\n', '    require(msg.sender == _ownersOf[cardAddress][firstMatchedIndex]);\n', '\n', '    AddressCard memory addressCardForWager = _addressCards[_indexOf[cardAddress]];\n', '    if (msg.sender == cardAddress) {\n', '      // we need to enforce the claim limit if you are the initial owner\n', '      require(addressCardForWager._claimed < CLAIM_LIMIT);\n', '    }\n', '\n', '    // now write the new data\n', '    _ownersClaimPriceOf[cardAddress][firstMatchedIndex] = amount;\n', '\n', '    // now update our statistics\n', '    updateCardStatistics(cardAddress);\n', '\n', '    // dev receives the wagering fee\n', '    _balanceOf[dev] = SafeMath.add(_balanceOf[dev], wageringFee);\n', '\n', '    // now that we&#39;re done, it&#39;s time to log the event\n', '    AddressCardWasWagered(cardAddress, msg.sender, amount);\n', '\n', '  }\n', '\n', '  function cancelWagerOfCard(address cardAddress) public {\n', '\n', '    require(cardAddressExists(msg.sender));\n', '\n', '    uint256 firstMatchedIndex;\n', '    bool isAlreadyWagered;\n', '    (firstMatchedIndex, isAlreadyWagered, , , ) = getOwnerOfCardsCheapestWager(msg.sender, cardAddress);\n', '    // calling the above method will automatically reinforce the check that the cardAddress exists\n', '    // as well as the owner actually owning the card\n', '    // we can only cancel a wager if there already is one\n', '    require(isAlreadyWagered);\n', '    // double check to make sure the card is actually owned by the sender\n', '    require(msg.sender == _ownersOf[cardAddress][firstMatchedIndex]);\n', '\n', '    // now write the new data\n', '    _ownersClaimPriceOf[cardAddress][firstMatchedIndex] = 0;\n', '\n', '    // now update our statistics\n', '    updateCardStatistics(cardAddress);\n', '\n', '    // now that we&#39;re done, it&#39;s time to log the event\n', '    AddressCardWagerWasCancelled(cardAddress, msg.sender);\n', '\n', '  }\n', '\n', '  // this is the main battle function of the contract, it takes the card address you\n', '  // wish to claim as well as your card choices as input. a lot of complex calculations\n', '  // happen within this function and in the end, a result will be determined on whether\n', '  // you won the claim or not. at the end, an event will be logged with all of the information\n', '  // about what happened in the battle including the final result, the contenders,\n', '  // the card choices (yours and your opponenets) as well as the final attack and defence numbers.\n', '  // this function will revert if the msg.value does not match the current minimum claim value\n', '  // of the card address you are attempting to claim.\n', '  function attemptToClaimCard(address cardAddress, address[3] choices) public payable {\n', '\n', '    // a lot of the functionality of attemptToClaimCard() is calculated in other methods as\n', '    // there is only a 16 local variable limit per method and we need a lot more than that\n', '\n', '    // see ownerCanClaimCard() below, this ensures we can actually claim the card we are after\n', '    // by running through various requirement checks\n', '    address claimContender;\n', '    uint256 claimContenderIndex;\n', '    (claimContender, claimContenderIndex) = ownerCanClaimCard(msg.sender, cardAddress, choices, msg.value);\n', '\n', '    address[3] memory opponentCardChoices = generateCardsFromClaimForOpponent(cardAddress, claimContender);\n', '\n', '    uint256[3][2] memory allFinalAttackFigures;\n', '    uint256[3][2] memory allFinalDefenceFigures;\n', '    (allFinalAttackFigures, allFinalDefenceFigures) = calculateAdjustedFiguresForBattle(choices, opponentCardChoices);\n', '    // after this point we have all of the modified attack and defence figures\n', '    // in the arrays above. the way the winner is determined is by counting \n', '    // how many attack points get through in total for each card, this is\n', '    // calculated by simply doing;\n', '    // opponentsHits = yourCard[attack] - opponentsCard[defence]\n', '    // if the defence of the opposing card is greater than the attack value,\n', '    // no hits will be taken.\n', '    // at the end, all hits are added up and the winner is the one with\n', '    // the least total amount of hits, if it is a draw, the wager will be\n', '    // returned to the sender (minus the dev fee)\n', '    uint256[2] memory totalHits = [ uint256(0), uint256(0) ];\n', '    for (uint256 i = 0; i < 3; i++) {\n', '      // start with the opponent attack to you\n', '      totalHits[0] += (allFinalAttackFigures[1][i] > allFinalDefenceFigures[0][i] ? allFinalAttackFigures[1][i] - allFinalDefenceFigures[0][i] : 0);\n', '      // then your attack to the opponent\n', '      totalHits[1] += (allFinalAttackFigures[0][i] > allFinalDefenceFigures[1][i] ? allFinalAttackFigures[0][i] - allFinalDefenceFigures[1][i] : 0);\n', '    }\n', '\n', '    // before we process the outcome, we should log the event.\n', '    // order is important here as we should log a successful \n', '    // claim attempt then a transfer (if that&#39;s what happens)\n', '    // instead of the other way around\n', '    ClaimAttempt(\n', '      totalHits[0] < totalHits[1], // it was successful if we had less hits than the opponent\n', '      cardAddress,\n', '      msg.sender,\n', '      claimContender,\n', '      choices,\n', '      opponentCardChoices,\n', '      allFinalAttackFigures,\n', '      allFinalDefenceFigures\n', '      );\n', '\n', '    // handle the outcomes\n', '    uint256 tmpAmount;\n', '    if (totalHits[0] == totalHits[1]) { // we have a draw\n', '\n', '      // hand out the dev tax\n', '      tmpAmount = SafeMath.div(SafeMath.mul(msg.value, devTax), 100); // 2%\n', '      _balanceOf[dev] = SafeMath.add(_balanceOf[dev], tmpAmount);\n', '      // now we return the rest to the sender\n', '      _balanceOf[msg.sender] = SafeMath.add(_balanceOf[msg.sender], SafeMath.sub(msg.value, tmpAmount)); // 98%\n', '\n', '    } else if (totalHits[0] > totalHits[1]) { // we have more hits so we were unsuccessful\n', '\n', '      // hand out the dev tax\n', '      tmpAmount = SafeMath.div(SafeMath.mul(msg.value, devTax), 100); // 2%\n', '      _balanceOf[dev] = SafeMath.add(_balanceOf[dev], tmpAmount);\n', '      // now we give the rest to the claim contender\n', '      _balanceOf[claimContender] = SafeMath.add(_balanceOf[claimContender], SafeMath.sub(msg.value, tmpAmount)); // 98%\n', '\n', '    } else { // this means we have less hits than the opponent so we were successful in our claim!\n', '\n', '      // hand out the dev tax\n', '      tmpAmount = SafeMath.div(SafeMath.mul(msg.value, devTax), 100); // 2%\n', '      _balanceOf[dev] = SafeMath.add(_balanceOf[dev], tmpAmount);\n', '      // return half to the sender\n', '      _balanceOf[msg.sender] = SafeMath.add(_balanceOf[msg.sender], SafeMath.div(msg.value, 2)); // 50%\n', '      // and now the remainder goes to the claim contender\n', '      _balanceOf[claimContender] = SafeMath.add(_balanceOf[claimContender], SafeMath.sub(SafeMath.div(msg.value, 2), tmpAmount)); // 48%\n', '\n', '      // finally transfer the ownership of the card from the claim contender to the sender but\n', '      // first we need to make sure to cancel the wager\n', '      _ownersClaimPriceOf[cardAddress][claimContenderIndex] = 0;\n', '      transferCard(cardAddress, claimContender, msg.sender);\n', '\n', '      // now update our statistics\n', '      updateCardStatistics(cardAddress);\n', '\n', '    }\n', '\n', '  }\n', '\n', '  function transferCardTo(address cardAddress, address toAddress) public {\n', '\n', '    // you can view this internal method below for more details.\n', '    // all of the requirements around transferring a card are\n', '    // tested within the transferCard() method.\n', '    // you are free to gift your own address card to anyone\n', '    // (assuming there are less than 10 copies circulating).\n', '    transferCard(cardAddress, msg.sender, toAddress);\n', '\n', '  }\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Wallet Functions\n', '\n', '\n', '  function withdrawAmount(uint256 amount) public {\n', '\n', '    require(amount > 0);\n', '\n', '    address sender = msg.sender;\n', '    uint256 balance = _balanceOf[sender];\n', '    \n', '    require(amount <= balance);\n', '    // transfer and update the balances\n', '    _balanceOf[sender] = SafeMath.sub(_balanceOf[sender], amount);\n', '    sender.transfer(amount);\n', '\n', '  }\n', '\n', '  function withdrawAll() public {\n', '\n', '    address sender = msg.sender;\n', '    uint256 balance = _balanceOf[sender];\n', '\n', '    require(balance > 0);\n', '    // transfer and update the balances\n', '    _balanceOf[sender] = 0;\n', '    sender.transfer(balance);\n', '\n', '  }\n', '\n', '  function getBalanceOfSender() public view returns (uint256) {\n', '    return _balanceOf[msg.sender];\n', '  }\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Helper Functions\n', '\n', '\n', '  function tmpShuffleSeed(uint256 tmpSeed, uint256 mix) public view returns (uint256) {\n', '\n', '    // really mix it up!\n', '    uint256 newTmpSeed = tmpSeed;\n', '    uint256 currentTime = now;\n', '    uint256 timeMix = currentTime + mix;\n', '    // in this instance, overflow is ok as we are just shuffling around the bits\n', '    // first lets square the seed\n', '    newTmpSeed *= newTmpSeed;\n', '    // now add our time and mix\n', '    newTmpSeed += timeMix;\n', '    // multiply by the time\n', '    newTmpSeed *= currentTime;\n', '    // now add our mix\n', '    newTmpSeed += mix;\n', '    // and finally multiply by the time and mix\n', '    newTmpSeed *= timeMix;\n', '\n', '    return newTmpSeed;\n', '\n', '  }\n', '\n', '  function shuffleSeed(uint256 mix) private {\n', '\n', '    // set our seed based on our last seed\n', '    _seed = tmpShuffleSeed(_seed, mix);\n', '  \n', '  }\n', '\n', '  function tmpQuerySeed(uint256 tmpSeed, uint256 modulus) public view returns (uint256 tmpShuffledSeed, uint256 result) {\n', '\n', '    require(modulus > 0);\n', '\n', '    // get our answer\n', '    uint256 response = tmpSeed % modulus;\n', '\n', '    // now we want to re-mix our seed based off our response\n', '    uint256 mix = response + 1; // non-zero\n', '    mix *= modulus;\n', '    mix += response;\n', '    mix *= modulus;\n', '\n', '    // now return it\n', '    return (tmpShuffleSeed(tmpSeed, mix), response);\n', '\n', '  }\n', '\n', '  function querySeed(uint256 modulus) private returns (uint256) {\n', '\n', '    require(modulus > 0);\n', '\n', '    uint256 tmpSeed;\n', '    uint256 response;\n', '    (tmpSeed, response) = tmpQuerySeed(_seed, modulus);\n', '\n', '    // tmpSeed will now represent the suffled version of our last seed\n', '    _seed = tmpSeed;\n', '\n', '    // now return it\n', '    return response;\n', '\n', '  }\n', '\n', '  function cumulativeIndexOf(uint256[] array, uint256 target) private pure returns (uint256) {\n', '\n', '    bool hasFound = false;\n', '    uint256 index;\n', '    uint256 cumulativeTotal = 0;\n', '    for (uint256 i = 0; i < array.length; i++) {\n', '      cumulativeTotal += array[i];\n', '      if (cumulativeTotal > target) {\n', '        hasFound = true;\n', '        index = i;\n', '        break;\n', '      }\n', '    }\n', '\n', '    require(hasFound);\n', '    return index;\n', '\n', '  }\n', '\n', '  function cardAddressExists(address cardAddress) public view returns (bool) {\n', '    return _exists[cardAddress];\n', '  }\n', '\n', '  function indexOfCardAddress(address cardAddress) public view returns (uint256) {\n', '    require(cardAddressExists(cardAddress));\n', '    return _indexOf[cardAddress];\n', '  }\n', '\n', '  function ownerCountOfCard(address owner, address cardAddress) public view returns (uint256) {\n', '\n', '    // both card addresses need to exist in order to own cards\n', '    require(cardAddressExists(owner));\n', '    require(cardAddressExists(cardAddress));\n', '\n', '    // check if it&#39;s your own address\n', '    if (owner == cardAddress) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 ownerCount = 0;\n', '    address[] memory owners = _ownersOf[cardAddress];\n', '    for (uint256 i = 0; i < owners.length; i++) {\n', '      if (owner == owners[i]) {\n', '        ownerCount++;\n', '      }\n', '    }\n', '\n', '    return ownerCount;\n', '\n', '  }\n', '\n', '  function ownerHasCard(address owner, address cardAddress) public view returns (bool doesOwn, uint256[] indexes) {\n', '\n', '    // both card addresses need to exist in order to own cards\n', '    require(cardAddressExists(owner));\n', '    require(cardAddressExists(cardAddress));\n', '\n', '    uint256[] memory ownerIndexes = new uint256[](ownerCountOfCard(owner, cardAddress));\n', '    // check if it&#39;s your own address\n', '    if (owner == cardAddress) {\n', '      return (true, ownerIndexes);\n', '    }\n', '\n', '    if (ownerIndexes.length > 0) {\n', '      uint256 currentIndex = 0;\n', '      address[] memory owners = _ownersOf[cardAddress];\n', '      for (uint256 i = 0; i < owners.length; i++) {\n', '        if (owner == owners[i]) {\n', '          ownerIndexes[currentIndex] = i;\n', '          currentIndex++;\n', '        }\n', '      }\n', '    }\n', '\n', '    // this owner may own multiple copies of the card and so an array of indexes are returned\n', '    // if the owner does not own the card, it will return (false, [])\n', '    return (ownerIndexes.length > 0, ownerIndexes);\n', '\n', '  }\n', '\n', '  function ownerHasCardSimple(address owner, address cardAddress) private view returns (bool) {\n', '\n', '    bool doesOwn;\n', '    (doesOwn, ) = ownerHasCard(owner, cardAddress);\n', '    return doesOwn;\n', '\n', '  }\n', '\n', '  function ownerCanClaimCard(address owner, address cardAddress, address[3] choices, uint256 amount) private view returns (address currentClaimContender, uint256 claimContenderIndex) {\n', '\n', '    // you cannot claim back your own address cards\n', '    require(owner != cardAddress);\n', '    require(cardAddressExists(owner));\n', '    require(ownerHasCardSimple(owner, cardAddress) || _cardsOf[owner].length < MAX_UNIQUE_CARDS_PER_ADDRESS);\n', '\n', '\n', '    uint256 cheapestIndex;\n', '    bool canClaim;\n', '    address claimContender;\n', '    uint256 lowestClaimPrice;\n', '    (cheapestIndex, canClaim, claimContender, lowestClaimPrice, ) = getCheapestCardWager(cardAddress);\n', '    // make sure we can actually claim it and that we are paying the correct amount\n', '    require(canClaim);\n', '    require(amount == lowestClaimPrice);\n', '    // we also need to check that the sender is not the current claim contender\n', '    require(owner != claimContender);\n', '\n', '    // now check if we own all of our choices\n', '    for (uint256 i = 0; i < choices.length; i++) {\n', '      require(ownerHasCardSimple(owner, choices[i])); // if one is not owned, it will trigger a revert\n', '    }\n', '\n', '    // if no requires have been triggered by this point it means we are able to claim the card\n', '    // now return the claim contender and their index\n', '    return (claimContender, cheapestIndex);\n', '\n', '  }\n', '\n', '  function generateCardsFromClaimForOpponent(address cardAddress, address opponentAddress) private returns (address[3]) {\n', '\n', '    require(cardAddressExists(cardAddress));\n', '    require(cardAddressExists(opponentAddress));\n', '    require(ownerHasCardSimple(opponentAddress, cardAddress));\n', '\n', '    // generate the opponents cards from their own inventory\n', '    // it is important to note that at least 1 of their choices\n', '    // needs to be the card you are attempting to claim\n', '    address[] memory cardsOfOpponent = _cardsOf[opponentAddress];\n', '    address[3] memory opponentCardChoices;\n', '    uint256 tmpSeed = tmpShuffleSeed(_seed, uint256(opponentAddress));\n', '    uint256 tmpModulus;\n', '    uint256 indexOfClaimableCard;\n', '    (tmpSeed, indexOfClaimableCard) = tmpQuerySeed(tmpSeed, 3); // 0, 1 or 2\n', '    for (uint256 i = 0; i < 3; i++) {\n', '      if (i == indexOfClaimableCard) {\n', '        opponentCardChoices[i] = cardAddress;\n', '      } else {\n', '        (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, cardsOfOpponent.length);\n', '        opponentCardChoices[i] = cardsOfOpponent[tmpModulus];        \n', '      }\n', '    }\n', '\n', '    // finally we need to update the main seed and as we initially started with\n', '    // the current main seed, tmpSeed will be the current representation of the seed\n', '    _seed = tmpSeed;\n', '\n', '    return opponentCardChoices;\n', '\n', '  }\n', '\n', '  function updateCardStatistics(address cardAddress) private {\n', '\n', '    AddressCard storage addressCardClaimed = _addressCards[_indexOf[cardAddress]];\n', '    address claimContender;\n', '    uint256 lowestClaimPrice;\n', '    uint256 wagerCount;\n', '    ( , , claimContender, lowestClaimPrice, wagerCount) = getCheapestCardWager(cardAddress);\n', '    addressCardClaimed._forClaim = uint8(wagerCount);\n', '    addressCardClaimed._lowestPrice = lowestClaimPrice;\n', '    addressCardClaimed._claimContender = claimContender;\n', '\n', '  }\n', '\n', '  function transferCard(address cardAddress, address fromAddress, address toAddress) private {\n', '\n', '    require(toAddress != fromAddress);\n', '    require(cardAddressExists(cardAddress));\n', '    require(cardAddressExists(fromAddress));\n', '    uint256 firstMatchedIndex;\n', '    bool isWagered;\n', '    (firstMatchedIndex, isWagered, , , ) = getOwnerOfCardsCheapestWager(fromAddress, cardAddress);\n', '    require(isWagered == false); // you cannot transfer a card if it&#39;s currently wagered\n', '\n', '    require(cardAddressExists(toAddress));\n', '    require(toAddress != cardAddress); // can&#39;t transfer a card to it&#39;s original address\n', '    require(ownerHasCardSimple(toAddress, cardAddress) || _cardsOf[toAddress].length < MAX_UNIQUE_CARDS_PER_ADDRESS);\n', '\n', '    // firstly, if toAddress doesn&#39;t have a copy we need to add one\n', '    if (!ownerHasCardSimple(toAddress, cardAddress)) {\n', '      _cardsOf[toAddress].push(cardAddress);\n', '    } \n', '\n', '    // now check whether the fromAddress is just our original card\n', '    // address, if this is the case, they are free to transfer out\n', '    // one of their cards assuming the claim limit is not yet reached\n', '    if (fromAddress == cardAddress) { // the card is being claimed/gifted\n', '\n', '      AddressCard storage addressCardClaimed = _addressCards[_indexOf[cardAddress]];\n', '      require(addressCardClaimed._claimed < CLAIM_LIMIT);\n', '\n', '      // we need to push new data to our arrays\n', '      _ownersOf[cardAddress].push(toAddress);\n', '      _ownersClaimPriceOf[cardAddress].push(uint256(0));\n', '\n', '      // now update the claimed count in the registry\n', '      addressCardClaimed._claimed = uint8(_ownersOf[cardAddress].length - 1); // we exclude the original address\n', '\n', '    } else {\n', '\n', '      // firstly we need to cache the current index from our fromAddress&#39; _cardsOf\n', '      uint256 cardIndexOfSender = getCardIndexOfOwner(cardAddress, fromAddress);\n', '\n', '      // now just update the address at the firstMatchedIndex\n', '      _ownersOf[cardAddress][firstMatchedIndex] = toAddress;\n', '\n', '      // finally check if our fromAddress has any copies of the card left\n', '      if (!ownerHasCardSimple(fromAddress, cardAddress)) {\n', '\n', '        // if not delete that card from their inventory and make room in the array\n', '        for (uint256 i = cardIndexOfSender; i < _cardsOf[fromAddress].length - 1; i++) {\n', '          // shuffle the next value over\n', '          _cardsOf[fromAddress][i] = _cardsOf[fromAddress][i + 1];\n', '        }\n', '        // now decrease the length\n', '        _cardsOf[fromAddress].length--;\n', '\n', '      }\n', '\n', '    }\n', '\n', '    // now that we&#39;re done, it&#39;s time to log the event\n', '    AddressCardWasTransferred(cardAddress, fromAddress, toAddress);\n', '\n', '  }\n', '\n', '  function calculateAdjustedFiguresForBattle(address[3] yourChoices, address[3] opponentsChoices) private view returns (uint256[3][2] allAdjustedAttackFigures, uint256[3][2] allAdjustedDefenceFigures) {\n', '\n', '    // [0] is yours, [1] is your opponents\n', '    AddressCard[3][2] memory allCards;\n', '    uint256[3][2] memory allAttackFigures;\n', '    uint256[3][2] memory allDefenceFigures;\n', '    bool[2] memory allOfSameType = [ true, true ];\n', '    uint256[2] memory cumulativeAttackBonuses = [ uint256(0), uint256(0) ];\n', '    uint256[2] memory cumulativeDefenceBonuses = [ uint256(0), uint256(0) ];\n', '\n', '    for (uint256 i = 0; i < 3; i++) {\n', '      // cache your cards\n', '      require(_exists[yourChoices[i]]);\n', '      allCards[0][i] = _addressCards[_indexOf[yourChoices[i]]];\n', '      allAttackFigures[0][i] = allCards[0][i]._attack;\n', '      allDefenceFigures[0][i] = allCards[0][i]._defence;\n', '\n', '      // cache your opponents cards\n', '      require(_exists[opponentsChoices[i]]);\n', '      allCards[1][i] = _addressCards[_indexOf[opponentsChoices[i]]];\n', '      allAttackFigures[1][i] = allCards[1][i]._attack;\n', '      allDefenceFigures[1][i] = allCards[1][i]._defence;\n', '    }\n', '\n', '    // for the next part, order is quite important as we want the\n', '    // addition to happen first and then the multiplication to happen \n', '    // at the very end for the type advantages/resistances\n', '\n', '    //////////////////////////////////////////////////////////////\n', '    // the first modifiers that needs to be applied is the\n', '    // ALL_ATT, ALL_DEF and the ALL_ATT_DEF mod\n', '    // if all 3 of the chosen cards match the same type\n', '    // and if at least one of them have the ALL_ATT, ALL_DEF\n', '    // or ALL_ATT_DEF modifier, all of the cards will receive\n', '    // the cumulative bonus for att/def/att+def\n', '    for (i = 0; i < 3; i++) {\n', '\n', '      // start with your cards      \n', '      // compare to see if the types are the same as the previous one\n', '      if (i > 0 && allCards[0][i]._cardType != allCards[0][i - 1]._cardType) {\n', '        allOfSameType[0] = false;\n', '      }\n', '      // next count up all the modifier values for a total possible bonus\n', '      if (allCards[0][i]._cardModifier == uint256(MODIFIER.ALL_ATT)) { // all attack\n', '        // for the ALL_ATT modifier, the additional attack bonus is\n', '        // stored in the primary value\n', '        cumulativeAttackBonuses[0] += allCards[0][i]._modifierPrimarayVal;\n', '      } else if (allCards[0][i]._cardModifier == uint256(MODIFIER.ALL_DEF)) { // all defence\n', '        // for the ALL_DEF modifier, the additional defence bonus is\n', '        // stored in the primary value\n', '        cumulativeDefenceBonuses[0] += allCards[0][i]._modifierPrimarayVal;\n', '      } else if (allCards[0][i]._cardModifier == uint256(MODIFIER.ALL_ATT_DEF)) { // all attack + defence\n', '        // for the ALL_ATT_DEF modifier, the additional attack bonus is\n', '        // stored in the primary value and the additional defence bonus is\n', '        // stored in the secondary value\n', '        cumulativeAttackBonuses[0] += allCards[0][i]._modifierPrimarayVal;\n', '        cumulativeDefenceBonuses[0] += allCards[0][i]._modifierSecondaryVal;\n', '      }\n', '      \n', '      // now do the same for your opponent\n', '      if (i > 0 && allCards[1][i]._cardType != allCards[1][i - 1]._cardType) {\n', '        allOfSameType[1] = false;\n', '      }\n', '      if (allCards[1][i]._cardModifier == uint256(MODIFIER.ALL_ATT)) {\n', '        cumulativeAttackBonuses[1] += allCards[1][i]._modifierPrimarayVal;\n', '      } else if (allCards[1][i]._cardModifier == uint256(MODIFIER.ALL_DEF)) {\n', '        cumulativeDefenceBonuses[1] += allCards[1][i]._modifierPrimarayVal;\n', '      } else if (allCards[1][i]._cardModifier == uint256(MODIFIER.ALL_ATT_DEF)) {\n', '        cumulativeAttackBonuses[1] += allCards[1][i]._modifierPrimarayVal;\n', '        cumulativeDefenceBonuses[1] += allCards[1][i]._modifierSecondaryVal;\n', '      }\n', '\n', '    }\n', '    // we void our bonus if they aren&#39;t all of the type\n', '    if (!allOfSameType[0]) {\n', '      cumulativeAttackBonuses[0] = 0;\n', '      cumulativeDefenceBonuses[0] = 0;\n', '    }\n', '    if (!allOfSameType[1]) {\n', '      cumulativeAttackBonuses[1] = 0;\n', '      cumulativeDefenceBonuses[1] = 0;\n', '    }\n', '    // now add the bonus figures to the initial attack numbers, they will be 0\n', '    // if they either weren&#39;t all of the same type or if no cards actually had\n', '    // the ALL_ modifier\n', '    for (i = 0; i < 3; i++) {\n', '      // for your cards\n', '      allAttackFigures[0][i] += cumulativeAttackBonuses[0];\n', '      allDefenceFigures[0][i] += cumulativeDefenceBonuses[0];\n', '\n', '      // ...and your opponents cards\n', '      allAttackFigures[1][i] += cumulativeAttackBonuses[1];\n', '      allDefenceFigures[1][i] += cumulativeDefenceBonuses[1]; \n', '    }\n', '\n', '    //////////////////////////////////////////////////////////////\n', '    // the second modifier that needs to be applied is the V_ATT\n', '    // or the V_DEF mod\n', '    // if the versing card matches the same type listed in the\n', '    // primaryModifierVal, that card will receive the bonus in\n', '    // secondaryModifierVal for att/def\n', '    for (i = 0; i < 3; i++) {\n', '\n', '      // start with your cards      \n', '      if (allCards[0][i]._cardModifier == uint256(MODIFIER.V_ATT)) { // versing attack\n', '        // check if the versing cards type matches the primary value\n', '        if (allCards[1][i]._cardType == allCards[0][i]._modifierPrimarayVal) {\n', '          // add the attack bonus (amount is held in the secondary value)\n', '          allAttackFigures[0][i] += allCards[0][i]._modifierSecondaryVal;\n', '        }\n', '      } else if (allCards[0][i]._cardModifier == uint256(MODIFIER.V_DEF)) { // versing defence\n', '        // check if the versing cards type matches the primary value\n', '        if (allCards[1][i]._cardType == allCards[0][i]._modifierPrimarayVal) {\n', '          // add the defence bonus (amount is held in the secondary value)\n', '          allDefenceFigures[0][i] += allCards[0][i]._modifierSecondaryVal;\n', '        }\n', '      }\n', '\n', '      // now do the same for your opponent\n', '      if (allCards[1][i]._cardModifier == uint256(MODIFIER.V_ATT)) {\n', '        if (allCards[0][i]._cardType == allCards[1][i]._modifierPrimarayVal) {\n', '          allAttackFigures[1][i] += allCards[1][i]._modifierSecondaryVal;\n', '        }\n', '      } else if (allCards[1][i]._cardModifier == uint256(MODIFIER.V_DEF)) {\n', '        if (allCards[0][i]._cardType == allCards[1][i]._modifierPrimarayVal) {\n', '          allDefenceFigures[1][i] += allCards[1][i]._modifierSecondaryVal;\n', '        }\n', '      }\n', '\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////////\n', '    // the third modifier that needs to be applied is the type\n', '    // advantage numbers as well as applying R_V (resists versing\n', '    // cards type advantage) and A_I (increases your cards advantage)\n', '    for (i = 0; i < 3; i++) {\n', '\n', '      // start with your cards\n', '      // first check if the card we&#39;re versing resists our type advantage\n', '      if (allCards[1][i]._cardModifier != uint256(MODIFIER.R_V)) {\n', '        // test all the possible combinations of advantages\n', '        if (\n', '          // fire vs nature\n', '          (allCards[0][i]._cardType == uint256(TYPE.FIRE) && allCards[1][i]._cardType == uint256(TYPE.NATURE)) ||\n', '          // water vs fire\n', '          (allCards[0][i]._cardType == uint256(TYPE.WATER) && allCards[1][i]._cardType == uint256(TYPE.FIRE)) ||\n', '          // nature vs water\n', '          (allCards[0][i]._cardType == uint256(TYPE.NATURE) && allCards[1][i]._cardType == uint256(TYPE.WATER))\n', '          ) {\n', '\n', '          // now check if your card has a type advantage increase modifier\n', '          if (allCards[0][i]._cardModifier == uint256(MODIFIER.A_I)) {\n', '            allAttackFigures[0][i] = SafeMath.div(SafeMath.mul(allAttackFigures[0][i], 3), 2); // x1.5\n', '            allDefenceFigures[0][i] = SafeMath.div(SafeMath.mul(allDefenceFigures[0][i], 3), 2); // x1.5\n', '          } else {\n', '            allAttackFigures[0][i] = SafeMath.div(SafeMath.mul(allAttackFigures[0][i], 5), 4); // x1.25\n', '            allDefenceFigures[0][i] = SafeMath.div(SafeMath.mul(allDefenceFigures[0][i], 5), 4); // x1.25\n', '          }\n', '        }\n', '      }\n', '\n', '      // now do the same for your opponent\n', '      if (allCards[0][i]._cardModifier != uint256(MODIFIER.R_V)) {\n', '        if (\n', '          (allCards[1][i]._cardType == uint256(TYPE.FIRE) && allCards[0][i]._cardType == uint256(TYPE.NATURE)) ||\n', '          (allCards[1][i]._cardType == uint256(TYPE.WATER) && allCards[0][i]._cardType == uint256(TYPE.FIRE)) ||\n', '          (allCards[1][i]._cardType == uint256(TYPE.NATURE) && allCards[0][i]._cardType == uint256(TYPE.WATER))\n', '          ) {\n', '          if (allCards[1][i]._cardModifier == uint256(MODIFIER.A_I)) {\n', '            allAttackFigures[1][i] = SafeMath.div(SafeMath.mul(allAttackFigures[1][i], 3), 2); // x1.5\n', '            allDefenceFigures[1][i] = SafeMath.div(SafeMath.mul(allDefenceFigures[1][i], 3), 2); // x1.5\n', '          } else {\n', '            allAttackFigures[1][i] = SafeMath.div(SafeMath.mul(allAttackFigures[1][i], 5), 4); // x1.25\n', '            allDefenceFigures[1][i] = SafeMath.div(SafeMath.mul(allDefenceFigures[1][i], 5), 4); // x1.25\n', '          }\n', '        }\n', '      }\n', '\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////////\n', '    // the final modifier that needs to be applied is the V_SWAP mod\n', '    // if your card has this modifier, it will swap the final attack\n', '    // and defence numbers of your card\n', '    uint256 tmp;\n', '    for (i = 0; i < 3; i++) {\n', '\n', '      // start with your cards\n', '      // check if the versing card has the V_SWAP modifier\n', '      if (allCards[1][i]._cardModifier == uint256(MODIFIER.V_SWAP)) {\n', '        tmp = allAttackFigures[0][i];\n', '        allAttackFigures[0][i] = allDefenceFigures[0][i];\n', '        allDefenceFigures[0][i] = tmp;\n', '      }\n', '      // ...and your opponents cards\n', '      if (allCards[0][i]._cardModifier == uint256(MODIFIER.V_SWAP)) {\n', '        tmp = allAttackFigures[1][i];\n', '        allAttackFigures[1][i] = allDefenceFigures[1][i];\n', '        allDefenceFigures[1][i] = tmp;\n', '      }\n', '\n', '    }\n', '\n', '    // we&#39;re all done!\n', '    return (allAttackFigures, allDefenceFigures);\n', '\n', '  }\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Getter Functions\n', '\n', '\n', '  function getCard(address cardAddress) public view returns (uint256 cardIndex, uint256 cardType, uint256 cardModifier, uint256 cardModifierPrimaryVal, uint256 cardModifierSecondaryVal, uint256 attack, uint256 defence, uint256 claimed, uint256 forClaim, uint256 lowestPrice, address claimContender) {\n', '\n', '    require(cardAddressExists(cardAddress));\n', '\n', '    uint256 index = _indexOf[cardAddress];\n', '    AddressCard memory addressCard = _addressCards[index];\n', '    return (\n', '        index,\n', '        uint256(addressCard._cardType),\n', '        uint256(addressCard._cardModifier),\n', '        uint256(addressCard._modifierPrimarayVal),\n', '        uint256(addressCard._modifierSecondaryVal),\n', '        uint256(addressCard._attack),\n', '        uint256(addressCard._defence),\n', '        uint256(addressCard._claimed),\n', '        uint256(addressCard._forClaim),\n', '        uint256(addressCard._lowestPrice),\n', '        address(addressCard._claimContender)\n', '      );\n', '\n', '  }\n', '\n', '  function getCheapestCardWager(address cardAddress) public view returns (uint256 cheapestIndex, bool isClaimable, address claimContender, uint256 claimPrice, uint256 wagerCount) {\n', '\n', '    require(cardAddressExists(cardAddress));\n', '\n', '    uint256 cheapestSale = 0;\n', '    uint256 indexOfCheapestSale = 0;\n', '    uint256 totalWagers = 0;\n', '    uint256[] memory allOwnersClaimPrice = _ownersClaimPriceOf[cardAddress];\n', '    for (uint256 i = 0; i < allOwnersClaimPrice.length; i++) {\n', '      uint256 priceAtIndex = allOwnersClaimPrice[i];\n', '      if (priceAtIndex != 0) {\n', '        totalWagers++;\n', '        if (cheapestSale == 0 || priceAtIndex < cheapestSale) {\n', '          cheapestSale = priceAtIndex;\n', '          indexOfCheapestSale = i;\n', '        }\n', '      }\n', '    }\n', '\n', '    return (\n', '        indexOfCheapestSale,\n', '        (cheapestSale > 0),\n', '        (cheapestSale > 0 ? _ownersOf[cardAddress][indexOfCheapestSale] : address(0)),\n', '        cheapestSale,\n', '        totalWagers\n', '      );\n', '\n', '  }\n', '\n', '  function getOwnerOfCardsCheapestWager(address owner, address cardAddress) public view returns (uint256 cheapestIndex, bool isSelling, uint256 claimPrice, uint256 priceRank, uint256 outOf) {\n', '\n', '    bool doesOwn;\n', '    uint256[] memory indexes;\n', '    (doesOwn, indexes) = ownerHasCard(owner, cardAddress);\n', '    require(doesOwn);\n', '\n', '    uint256[] memory allOwnersClaimPrice = _ownersClaimPriceOf[cardAddress];\n', '    uint256 cheapestSale = 0;\n', '    uint256 indexOfCheapestSale = 0; // this will handle the case of owner == cardAddress\n', '    if (indexes.length > 0) {\n', '      indexOfCheapestSale = indexes[0]; // defaults to the first index matched\n', '    } else { // also will handle the case of owner == cardAddress\n', '      cheapestSale = allOwnersClaimPrice[0];\n', '    }\n', '\n', '    for (uint256 i = 0; i < indexes.length; i++) {\n', '      if (allOwnersClaimPrice[indexes[i]] != 0 && (cheapestSale == 0 || allOwnersClaimPrice[indexes[i]] < cheapestSale)) {\n', '        cheapestSale = allOwnersClaimPrice[indexes[i]];\n', '        indexOfCheapestSale = indexes[i];\n', '      }\n', '    }\n', '\n', '    uint256 saleRank = 0;\n', '    uint256 totalWagers = 0;\n', '    if (cheapestSale > 0) {\n', '      saleRank = 1;\n', '      for (i = 0; i < allOwnersClaimPrice.length; i++) {\n', '        if (allOwnersClaimPrice[i] != 0) {\n', '          totalWagers++;\n', '          if (allOwnersClaimPrice[i] < cheapestSale) {\n', '            saleRank++;\n', '          }\n', '        }\n', '      }\n', '    }\n', '\n', '    return (\n', '        indexOfCheapestSale,\n', '        (cheapestSale > 0),\n', '        cheapestSale,\n', '        saleRank,\n', '        totalWagers\n', '      );\n', '\n', '  }\n', '\n', '  function getCardIndexOfOwner(address cardAddress, address owner) public view returns (uint256) {\n', '\n', '    require(cardAddressExists(cardAddress));\n', '    require(cardAddressExists(owner));\n', '    require(ownerHasCardSimple(owner, cardAddress));\n', '\n', '    uint256 matchedIndex;\n', '    address[] memory cardsOfOwner = _cardsOf[owner];\n', '    for (uint256 i = 0; i < cardsOfOwner.length; i++) {\n', '      if (cardsOfOwner[i] == cardAddress) {\n', '        matchedIndex = i;\n', '        break;\n', '      }\n', '    }\n', '\n', '    return matchedIndex;\n', '\n', '  }\n', '  \n', '  function getTotalUniqueCards() public view returns (uint256) {\n', '    return _addressCards.length;\n', '  }\n', '  \n', '  function getAllCardsAddress() public view returns (bytes20[]) {\n', '\n', '    bytes20[] memory allCardsAddress = new bytes20[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsAddress[i] = bytes20(addressCard._cardAddress);\n', '    }\n', '    return allCardsAddress;\n', '\n', '  }\n', '\n', '  function getAllCardsType() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsType = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsType[i] = bytes1(addressCard._cardType);\n', '    }\n', '    return allCardsType;\n', '\n', '  }\n', '\n', '  function getAllCardsModifier() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsModifier = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsModifier[i] = bytes1(addressCard._cardModifier);\n', '    }\n', '    return allCardsModifier;\n', '\n', '  }\n', '\n', '  function getAllCardsModifierPrimaryVal() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsModifierPrimaryVal = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsModifierPrimaryVal[i] = bytes1(addressCard._modifierPrimarayVal);\n', '    }\n', '    return allCardsModifierPrimaryVal;\n', '\n', '  }\n', '\n', '  function getAllCardsModifierSecondaryVal() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsModifierSecondaryVal = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsModifierSecondaryVal[i] = bytes1(addressCard._modifierSecondaryVal);\n', '    }\n', '    return allCardsModifierSecondaryVal;\n', '\n', '  }\n', '\n', '  function getAllCardsAttack() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsAttack = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsAttack[i] = bytes1(addressCard._attack);\n', '    }\n', '    return allCardsAttack;\n', '\n', '  }\n', '\n', '  function getAllCardsDefence() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsDefence = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsDefence[i] = bytes1(addressCard._defence);\n', '    }\n', '    return allCardsDefence;\n', '\n', '  }\n', '\n', '  function getAllCardsClaimed() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsClaimed = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsClaimed[i] = bytes1(addressCard._claimed);\n', '    }\n', '    return allCardsClaimed;\n', '\n', '  }\n', '\n', '  function getAllCardsForClaim() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsForClaim = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsForClaim[i] = bytes1(addressCard._forClaim);\n', '    }\n', '    return allCardsForClaim;\n', '\n', '  }\n', '\n', '  function getAllCardsLowestPrice() public view returns (bytes32[]) {\n', '\n', '    bytes32[] memory allCardsLowestPrice = new bytes32[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsLowestPrice[i] = bytes32(addressCard._lowestPrice);\n', '    }\n', '    return allCardsLowestPrice;\n', '\n', '  }\n', '\n', '  function getAllCardsClaimContender() public view returns (bytes4[]) {\n', '\n', '    // returns the indexes of the claim contender\n', '    bytes4[] memory allCardsClaimContender = new bytes4[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsClaimContender[i] = bytes4(_indexOf[addressCard._claimContender]);\n', '    }\n', '    return allCardsClaimContender;\n', '\n', '  }\n', '\n', '  function getAllOwnersOfCard(address cardAddress) public view returns (bytes4[]) {\n', '    \n', '    require(cardAddressExists(cardAddress));\n', '\n', '    // returns the indexes of the owners\n', '    address[] memory ownersOfCardAddress = _ownersOf[cardAddress];\n', '    bytes4[] memory allOwners = new bytes4[](ownersOfCardAddress.length);\n', '    for (uint256 i = 0; i < ownersOfCardAddress.length; i++) {\n', '      allOwners[i] = bytes4(_indexOf[ownersOfCardAddress[i]]);\n', '    }\n', '    return allOwners;\n', '\n', '  }\n', '\n', '  function getAllOwnersClaimPriceOfCard(address cardAddress) public view returns (bytes32[]) {\n', '    \n', '    require(cardAddressExists(cardAddress));\n', '\n', '    uint256[] memory ownersClaimPriceOfCardAddress = _ownersClaimPriceOf[cardAddress];\n', '    bytes32[] memory allOwnersClaimPrice = new bytes32[](ownersClaimPriceOfCardAddress.length);\n', '    for (uint256 i = 0; i < ownersClaimPriceOfCardAddress.length; i++) {\n', '      allOwnersClaimPrice[i] = bytes32(ownersClaimPriceOfCardAddress[i]);\n', '    }\n', '    return allOwnersClaimPrice;\n', '\n', '  }\n', '\n', '  function getAllCardAddressesOfOwner(address owner) public view returns (bytes4[]) {\n', '    \n', '    require(cardAddressExists(owner));\n', '\n', '    // returns the indexes of the cards owned\n', '    address[] memory cardsOfOwner = _cardsOf[owner];\n', '    bytes4[] memory allCardAddresses = new bytes4[](cardsOfOwner.length);\n', '    for (uint256 i = 0; i < cardsOfOwner.length; i++) {\n', '      allCardAddresses[i] = bytes4(_indexOf[cardsOfOwner[i]]);\n', '    }\n', '    return allCardAddresses;\n', '\n', '  }\n', '\n', '  function getAllCardAddressesCountOfOwner(address owner) public view returns (bytes1[]) {\n', '    \n', '    require(cardAddressExists(owner));\n', '\n', '    address[] memory cardsOfOwner = _cardsOf[owner];\n', '    bytes1[] memory allCardAddressesCount = new bytes1[](cardsOfOwner.length);\n', '    for (uint256 i = 0; i < cardsOfOwner.length; i++) {\n', '      allCardAddressesCount[i] = bytes1(ownerCountOfCard(owner, cardsOfOwner[i]));\n', '    }\n', '    return allCardAddressesCount;\n', '\n', '  }\n', '\n', '  function getAllCardAddressesPriceOfOwner(address owner) public view returns (bytes32[]) {\n', '    \n', '    require(cardAddressExists(owner));\n', '\n', '    address[] memory cardsOfOwner = _cardsOf[owner];\n', '    bytes32[] memory allCardAddressesPrice = new bytes32[](cardsOfOwner.length);\n', '    for (uint256 i = 0; i < cardsOfOwner.length; i++) {\n', '      uint256 price;\n', '      ( , , price, , ) = getOwnerOfCardsCheapestWager(owner, cardsOfOwner[i]);\n', '      allCardAddressesPrice[i] = bytes32(price);\n', '    }\n', '    return allCardAddressesPrice;\n', '\n', '  }\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  \n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (ie if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '//\n', '// AddressWars\n', '// (http://beta.addresswars.io/)\n', '// Public Beta v1.1\n', '//\n', '//\n', '//     .d8888b.                                    .d8888b.          \n', '//    d88P  Y88b                                  d88P  Y88b         \n', '//    888    888                                  888    888         \n', '//    888    888888  888     888  888.d8888b      888    888888  888 \n', "//    888    888`Y8bd8P'     888  88888K          888    888`Y8bd8P' \n", '//    888    888  X88K       Y88  88P"Y8888b.     888    888  X88K   \n', '//    Y88b  d88P.d8""8b.      Y8bd8P      X88     Y88b  d88P.d8""8b. \n', '//     "Y8888P" 888  888       Y88P   88888P\'      "Y8888P" 888  888 \n', '//\n', '//\n', '// ******************************\n', '//  Welcome to AddressWars Beta!\n', '// ******************************\n', '//\n', '// This contract is currently in a state of being tested and bug hunted,\n', '// as this is the beta, there will be no fees for enlisting or wagering.\n', '// This will encourage anyone to come and try out AddressWars for free\n', '// before deciding to play the live version (when released) as well as\n', '// making it so that the contract is tested to the fullest ability before\n', '// the live version is deployed. The website is currently under development\n', '// and will be continually improved as time goes on, once the live version\n', "// is deployed, you can access it's contract and data through the root url\n", '// (https://addresswars.io/) and there will always be a copy of the website\n', '// on a subdomain that you can visit in order to view and interact with this\n', '// contract at any time in the future.\n', '//\n', '// This contract is pushing the limits of the current Ethereum blockchain as\n', '// there are quite a lot of variables that it needs to keep track of as well\n', '// as being able to handle the statistical generation of key numbers. As a\n', '// result, the estimated gas cost to deploy this contract is 7.5M whereas\n', '// the current block gas limit is only 8M so this contract will take up\n', '// almost a whole block! Another problem with complex contracts is the fact\n', '// that there is a 16 local variable limit per function and in a few cases,\n', '// the functions needed access to a lot more than that so a lot of filtering\n', '// functions have been developed to handle the calculation internally then\n', '// simply return the useful parts.\n', '//\n', '//\n', '// **************************\n', '//  How to play AddressWars!\n', '// **************************\n', '//\n', '// Enlisting\n', '// In order to start playing AddressWars, you must first have an Ethereum\n', '// wallet address which you can issue transactions from but only non-contract \n', '// addresses (ie addresses where you can issue a transaction directly) can play.\n', '// From here, you can simply call the enlist() function and send the relevant\n', "// fee (in the beta it's 0 ETH, for the live it will be 0.01 ETH). After the\n", '// transaction succeeds, you will have your very own, randomly generated\n', '// address card that you can now put up for wager or use to attempt to claim\n', '// other address cards with!\n', '//\n', '// Wagering\n', '// You can choose to wager any card you own assuming you are not already \n', '// wagering a copy of that card. For your own address, you can provide a\n', '// maximum of 10 other copies to any other addresses (by either transferring \n', '// or wagering), once 10 copies of your own address are circulating, you will\n', '// no longer be able to transfer or wager your own address (although you can\n', '// still use it to claim other addresses). It is important to note that there\n', "// is no way to 'destroy' a copy of a card in circulation and your own address\n", "// card cannot be transferred back to you (and you can't attempt to claim your\n", '// own address card).\n', '// To wager a card, simply call the wagerCardForAmount() function and send\n', "// the relevant fee (in the beta it's 0 ETH, for the live it will be 0.005 ETH)\n", '// as well as the address of the card you wish to wager and the amount you are\n', '// willing to wager it for (in wei). From this point, any other address can\n', '// attempt to claim the address card you listed but the card that will be put up\n', '// for claim will be the one with the lowest claim price (this may not be yours \n', '// at the time but as soon as a successful claim happens and you are the next\n', '// cheapest price, the next time someone attempts to claim that address, you\n', '// will receive the wager and your card may be claimed and taken from you).\n', '//\n', '// Claiming\n', '// Assuming your address has already enlisted, you are free to attempt to\n', '// claim any card that has a current wager on it. You can only store up to\n', '// 8 unique card addresses (your own address + 7 others) in your inventory\n', '// and you cannot claim if you are already at this limit (unless you already own\n', '// that card). You can claim as many copies of a card you own as you like but you\n', '// can only get rid of them by wagering off one at a time. As mentioned above,\n', '// the claim contender will be the owner of the cheapest claim wager. You cannot \n', '// claim a card if you are the current claim contender or if the card address is \n', '// the same as your address (ie you enlisted and got that card).\n', '// To attempt to claim, you need to first assemble an army of 3 address cards\n', "// (these cards don't have to be unique but you do have to own them) and send the \n", '// current cheapest wager price to the attemptToClaimCard() function. This function  \n', '// will do all of the calculation work for you and determine if you managed to claim\n', '// the card or not. The first thing that happens is the contract randomly picks \n', '// your claim contenders cards ensuring that at least one of the cards is the card\n', '// address you are attempting to claim and the rest are from their inventory.\n', '// After this point, all of the complex maths happens and the final attack\n', '// and defence numbers will be calculated based on all of the cards types,\n', '// modifiers and the base attack and defence stats.\n', "// From here it's simply a matter of determining how many hits got through\n", "// on both claimer and claim contender, it's calculated as follows;\n", '// opponentsHits = yourCard[attack] - opponentsCard[defence]\n', '//  ^ will be 0 if opponentsCard[defence] > yourCard[attack]\n', '// This is totalled up for both the claimer and the claim contender and the\n', '// one with the least amount of hits wins!\n', '//\n', '// Claim Outcomes\n', '// There are 3 situations that can result from a claim attempt;\n', '// 1. The total hits for both the claimer and the claim contender are equal\n', '//    - this means that you have drawn with your opponent, the wager will\n', '//      then be distributed;\n', '//      98% -> the claimer (you get most of the wager back)\n', '//      2% -> the dev\n', '// 2. The claimer has more hits than the claim contender\n', '//    - this means that you have lost against your opponent as they ended\n', '//      up taking less hits than you, the wager will then be distributed;\n', '//      98% -> the claim contender (they get most of the wager)\n', '//      2% -> the dev\n', '// 3. The claimer has less hits than the claim contender\n', '//    - this means that you have succeeded in claiming the card and hence\n', '//      that card address will be transferred from the claim contender\n', '//      to the claimer. in this case, both claimer and claim contender\n', '//      receive a portion of the wager as follow;\n', '//      50% -> the claimer (you get half of the wager back)\n', '//      48% -> the claim contender (they get about half of the wager)\n', '//      2% -> the dev\n', '//\n', '// Transferring\n', '// You are free to transfer any card you own to another address that has\n', '// already enlisted. Upon transfer, only one copy of the card will be removed\n', '// from your inventory so if you have multiple copies of that card, it will\n', '// not be completely removed from your inventory. If you only had one copy\n', '// though, that address will be removed from your inventory and you will\n', '// be able to claim/receive another address in its place.\n', '// There are some restrictions when transferring a card; \n', '//   1. you cannot be currently wagering the card\n', '//   2. the address you are transferring to must already be enlisted\n', '//   3. the address you are transferring the card to must have less than \n', '//      8 unique cards already (or they must already own the card)\n', "//   4. you cannot transfer a card back to it's original address\n", '//   5. if you are gifting your own address card, the claim limit will apply\n', '//      and if 10 copies already exist, you will not be able to gift your card.\n', '//\n', '// Withdrawing\n', '// All ETH transferred to the contract will stay in there until an\n', '// address wishes to withdraw from their account. Balances are tracked\n', '// per address and you can either withdraw an amount (assuming you have\n', '// a balance higher than that amount) or you can just withdraw it all.\n', '// For both of these cases there will be no fees associated with withdrawing\n', '// from the contract and after you choose to withdraw, your balance will\n', '// update accordingly.\n', '//\n', '//\n', '// Have fun and good luck claiming!\n', '//\n', '\n', '\n', 'contract AddressWarsBeta {\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Constants\n', '\n', '\n', '  // dev\n', '  address public dev;\n', '  uint256 constant devTax = 2; // 2% of all wagers\n', '\n', '  // fees\n', '  // in the live version the;\n', '  // enlistingFee will be 0.01 ether and the\n', '  // wageringFee will be 0.005 ether\n', '  uint256 constant enlistingFee = 0;\n', '  uint256 constant wageringFee = 0;\n', '\n', '  // limits\n', '\n', '  // the claim limit represents how many times an address can\n', '  // wager/trasnfer their own address. in this case the limit\n', '  // is set to 10 which means there can only ever be 10 other\n', '  // copies of your address out there. once you have wagered\n', '  // all 10 copies, you will no longer be able to wager your\n', '  // own address card (although you can still use it in play).\n', '  uint256 constant CLAIM_LIMIT = 10;\n', '\n', '  // this will limit how many unique addresses you can own at\n', '  // one time. you can own multiple copies of a unique address\n', '  // but you can only own a total of 8 unique addresses (your\n', '  // own address + 7 others) at a time. you can choose to wager\n', '  // any address but if you wager one, the current claim price is the\n', '  // lowest price offered from all owners. upon a successful claim,\n', '  // one copy will transfer from your inventory and if you have no\n', '  // copies remaining, it will remove that address card and you will\n', '  // have another free slot.\n', '  uint256 constant MAX_UNIQUE_CARDS_PER_ADDRESS = 8;\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Statistical Variables\n', '\n', '\n', '  // this is used to calculate all of the statistics and random choices\n', '  // within AddressWars\n', '  // see the shuffleSeed() and querySeed() methods for more information.\n', '  uint256 private _seed;\n', '\n', '  // the type will determine a cards bonus numbers;\n', '  // normal cards do not get any type advantage bonuses\n', '  // fire gets 1.25x att and def when versing nature\n', '  // water gets 1.25x att and def when versing fire\n', '  // nature gets 1.25x att and def when versing water\n', '  // *type advantages are applied after all modifiers\n', '  // that use addition are calculated\n', '  enum TYPE { NORMAL, FIRE, WATER, NATURE }\n', '  uint256[] private typeChances = [ 6, 7, 7, 7 ];\n', '  uint256 constant typeSum = 27;\n', '\n', '  // the modifier will act like a bonus for your card(s)\n', '  // NONE: no bonus will be applied\n', '  // ALL_: if all cards are of the same type, they all get\n', '  //       bonus att/def/att+def numbers\n', '  // V_: if a versing card is of a certain type, your card\n', '  //     will get bonus att/def numbers\n', '  // V_SWAP: this will swap the versing cards att and def\n', "  //         numbers after they've been modified by any\n", '  //         other active modifiers\n', '  // R_V: your card resists the type advantages of the versing card,\n', '  //      normal type cards cannot receive this modifier\n', '  // A_I: your cards type advantage increases from 1.25x to 1.5x,\n', '  //      normal type cards cannot receive this modifier\n', '  enum MODIFIER {\n', '    NONE,\n', '    ALL_ATT, ALL_DEF, ALL_ATT_DEF,\n', '    V_ATT, V_DEF,\n', '    V_SWAP,\n', '    R_V,\n', '    A_I\n', '  }\n', '  uint256[] private modifierChances = [\n', '    55,\n', '    5, 6, 1,\n', '    12, 14,\n', '    3,\n', '    7,\n', '    4\n', '  ];\n', '  uint256 constant modifierSum = 107;\n', '\n', '  // below are the chances for the bonus stats of the modifiers,\n', '  // the seed will first choose a value between 0 and the sum, it will\n', '  // then cumulatively count up until it reaches the index with the\n', '  // matched roll\n', '  // for example;\n', '  // if your data was = [ 2, 3, 4, 2, 1 ], your cumulative total is 12,\n', '  // from there a number will be rolled and it will add up all the values\n', '  // until the cumulative total is greater than the number rolled\n', '  // if we rolled a 9, 2(0) + 3(1) + 4(2) + 2(3) = 11 > 9 so the index\n', '  // you matched in this case would be 3\n', '  // the final value will be;\n', '  // bonusMinimum + indexOf(cumulativeRoll)\n', '  uint256 constant cardBonusMinimum = 1;\n', '  uint256[] private modifierAttBonusChances = [ 2, 5, 8, 7, 3, 2, 1, 1 ]; // range: 1 - 8\n', '  uint256 constant modifierAttBonusSum = 29;\n', '  uint256[] private modifierDefBonusChances = [ 2, 3, 6, 8, 6, 5, 3, 2, 1, 1 ];  // range: 1 - 10\n', '  uint256 constant modifierDefBonusSum = 37;\n', '\n', '  // below are the distribution of the attack and defence numbers,\n', '  // in general, the attack average should be slightly higher than the\n', '  // defence average and defence should have a wider spread of values \n', '  // compared to attack which should be a tighter set of numbers\n', '  // the final value will be;\n', '  // cardMinimum + indexOf(cumulativeRoll)\n', '  uint256 constant cardAttackMinimum = 10;\n', '  uint256[] private cardAttackChances = [ 2, 2, 3, 5, 8, 9, 15, 17, 13, 11, 6, 5, 3, 2, 1, 1 ]; // range: 10 - 25\n', '  uint256 constant cardAttackSum = 103;\n', '  uint256 constant cardDefenceMinimum = 5;\n', '  uint256[] private cardDefenceChances = [ 1, 1, 2, 3, 5, 6, 11, 15, 19, 14, 12, 11, 9, 8, 7, 6, 5, 4, 3, 2, 2, 2, 2, 1, 1, 1 ]; // range: 5 - 30\n', '  uint256 constant cardDefenceSum = 153;\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Registry Variables\n', '\n', '\n', '  // overall address card tracking\n', '  mapping (address => bool) _exists;\n', '  mapping (address => uint256) _indexOf;\n', '  mapping (address => address[]) _ownersOf;\n', '  mapping (address => uint256[]) _ownersClaimPriceOf;\n', '  struct AddressCard {\n', '      address _cardAddress;\n', '      uint8 _cardType;\n', '      uint8 _cardModifier;\n', '      uint8 _modifierPrimarayVal;\n', '      uint8 _modifierSecondaryVal;\n', '      uint8 _attack;\n', '      uint8 _defence;\n', '      uint8 _claimed;\n', '      uint8 _forClaim;\n', '      uint256 _lowestPrice;\n', '      address _claimContender;\n', '  }\n', '  AddressCard[] private _addressCards;\n', '\n', '  // owner and balance tracking\n', '  mapping (address => uint256) _balanceOf;\n', '  mapping (address => address[]) _cardsOf;\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Events\n', '\n', '\n', '  event AddressDidEnlist(\n', '    address enlistedAddress);\n', '  event AddressCardWasWagered(\n', '    address addressCard, \n', '    address owner, \n', '    uint256 wagerAmount);\n', '  event AddressCardWagerWasCancelled(\n', '    address addressCard, \n', '    address owner);\n', '  event AddressCardWasTransferred(\n', '    address addressCard, \n', '    address fromAddress, \n', '    address toAddress);\n', '  event ClaimAttempt(\n', '    bool wasSuccessful, \n', '    address addressCard, \n', '    address claimer, \n', '    address claimContender, \n', '    address[3] claimerChoices, \n', '    address[3] claimContenderChoices, \n', '    uint256[3][2] allFinalAttackValues,\n', '    uint256[3][2] allFinalDefenceValues);\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Main Functions\n', '\n', '\n', '  // start up the contract!\n', '  function AddressWarsBeta() public {\n', '\n', '    // set our dev\n', '    dev = msg.sender;\n', '    // now use the dev address as the initial seed mix\n', '    shuffleSeed(uint256(dev));\n', '\n', '  }\n', '\n', '  // any non-contract address can call this function and begin playing AddressWars!\n', '  // please note that as there are a lot of write to storage operations, this function\n', '  // will be quite expensive in terms of gas so keep that in mind when sending your\n', '  // transaction to the network!\n', '  // 350k gas should be enough to handle all of the storage operations but MetaMask\n', '  // will give a good estimate when you initialize the transaction\n', '  // in order to enlist in AddressWars, you must first pay the enlistingFee (free for beta!)\n', '  function enlist() public payable {\n', '\n', '    require(cardAddressExists(msg.sender) == false);\n', '    require(msg.value == enlistingFee);\n', '    require(msg.sender == tx.origin); // this prevents contracts from enlisting,\n', '    // only normal addresses (ie ones that can send a request) can play AddressWars.\n', '\n', '    // first shuffle the main seed with the sender address as input\n', '    uint256 tmpSeed = tmpShuffleSeed(_seed, uint256(msg.sender));\n', '    uint256 tmpModulus;\n', '    // from this point on, tmpSeed will shuffle every time tmpQuerySeed()\n', '    // is called. it is used recursively so it will mutate upon each\n', '    // call of that function and finally at the end we will update\n', '    // the overall seed to save on gas fees\n', '\n', '    // now we can query the different attributes of the card\n', '    // first lets determine the card type\n', '    (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, typeSum);\n', '    uint256 cardType = cumulativeIndexOf(typeChances, tmpModulus);\n', '\n', '    // now to get the modifier\n', '    // special logic to handle normal type cards\n', '    uint256 adjustedModifierSum = modifierSum;\n', '    if (cardType == uint256(TYPE.NORMAL)) {\n', '      // normal cards cannot have the advantage increase modifier (the last in the array)\n', '      adjustedModifierSum -= modifierChances[modifierChances.length - 1];\n', '      // normal cards cannot have the resistance versing modifier (second last in the array)\n', '      adjustedModifierSum -= modifierChances[modifierChances.length - 2];\n', '    }\n', '    (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, adjustedModifierSum);\n', '    uint256 cardModifier = cumulativeIndexOf(modifierChances, tmpModulus);\n', '\n', '    // now we need to find our attack and defence values\n', '    (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, cardAttackSum);\n', '    uint256 cardAttack = cardAttackMinimum + cumulativeIndexOf(cardAttackChances, tmpModulus);\n', '    (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, cardDefenceSum);\n', '    uint256 cardDefence = cardDefenceMinimum + cumulativeIndexOf(cardDefenceChances, tmpModulus);\n', '\n', '    // finally handle our modifier values\n', '    uint256 primaryModifierVal = 0;\n', '    uint256 secondaryModifierVal = 0;\n', '    uint256 bonusAttackPenalty = 0;\n', '    uint256 bonusDefencePenalty = 0;\n', '    // handle the logic of our modifiers\n', '    if (cardModifier == uint256(MODIFIER.ALL_ATT)) { // all of the same type attack bonus\n', '\n', '      // the primary modifier value will hold our attack bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\n', '      primaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\n', '      // now for the attack penalty\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\n', '      bonusAttackPenalty = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\n', '      // penalty is doubled\n', '      bonusAttackPenalty *= 2;\n', '\n', '    } else if (cardModifier == uint256(MODIFIER.ALL_DEF)) { // all of the same type defence bonus\n', '\n', '      // the primary modifier value will hold our defence bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\n', '      primaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\n', '      // now for the defence penalty\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\n', '      bonusDefencePenalty = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\n', '      // penalty is doubled\n', '      bonusDefencePenalty *= 2;\n', '\n', '    } else if (cardModifier == uint256(MODIFIER.ALL_ATT_DEF)) { // all of the same type attack and defence bonus\n', '\n', '      // the primary modifier value will hold our attack bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\n', '      primaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\n', '      // now for the attack penalty\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\n', '      bonusAttackPenalty = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\n', '      // penalty is doubled\n', '      bonusAttackPenalty *= 2;\n', '\n', '      // the secondary modifier value will hold our defence bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\n', '      secondaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\n', '      // now for the defence penalty\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\n', '      bonusDefencePenalty = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\n', '      // penalty is doubled\n', '      bonusDefencePenalty *= 2;\n', '\n', '    } else if (cardModifier == uint256(MODIFIER.V_ATT)) { // versing a certain type attack bonus\n', '\n', '      // the primary modifier value will hold type we need to verse in order to get our bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, typeSum);\n', '      primaryModifierVal = cumulativeIndexOf(typeChances, tmpModulus);\n', '\n', '      // the secondary modifier value will hold our attack bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\n', '      secondaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\n', '      // now for the attack penalty\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\n', '      bonusAttackPenalty = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\n', '\n', '    } else if (cardModifier == uint256(MODIFIER.V_DEF)) { // versing a certain type defence bonus\n', '\n', '      // the primary modifier value will hold type we need to verse in order to get our bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, typeSum);\n', '      primaryModifierVal = cumulativeIndexOf(typeChances, tmpModulus);\n', '\n', '      // the secondary modifier value will hold our defence bonus\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\n', '      secondaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\n', '      // now for the defence penalty\n', '      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\n', '      bonusDefencePenalty = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\n', '\n', '    }\n', '\n', '    // now apply the penalties\n', '    if (bonusAttackPenalty >= cardAttack) {\n', '      cardAttack = 0;\n', '    } else {\n', '      cardAttack -= bonusAttackPenalty;\n', '    }\n', '    if (bonusDefencePenalty >= cardDefence) {\n', '      cardDefence = 0;\n', '    } else {\n', '      cardDefence -= bonusDefencePenalty;\n', '    }\n', '\n', '\n', '    // now to add it to the registry\n', '    _exists[msg.sender] = true;\n', '    _indexOf[msg.sender] = uint256(_addressCards.length);\n', '    _ownersOf[msg.sender] = [ msg.sender ];\n', '    _ownersClaimPriceOf[msg.sender] = [ uint256(0) ];\n', '    _addressCards.push(AddressCard({\n', '      _cardAddress: msg.sender,\n', '      _cardType: uint8(cardType),\n', '      _cardModifier: uint8(cardModifier),\n', '      _modifierPrimarayVal: uint8(primaryModifierVal),\n', '      _modifierSecondaryVal: uint8(secondaryModifierVal),\n', '      _attack: uint8(cardAttack),\n', '      _defence: uint8(cardDefence),\n', '      _claimed: uint8(0),\n', '      _forClaim: uint8(0),\n', '      _lowestPrice: uint256(0),\n', '      _claimContender: address(0)\n', '    }));\n', '\n', '    // ...and now start your own collection!\n', '    _cardsOf[msg.sender] = [ msg.sender ];\n', '\n', '    // dev receives the enlisting fee\n', '    _balanceOf[dev] = SafeMath.add(_balanceOf[dev], enlistingFee);\n', '\n', '    // finally we need to update the main seed and as we initially started with\n', '    // the current main seed, tmpSeed will be the current representation of the seed\n', '    _seed = tmpSeed;\n', '\n', "    // now that we're done, it's time to log the event\n", '    AddressDidEnlist(msg.sender);\n', '\n', '  }\n', '\n', '  // this is where you can wager one of your addresses for a certain amount.\n', '  // any other player can then attempt to claim your address off you, if the\n', '  // address is your own address, you will simply give them a copy (limited to 10\n', '  // total copies) but otherwise the player will take that address off you if they\n', '  // are successful.\n', "  // here's what can happen when you wager;\n", '  // 1. if an opponent is successful in claiming your card, they will receive 50%\n', '  //    of the wager amount back, the dev gets 2% and you get 48%\n', '  // 2. if an opponent is unsuccessful in claiming your card, you will receive\n', '  //    98% of the wager amount and the dev will get 2%\n', '  // 3. if an opponent is draws with you when claiming your card, they will receive\n', '  //    98% of the wager amount back and the dev will get 2%\n', '  // your wager will remain available for anyone to claim up until either you cancel\n', '  // the wager or an opponent is successful in claiming your card\n', '  // in order to wager in AddressWars, you must first pay the wageringFee (free for beta!)\n', '  function wagerCardForAmount(address cardAddress, uint256 amount) public payable {\n', '\n', '    require(amount > 0);\n', '\n', '    require(cardAddressExists(msg.sender));\n', '    require(msg.value == wageringFee);\n', '\n', '    uint256 firstMatchedIndex;\n', '    bool isAlreadyWagered;\n', '    (firstMatchedIndex, isAlreadyWagered, , , ) = getOwnerOfCardsCheapestWager(msg.sender, cardAddress);\n', '    // calling the above method will automatically reinforce the check that the cardAddress exists\n', '    // as well as the sender actually owning the card\n', '    // we cannot wager a card if we are already wagering it\n', '    require(isAlreadyWagered == false);\n', '    // double check to make sure the card is actually owned by the sender\n', '    require(msg.sender == _ownersOf[cardAddress][firstMatchedIndex]);\n', '\n', '    AddressCard memory addressCardForWager = _addressCards[_indexOf[cardAddress]];\n', '    if (msg.sender == cardAddress) {\n', '      // we need to enforce the claim limit if you are the initial owner\n', '      require(addressCardForWager._claimed < CLAIM_LIMIT);\n', '    }\n', '\n', '    // now write the new data\n', '    _ownersClaimPriceOf[cardAddress][firstMatchedIndex] = amount;\n', '\n', '    // now update our statistics\n', '    updateCardStatistics(cardAddress);\n', '\n', '    // dev receives the wagering fee\n', '    _balanceOf[dev] = SafeMath.add(_balanceOf[dev], wageringFee);\n', '\n', "    // now that we're done, it's time to log the event\n", '    AddressCardWasWagered(cardAddress, msg.sender, amount);\n', '\n', '  }\n', '\n', '  function cancelWagerOfCard(address cardAddress) public {\n', '\n', '    require(cardAddressExists(msg.sender));\n', '\n', '    uint256 firstMatchedIndex;\n', '    bool isAlreadyWagered;\n', '    (firstMatchedIndex, isAlreadyWagered, , , ) = getOwnerOfCardsCheapestWager(msg.sender, cardAddress);\n', '    // calling the above method will automatically reinforce the check that the cardAddress exists\n', '    // as well as the owner actually owning the card\n', '    // we can only cancel a wager if there already is one\n', '    require(isAlreadyWagered);\n', '    // double check to make sure the card is actually owned by the sender\n', '    require(msg.sender == _ownersOf[cardAddress][firstMatchedIndex]);\n', '\n', '    // now write the new data\n', '    _ownersClaimPriceOf[cardAddress][firstMatchedIndex] = 0;\n', '\n', '    // now update our statistics\n', '    updateCardStatistics(cardAddress);\n', '\n', "    // now that we're done, it's time to log the event\n", '    AddressCardWagerWasCancelled(cardAddress, msg.sender);\n', '\n', '  }\n', '\n', '  // this is the main battle function of the contract, it takes the card address you\n', '  // wish to claim as well as your card choices as input. a lot of complex calculations\n', '  // happen within this function and in the end, a result will be determined on whether\n', '  // you won the claim or not. at the end, an event will be logged with all of the information\n', '  // about what happened in the battle including the final result, the contenders,\n', '  // the card choices (yours and your opponenets) as well as the final attack and defence numbers.\n', '  // this function will revert if the msg.value does not match the current minimum claim value\n', '  // of the card address you are attempting to claim.\n', '  function attemptToClaimCard(address cardAddress, address[3] choices) public payable {\n', '\n', '    // a lot of the functionality of attemptToClaimCard() is calculated in other methods as\n', '    // there is only a 16 local variable limit per method and we need a lot more than that\n', '\n', '    // see ownerCanClaimCard() below, this ensures we can actually claim the card we are after\n', '    // by running through various requirement checks\n', '    address claimContender;\n', '    uint256 claimContenderIndex;\n', '    (claimContender, claimContenderIndex) = ownerCanClaimCard(msg.sender, cardAddress, choices, msg.value);\n', '\n', '    address[3] memory opponentCardChoices = generateCardsFromClaimForOpponent(cardAddress, claimContender);\n', '\n', '    uint256[3][2] memory allFinalAttackFigures;\n', '    uint256[3][2] memory allFinalDefenceFigures;\n', '    (allFinalAttackFigures, allFinalDefenceFigures) = calculateAdjustedFiguresForBattle(choices, opponentCardChoices);\n', '    // after this point we have all of the modified attack and defence figures\n', '    // in the arrays above. the way the winner is determined is by counting \n', '    // how many attack points get through in total for each card, this is\n', '    // calculated by simply doing;\n', '    // opponentsHits = yourCard[attack] - opponentsCard[defence]\n', '    // if the defence of the opposing card is greater than the attack value,\n', '    // no hits will be taken.\n', '    // at the end, all hits are added up and the winner is the one with\n', '    // the least total amount of hits, if it is a draw, the wager will be\n', '    // returned to the sender (minus the dev fee)\n', '    uint256[2] memory totalHits = [ uint256(0), uint256(0) ];\n', '    for (uint256 i = 0; i < 3; i++) {\n', '      // start with the opponent attack to you\n', '      totalHits[0] += (allFinalAttackFigures[1][i] > allFinalDefenceFigures[0][i] ? allFinalAttackFigures[1][i] - allFinalDefenceFigures[0][i] : 0);\n', '      // then your attack to the opponent\n', '      totalHits[1] += (allFinalAttackFigures[0][i] > allFinalDefenceFigures[1][i] ? allFinalAttackFigures[0][i] - allFinalDefenceFigures[1][i] : 0);\n', '    }\n', '\n', '    // before we process the outcome, we should log the event.\n', '    // order is important here as we should log a successful \n', "    // claim attempt then a transfer (if that's what happens)\n", '    // instead of the other way around\n', '    ClaimAttempt(\n', '      totalHits[0] < totalHits[1], // it was successful if we had less hits than the opponent\n', '      cardAddress,\n', '      msg.sender,\n', '      claimContender,\n', '      choices,\n', '      opponentCardChoices,\n', '      allFinalAttackFigures,\n', '      allFinalDefenceFigures\n', '      );\n', '\n', '    // handle the outcomes\n', '    uint256 tmpAmount;\n', '    if (totalHits[0] == totalHits[1]) { // we have a draw\n', '\n', '      // hand out the dev tax\n', '      tmpAmount = SafeMath.div(SafeMath.mul(msg.value, devTax), 100); // 2%\n', '      _balanceOf[dev] = SafeMath.add(_balanceOf[dev], tmpAmount);\n', '      // now we return the rest to the sender\n', '      _balanceOf[msg.sender] = SafeMath.add(_balanceOf[msg.sender], SafeMath.sub(msg.value, tmpAmount)); // 98%\n', '\n', '    } else if (totalHits[0] > totalHits[1]) { // we have more hits so we were unsuccessful\n', '\n', '      // hand out the dev tax\n', '      tmpAmount = SafeMath.div(SafeMath.mul(msg.value, devTax), 100); // 2%\n', '      _balanceOf[dev] = SafeMath.add(_balanceOf[dev], tmpAmount);\n', '      // now we give the rest to the claim contender\n', '      _balanceOf[claimContender] = SafeMath.add(_balanceOf[claimContender], SafeMath.sub(msg.value, tmpAmount)); // 98%\n', '\n', '    } else { // this means we have less hits than the opponent so we were successful in our claim!\n', '\n', '      // hand out the dev tax\n', '      tmpAmount = SafeMath.div(SafeMath.mul(msg.value, devTax), 100); // 2%\n', '      _balanceOf[dev] = SafeMath.add(_balanceOf[dev], tmpAmount);\n', '      // return half to the sender\n', '      _balanceOf[msg.sender] = SafeMath.add(_balanceOf[msg.sender], SafeMath.div(msg.value, 2)); // 50%\n', '      // and now the remainder goes to the claim contender\n', '      _balanceOf[claimContender] = SafeMath.add(_balanceOf[claimContender], SafeMath.sub(SafeMath.div(msg.value, 2), tmpAmount)); // 48%\n', '\n', '      // finally transfer the ownership of the card from the claim contender to the sender but\n', '      // first we need to make sure to cancel the wager\n', '      _ownersClaimPriceOf[cardAddress][claimContenderIndex] = 0;\n', '      transferCard(cardAddress, claimContender, msg.sender);\n', '\n', '      // now update our statistics\n', '      updateCardStatistics(cardAddress);\n', '\n', '    }\n', '\n', '  }\n', '\n', '  function transferCardTo(address cardAddress, address toAddress) public {\n', '\n', '    // you can view this internal method below for more details.\n', '    // all of the requirements around transferring a card are\n', '    // tested within the transferCard() method.\n', '    // you are free to gift your own address card to anyone\n', '    // (assuming there are less than 10 copies circulating).\n', '    transferCard(cardAddress, msg.sender, toAddress);\n', '\n', '  }\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Wallet Functions\n', '\n', '\n', '  function withdrawAmount(uint256 amount) public {\n', '\n', '    require(amount > 0);\n', '\n', '    address sender = msg.sender;\n', '    uint256 balance = _balanceOf[sender];\n', '    \n', '    require(amount <= balance);\n', '    // transfer and update the balances\n', '    _balanceOf[sender] = SafeMath.sub(_balanceOf[sender], amount);\n', '    sender.transfer(amount);\n', '\n', '  }\n', '\n', '  function withdrawAll() public {\n', '\n', '    address sender = msg.sender;\n', '    uint256 balance = _balanceOf[sender];\n', '\n', '    require(balance > 0);\n', '    // transfer and update the balances\n', '    _balanceOf[sender] = 0;\n', '    sender.transfer(balance);\n', '\n', '  }\n', '\n', '  function getBalanceOfSender() public view returns (uint256) {\n', '    return _balanceOf[msg.sender];\n', '  }\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Helper Functions\n', '\n', '\n', '  function tmpShuffleSeed(uint256 tmpSeed, uint256 mix) public view returns (uint256) {\n', '\n', '    // really mix it up!\n', '    uint256 newTmpSeed = tmpSeed;\n', '    uint256 currentTime = now;\n', '    uint256 timeMix = currentTime + mix;\n', '    // in this instance, overflow is ok as we are just shuffling around the bits\n', '    // first lets square the seed\n', '    newTmpSeed *= newTmpSeed;\n', '    // now add our time and mix\n', '    newTmpSeed += timeMix;\n', '    // multiply by the time\n', '    newTmpSeed *= currentTime;\n', '    // now add our mix\n', '    newTmpSeed += mix;\n', '    // and finally multiply by the time and mix\n', '    newTmpSeed *= timeMix;\n', '\n', '    return newTmpSeed;\n', '\n', '  }\n', '\n', '  function shuffleSeed(uint256 mix) private {\n', '\n', '    // set our seed based on our last seed\n', '    _seed = tmpShuffleSeed(_seed, mix);\n', '  \n', '  }\n', '\n', '  function tmpQuerySeed(uint256 tmpSeed, uint256 modulus) public view returns (uint256 tmpShuffledSeed, uint256 result) {\n', '\n', '    require(modulus > 0);\n', '\n', '    // get our answer\n', '    uint256 response = tmpSeed % modulus;\n', '\n', '    // now we want to re-mix our seed based off our response\n', '    uint256 mix = response + 1; // non-zero\n', '    mix *= modulus;\n', '    mix += response;\n', '    mix *= modulus;\n', '\n', '    // now return it\n', '    return (tmpShuffleSeed(tmpSeed, mix), response);\n', '\n', '  }\n', '\n', '  function querySeed(uint256 modulus) private returns (uint256) {\n', '\n', '    require(modulus > 0);\n', '\n', '    uint256 tmpSeed;\n', '    uint256 response;\n', '    (tmpSeed, response) = tmpQuerySeed(_seed, modulus);\n', '\n', '    // tmpSeed will now represent the suffled version of our last seed\n', '    _seed = tmpSeed;\n', '\n', '    // now return it\n', '    return response;\n', '\n', '  }\n', '\n', '  function cumulativeIndexOf(uint256[] array, uint256 target) private pure returns (uint256) {\n', '\n', '    bool hasFound = false;\n', '    uint256 index;\n', '    uint256 cumulativeTotal = 0;\n', '    for (uint256 i = 0; i < array.length; i++) {\n', '      cumulativeTotal += array[i];\n', '      if (cumulativeTotal > target) {\n', '        hasFound = true;\n', '        index = i;\n', '        break;\n', '      }\n', '    }\n', '\n', '    require(hasFound);\n', '    return index;\n', '\n', '  }\n', '\n', '  function cardAddressExists(address cardAddress) public view returns (bool) {\n', '    return _exists[cardAddress];\n', '  }\n', '\n', '  function indexOfCardAddress(address cardAddress) public view returns (uint256) {\n', '    require(cardAddressExists(cardAddress));\n', '    return _indexOf[cardAddress];\n', '  }\n', '\n', '  function ownerCountOfCard(address owner, address cardAddress) public view returns (uint256) {\n', '\n', '    // both card addresses need to exist in order to own cards\n', '    require(cardAddressExists(owner));\n', '    require(cardAddressExists(cardAddress));\n', '\n', "    // check if it's your own address\n", '    if (owner == cardAddress) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 ownerCount = 0;\n', '    address[] memory owners = _ownersOf[cardAddress];\n', '    for (uint256 i = 0; i < owners.length; i++) {\n', '      if (owner == owners[i]) {\n', '        ownerCount++;\n', '      }\n', '    }\n', '\n', '    return ownerCount;\n', '\n', '  }\n', '\n', '  function ownerHasCard(address owner, address cardAddress) public view returns (bool doesOwn, uint256[] indexes) {\n', '\n', '    // both card addresses need to exist in order to own cards\n', '    require(cardAddressExists(owner));\n', '    require(cardAddressExists(cardAddress));\n', '\n', '    uint256[] memory ownerIndexes = new uint256[](ownerCountOfCard(owner, cardAddress));\n', "    // check if it's your own address\n", '    if (owner == cardAddress) {\n', '      return (true, ownerIndexes);\n', '    }\n', '\n', '    if (ownerIndexes.length > 0) {\n', '      uint256 currentIndex = 0;\n', '      address[] memory owners = _ownersOf[cardAddress];\n', '      for (uint256 i = 0; i < owners.length; i++) {\n', '        if (owner == owners[i]) {\n', '          ownerIndexes[currentIndex] = i;\n', '          currentIndex++;\n', '        }\n', '      }\n', '    }\n', '\n', '    // this owner may own multiple copies of the card and so an array of indexes are returned\n', '    // if the owner does not own the card, it will return (false, [])\n', '    return (ownerIndexes.length > 0, ownerIndexes);\n', '\n', '  }\n', '\n', '  function ownerHasCardSimple(address owner, address cardAddress) private view returns (bool) {\n', '\n', '    bool doesOwn;\n', '    (doesOwn, ) = ownerHasCard(owner, cardAddress);\n', '    return doesOwn;\n', '\n', '  }\n', '\n', '  function ownerCanClaimCard(address owner, address cardAddress, address[3] choices, uint256 amount) private view returns (address currentClaimContender, uint256 claimContenderIndex) {\n', '\n', '    // you cannot claim back your own address cards\n', '    require(owner != cardAddress);\n', '    require(cardAddressExists(owner));\n', '    require(ownerHasCardSimple(owner, cardAddress) || _cardsOf[owner].length < MAX_UNIQUE_CARDS_PER_ADDRESS);\n', '\n', '\n', '    uint256 cheapestIndex;\n', '    bool canClaim;\n', '    address claimContender;\n', '    uint256 lowestClaimPrice;\n', '    (cheapestIndex, canClaim, claimContender, lowestClaimPrice, ) = getCheapestCardWager(cardAddress);\n', '    // make sure we can actually claim it and that we are paying the correct amount\n', '    require(canClaim);\n', '    require(amount == lowestClaimPrice);\n', '    // we also need to check that the sender is not the current claim contender\n', '    require(owner != claimContender);\n', '\n', '    // now check if we own all of our choices\n', '    for (uint256 i = 0; i < choices.length; i++) {\n', '      require(ownerHasCardSimple(owner, choices[i])); // if one is not owned, it will trigger a revert\n', '    }\n', '\n', '    // if no requires have been triggered by this point it means we are able to claim the card\n', '    // now return the claim contender and their index\n', '    return (claimContender, cheapestIndex);\n', '\n', '  }\n', '\n', '  function generateCardsFromClaimForOpponent(address cardAddress, address opponentAddress) private returns (address[3]) {\n', '\n', '    require(cardAddressExists(cardAddress));\n', '    require(cardAddressExists(opponentAddress));\n', '    require(ownerHasCardSimple(opponentAddress, cardAddress));\n', '\n', '    // generate the opponents cards from their own inventory\n', '    // it is important to note that at least 1 of their choices\n', '    // needs to be the card you are attempting to claim\n', '    address[] memory cardsOfOpponent = _cardsOf[opponentAddress];\n', '    address[3] memory opponentCardChoices;\n', '    uint256 tmpSeed = tmpShuffleSeed(_seed, uint256(opponentAddress));\n', '    uint256 tmpModulus;\n', '    uint256 indexOfClaimableCard;\n', '    (tmpSeed, indexOfClaimableCard) = tmpQuerySeed(tmpSeed, 3); // 0, 1 or 2\n', '    for (uint256 i = 0; i < 3; i++) {\n', '      if (i == indexOfClaimableCard) {\n', '        opponentCardChoices[i] = cardAddress;\n', '      } else {\n', '        (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, cardsOfOpponent.length);\n', '        opponentCardChoices[i] = cardsOfOpponent[tmpModulus];        \n', '      }\n', '    }\n', '\n', '    // finally we need to update the main seed and as we initially started with\n', '    // the current main seed, tmpSeed will be the current representation of the seed\n', '    _seed = tmpSeed;\n', '\n', '    return opponentCardChoices;\n', '\n', '  }\n', '\n', '  function updateCardStatistics(address cardAddress) private {\n', '\n', '    AddressCard storage addressCardClaimed = _addressCards[_indexOf[cardAddress]];\n', '    address claimContender;\n', '    uint256 lowestClaimPrice;\n', '    uint256 wagerCount;\n', '    ( , , claimContender, lowestClaimPrice, wagerCount) = getCheapestCardWager(cardAddress);\n', '    addressCardClaimed._forClaim = uint8(wagerCount);\n', '    addressCardClaimed._lowestPrice = lowestClaimPrice;\n', '    addressCardClaimed._claimContender = claimContender;\n', '\n', '  }\n', '\n', '  function transferCard(address cardAddress, address fromAddress, address toAddress) private {\n', '\n', '    require(toAddress != fromAddress);\n', '    require(cardAddressExists(cardAddress));\n', '    require(cardAddressExists(fromAddress));\n', '    uint256 firstMatchedIndex;\n', '    bool isWagered;\n', '    (firstMatchedIndex, isWagered, , , ) = getOwnerOfCardsCheapestWager(fromAddress, cardAddress);\n', "    require(isWagered == false); // you cannot transfer a card if it's currently wagered\n", '\n', '    require(cardAddressExists(toAddress));\n', "    require(toAddress != cardAddress); // can't transfer a card to it's original address\n", '    require(ownerHasCardSimple(toAddress, cardAddress) || _cardsOf[toAddress].length < MAX_UNIQUE_CARDS_PER_ADDRESS);\n', '\n', "    // firstly, if toAddress doesn't have a copy we need to add one\n", '    if (!ownerHasCardSimple(toAddress, cardAddress)) {\n', '      _cardsOf[toAddress].push(cardAddress);\n', '    } \n', '\n', '    // now check whether the fromAddress is just our original card\n', '    // address, if this is the case, they are free to transfer out\n', '    // one of their cards assuming the claim limit is not yet reached\n', '    if (fromAddress == cardAddress) { // the card is being claimed/gifted\n', '\n', '      AddressCard storage addressCardClaimed = _addressCards[_indexOf[cardAddress]];\n', '      require(addressCardClaimed._claimed < CLAIM_LIMIT);\n', '\n', '      // we need to push new data to our arrays\n', '      _ownersOf[cardAddress].push(toAddress);\n', '      _ownersClaimPriceOf[cardAddress].push(uint256(0));\n', '\n', '      // now update the claimed count in the registry\n', '      addressCardClaimed._claimed = uint8(_ownersOf[cardAddress].length - 1); // we exclude the original address\n', '\n', '    } else {\n', '\n', "      // firstly we need to cache the current index from our fromAddress' _cardsOf\n", '      uint256 cardIndexOfSender = getCardIndexOfOwner(cardAddress, fromAddress);\n', '\n', '      // now just update the address at the firstMatchedIndex\n', '      _ownersOf[cardAddress][firstMatchedIndex] = toAddress;\n', '\n', '      // finally check if our fromAddress has any copies of the card left\n', '      if (!ownerHasCardSimple(fromAddress, cardAddress)) {\n', '\n', '        // if not delete that card from their inventory and make room in the array\n', '        for (uint256 i = cardIndexOfSender; i < _cardsOf[fromAddress].length - 1; i++) {\n', '          // shuffle the next value over\n', '          _cardsOf[fromAddress][i] = _cardsOf[fromAddress][i + 1];\n', '        }\n', '        // now decrease the length\n', '        _cardsOf[fromAddress].length--;\n', '\n', '      }\n', '\n', '    }\n', '\n', "    // now that we're done, it's time to log the event\n", '    AddressCardWasTransferred(cardAddress, fromAddress, toAddress);\n', '\n', '  }\n', '\n', '  function calculateAdjustedFiguresForBattle(address[3] yourChoices, address[3] opponentsChoices) private view returns (uint256[3][2] allAdjustedAttackFigures, uint256[3][2] allAdjustedDefenceFigures) {\n', '\n', '    // [0] is yours, [1] is your opponents\n', '    AddressCard[3][2] memory allCards;\n', '    uint256[3][2] memory allAttackFigures;\n', '    uint256[3][2] memory allDefenceFigures;\n', '    bool[2] memory allOfSameType = [ true, true ];\n', '    uint256[2] memory cumulativeAttackBonuses = [ uint256(0), uint256(0) ];\n', '    uint256[2] memory cumulativeDefenceBonuses = [ uint256(0), uint256(0) ];\n', '\n', '    for (uint256 i = 0; i < 3; i++) {\n', '      // cache your cards\n', '      require(_exists[yourChoices[i]]);\n', '      allCards[0][i] = _addressCards[_indexOf[yourChoices[i]]];\n', '      allAttackFigures[0][i] = allCards[0][i]._attack;\n', '      allDefenceFigures[0][i] = allCards[0][i]._defence;\n', '\n', '      // cache your opponents cards\n', '      require(_exists[opponentsChoices[i]]);\n', '      allCards[1][i] = _addressCards[_indexOf[opponentsChoices[i]]];\n', '      allAttackFigures[1][i] = allCards[1][i]._attack;\n', '      allDefenceFigures[1][i] = allCards[1][i]._defence;\n', '    }\n', '\n', '    // for the next part, order is quite important as we want the\n', '    // addition to happen first and then the multiplication to happen \n', '    // at the very end for the type advantages/resistances\n', '\n', '    //////////////////////////////////////////////////////////////\n', '    // the first modifiers that needs to be applied is the\n', '    // ALL_ATT, ALL_DEF and the ALL_ATT_DEF mod\n', '    // if all 3 of the chosen cards match the same type\n', '    // and if at least one of them have the ALL_ATT, ALL_DEF\n', '    // or ALL_ATT_DEF modifier, all of the cards will receive\n', '    // the cumulative bonus for att/def/att+def\n', '    for (i = 0; i < 3; i++) {\n', '\n', '      // start with your cards      \n', '      // compare to see if the types are the same as the previous one\n', '      if (i > 0 && allCards[0][i]._cardType != allCards[0][i - 1]._cardType) {\n', '        allOfSameType[0] = false;\n', '      }\n', '      // next count up all the modifier values for a total possible bonus\n', '      if (allCards[0][i]._cardModifier == uint256(MODIFIER.ALL_ATT)) { // all attack\n', '        // for the ALL_ATT modifier, the additional attack bonus is\n', '        // stored in the primary value\n', '        cumulativeAttackBonuses[0] += allCards[0][i]._modifierPrimarayVal;\n', '      } else if (allCards[0][i]._cardModifier == uint256(MODIFIER.ALL_DEF)) { // all defence\n', '        // for the ALL_DEF modifier, the additional defence bonus is\n', '        // stored in the primary value\n', '        cumulativeDefenceBonuses[0] += allCards[0][i]._modifierPrimarayVal;\n', '      } else if (allCards[0][i]._cardModifier == uint256(MODIFIER.ALL_ATT_DEF)) { // all attack + defence\n', '        // for the ALL_ATT_DEF modifier, the additional attack bonus is\n', '        // stored in the primary value and the additional defence bonus is\n', '        // stored in the secondary value\n', '        cumulativeAttackBonuses[0] += allCards[0][i]._modifierPrimarayVal;\n', '        cumulativeDefenceBonuses[0] += allCards[0][i]._modifierSecondaryVal;\n', '      }\n', '      \n', '      // now do the same for your opponent\n', '      if (i > 0 && allCards[1][i]._cardType != allCards[1][i - 1]._cardType) {\n', '        allOfSameType[1] = false;\n', '      }\n', '      if (allCards[1][i]._cardModifier == uint256(MODIFIER.ALL_ATT)) {\n', '        cumulativeAttackBonuses[1] += allCards[1][i]._modifierPrimarayVal;\n', '      } else if (allCards[1][i]._cardModifier == uint256(MODIFIER.ALL_DEF)) {\n', '        cumulativeDefenceBonuses[1] += allCards[1][i]._modifierPrimarayVal;\n', '      } else if (allCards[1][i]._cardModifier == uint256(MODIFIER.ALL_ATT_DEF)) {\n', '        cumulativeAttackBonuses[1] += allCards[1][i]._modifierPrimarayVal;\n', '        cumulativeDefenceBonuses[1] += allCards[1][i]._modifierSecondaryVal;\n', '      }\n', '\n', '    }\n', "    // we void our bonus if they aren't all of the type\n", '    if (!allOfSameType[0]) {\n', '      cumulativeAttackBonuses[0] = 0;\n', '      cumulativeDefenceBonuses[0] = 0;\n', '    }\n', '    if (!allOfSameType[1]) {\n', '      cumulativeAttackBonuses[1] = 0;\n', '      cumulativeDefenceBonuses[1] = 0;\n', '    }\n', '    // now add the bonus figures to the initial attack numbers, they will be 0\n', "    // if they either weren't all of the same type or if no cards actually had\n", '    // the ALL_ modifier\n', '    for (i = 0; i < 3; i++) {\n', '      // for your cards\n', '      allAttackFigures[0][i] += cumulativeAttackBonuses[0];\n', '      allDefenceFigures[0][i] += cumulativeDefenceBonuses[0];\n', '\n', '      // ...and your opponents cards\n', '      allAttackFigures[1][i] += cumulativeAttackBonuses[1];\n', '      allDefenceFigures[1][i] += cumulativeDefenceBonuses[1]; \n', '    }\n', '\n', '    //////////////////////////////////////////////////////////////\n', '    // the second modifier that needs to be applied is the V_ATT\n', '    // or the V_DEF mod\n', '    // if the versing card matches the same type listed in the\n', '    // primaryModifierVal, that card will receive the bonus in\n', '    // secondaryModifierVal for att/def\n', '    for (i = 0; i < 3; i++) {\n', '\n', '      // start with your cards      \n', '      if (allCards[0][i]._cardModifier == uint256(MODIFIER.V_ATT)) { // versing attack\n', '        // check if the versing cards type matches the primary value\n', '        if (allCards[1][i]._cardType == allCards[0][i]._modifierPrimarayVal) {\n', '          // add the attack bonus (amount is held in the secondary value)\n', '          allAttackFigures[0][i] += allCards[0][i]._modifierSecondaryVal;\n', '        }\n', '      } else if (allCards[0][i]._cardModifier == uint256(MODIFIER.V_DEF)) { // versing defence\n', '        // check if the versing cards type matches the primary value\n', '        if (allCards[1][i]._cardType == allCards[0][i]._modifierPrimarayVal) {\n', '          // add the defence bonus (amount is held in the secondary value)\n', '          allDefenceFigures[0][i] += allCards[0][i]._modifierSecondaryVal;\n', '        }\n', '      }\n', '\n', '      // now do the same for your opponent\n', '      if (allCards[1][i]._cardModifier == uint256(MODIFIER.V_ATT)) {\n', '        if (allCards[0][i]._cardType == allCards[1][i]._modifierPrimarayVal) {\n', '          allAttackFigures[1][i] += allCards[1][i]._modifierSecondaryVal;\n', '        }\n', '      } else if (allCards[1][i]._cardModifier == uint256(MODIFIER.V_DEF)) {\n', '        if (allCards[0][i]._cardType == allCards[1][i]._modifierPrimarayVal) {\n', '          allDefenceFigures[1][i] += allCards[1][i]._modifierSecondaryVal;\n', '        }\n', '      }\n', '\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////////\n', '    // the third modifier that needs to be applied is the type\n', '    // advantage numbers as well as applying R_V (resists versing\n', '    // cards type advantage) and A_I (increases your cards advantage)\n', '    for (i = 0; i < 3; i++) {\n', '\n', '      // start with your cards\n', "      // first check if the card we're versing resists our type advantage\n", '      if (allCards[1][i]._cardModifier != uint256(MODIFIER.R_V)) {\n', '        // test all the possible combinations of advantages\n', '        if (\n', '          // fire vs nature\n', '          (allCards[0][i]._cardType == uint256(TYPE.FIRE) && allCards[1][i]._cardType == uint256(TYPE.NATURE)) ||\n', '          // water vs fire\n', '          (allCards[0][i]._cardType == uint256(TYPE.WATER) && allCards[1][i]._cardType == uint256(TYPE.FIRE)) ||\n', '          // nature vs water\n', '          (allCards[0][i]._cardType == uint256(TYPE.NATURE) && allCards[1][i]._cardType == uint256(TYPE.WATER))\n', '          ) {\n', '\n', '          // now check if your card has a type advantage increase modifier\n', '          if (allCards[0][i]._cardModifier == uint256(MODIFIER.A_I)) {\n', '            allAttackFigures[0][i] = SafeMath.div(SafeMath.mul(allAttackFigures[0][i], 3), 2); // x1.5\n', '            allDefenceFigures[0][i] = SafeMath.div(SafeMath.mul(allDefenceFigures[0][i], 3), 2); // x1.5\n', '          } else {\n', '            allAttackFigures[0][i] = SafeMath.div(SafeMath.mul(allAttackFigures[0][i], 5), 4); // x1.25\n', '            allDefenceFigures[0][i] = SafeMath.div(SafeMath.mul(allDefenceFigures[0][i], 5), 4); // x1.25\n', '          }\n', '        }\n', '      }\n', '\n', '      // now do the same for your opponent\n', '      if (allCards[0][i]._cardModifier != uint256(MODIFIER.R_V)) {\n', '        if (\n', '          (allCards[1][i]._cardType == uint256(TYPE.FIRE) && allCards[0][i]._cardType == uint256(TYPE.NATURE)) ||\n', '          (allCards[1][i]._cardType == uint256(TYPE.WATER) && allCards[0][i]._cardType == uint256(TYPE.FIRE)) ||\n', '          (allCards[1][i]._cardType == uint256(TYPE.NATURE) && allCards[0][i]._cardType == uint256(TYPE.WATER))\n', '          ) {\n', '          if (allCards[1][i]._cardModifier == uint256(MODIFIER.A_I)) {\n', '            allAttackFigures[1][i] = SafeMath.div(SafeMath.mul(allAttackFigures[1][i], 3), 2); // x1.5\n', '            allDefenceFigures[1][i] = SafeMath.div(SafeMath.mul(allDefenceFigures[1][i], 3), 2); // x1.5\n', '          } else {\n', '            allAttackFigures[1][i] = SafeMath.div(SafeMath.mul(allAttackFigures[1][i], 5), 4); // x1.25\n', '            allDefenceFigures[1][i] = SafeMath.div(SafeMath.mul(allDefenceFigures[1][i], 5), 4); // x1.25\n', '          }\n', '        }\n', '      }\n', '\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////////\n', '    // the final modifier that needs to be applied is the V_SWAP mod\n', '    // if your card has this modifier, it will swap the final attack\n', '    // and defence numbers of your card\n', '    uint256 tmp;\n', '    for (i = 0; i < 3; i++) {\n', '\n', '      // start with your cards\n', '      // check if the versing card has the V_SWAP modifier\n', '      if (allCards[1][i]._cardModifier == uint256(MODIFIER.V_SWAP)) {\n', '        tmp = allAttackFigures[0][i];\n', '        allAttackFigures[0][i] = allDefenceFigures[0][i];\n', '        allDefenceFigures[0][i] = tmp;\n', '      }\n', '      // ...and your opponents cards\n', '      if (allCards[0][i]._cardModifier == uint256(MODIFIER.V_SWAP)) {\n', '        tmp = allAttackFigures[1][i];\n', '        allAttackFigures[1][i] = allDefenceFigures[1][i];\n', '        allDefenceFigures[1][i] = tmp;\n', '      }\n', '\n', '    }\n', '\n', "    // we're all done!\n", '    return (allAttackFigures, allDefenceFigures);\n', '\n', '  }\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  //  Getter Functions\n', '\n', '\n', '  function getCard(address cardAddress) public view returns (uint256 cardIndex, uint256 cardType, uint256 cardModifier, uint256 cardModifierPrimaryVal, uint256 cardModifierSecondaryVal, uint256 attack, uint256 defence, uint256 claimed, uint256 forClaim, uint256 lowestPrice, address claimContender) {\n', '\n', '    require(cardAddressExists(cardAddress));\n', '\n', '    uint256 index = _indexOf[cardAddress];\n', '    AddressCard memory addressCard = _addressCards[index];\n', '    return (\n', '        index,\n', '        uint256(addressCard._cardType),\n', '        uint256(addressCard._cardModifier),\n', '        uint256(addressCard._modifierPrimarayVal),\n', '        uint256(addressCard._modifierSecondaryVal),\n', '        uint256(addressCard._attack),\n', '        uint256(addressCard._defence),\n', '        uint256(addressCard._claimed),\n', '        uint256(addressCard._forClaim),\n', '        uint256(addressCard._lowestPrice),\n', '        address(addressCard._claimContender)\n', '      );\n', '\n', '  }\n', '\n', '  function getCheapestCardWager(address cardAddress) public view returns (uint256 cheapestIndex, bool isClaimable, address claimContender, uint256 claimPrice, uint256 wagerCount) {\n', '\n', '    require(cardAddressExists(cardAddress));\n', '\n', '    uint256 cheapestSale = 0;\n', '    uint256 indexOfCheapestSale = 0;\n', '    uint256 totalWagers = 0;\n', '    uint256[] memory allOwnersClaimPrice = _ownersClaimPriceOf[cardAddress];\n', '    for (uint256 i = 0; i < allOwnersClaimPrice.length; i++) {\n', '      uint256 priceAtIndex = allOwnersClaimPrice[i];\n', '      if (priceAtIndex != 0) {\n', '        totalWagers++;\n', '        if (cheapestSale == 0 || priceAtIndex < cheapestSale) {\n', '          cheapestSale = priceAtIndex;\n', '          indexOfCheapestSale = i;\n', '        }\n', '      }\n', '    }\n', '\n', '    return (\n', '        indexOfCheapestSale,\n', '        (cheapestSale > 0),\n', '        (cheapestSale > 0 ? _ownersOf[cardAddress][indexOfCheapestSale] : address(0)),\n', '        cheapestSale,\n', '        totalWagers\n', '      );\n', '\n', '  }\n', '\n', '  function getOwnerOfCardsCheapestWager(address owner, address cardAddress) public view returns (uint256 cheapestIndex, bool isSelling, uint256 claimPrice, uint256 priceRank, uint256 outOf) {\n', '\n', '    bool doesOwn;\n', '    uint256[] memory indexes;\n', '    (doesOwn, indexes) = ownerHasCard(owner, cardAddress);\n', '    require(doesOwn);\n', '\n', '    uint256[] memory allOwnersClaimPrice = _ownersClaimPriceOf[cardAddress];\n', '    uint256 cheapestSale = 0;\n', '    uint256 indexOfCheapestSale = 0; // this will handle the case of owner == cardAddress\n', '    if (indexes.length > 0) {\n', '      indexOfCheapestSale = indexes[0]; // defaults to the first index matched\n', '    } else { // also will handle the case of owner == cardAddress\n', '      cheapestSale = allOwnersClaimPrice[0];\n', '    }\n', '\n', '    for (uint256 i = 0; i < indexes.length; i++) {\n', '      if (allOwnersClaimPrice[indexes[i]] != 0 && (cheapestSale == 0 || allOwnersClaimPrice[indexes[i]] < cheapestSale)) {\n', '        cheapestSale = allOwnersClaimPrice[indexes[i]];\n', '        indexOfCheapestSale = indexes[i];\n', '      }\n', '    }\n', '\n', '    uint256 saleRank = 0;\n', '    uint256 totalWagers = 0;\n', '    if (cheapestSale > 0) {\n', '      saleRank = 1;\n', '      for (i = 0; i < allOwnersClaimPrice.length; i++) {\n', '        if (allOwnersClaimPrice[i] != 0) {\n', '          totalWagers++;\n', '          if (allOwnersClaimPrice[i] < cheapestSale) {\n', '            saleRank++;\n', '          }\n', '        }\n', '      }\n', '    }\n', '\n', '    return (\n', '        indexOfCheapestSale,\n', '        (cheapestSale > 0),\n', '        cheapestSale,\n', '        saleRank,\n', '        totalWagers\n', '      );\n', '\n', '  }\n', '\n', '  function getCardIndexOfOwner(address cardAddress, address owner) public view returns (uint256) {\n', '\n', '    require(cardAddressExists(cardAddress));\n', '    require(cardAddressExists(owner));\n', '    require(ownerHasCardSimple(owner, cardAddress));\n', '\n', '    uint256 matchedIndex;\n', '    address[] memory cardsOfOwner = _cardsOf[owner];\n', '    for (uint256 i = 0; i < cardsOfOwner.length; i++) {\n', '      if (cardsOfOwner[i] == cardAddress) {\n', '        matchedIndex = i;\n', '        break;\n', '      }\n', '    }\n', '\n', '    return matchedIndex;\n', '\n', '  }\n', '  \n', '  function getTotalUniqueCards() public view returns (uint256) {\n', '    return _addressCards.length;\n', '  }\n', '  \n', '  function getAllCardsAddress() public view returns (bytes20[]) {\n', '\n', '    bytes20[] memory allCardsAddress = new bytes20[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsAddress[i] = bytes20(addressCard._cardAddress);\n', '    }\n', '    return allCardsAddress;\n', '\n', '  }\n', '\n', '  function getAllCardsType() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsType = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsType[i] = bytes1(addressCard._cardType);\n', '    }\n', '    return allCardsType;\n', '\n', '  }\n', '\n', '  function getAllCardsModifier() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsModifier = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsModifier[i] = bytes1(addressCard._cardModifier);\n', '    }\n', '    return allCardsModifier;\n', '\n', '  }\n', '\n', '  function getAllCardsModifierPrimaryVal() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsModifierPrimaryVal = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsModifierPrimaryVal[i] = bytes1(addressCard._modifierPrimarayVal);\n', '    }\n', '    return allCardsModifierPrimaryVal;\n', '\n', '  }\n', '\n', '  function getAllCardsModifierSecondaryVal() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsModifierSecondaryVal = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsModifierSecondaryVal[i] = bytes1(addressCard._modifierSecondaryVal);\n', '    }\n', '    return allCardsModifierSecondaryVal;\n', '\n', '  }\n', '\n', '  function getAllCardsAttack() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsAttack = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsAttack[i] = bytes1(addressCard._attack);\n', '    }\n', '    return allCardsAttack;\n', '\n', '  }\n', '\n', '  function getAllCardsDefence() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsDefence = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsDefence[i] = bytes1(addressCard._defence);\n', '    }\n', '    return allCardsDefence;\n', '\n', '  }\n', '\n', '  function getAllCardsClaimed() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsClaimed = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsClaimed[i] = bytes1(addressCard._claimed);\n', '    }\n', '    return allCardsClaimed;\n', '\n', '  }\n', '\n', '  function getAllCardsForClaim() public view returns (bytes1[]) {\n', '\n', '    bytes1[] memory allCardsForClaim = new bytes1[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsForClaim[i] = bytes1(addressCard._forClaim);\n', '    }\n', '    return allCardsForClaim;\n', '\n', '  }\n', '\n', '  function getAllCardsLowestPrice() public view returns (bytes32[]) {\n', '\n', '    bytes32[] memory allCardsLowestPrice = new bytes32[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsLowestPrice[i] = bytes32(addressCard._lowestPrice);\n', '    }\n', '    return allCardsLowestPrice;\n', '\n', '  }\n', '\n', '  function getAllCardsClaimContender() public view returns (bytes4[]) {\n', '\n', '    // returns the indexes of the claim contender\n', '    bytes4[] memory allCardsClaimContender = new bytes4[](_addressCards.length);\n', '    for (uint256 i = 0; i < _addressCards.length; i++) {\n', '      AddressCard memory addressCard = _addressCards[i];\n', '      allCardsClaimContender[i] = bytes4(_indexOf[addressCard._claimContender]);\n', '    }\n', '    return allCardsClaimContender;\n', '\n', '  }\n', '\n', '  function getAllOwnersOfCard(address cardAddress) public view returns (bytes4[]) {\n', '    \n', '    require(cardAddressExists(cardAddress));\n', '\n', '    // returns the indexes of the owners\n', '    address[] memory ownersOfCardAddress = _ownersOf[cardAddress];\n', '    bytes4[] memory allOwners = new bytes4[](ownersOfCardAddress.length);\n', '    for (uint256 i = 0; i < ownersOfCardAddress.length; i++) {\n', '      allOwners[i] = bytes4(_indexOf[ownersOfCardAddress[i]]);\n', '    }\n', '    return allOwners;\n', '\n', '  }\n', '\n', '  function getAllOwnersClaimPriceOfCard(address cardAddress) public view returns (bytes32[]) {\n', '    \n', '    require(cardAddressExists(cardAddress));\n', '\n', '    uint256[] memory ownersClaimPriceOfCardAddress = _ownersClaimPriceOf[cardAddress];\n', '    bytes32[] memory allOwnersClaimPrice = new bytes32[](ownersClaimPriceOfCardAddress.length);\n', '    for (uint256 i = 0; i < ownersClaimPriceOfCardAddress.length; i++) {\n', '      allOwnersClaimPrice[i] = bytes32(ownersClaimPriceOfCardAddress[i]);\n', '    }\n', '    return allOwnersClaimPrice;\n', '\n', '  }\n', '\n', '  function getAllCardAddressesOfOwner(address owner) public view returns (bytes4[]) {\n', '    \n', '    require(cardAddressExists(owner));\n', '\n', '    // returns the indexes of the cards owned\n', '    address[] memory cardsOfOwner = _cardsOf[owner];\n', '    bytes4[] memory allCardAddresses = new bytes4[](cardsOfOwner.length);\n', '    for (uint256 i = 0; i < cardsOfOwner.length; i++) {\n', '      allCardAddresses[i] = bytes4(_indexOf[cardsOfOwner[i]]);\n', '    }\n', '    return allCardAddresses;\n', '\n', '  }\n', '\n', '  function getAllCardAddressesCountOfOwner(address owner) public view returns (bytes1[]) {\n', '    \n', '    require(cardAddressExists(owner));\n', '\n', '    address[] memory cardsOfOwner = _cardsOf[owner];\n', '    bytes1[] memory allCardAddressesCount = new bytes1[](cardsOfOwner.length);\n', '    for (uint256 i = 0; i < cardsOfOwner.length; i++) {\n', '      allCardAddressesCount[i] = bytes1(ownerCountOfCard(owner, cardsOfOwner[i]));\n', '    }\n', '    return allCardAddressesCount;\n', '\n', '  }\n', '\n', '  function getAllCardAddressesPriceOfOwner(address owner) public view returns (bytes32[]) {\n', '    \n', '    require(cardAddressExists(owner));\n', '\n', '    address[] memory cardsOfOwner = _cardsOf[owner];\n', '    bytes32[] memory allCardAddressesPrice = new bytes32[](cardsOfOwner.length);\n', '    for (uint256 i = 0; i < cardsOfOwner.length; i++) {\n', '      uint256 price;\n', '      ( , , price, , ) = getOwnerOfCardsCheapestWager(owner, cardsOfOwner[i]);\n', '      allCardAddressesPrice[i] = bytes32(price);\n', '    }\n', '    return allCardAddressesPrice;\n', '\n', '  }\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////\n', '  \n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (ie if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}']
