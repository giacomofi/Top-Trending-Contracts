['pragma solidity ^0.4.23;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'interface TokenContract {\n', '  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '}\n', '\n', 'contract SafeWithdraw is Ownable {\n', '  address signerAddress = 0xDD594FeD73370549607A658DfE7737C437265BBC;\n', '  TokenContract public tkn;\n', '  address public tokenWallet;\n', '  mapping (bytes32 => bool) public claimed;\n', '\n', '  constructor() public {\n', '    tkn = TokenContract(0x92D3e963aA94D909869940A8d15FA16CcbC6655E);\n', '    tokenWallet = 0x850Ac570A9f4817C43722938127aFa504aeb7717;\n', '  }\n', '\n', '  function changeWallet(address _newWallet) onlyOwner public {\n', '    tokenWallet = _newWallet;\n', '  }\n', '\n', '  function changeSigner(address _newSigner) onlyOwner public {\n', '    signerAddress = _newSigner;\n', '  }\n', '\n', '  function transfer(uint256 _amount, string code, bytes sig) public {\n', '    bytes32 message = prefixed(keccak256(_amount, code));\n', '    \n', '    require (!claimed[message]);\n', '\n', '    if (recoverSigner(message, sig) == signerAddress) {\n', '      uint256 fullValue = _amount * (1 ether);\n', '      claimed[message] = true;\n', '      tkn.transferFrom(tokenWallet, msg.sender, fullValue);\n', '      emit Claimed(msg.sender, fullValue);\n', '    }\n', '  }\n', '\n', '  function killMe() public {\n', '    require(msg.sender == owner);\n', '    selfdestruct(msg.sender);\n', '  }\n', '\n', '  function splitSignature(bytes sig)\n', '    internal\n', '    pure\n', '    returns (uint8, bytes32, bytes32)\n', '  {\n', '    require(sig.length == 65);\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '    return (v, r, s);\n', '  }\n', '\n', '  function recoverSigner(bytes32 message, bytes sig)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    uint8 v;\n', '    bytes32 r;\n', '    bytes32 s;\n', '    (v, r, s) = splitSignature(sig);\n', '    return ecrecover(message, v, r, s);\n', '  }\n', '\n', '  function prefixed(bytes32 hash) internal pure returns (bytes32) {\n', '    return keccak256("\\x19Ethereum Signed Message:\\n32", hash);\n', '  }\n', '\n', '  event Claimed(address _by, uint256 _amount);\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'interface TokenContract {\n', '  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '}\n', '\n', 'contract SafeWithdraw is Ownable {\n', '  address signerAddress = 0xDD594FeD73370549607A658DfE7737C437265BBC;\n', '  TokenContract public tkn;\n', '  address public tokenWallet;\n', '  mapping (bytes32 => bool) public claimed;\n', '\n', '  constructor() public {\n', '    tkn = TokenContract(0x92D3e963aA94D909869940A8d15FA16CcbC6655E);\n', '    tokenWallet = 0x850Ac570A9f4817C43722938127aFa504aeb7717;\n', '  }\n', '\n', '  function changeWallet(address _newWallet) onlyOwner public {\n', '    tokenWallet = _newWallet;\n', '  }\n', '\n', '  function changeSigner(address _newSigner) onlyOwner public {\n', '    signerAddress = _newSigner;\n', '  }\n', '\n', '  function transfer(uint256 _amount, string code, bytes sig) public {\n', '    bytes32 message = prefixed(keccak256(_amount, code));\n', '    \n', '    require (!claimed[message]);\n', '\n', '    if (recoverSigner(message, sig) == signerAddress) {\n', '      uint256 fullValue = _amount * (1 ether);\n', '      claimed[message] = true;\n', '      tkn.transferFrom(tokenWallet, msg.sender, fullValue);\n', '      emit Claimed(msg.sender, fullValue);\n', '    }\n', '  }\n', '\n', '  function killMe() public {\n', '    require(msg.sender == owner);\n', '    selfdestruct(msg.sender);\n', '  }\n', '\n', '  function splitSignature(bytes sig)\n', '    internal\n', '    pure\n', '    returns (uint8, bytes32, bytes32)\n', '  {\n', '    require(sig.length == 65);\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '    return (v, r, s);\n', '  }\n', '\n', '  function recoverSigner(bytes32 message, bytes sig)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    uint8 v;\n', '    bytes32 r;\n', '    bytes32 s;\n', '    (v, r, s) = splitSignature(sig);\n', '    return ecrecover(message, v, r, s);\n', '  }\n', '\n', '  function prefixed(bytes32 hash) internal pure returns (bytes32) {\n', '    return keccak256("\\x19Ethereum Signed Message:\\n32", hash);\n', '  }\n', '\n', '  event Claimed(address _by, uint256 _amount);\n', '\n', '}']
