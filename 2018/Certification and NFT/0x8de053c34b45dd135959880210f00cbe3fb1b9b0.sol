['pragma solidity 0.4.21;\n', '\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', 'contract CryptoRoboticsToken {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    function burn(uint256 value) public;\n', '}\n', '\n', '\n', 'contract ICOContract {\n', '    function setTokenCountFromPreIco(uint256 value) public;\n', '}\n', '\n', '\n', 'contract Crowdsale is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    // The token being sold\n', '    CryptoRoboticsToken public token;\n', '    ICOContract ico;\n', '\n', '    // Address where funds are collected\n', '    address public wallet;\n', '\n', '    // Amount of wei raised\n', '    uint256 public weiRaised;\n', '\n', '    uint256 public openingTime;\n', '    uint256 public closingTime;\n', '\n', '    bool public isFinalized = false;\n', '\n', '    uint public tokenPriceInWei = 105 szabo;\n', '\n', '    uint256 public cap = 1008 ether;\n', '\n', '\n', '    event Finalized();\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '    modifier onlyWhileOpen {\n', '        require(now >= openingTime && now <= closingTime);\n', '        _;\n', '    }\n', '\n', '\n', '    function Crowdsale(CryptoRoboticsToken _token) public\n', '    {\n', '        require(_token != address(0));\n', '\n', '\n', '        wallet = 0xeb6BD1436046b22Eb03f6b7c215A8537C9bed868;\n', '        token = _token;\n', '        openingTime = now;\n', '        closingTime = 1526601600;\n', '    }\n', '\n', '\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '\n', '    function buyTokens(address _beneficiary) public payable {\n', '\n', '        uint256 weiAmount = msg.value;\n', '        _preValidatePurchase(_beneficiary, weiAmount);\n', '\n', '        // calculate token amount to be created\n', '        uint256 tokens = _getTokenAmount(weiAmount);\n', '\n', '        uint _diff =  weiAmount % tokenPriceInWei;\n', '\n', '        if (_diff > 0) {\n', '            msg.sender.transfer(_diff);\n', '            weiAmount = weiAmount.sub(_diff);\n', '        }\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '\n', '        _processPurchase(_beneficiary, tokens);\n', '        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '\n', '\n', '        _forwardFunds(weiAmount);\n', '    }\n', '\n', '\n', '    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view onlyWhileOpen {\n', '        require(_beneficiary != address(0));\n', '        require(weiRaised.add(_weiAmount) <= cap);\n', '        require(_weiAmount >= 20 ether);\n', '    }\n', '\n', '\n', '    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '        token.transfer(_beneficiary, _tokenAmount);\n', '    }\n', '\n', '\n', '    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '        _tokenAmount = _tokenAmount * 1 ether;\n', '        _deliverTokens(_beneficiary, _tokenAmount);\n', '    }\n', '\n', '\n', '    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n', '        uint _tokens = _weiAmount.div(tokenPriceInWei);\n', '        return _tokens;\n', '    }\n', '\n', '\n', '    function _forwardFunds(uint _weiAmount) internal {\n', '        wallet.transfer(_weiAmount);\n', '    }\n', '\n', '\n', '    function hasClosed() public view returns (bool) {\n', '        return now > closingTime;\n', '    }\n', '\n', '    function capReached() public view returns (bool) {\n', '        return weiRaised >= cap;\n', '    }\n', '\n', '    /**\n', '     * @dev Must be called after crowdsale ends, to do some extra finalization\n', '     * work. Calls the contract&#39;s finalization function.\n', '     */\n', '    function finalize() onlyOwner public {\n', '        require(!isFinalized);\n', '        require(hasClosed() || capReached());\n', '\n', '        finalization();\n', '        emit Finalized();\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '\n', '    function setIco(address _ico) onlyOwner public {\n', '        ico = ICOContract(_ico);\n', '    }\n', '\n', '\n', '    function finalization() internal {\n', '        uint _balance = token.balanceOf(this);\n', '        if (_balance > 0) {\n', '            token.transfer(address(ico), _balance);\n', '            ico.setTokenCountFromPreIco(_balance);\n', '        }\n', '    }\n', '}']
['pragma solidity 0.4.21;\n', '\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', 'contract CryptoRoboticsToken {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    function burn(uint256 value) public;\n', '}\n', '\n', '\n', 'contract ICOContract {\n', '    function setTokenCountFromPreIco(uint256 value) public;\n', '}\n', '\n', '\n', 'contract Crowdsale is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    // The token being sold\n', '    CryptoRoboticsToken public token;\n', '    ICOContract ico;\n', '\n', '    // Address where funds are collected\n', '    address public wallet;\n', '\n', '    // Amount of wei raised\n', '    uint256 public weiRaised;\n', '\n', '    uint256 public openingTime;\n', '    uint256 public closingTime;\n', '\n', '    bool public isFinalized = false;\n', '\n', '    uint public tokenPriceInWei = 105 szabo;\n', '\n', '    uint256 public cap = 1008 ether;\n', '\n', '\n', '    event Finalized();\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '    modifier onlyWhileOpen {\n', '        require(now >= openingTime && now <= closingTime);\n', '        _;\n', '    }\n', '\n', '\n', '    function Crowdsale(CryptoRoboticsToken _token) public\n', '    {\n', '        require(_token != address(0));\n', '\n', '\n', '        wallet = 0xeb6BD1436046b22Eb03f6b7c215A8537C9bed868;\n', '        token = _token;\n', '        openingTime = now;\n', '        closingTime = 1526601600;\n', '    }\n', '\n', '\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '\n', '    function buyTokens(address _beneficiary) public payable {\n', '\n', '        uint256 weiAmount = msg.value;\n', '        _preValidatePurchase(_beneficiary, weiAmount);\n', '\n', '        // calculate token amount to be created\n', '        uint256 tokens = _getTokenAmount(weiAmount);\n', '\n', '        uint _diff =  weiAmount % tokenPriceInWei;\n', '\n', '        if (_diff > 0) {\n', '            msg.sender.transfer(_diff);\n', '            weiAmount = weiAmount.sub(_diff);\n', '        }\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '\n', '        _processPurchase(_beneficiary, tokens);\n', '        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '\n', '\n', '        _forwardFunds(weiAmount);\n', '    }\n', '\n', '\n', '    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view onlyWhileOpen {\n', '        require(_beneficiary != address(0));\n', '        require(weiRaised.add(_weiAmount) <= cap);\n', '        require(_weiAmount >= 20 ether);\n', '    }\n', '\n', '\n', '    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '        token.transfer(_beneficiary, _tokenAmount);\n', '    }\n', '\n', '\n', '    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '        _tokenAmount = _tokenAmount * 1 ether;\n', '        _deliverTokens(_beneficiary, _tokenAmount);\n', '    }\n', '\n', '\n', '    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n', '        uint _tokens = _weiAmount.div(tokenPriceInWei);\n', '        return _tokens;\n', '    }\n', '\n', '\n', '    function _forwardFunds(uint _weiAmount) internal {\n', '        wallet.transfer(_weiAmount);\n', '    }\n', '\n', '\n', '    function hasClosed() public view returns (bool) {\n', '        return now > closingTime;\n', '    }\n', '\n', '    function capReached() public view returns (bool) {\n', '        return weiRaised >= cap;\n', '    }\n', '\n', '    /**\n', '     * @dev Must be called after crowdsale ends, to do some extra finalization\n', "     * work. Calls the contract's finalization function.\n", '     */\n', '    function finalize() onlyOwner public {\n', '        require(!isFinalized);\n', '        require(hasClosed() || capReached());\n', '\n', '        finalization();\n', '        emit Finalized();\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '\n', '    function setIco(address _ico) onlyOwner public {\n', '        ico = ICOContract(_ico);\n', '    }\n', '\n', '\n', '    function finalization() internal {\n', '        uint _balance = token.balanceOf(this);\n', '        if (_balance > 0) {\n', '            token.transfer(address(ico), _balance);\n', '            ico.setTokenCountFromPreIco(_balance);\n', '        }\n', '    }\n', '}']
