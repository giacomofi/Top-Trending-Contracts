['pragma solidity ^0.4.18;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '    \n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ReferContractInterface {\n', '    function decrement(address _who) public;\n', '    function mint(address _to, uint _value) public;\n', '    function getBalance(address _who) public view returns(uint);\n', '}\n', '\n', 'contract ReferConstants {\n', '    uint public constant FIRST_USER_CUT = 40;\n', '    uint public constant SECOND_USER_CUT = 25;\n', '    uint public constant THIRD_USER_CUT = 15;\n', '    uint public constant FOURTH_USER_CUT = 10;\n', '    uint public constant OWNER_CUT = 10;\n', '    event Bought(address user, address directParent, address indirectParent, uint money, uint tokens, uint level);\n', '    event LevelUpdated(address user, uint money, uint level);\n', '    \n', '    using SafeMath for uint;\n', '}\n', '\n', 'contract ReferContract is ReferConstants, Ownable {\n', '    ReferContractInterface referContractInterface;\n', '    uint public baseRate;\n', '    \n', '    mapping (address => uint) public etherBalance;\n', '    mapping (address => address) public userReferrer;\n', '    mapping (address => uint8) public userLevel;\n', '    mapping (address => uint) public tokensBought;\n', '    \n', '    constructor(address _tokenAddress) public {\n', '        referContractInterface = ReferContractInterface(_tokenAddress);\n', '        baseRate = 3000000000000000;\n', '        // to be consistent with game\n', '        userReferrer[owner] = owner;\n', '        userLevel[owner] = 4;\n', '    }\n', '    \n', '     // Update only if contract is not getting traction or got more\n', '     // traction that initially thought.\n', '     // increase the price if there is huge traffic to compensate more people\n', '     // decrease the price if there is less traffic to attract more users.\n', '    function updateRate(uint _newRate) onlyOwner public {\n', '        require(baseRate != 0);\n', '        // rate shouldn&#39;t be less than half or more than twice.\n', '        require(_newRate.mul(2) > baseRate && baseRate.mul(2) > _newRate);\n', '        baseRate = _newRate;\n', '    }\n', '    \n', '    function getRate(uint level) public view returns (uint) {\n', '        if (level == 4) {\n', '            return baseRate.mul(6);\n', '        } else if (level == 3) {\n', '            return baseRate.mul(5);\n', '        } else if (level == 2) {\n', '            return baseRate.mul(3);\n', '        } else if (level == 1) {\n', '            return baseRate.mul(2);\n', '        } else {\n', '            return baseRate.mul(6);\n', '        } \n', '    }\n', '    \n', '    function fundAccount(address ref, uint eth, uint level) internal {\n', '        if (ref != address(0x0) && userLevel[ref] >= level) {\n', '            etherBalance[ref] += eth;\n', '        } else {\n', '            etherBalance[owner] += eth;\n', '        }\n', '    }\n', '    \n', '    function distributeMoney(address ref, address parent1, uint money) internal {\n', '        // since we are calculating percentage which will be \n', '        // (money * x)/100\n', '        money = money.div(100);\n', '        \n', '        fundAccount(ref, money.mul(FIRST_USER_CUT), 1);\n', '        fundAccount(parent1, money.mul(SECOND_USER_CUT), 2);\n', '        fundAccount(userReferrer[parent1], money.mul(THIRD_USER_CUT), 3);\n', '        fundAccount(userReferrer[userReferrer[parent1]], money.mul(FOURTH_USER_CUT), 4);\n', '        fundAccount(owner, money.mul(OWNER_CUT), 0);\n', '    }\n', '    \n', '    function buyReferTokens(address ref, uint8 level) payable public {\n', '        require(level > 0 && level < 5);\n', '        \n', '        if (userLevel[msg.sender] == 0) { // new user\n', '            userLevel[msg.sender] = level;\n', '            if (getTokenBalance(ref) < 1) {  // The referee doesn&#39;t have a token \n', '                ref = owner; // change referee\n', '            }\n', '            userReferrer[msg.sender] = ref; // permanently set owner as the referrer\n', '            referContractInterface.decrement(userReferrer[msg.sender]);\n', '        } else { // old user\n', '            require(userLevel[msg.sender] == level);\n', '            if (getTokenBalance(userReferrer[msg.sender]) < 1) { // The referee doesn&#39;t have a token\n', '                ref = owner; // only change the parent but don&#39;t change gradparents\n', '            } else {\n', '                ref = userReferrer[msg.sender];\n', '            }\n', '            referContractInterface.decrement(ref);\n', '        }\n', '        \n', '        uint tokens = msg.value.div(getRate(level));\n', '        require(tokens >= 5);\n', '        referContractInterface.mint(msg.sender, tokens);\n', '        distributeMoney(ref, userReferrer[userReferrer[msg.sender]] , msg.value);\n', '        tokensBought[msg.sender] += tokens;\n', '        emit Bought(msg.sender, ref, userReferrer[userReferrer[msg.sender]], msg.value, tokens, level);\n', '    }\n', '    \n', '    function upgradeLevel(uint8 level) payable public {\n', '        require(level <= 4);\n', '        require(userLevel[msg.sender] != 0 && userLevel[msg.sender] < level);\n', '        uint rateDiff = getRate(level).sub(getRate(userLevel[msg.sender]));\n', '        uint toBePaid = rateDiff.mul(tokensBought[msg.sender]);\n', '        require(msg.value >= toBePaid);\n', '        userLevel[msg.sender] = level;\n', '        distributeMoney(userReferrer[msg.sender], userReferrer[userReferrer[msg.sender]] , msg.value);\n', '        emit LevelUpdated(msg.sender, msg.value, level);\n', '    }\n', '    \n', '    function getAmountToUpdate(uint8 level) view public returns (uint) {\n', '        uint rate = getRate(level).mul(tokensBought[msg.sender]);\n', '        uint ratePaid = getRate(userLevel[msg.sender]).mul(tokensBought[msg.sender]);\n', '        return rate.sub(ratePaid);\n', '    }\n', '    \n', '    function withdraw() public {\n', '        uint amount = etherBalance[msg.sender];\n', '        etherBalance[msg.sender] = 0;\n', '        msg.sender.transfer(amount);\n', '    }\n', '    \n', '    function getTokenBalance(address _who) public view returns(uint) {\n', '        return referContractInterface.getBalance(_who);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        \n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']