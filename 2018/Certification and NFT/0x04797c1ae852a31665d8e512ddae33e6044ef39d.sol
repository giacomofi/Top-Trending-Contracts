['pragma solidity ^0.4.23;\n', '\n', '/******* https://www.pennyether.com **************/\n', '\n', '/******* USING Registry **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .addressOf(bytes32): returns current address mapped to the name.\n', '    [modifier] .fromOwner(): requires the sender is owner.\n', '\n', '*************************************************/\n', '// Returned by .getRegistry()\n', 'interface IRegistry {\n', '    function owner() external view returns (address _addr);\n', '    function addressOf(bytes32 _name) external view returns (address _addr);\n', '}\n', '\n', 'contract UsingRegistry {\n', '    IRegistry private registry;\n', '\n', '    modifier fromOwner(){\n', '        require(msg.sender == getOwner());\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry)\n', '        public\n', '    {\n', '        require(_registry != 0);\n', '        registry = IRegistry(_registry);\n', '    }\n', '\n', '    function addressOf(bytes32 _name)\n', '        internal\n', '        view\n', '        returns(address _addr)\n', '    {\n', '        return registry.addressOf(_name);\n', '    }\n', '\n', '    function getOwner()\n', '        public\n', '        view\n', '        returns (address _addr)\n', '    {\n', '        return registry.owner();\n', '    }\n', '\n', '    function getRegistry()\n', '        public\n', '        view\n', '        returns (IRegistry _addr)\n', '    {\n', '        return registry;\n', '    }\n', '}\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    address => uint amounts. Address balances can be added to \n', '    or removed from via add() and subtract(). All balances can\n', '    be obtain by calling balances(). If an address has a 0 amount,\n', '    it is removed from the Ledger.\n', '\n', '    Note: THIS DOES NOT TEST FOR OVERFLOWS, but it&#39;s safe to\n', '          use to track Ether balances.\n', '\n', '    Public methods:\n', '      - [fromOwner] add()\n', '      - [fromOwner] subtract()\n', '    Public views:\n', '      - total()\n', '      - size()\n', '      - balanceOf()\n', '      - balances()\n', '      - entries() [to manually iterate]\n', '*/\n', 'contract Ledger {\n', '    uint public total;      // Total amount in Ledger\n', '\n', '    struct Entry {          // Doubly linked list tracks amount per address\n', '        uint balance;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        // If new entry, replace first entry with this one.\n', '        if (entry.balance == 0) {\n', '            entry.next = entries[0x0].next;\n', '            entries[entries[0x0].next].prev = _address;\n', '            entries[0x0].next = _address;\n', '        }\n', '        // Update stats.\n', '        total += _amt;\n', '        entry.balance += _amt;\n', '    }\n', '\n', '    function subtract(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '        returns (uint _amtRemoved)\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        uint _maxAmt = entry.balance;\n', '        if (_maxAmt == 0) return;\n', '        \n', '        if (_amt >= _maxAmt) {\n', '            // Subtract the max amount, and delete entry.\n', '            total -= _maxAmt;\n', '            entries[entry.prev].next = entry.next;\n', '            entries[entry.next].prev = entry.prev;\n', '            delete entries[_address];\n', '            return _maxAmt;\n', '        } else {\n', '            // Subtract the amount from entry.\n', '            total -= _amt;\n', '            entry.balance -= _amt;\n', '            return _amt;\n', '        }\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function balanceOf(address _address)\n', '        public\n', '        view\n', '        returns (uint _balance)\n', '    {\n', '        return entries[_address].balance;\n', '    }\n', '\n', '    function balances()\n', '        public\n', '        view\n', '        returns (address[] _addresses, uint[] _balances)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        _balances = new uint[](_size);\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _balances[_i] = entries[_curEntry.next].balance;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return (_addresses, _balances);\n', '    }\n', '}\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    addresses it has seen. Addresses can be added and removed\n', '    from the set, and a full list of addresses can be obtained.\n', '\n', '    Methods:\n', '     - [fromOwner] .add()\n', '     - [fromOwner] .remove()\n', '    Views:\n', '     - .size()\n', '     - .has()\n', '     - .addresses()\n', '*/\n', 'contract AddressSet {\n', '    \n', '    struct Entry {  // Doubly linked list\n', '        bool exists;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner.\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didCreate)\n', '    {\n', '        // Do not allow the adding of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', '        // If already exists, do nothing. Otherwise set it.\n', '        if (entry.exists) return;\n', '        else entry.exists = true;\n', '\n', '        // Replace first entry with this one.\n', '        // Before: HEAD <-> X <-> Y\n', '        // After: HEAD <-> THIS <-> X <-> Y\n', '        // do: THIS.NEXT = [0].next; [0].next.prev = THIS; [0].next = THIS; THIS.prev = 0;\n', '        Entry storage HEAD = entries[0x0];\n', '        entry.next = HEAD.next;\n', '        entries[HEAD.next].prev = _address;\n', '        HEAD.next = _address;\n', '        return true;\n', '    }\n', '\n', '    function remove(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didExist)\n', '    {\n', '        // Do not allow the removal of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', '        // If it doesn&#39;t exist already, there is nothing to do.\n', '        if (!entry.exists) return;\n', '\n', '        // Stitch together next and prev, delete entry.\n', '        // Before: X <-> THIS <-> Y\n', '        // After: X <-> Y\n', '        // do: THIS.next.prev = this.prev; THIS.prev.next = THIS.next;\n', '        entries[entry.prev].next = entry.next;\n', '        entries[entry.next].prev = entry.prev;\n', '        delete entries[_address];\n', '        return true;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function has(address _address)\n', '        public\n', '        view\n', '        returns (bool _exists)\n', '    {\n', '        return entries[_address].exists;\n', '    }\n', '\n', '    function addresses()\n', '        public\n', '        view\n', '        returns (address[] _addresses)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        // Iterate forward through all entries until the end.\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return _addresses;\n', '    }\n', '}\n', '\n', '/******* USING TREASURY **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .getTreasury(): returns current ITreasury instance\n', '    [modifier] .fromTreasury(): requires the sender is current Treasury\n', '\n', '*************************************************/\n', '// Returned by .getTreasury()\n', 'interface ITreasury {\n', '    function issueDividend() external returns (uint _profits);\n', '    function profitsSendable() external view returns (uint _profits);\n', '}\n', '\n', 'contract UsingTreasury is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromTreasury(){\n', '        require(msg.sender == address(getTreasury()));\n', '        _;\n', '    }\n', '    \n', '    function getTreasury()\n', '        public\n', '        view\n', '        returns (ITreasury)\n', '    {\n', '        return ITreasury(addressOf("TREASURY"));\n', '    }\n', '}\n', '\n', '\n', '/**\n', '  A simple class that manages bankroll, and maintains collateral.\n', '  This class only ever sends profits the Treasury. No exceptions.\n', '\n', '  - Anybody can add funding (according to whitelist)\n', '  - Anybody can tell profits (balance - (funding + collateral)) to go to Treasury.\n', '  - Anyone can remove their funding, so long as balance >= collateral.\n', '  - Whitelist is managed by getWhitelistOwner() -- typically Admin.\n', '\n', '  Exposes the following:\n', '    Public Methods\n', '     - addBankroll\n', '     - removeBankroll\n', '     - sendProfits\n', '    Public Views\n', '     - getCollateral\n', '     - profits\n', '     - profitsSent\n', '     - profitsTotal\n', '     - bankroll\n', '     - bankrollAvailable\n', '     - bankrolledBy\n', '     - bankrollerTable\n', '*/\n', 'contract Bankrollable is\n', '    UsingTreasury\n', '{   \n', '    // How much profits have been sent. \n', '    uint public profitsSent;\n', '    // Ledger keeps track of who has bankrolled us, and for how much\n', '    Ledger public ledger;\n', '    // This is a copy of ledger.total(), to save gas in .bankrollAvailable()\n', '    uint public bankroll;\n', '    // This is the whitelist of who can call .addBankroll()\n', '    AddressSet public whitelist;\n', '\n', '    modifier fromWhitelistOwner(){\n', '        require(msg.sender == getWhitelistOwner());\n', '        _;\n', '    }\n', '\n', '    event BankrollAdded(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event BankrollRemoved(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event ProfitsSent(uint time, address indexed treasury, uint amount);\n', '    event AddedToWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '    event RemovedFromWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '\n', '    // Constructor creates the ledger and whitelist, with self as owner.\n', '    constructor(address _registry)\n', '        UsingTreasury(_registry)\n', '        public\n', '    {\n', '        ledger = new Ledger(this);\n', '        whitelist = new AddressSet(this);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** WHITELIST MGMT ***********************/\n', '    /*****************************************************/    \n', '\n', '    function addToWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didAdd = whitelist.add(_addr);\n', '        if (_didAdd) emit AddedToWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    function removeFromWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didRemove = whitelist.remove(_addr);\n', '        if (_didRemove) emit RemovedFromWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC FUNCTIONS *********************/\n', '    /*****************************************************/\n', '\n', '    // Bankrollable contracts should be payable (to receive revenue)\n', '    function () public payable {}\n', '\n', '    // Increase funding by whatever value is sent\n', '    function addBankroll()\n', '        public\n', '        payable \n', '    {\n', '        require(whitelist.size()==0 || whitelist.has(msg.sender));\n', '        ledger.add(msg.sender, msg.value);\n', '        bankroll = ledger.total();\n', '        emit BankrollAdded(now, msg.sender, msg.value, bankroll);\n', '    }\n', '\n', '    // Removes up to _amount from Ledger, and sends it to msg.sender._callbackFn\n', '    function removeBankroll(uint _amount, string _callbackFn)\n', '        public\n', '        returns (uint _recalled)\n', '    {\n', '        // cap amount at the balance minus collateral, or nothing at all.\n', '        address _bankroller = msg.sender;\n', '        uint _collateral = getCollateral();\n', '        uint _balance = address(this).balance;\n', '        uint _available = _balance > _collateral ? _balance - _collateral : 0;\n', '        if (_amount > _available) _amount = _available;\n', '\n', '        // Try to remove _amount from ledger, get actual _amount removed.\n', '        _amount = ledger.subtract(_bankroller, _amount);\n', '        bankroll = ledger.total();\n', '        if (_amount == 0) return;\n', '\n', '        bytes4 _sig = bytes4(keccak256(_callbackFn));\n', '        require(_bankroller.call.value(_amount)(_sig));\n', '        emit BankrollRemoved(now, _bankroller, _amount, bankroll);\n', '        return _amount;\n', '    }\n', '\n', '    // Send any excess profits to treasury.\n', '    function sendProfits()\n', '        public\n', '        returns (uint _profits)\n', '    {\n', '        int _p = profits();\n', '        if (_p <= 0) return;\n', '        _profits = uint(_p);\n', '        profitsSent += _profits;\n', '        // Send profits to Treasury\n', '        address _tr = getTreasury();\n', '        require(_tr.call.value(_profits)());\n', '        emit ProfitsSent(now, _tr, _profits);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC VIEWS *************************/\n', '    /*****************************************************/\n', '\n', '    // Function must be overridden by inheritors to ensure collateral is kept.\n', '    function getCollateral()\n', '        public\n', '        view\n', '        returns (uint _amount);\n', '\n', '    // Function must be overridden by inheritors to enable whitelist control.\n', '    function getWhitelistOwner()\n', '        public\n', '        view\n', '        returns (address _addr);\n', '\n', '    // Profits are the difference between balance and threshold\n', '    function profits()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        int _balance = int(address(this).balance);\n', '        int _threshold = int(bankroll + getCollateral());\n', '        return _balance - _threshold;\n', '    }\n', '\n', '    // How profitable this contract is, overall\n', '    function profitsTotal()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        return int(profitsSent) + profits();\n', '    }\n', '\n', '    // Returns the amount that can currently be bankrolled.\n', '    //   - 0 if balance < collateral\n', '    //   - If profits: full bankroll\n', '    //   - If no profits: remaning bankroll: balance - collateral\n', '    function bankrollAvailable()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        uint _balance = address(this).balance;\n', '        uint _bankroll = bankroll;\n', '        uint _collat = getCollateral();\n', '        // Balance is below collateral!\n', '        if (_balance <= _collat) return 0;\n', '        // No profits, but we have a balance over collateral.\n', '        else if (_balance < _collat + _bankroll) return _balance - _collat;\n', '        // Profits. Return only _bankroll\n', '        else return _bankroll;\n', '    }\n', '\n', '    function bankrolledBy(address _addr)\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return ledger.balanceOf(_addr);\n', '    }\n', '\n', '    function bankrollerTable()\n', '        public\n', '        view\n', '        returns (address[], uint[])\n', '    {\n', '        return ledger.balances();\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/******* USING ADMIN ***********************\n', '\n', 'Gives the inherting contract access to:\n', '    .getAdmin(): returns the current address of the admin\n', '    [modifier] .fromAdmin: requires the sender is the admin\n', '\n', '*************************************************/\n', 'contract UsingAdmin is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromAdmin(){\n', '        require(msg.sender == getAdmin());\n', '        _;\n', '    }\n', '    \n', '    function getAdmin()\n', '        public\n', '        constant\n', '        returns (address _addr)\n', '    {\n', '        return addressOf("ADMIN");\n', '    }\n', '}\n', '\n', '/*********************************************************\n', '*********************** INSTADICE ************************\n', '**********************************************************\n', '\n', 'UI: https://www.pennyether.com\n', '\n', 'This contract allows for users to wager a limited amount on then\n', 'outcome of a random roll between [1, 100]. The user may choose\n', 'a number, and if the roll is less than or equal to that number,\n', 'they will win a payout that is inversely proportional to the\n', 'number they chose (lower numbers pay out more).\n', '\n', 'When a roll is "finalized", it means the result was determined\n', 'and the payout paid to the user if they won. Each time somebody \n', 'rolls, their previous roll is finalized. Roll results are based\n', 'on blockhash, and since only the last 256 blockhashes are \n', 'available (who knows why it is so limited...), the user must\n', 'finalize within 256 blocks or their roll loses.\n', '\n', 'Note about randomness:\n', '  Although using blockhash for randomness is not advised,\n', '  it is perfectly acceptable if the results of the block\n', '  are not worth an expected value greater than that of:\n', '    (full block reward - uncle block reward) = ~.625 Eth\n', '\n', '  In other words, a miner is better of mining honestly and\n', '  getting a full block reward than trying to game this contract,\n', '  unless the maximum bet is increased to about .625, which\n', '  this contract forbids.\n', '*/\n', 'contract InstaDice is\n', '    Bankrollable,\n', '    UsingAdmin\n', '{\n', '    struct User {\n', '        uint32 id;\n', '        uint32 r_id;\n', '        uint32 r_block;\n', '        uint8 r_number;\n', '        uint72 r_payout;\n', '    }\n', '\n', '    // These stats are updated on each roll.\n', '    struct Stats {\n', '        uint32 numUsers;\n', '        uint32 numRolls;\n', '        uint96 totalWagered;\n', '        uint96 totalWon;\n', '    }\n', '    \n', '    // Admin controlled settings\n', '    struct Settings {\n', '        uint64 minBet;    //\n', '        uint64 maxBet;    // \n', '        uint8 minNumber;  // they get ~20x their bet\n', '        uint8 maxNumber;  // they get ~1.01x their bet\n', '        uint16 feeBips;   // each bip is .01%, eg: 100 = 1% fee.\n', '    }\n', '\n', '    mapping (address => User) public users;\n', '    Stats stats;\n', '    Settings settings;\n', '    uint8 constant public version = 2;\n', '    \n', '    // Admin events\n', '    event Created(uint time);\n', '    event SettingsChanged(uint time, address indexed admin);\n', '\n', '    // Events\n', '    event RollWagered(uint time, uint32 indexed id, address indexed user, uint bet, uint8 number, uint payout);\n', '    event RollRefunded(uint time, address indexed user, string msg, uint bet, uint8 number);\n', '    event RollFinalized(uint time, uint32 indexed id, address indexed user, uint8 result, uint payout);\n', '    event PayoutError(uint time, string msg);\n', '\n', '    constructor(address _registry)\n', '        Bankrollable(_registry)\n', '        UsingAdmin(_registry)\n', '        public\n', '    {\n', '        // populate with prev contracts&#39; stats\n', '        stats.totalWagered = 3650000000000000000;\n', '        stats.totalWon = 3537855001272912000;\n', '        stats.numRolls = 123;\n', '        stats.numUsers = 19;\n', '\n', '        // default settings\n', '        settings.maxBet = .3 ether;\n', '        settings.minBet = .001 ether;\n', '        settings.minNumber = 5;\n', '        settings.maxNumber = 98;\n', '        settings.feeBips = 100;\n', '        emit Created(now);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////\n', '    ////// ADMIN FUNCTIONS ////////////////////////////\n', '    ///////////////////////////////////////////////////\n', '\n', '    // Changes the settings\n', '    function changeSettings(\n', '        uint64 _minBet,\n', '        uint64 _maxBet,\n', '        uint8 _minNumber,\n', '        uint8 _maxNumber,\n', '        uint16 _feeBips\n', '    )\n', '        public\n', '        fromAdmin\n', '    {\n', '        require(_minBet <= _maxBet);    // makes sense\n', '        require(_maxBet <= .625 ether); // capped at (block reward - uncle reward)\n', '        require(_minNumber >= 1);       // not advisible, but why not\n', '        require(_maxNumber <= 99);      // over 100 makes no sense\n', '        require(_feeBips <= 500);       // max of 5%\n', '        settings.minBet = _minBet;\n', '        settings.maxBet = _maxBet;\n', '        settings.minNumber = _minNumber;\n', '        settings.maxNumber = _maxNumber;\n', '        settings.feeBips = _feeBips;\n', '        emit SettingsChanged(now, msg.sender);\n', '    }\n', '    \n', '\n', '    ///////////////////////////////////////////////////\n', '    ////// PUBLIC FUNCTIONS ///////////////////////////\n', '    ///////////////////////////////////////////////////\n', '\n', '    // Resolves the last roll for the user.\n', '    // Then creates a new roll.\n', '    // Gas:\n', '    //    Total: 56k (new), or up to 44k (repeat)\n', '    //    Overhead: 36k\n', '    //       22k: tx overhead\n', '    //        2k: SLOAD\n', '    //        3k: execution\n', '    //        2k: curMaxBet()\n', '    //        5k: update stats\n', '    //        2k: RollWagered event\n', '    //    New User: 20k\n', '    //       20k: create user\n', '    //    Repeat User: 8k, 16k\n', '    //        5k: update user\n', '    //        3k: RollFinalized event\n', '    //        8k: pay last roll\n', '    function roll(uint8 _number)\n', '        public\n', '        payable\n', '        returns (bool _success)\n', '    {\n', '        // Ensure bet and number are valid.\n', '        if (!_validateBetOrRefund(_number)) return;\n', '\n', '        // Ensure one bet per block.\n', '        User memory _prevUser = users[msg.sender];\n', '        if (_prevUser.r_block == uint32(block.number)){\n', '            _errorAndRefund("Only one bet per block allowed.", msg.value, _number);\n', '            return false;\n', '        }\n', '\n', '        // Create and write new user data before finalizing last roll\n', '        Stats memory _stats = stats;\n', '        User memory _newUser = User({\n', '            id: _prevUser.id == 0 ? _stats.numUsers + 1 : _prevUser.id,\n', '            r_id: _stats.numRolls + 1,\n', '            r_block: uint32(block.number),\n', '            r_number: _number,\n', '            r_payout: computePayout(msg.value, _number)\n', '        });\n', '        users[msg.sender] = _newUser;\n', '\n', '        // Finalize last roll, if there was one.\n', '        // This will throw if user won, but we couldn&#39;t pay.\n', '        if (_prevUser.r_block != 0) _finalizePreviousRoll(_prevUser, _stats);\n', '\n', '        // Increment additional stats data\n', '        _stats.numUsers = _prevUser.id == 0 ? _stats.numUsers + 1 : _stats.numUsers;\n', '        _stats.numRolls = stats.numRolls + 1;\n', '        _stats.totalWagered = stats.totalWagered + uint96(msg.value);\n', '        stats = _stats;\n', '\n', '        // Save user in one write.\n', '        emit RollWagered(now, _newUser.r_id, msg.sender, msg.value, _newUser.r_number, _newUser.r_payout);\n', '        return true;\n', '    }\n', '\n', '    // Finalizes the previous roll and pays out user if they won.\n', '    // Gas: 45k\n', '    //   21k: tx overhead\n', '    //    1k: SLOADs\n', '    //    2k: execution\n', '    //    8k: send winnings\n', '    //    5k: update user\n', '    //    5k: update stats\n', '    //    3k: RollFinalized event\n', '    function payoutPreviousRoll()\n', '        public\n', '        returns (bool _success)\n', '    {\n', '        // Load last roll in one SLOAD.\n', '        User memory _prevUser = users[msg.sender];\n', '        // Error if on same block.\n', '        if (_prevUser.r_block == uint32(block.number)){\n', '            emit PayoutError(now, "Cannot payout roll on the same block");\n', '            return false;\n', '        }\n', '        // Error if nothing to payout.\n', '        if (_prevUser.r_block == 0){\n', '            emit PayoutError(now, "No roll to pay out.");\n', '            return false;\n', '        }\n', '\n', '        // Clear last roll data\n', '        User storage _user = users[msg.sender];\n', '        _user.r_id = 0;\n', '        _user.r_block = 0;\n', '        _user.r_number = 0;\n', '        _user.r_payout = 0;\n', '\n', '        // Finalize previous roll and update stats\n', '        Stats memory _stats = stats;\n', '        _finalizePreviousRoll(_prevUser, _stats);\n', '        stats.totalWon = _stats.totalWon;\n', '        return true;\n', '    }\n', '\n', '\n', '    ////////////////////////////////////////////////////////\n', '    ////// PRIVATE FUNCTIONS ///////////////////////////////\n', '    ////////////////////////////////////////////////////////\n', '\n', '    // Validates the bet, or refunds the user.\n', '    function _validateBetOrRefund(uint8 _number)\n', '        private\n', '        returns (bool _isValid)\n', '    {\n', '        Settings memory _settings = settings;\n', '        if (_number < _settings.minNumber) {\n', '            _errorAndRefund("Roll number too small.", msg.value, _number);\n', '            return false;\n', '        }\n', '        if (_number > _settings.maxNumber){\n', '            _errorAndRefund("Roll number too large.", msg.value, _number);\n', '            return false;\n', '        }\n', '        if (msg.value < _settings.minBet){\n', '            _errorAndRefund("Bet too small.", msg.value, _number);\n', '            return false;\n', '        }\n', '        if (msg.value > _settings.maxBet){\n', '            _errorAndRefund("Bet too large.", msg.value, _number);\n', '            return false;\n', '        }\n', '        if (msg.value > curMaxBet()){\n', '            _errorAndRefund("May be unable to payout on a win.", msg.value, _number);\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Finalizes the previous roll for the _user.\n', '    // This will modify _stats, but not _user.\n', '    // Throws if unable to pay user on a win.\n', '    function _finalizePreviousRoll(User memory _user, Stats memory _stats)\n', '        private\n', '    {\n', '        assert(_user.r_block != uint32(block.number));\n', '        assert(_user.r_block != 0);\n', '        \n', '        // compute result and isWinner\n', '        uint8 _result = computeResult(_user.r_block, _user.r_id);\n', '        bool _isWinner = _result <= _user.r_number;\n', '        if (_isWinner) {\n', '            require(msg.sender.call.value(_user.r_payout)());\n', '            _stats.totalWon += _user.r_payout;\n', '        }\n', '        // they won and we paid, or they lost. roll is finalized.\n', '        emit RollFinalized(now, _user.r_id, msg.sender, _result, _isWinner ? _user.r_payout : 0);\n', '    }\n', '\n', '    // Only called from above.\n', '    // Refunds user the full value, and logs an error\n', '    function _errorAndRefund(string _msg, uint _bet, uint8 _number)\n', '        private\n', '    {\n', '        require(msg.sender.call.value(msg.value)());\n', '        emit RollRefunded(now, msg.sender, _msg, _bet, _number);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////\n', '    ////// PUBLIC VIEWS ///////////////////////////////\n', '    ///////////////////////////////////////////////////\n', '\n', '    // IMPLEMENTS: Bankrollable.getCollateral()\n', '    // This contract has no collateral, as it pays out in near realtime.\n', '    function getCollateral() public view returns (uint _amount) {\n', '        return 0;\n', '    }\n', '\n', '    // IMPLEMENTS: Bankrollable.getWhitelistOwner()\n', '    // Ensures contract always has at least bankroll + totalCredits.\n', '    function getWhitelistOwner() public view returns (address _wlOwner)\n', '    {\n', '        return getAdmin();\n', '    }\n', '\n', '    // Returns the largest bet such that we could pay out 10 maximum wins.\n', '    // The likelihood that 10 maximum bets (with highest payouts) are won\n', '    //  within a short period of time are extremely low.\n', '    function curMaxBet() public view returns (uint _amount) {\n', '        // Return largest bet such that 10*bet*payout = bankrollable()\n', '        uint _maxPayout = 10 * 100 / uint(settings.minNumber);\n', '        return bankrollAvailable() / _maxPayout;\n', '    }\n', '\n', '    // Return the less of settings.maxBet and curMaxBet()\n', '    function effectiveMaxBet() public view returns (uint _amount) {\n', '        uint _curMax = curMaxBet();\n', '        return _curMax > settings.maxBet ? settings.maxBet : _curMax;\n', '    }\n', '\n', '    // Computes the payout amount for the current _feeBips\n', '    function computePayout(uint _bet, uint _number)\n', '        public\n', '        view\n', '        returns (uint72 _wei)\n', '    {\n', '        uint _feeBips = settings.feeBips;   // Cast to uint, makes below math cheaper.\n', '        uint _bigBet = _bet * 1e32;         // Will not overflow unless _bet >> ~1e40\n', '        uint _bigPayout = (_bigBet * 100) / _number;\n', '        uint _bigFee = (_bigPayout * _feeBips) / 10000;\n', '        return uint72( (_bigPayout - _bigFee) / 1e32 );\n', '    }\n', '\n', '    // Returns a number between 1 and 100 (inclusive)\n', '    // If blockNumber is too far past, returns 101.\n', '    function computeResult(uint32 _blockNumber, uint32 _id)\n', '        public\n', '        view\n', '        returns (uint8 _result)\n', '    {\n', '        bytes32 _blockHash = blockhash(_blockNumber);\n', '        if (_blockHash == 0) { return 101; }\n', '        return uint8(uint(keccak256(_blockHash, _id)) % 100 + 1);\n', '    }\n', '\n', '    // Expose all Stats /////////////////////////////////\n', '    function numUsers() public view returns (uint32) {\n', '        return stats.numUsers;\n', '    }\n', '    function numRolls() public view returns (uint32) {\n', '        return stats.numRolls;\n', '    }\n', '    function totalWagered() public view returns (uint) {\n', '        return stats.totalWagered;\n', '    }\n', '    function totalWon() public view returns (uint) {\n', '        return stats.totalWon;\n', '    }\n', '    //////////////////////////////////////////////////////\n', '\n', '    // Expose all Settings ///////////////////////////////\n', '    function minBet() public view returns (uint) {\n', '        return settings.minBet;\n', '    }\n', '    function maxBet() public view returns (uint) {\n', '        return settings.maxBet;\n', '    }\n', '    function minNumber() public view returns (uint8) {\n', '        return settings.minNumber;\n', '    }\n', '    function maxNumber() public view returns (uint8) {\n', '        return settings.maxNumber;\n', '    }\n', '    function feeBips() public view returns (uint16) {\n', '        return settings.feeBips;\n', '    }\n', '    //////////////////////////////////////////////////////\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/******* https://www.pennyether.com **************/\n', '\n', '/******* USING Registry **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .addressOf(bytes32): returns current address mapped to the name.\n', '    [modifier] .fromOwner(): requires the sender is owner.\n', '\n', '*************************************************/\n', '// Returned by .getRegistry()\n', 'interface IRegistry {\n', '    function owner() external view returns (address _addr);\n', '    function addressOf(bytes32 _name) external view returns (address _addr);\n', '}\n', '\n', 'contract UsingRegistry {\n', '    IRegistry private registry;\n', '\n', '    modifier fromOwner(){\n', '        require(msg.sender == getOwner());\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry)\n', '        public\n', '    {\n', '        require(_registry != 0);\n', '        registry = IRegistry(_registry);\n', '    }\n', '\n', '    function addressOf(bytes32 _name)\n', '        internal\n', '        view\n', '        returns(address _addr)\n', '    {\n', '        return registry.addressOf(_name);\n', '    }\n', '\n', '    function getOwner()\n', '        public\n', '        view\n', '        returns (address _addr)\n', '    {\n', '        return registry.owner();\n', '    }\n', '\n', '    function getRegistry()\n', '        public\n', '        view\n', '        returns (IRegistry _addr)\n', '    {\n', '        return registry;\n', '    }\n', '}\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    address => uint amounts. Address balances can be added to \n', '    or removed from via add() and subtract(). All balances can\n', '    be obtain by calling balances(). If an address has a 0 amount,\n', '    it is removed from the Ledger.\n', '\n', "    Note: THIS DOES NOT TEST FOR OVERFLOWS, but it's safe to\n", '          use to track Ether balances.\n', '\n', '    Public methods:\n', '      - [fromOwner] add()\n', '      - [fromOwner] subtract()\n', '    Public views:\n', '      - total()\n', '      - size()\n', '      - balanceOf()\n', '      - balances()\n', '      - entries() [to manually iterate]\n', '*/\n', 'contract Ledger {\n', '    uint public total;      // Total amount in Ledger\n', '\n', '    struct Entry {          // Doubly linked list tracks amount per address\n', '        uint balance;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        // If new entry, replace first entry with this one.\n', '        if (entry.balance == 0) {\n', '            entry.next = entries[0x0].next;\n', '            entries[entries[0x0].next].prev = _address;\n', '            entries[0x0].next = _address;\n', '        }\n', '        // Update stats.\n', '        total += _amt;\n', '        entry.balance += _amt;\n', '    }\n', '\n', '    function subtract(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '        returns (uint _amtRemoved)\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        uint _maxAmt = entry.balance;\n', '        if (_maxAmt == 0) return;\n', '        \n', '        if (_amt >= _maxAmt) {\n', '            // Subtract the max amount, and delete entry.\n', '            total -= _maxAmt;\n', '            entries[entry.prev].next = entry.next;\n', '            entries[entry.next].prev = entry.prev;\n', '            delete entries[_address];\n', '            return _maxAmt;\n', '        } else {\n', '            // Subtract the amount from entry.\n', '            total -= _amt;\n', '            entry.balance -= _amt;\n', '            return _amt;\n', '        }\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function balanceOf(address _address)\n', '        public\n', '        view\n', '        returns (uint _balance)\n', '    {\n', '        return entries[_address].balance;\n', '    }\n', '\n', '    function balances()\n', '        public\n', '        view\n', '        returns (address[] _addresses, uint[] _balances)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        _balances = new uint[](_size);\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _balances[_i] = entries[_curEntry.next].balance;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return (_addresses, _balances);\n', '    }\n', '}\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    addresses it has seen. Addresses can be added and removed\n', '    from the set, and a full list of addresses can be obtained.\n', '\n', '    Methods:\n', '     - [fromOwner] .add()\n', '     - [fromOwner] .remove()\n', '    Views:\n', '     - .size()\n', '     - .has()\n', '     - .addresses()\n', '*/\n', 'contract AddressSet {\n', '    \n', '    struct Entry {  // Doubly linked list\n', '        bool exists;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner.\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didCreate)\n', '    {\n', '        // Do not allow the adding of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', '        // If already exists, do nothing. Otherwise set it.\n', '        if (entry.exists) return;\n', '        else entry.exists = true;\n', '\n', '        // Replace first entry with this one.\n', '        // Before: HEAD <-> X <-> Y\n', '        // After: HEAD <-> THIS <-> X <-> Y\n', '        // do: THIS.NEXT = [0].next; [0].next.prev = THIS; [0].next = THIS; THIS.prev = 0;\n', '        Entry storage HEAD = entries[0x0];\n', '        entry.next = HEAD.next;\n', '        entries[HEAD.next].prev = _address;\n', '        HEAD.next = _address;\n', '        return true;\n', '    }\n', '\n', '    function remove(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didExist)\n', '    {\n', '        // Do not allow the removal of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', "        // If it doesn't exist already, there is nothing to do.\n", '        if (!entry.exists) return;\n', '\n', '        // Stitch together next and prev, delete entry.\n', '        // Before: X <-> THIS <-> Y\n', '        // After: X <-> Y\n', '        // do: THIS.next.prev = this.prev; THIS.prev.next = THIS.next;\n', '        entries[entry.prev].next = entry.next;\n', '        entries[entry.next].prev = entry.prev;\n', '        delete entries[_address];\n', '        return true;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function has(address _address)\n', '        public\n', '        view\n', '        returns (bool _exists)\n', '    {\n', '        return entries[_address].exists;\n', '    }\n', '\n', '    function addresses()\n', '        public\n', '        view\n', '        returns (address[] _addresses)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        // Iterate forward through all entries until the end.\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return _addresses;\n', '    }\n', '}\n', '\n', '/******* USING TREASURY **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .getTreasury(): returns current ITreasury instance\n', '    [modifier] .fromTreasury(): requires the sender is current Treasury\n', '\n', '*************************************************/\n', '// Returned by .getTreasury()\n', 'interface ITreasury {\n', '    function issueDividend() external returns (uint _profits);\n', '    function profitsSendable() external view returns (uint _profits);\n', '}\n', '\n', 'contract UsingTreasury is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromTreasury(){\n', '        require(msg.sender == address(getTreasury()));\n', '        _;\n', '    }\n', '    \n', '    function getTreasury()\n', '        public\n', '        view\n', '        returns (ITreasury)\n', '    {\n', '        return ITreasury(addressOf("TREASURY"));\n', '    }\n', '}\n', '\n', '\n', '/**\n', '  A simple class that manages bankroll, and maintains collateral.\n', '  This class only ever sends profits the Treasury. No exceptions.\n', '\n', '  - Anybody can add funding (according to whitelist)\n', '  - Anybody can tell profits (balance - (funding + collateral)) to go to Treasury.\n', '  - Anyone can remove their funding, so long as balance >= collateral.\n', '  - Whitelist is managed by getWhitelistOwner() -- typically Admin.\n', '\n', '  Exposes the following:\n', '    Public Methods\n', '     - addBankroll\n', '     - removeBankroll\n', '     - sendProfits\n', '    Public Views\n', '     - getCollateral\n', '     - profits\n', '     - profitsSent\n', '     - profitsTotal\n', '     - bankroll\n', '     - bankrollAvailable\n', '     - bankrolledBy\n', '     - bankrollerTable\n', '*/\n', 'contract Bankrollable is\n', '    UsingTreasury\n', '{   \n', '    // How much profits have been sent. \n', '    uint public profitsSent;\n', '    // Ledger keeps track of who has bankrolled us, and for how much\n', '    Ledger public ledger;\n', '    // This is a copy of ledger.total(), to save gas in .bankrollAvailable()\n', '    uint public bankroll;\n', '    // This is the whitelist of who can call .addBankroll()\n', '    AddressSet public whitelist;\n', '\n', '    modifier fromWhitelistOwner(){\n', '        require(msg.sender == getWhitelistOwner());\n', '        _;\n', '    }\n', '\n', '    event BankrollAdded(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event BankrollRemoved(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event ProfitsSent(uint time, address indexed treasury, uint amount);\n', '    event AddedToWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '    event RemovedFromWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '\n', '    // Constructor creates the ledger and whitelist, with self as owner.\n', '    constructor(address _registry)\n', '        UsingTreasury(_registry)\n', '        public\n', '    {\n', '        ledger = new Ledger(this);\n', '        whitelist = new AddressSet(this);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** WHITELIST MGMT ***********************/\n', '    /*****************************************************/    \n', '\n', '    function addToWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didAdd = whitelist.add(_addr);\n', '        if (_didAdd) emit AddedToWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    function removeFromWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didRemove = whitelist.remove(_addr);\n', '        if (_didRemove) emit RemovedFromWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC FUNCTIONS *********************/\n', '    /*****************************************************/\n', '\n', '    // Bankrollable contracts should be payable (to receive revenue)\n', '    function () public payable {}\n', '\n', '    // Increase funding by whatever value is sent\n', '    function addBankroll()\n', '        public\n', '        payable \n', '    {\n', '        require(whitelist.size()==0 || whitelist.has(msg.sender));\n', '        ledger.add(msg.sender, msg.value);\n', '        bankroll = ledger.total();\n', '        emit BankrollAdded(now, msg.sender, msg.value, bankroll);\n', '    }\n', '\n', '    // Removes up to _amount from Ledger, and sends it to msg.sender._callbackFn\n', '    function removeBankroll(uint _amount, string _callbackFn)\n', '        public\n', '        returns (uint _recalled)\n', '    {\n', '        // cap amount at the balance minus collateral, or nothing at all.\n', '        address _bankroller = msg.sender;\n', '        uint _collateral = getCollateral();\n', '        uint _balance = address(this).balance;\n', '        uint _available = _balance > _collateral ? _balance - _collateral : 0;\n', '        if (_amount > _available) _amount = _available;\n', '\n', '        // Try to remove _amount from ledger, get actual _amount removed.\n', '        _amount = ledger.subtract(_bankroller, _amount);\n', '        bankroll = ledger.total();\n', '        if (_amount == 0) return;\n', '\n', '        bytes4 _sig = bytes4(keccak256(_callbackFn));\n', '        require(_bankroller.call.value(_amount)(_sig));\n', '        emit BankrollRemoved(now, _bankroller, _amount, bankroll);\n', '        return _amount;\n', '    }\n', '\n', '    // Send any excess profits to treasury.\n', '    function sendProfits()\n', '        public\n', '        returns (uint _profits)\n', '    {\n', '        int _p = profits();\n', '        if (_p <= 0) return;\n', '        _profits = uint(_p);\n', '        profitsSent += _profits;\n', '        // Send profits to Treasury\n', '        address _tr = getTreasury();\n', '        require(_tr.call.value(_profits)());\n', '        emit ProfitsSent(now, _tr, _profits);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC VIEWS *************************/\n', '    /*****************************************************/\n', '\n', '    // Function must be overridden by inheritors to ensure collateral is kept.\n', '    function getCollateral()\n', '        public\n', '        view\n', '        returns (uint _amount);\n', '\n', '    // Function must be overridden by inheritors to enable whitelist control.\n', '    function getWhitelistOwner()\n', '        public\n', '        view\n', '        returns (address _addr);\n', '\n', '    // Profits are the difference between balance and threshold\n', '    function profits()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        int _balance = int(address(this).balance);\n', '        int _threshold = int(bankroll + getCollateral());\n', '        return _balance - _threshold;\n', '    }\n', '\n', '    // How profitable this contract is, overall\n', '    function profitsTotal()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        return int(profitsSent) + profits();\n', '    }\n', '\n', '    // Returns the amount that can currently be bankrolled.\n', '    //   - 0 if balance < collateral\n', '    //   - If profits: full bankroll\n', '    //   - If no profits: remaning bankroll: balance - collateral\n', '    function bankrollAvailable()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        uint _balance = address(this).balance;\n', '        uint _bankroll = bankroll;\n', '        uint _collat = getCollateral();\n', '        // Balance is below collateral!\n', '        if (_balance <= _collat) return 0;\n', '        // No profits, but we have a balance over collateral.\n', '        else if (_balance < _collat + _bankroll) return _balance - _collat;\n', '        // Profits. Return only _bankroll\n', '        else return _bankroll;\n', '    }\n', '\n', '    function bankrolledBy(address _addr)\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return ledger.balanceOf(_addr);\n', '    }\n', '\n', '    function bankrollerTable()\n', '        public\n', '        view\n', '        returns (address[], uint[])\n', '    {\n', '        return ledger.balances();\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/******* USING ADMIN ***********************\n', '\n', 'Gives the inherting contract access to:\n', '    .getAdmin(): returns the current address of the admin\n', '    [modifier] .fromAdmin: requires the sender is the admin\n', '\n', '*************************************************/\n', 'contract UsingAdmin is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromAdmin(){\n', '        require(msg.sender == getAdmin());\n', '        _;\n', '    }\n', '    \n', '    function getAdmin()\n', '        public\n', '        constant\n', '        returns (address _addr)\n', '    {\n', '        return addressOf("ADMIN");\n', '    }\n', '}\n', '\n', '/*********************************************************\n', '*********************** INSTADICE ************************\n', '**********************************************************\n', '\n', 'UI: https://www.pennyether.com\n', '\n', 'This contract allows for users to wager a limited amount on then\n', 'outcome of a random roll between [1, 100]. The user may choose\n', 'a number, and if the roll is less than or equal to that number,\n', 'they will win a payout that is inversely proportional to the\n', 'number they chose (lower numbers pay out more).\n', '\n', 'When a roll is "finalized", it means the result was determined\n', 'and the payout paid to the user if they won. Each time somebody \n', 'rolls, their previous roll is finalized. Roll results are based\n', 'on blockhash, and since only the last 256 blockhashes are \n', 'available (who knows why it is so limited...), the user must\n', 'finalize within 256 blocks or their roll loses.\n', '\n', 'Note about randomness:\n', '  Although using blockhash for randomness is not advised,\n', '  it is perfectly acceptable if the results of the block\n', '  are not worth an expected value greater than that of:\n', '    (full block reward - uncle block reward) = ~.625 Eth\n', '\n', '  In other words, a miner is better of mining honestly and\n', '  getting a full block reward than trying to game this contract,\n', '  unless the maximum bet is increased to about .625, which\n', '  this contract forbids.\n', '*/\n', 'contract InstaDice is\n', '    Bankrollable,\n', '    UsingAdmin\n', '{\n', '    struct User {\n', '        uint32 id;\n', '        uint32 r_id;\n', '        uint32 r_block;\n', '        uint8 r_number;\n', '        uint72 r_payout;\n', '    }\n', '\n', '    // These stats are updated on each roll.\n', '    struct Stats {\n', '        uint32 numUsers;\n', '        uint32 numRolls;\n', '        uint96 totalWagered;\n', '        uint96 totalWon;\n', '    }\n', '    \n', '    // Admin controlled settings\n', '    struct Settings {\n', '        uint64 minBet;    //\n', '        uint64 maxBet;    // \n', '        uint8 minNumber;  // they get ~20x their bet\n', '        uint8 maxNumber;  // they get ~1.01x their bet\n', '        uint16 feeBips;   // each bip is .01%, eg: 100 = 1% fee.\n', '    }\n', '\n', '    mapping (address => User) public users;\n', '    Stats stats;\n', '    Settings settings;\n', '    uint8 constant public version = 2;\n', '    \n', '    // Admin events\n', '    event Created(uint time);\n', '    event SettingsChanged(uint time, address indexed admin);\n', '\n', '    // Events\n', '    event RollWagered(uint time, uint32 indexed id, address indexed user, uint bet, uint8 number, uint payout);\n', '    event RollRefunded(uint time, address indexed user, string msg, uint bet, uint8 number);\n', '    event RollFinalized(uint time, uint32 indexed id, address indexed user, uint8 result, uint payout);\n', '    event PayoutError(uint time, string msg);\n', '\n', '    constructor(address _registry)\n', '        Bankrollable(_registry)\n', '        UsingAdmin(_registry)\n', '        public\n', '    {\n', "        // populate with prev contracts' stats\n", '        stats.totalWagered = 3650000000000000000;\n', '        stats.totalWon = 3537855001272912000;\n', '        stats.numRolls = 123;\n', '        stats.numUsers = 19;\n', '\n', '        // default settings\n', '        settings.maxBet = .3 ether;\n', '        settings.minBet = .001 ether;\n', '        settings.minNumber = 5;\n', '        settings.maxNumber = 98;\n', '        settings.feeBips = 100;\n', '        emit Created(now);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////\n', '    ////// ADMIN FUNCTIONS ////////////////////////////\n', '    ///////////////////////////////////////////////////\n', '\n', '    // Changes the settings\n', '    function changeSettings(\n', '        uint64 _minBet,\n', '        uint64 _maxBet,\n', '        uint8 _minNumber,\n', '        uint8 _maxNumber,\n', '        uint16 _feeBips\n', '    )\n', '        public\n', '        fromAdmin\n', '    {\n', '        require(_minBet <= _maxBet);    // makes sense\n', '        require(_maxBet <= .625 ether); // capped at (block reward - uncle reward)\n', '        require(_minNumber >= 1);       // not advisible, but why not\n', '        require(_maxNumber <= 99);      // over 100 makes no sense\n', '        require(_feeBips <= 500);       // max of 5%\n', '        settings.minBet = _minBet;\n', '        settings.maxBet = _maxBet;\n', '        settings.minNumber = _minNumber;\n', '        settings.maxNumber = _maxNumber;\n', '        settings.feeBips = _feeBips;\n', '        emit SettingsChanged(now, msg.sender);\n', '    }\n', '    \n', '\n', '    ///////////////////////////////////////////////////\n', '    ////// PUBLIC FUNCTIONS ///////////////////////////\n', '    ///////////////////////////////////////////////////\n', '\n', '    // Resolves the last roll for the user.\n', '    // Then creates a new roll.\n', '    // Gas:\n', '    //    Total: 56k (new), or up to 44k (repeat)\n', '    //    Overhead: 36k\n', '    //       22k: tx overhead\n', '    //        2k: SLOAD\n', '    //        3k: execution\n', '    //        2k: curMaxBet()\n', '    //        5k: update stats\n', '    //        2k: RollWagered event\n', '    //    New User: 20k\n', '    //       20k: create user\n', '    //    Repeat User: 8k, 16k\n', '    //        5k: update user\n', '    //        3k: RollFinalized event\n', '    //        8k: pay last roll\n', '    function roll(uint8 _number)\n', '        public\n', '        payable\n', '        returns (bool _success)\n', '    {\n', '        // Ensure bet and number are valid.\n', '        if (!_validateBetOrRefund(_number)) return;\n', '\n', '        // Ensure one bet per block.\n', '        User memory _prevUser = users[msg.sender];\n', '        if (_prevUser.r_block == uint32(block.number)){\n', '            _errorAndRefund("Only one bet per block allowed.", msg.value, _number);\n', '            return false;\n', '        }\n', '\n', '        // Create and write new user data before finalizing last roll\n', '        Stats memory _stats = stats;\n', '        User memory _newUser = User({\n', '            id: _prevUser.id == 0 ? _stats.numUsers + 1 : _prevUser.id,\n', '            r_id: _stats.numRolls + 1,\n', '            r_block: uint32(block.number),\n', '            r_number: _number,\n', '            r_payout: computePayout(msg.value, _number)\n', '        });\n', '        users[msg.sender] = _newUser;\n', '\n', '        // Finalize last roll, if there was one.\n', "        // This will throw if user won, but we couldn't pay.\n", '        if (_prevUser.r_block != 0) _finalizePreviousRoll(_prevUser, _stats);\n', '\n', '        // Increment additional stats data\n', '        _stats.numUsers = _prevUser.id == 0 ? _stats.numUsers + 1 : _stats.numUsers;\n', '        _stats.numRolls = stats.numRolls + 1;\n', '        _stats.totalWagered = stats.totalWagered + uint96(msg.value);\n', '        stats = _stats;\n', '\n', '        // Save user in one write.\n', '        emit RollWagered(now, _newUser.r_id, msg.sender, msg.value, _newUser.r_number, _newUser.r_payout);\n', '        return true;\n', '    }\n', '\n', '    // Finalizes the previous roll and pays out user if they won.\n', '    // Gas: 45k\n', '    //   21k: tx overhead\n', '    //    1k: SLOADs\n', '    //    2k: execution\n', '    //    8k: send winnings\n', '    //    5k: update user\n', '    //    5k: update stats\n', '    //    3k: RollFinalized event\n', '    function payoutPreviousRoll()\n', '        public\n', '        returns (bool _success)\n', '    {\n', '        // Load last roll in one SLOAD.\n', '        User memory _prevUser = users[msg.sender];\n', '        // Error if on same block.\n', '        if (_prevUser.r_block == uint32(block.number)){\n', '            emit PayoutError(now, "Cannot payout roll on the same block");\n', '            return false;\n', '        }\n', '        // Error if nothing to payout.\n', '        if (_prevUser.r_block == 0){\n', '            emit PayoutError(now, "No roll to pay out.");\n', '            return false;\n', '        }\n', '\n', '        // Clear last roll data\n', '        User storage _user = users[msg.sender];\n', '        _user.r_id = 0;\n', '        _user.r_block = 0;\n', '        _user.r_number = 0;\n', '        _user.r_payout = 0;\n', '\n', '        // Finalize previous roll and update stats\n', '        Stats memory _stats = stats;\n', '        _finalizePreviousRoll(_prevUser, _stats);\n', '        stats.totalWon = _stats.totalWon;\n', '        return true;\n', '    }\n', '\n', '\n', '    ////////////////////////////////////////////////////////\n', '    ////// PRIVATE FUNCTIONS ///////////////////////////////\n', '    ////////////////////////////////////////////////////////\n', '\n', '    // Validates the bet, or refunds the user.\n', '    function _validateBetOrRefund(uint8 _number)\n', '        private\n', '        returns (bool _isValid)\n', '    {\n', '        Settings memory _settings = settings;\n', '        if (_number < _settings.minNumber) {\n', '            _errorAndRefund("Roll number too small.", msg.value, _number);\n', '            return false;\n', '        }\n', '        if (_number > _settings.maxNumber){\n', '            _errorAndRefund("Roll number too large.", msg.value, _number);\n', '            return false;\n', '        }\n', '        if (msg.value < _settings.minBet){\n', '            _errorAndRefund("Bet too small.", msg.value, _number);\n', '            return false;\n', '        }\n', '        if (msg.value > _settings.maxBet){\n', '            _errorAndRefund("Bet too large.", msg.value, _number);\n', '            return false;\n', '        }\n', '        if (msg.value > curMaxBet()){\n', '            _errorAndRefund("May be unable to payout on a win.", msg.value, _number);\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Finalizes the previous roll for the _user.\n', '    // This will modify _stats, but not _user.\n', '    // Throws if unable to pay user on a win.\n', '    function _finalizePreviousRoll(User memory _user, Stats memory _stats)\n', '        private\n', '    {\n', '        assert(_user.r_block != uint32(block.number));\n', '        assert(_user.r_block != 0);\n', '        \n', '        // compute result and isWinner\n', '        uint8 _result = computeResult(_user.r_block, _user.r_id);\n', '        bool _isWinner = _result <= _user.r_number;\n', '        if (_isWinner) {\n', '            require(msg.sender.call.value(_user.r_payout)());\n', '            _stats.totalWon += _user.r_payout;\n', '        }\n', '        // they won and we paid, or they lost. roll is finalized.\n', '        emit RollFinalized(now, _user.r_id, msg.sender, _result, _isWinner ? _user.r_payout : 0);\n', '    }\n', '\n', '    // Only called from above.\n', '    // Refunds user the full value, and logs an error\n', '    function _errorAndRefund(string _msg, uint _bet, uint8 _number)\n', '        private\n', '    {\n', '        require(msg.sender.call.value(msg.value)());\n', '        emit RollRefunded(now, msg.sender, _msg, _bet, _number);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////\n', '    ////// PUBLIC VIEWS ///////////////////////////////\n', '    ///////////////////////////////////////////////////\n', '\n', '    // IMPLEMENTS: Bankrollable.getCollateral()\n', '    // This contract has no collateral, as it pays out in near realtime.\n', '    function getCollateral() public view returns (uint _amount) {\n', '        return 0;\n', '    }\n', '\n', '    // IMPLEMENTS: Bankrollable.getWhitelistOwner()\n', '    // Ensures contract always has at least bankroll + totalCredits.\n', '    function getWhitelistOwner() public view returns (address _wlOwner)\n', '    {\n', '        return getAdmin();\n', '    }\n', '\n', '    // Returns the largest bet such that we could pay out 10 maximum wins.\n', '    // The likelihood that 10 maximum bets (with highest payouts) are won\n', '    //  within a short period of time are extremely low.\n', '    function curMaxBet() public view returns (uint _amount) {\n', '        // Return largest bet such that 10*bet*payout = bankrollable()\n', '        uint _maxPayout = 10 * 100 / uint(settings.minNumber);\n', '        return bankrollAvailable() / _maxPayout;\n', '    }\n', '\n', '    // Return the less of settings.maxBet and curMaxBet()\n', '    function effectiveMaxBet() public view returns (uint _amount) {\n', '        uint _curMax = curMaxBet();\n', '        return _curMax > settings.maxBet ? settings.maxBet : _curMax;\n', '    }\n', '\n', '    // Computes the payout amount for the current _feeBips\n', '    function computePayout(uint _bet, uint _number)\n', '        public\n', '        view\n', '        returns (uint72 _wei)\n', '    {\n', '        uint _feeBips = settings.feeBips;   // Cast to uint, makes below math cheaper.\n', '        uint _bigBet = _bet * 1e32;         // Will not overflow unless _bet >> ~1e40\n', '        uint _bigPayout = (_bigBet * 100) / _number;\n', '        uint _bigFee = (_bigPayout * _feeBips) / 10000;\n', '        return uint72( (_bigPayout - _bigFee) / 1e32 );\n', '    }\n', '\n', '    // Returns a number between 1 and 100 (inclusive)\n', '    // If blockNumber is too far past, returns 101.\n', '    function computeResult(uint32 _blockNumber, uint32 _id)\n', '        public\n', '        view\n', '        returns (uint8 _result)\n', '    {\n', '        bytes32 _blockHash = blockhash(_blockNumber);\n', '        if (_blockHash == 0) { return 101; }\n', '        return uint8(uint(keccak256(_blockHash, _id)) % 100 + 1);\n', '    }\n', '\n', '    // Expose all Stats /////////////////////////////////\n', '    function numUsers() public view returns (uint32) {\n', '        return stats.numUsers;\n', '    }\n', '    function numRolls() public view returns (uint32) {\n', '        return stats.numRolls;\n', '    }\n', '    function totalWagered() public view returns (uint) {\n', '        return stats.totalWagered;\n', '    }\n', '    function totalWon() public view returns (uint) {\n', '        return stats.totalWon;\n', '    }\n', '    //////////////////////////////////////////////////////\n', '\n', '    // Expose all Settings ///////////////////////////////\n', '    function minBet() public view returns (uint) {\n', '        return settings.minBet;\n', '    }\n', '    function maxBet() public view returns (uint) {\n', '        return settings.maxBet;\n', '    }\n', '    function minNumber() public view returns (uint8) {\n', '        return settings.minNumber;\n', '    }\n', '    function maxNumber() public view returns (uint8) {\n', '        return settings.maxNumber;\n', '    }\n', '    function feeBips() public view returns (uint16) {\n', '        return settings.feeBips;\n', '    }\n', '    //////////////////////////////////////////////////////\n', '\n', '}']
