['pragma solidity ^0.4.13;\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract NeuroChainClausius is Owned, ERC20Interface {\n', '\n', '  // Adding safe calculation methods to uint256\n', '  using SafeMath for uint;\n', '  // Defining balances mapping (ERC20)\n', '  mapping(address => uint256) balances;\n', '  // Defining allowances mapping (ERC20)\n', '  mapping(address => mapping (address => uint256)) allowed;\n', '  // Defining addresses allowed to bypass global freeze\n', '  mapping(address => bool) public freezeBypassing;\n', '  // Defining addresses association between NeuroChain and ETH network\n', '  mapping(address => string) public neuroChainAddresses;\n', '  // Event raised when a NeuroChain address is changed\n', '  event NeuroChainAddressSet(\n', '    address ethAddress,\n', '    string neurochainAddress,\n', '    uint timestamp,\n', '    bool isForcedChange\n', '  );\n', '  // Event raised when trading status is toggled\n', '  event FreezeStatusChanged(\n', '    bool toStatus,\n', '    uint timestamp\n', '  );\n', '  // Token Symbol\n', '  string public symbol = "NCC";\n', '  // Token Name\n', '  string public name = "NeuroChain Clausius";\n', '  // Token Decimals\n', '  uint8 public decimals = 18;\n', '  // Total supply of token\n', '  uint public _totalSupply = 657440000 * 10**uint(decimals);\n', '  // Current distributed supply\n', '  uint public _circulatingSupply = 0;\n', '  // Global freeze toggle\n', '  bool public tradingLive = false;\n', '  // Address of the Crowdsale Contract\n', '  address public icoContractAddress;\n', '  /**\n', '   * @notice Sending Tokens to an address\n', '   * @param to The receiver address\n', '   * @param tokens The amount of tokens to send (without de decimal part)\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function distributeSupply(\n', '    address to,\n', '    uint tokens\n', '  )\n', '  public onlyOwner returns (bool success)\n', '  {\n', '    uint tokenAmount = tokens.mul(10**uint(decimals));\n', '    require(_circulatingSupply.add(tokenAmount) <= _totalSupply);\n', '    _circulatingSupply = _circulatingSupply.add(tokenAmount);\n', '    balances[to] = tokenAmount;\n', '    return true;\n', '  }\n', '  /**\n', '   * @notice Allowing a spender to bypass global frezze\n', '   * @param sender The allowed address\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function allowFreezeBypass(\n', '    address sender\n', '  )\n', '  public onlyOwner returns (bool success)\n', '  {\n', '    freezeBypassing[sender] = true;\n', '    return true;\n', '  }\n', '  /**\n', '   * @notice Sets if the trading is live\n', '   * @param isLive Enabling/Disabling trading\n', '   */\n', '  function setTradingStatus(\n', '    bool isLive\n', '  )\n', '  public onlyOwner\n', '  {\n', '    tradingLive = isLive;\n', '    FreezeStatusChanged(tradingLive, block.timestamp);\n', '  }\n', '  // Modifier that requires the trading to be live or\n', '  // allowed to bypass the freeze status\n', '  modifier tokenTradingMustBeLive(address sender) {\n', '    require(tradingLive || freezeBypassing[sender]);\n', '    _;\n', '  }\n', '  /**\n', '   * @notice Sets the ICO Contract Address variable to be used with the\n', '   * `onlyIcoContract` modifier.\n', '   * @param contractAddress The NeuroChainCrowdsale deployed address\n', '   */\n', '  function setIcoContractAddress(\n', '    address contractAddress\n', '  )\n', '  public onlyOwner\n', '  {\n', '    freezeBypassing[contractAddress] = true;\n', '    icoContractAddress = contractAddress;\n', '  }\n', '  // Modifier that requires msg.sender to be Crowdsale Contract\n', '  modifier onlyIcoContract() {\n', '    require(msg.sender == icoContractAddress);\n', '    _;\n', '  }\n', '  /**\n', '   * @notice Permit `msg.sender` to set its NeuroChain Address\n', '   * @param neurochainAddress The NeuroChain Address\n', '   */\n', '  function setNeuroChainAddress(\n', '    string neurochainAddress\n', '  )\n', '  public\n', '  {\n', '    neuroChainAddresses[msg.sender] = neurochainAddress;\n', '    NeuroChainAddressSet(\n', '      msg.sender,\n', '      neurochainAddress,\n', '      block.timestamp,\n', '      false\n', '    );\n', '  }\n', '  /**\n', '   * @notice Force NeuroChain Address to be associated to a\n', '   * standard ERC20 account\n', '   * @dev Can only be called by the ICO Contract\n', '   * @param ethAddress The ETH address to associate\n', '   * @param neurochainAddress The NeuroChain Address\n', '   */\n', '  function forceNeuroChainAddress(\n', '    address ethAddress,\n', '    string neurochainAddress\n', '  )\n', '  public onlyIcoContract\n', '  {\n', '    neuroChainAddresses[ethAddress] = neurochainAddress;\n', '    NeuroChainAddressSet(\n', '      ethAddress,\n', '      neurochainAddress,\n', '      block.timestamp,\n', '      true\n', '    );\n', '  }\n', '  /**\n', '   * @notice Return the total supply of the token\n', '   * @dev This function is part of the ERC20 standard\n', '   * @return The token supply\n', '   */\n', '  function totalSupply() public constant returns (uint) {\n', '    return _totalSupply;\n', '  }\n', '  /**\n', '   * @notice Get the token balance of `tokenOwner`\n', '   * @dev This function is part of the ERC20 standard\n', '   * @param tokenOwner The wallet to get the balance of\n', '   * @return {"balance": "The balance of `tokenOwner`"}\n', '   */\n', '  function balanceOf(\n', '    address tokenOwner\n', '  )\n', '  public constant returns (uint balance)\n', '  {\n', '    return balances[tokenOwner];\n', '  }\n', '  /**\n', '   * @notice Transfers `tokens` from msg.sender to `to`\n', '   * @dev This function is part of the ERC20 standard\n', '   * @param to The address that receives the tokens\n', '   * @param tokens Token amount to transfer\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function transfer(\n', '    address to,\n', '    uint tokens\n', '  )\n', '  public tokenTradingMustBeLive(msg.sender) returns (bool success)\n', '  {\n', '    balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '    balances[to] = balances[to].add(tokens);\n', '    Transfer(msg.sender, to, tokens);\n', '    return true;\n', '  }\n', '  /**\n', '   * @notice Transfer tokens from an address to another\n', '   * through an allowance made beforehand\n', '   * @dev This function is part of the ERC20 standard\n', '   * @param from The address sending the tokens\n', '   * @param to The address recieving the tokens\n', '   * @param tokens Token amount to transfer\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function transferFrom(\n', '    address from,\n', '    address to,\n', '    uint tokens\n', '  )\n', '  public tokenTradingMustBeLive(from) returns (bool success)\n', '  {\n', '    balances[from] = balances[from].sub(tokens);\n', '    allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '    balances[to] = balances[to].add(tokens);\n', '    Transfer(from, to, tokens);\n', '    return true;\n', '  }\n', '  /**\n', '   * @notice Approve an address to send `tokenAmount` tokens to `msg.sender` (make an allowance)\n', '   * @dev This function is part of the ERC20 standard\n', '   * @param spender The allowed address\n', '   * @param tokens The maximum amount allowed to spend\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function approve(\n', '    address spender,\n', '    uint tokens\n', '  )\n', '  public returns (bool success)\n', '  {\n', '    allowed[msg.sender][spender] = tokens;\n', '    Approval(msg.sender, spender, tokens);\n', '    return true;\n', '  }\n', '  /**\n', '   * @notice Get the remaining allowance for a spender on a given address\n', '   * @dev This function is part of the ERC20 standard\n', '   * @param tokenOwner The address that owns the tokens\n', '   * @param spender The spender\n', '   * @return {"remaining": "The amount of tokens remaining in the allowance"}\n', '   */\n', '  function allowance(\n', '    address tokenOwner,\n', '    address spender\n', '  )\n', '  public constant returns (uint remaining)\n', '  {\n', '    return allowed[tokenOwner][spender];\n', '  }\n', '  /**\n', '   * @notice Permits to create an approval on a contract and then call a method\n', '   * on the approved contract right away.\n', '   * @param spender The allowed address\n', '   * @param tokens The maximum amount allowed to spend\n', '   * @param data The data sent back as parameter to the contract (bytes array)\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function approveAndCall(\n', '    address spender,\n', '    uint tokens,\n', '    bytes data\n', '  )\n', '  public returns (bool success)\n', '  {\n', '    allowed[msg.sender][spender] = tokens;\n', '    Approval(msg.sender, spender, tokens);\n', '    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '    return true;\n', '  }\n', '  /**\n', '   * @notice Permits to withdraw any ERC20 tokens that have been mistakingly sent to this contract\n', '   * @param tokenAddress The received ERC20 token address\n', '   * @param tokens The amount of ERC20 tokens to withdraw from this contract\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function transferAnyERC20Token(\n', '    address tokenAddress,\n', '    uint tokens\n', '  )\n', '  public onlyOwner returns (bool success)\n', '  {\n', '    return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers with 18 decimals, represented as uints (e.g. ether or token values)\n', '    */\n', '    uint constant ETHER_PRECISION = 10 ** 18;\n', '    function ediv(uint x, uint y) internal pure returns (uint z) {\n', '        // Put x to the 36th order of magnitude, so natural division will put it back to the 18th\n', '        // Adding y/2 before putting x back to the 18th order of magnitude is necessary to force the EVM to round up instead of down\n', '        z = add(mul(x, ETHER_PRECISION), y / 2) / y;\n', '    }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract NeuroChainClausius is Owned, ERC20Interface {\n', '\n', '  // Adding safe calculation methods to uint256\n', '  using SafeMath for uint;\n', '  // Defining balances mapping (ERC20)\n', '  mapping(address => uint256) balances;\n', '  // Defining allowances mapping (ERC20)\n', '  mapping(address => mapping (address => uint256)) allowed;\n', '  // Defining addresses allowed to bypass global freeze\n', '  mapping(address => bool) public freezeBypassing;\n', '  // Defining addresses association between NeuroChain and ETH network\n', '  mapping(address => string) public neuroChainAddresses;\n', '  // Event raised when a NeuroChain address is changed\n', '  event NeuroChainAddressSet(\n', '    address ethAddress,\n', '    string neurochainAddress,\n', '    uint timestamp,\n', '    bool isForcedChange\n', '  );\n', '  // Event raised when trading status is toggled\n', '  event FreezeStatusChanged(\n', '    bool toStatus,\n', '    uint timestamp\n', '  );\n', '  // Token Symbol\n', '  string public symbol = "NCC";\n', '  // Token Name\n', '  string public name = "NeuroChain Clausius";\n', '  // Token Decimals\n', '  uint8 public decimals = 18;\n', '  // Total supply of token\n', '  uint public _totalSupply = 657440000 * 10**uint(decimals);\n', '  // Current distributed supply\n', '  uint public _circulatingSupply = 0;\n', '  // Global freeze toggle\n', '  bool public tradingLive = false;\n', '  // Address of the Crowdsale Contract\n', '  address public icoContractAddress;\n', '  /**\n', '   * @notice Sending Tokens to an address\n', '   * @param to The receiver address\n', '   * @param tokens The amount of tokens to send (without de decimal part)\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function distributeSupply(\n', '    address to,\n', '    uint tokens\n', '  )\n', '  public onlyOwner returns (bool success)\n', '  {\n', '    uint tokenAmount = tokens.mul(10**uint(decimals));\n', '    require(_circulatingSupply.add(tokenAmount) <= _totalSupply);\n', '    _circulatingSupply = _circulatingSupply.add(tokenAmount);\n', '    balances[to] = tokenAmount;\n', '    return true;\n', '  }\n', '  /**\n', '   * @notice Allowing a spender to bypass global frezze\n', '   * @param sender The allowed address\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function allowFreezeBypass(\n', '    address sender\n', '  )\n', '  public onlyOwner returns (bool success)\n', '  {\n', '    freezeBypassing[sender] = true;\n', '    return true;\n', '  }\n', '  /**\n', '   * @notice Sets if the trading is live\n', '   * @param isLive Enabling/Disabling trading\n', '   */\n', '  function setTradingStatus(\n', '    bool isLive\n', '  )\n', '  public onlyOwner\n', '  {\n', '    tradingLive = isLive;\n', '    FreezeStatusChanged(tradingLive, block.timestamp);\n', '  }\n', '  // Modifier that requires the trading to be live or\n', '  // allowed to bypass the freeze status\n', '  modifier tokenTradingMustBeLive(address sender) {\n', '    require(tradingLive || freezeBypassing[sender]);\n', '    _;\n', '  }\n', '  /**\n', '   * @notice Sets the ICO Contract Address variable to be used with the\n', '   * `onlyIcoContract` modifier.\n', '   * @param contractAddress The NeuroChainCrowdsale deployed address\n', '   */\n', '  function setIcoContractAddress(\n', '    address contractAddress\n', '  )\n', '  public onlyOwner\n', '  {\n', '    freezeBypassing[contractAddress] = true;\n', '    icoContractAddress = contractAddress;\n', '  }\n', '  // Modifier that requires msg.sender to be Crowdsale Contract\n', '  modifier onlyIcoContract() {\n', '    require(msg.sender == icoContractAddress);\n', '    _;\n', '  }\n', '  /**\n', '   * @notice Permit `msg.sender` to set its NeuroChain Address\n', '   * @param neurochainAddress The NeuroChain Address\n', '   */\n', '  function setNeuroChainAddress(\n', '    string neurochainAddress\n', '  )\n', '  public\n', '  {\n', '    neuroChainAddresses[msg.sender] = neurochainAddress;\n', '    NeuroChainAddressSet(\n', '      msg.sender,\n', '      neurochainAddress,\n', '      block.timestamp,\n', '      false\n', '    );\n', '  }\n', '  /**\n', '   * @notice Force NeuroChain Address to be associated to a\n', '   * standard ERC20 account\n', '   * @dev Can only be called by the ICO Contract\n', '   * @param ethAddress The ETH address to associate\n', '   * @param neurochainAddress The NeuroChain Address\n', '   */\n', '  function forceNeuroChainAddress(\n', '    address ethAddress,\n', '    string neurochainAddress\n', '  )\n', '  public onlyIcoContract\n', '  {\n', '    neuroChainAddresses[ethAddress] = neurochainAddress;\n', '    NeuroChainAddressSet(\n', '      ethAddress,\n', '      neurochainAddress,\n', '      block.timestamp,\n', '      true\n', '    );\n', '  }\n', '  /**\n', '   * @notice Return the total supply of the token\n', '   * @dev This function is part of the ERC20 standard\n', '   * @return The token supply\n', '   */\n', '  function totalSupply() public constant returns (uint) {\n', '    return _totalSupply;\n', '  }\n', '  /**\n', '   * @notice Get the token balance of `tokenOwner`\n', '   * @dev This function is part of the ERC20 standard\n', '   * @param tokenOwner The wallet to get the balance of\n', '   * @return {"balance": "The balance of `tokenOwner`"}\n', '   */\n', '  function balanceOf(\n', '    address tokenOwner\n', '  )\n', '  public constant returns (uint balance)\n', '  {\n', '    return balances[tokenOwner];\n', '  }\n', '  /**\n', '   * @notice Transfers `tokens` from msg.sender to `to`\n', '   * @dev This function is part of the ERC20 standard\n', '   * @param to The address that receives the tokens\n', '   * @param tokens Token amount to transfer\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function transfer(\n', '    address to,\n', '    uint tokens\n', '  )\n', '  public tokenTradingMustBeLive(msg.sender) returns (bool success)\n', '  {\n', '    balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '    balances[to] = balances[to].add(tokens);\n', '    Transfer(msg.sender, to, tokens);\n', '    return true;\n', '  }\n', '  /**\n', '   * @notice Transfer tokens from an address to another\n', '   * through an allowance made beforehand\n', '   * @dev This function is part of the ERC20 standard\n', '   * @param from The address sending the tokens\n', '   * @param to The address recieving the tokens\n', '   * @param tokens Token amount to transfer\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function transferFrom(\n', '    address from,\n', '    address to,\n', '    uint tokens\n', '  )\n', '  public tokenTradingMustBeLive(from) returns (bool success)\n', '  {\n', '    balances[from] = balances[from].sub(tokens);\n', '    allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '    balances[to] = balances[to].add(tokens);\n', '    Transfer(from, to, tokens);\n', '    return true;\n', '  }\n', '  /**\n', '   * @notice Approve an address to send `tokenAmount` tokens to `msg.sender` (make an allowance)\n', '   * @dev This function is part of the ERC20 standard\n', '   * @param spender The allowed address\n', '   * @param tokens The maximum amount allowed to spend\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function approve(\n', '    address spender,\n', '    uint tokens\n', '  )\n', '  public returns (bool success)\n', '  {\n', '    allowed[msg.sender][spender] = tokens;\n', '    Approval(msg.sender, spender, tokens);\n', '    return true;\n', '  }\n', '  /**\n', '   * @notice Get the remaining allowance for a spender on a given address\n', '   * @dev This function is part of the ERC20 standard\n', '   * @param tokenOwner The address that owns the tokens\n', '   * @param spender The spender\n', '   * @return {"remaining": "The amount of tokens remaining in the allowance"}\n', '   */\n', '  function allowance(\n', '    address tokenOwner,\n', '    address spender\n', '  )\n', '  public constant returns (uint remaining)\n', '  {\n', '    return allowed[tokenOwner][spender];\n', '  }\n', '  /**\n', '   * @notice Permits to create an approval on a contract and then call a method\n', '   * on the approved contract right away.\n', '   * @param spender The allowed address\n', '   * @param tokens The maximum amount allowed to spend\n', '   * @param data The data sent back as parameter to the contract (bytes array)\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function approveAndCall(\n', '    address spender,\n', '    uint tokens,\n', '    bytes data\n', '  )\n', '  public returns (bool success)\n', '  {\n', '    allowed[msg.sender][spender] = tokens;\n', '    Approval(msg.sender, spender, tokens);\n', '    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '    return true;\n', '  }\n', '  /**\n', '   * @notice Permits to withdraw any ERC20 tokens that have been mistakingly sent to this contract\n', '   * @param tokenAddress The received ERC20 token address\n', '   * @param tokens The amount of ERC20 tokens to withdraw from this contract\n', '   * @return {"success": "If the operation completed successfuly"}\n', '   */\n', '  function transferAnyERC20Token(\n', '    address tokenAddress,\n', '    uint tokens\n', '  )\n', '  public onlyOwner returns (bool success)\n', '  {\n', '    return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers with 18 decimals, represented as uints (e.g. ether or token values)\n', '    */\n', '    uint constant ETHER_PRECISION = 10 ** 18;\n', '    function ediv(uint x, uint y) internal pure returns (uint z) {\n', '        // Put x to the 36th order of magnitude, so natural division will put it back to the 18th\n', '        // Adding y/2 before putting x back to the 18th order of magnitude is necessary to force the EVM to round up instead of down\n', '        z = add(mul(x, ETHER_PRECISION), y / 2) / y;\n', '    }\n', '}']
