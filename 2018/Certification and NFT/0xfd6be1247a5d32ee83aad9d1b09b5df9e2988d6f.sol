['pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/*\n', '\n', 'When executed after the Kings contract, the entire token balance inside the contract will be transferred to the minter if they becomes the king which they are already the king.\n', '\n', '\n', '*/\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract ERC918Interface {\n', '\n', '  function epochCount() public constant returns (uint);\n', '\n', '  function totalSupply() public constant returns (uint);\n', '  function getMiningDifficulty() public constant returns (uint);\n', '  function getMiningTarget() public constant returns (uint);\n', '  function getMiningReward() public constant returns (uint);\n', '  function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '\n', '  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '\n', '  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '}\n', '\n', 'contract mintForwarderInterface\n', '{\n', '  function mintForwarder(uint256 nonce, bytes32 challenge_digest, address[] proxyMintArray) public returns (bool success);\n', '}\n', '\n', 'contract proxyMinterInterface\n', '{\n', '  function proxyMint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '}\n', '\n', 'contract miningKingContract\n', '{\n', '  function getKing() public returns (address king);\n', '}\n', '\n', '\n', 'contract ownedContractInterface\n', '{\n', '  address public owner;\n', '\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '\n', '// Owned contract\n', '\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '\n', '    address public newOwner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '\n', '    function Owned() public {\n', '\n', '        owner = msg.sender;\n', '\n', '    }\n', '\n', '\n', '    modifier onlyOwner {\n', '\n', '        require(msg.sender == owner);\n', '\n', '        _;\n', '\n', '    }\n', '\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '\n', '        newOwner = _newOwner;\n', '\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '\n', '        require(msg.sender == newOwner);\n', '\n', '        OwnershipTransferred(owner, newOwner);\n', '\n', '        owner = newOwner;\n', '\n', '        newOwner = address(0);\n', '\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract DoubleKingsReward is Owned\n', '{\n', '\n', '\n', '  using SafeMath for uint;\n', '\n', '\n', '   address public kingContract;\n', '\n', '   address public minedToken;\n', '\n', '\n', '\n', '   // 0xBTC is 0xb6ed7644c69416d67b522e20bc294a9a9b405b31;\n', '  constructor(address mToken, address mkContract) public  {\n', '    minedToken = mToken;\n', '    kingContract = mkContract;\n', '  }\n', '\n', '\n', '  function getBalance() view public returns (uint)\n', '  {\n', '    return ERC20Interface(minedToken).balanceOf(this);\n', '  }\n', '\n', '  //do not allow ether to enter\n', '  function() public payable {\n', '      revert();\n', '  }\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' Pay out the token balance if the king becomes the king twice in a row\n', '**/\n', '\n', '//proxyMintWithKing\n', '   function mintForwarder(uint256 nonce, bytes32 challenge_digest, address[] proxyMintArray) public returns (bool)\n', '   {\n', '\n', '       require(proxyMintArray.length > 0);\n', '\n', '\n', '       uint previousEpochCount = ERC918Interface(minedToken).epochCount();\n', '\n', '       address proxyMinter = proxyMintArray[0];\n', '\n', '       if(proxyMintArray.length == 1)\n', '       {\n', '         //Forward to the last proxyMint contract, typically a pool&#39;s owned  mint contract\n', '         require(proxyMinterInterface(proxyMinter).proxyMint(nonce, challenge_digest));\n', '       }else{\n', '         //if array length is greater than 1, pop the proxyMinter from the front of the array and keep cascading down the chain...\n', '         address[] memory remainingProxyMintArray = popFirstFromArray(proxyMintArray);\n', '\n', '         require(mintForwarderInterface(proxyMinter).mintForwarder(nonce, challenge_digest,remainingProxyMintArray));\n', '       }\n', '\n', '      //make sure that the minedToken really was proxy minted through the proxyMint delegate call chain\n', '       require( ERC918Interface(minedToken).epochCount() == previousEpochCount.add(1) );\n', '\n', '\n', '\n', '\n', '       // UNIQUE CONTRACT ACTION SPACE\n', '       address proxyMinterAddress = ownedContractInterface(proxyMinter).owner();\n', '       require(proxyMinterAddress == owner);\n', '\n', '       address miningKing = miningKingContract(kingContract).getKing();\n', '\n', '       bytes memory nonceBytes = uintToBytesForAddress(nonce);\n', '\n', '       address newKing = bytesToAddress(nonceBytes);\n', '\n', '       if(miningKing == newKing)\n', '       {\n', '         uint balance = ERC20Interface(minedToken).balanceOf(this);\n', '         require(ERC20Interface(minedToken).transfer(newKing,balance));\n', '       }\n', '       // --------\n', '\n', '       return true;\n', '   }\n', '\n', '\n', '  function popFirstFromArray(address[] array) pure public returns (address[] memory)\n', '  {\n', '    address[] memory newArray = new address[](array.length-1);\n', '\n', '    for (uint i=0; i < array.length-1; i++) {\n', '      newArray[i] =  array[i+1]  ;\n', '    }\n', '\n', '    return newArray;\n', '  }\n', '\n', ' function uintToBytesForAddress(uint256 x) pure public returns (bytes b) {\n', '\n', '      b = new bytes(20);\n', '      for (uint i = 0; i < 20; i++) {\n', '          b[i] = byte(uint8(x / (2**(8*(31 - i)))));\n', '      }\n', '\n', '      return b;\n', '    }\n', '\n', '\n', ' function bytesToAddress (bytes b) pure public returns (address) {\n', '     uint result = 0;\n', '     for (uint i = b.length-1; i+1 > 0; i--) {\n', '       uint c = uint(b[i]);\n', '       uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\n', '       result += to_inc;\n', '     }\n', '     return address(result);\n', ' }\n', '\n', ' // ------------------------------------------------------------------------\n', '\n', ' // Owner can transfer out any accidentally sent ERC20 tokens\n', '\n', ' // ------------------------------------------------------------------------\n', '\n', ' function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '\n', '     return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '\n', ' }\n', '\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/*\n', '\n', 'When executed after the Kings contract, the entire token balance inside the contract will be transferred to the minter if they becomes the king which they are already the king.\n', '\n', '\n', '*/\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract ERC918Interface {\n', '\n', '  function epochCount() public constant returns (uint);\n', '\n', '  function totalSupply() public constant returns (uint);\n', '  function getMiningDifficulty() public constant returns (uint);\n', '  function getMiningTarget() public constant returns (uint);\n', '  function getMiningReward() public constant returns (uint);\n', '  function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '\n', '  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '\n', '  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '}\n', '\n', 'contract mintForwarderInterface\n', '{\n', '  function mintForwarder(uint256 nonce, bytes32 challenge_digest, address[] proxyMintArray) public returns (bool success);\n', '}\n', '\n', 'contract proxyMinterInterface\n', '{\n', '  function proxyMint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '}\n', '\n', 'contract miningKingContract\n', '{\n', '  function getKing() public returns (address king);\n', '}\n', '\n', '\n', 'contract ownedContractInterface\n', '{\n', '  address public owner;\n', '\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '\n', '// Owned contract\n', '\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '\n', '    address public newOwner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '\n', '    function Owned() public {\n', '\n', '        owner = msg.sender;\n', '\n', '    }\n', '\n', '\n', '    modifier onlyOwner {\n', '\n', '        require(msg.sender == owner);\n', '\n', '        _;\n', '\n', '    }\n', '\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '\n', '        newOwner = _newOwner;\n', '\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '\n', '        require(msg.sender == newOwner);\n', '\n', '        OwnershipTransferred(owner, newOwner);\n', '\n', '        owner = newOwner;\n', '\n', '        newOwner = address(0);\n', '\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract DoubleKingsReward is Owned\n', '{\n', '\n', '\n', '  using SafeMath for uint;\n', '\n', '\n', '   address public kingContract;\n', '\n', '   address public minedToken;\n', '\n', '\n', '\n', '   // 0xBTC is 0xb6ed7644c69416d67b522e20bc294a9a9b405b31;\n', '  constructor(address mToken, address mkContract) public  {\n', '    minedToken = mToken;\n', '    kingContract = mkContract;\n', '  }\n', '\n', '\n', '  function getBalance() view public returns (uint)\n', '  {\n', '    return ERC20Interface(minedToken).balanceOf(this);\n', '  }\n', '\n', '  //do not allow ether to enter\n', '  function() public payable {\n', '      revert();\n', '  }\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' Pay out the token balance if the king becomes the king twice in a row\n', '**/\n', '\n', '//proxyMintWithKing\n', '   function mintForwarder(uint256 nonce, bytes32 challenge_digest, address[] proxyMintArray) public returns (bool)\n', '   {\n', '\n', '       require(proxyMintArray.length > 0);\n', '\n', '\n', '       uint previousEpochCount = ERC918Interface(minedToken).epochCount();\n', '\n', '       address proxyMinter = proxyMintArray[0];\n', '\n', '       if(proxyMintArray.length == 1)\n', '       {\n', "         //Forward to the last proxyMint contract, typically a pool's owned  mint contract\n", '         require(proxyMinterInterface(proxyMinter).proxyMint(nonce, challenge_digest));\n', '       }else{\n', '         //if array length is greater than 1, pop the proxyMinter from the front of the array and keep cascading down the chain...\n', '         address[] memory remainingProxyMintArray = popFirstFromArray(proxyMintArray);\n', '\n', '         require(mintForwarderInterface(proxyMinter).mintForwarder(nonce, challenge_digest,remainingProxyMintArray));\n', '       }\n', '\n', '      //make sure that the minedToken really was proxy minted through the proxyMint delegate call chain\n', '       require( ERC918Interface(minedToken).epochCount() == previousEpochCount.add(1) );\n', '\n', '\n', '\n', '\n', '       // UNIQUE CONTRACT ACTION SPACE\n', '       address proxyMinterAddress = ownedContractInterface(proxyMinter).owner();\n', '       require(proxyMinterAddress == owner);\n', '\n', '       address miningKing = miningKingContract(kingContract).getKing();\n', '\n', '       bytes memory nonceBytes = uintToBytesForAddress(nonce);\n', '\n', '       address newKing = bytesToAddress(nonceBytes);\n', '\n', '       if(miningKing == newKing)\n', '       {\n', '         uint balance = ERC20Interface(minedToken).balanceOf(this);\n', '         require(ERC20Interface(minedToken).transfer(newKing,balance));\n', '       }\n', '       // --------\n', '\n', '       return true;\n', '   }\n', '\n', '\n', '  function popFirstFromArray(address[] array) pure public returns (address[] memory)\n', '  {\n', '    address[] memory newArray = new address[](array.length-1);\n', '\n', '    for (uint i=0; i < array.length-1; i++) {\n', '      newArray[i] =  array[i+1]  ;\n', '    }\n', '\n', '    return newArray;\n', '  }\n', '\n', ' function uintToBytesForAddress(uint256 x) pure public returns (bytes b) {\n', '\n', '      b = new bytes(20);\n', '      for (uint i = 0; i < 20; i++) {\n', '          b[i] = byte(uint8(x / (2**(8*(31 - i)))));\n', '      }\n', '\n', '      return b;\n', '    }\n', '\n', '\n', ' function bytesToAddress (bytes b) pure public returns (address) {\n', '     uint result = 0;\n', '     for (uint i = b.length-1; i+1 > 0; i--) {\n', '       uint c = uint(b[i]);\n', '       uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\n', '       result += to_inc;\n', '     }\n', '     return address(result);\n', ' }\n', '\n', ' // ------------------------------------------------------------------------\n', '\n', ' // Owner can transfer out any accidentally sent ERC20 tokens\n', '\n', ' // ------------------------------------------------------------------------\n', '\n', ' function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '\n', '     return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '\n', ' }\n', '\n', '\n', '}']
