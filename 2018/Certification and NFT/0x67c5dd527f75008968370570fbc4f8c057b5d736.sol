['pragma solidity 0.4.24;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract CasperToken is ERC20Interface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    string public constant name = "Csper Token";\n', '    string public constant symbol = "CST";\n', '    uint8 public constant decimals = 18;\n', '\n', '    uint constant public cstToMicro = uint(10) ** decimals;\n', '\n', '    // This constants reflects CST token distribution\n', '    uint constant public _totalSupply    = 440000000 * cstToMicro;\n', '    uint constant public preICOSupply    = 13000000 * cstToMicro;\n', '    uint constant public presaleSupply   = 183574716 * cstToMicro;\n', '    uint constant public crowdsaleSupply = 19750000 * cstToMicro;\n', '    uint constant public communitySupply = 66000000 * cstToMicro;\n', '    uint constant public systemSupply    = 35210341 * cstToMicro;\n', '    uint constant public investorSupply  = 36714943 * cstToMicro;\n', '    uint constant public teamSupply      = 66000000 * cstToMicro;\n', '    uint constant public adviserSupply   = 7000000 * cstToMicro;\n', '    uint constant public bountySupply    = 8800000 * cstToMicro;\n', '    uint constant public referralSupply  = 3950000 * cstToMicro;\n', '\n', '    // This variables accumulate amount of sold CST during\n', '    // presale, crowdsale, or given to investors as bonus.\n', '    uint public presaleSold = 0;\n', '    uint public crowdsaleSold = 0;\n', '    uint public investorGiven = 0;\n', '\n', '    // Amount of ETH received during ICO\n', '    uint public ethSold = 0;\n', '\n', '    uint constant public softcapUSD = 4500000;\n', '    uint constant public preicoUSD  = 1040000;\n', '\n', '    // Presale lower bound in dollars.\n', '    uint constant public crowdsaleMinUSD = cstToMicro * 10 * 100 / 12;\n', '    uint constant public bonusLevel0 = cstToMicro * 10000 * 100 / 12; // 10000$\n', '    uint constant public bonusLevel100 = cstToMicro * 100000 * 100 / 12; // 100000$\n', '\n', '    // Tokens are unlocked in 5 stages, by 20% (see doc to checkTransfer)\n', '    // All dates are stored as timestamps.\n', '    uint constant public unlockDate1 = 1538179199; // 28.09.2018 23:59:59\n', '    uint constant public unlockDate2 = 1543622399; // 30.11.2018 23:59:59\n', '    uint constant public unlockDate3 = 1548979199; // 31.01.2019 23:59:59\n', '    uint constant public unlockDate4 = 1553903999; // 29.03.2019 23:59:59\n', '    uint constant public unlockDate5 = 1559347199; // 31.05.2019 23:59:59\n', '\n', '    uint constant public teamUnlock1 = 1549065600; // 2.02.2019 \n', '    uint constant public teamUnlock2 = 1564704000; // 2.08.2019\n', '    uint constant public teamUnlock3 = 1580601600; // 2.02.2020\n', '    uint constant public teamUnlock4 = 1596326400; // 2.08.2020\n', '\n', '    uint constant public teamETHUnlock1 = 1535846400; // 2.09.2018\n', '    uint constant public teamETHUnlock2 = 1538438400; // 2.10.2018\n', '    uint constant public teamETHUnlock3 = 1541116800; // 2.11.2018\n', '\n', '    //https://casperproject.atlassian.net/wiki/spaces/PROD/pages/277839878/Smart+contract+ICO\n', '    // Presale 10.06.2018 - 22.07.2018\n', '    // Crowd-sale 23.07.2018 - 2.08.2018 (16.08.2018)\n', '    uint constant public presaleStartTime     = 1528588800;\n', '    uint constant public crowdsaleStartTime   = 1532304000;\n', '    uint          public crowdsaleEndTime     = 1533168000;\n', '    uint constant public crowdsaleHardEndTime = 1534377600;\n', '    //address constant CsperWallet = 0x6A5e633065475393211aB623286200910F465d02;\n', '    constructor() public {\n', '        admin = owner;\n', '        balances[owner] = _totalSupply;\n', '        emit Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerAndDirector {\n', '        require(msg.sender == owner || msg.sender == director);\n', '        _;\n', '    }\n', '\n', '    address admin;\n', '    function setAdmin(address _newAdmin) public onlyOwnerAndDirector {\n', '        admin = _newAdmin;\n', '    }\n', '\n', '    address director;\n', '    function setDirector(address _newDirector) public onlyOwner {\n', '        director = _newDirector;\n', '    }\n', '\n', '    bool assignedPreico = false;\n', '    /// @notice assignPreicoTokens transfers 10x tokens to pre-ICO participants\n', '    function assignPreicoTokens() public onlyOwnerAndDirector {\n', '        require(!assignedPreico);\n', '        assignedPreico = true;\n', '\n', '        _freezeTransfer(0xb424958766e736827Be5A441bA2A54bEeF54fC7C, 10 * 19514560000000000000000);\n', '        _freezeTransfer(0xF5dF9C2aAe5118b64Cda30eBb8d85EbE65A03990, 10 * 36084880000000000000000);\n', '        _freezeTransfer(0x5D8aCe48970dce4bcD7f985eDb24f5459Ef184Ec, 10 * 2492880000000000000000);\n', '        _freezeTransfer(0xcD6d5b09a34562a1ED7857B19b32bED77417655b, 10 * 1660880000000000000000);\n', '        _freezeTransfer(0x50f73AC8435E4e500e37FAb8802bcB840bf4b8B8, 10 * 94896880000000000000000);\n', '        _freezeTransfer(0x65Aa068590216cb088f4da28190d8815C31aB330, 10 * 16075280000000000000000);\n', '        _freezeTransfer(0x2046838D148196a5117C4026E21C165785bD3982, 10 * 5893680000000000000000);\n', '        _freezeTransfer(0x458e1f1050C34f5D125437fcEA0Df0aA9212EDa2, 10 * 32772040882120167215360);\n', '        _freezeTransfer(0x12B687E19Cef53b2A709e9b98C4d1973850cA53F, 10 * 70956080000000000000000);\n', '        _freezeTransfer(0x1Cf5daAB09155aaC1716Aa92937eC1c6D45720c7, 10 * 3948880000000000000000);\n', '        _freezeTransfer(0x32fAAdFdC7938E7FbC7386CcF546c5fc382ed094, 10 * 88188880000000000000000);\n', '        _freezeTransfer(0xC4eA6C0e9d95d957e75D1EB1Fbe15694CD98336c, 10 * 81948880000000000000000);\n', '        _freezeTransfer(0xB97D3d579d35a479c20D28988A459E3F35692B05, 10 * 121680000000000000000);\n', '        _freezeTransfer(0x65AD745047633C3402d4BC5382f72EA3A9eCFe47, 10 * 5196880000000000000000);\n', '        _freezeTransfer(0xd0BEF2Fb95193f429f0075e442938F5d829a33c8, 10 * 223388880000000000000000);\n', '        _freezeTransfer(0x9Fc87C3d44A6374D48b2786C46204F673b0Ae236, 10 * 28284880000000000000000);\n', '        _freezeTransfer(0x42C73b8945a82041B06428359a94403a2e882406, 10 * 13080080000000000000000);\n', '        _freezeTransfer(0xa4c9595b90BBa7B4d805e555E477200C61711F3a, 10 * 6590480000000000000000);\n', '        _freezeTransfer(0xb93b8ceD7CD86a667E12104831b4d514365F9DF8, 10 * 116358235759665569280);\n', '        _freezeTransfer(0xa94F999b3f76EB7b2Ba7B17fC37E912Fa2538a87, 10 * 10389600000000000000000);\n', '        _freezeTransfer(0xD65B9b98ca08024C3c19868d42C88A3E47D67120, 10 * 25892880000000000000000);\n', '        _freezeTransfer(0x3a978a9Cc36f1FE5Aab6D31E41c08d8380ad0ACB, 10 * 548080000000000000000);\n', '        _freezeTransfer(0xBD46d909D55d760E2f79C5838c5C42E45c0a853A, 10 * 7526480000000000000000);\n', '        _freezeTransfer(0xdD9d289d4699fDa518cf91EaFA029710e3Cbb7AA, 10 * 3324880000000000000000);\n', '        _freezeTransfer(0x8671B362902C3839ae9b4bc099fd24CdeFA026F4, 10 * 21836880000000000000000);\n', '        _freezeTransfer(0xf3C25Ee648031B28ADEBDD30c91056c2c5cd9C6b, 10 * 132284880000000000000000);\n', '        _freezeTransfer(0x1A2392fB72255eAe19BB626678125A506a93E363, 10 * 61772880000000000000000);\n', '        _freezeTransfer(0xCE2cEa425f7635557CFC00E18bc338DdE5B16C9A, 10 * 105360320000000000000000);\n', '        _freezeTransfer(0x952AD1a2891506AC442D95DA4C0F1AE70A27b677, 10 * 100252880000000000000000);\n', '        _freezeTransfer(0x5eE1fC4D251143Da96db2a5cD61507f2203bf7b7, 10 * 80492880000000000000000);\n', '    }\n', '\n', '    bool assignedTeam = false;\n', '    /// @notice assignTeamTokens assigns tokens to team members\n', '    /// @notice tokens for team have their own supply\n', '    function assignTeamTokens() public onlyOwnerAndDirector {\n', '        require(!assignedTeam);\n', '        assignedTeam = true;\n', '\n', '        _teamTransfer(0x1E21f744d91994D19f2a61041CD7cCA571185dfc, 13674375 * cstToMicro); // ArK\n', '        _teamTransfer(0x4CE4Ea57c40bBa26B7b799d5e0b4cd063B034c8A,  9920625 * cstToMicro); // Vi4\n', '        _teamTransfer(0xdCd8a8e561d23Ca710f23E7612F1D4E0dE9bde83,  1340625 * cstToMicro); // Se4\n', '        _teamTransfer(0x0dFFA8624A1f512b8dcDE807F8B0Eab68672e5D5, 13406250 * cstToMicro); // AnD\n', '        _teamTransfer(0xE091180bB0C284AA0Bd15C6888A41aba45c54AF0, 13138125 * cstToMicro); // VlM\n', '        _teamTransfer(0xcdB7A51bA9af93a7BFfe08a31E4C6c5f9068A051,  3960000 * cstToMicro); // NuT\n', '        _teamTransfer(0x57Bd10E12f789B74071d62550DaeB3765Ad83834,  3960000 * cstToMicro); // AlK\n', '        _teamTransfer(0xEE74922eaF503463a8b20aFaD83d42F28D59f45d,  3960000 * cstToMicro); // StK\n', '        _teamTransfer(0x58681a49A6f9D61eB368241a336628781afD5f87,  1320000 * cstToMicro); // DeP\n', '\n', '        _teamTransfer(0x3C4662b4677dC81f16Bf3c823A7E6CE1fF7e94d7,  80000 * cstToMicro); // YuM\n', '        _teamTransfer(0x041A1e96E0C9d3957613071c104E44a9c9d43996, 150000 * cstToMicro); // IgK\n', '        _teamTransfer(0xD63d63D2ADAF87B0Edc38218b0a2D27FD909d8B1, 100000 * cstToMicro); // SeT\n', '        _teamTransfer(0xd0d49Da78BbCBb416152dC41cc7acAb559Fb8275,  80000 * cstToMicro); // ArM\n', '        _teamTransfer(0x75FdfAc64c27f5B5f0823863Fe0f2ddc660A376F, 100000 * cstToMicro); // Lera\n', '        _teamTransfer(0xb66AFf323d97EF52192F170fF0F16D0a05Ebe56C,  60000 * cstToMicro); // SaBuh\n', '        _teamTransfer(0xec6234E34477f7A19cD3D67401003675522a4Fad,  60000 * cstToMicro); // SaV\n', '        _teamTransfer(0x1be50e8337F99983ECd4A4b15a74a5a795B73dF9,  40000 * cstToMicro); // Olga\n', '        _teamTransfer(0x4c14DB011065e72C6E839bd826d101Ec09d3C530, 833000 * cstToMicro); // VaB\n', '        _teamTransfer(0x7891C07b20fFf1918fAD43CF6fc7E3f83900f06d,  50000 * cstToMicro); // Artur\n', '        _teamTransfer(0x27996b3c1EcF2e7cbc5f31dE7Bca17EFCb398617, 150000 * cstToMicro); // EvS\n', '    }\n', '\n', '    /// @nptice kycPassed is executed by backend and tells SC\n', '    /// that particular client has passed KYC\n', '    mapping(address => bool) public kyc;\n', '    mapping(address => address) public referral;\n', '    function kycPassed(address _mem, address _ref) public onlyAdmin {\n', '        kyc[_mem] = true;\n', '        if (_ref == richardAddr || _ref == wuguAddr) {\n', '            referral[_mem] = _ref;\n', '        }\n', '    }\n', '\n', '    // mappings for implementing ERC20\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    // mapping for implementing unlock mechanic\n', '    mapping(address => uint) freezed;\n', '    mapping(address => uint) teamFreezed;\n', '\n', '    // ERC20 standard functions\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint _tokens) private {\n', '        balances[_from] = balances[_from].sub(_tokens);\n', '        balances[_to] = balances[_to].add(_tokens);\n', '        emit Transfer(_from, _to, _tokens);\n', '    }\n', '    \n', '    function transfer(address _to, uint _tokens) public returns (bool success) {\n', '        checkTransfer(msg.sender, _tokens);\n', '        _transfer(msg.sender, _to, _tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        checkTransfer(from, tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        _transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    /// @notice checkTransfer ensures that `from` can send only unlocked tokens\n', '    /// @notice this function is called for every transfer\n', '    /// We unlock PURCHASED and BONUS tokens in 5 stages:\n', '    /// after 28.09.2018 20% are unlocked\n', '    /// after 30.11.2018 40% are unlocked\n', '    /// after 31.01.2019 60% are unlocked\n', '    /// after 29.03.2019 80% are unlocked\n', '    /// after 31.05.2019 100% are unlocked\n', '    function checkTransfer(address from, uint tokens) public view {\n', '        uint newBalance = balances[from].sub(tokens);\n', '        uint total = 0;\n', '        if (now < unlockDate5) {\n', '            require(now >= unlockDate1);\n', '            uint frzdPercent = 0;\n', '            if (now < unlockDate2) {\n', '                frzdPercent = 80;\n', '            } else if (now < unlockDate3) {\n', '                frzdPercent = 60;\n', '            } else if (now < unlockDate4) {\n', '                frzdPercent = 40;\n', '            } else {\n', '                frzdPercent = 20;\n', '            }\n', '            total = freezed[from].mul(frzdPercent).div(100);\n', '            require(newBalance >= total);\n', '        }\n', '        \n', '        if (now < teamUnlock4 && teamFreezed[from] > 0) {\n', '            uint p = 0;\n', '            if (now < teamUnlock1) {\n', '                p = 100;\n', '            } else if (now < teamUnlock2) {\n', '                p = 75;\n', '            } else if (now < teamUnlock3) {\n', '                p = 50;\n', '            } else if (now < teamUnlock4) {\n', '                p = 25;\n', '            }\n', '            total = total.add(teamFreezed[from].mul(p).div(100));\n', '            require(newBalance >= total);\n', '        }\n', '    }\n', '\n', '    /// @return ($ received, ETH received, CST sold)\n', '    function ICOStatus() public view returns (uint usd, uint eth, uint cst) {\n', '        usd = presaleSold.mul(12).div(10**20) + crowdsaleSold.mul(16).div(10**20);\n', '        usd = usd.add(preicoUSD); // pre-ico tokens\n', '\n', '        return (usd, ethSold + preicoUSD.mul(10**8).div(ethRate), presaleSold + crowdsaleSold);\n', '    }\n', '\n', '    function checkICOStatus() public view returns(bool) {\n', '        uint eth;\n', '        uint cst;\n', '\n', '        (, eth, cst) = ICOStatus();\n', '\n', '        uint dollarsRecvd = eth.mul(ethRate).div(10**8);\n', '\n', '        // 26 228 800$\n', '        return dollarsRecvd >= 25228966 || (cst == presaleSupply + crowdsaleSupply) || now > crowdsaleEndTime;\n', '    }\n', '\n', '    bool icoClosed = false;\n', '    function closeICO() public onlyOwner {\n', '        require(!icoClosed);\n', '        icoClosed = checkICOStatus();\n', '    }\n', '\n', '    /// @notice by agreement, we can transfer $4.8M from bank\n', '    /// after softcap is reached.\n', '    /// @param _to wallet to send CST to\n', '    /// @param  _usd amount of dollars which is withdrawn\n', '    uint bonusTransferred = 0;\n', '    uint constant maxUSD = 4800000;\n', '    function transferBonus(address _to, uint _usd) public onlyOwner {\n', '        bonusTransferred = bonusTransferred.add(_usd);\n', '        require(bonusTransferred <= maxUSD);\n', '\n', '        uint cst = _usd.mul(100).mul(cstToMicro).div(12); // presale tariff\n', '        presaleSold = presaleSold.add(cst);\n', '        require(presaleSold <= presaleSupply);\n', '        ethSold = ethSold.add(_usd.mul(10**8).div(ethRate));\n', '\n', '        _freezeTransfer(_to, cst);\n', '    }\n', '\n', '    /// @notice extend crowdsale for 2 weeks\n', '    function prolongCrowdsale() public onlyOwnerAndDirector {\n', '        require(now < crowdsaleEndTime);\n', '        crowdsaleEndTime = crowdsaleHardEndTime;\n', '    }\n', '\n', '    // 100 000 000 Ether in dollars\n', '    uint public ethRate = 0;\n', '    uint public ethRateMax = 0;\n', '    uint public ethLastUpdate = 0;\n', '    function setETHRate(uint _rate) public onlyAdmin {\n', '        require(ethRateMax == 0 || _rate < ethRateMax);\n', '        ethRate = _rate;\n', '        ethLastUpdate = now;\n', '    }\n', '\n', '    // 100 000 000 BTC in dollars\n', '    uint public btcRate = 0;\n', '    uint public btcRateMax = 0;\n', '    uint public btcLastUpdate;\n', '    function setBTCRate(uint _rate) public onlyAdmin {\n', '        require(btcRateMax == 0 || _rate < btcRateMax);\n', '        btcRate = _rate;\n', '        btcLastUpdate = now;\n', '    }\n', '\n', '    /// @notice setMaxRate sets max rate for both BTC/ETH to soften\n', '    /// negative consequences in case our backend gots hacked.\n', '    function setMaxRate(uint ethMax, uint btcMax) public onlyOwnerAndDirector {\n', '        ethRateMax = ethMax;\n', '        btcRateMax = btcMax;\n', '    }\n', '\n', '    /// @notice _sellPresale checks CST purchases during crowdsale\n', '    function _sellPresale(uint cst) private {\n', '        require(cst >= bonusLevel0.mul(9950).div(10000));\n', '        presaleSold = presaleSold.add(cst);\n', '        require(presaleSold <= presaleSupply);\n', '    }\n', '\n', '    /// @notice _sellCrowd checks CST purchases during crowdsale\n', '    function _sellCrowd(uint cst, address _to) private {\n', '        require(cst >= crowdsaleMinUSD);\n', '\n', '        if (crowdsaleSold.add(cst) <= crowdsaleSupply) {\n', '            crowdsaleSold = crowdsaleSold.add(cst);\n', '        } else {\n', '            presaleSold = presaleSold.add(crowdsaleSold).add(cst).sub(crowdsaleSupply);\n', '            require(presaleSold <= presaleSupply);\n', '            crowdsaleSold = crowdsaleSupply;\n', '        }\n', '\n', '        if (now < crowdsaleStartTime + 3 days) {\n', '            if (whitemap[_to] >= cst) {\n', '                whitemap[_to] -= cst;\n', '                whitelistTokens -= cst;\n', '            } else {\n', '                require(crowdsaleSupply.add(presaleSupply).sub(presaleSold) >= crowdsaleSold.add(whitelistTokens));\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice addInvestorBonusInPercent is used for sending bonuses for big investors in %\n', '    function addInvestorBonusInPercent(address _to, uint8 p) public onlyOwner {\n', '        require(p > 0 && p <= 5);\n', '        uint bonus = balances[_to].mul(p).div(100);\n', '\n', '        investorGiven = investorGiven.add(bonus);\n', '        require(investorGiven <= investorSupply);\n', '\n', '        _freezeTransfer(_to, bonus);\n', '    }\n', ' \n', '    /// @notice addInvestorBonusInTokens is used for sending bonuses for big investors in tokens\n', '    function addInvestorBonusInTokens(address _to, uint tokens) public onlyOwner {\n', '        _freezeTransfer(_to, tokens);\n', '        \n', '        investorGiven = investorGiven.add(tokens);\n', '        require(investorGiven <= investorSupply);\n', '    }\n', '\n', '    function () payable public {\n', '        purchaseWithETH(msg.sender);\n', '    }\n', '\n', '    /// @notice _freezeTranfer perform actual tokens transfer which\n', '    /// will be freezed (see also checkTransfer() )\n', '    function _freezeTransfer(address _to, uint cst) private {\n', '        _transfer(owner, _to, cst);\n', '        freezed[_to] = freezed[_to].add(cst);\n', '    }\n', '\n', '    /// @notice _freezeTranfer perform actual tokens transfer which\n', '    /// will be freezed (see also checkTransfer() )\n', '    function _teamTransfer(address _to, uint cst) private {\n', '        _transfer(owner, _to, cst);\n', '        teamFreezed[_to] = teamFreezed[_to].add(cst);\n', '    }\n', '\n', '    address public constant wuguAddr = 0x096ad02a48338CB9eA967a96062842891D195Af5;\n', '    address public constant richardAddr = 0x411fB4D77EDc659e9838C21be72f55CC304C0cB8;\n', '    mapping(address => address[]) promoterClients;\n', '    mapping(address => mapping(address => uint)) promoterBonus;\n', '\n', '    /// @notice withdrawPromoter transfers back to promoter \n', '    /// all bonuses accumulated to current moment\n', '    function withdrawPromoter() public {\n', '        address _to = msg.sender;\n', '        require(_to == wuguAddr || _to == richardAddr);\n', '\n', '        uint usd;\n', '        (usd,,) = ICOStatus();\n', '\n', '        // USD received - 5% must be more than softcap\n', '        require(usd.mul(95).div(100) >= softcapUSD);\n', '\n', '        uint bonus = 0;\n', '        address[] memory clients = promoterClients[_to];\n', '        for(uint i = 0; i < clients.length; i++) {\n', '            if (kyc[clients[i]]) {\n', '                uint num = promoterBonus[_to][clients[i]];\n', '                delete promoterBonus[_to][clients[i]];\n', '                bonus += num;\n', '            }\n', '        }\n', '        \n', '        _to.transfer(bonus);\n', '    }\n', '\n', '    /// @notice cashBack will be used in case of failed ICO\n', '    /// All partitipants can receive their ETH back\n', '    function cashBack(address _to) public {\n', '        uint usd;\n', '        (usd,,) = ICOStatus();\n', '\n', '        // ICO fails if crowd-sale is ended and we have not yet reached soft-cap\n', '        require(now > crowdsaleEndTime && usd < softcapUSD);\n', '        require(ethSent[_to] > 0);\n', '\n', '        delete ethSent[_to];\n', '\n', '        _to.transfer(ethSent[_to]);\n', '    }\n', '\n', '    /// @notice stores amount of ETH received by SC\n', '    mapping(address => uint) ethSent;\n', '\n', '    function purchaseWithETH(address _to) payable public {\n', '        purchaseWithPromoter(_to, referral[msg.sender]);\n', '    }\n', '\n', '    /// @notice purchases tokens, which a send to `_to` with 5% returned to `_ref`\n', '    /// @notice 5% return must work only on crowdsale\n', '    function purchaseWithPromoter(address _to, address _ref) payable public {\n', '        require(now >= presaleStartTime && now <= crowdsaleEndTime);\n', '\n', '        require(!icoClosed);\n', '    \n', '        uint _wei = msg.value;\n', '        uint cst;\n', '\n', '        ethSent[msg.sender] = ethSent[msg.sender].add(_wei);\n', '        ethSold = ethSold.add(_wei);\n', '\n', '        // accept payment on presale only if it is more than 9997$\n', '        // actual check is performed in _sellPresale\n', '        if (now < crowdsaleStartTime || approvedInvestors[msg.sender]) {\n', '            require(kyc[msg.sender]);\n', '            cst = _wei.mul(ethRate).div(12000000); // 1 CST = 0.12 $ on presale\n', '\n', '            require(now < crowdsaleStartTime || cst >= bonusLevel100);\n', '\n', '            _sellPresale(cst);\n', '\n', '            /// we have only 2 recognized promoters\n', '            if (_ref == wuguAddr || _ref == richardAddr) {\n', '                promoterClients[_ref].push(_to);\n', '                promoterBonus[_ref][_to] = _wei.mul(5).div(100);\n', '            }\n', '        } else {\n', '            cst = _wei.mul(ethRate).div(16000000); // 1 CST = 0.16 $ on crowd-sale\n', '            _sellCrowd(cst, _to);\n', '        }\n', '\n', '        _freezeTransfer(_to, cst);\n', '    }\n', '\n', '    /// @notice purchaseWithBTC is called from backend, where we convert\n', '    /// BTC to ETH, and then assign tokens to purchaser, using BTC / $ exchange rate.\n', '    function purchaseWithBTC(address _to, uint _satoshi, uint _wei) public onlyAdmin {\n', '        require(now >= presaleStartTime && now <= crowdsaleEndTime);\n', '\n', '        require(!icoClosed);\n', '\n', '        ethSold = ethSold.add(_wei);\n', '\n', '        uint cst;\n', '        // accept payment on presale only if it is more than 9997$\n', '        // actual check is performed in _sellPresale\n', '        if (now < crowdsaleStartTime || approvedInvestors[msg.sender]) {\n', '            require(kyc[msg.sender]);\n', '            cst = _satoshi.mul(btcRate.mul(10000)).div(12); // 1 CST = 0.12 $ on presale\n', '\n', '            require(now < crowdsaleStartTime || cst >= bonusLevel100);\n', '\n', '            _sellPresale(cst);\n', '        } else {\n', '            cst = _satoshi.mul(btcRate.mul(10000)).div(16); // 1 CST = 0.16 $ on presale\n', '            _sellCrowd(cst, _to);\n', '        }\n', '\n', '        _freezeTransfer(_to, cst);\n', '    }\n', '\n', '    /// @notice withdrawFunds is called to send team bonuses after\n', '    /// then end of the ICO\n', '    bool withdrawCalled = false;\n', '    function withdrawFunds() public onlyOwner {\n', '        require(icoClosed && now >= teamETHUnlock1);\n', '\n', '        require(!withdrawCalled);\n', '        withdrawCalled = true;\n', '\n', '        uint eth;\n', '        (,eth,) = ICOStatus();\n', '\n', '        // pre-ico tokens are not in ethSold\n', '        uint minus = bonusTransferred.mul(10**8).div(ethRate);\n', '        uint team = ethSold.sub(minus);\n', '\n', '        team = team.mul(15).div(100);\n', '\n', '        uint ownerETH = 0;\n', '        uint teamETH = 0;\n', '        if (address(this).balance >= team) {\n', '            teamETH = team;\n', '            ownerETH = address(this).balance.sub(teamETH);\n', '        } else {\n', '            teamETH = address(this).balance;\n', '        }\n', '\n', '        teamETH1 = teamETH.div(3);\n', '        teamETH2 = teamETH.div(3);\n', '        teamETH3 = teamETH.sub(teamETH1).sub(teamETH2);\n', '\n', '        // TODO multisig\n', '        address(0x741A26104530998F625D15cbb9D58b01811d2CA7).transfer(ownerETH);\n', '    }\n', '\n', '    uint teamETH1 = 0;\n', '    uint teamETH2 = 0;\n', '    uint teamETH3 = 0;\n', '    function withdrawTeam() public {\n', '        require(now >= teamETHUnlock1);\n', '\n', '        uint amount = 0;\n', '        if (now < teamETHUnlock2) {\n', '            amount = teamETH1;\n', '            teamETH1 = 0;\n', '        } else if (now < teamETHUnlock3) {\n', '            amount = teamETH1 + teamETH2;\n', '            teamETH1 = 0;\n', '            teamETH2 = 0;\n', '        } else {\n', '            amount = teamETH1 + teamETH2 + teamETH3;\n', '            teamETH1 = 0;\n', '            teamETH2 = 0;\n', '            teamETH3 = 0;\n', '        }\n', '\n', '        address(0xcdB7A51bA9af93a7BFfe08a31E4C6c5f9068A051).transfer(amount.mul(6).div(100)); // NuT\n', '        address(0x57Bd10E12f789B74071d62550DaeB3765Ad83834).transfer(amount.mul(6).div(100)); // AlK\n', '        address(0xEE74922eaF503463a8b20aFaD83d42F28D59f45d).transfer(amount.mul(6).div(100)); // StK\n', '        address(0x58681a49A6f9D61eB368241a336628781afD5f87).transfer(amount.mul(2).div(100)); // DeP\n', '        address(0x4c14DB011065e72C6E839bd826d101Ec09d3C530).transfer(amount.mul(2).div(100)); // VaB\n', '\n', '        amount = amount.mul(78).div(100);\n', '\n', '        address(0x1E21f744d91994D19f2a61041CD7cCA571185dfc).transfer(amount.mul(uint(255).mul(100).div(96)).div(1000)); // ArK\n', '        address(0x4CE4Ea57c40bBa26B7b799d5e0b4cd063B034c8A).transfer(amount.mul(uint(185).mul(100).div(96)).div(1000)); // ViT\n', '        address(0xdCd8a8e561d23Ca710f23E7612F1D4E0dE9bde83).transfer(amount.mul(uint(25).mul(100).div(96)).div(1000));  // SeT\n', '        address(0x0dFFA8624A1f512b8dcDE807F8B0Eab68672e5D5).transfer(amount.mul(uint(250).mul(100).div(96)).div(1000)); // AnD\n', '        address(0xE091180bB0C284AA0Bd15C6888A41aba45c54AF0).transfer(amount.mul(uint(245).mul(100).div(96)).div(1000)); // VlM\n', '    }\n', '\n', '    /// @notice doAirdrop is called when we launch airdrop.\n', '    /// @notice airdrop tokens has their own supply.\n', '    uint dropped = 0;\n', '    function doAirdrop(address[] members, uint[] tokens) public onlyOwnerAndDirector {\n', '        require(members.length == tokens.length);\n', '    \n', '        for(uint i = 0; i < members.length; i++) {\n', '            _freezeTransfer(members[i], tokens[i]);\n', '            dropped = dropped.add(tokens[i]);\n', '        }\n', '        require(dropped <= bountySupply);\n', '    }\n', '\n', '    mapping(address => uint) public whitemap;\n', '    uint public whitelistTokens = 0;\n', '    /// @notice addWhitelistMember is used to whitelist participant.\n', '    /// This means, that for the first 3 days of crowd-sale `_tokens` CST \n', '    /// will be reserved for him.\n', '    function addWhitelistMember(address[] _mem, uint[] _tokens) public onlyAdmin {\n', '        require(_mem.length == _tokens.length);\n', '        for(uint i = 0; i < _mem.length; i++) {\n', '            whitelistTokens = whitelistTokens.sub(whitemap[_mem[i]]).add(_tokens[i]);\n', '            whitemap[_mem[i]] = _tokens[i];\n', '        }\n', '    }\n', '\n', '    uint public adviserSold = 0;\n', '    /// @notice transferAdviser is called to send tokens to advisers.\n', '    /// @notice adviser tokens have their own supply\n', '    function transferAdviser(address[] _adv, uint[] _tokens) public onlyOwnerAndDirector {\n', '        require(_adv.length == _tokens.length);\n', '        for (uint i = 0; i < _adv.length; i++) {\n', '            adviserSold = adviserSold.add(_tokens[i]);\n', '            _freezeTransfer(_adv[i], _tokens[i]);\n', '        }\n', '        require(adviserSold <= adviserSupply);\n', '    }\n', '\n', '    mapping(address => bool) approvedInvestors;\n', '    function approveInvestor(address _addr) public onlyOwner {\n', '        approvedInvestors[_addr] = true;\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract CasperToken is ERC20Interface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    string public constant name = "Csper Token";\n', '    string public constant symbol = "CST";\n', '    uint8 public constant decimals = 18;\n', '\n', '    uint constant public cstToMicro = uint(10) ** decimals;\n', '\n', '    // This constants reflects CST token distribution\n', '    uint constant public _totalSupply    = 440000000 * cstToMicro;\n', '    uint constant public preICOSupply    = 13000000 * cstToMicro;\n', '    uint constant public presaleSupply   = 183574716 * cstToMicro;\n', '    uint constant public crowdsaleSupply = 19750000 * cstToMicro;\n', '    uint constant public communitySupply = 66000000 * cstToMicro;\n', '    uint constant public systemSupply    = 35210341 * cstToMicro;\n', '    uint constant public investorSupply  = 36714943 * cstToMicro;\n', '    uint constant public teamSupply      = 66000000 * cstToMicro;\n', '    uint constant public adviserSupply   = 7000000 * cstToMicro;\n', '    uint constant public bountySupply    = 8800000 * cstToMicro;\n', '    uint constant public referralSupply  = 3950000 * cstToMicro;\n', '\n', '    // This variables accumulate amount of sold CST during\n', '    // presale, crowdsale, or given to investors as bonus.\n', '    uint public presaleSold = 0;\n', '    uint public crowdsaleSold = 0;\n', '    uint public investorGiven = 0;\n', '\n', '    // Amount of ETH received during ICO\n', '    uint public ethSold = 0;\n', '\n', '    uint constant public softcapUSD = 4500000;\n', '    uint constant public preicoUSD  = 1040000;\n', '\n', '    // Presale lower bound in dollars.\n', '    uint constant public crowdsaleMinUSD = cstToMicro * 10 * 100 / 12;\n', '    uint constant public bonusLevel0 = cstToMicro * 10000 * 100 / 12; // 10000$\n', '    uint constant public bonusLevel100 = cstToMicro * 100000 * 100 / 12; // 100000$\n', '\n', '    // Tokens are unlocked in 5 stages, by 20% (see doc to checkTransfer)\n', '    // All dates are stored as timestamps.\n', '    uint constant public unlockDate1 = 1538179199; // 28.09.2018 23:59:59\n', '    uint constant public unlockDate2 = 1543622399; // 30.11.2018 23:59:59\n', '    uint constant public unlockDate3 = 1548979199; // 31.01.2019 23:59:59\n', '    uint constant public unlockDate4 = 1553903999; // 29.03.2019 23:59:59\n', '    uint constant public unlockDate5 = 1559347199; // 31.05.2019 23:59:59\n', '\n', '    uint constant public teamUnlock1 = 1549065600; // 2.02.2019 \n', '    uint constant public teamUnlock2 = 1564704000; // 2.08.2019\n', '    uint constant public teamUnlock3 = 1580601600; // 2.02.2020\n', '    uint constant public teamUnlock4 = 1596326400; // 2.08.2020\n', '\n', '    uint constant public teamETHUnlock1 = 1535846400; // 2.09.2018\n', '    uint constant public teamETHUnlock2 = 1538438400; // 2.10.2018\n', '    uint constant public teamETHUnlock3 = 1541116800; // 2.11.2018\n', '\n', '    //https://casperproject.atlassian.net/wiki/spaces/PROD/pages/277839878/Smart+contract+ICO\n', '    // Presale 10.06.2018 - 22.07.2018\n', '    // Crowd-sale 23.07.2018 - 2.08.2018 (16.08.2018)\n', '    uint constant public presaleStartTime     = 1528588800;\n', '    uint constant public crowdsaleStartTime   = 1532304000;\n', '    uint          public crowdsaleEndTime     = 1533168000;\n', '    uint constant public crowdsaleHardEndTime = 1534377600;\n', '    //address constant CsperWallet = 0x6A5e633065475393211aB623286200910F465d02;\n', '    constructor() public {\n', '        admin = owner;\n', '        balances[owner] = _totalSupply;\n', '        emit Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerAndDirector {\n', '        require(msg.sender == owner || msg.sender == director);\n', '        _;\n', '    }\n', '\n', '    address admin;\n', '    function setAdmin(address _newAdmin) public onlyOwnerAndDirector {\n', '        admin = _newAdmin;\n', '    }\n', '\n', '    address director;\n', '    function setDirector(address _newDirector) public onlyOwner {\n', '        director = _newDirector;\n', '    }\n', '\n', '    bool assignedPreico = false;\n', '    /// @notice assignPreicoTokens transfers 10x tokens to pre-ICO participants\n', '    function assignPreicoTokens() public onlyOwnerAndDirector {\n', '        require(!assignedPreico);\n', '        assignedPreico = true;\n', '\n', '        _freezeTransfer(0xb424958766e736827Be5A441bA2A54bEeF54fC7C, 10 * 19514560000000000000000);\n', '        _freezeTransfer(0xF5dF9C2aAe5118b64Cda30eBb8d85EbE65A03990, 10 * 36084880000000000000000);\n', '        _freezeTransfer(0x5D8aCe48970dce4bcD7f985eDb24f5459Ef184Ec, 10 * 2492880000000000000000);\n', '        _freezeTransfer(0xcD6d5b09a34562a1ED7857B19b32bED77417655b, 10 * 1660880000000000000000);\n', '        _freezeTransfer(0x50f73AC8435E4e500e37FAb8802bcB840bf4b8B8, 10 * 94896880000000000000000);\n', '        _freezeTransfer(0x65Aa068590216cb088f4da28190d8815C31aB330, 10 * 16075280000000000000000);\n', '        _freezeTransfer(0x2046838D148196a5117C4026E21C165785bD3982, 10 * 5893680000000000000000);\n', '        _freezeTransfer(0x458e1f1050C34f5D125437fcEA0Df0aA9212EDa2, 10 * 32772040882120167215360);\n', '        _freezeTransfer(0x12B687E19Cef53b2A709e9b98C4d1973850cA53F, 10 * 70956080000000000000000);\n', '        _freezeTransfer(0x1Cf5daAB09155aaC1716Aa92937eC1c6D45720c7, 10 * 3948880000000000000000);\n', '        _freezeTransfer(0x32fAAdFdC7938E7FbC7386CcF546c5fc382ed094, 10 * 88188880000000000000000);\n', '        _freezeTransfer(0xC4eA6C0e9d95d957e75D1EB1Fbe15694CD98336c, 10 * 81948880000000000000000);\n', '        _freezeTransfer(0xB97D3d579d35a479c20D28988A459E3F35692B05, 10 * 121680000000000000000);\n', '        _freezeTransfer(0x65AD745047633C3402d4BC5382f72EA3A9eCFe47, 10 * 5196880000000000000000);\n', '        _freezeTransfer(0xd0BEF2Fb95193f429f0075e442938F5d829a33c8, 10 * 223388880000000000000000);\n', '        _freezeTransfer(0x9Fc87C3d44A6374D48b2786C46204F673b0Ae236, 10 * 28284880000000000000000);\n', '        _freezeTransfer(0x42C73b8945a82041B06428359a94403a2e882406, 10 * 13080080000000000000000);\n', '        _freezeTransfer(0xa4c9595b90BBa7B4d805e555E477200C61711F3a, 10 * 6590480000000000000000);\n', '        _freezeTransfer(0xb93b8ceD7CD86a667E12104831b4d514365F9DF8, 10 * 116358235759665569280);\n', '        _freezeTransfer(0xa94F999b3f76EB7b2Ba7B17fC37E912Fa2538a87, 10 * 10389600000000000000000);\n', '        _freezeTransfer(0xD65B9b98ca08024C3c19868d42C88A3E47D67120, 10 * 25892880000000000000000);\n', '        _freezeTransfer(0x3a978a9Cc36f1FE5Aab6D31E41c08d8380ad0ACB, 10 * 548080000000000000000);\n', '        _freezeTransfer(0xBD46d909D55d760E2f79C5838c5C42E45c0a853A, 10 * 7526480000000000000000);\n', '        _freezeTransfer(0xdD9d289d4699fDa518cf91EaFA029710e3Cbb7AA, 10 * 3324880000000000000000);\n', '        _freezeTransfer(0x8671B362902C3839ae9b4bc099fd24CdeFA026F4, 10 * 21836880000000000000000);\n', '        _freezeTransfer(0xf3C25Ee648031B28ADEBDD30c91056c2c5cd9C6b, 10 * 132284880000000000000000);\n', '        _freezeTransfer(0x1A2392fB72255eAe19BB626678125A506a93E363, 10 * 61772880000000000000000);\n', '        _freezeTransfer(0xCE2cEa425f7635557CFC00E18bc338DdE5B16C9A, 10 * 105360320000000000000000);\n', '        _freezeTransfer(0x952AD1a2891506AC442D95DA4C0F1AE70A27b677, 10 * 100252880000000000000000);\n', '        _freezeTransfer(0x5eE1fC4D251143Da96db2a5cD61507f2203bf7b7, 10 * 80492880000000000000000);\n', '    }\n', '\n', '    bool assignedTeam = false;\n', '    /// @notice assignTeamTokens assigns tokens to team members\n', '    /// @notice tokens for team have their own supply\n', '    function assignTeamTokens() public onlyOwnerAndDirector {\n', '        require(!assignedTeam);\n', '        assignedTeam = true;\n', '\n', '        _teamTransfer(0x1E21f744d91994D19f2a61041CD7cCA571185dfc, 13674375 * cstToMicro); // ArK\n', '        _teamTransfer(0x4CE4Ea57c40bBa26B7b799d5e0b4cd063B034c8A,  9920625 * cstToMicro); // Vi4\n', '        _teamTransfer(0xdCd8a8e561d23Ca710f23E7612F1D4E0dE9bde83,  1340625 * cstToMicro); // Se4\n', '        _teamTransfer(0x0dFFA8624A1f512b8dcDE807F8B0Eab68672e5D5, 13406250 * cstToMicro); // AnD\n', '        _teamTransfer(0xE091180bB0C284AA0Bd15C6888A41aba45c54AF0, 13138125 * cstToMicro); // VlM\n', '        _teamTransfer(0xcdB7A51bA9af93a7BFfe08a31E4C6c5f9068A051,  3960000 * cstToMicro); // NuT\n', '        _teamTransfer(0x57Bd10E12f789B74071d62550DaeB3765Ad83834,  3960000 * cstToMicro); // AlK\n', '        _teamTransfer(0xEE74922eaF503463a8b20aFaD83d42F28D59f45d,  3960000 * cstToMicro); // StK\n', '        _teamTransfer(0x58681a49A6f9D61eB368241a336628781afD5f87,  1320000 * cstToMicro); // DeP\n', '\n', '        _teamTransfer(0x3C4662b4677dC81f16Bf3c823A7E6CE1fF7e94d7,  80000 * cstToMicro); // YuM\n', '        _teamTransfer(0x041A1e96E0C9d3957613071c104E44a9c9d43996, 150000 * cstToMicro); // IgK\n', '        _teamTransfer(0xD63d63D2ADAF87B0Edc38218b0a2D27FD909d8B1, 100000 * cstToMicro); // SeT\n', '        _teamTransfer(0xd0d49Da78BbCBb416152dC41cc7acAb559Fb8275,  80000 * cstToMicro); // ArM\n', '        _teamTransfer(0x75FdfAc64c27f5B5f0823863Fe0f2ddc660A376F, 100000 * cstToMicro); // Lera\n', '        _teamTransfer(0xb66AFf323d97EF52192F170fF0F16D0a05Ebe56C,  60000 * cstToMicro); // SaBuh\n', '        _teamTransfer(0xec6234E34477f7A19cD3D67401003675522a4Fad,  60000 * cstToMicro); // SaV\n', '        _teamTransfer(0x1be50e8337F99983ECd4A4b15a74a5a795B73dF9,  40000 * cstToMicro); // Olga\n', '        _teamTransfer(0x4c14DB011065e72C6E839bd826d101Ec09d3C530, 833000 * cstToMicro); // VaB\n', '        _teamTransfer(0x7891C07b20fFf1918fAD43CF6fc7E3f83900f06d,  50000 * cstToMicro); // Artur\n', '        _teamTransfer(0x27996b3c1EcF2e7cbc5f31dE7Bca17EFCb398617, 150000 * cstToMicro); // EvS\n', '    }\n', '\n', '    /// @nptice kycPassed is executed by backend and tells SC\n', '    /// that particular client has passed KYC\n', '    mapping(address => bool) public kyc;\n', '    mapping(address => address) public referral;\n', '    function kycPassed(address _mem, address _ref) public onlyAdmin {\n', '        kyc[_mem] = true;\n', '        if (_ref == richardAddr || _ref == wuguAddr) {\n', '            referral[_mem] = _ref;\n', '        }\n', '    }\n', '\n', '    // mappings for implementing ERC20\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    // mapping for implementing unlock mechanic\n', '    mapping(address => uint) freezed;\n', '    mapping(address => uint) teamFreezed;\n', '\n', '    // ERC20 standard functions\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint _tokens) private {\n', '        balances[_from] = balances[_from].sub(_tokens);\n', '        balances[_to] = balances[_to].add(_tokens);\n', '        emit Transfer(_from, _to, _tokens);\n', '    }\n', '    \n', '    function transfer(address _to, uint _tokens) public returns (bool success) {\n', '        checkTransfer(msg.sender, _tokens);\n', '        _transfer(msg.sender, _to, _tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        checkTransfer(from, tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        _transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    /// @notice checkTransfer ensures that `from` can send only unlocked tokens\n', '    /// @notice this function is called for every transfer\n', '    /// We unlock PURCHASED and BONUS tokens in 5 stages:\n', '    /// after 28.09.2018 20% are unlocked\n', '    /// after 30.11.2018 40% are unlocked\n', '    /// after 31.01.2019 60% are unlocked\n', '    /// after 29.03.2019 80% are unlocked\n', '    /// after 31.05.2019 100% are unlocked\n', '    function checkTransfer(address from, uint tokens) public view {\n', '        uint newBalance = balances[from].sub(tokens);\n', '        uint total = 0;\n', '        if (now < unlockDate5) {\n', '            require(now >= unlockDate1);\n', '            uint frzdPercent = 0;\n', '            if (now < unlockDate2) {\n', '                frzdPercent = 80;\n', '            } else if (now < unlockDate3) {\n', '                frzdPercent = 60;\n', '            } else if (now < unlockDate4) {\n', '                frzdPercent = 40;\n', '            } else {\n', '                frzdPercent = 20;\n', '            }\n', '            total = freezed[from].mul(frzdPercent).div(100);\n', '            require(newBalance >= total);\n', '        }\n', '        \n', '        if (now < teamUnlock4 && teamFreezed[from] > 0) {\n', '            uint p = 0;\n', '            if (now < teamUnlock1) {\n', '                p = 100;\n', '            } else if (now < teamUnlock2) {\n', '                p = 75;\n', '            } else if (now < teamUnlock3) {\n', '                p = 50;\n', '            } else if (now < teamUnlock4) {\n', '                p = 25;\n', '            }\n', '            total = total.add(teamFreezed[from].mul(p).div(100));\n', '            require(newBalance >= total);\n', '        }\n', '    }\n', '\n', '    /// @return ($ received, ETH received, CST sold)\n', '    function ICOStatus() public view returns (uint usd, uint eth, uint cst) {\n', '        usd = presaleSold.mul(12).div(10**20) + crowdsaleSold.mul(16).div(10**20);\n', '        usd = usd.add(preicoUSD); // pre-ico tokens\n', '\n', '        return (usd, ethSold + preicoUSD.mul(10**8).div(ethRate), presaleSold + crowdsaleSold);\n', '    }\n', '\n', '    function checkICOStatus() public view returns(bool) {\n', '        uint eth;\n', '        uint cst;\n', '\n', '        (, eth, cst) = ICOStatus();\n', '\n', '        uint dollarsRecvd = eth.mul(ethRate).div(10**8);\n', '\n', '        // 26 228 800$\n', '        return dollarsRecvd >= 25228966 || (cst == presaleSupply + crowdsaleSupply) || now > crowdsaleEndTime;\n', '    }\n', '\n', '    bool icoClosed = false;\n', '    function closeICO() public onlyOwner {\n', '        require(!icoClosed);\n', '        icoClosed = checkICOStatus();\n', '    }\n', '\n', '    /// @notice by agreement, we can transfer $4.8M from bank\n', '    /// after softcap is reached.\n', '    /// @param _to wallet to send CST to\n', '    /// @param  _usd amount of dollars which is withdrawn\n', '    uint bonusTransferred = 0;\n', '    uint constant maxUSD = 4800000;\n', '    function transferBonus(address _to, uint _usd) public onlyOwner {\n', '        bonusTransferred = bonusTransferred.add(_usd);\n', '        require(bonusTransferred <= maxUSD);\n', '\n', '        uint cst = _usd.mul(100).mul(cstToMicro).div(12); // presale tariff\n', '        presaleSold = presaleSold.add(cst);\n', '        require(presaleSold <= presaleSupply);\n', '        ethSold = ethSold.add(_usd.mul(10**8).div(ethRate));\n', '\n', '        _freezeTransfer(_to, cst);\n', '    }\n', '\n', '    /// @notice extend crowdsale for 2 weeks\n', '    function prolongCrowdsale() public onlyOwnerAndDirector {\n', '        require(now < crowdsaleEndTime);\n', '        crowdsaleEndTime = crowdsaleHardEndTime;\n', '    }\n', '\n', '    // 100 000 000 Ether in dollars\n', '    uint public ethRate = 0;\n', '    uint public ethRateMax = 0;\n', '    uint public ethLastUpdate = 0;\n', '    function setETHRate(uint _rate) public onlyAdmin {\n', '        require(ethRateMax == 0 || _rate < ethRateMax);\n', '        ethRate = _rate;\n', '        ethLastUpdate = now;\n', '    }\n', '\n', '    // 100 000 000 BTC in dollars\n', '    uint public btcRate = 0;\n', '    uint public btcRateMax = 0;\n', '    uint public btcLastUpdate;\n', '    function setBTCRate(uint _rate) public onlyAdmin {\n', '        require(btcRateMax == 0 || _rate < btcRateMax);\n', '        btcRate = _rate;\n', '        btcLastUpdate = now;\n', '    }\n', '\n', '    /// @notice setMaxRate sets max rate for both BTC/ETH to soften\n', '    /// negative consequences in case our backend gots hacked.\n', '    function setMaxRate(uint ethMax, uint btcMax) public onlyOwnerAndDirector {\n', '        ethRateMax = ethMax;\n', '        btcRateMax = btcMax;\n', '    }\n', '\n', '    /// @notice _sellPresale checks CST purchases during crowdsale\n', '    function _sellPresale(uint cst) private {\n', '        require(cst >= bonusLevel0.mul(9950).div(10000));\n', '        presaleSold = presaleSold.add(cst);\n', '        require(presaleSold <= presaleSupply);\n', '    }\n', '\n', '    /// @notice _sellCrowd checks CST purchases during crowdsale\n', '    function _sellCrowd(uint cst, address _to) private {\n', '        require(cst >= crowdsaleMinUSD);\n', '\n', '        if (crowdsaleSold.add(cst) <= crowdsaleSupply) {\n', '            crowdsaleSold = crowdsaleSold.add(cst);\n', '        } else {\n', '            presaleSold = presaleSold.add(crowdsaleSold).add(cst).sub(crowdsaleSupply);\n', '            require(presaleSold <= presaleSupply);\n', '            crowdsaleSold = crowdsaleSupply;\n', '        }\n', '\n', '        if (now < crowdsaleStartTime + 3 days) {\n', '            if (whitemap[_to] >= cst) {\n', '                whitemap[_to] -= cst;\n', '                whitelistTokens -= cst;\n', '            } else {\n', '                require(crowdsaleSupply.add(presaleSupply).sub(presaleSold) >= crowdsaleSold.add(whitelistTokens));\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice addInvestorBonusInPercent is used for sending bonuses for big investors in %\n', '    function addInvestorBonusInPercent(address _to, uint8 p) public onlyOwner {\n', '        require(p > 0 && p <= 5);\n', '        uint bonus = balances[_to].mul(p).div(100);\n', '\n', '        investorGiven = investorGiven.add(bonus);\n', '        require(investorGiven <= investorSupply);\n', '\n', '        _freezeTransfer(_to, bonus);\n', '    }\n', ' \n', '    /// @notice addInvestorBonusInTokens is used for sending bonuses for big investors in tokens\n', '    function addInvestorBonusInTokens(address _to, uint tokens) public onlyOwner {\n', '        _freezeTransfer(_to, tokens);\n', '        \n', '        investorGiven = investorGiven.add(tokens);\n', '        require(investorGiven <= investorSupply);\n', '    }\n', '\n', '    function () payable public {\n', '        purchaseWithETH(msg.sender);\n', '    }\n', '\n', '    /// @notice _freezeTranfer perform actual tokens transfer which\n', '    /// will be freezed (see also checkTransfer() )\n', '    function _freezeTransfer(address _to, uint cst) private {\n', '        _transfer(owner, _to, cst);\n', '        freezed[_to] = freezed[_to].add(cst);\n', '    }\n', '\n', '    /// @notice _freezeTranfer perform actual tokens transfer which\n', '    /// will be freezed (see also checkTransfer() )\n', '    function _teamTransfer(address _to, uint cst) private {\n', '        _transfer(owner, _to, cst);\n', '        teamFreezed[_to] = teamFreezed[_to].add(cst);\n', '    }\n', '\n', '    address public constant wuguAddr = 0x096ad02a48338CB9eA967a96062842891D195Af5;\n', '    address public constant richardAddr = 0x411fB4D77EDc659e9838C21be72f55CC304C0cB8;\n', '    mapping(address => address[]) promoterClients;\n', '    mapping(address => mapping(address => uint)) promoterBonus;\n', '\n', '    /// @notice withdrawPromoter transfers back to promoter \n', '    /// all bonuses accumulated to current moment\n', '    function withdrawPromoter() public {\n', '        address _to = msg.sender;\n', '        require(_to == wuguAddr || _to == richardAddr);\n', '\n', '        uint usd;\n', '        (usd,,) = ICOStatus();\n', '\n', '        // USD received - 5% must be more than softcap\n', '        require(usd.mul(95).div(100) >= softcapUSD);\n', '\n', '        uint bonus = 0;\n', '        address[] memory clients = promoterClients[_to];\n', '        for(uint i = 0; i < clients.length; i++) {\n', '            if (kyc[clients[i]]) {\n', '                uint num = promoterBonus[_to][clients[i]];\n', '                delete promoterBonus[_to][clients[i]];\n', '                bonus += num;\n', '            }\n', '        }\n', '        \n', '        _to.transfer(bonus);\n', '    }\n', '\n', '    /// @notice cashBack will be used in case of failed ICO\n', '    /// All partitipants can receive their ETH back\n', '    function cashBack(address _to) public {\n', '        uint usd;\n', '        (usd,,) = ICOStatus();\n', '\n', '        // ICO fails if crowd-sale is ended and we have not yet reached soft-cap\n', '        require(now > crowdsaleEndTime && usd < softcapUSD);\n', '        require(ethSent[_to] > 0);\n', '\n', '        delete ethSent[_to];\n', '\n', '        _to.transfer(ethSent[_to]);\n', '    }\n', '\n', '    /// @notice stores amount of ETH received by SC\n', '    mapping(address => uint) ethSent;\n', '\n', '    function purchaseWithETH(address _to) payable public {\n', '        purchaseWithPromoter(_to, referral[msg.sender]);\n', '    }\n', '\n', '    /// @notice purchases tokens, which a send to `_to` with 5% returned to `_ref`\n', '    /// @notice 5% return must work only on crowdsale\n', '    function purchaseWithPromoter(address _to, address _ref) payable public {\n', '        require(now >= presaleStartTime && now <= crowdsaleEndTime);\n', '\n', '        require(!icoClosed);\n', '    \n', '        uint _wei = msg.value;\n', '        uint cst;\n', '\n', '        ethSent[msg.sender] = ethSent[msg.sender].add(_wei);\n', '        ethSold = ethSold.add(_wei);\n', '\n', '        // accept payment on presale only if it is more than 9997$\n', '        // actual check is performed in _sellPresale\n', '        if (now < crowdsaleStartTime || approvedInvestors[msg.sender]) {\n', '            require(kyc[msg.sender]);\n', '            cst = _wei.mul(ethRate).div(12000000); // 1 CST = 0.12 $ on presale\n', '\n', '            require(now < crowdsaleStartTime || cst >= bonusLevel100);\n', '\n', '            _sellPresale(cst);\n', '\n', '            /// we have only 2 recognized promoters\n', '            if (_ref == wuguAddr || _ref == richardAddr) {\n', '                promoterClients[_ref].push(_to);\n', '                promoterBonus[_ref][_to] = _wei.mul(5).div(100);\n', '            }\n', '        } else {\n', '            cst = _wei.mul(ethRate).div(16000000); // 1 CST = 0.16 $ on crowd-sale\n', '            _sellCrowd(cst, _to);\n', '        }\n', '\n', '        _freezeTransfer(_to, cst);\n', '    }\n', '\n', '    /// @notice purchaseWithBTC is called from backend, where we convert\n', '    /// BTC to ETH, and then assign tokens to purchaser, using BTC / $ exchange rate.\n', '    function purchaseWithBTC(address _to, uint _satoshi, uint _wei) public onlyAdmin {\n', '        require(now >= presaleStartTime && now <= crowdsaleEndTime);\n', '\n', '        require(!icoClosed);\n', '\n', '        ethSold = ethSold.add(_wei);\n', '\n', '        uint cst;\n', '        // accept payment on presale only if it is more than 9997$\n', '        // actual check is performed in _sellPresale\n', '        if (now < crowdsaleStartTime || approvedInvestors[msg.sender]) {\n', '            require(kyc[msg.sender]);\n', '            cst = _satoshi.mul(btcRate.mul(10000)).div(12); // 1 CST = 0.12 $ on presale\n', '\n', '            require(now < crowdsaleStartTime || cst >= bonusLevel100);\n', '\n', '            _sellPresale(cst);\n', '        } else {\n', '            cst = _satoshi.mul(btcRate.mul(10000)).div(16); // 1 CST = 0.16 $ on presale\n', '            _sellCrowd(cst, _to);\n', '        }\n', '\n', '        _freezeTransfer(_to, cst);\n', '    }\n', '\n', '    /// @notice withdrawFunds is called to send team bonuses after\n', '    /// then end of the ICO\n', '    bool withdrawCalled = false;\n', '    function withdrawFunds() public onlyOwner {\n', '        require(icoClosed && now >= teamETHUnlock1);\n', '\n', '        require(!withdrawCalled);\n', '        withdrawCalled = true;\n', '\n', '        uint eth;\n', '        (,eth,) = ICOStatus();\n', '\n', '        // pre-ico tokens are not in ethSold\n', '        uint minus = bonusTransferred.mul(10**8).div(ethRate);\n', '        uint team = ethSold.sub(minus);\n', '\n', '        team = team.mul(15).div(100);\n', '\n', '        uint ownerETH = 0;\n', '        uint teamETH = 0;\n', '        if (address(this).balance >= team) {\n', '            teamETH = team;\n', '            ownerETH = address(this).balance.sub(teamETH);\n', '        } else {\n', '            teamETH = address(this).balance;\n', '        }\n', '\n', '        teamETH1 = teamETH.div(3);\n', '        teamETH2 = teamETH.div(3);\n', '        teamETH3 = teamETH.sub(teamETH1).sub(teamETH2);\n', '\n', '        // TODO multisig\n', '        address(0x741A26104530998F625D15cbb9D58b01811d2CA7).transfer(ownerETH);\n', '    }\n', '\n', '    uint teamETH1 = 0;\n', '    uint teamETH2 = 0;\n', '    uint teamETH3 = 0;\n', '    function withdrawTeam() public {\n', '        require(now >= teamETHUnlock1);\n', '\n', '        uint amount = 0;\n', '        if (now < teamETHUnlock2) {\n', '            amount = teamETH1;\n', '            teamETH1 = 0;\n', '        } else if (now < teamETHUnlock3) {\n', '            amount = teamETH1 + teamETH2;\n', '            teamETH1 = 0;\n', '            teamETH2 = 0;\n', '        } else {\n', '            amount = teamETH1 + teamETH2 + teamETH3;\n', '            teamETH1 = 0;\n', '            teamETH2 = 0;\n', '            teamETH3 = 0;\n', '        }\n', '\n', '        address(0xcdB7A51bA9af93a7BFfe08a31E4C6c5f9068A051).transfer(amount.mul(6).div(100)); // NuT\n', '        address(0x57Bd10E12f789B74071d62550DaeB3765Ad83834).transfer(amount.mul(6).div(100)); // AlK\n', '        address(0xEE74922eaF503463a8b20aFaD83d42F28D59f45d).transfer(amount.mul(6).div(100)); // StK\n', '        address(0x58681a49A6f9D61eB368241a336628781afD5f87).transfer(amount.mul(2).div(100)); // DeP\n', '        address(0x4c14DB011065e72C6E839bd826d101Ec09d3C530).transfer(amount.mul(2).div(100)); // VaB\n', '\n', '        amount = amount.mul(78).div(100);\n', '\n', '        address(0x1E21f744d91994D19f2a61041CD7cCA571185dfc).transfer(amount.mul(uint(255).mul(100).div(96)).div(1000)); // ArK\n', '        address(0x4CE4Ea57c40bBa26B7b799d5e0b4cd063B034c8A).transfer(amount.mul(uint(185).mul(100).div(96)).div(1000)); // ViT\n', '        address(0xdCd8a8e561d23Ca710f23E7612F1D4E0dE9bde83).transfer(amount.mul(uint(25).mul(100).div(96)).div(1000));  // SeT\n', '        address(0x0dFFA8624A1f512b8dcDE807F8B0Eab68672e5D5).transfer(amount.mul(uint(250).mul(100).div(96)).div(1000)); // AnD\n', '        address(0xE091180bB0C284AA0Bd15C6888A41aba45c54AF0).transfer(amount.mul(uint(245).mul(100).div(96)).div(1000)); // VlM\n', '    }\n', '\n', '    /// @notice doAirdrop is called when we launch airdrop.\n', '    /// @notice airdrop tokens has their own supply.\n', '    uint dropped = 0;\n', '    function doAirdrop(address[] members, uint[] tokens) public onlyOwnerAndDirector {\n', '        require(members.length == tokens.length);\n', '    \n', '        for(uint i = 0; i < members.length; i++) {\n', '            _freezeTransfer(members[i], tokens[i]);\n', '            dropped = dropped.add(tokens[i]);\n', '        }\n', '        require(dropped <= bountySupply);\n', '    }\n', '\n', '    mapping(address => uint) public whitemap;\n', '    uint public whitelistTokens = 0;\n', '    /// @notice addWhitelistMember is used to whitelist participant.\n', '    /// This means, that for the first 3 days of crowd-sale `_tokens` CST \n', '    /// will be reserved for him.\n', '    function addWhitelistMember(address[] _mem, uint[] _tokens) public onlyAdmin {\n', '        require(_mem.length == _tokens.length);\n', '        for(uint i = 0; i < _mem.length; i++) {\n', '            whitelistTokens = whitelistTokens.sub(whitemap[_mem[i]]).add(_tokens[i]);\n', '            whitemap[_mem[i]] = _tokens[i];\n', '        }\n', '    }\n', '\n', '    uint public adviserSold = 0;\n', '    /// @notice transferAdviser is called to send tokens to advisers.\n', '    /// @notice adviser tokens have their own supply\n', '    function transferAdviser(address[] _adv, uint[] _tokens) public onlyOwnerAndDirector {\n', '        require(_adv.length == _tokens.length);\n', '        for (uint i = 0; i < _adv.length; i++) {\n', '            adviserSold = adviserSold.add(_tokens[i]);\n', '            _freezeTransfer(_adv[i], _tokens[i]);\n', '        }\n', '        require(adviserSold <= adviserSupply);\n', '    }\n', '\n', '    mapping(address => bool) approvedInvestors;\n', '    function approveInvestor(address _addr) public onlyOwner {\n', '        approvedInvestors[_addr] = true;\n', '    }\n', '}']
