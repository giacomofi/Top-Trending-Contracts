['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address _who) public constant returns (uint);\n', '  function allowance(address _owner, address _spender) public constant returns (uint);\n', '\n', '  function transfer(address _to, uint _value) public returns (bool ok);\n', '  function transferFrom(address _from, address _to, uint _value) public returns (bool ok);\n', '  function approve(address _spender, uint _value) public returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', 'contract Haltable is Ownable {\n', '\n', '    // @dev To Halt in Emergency Condition\n', '    bool public halted = false;\n', '    //empty contructor\n', '    function Haltable() public {}\n', '\n', '    // @dev Use this as function modifier that should not execute if contract state Halted\n', '    modifier stopIfHalted {\n', '      require(!halted);\n', '      _;\n', '    }\n', '\n', '    // @dev Use this as function modifier that should execute only if contract state Halted\n', '    modifier runIfHalted{\n', '      require(halted);\n', '      _;\n', '    }\n', '\n', '    // @dev called by only owner in case of any emergecy situation\n', '    function halt() onlyOwner stopIfHalted public {\n', '        halted = true;\n', '    }\n', '    // @dev called by only owner to stop the emergency situation\n', '    function unHalt() onlyOwner runIfHalted public {\n', '        halted = false;\n', '    }\n', '}\n', '\n', 'contract UpgradeAgent is SafeMath {\n', '  address public owner;\n', '  bool public isUpgradeAgent;\n', '  function upgradeFrom(address _from, uint256 _value) public;\n', '  function setOriginalSupply() public;\n', '}\n', '\n', 'contract MiBoodleToken is ERC20,SafeMath,Haltable {\n', '\n', '    //flag to determine if address is for real contract or not\n', '    bool public isMiBoodleToken = false;\n', '\n', '    //Token related information\n', '    string public constant name = "miBoodle";\n', '    string public constant symbol = "MIBO";\n', '    uint256 public constant decimals = 18; // decimal places\n', '\n', '    //mapping of token balances\n', '    mapping (address => uint256) balances;\n', '    //mapping of allowed address for each address with tranfer limit\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    //mapping of allowed address for each address with burnable limit\n', '    mapping (address => mapping (address => uint256)) allowedToBurn;\n', '\n', '    //mapping of ether investment\n', '    mapping (address => uint256) investment;\n', '\n', '    address public upgradeMaster;\n', '    UpgradeAgent public upgradeAgent;\n', '    uint256 public totalUpgraded;\n', '    bool public upgradeAgentStatus = false;\n', '\n', '    //crowdSale related information\n', '     //crowdsale start time\n', '    uint256 public start;\n', '    //crowdsale end time\n', '    uint256 public end;\n', '    //crowdsale prefunding start time\n', '    uint256 public preFundingStart;\n', '    //Tokens per Ether in preFunding\n', '    uint256 public preFundingtokens;\n', '    //Tokens per Ether in Funding\n', '    uint256 public fundingTokens;\n', '    //max token supply\n', '    uint256 public maxTokenSupply = 600000000 ether;\n', '    //max token for sale\n', '    uint256 public maxTokenSale = 200000000 ether;\n', '    //max token for preSale\n', '    uint256 public maxTokenForPreSale = 100000000 ether;\n', '    //address of multisig\n', '    address public multisig;\n', '    //address of vault\n', '    address public vault;\n', '    //Is crowdsale finalized\n', '    bool public isCrowdSaleFinalized = false;\n', '    //Accept minimum ethers\n', '    uint256 minInvest = 1 ether;\n', '    //Accept maximum ethers\n', '    uint256 maxInvest = 50 ether;\n', '    //Is transfer enable\n', '    bool public isTransferEnable = false;\n', '    //Is Released Ether Once\n', '    bool public isReleasedOnce = false;\n', '\n', '    //event\n', '    event Allocate(address _address,uint256 _value);\n', '    event Burn(address owner,uint256 _value);\n', '    event ApproveBurner(address owner, address canBurn, uint256 value);\n', '    event BurnFrom(address _from,uint256 _value);\n', '    event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n', '    event UpgradeAgentSet(address agent);\n', '    event Deposit(address _investor,uint256 _value);\n', '\n', '    function MiBoodleToken(uint256 _preFundingtokens,uint256 _fundingTokens,uint256 _preFundingStart,uint256 _start,uint256 _end) public {\n', '        upgradeMaster = msg.sender;\n', '        isMiBoodleToken = true;\n', '        preFundingtokens = _preFundingtokens;\n', '        fundingTokens = _fundingTokens;\n', '        preFundingStart = safeAdd(now, _preFundingStart);\n', '        start = safeAdd(now, _start);\n', '        end = safeAdd(now, _end);\n', '    }\n', '\n', '    //&#39;owner&#39; can set minimum ether to accept\n', '    // @param _minInvest Minimum value of ether\n', '    function setMinimumEtherToAccept(uint256 _minInvest) public stopIfHalted onlyOwner {\n', '        minInvest = _minInvest;\n', '    }\n', '\n', '    //&#39;owner&#39; can set maximum ether to accept\n', '    // @param _maxInvest Maximum value of ether\n', '    function setMaximumEtherToAccept(uint256 _maxInvest) public stopIfHalted onlyOwner {\n', '        maxInvest = _maxInvest;\n', '    }\n', '\n', '    //&#39;owner&#39; can set start time of pre funding\n', '    // @param _preFundingStart Starting time of prefunding\n', '    function setPreFundingStartTime(uint256 _preFundingStart) public stopIfHalted onlyOwner {\n', '        preFundingStart = now + _preFundingStart;\n', '    }\n', '\n', '    //&#39;owner&#39; can set start time of funding\n', '    // @param _start Starting time of funding\n', '    function setFundingStartTime(uint256 _start) public stopIfHalted onlyOwner {\n', '        start = now + _start;\n', '    }\n', '\n', '    //&#39;owner&#39; can set end time of funding\n', '    // @param _end Ending time of funding\n', '    function setFundingEndTime(uint256 _end) public stopIfHalted onlyOwner {\n', '        end = now + _end;\n', '    }\n', '\n', '    //&#39;owner&#39; can set transfer enable or disable\n', '    // @param _isTransferEnable Token transfer enable or disable\n', '    function setTransferEnable(bool _isTransferEnable) public stopIfHalted onlyOwner {\n', '        isTransferEnable = _isTransferEnable;\n', '    }\n', '\n', '    //&#39;owner&#39; can set number of tokens per Ether in prefunding\n', '    // @param _preFundingtokens Tokens per Ether in prefunding\n', '    function setPreFundingtokens(uint256 _preFundingtokens) public stopIfHalted onlyOwner {\n', '        preFundingtokens = _preFundingtokens;\n', '    }\n', '\n', '    //&#39;owner&#39; can set number of tokens per Ether in funding\n', '    // @param _fundingTokens Tokens per Ether in funding\n', '    function setFundingtokens(uint256 _fundingTokens) public stopIfHalted onlyOwner {\n', '        fundingTokens = _fundingTokens;\n', '    }\n', '\n', '    //Owner can Set Multisig wallet\n', '    //@ param _multisig address of Multisig wallet.\n', '    function setMultisigWallet(address _multisig) onlyOwner public {\n', '        require(_multisig != 0);\n', '        multisig = _multisig;\n', '    }\n', '\n', '    //Owner can Set TokenVault\n', '    //@ param _vault address of TokenVault.\n', '    function setMiBoodleVault(address _vault) onlyOwner public {\n', '        require(_vault != 0);\n', '        vault = _vault;\n', '    }\n', '\n', '    //owner can call to allocate tokens to investor who invested in other currencies\n', '    //@ param _investor address of investor\n', '    //@ param _tokens number of tokens to give to investor\n', '    function cashInvestment(address _investor,uint256 _tokens) onlyOwner stopIfHalted external {\n', '        //validate address\n', '        require(_investor != 0);\n', '        //not allow with tokens 0\n', '        require(_tokens > 0);\n', '        //not allow if crowdsale ends.\n', '        require(now >= preFundingStart && now <= end);\n', '        if (now < start && now >= preFundingStart) {\n', '            //total supply should not be greater than max token sale for pre funding\n', '            require(safeAdd(totalSupply, _tokens) <= maxTokenForPreSale);\n', '        } else {\n', '            //total supply should not be greater than max token sale\n', '            require(safeAdd(totalSupply, _tokens) <= maxTokenSale);\n', '        }\n', '        //Call internal method to assign tokens\n', '        assignTokens(_investor,_tokens);\n', '    }\n', '\n', '    // transfer the tokens to investor&#39;s address\n', '    // Common function code for cashInvestment and Crowdsale Investor\n', '    function assignTokens(address _investor, uint256 _tokens) internal {\n', '        // Creating tokens and  increasing the totalSupply\n', '        totalSupply = safeAdd(totalSupply,_tokens);\n', '        // Assign new tokens to the sender\n', '        balances[_investor] = safeAdd(balances[_investor],_tokens);\n', '        // Finally token created for sender, log the creation event\n', '        Allocate(_investor, _tokens);\n', '    }\n', '\n', '    // Withdraw ether during pre-sale and sale \n', '    function withdraw() external onlyOwner {\n', '        // Release only if token-sale not ended and multisig set\n', '        require(now <= end && multisig != address(0));\n', '        // Release only if not released anytime before\n', '        require(!isReleasedOnce);\n', '        // Release only if balance more then 200 ether\n', '        require(address(this).balance >= 200 ether);\n', '        // Set ether released once \n', '        isReleasedOnce = true;\n', '        // Release 200 ether\n', '        assert(multisig.send(200 ether));\n', '    }\n', '\n', '    //Finalize crowdsale and allocate tokens to multisig and vault\n', '    function finalizeCrowdSale() external {\n', '        require(!isCrowdSaleFinalized);\n', '        require(multisig != 0 && vault != 0 && now > end);\n', '        require(safeAdd(totalSupply,250000000 ether) <= maxTokenSupply);\n', '        assignTokens(multisig, 250000000 ether);\n', '        require(safeAdd(totalSupply,150000000 ether) <= maxTokenSupply);\n', '        assignTokens(vault, 150000000 ether);\n', '        isCrowdSaleFinalized = true;\n', '        require(multisig.send(address(this).balance));\n', '    }\n', '\n', '    //fallback function to accept ethers\n', '    function() payable stopIfHalted external {\n', '        //not allow if crowdsale ends.\n', '        require(now <= end && now >= preFundingStart);\n', '        //not allow to invest with less then minimum investment value\n', '        require(msg.value >= minInvest);\n', '        //not allow to invest with more then maximum investment value\n', '        require(safeAdd(investment[msg.sender],msg.value) <= maxInvest);\n', '\n', '        //Hold created tokens for current state of funding\n', '        uint256 createdTokens;\n', '        if (now < start) {\n', '            createdTokens = safeMul(msg.value,preFundingtokens);\n', '            //total supply should not be greater than max token sale for pre funding\n', '            require(safeAdd(totalSupply, createdTokens) <= maxTokenForPreSale);\n', '        } else {\n', '            createdTokens = safeMul(msg.value,fundingTokens);\n', '            //total supply should not greater than maximum token to supply \n', '            require(safeAdd(totalSupply, createdTokens) <= maxTokenSale);\n', '        }\n', '\n', '        // Add investment details of investor\n', '        investment[msg.sender] = safeAdd(investment[msg.sender],msg.value);\n', '        \n', '        //call internal method to assign tokens\n', '        assignTokens(msg.sender,createdTokens);\n', '        Deposit(msg.sender,createdTokens);\n', '    }\n', '\n', '    // @param _who The address of the investor to check balance\n', '    // @return balance tokens of investor address\n', '    function balanceOf(address _who) public constant returns (uint) {\n', '        return balances[_who];\n', '    }\n', '\n', '    // @param _owner The address of the account owning tokens\n', '    // @param _spender The address of the account able to transfer the tokens\n', '    // @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public constant returns (uint) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // @param _owner The address of the account owning tokens\n', '    // @param _spender The address of the account able to transfer the tokens\n', '    // @return Amount of remaining tokens allowed to spent\n', '    function allowanceToBurn(address _owner, address _spender) public constant returns (uint) {\n', '        return allowedToBurn[_owner][_spender];\n', '    }\n', '\n', '    //  Transfer `value` miBoodle tokens from sender&#39;s account\n', '    // `msg.sender` to provided account address `to`.\n', '    // @param _to The address of the recipient\n', '    // @param _value The number of miBoodle tokens to transfer\n', '    // @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) public returns (bool ok) {\n', '        //allow only if transfer is enable\n', '        require(isTransferEnable);\n', '        //require(now >= end);\n', '        //validate receiver address and value.Not allow 0 value\n', '        require(_to != 0 && _value > 0);\n', '        uint256 senderBalance = balances[msg.sender];\n', '        //Check sender have enough balance\n', '        require(senderBalance >= _value);\n', '        senderBalance = safeSub(senderBalance, _value);\n', '        balances[msg.sender] = senderBalance;\n', '        balances[_to] = safeAdd(balances[_to],_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    //  Transfer `value` miBoodle tokens from sender &#39;from&#39;\n', '    // to provided account address `to`.\n', '    // @param from The address of the sender\n', '    // @param to The address of the recipient\n', '    // @param value The number of miBoodle to transfer\n', '    // @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool ok) {\n', '        //allow only if transfer is enable\n', '        require(isTransferEnable);\n', '        //require(now >= end);\n', '        //validate _from,_to address and _value(Not allow with 0)\n', '        require(_from != 0 && _to != 0 && _value > 0);\n', '        //Check amount is approved by the owner for spender to spent and owner have enough balances\n', '        require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value);\n', '        balances[_from] = safeSub(balances[_from],_value);\n', '        balances[_to] = safeAdd(balances[_to],_value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    //  `msg.sender` approves `spender` to spend `value` tokens\n', '    // @param spender The address of the account able to transfer the tokens\n', '    // @param value The amount of wei to be approved for transfer\n', '    // @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) public returns (bool ok) {\n', '        //validate _spender address\n', '        require(_spender != 0);\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    //  `msg.sender` approves `_canBurn` to burn `value` tokens\n', '    // @param _canBurn The address of the account able to burn the tokens\n', '    // @param _value The amount of wei to be approved for burn\n', '    // @return Whether the approval was successful or not\n', '    function approveForBurn(address _canBurn, uint _value) public returns (bool ok) {\n', '        //validate _spender address\n', '        require(_canBurn != 0);\n', '        allowedToBurn[msg.sender][_canBurn] = _value;\n', '        ApproveBurner(msg.sender, _canBurn, _value);\n', '        return true;\n', '    }\n', '\n', '    //  Burn `value` miBoodle tokens from sender&#39;s account\n', '    // `msg.sender` to provided _value.\n', '    // @param _value The number of miBoodle tokens to destroy\n', '    // @return Whether the Burn was successful or not\n', '    function burn(uint _value) public returns (bool ok) {\n', '        //allow only if transfer is enable\n', '        require(now >= end);\n', '        //validate receiver address and value.Now allow 0 value\n', '        require(_value > 0);\n', '        uint256 senderBalance = balances[msg.sender];\n', '        require(senderBalance >= _value);\n', '        senderBalance = safeSub(senderBalance, _value);\n', '        balances[msg.sender] = senderBalance;\n', '        totalSupply = safeSub(totalSupply,_value);\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    //  Burn `value` miBoodle tokens from sender &#39;from&#39;\n', '    // to provided account address `to`.\n', '    // @param from The address of the burner\n', '    // @param to The address of the token holder from token to burn\n', '    // @param value The number of miBoodle to burn\n', '    // @return Whether the transfer was successful or not\n', '    function burnFrom(address _from, uint _value) public returns (bool ok) {\n', '        //allow only if transfer is enable\n', '        require(now >= end);\n', '        //validate _from,_to address and _value(Now allow with 0)\n', '        require(_from != 0 && _value > 0);\n', '        //Check amount is approved by the owner to burn and owner have enough balances\n', '        require(allowedToBurn[_from][msg.sender] >= _value && balances[_from] >= _value);\n', '        balances[_from] = safeSub(balances[_from],_value);\n', '        totalSupply = safeSub(totalSupply,_value);\n', '        allowedToBurn[_from][msg.sender] = safeSub(allowedToBurn[_from][msg.sender],_value);\n', '        BurnFrom(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    // Token upgrade functionality\n', '\n', '    /// @notice Upgrade tokens to the new token contract.\n', '    /// @param value The number of tokens to upgrade\n', '    function upgrade(uint256 value) external {\n', '        /*if (getState() != State.Success) throw; // Abort if not in Success state.*/\n', '        require(upgradeAgentStatus); // need a real upgradeAgent address\n', '\n', '        // Validate input value.\n', '        require (value > 0 && upgradeAgent.owner() != 0x0);\n', '        require (value <= balances[msg.sender]);\n', '\n', '        // update the balances here first before calling out (reentrancy)\n', '        balances[msg.sender] = safeSub(balances[msg.sender], value);\n', '        totalSupply = safeSub(totalSupply, value);\n', '        totalUpgraded = safeAdd(totalUpgraded, value);\n', '        upgradeAgent.upgradeFrom(msg.sender, value);\n', '        Upgrade(msg.sender, upgradeAgent, value);\n', '    }\n', '\n', '    /// @notice Set address of upgrade target contract and enable upgrade\n', '    /// process.\n', '    /// @param agent The address of the UpgradeAgent contract\n', '    function setUpgradeAgent(address agent) external onlyOwner {\n', '        require(agent != 0x0 && msg.sender == upgradeMaster);\n', '        upgradeAgent = UpgradeAgent(agent);\n', '        require (upgradeAgent.isUpgradeAgent());\n', '        // this needs to be called in success condition to guarantee the invariant is true\n', '        upgradeAgentStatus = true;\n', '        upgradeAgent.setOriginalSupply();\n', '        UpgradeAgentSet(upgradeAgent);\n', '    }\n', '\n', '    /// @notice Set address of upgrade target contract and enable upgrade\n', '    /// process.\n', '    /// @param master The address that will manage upgrades, not the upgradeAgent contract address\n', '    function setUpgradeMaster(address master) external {\n', '        require (master != 0x0 && msg.sender == upgradeMaster);\n', '        upgradeMaster = master;\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address _who) public constant returns (uint);\n', '  function allowance(address _owner, address _spender) public constant returns (uint);\n', '\n', '  function transfer(address _to, uint _value) public returns (bool ok);\n', '  function transferFrom(address _from, address _to, uint _value) public returns (bool ok);\n', '  function approve(address _spender, uint _value) public returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', 'contract Haltable is Ownable {\n', '\n', '    // @dev To Halt in Emergency Condition\n', '    bool public halted = false;\n', '    //empty contructor\n', '    function Haltable() public {}\n', '\n', '    // @dev Use this as function modifier that should not execute if contract state Halted\n', '    modifier stopIfHalted {\n', '      require(!halted);\n', '      _;\n', '    }\n', '\n', '    // @dev Use this as function modifier that should execute only if contract state Halted\n', '    modifier runIfHalted{\n', '      require(halted);\n', '      _;\n', '    }\n', '\n', '    // @dev called by only owner in case of any emergecy situation\n', '    function halt() onlyOwner stopIfHalted public {\n', '        halted = true;\n', '    }\n', '    // @dev called by only owner to stop the emergency situation\n', '    function unHalt() onlyOwner runIfHalted public {\n', '        halted = false;\n', '    }\n', '}\n', '\n', 'contract UpgradeAgent is SafeMath {\n', '  address public owner;\n', '  bool public isUpgradeAgent;\n', '  function upgradeFrom(address _from, uint256 _value) public;\n', '  function setOriginalSupply() public;\n', '}\n', '\n', 'contract MiBoodleToken is ERC20,SafeMath,Haltable {\n', '\n', '    //flag to determine if address is for real contract or not\n', '    bool public isMiBoodleToken = false;\n', '\n', '    //Token related information\n', '    string public constant name = "miBoodle";\n', '    string public constant symbol = "MIBO";\n', '    uint256 public constant decimals = 18; // decimal places\n', '\n', '    //mapping of token balances\n', '    mapping (address => uint256) balances;\n', '    //mapping of allowed address for each address with tranfer limit\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    //mapping of allowed address for each address with burnable limit\n', '    mapping (address => mapping (address => uint256)) allowedToBurn;\n', '\n', '    //mapping of ether investment\n', '    mapping (address => uint256) investment;\n', '\n', '    address public upgradeMaster;\n', '    UpgradeAgent public upgradeAgent;\n', '    uint256 public totalUpgraded;\n', '    bool public upgradeAgentStatus = false;\n', '\n', '    //crowdSale related information\n', '     //crowdsale start time\n', '    uint256 public start;\n', '    //crowdsale end time\n', '    uint256 public end;\n', '    //crowdsale prefunding start time\n', '    uint256 public preFundingStart;\n', '    //Tokens per Ether in preFunding\n', '    uint256 public preFundingtokens;\n', '    //Tokens per Ether in Funding\n', '    uint256 public fundingTokens;\n', '    //max token supply\n', '    uint256 public maxTokenSupply = 600000000 ether;\n', '    //max token for sale\n', '    uint256 public maxTokenSale = 200000000 ether;\n', '    //max token for preSale\n', '    uint256 public maxTokenForPreSale = 100000000 ether;\n', '    //address of multisig\n', '    address public multisig;\n', '    //address of vault\n', '    address public vault;\n', '    //Is crowdsale finalized\n', '    bool public isCrowdSaleFinalized = false;\n', '    //Accept minimum ethers\n', '    uint256 minInvest = 1 ether;\n', '    //Accept maximum ethers\n', '    uint256 maxInvest = 50 ether;\n', '    //Is transfer enable\n', '    bool public isTransferEnable = false;\n', '    //Is Released Ether Once\n', '    bool public isReleasedOnce = false;\n', '\n', '    //event\n', '    event Allocate(address _address,uint256 _value);\n', '    event Burn(address owner,uint256 _value);\n', '    event ApproveBurner(address owner, address canBurn, uint256 value);\n', '    event BurnFrom(address _from,uint256 _value);\n', '    event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n', '    event UpgradeAgentSet(address agent);\n', '    event Deposit(address _investor,uint256 _value);\n', '\n', '    function MiBoodleToken(uint256 _preFundingtokens,uint256 _fundingTokens,uint256 _preFundingStart,uint256 _start,uint256 _end) public {\n', '        upgradeMaster = msg.sender;\n', '        isMiBoodleToken = true;\n', '        preFundingtokens = _preFundingtokens;\n', '        fundingTokens = _fundingTokens;\n', '        preFundingStart = safeAdd(now, _preFundingStart);\n', '        start = safeAdd(now, _start);\n', '        end = safeAdd(now, _end);\n', '    }\n', '\n', "    //'owner' can set minimum ether to accept\n", '    // @param _minInvest Minimum value of ether\n', '    function setMinimumEtherToAccept(uint256 _minInvest) public stopIfHalted onlyOwner {\n', '        minInvest = _minInvest;\n', '    }\n', '\n', "    //'owner' can set maximum ether to accept\n", '    // @param _maxInvest Maximum value of ether\n', '    function setMaximumEtherToAccept(uint256 _maxInvest) public stopIfHalted onlyOwner {\n', '        maxInvest = _maxInvest;\n', '    }\n', '\n', "    //'owner' can set start time of pre funding\n", '    // @param _preFundingStart Starting time of prefunding\n', '    function setPreFundingStartTime(uint256 _preFundingStart) public stopIfHalted onlyOwner {\n', '        preFundingStart = now + _preFundingStart;\n', '    }\n', '\n', "    //'owner' can set start time of funding\n", '    // @param _start Starting time of funding\n', '    function setFundingStartTime(uint256 _start) public stopIfHalted onlyOwner {\n', '        start = now + _start;\n', '    }\n', '\n', "    //'owner' can set end time of funding\n", '    // @param _end Ending time of funding\n', '    function setFundingEndTime(uint256 _end) public stopIfHalted onlyOwner {\n', '        end = now + _end;\n', '    }\n', '\n', "    //'owner' can set transfer enable or disable\n", '    // @param _isTransferEnable Token transfer enable or disable\n', '    function setTransferEnable(bool _isTransferEnable) public stopIfHalted onlyOwner {\n', '        isTransferEnable = _isTransferEnable;\n', '    }\n', '\n', "    //'owner' can set number of tokens per Ether in prefunding\n", '    // @param _preFundingtokens Tokens per Ether in prefunding\n', '    function setPreFundingtokens(uint256 _preFundingtokens) public stopIfHalted onlyOwner {\n', '        preFundingtokens = _preFundingtokens;\n', '    }\n', '\n', "    //'owner' can set number of tokens per Ether in funding\n", '    // @param _fundingTokens Tokens per Ether in funding\n', '    function setFundingtokens(uint256 _fundingTokens) public stopIfHalted onlyOwner {\n', '        fundingTokens = _fundingTokens;\n', '    }\n', '\n', '    //Owner can Set Multisig wallet\n', '    //@ param _multisig address of Multisig wallet.\n', '    function setMultisigWallet(address _multisig) onlyOwner public {\n', '        require(_multisig != 0);\n', '        multisig = _multisig;\n', '    }\n', '\n', '    //Owner can Set TokenVault\n', '    //@ param _vault address of TokenVault.\n', '    function setMiBoodleVault(address _vault) onlyOwner public {\n', '        require(_vault != 0);\n', '        vault = _vault;\n', '    }\n', '\n', '    //owner can call to allocate tokens to investor who invested in other currencies\n', '    //@ param _investor address of investor\n', '    //@ param _tokens number of tokens to give to investor\n', '    function cashInvestment(address _investor,uint256 _tokens) onlyOwner stopIfHalted external {\n', '        //validate address\n', '        require(_investor != 0);\n', '        //not allow with tokens 0\n', '        require(_tokens > 0);\n', '        //not allow if crowdsale ends.\n', '        require(now >= preFundingStart && now <= end);\n', '        if (now < start && now >= preFundingStart) {\n', '            //total supply should not be greater than max token sale for pre funding\n', '            require(safeAdd(totalSupply, _tokens) <= maxTokenForPreSale);\n', '        } else {\n', '            //total supply should not be greater than max token sale\n', '            require(safeAdd(totalSupply, _tokens) <= maxTokenSale);\n', '        }\n', '        //Call internal method to assign tokens\n', '        assignTokens(_investor,_tokens);\n', '    }\n', '\n', "    // transfer the tokens to investor's address\n", '    // Common function code for cashInvestment and Crowdsale Investor\n', '    function assignTokens(address _investor, uint256 _tokens) internal {\n', '        // Creating tokens and  increasing the totalSupply\n', '        totalSupply = safeAdd(totalSupply,_tokens);\n', '        // Assign new tokens to the sender\n', '        balances[_investor] = safeAdd(balances[_investor],_tokens);\n', '        // Finally token created for sender, log the creation event\n', '        Allocate(_investor, _tokens);\n', '    }\n', '\n', '    // Withdraw ether during pre-sale and sale \n', '    function withdraw() external onlyOwner {\n', '        // Release only if token-sale not ended and multisig set\n', '        require(now <= end && multisig != address(0));\n', '        // Release only if not released anytime before\n', '        require(!isReleasedOnce);\n', '        // Release only if balance more then 200 ether\n', '        require(address(this).balance >= 200 ether);\n', '        // Set ether released once \n', '        isReleasedOnce = true;\n', '        // Release 200 ether\n', '        assert(multisig.send(200 ether));\n', '    }\n', '\n', '    //Finalize crowdsale and allocate tokens to multisig and vault\n', '    function finalizeCrowdSale() external {\n', '        require(!isCrowdSaleFinalized);\n', '        require(multisig != 0 && vault != 0 && now > end);\n', '        require(safeAdd(totalSupply,250000000 ether) <= maxTokenSupply);\n', '        assignTokens(multisig, 250000000 ether);\n', '        require(safeAdd(totalSupply,150000000 ether) <= maxTokenSupply);\n', '        assignTokens(vault, 150000000 ether);\n', '        isCrowdSaleFinalized = true;\n', '        require(multisig.send(address(this).balance));\n', '    }\n', '\n', '    //fallback function to accept ethers\n', '    function() payable stopIfHalted external {\n', '        //not allow if crowdsale ends.\n', '        require(now <= end && now >= preFundingStart);\n', '        //not allow to invest with less then minimum investment value\n', '        require(msg.value >= minInvest);\n', '        //not allow to invest with more then maximum investment value\n', '        require(safeAdd(investment[msg.sender],msg.value) <= maxInvest);\n', '\n', '        //Hold created tokens for current state of funding\n', '        uint256 createdTokens;\n', '        if (now < start) {\n', '            createdTokens = safeMul(msg.value,preFundingtokens);\n', '            //total supply should not be greater than max token sale for pre funding\n', '            require(safeAdd(totalSupply, createdTokens) <= maxTokenForPreSale);\n', '        } else {\n', '            createdTokens = safeMul(msg.value,fundingTokens);\n', '            //total supply should not greater than maximum token to supply \n', '            require(safeAdd(totalSupply, createdTokens) <= maxTokenSale);\n', '        }\n', '\n', '        // Add investment details of investor\n', '        investment[msg.sender] = safeAdd(investment[msg.sender],msg.value);\n', '        \n', '        //call internal method to assign tokens\n', '        assignTokens(msg.sender,createdTokens);\n', '        Deposit(msg.sender,createdTokens);\n', '    }\n', '\n', '    // @param _who The address of the investor to check balance\n', '    // @return balance tokens of investor address\n', '    function balanceOf(address _who) public constant returns (uint) {\n', '        return balances[_who];\n', '    }\n', '\n', '    // @param _owner The address of the account owning tokens\n', '    // @param _spender The address of the account able to transfer the tokens\n', '    // @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public constant returns (uint) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // @param _owner The address of the account owning tokens\n', '    // @param _spender The address of the account able to transfer the tokens\n', '    // @return Amount of remaining tokens allowed to spent\n', '    function allowanceToBurn(address _owner, address _spender) public constant returns (uint) {\n', '        return allowedToBurn[_owner][_spender];\n', '    }\n', '\n', "    //  Transfer `value` miBoodle tokens from sender's account\n", '    // `msg.sender` to provided account address `to`.\n', '    // @param _to The address of the recipient\n', '    // @param _value The number of miBoodle tokens to transfer\n', '    // @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) public returns (bool ok) {\n', '        //allow only if transfer is enable\n', '        require(isTransferEnable);\n', '        //require(now >= end);\n', '        //validate receiver address and value.Not allow 0 value\n', '        require(_to != 0 && _value > 0);\n', '        uint256 senderBalance = balances[msg.sender];\n', '        //Check sender have enough balance\n', '        require(senderBalance >= _value);\n', '        senderBalance = safeSub(senderBalance, _value);\n', '        balances[msg.sender] = senderBalance;\n', '        balances[_to] = safeAdd(balances[_to],_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', "    //  Transfer `value` miBoodle tokens from sender 'from'\n", '    // to provided account address `to`.\n', '    // @param from The address of the sender\n', '    // @param to The address of the recipient\n', '    // @param value The number of miBoodle to transfer\n', '    // @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool ok) {\n', '        //allow only if transfer is enable\n', '        require(isTransferEnable);\n', '        //require(now >= end);\n', '        //validate _from,_to address and _value(Not allow with 0)\n', '        require(_from != 0 && _to != 0 && _value > 0);\n', '        //Check amount is approved by the owner for spender to spent and owner have enough balances\n', '        require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value);\n', '        balances[_from] = safeSub(balances[_from],_value);\n', '        balances[_to] = safeAdd(balances[_to],_value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    //  `msg.sender` approves `spender` to spend `value` tokens\n', '    // @param spender The address of the account able to transfer the tokens\n', '    // @param value The amount of wei to be approved for transfer\n', '    // @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) public returns (bool ok) {\n', '        //validate _spender address\n', '        require(_spender != 0);\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    //  `msg.sender` approves `_canBurn` to burn `value` tokens\n', '    // @param _canBurn The address of the account able to burn the tokens\n', '    // @param _value The amount of wei to be approved for burn\n', '    // @return Whether the approval was successful or not\n', '    function approveForBurn(address _canBurn, uint _value) public returns (bool ok) {\n', '        //validate _spender address\n', '        require(_canBurn != 0);\n', '        allowedToBurn[msg.sender][_canBurn] = _value;\n', '        ApproveBurner(msg.sender, _canBurn, _value);\n', '        return true;\n', '    }\n', '\n', "    //  Burn `value` miBoodle tokens from sender's account\n", '    // `msg.sender` to provided _value.\n', '    // @param _value The number of miBoodle tokens to destroy\n', '    // @return Whether the Burn was successful or not\n', '    function burn(uint _value) public returns (bool ok) {\n', '        //allow only if transfer is enable\n', '        require(now >= end);\n', '        //validate receiver address and value.Now allow 0 value\n', '        require(_value > 0);\n', '        uint256 senderBalance = balances[msg.sender];\n', '        require(senderBalance >= _value);\n', '        senderBalance = safeSub(senderBalance, _value);\n', '        balances[msg.sender] = senderBalance;\n', '        totalSupply = safeSub(totalSupply,_value);\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', "    //  Burn `value` miBoodle tokens from sender 'from'\n", '    // to provided account address `to`.\n', '    // @param from The address of the burner\n', '    // @param to The address of the token holder from token to burn\n', '    // @param value The number of miBoodle to burn\n', '    // @return Whether the transfer was successful or not\n', '    function burnFrom(address _from, uint _value) public returns (bool ok) {\n', '        //allow only if transfer is enable\n', '        require(now >= end);\n', '        //validate _from,_to address and _value(Now allow with 0)\n', '        require(_from != 0 && _value > 0);\n', '        //Check amount is approved by the owner to burn and owner have enough balances\n', '        require(allowedToBurn[_from][msg.sender] >= _value && balances[_from] >= _value);\n', '        balances[_from] = safeSub(balances[_from],_value);\n', '        totalSupply = safeSub(totalSupply,_value);\n', '        allowedToBurn[_from][msg.sender] = safeSub(allowedToBurn[_from][msg.sender],_value);\n', '        BurnFrom(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    // Token upgrade functionality\n', '\n', '    /// @notice Upgrade tokens to the new token contract.\n', '    /// @param value The number of tokens to upgrade\n', '    function upgrade(uint256 value) external {\n', '        /*if (getState() != State.Success) throw; // Abort if not in Success state.*/\n', '        require(upgradeAgentStatus); // need a real upgradeAgent address\n', '\n', '        // Validate input value.\n', '        require (value > 0 && upgradeAgent.owner() != 0x0);\n', '        require (value <= balances[msg.sender]);\n', '\n', '        // update the balances here first before calling out (reentrancy)\n', '        balances[msg.sender] = safeSub(balances[msg.sender], value);\n', '        totalSupply = safeSub(totalSupply, value);\n', '        totalUpgraded = safeAdd(totalUpgraded, value);\n', '        upgradeAgent.upgradeFrom(msg.sender, value);\n', '        Upgrade(msg.sender, upgradeAgent, value);\n', '    }\n', '\n', '    /// @notice Set address of upgrade target contract and enable upgrade\n', '    /// process.\n', '    /// @param agent The address of the UpgradeAgent contract\n', '    function setUpgradeAgent(address agent) external onlyOwner {\n', '        require(agent != 0x0 && msg.sender == upgradeMaster);\n', '        upgradeAgent = UpgradeAgent(agent);\n', '        require (upgradeAgent.isUpgradeAgent());\n', '        // this needs to be called in success condition to guarantee the invariant is true\n', '        upgradeAgentStatus = true;\n', '        upgradeAgent.setOriginalSupply();\n', '        UpgradeAgentSet(upgradeAgent);\n', '    }\n', '\n', '    /// @notice Set address of upgrade target contract and enable upgrade\n', '    /// process.\n', '    /// @param master The address that will manage upgrades, not the upgradeAgent contract address\n', '    function setUpgradeMaster(address master) external {\n', '        require (master != 0x0 && msg.sender == upgradeMaster);\n', '        upgradeMaster = master;\n', '    }\n', '}']
