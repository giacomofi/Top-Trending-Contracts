['pragma solidity ^0.4.17;\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\n', 'contract ERC721 {\n', '    // Required methods\n', '    function implementsERC721() public pure returns (bool);\n', '    function totalSupply() public view returns (uint256 total);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) external view returns (address owner);\n', '    function approve(address _to, uint256 _tokenId) external;\n', '    function transfer(address _to, uint256 _tokenId) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '\n', '    // Events\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event Approval(address owner, address approved, uint256 tokenId);\n', '    // Optional\n', '    // function name() public view returns (string name);\n', '    // function symbol() public view returns (string symbol);\n', '    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n', '    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n', '\n', '    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n', '    // function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '}\n', '\n', 'contract FootballerAccessControl{\n', '\n', '  ///@dev Emited when contract is upgraded\n', '  event ContractUpgrade(address newContract);\n', '  //The address of manager (the account or contracts) that can execute action within the role.\n', '  address public managerAddress;\n', '\n', '  ///@dev keeps track whether the contract is paused.\n', '  bool public paused = false;\n', '\n', '  function FootballerAccessControl() public {\n', '    managerAddress = msg.sender;\n', '  }\n', '\n', '  /// @dev Access modifier for manager-only functionality\n', '  modifier onlyManager() {\n', '    require(msg.sender == managerAddress);\n', '    _;\n', '  }\n', '\n', '  ///@dev assigns a new address to act as the Manager.Only available to the current Manager.\n', '  function setManager(address _newManager) external onlyManager {\n', '    require(_newManager != address(0));\n', '    managerAddress = _newManager;\n', '  }\n', '\n', '  /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '  /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /// @dev Modifier to allow actions only when the contract IS paused\n', '  modifier whenPaused {\n', '      require(paused);\n', '      _;\n', '  }\n', '\n', '  /// @dev Called by manager to pause the contract. Used only when\n', '  ///  a bug or exploit is detected and we need to limit damage.\n', '  function pause() external onlyManager whenNotPaused {\n', '    paused = true;\n', '  }\n', '\n', '  /// @dev Unpauses the smart contract. Can only be called by the manager,\n', '  /// since one reason we may pause the contract is when manager accounts are compromised.\n', '  /// @notice This is public rather than external so it can be called by derived contracts.\n', '  function unpause() public onlyManager {\n', '    // can&#39;t unpause if contract was upgraded\n', '    paused = false;\n', '  }\n', '\n', '}\n', '\n', 'contract FootballerBase is FootballerAccessControl {\n', '  using SafeMath for uint256;\n', '  /*** events ***/\n', '  event Create(address owner, uint footballerId);\n', '  event Transfer(address _from, address _to, uint256 tokenId);\n', '\n', '  uint private randNonce = 0;\n', '\n', '  //球员/球星 属性\n', '  struct footballer {\n', '    uint price; //球员-价格 ， 球星-一口价 单位wei\n', '    //球员的战斗属性\n', '    uint defend; //防御\n', '    uint attack; //进攻\n', '    uint quality; //素质\n', '  }\n', '\n', '  //存球星和球员\n', '  footballer[] public footballers;\n', '  //将球员的id和球员的拥有者对应起来\n', '  mapping (uint256 => address) public footballerToOwner;\n', '\n', '  //记录拥有者有多少球员，在balanceOf（）内部使用来解决所有权计数\n', '  mapping (address => uint256) public ownershipTokenCount;\n', '\n', '  //从footballID 到 已批准调用transferFrom（）的地址的映射\n', '  //每个球员只能有一个批准的地址。零值表示没有批准\n', '  mapping (uint256 => address) public footballerToApproved;\n', '\n', '  // 将特定球员的所有权 赋给 某个地址\n', '  function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '    footballerToApproved[_tokenId] = address(0);\n', '    ownershipTokenCount[_to] = ownershipTokenCount[_to].add(1);\n', '    footballerToOwner[_tokenId] = _to;\n', '    ownershipTokenCount[_from] = ownershipTokenCount[_from].sub(1);\n', '    emit Transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  //管理员用于投放球星,和createStar函数一起使用，才能将球星完整信息保存起来\n', '  function _createFootballerStar(uint _price,uint _defend,uint _attack, uint _quality) internal onlyManager returns(uint) {\n', '      footballer memory _player = footballer({\n', '        price:_price,\n', '        defend:_defend,\n', '        attack:_attack,\n', '        quality:_quality\n', '      });\n', '      uint newFootballerId = footballers.push(_player) - 1;\n', '      footballerToOwner[newFootballerId] = managerAddress;\n', '      ownershipTokenCount[managerAddress] = ownershipTokenCount[managerAddress].add(1);\n', '      //记录这个球星可以进行交易\n', '      footballerToApproved[newFootballerId] = managerAddress;\n', '      require(newFootballerId == uint256(uint32(newFootballerId)));\n', '      emit Create(managerAddress, newFootballerId);\n', '      return newFootballerId;\n', '    }\n', '\n', '\n', '    //用于当用户买卡包时，随机生成球员\n', '    function createFootballer () internal returns (uint) {\n', '        footballer memory _player = footballer({\n', '          price: 0,\n', '          defend: _randMod(20,80),\n', '          attack: _randMod(20,80),\n', '          quality: _randMod(20,80)\n', '        });\n', '        uint newFootballerId = footballers.push(_player) - 1;\n', '      //  require(newFootballerId == uint256(uint32(newFootballerId)));\n', '        footballerToOwner[newFootballerId] = msg.sender;\n', '        ownershipTokenCount[msg.sender] =ownershipTokenCount[msg.sender].add(1);\n', '        emit Create(msg.sender, newFootballerId);\n', '        return newFootballerId;\n', '    }\n', '\n', '  // 生成一个从 _min 到 _max 范围内的随机数（不包括 _max）\n', '  function _randMod(uint _min, uint _max) private returns(uint) {\n', '      randNonce++;\n', '      uint modulus = _max - _min;\n', '      return uint(keccak256(now, msg.sender, randNonce)) % modulus + _min;\n', '  }\n', '\n', '}\n', '\n', 'contract FootballerOwnership is FootballerBase, ERC721 {\n', '  /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '  string public constant name = "CyptoWorldCup";\n', '  string public constant symbol = "CWC";\n', '\n', '\n', '  function implementsERC721() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  //判断一个给定的地址是不是现在某个球员的拥有者\n', '  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '    return footballerToOwner[_tokenId] == _claimant;\n', '  }\n', '\n', '  //判断一个给定的地址现在对于某个球员 是不是有 transferApproval\n', '  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '    return footballerToApproved[_tokenId] == _claimant;\n', '  }\n', '\n', '  //给某地址的用户 对 球员有transfer的权利\n', '  function _approve(uint256 _tokenId, address _approved) internal {\n', '      footballerToApproved[_tokenId] = _approved;\n', '  }\n', '\n', '  //返回 owner 拥有的球员数\n', '  function balanceOf(address _owner) public view returns (uint256 count) {\n', '    return ownershipTokenCount[_owner];\n', '  }\n', '\n', '  //转移 球员 给 另一个地址\n', '  function transfer(address _to, uint256 _tokenId) public whenNotPaused {\n', '    require(_to != address(0));\n', '    require(_to != address(this));\n', '    //只能send自己的球员\n', '    require(_owns(msg.sender, _tokenId));\n', '    //重新分配所有权，清除待批准 approvals ，发出转移事件\n', '    _transfer(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  //授予另一个地址通过transferFrom（）转移特定球员的权利。\n', '  function approve(address _to, uint256 _tokenId) external whenNotPaused {\n', '    //只有球员的拥有者才有资格决定要把这个权利给谁\n', '    require(_owns(msg.sender, _tokenId));\n', '    _approve(_tokenId, _to);\n', '    emit Approval(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  //转让由另一个地址所拥有的球员，该地址之前已经获得所有者的转让批准\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) external whenNotPaused {\n', '    require(_to != address(0));\n', '    //不允许转让本合同以防止意外滥用。\n', '    // 合约不应该拥有任何球员（除非 在创建球星之后并且在拍卖之前 非常短）。\n', '    require(_to != address(this));\n', '    require(_approvedFor(msg.sender, _tokenId));\n', '    require(_owns(_from, _tokenId));\n', '    //该函数定义在FootballerBase\n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  //返回现在一共有多少（球员+球星）\n', '  function totalSupply() public view returns (uint) {\n', '    return footballers.length;\n', '  }\n', '\n', '  //返回该特定球员的拥有者的地址\n', '  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n', '    owner = footballerToOwner[_tokenId];\n', '    require(owner != address(0));\n', '  }\n', '\n', '  //返回该地址的用户拥有的球员的id\n', '  function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n', '    uint256 tokenCount = balanceOf(_owner);\n', '    if(tokenCount == 0) {\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 totalpalyers = totalSupply();\n', '      uint256 resultIndex = 0;\n', '      uint256 footballerId;\n', '      for (footballerId = 0; footballerId < totalpalyers; footballerId++) {\n', '        if(footballerToOwner[footballerId] == _owner) {\n', '          result[resultIndex] = footballerId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  }\n', '}\n', '\n', 'contract FootballerAction is FootballerOwnership {\n', '  //创建球星\n', '  function createFootballerStar(uint _price,uint _defend,uint _attack, uint _quality) public returns(uint) {\n', '      return _createFootballerStar(_price,_defend,_attack,_quality);\n', '  }\n', '\n', '  //抽卡包得球星\n', '  function CardFootballers() public payable returns (uint) {\n', '      uint price = 4000000000000 wei; //0.04 eth\n', '      require(msg.value >= price);\n', '      uint ballerCount = 14;\n', '      uint newFootballerId = 0;\n', '      for (uint i = 0; i < ballerCount; i++) {\n', '         newFootballerId = createFootballer();\n', '      }\n', '      managerAddress.transfer(msg.value);\n', '      return price;\n', '  }\n', '\n', '  function buyStar(uint footballerId,uint price) public payable  {\n', '    require(msg.value >= price);\n', '    //将球星的拥有权 交给 购买的用户\n', '    address holder = footballerToApproved[footballerId];\n', '    require(holder != address(0));\n', '    _transfer(holder,msg.sender,footballerId);\n', '    //给卖家转钱\n', '    holder.transfer(msg.value);\n', '  }\n', '\n', '  //用户出售自己拥有的球员或球星\n', '  function sell(uint footballerId,uint price) public returns(uint) {\n', '    require(footballerToOwner[footballerId] == msg.sender);\n', '    require(footballerToApproved[footballerId] == address(0));\n', '    footballerToApproved[footballerId] = msg.sender;\n', '    footballers[footballerId].price = price;\n', '  }\n', '\n', '  //显示球队\n', '  function getTeamBallers(address actor) public view returns (uint[]) {\n', '    uint len = footballers.length;\n', '    uint count=0;\n', '    for(uint i = 0; i < len; i++) {\n', '        if(_owns(actor, i)){\n', '          if(footballerToApproved[i] == address(0)){\n', '            count++;\n', '          }\n', '       }\n', '    }\n', '    uint[] memory res = new uint256[](count);\n', '    uint index = 0;\n', '    for(i = 0; i < len; i++) {\n', '      if(_owns(actor, i)){\n', '          if(footballerToApproved[i] == address(0)){\n', '            res[index] = i;\n', '            index++;\n', '          }\n', '        }\n', '    }\n', '    return res;\n', '  }\n', '\n', '  //显示出售的球星+球员\n', '  function getSellBallers() public view returns (uint[]) {\n', '    uint len = footballers.length;\n', '    uint count = 0;\n', '    for(uint i = 0; i < len; i++) {\n', '        if(footballerToApproved[i] != address(0)){\n', '          count++;\n', '        }\n', '    }\n', '    uint[] memory res = new uint256[](count);\n', '    uint index = 0;\n', '    for( i = 0; i < len; i++) {\n', '        if(footballerToApproved[i] != address(0)){\n', '          res[index] = i;\n', '          index++;\n', '        }\n', '    }\n', '    return res;\n', '  }\n', '\n', '  //获得球员+球星的总数量\n', '  function getAllBaller() public view returns (uint) {\n', '    uint len = totalSupply();\n', '    return len;\n', '  }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']
['pragma solidity ^0.4.17;\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\n', 'contract ERC721 {\n', '    // Required methods\n', '    function implementsERC721() public pure returns (bool);\n', '    function totalSupply() public view returns (uint256 total);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) external view returns (address owner);\n', '    function approve(address _to, uint256 _tokenId) external;\n', '    function transfer(address _to, uint256 _tokenId) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '\n', '    // Events\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event Approval(address owner, address approved, uint256 tokenId);\n', '    // Optional\n', '    // function name() public view returns (string name);\n', '    // function symbol() public view returns (string symbol);\n', '    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n', '    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n', '\n', '    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n', '    // function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '}\n', '\n', 'contract FootballerAccessControl{\n', '\n', '  ///@dev Emited when contract is upgraded\n', '  event ContractUpgrade(address newContract);\n', '  //The address of manager (the account or contracts) that can execute action within the role.\n', '  address public managerAddress;\n', '\n', '  ///@dev keeps track whether the contract is paused.\n', '  bool public paused = false;\n', '\n', '  function FootballerAccessControl() public {\n', '    managerAddress = msg.sender;\n', '  }\n', '\n', '  /// @dev Access modifier for manager-only functionality\n', '  modifier onlyManager() {\n', '    require(msg.sender == managerAddress);\n', '    _;\n', '  }\n', '\n', '  ///@dev assigns a new address to act as the Manager.Only available to the current Manager.\n', '  function setManager(address _newManager) external onlyManager {\n', '    require(_newManager != address(0));\n', '    managerAddress = _newManager;\n', '  }\n', '\n', '  /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '  /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /// @dev Modifier to allow actions only when the contract IS paused\n', '  modifier whenPaused {\n', '      require(paused);\n', '      _;\n', '  }\n', '\n', '  /// @dev Called by manager to pause the contract. Used only when\n', '  ///  a bug or exploit is detected and we need to limit damage.\n', '  function pause() external onlyManager whenNotPaused {\n', '    paused = true;\n', '  }\n', '\n', '  /// @dev Unpauses the smart contract. Can only be called by the manager,\n', '  /// since one reason we may pause the contract is when manager accounts are compromised.\n', '  /// @notice This is public rather than external so it can be called by derived contracts.\n', '  function unpause() public onlyManager {\n', "    // can't unpause if contract was upgraded\n", '    paused = false;\n', '  }\n', '\n', '}\n', '\n', 'contract FootballerBase is FootballerAccessControl {\n', '  using SafeMath for uint256;\n', '  /*** events ***/\n', '  event Create(address owner, uint footballerId);\n', '  event Transfer(address _from, address _to, uint256 tokenId);\n', '\n', '  uint private randNonce = 0;\n', '\n', '  //球员/球星 属性\n', '  struct footballer {\n', '    uint price; //球员-价格 ， 球星-一口价 单位wei\n', '    //球员的战斗属性\n', '    uint defend; //防御\n', '    uint attack; //进攻\n', '    uint quality; //素质\n', '  }\n', '\n', '  //存球星和球员\n', '  footballer[] public footballers;\n', '  //将球员的id和球员的拥有者对应起来\n', '  mapping (uint256 => address) public footballerToOwner;\n', '\n', '  //记录拥有者有多少球员，在balanceOf（）内部使用来解决所有权计数\n', '  mapping (address => uint256) public ownershipTokenCount;\n', '\n', '  //从footballID 到 已批准调用transferFrom（）的地址的映射\n', '  //每个球员只能有一个批准的地址。零值表示没有批准\n', '  mapping (uint256 => address) public footballerToApproved;\n', '\n', '  // 将特定球员的所有权 赋给 某个地址\n', '  function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '    footballerToApproved[_tokenId] = address(0);\n', '    ownershipTokenCount[_to] = ownershipTokenCount[_to].add(1);\n', '    footballerToOwner[_tokenId] = _to;\n', '    ownershipTokenCount[_from] = ownershipTokenCount[_from].sub(1);\n', '    emit Transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  //管理员用于投放球星,和createStar函数一起使用，才能将球星完整信息保存起来\n', '  function _createFootballerStar(uint _price,uint _defend,uint _attack, uint _quality) internal onlyManager returns(uint) {\n', '      footballer memory _player = footballer({\n', '        price:_price,\n', '        defend:_defend,\n', '        attack:_attack,\n', '        quality:_quality\n', '      });\n', '      uint newFootballerId = footballers.push(_player) - 1;\n', '      footballerToOwner[newFootballerId] = managerAddress;\n', '      ownershipTokenCount[managerAddress] = ownershipTokenCount[managerAddress].add(1);\n', '      //记录这个球星可以进行交易\n', '      footballerToApproved[newFootballerId] = managerAddress;\n', '      require(newFootballerId == uint256(uint32(newFootballerId)));\n', '      emit Create(managerAddress, newFootballerId);\n', '      return newFootballerId;\n', '    }\n', '\n', '\n', '    //用于当用户买卡包时，随机生成球员\n', '    function createFootballer () internal returns (uint) {\n', '        footballer memory _player = footballer({\n', '          price: 0,\n', '          defend: _randMod(20,80),\n', '          attack: _randMod(20,80),\n', '          quality: _randMod(20,80)\n', '        });\n', '        uint newFootballerId = footballers.push(_player) - 1;\n', '      //  require(newFootballerId == uint256(uint32(newFootballerId)));\n', '        footballerToOwner[newFootballerId] = msg.sender;\n', '        ownershipTokenCount[msg.sender] =ownershipTokenCount[msg.sender].add(1);\n', '        emit Create(msg.sender, newFootballerId);\n', '        return newFootballerId;\n', '    }\n', '\n', '  // 生成一个从 _min 到 _max 范围内的随机数（不包括 _max）\n', '  function _randMod(uint _min, uint _max) private returns(uint) {\n', '      randNonce++;\n', '      uint modulus = _max - _min;\n', '      return uint(keccak256(now, msg.sender, randNonce)) % modulus + _min;\n', '  }\n', '\n', '}\n', '\n', 'contract FootballerOwnership is FootballerBase, ERC721 {\n', '  /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '  string public constant name = "CyptoWorldCup";\n', '  string public constant symbol = "CWC";\n', '\n', '\n', '  function implementsERC721() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  //判断一个给定的地址是不是现在某个球员的拥有者\n', '  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '    return footballerToOwner[_tokenId] == _claimant;\n', '  }\n', '\n', '  //判断一个给定的地址现在对于某个球员 是不是有 transferApproval\n', '  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '    return footballerToApproved[_tokenId] == _claimant;\n', '  }\n', '\n', '  //给某地址的用户 对 球员有transfer的权利\n', '  function _approve(uint256 _tokenId, address _approved) internal {\n', '      footballerToApproved[_tokenId] = _approved;\n', '  }\n', '\n', '  //返回 owner 拥有的球员数\n', '  function balanceOf(address _owner) public view returns (uint256 count) {\n', '    return ownershipTokenCount[_owner];\n', '  }\n', '\n', '  //转移 球员 给 另一个地址\n', '  function transfer(address _to, uint256 _tokenId) public whenNotPaused {\n', '    require(_to != address(0));\n', '    require(_to != address(this));\n', '    //只能send自己的球员\n', '    require(_owns(msg.sender, _tokenId));\n', '    //重新分配所有权，清除待批准 approvals ，发出转移事件\n', '    _transfer(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  //授予另一个地址通过transferFrom（）转移特定球员的权利。\n', '  function approve(address _to, uint256 _tokenId) external whenNotPaused {\n', '    //只有球员的拥有者才有资格决定要把这个权利给谁\n', '    require(_owns(msg.sender, _tokenId));\n', '    _approve(_tokenId, _to);\n', '    emit Approval(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  //转让由另一个地址所拥有的球员，该地址之前已经获得所有者的转让批准\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) external whenNotPaused {\n', '    require(_to != address(0));\n', '    //不允许转让本合同以防止意外滥用。\n', '    // 合约不应该拥有任何球员（除非 在创建球星之后并且在拍卖之前 非常短）。\n', '    require(_to != address(this));\n', '    require(_approvedFor(msg.sender, _tokenId));\n', '    require(_owns(_from, _tokenId));\n', '    //该函数定义在FootballerBase\n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  //返回现在一共有多少（球员+球星）\n', '  function totalSupply() public view returns (uint) {\n', '    return footballers.length;\n', '  }\n', '\n', '  //返回该特定球员的拥有者的地址\n', '  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n', '    owner = footballerToOwner[_tokenId];\n', '    require(owner != address(0));\n', '  }\n', '\n', '  //返回该地址的用户拥有的球员的id\n', '  function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n', '    uint256 tokenCount = balanceOf(_owner);\n', '    if(tokenCount == 0) {\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 totalpalyers = totalSupply();\n', '      uint256 resultIndex = 0;\n', '      uint256 footballerId;\n', '      for (footballerId = 0; footballerId < totalpalyers; footballerId++) {\n', '        if(footballerToOwner[footballerId] == _owner) {\n', '          result[resultIndex] = footballerId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  }\n', '}\n', '\n', 'contract FootballerAction is FootballerOwnership {\n', '  //创建球星\n', '  function createFootballerStar(uint _price,uint _defend,uint _attack, uint _quality) public returns(uint) {\n', '      return _createFootballerStar(_price,_defend,_attack,_quality);\n', '  }\n', '\n', '  //抽卡包得球星\n', '  function CardFootballers() public payable returns (uint) {\n', '      uint price = 4000000000000 wei; //0.04 eth\n', '      require(msg.value >= price);\n', '      uint ballerCount = 14;\n', '      uint newFootballerId = 0;\n', '      for (uint i = 0; i < ballerCount; i++) {\n', '         newFootballerId = createFootballer();\n', '      }\n', '      managerAddress.transfer(msg.value);\n', '      return price;\n', '  }\n', '\n', '  function buyStar(uint footballerId,uint price) public payable  {\n', '    require(msg.value >= price);\n', '    //将球星的拥有权 交给 购买的用户\n', '    address holder = footballerToApproved[footballerId];\n', '    require(holder != address(0));\n', '    _transfer(holder,msg.sender,footballerId);\n', '    //给卖家转钱\n', '    holder.transfer(msg.value);\n', '  }\n', '\n', '  //用户出售自己拥有的球员或球星\n', '  function sell(uint footballerId,uint price) public returns(uint) {\n', '    require(footballerToOwner[footballerId] == msg.sender);\n', '    require(footballerToApproved[footballerId] == address(0));\n', '    footballerToApproved[footballerId] = msg.sender;\n', '    footballers[footballerId].price = price;\n', '  }\n', '\n', '  //显示球队\n', '  function getTeamBallers(address actor) public view returns (uint[]) {\n', '    uint len = footballers.length;\n', '    uint count=0;\n', '    for(uint i = 0; i < len; i++) {\n', '        if(_owns(actor, i)){\n', '          if(footballerToApproved[i] == address(0)){\n', '            count++;\n', '          }\n', '       }\n', '    }\n', '    uint[] memory res = new uint256[](count);\n', '    uint index = 0;\n', '    for(i = 0; i < len; i++) {\n', '      if(_owns(actor, i)){\n', '          if(footballerToApproved[i] == address(0)){\n', '            res[index] = i;\n', '            index++;\n', '          }\n', '        }\n', '    }\n', '    return res;\n', '  }\n', '\n', '  //显示出售的球星+球员\n', '  function getSellBallers() public view returns (uint[]) {\n', '    uint len = footballers.length;\n', '    uint count = 0;\n', '    for(uint i = 0; i < len; i++) {\n', '        if(footballerToApproved[i] != address(0)){\n', '          count++;\n', '        }\n', '    }\n', '    uint[] memory res = new uint256[](count);\n', '    uint index = 0;\n', '    for( i = 0; i < len; i++) {\n', '        if(footballerToApproved[i] != address(0)){\n', '          res[index] = i;\n', '          index++;\n', '        }\n', '    }\n', '    return res;\n', '  }\n', '\n', '  //获得球员+球星的总数量\n', '  function getAllBaller() public view returns (uint) {\n', '    uint len = totalSupply();\n', '    return len;\n', '  }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']
