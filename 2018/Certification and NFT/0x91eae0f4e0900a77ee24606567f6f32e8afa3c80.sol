['// File: contracts/FlightDelayConstants.sol\n', '\n', '/**\n', ' * FlightDelay with Oraclized Underwriting and Payout\n', ' *\n', ' * @description\tEvents and Constants\n', ' * @copyright (c) 2017 etherisc GmbH\n', ' * @author Christoph Mussenbrock\n', ' */\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', 'contract FlightDelayConstants {\n', '\n', '    /*\n', '    * General events\n', '    */\n', '\n', '// --> test-mode\n', '//        event LogUint(string _message, uint _uint);\n', '//        event LogUintEth(string _message, uint ethUint);\n', '//        event LogUintTime(string _message, uint timeUint);\n', '//        event LogInt(string _message, int _int);\n', '//        event LogAddress(string _message, address _address);\n', '//        event LogBytes32(string _message, bytes32 hexBytes32);\n', '//        event LogBytes(string _message, bytes hexBytes);\n', '//        event LogBytes32Str(string _message, bytes32 strBytes32);\n', '//        event LogString(string _message, string _string);\n', '//        event LogBool(string _message, bool _bool);\n', '//        event Log(address);\n', '// <-- test-mode\n', '\n', '    event LogPolicyApplied(\n', '        uint _policyId,\n', '        address _customer,\n', '        bytes32 strCarrierFlightNumber,\n', '        uint ethPremium\n', '    );\n', '    event LogPolicyAccepted(\n', '        uint _policyId,\n', '        uint _statistics0,\n', '        uint _statistics1,\n', '        uint _statistics2,\n', '        uint _statistics3,\n', '        uint _statistics4,\n', '        uint _statistics5\n', '    );\n', '    event LogPolicyPaidOut(\n', '        uint _policyId,\n', '        uint ethAmount\n', '    );\n', '    event LogPolicyExpired(\n', '        uint _policyId\n', '    );\n', '    event LogPolicyDeclined(\n', '        uint _policyId,\n', '        bytes32 strReason\n', '    );\n', '    event LogPolicyManualPayout(\n', '        uint _policyId,\n', '        bytes32 strReason\n', '    );\n', '    event LogSendFunds(\n', '        address _recipient,\n', '        uint8 _from,\n', '        uint ethAmount\n', '    );\n', '    event LogReceiveFunds(\n', '        address _sender,\n', '        uint8 _to,\n', '        uint ethAmount\n', '    );\n', '    event LogSendFail(\n', '        uint _policyId,\n', '        bytes32 strReason\n', '    );\n', '    event LogOraclizeCall(\n', '        uint _policyId,\n', '        bytes32 hexQueryId,\n', '        string _oraclizeUrl,\n', '        uint256 _oraclizeTime\n', '    );\n', '    event LogOraclizeCallback(\n', '        uint _policyId,\n', '        bytes32 hexQueryId,\n', '        string _result,\n', '        bytes hexProof\n', '    );\n', '    event LogSetState(\n', '        uint _policyId,\n', '        uint8 _policyState,\n', '        uint _stateTime,\n', '        bytes32 _stateMessage\n', '    );\n', '    event LogExternal(\n', '        uint256 _policyId,\n', '        address _address,\n', '        bytes32 _externalId\n', '    );\n', '\n', '    /*\n', '    * General constants\n', '    */\n', '    // contracts release version\n', '    uint public constant MAJOR_VERSION = 1;\n', '    uint public constant MINOR_VERSION = 0;\n', '    uint public constant PATCH_VERSION = 2;\n', '\n', '    // minimum observations for valid prediction\n', '    uint constant MIN_OBSERVATIONS = 10;\n', '    // minimum premium to cover costs\n', '    uint constant MIN_PREMIUM = 50 finney;\n', '    // maximum premium\n', '    uint constant MAX_PREMIUM = 1 ether;\n', '    // maximum payout\n', '    uint constant MAX_PAYOUT = 1100 finney;\n', '\n', '    uint constant MIN_PREMIUM_EUR = 1500 wei;\n', '    uint constant MAX_PREMIUM_EUR = 29000 wei;\n', '    uint constant MAX_PAYOUT_EUR = 30000 wei;\n', '\n', '    uint constant MIN_PREMIUM_USD = 1700 wei;\n', '    uint constant MAX_PREMIUM_USD = 34000 wei;\n', '    uint constant MAX_PAYOUT_USD = 35000 wei;\n', '\n', '    uint constant MIN_PREMIUM_GBP = 1300 wei;\n', '    uint constant MAX_PREMIUM_GBP = 25000 wei;\n', '    uint constant MAX_PAYOUT_GBP = 270 wei;\n', '\n', '    // maximum cumulated weighted premium per risk\n', '    uint constant MAX_CUMULATED_WEIGHTED_PREMIUM = 60 ether;\n', '    // 1 percent for DAO, 1 percent for maintainer\n', '    uint8 constant REWARD_PERCENT = 2;\n', '    // reserve for tail risks\n', '    uint8 constant RESERVE_PERCENT = 1;\n', '    // the weight pattern; in future versions this may become part of the policy struct.\n', '    // currently can&#39;t be constant because of compiler restrictions\n', '    // WEIGHT_PATTERN[0] is not used, just to be consistent\n', '    uint8[6] WEIGHT_PATTERN = [\n', '        0,\n', '        0,\n', '        0,\n', '        30,\n', '        50,\n', '        50\n', '    ];\n', '\n', '// --> prod-mode\n', '    // DEFINITIONS FOR ROPSTEN AND MAINNET\n', '    // minimum time before departure for applying\n', '    uint constant MIN_TIME_BEFORE_DEPARTURE\t= 24 hours; // for production\n', '    // check for delay after .. minutes after scheduled arrival\n', '    uint constant CHECK_PAYOUT_OFFSET = 15 minutes; // for production\n', '// <-- prod-mode\n', '\n', '// --> test-mode\n', '//        // DEFINITIONS FOR LOCAL TESTNET\n', '//        // minimum time before departure for applying\n', '//        uint constant MIN_TIME_BEFORE_DEPARTURE = 1 seconds; // for testing\n', '//        // check for delay after .. minutes after scheduled arrival\n', '//        uint constant CHECK_PAYOUT_OFFSET = 1 seconds; // for testing\n', '// <-- test-mode\n', '\n', '    // maximum duration of flight\n', '    uint constant MAX_FLIGHT_DURATION = 2 days;\n', '    // Deadline for acceptance of policies: 31.12.2030 (Testnet)\n', '    uint constant CONTRACT_DEAD_LINE = 1922396399;\n', '\n', '    // gas Constants for oraclize\n', '    uint constant ORACLIZE_GAS = 700000;\n', '    uint constant ORACLIZE_GASPRICE = 4000000000;\n', '\n', '\n', '    /*\n', '    * URLs and query strings for oraclize\n', '    */\n', '\n', '// --> prod-mode\n', '    // DEFINITIONS FOR ROPSTEN AND MAINNET\n', '    string constant ORACLIZE_RATINGS_BASE_URL =\n', '        // ratings api is v1, see https://developer.flightstats.com/api-docs/ratings/v1\n', '        "[URL] json(https://api.flightstats.com/flex/ratings/rest/v1/json/flight/";\n', '    string constant ORACLIZE_RATINGS_QUERY =\n', '        "?${[decrypt] BJoM0BfTe82RtghrzzCbNA7b9E9tQIX8LtM+pRRh22RfQ5QhnVAv6Kk4SyaMwQKczC7YtinJ/Xm6PZMgKnWN7+/pFUfI2YcxaAW0vYuXJF4zCTxPYXa6j4shhce60AMBeKoZZsgn6Og+olgSpgpfi4MwkmmytwdCLHqat3gGUPklBhM1HR0x}).ratings[0][&#39;observations&#39;,&#39;late15&#39;,&#39;late30&#39;,&#39;late45&#39;,&#39;cancelled&#39;,&#39;diverted&#39;,&#39;arrivalAirportFsCode&#39;,&#39;departureAirportFsCode&#39;]";\n', '    string constant ORACLIZE_STATUS_BASE_URL =\n', '        // flight status api is v2, see https://developer.flightstats.com/api-docs/flightstatus/v2/flight\n', '        "[URL] json(https://api.flightstats.com/flex/flightstatus/rest/v2/json/flight/status/";\n', '    string constant ORACLIZE_STATUS_QUERY =\n', '        // pattern:\n', '        "?${[decrypt] BA3YyqF4iMQszBawvgG82bqX3fw7JoWA1thFsboUECR/L8JkBCgvaThg1LcUWbIntosEKs/kvqyzOtvdQfMgjYPV0c6hsq/gKQkmJYILZmLY4SgBebH8g0qbfrrjxF5gEbfCi2qoR6PSxcQzKIjgd4HvAaumlQd4CkJLmY463ymqNN9B8/PL}&utc=true).flightStatuses[0][&#39;status&#39;,&#39;delays&#39;,&#39;operationalTimes&#39;]";\n', '// <-- prod-mode\n', '\n', '// --> test-mode\n', '//        // DEFINITIONS FOR LOCAL TESTNET\n', '//        string constant ORACLIZE_RATINGS_BASE_URL =\n', '//            // ratings api is v1, see https://developer.flightstats.com/api-docs/ratings/v1\n', '//            "[URL] json(https://api-test.etherisc.com/flex/ratings/rest/v1/json/flight/";\n', '//        string constant ORACLIZE_RATINGS_QUERY =\n', '//            // for testrpc:\n', '//            ").ratings[0][&#39;observations&#39;,&#39;late15&#39;,&#39;late30&#39;,&#39;late45&#39;,&#39;cancelled&#39;,&#39;diverted&#39;,&#39;arrivalAirportFsCode&#39;,&#39;departureAirportFsCode&#39;]";\n', '//        string constant ORACLIZE_STATUS_BASE_URL =\n', '//            // flight status api is v2, see https://developer.flightstats.com/api-docs/flightstatus/v2/flight\n', '//            "[URL] json(https://api-test.etherisc.com/flex/flightstatus/rest/v2/json/flight/status/";\n', '//        string constant ORACLIZE_STATUS_QUERY =\n', '//            // for testrpc:\n', '//            "?utc=true).flightStatuses[0][&#39;status&#39;,&#39;delays&#39;,&#39;operationalTimes&#39;]";\n', '// <-- test-mode\n', '}\n', '\n', '// File: contracts/FlightDelayControllerInterface.sol\n', '\n', '/**\n', ' * FlightDelay with Oraclized Underwriting and Payout\n', ' *\n', ' * @description Contract interface\n', ' * @copyright (c) 2017 etherisc GmbH\n', ' * @author Christoph Mussenbrock, Stephan Karpischek\n', ' */\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', 'contract FlightDelayControllerInterface {\n', '\n', '    function isOwner(address _addr) public returns (bool _isOwner);\n', '\n', '    function selfRegister(bytes32 _id) public returns (bool result);\n', '\n', '    function getContract(bytes32 _id) public returns (address _addr);\n', '}\n', '\n', '// File: contracts/FlightDelayDatabaseModel.sol\n', '\n', '/**\n', ' * FlightDelay with Oraclized Underwriting and Payout\n', ' *\n', ' * @description Database model\n', ' * @copyright (c) 2017 etherisc GmbH\n', ' * @author Christoph Mussenbrock, Stephan Karpischek\n', ' */\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', 'contract FlightDelayDatabaseModel {\n', '\n', '    // Ledger accounts.\n', '    enum Acc {\n', '        Premium,      // 0\n', '        RiskFund,     // 1\n', '        Payout,       // 2\n', '        Balance,      // 3\n', '        Reward,       // 4\n', '        OraclizeCosts // 5\n', '    }\n', '\n', '    // policy Status Codes and meaning:\n', '    //\n', '    // 00 = Applied:\t  the customer has payed a premium, but the oracle has\n', '    //\t\t\t\t\t        not yet checked and confirmed.\n', '    //\t\t\t\t\t        The customer can still revoke the policy.\n', '    // 01 = Accepted:\t  the oracle has checked and confirmed.\n', '    //\t\t\t\t\t        The customer can still revoke the policy.\n', '    // 02 = Revoked:\t  The customer has revoked the policy.\n', '    //\t\t\t\t\t        The premium minus cancellation fee is payed back to the\n', '    //\t\t\t\t\t        customer by the oracle.\n', '    // 03 = PaidOut:\t  The flight has ended with delay.\n', '    //\t\t\t\t\t        The oracle has checked and payed out.\n', '    // 04 = Expired:\t  The flight has endet with <15min. delay.\n', '    //\t\t\t\t\t        No payout.\n', '    // 05 = Declined:\t  The application was invalid.\n', '    //\t\t\t\t\t        The premium minus cancellation fee is payed back to the\n', '    //\t\t\t\t\t        customer by the oracle.\n', '    // 06 = SendFailed:\tDuring Revoke, Decline or Payout, sending ether failed\n', '    //\t\t\t\t\t        for unknown reasons.\n', '    //\t\t\t\t\t        The funds remain in the contracts RiskFund.\n', '\n', '\n', '    //                   00       01        02       03        04      05           06\n', '    enum policyState { Applied, Accepted, Revoked, PaidOut, Expired, Declined, SendFailed }\n', '\n', '    // oraclize callback types:\n', '    enum oraclizeState { ForUnderwriting, ForPayout }\n', '\n', '    //               00   01   02   03\n', '    enum Currency { ETH, EUR, USD, GBP }\n', '\n', '    // the policy structure: this structure keeps track of the individual parameters of a policy.\n', '    // typically customer address, premium and some status information.\n', '    struct Policy {\n', '        // 0 - the customer\n', '        address customer;\n', '\n', '        // 1 - premium\n', '        uint premium;\n', '        // risk specific parameters:\n', '        // 2 - pointer to the risk in the risks mapping\n', '        bytes32 riskId;\n', '        // custom payout pattern\n', '        // in future versions, customer will be able to tamper with this array.\n', '        // to keep things simple, we have decided to hard-code the array for all policies.\n', '        // uint8[5] pattern;\n', '        // 3 - probability weight. this is the central parameter\n', '        uint weight;\n', '        // 4 - calculated Payout\n', '        uint calculatedPayout;\n', '        // 5 - actual Payout\n', '        uint actualPayout;\n', '\n', '        // status fields:\n', '        // 6 - the state of the policy\n', '        policyState state;\n', '        // 7 - time of last state change\n', '        uint stateTime;\n', '        // 8 - state change message/reason\n', '        bytes32 stateMessage;\n', '        // 9 - TLSNotary Proof\n', '        bytes proof;\n', '        // 10 - Currency\n', '        Currency currency;\n', '        // 10 - External customer id\n', '        bytes32 customerExternalId;\n', '    }\n', '\n', '    // the risk structure; this structure keeps track of the risk-\n', '    // specific parameters.\n', '    // several policies can share the same risk structure (typically\n', '    // some people flying with the same plane)\n', '    struct Risk {\n', '        // 0 - Airline Code + FlightNumber\n', '        bytes32 carrierFlightNumber;\n', '        // 1 - scheduled departure and arrival time in the format /dep/YYYY/MM/DD\n', '        bytes32 departureYearMonthDay;\n', '        // 2 - the inital arrival time\n', '        uint arrivalTime;\n', '        // 3 - the final delay in minutes\n', '        uint delayInMinutes;\n', '        // 4 - the determined delay category (0-5)\n', '        uint8 delay;\n', '        // 5 - we limit the cumulated weighted premium to avoid cluster risks\n', '        uint cumulatedWeightedPremium;\n', '        // 6 - max cumulated Payout for this risk\n', '        uint premiumMultiplier;\n', '    }\n', '\n', '    // the oraclize callback structure: we use several oraclize calls.\n', '    // all oraclize calls will result in a common callback to __callback(...).\n', '    // to keep track of the different querys we have to introduce this struct.\n', '    struct OraclizeCallback {\n', '        // for which policy have we called?\n', '        uint policyId;\n', '        // for which purpose did we call? {ForUnderwrite | ForPayout}\n', '        oraclizeState oState;\n', '        // time\n', '        uint oraclizeTime;\n', '    }\n', '\n', '    struct Customer {\n', '        bytes32 customerExternalId;\n', '        bool identityConfirmed;\n', '    }\n', '}\n', '\n', '// File: contracts/FlightDelayControlledContract.sol\n', '\n', '/**\n', ' * FlightDelay with Oraclized Underwriting and Payout\n', ' *\n', ' * @description Controlled contract Interface\n', ' * @copyright (c) 2017 etherisc GmbH\n', ' * @author Christoph Mussenbrock\n', ' */\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', '\n', '\n', 'contract FlightDelayControlledContract is FlightDelayDatabaseModel {\n', '\n', '    address public controller;\n', '    FlightDelayControllerInterface FD_CI;\n', '\n', '    modifier onlyController() {\n', '        require(msg.sender == controller);\n', '        _;\n', '    }\n', '\n', '    function setController(address _controller) internal returns (bool _result) {\n', '        controller = _controller;\n', '        FD_CI = FlightDelayControllerInterface(_controller);\n', '        _result = true;\n', '    }\n', '\n', '    function destruct() public onlyController {\n', '        selfdestruct(controller);\n', '    }\n', '\n', '    function setContracts() public onlyController {}\n', '\n', '    function getContract(bytes32 _id) internal returns (address _addr) {\n', '        _addr = FD_CI.getContract(_id);\n', '    }\n', '}\n', '\n', '// File: contracts/Owned.sol\n', '\n', '/**\n', ' * FlightDelay with Oraclized Underwriting and Payout\n', ' *\n', ' * @description\tOwned pattern\n', ' * @copyright (c) 2017 etherisc GmbH\n', ' * @author Christoph Mussenbrock, Stephan Karpischek\n', ' */\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Owned {\n', '\n', '    address public owner;\n', '\n', '    /**\n', '     * @dev The Owned constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/FlightDelayController.sol\n', '\n', '/**\n', ' * FlightDelay with Oraclized Underwriting and Payout\n', ' *\n', ' * @description Controller contract\n', ' * @copyright (c) 2017 etherisc GmbH\n', ' * @author Christoph Mussenbrock\n', ' */\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', '\n', '\n', 'contract FlightDelayController is Owned, FlightDelayConstants {\n', '\n', '    struct Controller {\n', '        address addr;\n', '        bool isControlled;\n', '        bool isInitialized;\n', '    }\n', '\n', '    mapping (bytes32 => Controller) public contracts;\n', '    bytes32[] public contractIds;\n', '\n', '    /**\n', '    * Constructor.\n', '    */\n', '    function FlightDelayController() public {\n', '        registerContract(owner, "FD.Owner", false);\n', '        registerContract(address(this), "FD.Controller", false);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != address(0));\n', '        owner = _newOwner;\n', '        setContract(_newOwner, "FD.Owner", false);\n', '    }\n', '\n', '    /**\n', '    * Store address of one contract in mapping.\n', '    * @param _addr       Address of contract\n', '    * @param _id         ID of contract\n', '    */\n', '    function setContract(address _addr, bytes32 _id, bool _isControlled) internal {\n', '        contracts[_id].addr = _addr;\n', '        contracts[_id].isControlled = _isControlled;\n', '    }\n', '\n', '    /**\n', '    * Get contract address from ID. This function is called by the\n', '    * contract&#39;s setContracts function.\n', '    * @param _id         ID of contract\n', '    * @return The address of the contract.\n', '    */\n', '    function getContract(bytes32 _id) public returns (address _addr) {\n', '        _addr = contracts[_id].addr;\n', '    }\n', '\n', '    /**\n', '    * Registration of contracts.\n', '    * It will only accept calls of deployments initiated by the owner.\n', '    * @param _id         ID of contract\n', '    * @return  bool        success\n', '    */\n', '    function registerContract(address _addr, bytes32 _id, bool _isControlled) public onlyOwner returns (bool _result) {\n', '        setContract(_addr, _id, _isControlled);\n', '        contractIds.push(_id);\n', '        _result = true;\n', '    }\n', '\n', '    /**\n', '    * Deregister a contract.\n', '    * In future, contracts should be exchangeable.\n', '    * @param _id         ID of contract\n', '    * @return  bool        success\n', '    */\n', '    function deregister(bytes32 _id) public onlyOwner returns (bool _result) {\n', '        if (getContract(_id) == 0x0) {\n', '            return false;\n', '        }\n', '        setContract(0x0, _id, false);\n', '        _result = true;\n', '    }\n', '\n', '    /**\n', '    * After deploying all contracts, this function is called and calls\n', '    * setContracts() for every registered contract.\n', '    * This call pulls the addresses of the needed contracts in the respective contract.\n', '    * We assume that contractIds.length is small, so this won&#39;t run out of gas.\n', '    */\n', '    function setAllContracts() public onlyOwner {\n', '        FlightDelayControlledContract controlledContract;\n', '        // TODO: Check for upper bound for i\n', '        // i = 0 is FD.Owner, we skip this. // check!\n', '        for (uint i = 0; i < contractIds.length; i++) {\n', '            if (contracts[contractIds[i]].isControlled == true) {\n', '                controlledContract = FlightDelayControlledContract(contracts[contractIds[i]].addr);\n', '                controlledContract.setContracts();\n', '            }\n', '        }\n', '    }\n', '\n', '    function setOneContract(uint i) public onlyOwner {\n', '        FlightDelayControlledContract controlledContract;\n', '        // TODO: Check for upper bound for i\n', '        controlledContract = FlightDelayControlledContract(contracts[contractIds[i]].addr);\n', '        controlledContract.setContracts();\n', '    }\n', '\n', '    /**\n', '    * Destruct one contract.\n', '    * @param _id         ID of contract to destroy.\n', '    */\n', '    function destructOne(bytes32 _id) public onlyOwner {\n', '        address addr = getContract(_id);\n', '        if (addr != 0x0) {\n', '            FlightDelayControlledContract(addr).destruct();\n', '        }\n', '    }\n', '\n', '    /**\n', '    * Destruct all contracts.\n', '    * We assume that contractIds.length is small, so this won&#39;t run out of gas.\n', '    * Otherwise, you can still destroy one contract after the other with destructOne.\n', '    */\n', '    function destructAll() public onlyOwner {\n', '        // TODO: Check for upper bound for i\n', '        for (uint i = 0; i < contractIds.length; i++) {\n', '            if (contracts[contractIds[i]].isControlled == true) {\n', '                destructOne(contractIds[i]);\n', '            }\n', '        }\n', '\n', '        selfdestruct(owner);\n', '    }\n', '}']
['// File: contracts/FlightDelayConstants.sol\n', '\n', '/**\n', ' * FlightDelay with Oraclized Underwriting and Payout\n', ' *\n', ' * @description\tEvents and Constants\n', ' * @copyright (c) 2017 etherisc GmbH\n', ' * @author Christoph Mussenbrock\n', ' */\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', 'contract FlightDelayConstants {\n', '\n', '    /*\n', '    * General events\n', '    */\n', '\n', '// --> test-mode\n', '//        event LogUint(string _message, uint _uint);\n', '//        event LogUintEth(string _message, uint ethUint);\n', '//        event LogUintTime(string _message, uint timeUint);\n', '//        event LogInt(string _message, int _int);\n', '//        event LogAddress(string _message, address _address);\n', '//        event LogBytes32(string _message, bytes32 hexBytes32);\n', '//        event LogBytes(string _message, bytes hexBytes);\n', '//        event LogBytes32Str(string _message, bytes32 strBytes32);\n', '//        event LogString(string _message, string _string);\n', '//        event LogBool(string _message, bool _bool);\n', '//        event Log(address);\n', '// <-- test-mode\n', '\n', '    event LogPolicyApplied(\n', '        uint _policyId,\n', '        address _customer,\n', '        bytes32 strCarrierFlightNumber,\n', '        uint ethPremium\n', '    );\n', '    event LogPolicyAccepted(\n', '        uint _policyId,\n', '        uint _statistics0,\n', '        uint _statistics1,\n', '        uint _statistics2,\n', '        uint _statistics3,\n', '        uint _statistics4,\n', '        uint _statistics5\n', '    );\n', '    event LogPolicyPaidOut(\n', '        uint _policyId,\n', '        uint ethAmount\n', '    );\n', '    event LogPolicyExpired(\n', '        uint _policyId\n', '    );\n', '    event LogPolicyDeclined(\n', '        uint _policyId,\n', '        bytes32 strReason\n', '    );\n', '    event LogPolicyManualPayout(\n', '        uint _policyId,\n', '        bytes32 strReason\n', '    );\n', '    event LogSendFunds(\n', '        address _recipient,\n', '        uint8 _from,\n', '        uint ethAmount\n', '    );\n', '    event LogReceiveFunds(\n', '        address _sender,\n', '        uint8 _to,\n', '        uint ethAmount\n', '    );\n', '    event LogSendFail(\n', '        uint _policyId,\n', '        bytes32 strReason\n', '    );\n', '    event LogOraclizeCall(\n', '        uint _policyId,\n', '        bytes32 hexQueryId,\n', '        string _oraclizeUrl,\n', '        uint256 _oraclizeTime\n', '    );\n', '    event LogOraclizeCallback(\n', '        uint _policyId,\n', '        bytes32 hexQueryId,\n', '        string _result,\n', '        bytes hexProof\n', '    );\n', '    event LogSetState(\n', '        uint _policyId,\n', '        uint8 _policyState,\n', '        uint _stateTime,\n', '        bytes32 _stateMessage\n', '    );\n', '    event LogExternal(\n', '        uint256 _policyId,\n', '        address _address,\n', '        bytes32 _externalId\n', '    );\n', '\n', '    /*\n', '    * General constants\n', '    */\n', '    // contracts release version\n', '    uint public constant MAJOR_VERSION = 1;\n', '    uint public constant MINOR_VERSION = 0;\n', '    uint public constant PATCH_VERSION = 2;\n', '\n', '    // minimum observations for valid prediction\n', '    uint constant MIN_OBSERVATIONS = 10;\n', '    // minimum premium to cover costs\n', '    uint constant MIN_PREMIUM = 50 finney;\n', '    // maximum premium\n', '    uint constant MAX_PREMIUM = 1 ether;\n', '    // maximum payout\n', '    uint constant MAX_PAYOUT = 1100 finney;\n', '\n', '    uint constant MIN_PREMIUM_EUR = 1500 wei;\n', '    uint constant MAX_PREMIUM_EUR = 29000 wei;\n', '    uint constant MAX_PAYOUT_EUR = 30000 wei;\n', '\n', '    uint constant MIN_PREMIUM_USD = 1700 wei;\n', '    uint constant MAX_PREMIUM_USD = 34000 wei;\n', '    uint constant MAX_PAYOUT_USD = 35000 wei;\n', '\n', '    uint constant MIN_PREMIUM_GBP = 1300 wei;\n', '    uint constant MAX_PREMIUM_GBP = 25000 wei;\n', '    uint constant MAX_PAYOUT_GBP = 270 wei;\n', '\n', '    // maximum cumulated weighted premium per risk\n', '    uint constant MAX_CUMULATED_WEIGHTED_PREMIUM = 60 ether;\n', '    // 1 percent for DAO, 1 percent for maintainer\n', '    uint8 constant REWARD_PERCENT = 2;\n', '    // reserve for tail risks\n', '    uint8 constant RESERVE_PERCENT = 1;\n', '    // the weight pattern; in future versions this may become part of the policy struct.\n', "    // currently can't be constant because of compiler restrictions\n", '    // WEIGHT_PATTERN[0] is not used, just to be consistent\n', '    uint8[6] WEIGHT_PATTERN = [\n', '        0,\n', '        0,\n', '        0,\n', '        30,\n', '        50,\n', '        50\n', '    ];\n', '\n', '// --> prod-mode\n', '    // DEFINITIONS FOR ROPSTEN AND MAINNET\n', '    // minimum time before departure for applying\n', '    uint constant MIN_TIME_BEFORE_DEPARTURE\t= 24 hours; // for production\n', '    // check for delay after .. minutes after scheduled arrival\n', '    uint constant CHECK_PAYOUT_OFFSET = 15 minutes; // for production\n', '// <-- prod-mode\n', '\n', '// --> test-mode\n', '//        // DEFINITIONS FOR LOCAL TESTNET\n', '//        // minimum time before departure for applying\n', '//        uint constant MIN_TIME_BEFORE_DEPARTURE = 1 seconds; // for testing\n', '//        // check for delay after .. minutes after scheduled arrival\n', '//        uint constant CHECK_PAYOUT_OFFSET = 1 seconds; // for testing\n', '// <-- test-mode\n', '\n', '    // maximum duration of flight\n', '    uint constant MAX_FLIGHT_DURATION = 2 days;\n', '    // Deadline for acceptance of policies: 31.12.2030 (Testnet)\n', '    uint constant CONTRACT_DEAD_LINE = 1922396399;\n', '\n', '    // gas Constants for oraclize\n', '    uint constant ORACLIZE_GAS = 700000;\n', '    uint constant ORACLIZE_GASPRICE = 4000000000;\n', '\n', '\n', '    /*\n', '    * URLs and query strings for oraclize\n', '    */\n', '\n', '// --> prod-mode\n', '    // DEFINITIONS FOR ROPSTEN AND MAINNET\n', '    string constant ORACLIZE_RATINGS_BASE_URL =\n', '        // ratings api is v1, see https://developer.flightstats.com/api-docs/ratings/v1\n', '        "[URL] json(https://api.flightstats.com/flex/ratings/rest/v1/json/flight/";\n', '    string constant ORACLIZE_RATINGS_QUERY =\n', '        "?${[decrypt] BJoM0BfTe82RtghrzzCbNA7b9E9tQIX8LtM+pRRh22RfQ5QhnVAv6Kk4SyaMwQKczC7YtinJ/Xm6PZMgKnWN7+/pFUfI2YcxaAW0vYuXJF4zCTxPYXa6j4shhce60AMBeKoZZsgn6Og+olgSpgpfi4MwkmmytwdCLHqat3gGUPklBhM1HR0x}).ratings[0][\'observations\',\'late15\',\'late30\',\'late45\',\'cancelled\',\'diverted\',\'arrivalAirportFsCode\',\'departureAirportFsCode\']";\n', '    string constant ORACLIZE_STATUS_BASE_URL =\n', '        // flight status api is v2, see https://developer.flightstats.com/api-docs/flightstatus/v2/flight\n', '        "[URL] json(https://api.flightstats.com/flex/flightstatus/rest/v2/json/flight/status/";\n', '    string constant ORACLIZE_STATUS_QUERY =\n', '        // pattern:\n', '        "?${[decrypt] BA3YyqF4iMQszBawvgG82bqX3fw7JoWA1thFsboUECR/L8JkBCgvaThg1LcUWbIntosEKs/kvqyzOtvdQfMgjYPV0c6hsq/gKQkmJYILZmLY4SgBebH8g0qbfrrjxF5gEbfCi2qoR6PSxcQzKIjgd4HvAaumlQd4CkJLmY463ymqNN9B8/PL}&utc=true).flightStatuses[0][\'status\',\'delays\',\'operationalTimes\']";\n', '// <-- prod-mode\n', '\n', '// --> test-mode\n', '//        // DEFINITIONS FOR LOCAL TESTNET\n', '//        string constant ORACLIZE_RATINGS_BASE_URL =\n', '//            // ratings api is v1, see https://developer.flightstats.com/api-docs/ratings/v1\n', '//            "[URL] json(https://api-test.etherisc.com/flex/ratings/rest/v1/json/flight/";\n', '//        string constant ORACLIZE_RATINGS_QUERY =\n', '//            // for testrpc:\n', '//            ").ratings[0][\'observations\',\'late15\',\'late30\',\'late45\',\'cancelled\',\'diverted\',\'arrivalAirportFsCode\',\'departureAirportFsCode\']";\n', '//        string constant ORACLIZE_STATUS_BASE_URL =\n', '//            // flight status api is v2, see https://developer.flightstats.com/api-docs/flightstatus/v2/flight\n', '//            "[URL] json(https://api-test.etherisc.com/flex/flightstatus/rest/v2/json/flight/status/";\n', '//        string constant ORACLIZE_STATUS_QUERY =\n', '//            // for testrpc:\n', '//            "?utc=true).flightStatuses[0][\'status\',\'delays\',\'operationalTimes\']";\n', '// <-- test-mode\n', '}\n', '\n', '// File: contracts/FlightDelayControllerInterface.sol\n', '\n', '/**\n', ' * FlightDelay with Oraclized Underwriting and Payout\n', ' *\n', ' * @description Contract interface\n', ' * @copyright (c) 2017 etherisc GmbH\n', ' * @author Christoph Mussenbrock, Stephan Karpischek\n', ' */\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', 'contract FlightDelayControllerInterface {\n', '\n', '    function isOwner(address _addr) public returns (bool _isOwner);\n', '\n', '    function selfRegister(bytes32 _id) public returns (bool result);\n', '\n', '    function getContract(bytes32 _id) public returns (address _addr);\n', '}\n', '\n', '// File: contracts/FlightDelayDatabaseModel.sol\n', '\n', '/**\n', ' * FlightDelay with Oraclized Underwriting and Payout\n', ' *\n', ' * @description Database model\n', ' * @copyright (c) 2017 etherisc GmbH\n', ' * @author Christoph Mussenbrock, Stephan Karpischek\n', ' */\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', 'contract FlightDelayDatabaseModel {\n', '\n', '    // Ledger accounts.\n', '    enum Acc {\n', '        Premium,      // 0\n', '        RiskFund,     // 1\n', '        Payout,       // 2\n', '        Balance,      // 3\n', '        Reward,       // 4\n', '        OraclizeCosts // 5\n', '    }\n', '\n', '    // policy Status Codes and meaning:\n', '    //\n', '    // 00 = Applied:\t  the customer has payed a premium, but the oracle has\n', '    //\t\t\t\t\t        not yet checked and confirmed.\n', '    //\t\t\t\t\t        The customer can still revoke the policy.\n', '    // 01 = Accepted:\t  the oracle has checked and confirmed.\n', '    //\t\t\t\t\t        The customer can still revoke the policy.\n', '    // 02 = Revoked:\t  The customer has revoked the policy.\n', '    //\t\t\t\t\t        The premium minus cancellation fee is payed back to the\n', '    //\t\t\t\t\t        customer by the oracle.\n', '    // 03 = PaidOut:\t  The flight has ended with delay.\n', '    //\t\t\t\t\t        The oracle has checked and payed out.\n', '    // 04 = Expired:\t  The flight has endet with <15min. delay.\n', '    //\t\t\t\t\t        No payout.\n', '    // 05 = Declined:\t  The application was invalid.\n', '    //\t\t\t\t\t        The premium minus cancellation fee is payed back to the\n', '    //\t\t\t\t\t        customer by the oracle.\n', '    // 06 = SendFailed:\tDuring Revoke, Decline or Payout, sending ether failed\n', '    //\t\t\t\t\t        for unknown reasons.\n', '    //\t\t\t\t\t        The funds remain in the contracts RiskFund.\n', '\n', '\n', '    //                   00       01        02       03        04      05           06\n', '    enum policyState { Applied, Accepted, Revoked, PaidOut, Expired, Declined, SendFailed }\n', '\n', '    // oraclize callback types:\n', '    enum oraclizeState { ForUnderwriting, ForPayout }\n', '\n', '    //               00   01   02   03\n', '    enum Currency { ETH, EUR, USD, GBP }\n', '\n', '    // the policy structure: this structure keeps track of the individual parameters of a policy.\n', '    // typically customer address, premium and some status information.\n', '    struct Policy {\n', '        // 0 - the customer\n', '        address customer;\n', '\n', '        // 1 - premium\n', '        uint premium;\n', '        // risk specific parameters:\n', '        // 2 - pointer to the risk in the risks mapping\n', '        bytes32 riskId;\n', '        // custom payout pattern\n', '        // in future versions, customer will be able to tamper with this array.\n', '        // to keep things simple, we have decided to hard-code the array for all policies.\n', '        // uint8[5] pattern;\n', '        // 3 - probability weight. this is the central parameter\n', '        uint weight;\n', '        // 4 - calculated Payout\n', '        uint calculatedPayout;\n', '        // 5 - actual Payout\n', '        uint actualPayout;\n', '\n', '        // status fields:\n', '        // 6 - the state of the policy\n', '        policyState state;\n', '        // 7 - time of last state change\n', '        uint stateTime;\n', '        // 8 - state change message/reason\n', '        bytes32 stateMessage;\n', '        // 9 - TLSNotary Proof\n', '        bytes proof;\n', '        // 10 - Currency\n', '        Currency currency;\n', '        // 10 - External customer id\n', '        bytes32 customerExternalId;\n', '    }\n', '\n', '    // the risk structure; this structure keeps track of the risk-\n', '    // specific parameters.\n', '    // several policies can share the same risk structure (typically\n', '    // some people flying with the same plane)\n', '    struct Risk {\n', '        // 0 - Airline Code + FlightNumber\n', '        bytes32 carrierFlightNumber;\n', '        // 1 - scheduled departure and arrival time in the format /dep/YYYY/MM/DD\n', '        bytes32 departureYearMonthDay;\n', '        // 2 - the inital arrival time\n', '        uint arrivalTime;\n', '        // 3 - the final delay in minutes\n', '        uint delayInMinutes;\n', '        // 4 - the determined delay category (0-5)\n', '        uint8 delay;\n', '        // 5 - we limit the cumulated weighted premium to avoid cluster risks\n', '        uint cumulatedWeightedPremium;\n', '        // 6 - max cumulated Payout for this risk\n', '        uint premiumMultiplier;\n', '    }\n', '\n', '    // the oraclize callback structure: we use several oraclize calls.\n', '    // all oraclize calls will result in a common callback to __callback(...).\n', '    // to keep track of the different querys we have to introduce this struct.\n', '    struct OraclizeCallback {\n', '        // for which policy have we called?\n', '        uint policyId;\n', '        // for which purpose did we call? {ForUnderwrite | ForPayout}\n', '        oraclizeState oState;\n', '        // time\n', '        uint oraclizeTime;\n', '    }\n', '\n', '    struct Customer {\n', '        bytes32 customerExternalId;\n', '        bool identityConfirmed;\n', '    }\n', '}\n', '\n', '// File: contracts/FlightDelayControlledContract.sol\n', '\n', '/**\n', ' * FlightDelay with Oraclized Underwriting and Payout\n', ' *\n', ' * @description Controlled contract Interface\n', ' * @copyright (c) 2017 etherisc GmbH\n', ' * @author Christoph Mussenbrock\n', ' */\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', '\n', '\n', 'contract FlightDelayControlledContract is FlightDelayDatabaseModel {\n', '\n', '    address public controller;\n', '    FlightDelayControllerInterface FD_CI;\n', '\n', '    modifier onlyController() {\n', '        require(msg.sender == controller);\n', '        _;\n', '    }\n', '\n', '    function setController(address _controller) internal returns (bool _result) {\n', '        controller = _controller;\n', '        FD_CI = FlightDelayControllerInterface(_controller);\n', '        _result = true;\n', '    }\n', '\n', '    function destruct() public onlyController {\n', '        selfdestruct(controller);\n', '    }\n', '\n', '    function setContracts() public onlyController {}\n', '\n', '    function getContract(bytes32 _id) internal returns (address _addr) {\n', '        _addr = FD_CI.getContract(_id);\n', '    }\n', '}\n', '\n', '// File: contracts/Owned.sol\n', '\n', '/**\n', ' * FlightDelay with Oraclized Underwriting and Payout\n', ' *\n', ' * @description\tOwned pattern\n', ' * @copyright (c) 2017 etherisc GmbH\n', ' * @author Christoph Mussenbrock, Stephan Karpischek\n', ' */\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Owned {\n', '\n', '    address public owner;\n', '\n', '    /**\n', '     * @dev The Owned constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/FlightDelayController.sol\n', '\n', '/**\n', ' * FlightDelay with Oraclized Underwriting and Payout\n', ' *\n', ' * @description Controller contract\n', ' * @copyright (c) 2017 etherisc GmbH\n', ' * @author Christoph Mussenbrock\n', ' */\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', '\n', '\n', 'contract FlightDelayController is Owned, FlightDelayConstants {\n', '\n', '    struct Controller {\n', '        address addr;\n', '        bool isControlled;\n', '        bool isInitialized;\n', '    }\n', '\n', '    mapping (bytes32 => Controller) public contracts;\n', '    bytes32[] public contractIds;\n', '\n', '    /**\n', '    * Constructor.\n', '    */\n', '    function FlightDelayController() public {\n', '        registerContract(owner, "FD.Owner", false);\n', '        registerContract(address(this), "FD.Controller", false);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != address(0));\n', '        owner = _newOwner;\n', '        setContract(_newOwner, "FD.Owner", false);\n', '    }\n', '\n', '    /**\n', '    * Store address of one contract in mapping.\n', '    * @param _addr       Address of contract\n', '    * @param _id         ID of contract\n', '    */\n', '    function setContract(address _addr, bytes32 _id, bool _isControlled) internal {\n', '        contracts[_id].addr = _addr;\n', '        contracts[_id].isControlled = _isControlled;\n', '    }\n', '\n', '    /**\n', '    * Get contract address from ID. This function is called by the\n', "    * contract's setContracts function.\n", '    * @param _id         ID of contract\n', '    * @return The address of the contract.\n', '    */\n', '    function getContract(bytes32 _id) public returns (address _addr) {\n', '        _addr = contracts[_id].addr;\n', '    }\n', '\n', '    /**\n', '    * Registration of contracts.\n', '    * It will only accept calls of deployments initiated by the owner.\n', '    * @param _id         ID of contract\n', '    * @return  bool        success\n', '    */\n', '    function registerContract(address _addr, bytes32 _id, bool _isControlled) public onlyOwner returns (bool _result) {\n', '        setContract(_addr, _id, _isControlled);\n', '        contractIds.push(_id);\n', '        _result = true;\n', '    }\n', '\n', '    /**\n', '    * Deregister a contract.\n', '    * In future, contracts should be exchangeable.\n', '    * @param _id         ID of contract\n', '    * @return  bool        success\n', '    */\n', '    function deregister(bytes32 _id) public onlyOwner returns (bool _result) {\n', '        if (getContract(_id) == 0x0) {\n', '            return false;\n', '        }\n', '        setContract(0x0, _id, false);\n', '        _result = true;\n', '    }\n', '\n', '    /**\n', '    * After deploying all contracts, this function is called and calls\n', '    * setContracts() for every registered contract.\n', '    * This call pulls the addresses of the needed contracts in the respective contract.\n', "    * We assume that contractIds.length is small, so this won't run out of gas.\n", '    */\n', '    function setAllContracts() public onlyOwner {\n', '        FlightDelayControlledContract controlledContract;\n', '        // TODO: Check for upper bound for i\n', '        // i = 0 is FD.Owner, we skip this. // check!\n', '        for (uint i = 0; i < contractIds.length; i++) {\n', '            if (contracts[contractIds[i]].isControlled == true) {\n', '                controlledContract = FlightDelayControlledContract(contracts[contractIds[i]].addr);\n', '                controlledContract.setContracts();\n', '            }\n', '        }\n', '    }\n', '\n', '    function setOneContract(uint i) public onlyOwner {\n', '        FlightDelayControlledContract controlledContract;\n', '        // TODO: Check for upper bound for i\n', '        controlledContract = FlightDelayControlledContract(contracts[contractIds[i]].addr);\n', '        controlledContract.setContracts();\n', '    }\n', '\n', '    /**\n', '    * Destruct one contract.\n', '    * @param _id         ID of contract to destroy.\n', '    */\n', '    function destructOne(bytes32 _id) public onlyOwner {\n', '        address addr = getContract(_id);\n', '        if (addr != 0x0) {\n', '            FlightDelayControlledContract(addr).destruct();\n', '        }\n', '    }\n', '\n', '    /**\n', '    * Destruct all contracts.\n', "    * We assume that contractIds.length is small, so this won't run out of gas.\n", '    * Otherwise, you can still destroy one contract after the other with destructOne.\n', '    */\n', '    function destructAll() public onlyOwner {\n', '        // TODO: Check for upper bound for i\n', '        for (uint i = 0; i < contractIds.length; i++) {\n', '            if (contracts[contractIds[i]].isControlled == true) {\n', '                destructOne(contractIds[i]);\n', '            }\n', '        }\n', '\n', '        selfdestruct(owner);\n', '    }\n', '}']
