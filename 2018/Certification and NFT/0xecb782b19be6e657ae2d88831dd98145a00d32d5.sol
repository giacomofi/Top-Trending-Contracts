['pragma solidity 0.4.24;\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b, "mul overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 c = a / b;\n', '        // require(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "sub underflow");\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "add overflow");\n', '        return c;\n', '    }\n', '\n', '    function roundedDiv(uint a, uint b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 z = a / b;\n', '        if (a % b >= b / 2) {\n', '            z++;  // no need for safe add b/c it can happen only if we divided the input\n', '        }\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    Generic contract to authorise calls to certain functions only from a given address.\n', '    The address authorised must be a contract (multisig or not, depending on the permission), except for local test\n', '\n', '    deployment works as:\n', '           1. contract deployer account deploys contracts\n', '           2. constructor grants "PermissionGranter" permission to deployer account\n', '           3. deployer account executes initial setup (no multiSig)\n', '           4. deployer account grants PermissionGranter permission for the MultiSig contract\n', '                (e.g. StabilityBoardProxy or PreTokenProxy)\n', '           5. deployer account revokes its own PermissionGranter permission\n', '*/\n', '\n', 'contract Restricted {\n', '\n', '    // NB: using bytes32 rather than the string type because it&#39;s cheaper gas-wise:\n', '    mapping (address => mapping (bytes32 => bool)) public permissions;\n', '\n', '    event PermissionGranted(address indexed agent, bytes32 grantedPermission);\n', '    event PermissionRevoked(address indexed agent, bytes32 revokedPermission);\n', '\n', '    modifier restrict(bytes32 requiredPermission) {\n', '        require(permissions[msg.sender][requiredPermission], "msg.sender must have permission");\n', '        _;\n', '    }\n', '\n', '    constructor(address permissionGranterContract) public {\n', '        require(permissionGranterContract != address(0), "permissionGranterContract must be set");\n', '        permissions[permissionGranterContract]["PermissionGranter"] = true;\n', '        emit PermissionGranted(permissionGranterContract, "PermissionGranter");\n', '    }\n', '\n', '    function grantPermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = true;\n', '        emit PermissionGranted(agent, requiredPermission);\n', '    }\n', '\n', '    function grantMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            grantPermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '    function revokePermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = false;\n', '        emit PermissionRevoked(agent, requiredPermission);\n', '    }\n', '\n', '    function revokeMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            revokePermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', '/* Augmint pretoken contract to record agreements and tokens allocated based on the agreement.\n', '\n', '    Important: this is NOT an ERC20 token!\n', '\n', '    PreTokens are non-fungible: agreements can have different conditions (valuationCap and discount)\n', '        and pretokens are not tradable.\n', '\n', '    Ownership can be transferred if owner wants to change wallet but the whole agreement and\n', '        the total pretoken amount is moved to a new account\n', '\n', '    PreTokenSigner can (via MultiSig):\n', '      - add agreements and issue pretokens to an agreement\n', '      - change owner of any agreement to handle if an owner lost a private keys\n', '      - burn pretokens from any agreement to fix potential erroneous issuance\n', '    These are known compromises on trustlessness hence all these tokens distributed based on signed agreements and\n', '        preTokens are issued only to a closed group of contributors / team members.\n', '    If despite these something goes wrong then as a last resort a new pretoken contract can be recreated from agreements.\n', '\n', '    Some ERC20 functions are implemented so agreement owners can see their balances and use transfer in standard wallets.\n', '    Restrictions:\n', '      - only total balance can be transfered - effectively ERC20 transfer used to transfer agreement ownership\n', '      - only agreement holders can transfer\n', '        (i.e. can&#39;t transfer 0 amount if have no agreement to avoid polluting logs with Transfer events)\n', '      - transfer is only allowed to accounts without an agreement yet\n', '      - no approval and transferFrom ERC20 functions\n', ' */\n', '\n', 'contract PreToken is Restricted {\n', '    using SafeMath for uint256;\n', '\n', '    uint public constant CHUNK_SIZE = 100;\n', '\n', '    string constant public name = "Augmint pretokens"; // solhint-disable-line const-name-snakecase\n', '    string constant public symbol = "APRE"; // solhint-disable-line const-name-snakecase\n', '    uint8 constant public decimals = 0; // solhint-disable-line const-name-snakecase\n', '\n', '    uint public totalSupply;\n', '\n', '    struct Agreement {\n', '        address owner;\n', '        uint balance;\n', '        uint32 discount; //  discountRate in parts per million , ie. 10,000 = 1%\n', '        uint32 valuationCap; // in USD (no decimals)\n', '    }\n', '\n', '    /* Agreement hash is the SHA-2 (SHA-256) hash of signed agreement document.\n', '         To generate:\n', '            OSX: shasum -a 256 agreement.pdf\n', '            Windows: certUtil -hashfile agreement.pdf SHA256 */\n', '    mapping(address => bytes32) public agreementOwners; // to lookup agrement by owner\n', '    mapping(bytes32 => Agreement) public agreements;\n', '\n', '    bytes32[] public allAgreements; // all agreements to able to iterate over\n', '\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '\n', '    event NewAgreement(address owner, bytes32 agreementHash, uint32 discount, uint32 valuationCap);\n', '\n', '    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    function addAgreement(address owner, bytes32 agreementHash, uint32 discount, uint32 valuationCap)\n', '    external restrict("PreTokenSigner") {\n', '        require(owner != address(0), "owner must not be 0x0");\n', '        require(agreementOwners[owner] == 0x0, "owner must not have an aggrement yet");\n', '        require(agreementHash != 0x0, "agreementHash must not be 0x0");\n', '        require(discount > 0, "discount must be > 0");\n', '        require(agreements[agreementHash].discount == 0, "agreement must not exist yet");\n', '\n', '        agreements[agreementHash] = Agreement(owner, 0, discount, valuationCap);\n', '        agreementOwners[owner] = agreementHash;\n', '        allAgreements.push(agreementHash);\n', '\n', '        emit NewAgreement(owner, agreementHash, discount, valuationCap);\n', '    }\n', '\n', '    function issueTo(bytes32 agreementHash, uint amount) external restrict("PreTokenSigner") {\n', '        Agreement storage agreement = agreements[agreementHash];\n', '        require(agreement.discount > 0, "agreement must exist");\n', '\n', '        agreement.balance = agreement.balance.add(amount);\n', '        totalSupply = totalSupply.add(amount);\n', '\n', '        emit Transfer(0x0, agreement.owner, amount);\n', '    }\n', '\n', '    /* Restricted function to allow pretoken signers to fix incorrect issuance */\n', '    function burnFrom(bytes32 agreementHash, uint amount)\n', '    public restrict("PreTokenSigner") returns (bool) {\n', '        Agreement storage agreement = agreements[agreementHash];\n', '        require(agreement.discount > 0, "agreement must exist"); // this is redundant b/c of next requires but be explicit\n', '        require(amount > 0, "burn amount must be > 0");\n', '        require(agreement.balance >= amount, "must not burn more than balance"); // .sub would revert anyways but emit reason\n', '\n', '        agreement.balance = agreement.balance.sub(amount);\n', '        totalSupply = totalSupply.sub(amount);\n', '\n', '        emit Transfer(agreement.owner, 0x0, amount);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address owner) public view returns (uint) {\n', '        return agreements[agreementOwners[owner]].balance;\n', '    }\n', '\n', '    /* function to transfer agreement ownership to other wallet by owner\n', '        it&#39;s in ERC20 form so owners can use standard ERC20 wallet just need to pass full balance as value */\n', '    function transfer(address to, uint amount) public returns (bool) { // solhint-disable-line no-simple-event-func-name\n', '        require(amount == agreements[agreementOwners[msg.sender]].balance, "must transfer full balance");\n', '        _transfer(msg.sender, to);\n', '        return true;\n', '    }\n', '\n', '    /* Restricted function to allow pretoken signers to fix if pretoken owner lost keys */\n', '    function transferAgreement(bytes32 agreementHash, address to)\n', '    public restrict("PreTokenSigner") returns (bool) {\n', '        _transfer(agreements[agreementHash].owner, to);\n', '        return true;\n', '    }\n', '\n', '    /* private function used by transferAgreement & transfer */\n', '    function _transfer(address from, address to) private {\n', '        Agreement storage agreement = agreements[agreementOwners[from]];\n', '        require(agreementOwners[from] != 0x0, "from agreement must exists");\n', '        require(agreementOwners[to] == 0, "to must not have an agreement");\n', '        require(to != 0x0, "must not transfer to 0x0");\n', '\n', '        agreement.owner = to;\n', '\n', '        agreementOwners[to] = agreementOwners[from];\n', '        agreementOwners[from] = 0x0;\n', '\n', '        emit Transfer(from, to, agreement.balance);\n', '    }\n', '\n', '    function getAgreementsCount() external view returns (uint agreementsCount) {\n', '        return allAgreements.length;\n', '    }\n', '\n', '    // UI helper fx - Returns all agreements from offset as\n', '    // [index in allAgreements, account address as uint, balance, agreementHash as uint,\n', '    //          discount as uint, valuationCap as uint ]\n', '    function getAllAgreements(uint offset) external view returns(uint[6][CHUNK_SIZE] agreementsResult) {\n', '\n', '        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < allAgreements.length; i++) {\n', '            bytes32 agreementHash = allAgreements[i + offset];\n', '            Agreement storage agreement = agreements[agreementHash];\n', '\n', '            agreementsResult[i] = [ i + offset, uint(agreement.owner), agreement.balance,\n', '                uint(agreementHash), uint(agreement.discount), uint(agreement.valuationCap)];\n', '        }\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b, "mul overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 c = a / b;\n', "        // require(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "sub underflow");\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "add overflow");\n', '        return c;\n', '    }\n', '\n', '    function roundedDiv(uint a, uint b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 z = a / b;\n', '        if (a % b >= b / 2) {\n', '            z++;  // no need for safe add b/c it can happen only if we divided the input\n', '        }\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    Generic contract to authorise calls to certain functions only from a given address.\n', '    The address authorised must be a contract (multisig or not, depending on the permission), except for local test\n', '\n', '    deployment works as:\n', '           1. contract deployer account deploys contracts\n', '           2. constructor grants "PermissionGranter" permission to deployer account\n', '           3. deployer account executes initial setup (no multiSig)\n', '           4. deployer account grants PermissionGranter permission for the MultiSig contract\n', '                (e.g. StabilityBoardProxy or PreTokenProxy)\n', '           5. deployer account revokes its own PermissionGranter permission\n', '*/\n', '\n', 'contract Restricted {\n', '\n', "    // NB: using bytes32 rather than the string type because it's cheaper gas-wise:\n", '    mapping (address => mapping (bytes32 => bool)) public permissions;\n', '\n', '    event PermissionGranted(address indexed agent, bytes32 grantedPermission);\n', '    event PermissionRevoked(address indexed agent, bytes32 revokedPermission);\n', '\n', '    modifier restrict(bytes32 requiredPermission) {\n', '        require(permissions[msg.sender][requiredPermission], "msg.sender must have permission");\n', '        _;\n', '    }\n', '\n', '    constructor(address permissionGranterContract) public {\n', '        require(permissionGranterContract != address(0), "permissionGranterContract must be set");\n', '        permissions[permissionGranterContract]["PermissionGranter"] = true;\n', '        emit PermissionGranted(permissionGranterContract, "PermissionGranter");\n', '    }\n', '\n', '    function grantPermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = true;\n', '        emit PermissionGranted(agent, requiredPermission);\n', '    }\n', '\n', '    function grantMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            grantPermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '    function revokePermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = false;\n', '        emit PermissionRevoked(agent, requiredPermission);\n', '    }\n', '\n', '    function revokeMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            revokePermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', '/* Augmint pretoken contract to record agreements and tokens allocated based on the agreement.\n', '\n', '    Important: this is NOT an ERC20 token!\n', '\n', '    PreTokens are non-fungible: agreements can have different conditions (valuationCap and discount)\n', '        and pretokens are not tradable.\n', '\n', '    Ownership can be transferred if owner wants to change wallet but the whole agreement and\n', '        the total pretoken amount is moved to a new account\n', '\n', '    PreTokenSigner can (via MultiSig):\n', '      - add agreements and issue pretokens to an agreement\n', '      - change owner of any agreement to handle if an owner lost a private keys\n', '      - burn pretokens from any agreement to fix potential erroneous issuance\n', '    These are known compromises on trustlessness hence all these tokens distributed based on signed agreements and\n', '        preTokens are issued only to a closed group of contributors / team members.\n', '    If despite these something goes wrong then as a last resort a new pretoken contract can be recreated from agreements.\n', '\n', '    Some ERC20 functions are implemented so agreement owners can see their balances and use transfer in standard wallets.\n', '    Restrictions:\n', '      - only total balance can be transfered - effectively ERC20 transfer used to transfer agreement ownership\n', '      - only agreement holders can transfer\n', "        (i.e. can't transfer 0 amount if have no agreement to avoid polluting logs with Transfer events)\n", '      - transfer is only allowed to accounts without an agreement yet\n', '      - no approval and transferFrom ERC20 functions\n', ' */\n', '\n', 'contract PreToken is Restricted {\n', '    using SafeMath for uint256;\n', '\n', '    uint public constant CHUNK_SIZE = 100;\n', '\n', '    string constant public name = "Augmint pretokens"; // solhint-disable-line const-name-snakecase\n', '    string constant public symbol = "APRE"; // solhint-disable-line const-name-snakecase\n', '    uint8 constant public decimals = 0; // solhint-disable-line const-name-snakecase\n', '\n', '    uint public totalSupply;\n', '\n', '    struct Agreement {\n', '        address owner;\n', '        uint balance;\n', '        uint32 discount; //  discountRate in parts per million , ie. 10,000 = 1%\n', '        uint32 valuationCap; // in USD (no decimals)\n', '    }\n', '\n', '    /* Agreement hash is the SHA-2 (SHA-256) hash of signed agreement document.\n', '         To generate:\n', '            OSX: shasum -a 256 agreement.pdf\n', '            Windows: certUtil -hashfile agreement.pdf SHA256 */\n', '    mapping(address => bytes32) public agreementOwners; // to lookup agrement by owner\n', '    mapping(bytes32 => Agreement) public agreements;\n', '\n', '    bytes32[] public allAgreements; // all agreements to able to iterate over\n', '\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '\n', '    event NewAgreement(address owner, bytes32 agreementHash, uint32 discount, uint32 valuationCap);\n', '\n', '    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    function addAgreement(address owner, bytes32 agreementHash, uint32 discount, uint32 valuationCap)\n', '    external restrict("PreTokenSigner") {\n', '        require(owner != address(0), "owner must not be 0x0");\n', '        require(agreementOwners[owner] == 0x0, "owner must not have an aggrement yet");\n', '        require(agreementHash != 0x0, "agreementHash must not be 0x0");\n', '        require(discount > 0, "discount must be > 0");\n', '        require(agreements[agreementHash].discount == 0, "agreement must not exist yet");\n', '\n', '        agreements[agreementHash] = Agreement(owner, 0, discount, valuationCap);\n', '        agreementOwners[owner] = agreementHash;\n', '        allAgreements.push(agreementHash);\n', '\n', '        emit NewAgreement(owner, agreementHash, discount, valuationCap);\n', '    }\n', '\n', '    function issueTo(bytes32 agreementHash, uint amount) external restrict("PreTokenSigner") {\n', '        Agreement storage agreement = agreements[agreementHash];\n', '        require(agreement.discount > 0, "agreement must exist");\n', '\n', '        agreement.balance = agreement.balance.add(amount);\n', '        totalSupply = totalSupply.add(amount);\n', '\n', '        emit Transfer(0x0, agreement.owner, amount);\n', '    }\n', '\n', '    /* Restricted function to allow pretoken signers to fix incorrect issuance */\n', '    function burnFrom(bytes32 agreementHash, uint amount)\n', '    public restrict("PreTokenSigner") returns (bool) {\n', '        Agreement storage agreement = agreements[agreementHash];\n', '        require(agreement.discount > 0, "agreement must exist"); // this is redundant b/c of next requires but be explicit\n', '        require(amount > 0, "burn amount must be > 0");\n', '        require(agreement.balance >= amount, "must not burn more than balance"); // .sub would revert anyways but emit reason\n', '\n', '        agreement.balance = agreement.balance.sub(amount);\n', '        totalSupply = totalSupply.sub(amount);\n', '\n', '        emit Transfer(agreement.owner, 0x0, amount);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address owner) public view returns (uint) {\n', '        return agreements[agreementOwners[owner]].balance;\n', '    }\n', '\n', '    /* function to transfer agreement ownership to other wallet by owner\n', "        it's in ERC20 form so owners can use standard ERC20 wallet just need to pass full balance as value */\n", '    function transfer(address to, uint amount) public returns (bool) { // solhint-disable-line no-simple-event-func-name\n', '        require(amount == agreements[agreementOwners[msg.sender]].balance, "must transfer full balance");\n', '        _transfer(msg.sender, to);\n', '        return true;\n', '    }\n', '\n', '    /* Restricted function to allow pretoken signers to fix if pretoken owner lost keys */\n', '    function transferAgreement(bytes32 agreementHash, address to)\n', '    public restrict("PreTokenSigner") returns (bool) {\n', '        _transfer(agreements[agreementHash].owner, to);\n', '        return true;\n', '    }\n', '\n', '    /* private function used by transferAgreement & transfer */\n', '    function _transfer(address from, address to) private {\n', '        Agreement storage agreement = agreements[agreementOwners[from]];\n', '        require(agreementOwners[from] != 0x0, "from agreement must exists");\n', '        require(agreementOwners[to] == 0, "to must not have an agreement");\n', '        require(to != 0x0, "must not transfer to 0x0");\n', '\n', '        agreement.owner = to;\n', '\n', '        agreementOwners[to] = agreementOwners[from];\n', '        agreementOwners[from] = 0x0;\n', '\n', '        emit Transfer(from, to, agreement.balance);\n', '    }\n', '\n', '    function getAgreementsCount() external view returns (uint agreementsCount) {\n', '        return allAgreements.length;\n', '    }\n', '\n', '    // UI helper fx - Returns all agreements from offset as\n', '    // [index in allAgreements, account address as uint, balance, agreementHash as uint,\n', '    //          discount as uint, valuationCap as uint ]\n', '    function getAllAgreements(uint offset) external view returns(uint[6][CHUNK_SIZE] agreementsResult) {\n', '\n', '        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < allAgreements.length; i++) {\n', '            bytes32 agreementHash = allAgreements[i + offset];\n', '            Agreement storage agreement = agreements[agreementHash];\n', '\n', '            agreementsResult[i] = [ i + offset, uint(agreement.owner), agreement.balance,\n', '                uint(agreementHash), uint(agreement.discount), uint(agreement.valuationCap)];\n', '        }\n', '    }\n', '}']
