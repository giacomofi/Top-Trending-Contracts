['pragma solidity ^0.4.24;\n', '\n', '// File: ..\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: ..\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '}\n', '\n', '// File: ..\\openzeppelin-solidity\\contracts\\lifecycle\\Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: contracts\\HorseyExchange.sol\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Basic {\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '    function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '}\n', '\n', '/**\n', '    @dev HorseyExchange contract - handles horsey market exchange which\n', '    includes the following set of functions:\n', '    1. Deposit to Exchange\n', '    2. Cancel sale\n', '    3. Purchase token\n', '**/\n', 'contract HorseyExchange is Pausable { //also Ownable\n', '\n', '    using SafeMath for uint256;\n', '\n', '    event HorseyDeposit(uint256 tokenId, uint256 price);\n', '    event SaleCanceled(uint256 tokenId);\n', '    event HorseyPurchased(uint256 tokenId, address newOwner, uint256 totalToPay);\n', '\n', '    /// @dev Fee applied to market maker - measured as percentage\n', '    uint256 public marketMakerFee = 3;\n', '\n', '    /// @dev Amount collected in fees\n', '    uint256 collectedFees = 0;\n', '\n', '    /// @dev  RoyalStables TOKEN\n', '    ERC721Basic public token;\n', '\n', '    /**\n', '        @dev used to store the price and the owner address of a token on sale\n', '    */\n', '    struct SaleData {\n', '        uint256 price;\n', '        address owner;\n', '    }\n', '\n', '    /// @dev Market spec to lookup price and original owner based on token id\n', '    mapping (uint256 => SaleData) market;\n', '\n', '    /// @dev mapping of current tokens on market by owner\n', '    mapping (address => uint256[]) userBarn;\n', '\n', '    /// @dev initialize\n', '    constructor() Pausable() public {\n', '    }\n', '\n', '    /**\n', '        @dev Since the exchange requires the horsey contract and horsey contract\n', '            requires exchange address, we cant initialize both of them in constructors\n', '        @param _token Address of the stables contract\n', '    */\n', '    function setStables(address _token) external\n', '    onlyOwner()\n', '    {\n', '        require(address(_token) != 0,"Address of token is zero");\n', '        token = ERC721Basic(_token);\n', '    }\n', '\n', '    /**\n', '        @dev Allows the owner to change market fees\n', '        @param fees The new fees to apply (can be zero)\n', '    */\n', '    function setMarketFees(uint256 fees) external\n', '    onlyOwner()\n', '    {\n', '        marketMakerFee = fees;\n', '    }\n', '\n', '    /// @return the tokens on sale based on the user address\n', '    function getTokensOnSale(address user) external view returns(uint256[]) {\n', '        return userBarn[user];\n', '    }\n', '\n', '    /// @return the token price with the fees\n', '    function getTokenPrice(uint256 tokenId) public view\n', '    isOnMarket(tokenId) returns (uint256) {\n', '        return market[tokenId].price + (market[tokenId].price.div(100).mul(marketMakerFee));\n', '    }\n', '\n', '    /**\n', '        @dev User sends token to sell to exchange - at this point the exchange contract takes\n', '            ownership, but will map token ownership back to owner for auotmated withdraw on\n', '            cancel - requires that user is the rightful owner and is not\n', '            asking for a null price\n', '    */\n', '    function depositToExchange(uint256 tokenId, uint256 price) external\n', '    whenNotPaused()\n', '    isTokenOwner(tokenId)\n', '    nonZeroPrice(price)\n', '    tokenAvailable() {\n', '        require(token.getApproved(tokenId) == address(this),"Exchange is not allowed to transfer");\n', '        //Transfers token from depositee to exchange (contract address)\n', '        token.transferFrom(msg.sender, address(this), tokenId);\n', '        \n', '        //add the token to the market\n', '        market[tokenId] = SaleData(price,msg.sender);\n', '\n', '        //Add token to exchange map - tracking by owner of all tokens\n', '        userBarn[msg.sender].push(tokenId);\n', '\n', '        emit HorseyDeposit(tokenId, price);\n', '    }\n', '\n', '    /**\n', '        @dev Allows true owner of token to cancel sale at anytime\n', '        @param tokenId ID of the token to remove from the market\n', '        @return true if user still has tokens for sale\n', '    */\n', '    function cancelSale(uint256 tokenId) external \n', '    whenNotPaused()\n', '    originalOwnerOf(tokenId) \n', '    tokenAvailable() returns (bool) {\n', '        //throws on fail - transfers token from exchange back to original owner\n', '        token.transferFrom(address(this),msg.sender,tokenId);\n', '        \n', '        //Reset token on market - remove\n', '        delete market[tokenId];\n', '\n', '        //Reset barn tracker for user\n', '        _removeTokenFromBarn(tokenId, msg.sender);\n', '\n', '        emit SaleCanceled(tokenId);\n', '\n', '        //Return true if this user is still &#39;active&#39; within the exchange\n', '        //This will help with client side actions\n', '        return userBarn[msg.sender].length > 0;\n', '    }\n', '\n', '    /**\n', '        @dev Performs the purchase of a token that is present on the market - this includes checking that the\n', '            proper amount is sent + appliced fee, updating seller&#39;s balance, updated collected fees and\n', '            transfering token to buyer\n', '            Only market tokens can be purchased\n', '        @param tokenId ID of the token we wish to purchase\n', '    */\n', '    function purchaseToken(uint256 tokenId) external payable \n', '    whenNotPaused()\n', '    isOnMarket(tokenId) \n', '    tokenAvailable()\n', '    notOriginalOwnerOf(tokenId)\n', '    {\n', '        //Did the sender accidently pay over? - if so track the amount over\n', '        uint256 totalToPay = getTokenPrice(tokenId);\n', '        require(msg.value >= totalToPay, "Not paying enough");\n', '\n', '        //fetch this tokens sale data\n', '        SaleData memory sale = market[tokenId];\n', '\n', '        //Add to collected fee amount payable to DEVS\n', '        collectedFees += totalToPay - sale.price;\n', '\n', '        //pay the seller\n', '        sale.owner.transfer(sale.price);\n', '\n', '        //Reset barn tracker for user\n', '        _removeTokenFromBarn(tokenId,  sale.owner);\n', '\n', '        //Reset token on market - remove\n', '        delete market[tokenId];\n', '\n', '        //Transfer the ERC721 to the buyer - we leave the sale amount\n', '        //to be withdrawn by the user (transferred from exchange)\n', '        token.transferFrom(address(this), msg.sender, tokenId);\n', '\n', '        //Return over paid amount to sender if necessary\n', '        if(msg.value > totalToPay) //overpaid\n', '        {\n', '            msg.sender.transfer(msg.value.sub(totalToPay));\n', '        }\n', '\n', '        emit HorseyPurchased(tokenId, msg.sender, totalToPay);\n', '    }\n', '\n', '    /// @dev Transfers the collected fees to the owner\n', '    function withdraw() external\n', '    onlyOwner()\n', '    {\n', '        assert(collectedFees <= address(this).balance);\n', '        owner.transfer(collectedFees);\n', '        collectedFees = 0;\n', '    }\n', '\n', '    /**\n', '        @dev Internal function to remove a token from the users barn array\n', '        @param tokenId ID of the token to remove\n', '        @param barnAddress Address of the user selling tokens\n', '    */\n', '    function _removeTokenFromBarn(uint tokenId, address barnAddress)  internal {\n', '        uint256[] storage barnArray = userBarn[barnAddress];\n', '        require(barnArray.length > 0,"No tokens to remove");\n', '        int index = _indexOf(tokenId, barnArray);\n', '        require(index >= 0, "Token not found in barn");\n', '\n', '        // Shift entire array :(\n', '        for (uint256 i = uint256(index); i<barnArray.length-1; i++){\n', '            barnArray[i] = barnArray[i+1];\n', '        }\n', '\n', '        // Remove element, update length, return array\n', '        // this should be enough since https://ethereum.stackexchange.com/questions/1527/how-to-delete-an-element-at-a-certain-index-in-an-array\n', '        barnArray.length--;\n', '    }\n', '\n', '    /**\n', '        @dev Helper function which stores in memory an array which is passed in, and\n', '        @param item element we are looking for\n', '        @param array the array to look into\n', '        @return the index of the item of interest\n', '    */\n', '    function _indexOf(uint item, uint256[] memory array) internal pure returns (int256){\n', '\n', '        //Iterate over array to find indexOf(token)\n', '        for(uint256 i = 0; i < array.length; i++){\n', '            if(array[i] == item){\n', '                return int256(i);\n', '            }\n', '        }\n', '\n', '        //Item not found\n', '        return -1;\n', '    }\n', '\n', '    /// @dev requires token to be on the market = current owner is exchange\n', '    modifier isOnMarket(uint256 tokenId) {\n', '        require(token.ownerOf(tokenId) == address(this),"Token not on market");\n', '        _;\n', '    }\n', '    \n', '    /// @dev Is the user the owner of this token?\n', '    modifier isTokenOwner(uint256 tokenId) {\n', '        require(token.ownerOf(tokenId) == msg.sender,"Not tokens owner");\n', '        _;\n', '    }\n', '\n', '    /// @dev Is this the original owner of the token - at exchange level\n', '    modifier originalOwnerOf(uint256 tokenId) {\n', '        require(market[tokenId].owner == msg.sender,"Not the original owner of");\n', '        _;\n', '    }\n', '\n', '    /// @dev Is this the original owner of the token - at exchange level\n', '    modifier notOriginalOwnerOf(uint256 tokenId) {\n', '        require(market[tokenId].owner != msg.sender,"Is the original owner");\n', '        _;\n', '    }\n', '\n', '    /// @dev Is a nonzero price being sent?\n', '    modifier nonZeroPrice(uint256 price){\n', '        require(price > 0,"Price is zero");\n', '        _;\n', '    }\n', '\n', '    /// @dev Do we have a token address\n', '    modifier tokenAvailable(){\n', '        require(address(token) != 0,"Token address not set");\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts\\EthorseHelpers.sol\n', '\n', 'contract BettingControllerInterface {\n', '    address public owner;\n', '}\n', '/**\n', '    @title Race contract - used for linking ethorse Race struct \n', '    @dev This interface is losely based on ethorse race contract\n', '*/\n', 'contract EthorseRace {\n', '\n', '    //Encapsulation of racing information \n', '    struct chronus_info {\n', '        bool  betting_open; // boolean: check if betting is open\n', '        bool  race_start; //boolean: check if race has started\n', '        bool  race_end; //boolean: check if race has ended\n', '        bool  voided_bet; //boolean: check if race has been voided\n', '        uint32  starting_time; // timestamp of when the race starts\n', '        uint32  betting_duration;\n', '        uint32  race_duration; // duration of the race\n', '        uint32 voided_timestamp;\n', '    }\n', '\n', '    address public owner;\n', '    \n', '    //Point to racing information\n', '    chronus_info public chronus;\n', '\n', '    //Coin index mapping to flag - true if index is winner\n', '    mapping (bytes32 => bool) public winner_horse;\n', '    /*\n', '            // exposing the coin pool details for DApp\n', '    function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint) {\n', '        return (coinIndex[index].total, coinIndex[index].pre, coinIndex[index].post, coinIndex[index].price_check, voterIndex[candidate].bets[index]);\n', '    }\n', '    */\n', '    // exposing the coin pool details for DApp\n', '    function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint);\n', '}\n', '\n', '/**\n', '    @title API contract - used to connect with Race contract and \n', '        encapsulate race information for token inidices and winner\n', '        checking.\n', '*/\n', 'contract EthorseHelpers {\n', '\n', '    /// @dev Convert all symbols to bytes array\n', '    bytes32[] public all_horses = [bytes32("BTC"),bytes32("ETH"),bytes32("LTC")];\n', '    mapping(address => bool) private _legitOwners;\n', '\n', '    /// @dev Used to add new symbol to the bytes array \n', '    function _addHorse(bytes32 newHorse) internal {\n', '        all_horses.push(newHorse);\n', '    }\n', '\n', '    function _addLegitOwner(address newOwner) internal\n', '    {\n', '        _legitOwners[newOwner] = true;\n', '    }\n', '\n', '    function getall_horsesCount() public view returns(uint) {\n', '        return all_horses.length;\n', '    }\n', '\n', '    /**\n', '        @param raceAddress - address of this race\n', '        @param eth_address - user&#39;s ethereum wallet address\n', '        @return true if user is winner + name of the winning horse (LTC,BTC,ETH,...)\n', '    */\n', '    function _isWinnerOf(address raceAddress, address eth_address) internal view returns (bool,bytes32)\n', '    {\n', '        //acquire race, fails if doesnt exist\n', '        EthorseRace race = EthorseRace(raceAddress);\n', '        //acquire races betting controller\n', '        BettingControllerInterface bc = BettingControllerInterface(race.owner());\n', '        //make sure the betting controllers owner is in the legit list given by devs\n', '        require(_legitOwners[bc.owner()]);\n', '        //acquire chronus\n', '        bool  voided_bet; //boolean: check if race has been voided\n', '        bool  race_end; //boolean: check if race has ended\n', '        (,,race_end,voided_bet,,,,) = race.chronus();\n', '\n', '        //cant be winner if race was refunded or didnt end yet\n', '        if(voided_bet || !race_end)\n', '            return (false,bytes32(0));\n', '\n', '        //aquire winner race index\n', '        bytes32 horse;\n', '        bool found = false;\n', '        uint256 arrayLength = all_horses.length;\n', '\n', '        //Iterate over coin symbols to find winner - tie could be possible?\n', '        for(uint256 i = 0; i < arrayLength; i++)\n', '        {\n', '            if(race.winner_horse(all_horses[i])) {\n', '                horse = all_horses[i];\n', '                found = true;\n', '                break;\n', '            }\n', '        }\n', '        //no winner horse? shouldnt happen unless this horse isnt registered\n', '        if(!found)\n', '            return (false,bytes32(0));\n', '\n', '        //check the bet amount of the eth_address on the winner horse\n', '        uint256 bet_amount = 0;\n', '        if(eth_address != address(0)) {\n', '            (,,,, bet_amount) = race.getCoinIndex(horse, eth_address);\n', '        }\n', '        \n', '        //winner if the eth_address had a bet > 0 on the winner horse\n', '        return (bet_amount > 0, horse);\n', '    }\n', '}\n', '\n', '// File: contracts\\HorseyToken.sol\n', '\n', 'contract RoyalStablesInterface {\n', '    \n', '    struct Horsey {\n', '        address race;\n', '        bytes32 dna;\n', '        uint8 feedingCounter;\n', '        uint8 tier;\n', '    }\n', '\n', '    mapping(uint256 => Horsey) public horseys;\n', '    mapping(address => uint32) public carrot_credits;\n', '    mapping(uint256 => string) public names;\n', '    address public master;\n', '\n', '    function getOwnedTokens(address eth_address) public view returns (uint256[]);\n', '    function storeName(uint256 tokenId, string newName) public;\n', '    function storeCarrotsCredit(address client, uint32 amount) public;\n', '    function storeHorsey(address client, uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public;\n', '    function modifyHorsey(uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public;\n', '    function modifyHorseyDna(uint256 tokenId, bytes32 dna) public;\n', '    function modifyHorseyFeedingCounter(uint256 tokenId, uint8 feedingCounter) public;\n', '    function modifyHorseyTier(uint256 tokenId, uint8 tier) public;\n', '    function unstoreHorsey(uint256 tokenId) public;\n', '    function ownerOf(uint256 tokenId) public returns (address);\n', '}\n', '\n', '/**\n', '    @title HorseyToken ERC721 Token\n', '    @dev Horse contract - horse derives fro AccessManager built on top of ERC721 token and uses \n', '    @dev EthorseHelpers and AccessManager\n', '*/\n', 'contract HorseyToken is EthorseHelpers,Pausable {\n', '    using SafeMath for uint256;\n', '\n', '    /// @dev called when someone claims a token\n', '    event Claimed(address raceAddress, address eth_address, uint256 tokenId);\n', '    \n', '    /// @dev called when someone starts a feeding process\n', '    event Feeding(uint256 tokenId);\n', '\n', '    /// @dev called when someone ends a feeding process\n', '    event ReceivedCarrot(uint256 tokenId, bytes32 newDna);\n', '\n', '    /// @dev called when someone fails to end a feeding on the 255 blocks timer\n', '    event FeedingFailed(uint256 tokenId);\n', '\n', '    /// @dev called when a horsey is renamed\n', '    event HorseyRenamed(uint256 tokenId, string newName);\n', '\n', '    /// @dev called when a horsey is freed for carrots\n', '    event HorseyFreed(uint256 tokenId);\n', '\n', '    /// @dev address of the RoyalStables\n', '    RoyalStablesInterface public stables;\n', '\n', '    ///@dev multiplier applied to carrots received from burning a horsey\n', '    uint8 public carrotsMultiplier = 1;\n', '\n', '    ///@dev multiplier applied to rarity bounds when feeding horsey\n', '    uint8 public rarityMultiplier = 1;\n', '\n', '    ///@dev fee to pay when claiming a token\n', '    uint256 public claimingFee = 0.008 ether;\n', '\n', '    /**\n', '        @dev Holds the necessary data to feed a horsey\n', '            The user has to create begin feeding and wait for the block\n', '            with the feeding transaction to be hashed\n', '            Only then he can stop the feeding\n', '    */\n', '    struct FeedingData {\n', '        uint256 blockNumber;    ///@dev Holds the block number where the feeding began\n', '        uint256 horsey;         ///@dev Holds the horsey id\n', '    }\n', '\n', '    /// @dev Maps a user to his pending feeding\n', '    mapping(address => FeedingData) public pendingFeedings;\n', '\n', '    /// @dev Stores the renaming fees per character a user has to pay upon renaming a horsey\n', '    uint256 public renamingCostsPerChar = 0.001 ether;\n', '\n', '    /**\n', '        @dev Contracts constructor\n', '            Initializes token data\n', '            is pausable,ownable\n', '        @param stablesAddress Address of the official RoyalStables contract\n', '    */\n', '    constructor(address stablesAddress) \n', '    EthorseHelpers() \n', '    Pausable() public {\n', '        stables = RoyalStablesInterface(stablesAddress);\n', '    }\n', '\n', '    /**\n', '        @dev Changes multiplier for rarity on feed\n', '        @param newRarityMultiplier The cost to charge in wei for each character of the name\n', '    */\n', '    function setRarityMultiplier(uint8 newRarityMultiplier) external \n', '    onlyOwner()  {\n', '        rarityMultiplier = newRarityMultiplier;\n', '    }\n', '\n', '    /**\n', '        @dev Sets a new muliplier for freeing a horse\n', '        @param newCarrotsMultiplier the new multiplier for feeding\n', '    */\n', '    function setCarrotsMultiplier(uint8 newCarrotsMultiplier) external \n', '    onlyOwner()  {\n', '        carrotsMultiplier = newCarrotsMultiplier;\n', '    }\n', '\n', '    /**\n', '        @dev Sets a new renaming per character cost in wei\n', '            Any CLevel can call this function\n', '        @param newRenamingCost The cost to charge in wei for each character of the name\n', '    */\n', '    function setRenamingCosts(uint256 newRenamingCost) external \n', '    onlyOwner()  {\n', '        renamingCostsPerChar = newRenamingCost;\n', '    }\n', '\n', '    /**\n', '        @dev Sets a new claiming fee in wei\n', '            Any CLevel can call this function\n', '        @param newClaimingFee The cost to charge in wei for each claimed HRSY\n', '    */\n', '    function setClaimingCosts(uint256 newClaimingFee) external\n', '    onlyOwner()  {\n', '        claimingFee = newClaimingFee;\n', '    }\n', '\n', '    /**\n', '        @dev Allows to add a legit owner address for races validation\n', '        @param newAddress the dev address deploying BettingController to add\n', '    */\n', '    function addLegitDevAddress(address newAddress) external\n', '    onlyOwner() {\n', '        _addLegitOwner(newAddress);\n', '    }\n', '\n', '    /**\n', '        @dev Owner can withdraw the current balance\n', '    */\n', '    function withdraw() external \n', '    onlyOwner()  {\n', '        owner.transfer(address(this).balance); //throws on fail\n', '    }\n', '\n', '    //allows owner to add a horse name to the possible horses list (BTC,ETH,LTC,...)\n', '    /**\n', '        @dev Adds a new horse index to the possible horses list (BTC,ETH,LTC,...)\n', '            This is in case ethorse adds a new coin\n', '            Any CLevel can call this function\n', '        @param newHorse Index of the horse to add (same data type as the original ethorse erc20 contract code)\n', '    */\n', '    function addHorseIndex(bytes32 newHorse) external\n', '    onlyOwner() {\n', '        _addHorse(newHorse);\n', '    }\n', '\n', '    /**\n', '        @dev Gets the complete list of token ids which belongs to an address\n', '        @param eth_address The address you want to lookup owned tokens from\n', '        @return List of all owned by eth_address tokenIds\n', '    */\n', '    function getOwnedTokens(address eth_address) public view returns (uint256[]) {\n', '        return stables.getOwnedTokens(eth_address);\n', '    }\n', '    \n', '    /**\n', '        @dev Allows to check if an eth_address can claim a horsey from this contract\n', '            should we also check if already claimed here?\n', '        @param raceAddress The ethorse race you want to claim from\n', '        @param eth_address The users address you want to claim the token for\n', '        @return True only if eth_address is a winner of the race contract at raceAddress\n', '    */\n', '    function can_claim(address raceAddress, address eth_address) public view returns (bool) {\n', '        bool res;\n', '        (res,) = _isWinnerOf(raceAddress, eth_address);\n', '        return res;\n', '    }\n', '\n', '    /**\n', '        @dev Allows a user to claim a special horsey with the same dna as the race one\n', '            Cant be used on paused\n', '            The sender has to be a winner of the race and must never have claimed a special horsey from this race\n', '        @param raceAddress The race&#39;s address\n', '    */\n', '    function claim(address raceAddress) external payable\n', '    costs(claimingFee)\n', '    whenNotPaused()\n', '    {\n', '        //call _isWinnerOf with a 0 address to simply get the winner horse\n', '        bytes32 winner;\n', '        (,winner) = _isWinnerOf(raceAddress, address(0));\n', '        require(winner != bytes32(0),"Winner is zero");\n', '        require(can_claim(raceAddress, msg.sender),"can_claim return false");\n', '        //require(!exists(id)); should already be checked by mining function\n', '        uint256 id = _generate_special_horsey(raceAddress, msg.sender, winner);\n', '        emit Claimed(raceAddress, msg.sender, id);\n', '    }\n', '\n', '    /**\n', '        @dev Allows a user to give a horsey a name or rename it\n', '            This function is payable and its cost is renamingCostsPerChar * length(newname)\n', '            Cant be called while paused\n', '            If called with too low balance, the modifier will throw\n', '            If called with too much balance, we try to return the remaining funds back\n', '            Upon completion we update all ceos balances, maybe not very efficient?\n', '        @param tokenId ID of the horsey to rename\n', '        @param newName The name to give to the horsey\n', '    */\n', '    function renameHorsey(uint256 tokenId, string newName) external \n', '    whenNotPaused()\n', '    onlyOwnerOf(tokenId) \n', '    costs(renamingCostsPerChar * bytes(newName).length)\n', '    payable {\n', '        uint256 renamingFee = renamingCostsPerChar * bytes(newName).length;\n', '        //Return over paid amount to sender if necessary\n', '        if(msg.value > renamingFee) //overpaid\n', '        {\n', '            msg.sender.transfer(msg.value.sub(renamingFee));\n', '        }\n', '        //store the new name\n', '        stables.storeName(tokenId,newName);\n', '        emit HorseyRenamed(tokenId,newName);\n', '    }\n', '\n', '    /**\n', '        @dev Allows a user to burn a token he owns to get carrots\n', '            The mount of carrots given is equal to the horsey&#39;s feedingCounter upon burning\n', '            Cant be called on a horsey with a pending feeding\n', '            Cant be called while paused\n', '        @param tokenId ID of the token to burn\n', '    */\n', '    function freeForCarrots(uint256 tokenId) external \n', '    whenNotPaused()\n', '    onlyOwnerOf(tokenId) {\n', '        require(pendingFeedings[msg.sender].horsey != tokenId,"");\n', '        //credit carrots\n', '        uint8 feedingCounter;\n', '        (,,feedingCounter,) = stables.horseys(tokenId);\n', '        stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) + uint32(feedingCounter * carrotsMultiplier));\n', '        stables.unstoreHorsey(tokenId);\n', '        emit HorseyFreed(tokenId);\n', '    }\n', '\n', '    /**\n', '        @dev Returns the amount of carrots the user owns\n', '            We have a getter to hide the carrots amount from public view\n', '        @return The current amount of carrot credits the sender owns \n', '    */\n', '    function getCarrotCredits() external view returns (uint32) {\n', '        return stables.carrot_credits(msg.sender);\n', '    }\n', '\n', '    /**\n', '        @dev Returns horsey data of a given token\n', '        @param tokenId ID of the horsey to fetch\n', '        @return (race address, dna, feedingCounter, name)\n', '    */\n', '    function getHorsey(uint256 tokenId) public view returns (address, bytes32, uint8, string) {\n', '        RoyalStablesInterface.Horsey memory temp;\n', '        (temp.race,temp.dna,temp.feedingCounter,temp.tier) = stables.horseys(tokenId);\n', '        return (temp.race,temp.dna,temp.feedingCounter,stables.names(tokenId));\n', '    }\n', '\n', '    /**\n', '        @dev Allows to feed a horsey to increase its feedingCounter value\n', '            Gives a chance to get a rare trait\n', '            The amount of carrots required is the value of current feedingCounter\n', '            The carrots the user owns will be reduced accordingly upon success\n', '            Cant be called while paused\n', '        @param tokenId ID of the horsey to feed\n', '    */\n', '    function feed(uint256 tokenId) external \n', '    whenNotPaused()\n', '    onlyOwnerOf(tokenId) \n', '    carrotsMeetLevel(tokenId)\n', '    noFeedingInProgress()\n', '    {\n', '        pendingFeedings[msg.sender] = FeedingData(block.number,tokenId);\n', '        uint8 feedingCounter;\n', '        (,,feedingCounter,) = stables.horseys(tokenId);\n', '        stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter));\n', '        emit Feeding(tokenId);\n', '    }\n', '\n', '    /**\n', '        @dev Allows user to stop feeding a horsey\n', '            This will trigger a random rarity chance\n', '    */\n', '    function stopFeeding() external\n', '    feedingInProgress() returns (bool) {\n', '        uint256 blockNumber = pendingFeedings[msg.sender].blockNumber;\n', '        uint256 tokenId = pendingFeedings[msg.sender].horsey;\n', '        //you cant feed and stop feeding from the same block!\n', '        require(block.number - blockNumber >= 1,"feeding and stop feeding are in same block");\n', '\n', '        delete pendingFeedings[msg.sender];\n', '\n', '        //solidity only gives you access to the previous 256 blocks\n', '        //deny and remove this obsolete feeding if we cant fetch its blocks hash\n', '        if(block.number - blockNumber > 255) {\n', '            //the feeding is outdated = failed\n', '            //the user can feed again but he lost his carrots\n', '            emit FeedingFailed(tokenId);\n', '            return false; \n', '        }\n', '\n', '        //token could have been transfered in the meantime to someone else\n', '        if(stables.ownerOf(tokenId) != msg.sender) {\n', '            //the feeding is failed because the token no longer belongs to this user = failed\n', '            //the user has lost his carrots\n', '            emit FeedingFailed(tokenId);\n', '            return false; \n', '        }\n', '        \n', '        //call horsey generation with the claim block hash\n', '        _feed(tokenId, blockhash(blockNumber));\n', '        bytes32 dna;\n', '        (,dna,,) = stables.horseys(tokenId);\n', '        emit ReceivedCarrot(tokenId, dna);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Only ether sent explicitly through the donation() function is accepted\n', '    function() external payable {\n', '        revert("Not accepting donations");\n', '    }\n', '\n', '    /**\n', '        @dev Internal function to increase a horsey&#39;s rarity\n', '            Uses a random value to assess if the feeding process increases rarity\n', '            The chances of having a rarity increase are based on the current feedingCounter\n', '        @param tokenId ID of the token to "feed"\n', '        @param blockHash Hash of the block where the feeding began\n', '    */\n', '    function _feed(uint256 tokenId, bytes32 blockHash) internal {\n', '        //Grab the upperbound for probability 100,100\n', '        uint8 tier;\n', '        uint8 feedingCounter;\n', '        (,,feedingCounter,tier) = stables.horseys(tokenId);\n', '        uint256 probabilityByRarity = 10 ** (uint256(tier).add(1));\n', '        uint256 randNum = uint256(keccak256(abi.encodePacked(tokenId, blockHash))) % probabilityByRarity;\n', '\n', '        //Scale probability based on horsey&#39;s level\n', '        if(randNum <= (feedingCounter * rarityMultiplier)){\n', '            _increaseRarity(tokenId, blockHash);\n', '        }\n', '\n', '        //Increment feedingCounter\n', '        //Maximum allowed is 255, which requires 32385 carrots, so we should never reach that\n', '        if(feedingCounter < 255) {\n', '            stables.modifyHorseyFeedingCounter(tokenId,feedingCounter+1);\n', '        }\n', '    }\n', '\n', '    /// @dev creates a special token id based on the race and the coin index\n', '    function _makeSpecialId(address race, address sender, bytes32 coinIndex) internal pure returns (uint256) {\n', '        return uint256(keccak256(abi.encodePacked(race, sender, coinIndex)));\n', '    }\n', '\n', '    /**\n', '        @dev Internal function to generate a SPECIAL horsey token\n', '            we then use the ERC721 inherited minting process\n', '            the dna is a bytes32 target for a keccak256. Not using blockhash\n', '            finaly, a bitmask zeros the first 2 bytes for rarity traits\n', '        @param race Address of the associated race\n', '        @param eth_address Address of the user to receive the token\n', '        @param coinIndex The index of the winning coin\n', '        @return ID of the token\n', '    */\n', '    function _generate_special_horsey(address race, address eth_address, bytes32 coinIndex) internal returns (uint256) {\n', '        uint256 id = _makeSpecialId(race, eth_address, coinIndex);\n', '        //generate dna\n', '        bytes32 dna = _shiftRight(keccak256(abi.encodePacked(race, coinIndex)),16);\n', '         //storeHorsey checks if the token exists before minting already, so we dont have to here\n', '        stables.storeHorsey(eth_address,id,race,dna,1,0);\n', '        return id;\n', '    }\n', '    \n', '    /**\n', '        @dev Internal function called to increase a horsey rarity\n', '            We generate a random zeros mask with a single 1 in the leading 16 bits\n', '        @param tokenId Id of the token to increase rarity of\n', '        @param blockHash hash of the block where the feeding began\n', '    */\n', '    function _increaseRarity(uint256 tokenId, bytes32 blockHash) private {\n', '        uint8 tier;\n', '        bytes32 dna;\n', '        (,dna,,tier) = stables.horseys(tokenId);\n', '        if(tier < 255)\n', '            stables.modifyHorseyTier(tokenId,tier+1);\n', '        uint256 random = uint256(keccak256(abi.encodePacked(tokenId, blockHash)));\n', '        //this creates a mask of 256 bits such as one of the first 16 bits will be 1\n', '        bytes32 rarityMask = _shiftLeft(bytes32(1), (random % 16 + 240));\n', '        bytes32 newdna = dna | rarityMask; //apply mask to add the random flag\n', '        stables.modifyHorseyDna(tokenId,newdna);\n', '    }\n', '\n', '    /// @dev shifts a bytes32 left by n positions\n', '    function _shiftLeft(bytes32 data, uint n) internal pure returns (bytes32) {\n', '        return bytes32(uint256(data)*(2 ** n));\n', '    }\n', '\n', '    /// @dev shifts a bytes32 right by n positions\n', '    function _shiftRight(bytes32 data, uint n) internal pure returns (bytes32) {\n', '        return bytes32(uint256(data)/(2 ** n));\n', '    }\n', '\n', '    /// @dev Modifier to ensure user can afford a rehorse\n', '    modifier carrotsMeetLevel(uint256 tokenId){\n', '        uint256 feedingCounter;\n', '        (,,feedingCounter,) = stables.horseys(tokenId);\n', '        require(feedingCounter <= stables.carrot_credits(msg.sender),"Not enough carrots");\n', '        _;\n', '    }\n', '\n', '    /// @dev insures the caller payed the required amount\n', '    modifier costs(uint256 amount) {\n', '        require(msg.value >= amount,"Not enough funds");\n', '        _;\n', '    }\n', '\n', '    /// @dev requires the address to be non null\n', '    modifier validAddress(address addr) {\n', '        require(addr != address(0),"Address is zero");\n', '        _;\n', '    }\n', '\n', '    /// @dev requires that the user isnt feeding a horsey already\n', '    modifier noFeedingInProgress() {\n', '        //if the key does not exit, then the default struct data is used where blockNumber is 0\n', '        require(pendingFeedings[msg.sender].blockNumber == 0,"Already feeding");\n', '        _;\n', '    }\n', '\n', '    /// @dev requires that the user isnt feeding a horsey already\n', '    modifier feedingInProgress() {\n', '        //if the key does not exit, then the default struct data is used where blockNumber is 0\n', '        require(pendingFeedings[msg.sender].blockNumber != 0,"No pending feeding");\n', '        _;\n', '    }\n', '\n', '    /// @dev requires that the user isnt feeding a horsey already\n', '    modifier onlyOwnerOf(uint256 tokenId) {\n', '        require(stables.ownerOf(tokenId) == msg.sender, "Caller is not owner of this token");\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts\\HorseyPilot.sol\n', '\n', '/**\n', '    @title Adds rank management utilities and voting behavior\n', '    @dev Handles equities distribution and levels of access\n', '\n', '    EXCHANGE FUNCTIONS IT CAN CALL\n', '\n', '    setClaimingFee OK 5\n', '    setMarketFees OK 1\n', '    withdraw\n', '\n', '    TOKEN FUNCTIONS IT CAN CALL\n', '\n', '    setRenamingCosts OK 0\n', '    addHorseIndex OK 3\n', '    setCarrotsMultiplier 8\n', '    setRarityMultiplier 9\n', '    addLegitDevAddress 2\n', '    withdraw\n', '\n', '    PAUSING OK 4\n', '*/\n', '\n', 'contract HorseyPilot {\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    /// @dev event that is fired when a new proposal is made\n', '    event NewProposal(uint8 methodId, uint parameter, address proposer);\n', '\n', '    /// @dev event that is fired when a proposal is accepted\n', '    event ProposalPassed(uint8 methodId, uint parameter, address proposer);\n', '\n', '    /// @dev minimum threshold that must be met in order to confirm\n', '    /// a contract update\n', '    uint8 constant votingThreshold = 2;\n', '\n', '    /// @dev minimum amount of time a proposal can live\n', '    /// after this time it can be forcefully invoked or killed by anyone\n', '    uint256 constant proposalLife = 7 days;\n', '\n', '    /// @dev amount of time until another proposal can be made\n', '    /// we use this to eliminate proposal spamming\n', '    uint256 constant proposalCooldown = 1 days;\n', '\n', '    /// @dev used to reference the exact time the last proposal vetoed\n', '    uint256 cooldownStart;\n', '\n', '    /// @dev The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public jokerAddress;\n', '    address public knightAddress;\n', '    address public paladinAddress;\n', '\n', '    /// @dev List of all addresses allowed to vote\n', '    address[3] public voters;\n', '\n', '    /// @dev joker is the pool and gets the rest\n', '    uint8 constant public knightEquity = 40;\n', '    uint8 constant public paladinEquity = 10;\n', '\n', '    /// @dev deployed exchange and token addresses\n', '    address public exchangeAddress;\n', '    address public tokenAddress;\n', '\n', '    /// @dev Mapping to keep track of pending balance of contract owners\n', '    mapping(address => uint) internal _cBalance;\n', '\n', '    /// @dev Encapsulates information about a proposed update\n', '    struct Proposal{\n', '        address proposer;           /// @dev address of the CEO at the origin of this proposal\n', '        uint256 timestamp;          /// @dev the time at which this propsal was made\n', '        uint256 parameter;          /// @dev parameters associated with proposed method invocation\n', '        uint8   methodId;           /// @dev id maps to function 0:rename horse, 1:change fees, 2:?    \n', '        address[] yay;              /// @dev list of all addresses who voted     \n', '        address[] nay;              /// @dev list of all addresses who voted against     \n', '    }\n', '\n', '    /// @dev the pending proposal\n', '    Proposal public currentProposal;\n', '\n', '    /// @dev true if the proposal is waiting for votes\n', '    bool public proposalInProgress = false;\n', '\n', '    /// @dev Value to keep track of avaible balance\n', '    uint256 public toBeDistributed;\n', '\n', '    /// @dev used to deploy contracts only once\n', '    bool deployed = false;\n', '\n', '    /**\n', '        @param _jokerAddress joker\n', '        @param _knightAddress knight\n', '        @param _paladinAddress paladin\n', '        @param _voters list of all allowed voting addresses\n', '    */\n', '    constructor(\n', '    address _jokerAddress,\n', '    address _knightAddress,\n', '    address _paladinAddress,\n', '    address[3] _voters\n', '    ) public {\n', '        jokerAddress = _jokerAddress;\n', '        knightAddress = _knightAddress;\n', '        paladinAddress = _paladinAddress;\n', '\n', '        for(uint i = 0; i < 3; i++) {\n', '            voters[i] = _voters[i];\n', '        }\n', '\n', '        //Set cooldown start to 1 day ago so that cooldown is irrelevant\n', '        cooldownStart = block.timestamp - proposalCooldown;\n', '    }\n', '\n', '    /**\n', '        @dev Used to deploy children contracts as a one shot call\n', '    */\n', '    function deployChildren(address stablesAddress) external {\n', '        require(!deployed,"already deployed");\n', '        // deploy token and exchange contracts\n', '        exchangeAddress = new HorseyExchange();\n', '        tokenAddress = new HorseyToken(stablesAddress);\n', '\n', '        // the exchange requires horsey token address\n', '        HorseyExchange(exchangeAddress).setStables(stablesAddress);\n', '\n', '        deployed = true;\n', '    }\n', '\n', '    /**\n', '        @dev Transfers joker ownership to a new address\n', '        @param newJoker the new address\n', '    */\n', '    function transferJokerOwnership(address newJoker) external \n', '    validAddress(newJoker) {\n', '        require(jokerAddress == msg.sender,"Not right role");\n', '        _moveBalance(newJoker);\n', '        jokerAddress = newJoker;\n', '    }\n', '\n', '    /**\n', '        @dev Transfers knight ownership to a new address\n', '        @param newKnight the new address\n', '    */\n', '    function transferKnightOwnership(address newKnight) external \n', '    validAddress(newKnight) {\n', '        require(knightAddress == msg.sender,"Not right role");\n', '        _moveBalance(newKnight);\n', '        knightAddress = newKnight;\n', '    }\n', '\n', '    /**\n', '        @dev Transfers paladin ownership to a new address\n', '        @param newPaladin the new address\n', '    */\n', '    function transferPaladinOwnership(address newPaladin) external \n', '    validAddress(newPaladin) {\n', '        require(paladinAddress == msg.sender,"Not right role");\n', '        _moveBalance(newPaladin);\n', '        paladinAddress = newPaladin;\n', '    }\n', '\n', '    /**\n', '        @dev Allow CEO to withdraw from pending value always checks to update redist\n', '            We ONLY redist when a user tries to withdraw so we are not redistributing\n', '            on every payment\n', '        @param destination The address to send the ether to\n', '    */\n', '    function withdrawCeo(address destination) external \n', '    onlyCLevelAccess()\n', '    validAddress(destination) {\n', '        //Check that pending balance can be redistributed - if so perform\n', '        //this procedure\n', '        if(toBeDistributed > 0){\n', '            _updateDistribution();\n', '        }\n', '        \n', '        //Grab the balance of this CEO \n', '        uint256 balance = _cBalance[msg.sender];\n', '        \n', '        //If we have non-zero balance, CEO may withdraw from pending amount\n', '        if(balance > 0 && (address(this).balance >= balance)) {\n', '            destination.transfer(balance); //throws on fail\n', '            _cBalance[msg.sender] = 0;\n', '        }\n', '    }\n', '\n', '    /// @dev acquire funds from owned contracts\n', '    function syncFunds() external {\n', '        uint256 prevBalance = address(this).balance;\n', '        HorseyToken(tokenAddress).withdraw();\n', '        HorseyExchange(exchangeAddress).withdraw();\n', '        uint256 newBalance = address(this).balance;\n', '        //add to\n', '        toBeDistributed = toBeDistributed.add(newBalance - prevBalance);\n', '    }\n', '\n', '    /// @dev allows a noble to access his holdings\n', '    function getNobleBalance() external view\n', '    onlyCLevelAccess() returns (uint256) {\n', '        return _cBalance[msg.sender];\n', '    }\n', '\n', '    /**\n', '        @dev Make a proposal and add to pending proposals\n', '        @param methodId a string representing the function ie. &#39;renameHorsey()&#39;\n', '        @param parameter parameter to be used if invocation is approved\n', '    */\n', '    function makeProposal( uint8 methodId, uint256 parameter ) external\n', '    onlyCLevelAccess()\n', '    proposalAvailable()\n', '    cooledDown()\n', '    {\n', '        currentProposal.timestamp = block.timestamp;\n', '        currentProposal.parameter = parameter;\n', '        currentProposal.methodId = methodId;\n', '        currentProposal.proposer = msg.sender;\n', '        delete currentProposal.yay;\n', '        delete currentProposal.nay;\n', '        proposalInProgress = true;\n', '        \n', '        emit NewProposal(methodId,parameter,msg.sender);\n', '    }\n', '\n', '    /**\n', '        @dev Call to vote on a pending proposal\n', '    */\n', '    function voteOnProposal(bool voteFor) external \n', '    proposalPending()\n', '    onlyVoters()\n', '    notVoted() {\n', '        //cant vote on expired!\n', '        require((block.timestamp - currentProposal.timestamp) <= proposalLife);\n', '        if(voteFor)\n', '        {\n', '            currentProposal.yay.push(msg.sender);\n', '            //Proposal went through? invoke it\n', '            if( currentProposal.yay.length >= votingThreshold )\n', '            {\n', '                _doProposal();\n', '                proposalInProgress = false;\n', '                //no need to reset cooldown on successful proposal\n', '                return;\n', '            }\n', '\n', '        } else {\n', '            currentProposal.nay.push(msg.sender);\n', '            //Proposal failed?\n', '            if( currentProposal.nay.length >= votingThreshold )\n', '            {\n', '                proposalInProgress = false;\n', '                cooldownStart = block.timestamp;\n', '                return;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '        @dev Helps moving pending balance from one role to another\n', '        @param newAddress the address to transfer the pending balance from the msg.sender account\n', '    */\n', '    function _moveBalance(address newAddress) internal\n', '    validAddress(newAddress) {\n', '        require(newAddress != msg.sender); /// @dev IMPORTANT or else the account balance gets reset here!\n', '        _cBalance[newAddress] = _cBalance[msg.sender];\n', '        _cBalance[msg.sender] = 0;\n', '    }\n', '\n', '    /**\n', '        @dev Called at the start of withdraw to distribute any pending balances that live in the contract\n', '            will only ever be called if balance is non-zero (funds should be distributed)\n', '    */\n', '    function _updateDistribution() internal {\n', '        require(toBeDistributed != 0,"nothing to distribute");\n', '        uint256 knightPayday = toBeDistributed.div(100).mul(knightEquity);\n', '        uint256 paladinPayday = toBeDistributed.div(100).mul(paladinEquity);\n', '\n', '        /// @dev due to the equities distribution, queen gets the remaining value\n', '        uint256 jokerPayday = toBeDistributed.sub(knightPayday).sub(paladinPayday);\n', '\n', '        _cBalance[jokerAddress] = _cBalance[jokerAddress].add(jokerPayday);\n', '        _cBalance[knightAddress] = _cBalance[knightAddress].add(knightPayday);\n', '        _cBalance[paladinAddress] = _cBalance[paladinAddress].add(paladinPayday);\n', '        //Reset balance to 0\n', '        toBeDistributed = 0;\n', '    }\n', '\n', '    /**\n', '        @dev Execute the proposal\n', '    */\n', '    function _doProposal() internal {\n', '        /// UPDATE the renaming cost\n', '        if( currentProposal.methodId == 0 ) HorseyToken(tokenAddress).setRenamingCosts(currentProposal.parameter);\n', '        \n', '        /// UPDATE the market fees\n', '        if( currentProposal.methodId == 1 ) HorseyExchange(exchangeAddress).setMarketFees(currentProposal.parameter);\n', '\n', '        /// UPDATE the legit dev addresses list\n', '        if( currentProposal.methodId == 2 ) HorseyToken(tokenAddress).addLegitDevAddress(address(currentProposal.parameter));\n', '\n', '        /// ADD a horse index to exchange\n', '        if( currentProposal.methodId == 3 ) HorseyToken(tokenAddress).addHorseIndex(bytes32(currentProposal.parameter));\n', '\n', '        /// PAUSE/UNPAUSE the dApp\n', '        if( currentProposal.methodId == 4 ) {\n', '            if(currentProposal.parameter == 0) {\n', '                HorseyExchange(exchangeAddress).unpause();\n', '                HorseyToken(tokenAddress).unpause();\n', '            } else {\n', '                HorseyExchange(exchangeAddress).pause();\n', '                HorseyToken(tokenAddress).pause();\n', '            }\n', '        }\n', '\n', '        /// UPDATE the claiming fees\n', '        if( currentProposal.methodId == 5 ) HorseyToken(tokenAddress).setClaimingCosts(currentProposal.parameter);\n', '\n', '        /// UPDATE carrots multiplier\n', '        if( currentProposal.methodId == 8 ){\n', '            HorseyToken(tokenAddress).setCarrotsMultiplier(uint8(currentProposal.parameter));\n', '        }\n', '\n', '        /// UPDATE rarity multiplier\n', '        if( currentProposal.methodId == 9 ){\n', '            HorseyToken(tokenAddress).setRarityMultiplier(uint8(currentProposal.parameter));\n', '        }\n', '\n', '        emit ProposalPassed(currentProposal.methodId,currentProposal.parameter,currentProposal.proposer);\n', '    }\n', '\n', '    /// @dev requires the address to be non null\n', '    modifier validAddress(address addr) {\n', '        require(addr != address(0),"Address is zero");\n', '        _;\n', '    }\n', '\n', '    /// @dev requires the sender to be on the contract owners list\n', '    modifier onlyCLevelAccess() {\n', '        require((jokerAddress == msg.sender) || (knightAddress == msg.sender) || (paladinAddress == msg.sender),"not c level");\n', '        _;\n', '    }\n', '\n', '    /// @dev requires that a proposal is not in process or has exceeded its lifetime, and has cooled down\n', '    /// after being vetoed\n', '    modifier proposalAvailable(){\n', '        require(((!proposalInProgress) || ((block.timestamp - currentProposal.timestamp) > proposalLife)),"proposal already pending");\n', '        _;\n', '    }\n', '\n', '    // @dev requries that if this proposer was the last proposer, that he or she has reached the \n', '    // cooldown limit\n', '    modifier cooledDown( ){\n', '        if(msg.sender == currentProposal.proposer && (block.timestamp - cooldownStart < 1 days)){\n', '            revert("Cool down period not passed yet");\n', '        }\n', '        _;\n', '    }\n', '\n', '    /// @dev requires a proposal to be active\n', '    modifier proposalPending() {\n', '        require(proposalInProgress,"no proposal pending");\n', '        _;\n', '    }\n', '\n', '    /// @dev requires the voter to not have voted already\n', '    modifier notVoted() {\n', '        uint256 length = currentProposal.yay.length;\n', '        for(uint i = 0; i < length; i++) {\n', '            if(currentProposal.yay[i] == msg.sender) {\n', '                revert("Already voted");\n', '            }\n', '        }\n', '\n', '        length = currentProposal.nay.length;\n', '        for(i = 0; i < length; i++) {\n', '            if(currentProposal.nay[i] == msg.sender) {\n', '                revert("Already voted");\n', '            }\n', '        }\n', '        _;\n', '    }\n', '\n', '    /// @dev requires the voter to not have voted already\n', '    modifier onlyVoters() {\n', '        bool found = false;\n', '        uint256 length = voters.length;\n', '        for(uint i = 0; i < length; i++) {\n', '            if(voters[i] == msg.sender) {\n', '                found = true;\n', '                break;\n', '            }\n', '        }\n', '        if(!found) {\n', '            revert("not a voter");\n', '        }\n', '        _;\n', '    }\n', '}']