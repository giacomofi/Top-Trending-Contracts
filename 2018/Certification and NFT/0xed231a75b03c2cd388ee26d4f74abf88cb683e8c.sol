['/*\n', ' * CollateralMonitor\n', ' *\n', ' * This contract reports aggregated issuance\n', ' * and collateralisation statistics for the \n', ' * Havven stablecoin system.\n', ' * \n', ' * Author: Anton Jurisevic\n', ' * Date: 14/06/2018\n', ' * Version: nUSDa 1.0\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'contract Havven {\n', '    uint public price;\n', '    uint public issuanceRatio;\n', '    mapping(address => uint) public nominsIssued;\n', '    function balanceOf(address account) public view returns (uint);\n', '    function totalSupply() public view returns (uint);\n', '    function availableHavvens(address account) public view returns (uint);\n', '}\n', '\n', 'contract Nomin {\n', '    function totalSupply() public view returns (uint);\n', '}\n', '\n', 'contract HavvenEscrow {\n', '    function balanceOf(address account) public view returns (uint);\n', '}\n', '\n', '/**\n', ' * @title Safely manipulate unsigned fixed-point decimals at a given precision level.\n', ' * @dev Functions accepting uints in this contract and derived contracts\n', ' * are taken to be such fixed point decimals (including fiat, ether, and nomin quantities).\n', ' */\n', 'contract SafeDecimalMath {\n', '\n', '    /* Number of decimal places in the representation. */\n', '    uint8 public constant decimals = 18;\n', '\n', '    /* The number representing 1.0. */\n', '    uint public constant UNIT = 10 ** uint(decimals);\n', '\n', '    /**\n', '     * @return True iff adding x and y will not overflow.\n', '     */\n', '    function addIsSafe(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return x + y >= y;\n', '    }\n', '\n', '    /**\n', '     * @return The result of adding x and y, throwing an exception in case of overflow.\n', '     */\n', '    function safeAdd(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        require(x + y >= y);\n', '        return x + y;\n', '    }\n', '\n', '    /**\n', '     * @return True iff subtracting y from x will not overflow in the negative direction.\n', '     */\n', '    function subIsSafe(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return y <= x;\n', '    }\n', '\n', '    /**\n', '     * @return The result of subtracting y from x, throwing an exception in case of overflow.\n', '     */\n', '    function safeSub(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        require(y <= x);\n', '        return x - y;\n', '    }\n', '\n', '    /**\n', '     * @return True iff multiplying x and y would not overflow.\n', '     */\n', '    function mulIsSafe(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        if (x == 0) {\n', '            return true;\n', '        }\n', '        return (x * y) / x == y;\n', '    }\n', '\n', '    /**\n', '     * @return The result of multiplying x and y, throwing an exception in case of overflow.\n', '     */\n', '    function safeMul(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        if (x == 0) {\n', '            return 0;\n', '        }\n', '        uint p = x * y;\n', '        require(p / x == y);\n', '        return p;\n', '    }\n', '\n', '    /**\n', '     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n', '     * decimals. Throws an exception in case of overflow.\n', '     * \n', '     * @dev A unit factor is divided out after the product of x and y is evaluated,\n', '     * so that product must be less than 2**256.\n', '     * Incidentally, the internal division always rounds down: one could have rounded to the nearest integer,\n', '     * but then one would be spending a significant fraction of a cent (of order a microether\n', '     * at present gas prices) in order to save less than one part in 0.5 * 10^18 per operation, if the operands\n', '     * contain small enough fractional components. It would also marginally diminish the \n', '     * domain this function is defined upon. \n', '     */\n', '    function safeMul_dec(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        /* Divide by UNIT to remove the extra factor introduced by the product. */\n', '        return safeMul(x, y) / UNIT;\n', '\n', '    }\n', '\n', '    /**\n', '     * @return True iff the denominator of x/y is nonzero.\n', '     */\n', '    function divIsSafe(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return y != 0;\n', '    }\n', '\n', '    /**\n', '     * @return The result of dividing x by y, throwing an exception if the divisor is zero.\n', '     */\n', '    function safeDiv(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        /* Although a 0 denominator already throws an exception,\n', '         * it is equivalent to a THROW operation, which consumes all gas.\n', '         * A require statement emits REVERT instead, which remits remaining gas. */\n', '        require(y != 0);\n', '        return x / y;\n', '    }\n', '\n', '    /**\n', '     * @return The result of dividing x by y, interpreting the operands as fixed point decimal numbers.\n', '     * @dev Throws an exception in case of overflow or zero divisor; x must be less than 2^256 / UNIT.\n', '     * Internal rounding is downward: a similar caveat holds as with safeDecMul().\n', '     */\n', '    function safeDiv_dec(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        /* Reintroduce the UNIT factor that will be divided out by y. */\n', '        return safeDiv(safeMul(x, UNIT), y);\n', '    }\n', '\n', '    /**\n', '     * @dev Convert an unsigned integer to a unsigned fixed-point decimal.\n', '     * Throw an exception if the result would be out of range.\n', '     */\n', '    function intToDec(uint i)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        return safeMul(i, UNIT);\n', '    }\n', '\n', '    function min(uint a, uint b) \n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max(uint a, uint b) \n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        return a > b ? a : b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title A contract with an owner.\n', ' * @notice Contract ownership can be transferred by first nominating the new owner,\n', ' * who must then accept the ownership, which prevents accidental incorrect ownership transfers.\n', ' */\n', 'contract Owned {\n', '    address public owner;\n', '    address public nominatedOwner;\n', '\n', '    /**\n', '     * @dev Owned Constructor\n', '     */\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        require(_owner != address(0));\n', '        owner = _owner;\n', '        emit OwnerChanged(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @notice Nominate a new owner of this contract.\n', '     * @dev Only the current owner may nominate a new owner.\n', '     */\n', '    function nominateNewOwner(address _owner)\n', '        external\n', '        onlyOwner\n', '    {\n', '        nominatedOwner = _owner;\n', '        emit OwnerNominated(_owner);\n', '    }\n', '\n', '    /**\n', '     * @notice Accept the nomination to be owner.\n', '     */\n', '    function acceptOwnership()\n', '        external\n', '        onlyNominatedOwner\n', '    {\n', '        owner = nominatedOwner;\n', '        nominatedOwner = address(0);\n', '        emit OwnerChanged(owner, nominatedOwner);\n', '    }\n', '\n', '    modifier onlyOwner\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyNominatedOwner\n', '    {\n', '        require(msg.sender == nominatedOwner);\n', '        _;\n', '    }\n', '\n', '    event OwnerNominated(address newOwner);\n', '    event OwnerChanged(address oldOwner, address newOwner);\n', '}\n', '\n', '\n', '/*\n', ' * The CollateralMonitor queries and reports information\n', ' * about collateralisation levels of the network.\n', ' */\n', 'contract CollateralMonitor is Owned, SafeDecimalMath {\n', '    \n', '    Havven havven;\n', '    Nomin nomin;\n', '    HavvenEscrow escrow;\n', '\n', '    address[] issuers;\n', '    uint maxIssuers = 10;\n', '\n', '    constructor(Havven _havven, Nomin _nomin, HavvenEscrow _escrow)\n', '        Owned(msg.sender)\n', '        public\n', '    {\n', '        havven = _havven;\n', '        nomin = _nomin;\n', '        escrow = _escrow;\n', '    }\n', '\n', '    function setHavven(Havven _havven)\n', '        onlyOwner\n', '        external\n', '    {\n', '        havven = _havven;\n', '    }\n', '\n', '    function setNomin(Nomin _nomin)\n', '         onlyOwner\n', '         external\n', '    {\n', '        nomin = _nomin;\n', '    }\n', '\n', '    function setEscrow(HavvenEscrow _escrow)\n', '        onlyOwner\n', '        external\n', '    {\n', '        escrow = _escrow;\n', '    }\n', '\n', '    function setMaxIssuers(uint newMax)\n', '        onlyOwner\n', '        external\n', '    {\n', '        maxIssuers = newMax;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyNominatedOwner {\n', '        require(msg.sender == nominatedOwner);\n', '        _;\n', '    }\n', '\n', '    function pushIssuer(address issuer)\n', '        onlyOwner\n', '        public\n', '    {\n', '        for (uint i = 0; i < issuers.length; i++) {\n', '            require(issuers[i] != issuer);\n', '        }\n', '        issuers.push(issuer);\n', '    }\n', '\n', '    function pushIssuers(address[] newIssuers)\n', '        onlyOwner\n', '        external\n', '    {\n', '        for (uint i = 0; i < issuers.length; i++) {\n', '            pushIssuer(newIssuers[i]);\n', '        }\n', '    }\n', '\n', '    function deleteIssuer(uint index)\n', '        onlyOwner\n', '        external\n', '    {\n', '        uint length = issuers.length;\n', '        require(index < length);\n', '        issuers[index] = issuers[length - 1];\n', '        delete issuers[length - 1];\n', '    }\n', '\n', '    function resizeIssuersArray(uint size)\n', '        onlyOwner\n', '        external\n', '    {\n', '        issuers.length = size;\n', '    }\n', '\n', '\n', '    /**********************************\\\n', '      collateral()\n', '\n', '      Reports the collateral available \n', '      for issuance of a given issuer.\n', '    \\**********************************/\n', '\n', '    function collateral(address account)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return safeAdd(havven.balanceOf(account), escrow.balanceOf(account));\n', '    }\n', '\n', '\n', '    /**********************************\\\n', '      totalIssuingCollateral()\n', '\n', '      Reports the collateral available \n', '      for issuance of all issuers.\n', '    \\**********************************/\n', '\n', '    function _limitedTotalIssuingCollateral(uint sumLimit)\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint sum;\n', '        uint limit = min(sumLimit, issuers.length);\n', '        for (uint i = 0; i < limit; i++) {\n', '            sum += collateral(issuers[i]);\n', '        } \n', '        return sum;\n', '    }\n', '\n', '    function totalIssuingCollateral()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return _limitedTotalIssuingCollateral(issuers.length);\n', '    }\n', '\n', '    function totalIssuingCollateral_limitedSum()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return _limitedTotalIssuingCollateral(maxIssuers);\n', '    } \n', '\n', '\n', '\n', '    /********************************\\\n', '      collateralisation()\n', '    \n', '      Reports the collateralisation\n', '      ratio of one account, assuming\n', '      a nomin price of one dollar.\n', '    \\********************************/\n', '\n', '    function collateralisation(address account)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        safeDiv_dec(safeMul_dec(collateral(account), havven.price()), \n', '                    havven.nominsIssued(account));\n', '    }\n', '\n', '\n', '    /********************************\\\n', '      totalIssuerCollateralisation()\n', '    \n', '      Reports the collateralisation\n', '      ratio of all issuers, assuming\n', '      a nomin price of one dollar.\n', '    \\********************************/\n', '\n', '    function totalIssuerCollateralisation()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        safeDiv_dec(safeMul_dec(totalIssuingCollateral(), havven.price()),\n', '                    nomin.totalSupply());\n', '    }\n', '\n', '\n', '    /********************************\\\n', '      totalNetworkCollateralisation()\n', '    \n', '      Reports the collateralisation\n', '      ratio of the entire network,\n', '      assuming a nomin price of one\n', '      dollar, and that havvens can\n', '      flow from non-issuer to issuer\n', '      accounts.\n', '    \\********************************/\n', '\n', '    function totalNetworkCollateralisation()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        safeDiv_dec(safeMul_dec(havven.totalSupply(), havven.price()),\n', '                    nomin.totalSupply());\n', '    }\n', '\n', '\n', '    /**************************************\\\n', '      totalIssuanceDebt()\n', '\n', '      Reports the the (unbounded) number\n', '      of havvens that would be locked by\n', '      all issued nomins, if the collateral\n', '      backing them was unlimited.\n', '    \\**************************************/\n', '\n', '    function totalIssuanceDebt()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return safeDiv_dec(nomin.totalSupply(),\n', '                           safeMul_dec(havven.issuanceRatio(), havven.price()));\n', '    }\n', '\n', '    function totalIssuanceDebt_limitedSum()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint sum;\n', '        uint limit = min(maxIssuers, issuers.length);\n', '        for (uint i = 0; i < limit; i++) {\n', '            sum += havven.nominsIssued(issuers[i]);\n', '        }\n', '        return safeDiv_dec(sum,\n', '                           safeMul_dec(havven.issuanceRatio(), havven.price()));\n', '    }\n', '\n', '\n', '    /*************************************\\\n', '      totalLockedHavvens()\n', '\n', '      Reports the the number of havvens\n', '      locked by all issued nomins.\n', '      This is capped by the actual number\n', '      of havvens in circulation.\n', '    \\*************************************/\n', '\n', '    function totalLockedHavvens()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return min(totalIssuanceDebt(), totalIssuingCollateral());\n', '    }\n', '\n', '    function totalLockedHavvens_limitedSum()\n', '        public\n', '        view\n', '        returns (uint)\n', '    { \n', '        return min(totalIssuanceDebt_limitedSum(), totalIssuingCollateral());\n', '    }\n', '\n', '\n', '    /****************************************************\\\n', '      totalLockedHavvens_byAvailableHavvens_limitedSum()\n', '      \n', '      Should be equivalent to\n', '      totalLockedHavvens_limitedSum() but it uses an\n', '      alternate computation method.\n', '    \\****************************************************/\n', '\n', '    function totalLockedHavvens_byAvailableHavvens_limitedSum()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint sum;\n', '        uint limit = min(maxIssuers, issuers.length);\n', '        for (uint i = 0; i < limit; i++) {\n', '            address issuer = issuers[i];\n', '            sum += safeSub(collateral(issuer), havven.availableHavvens(issuer));\n', '        }\n', '        return sum;\n', '    }\n', '}']
['/*\n', ' * CollateralMonitor\n', ' *\n', ' * This contract reports aggregated issuance\n', ' * and collateralisation statistics for the \n', ' * Havven stablecoin system.\n', ' * \n', ' * Author: Anton Jurisevic\n', ' * Date: 14/06/2018\n', ' * Version: nUSDa 1.0\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'contract Havven {\n', '    uint public price;\n', '    uint public issuanceRatio;\n', '    mapping(address => uint) public nominsIssued;\n', '    function balanceOf(address account) public view returns (uint);\n', '    function totalSupply() public view returns (uint);\n', '    function availableHavvens(address account) public view returns (uint);\n', '}\n', '\n', 'contract Nomin {\n', '    function totalSupply() public view returns (uint);\n', '}\n', '\n', 'contract HavvenEscrow {\n', '    function balanceOf(address account) public view returns (uint);\n', '}\n', '\n', '/**\n', ' * @title Safely manipulate unsigned fixed-point decimals at a given precision level.\n', ' * @dev Functions accepting uints in this contract and derived contracts\n', ' * are taken to be such fixed point decimals (including fiat, ether, and nomin quantities).\n', ' */\n', 'contract SafeDecimalMath {\n', '\n', '    /* Number of decimal places in the representation. */\n', '    uint8 public constant decimals = 18;\n', '\n', '    /* The number representing 1.0. */\n', '    uint public constant UNIT = 10 ** uint(decimals);\n', '\n', '    /**\n', '     * @return True iff adding x and y will not overflow.\n', '     */\n', '    function addIsSafe(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return x + y >= y;\n', '    }\n', '\n', '    /**\n', '     * @return The result of adding x and y, throwing an exception in case of overflow.\n', '     */\n', '    function safeAdd(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        require(x + y >= y);\n', '        return x + y;\n', '    }\n', '\n', '    /**\n', '     * @return True iff subtracting y from x will not overflow in the negative direction.\n', '     */\n', '    function subIsSafe(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return y <= x;\n', '    }\n', '\n', '    /**\n', '     * @return The result of subtracting y from x, throwing an exception in case of overflow.\n', '     */\n', '    function safeSub(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        require(y <= x);\n', '        return x - y;\n', '    }\n', '\n', '    /**\n', '     * @return True iff multiplying x and y would not overflow.\n', '     */\n', '    function mulIsSafe(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        if (x == 0) {\n', '            return true;\n', '        }\n', '        return (x * y) / x == y;\n', '    }\n', '\n', '    /**\n', '     * @return The result of multiplying x and y, throwing an exception in case of overflow.\n', '     */\n', '    function safeMul(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        if (x == 0) {\n', '            return 0;\n', '        }\n', '        uint p = x * y;\n', '        require(p / x == y);\n', '        return p;\n', '    }\n', '\n', '    /**\n', '     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n', '     * decimals. Throws an exception in case of overflow.\n', '     * \n', '     * @dev A unit factor is divided out after the product of x and y is evaluated,\n', '     * so that product must be less than 2**256.\n', '     * Incidentally, the internal division always rounds down: one could have rounded to the nearest integer,\n', '     * but then one would be spending a significant fraction of a cent (of order a microether\n', '     * at present gas prices) in order to save less than one part in 0.5 * 10^18 per operation, if the operands\n', '     * contain small enough fractional components. It would also marginally diminish the \n', '     * domain this function is defined upon. \n', '     */\n', '    function safeMul_dec(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        /* Divide by UNIT to remove the extra factor introduced by the product. */\n', '        return safeMul(x, y) / UNIT;\n', '\n', '    }\n', '\n', '    /**\n', '     * @return True iff the denominator of x/y is nonzero.\n', '     */\n', '    function divIsSafe(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return y != 0;\n', '    }\n', '\n', '    /**\n', '     * @return The result of dividing x by y, throwing an exception if the divisor is zero.\n', '     */\n', '    function safeDiv(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        /* Although a 0 denominator already throws an exception,\n', '         * it is equivalent to a THROW operation, which consumes all gas.\n', '         * A require statement emits REVERT instead, which remits remaining gas. */\n', '        require(y != 0);\n', '        return x / y;\n', '    }\n', '\n', '    /**\n', '     * @return The result of dividing x by y, interpreting the operands as fixed point decimal numbers.\n', '     * @dev Throws an exception in case of overflow or zero divisor; x must be less than 2^256 / UNIT.\n', '     * Internal rounding is downward: a similar caveat holds as with safeDecMul().\n', '     */\n', '    function safeDiv_dec(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        /* Reintroduce the UNIT factor that will be divided out by y. */\n', '        return safeDiv(safeMul(x, UNIT), y);\n', '    }\n', '\n', '    /**\n', '     * @dev Convert an unsigned integer to a unsigned fixed-point decimal.\n', '     * Throw an exception if the result would be out of range.\n', '     */\n', '    function intToDec(uint i)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        return safeMul(i, UNIT);\n', '    }\n', '\n', '    function min(uint a, uint b) \n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max(uint a, uint b) \n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        return a > b ? a : b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title A contract with an owner.\n', ' * @notice Contract ownership can be transferred by first nominating the new owner,\n', ' * who must then accept the ownership, which prevents accidental incorrect ownership transfers.\n', ' */\n', 'contract Owned {\n', '    address public owner;\n', '    address public nominatedOwner;\n', '\n', '    /**\n', '     * @dev Owned Constructor\n', '     */\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        require(_owner != address(0));\n', '        owner = _owner;\n', '        emit OwnerChanged(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @notice Nominate a new owner of this contract.\n', '     * @dev Only the current owner may nominate a new owner.\n', '     */\n', '    function nominateNewOwner(address _owner)\n', '        external\n', '        onlyOwner\n', '    {\n', '        nominatedOwner = _owner;\n', '        emit OwnerNominated(_owner);\n', '    }\n', '\n', '    /**\n', '     * @notice Accept the nomination to be owner.\n', '     */\n', '    function acceptOwnership()\n', '        external\n', '        onlyNominatedOwner\n', '    {\n', '        owner = nominatedOwner;\n', '        nominatedOwner = address(0);\n', '        emit OwnerChanged(owner, nominatedOwner);\n', '    }\n', '\n', '    modifier onlyOwner\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyNominatedOwner\n', '    {\n', '        require(msg.sender == nominatedOwner);\n', '        _;\n', '    }\n', '\n', '    event OwnerNominated(address newOwner);\n', '    event OwnerChanged(address oldOwner, address newOwner);\n', '}\n', '\n', '\n', '/*\n', ' * The CollateralMonitor queries and reports information\n', ' * about collateralisation levels of the network.\n', ' */\n', 'contract CollateralMonitor is Owned, SafeDecimalMath {\n', '    \n', '    Havven havven;\n', '    Nomin nomin;\n', '    HavvenEscrow escrow;\n', '\n', '    address[] issuers;\n', '    uint maxIssuers = 10;\n', '\n', '    constructor(Havven _havven, Nomin _nomin, HavvenEscrow _escrow)\n', '        Owned(msg.sender)\n', '        public\n', '    {\n', '        havven = _havven;\n', '        nomin = _nomin;\n', '        escrow = _escrow;\n', '    }\n', '\n', '    function setHavven(Havven _havven)\n', '        onlyOwner\n', '        external\n', '    {\n', '        havven = _havven;\n', '    }\n', '\n', '    function setNomin(Nomin _nomin)\n', '         onlyOwner\n', '         external\n', '    {\n', '        nomin = _nomin;\n', '    }\n', '\n', '    function setEscrow(HavvenEscrow _escrow)\n', '        onlyOwner\n', '        external\n', '    {\n', '        escrow = _escrow;\n', '    }\n', '\n', '    function setMaxIssuers(uint newMax)\n', '        onlyOwner\n', '        external\n', '    {\n', '        maxIssuers = newMax;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyNominatedOwner {\n', '        require(msg.sender == nominatedOwner);\n', '        _;\n', '    }\n', '\n', '    function pushIssuer(address issuer)\n', '        onlyOwner\n', '        public\n', '    {\n', '        for (uint i = 0; i < issuers.length; i++) {\n', '            require(issuers[i] != issuer);\n', '        }\n', '        issuers.push(issuer);\n', '    }\n', '\n', '    function pushIssuers(address[] newIssuers)\n', '        onlyOwner\n', '        external\n', '    {\n', '        for (uint i = 0; i < issuers.length; i++) {\n', '            pushIssuer(newIssuers[i]);\n', '        }\n', '    }\n', '\n', '    function deleteIssuer(uint index)\n', '        onlyOwner\n', '        external\n', '    {\n', '        uint length = issuers.length;\n', '        require(index < length);\n', '        issuers[index] = issuers[length - 1];\n', '        delete issuers[length - 1];\n', '    }\n', '\n', '    function resizeIssuersArray(uint size)\n', '        onlyOwner\n', '        external\n', '    {\n', '        issuers.length = size;\n', '    }\n', '\n', '\n', '    /**********************************\\\n', '      collateral()\n', '\n', '      Reports the collateral available \n', '      for issuance of a given issuer.\n', '    \\**********************************/\n', '\n', '    function collateral(address account)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return safeAdd(havven.balanceOf(account), escrow.balanceOf(account));\n', '    }\n', '\n', '\n', '    /**********************************\\\n', '      totalIssuingCollateral()\n', '\n', '      Reports the collateral available \n', '      for issuance of all issuers.\n', '    \\**********************************/\n', '\n', '    function _limitedTotalIssuingCollateral(uint sumLimit)\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint sum;\n', '        uint limit = min(sumLimit, issuers.length);\n', '        for (uint i = 0; i < limit; i++) {\n', '            sum += collateral(issuers[i]);\n', '        } \n', '        return sum;\n', '    }\n', '\n', '    function totalIssuingCollateral()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return _limitedTotalIssuingCollateral(issuers.length);\n', '    }\n', '\n', '    function totalIssuingCollateral_limitedSum()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return _limitedTotalIssuingCollateral(maxIssuers);\n', '    } \n', '\n', '\n', '\n', '    /********************************\\\n', '      collateralisation()\n', '    \n', '      Reports the collateralisation\n', '      ratio of one account, assuming\n', '      a nomin price of one dollar.\n', '    \\********************************/\n', '\n', '    function collateralisation(address account)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        safeDiv_dec(safeMul_dec(collateral(account), havven.price()), \n', '                    havven.nominsIssued(account));\n', '    }\n', '\n', '\n', '    /********************************\\\n', '      totalIssuerCollateralisation()\n', '    \n', '      Reports the collateralisation\n', '      ratio of all issuers, assuming\n', '      a nomin price of one dollar.\n', '    \\********************************/\n', '\n', '    function totalIssuerCollateralisation()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        safeDiv_dec(safeMul_dec(totalIssuingCollateral(), havven.price()),\n', '                    nomin.totalSupply());\n', '    }\n', '\n', '\n', '    /********************************\\\n', '      totalNetworkCollateralisation()\n', '    \n', '      Reports the collateralisation\n', '      ratio of the entire network,\n', '      assuming a nomin price of one\n', '      dollar, and that havvens can\n', '      flow from non-issuer to issuer\n', '      accounts.\n', '    \\********************************/\n', '\n', '    function totalNetworkCollateralisation()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        safeDiv_dec(safeMul_dec(havven.totalSupply(), havven.price()),\n', '                    nomin.totalSupply());\n', '    }\n', '\n', '\n', '    /**************************************\\\n', '      totalIssuanceDebt()\n', '\n', '      Reports the the (unbounded) number\n', '      of havvens that would be locked by\n', '      all issued nomins, if the collateral\n', '      backing them was unlimited.\n', '    \\**************************************/\n', '\n', '    function totalIssuanceDebt()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return safeDiv_dec(nomin.totalSupply(),\n', '                           safeMul_dec(havven.issuanceRatio(), havven.price()));\n', '    }\n', '\n', '    function totalIssuanceDebt_limitedSum()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint sum;\n', '        uint limit = min(maxIssuers, issuers.length);\n', '        for (uint i = 0; i < limit; i++) {\n', '            sum += havven.nominsIssued(issuers[i]);\n', '        }\n', '        return safeDiv_dec(sum,\n', '                           safeMul_dec(havven.issuanceRatio(), havven.price()));\n', '    }\n', '\n', '\n', '    /*************************************\\\n', '      totalLockedHavvens()\n', '\n', '      Reports the the number of havvens\n', '      locked by all issued nomins.\n', '      This is capped by the actual number\n', '      of havvens in circulation.\n', '    \\*************************************/\n', '\n', '    function totalLockedHavvens()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return min(totalIssuanceDebt(), totalIssuingCollateral());\n', '    }\n', '\n', '    function totalLockedHavvens_limitedSum()\n', '        public\n', '        view\n', '        returns (uint)\n', '    { \n', '        return min(totalIssuanceDebt_limitedSum(), totalIssuingCollateral());\n', '    }\n', '\n', '\n', '    /****************************************************\\\n', '      totalLockedHavvens_byAvailableHavvens_limitedSum()\n', '      \n', '      Should be equivalent to\n', '      totalLockedHavvens_limitedSum() but it uses an\n', '      alternate computation method.\n', '    \\****************************************************/\n', '\n', '    function totalLockedHavvens_byAvailableHavvens_limitedSum()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint sum;\n', '        uint limit = min(maxIssuers, issuers.length);\n', '        for (uint i = 0; i < limit; i++) {\n', '            address issuer = issuers[i];\n', '            sum += safeSub(collateral(issuer), havven.availableHavvens(issuer));\n', '        }\n', '        return sum;\n', '    }\n', '}']
