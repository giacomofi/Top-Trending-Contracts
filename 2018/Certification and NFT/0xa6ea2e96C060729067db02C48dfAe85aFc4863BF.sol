['pragma solidity ^0.4.17;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Etharea {\n', '    using SafeMath for uint;\n', '    struct Area {\n', '        string id;\n', '        uint price;\n', '        address owner;\n', '        uint lastUpdate;\n', '    }\n', '\n', '    address manager;\n', '    Area[] public soldAreas;\n', '    mapping(string => address) areaIdToOwner;\n', '    mapping(string => uint) areaIdToIndex;\n', '    mapping(string => bool) enabledAreas;\n', '    uint public defaultPrice = 0.01 ether;\n', '\n', '    modifier onlyOwner() {\n', '        require(manager == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier percentage(uint percents) {\n', '        require(percents >= 0 && percents <= 100);\n', '        _;\n', '    }\n', '\n', '    function Etharea() public {\n', '        manager = msg.sender;\n', '    }\n', '\n', '    function buy(string areaId) public payable {\n', '        require(msg.sender != address(0));\n', '        require(!isContract(msg.sender));\n', '        require(areaIdToOwner[areaId] != msg.sender);\n', '        require(enabledAreas[areaId]);\n', '        if (areaIdToOwner[areaId] == address(0)) {\n', '            firstBuy(areaId);\n', '        } else {\n', '            buyFromOwner(areaId);\n', '        }\n', '        manager.transfer(address(this).balance);\n', '    }\n', '\n', '    function firstBuy(string areaId) private {\n', '        uint priceRisePercent;\n', '        (priceRisePercent,) = getPriceRiseAndFeePercent(defaultPrice);\n', '        require(msg.value == defaultPrice);\n', '        Area memory newArea = Area({\n', '            id: areaId,\n', '            price: defaultPrice.div(100).mul(priceRisePercent.add(100)),\n', '            owner: msg.sender,\n', '            lastUpdate: now\n', '            });\n', '\n', '        uint index = soldAreas.push(newArea).sub(1);\n', '        areaIdToIndex[areaId] = index;\n', '        areaIdToOwner[areaId] = msg.sender;\n', '    }\n', '\n', '    function buyFromOwner(string areaId) private {\n', '        Area storage areaToChange = soldAreas[areaIdToIndex[areaId]];\n', '        require(msg.value == areaToChange.price);\n', '\n', '        uint priceRisePercent;\n', '        uint transactionFeePercent;\n', '        (priceRisePercent, transactionFeePercent) = getPriceRiseAndFeePercent(areaToChange.price);\n', '        address oldOwner = areaIdToOwner[areaId];\n', '        uint payment = msg.value.div(100).mul(uint(100).sub(transactionFeePercent));\n', '        uint newPrice = areaToChange.price.div(100).mul(priceRisePercent.add(100));\n', '\n', '        areaToChange.owner = msg.sender;\n', '        areaToChange.lastUpdate = now;\n', '        areaIdToOwner[areaId] = msg.sender;\n', '        areaToChange.price = newPrice;\n', '        oldOwner.transfer(payment);\n', '    }\n', '\n', '    function getSoldAreasCount() public view returns (uint) {\n', '        return soldAreas.length;\n', '    }\n', '\n', '    function getBalance() public onlyOwner view returns (uint) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function getAreaOwner(string areaId) public view returns (address) {\n', '        return areaIdToOwner[areaId];\n', '    }\n', '\n', '    function getAreaIndex(string areaId) public view returns (uint) {\n', '        uint areaIndex = areaIdToIndex[areaId];\n', '        Area memory area = soldAreas[areaIndex];\n', '        require(keccak256(area.id) == keccak256(areaId));\n', '        return areaIndex;\n', '    }\n', '\n', '    function setDefaultPrice(uint newPrice) public onlyOwner {\n', '        defaultPrice = newPrice;\n', '    }\n', '\n', '    function withdraw() public onlyOwner {\n', '        require(address(this).balance > 0);\n', '        manager.transfer(address(this).balance);\n', '    }\n', '\n', '    function getPriceRiseAndFeePercent(uint currentPrice)\n', '    public pure returns (uint, uint)\n', '    {\n', '        if (currentPrice >= 0.01 ether && currentPrice < 0.15 ether) {\n', '            return (100, 10);\n', '        }\n', '\n', '        if (currentPrice >= 0.15 ether && currentPrice < 1 ether) {\n', '            return (60, 6);\n', '        }\n', '\n', '        if (currentPrice >= 1 ether && currentPrice < 4 ether) {\n', '            return (40, 5);\n', '        }\n', '\n', '        if (currentPrice >= 4 ether && currentPrice < 10 ether) {\n', '            return (30, 4);\n', '        }\n', '\n', '        if (currentPrice >= 10 ether) {\n', '            return (25, 3);\n', '        }\n', '    }\n', '\n', '    function enableArea(string areaId) public onlyOwner {\n', '        require(!enabledAreas[areaId]);\n', '        enabledAreas[areaId] = true;\n', '    }\n', '\n', '    function isAreaEnabled(string areaId) public view returns (bool) {\n', '        return enabledAreas[areaId];\n', '    }\n', '\n', '    function isContract(address userAddress) internal view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(userAddress) }\n', '        return size > 0;\n', '    }\n', '}']