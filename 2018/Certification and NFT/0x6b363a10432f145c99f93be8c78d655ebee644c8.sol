['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Utility contract to allow pausing and unpausing of certain functions\n', ' */\n', 'contract Pausable {\n', '\n', '    event Pause(uint256 _timestammp);\n', '    event Unpause(uint256 _timestamp);\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused, "Contract is paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused, "Contract is not paused");\n', '        _;\n', '    }\n', '\n', '   /**\n', '    * @notice Called by the owner to pause, triggers stopped state\n', '    */\n', '    function _pause() internal whenNotPaused {\n', '        paused = true;\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        emit Pause(now);\n', '    }\n', '\n', '    /**\n', '    * @notice Called by the owner to unpause, returns to normal state\n', '    */\n', '    function _unpause() internal whenPaused {\n', '        paused = false;\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        emit Unpause(now);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface that every module contract should implement\n', ' */\n', 'interface IModule {\n', '\n', '    /**\n', '     * @notice This function returns the signature of configure function\n', '     */\n', '    function getInitFunction() external pure returns (bytes4);\n', '\n', '    /**\n', '     * @notice Return the permission flags that are associated with a module\n', '     */\n', '    function getPermissions() external view returns(bytes32[]);\n', '\n', '    /**\n', '     * @notice Used to withdraw the fee by the factory owner\n', '     */\n', '    function takeFee(uint256 _amount) external returns(bool);\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface for all security tokens\n', ' */\n', 'interface ISecurityToken {\n', '\n', '    // Standard ERC20 interface\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function allowance(address _owner, address _spender) external view returns (uint256);\n', '    function transfer(address _to, uint256 _value) external returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '    function approve(address _spender, uint256 _value) external returns (bool);\n', '    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\n', '    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    //transfer, transferFrom must respect the result of verifyTransfer\n', '    function verifyTransfer(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    /**\n', '     * @notice Mints new tokens and assigns them to the target _investor.\n', "     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\n", '     * @param _investor Address the tokens will be minted to\n', '     * @param _value is the amount of tokens that will be minted to the investor\n', '     */\n', '    function mint(address _investor, uint256 _value) external returns (bool success);\n', '\n', '    /**\n', '     * @notice Mints new tokens and assigns them to the target _investor.\n', "     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\n", '     * @param _investor Address the tokens will be minted to\n', '     * @param _value is The amount of tokens that will be minted to the investor\n', '     * @param _data Data to indicate validation\n', '     */\n', '    function mintWithData(address _investor, uint256 _value, bytes _data) external returns (bool success);\n', '\n', '    /**\n', '     * @notice Used to burn the securityToken on behalf of someone else\n', '     * @param _from Address for whom to burn tokens\n', '     * @param _value No. of tokens to be burned\n', '     * @param _data Data to indicate validation\n', '     */\n', '    function burnFromWithData(address _from, uint256 _value, bytes _data) external;\n', '\n', '    /**\n', '     * @notice Used to burn the securityToken\n', '     * @param _value No. of tokens to be burned\n', '     * @param _data Data to indicate validation\n', '     */\n', '    function burnWithData(uint256 _value, bytes _data) external;\n', '\n', '    event Minted(address indexed _to, uint256 _value);\n', '    event Burnt(address indexed _burner, uint256 _value);\n', '\n', '    // Permissions this to a Permission module, which has a key of 1\n', '    // If no Permission return false - note that IModule withPerm will allow ST owner all permissions anyway\n', '    // this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n', '    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns (bool);\n', '\n', '    /**\n', '     * @notice Returns module list for a module type\n', '     * @param _module Address of the module\n', '     * @return bytes32 Name\n', '     * @return address Module address\n', '     * @return address Module factory address\n', '     * @return bool Module archived\n', '     * @return uint8 Module type\n', '     * @return uint256 Module index\n', '     * @return uint256 Name index\n', '\n', '     */\n', '    function getModule(address _module) external view returns(bytes32, address, address, bool, uint8, uint256, uint256);\n', '\n', '    /**\n', '     * @notice Returns module list for a module name\n', '     * @param _name Name of the module\n', '     * @return address[] List of modules with this name\n', '     */\n', '    function getModulesByName(bytes32 _name) external view returns (address[]);\n', '\n', '    /**\n', '     * @notice Returns module list for a module type\n', '     * @param _type Type of the module\n', '     * @return address[] List of modules with this type\n', '     */\n', '    function getModulesByType(uint8 _type) external view returns (address[]);\n', '\n', '    /**\n', '     * @notice Queries totalSupply at a specified checkpoint\n', '     * @param _checkpointId Checkpoint ID to query as of\n', '     */\n', '    function totalSupplyAt(uint256 _checkpointId) external view returns (uint256);\n', '\n', '    /**\n', '     * @notice Queries balance at a specified checkpoint\n', '     * @param _investor Investor to query balance for\n', '     * @param _checkpointId Checkpoint ID to query as of\n', '     */\n', '    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns (uint256);\n', '\n', '    /**\n', '     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\n', '     */\n', '    function createCheckpoint() external returns (uint256);\n', '\n', '    /**\n', '     * @notice Gets length of investors array\n', '     * NB - this length may differ from investorCount if the list has not been pruned of zero-balance investors\n', '     * @return Length\n', '     */\n', '    function getInvestors() external view returns (address[]);\n', '\n', '    /**\n', '     * @notice returns an array of investors at a given checkpoint\n', '     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n', '     * @param _checkpointId Checkpoint id at which investor list is to be populated\n', '     * @return list of investors\n', '     */\n', '    function getInvestorsAt(uint256 _checkpointId) external view returns(address[]);\n', '\n', '    /**\n', '     * @notice generates subset of investors\n', '     * NB - can be used in batches if investor list is large\n', '     * @param _start Position of investor to start iteration from\n', '     * @param _end Position of investor to stop iteration at\n', '     * @return list of investors\n', '     */\n', '    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[]);\n', '    \n', '    /**\n', '     * @notice Gets current checkpoint ID\n', '     * @return Id\n', '     */\n', '    function currentCheckpointId() external view returns (uint256);\n', '\n', '    /**\n', '    * @notice Gets an investor at a particular index\n', '    * @param _index Index to return address from\n', '    * @return Investor address\n', '    */\n', '    function investors(uint256 _index) external view returns (address);\n', '\n', '   /**\n', '    * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\n', '    * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\n', '    * @param _tokenContract Address of the ERC20Basic compliance token\n', '    * @param _value Amount of POLY to withdraw\n', '    */\n', '    function withdrawERC20(address _tokenContract, uint256 _value) external;\n', '\n', '    /**\n', '    * @notice Allows owner to approve more POLY to one of the modules\n', '    * @param _module Module address\n', '    * @param _budget New budget\n', '    */\n', '    function changeModuleBudget(address _module, uint256 _budget) external;\n', '\n', '    /**\n', '     * @notice Changes the tokenDetails\n', '     * @param _newTokenDetails New token details\n', '     */\n', '    function updateTokenDetails(string _newTokenDetails) external;\n', '\n', '    /**\n', '    * @notice Allows the owner to change token granularity\n', '    * @param _granularity Granularity level of the token\n', '    */\n', '    function changeGranularity(uint256 _granularity) external;\n', '\n', '    /**\n', '    * @notice Removes addresses with zero balances from the investors list\n', '    * @param _start Index in investors list at which to start removing zero balances\n', '    * @param _iters Max number of iterations of the for loop\n', '    * NB - pruning this list will mean you may not be able to iterate over investors on-chain as of a historical checkpoint\n', '    */\n', '    function pruneInvestors(uint256 _start, uint256 _iters) external;\n', '\n', '    /**\n', '     * @notice Freezes all the transfers\n', '     */\n', '    function freezeTransfers() external;\n', '\n', '    /**\n', '     * @notice Un-freezes all the transfers\n', '     */\n', '    function unfreezeTransfers() external;\n', '\n', '    /**\n', '     * @notice Ends token minting period permanently\n', '     */\n', '    function freezeMinting() external;\n', '\n', '    /**\n', '     * @notice Mints new tokens and assigns them to the target investors.\n', '     * Can only be called by the STO attached to the token or by the Issuer (Security Token contract owner)\n', '     * @param _investors A list of addresses to whom the minted tokens will be delivered\n', '     * @param _values A list of the amount of tokens to mint to corresponding addresses from _investor[] list\n', '     * @return Success\n', '     */\n', '    function mintMulti(address[] _investors, uint256[] _values) external returns (bool success);\n', '\n', '    /**\n', '     * @notice Function used to attach a module to the security token\n', '     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n', '     * @dev to control restrictions on transfers.\n', '     * @dev You are allowed to add a new moduleType if:\n', '     * @dev - there is no existing module of that type yet added\n', '     * @dev - the last member of the module list is replacable\n', '     * @param _moduleFactory is the address of the module factory to be added\n', '     * @param _data is data packed into bytes used to further configure the module (See STO usage)\n', '     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\n', '     */\n', '    function addModule(\n', '        address _moduleFactory,\n', '        bytes _data,\n', '        uint256 _maxCost,\n', '        uint256 _budget\n', '    ) external;\n', '\n', '    /**\n', '    * @notice Archives a module attached to the SecurityToken\n', '    * @param _module address of module to archive\n', '    */\n', '    function archiveModule(address _module) external;\n', '\n', '    /**\n', '    * @notice Unarchives a module attached to the SecurityToken\n', '    * @param _module address of module to unarchive\n', '    */\n', '    function unarchiveModule(address _module) external;\n', '\n', '    /**\n', '    * @notice Removes a module attached to the SecurityToken\n', '    * @param _module address of module to archive\n', '    */\n', '    function removeModule(address _module) external;\n', '\n', '    /**\n', '     * @notice Used by the issuer to set the controller addresses\n', '     * @param _controller address of the controller\n', '     */\n', '    function setController(address _controller) external;\n', '\n', '    /**\n', '     * @notice Used by a controller to execute a forced transfer\n', '     * @param _from address from which to take tokens\n', '     * @param _to address where to send tokens\n', '     * @param _value amount of tokens to transfer\n', '     * @param _data data to indicate validation\n', '     * @param _log data attached to the transfer by controller to emit in event\n', '     */\n', '    function forceTransfer(address _from, address _to, uint256 _value, bytes _data, bytes _log) external;\n', '\n', '    /**\n', '     * @notice Used by a controller to execute a foced burn\n', '     * @param _from address from which to take tokens\n', '     * @param _value amount of tokens to transfer\n', '     * @param _data data to indicate validation\n', '     * @param _log data attached to the transfer by controller to emit in event\n', '     */\n', '    function forceBurn(address _from, uint256 _value, bytes _data, bytes _log) external;\n', '\n', '    /**\n', '     * @notice Used by the issuer to permanently disable controller functionality\n', '     * @dev enabled via feature switch "disableControllerAllowed"\n', '     */\n', '     function disableController() external;\n', '\n', '     /**\n', '     * @notice Used to get the version of the securityToken\n', '     */\n', '     function getVersion() external view returns(uint8[]);\n', '\n', '     /**\n', '     * @notice Gets the investor count\n', '     */\n', '     function getInvestorCount() external view returns(uint256);\n', '\n', '     /**\n', '      * @notice Overloaded version of the transfer function\n', '      * @param _to receiver of transfer\n', '      * @param _value value of transfer\n', '      * @param _data data to indicate validation\n', '      * @return bool success\n', '      */\n', '     function transferWithData(address _to, uint256 _value, bytes _data) external returns (bool success);\n', '\n', '     /**\n', '      * @notice Overloaded version of the transferFrom function\n', '      * @param _from sender of transfer\n', '      * @param _to receiver of transfer\n', '      * @param _value value of transfer\n', '      * @param _data data to indicate validation\n', '      * @return bool success\n', '      */\n', '     function transferFromWithData(address _from, address _to, uint256 _value, bytes _data) external returns(bool);\n', '\n', '     /**\n', '      * @notice Provides the granularity of the token\n', '      * @return uint256\n', '      */\n', '     function granularity() external view returns(uint256);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function allowance(address _owner, address _spender) external view returns (uint256);\n', '    function transfer(address _to, uint256 _value) external returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '    function approve(address _spender, uint256 _value) external returns (bool);\n', '    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\n', '    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Interface that any module contract should implement\n', ' * @notice Contract is abstract\n', ' */\n', 'contract Module is IModule {\n', '\n', '    address public factory;\n', '\n', '    address public securityToken;\n', '\n', '    bytes32 public constant FEE_ADMIN = "FEE_ADMIN";\n', '\n', '    IERC20 public polyToken;\n', '\n', '    /**\n', '     * @notice Constructor\n', '     * @param _securityToken Address of the security token\n', '     * @param _polyAddress Address of the polytoken\n', '     */\n', '    constructor (address _securityToken, address _polyAddress) public {\n', '        securityToken = _securityToken;\n', '        factory = msg.sender;\n', '        polyToken = IERC20(_polyAddress);\n', '    }\n', '\n', '    //Allows owner, factory or permissioned delegate\n', '    modifier withPerm(bytes32 _perm) {\n', '        bool isOwner = msg.sender == Ownable(securityToken).owner();\n', '        bool isFactory = msg.sender == factory;\n', '        require(isOwner||isFactory||ISecurityToken(securityToken).checkPermission(msg.sender, address(this), _perm), "Permission check failed");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == Ownable(securityToken).owner(), "Sender is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyFactory {\n', '        require(msg.sender == factory, "Sender is not factory");\n', '        _;\n', '    }\n', '\n', '    modifier onlyFactoryOwner {\n', '        require(msg.sender == Ownable(factory).owner(), "Sender is not factory owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyFactoryOrOwner {\n', '        require((msg.sender == Ownable(securityToken).owner()) || (msg.sender == factory), "Sender is not factory or owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice used to withdraw the fee by the factory owner\n', '     */\n', '    function takeFee(uint256 _amount) public withPerm(FEE_ADMIN) returns(bool) {\n', '        require(polyToken.transferFrom(securityToken, Ownable(factory).owner(), _amount), "Unable to take fee");\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Interface to be implemented by all STO modules\n', ' */\n', 'contract ISTO is Module, Pausable  {\n', '    using SafeMath for uint256;\n', '\n', '    enum FundRaiseType { ETH, POLY, DAI }\n', '    mapping (uint8 => bool) public fundRaiseTypes;\n', '    mapping (uint8 => uint256) public fundsRaised;\n', '\n', '    // Start time of the STO\n', '    uint256 public startTime;\n', '    // End time of the STO\n', '    uint256 public endTime;\n', '    // Time STO was paused\n', '    uint256 public pausedTime;\n', '    // Number of individual investors\n', '    uint256 public investorCount;\n', '    // Address where ETH & POLY funds are delivered\n', '    address public wallet;\n', '     // Final amount of tokens sold\n', '    uint256 public totalTokensSold;\n', '\n', '    // Event\n', '    event SetFundRaiseTypes(FundRaiseType[] _fundRaiseTypes);\n', '\n', '    /**\n', '    * @notice Reclaims ERC20Basic compatible tokens\n', '    * @dev We duplicate here due to the overriden owner & onlyOwner\n', '    * @param _tokenContract The address of the token contract\n', '    */\n', '    function reclaimERC20(address _tokenContract) external onlyOwner {\n', '        require(_tokenContract != address(0), "Invalid address");\n', '        IERC20 token = IERC20(_tokenContract);\n', '        uint256 balance = token.balanceOf(address(this));\n', '        require(token.transfer(msg.sender, balance), "Transfer failed");\n', '    }\n', '\n', '    /**\n', '     * @notice Returns funds raised by the STO\n', '     */\n', '    function getRaised(FundRaiseType _fundRaiseType) public view returns (uint256) {\n', '        return fundsRaised[uint8(_fundRaiseType)];\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the total no. of tokens sold\n', '     */\n', '    function getTokensSold() public view returns (uint256);\n', '\n', '    /**\n', '     * @notice Pause (overridden function)\n', '     */\n', '    function pause() public onlyOwner {\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        require(now < endTime, "STO has been finalized");\n', '        super._pause();\n', '    }\n', '\n', '    /**\n', '     * @notice Unpause (overridden function)\n', '     */\n', '    function unpause() public onlyOwner {\n', '        super._unpause();\n', '    }\n', '\n', '    function _setFundRaiseType(FundRaiseType[] _fundRaiseTypes) internal {\n', '        // FundRaiseType[] parameter type ensures only valid values for _fundRaiseTypes\n', '        require(_fundRaiseTypes.length > 0, "Raise type is not specified");\n', '        fundRaiseTypes[uint8(FundRaiseType.ETH)] = false;\n', '        fundRaiseTypes[uint8(FundRaiseType.POLY)] = false;\n', '        fundRaiseTypes[uint8(FundRaiseType.DAI)] = false;\n', '        for (uint8 j = 0; j < _fundRaiseTypes.length; j++) {\n', '            fundRaiseTypes[uint8(_fundRaiseTypes[j])] = true;\n', '        }\n', '        emit SetFundRaiseTypes(_fundRaiseTypes);\n', '    }\n', '\n', '}\n', '\n', 'interface IOracle {\n', '\n', '    /**\n', '    * @notice Returns address of oracle currency (0x0 for ETH)\n', '    */\n', '    function getCurrencyAddress() external view returns(address);\n', '\n', '    /**\n', '    * @notice Returns symbol of oracle currency (0x0 for ETH)\n', '    */\n', '    function getCurrencySymbol() external view returns(bytes32);\n', '\n', '    /**\n', '    * @notice Returns denomination of price\n', '    */\n', '    function getCurrencyDenominated() external view returns(bytes32);\n', '\n', '    /**\n', '    * @notice Returns price - should throw if not valid\n', '    */\n', '    function getPrice() external view returns(uint256);\n', '\n', '}\n', '\n', '/**\n', ' * @title Utility contract to allow owner to retreive any ERC20 sent to the contract\n', ' */\n', 'contract ReclaimTokens is Ownable {\n', '\n', '    /**\n', '    * @notice Reclaim all ERC20Basic compatible tokens\n', '    * @param _tokenContract The address of the token contract\n', '    */\n', '    function reclaimERC20(address _tokenContract) external onlyOwner {\n', '        require(_tokenContract != address(0), "Invalid address");\n', '        IERC20 token = IERC20(_tokenContract);\n', '        uint256 balance = token.balanceOf(address(this));\n', '        require(token.transfer(owner, balance), "Transfer failed");\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Core functionality for registry upgradability\n', ' */\n', 'contract PolymathRegistry is ReclaimTokens {\n', '\n', '    mapping (bytes32 => address) public storedAddresses;\n', '\n', '    event ChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);\n', '\n', '    /**\n', '     * @notice Gets the contract address\n', '     * @param _nameKey is the key for the contract address mapping\n', '     * @return address\n', '     */\n', '    function getAddress(string _nameKey) external view returns(address) {\n', '        bytes32 key = keccak256(bytes(_nameKey));\n', '        require(storedAddresses[key] != address(0), "Invalid address key");\n', '        return storedAddresses[key];\n', '    }\n', '\n', '    /**\n', '     * @notice Changes the contract address\n', '     * @param _nameKey is the key for the contract address mapping\n', '     * @param _newAddress is the new contract address\n', '     */\n', '    function changeAddress(string _nameKey, address _newAddress) external onlyOwner {\n', '        bytes32 key = keccak256(bytes(_nameKey));\n', '        emit ChangeAddress(_nameKey, storedAddresses[key], _newAddress);\n', '        storedAddresses[key] = _newAddress;\n', '    }\n', '\n', '\n', '}\n', '\n', 'contract RegistryUpdater is Ownable {\n', '\n', '    address public polymathRegistry;\n', '    address public moduleRegistry;\n', '    address public securityTokenRegistry;\n', '    address public featureRegistry;\n', '    address public polyToken;\n', '\n', '    constructor (address _polymathRegistry) public {\n', '        require(_polymathRegistry != address(0), "Invalid address");\n', '        polymathRegistry = _polymathRegistry;\n', '    }\n', '\n', '    function updateFromRegistry() public onlyOwner {\n', '        moduleRegistry = PolymathRegistry(polymathRegistry).getAddress("ModuleRegistry");\n', '        securityTokenRegistry = PolymathRegistry(polymathRegistry).getAddress("SecurityTokenRegistry");\n', '        featureRegistry = PolymathRegistry(polymathRegistry).getAddress("FeatureRegistry");\n', '        polyToken = PolymathRegistry(polymathRegistry).getAddress("PolyToken");\n', '    }\n', '\n', '}\n', '\n', 'library DecimalMath {\n', '\n', '    using SafeMath for uint256;\n', '\n', '     /**\n', '     * @notice This function multiplies two decimals represented as (decimal * 10**DECIMALS)\n', '     * @return uint256 Result of multiplication represented as (decimal * 10**DECIMALS)\n', '     */\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = SafeMath.add(SafeMath.mul(x, y), (10 ** 18) / 2) / (10 ** 18);\n', '    }\n', '\n', '    /**\n', '     * @notice This function divides two decimals represented as (decimal * 10**DECIMALS)\n', '     * @return uint256 Result of division represented as (decimal * 10**DECIMALS)\n', '     */\n', '    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = SafeMath.add(SafeMath.mul(x, (10 ** 18)), y / 2) / y;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Helps contracts guard agains reentrancy attacks.\n', ' * @author Remco Bloemen <remco@2Ï€.com>\n', ' * @notice If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancyLock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancyLock);\n', '    reentrancyLock = true;\n', '    _;\n', '    reentrancyLock = false;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title STO module for standard capped crowdsale\n', ' */\n', 'contract USDTieredSTO is ISTO, ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '\n', '    /////////////\n', '    // Storage //\n', '    /////////////\n', '\n', '    string public POLY_ORACLE = "PolyUsdOracle";\n', '    string public ETH_ORACLE = "EthUsdOracle";\n', '    mapping (bytes32 => mapping (bytes32 => string)) oracleKeys;\n', '\n', '    IERC20 public usdToken;\n', '\n', '    // Determine whether users can invest on behalf of a beneficiary\n', '    bool public allowBeneficialInvestments = false;\n', '\n', '    // Address where ETH, POLY & DAI funds are delivered\n', '    address public wallet;\n', '\n', '    // Address of issuer reserve wallet for unsold tokens\n', '    address public reserveWallet;\n', '\n', '    // How many token units a buyer gets per USD per tier (multiplied by 10**18)\n', '    uint256[] public ratePerTier;\n', '\n', '    // How many token units a buyer gets per USD per tier (multiplied by 10**18) when investing in POLY up to tokensPerTierDiscountPoly\n', '    uint256[] public ratePerTierDiscountPoly;\n', '\n', '    // How many tokens are available in each tier (relative to totalSupply)\n', '    uint256[] public tokensPerTierTotal;\n', '\n', '    // How many token units are available in each tier (relative to totalSupply) at the ratePerTierDiscountPoly rate\n', '    uint256[] public tokensPerTierDiscountPoly;\n', '\n', '    // How many tokens have been minted in each tier (relative to totalSupply)\n', '    uint256[] public mintedPerTierTotal;\n', '\n', '    // How many tokens have been minted in each tier (relative to totalSupply) for each fund raise type\n', '    mapping (uint8 => uint256[]) public mintedPerTier;\n', '\n', '    // How many tokens have been minted in each tier (relative to totalSupply) at discounted POLY rate\n', '    uint256[] public mintedPerTierDiscountPoly;\n', '\n', '    // Current tier\n', '    uint8 public currentTier;\n', '\n', '    // Amount of USD funds raised\n', '    uint256 public fundsRaisedUSD;\n', '\n', '    // Amount in USD invested by each address\n', '    mapping (address => uint256) public investorInvestedUSD;\n', '\n', '    // Amount in fund raise type invested by each investor\n', '    mapping (address => mapping (uint8 => uint256)) public investorInvested;\n', '\n', '    // List of accredited investors\n', '    mapping (address => bool) public accredited;\n', '\n', '    // Default limit in USD for non-accredited investors multiplied by 10**18\n', '    uint256 public nonAccreditedLimitUSD;\n', '\n', '    // Overrides for default limit in USD for non-accredited investors multiplied by 10**18\n', '    mapping (address => uint256) public nonAccreditedLimitUSDOverride;\n', '\n', '    // Minimum investable amount in USD\n', '    uint256 public minimumInvestmentUSD;\n', '\n', '    // Whether or not the STO has been finalized\n', '    bool public isFinalized;\n', '\n', '    // Final amount of tokens returned to issuer\n', '    uint256 public finalAmountReturned;\n', '\n', '    ////////////\n', '    // Events //\n', '    ////////////\n', '\n', '    event SetAllowBeneficialInvestments(bool _allowed);\n', '    event SetNonAccreditedLimit(address _investor, uint256 _limit);\n', '    event SetAccredited(address _investor, bool _accredited);\n', '    event TokenPurchase(\n', '        address indexed _purchaser,\n', '        address indexed _beneficiary,\n', '        uint256 _tokens,\n', '        uint256 _usdAmount,\n', '        uint256 _tierPrice,\n', '        uint8 _tier\n', '    );\n', '    event FundsReceived(\n', '        address indexed _purchaser,\n', '        address indexed _beneficiary,\n', '        uint256 _usdAmount,\n', '        FundRaiseType _fundRaiseType,\n', '        uint256 _receivedValue,\n', '        uint256 _spentValue,\n', '        uint256 _rate\n', '    );\n', '    event FundsReceivedPOLY(\n', '        address indexed _purchaser,\n', '        address indexed _beneficiary,\n', '        uint256 _usdAmount,\n', '        uint256 _receivedValue,\n', '        uint256 _spentValue,\n', '        uint256 _rate\n', '    );\n', '    event ReserveTokenMint(address indexed _owner, address indexed _wallet, uint256 _tokens, uint8 _latestTier);\n', '\n', '    event SetAddresses(\n', '        address indexed _wallet,\n', '        address indexed _reserveWallet,\n', '        address indexed _usdToken\n', '    );\n', '    event SetLimits(\n', '        uint256 _nonAccreditedLimitUSD,\n', '        uint256 _minimumInvestmentUSD\n', '    );\n', '    event SetTimes(\n', '        uint256 _startTime,\n', '        uint256 _endTime\n', '    );\n', '    event SetTiers(\n', '        uint256[] _ratePerTier,\n', '        uint256[] _ratePerTierDiscountPoly,\n', '        uint256[] _tokensPerTierTotal,\n', '        uint256[] _tokensPerTierDiscountPoly\n', '    );\n', '\n', '    ///////////////\n', '    // Modifiers //\n', '    ///////////////\n', '\n', '    modifier validETH {\n', '        require(_getOracle(bytes32("ETH"), bytes32("USD")) != address(0), "Invalid ETHUSD Oracle");\n', '        require(fundRaiseTypes[uint8(FundRaiseType.ETH)], "Fund raise in ETH should be allowed");\n', '        _;\n', '    }\n', '\n', '    modifier validPOLY {\n', '        require(_getOracle(bytes32("POLY"), bytes32("USD")) != address(0), "Invalid POLYUSD Oracle");\n', '        require(fundRaiseTypes[uint8(FundRaiseType.POLY)], "Fund raise in POLY should be allowed");\n', '        _;\n', '    }\n', '\n', '    modifier validDAI {\n', '        require(fundRaiseTypes[uint8(FundRaiseType.DAI)], "Fund raise in DAI should be allowed");\n', '        _;\n', '    }\n', '\n', '    ///////////////////////\n', '    // STO Configuration //\n', '    ///////////////////////\n', '\n', '    constructor (address _securityToken, address _polyAddress, address _factory) public Module(_securityToken, _polyAddress) {\n', '        oracleKeys[bytes32("ETH")][bytes32("USD")] = ETH_ORACLE;\n', '        oracleKeys[bytes32("POLY")][bytes32("USD")] = POLY_ORACLE;\n', '        require(_factory != address(0), "In-valid address");\n', '        factory = _factory;\n', '    }\n', '\n', '    /**\n', '     * @notice Function used to intialize the contract variables\n', '     * @param _startTime Unix timestamp at which offering get started\n', '     * @param _endTime Unix timestamp at which offering get ended\n', '     * @param _ratePerTier Rate (in USD) per tier (* 10**18)\n', '     * @param _tokensPerTierTotal Tokens available in each tier\n', '     * @param _nonAccreditedLimitUSD Limit in USD (* 10**18) for non-accredited investors\n', '     * @param _minimumInvestmentUSD Minimun investment in USD (* 10**18)\n', '     * @param _fundRaiseTypes Types of currency used to collect the funds\n', '     * @param _wallet Ethereum account address to hold the funds\n', '     * @param _reserveWallet Ethereum account address to receive unsold tokens\n', '     * @param _usdToken Contract address of the stable coin\n', '     */\n', '    function configure(\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        uint256[] _ratePerTier,\n', '        uint256[] _ratePerTierDiscountPoly,\n', '        uint256[] _tokensPerTierTotal,\n', '        uint256[] _tokensPerTierDiscountPoly,\n', '        uint256 _nonAccreditedLimitUSD,\n', '        uint256 _minimumInvestmentUSD,\n', '        FundRaiseType[] _fundRaiseTypes,\n', '        address _wallet,\n', '        address _reserveWallet,\n', '        address _usdToken\n', '    ) public onlyFactory {\n', '        modifyTimes(_startTime, _endTime);\n', '        // NB - modifyTiers must come before modifyFunding\n', '        modifyTiers(_ratePerTier, _ratePerTierDiscountPoly, _tokensPerTierTotal, _tokensPerTierDiscountPoly);\n', '        // NB - modifyFunding must come before modifyAddresses\n', '        modifyFunding(_fundRaiseTypes);\n', '        modifyAddresses(_wallet, _reserveWallet, _usdToken);\n', '        modifyLimits(_nonAccreditedLimitUSD, _minimumInvestmentUSD);\n', '    }\n', '\n', '    function modifyFunding(FundRaiseType[] _fundRaiseTypes) public onlyFactoryOrOwner {\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        require(now < startTime, "STO shouldn\'t be started");\n', '        _setFundRaiseType(_fundRaiseTypes);\n', '        uint256 length = getNumberOfTiers();\n', '        mintedPerTierTotal = new uint256[](length);\n', '        mintedPerTierDiscountPoly = new uint256[](length);\n', '        for (uint8 i = 0; i < _fundRaiseTypes.length; i++) {\n', '            mintedPerTier[uint8(_fundRaiseTypes[i])] = new uint256[](length);\n', '        }\n', '    }\n', '\n', '    function modifyLimits(\n', '        uint256 _nonAccreditedLimitUSD,\n', '        uint256 _minimumInvestmentUSD\n', '    ) public onlyFactoryOrOwner {\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        require(now < startTime, "STO shouldn\'t be started");\n', '        minimumInvestmentUSD = _minimumInvestmentUSD;\n', '        nonAccreditedLimitUSD = _nonAccreditedLimitUSD;\n', '        emit SetLimits(minimumInvestmentUSD, nonAccreditedLimitUSD);\n', '    }\n', '\n', '    function modifyTiers(\n', '        uint256[] _ratePerTier,\n', '        uint256[] _ratePerTierDiscountPoly,\n', '        uint256[] _tokensPerTierTotal,\n', '        uint256[] _tokensPerTierDiscountPoly\n', '    ) public onlyFactoryOrOwner {\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        require(now < startTime, "STO shouldn\'t be started");\n', '        require(_tokensPerTierTotal.length > 0, "Length should be > 0");\n', '        require(_ratePerTier.length == _tokensPerTierTotal.length, "Mismatch b/w rates & tokens / tier");\n', '        require(_ratePerTierDiscountPoly.length == _tokensPerTierTotal.length, "Mismatch b/w discount rates & tokens / tier");\n', '        require(_tokensPerTierDiscountPoly.length == _tokensPerTierTotal.length, "Mismatch b/w discount tokens / tier & tokens / tier");\n', '        for (uint8 i = 0; i < _ratePerTier.length; i++) {\n', '            require(_ratePerTier[i] > 0, "Rate > 0");\n', '            require(_tokensPerTierTotal[i] > 0, "Tokens per tier > 0");\n', '            require(_tokensPerTierDiscountPoly[i] <= _tokensPerTierTotal[i], "Discounted tokens / tier <= tokens / tier");\n', '            require(_ratePerTierDiscountPoly[i] <= _ratePerTier[i], "Discounted rate / tier <= rate / tier");\n', '        }\n', '        ratePerTier = _ratePerTier;\n', '        ratePerTierDiscountPoly = _ratePerTierDiscountPoly;\n', '        tokensPerTierTotal = _tokensPerTierTotal;\n', '        tokensPerTierDiscountPoly = _tokensPerTierDiscountPoly;\n', '        emit SetTiers(_ratePerTier, _ratePerTierDiscountPoly, _tokensPerTierTotal, _tokensPerTierDiscountPoly);\n', '    }\n', '\n', '    function modifyTimes(\n', '        uint256 _startTime,\n', '        uint256 _endTime\n', '    ) public onlyFactoryOrOwner {\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        require((startTime == 0) || (now < startTime), "Invalid startTime");\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        require((_endTime > _startTime) && (_startTime > now), "Invalid times");\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        emit SetTimes(_startTime, _endTime);\n', '    }\n', '\n', '    function modifyAddresses(\n', '        address _wallet,\n', '        address _reserveWallet,\n', '        address _usdToken\n', '    ) public onlyFactoryOrOwner {\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        require(now < startTime, "STO shouldn\'t be started");\n', '        require(_wallet != address(0) && _reserveWallet != address(0), "Invalid address");\n', '        if (fundRaiseTypes[uint8(FundRaiseType.DAI)]) {\n', '            require(_usdToken != address(0), "Invalid address");\n', '        }\n', '        wallet = _wallet;\n', '        reserveWallet = _reserveWallet;\n', '        usdToken = IERC20(_usdToken);\n', '        emit SetAddresses(_wallet, _reserveWallet, _usdToken);\n', '    }\n', '\n', '    ////////////////////\n', '    // STO Management //\n', '    ////////////////////\n', '\n', '    /**\n', '     * @notice Finalizes the STO and mint remaining tokens to reserve address\n', '     * @notice Reserve address must be whitelisted to successfully finalize\n', '     */\n', '    function finalize() public onlyOwner {\n', '        require(!isFinalized, "STO is already finalized");\n', '        isFinalized = true;\n', '        uint256 tempReturned;\n', '        uint256 tempSold;\n', '        uint256 remainingTokens;\n', '        for (uint8 i = 0; i < tokensPerTierTotal.length; i++) {\n', '            remainingTokens = tokensPerTierTotal[i].sub(mintedPerTierTotal[i]);\n', '            tempReturned = tempReturned.add(remainingTokens);\n', '            tempSold = tempSold.add(mintedPerTierTotal[i]);\n', '            if (remainingTokens > 0) {\n', '                mintedPerTierTotal[i] = tokensPerTierTotal[i];\n', '            }\n', '        }\n', '        require(ISecurityToken(securityToken).mint(reserveWallet, tempReturned), "Error in minting");\n', '        emit ReserveTokenMint(msg.sender, reserveWallet, tempReturned, currentTier);\n', '        finalAmountReturned = tempReturned;\n', '        totalTokensSold = tempSold;\n', '    }\n', '\n', '    /**\n', '     * @notice Modifies the list of accredited addresses\n', '     * @param _investors Array of investor addresses to modify\n', '     * @param _accredited Array of bools specifying accreditation status\n', '     */\n', '    function changeAccredited(address[] _investors, bool[] _accredited) public onlyOwner {\n', '        require(_investors.length == _accredited.length, "Array length mismatch");\n', '        for (uint256 i = 0; i < _investors.length; i++) {\n', '            accredited[_investors[i]] = _accredited[i];\n', '            emit SetAccredited(_investors[i], _accredited[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Modifies the list of overrides for non-accredited limits in USD\n', '     * @param _investors Array of investor addresses to modify\n', '     * @param _nonAccreditedLimit Array of uints specifying non-accredited limits\n', '     */\n', '    function changeNonAccreditedLimit(address[] _investors, uint256[] _nonAccreditedLimit) public onlyOwner {\n', '        //nonAccreditedLimitUSDOverride\n', '        require(_investors.length == _nonAccreditedLimit.length, "Array length mismatch");\n', '        for (uint256 i = 0; i < _investors.length; i++) {\n', '            require(_nonAccreditedLimit[i] > 0, "Limit can not be 0");\n', '            nonAccreditedLimitUSDOverride[_investors[i]] = _nonAccreditedLimit[i];\n', '            emit SetNonAccreditedLimit(_investors[i], _nonAccreditedLimit[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Function to set allowBeneficialInvestments (allow beneficiary to be different to funder)\n', '     * @param _allowBeneficialInvestments Boolean to allow or disallow beneficial investments\n', '     */\n', '    function changeAllowBeneficialInvestments(bool _allowBeneficialInvestments) public onlyOwner {\n', '        require(_allowBeneficialInvestments != allowBeneficialInvestments, "Value unchanged");\n', '        allowBeneficialInvestments = _allowBeneficialInvestments;\n', '        emit SetAllowBeneficialInvestments(allowBeneficialInvestments);\n', '    }\n', '\n', '    //////////////////////////\n', '    // Investment Functions //\n', '    //////////////////////////\n', '\n', '    /**\n', '    * @notice fallback function - assumes ETH being invested\n', '    */\n', '    function () external payable {\n', '        buyWithETH(msg.sender);\n', '    }\n', '\n', '    /**\n', '      * @notice Purchase tokens using ETH\n', '      * @param _beneficiary Address where security tokens will be sent\n', '      */\n', '    function buyWithETH(address _beneficiary) public payable validETH {\n', '        uint256 rate = getRate(FundRaiseType.ETH);\n', '        (uint256 spentUSD, uint256 spentValue) = _buyTokens(_beneficiary, msg.value, rate, FundRaiseType.ETH);\n', '        // Modify storage\n', '        investorInvested[_beneficiary][uint8(FundRaiseType.ETH)] = investorInvested[_beneficiary][uint8(FundRaiseType.ETH)].add(spentValue);\n', '        fundsRaised[uint8(FundRaiseType.ETH)] = fundsRaised[uint8(FundRaiseType.ETH)].add(spentValue);\n', '        // Forward ETH to issuer wallet\n', '        wallet.transfer(spentValue);\n', '        // Refund excess ETH to investor wallet\n', '        msg.sender.transfer(msg.value.sub(spentValue));\n', '        emit FundsReceived(msg.sender, _beneficiary, spentUSD, FundRaiseType.ETH, msg.value, spentValue, rate);\n', '    }\n', '\n', '    /**\n', '      * @notice Purchase tokens using POLY\n', '      * @param _beneficiary Address where security tokens will be sent\n', '      * @param _investedPOLY Amount of POLY invested\n', '      */\n', '    function buyWithPOLY(address _beneficiary, uint256 _investedPOLY) public validPOLY {\n', '        _buyWithTokens(_beneficiary, _investedPOLY, FundRaiseType.POLY);\n', '    }\n', '\n', '    /**\n', '      * @notice Purchase tokens using POLY\n', '      * @param _beneficiary Address where security tokens will be sent\n', '      * @param _investedDAI Amount of POLY invested\n', '      */\n', '    function buyWithUSD(address _beneficiary, uint256 _investedDAI) public validDAI {\n', '        _buyWithTokens(_beneficiary, _investedDAI, FundRaiseType.DAI);\n', '    }\n', '\n', '    function _buyWithTokens(address _beneficiary, uint256 _tokenAmount, FundRaiseType _fundRaiseType) internal {\n', '        require(_fundRaiseType == FundRaiseType.POLY || _fundRaiseType == FundRaiseType.DAI, "POLY & DAI supported");\n', '        uint256 rate = getRate(_fundRaiseType);\n', '        (uint256 spentUSD, uint256 spentValue) = _buyTokens(_beneficiary, _tokenAmount, rate, _fundRaiseType);\n', '        // Modify storage\n', '        investorInvested[_beneficiary][uint8(_fundRaiseType)] = investorInvested[_beneficiary][uint8(_fundRaiseType)].add(spentValue);\n', '        fundsRaised[uint8(_fundRaiseType)] = fundsRaised[uint8(_fundRaiseType)].add(spentValue);\n', '        // Forward DAI to issuer wallet\n', '        IERC20 token = _fundRaiseType == FundRaiseType.POLY ? polyToken : usdToken;\n', '        require(token.transferFrom(msg.sender, wallet, spentValue), "Transfer failed");\n', '        emit FundsReceived(msg.sender, _beneficiary, spentUSD, _fundRaiseType, _tokenAmount, spentValue, rate);\n', '    }\n', '\n', '    /**\n', '      * @notice Low level token purchase\n', '      * @param _beneficiary Address where security tokens will be sent\n', '      * @param _investmentValue Amount of POLY, ETH or DAI invested\n', '      * @param _fundRaiseType Fund raise type (POLY, ETH, DAI)\n', '      */\n', '    function _buyTokens(\n', '        address _beneficiary,\n', '        uint256 _investmentValue,\n', '        uint256 _rate,\n', '        FundRaiseType _fundRaiseType\n', '    )\n', '        internal\n', '        nonReentrant\n', '        whenNotPaused\n', '        returns(uint256, uint256)\n', '    {\n', '        if (!allowBeneficialInvestments) {\n', '            require(_beneficiary == msg.sender, "Beneficiary does not match funder");\n', '        }\n', '\n', '        require(isOpen(), "STO is not open");\n', '        require(_investmentValue > 0, "No funds were sent");\n', '\n', '        uint256 investedUSD = DecimalMath.mul(_rate, _investmentValue);\n', '        uint256 originalUSD = investedUSD;\n', '\n', '        // Check for minimum investment\n', '        require(investedUSD.add(investorInvestedUSD[_beneficiary]) >= minimumInvestmentUSD, "Total investment < minimumInvestmentUSD");\n', '\n', '        // Check for non-accredited cap\n', '        if (!accredited[_beneficiary]) {\n', '            uint256 investorLimitUSD = (nonAccreditedLimitUSDOverride[_beneficiary] == 0) ? nonAccreditedLimitUSD : nonAccreditedLimitUSDOverride[_beneficiary];\n', '            require(investorInvestedUSD[_beneficiary] < investorLimitUSD, "Non-accredited investor has reached limit");\n', '            if (investedUSD.add(investorInvestedUSD[_beneficiary]) > investorLimitUSD)\n', '                investedUSD = investorLimitUSD.sub(investorInvestedUSD[_beneficiary]);\n', '        }\n', '        uint256 spentUSD;\n', '        // Iterate over each tier and process payment\n', '        for (uint8 i = currentTier; i < ratePerTier.length; i++) {\n', '            // Update current tier if needed\n', '            if (currentTier != i)\n', '                currentTier = i;\n', '            // If there are tokens remaining, process investment\n', '            if (mintedPerTierTotal[i] < tokensPerTierTotal[i])\n', '                spentUSD = spentUSD.add(_calculateTier(_beneficiary, i, investedUSD.sub(spentUSD), _fundRaiseType));\n', '            // If all funds have been spent, exit the loop\n', '            if (investedUSD == spentUSD)\n', '                break;\n', '        }\n', '\n', '        // Modify storage\n', '        if (spentUSD > 0) {\n', '            if (investorInvestedUSD[_beneficiary] == 0)\n', '                investorCount = investorCount + 1;\n', '            investorInvestedUSD[_beneficiary] = investorInvestedUSD[_beneficiary].add(spentUSD);\n', '            fundsRaisedUSD = fundsRaisedUSD.add(spentUSD);\n', '        }\n', '\n', '        // Calculate spent in base currency (ETH, DAI or POLY)\n', '        uint256 spentValue;\n', '        if (spentUSD == 0) {\n', '            spentValue = 0;\n', '        } else {\n', '            spentValue = DecimalMath.mul(DecimalMath.div(spentUSD, originalUSD), _investmentValue);\n', '        }\n', '\n', '        // Return calculated amounts\n', '        return (spentUSD, spentValue);\n', '    }\n', '\n', '    function _calculateTier(\n', '        address _beneficiary,\n', '        uint8 _tier,\n', '        uint256 _investedUSD,\n', '        FundRaiseType _fundRaiseType\n', '    ) \n', '        internal\n', '        returns(uint256)\n', '     {\n', '        // First purchase any discounted tokens if POLY investment\n', '        uint256 spentUSD;\n', '        uint256 tierSpentUSD;\n', '        uint256 tierPurchasedTokens;\n', '        uint256 investedUSD = _investedUSD;\n', '        // Check whether there are any remaining discounted tokens\n', '        if ((_fundRaiseType == FundRaiseType.POLY) && (tokensPerTierDiscountPoly[_tier] > mintedPerTierDiscountPoly[_tier])) {\n', '            uint256 discountRemaining = tokensPerTierDiscountPoly[_tier].sub(mintedPerTierDiscountPoly[_tier]);\n', '            uint256 totalRemaining = tokensPerTierTotal[_tier].sub(mintedPerTierTotal[_tier]);\n', '            if (totalRemaining < discountRemaining)\n', '                (spentUSD, tierPurchasedTokens) = _purchaseTier(_beneficiary, ratePerTierDiscountPoly[_tier], totalRemaining, investedUSD, _tier);\n', '            else\n', '                (spentUSD, tierPurchasedTokens) = _purchaseTier(_beneficiary, ratePerTierDiscountPoly[_tier], discountRemaining, investedUSD, _tier);\n', '            investedUSD = investedUSD.sub(spentUSD);\n', '            mintedPerTierDiscountPoly[_tier] = mintedPerTierDiscountPoly[_tier].add(tierPurchasedTokens);\n', '            mintedPerTier[uint8(FundRaiseType.POLY)][_tier] = mintedPerTier[uint8(FundRaiseType.POLY)][_tier].add(tierPurchasedTokens);\n', '            mintedPerTierTotal[_tier] = mintedPerTierTotal[_tier].add(tierPurchasedTokens);\n', '        }\n', '        // Now, if there is any remaining USD to be invested, purchase at non-discounted rate\n', '        if ((investedUSD > 0) && (tokensPerTierTotal[_tier].sub(mintedPerTierTotal[_tier]) > 0)) {\n', '            (tierSpentUSD, tierPurchasedTokens) = _purchaseTier(_beneficiary, ratePerTier[_tier], tokensPerTierTotal[_tier].sub(mintedPerTierTotal[_tier]), investedUSD, _tier);\n', '            spentUSD = spentUSD.add(tierSpentUSD);\n', '            mintedPerTier[uint8(_fundRaiseType)][_tier] = mintedPerTier[uint8(_fundRaiseType)][_tier].add(tierPurchasedTokens);\n', '            mintedPerTierTotal[_tier] = mintedPerTierTotal[_tier].add(tierPurchasedTokens);\n', '        }\n', '        return spentUSD;\n', '    }\n', '\n', '    function _purchaseTier(\n', '        address _beneficiary,\n', '        uint256 _tierPrice,\n', '        uint256 _tierRemaining,\n', '        uint256 _investedUSD,\n', '        uint8 _tier\n', '    )\n', '        internal\n', '        returns(uint256, uint256)\n', '    {\n', '        uint256 maximumTokens = DecimalMath.div(_investedUSD, _tierPrice);\n', '        uint256 spentUSD;\n', '        uint256 purchasedTokens;\n', '        if (maximumTokens > _tierRemaining) {\n', '            spentUSD = DecimalMath.mul(_tierRemaining, _tierPrice);\n', '            // In case of rounding issues, ensure that spentUSD is never more than investedUSD\n', '            if (spentUSD > _investedUSD) {\n', '                spentUSD = _investedUSD;\n', '            }\n', '            purchasedTokens = _tierRemaining;\n', '        } else {\n', '            spentUSD = _investedUSD;\n', '            purchasedTokens = maximumTokens;\n', '        }\n', '        require(ISecurityToken(securityToken).mint(_beneficiary, purchasedTokens), "Error in minting");\n', '        emit TokenPurchase(msg.sender, _beneficiary, purchasedTokens, spentUSD, _tierPrice, _tier);\n', '        return (spentUSD, purchasedTokens);\n', '    }\n', '\n', '    /////////////\n', '    // Getters //\n', '    /////////////\n', '\n', '    /**\n', '     * @notice This function returns whether or not the STO is in fundraising mode (open)\n', '     * @return bool Whether the STO is accepting investments\n', '     */\n', '    function isOpen() public view returns(bool) {\n', '        if (isFinalized)\n', '            return false;\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        if (now < startTime)\n', '            return false;\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        if (now >= endTime)\n', '            return false;\n', '        if (capReached())\n', '            return false;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Checks whether the cap has been reached.\n', '     * @return bool Whether the cap was reached\n', '     */\n', '    function capReached() public view returns (bool) {\n', '        if (isFinalized) {\n', '            return (finalAmountReturned == 0);\n', '        }\n', '        return (mintedPerTierTotal[mintedPerTierTotal.length - 1] == tokensPerTierTotal[tokensPerTierTotal.length - 1]);\n', '    }\n', '\n', '    function getRate(FundRaiseType _fundRaiseType) public view returns (uint256) {\n', '        if (_fundRaiseType == FundRaiseType.ETH) {\n', '            return IOracle(_getOracle(bytes32("ETH"), bytes32("USD"))).getPrice();\n', '        } else if (_fundRaiseType == FundRaiseType.POLY) {\n', '            return IOracle(_getOracle(bytes32("POLY"), bytes32("USD"))).getPrice();\n', '        } else if (_fundRaiseType == FundRaiseType.DAI) {\n', '            return 1 * 10**18;\n', '        } else {\n', '            revert("Incorrect funding");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice This function converts from ETH or POLY to USD\n', '     * @param _fundRaiseType Currency key\n', '     * @param _amount Value to convert to USD\n', '     * @return uint256 Value in USD\n', '     */\n', '    function convertToUSD(FundRaiseType _fundRaiseType, uint256 _amount) public view returns(uint256) {\n', '        uint256 rate = getRate(_fundRaiseType);\n', '        return DecimalMath.mul(_amount, rate);\n', '    }\n', '\n', '    /**\n', '     * @notice This function converts from USD to ETH or POLY\n', '     * @param _fundRaiseType Currency key\n', '     * @param _amount Value to convert from USD\n', '     * @return uint256 Value in ETH or POLY\n', '     */\n', '    function convertFromUSD(FundRaiseType _fundRaiseType, uint256 _amount) public view returns(uint256) {\n', '        uint256 rate = getRate(_fundRaiseType);\n', '        return DecimalMath.div(_amount, rate);\n', '    }\n', '\n', '    /**\n', '     * @notice Return the total no. of tokens sold\n', '     * @return uint256 Total number of tokens sold\n', '     */\n', '    function getTokensSold() public view returns (uint256) {\n', '        if (isFinalized)\n', '            return totalTokensSold;\n', '        else\n', '            return getTokensMinted();\n', '    }\n', '\n', '    /**\n', '     * @notice Return the total no. of tokens minted\n', '     * @return uint256 Total number of tokens minted\n', '     */\n', '    function getTokensMinted() public view returns (uint256) {\n', '        uint256 tokensMinted;\n', '        for (uint8 i = 0; i < mintedPerTierTotal.length; i++) {\n', '            tokensMinted = tokensMinted.add(mintedPerTierTotal[i]);\n', '        }\n', '        return tokensMinted;\n', '    }\n', '\n', '    /**\n', '     * @notice Return the total no. of tokens sold for ETH\n', '     * @return uint256 Total number of tokens sold for ETH\n', '     */\n', '    function getTokensSoldFor(FundRaiseType _fundRaiseType) public view returns (uint256) {\n', '        uint256 tokensSold;\n', '        for (uint8 i = 0; i < mintedPerTier[uint8(_fundRaiseType)].length; i++) {\n', '            tokensSold = tokensSold.add(mintedPerTier[uint8(_fundRaiseType)][i]);\n', '        }\n', '        return tokensSold;\n', '    }\n', '\n', '    /**\n', '     * @notice Return the total no. of tiers\n', '     * @return uint256 Total number of tiers\n', '     */\n', '    function getNumberOfTiers() public view returns (uint256) {\n', '        return tokensPerTierTotal.length;\n', '    }\n', '\n', '    /**\n', '     * @notice Return the permissions flag that are associated with STO\n', '     */\n', '    function getPermissions() public view returns(bytes32[]) {\n', '        bytes32[] memory allPermissions = new bytes32[](0);\n', '        return allPermissions;\n', '    }\n', '\n', '    /**\n', '     * @notice This function returns the signature of configure function\n', '     * @return bytes4 Configure function signature\n', '     */\n', '    function getInitFunction() public pure returns (bytes4) {\n', '        return 0xb0ff041e;\n', '    }\n', '\n', '    function _getOracle(bytes32 _currency, bytes32 _denominatedCurrency) internal view returns (address) {\n', '        return PolymathRegistry(RegistryUpdater(securityToken).polymathRegistry()).getAddress(oracleKeys[_currency][_denominatedCurrency]);\n', '    }\n', '\n', '}']