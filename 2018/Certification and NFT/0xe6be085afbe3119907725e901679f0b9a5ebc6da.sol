['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface token {\n', '    function mint(address _to, uint256 _amount) public returns (bool);     \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function transferOwnership(address newOwner) public;\n', '    \n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Crowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale.\n', ' * Crowdsales have a start and end timestamps, where investors can make\n', ' * token purchases and the crowdsale will assign them tokens based\n', ' * on a token per ETH rate. Funds collected are forwarded to a wallet\n', ' * as they arrive.\n', ' */\n', 'contract Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    // The token being sold\n', '    token public tokenReward;\n', '\n', '    // start and end timestamps where investments are allowed (both inclusive)\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '\n', '    // address where funds are collected\n', '    address public wallet;\n', '\n', '    // how many token units a buyer gets per wei\n', '    uint256 public rate;\n', '\n', '    // amount of raised money in wei\n', '    uint256 public weiRaised;\n', '\n', '    /**\n', '    * event for token purchase logging\n', '    * @param purchaser who paid for the tokens\n', '    * @param beneficiary who got the tokens\n', '    * @param value weis paid for purchase\n', '    * @param amount amount of tokens purchased\n', '    */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '\n', '    function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, address _token) public {\n', '        //require(_startTime >= now);\n', '        require(_endTime >= _startTime);\n', '        require(_rate > 0);\n', '        require(_wallet != address(0));\n', '\n', '        // token = createTokenContract();\n', '        tokenReward = token(_token);\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        rate = _rate;\n', '        wallet = _wallet;\n', '    }\n', '\n', '    // creates the token to be sold.\n', '    // override this method to have crowdsale of a specific mintable token.\n', '    // function createTokenContract() internal returns (MintableToken) {\n', '    //     return new MintableToken();\n', '    // }\n', '\n', '    // send ether to the fund collection wallet\n', '    // override to create custom fund forwarding mechanisms\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    // @return true if the transaction can buy tokens\n', '    function validPurchase() internal view returns (bool) {\n', '        bool withinPeriod = now >= startTime && now <= endTime;\n', '        bool nonZeroPurchase = msg.value != 0;\n', '        return withinPeriod && nonZeroPurchase;\n', '    }\n', '\n', '    // @return true if crowdsale event has ended\n', '    function hasEnded() public view returns (bool) {\n', '        return now > endTime;\n', '    }\n', '\n', '\n', '}\n', '\n', '/**\n', ' * @title RefundVault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Supports refunding the money if crowdsale fails,\n', ' * and forwarding it if crowdsale is successful.\n', ' */\n', 'contract RefundVault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    enum State { Active, Refunding, Closed }\n', '\n', '    mapping (address => uint256) public deposited;\n', '    address public wallet;\n', '    State public state;\n', '\n', '    event Closed();\n', '    event RefundsEnabled();\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '    function RefundVault(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '        state = State.Active;\n', '    }\n', '\n', '    function deposit(address investor) onlyOwner public payable {\n', '        require(state == State.Active);\n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '    }\n', '\n', '    function close() onlyOwner public {\n', '        require(state == State.Active);\n', '        state = State.Closed;\n', '        emit Closed();\n', '        wallet.transfer(this.balance);\n', '    }\n', '\n', '    function enableRefunds() onlyOwner public {\n', '        require(state == State.Active);\n', '        state = State.Refunding;\n', '        emit RefundsEnabled();\n', '    }\n', '\n', '    function refund(address investor) public {\n', '        require(state == State.Refunding);\n', '        uint256 depositedValue = deposited[investor];\n', '        deposited[investor] = 0;\n', '        investor.transfer(depositedValue);\n', '        emit Refunded(investor, depositedValue);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title FinalizableCrowdsale\n', ' * @dev Extension of Crowdsale where an owner can do extra work\n', ' * after finishing.\n', ' */\n', 'contract FinalizableCrowdsale is Crowdsale, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    bool public isFinalized = false;\n', '\n', '    event Finalized();\n', '\n', '    /**\n', '    * @dev Must be called after crowdsale ends, to do some extra finalization\n', '    * work. Calls the contract&#39;s finalization function.\n', '    */\n', '    function finalize() onlyOwner public {\n', '        require(!isFinalized);\n', '        require(hasEnded());\n', '\n', '        finalization();\n', '        emit Finalized();\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '  /**\n', '   * @dev Can be overridden to add finalization logic. The overriding function\n', '   * should call super.finalization() to ensure the chain of finalization is\n', '   * executed entirely.\n', '   */\n', '    function finalization() internal {\n', '    }\n', '}\n', '/**\n', ' * @title RefundableCrowdsale\n', ' * @dev Extension of Crowdsale contract that adds a funding goal, and\n', ' * the possibility of users getting a refund if goal is not met.\n', ' * Uses a RefundVault as the crowdsale&#39;s vault.\n', ' */\n', 'contract RefundableCrowdsale is FinalizableCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    // minimum amount of funds to be raised in weis\n', '    uint256 public goal;\n', '\n', '    // refund vault used to hold funds while crowdsale is running\n', '    RefundVault public vault;\n', '\n', '    function RefundableCrowdsale(uint256 _goal) public {\n', '        require(_goal > 0);\n', '        vault = new RefundVault(wallet);\n', '        goal = _goal;\n', '    }\n', '\n', '    // We&#39;re overriding the fund forwarding from Crowdsale.\n', '    // In addition to sending the funds, we want to call\n', '    // the RefundVault deposit function\n', '    function forwardFunds() internal {\n', '        vault.deposit.value(msg.value)(msg.sender);\n', '    }\n', '\n', '    // if crowdsale is unsuccessful, investors can claim refunds here\n', '    function claimRefund() public {\n', '        require(isFinalized);\n', '        require(!goalReached());\n', '\n', '        vault.refund(msg.sender);\n', '    }\n', '\n', '    // vault finalization task, called when owner calls finalize()\n', '    function finalization() internal {\n', '        if (!goalReached()) {\n', '            vault.enableRefunds(); \n', '        } \n', '\n', '        super.finalization();\n', '    }\n', '\n', '    function goalReached() public view returns (bool) {\n', '        return weiRaised >= goal;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title CappedCrowdsale\n', ' * @dev Extension of Crowdsale with a max amount of funds raised\n', ' */\n', 'contract CappedCrowdsale is Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public cap;\n', '\n', '    function CappedCrowdsale(uint256 _cap) public {\n', '        require(_cap > 0);\n', '        cap = _cap;\n', '    }\n', '\n', '\n', '    // overriding Crowdsale#hasEnded to add cap logic\n', '    // @return true if crowdsale event has ended\n', '    function hasEnded() public view returns (bool) {\n', '        bool capReached = weiRaised >= cap;\n', '        return super.hasEnded() || capReached;\n', '    }\n', '\n', '}\n', '\n', 'contract ControlledAccess is Ownable {\n', '    address public signer;\n', '    event SignerTransferred(address indexed previousSigner, address indexed newSigner);\n', '\n', '     /**\n', '    * @dev Throws if called by any account other than the signer.\n', '    */\n', '    modifier onlySigner() {\n', '        require(msg.sender == signer);\n', '        _;\n', '    }\n', '    /**\n', '    * @dev Allows the current owner to transfer the signer of the contract to a newSigner.\n', '    * @param newSigner The address to transfer signership to.\n', '    */\n', '\n', '    function transferSigner(address newSigner) public onlyOwner {\n', '        require(newSigner != address(0));\n', '        emit SignerTransferred(signer, newSigner);\n', '        signer = newSigner;\n', '    }\n', '    \n', '   /* \n', '    * @dev Requires msg.sender to have valid access message.\n', '    * @param _v ECDSA signature parameter v.\n', '    * @param _r ECDSA signature parameters r.\n', '    * @param _s ECDSA signature parameters s.\n', '    */\n', '    modifier onlyValidAccess(uint8 _v, bytes32 _r, bytes32 _s) \n', '    {\n', '        require(isValidAccessMessage(msg.sender,_v,_r,_s) );\n', '        _;\n', '    }\n', ' \n', '    /* \n', '    * @dev Verifies if message was signed by owner to give access to _add for this contract.\n', '    *      Assumes Geth signature prefix.\n', '    * @param _add Address of agent with access\n', '    * @param _v ECDSA signature parameter v.\n', '    * @param _r ECDSA signature parameters r.\n', '    * @param _s ECDSA signature parameters s.\n', '    * @return Validity of access message for a given address.\n', '    */\n', '    function isValidAccessMessage(\n', '        address _add,\n', '        uint8 _v, \n', '        bytes32 _r, \n', '        bytes32 _s) \n', '        view public returns (bool)\n', '    {\n', '        bytes32 hash = keccak256(this, _add);\n', '        return signer == ecrecover(\n', '            keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '            _v,\n', '            _r,\n', '            _s\n', '        );\n', '    }\n', '}\n', '\n', 'contract ElepigCrowdsale is CappedCrowdsale, RefundableCrowdsale, ControlledAccess {\n', '    using SafeMath for uint256;\n', '    \n', '    // ICO Stage  \n', '    // ============\n', '    enum CrowdsaleStage { PreICO, ICO1, ICO2, ICO3, ICO4 } //Sale has pre-ico and 4 bonus rounds\n', '    CrowdsaleStage public stage = CrowdsaleStage.PreICO; // By default stage is Pre ICO\n', '    // =============\n', '\n', '    address public community;    \n', '\n', '  // Token Distribution\n', '    // =============================\n', '    // 150MM of Elepig are already minted. \n', '    uint256 public totalTokensForSale = 150000000000000000000000000;  // 150 EPGs will be sold in Crowdsale (50% of total tokens for community) \n', '    uint256 public totalTokensForSaleDuringPreICO = 30000000000000000000000000; // 30MM out of 150MM EPGs will be sold during Pre ICO\n', '    uint256 public totalTokensForSaleDuringICO1 = 37500000000000000000000000;   // 37.5MM out of 150MM EPGs will be sold during Bonus Round 1\n', '    uint256 public totalTokensForSaleDuringICO2 = 37500000000000000000000000;   // 37.5MM out of 150MM EPGs will be sold during Bonus Round 2\n', '    uint256 public totalTokensForSaleDuringICO3 = 30000000000000000000000000;   // 30MM out of 150MM EPGs will be sold during Bonus Round 3\n', '    uint256 public totalTokensForSaleDuringICO4 = 15000000000000000000000000;   // 15MM out of 150MM EPGs will be sold during Bonus Round 4\n', '  // ==============================\n', '\n', '    // Amount raised\n', '    // ==================\n', '    \n', '    // store amount sold at each stage of sale\n', '    uint256 public totalWeiRaisedDuringPreICO;\n', '    uint256 public totalWeiRaisedDuringICO1;\n', '    uint256 public totalWeiRaisedDuringICO2;\n', '    uint256 public totalWeiRaisedDuringICO3;\n', '    uint256 public totalWeiRaisedDuringICO4;\n', '    uint256 public totalWeiRaised;\n', '\n', '\n', '    // store amount sold at each stage of sale\n', '    uint256 public totalTokensPreICO;\n', '    uint256 public totalTokensICO1;\n', '    uint256 public totalTokensICO2;\n', '    uint256 public totalTokensICO3;\n', '    uint256 public totalTokensICO4;\n', '    uint256 public tokensMinted;\n', '    \n', '\n', '    uint256 public airDropsClaimed = 0;\n', '    // ===================\n', '\n', '    mapping (address => bool) public airdrops;\n', '    mapping (address => bool) public blacklist;\n', '    \n', '    \n', '    // Events\n', '    event EthTransferred(string text);\n', '    event EthRefunded(string text);\n', '   \n', '\n', '\n', '    // Constructor\n', '    // ============\n', '    function ElepigCrowdsale(\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        uint256 _rate,\n', '        address _wallet,\n', '        uint256 _goal,\n', '        uint256 _cap,\n', '        address _communityAddress,\n', '        address _token,\n', '        address _signer\n', '    ) \n', '    CappedCrowdsale(_cap) FinalizableCrowdsale() RefundableCrowdsale(_goal) Crowdsale( _startTime, _endTime,  _rate, _wallet, _token) public {\n', '        require(_goal <= _cap);   // goal is softcap\n', '        require(_signer != address(0));\n', '        require(_communityAddress != address(0));\n', '        require(_token != address(0));\n', '\n', '\n', '        community = _communityAddress; // sets address of community wallet - address where tokens not sold will be minted\n', '        signer = _signer; // sets original address of signer\n', '\n', '        \n', '    }\n', '    \n', '\n', '  // =========================================================\n', '  // Crowdsale Stage Management\n', '  // =========================================================\n', '\n', '  // Change Crowdsale Stage. Available Options: PreICO, ICO1, ICO2, ICO3, ICO4\n', '    function setCrowdsaleStage(uint value) public onlyOwner {\n', '        require(value <= 4);\n', '        if (uint(CrowdsaleStage.PreICO) == value) {\n', '            rate = 2380; // 1 EPG = 0.00042 ETH\n', '            stage = CrowdsaleStage.PreICO;\n', '        } else if (uint(CrowdsaleStage.ICO1) == value) {\n', '            rate = 2040; // 1 EPG = 0.00049 ETH\n', '            stage = CrowdsaleStage.ICO1;\n', '        }\n', '        else if (uint(CrowdsaleStage.ICO2) == value) {\n', '            rate = 1785; // 1 EPG = 0.00056 ETH\n', '            stage = CrowdsaleStage.ICO2;\n', '        }\n', '        else if (uint(CrowdsaleStage.ICO3) == value) {\n', '            rate = 1587; // 1 EPG = 0.00063 ETH\n', '            stage = CrowdsaleStage.ICO3;\n', '        }\n', '        else if (uint(CrowdsaleStage.ICO4) == value) {\n', '            rate = 1503; // 1 EPG = 0.000665 ETH\n', '            stage = CrowdsaleStage.ICO4;\n', '        }\n', '    }\n', '\n', '\n', '    // Change the current rate\n', '    function setCurrentRate(uint256 _rate) private {\n', '        rate = _rate;\n', '    }    \n', '    // ================ Stage Management Over =====================\n', '\n', '    // ============================================================\n', '    //                     Address Management \n', '    // ============================================================\n', '\n', '\n', '    // adding an address to the blacklist, addresses on this list cannot send ETH to the contract     \n', '    function addBlacklistAddress (address _address) public onlyOwner {\n', '        blacklist[_address] = true;\n', '    }\n', '    \n', '    // removing an address from the blacklist    \n', '    function removeBlacklistAddress (address _address) public onlyOwner {\n', '        blacklist[_address] = false;\n', '    } \n', '\n', '    // ================= Address Management Over ==================\n', '\n', '\n', '    // Token Purchase, function will be called when &#39;data&#39; is sent in \n', '    // FOR KYC\n', '    function donate(uint8 _v, bytes32 _r, bytes32 _s) \n', '    onlyValidAccess(_v,_r,_s) public payable{\n', '        require(msg.value >= 150000000000000000); // minimum limit - no max\n', '        require(blacklist[msg.sender] == false); // require that the sender is not in the blacklist      \n', '        \n', '        require(validPurchase()); // after ico start date and not value of 0  \n', '        \n', '        uint256 tokensThatWillBeMintedAfterPurchase = msg.value.mul(rate);\n', '\n', '        // if Pre-ICO sale limit is reached, refund sender\n', '        if ((stage == CrowdsaleStage.PreICO) && (totalTokensPreICO + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringPreICO)) {\n', '            msg.sender.transfer(msg.value); // Refund them\n', '            emit EthRefunded("PreICO Limit Hit");\n', '            return;\n', '        } \n', '        if ((stage == CrowdsaleStage.ICO1) && (totalTokensICO1 + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringICO1)) {\n', '            msg.sender.transfer(msg.value); // Refund them\n', '            emit EthRefunded("ICO1 Limit Hit");\n', '            return;\n', '\n', '        }         \n', '        if ((stage == CrowdsaleStage.ICO2) && (totalTokensICO2 + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringICO2)) {\n', '            msg.sender.transfer(msg.value); // Refund them\n', '            emit EthRefunded("ICO2 Limit Hit");\n', '            return;\n', '\n', '        }  \n', '        if ((stage == CrowdsaleStage.ICO3) && (totalTokensICO3 + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringICO3)) {\n', '            msg.sender.transfer(msg.value); // Refund them\n', '            emit EthRefunded("ICO3 Limit Hit");\n', '            return;        \n', '        } \n', '\n', '        if ((stage == CrowdsaleStage.ICO4) && (totalTokensICO4 + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringICO4)) {\n', '            msg.sender.transfer(msg.value); // Refund them\n', '            emit EthRefunded("ICO4 Limit Hit");\n', '            return;\n', '        } else {                \n', '            // calculate token amount to be created\n', '            uint256 tokens = msg.value.mul(rate);\n', '            weiRaised = weiRaised.add(msg.value);          \n', '\n', '            // mint token\n', '            tokenReward.mint(msg.sender, tokens);\n', '            emit TokenPurchase(msg.sender, msg.sender, msg.value, tokens);\n', '            forwardFunds();            \n', '            // end of buy tokens\n', '\n', '            if (stage == CrowdsaleStage.PreICO) {\n', '                totalWeiRaisedDuringPreICO = totalWeiRaisedDuringPreICO.add(msg.value);\n', '                totalTokensPreICO = totalTokensPreICO.add(tokensThatWillBeMintedAfterPurchase);    \n', '            } else if (stage == CrowdsaleStage.ICO1) {\n', '                totalWeiRaisedDuringICO1 = totalWeiRaisedDuringICO1.add(msg.value);\n', '                totalTokensICO1 = totalTokensICO1.add(tokensThatWillBeMintedAfterPurchase);\n', '            } else if (stage == CrowdsaleStage.ICO2) {\n', '                totalWeiRaisedDuringICO2 = totalWeiRaisedDuringICO2.add(msg.value);\n', '                totalTokensICO2 = totalTokensICO2.add(tokensThatWillBeMintedAfterPurchase);\n', '            } else if (stage == CrowdsaleStage.ICO3) {\n', '                totalWeiRaisedDuringICO3 = totalWeiRaisedDuringICO3.add(msg.value);\n', '                totalTokensICO3 = totalTokensICO3.add(tokensThatWillBeMintedAfterPurchase);\n', '            } else if (stage == CrowdsaleStage.ICO4) {\n', '                totalWeiRaisedDuringICO4 = totalWeiRaisedDuringICO4.add(msg.value);\n', '                totalTokensICO4 = totalTokensICO4.add(tokensThatWillBeMintedAfterPurchase);\n', '            }\n', '\n', '        }\n', '        // update state\n', '        tokensMinted = tokensMinted.add(tokensThatWillBeMintedAfterPurchase);      \n', '        \n', '    }\n', '\n', '    // =========================\n', '    function () external payable {\n', '        revert();\n', '    }\n', '\n', '    function forwardFunds() internal {\n', '        // if Wei raised greater than softcap, send to wallet else put in refund vault\n', '        if (goalReached()) {\n', '            wallet.transfer(msg.value);\n', '            emit EthTransferred("forwarding funds to wallet");\n', '        } else  {\n', '            emit EthTransferred("forwarding funds to refundable vault");\n', '            super.forwardFunds();\n', '        }\n', '    }\n', '  \n', '     /**\n', '    * @dev perform a transfer of allocations (recommend doing in batches of 80 due to gas block limit)\n', '    * @param _from is the address the tokens will come from\n', '    * @param _recipient is a list of recipients\n', '    * @param _premium is a bool of if the list of addresses are premium or not\n', '    */\n', '    function airdropTokens(address _from, address[] _recipient, bool _premium) public onlyOwner {\n', '        uint airdropped;\n', '        uint tokens;\n', '\n', '        if(_premium == true) {\n', '            tokens = 500000000000000000000;\n', '        } else {\n', '            tokens = 50000000000000000000;\n', '        }\n', '\n', '        for(uint256 i = 0; i < _recipient.length; i++)\n', '        {\n', '            if (!airdrops[_recipient[i]]) {\n', '                airdrops[_recipient[i]] = true;\n', '                require(tokenReward.transferFrom(_from, _recipient[i], tokens));\n', '                airdropped = airdropped.add(tokens);\n', '            }\n', '        }\n', '        \n', '        airDropsClaimed = airDropsClaimed.add(airdropped);\n', '    }\n', '\n', '  // Finish: Mint Extra Tokens as needed before finalizing the Crowdsale.\n', '  // ====================================================================\n', '\n', '    function finish() public onlyOwner {\n', '\n', '        require(!isFinalized);\n', '        \n', '        if(tokensMinted < totalTokensForSale) {\n', '\n', '            uint256 unsoldTokens = totalTokensForSale - tokensMinted;            \n', '            tokenReward.mint(community, unsoldTokens);\n', '            \n', '        }\n', '             \n', '        finalize();\n', '    } \n', '\n', '    // if goal reached, manually close the vault\n', '    function releaseVault() public onlyOwner {\n', '        require(goalReached());\n', '        vault.close();\n', '    }\n', '\n', '    // transfers ownership of contract back to wallet\n', '    function transferTokenOwnership(address _newOwner) public onlyOwner {\n', '        tokenReward.transferOwnership(_newOwner);\n', '    }\n', '  // ===============================\n', '\n', '  \n', '}']
['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface token {\n', '    function mint(address _to, uint256 _amount) public returns (bool);     \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function transferOwnership(address newOwner) public;\n', '    \n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Crowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale.\n', ' * Crowdsales have a start and end timestamps, where investors can make\n', ' * token purchases and the crowdsale will assign them tokens based\n', ' * on a token per ETH rate. Funds collected are forwarded to a wallet\n', ' * as they arrive.\n', ' */\n', 'contract Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    // The token being sold\n', '    token public tokenReward;\n', '\n', '    // start and end timestamps where investments are allowed (both inclusive)\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '\n', '    // address where funds are collected\n', '    address public wallet;\n', '\n', '    // how many token units a buyer gets per wei\n', '    uint256 public rate;\n', '\n', '    // amount of raised money in wei\n', '    uint256 public weiRaised;\n', '\n', '    /**\n', '    * event for token purchase logging\n', '    * @param purchaser who paid for the tokens\n', '    * @param beneficiary who got the tokens\n', '    * @param value weis paid for purchase\n', '    * @param amount amount of tokens purchased\n', '    */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '\n', '    function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, address _token) public {\n', '        //require(_startTime >= now);\n', '        require(_endTime >= _startTime);\n', '        require(_rate > 0);\n', '        require(_wallet != address(0));\n', '\n', '        // token = createTokenContract();\n', '        tokenReward = token(_token);\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        rate = _rate;\n', '        wallet = _wallet;\n', '    }\n', '\n', '    // creates the token to be sold.\n', '    // override this method to have crowdsale of a specific mintable token.\n', '    // function createTokenContract() internal returns (MintableToken) {\n', '    //     return new MintableToken();\n', '    // }\n', '\n', '    // send ether to the fund collection wallet\n', '    // override to create custom fund forwarding mechanisms\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    // @return true if the transaction can buy tokens\n', '    function validPurchase() internal view returns (bool) {\n', '        bool withinPeriod = now >= startTime && now <= endTime;\n', '        bool nonZeroPurchase = msg.value != 0;\n', '        return withinPeriod && nonZeroPurchase;\n', '    }\n', '\n', '    // @return true if crowdsale event has ended\n', '    function hasEnded() public view returns (bool) {\n', '        return now > endTime;\n', '    }\n', '\n', '\n', '}\n', '\n', '/**\n', ' * @title RefundVault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Supports refunding the money if crowdsale fails,\n', ' * and forwarding it if crowdsale is successful.\n', ' */\n', 'contract RefundVault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    enum State { Active, Refunding, Closed }\n', '\n', '    mapping (address => uint256) public deposited;\n', '    address public wallet;\n', '    State public state;\n', '\n', '    event Closed();\n', '    event RefundsEnabled();\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '    function RefundVault(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '        state = State.Active;\n', '    }\n', '\n', '    function deposit(address investor) onlyOwner public payable {\n', '        require(state == State.Active);\n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '    }\n', '\n', '    function close() onlyOwner public {\n', '        require(state == State.Active);\n', '        state = State.Closed;\n', '        emit Closed();\n', '        wallet.transfer(this.balance);\n', '    }\n', '\n', '    function enableRefunds() onlyOwner public {\n', '        require(state == State.Active);\n', '        state = State.Refunding;\n', '        emit RefundsEnabled();\n', '    }\n', '\n', '    function refund(address investor) public {\n', '        require(state == State.Refunding);\n', '        uint256 depositedValue = deposited[investor];\n', '        deposited[investor] = 0;\n', '        investor.transfer(depositedValue);\n', '        emit Refunded(investor, depositedValue);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title FinalizableCrowdsale\n', ' * @dev Extension of Crowdsale where an owner can do extra work\n', ' * after finishing.\n', ' */\n', 'contract FinalizableCrowdsale is Crowdsale, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    bool public isFinalized = false;\n', '\n', '    event Finalized();\n', '\n', '    /**\n', '    * @dev Must be called after crowdsale ends, to do some extra finalization\n', "    * work. Calls the contract's finalization function.\n", '    */\n', '    function finalize() onlyOwner public {\n', '        require(!isFinalized);\n', '        require(hasEnded());\n', '\n', '        finalization();\n', '        emit Finalized();\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '  /**\n', '   * @dev Can be overridden to add finalization logic. The overriding function\n', '   * should call super.finalization() to ensure the chain of finalization is\n', '   * executed entirely.\n', '   */\n', '    function finalization() internal {\n', '    }\n', '}\n', '/**\n', ' * @title RefundableCrowdsale\n', ' * @dev Extension of Crowdsale contract that adds a funding goal, and\n', ' * the possibility of users getting a refund if goal is not met.\n', " * Uses a RefundVault as the crowdsale's vault.\n", ' */\n', 'contract RefundableCrowdsale is FinalizableCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    // minimum amount of funds to be raised in weis\n', '    uint256 public goal;\n', '\n', '    // refund vault used to hold funds while crowdsale is running\n', '    RefundVault public vault;\n', '\n', '    function RefundableCrowdsale(uint256 _goal) public {\n', '        require(_goal > 0);\n', '        vault = new RefundVault(wallet);\n', '        goal = _goal;\n', '    }\n', '\n', "    // We're overriding the fund forwarding from Crowdsale.\n", '    // In addition to sending the funds, we want to call\n', '    // the RefundVault deposit function\n', '    function forwardFunds() internal {\n', '        vault.deposit.value(msg.value)(msg.sender);\n', '    }\n', '\n', '    // if crowdsale is unsuccessful, investors can claim refunds here\n', '    function claimRefund() public {\n', '        require(isFinalized);\n', '        require(!goalReached());\n', '\n', '        vault.refund(msg.sender);\n', '    }\n', '\n', '    // vault finalization task, called when owner calls finalize()\n', '    function finalization() internal {\n', '        if (!goalReached()) {\n', '            vault.enableRefunds(); \n', '        } \n', '\n', '        super.finalization();\n', '    }\n', '\n', '    function goalReached() public view returns (bool) {\n', '        return weiRaised >= goal;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title CappedCrowdsale\n', ' * @dev Extension of Crowdsale with a max amount of funds raised\n', ' */\n', 'contract CappedCrowdsale is Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public cap;\n', '\n', '    function CappedCrowdsale(uint256 _cap) public {\n', '        require(_cap > 0);\n', '        cap = _cap;\n', '    }\n', '\n', '\n', '    // overriding Crowdsale#hasEnded to add cap logic\n', '    // @return true if crowdsale event has ended\n', '    function hasEnded() public view returns (bool) {\n', '        bool capReached = weiRaised >= cap;\n', '        return super.hasEnded() || capReached;\n', '    }\n', '\n', '}\n', '\n', 'contract ControlledAccess is Ownable {\n', '    address public signer;\n', '    event SignerTransferred(address indexed previousSigner, address indexed newSigner);\n', '\n', '     /**\n', '    * @dev Throws if called by any account other than the signer.\n', '    */\n', '    modifier onlySigner() {\n', '        require(msg.sender == signer);\n', '        _;\n', '    }\n', '    /**\n', '    * @dev Allows the current owner to transfer the signer of the contract to a newSigner.\n', '    * @param newSigner The address to transfer signership to.\n', '    */\n', '\n', '    function transferSigner(address newSigner) public onlyOwner {\n', '        require(newSigner != address(0));\n', '        emit SignerTransferred(signer, newSigner);\n', '        signer = newSigner;\n', '    }\n', '    \n', '   /* \n', '    * @dev Requires msg.sender to have valid access message.\n', '    * @param _v ECDSA signature parameter v.\n', '    * @param _r ECDSA signature parameters r.\n', '    * @param _s ECDSA signature parameters s.\n', '    */\n', '    modifier onlyValidAccess(uint8 _v, bytes32 _r, bytes32 _s) \n', '    {\n', '        require(isValidAccessMessage(msg.sender,_v,_r,_s) );\n', '        _;\n', '    }\n', ' \n', '    /* \n', '    * @dev Verifies if message was signed by owner to give access to _add for this contract.\n', '    *      Assumes Geth signature prefix.\n', '    * @param _add Address of agent with access\n', '    * @param _v ECDSA signature parameter v.\n', '    * @param _r ECDSA signature parameters r.\n', '    * @param _s ECDSA signature parameters s.\n', '    * @return Validity of access message for a given address.\n', '    */\n', '    function isValidAccessMessage(\n', '        address _add,\n', '        uint8 _v, \n', '        bytes32 _r, \n', '        bytes32 _s) \n', '        view public returns (bool)\n', '    {\n', '        bytes32 hash = keccak256(this, _add);\n', '        return signer == ecrecover(\n', '            keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '            _v,\n', '            _r,\n', '            _s\n', '        );\n', '    }\n', '}\n', '\n', 'contract ElepigCrowdsale is CappedCrowdsale, RefundableCrowdsale, ControlledAccess {\n', '    using SafeMath for uint256;\n', '    \n', '    // ICO Stage  \n', '    // ============\n', '    enum CrowdsaleStage { PreICO, ICO1, ICO2, ICO3, ICO4 } //Sale has pre-ico and 4 bonus rounds\n', '    CrowdsaleStage public stage = CrowdsaleStage.PreICO; // By default stage is Pre ICO\n', '    // =============\n', '\n', '    address public community;    \n', '\n', '  // Token Distribution\n', '    // =============================\n', '    // 150MM of Elepig are already minted. \n', '    uint256 public totalTokensForSale = 150000000000000000000000000;  // 150 EPGs will be sold in Crowdsale (50% of total tokens for community) \n', '    uint256 public totalTokensForSaleDuringPreICO = 30000000000000000000000000; // 30MM out of 150MM EPGs will be sold during Pre ICO\n', '    uint256 public totalTokensForSaleDuringICO1 = 37500000000000000000000000;   // 37.5MM out of 150MM EPGs will be sold during Bonus Round 1\n', '    uint256 public totalTokensForSaleDuringICO2 = 37500000000000000000000000;   // 37.5MM out of 150MM EPGs will be sold during Bonus Round 2\n', '    uint256 public totalTokensForSaleDuringICO3 = 30000000000000000000000000;   // 30MM out of 150MM EPGs will be sold during Bonus Round 3\n', '    uint256 public totalTokensForSaleDuringICO4 = 15000000000000000000000000;   // 15MM out of 150MM EPGs will be sold during Bonus Round 4\n', '  // ==============================\n', '\n', '    // Amount raised\n', '    // ==================\n', '    \n', '    // store amount sold at each stage of sale\n', '    uint256 public totalWeiRaisedDuringPreICO;\n', '    uint256 public totalWeiRaisedDuringICO1;\n', '    uint256 public totalWeiRaisedDuringICO2;\n', '    uint256 public totalWeiRaisedDuringICO3;\n', '    uint256 public totalWeiRaisedDuringICO4;\n', '    uint256 public totalWeiRaised;\n', '\n', '\n', '    // store amount sold at each stage of sale\n', '    uint256 public totalTokensPreICO;\n', '    uint256 public totalTokensICO1;\n', '    uint256 public totalTokensICO2;\n', '    uint256 public totalTokensICO3;\n', '    uint256 public totalTokensICO4;\n', '    uint256 public tokensMinted;\n', '    \n', '\n', '    uint256 public airDropsClaimed = 0;\n', '    // ===================\n', '\n', '    mapping (address => bool) public airdrops;\n', '    mapping (address => bool) public blacklist;\n', '    \n', '    \n', '    // Events\n', '    event EthTransferred(string text);\n', '    event EthRefunded(string text);\n', '   \n', '\n', '\n', '    // Constructor\n', '    // ============\n', '    function ElepigCrowdsale(\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        uint256 _rate,\n', '        address _wallet,\n', '        uint256 _goal,\n', '        uint256 _cap,\n', '        address _communityAddress,\n', '        address _token,\n', '        address _signer\n', '    ) \n', '    CappedCrowdsale(_cap) FinalizableCrowdsale() RefundableCrowdsale(_goal) Crowdsale( _startTime, _endTime,  _rate, _wallet, _token) public {\n', '        require(_goal <= _cap);   // goal is softcap\n', '        require(_signer != address(0));\n', '        require(_communityAddress != address(0));\n', '        require(_token != address(0));\n', '\n', '\n', '        community = _communityAddress; // sets address of community wallet - address where tokens not sold will be minted\n', '        signer = _signer; // sets original address of signer\n', '\n', '        \n', '    }\n', '    \n', '\n', '  // =========================================================\n', '  // Crowdsale Stage Management\n', '  // =========================================================\n', '\n', '  // Change Crowdsale Stage. Available Options: PreICO, ICO1, ICO2, ICO3, ICO4\n', '    function setCrowdsaleStage(uint value) public onlyOwner {\n', '        require(value <= 4);\n', '        if (uint(CrowdsaleStage.PreICO) == value) {\n', '            rate = 2380; // 1 EPG = 0.00042 ETH\n', '            stage = CrowdsaleStage.PreICO;\n', '        } else if (uint(CrowdsaleStage.ICO1) == value) {\n', '            rate = 2040; // 1 EPG = 0.00049 ETH\n', '            stage = CrowdsaleStage.ICO1;\n', '        }\n', '        else if (uint(CrowdsaleStage.ICO2) == value) {\n', '            rate = 1785; // 1 EPG = 0.00056 ETH\n', '            stage = CrowdsaleStage.ICO2;\n', '        }\n', '        else if (uint(CrowdsaleStage.ICO3) == value) {\n', '            rate = 1587; // 1 EPG = 0.00063 ETH\n', '            stage = CrowdsaleStage.ICO3;\n', '        }\n', '        else if (uint(CrowdsaleStage.ICO4) == value) {\n', '            rate = 1503; // 1 EPG = 0.000665 ETH\n', '            stage = CrowdsaleStage.ICO4;\n', '        }\n', '    }\n', '\n', '\n', '    // Change the current rate\n', '    function setCurrentRate(uint256 _rate) private {\n', '        rate = _rate;\n', '    }    \n', '    // ================ Stage Management Over =====================\n', '\n', '    // ============================================================\n', '    //                     Address Management \n', '    // ============================================================\n', '\n', '\n', '    // adding an address to the blacklist, addresses on this list cannot send ETH to the contract     \n', '    function addBlacklistAddress (address _address) public onlyOwner {\n', '        blacklist[_address] = true;\n', '    }\n', '    \n', '    // removing an address from the blacklist    \n', '    function removeBlacklistAddress (address _address) public onlyOwner {\n', '        blacklist[_address] = false;\n', '    } \n', '\n', '    // ================= Address Management Over ==================\n', '\n', '\n', "    // Token Purchase, function will be called when 'data' is sent in \n", '    // FOR KYC\n', '    function donate(uint8 _v, bytes32 _r, bytes32 _s) \n', '    onlyValidAccess(_v,_r,_s) public payable{\n', '        require(msg.value >= 150000000000000000); // minimum limit - no max\n', '        require(blacklist[msg.sender] == false); // require that the sender is not in the blacklist      \n', '        \n', '        require(validPurchase()); // after ico start date and not value of 0  \n', '        \n', '        uint256 tokensThatWillBeMintedAfterPurchase = msg.value.mul(rate);\n', '\n', '        // if Pre-ICO sale limit is reached, refund sender\n', '        if ((stage == CrowdsaleStage.PreICO) && (totalTokensPreICO + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringPreICO)) {\n', '            msg.sender.transfer(msg.value); // Refund them\n', '            emit EthRefunded("PreICO Limit Hit");\n', '            return;\n', '        } \n', '        if ((stage == CrowdsaleStage.ICO1) && (totalTokensICO1 + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringICO1)) {\n', '            msg.sender.transfer(msg.value); // Refund them\n', '            emit EthRefunded("ICO1 Limit Hit");\n', '            return;\n', '\n', '        }         \n', '        if ((stage == CrowdsaleStage.ICO2) && (totalTokensICO2 + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringICO2)) {\n', '            msg.sender.transfer(msg.value); // Refund them\n', '            emit EthRefunded("ICO2 Limit Hit");\n', '            return;\n', '\n', '        }  \n', '        if ((stage == CrowdsaleStage.ICO3) && (totalTokensICO3 + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringICO3)) {\n', '            msg.sender.transfer(msg.value); // Refund them\n', '            emit EthRefunded("ICO3 Limit Hit");\n', '            return;        \n', '        } \n', '\n', '        if ((stage == CrowdsaleStage.ICO4) && (totalTokensICO4 + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringICO4)) {\n', '            msg.sender.transfer(msg.value); // Refund them\n', '            emit EthRefunded("ICO4 Limit Hit");\n', '            return;\n', '        } else {                \n', '            // calculate token amount to be created\n', '            uint256 tokens = msg.value.mul(rate);\n', '            weiRaised = weiRaised.add(msg.value);          \n', '\n', '            // mint token\n', '            tokenReward.mint(msg.sender, tokens);\n', '            emit TokenPurchase(msg.sender, msg.sender, msg.value, tokens);\n', '            forwardFunds();            \n', '            // end of buy tokens\n', '\n', '            if (stage == CrowdsaleStage.PreICO) {\n', '                totalWeiRaisedDuringPreICO = totalWeiRaisedDuringPreICO.add(msg.value);\n', '                totalTokensPreICO = totalTokensPreICO.add(tokensThatWillBeMintedAfterPurchase);    \n', '            } else if (stage == CrowdsaleStage.ICO1) {\n', '                totalWeiRaisedDuringICO1 = totalWeiRaisedDuringICO1.add(msg.value);\n', '                totalTokensICO1 = totalTokensICO1.add(tokensThatWillBeMintedAfterPurchase);\n', '            } else if (stage == CrowdsaleStage.ICO2) {\n', '                totalWeiRaisedDuringICO2 = totalWeiRaisedDuringICO2.add(msg.value);\n', '                totalTokensICO2 = totalTokensICO2.add(tokensThatWillBeMintedAfterPurchase);\n', '            } else if (stage == CrowdsaleStage.ICO3) {\n', '                totalWeiRaisedDuringICO3 = totalWeiRaisedDuringICO3.add(msg.value);\n', '                totalTokensICO3 = totalTokensICO3.add(tokensThatWillBeMintedAfterPurchase);\n', '            } else if (stage == CrowdsaleStage.ICO4) {\n', '                totalWeiRaisedDuringICO4 = totalWeiRaisedDuringICO4.add(msg.value);\n', '                totalTokensICO4 = totalTokensICO4.add(tokensThatWillBeMintedAfterPurchase);\n', '            }\n', '\n', '        }\n', '        // update state\n', '        tokensMinted = tokensMinted.add(tokensThatWillBeMintedAfterPurchase);      \n', '        \n', '    }\n', '\n', '    // =========================\n', '    function () external payable {\n', '        revert();\n', '    }\n', '\n', '    function forwardFunds() internal {\n', '        // if Wei raised greater than softcap, send to wallet else put in refund vault\n', '        if (goalReached()) {\n', '            wallet.transfer(msg.value);\n', '            emit EthTransferred("forwarding funds to wallet");\n', '        } else  {\n', '            emit EthTransferred("forwarding funds to refundable vault");\n', '            super.forwardFunds();\n', '        }\n', '    }\n', '  \n', '     /**\n', '    * @dev perform a transfer of allocations (recommend doing in batches of 80 due to gas block limit)\n', '    * @param _from is the address the tokens will come from\n', '    * @param _recipient is a list of recipients\n', '    * @param _premium is a bool of if the list of addresses are premium or not\n', '    */\n', '    function airdropTokens(address _from, address[] _recipient, bool _premium) public onlyOwner {\n', '        uint airdropped;\n', '        uint tokens;\n', '\n', '        if(_premium == true) {\n', '            tokens = 500000000000000000000;\n', '        } else {\n', '            tokens = 50000000000000000000;\n', '        }\n', '\n', '        for(uint256 i = 0; i < _recipient.length; i++)\n', '        {\n', '            if (!airdrops[_recipient[i]]) {\n', '                airdrops[_recipient[i]] = true;\n', '                require(tokenReward.transferFrom(_from, _recipient[i], tokens));\n', '                airdropped = airdropped.add(tokens);\n', '            }\n', '        }\n', '        \n', '        airDropsClaimed = airDropsClaimed.add(airdropped);\n', '    }\n', '\n', '  // Finish: Mint Extra Tokens as needed before finalizing the Crowdsale.\n', '  // ====================================================================\n', '\n', '    function finish() public onlyOwner {\n', '\n', '        require(!isFinalized);\n', '        \n', '        if(tokensMinted < totalTokensForSale) {\n', '\n', '            uint256 unsoldTokens = totalTokensForSale - tokensMinted;            \n', '            tokenReward.mint(community, unsoldTokens);\n', '            \n', '        }\n', '             \n', '        finalize();\n', '    } \n', '\n', '    // if goal reached, manually close the vault\n', '    function releaseVault() public onlyOwner {\n', '        require(goalReached());\n', '        vault.close();\n', '    }\n', '\n', '    // transfers ownership of contract back to wallet\n', '    function transferTokenOwnership(address _newOwner) public onlyOwner {\n', '        tokenReward.transferOwnership(_newOwner);\n', '    }\n', '  // ===============================\n', '\n', '  \n', '}']
