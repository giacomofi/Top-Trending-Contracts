['pragma solidity ^0.4.21;\n', '\n', 'contract Updater\n', '{\n', '    mapping (address => bool) public owners;\n', '\n', '    struct State {\n', '        bool exchange;\n', '        bool payment;\n', '    }\n', '    mapping(address => State) public states;\n', '\n', '    event InfoUpdated(bytes4 indexed method, address indexed target, bool indexed res, uint256 ETHUSD, uint256 token, uint256 value);\n', '    event OwnerChanged(address indexed previousOwner, bool state);\n', '\n', '    modifier onlyOwner() {\n', '        require(owners[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function Updater() public {\n', '        owners[msg.sender] = true;\n', '    }\n', '\n', '    function setOwner(address _newOwner,bool _state) onlyOwner public {\n', '        emit OwnerChanged(_newOwner, _state);\n', '        owners[_newOwner] = _state;\n', '    }\n', '\n', '    function setStates(address[] _addr, uint8[] _exchange, uint8[] _payment) onlyOwner public {\n', '        for(uint256 i = 0; i < _addr.length; i++){\n', '            states[_addr[i]].exchange = _exchange[i]>0;\n', '            states[_addr[i]].payment = _payment[i]>0;\n', '        }\n', '    }\n', '\n', '    function update(address[] _addr, uint256[] _ETHUSD, uint256[] _token, uint256[] _value) onlyOwner public {\n', '        for(uint256 i = 0; i < _addr.length; i++){\n', '            State storage state = states[_addr[i]];\n', '            bool res;\n', '            if(!(state.exchange || state.payment)){\n', '                res=_addr[i].call(bytes4(keccak256("updateInfo(uint256,uint256,uint256)")),_ETHUSD[i],_token[i],_value[i]);\n', '                emit InfoUpdated(bytes4(keccak256("updateInfo(uint256,uint256,uint256)")),_addr[i],res,_ETHUSD[i],_token[i],_value[i]);\n', '                continue;\n', '            }\n', '            if(state.exchange){\n', '                res=_addr[i].call(bytes4(keccak256("changeExchange(uint256)")),_ETHUSD[i]);\n', '                emit InfoUpdated(bytes4(keccak256("changeExchange(uint256)")),_addr[i],res,_ETHUSD[i],0x0,0x0);\n', '            }\n', '            if(state.payment){\n', '                res=_addr[i].call(bytes4(keccak256("paymentsInOtherCurrency(uint256,uint256)")),_token[i],_value[i]);\n', '                emit InfoUpdated(bytes4(keccak256("paymentsInOtherCurrency(uint256,uint256)")),_addr[i],res,0x0,_token[i],_value[i]);\n', '            }\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract Updater\n', '{\n', '    mapping (address => bool) public owners;\n', '\n', '    struct State {\n', '        bool exchange;\n', '        bool payment;\n', '    }\n', '    mapping(address => State) public states;\n', '\n', '    event InfoUpdated(bytes4 indexed method, address indexed target, bool indexed res, uint256 ETHUSD, uint256 token, uint256 value);\n', '    event OwnerChanged(address indexed previousOwner, bool state);\n', '\n', '    modifier onlyOwner() {\n', '        require(owners[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function Updater() public {\n', '        owners[msg.sender] = true;\n', '    }\n', '\n', '    function setOwner(address _newOwner,bool _state) onlyOwner public {\n', '        emit OwnerChanged(_newOwner, _state);\n', '        owners[_newOwner] = _state;\n', '    }\n', '\n', '    function setStates(address[] _addr, uint8[] _exchange, uint8[] _payment) onlyOwner public {\n', '        for(uint256 i = 0; i < _addr.length; i++){\n', '            states[_addr[i]].exchange = _exchange[i]>0;\n', '            states[_addr[i]].payment = _payment[i]>0;\n', '        }\n', '    }\n', '\n', '    function update(address[] _addr, uint256[] _ETHUSD, uint256[] _token, uint256[] _value) onlyOwner public {\n', '        for(uint256 i = 0; i < _addr.length; i++){\n', '            State storage state = states[_addr[i]];\n', '            bool res;\n', '            if(!(state.exchange || state.payment)){\n', '                res=_addr[i].call(bytes4(keccak256("updateInfo(uint256,uint256,uint256)")),_ETHUSD[i],_token[i],_value[i]);\n', '                emit InfoUpdated(bytes4(keccak256("updateInfo(uint256,uint256,uint256)")),_addr[i],res,_ETHUSD[i],_token[i],_value[i]);\n', '                continue;\n', '            }\n', '            if(state.exchange){\n', '                res=_addr[i].call(bytes4(keccak256("changeExchange(uint256)")),_ETHUSD[i]);\n', '                emit InfoUpdated(bytes4(keccak256("changeExchange(uint256)")),_addr[i],res,_ETHUSD[i],0x0,0x0);\n', '            }\n', '            if(state.payment){\n', '                res=_addr[i].call(bytes4(keccak256("paymentsInOtherCurrency(uint256,uint256)")),_token[i],_value[i]);\n', '                emit InfoUpdated(bytes4(keccak256("paymentsInOtherCurrency(uint256,uint256)")),_addr[i],res,0x0,_token[i],_value[i]);\n', '            }\n', '        }\n', '    }\n', '}']
