['pragma solidity ^0.4.13;\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    function DSAuth() public {\n', '        owner = msg.sender;\n', '        LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'contract DSExec {\n', '    function tryExec( address target, bytes calldata, uint value)\n', '             internal\n', '             returns (bool call_ret)\n', '    {\n', '        return target.call.value(value)(calldata);\n', '    }\n', '    function exec( address target, bytes calldata, uint value)\n', '             internal\n', '    {\n', '        if(!tryExec(target, calldata, value)) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    // Convenience aliases\n', '    function exec( address t, bytes c )\n', '        internal\n', '    {\n', '        exec(t, c, 0);\n', '    }\n', '    function exec( address t, uint256 v )\n', '        internal\n', '    {\n', '        bytes memory c; exec(t, c, v);\n', '    }\n', '    function tryExec( address t, bytes c )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return tryExec(t, c, 0);\n', '    }\n', '    function tryExec( address t, uint256 v )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        bytes memory c; return tryExec(t, c, v);\n', '    }\n', '}\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  guy,\n', '        bytes32  indexed  foo,\n', '        bytes32  indexed  bar,\n', '        uint              wad,\n', '        bytes             fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', 'contract DSGroup is DSExec, DSNote {\n', '    address[]  public  members;\n', '    uint       public  quorum;\n', '    uint       public  window;\n', '    uint       public  actionCount;\n', '\n', '    mapping (uint => Action)                     public  actions;\n', '    mapping (uint => mapping (address => bool))  public  confirmedBy;\n', '    mapping (address => bool)                    public  isMember;\n', '\n', '    // Legacy events\n', '    event Proposed   (uint id, bytes calldata);\n', '    event Confirmed  (uint id, address member);\n', '    event Triggered  (uint id);\n', '\n', '    struct Action {\n', '        address  target;\n', '        bytes    calldata;\n', '        uint     value;\n', '\n', '        uint     confirmations;\n', '        uint     deadline;\n', '        bool     triggered;\n', '    }\n', '\n', '    function DSGroup(\n', '        address[]  members_,\n', '        uint       quorum_,\n', '        uint       window_\n', '    ) {\n', '        members  = members_;\n', '        quorum   = quorum_;\n', '        window   = window_;\n', '\n', '        for (uint i = 0; i < members.length; i++) {\n', '            isMember[members[i]] = true;\n', '        }\n', '    }\n', '\n', '    function memberCount() constant returns (uint) {\n', '        return members.length;\n', '    }\n', '\n', '    function target(uint id) constant returns (address) {\n', '        return actions[id].target;\n', '    }\n', '    function calldata(uint id) constant returns (bytes) {\n', '        return actions[id].calldata;\n', '    }\n', '    function value(uint id) constant returns (uint) {\n', '        return actions[id].value;\n', '    }\n', '\n', '    function confirmations(uint id) constant returns (uint) {\n', '        return actions[id].confirmations;\n', '    }\n', '    function deadline(uint id) constant returns (uint) {\n', '        return actions[id].deadline;\n', '    }\n', '    function triggered(uint id) constant returns (bool) {\n', '        return actions[id].triggered;\n', '    }\n', '\n', '    function confirmed(uint id) constant returns (bool) {\n', '        return confirmations(id) >= quorum;\n', '    }\n', '    function expired(uint id) constant returns (bool) {\n', '        return now > deadline(id);\n', '    }\n', '\n', '    function deposit() note payable {\n', '    }\n', '\n', '    function propose(\n', '        address  target,\n', '        bytes    calldata,\n', '        uint     value\n', '    ) onlyMembers note returns (uint id) {\n', '        id = ++actionCount;\n', '\n', '        actions[id].target    = target;\n', '        actions[id].calldata  = calldata;\n', '        actions[id].value     = value;\n', '        actions[id].deadline  = now + window;\n', '\n', '        Proposed(id, calldata);\n', '    }\n', '\n', '    function confirm(uint id) onlyMembers onlyActive(id) note {\n', '        assert(!confirmedBy[id][msg.sender]);\n', '\n', '        confirmedBy[id][msg.sender] = true;\n', '        actions[id].confirmations++;\n', '\n', '        Confirmed(id, msg.sender);\n', '    }\n', '\n', '    function trigger(uint id) onlyMembers onlyActive(id) note {\n', '        assert(confirmed(id));\n', '\n', '        actions[id].triggered = true;\n', '        exec(actions[id].target, actions[id].calldata, actions[id].value);\n', '\n', '        Triggered(id);\n', '    }\n', '\n', '    modifier onlyMembers {\n', '        assert(isMember[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyActive(uint id) {\n', '        assert(!expired(id));\n', '        assert(!triggered(id));\n', '        _;\n', '    }\n', '\n', '    //------------------------------------------------------------------\n', '    // Legacy functions\n', '    //------------------------------------------------------------------\n', '\n', '    function getInfo() constant returns (\n', '        uint  quorum_,\n', '        uint  memberCount,\n', '        uint  window_,\n', '        uint  actionCount_\n', '    ) {\n', '        return (quorum, members.length, window, actionCount);\n', '    }\n', '\n', '    function getActionStatus(uint id) constant returns (\n', '        uint     confirmations,\n', '        uint     deadline,\n', '        bool     triggered,\n', '        address  target,\n', '        uint     value\n', '    ) {\n', '        return (\n', '            actions[id].confirmations,\n', '            actions[id].deadline,\n', '            actions[id].triggered,\n', '            actions[id].target,\n', '            actions[id].value\n', '        );\n', '    }\n', '}\n', '\n', 'contract DSGroupFactory is DSNote {\n', '    mapping (address => bool)  public  isGroup;\n', '\n', '    function newGroup(\n', '        address[]  members,\n', '        uint       quorum,\n', '        uint       window\n', '    ) note returns (DSGroup group) {\n', '        group = new DSGroup(members, quorum, window);\n', '        isGroup[group] = true;\n', '    }\n', '}\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', '    // It&#39;s O(log n), instead of O(n) for naive repeated multiplication.\n', '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract DSThing is DSAuth, DSNote, DSMath {\n', '\n', '    function S(string s) internal pure returns (bytes4) {\n', '        return bytes4(keccak256(s));\n', '    }\n', '\n', '}\n', '\n', 'contract WETH9_ {\n', '    string public name     = "Wrapped Ether";\n', '    string public symbol   = "WETH";\n', '    uint8  public decimals = 18;\n', '\n', '    event  Approval(address indexed src, address indexed guy, uint wad);\n', '    event  Transfer(address indexed src, address indexed dst, uint wad);\n', '    event  Deposit(address indexed dst, uint wad);\n', '    event  Withdrawal(address indexed src, uint wad);\n', '\n', '    mapping (address => uint)                       public  balanceOf;\n', '    mapping (address => mapping (address => uint))  public  allowance;\n', '\n', '    function() public payable {\n', '        deposit();\n', '    }\n', '    function deposit() public payable {\n', '        balanceOf[msg.sender] += msg.value;\n', '        Deposit(msg.sender, msg.value);\n', '    }\n', '    function withdraw(uint wad) public {\n', '        require(balanceOf[msg.sender] >= wad);\n', '        balanceOf[msg.sender] -= wad;\n', '        msg.sender.transfer(wad);\n', '        Withdrawal(msg.sender, wad);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return this.balance;\n', '    }\n', '\n', '    function approve(address guy, uint wad) public returns (bool) {\n', '        allowance[msg.sender][guy] = wad;\n', '        Approval(msg.sender, guy, wad);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(balanceOf[src] >= wad);\n', '\n', '        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n', '            require(allowance[src][msg.sender] >= wad);\n', '            allowance[src][msg.sender] -= wad;\n', '        }\n', '\n', '        balanceOf[src] -= wad;\n', '        balanceOf[dst] += wad;\n', '\n', '        Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'interface FundInterface {\n', '\n', '    // EVENTS\n', '\n', '    event PortfolioContent(address[] assets, uint[] holdings, uint[] prices);\n', '    event RequestUpdated(uint id);\n', '    event Redeemed(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\n', '    event FeesConverted(uint atTimestamp, uint shareQuantityConverted, uint unclaimed);\n', '    event CalculationUpdate(uint atTimestamp, uint managementFee, uint performanceFee, uint nav, uint sharePrice, uint totalSupply);\n', '    event ErrorMessage(string errorMessage);\n', '\n', '    // EXTERNAL METHODS\n', '    // Compliance by Investor\n', '    function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external;\n', '    function executeRequest(uint requestId) external;\n', '    function cancelRequest(uint requestId) external;\n', '    function redeemAllOwnedAssets(uint shareQuantity) external returns (bool);\n', '    // Administration by Manager\n', '    function enableInvestment(address[] ofAssets) external;\n', '    function disableInvestment(address[] ofAssets) external;\n', '    function shutDown() external;\n', '\n', '    // PUBLIC METHODS\n', '    function emergencyRedeem(uint shareQuantity, address[] requestedAssets) public returns (bool success);\n', '    function calcSharePriceAndAllocateFees() public returns (uint);\n', '\n', '\n', '    // PUBLIC VIEW METHODS\n', '    // Get general information\n', '    function getModules() view returns (address, address, address);\n', '    function getLastRequestId() view returns (uint);\n', '    function getManager() view returns (address);\n', '\n', '    // Get accounting information\n', '    function performCalculations() view returns (uint, uint, uint, uint, uint, uint, uint);\n', '    function calcSharePrice() view returns (uint);\n', '}\n', '\n', 'interface AssetInterface {\n', '    /*\n', '     * Implements ERC 20 standard.\n', '     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\n', '     * https://github.com/ethereum/EIPs/issues/20\n', '     *\n', '     *  Added support for the ERC 223 "tokenFallback" method in a "transfer" function with a payload.\n', '     *  https://github.com/ethereum/EIPs/issues/223\n', '     */\n', '\n', '    // Events\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    // There is no ERC223 compatible Transfer event, with `_data` included.\n', '\n', '    //ERC 223\n', '    // PUBLIC METHODS\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool success);\n', '\n', '    // ERC 20\n', '    // PUBLIC METHODS\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    // PUBLIC VIEW METHODS\n', '    function balanceOf(address _owner) view public returns (uint balance);\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '}\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract Asset is DSMath, ERC20Interface {\n', '\n', '    // DATA STRUCTURES\n', '\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '    uint public _totalSupply;\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /**\n', '     * @notice Send `_value` tokens to `_to` from `msg.sender`\n', '     * @dev Transfers sender&#39;s tokens to a given address\n', '     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\n', '     * @param _to Address of token receiver\n', '     * @param _value Number of tokens to transfer\n', '     * @return Returns success of function call\n', '     */\n', '    function transfer(address _to, uint _value)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(balances[msg.sender] >= _value); // sanity checks\n', '        require(balances[_to] + _value >= balances[_to]);\n', '\n', '        balances[msg.sender] = sub(balances[msg.sender], _value);\n', '        balances[_to] = add(balances[_to], _value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    /// @notice Transfer `_value` tokens from `_from` to `_to` if `msg.sender` is allowed.\n', '    /// @notice Restriction: An account can only use this function to send to itself\n', '    /// @dev Allows for an approved third party to transfer tokens from one\n', '    /// address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @return Returns success of function call.\n', '    function transferFrom(address _from, address _to, uint _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(_from != address(0));\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        require(balances[_from] >= _value);\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]);\n', '        // require(_to == msg.sender); // can only use transferFrom to send to self\n', '\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    /// @return Returns success of function call.\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        require(_spender != address(0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @dev Returns number of allowed tokens that a spender can transfer on\n', '    /// behalf of a token owner.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    /// @return Returns remaining allowance for spender.\n', '    function allowance(address _owner, address _spender)\n', '        constant\n', '        public\n', '        returns (uint)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by the given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @return Returns balance of owner.\n', '    function balanceOf(address _owner) constant public returns (uint) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function totalSupply() view public returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '}\n', '\n', 'interface SharesInterface {\n', '\n', '    event Created(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\n', '    event Annihilated(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\n', '\n', '    // VIEW METHODS\n', '\n', '    function getName() view returns (bytes32);\n', '    function getSymbol() view returns (bytes8);\n', '    function getDecimals() view returns (uint);\n', '    function getCreationTime() view returns (uint);\n', '    function toSmallestShareUnit(uint quantity) view returns (uint);\n', '    function toWholeShareUnit(uint quantity) view returns (uint);\n', '\n', '}\n', '\n', 'contract Shares is SharesInterface, Asset {\n', '\n', '    // FIELDS\n', '\n', '    // Constructor fields\n', '    bytes32 public name;\n', '    bytes8 public symbol;\n', '    uint public decimal;\n', '    uint public creationTime;\n', '\n', '    // METHODS\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @param _name Name these shares\n', '    /// @param _symbol Symbol of shares\n', '    /// @param _decimal Amount of decimals sharePrice is denominated in, defined to be equal as deciamls in REFERENCE_ASSET contract\n', '    /// @param _creationTime Timestamp of share creation\n', '    function Shares(bytes32 _name, bytes8 _symbol, uint _decimal, uint _creationTime) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimal = _decimal;\n', '        creationTime = _creationTime;\n', '    }\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /**\n', '     * @notice Send `_value` tokens to `_to` from `msg.sender`\n', '     * @dev Transfers sender&#39;s tokens to a given address\n', '     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\n', '     * @param _to Address of token receiver\n', '     * @param _value Number of tokens to transfer\n', '     * @return Returns success of function call\n', '     */\n', '    function transfer(address _to, uint _value)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(balances[msg.sender] >= _value); // sanity checks\n', '        require(balances[_to] + _value >= balances[_to]);\n', '\n', '        balances[msg.sender] = sub(balances[msg.sender], _value);\n', '        balances[_to] = add(balances[_to], _value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    function getName() view returns (bytes32) { return name; }\n', '    function getSymbol() view returns (bytes8) { return symbol; }\n', '    function getDecimals() view returns (uint) { return decimal; }\n', '    function getCreationTime() view returns (uint) { return creationTime; }\n', '    function toSmallestShareUnit(uint quantity) view returns (uint) { return mul(quantity, 10 ** getDecimals()); }\n', '    function toWholeShareUnit(uint quantity) view returns (uint) { return quantity / (10 ** getDecimals()); }\n', '\n', '    // INTERNAL METHODS\n', '\n', '    /// @param recipient Address the new shares should be sent to\n', '    /// @param shareQuantity Number of shares to be created\n', '    function createShares(address recipient, uint shareQuantity) internal {\n', '        _totalSupply = add(_totalSupply, shareQuantity);\n', '        balances[recipient] = add(balances[recipient], shareQuantity);\n', '        emit Created(msg.sender, now, shareQuantity);\n', '        emit Transfer(address(0), recipient, shareQuantity);\n', '    }\n', '\n', '    /// @param recipient Address the new shares should be taken from when destroyed\n', '    /// @param shareQuantity Number of shares to be annihilated\n', '    function annihilateShares(address recipient, uint shareQuantity) internal {\n', '        _totalSupply = sub(_totalSupply, shareQuantity);\n', '        balances[recipient] = sub(balances[recipient], shareQuantity);\n', '        emit Annihilated(msg.sender, now, shareQuantity);\n', '        emit Transfer(recipient, address(0), shareQuantity);\n', '    }\n', '}\n', '\n', 'interface CompetitionInterface {\n', '\n', '    // EVENTS\n', '\n', '    event Register(uint withId, address fund, address manager);\n', '    event ClaimReward(address registrant, address fund, uint shares);\n', '\n', '    // PRE, POST, INVARIANT CONDITIONS\n', '\n', '    function termsAndConditionsAreSigned(address byManager, uint8 v, bytes32 r, bytes32 s) view returns (bool);\n', '    function isWhitelisted(address x) view returns (bool);\n', '    function isCompetitionActive() view returns (bool);\n', '\n', '    // CONSTANT METHODS\n', '\n', '    function getMelonAsset() view returns (address);\n', '    function getRegistrantId(address x) view returns (uint);\n', '    function getRegistrantFund(address x) view returns (address);\n', '    function getCompetitionStatusOfRegistrants() view returns (address[], address[], bool[]);\n', '    function getTimeTillEnd() view returns (uint);\n', '    function getEtherValue(uint amount) view returns (uint);\n', '    function calculatePayout(uint payin) view returns (uint);\n', '\n', '    // PUBLIC METHODS\n', '\n', '    function registerForCompetition(address fund, uint8 v, bytes32 r, bytes32 s) payable;\n', '    function batchAddToWhitelist(uint maxBuyinQuantity, address[] whitelistants);\n', '    function withdrawMln(address to, uint amount);\n', '    function claimReward();\n', '\n', '}\n', '\n', 'interface ComplianceInterface {\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @notice Checks whether investment is permitted for a participant\n', '    /// @param ofParticipant Address requesting to invest in a Melon fund\n', '    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\n', '    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\n', '    /// @return Whether identity is eligible to invest in a Melon fund.\n', '    function isInvestmentPermitted(\n', '        address ofParticipant,\n', '        uint256 giveQuantity,\n', '        uint256 shareQuantity\n', '    ) view returns (bool);\n', '\n', '    /// @notice Checks whether redemption is permitted for a participant\n', '    /// @param ofParticipant Address requesting to redeem from a Melon fund\n', '    /// @param shareQuantity Quantity of shares times 10 ** 18 offered to redeem\n', '    /// @param receiveQuantity Quantity of Melon token times 10 ** 18 requested to receive for shareQuantity\n', '    /// @return Whether identity is eligible to redeem from a Melon fund.\n', '    function isRedemptionPermitted(\n', '        address ofParticipant,\n', '        uint256 shareQuantity,\n', '        uint256 receiveQuantity\n', '    ) view returns (bool);\n', '}\n', '\n', 'contract DBC {\n', '\n', '    // MODIFIERS\n', '\n', '    modifier pre_cond(bool condition) {\n', '        require(condition);\n', '        _;\n', '    }\n', '\n', '    modifier post_cond(bool condition) {\n', '        _;\n', '        assert(condition);\n', '    }\n', '\n', '    modifier invariant(bool condition) {\n', '        require(condition);\n', '        _;\n', '        assert(condition);\n', '    }\n', '}\n', '\n', 'contract Owned is DBC {\n', '\n', '    // FIELDS\n', '\n', '    address public owner;\n', '\n', '    // NON-CONSTANT METHODS\n', '\n', '    function Owned() { owner = msg.sender; }\n', '\n', '    function changeOwner(address ofNewOwner) pre_cond(isOwner()) { owner = ofNewOwner; }\n', '\n', '    // PRE, POST, INVARIANT CONDITIONS\n', '\n', '    function isOwner() internal returns (bool) { return msg.sender == owner; }\n', '\n', '}\n', '\n', 'contract Fund is DSMath, DBC, Owned, Shares, FundInterface {\n', '\n', '    event OrderUpdated(address exchange, bytes32 orderId, UpdateType updateType);\n', '\n', '    // TYPES\n', '\n', '    struct Modules { // Describes all modular parts, standardised through an interface\n', '        CanonicalPriceFeed pricefeed; // Provides all external data\n', '        ComplianceInterface compliance; // Boolean functions regarding invest/redeem\n', '        RiskMgmtInterface riskmgmt; // Boolean functions regarding make/take orders\n', '    }\n', '\n', '    struct Calculations { // List of internal calculations\n', '        uint gav; // Gross asset value\n', '        uint managementFee; // Time based fee\n', '        uint performanceFee; // Performance based fee measured against QUOTE_ASSET\n', '        uint unclaimedFees; // Fees not yet allocated to the fund manager\n', '        uint nav; // Net asset value\n', '        uint highWaterMark; // A record of best all-time fund performance\n', '        uint totalSupply; // Total supply of shares\n', '        uint timestamp; // Time when calculations are performed in seconds\n', '    }\n', '\n', '    enum UpdateType { make, take, cancel }\n', '    enum RequestStatus { active, cancelled, executed }\n', '    struct Request { // Describes and logs whenever asset enter and leave fund due to Participants\n', '        address participant; // Participant in Melon fund requesting investment or redemption\n', '        RequestStatus status; // Enum: active, cancelled, executed; Status of request\n', '        address requestAsset; // Address of the asset being requested\n', '        uint shareQuantity; // Quantity of Melon fund shares\n', '        uint giveQuantity; // Quantity in Melon asset to give to Melon fund to receive shareQuantity\n', '        uint receiveQuantity; // Quantity in Melon asset to receive from Melon fund for given shareQuantity\n', '        uint timestamp;     // Time of request creation in seconds\n', '        uint atUpdateId;    // Pricefeed updateId when this request was created\n', '    }\n', '\n', '    struct Exchange {\n', '        address exchange;\n', '        address exchangeAdapter;\n', '        bool takesCustody;  // exchange takes custody before making order\n', '    }\n', '\n', '    struct OpenMakeOrder {\n', '        uint id; // Order Id from exchange\n', '        uint expiresAt; // Timestamp when the order expires\n', '    }\n', '\n', '    struct Order { // Describes an order event (make or take order)\n', '        address exchangeAddress; // address of the exchange this order is on\n', '        bytes32 orderId; // Id as returned from exchange\n', '        UpdateType updateType; // Enum: make, take (cancel should be ignored)\n', '        address makerAsset; // Order maker&#39;s asset\n', '        address takerAsset; // Order taker&#39;s asset\n', '        uint makerQuantity; // Quantity of makerAsset to be traded\n', '        uint takerQuantity; // Quantity of takerAsset to be traded\n', '        uint timestamp; // Time of order creation in seconds\n', '        uint fillTakerQuantity; // Quantity of takerAsset to be filled\n', '    }\n', '\n', '    // FIELDS\n', '\n', '    // Constant fields\n', '    uint public constant MAX_FUND_ASSETS = 20; // Max ownable assets by the fund supported by gas limits\n', '    uint public constant ORDER_EXPIRATION_TIME = 86400; // Make order expiration time (1 day)\n', '    // Constructor fields\n', '    uint public MANAGEMENT_FEE_RATE; // Fee rate in QUOTE_ASSET per managed seconds in WAD\n', '    uint public PERFORMANCE_FEE_RATE; // Fee rate in QUOTE_ASSET per delta improvement in WAD\n', '    address public VERSION; // Address of Version contract\n', '    Asset public QUOTE_ASSET; // QUOTE asset as ERC20 contract\n', '    // Methods fields\n', '    Modules public modules; // Struct which holds all the initialised module instances\n', '    Exchange[] public exchanges; // Array containing exchanges this fund supports\n', '    Calculations public atLastUnclaimedFeeAllocation; // Calculation results at last allocateUnclaimedFees() call\n', '    Order[] public orders;  // append-only list of makes/takes from this fund\n', '    mapping (address => mapping(address => OpenMakeOrder)) public exchangesToOpenMakeOrders; // exchangeIndex to: asset to open make orders\n', '    bool public isShutDown; // Security feature, if yes than investing, managing, allocateUnclaimedFees gets blocked\n', '    Request[] public requests; // All the requests this fund received from participants\n', '    mapping (address => bool) public isInvestAllowed; // If false, fund rejects investments from the key asset\n', '    address[] public ownedAssets; // List of all assets owned by the fund or for which the fund has open make orders\n', '    mapping (address => bool) public isInAssetList; // Mapping from asset to whether the asset exists in ownedAssets\n', '    mapping (address => bool) public isInOpenMakeOrder; // Mapping from asset to whether the asset is in a open make order as buy asset\n', '\n', '    // METHODS\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @dev Should only be called via Version.setupFund(..)\n', '    /// @param withName human-readable descriptive name (not necessarily unique)\n', '    /// @param ofQuoteAsset Asset against which mgmt and performance fee is measured against and which can be used to invest using this single asset\n', '    /// @param ofManagementFee A time based fee expressed, given in a number which is divided by 1 WAD\n', '    /// @param ofPerformanceFee A time performance based fee, performance relative to ofQuoteAsset, given in a number which is divided by 1 WAD\n', '    /// @param ofCompliance Address of compliance module\n', '    /// @param ofRiskMgmt Address of risk management module\n', '    /// @param ofPriceFeed Address of price feed module\n', '    /// @param ofExchanges Addresses of exchange on which this fund can trade\n', '    /// @param ofDefaultAssets Addresses of assets to enable invest for (quote asset is already enabled)\n', '    /// @return Deployed Fund with manager set as ofManager\n', '    function Fund(\n', '        address ofManager,\n', '        bytes32 withName,\n', '        address ofQuoteAsset,\n', '        uint ofManagementFee,\n', '        uint ofPerformanceFee,\n', '        address ofCompliance,\n', '        address ofRiskMgmt,\n', '        address ofPriceFeed,\n', '        address[] ofExchanges,\n', '        address[] ofDefaultAssets\n', '    )\n', '        Shares(withName, "MLNF", 18, now)\n', '    {\n', '        require(ofManagementFee < 10 ** 18); // Require management fee to be less than 100 percent\n', '        require(ofPerformanceFee < 10 ** 18); // Require performance fee to be less than 100 percent\n', '        isInvestAllowed[ofQuoteAsset] = true;\n', '        owner = ofManager;\n', '        MANAGEMENT_FEE_RATE = ofManagementFee; // 1 percent is expressed as 0.01 * 10 ** 18\n', '        PERFORMANCE_FEE_RATE = ofPerformanceFee; // 1 percent is expressed as 0.01 * 10 ** 18\n', '        VERSION = msg.sender;\n', '        modules.compliance = ComplianceInterface(ofCompliance);\n', '        modules.riskmgmt = RiskMgmtInterface(ofRiskMgmt);\n', '        modules.pricefeed = CanonicalPriceFeed(ofPriceFeed);\n', '        // Bridged to Melon exchange interface by exchangeAdapter library\n', '        for (uint i = 0; i < ofExchanges.length; ++i) {\n', '            require(modules.pricefeed.exchangeIsRegistered(ofExchanges[i]));\n', '            var (ofExchangeAdapter, takesCustody, ) = modules.pricefeed.getExchangeInformation(ofExchanges[i]);\n', '            exchanges.push(Exchange({\n', '                exchange: ofExchanges[i],\n', '                exchangeAdapter: ofExchangeAdapter,\n', '                takesCustody: takesCustody\n', '            }));\n', '        }\n', '        QUOTE_ASSET = Asset(ofQuoteAsset);\n', '        // Quote Asset always in owned assets list\n', '        ownedAssets.push(ofQuoteAsset);\n', '        isInAssetList[ofQuoteAsset] = true;\n', '        require(address(QUOTE_ASSET) == modules.pricefeed.getQuoteAsset()); // Sanity check\n', '        for (uint j = 0; j < ofDefaultAssets.length; j++) {\n', '            require(modules.pricefeed.assetIsRegistered(ofDefaultAssets[j]));\n', '            isInvestAllowed[ofDefaultAssets[j]] = true;\n', '        }\n', '        atLastUnclaimedFeeAllocation = Calculations({\n', '            gav: 0,\n', '            managementFee: 0,\n', '            performanceFee: 0,\n', '            unclaimedFees: 0,\n', '            nav: 0,\n', '            highWaterMark: 10 ** getDecimals(),\n', '            totalSupply: _totalSupply,\n', '            timestamp: now\n', '        });\n', '    }\n', '\n', '    // EXTERNAL METHODS\n', '\n', '    // EXTERNAL : ADMINISTRATION\n', '\n', '    /// @notice Enable investment in specified assets\n', '    /// @param ofAssets Array of assets to enable investment in\n', '    function enableInvestment(address[] ofAssets)\n', '        external\n', '        pre_cond(isOwner())\n', '    {\n', '        for (uint i = 0; i < ofAssets.length; ++i) {\n', '            require(modules.pricefeed.assetIsRegistered(ofAssets[i]));\n', '            isInvestAllowed[ofAssets[i]] = true;\n', '        }\n', '    }\n', '\n', '    /// @notice Disable investment in specified assets\n', '    /// @param ofAssets Array of assets to disable investment in\n', '    function disableInvestment(address[] ofAssets)\n', '        external\n', '        pre_cond(isOwner())\n', '    {\n', '        for (uint i = 0; i < ofAssets.length; ++i) {\n', '            isInvestAllowed[ofAssets[i]] = false;\n', '        }\n', '    }\n', '\n', '    function shutDown() external pre_cond(msg.sender == VERSION) { isShutDown = true; }\n', '\n', '    // EXTERNAL : PARTICIPATION\n', '\n', '    /// @notice Give melon tokens to receive shares of this fund\n', '    /// @dev Recommended to give some leeway in prices to account for possibly slightly changing prices\n', '    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\n', '    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\n', '    /// @param investmentAsset Address of asset to invest in\n', '    function requestInvestment(\n', '        uint giveQuantity,\n', '        uint shareQuantity,\n', '        address investmentAsset\n', '    )\n', '        external\n', '        pre_cond(!isShutDown)\n', '        pre_cond(isInvestAllowed[investmentAsset]) // investment using investmentAsset has not been deactivated by the Manager\n', '        pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity))    // Compliance Module: Investment permitted\n', '    {\n', '        requests.push(Request({\n', '            participant: msg.sender,\n', '            status: RequestStatus.active,\n', '            requestAsset: investmentAsset,\n', '            shareQuantity: shareQuantity,\n', '            giveQuantity: giveQuantity,\n', '            receiveQuantity: shareQuantity,\n', '            timestamp: now,\n', '            atUpdateId: modules.pricefeed.getLastUpdateId()\n', '        }));\n', '\n', '        emit RequestUpdated(getLastRequestId());\n', '    }\n', '\n', '    /// @notice Executes active investment and redemption requests, in a way that minimises information advantages of investor\n', '    /// @dev Distributes melon and shares according to the request\n', '    /// @param id Index of request to be executed\n', '    /// @dev Active investment or redemption request executed\n', '    function executeRequest(uint id)\n', '        external\n', '        pre_cond(!isShutDown)\n', '        pre_cond(requests[id].status == RequestStatus.active)\n', '        pre_cond(\n', '            _totalSupply == 0 ||\n', '            (\n', '                now >= add(requests[id].timestamp, modules.pricefeed.getInterval()) &&\n', '                modules.pricefeed.getLastUpdateId() >= add(requests[id].atUpdateId, 2)\n', '            )\n', '        )   // PriceFeed Module: Wait at least one interval time and two updates before continuing (unless it is the first investment)\n', '\n', '    {\n', '        Request request = requests[id];\n', '        var (isRecent, , ) =\n', '            modules.pricefeed.getPriceInfo(address(request.requestAsset));\n', '        require(isRecent);\n', '\n', '        // sharePrice quoted in QUOTE_ASSET and multiplied by 10 ** fundDecimals\n', '        uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees())); // By definition quoteDecimals == fundDecimals\n', '        if (request.requestAsset != address(QUOTE_ASSET)) {\n', '            var (isPriceRecent, invertedRequestAssetPrice, requestAssetDecimal) = modules.pricefeed.getInvertedPriceInfo(request.requestAsset);\n', '            if (!isPriceRecent) {\n', '                revert();\n', '            }\n', '            costQuantity = mul(costQuantity, invertedRequestAssetPrice) / 10 ** requestAssetDecimal;\n', '        }\n', '\n', '        if (\n', '            isInvestAllowed[request.requestAsset] &&\n', '            costQuantity <= request.giveQuantity\n', '        ) {\n', '            request.status = RequestStatus.executed;\n', '            require(AssetInterface(request.requestAsset).transferFrom(request.participant, address(this), costQuantity)); // Allocate Value\n', '            createShares(request.participant, request.shareQuantity); // Accounting\n', '            if (!isInAssetList[request.requestAsset]) {\n', '                ownedAssets.push(request.requestAsset);\n', '                isInAssetList[request.requestAsset] = true;\n', '            }\n', '        } else {\n', '            revert(); // Invalid Request or invalid giveQuantity / receiveQuantity\n', '        }\n', '    }\n', '\n', '    /// @notice Cancels active investment and redemption requests\n', '    /// @param id Index of request to be executed\n', '    function cancelRequest(uint id)\n', '        external\n', '        pre_cond(requests[id].status == RequestStatus.active) // Request is active\n', '        pre_cond(requests[id].participant == msg.sender || isShutDown) // Either request creator or fund is shut down\n', '    {\n', '        requests[id].status = RequestStatus.cancelled;\n', '    }\n', '\n', '    /// @notice Redeems by allocating an ownership percentage of each asset to the participant\n', '    /// @dev Independent of running price feed!\n', '    /// @param shareQuantity Number of shares owned by the participant, which the participant would like to redeem for individual assets\n', '    /// @return Whether all assets sent to shareholder or not\n', '    function redeemAllOwnedAssets(uint shareQuantity)\n', '        external\n', '        returns (bool success)\n', '    {\n', '        return emergencyRedeem(shareQuantity, ownedAssets);\n', '    }\n', '\n', '    // EXTERNAL : MANAGING\n', '\n', '    /// @notice Universal method for calling exchange functions through adapters\n', '    /// @notice See adapter contracts for parameters needed for each exchange\n', '    /// @param exchangeIndex Index of the exchange in the "exchanges" array\n', '    /// @param method Signature of the adapter method to call (as per ABI spec)\n', '    /// @param orderAddresses [0] Order maker\n', '    /// @param orderAddresses [1] Order taker\n', '    /// @param orderAddresses [2] Order maker asset\n', '    /// @param orderAddresses [3] Order taker asset\n', '    /// @param orderAddresses [4] Fee recipient\n', '    /// @param orderValues [0] Maker token quantity\n', '    /// @param orderValues [1] Taker token quantity\n', '    /// @param orderValues [2] Maker fee\n', '    /// @param orderValues [3] Taker fee\n', '    /// @param orderValues [4] Timestamp (seconds)\n', '    /// @param orderValues [5] Salt/nonce\n', '    /// @param orderValues [6] Fill amount: amount of taker token to be traded\n', '    /// @param orderValues [7] Dexy signature mode\n', '    /// @param identifier Order identifier\n', '    /// @param v ECDSA recovery id\n', '    /// @param r ECDSA signature output r\n', '    /// @param s ECDSA signature output s\n', '    function callOnExchange(\n', '        uint exchangeIndex,\n', '        bytes4 method,\n', '        address[5] orderAddresses,\n', '        uint[8] orderValues,\n', '        bytes32 identifier,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '        external\n', '    {\n', '        require(modules.pricefeed.exchangeMethodIsAllowed(\n', '            exchanges[exchangeIndex].exchange, method\n', '        ));\n', '        require((exchanges[exchangeIndex].exchangeAdapter).delegatecall(\n', '            method, exchanges[exchangeIndex].exchange,\n', '            orderAddresses, orderValues, identifier, v, r, s\n', '        ));\n', '    }\n', '\n', '    function addOpenMakeOrder(\n', '        address ofExchange,\n', '        address ofSellAsset,\n', '        uint orderId\n', '    )\n', '        pre_cond(msg.sender == address(this))\n', '    {\n', '        isInOpenMakeOrder[ofSellAsset] = true;\n', '        exchangesToOpenMakeOrders[ofExchange][ofSellAsset].id = orderId;\n', '        exchangesToOpenMakeOrders[ofExchange][ofSellAsset].expiresAt = add(now, ORDER_EXPIRATION_TIME);\n', '    }\n', '\n', '    function removeOpenMakeOrder(\n', '        address ofExchange,\n', '        address ofSellAsset\n', '    )\n', '        pre_cond(msg.sender == address(this))\n', '    {\n', '        delete exchangesToOpenMakeOrders[ofExchange][ofSellAsset];\n', '    }\n', '\n', '    function orderUpdateHook(\n', '        address ofExchange,\n', '        bytes32 orderId,\n', '        UpdateType updateType,\n', '        address[2] orderAddresses, // makerAsset, takerAsset\n', '        uint[3] orderValues        // makerQuantity, takerQuantity, fillTakerQuantity (take only)\n', '    )\n', '        pre_cond(msg.sender == address(this))\n', '    {\n', '        // only save make/take\n', '        if (updateType == UpdateType.make || updateType == UpdateType.take) {\n', '            orders.push(Order({\n', '                exchangeAddress: ofExchange,\n', '                orderId: orderId,\n', '                updateType: updateType,\n', '                makerAsset: orderAddresses[0],\n', '                takerAsset: orderAddresses[1],\n', '                makerQuantity: orderValues[0],\n', '                takerQuantity: orderValues[1],\n', '                timestamp: block.timestamp,\n', '                fillTakerQuantity: orderValues[2]\n', '            }));\n', '        }\n', '        emit OrderUpdated(ofExchange, orderId, updateType);\n', '    }\n', '\n', '    // PUBLIC METHODS\n', '\n', '    // PUBLIC METHODS : ACCOUNTING\n', '\n', '    /// @notice Calculates gross asset value of the fund\n', '    /// @dev Decimals in assets must be equal to decimals in PriceFeed for all entries in AssetRegistrar\n', '    /// @dev Assumes that module.pricefeed.getPriceInfo(..) returns recent prices\n', '    /// @return gav Gross asset value quoted in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    function calcGav() returns (uint gav) {\n', '        // prices quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\n', '        uint[] memory allAssetHoldings = new uint[](ownedAssets.length);\n', '        uint[] memory allAssetPrices = new uint[](ownedAssets.length);\n', '        address[] memory tempOwnedAssets;\n', '        tempOwnedAssets = ownedAssets;\n', '        delete ownedAssets;\n', '        for (uint i = 0; i < tempOwnedAssets.length; ++i) {\n', '            address ofAsset = tempOwnedAssets[i];\n', '            // assetHoldings formatting: mul(exchangeHoldings, 10 ** assetDecimal)\n', '            uint assetHoldings = add(\n', '                uint(AssetInterface(ofAsset).balanceOf(address(this))), // asset base units held by fund\n', '                quantityHeldInCustodyOfExchange(ofAsset)\n', '            );\n', '            // assetPrice formatting: mul(exchangePrice, 10 ** assetDecimal)\n', '            var (isRecent, assetPrice, assetDecimals) = modules.pricefeed.getPriceInfo(ofAsset);\n', '            if (!isRecent) {\n', '                revert();\n', '            }\n', '            allAssetHoldings[i] = assetHoldings;\n', '            allAssetPrices[i] = assetPrice;\n', '            // gav as sum of mul(assetHoldings, assetPrice) with formatting: mul(mul(exchangeHoldings, exchangePrice), 10 ** shareDecimals)\n', '            gav = add(gav, mul(assetHoldings, assetPrice) / (10 ** uint256(assetDecimals)));   // Sum up product of asset holdings of this vault and asset prices\n', '            if (assetHoldings != 0 || ofAsset == address(QUOTE_ASSET) || isInOpenMakeOrder[ofAsset]) { // Check if asset holdings is not zero or is address(QUOTE_ASSET) or in open make order\n', '                ownedAssets.push(ofAsset);\n', '            } else {\n', '                isInAssetList[ofAsset] = false; // Remove from ownedAssets if asset holdings are zero\n', '            }\n', '        }\n', '        emit PortfolioContent(tempOwnedAssets, allAssetHoldings, allAssetPrices);\n', '    }\n', '\n', '    /// @notice Add an asset to the list that this fund owns\n', '    function addAssetToOwnedAssets (address ofAsset)\n', '        public\n', '        pre_cond(isOwner() || msg.sender == address(this))\n', '    {\n', '        isInOpenMakeOrder[ofAsset] = true;\n', '        if (!isInAssetList[ofAsset]) {\n', '            ownedAssets.push(ofAsset);\n', '            isInAssetList[ofAsset] = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '    @notice Calculates unclaimed fees of the fund manager\n', '    @param gav Gross asset value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    @return {\n', '      "managementFees": "A time (seconds) based fee in QUOTE_ASSET and multiplied by 10 ** shareDecimals",\n', '      "performanceFees": "A performance (rise of sharePrice measured in QUOTE_ASSET) based fee in QUOTE_ASSET and multiplied by 10 ** shareDecimals",\n', '      "unclaimedfees": "The sum of both managementfee and performancefee in QUOTE_ASSET and multiplied by 10 ** shareDecimals"\n', '    }\n', '    */\n', '    function calcUnclaimedFees(uint gav)\n', '        view\n', '        returns (\n', '            uint managementFee,\n', '            uint performanceFee,\n', '            uint unclaimedFees)\n', '    {\n', '        // Management fee calculation\n', '        uint timePassed = sub(now, atLastUnclaimedFeeAllocation.timestamp);\n', '        uint gavPercentage = mul(timePassed, gav) / (1 years);\n', '        managementFee = wmul(gavPercentage, MANAGEMENT_FEE_RATE);\n', '\n', '        // Performance fee calculation\n', '        // Handle potential division through zero by defining a default value\n', '        uint valuePerShareExclMgmtFees = _totalSupply > 0 ? calcValuePerShare(sub(gav, managementFee), _totalSupply) : toSmallestShareUnit(1);\n', '        if (valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation.highWaterMark) {\n', '            uint gainInSharePrice = sub(valuePerShareExclMgmtFees, atLastUnclaimedFeeAllocation.highWaterMark);\n', '            uint investmentProfits = wmul(gainInSharePrice, _totalSupply);\n', '            performanceFee = wmul(investmentProfits, PERFORMANCE_FEE_RATE);\n', '        }\n', '\n', '        // Sum of all FEES\n', '        unclaimedFees = add(managementFee, performanceFee);\n', '    }\n', '\n', '    /// @notice Calculates the Net asset value of this fund\n', '    /// @param gav Gross asset value of this fund in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    /// @param unclaimedFees The sum of both managementFee and performanceFee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    /// @return nav Net asset value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    function calcNav(uint gav, uint unclaimedFees)\n', '        view\n', '        returns (uint nav)\n', '    {\n', '        nav = sub(gav, unclaimedFees);\n', '    }\n', '\n', '    /// @notice Calculates the share price of the fund\n', '    /// @dev Convention for valuePerShare (== sharePrice) formatting: mul(totalValue / numShares, 10 ** decimal), to avoid floating numbers\n', '    /// @dev Non-zero share supply; value denominated in [base unit of melonAsset]\n', '    /// @param totalValue the total value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    /// @param numShares the number of shares multiplied by 10 ** shareDecimals\n', '    /// @return valuePerShare Share price denominated in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    function calcValuePerShare(uint totalValue, uint numShares)\n', '        view\n', '        pre_cond(numShares > 0)\n', '        returns (uint valuePerShare)\n', '    {\n', '        valuePerShare = toSmallestShareUnit(totalValue) / numShares;\n', '    }\n', '\n', '    /**\n', '    @notice Calculates essential fund metrics\n', '    @return {\n', '      "gav": "Gross asset value of this fund denominated in [base unit of melonAsset]",\n', '      "managementFee": "A time (seconds) based fee",\n', '      "performanceFee": "A performance (rise of sharePrice measured in QUOTE_ASSET) based fee",\n', '      "unclaimedFees": "The sum of both managementFee and performanceFee denominated in [base unit of melonAsset]",\n', '      "feesShareQuantity": "The number of shares to be given as fees to the manager",\n', '      "nav": "Net asset value denominated in [base unit of melonAsset]",\n', '      "sharePrice": "Share price denominated in [base unit of melonAsset]"\n', '    }\n', '    */\n', '    function performCalculations()\n', '        view\n', '        returns (\n', '            uint gav,\n', '            uint managementFee,\n', '            uint performanceFee,\n', '            uint unclaimedFees,\n', '            uint feesShareQuantity,\n', '            uint nav,\n', '            uint sharePrice\n', '        )\n', '    {\n', '        gav = calcGav(); // Reflects value independent of fees\n', '        (managementFee, performanceFee, unclaimedFees) = calcUnclaimedFees(gav);\n', '        nav = calcNav(gav, unclaimedFees);\n', '\n', '        // The value of unclaimedFees measured in shares of this fund at current value\n', '        feesShareQuantity = (gav == 0) ? 0 : mul(_totalSupply, unclaimedFees) / gav;\n', '        // The total share supply including the value of unclaimedFees, measured in shares of this fund\n', '        uint totalSupplyAccountingForFees = add(_totalSupply, feesShareQuantity);\n', '        sharePrice = _totalSupply > 0 ? calcValuePerShare(gav, totalSupplyAccountingForFees) : toSmallestShareUnit(1); // Handle potential division through zero by defining a default value\n', '    }\n', '\n', '    /// @notice Converts unclaimed fees of the manager into fund shares\n', '    /// @return sharePrice Share price denominated in [base unit of melonAsset]\n', '    function calcSharePriceAndAllocateFees() public returns (uint)\n', '    {\n', '        var (\n', '            gav,\n', '            managementFee,\n', '            performanceFee,\n', '            unclaimedFees,\n', '            feesShareQuantity,\n', '            nav,\n', '            sharePrice\n', '        ) = performCalculations();\n', '\n', '        createShares(owner, feesShareQuantity); // Updates _totalSupply by creating shares allocated to manager\n', '\n', '        // Update Calculations\n', '        uint highWaterMark = atLastUnclaimedFeeAllocation.highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation.highWaterMark : sharePrice;\n', '        atLastUnclaimedFeeAllocation = Calculations({\n', '            gav: gav,\n', '            managementFee: managementFee,\n', '            performanceFee: performanceFee,\n', '            unclaimedFees: unclaimedFees,\n', '            nav: nav,\n', '            highWaterMark: highWaterMark,\n', '            totalSupply: _totalSupply,\n', '            timestamp: now\n', '        });\n', '\n', '        emit FeesConverted(now, feesShareQuantity, unclaimedFees);\n', '        emit CalculationUpdate(now, managementFee, performanceFee, nav, sharePrice, _totalSupply);\n', '\n', '        return sharePrice;\n', '    }\n', '\n', '    // PUBLIC : REDEEMING\n', '\n', '    /// @notice Redeems by allocating an ownership percentage only of requestedAssets to the participant\n', '    /// @dev This works, but with loops, so only up to a certain number of assets (right now the max is 4)\n', '    /// @dev Independent of running price feed! Note: if requestedAssets != ownedAssets then participant misses out on some owned value\n', '    /// @param shareQuantity Number of shares owned by the participant, which the participant would like to redeem for a slice of assets\n', '    /// @param requestedAssets List of addresses that consitute a subset of ownedAssets.\n', '    /// @return Whether all assets sent to shareholder or not\n', '    function emergencyRedeem(uint shareQuantity, address[] requestedAssets)\n', '        public\n', '        pre_cond(balances[msg.sender] >= shareQuantity)  // sender owns enough shares\n', '        returns (bool)\n', '    {\n', '        address ofAsset;\n', '        uint[] memory ownershipQuantities = new uint[](requestedAssets.length);\n', '        address[] memory redeemedAssets = new address[](requestedAssets.length);\n', '\n', '        // Check whether enough assets held by fund\n', '        for (uint i = 0; i < requestedAssets.length; ++i) {\n', '            ofAsset = requestedAssets[i];\n', '            require(isInAssetList[ofAsset]);\n', '            for (uint j = 0; j < redeemedAssets.length; j++) {\n', '                if (ofAsset == redeemedAssets[j]) {\n', '                    revert();\n', '                }\n', '            }\n', '            redeemedAssets[i] = ofAsset;\n', '            uint assetHoldings = add(\n', '                uint(AssetInterface(ofAsset).balanceOf(address(this))),\n', '                quantityHeldInCustodyOfExchange(ofAsset)\n', '            );\n', '\n', '            if (assetHoldings == 0) continue;\n', '\n', '            // participant&#39;s ownership percentage of asset holdings\n', '            ownershipQuantities[i] = mul(assetHoldings, shareQuantity) / _totalSupply;\n', '\n', '            // CRITICAL ERR: Not enough fund asset balance for owed ownershipQuantitiy, eg in case of unreturned asset quantity at address(exchanges[i].exchange) address\n', '            if (uint(AssetInterface(ofAsset).balanceOf(address(this))) < ownershipQuantities[i]) {\n', '                isShutDown = true;\n', '                emit ErrorMessage("CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy");\n', '                return false;\n', '            }\n', '        }\n', '\n', '        // Annihilate shares before external calls to prevent reentrancy\n', '        annihilateShares(msg.sender, shareQuantity);\n', '\n', '        // Transfer ownershipQuantity of Assets\n', '        for (uint k = 0; k < requestedAssets.length; ++k) {\n', '            // Failed to send owed ownershipQuantity from fund to participant\n', '            ofAsset = requestedAssets[k];\n', '            if (ownershipQuantities[k] == 0) {\n', '                continue;\n', '            } else if (!AssetInterface(ofAsset).transfer(msg.sender, ownershipQuantities[k])) {\n', '                revert();\n', '            }\n', '        }\n', '        emit Redeemed(msg.sender, now, shareQuantity);\n', '        return true;\n', '    }\n', '\n', '    // PUBLIC : FEES\n', '\n', '    /// @dev Quantity of asset held in exchange according to associated order id\n', '    /// @param ofAsset Address of asset\n', '    /// @return Quantity of input asset held in exchange\n', '    function quantityHeldInCustodyOfExchange(address ofAsset) returns (uint) {\n', '        uint totalSellQuantity;     // quantity in custody across exchanges\n', '        uint totalSellQuantityInApprove; // quantity of asset in approve (allowance) but not custody of exchange\n', '        for (uint i; i < exchanges.length; i++) {\n', '            if (exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id == 0) {\n', '                continue;\n', '            }\n', '            var (sellAsset, , sellQuantity, ) = GenericExchangeInterface(exchanges[i].exchangeAdapter).getOrder(exchanges[i].exchange, exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id);\n', '            if (sellQuantity == 0) {    // remove id if remaining sell quantity zero (closed)\n', '                delete exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset];\n', '            }\n', '            totalSellQuantity = add(totalSellQuantity, sellQuantity);\n', '            if (!exchanges[i].takesCustody) {\n', '                totalSellQuantityInApprove += sellQuantity;\n', '            }\n', '        }\n', '        if (totalSellQuantity == 0) {\n', '            isInOpenMakeOrder[sellAsset] = false;\n', '        }\n', '        return sub(totalSellQuantity, totalSellQuantityInApprove); // Since quantity in approve is not actually in custody\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @notice Calculates sharePrice denominated in [base unit of melonAsset]\n', '    /// @return sharePrice Share price denominated in [base unit of melonAsset]\n', '    function calcSharePrice() view returns (uint sharePrice) {\n', '        (, , , , , sharePrice) = performCalculations();\n', '        return sharePrice;\n', '    }\n', '\n', '    function getModules() view returns (address, address, address) {\n', '        return (\n', '            address(modules.pricefeed),\n', '            address(modules.compliance),\n', '            address(modules.riskmgmt)\n', '        );\n', '    }\n', '\n', '    function getLastRequestId() view returns (uint) { return requests.length - 1; }\n', '    function getLastOrderIndex() view returns (uint) { return orders.length - 1; }\n', '    function getManager() view returns (address) { return owner; }\n', '    function getOwnedAssetsLength() view returns (uint) { return ownedAssets.length; }\n', '    function getExchangeInfo() view returns (address[], address[], bool[]) {\n', '        address[] memory ofExchanges = new address[](exchanges.length);\n', '        address[] memory ofAdapters = new address[](exchanges.length);\n', '        bool[] memory takesCustody = new bool[](exchanges.length);\n', '        for (uint i = 0; i < exchanges.length; i++) {\n', '            ofExchanges[i] = exchanges[i].exchange;\n', '            ofAdapters[i] = exchanges[i].exchangeAdapter;\n', '            takesCustody[i] = exchanges[i].takesCustody;\n', '        }\n', '        return (ofExchanges, ofAdapters, takesCustody);\n', '    }\n', '    function orderExpired(address ofExchange, address ofAsset) view returns (bool) {\n', '        uint expiryTime = exchangesToOpenMakeOrders[ofExchange][ofAsset].expiresAt;\n', '        require(expiryTime > 0);\n', '        return block.timestamp >= expiryTime;\n', '    }\n', '    function getOpenOrderInfo(address ofExchange, address ofAsset) view returns (uint, uint) {\n', '        OpenMakeOrder order = exchangesToOpenMakeOrders[ofExchange][ofAsset];\n', '        return (order.id, order.expiresAt);\n', '    }\n', '}\n', '\n', 'contract CompetitionCompliance is ComplianceInterface, DBC, Owned {\n', '\n', '    address public competitionAddress;\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @dev Constructor\n', '    /// @param ofCompetition Address of the competition contract\n', '    function CompetitionCompliance(address ofCompetition) public {\n', '        competitionAddress = ofCompetition;\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @notice Checks whether investment is permitted for a participant\n', '    /// @param ofParticipant Address requesting to invest in a Melon fund\n', '    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\n', '    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\n', '    /// @return Whether identity is eligible to invest in a Melon fund.\n', '    function isInvestmentPermitted(\n', '        address ofParticipant,\n', '        uint256 giveQuantity,\n', '        uint256 shareQuantity\n', '    )\n', '        view\n', '        returns (bool)\n', '    {\n', '        return competitionAddress == ofParticipant;\n', '    }\n', '\n', '    /// @notice Checks whether redemption is permitted for a participant\n', '    /// @param ofParticipant Address requesting to redeem from a Melon fund\n', '    /// @param shareQuantity Quantity of shares times 10 ** 18 offered to redeem\n', '    /// @param receiveQuantity Quantity of Melon token times 10 ** 18 requested to receive for shareQuantity\n', '    /// @return isEligible Whether identity is eligible to redeem from a Melon fund.\n', '    function isRedemptionPermitted(\n', '        address ofParticipant,\n', '        uint256 shareQuantity,\n', '        uint256 receiveQuantity\n', '    )\n', '        view\n', '        returns (bool)\n', '    {\n', '        return competitionAddress == ofParticipant;\n', '    }\n', '\n', '    /// @notice Checks whether an address is whitelisted in the competition contract and competition is active\n', '    /// @param x Address\n', '    /// @return Whether the address is whitelisted\n', '    function isCompetitionAllowed(\n', '        address x\n', '    )\n', '        view\n', '        returns (bool)\n', '    {\n', '        return CompetitionInterface(competitionAddress).isWhitelisted(x) && CompetitionInterface(competitionAddress).isCompetitionActive();\n', '    }\n', '\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /// @notice Changes the competition address\n', '    /// @param ofCompetition Address of the competition contract\n', '    function changeCompetitionAddress(\n', '        address ofCompetition\n', '    )\n', '        pre_cond(isOwner())\n', '    {\n', '        competitionAddress = ofCompetition;\n', '    }\n', '\n', '}\n', '\n', 'interface GenericExchangeInterface {\n', '\n', '    // EVENTS\n', '\n', '    event OrderUpdated(uint id);\n', '\n', '    // METHODS\n', '    // EXTERNAL METHODS\n', '\n', '    function makeOrder(\n', '        address onExchange,\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    ) external returns (uint);\n', '    function takeOrder(address onExchange, uint id, uint quantity) external returns (bool);\n', '    function cancelOrder(address onExchange, uint id) external returns (bool);\n', '\n', '\n', '    // PUBLIC METHODS\n', '    // PUBLIC VIEW METHODS\n', '\n', '    function isApproveOnly() view returns (bool);\n', '    function getLastOrderId(address onExchange) view returns (uint);\n', '    function isActive(address onExchange, uint id) view returns (bool);\n', '    function getOwner(address onExchange, uint id) view returns (address);\n', '    function getOrder(address onExchange, uint id) view returns (address, address, uint, uint);\n', '    function getTimestamp(address onExchange, uint id) view returns (uint);\n', '\n', '}\n', '\n', 'contract CanonicalRegistrar is DSThing, DBC {\n', '\n', '    // TYPES\n', '\n', '    struct Asset {\n', '        bool exists; // True if asset is registered here\n', '        bytes32 name; // Human-readable name of the Asset as in ERC223 token standard\n', '        bytes8 symbol; // Human-readable symbol of the Asset as in ERC223 token standard\n', '        uint decimals; // Decimal, order of magnitude of precision, of the Asset as in ERC223 token standard\n', '        string url; // URL for additional information of Asset\n', '        string ipfsHash; // Same as url but for ipfs\n', '        address breakIn; // Break in contract on destination chain\n', '        address breakOut; // Break out contract on this chain; A way to leave\n', '        uint[] standards; // compliance with standards like ERC20, ERC223, ERC777, etc. (the uint is the standard number)\n', '        bytes4[] functionSignatures; // Whitelisted function signatures that can be called using `useExternalFunction` in Fund contract. Note: Adhere to a naming convention for `Fund<->Asset` as much as possible. I.e. name same concepts with the same functionSignature.\n', '        uint price; // Price of asset quoted against `QUOTE_ASSET` * 10 ** decimals\n', '        uint timestamp; // Timestamp of last price update of this asset\n', '    }\n', '\n', '    struct Exchange {\n', '        bool exists;\n', '        address adapter; // adapter contract for this exchange\n', '        // One-time note: takesCustody is inverse case of isApproveOnly\n', '        bool takesCustody; // True in case of exchange implementation which requires  are approved when an order is made instead of transfer\n', '        bytes4[] functionSignatures; // Whitelisted function signatures that can be called using `useExternalFunction` in Fund contract. Note: Adhere to a naming convention for `Fund<->ExchangeAdapter` as much as possible. I.e. name same concepts with the same functionSignature.\n', '    }\n', '    // TODO: populate each field here\n', '    // TODO: add whitelistFunction function\n', '\n', '    // FIELDS\n', '\n', '    // Methods fields\n', '    mapping (address => Asset) public assetInformation;\n', '    address[] public registeredAssets;\n', '\n', '    mapping (address => Exchange) public exchangeInformation;\n', '    address[] public registeredExchanges;\n', '\n', '    // METHODS\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /// @notice Registers an Asset information entry\n', '    /// @dev Pre: Only registrar owner should be able to register\n', '    /// @dev Post: Address ofAsset is registered\n', '    /// @param ofAsset Address of asset to be registered\n', '    /// @param inputName Human-readable name of the Asset as in ERC223 token standard\n', '    /// @param inputSymbol Human-readable symbol of the Asset as in ERC223 token standard\n', '    /// @param inputDecimals Human-readable symbol of the Asset as in ERC223 token standard\n', '    /// @param inputUrl Url for extended information of the asset\n', '    /// @param inputIpfsHash Same as url but for ipfs\n', '    /// @param breakInBreakOut Address of break in and break out contracts on destination chain\n', '    /// @param inputStandards Integers of EIP standards this asset adheres to\n', '    /// @param inputFunctionSignatures Function signatures for whitelisted asset functions\n', '    function registerAsset(\n', '        address ofAsset,\n', '        bytes32 inputName,\n', '        bytes8 inputSymbol,\n', '        uint inputDecimals,\n', '        string inputUrl,\n', '        string inputIpfsHash,\n', '        address[2] breakInBreakOut,\n', '        uint[] inputStandards,\n', '        bytes4[] inputFunctionSignatures\n', '    )\n', '        auth\n', '        pre_cond(!assetInformation[ofAsset].exists)\n', '    {\n', '        assetInformation[ofAsset].exists = true;\n', '        registeredAssets.push(ofAsset);\n', '        updateAsset(\n', '            ofAsset,\n', '            inputName,\n', '            inputSymbol,\n', '            inputDecimals,\n', '            inputUrl,\n', '            inputIpfsHash,\n', '            breakInBreakOut,\n', '            inputStandards,\n', '            inputFunctionSignatures\n', '        );\n', '        assert(assetInformation[ofAsset].exists);\n', '    }\n', '\n', '    /// @notice Register an exchange information entry\n', '    /// @dev Pre: Only registrar owner should be able to register\n', '    /// @dev Post: Address ofExchange is registered\n', '    /// @param ofExchange Address of the exchange\n', '    /// @param ofExchangeAdapter Address of exchange adapter for this exchange\n', '    /// @param inputTakesCustody Whether this exchange takes custody of tokens before trading\n', '    /// @param inputFunctionSignatures Function signatures for whitelisted exchange functions\n', '    function registerExchange(\n', '        address ofExchange,\n', '        address ofExchangeAdapter,\n', '        bool inputTakesCustody,\n', '        bytes4[] inputFunctionSignatures\n', '    )\n', '        auth\n', '        pre_cond(!exchangeInformation[ofExchange].exists)\n', '    {\n', '        exchangeInformation[ofExchange].exists = true;\n', '        registeredExchanges.push(ofExchange);\n', '        updateExchange(\n', '            ofExchange,\n', '            ofExchangeAdapter,\n', '            inputTakesCustody,\n', '            inputFunctionSignatures\n', '        );\n', '        assert(exchangeInformation[ofExchange].exists);\n', '    }\n', '\n', '    /// @notice Updates description information of a registered Asset\n', '    /// @dev Pre: Owner can change an existing entry\n', '    /// @dev Post: Changed Name, Symbol, URL and/or IPFSHash\n', '    /// @param ofAsset Address of the asset to be updated\n', '    /// @param inputName Human-readable name of the Asset as in ERC223 token standard\n', '    /// @param inputSymbol Human-readable symbol of the Asset as in ERC223 token standard\n', '    /// @param inputUrl Url for extended information of the asset\n', '    /// @param inputIpfsHash Same as url but for ipfs\n', '    function updateAsset(\n', '        address ofAsset,\n', '        bytes32 inputName,\n', '        bytes8 inputSymbol,\n', '        uint inputDecimals,\n', '        string inputUrl,\n', '        string inputIpfsHash,\n', '        address[2] ofBreakInBreakOut,\n', '        uint[] inputStandards,\n', '        bytes4[] inputFunctionSignatures\n', '    )\n', '        auth\n', '        pre_cond(assetInformation[ofAsset].exists)\n', '    {\n', '        Asset asset = assetInformation[ofAsset];\n', '        asset.name = inputName;\n', '        asset.symbol = inputSymbol;\n', '        asset.decimals = inputDecimals;\n', '        asset.url = inputUrl;\n', '        asset.ipfsHash = inputIpfsHash;\n', '        asset.breakIn = ofBreakInBreakOut[0];\n', '        asset.breakOut = ofBreakInBreakOut[1];\n', '        asset.standards = inputStandards;\n', '        asset.functionSignatures = inputFunctionSignatures;\n', '    }\n', '\n', '    function updateExchange(\n', '        address ofExchange,\n', '        address ofExchangeAdapter,\n', '        bool inputTakesCustody,\n', '        bytes4[] inputFunctionSignatures\n', '    )\n', '        auth\n', '        pre_cond(exchangeInformation[ofExchange].exists)\n', '    {\n', '        Exchange exchange = exchangeInformation[ofExchange];\n', '        exchange.adapter = ofExchangeAdapter;\n', '        exchange.takesCustody = inputTakesCustody;\n', '        exchange.functionSignatures = inputFunctionSignatures;\n', '    }\n', '\n', '    // TODO: check max size of array before remaking this becomes untenable\n', '    /// @notice Deletes an existing entry\n', '    /// @dev Owner can delete an existing entry\n', '    /// @param ofAsset address for which specific information is requested\n', '    function removeAsset(\n', '        address ofAsset,\n', '        uint assetIndex\n', '    )\n', '        auth\n', '        pre_cond(assetInformation[ofAsset].exists)\n', '    {\n', '        require(registeredAssets[assetIndex] == ofAsset);\n', '        delete assetInformation[ofAsset]; // Sets exists boolean to false\n', '        delete registeredAssets[assetIndex];\n', '        for (uint i = assetIndex; i < registeredAssets.length-1; i++) {\n', '            registeredAssets[i] = registeredAssets[i+1];\n', '        }\n', '        registeredAssets.length--;\n', '        assert(!assetInformation[ofAsset].exists);\n', '    }\n', '\n', '    /// @notice Deletes an existing entry\n', '    /// @dev Owner can delete an existing entry\n', '    /// @param ofExchange address for which specific information is requested\n', '    /// @param exchangeIndex index of the exchange in array\n', '    function removeExchange(\n', '        address ofExchange,\n', '        uint exchangeIndex\n', '    )\n', '        auth\n', '        pre_cond(exchangeInformation[ofExchange].exists)\n', '    {\n', '        require(registeredExchanges[exchangeIndex] == ofExchange);\n', '        delete exchangeInformation[ofExchange];\n', '        delete registeredExchanges[exchangeIndex];\n', '        for (uint i = exchangeIndex; i < registeredExchanges.length-1; i++) {\n', '            registeredExchanges[i] = registeredExchanges[i+1];\n', '        }\n', '        registeredExchanges.length--;\n', '        assert(!exchangeInformation[ofExchange].exists);\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    // get asset specific information\n', '    function getName(address ofAsset) view returns (bytes32) { return assetInformation[ofAsset].name; }\n', '    function getSymbol(address ofAsset) view returns (bytes8) { return assetInformation[ofAsset].symbol; }\n', '    function getDecimals(address ofAsset) view returns (uint) { return assetInformation[ofAsset].decimals; }\n', '    function assetIsRegistered(address ofAsset) view returns (bool) { return assetInformation[ofAsset].exists; }\n', '    function getRegisteredAssets() view returns (address[]) { return registeredAssets; }\n', '    function assetMethodIsAllowed(\n', '        address ofAsset, bytes4 querySignature\n', '    )\n', '        returns (bool)\n', '    {\n', '        bytes4[] memory signatures = assetInformation[ofAsset].functionSignatures;\n', '        for (uint i = 0; i < signatures.length; i++) {\n', '            if (signatures[i] == querySignature) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    // get exchange-specific information\n', '    function exchangeIsRegistered(address ofExchange) view returns (bool) { return exchangeInformation[ofExchange].exists; }\n', '    function getRegisteredExchanges() view returns (address[]) { return registeredExchanges; }\n', '    function getExchangeInformation(address ofExchange)\n', '        view\n', '        returns (address, bool)\n', '    {\n', '        Exchange exchange = exchangeInformation[ofExchange];\n', '        return (\n', '            exchange.adapter,\n', '            exchange.takesCustody\n', '        );\n', '    }\n', '    function getExchangeFunctionSignatures(address ofExchange)\n', '        view\n', '        returns (bytes4[])\n', '    {\n', '        return exchangeInformation[ofExchange].functionSignatures;\n', '    }\n', '    function exchangeMethodIsAllowed(\n', '        address ofExchange, bytes4 querySignature\n', '    )\n', '        returns (bool)\n', '    {\n', '        bytes4[] memory signatures = exchangeInformation[ofExchange].functionSignatures;\n', '        for (uint i = 0; i < signatures.length; i++) {\n', '            if (signatures[i] == querySignature) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '}\n', '\n', 'interface SimplePriceFeedInterface {\n', '\n', '    // EVENTS\n', '\n', '    event PriceUpdated(bytes32 hash);\n', '\n', '    // PUBLIC METHODS\n', '\n', '    function update(address[] ofAssets, uint[] newPrices) external;\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    // Get price feed operation specific information\n', '    function getQuoteAsset() view returns (address);\n', '    function getLastUpdateId() view returns (uint);\n', '    // Get asset specific information as updated in price feed\n', '    function getPrice(address ofAsset) view returns (uint price, uint timestamp);\n', '    function getPrices(address[] ofAssets) view returns (uint[] prices, uint[] timestamps);\n', '}\n', '\n', 'contract SimplePriceFeed is SimplePriceFeedInterface, DSThing, DBC {\n', '\n', '    // TYPES\n', '    struct Data {\n', '        uint price;\n', '        uint timestamp;\n', '    }\n', '\n', '    // FIELDS\n', '    mapping(address => Data) public assetsToPrices;\n', '\n', '    // Constructor fields\n', '    address public QUOTE_ASSET; // Asset of a portfolio against which all other assets are priced\n', '\n', '    // Contract-level variables\n', '    uint public updateId;        // Update counter for this pricefeed; used as a check during investment\n', '    CanonicalRegistrar public registrar;\n', '    CanonicalPriceFeed public superFeed;\n', '\n', '    // METHODS\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @param ofQuoteAsset Address of quote asset\n', '    /// @param ofRegistrar Address of canonical registrar\n', '    /// @param ofSuperFeed Address of superfeed\n', '    function SimplePriceFeed(\n', '        address ofRegistrar,\n', '        address ofQuoteAsset,\n', '        address ofSuperFeed\n', '    ) {\n', '        registrar = CanonicalRegistrar(ofRegistrar);\n', '        QUOTE_ASSET = ofQuoteAsset;\n', '        superFeed = CanonicalPriceFeed(ofSuperFeed);\n', '    }\n', '\n', '    // EXTERNAL METHODS\n', '\n', '    /// @dev Only Owner; Same sized input arrays\n', '    /// @dev Updates price of asset relative to QUOTE_ASSET\n', '    /** Ex:\n', '     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\n', '     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\n', '     *  and let EUR-T decimals == 8.\n', '     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\n', '     */\n', '    /// @param ofAssets list of asset addresses\n', '    /// @param newPrices list of prices for each of the assets\n', '    function update(address[] ofAssets, uint[] newPrices)\n', '        external\n', '        auth\n', '    {\n', '        _updatePrices(ofAssets, newPrices);\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    // Get pricefeed specific information\n', '    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\n', '    function getLastUpdateId() view returns (uint) { return updateId; }\n', '\n', '    /**\n', '    @notice Gets price of an asset multiplied by ten to the power of assetDecimals\n', '    @dev Asset has been registered\n', '    @param ofAsset Asset for which price should be returned\n', '    @return {\n', '      "price": "Price formatting: mul(exchangePrice, 10 ** decimal), to avoid floating numbers",\n', '      "timestamp": "When the asset&#39;s price was updated"\n', '    }\n', '    */\n', '    function getPrice(address ofAsset)\n', '        view\n', '        returns (uint price, uint timestamp)\n', '    {\n', '        Data data = assetsToPrices[ofAsset];\n', '        return (data.price, data.timestamp);\n', '    }\n', '\n', '    /**\n', '    @notice Price of a registered asset in format (bool areRecent, uint[] prices, uint[] decimals)\n', '    @dev Convention for price formatting: mul(price, 10 ** decimal), to avoid floating numbers\n', '    @param ofAssets Assets for which prices should be returned\n', '    @return {\n', '        "prices":       "Array of prices",\n', '        "timestamps":   "Array of timestamps",\n', '    }\n', '    */\n', '    function getPrices(address[] ofAssets)\n', '        view\n', '        returns (uint[], uint[])\n', '    {\n', '        uint[] memory prices = new uint[](ofAssets.length);\n', '        uint[] memory timestamps = new uint[](ofAssets.length);\n', '        for (uint i; i < ofAssets.length; i++) {\n', '            var (price, timestamp) = getPrice(ofAssets[i]);\n', '            prices[i] = price;\n', '            timestamps[i] = timestamp;\n', '        }\n', '        return (prices, timestamps);\n', '    }\n', '\n', '    // INTERNAL METHODS\n', '\n', '    /// @dev Internal so that feeds inheriting this one are not obligated to have an exposed update(...) method, but can still perform updates\n', '    function _updatePrices(address[] ofAssets, uint[] newPrices)\n', '        internal\n', '        pre_cond(ofAssets.length == newPrices.length)\n', '    {\n', '        updateId++;\n', '        for (uint i = 0; i < ofAssets.length; ++i) {\n', '            require(registrar.assetIsRegistered(ofAssets[i]));\n', '            require(assetsToPrices[ofAssets[i]].timestamp != now); // prevent two updates in one block\n', '            assetsToPrices[ofAssets[i]].timestamp = now;\n', '            assetsToPrices[ofAssets[i]].price = newPrices[i];\n', '        }\n', '        emit PriceUpdated(keccak256(ofAssets, newPrices));\n', '    }\n', '}\n', '\n', 'contract StakingPriceFeed is SimplePriceFeed {\n', '\n', '    OperatorStaking public stakingContract;\n', '    AssetInterface public stakingToken;\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @param ofQuoteAsset Address of quote asset\n', '    /// @param ofRegistrar Address of canonical registrar\n', '    /// @param ofSuperFeed Address of superfeed\n', '    function StakingPriceFeed(\n', '        address ofRegistrar,\n', '        address ofQuoteAsset,\n', '        address ofSuperFeed\n', '    )\n', '        SimplePriceFeed(ofRegistrar, ofQuoteAsset, ofSuperFeed)\n', '    {\n', '        stakingContract = OperatorStaking(ofSuperFeed); // canonical feed *is* staking contract\n', '        stakingToken = AssetInterface(stakingContract.stakingToken());\n', '    }\n', '\n', '    // EXTERNAL METHODS\n', '\n', '    /// @param amount Number of tokens to stake for this feed\n', '    /// @param data Data may be needed for some future applications (can be empty for now)\n', '    function depositStake(uint amount, bytes data)\n', '        external\n', '        auth\n', '    {\n', '        require(stakingToken.transferFrom(msg.sender, address(this), amount));\n', '        require(stakingToken.approve(stakingContract, amount));\n', '        stakingContract.stake(amount, data);\n', '    }\n', '\n', '    /// @param amount Number of tokens to unstake for this feed\n', '    /// @param data Data may be needed for some future applications (can be empty for now)\n', '    function unstake(uint amount, bytes data) {\n', '        stakingContract.unstake(amount, data);\n', '    }\n', '\n', '    function withdrawStake()\n', '        external\n', '        auth\n', '    {\n', '        uint amountToWithdraw = stakingContract.stakeToWithdraw(address(this));\n', '        stakingContract.withdrawStake();\n', '        require(stakingToken.transfer(msg.sender, amountToWithdraw));\n', '    }\n', '}\n', '\n', 'interface RiskMgmtInterface {\n', '\n', '    // METHODS\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @notice Checks if the makeOrder price is reasonable and not manipulative\n', '    /// @param orderPrice Price of Order\n', '    /// @param referencePrice Reference price obtained through PriceFeed contract\n', '    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\n', '    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\n', '    /// @param sellQuantity Quantity of sellAsset to be sold\n', '    /// @param buyQuantity Quantity of buyAsset to be bought\n', '    /// @return If makeOrder is permitted\n', '    function isMakePermitted(\n', '        uint orderPrice,\n', '        uint referencePrice,\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    ) view returns (bool);\n', '\n', '    /// @notice Checks if the takeOrder price is reasonable and not manipulative\n', '    /// @param orderPrice Price of Order\n', '    /// @param referencePrice Reference price obtained through PriceFeed contract\n', '    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\n', '    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\n', '    /// @param sellQuantity Quantity of sellAsset to be sold\n', '    /// @param buyQuantity Quantity of buyAsset to be bought\n', '    /// @return If takeOrder is permitted\n', '    function isTakePermitted(\n', '        uint orderPrice,\n', '        uint referencePrice,\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    ) view returns (bool);\n', '}\n', '\n', 'contract OperatorStaking is DBC {\n', '\n', '    // EVENTS\n', '\n', '    event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\n', '    event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\n', '    event StakeBurned(address indexed user, uint256 amount, bytes data);\n', '\n', '    // TYPES\n', '\n', '    struct StakeData {\n', '        uint amount;\n', '        address staker;\n', '    }\n', '\n', '    // Circular linked list\n', '    struct Node {\n', '        StakeData data;\n', '        uint prev;\n', '        uint next;\n', '    }\n', '\n', '    // FIELDS\n', '\n', '    // INTERNAL FIELDS\n', '    Node[] internal stakeNodes; // Sorted circular linked list nodes containing stake data (Built on top https://programtheblockchain.com/posts/2018/03/30/storage-patterns-doubly-linked-list/)\n', '\n', '    // PUBLIC FIELDS\n', '    uint public minimumStake;\n', '    uint public numOperators;\n', '    uint public withdrawalDelay;\n', '    mapping (address => bool) public isRanked;\n', '    mapping (address => uint) public latestUnstakeTime;\n', '    mapping (address => uint) public stakeToWithdraw;\n', '    mapping (address => uint) public stakedAmounts;\n', '    uint public numStakers; // Current number of stakers (Needed because of array holes)\n', '    AssetInterface public stakingToken;\n', '\n', '    // TODO: consider renaming "operator" depending on how this is implemented\n', '    //  (i.e. is pricefeed staking itself?)\n', '    function OperatorStaking(\n', '        AssetInterface _stakingToken,\n', '        uint _minimumStake,\n', '        uint _numOperators,\n', '        uint _withdrawalDelay\n', '    )\n', '        public\n', '    {\n', '        require(address(_stakingToken) != address(0));\n', '        stakingToken = _stakingToken;\n', '        minimumStake = _minimumStake;\n', '        numOperators = _numOperators;\n', '        withdrawalDelay = _withdrawalDelay;\n', '        StakeData memory temp = StakeData({ amount: 0, staker: address(0) });\n', '        stakeNodes.push(Node(temp, 0, 0));\n', '    }\n', '\n', '    // METHODS : STAKING\n', '\n', '    function stake(\n', '        uint amount,\n', '        bytes data\n', '    )\n', '        public\n', '        pre_cond(amount >= minimumStake)\n', '    {\n', '        uint tailNodeId = stakeNodes[0].prev;\n', '        stakedAmounts[msg.sender] += amount;\n', '        updateStakerRanking(msg.sender);\n', '        require(stakingToken.transferFrom(msg.sender, address(this), amount));\n', '    }\n', '\n', '    function unstake(\n', '        uint amount,\n', '        bytes data\n', '    )\n', '        public\n', '    {\n', '        uint preStake = stakedAmounts[msg.sender];\n', '        uint postStake = preStake - amount;\n', '        require(postStake >= minimumStake || postStake == 0);\n', '        require(stakedAmounts[msg.sender] >= amount);\n', '        latestUnstakeTime[msg.sender] = block.timestamp;\n', '        stakedAmounts[msg.sender] -= amount;\n', '        stakeToWithdraw[msg.sender] += amount;\n', '        updateStakerRanking(msg.sender);\n', '        emit Unstaked(msg.sender, amount, stakedAmounts[msg.sender], data);\n', '    }\n', '\n', '    function withdrawStake()\n', '        public\n', '        pre_cond(stakeToWithdraw[msg.sender] > 0)\n', '        pre_cond(block.timestamp >= latestUnstakeTime[msg.sender] + withdrawalDelay)\n', '    {\n', '        uint amount = stakeToWithdraw[msg.sender];\n', '        stakeToWithdraw[msg.sender] = 0;\n', '        require(stakingToken.transfer(msg.sender, amount));\n', '    }\n', '\n', '    // VIEW FUNCTIONS\n', '\n', '    function isValidNode(uint id) view returns (bool) {\n', '        // 0 is a sentinel and therefore invalid.\n', '        // A valid node is the head or has a previous node.\n', '        return id != 0 && (id == stakeNodes[0].next || stakeNodes[id].prev != 0);\n', '    }\n', '\n', '    function searchNode(address staker) view returns (uint) {\n', '        uint current = stakeNodes[0].next;\n', '        while (isValidNode(current)) {\n', '            if (staker == stakeNodes[current].data.staker) {\n', '                return current;\n', '            }\n', '            current = stakeNodes[current].next;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function isOperator(address user) view returns (bool) {\n', '        address[] memory operators = getOperators();\n', '        for (uint i; i < operators.length; i++) {\n', '            if (operators[i] == user) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function getOperators()\n', '        view\n', '        returns (address[])\n', '    {\n', '        uint arrLength = (numOperators > numStakers) ?\n', '            numStakers :\n', '            numOperators;\n', '        address[] memory operators = new address[](arrLength);\n', '        uint current = stakeNodes[0].next;\n', '        for (uint i; i < arrLength; i++) {\n', '            operators[i] = stakeNodes[current].data.staker;\n', '            current = stakeNodes[current].next;\n', '        }\n', '        return operators;\n', '    }\n', '\n', '    function getStakersAndAmounts()\n', '        view\n', '        returns (address[], uint[])\n', '    {\n', '        address[] memory stakers = new address[](numStakers);\n', '        uint[] memory amounts = new uint[](numStakers);\n', '        uint current = stakeNodes[0].next;\n', '        for (uint i; i < numStakers; i++) {\n', '            stakers[i] = stakeNodes[current].data.staker;\n', '            amounts[i] = stakeNodes[current].data.amount;\n', '            current = stakeNodes[current].next;\n', '        }\n', '        return (stakers, amounts);\n', '    }\n', '\n', '    function totalStakedFor(address user)\n', '        view\n', '        returns (uint)\n', '    {\n', '        return stakedAmounts[user];\n', '    }\n', '\n', '    // INTERNAL METHODS\n', '\n', '    // DOUBLY-LINKED LIST\n', '\n', '    function insertNodeSorted(uint amount, address staker) internal returns (uint) {\n', '        uint current = stakeNodes[0].next;\n', '        if (current == 0) return insertNodeAfter(0, amount, staker);\n', '        while (isValidNode(current)) {\n', '            if (amount > stakeNodes[current].data.amount) {\n', '                break;\n', '            }\n', '            current = stakeNodes[current].next;\n', '        }\n', '        return insertNodeBefore(current, amount, staker);\n', '    }\n', '\n', '    function insertNodeAfter(uint id, uint amount, address staker) internal returns (uint newID) {\n', '\n', '        // 0 is allowed here to insert at the beginning.\n', '        require(id == 0 || isValidNode(id));\n', '\n', '        Node storage node = stakeNodes[id];\n', '\n', '        stakeNodes.push(Node({\n', '            data: StakeData(amount, staker),\n', '            prev: id,\n', '            next: node.next\n', '        }));\n', '\n', '        newID = stakeNodes.length - 1;\n', '\n', '        stakeNodes[node.next].prev = newID;\n', '        node.next = newID;\n', '        numStakers++;\n', '    }\n', '\n', '    function insertNodeBefore(uint id, uint amount, address staker) internal returns (uint) {\n', '        return insertNodeAfter(stakeNodes[id].prev, amount, staker);\n', '    }\n', '\n', '    function removeNode(uint id) internal {\n', '        require(isValidNode(id));\n', '\n', '        Node storage node = stakeNodes[id];\n', '\n', '        stakeNodes[node.next].prev = node.prev;\n', '        stakeNodes[node.prev].next = node.next;\n', '\n', '        delete stakeNodes[id];\n', '        numStakers--;\n', '    }\n', '\n', '    // UPDATING OPERATORS\n', '\n', '    function updateStakerRanking(address _staker) internal {\n', '        uint newStakedAmount = stakedAmounts[_staker];\n', '        if (newStakedAmount == 0) {\n', '            isRanked[_staker] = false;\n', '            removeStakerFromArray(_staker);\n', '        } else if (isRanked[_staker]) {\n', '            removeStakerFromArray(_staker);\n', '            insertNodeSorted(newStakedAmount, _staker);\n', '        } else {\n', '            isRanked[_staker] = true;\n', '            insertNodeSorted(newStakedAmount, _staker);\n', '        }\n', '    }\n', '\n', '    function removeStakerFromArray(address _staker) internal {\n', '        uint id = searchNode(_staker);\n', '        require(id > 0);\n', '        removeNode(id);\n', '    }\n', '\n', '}\n', '\n', 'contract CanonicalPriceFeed is OperatorStaking, SimplePriceFeed, CanonicalRegistrar {\n', '\n', '    // EVENTS\n', '    event SetupPriceFeed(address ofPriceFeed);\n', '\n', '    struct HistoricalPrices {\n', '        address[] assets;\n', '        uint[] prices;\n', '        uint timestamp;\n', '    }\n', '\n', '    // FIELDS\n', '    bool public updatesAreAllowed = true;\n', '    uint public minimumPriceCount = 1;\n', '    uint public VALIDITY;\n', '    uint public INTERVAL;\n', '    mapping (address => bool) public isStakingFeed; // If the Staking Feed has been created through this contract\n', '    HistoricalPrices[] public priceHistory;\n', '\n', '    // METHODS\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @dev Define and register a quote asset against which all prices are measured/based against\n', '    /// @param ofStakingAsset Address of staking asset (may or may not be quoteAsset)\n', '    /// @param ofQuoteAsset Address of quote asset\n', '    /// @param quoteAssetName Name of quote asset\n', '    /// @param quoteAssetSymbol Symbol for quote asset\n', '    /// @param quoteAssetDecimals Decimal places for quote asset\n', '    /// @param quoteAssetUrl URL related to quote asset\n', '    /// @param quoteAssetIpfsHash IPFS hash associated with quote asset\n', '    /// @param quoteAssetBreakInBreakOut Break-in/break-out for quote asset on destination chain\n', '    /// @param quoteAssetStandards EIP standards quote asset adheres to\n', '    /// @param quoteAssetFunctionSignatures Whitelisted functions of quote asset contract\n', '    // /// @param interval Number of seconds between pricefeed updates (this interval is not enforced on-chain, but should be followed by the datafeed maintainer)\n', '    // /// @param validity Number of seconds that datafeed update information is valid for\n', '    /// @param ofGovernance Address of contract governing the Canonical PriceFeed\n', '    function CanonicalPriceFeed(\n', '        address ofStakingAsset,\n', '        address ofQuoteAsset, // Inital entry in asset registrar contract is Melon (QUOTE_ASSET)\n', '        bytes32 quoteAssetName,\n', '        bytes8 quoteAssetSymbol,\n', '        uint quoteAssetDecimals,\n', '        string quoteAssetUrl,\n', '        string quoteAssetIpfsHash,\n', '        address[2] quoteAssetBreakInBreakOut,\n', '        uint[] quoteAssetStandards,\n', '        bytes4[] quoteAssetFunctionSignatures,\n', '        uint[2] updateInfo, // interval, validity\n', '        uint[3] stakingInfo, // minStake, numOperators, unstakeDelay\n', '        address ofGovernance\n', '    )\n', '        OperatorStaking(\n', '            AssetInterface(ofStakingAsset), stakingInfo[0], stakingInfo[1], stakingInfo[2]\n', '        )\n', '        SimplePriceFeed(address(this), ofQuoteAsset, address(0))\n', '    {\n', '        registerAsset(\n', '            ofQuoteAsset,\n', '            quoteAssetName,\n', '            quoteAssetSymbol,\n', '            quoteAssetDecimals,\n', '            quoteAssetUrl,\n', '            quoteAssetIpfsHash,\n', '            quoteAssetBreakInBreakOut,\n', '            quoteAssetStandards,\n', '            quoteAssetFunctionSignatures\n', '        );\n', '        INTERVAL = updateInfo[0];\n', '        VALIDITY = updateInfo[1];\n', '        setOwner(ofGovernance);\n', '    }\n', '\n', '    // EXTERNAL METHODS\n', '\n', '    /// @notice Create a new StakingPriceFeed\n', '    function setupStakingPriceFeed() external {\n', '        address ofStakingPriceFeed = new StakingPriceFeed(\n', '            address(this),\n', '            stakingToken,\n', '            address(this)\n', '        );\n', '        isStakingFeed[ofStakingPriceFeed] = true;\n', '        StakingPriceFeed(ofStakingPriceFeed).setOwner(msg.sender);\n', '        emit SetupPriceFeed(ofStakingPriceFeed);\n', '    }\n', '\n', '    /// @dev override inherited update function to prevent manual update from authority\n', '    function update() external { revert(); }\n', '\n', '    /// @dev Burn state for a pricefeed operator\n', '    /// @param user Address of pricefeed operator to burn the stake from\n', '    function burnStake(address user)\n', '        external\n', '        auth\n', '    {\n', '        uint totalToBurn = add(stakedAmounts[user], stakeToWithdraw[user]);\n', '        stakedAmounts[user] = 0;\n', '        stakeToWithdraw[user] = 0;\n', '        updateStakerRanking(user);\n', '        emit StakeBurned(user, totalToBurn, "");\n', '    }\n', '\n', '    // PUBLIC METHODS\n', '\n', '    // STAKING\n', '\n', '    function stake(\n', '        uint amount,\n', '        bytes data\n', '    )\n', '        public\n', '        pre_cond(isStakingFeed[msg.sender])\n', '    {\n', '        OperatorStaking.stake(amount, data);\n', '    }\n', '\n', '    // function stakeFor(\n', '    //     address user,\n', '    //     uint amount,\n', '    //     bytes data\n', '    // )\n', '    //     public\n', '    //     pre_cond(isStakingFeed[user])\n', '    // {\n', '\n', '    //     OperatorStaking.stakeFor(user, amount, data);\n', '    // }\n', '\n', '    // AGGREGATION\n', '\n', '    /// @dev Only Owner; Same sized input arrays\n', '    /// @dev Updates price of asset relative to QUOTE_ASSET\n', '    /** Ex:\n', '     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\n', '     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\n', '     *  and let EUR-T decimals == 8.\n', '     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\n', '     */\n', '    /// @param ofAssets list of asset addresses\n', '    function collectAndUpdate(address[] ofAssets)\n', '        public\n', '        auth\n', '        pre_cond(updatesAreAllowed)\n', '    {\n', '        uint[] memory newPrices = pricesToCommit(ofAssets);\n', '        priceHistory.push(\n', '            HistoricalPrices({assets: ofAssets, prices: newPrices, timestamp: block.timestamp})\n', '        );\n', '        _updatePrices(ofAssets, newPrices);\n', '    }\n', '\n', '    function pricesToCommit(address[] ofAssets)\n', '        view\n', '        returns (uint[])\n', '    {\n', '        address[] memory operators = getOperators();\n', '        uint[] memory newPrices = new uint[](ofAssets.length);\n', '        for (uint i = 0; i < ofAssets.length; i++) {\n', '            uint[] memory assetPrices = new uint[](operators.length);\n', '            for (uint j = 0; j < operators.length; j++) {\n', '                SimplePriceFeed feed = SimplePriceFeed(operators[j]);\n', '                var (price, timestamp) = feed.assetsToPrices(ofAssets[i]);\n', '                if (now > add(timestamp, VALIDITY)) {\n', '                    continue; // leaves a zero in the array (dealt with later)\n', '                }\n', '                assetPrices[j] = price;\n', '            }\n', '            newPrices[i] = medianize(assetPrices);\n', '        }\n', '        return newPrices;\n', '    }\n', '\n', '    /// @dev from MakerDao medianizer contract\n', '    function medianize(uint[] unsorted)\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint numValidEntries;\n', '        for (uint i = 0; i < unsorted.length; i++) {\n', '            if (unsorted[i] != 0) {\n', '                numValidEntries++;\n', '            }\n', '        }\n', '        if (numValidEntries < minimumPriceCount) {\n', '            revert();\n', '        }\n', '        uint counter;\n', '        uint[] memory out = new uint[](numValidEntries);\n', '        for (uint j = 0; j < unsorted.length; j++) {\n', '            uint item = unsorted[j];\n', '            if (item != 0) {    // skip zero (invalid) entries\n', '                if (counter == 0 || item >= out[counter - 1]) {\n', '                    out[counter] = item;  // item is larger than last in array (we are home)\n', '                } else {\n', '                    uint k = 0;\n', '                    while (item >= out[k]) {\n', '                        k++;  // get to where element belongs (between smaller and larger items)\n', '                    }\n', '                    for (uint l = counter; l > k; l--) {\n', '                        out[l] = out[l - 1];    // bump larger elements rightward to leave slot\n', '                    }\n', '                    out[k] = item;\n', '                }\n', '                counter++;\n', '            }\n', '        }\n', '\n', '        uint value;\n', '        if (counter % 2 == 0) {\n', '            uint value1 = uint(out[(counter / 2) - 1]);\n', '            uint value2 = uint(out[(counter / 2)]);\n', '            value = add(value1, value2) / 2;\n', '        } else {\n', '            value = out[(counter - 1) / 2];\n', '        }\n', '        return value;\n', '    }\n', '\n', '    function setMinimumPriceCount(uint newCount) auth { minimumPriceCount = newCount; }\n', '    function enableUpdates() auth { updatesAreAllowed = true; }\n', '    function disableUpdates() auth { updatesAreAllowed = false; }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    // FEED INFORMATION\n', '\n', '    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\n', '    function getInterval() view returns (uint) { return INTERVAL; }\n', '    function getValidity() view returns (uint) { return VALIDITY; }\n', '    function getLastUpdateId() view returns (uint) { return updateId; }\n', '\n', '    // PRICES\n', '\n', '    /// @notice Whether price of asset has been updated less than VALIDITY seconds ago\n', '    /// @param ofAsset Asset in registrar\n', '    /// @return isRecent Price information ofAsset is recent\n', '    function hasRecentPrice(address ofAsset)\n', '        view\n', '        pre_cond(assetIsRegistered(ofAsset))\n', '        returns (bool isRecent)\n', '    {\n', '        var ( , timestamp) = getPrice(ofAsset);\n', '        return (sub(now, timestamp) <= VALIDITY);\n', '    }\n', '\n', '    /// @notice Whether prices of assets have been updated less than VALIDITY seconds ago\n', '    /// @param ofAssets All assets in registrar\n', '    /// @return isRecent Price information ofAssets array is recent\n', '    function hasRecentPrices(address[] ofAssets)\n', '        view\n', '        returns (bool areRecent)\n', '    {\n', '        for (uint i; i < ofAssets.length; i++) {\n', '            if (!hasRecentPrice(ofAssets[i])) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function getPriceInfo(address ofAsset)\n', '        view\n', '        returns (bool isRecent, uint price, uint assetDecimals)\n', '    {\n', '        isRecent = hasRecentPrice(ofAsset);\n', '        (price, ) = getPrice(ofAsset);\n', '        assetDecimals = getDecimals(ofAsset);\n', '    }\n', '\n', '    /**\n', '    @notice Gets inverted price of an asset\n', '    @dev Asset has been initialised and its price is non-zero\n', '    @dev Existing price ofAssets quoted in QUOTE_ASSET (convention)\n', '    @param ofAsset Asset for which inverted price should be return\n', '    @return {\n', '        "isRecent": "Whether the price is fresh, given VALIDITY interval",\n', '        "invertedPrice": "Price based (instead of quoted) against QUOTE_ASSET",\n', '        "assetDecimals": "Decimal places for this asset"\n', '    }\n', '    */\n', '    function getInvertedPriceInfo(address ofAsset)\n', '        view\n', '        returns (bool isRecent, uint invertedPrice, uint assetDecimals)\n', '    {\n', '        uint inputPrice;\n', '        // inputPrice quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\n', '        (isRecent, inputPrice, assetDecimals) = getPriceInfo(ofAsset);\n', '\n', '        // outputPrice based in QUOTE_ASSET and multiplied by 10 ** quoteDecimal\n', '        uint quoteDecimals = getDecimals(QUOTE_ASSET);\n', '\n', '        return (\n', '            isRecent,\n', '            mul(10 ** uint(quoteDecimals), 10 ** uint(assetDecimals)) / inputPrice,\n', '            quoteDecimals   // TODO: check on this; shouldn&#39;t it be assetDecimals?\n', '        );\n', '    }\n', '\n', '    /**\n', '    @notice Gets reference price of an asset pair\n', '    @dev One of the address is equal to quote asset\n', '    @dev either ofBase == QUOTE_ASSET or ofQuote == QUOTE_ASSET\n', '    @param ofBase Address of base asset\n', '    @param ofQuote Address of quote asset\n', '    @return {\n', '        "isRecent": "Whether the price is fresh, given VALIDITY interval",\n', '        "referencePrice": "Reference price",\n', '        "decimal": "Decimal places for this asset"\n', '    }\n', '    */\n', '    function getReferencePriceInfo(address ofBase, address ofQuote)\n', '        view\n', '        returns (bool isRecent, uint referencePrice, uint decimal)\n', '    {\n', '        if (getQuoteAsset() == ofQuote) {\n', '            (isRecent, referencePrice, decimal) = getPriceInfo(ofBase);\n', '        } else if (getQuoteAsset() == ofBase) {\n', '            (isRecent, referencePrice, decimal) = getInvertedPriceInfo(ofQuote);\n', '        } else {\n', '            revert(); // no suitable reference price available\n', '        }\n', '    }\n', '\n', '    /// @notice Gets price of Order\n', '    /// @param sellAsset Address of the asset to be sold\n', '    /// @param buyAsset Address of the asset to be bought\n', '    /// @param sellQuantity Quantity in base units being sold of sellAsset\n', '    /// @param buyQuantity Quantity in base units being bought of buyAsset\n', '    /// @return orderPrice Price as determined by an order\n', '    function getOrderPriceInfo(\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    )\n', '        view\n', '        returns (uint orderPrice)\n', '    {\n', '        return mul(buyQuantity, 10 ** uint(getDecimals(sellAsset))) / sellQuantity;\n', '    }\n', '\n', '    /// @notice Checks whether data exists for a given asset pair\n', '    /// @dev Prices are only upated against QUOTE_ASSET\n', '    /// @param sellAsset Asset for which check to be done if data exists\n', '    /// @param buyAsset Asset for which check to be done if data exists\n', '    /// @return Whether assets exist for given asset pair\n', '    function existsPriceOnAssetPair(address sellAsset, address buyAsset)\n', '        view\n', '        returns (bool isExistent)\n', '    {\n', '        return\n', '            hasRecentPrice(sellAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\n', '            hasRecentPrice(buyAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\n', '            (buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET) && // One asset must be QUOTE_ASSET\n', '            (buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET); // Pair must consists of diffrent assets\n', '    }\n', '\n', '    /// @return Sparse array of addresses of owned pricefeeds\n', '    function getPriceFeedsByOwner(address _owner)\n', '        view\n', '        returns(address[])\n', '    {\n', '        address[] memory ofPriceFeeds = new address[](numStakers);\n', '        if (numStakers == 0) return ofPriceFeeds;\n', '        uint current = stakeNodes[0].next;\n', '        for (uint i; i < numStakers; i++) {\n', '            StakingPriceFeed stakingFeed = StakingPriceFeed(stakeNodes[current].data.staker);\n', '            if (stakingFeed.owner() == _owner) {\n', '                ofPriceFeeds[i] = address(stakingFeed);\n', '            }\n', '            current = stakeNodes[current].next;\n', '        }\n', '        return ofPriceFeeds;\n', '    }\n', '\n', '    function getHistoryLength() returns (uint) { return priceHistory.length; }\n', '\n', '    function getHistoryAt(uint id) returns (address[], uint[], uint) {\n', '        address[] memory assets = priceHistory[id].assets;\n', '        uint[] memory prices = priceHistory[id].prices;\n', '        uint timestamp = priceHistory[id].timestamp;\n', '        return (assets, prices, timestamp);\n', '    }\n', '}\n', '\n', 'interface VersionInterface {\n', '\n', '    // EVENTS\n', '\n', '    event FundUpdated(uint id);\n', '\n', '    // PUBLIC METHODS\n', '\n', '    function shutDown() external;\n', '\n', '    function setupFund(\n', '        bytes32 ofFundName,\n', '        address ofQuoteAsset,\n', '        uint ofManagementFee,\n', '        uint ofPerformanceFee,\n', '        address ofCompliance,\n', '        address ofRiskMgmt,\n', '        address[] ofExchanges,\n', '        address[] ofDefaultAssets,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    );\n', '    function shutDownFund(address ofFund);\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    function getNativeAsset() view returns (address);\n', '    function getFundById(uint withId) view returns (address);\n', '    function getLastFundId() view returns (uint);\n', '    function getFundByManager(address ofManager) view returns (address);\n', '    function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed);\n', '\n', '}\n', '\n', 'contract Version is DBC, Owned, VersionInterface {\n', '    // FIELDS\n', '\n', '    bytes32 public constant TERMS_AND_CONDITIONS = 0xAA9C907B0D6B4890E7225C09CBC16A01CB97288840201AA7CDCB27F4ED7BF159; // Hashed terms and conditions as displayed on IPFS, decoded from base 58\n', '\n', '    // Constructor fields\n', '    string public VERSION_NUMBER; // SemVer of Melon protocol version\n', '    address public MELON_ASSET; // Address of Melon asset contract\n', '    address public NATIVE_ASSET; // Address of Fixed quote asset\n', '    address public GOVERNANCE; // Address of Melon protocol governance contract\n', '    address public CANONICAL_PRICEFEED; // Address of the canonical pricefeed\n', '\n', '    // Methods fields\n', '    bool public isShutDown; // Governance feature, if yes than setupFund gets blocked and shutDownFund gets opened\n', '    address public COMPLIANCE; // restrict to Competition compliance module for this version\n', '    address[] public listOfFunds; // A complete list of fund addresses created using this version\n', '    mapping (address => address) public managerToFunds; // Links manager address to fund address created using this version\n', '\n', '    // EVENTS\n', '\n', '    event FundUpdated(address ofFund);\n', '\n', '    // METHODS\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @param versionNumber SemVer of Melon protocol version\n', '    /// @param ofGovernance Address of Melon governance contract\n', '    /// @param ofMelonAsset Address of Melon asset contract\n', '    function Version(\n', '        string versionNumber,\n', '        address ofGovernance,\n', '        address ofMelonAsset,\n', '        address ofNativeAsset,\n', '        address ofCanonicalPriceFeed,\n', '        address ofCompetitionCompliance\n', '    ) {\n', '        VERSION_NUMBER = versionNumber;\n', '        GOVERNANCE = ofGovernance;\n', '        MELON_ASSET = ofMelonAsset;\n', '        NATIVE_ASSET = ofNativeAsset;\n', '        CANONICAL_PRICEFEED = ofCanonicalPriceFeed;\n', '        COMPLIANCE = ofCompetitionCompliance;\n', '    }\n', '\n', '    // EXTERNAL METHODS\n', '\n', '    function shutDown() external pre_cond(msg.sender == GOVERNANCE) { isShutDown = true; }\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /// @param ofFundName human-readable descriptive name (not necessarily unique)\n', '    /// @param ofQuoteAsset Asset against which performance fee is measured against\n', '    /// @param ofManagementFee A time based fee, given in a number which is divided by 10 ** 15\n', '    /// @param ofPerformanceFee A time performance based fee, performance relative to ofQuoteAsset, given in a number which is divided by 10 ** 15\n', '    /// @param ofCompliance Address of participation module\n', '    /// @param ofRiskMgmt Address of risk management module\n', '    /// @param ofExchanges Addresses of exchange on which this fund can trade\n', '    /// @param ofDefaultAssets Enable invest/redeem with these assets (quote asset already enabled)\n', '    /// @param v ellipitc curve parameter v\n', '    /// @param r ellipitc curve parameter r\n', '    /// @param s ellipitc curve parameter s\n', '    function setupFund(\n', '        bytes32 ofFundName,\n', '        address ofQuoteAsset,\n', '        uint ofManagementFee,\n', '        uint ofPerformanceFee,\n', '        address ofCompliance,\n', '        address ofRiskMgmt,\n', '        address[] ofExchanges,\n', '        address[] ofDefaultAssets,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) {\n', '        require(!isShutDown);\n', '        require(termsAndConditionsAreSigned(v, r, s));\n', '        require(CompetitionCompliance(COMPLIANCE).isCompetitionAllowed(msg.sender));\n', '        require(managerToFunds[msg.sender] == address(0)); // Add limitation for simpler migration process of shutting down and setting up fund\n', '        address[] memory melonAsDefaultAsset = new address[](1);\n', '        melonAsDefaultAsset[0] = MELON_ASSET; // Melon asset should be in default assets\n', '        address ofFund = new Fund(\n', '            msg.sender,\n', '            ofFundName,\n', '            NATIVE_ASSET,\n', '            0,\n', '            0,\n', '            COMPLIANCE,\n', '            ofRiskMgmt,\n', '            CANONICAL_PRICEFEED,\n', '            ofExchanges,\n', '            melonAsDefaultAsset\n', '        );\n', '        listOfFunds.push(ofFund);\n', '        managerToFunds[msg.sender] = ofFund;\n', '        emit FundUpdated(ofFund);\n', '    }\n', '\n', '    /// @dev Dereference Fund and shut it down\n', '    /// @param ofFund Address of the fund to be shut down\n', '    function shutDownFund(address ofFund)\n', '        pre_cond(isShutDown || managerToFunds[msg.sender] == ofFund)\n', '    {\n', '        Fund fund = Fund(ofFund);\n', '        delete managerToFunds[msg.sender];\n', '        fund.shutDown();\n', '        emit FundUpdated(ofFund);\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @dev Proof that terms and conditions have been read and understood\n', '    /// @param v ellipitc curve parameter v\n', '    /// @param r ellipitc curve parameter r\n', '    /// @param s ellipitc curve parameter s\n', '    /// @return signed Whether or not terms and conditions have been read and understood\n', '    function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed) {\n', '        return ecrecover(\n', '            // Parity does prepend \\x19Ethereum Signed Message:\\n{len(message)} before signing.\n', '            //  Signature order has also been changed in 1.6.7 and upcoming 1.7.x,\n', '            //  it will return rsv (same as geth; where v is [27, 28]).\n', '            // Note that if you are using ecrecover, v will be either "00" or "01".\n', '            //  As a result, in order to use this value, you will have to parse it to an\n', '            //  integer and then add 27. This will result in either a 27 or a 28.\n', '            //  https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethsign\n', '            keccak256("\\x19Ethereum Signed Message:\\n32", TERMS_AND_CONDITIONS),\n', '            v,\n', '            r,\n', '            s\n', '        ) == msg.sender; // Has sender signed TERMS_AND_CONDITIONS\n', '    }\n', '\n', '    function getNativeAsset() view returns (address) { return NATIVE_ASSET; }\n', '    function getFundById(uint withId) view returns (address) { return listOfFunds[withId]; }\n', '    function getLastFundId() view returns (uint) { return listOfFunds.length - 1; }\n', '    function getFundByManager(address ofManager) view returns (address) { return managerToFunds[ofManager]; }\n', '}']