['pragma solidity ^0.4.24;\n', '\n', 'contract INTIME {\n', '    using SafeMath for *;\n', '    \n', '    struct Player {\n', '        uint id;\n', '        uint referrer;\n', '        uint generation;\n', '        string name;\n', '        uint256 weight;\n', '        uint256 balance;\n', '        uint256 withdrawal;\n', '        uint256 referralBonus;\n', '        uint256 lastKeyBonus;\n', '        uint256 potBonus;\n', '        uint256 stakingBonus;\n', '        uint256 airdropBonus;\n', '    }\n', '    \n', '    mapping(address => Player) public players;\n', '    \n', '    // System\n', '    address public teamAddress;\n', '    uint256 public teamNamingIncome;\n', '    address public keyAddress;\n', '    address[] participantPool;\n', '    uint256 participantPoolStart;\n', '    uint256 participantPoolEnd;\n', '    address[] public participants;\n', '    uint256 public participantsLength;\n', '    address[] public winner;\n', '    uint256 public deadline;\n', '    uint256 keyPrice_min;\n', '    uint256 keyPrice_max;\n', '    uint256 public keyPrice;\n', '    uint256 public currentGeneration;\n', '    uint256 public currentKeyRound;\n', '    uint256 public duration;\n', '    uint256[] public durationPhaseArray;\n', '    uint256 public durationPhaseIndex;\n', '    uint256 public poolWeight;\n', '    uint256 public poolBalance;\n', '    uint256 public poolReward;\n', '    uint256 public poolWithdraw;\n', '    bool public airdropped;\n', '    bool public keyLocked;\n', '    uint256 public airdropWinTime;\n', '    uint256 public airdropBalance;\n', '    uint256 public airdroppedAmount;\n', '    uint256 public unitStake;\n', '    uint256 public potReserve;\n', '    \n', '    mapping(string => address) addressFromName;\n', '    \n', '    event Withdrawal(\n', '        address indexed _from,\n', '        uint256 _value\n', '    );\n', '    event Deposit(\n', '        address indexed _keyHolder,\n', '        uint256 _weight,\n', '        uint256 _keyPrice,\n', '        uint256 _deadline,\n', '        uint256 _durationPhaseIndex,\n', '        bool _phaseChanged,\n', '        uint256 _poolBalance,\n', '        uint256 _poolReward,\n', '        uint256 _poolWeight,\n', '        // If Airdrop\n', '        bool _airdropped,\n', '        uint256 _airdropBalance,\n', '        // If Trigger Reserve\n', '        bool _potReserveGive,\n', '        uint256 _potReserve\n', '    );\n', '    \n', '    /**\n', '     * @dev prevents contracts from interacting with fomo3d \n', '     */\n', '    modifier isHuman() {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '        \n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0, "sorry humans only");\n', '        _;\n', '    }\n', '    /**\n', '     * Constructor function\n', '     * \n', '     */\n', '    constructor (\n', '        address _teamAddress\n', '    ) public {\n', '        teamAddress = _teamAddress;\n', '        keyPrice_min = 1e14;       // in wei, 0.0001 eth\n', '        keyPrice_max = 15e15;      // in wei, 0.015 eth\n', '        keyPrice = keyPrice_min;   // in wei, 0.0001 eth\n', '        keyAddress = msg.sender;\n', '        durationPhaseArray = [1440, 720, 360, 180, 90, 60, 30];\n', '        durationPhaseIndex = 0;\n', '        duration = durationPhaseArray[durationPhaseIndex];\n', '        currentGeneration = 0;\n', '        resetGame();\n', '    }\n', '    \n', '    function resetGame() private {\n', '        uint256 residualBalance = 0;\n', '        if(currentGeneration != 0) {\n', '            // Distribute tokens\n', '            // Staking distribution => distributed on deposit\n', '            // Pool distribution => 20%\n', '            unitStake = 0;\n', '            // 75% for the winner;\n', '            players[keyAddress].balance += poolBalance / 5 * 75 / 100;\n', '            players[keyAddress].lastKeyBonus += poolBalance / 5 * 75 / 100;\n', '            // 15% for random participant\n', '            if(participantPoolEnd - participantPoolStart > 0) {\n', '                uint randParticipantIndex = rand(participantPoolStart + 1, participantPoolEnd);\n', '                players[participantPool[randParticipantIndex - 1]].balance += poolBalance / 5 * 15 / 100;\n', '                players[participantPool[randParticipantIndex - 1]].lastKeyBonus += poolBalance / 5 * 15 / 100;\n', '            } else {\n', '                players[keyAddress].balance += poolBalance / 5 * 15 / 100;\n', '                players[keyAddress].lastKeyBonus += poolBalance / 5 * 15 / 100;\n', '            }\n', '            // 10% and pot reserve for next round\n', '            residualBalance += poolBalance / 5 * 10 / 100 + potReserve;\n', '            winner.push(keyAddress);\n', '        }\n', '        airdropWinTime = now;\n', '        keyPrice = 1e15;\n', '        poolWeight = 0;\n', '        poolReward = 0;\n', '        potReserve = 0;\n', '        \n', '        // Reset duration and deadline\n', '        durationPhaseIndex = 0;\n', '        duration = durationPhaseArray[durationPhaseIndex];\n', '        deadline = now + duration * 1 minutes;\n', '        \n', '        poolBalance = residualBalance;\n', '        keyLocked = false;\n', '        currentKeyRound = 0;\n', '        currentGeneration ++;\n', '        keyAddress = teamAddress;\n', '        participantPoolStart = participantPool.length;\n', '        participantPoolEnd = participantPool.length;\n', '    }\n', '    \n', '    /**\n', '     * Unique address\n', '     *\n', '     */\n', '    function setName(string name) isHuman() payable public {\n', '        uint256 amount = msg.value;\n', '        require(amount >= 1e15);\n', '        require(addressFromName[name] == address(0));\n', '        players[teamAddress].balance += amount;\n', '        teamNamingIncome += amount;\n', '        players[msg.sender].name = name;\n', '        addressFromName[name] = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Fallback function\n', '     *\n', '     * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '     */\n', '    function referralName (string name) isHuman() payable public {\n', '        if(addressFromName[name] != address(0) && addressFromName[name] != msg.sender && players[msg.sender].referrer == 0)\n', '            players[msg.sender].referrer = players[addressFromName[name]].id;\n', '        uint256 amount = msg.value;\n', '        deposit(amount);\n', '    }\n', '    function referralPay (uint referrer) isHuman() payable public {\n', '        if(referrer > participants.length)\n', '            referrer = 0;\n', '        if(players[msg.sender].id != referrer && players[msg.sender].referrer == 0)\n', '            players[msg.sender].referrer = referrer;\n', '        uint256 amount = msg.value;\n', '        deposit(amount);\n', '    }\n', '    function () isHuman() payable public {\n', '        uint256 amount = msg.value;\n', '        deposit(amount);\n', '    }\n', '    function depositVault (uint keyCount, uint referrer) isHuman() public {\n', '        require(keyLocked == false);\n', '        keyLocked = true;\n', '        // Buy key from current balance\n', '        uint256 amount = keyCount * keyPrice;\n', '        uint256 availableWithdrawal = players[msg.sender].balance - players[msg.sender].withdrawal;\n', '        require(amount <= availableWithdrawal);\n', '        require(amount > 0);\n', '        players[msg.sender].withdrawal += amount;\n', '        \n', '        if(referrer > participants.length)\n', '            referrer = 0;\n', '        if(players[msg.sender].id != referrer && players[msg.sender].referrer == 0)\n', '            players[msg.sender].referrer = referrer;\n', '        keyLocked = false;\n', '        deposit(amount);\n', '    }\n', '    function deposit(uint256 amount) private {\n', '        if(now >= deadline) resetGame();\n', '        require(keyLocked == false);\n', '        keyLocked = true;\n', '        \n', '        // Update pool balance\n', '\t\trequire(amount >= keyPrice, "You have to buy at least one key.");\n', '\t\tpoolBalance += amount;\n', '\t\t\n', '\t\tcurrentKeyRound ++;\n', '\t\tparticipantPool.push(msg.sender);\n', '\t\tparticipantPoolEnd = participantPool.length;\n', '\t\t// Update deadline if not last round\n', '\t\tif(durationPhaseIndex < 6) deadline = now + duration * 1 minutes;\n', '\t\t\n', '\t\t// Update key holder\n', '\t\tkeyAddress = msg.sender;\n', '\t\t\n', '\t\tif(players[msg.sender].generation == 0) {\n', '\t\t    participants.push(msg.sender);\n', '\t\t    participantsLength = participants.length;\n', '\t\t    players[msg.sender].id = participants.length;\n', '\t\t}\n', '\t\tif(players[msg.sender].generation != currentGeneration) {\n', '\t\t\tplayers[msg.sender].generation = currentGeneration;\n', '\t\t\tplayers[msg.sender].weight = 0;\n', '\t\t}\n', '\t\t// Handling stake distribution\n', '\t\tuint256 p_i = 0;\n', '\t\tuint256 deltaStake = 0;\n', '\t\taddress _addr;\n', '\t\t// 58% for staking\n', '\t\tif(poolWeight > 0) {\n', '\t\t    unitStake = amount * 58 / 100 / poolWeight;\n', '\t\t    for(p_i = 0; p_i < participants.length; p_i++) {\n', '\t\t        _addr = participants[p_i];\n', '\t\t        if(players[_addr].generation == currentGeneration) {\n', '\t\t            players[_addr].balance += players[_addr].weight * unitStake;\n', '\t\t            players[_addr].stakingBonus += players[_addr].weight * unitStake;\n', '\t\t        }\n', '\t\t    }\n', '\t\t}\n', '\t\t// 15% for referral\n', '\t\tif(players[msg.sender].referrer > 0) {\n', '\t\t    _addr = participants[players[msg.sender].referrer - 1];\n', '\t\t    players[_addr].balance += amount * 15 / 100;\n', '\t\t    players[_addr].referralBonus += amount * 15 / 100;\n', '\t\t} else {\n', '\t\t    if(poolWeight > 0) {\n', '\t\t        deltaStake = amount * 15 / 100 / poolWeight;\n', '\t\t        for(p_i = 0; p_i < participants.length; p_i++) {\n', '\t\t            _addr = participants[p_i];\n', '\t\t            if(players[_addr].generation == currentGeneration) {\n', '\t\t                players[_addr].balance += players[_addr].weight * deltaStake;\n', '\t\t                players[_addr].stakingBonus += players[_addr].weight * deltaStake;\n', '\t\t            }\n', '\t\t        }\n', '\t\t    } else {\n', '\t\t        players[teamAddress].balance += amount * 15 / 100;\n', '\t\t        players[teamAddress].stakingBonus += amount * 15 / 100;\n', '\t\t    }\n', '\t\t}\n', '\t\t// 4% for team\n', '\t\tunitStake += deltaStake;\n', '\t\tplayers[teamAddress].balance += amount * 4 / 100;\n', '\t\tplayers[teamAddress].stakingBonus += amount * 4 / 100;\n', '\t\t\n', '\t\tpoolReward += amount * 77 / 100;\n', '\t\t\n', '\t\tairdropBalance += amount * 2 / 100;\n', '\t\tairdropped = false;\n', '\t\tairdroppedAmount = 0;\n', '\t\tuint randNum = 0;\n', '\t\tif(amount >= 1e17 && amount < 1e18) {\n', '\t\t    // 0.1 ~ 1 eth, 1% chance\n', '\t\t    randNum = rand(1, 10000);\n', '\t\t    if(randNum <= 10) airdropped = true;\n', '\t\t} else if(amount >= 1e18 && amount < 1e19) {\n', '\t\t    // 1 eth ~ 10 eth, 10% chance\n', '\t\t    randNum = rand(1, 10000);\n', '\t\t    if(randNum <= 100) airdropped = true;\n', '\t\t} else if(amount >= 1e19) {\n', '\t\t    // greater than 1 eth, 5% chance\n', '\t\t    randNum = rand(1, 10000);\n', '\t\t    if(randNum <= 500) airdropped = true;\n', '\t\t}\n', '\t\tbool _phaseChanged = false;\n', '\t\tif(airdropped) {\n', '\t\t    \n', '\t\t    airdropWinTime = now;\n', '\t\t    players[msg.sender].balance += airdropBalance;\n', '            players[msg.sender].airdropBonus += airdropBalance;\n', '            poolReward += airdropBalance;\n', '            \n', '            airdroppedAmount = airdropBalance;\n', '            airdropBalance = 0;\n', '            if(durationPhaseIndex == 0 && airdropBalance >= 1e18) _phaseChanged = true;\n', '            else if(durationPhaseIndex == 1 && airdropBalance >= 2e18) _phaseChanged = true;\n', '            else if(durationPhaseIndex == 2 && airdropBalance >= 3e18) _phaseChanged = true;\n', '            else if(durationPhaseIndex == 3 && airdropBalance >= 5e18) _phaseChanged = true;\n', '            else if(durationPhaseIndex == 4 && airdropBalance >= 7e18) _phaseChanged = true;\n', '            else if(durationPhaseIndex == 5 && airdropBalance >= 1e19) _phaseChanged = true;\n', '            if(_phaseChanged) {\n', '                durationPhaseIndex ++;\n', '                duration = durationPhaseArray[durationPhaseIndex];\n', '                deadline = now + duration * 1 minutes;\n', '            }\n', '            \n', '\t\t}\n', '\t\t\n', '\t\t// Staking weight calculation\n', '\t\tuint256 weight = amount.mul(1e7).div(keyPrice);\n', '\t\tplayers[msg.sender].weight += weight;\n', '\t\tuint256 originalPoolSegment = poolWeight / ((5e5).mul(1e7));\n', '\t\tpoolWeight += weight;\n', '\t\tuint256 afterPoolSegment = poolWeight / ((5e5).mul(1e7));\n', '\t\t\n', '\t\t// Different Segment => giveout potReserve, every 1e5 keys\n', '\t\tpotReserve += amount * 1 / 100;\n', '\t\tbool _potReserveGive = false;\n', '\t\tuint256 _potReserve = potReserve;\n', '\t\tif(originalPoolSegment != afterPoolSegment) {\n', '\t\t    _potReserveGive = true;\n', '\t\t    players[msg.sender].balance += potReserve;\n', '\t\t    players[msg.sender].potBonus += potReserve;\n', '\t\t    poolReward += potReserve;\n', '\t\t    potReserve = 0;\n', '\t\t}\n', '\t\t\n', '\t\t// Grow key price\n', '\t\tif(keyPrice < keyPrice_max) {\n', '\t\t    keyPrice = keyPrice_max - (1e23 - poolBalance).mul(keyPrice_max - keyPrice_min).div(1e23);\n', '\t\t} else {\n', '\t\t    keyPrice = keyPrice_max;\n', '\t\t}\n', '\t\tkeyLocked = false;\n', '\t\temit Deposit(\n', '\t\t    msg.sender,\n', '\t\t    weight,\n', '\t\t    keyPrice,\n', '\t\t    deadline,\n', '\t\t    durationPhaseIndex,\n', '\t\t    _phaseChanged,\n', '\t\t    poolBalance,\n', '\t\t    poolReward,\n', '\t\t    poolWeight,\n', '\t\t    airdropped,\n', '\t\t    airdropBalance,\n', '\t\t    _potReserveGive,\n', '\t\t    _potReserve\n', '        );\n', '    }\n', '    uint256 nonce = 0;\n', '    function rand(uint min, uint max) private returns (uint){\n', '        nonce++;\n', '        return uint(keccak256(toBytes(nonce)))%(min+max)-min;\n', '    }\n', '    function toBytes(uint256 x) private pure returns (bytes b) {\n', '        b = new bytes(32);\n', '        assembly { mstore(add(b, 32), x) }\n', '    }\n', '    /**\n', '     * Withdraw the funds\n', '     */\n', '    function safeWithdrawal() isHuman() public {\n', '        uint256 availableWithdrawal = players[msg.sender].balance - players[msg.sender].withdrawal;\n', '        require(availableWithdrawal > 0);\n', '        require(keyLocked == false);\n', '        keyLocked = true;\n', '        poolWithdraw += availableWithdrawal;\n', '        players[msg.sender].withdrawal += availableWithdrawal;\n', '        msg.sender.transfer(availableWithdrawal);\n', '        keyLocked = false;\n', '        emit Withdrawal(msg.sender, availableWithdrawal);\n', '    }\n', '    function helpWithdrawal(address userAddress) isHuman() public {\n', '        // Will only be executed when user himself cannot withdraw and asks our team for help\n', '        require(msg.sender == teamAddress);\n', '        uint256 availableWithdrawal = players[userAddress].balance - players[userAddress].withdrawal;\n', '        require(availableWithdrawal > 0);\n', '        require(keyLocked == false);\n', '        keyLocked = true;\n', '        poolWithdraw += availableWithdrawal;\n', '        players[userAddress].withdrawal += availableWithdrawal;\n', '        // Service fee: 5%\n', '        players[teamAddress].balance += availableWithdrawal * 5 / 100;\n', '        // User get 95%\n', '        userAddress.transfer(availableWithdrawal * 95 / 100);\n', '        keyLocked = false;\n', '        emit Withdrawal(userAddress, availableWithdrawal);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']