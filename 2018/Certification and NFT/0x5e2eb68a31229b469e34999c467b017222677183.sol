['pragma solidity ^0.4.11;\n', '\n', '// File: attrstore/AttributeStore.sol\n', '\n', 'pragma solidity^0.4.11;\n', '\n', 'library AttributeStore {\n', '    struct Data {\n', '        mapping(bytes32 => uint) store;\n', '    }\n', '\n', '    function getAttribute(Data storage self, bytes32 _UUID, string _attrName)\n', '    public view returns (uint) {\n', '        bytes32 key = keccak256(_UUID, _attrName);\n', '        return self.store[key];\n', '    }\n', '\n', '    function setAttribute(Data storage self, bytes32 _UUID, string _attrName, uint _attrVal)\n', '    public {\n', '        bytes32 key = keccak256(_UUID, _attrName);\n', '        self.store[key] = _attrVal;\n', '    }\n', '}\n', '\n', '// File: dll/DLL.sol\n', '\n', 'pragma solidity^0.4.11;\n', '\n', 'library DLL {\n', '\n', '  uint constant NULL_NODE_ID = 0;\n', '\n', '  struct Node {\n', '    uint next;\n', '    uint prev;\n', '  }\n', '\n', '  struct Data {\n', '    mapping(uint => Node) dll;\n', '  }\n', '\n', '  function isEmpty(Data storage self) public view returns (bool) {\n', '    return getStart(self) == NULL_NODE_ID;\n', '  }\n', '\n', '  function contains(Data storage self, uint _curr) public view returns (bool) {\n', '    if (isEmpty(self) || _curr == NULL_NODE_ID) {\n', '      return false;\n', '    } \n', '\n', '    bool isSingleNode = (getStart(self) == _curr) && (getEnd(self) == _curr);\n', '    bool isNullNode = (getNext(self, _curr) == NULL_NODE_ID) && (getPrev(self, _curr) == NULL_NODE_ID);\n', '    return isSingleNode || !isNullNode;\n', '  }\n', '\n', '  function getNext(Data storage self, uint _curr) public view returns (uint) {\n', '    return self.dll[_curr].next;\n', '  }\n', '\n', '  function getPrev(Data storage self, uint _curr) public view returns (uint) {\n', '    return self.dll[_curr].prev;\n', '  }\n', '\n', '  function getStart(Data storage self) public view returns (uint) {\n', '    return getNext(self, NULL_NODE_ID);\n', '  }\n', '\n', '  function getEnd(Data storage self) public view returns (uint) {\n', '    return getPrev(self, NULL_NODE_ID);\n', '  }\n', '\n', '  /**\n', '  @dev Inserts a new node between _prev and _next. When inserting a node already existing in \n', '  the list it will be automatically removed from the old position.\n', '  @param _prev the node which _new will be inserted after\n', '  @param _curr the id of the new node being inserted\n', '  @param _next the node which _new will be inserted before\n', '  */\n', '  function insert(Data storage self, uint _prev, uint _curr, uint _next) public {\n', '    require(_curr != NULL_NODE_ID);\n', '\n', '    remove(self, _curr);\n', '\n', '    require(_prev == NULL_NODE_ID || contains(self, _prev));\n', '    require(_next == NULL_NODE_ID || contains(self, _next));\n', '\n', '    require(getNext(self, _prev) == _next);\n', '    require(getPrev(self, _next) == _prev);\n', '\n', '    self.dll[_curr].prev = _prev;\n', '    self.dll[_curr].next = _next;\n', '\n', '    self.dll[_prev].next = _curr;\n', '    self.dll[_next].prev = _curr;\n', '  }\n', '\n', '  function remove(Data storage self, uint _curr) public {\n', '    if (!contains(self, _curr)) {\n', '      return;\n', '    }\n', '\n', '    uint next = getNext(self, _curr);\n', '    uint prev = getPrev(self, _curr);\n', '\n', '    self.dll[next].prev = prev;\n', '    self.dll[prev].next = next;\n', '\n', '    delete self.dll[_curr];\n', '  }\n', '}\n', '\n', '// File: tokens/eip20/EIP20Interface.sol\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract EIP20Interface {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '// File: zeppelin/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: plcrvoting/PLCRVoting.sol\n', '\n', '/**\n', '@title Partial-Lock-Commit-Reveal Voting scheme with ERC20 tokens\n', '@author Team: Aspyn Palatnick, Cem Ozer, Yorke Rhodes\n', '*/\n', 'contract PLCRVoting {\n', '\n', '    // ============\n', '    // EVENTS:\n', '    // ============\n', '\n', '    event _VoteCommitted(uint indexed pollID, uint numTokens, address indexed voter);\n', '    event _VoteRevealed(uint indexed pollID, uint numTokens, uint votesFor, uint votesAgainst, uint indexed choice, address indexed voter);\n', '    event _PollCreated(uint voteQuorum, uint commitEndDate, uint revealEndDate, uint indexed pollID, address indexed creator);\n', '    event _VotingRightsGranted(uint numTokens, address indexed voter);\n', '    event _VotingRightsWithdrawn(uint numTokens, address indexed voter);\n', '    event _TokensRescued(uint indexed pollID, address indexed voter);\n', '\n', '    // ============\n', '    // DATA STRUCTURES:\n', '    // ============\n', '\n', '    using AttributeStore for AttributeStore.Data;\n', '    using DLL for DLL.Data;\n', '    using SafeMath for uint;\n', '\n', '    struct Poll {\n', '        uint commitEndDate;     /// expiration date of commit period for poll\n', '        uint revealEndDate;     /// expiration date of reveal period for poll\n', '        uint voteQuorum;\t    /// number of votes required for a proposal to pass\n', '        uint votesFor;\t\t    /// tally of votes supporting proposal\n', '        uint votesAgainst;      /// tally of votes countering proposal\n', '        mapping(address => bool) didCommit;  /// indicates whether an address committed a vote for this poll\n', '        mapping(address => bool) didReveal;   /// indicates whether an address revealed a vote for this poll\n', '    }\n', '\n', '    // ============\n', '    // STATE VARIABLES:\n', '    // ============\n', '\n', '    uint constant public INITIAL_POLL_NONCE = 0;\n', '    uint public pollNonce;\n', '\n', '    mapping(uint => Poll) public pollMap; // maps pollID to Poll struct\n', '    mapping(address => uint) public voteTokenBalance; // maps user&#39;s address to voteToken balance\n', '\n', '    mapping(address => DLL.Data) dllMap;\n', '    AttributeStore.Data store;\n', '\n', '    EIP20Interface public token;\n', '\n', '    // ============\n', '    // CONSTRUCTOR:\n', '    // ============\n', '\n', '    /**\n', '    @dev Initializes voteQuorum, commitDuration, revealDuration, and pollNonce in addition to token contract and trusted mapping\n', '    @param _tokenAddr The address where the ERC20 token contract is deployed\n', '    */\n', '    function PLCRVoting(address _tokenAddr) public {\n', '        token = EIP20Interface(_tokenAddr);\n', '        pollNonce = INITIAL_POLL_NONCE;\n', '    }\n', '\n', '    // ================\n', '    // TOKEN INTERFACE:\n', '    // ================\n', '\n', '    /**\n', '    @notice Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights\n', '    @dev Assumes that msg.sender has approved voting contract to spend on their behalf\n', '    @param _numTokens The number of votingTokens desired in exchange for ERC20 tokens\n', '    */\n', '    function requestVotingRights(uint _numTokens) external {\n', '        require(token.balanceOf(msg.sender) >= _numTokens);\n', '        voteTokenBalance[msg.sender] += _numTokens;\n', '        require(token.transferFrom(msg.sender, this, _numTokens));\n', '        _VotingRightsGranted(_numTokens, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @notice Withdraw _numTokens ERC20 tokens from the voting contract, revoking these voting rights\n', '    @param _numTokens The number of ERC20 tokens desired in exchange for voting rights\n', '    */\n', '    function withdrawVotingRights(uint _numTokens) external {\n', '        uint availableTokens = voteTokenBalance[msg.sender].sub(getLockedTokens(msg.sender));\n', '        require(availableTokens >= _numTokens);\n', '        voteTokenBalance[msg.sender] -= _numTokens;\n', '        require(token.transfer(msg.sender, _numTokens));\n', '        _VotingRightsWithdrawn(_numTokens, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev Unlocks tokens locked in unrevealed vote where poll has ended\n', '    @param _pollID Integer identifier associated with the target poll\n', '    */\n', '    function rescueTokens(uint _pollID) external {\n', '        require(isExpired(pollMap[_pollID].revealEndDate));\n', '        require(dllMap[msg.sender].contains(_pollID));\n', '\n', '        dllMap[msg.sender].remove(_pollID);\n', '        _TokensRescued(_pollID, msg.sender);\n', '    }\n', '\n', '    // =================\n', '    // VOTING INTERFACE:\n', '    // =================\n', '\n', '    /**\n', '    @notice Commits vote using hash of choice and secret salt to conceal vote until reveal\n', '    @param _pollID Integer identifier associated with target poll\n', '    @param _secretHash Commit keccak256 hash of voter&#39;s choice and salt (tightly packed in this order)\n', '    @param _numTokens The number of tokens to be committed towards the target poll\n', '    @param _prevPollID The ID of the poll that the user has voted the maximum number of tokens in which is still less than or equal to numTokens\n', '    */\n', '    function commitVote(uint _pollID, bytes32 _secretHash, uint _numTokens, uint _prevPollID) external {\n', '        require(commitPeriodActive(_pollID));\n', '        require(voteTokenBalance[msg.sender] >= _numTokens); // prevent user from overspending\n', '        require(_pollID != 0);                // prevent user from committing to zero node placeholder\n', '\n', '        // Check if _prevPollID exists in the user&#39;s DLL or if _prevPollID is 0\n', '        require(_prevPollID == 0 || dllMap[msg.sender].contains(_prevPollID));\n', '\n', '        uint nextPollID = dllMap[msg.sender].getNext(_prevPollID);\n', '\n', '        // if nextPollID is equal to _pollID, _pollID is being updated,\n', '        nextPollID = (nextPollID == _pollID) ? dllMap[msg.sender].getNext(_pollID) : nextPollID;\n', '\n', '        require(validPosition(_prevPollID, nextPollID, msg.sender, _numTokens));\n', '        dllMap[msg.sender].insert(_prevPollID, _pollID, nextPollID);\n', '\n', '        bytes32 UUID = attrUUID(msg.sender, _pollID);\n', '\n', '        store.setAttribute(UUID, "numTokens", _numTokens);\n', '        store.setAttribute(UUID, "commitHash", uint(_secretHash));\n', '\n', '        pollMap[_pollID].didCommit[msg.sender] = true;\n', '        _VoteCommitted(_pollID, _numTokens, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev Compares previous and next poll&#39;s committed tokens for sorting purposes\n', '    @param _prevID Integer identifier associated with previous poll in sorted order\n', '    @param _nextID Integer identifier associated with next poll in sorted order\n', '    @param _voter Address of user to check DLL position for\n', '    @param _numTokens The number of tokens to be committed towards the poll (used for sorting)\n', '    @return valid Boolean indication of if the specified position maintains the sort\n', '    */\n', '    function validPosition(uint _prevID, uint _nextID, address _voter, uint _numTokens) public constant returns (bool valid) {\n', '        bool prevValid = (_numTokens >= getNumTokens(_voter, _prevID));\n', '        // if next is zero node, _numTokens does not need to be greater\n', '        bool nextValid = (_numTokens <= getNumTokens(_voter, _nextID) || _nextID == 0);\n', '        return prevValid && nextValid;\n', '    }\n', '\n', '    /**\n', '    @notice Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens\n', '    @param _pollID Integer identifier associated with target poll\n', '    @param _voteOption Vote choice used to generate commitHash for associated poll\n', '    @param _salt Secret number used to generate commitHash for associated poll\n', '    */\n', '    function revealVote(uint _pollID, uint _voteOption, uint _salt) external {\n', '        // Make sure the reveal period is active\n', '        require(revealPeriodActive(_pollID));\n', '        require(pollMap[_pollID].didCommit[msg.sender]);                         // make sure user has committed a vote for this poll\n', '        require(!pollMap[_pollID].didReveal[msg.sender]);                        // prevent user from revealing multiple times\n', '        require(keccak256(_voteOption, _salt) == getCommitHash(msg.sender, _pollID)); // compare resultant hash from inputs to original commitHash\n', '\n', '        uint numTokens = getNumTokens(msg.sender, _pollID);\n', '\n', '        if (_voteOption == 1) {// apply numTokens to appropriate poll choice\n', '            pollMap[_pollID].votesFor += numTokens;\n', '        } else {\n', '            pollMap[_pollID].votesAgainst += numTokens;\n', '        }\n', '\n', '        dllMap[msg.sender].remove(_pollID); // remove the node referring to this vote upon reveal\n', '        pollMap[_pollID].didReveal[msg.sender] = true;\n', '\n', '        _VoteRevealed(_pollID, numTokens, pollMap[_pollID].votesFor, pollMap[_pollID].votesAgainst, _voteOption, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @param _pollID Integer identifier associated with target poll\n', '    @param _salt Arbitrarily chosen integer used to generate secretHash\n', '    @return correctVotes Number of tokens voted for winning option\n', '    */\n', '    function getNumPassingTokens(address _voter, uint _pollID, uint _salt) public constant returns (uint correctVotes) {\n', '        require(pollEnded(_pollID));\n', '        require(pollMap[_pollID].didReveal[_voter]);\n', '\n', '        uint winningChoice = isPassed(_pollID) ? 1 : 0;\n', '        bytes32 winnerHash = keccak256(winningChoice, _salt);\n', '        bytes32 commitHash = getCommitHash(_voter, _pollID);\n', '\n', '        require(winnerHash == commitHash);\n', '\n', '        return getNumTokens(_voter, _pollID);\n', '    }\n', '\n', '    // ==================\n', '    // POLLING INTERFACE:\n', '    // ==================\n', '\n', '    /**\n', '    @dev Initiates a poll with canonical configured parameters at pollID emitted by PollCreated event\n', '    @param _voteQuorum Type of majority (out of 100) that is necessary for poll to be successful\n', '    @param _commitDuration Length of desired commit period in seconds\n', '    @param _revealDuration Length of desired reveal period in seconds\n', '    */\n', '    function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {\n', '        pollNonce = pollNonce + 1;\n', '\n', '        uint commitEndDate = block.timestamp.add(_commitDuration);\n', '        uint revealEndDate = commitEndDate.add(_revealDuration);\n', '\n', '        pollMap[pollNonce] = Poll({\n', '            voteQuorum: _voteQuorum,\n', '            commitEndDate: commitEndDate,\n', '            revealEndDate: revealEndDate,\n', '            votesFor: 0,\n', '            votesAgainst: 0\n', '        });\n', '\n', '        _PollCreated(_voteQuorum, commitEndDate, revealEndDate, pollNonce, msg.sender);\n', '        return pollNonce;\n', '    }\n', '\n', '    /**\n', '    @notice Determines if proposal has passed\n', '    @dev Check if votesFor out of totalVotes exceeds votesQuorum (requires pollEnded)\n', '    @param _pollID Integer identifier associated with target poll\n', '    */\n', '    function isPassed(uint _pollID) constant public returns (bool passed) {\n', '        require(pollEnded(_pollID));\n', '\n', '        Poll memory poll = pollMap[_pollID];\n', '        return (100 * poll.votesFor) > (poll.voteQuorum * (poll.votesFor + poll.votesAgainst));\n', '    }\n', '\n', '    // ----------------\n', '    // POLLING HELPERS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev Gets the total winning votes for reward distribution purposes\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Total number of votes committed to the winning option for specified poll\n', '    */\n', '    function getTotalNumberOfTokensForWinningOption(uint _pollID) constant public returns (uint numTokens) {\n', '        require(pollEnded(_pollID));\n', '\n', '        if (isPassed(_pollID))\n', '            return pollMap[_pollID].votesFor;\n', '        else\n', '            return pollMap[_pollID].votesAgainst;\n', '    }\n', '\n', '    /**\n', '    @notice Determines if poll is over\n', '    @dev Checks isExpired for specified poll&#39;s revealEndDate\n', '    @return Boolean indication of whether polling period is over\n', '    */\n', '    function pollEnded(uint _pollID) constant public returns (bool ended) {\n', '        require(pollExists(_pollID));\n', '\n', '        return isExpired(pollMap[_pollID].revealEndDate);\n', '    }\n', '\n', '    /**\n', '    @notice Checks if the commit period is still active for the specified poll\n', '    @dev Checks isExpired for the specified poll&#39;s commitEndDate\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Boolean indication of isCommitPeriodActive for target poll\n', '    */\n', '    function commitPeriodActive(uint _pollID) constant public returns (bool active) {\n', '        require(pollExists(_pollID));\n', '\n', '        return !isExpired(pollMap[_pollID].commitEndDate);\n', '    }\n', '\n', '    /**\n', '    @notice Checks if the reveal period is still active for the specified poll\n', '    @dev Checks isExpired for the specified poll&#39;s revealEndDate\n', '    @param _pollID Integer identifier associated with target poll\n', '    */\n', '    function revealPeriodActive(uint _pollID) constant public returns (bool active) {\n', '        require(pollExists(_pollID));\n', '\n', '        return !isExpired(pollMap[_pollID].revealEndDate) && !commitPeriodActive(_pollID);\n', '    }\n', '\n', '    /**\n', '    @dev Checks if user has committed for specified poll\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Boolean indication of whether user has committed\n', '    */\n', '    function didCommit(address _voter, uint _pollID) constant public returns (bool committed) {\n', '        require(pollExists(_pollID));\n', '\n', '        return pollMap[_pollID].didCommit[_voter];\n', '    }\n', '\n', '    /**\n', '    @dev Checks if user has revealed for specified poll\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Boolean indication of whether user has revealed\n', '    */\n', '    function didReveal(address _voter, uint _pollID) constant public returns (bool revealed) {\n', '        require(pollExists(_pollID));\n', '\n', '        return pollMap[_pollID].didReveal[_voter];\n', '    }\n', '\n', '    /**\n', '    @dev Checks if a poll exists\n', '    @param _pollID The pollID whose existance is to be evaluated.\n', '    @return Boolean Indicates whether a poll exists for the provided pollID\n', '    */\n', '    function pollExists(uint _pollID) constant public returns (bool exists) {\n', '        return (_pollID != 0 && _pollID <= pollNonce);\n', '    }\n', '\n', '    // ---------------------------\n', '    // DOUBLE-LINKED-LIST HELPERS:\n', '    // ---------------------------\n', '\n', '    /**\n', '    @dev Gets the bytes32 commitHash property of target poll\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Bytes32 hash property attached to target poll\n', '    */\n', '    function getCommitHash(address _voter, uint _pollID) constant public returns (bytes32 commitHash) {\n', '        return bytes32(store.getAttribute(attrUUID(_voter, _pollID), "commitHash"));\n', '    }\n', '\n', '    /**\n', '    @dev Wrapper for getAttribute with attrName="numTokens"\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Number of tokens committed to poll in sorted poll-linked-list\n', '    */\n', '    function getNumTokens(address _voter, uint _pollID) constant public returns (uint numTokens) {\n', '        return store.getAttribute(attrUUID(_voter, _pollID), "numTokens");\n', '    }\n', '\n', '    /**\n', '    @dev Gets top element of sorted poll-linked-list\n', '    @param _voter Address of user to check against\n', '    @return Integer identifier to poll with maximum number of tokens committed to it\n', '    */\n', '    function getLastNode(address _voter) constant public returns (uint pollID) {\n', '        return dllMap[_voter].getPrev(0);\n', '    }\n', '\n', '    /**\n', '    @dev Gets the numTokens property of getLastNode\n', '    @param _voter Address of user to check against\n', '    @return Maximum number of tokens committed in poll specified\n', '    */\n', '    function getLockedTokens(address _voter) constant public returns (uint numTokens) {\n', '        return getNumTokens(_voter, getLastNode(_voter));\n', '    }\n', '\n', '    /*\n', '    @dev Takes the last node in the user&#39;s DLL and iterates backwards through the list searching\n', '    for a node with a value less than or equal to the provided _numTokens value. When such a node\n', '    is found, if the provided _pollID matches the found nodeID, this operation is an in-place\n', '    update. In that case, return the previous node of the node being updated. Otherwise return the\n', '    first node that was found with a value less than or equal to the provided _numTokens.\n', '    @param _voter The voter whose DLL will be searched\n', '    @param _numTokens The value for the numTokens attribute in the node to be inserted\n', '    @return the node which the propoded node should be inserted after\n', '    */\n', '    function getInsertPointForNumTokens(address _voter, uint _numTokens, uint _pollID)\n', '    constant public returns (uint prevNode) {\n', '      // Get the last node in the list and the number of tokens in that node\n', '      uint nodeID = getLastNode(_voter);\n', '      uint tokensInNode = getNumTokens(_voter, nodeID);\n', '\n', '      // Iterate backwards through the list until reaching the root node\n', '      while(nodeID != 0) {\n', '        // Get the number of tokens in the current node\n', '        tokensInNode = getNumTokens(_voter, nodeID);\n', '        if(tokensInNode <= _numTokens) { // We found the insert point!\n', '          if(nodeID == _pollID) {\n', '            // This is an in-place update. Return the prev node of the node being updated\n', '            nodeID = dllMap[_voter].getPrev(nodeID);\n', '          }\n', '          // Return the insert point\n', '          return nodeID; \n', '        }\n', '        // We did not find the insert point. Continue iterating backwards through the list\n', '        nodeID = dllMap[_voter].getPrev(nodeID);\n', '      }\n', '\n', '      // The list is empty, or a smaller value than anything else in the list is being inserted\n', '      return nodeID;\n', '    }\n', '\n', '    // ----------------\n', '    // GENERAL HELPERS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev Checks if an expiration date has been reached\n', '    @param _terminationDate Integer timestamp of date to compare current timestamp with\n', '    @return expired Boolean indication of whether the terminationDate has passed\n', '    */\n', '    function isExpired(uint _terminationDate) constant public returns (bool expired) {\n', '        return (block.timestamp > _terminationDate);\n', '    }\n', '\n', '    /**\n', '    @dev Generates an identifier which associates a user and a poll together\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return UUID Hash which is deterministic from _user and _pollID\n', '    */\n', '    function attrUUID(address _user, uint _pollID) public pure returns (bytes32 UUID) {\n', '        return keccak256(_user, _pollID);\n', '    }\n', '}\n', '\n', '// File: contracts/Parameterizer.sol\n', '\n', 'pragma solidity^0.4.11;\n', '\n', '\n', '\n', '\n', 'contract Parameterizer {\n', '\n', '  // ------\n', '  // EVENTS\n', '  // ------\n', '\n', '  event _ReparameterizationProposal(string name, uint value, bytes32 propID, uint deposit, uint appEndDate, address indexed proposer);\n', '  event _NewChallenge(bytes32 indexed propID, uint challengeID, uint commitEndDate, uint revealEndDate, address indexed challenger);\n', '  event _ProposalAccepted(bytes32 indexed propID, string name, uint value);\n', '  event _ProposalExpired(bytes32 indexed propID);\n', '  event _ChallengeSucceeded(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);\n', '  event _ChallengeFailed(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);\n', '  event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter);\n', '\n', '\n', '  // ------\n', '  // DATA STRUCTURES\n', '  // ------\n', '\n', '  using SafeMath for uint;\n', '\n', '  struct ParamProposal {\n', '    uint appExpiry;\n', '    uint challengeID;\n', '    uint deposit;\n', '    string name;\n', '    address owner;\n', '    uint processBy;\n', '    uint value;\n', '  }\n', '\n', '  struct Challenge {\n', '    uint rewardPool;        // (remaining) pool of tokens distributed amongst winning voters\n', '    address challenger;     // owner of Challenge\n', '    bool resolved;          // indication of if challenge is resolved\n', '    uint stake;             // number of tokens at risk for either party during challenge\n', '    uint winningTokens;     // (remaining) amount of tokens used for voting by the winning side\n', '    mapping(address => bool) tokenClaims;\n', '  }\n', '\n', '  // ------\n', '  // STATE\n', '  // ------\n', '\n', '  mapping(bytes32 => uint) public params;\n', '\n', '  // maps challengeIDs to associated challenge data\n', '  mapping(uint => Challenge) public challenges;\n', '\n', '  // maps pollIDs to intended data change if poll passes\n', '  mapping(bytes32 => ParamProposal) public proposals;\n', '\n', '  // Global Variables\n', '  EIP20Interface public token;\n', '  PLCRVoting public voting;\n', '  uint public PROCESSBY = 604800; // 7 days\n', '\n', '  // ------------\n', '  // CONSTRUCTOR\n', '  // ------------\n', '\n', '  /**\n', '  @dev constructor\n', '  @param _tokenAddr        address of the token which parameterizes this system\n', '  @param _plcrAddr         address of a PLCR voting contract for the provided token\n', '  @param _minDeposit       minimum deposit for listing to be whitelisted\n', '  @param _pMinDeposit      minimum deposit to propose a reparameterization\n', '  @param _applyStageLen    period over which applicants wait to be whitelisted\n', '  @param _pApplyStageLen   period over which reparmeterization proposals wait to be processed\n', '  @param _dispensationPct  percentage of losing party&#39;s deposit distributed to winning party\n', '  @param _pDispensationPct percentage of losing party&#39;s deposit distributed to winning party in parameterizer\n', '  @param _commitStageLen  length of commit period for voting\n', '  @param _pCommitStageLen length of commit period for voting in parameterizer\n', '  @param _revealStageLen  length of reveal period for voting\n', '  @param _pRevealStageLen length of reveal period for voting in parameterizer\n', '  @param _voteQuorum       type of majority out of 100 necessary for vote success\n', '  @param _pVoteQuorum      type of majority out of 100 necessary for vote success in parameterizer\n', '  */\n', '  function Parameterizer(\n', '    address _tokenAddr,\n', '    address _plcrAddr,\n', '    uint _minDeposit,\n', '    uint _pMinDeposit,\n', '    uint _applyStageLen,\n', '    uint _pApplyStageLen,\n', '    uint _commitStageLen,\n', '    uint _pCommitStageLen,\n', '    uint _revealStageLen,\n', '    uint _pRevealStageLen,\n', '    uint _dispensationPct,\n', '    uint _pDispensationPct,\n', '    uint _voteQuorum,\n', '    uint _pVoteQuorum\n', '    ) public {\n', '      token = EIP20Interface(_tokenAddr);\n', '      voting = PLCRVoting(_plcrAddr);\n', '\n', '      set("minDeposit", _minDeposit);\n', '      set("pMinDeposit", _pMinDeposit);\n', '      set("applyStageLen", _applyStageLen);\n', '      set("pApplyStageLen", _pApplyStageLen);\n', '      set("commitStageLen", _commitStageLen);\n', '      set("pCommitStageLen", _pCommitStageLen);\n', '      set("revealStageLen", _revealStageLen);\n', '      set("pRevealStageLen", _pRevealStageLen);\n', '      set("dispensationPct", _dispensationPct);\n', '      set("pDispensationPct", _pDispensationPct);\n', '      set("voteQuorum", _voteQuorum);\n', '      set("pVoteQuorum", _pVoteQuorum);\n', '  }\n', '\n', '  // -----------------------\n', '  // TOKEN HOLDER INTERFACE\n', '  // -----------------------\n', '\n', '  /**\n', '  @notice propose a reparamaterization of the key _name&#39;s value to _value.\n', '  @param _name the name of the proposed param to be set\n', '  @param _value the proposed value to set the param to be set\n', '  */\n', '  function proposeReparameterization(string _name, uint _value) public returns (bytes32) {\n', '    uint deposit = get("pMinDeposit");\n', '    bytes32 propID = keccak256(_name, _value);\n', '\n', '    if (keccak256(_name) == keccak256(&#39;dispensationPct&#39;) ||\n', '       keccak256(_name) == keccak256(&#39;pDispensationPct&#39;)) {\n', '        require(_value <= 100);\n', '    }\n', '\n', '    require(!propExists(propID)); // Forbid duplicate proposals\n', '    require(get(_name) != _value); // Forbid NOOP reparameterizations\n', '\n', '    // attach name and value to pollID\n', '    proposals[propID] = ParamProposal({\n', '      appExpiry: now.add(get("pApplyStageLen")),\n', '      challengeID: 0,\n', '      deposit: deposit,\n', '      name: _name,\n', '      owner: msg.sender,\n', '      processBy: now.add(get("pApplyStageLen"))\n', '        .add(get("pCommitStageLen"))\n', '        .add(get("pRevealStageLen"))\n', '        .add(PROCESSBY),\n', '      value: _value\n', '    });\n', '\n', '    require(token.transferFrom(msg.sender, this, deposit)); // escrow tokens (deposit amt)\n', '\n', '    _ReparameterizationProposal(_name, _value, propID, deposit, proposals[propID].appExpiry, msg.sender);\n', '    return propID;\n', '  }\n', '\n', '  /**\n', '  @notice challenge the provided proposal ID, and put tokens at stake to do so.\n', '  @param _propID the proposal ID to challenge\n', '  */\n', '  function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {\n', '    ParamProposal memory prop = proposals[_propID];\n', '    uint deposit = prop.deposit;\n', '\n', '    require(propExists(_propID) && prop.challengeID == 0);\n', '\n', '    //start poll\n', '    uint pollID = voting.startPoll(\n', '      get("pVoteQuorum"),\n', '      get("pCommitStageLen"),\n', '      get("pRevealStageLen")\n', '    );\n', '\n', '    challenges[pollID] = Challenge({\n', '      challenger: msg.sender,\n', '      rewardPool: SafeMath.sub(100, get("pDispensationPct")).mul(deposit).div(100),\n', '      stake: deposit,\n', '      resolved: false,\n', '      winningTokens: 0\n', '    });\n', '\n', '    proposals[_propID].challengeID = pollID;       // update listing to store most recent challenge\n', '\n', '    //take tokens from challenger\n', '    require(token.transferFrom(msg.sender, this, deposit));\n', '\n', '    var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);\n', '\n', '    _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);\n', '    return pollID;\n', '  }\n', '\n', '  /**\n', '  @notice for the provided proposal ID, set it, resolve its challenge, or delete it depending on whether it can be set, has a challenge which can be resolved, or if its "process by" date has passed\n', '  @param _propID the proposal ID to make a determination and state transition for\n', '  */\n', '  function processProposal(bytes32 _propID) public {\n', '    ParamProposal storage prop = proposals[_propID];\n', '    address propOwner = prop.owner;\n', '    uint propDeposit = prop.deposit;\n', '\n', '    \n', '    // Before any token transfers, deleting the proposal will ensure that if reentrancy occurs the\n', '    // prop.owner and prop.deposit will be 0, thereby preventing theft\n', '   if (canBeSet(_propID)) {\n', '      // There is no challenge against the proposal. The processBy date for the proposal has not\n', '     // passed, but the proposal&#39;s appExpirty date has passed.\n', '      set(prop.name, prop.value);\n', '      _ProposalAccepted(_propID, prop.name, prop.value);\n', '      delete proposals[_propID];\n', '      require(token.transfer(propOwner, propDeposit));\n', '    } else if (challengeCanBeResolved(_propID)) {\n', '      // There is a challenge against the proposal.\n', '      resolveChallenge(_propID);\n', '    } else if (now > prop.processBy) {\n', '      // There is no challenge against the proposal, but the processBy date has passed.\n', '      _ProposalExpired(_propID);\n', '      delete proposals[_propID];\n', '      require(token.transfer(propOwner, propDeposit));\n', '    } else {\n', '      // There is no challenge against the proposal, and neither the appExpiry date nor the\n', '      // processBy date has passed.\n', '      revert();\n', '    }\n', '\n', '    assert(get("dispensationPct") <= 100);\n', '    assert(get("pDispensationPct") <= 100);\n', '\n', '    // verify that future proposal appExpiry and processBy times will not overflow\n', '    now.add(get("pApplyStageLen"))\n', '      .add(get("pCommitStageLen"))\n', '      .add(get("pRevealStageLen"))\n', '      .add(PROCESSBY);\n', '\n', '    delete proposals[_propID];\n', '  }\n', '\n', '  /**\n', '  @notice claim the tokens owed for the msg.sender in the provided challenge\n', '  @param _challengeID the challenge ID to claim tokens for\n', '  @param _salt the salt used to vote in the challenge being withdrawn for\n', '  */\n', '  function claimReward(uint _challengeID, uint _salt) public {\n', '    // ensure voter has not already claimed tokens and challenge results have been processed\n', '    require(challenges[_challengeID].tokenClaims[msg.sender] == false);\n', '    require(challenges[_challengeID].resolved == true);\n', '\n', '    uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID, _salt);\n', '    uint reward = voterReward(msg.sender, _challengeID, _salt);\n', '\n', '    // subtract voter&#39;s information to preserve the participation ratios of other voters\n', '    // compared to the remaining pool of rewards\n', '    challenges[_challengeID].winningTokens -= voterTokens;\n', '    challenges[_challengeID].rewardPool -= reward;\n', '\n', '    // ensures a voter cannot claim tokens again\n', '    challenges[_challengeID].tokenClaims[msg.sender] = true;\n', '\n', '    _RewardClaimed(_challengeID, reward, msg.sender);\n', '    require(token.transfer(msg.sender, reward));\n', '  }\n', '\n', '  // --------\n', '  // GETTERS\n', '  // --------\n', '\n', '  /**\n', '  @dev                Calculates the provided voter&#39;s token reward for the given poll.\n', '  @param _voter       The address of the voter whose reward balance is to be returned\n', '  @param _challengeID The ID of the challenge the voter&#39;s reward is being calculated for\n', '  @param _salt        The salt of the voter&#39;s commit hash in the given poll\n', '  @return             The uint indicating the voter&#39;s reward\n', '  */\n', '  function voterReward(address _voter, uint _challengeID, uint _salt)\n', '  public view returns (uint) {\n', '    uint winningTokens = challenges[_challengeID].winningTokens;\n', '    uint rewardPool = challenges[_challengeID].rewardPool;\n', '    uint voterTokens = voting.getNumPassingTokens(_voter, _challengeID, _salt);\n', '    return (voterTokens * rewardPool) / winningTokens;\n', '  }\n', '\n', '  /**\n', '  @notice Determines whether a proposal passed its application stage without a challenge\n', '  @param _propID The proposal ID for which to determine whether its application stage passed without a challenge\n', '  */\n', '  function canBeSet(bytes32 _propID) view public returns (bool) {\n', '    ParamProposal memory prop = proposals[_propID];\n', '\n', '    return (now > prop.appExpiry && now < prop.processBy && prop.challengeID == 0);\n', '  }\n', '\n', '  /**\n', '  @notice Determines whether a proposal exists for the provided proposal ID\n', '  @param _propID The proposal ID whose existance is to be determined\n', '  */\n', '  function propExists(bytes32 _propID) view public returns (bool) {\n', '    return proposals[_propID].processBy > 0;\n', '  }\n', '\n', '  /**\n', '  @notice Determines whether the provided proposal ID has a challenge which can be resolved\n', '  @param _propID The proposal ID whose challenge to inspect\n', '  */\n', '  function challengeCanBeResolved(bytes32 _propID) view public returns (bool) {\n', '    ParamProposal memory prop = proposals[_propID];\n', '    Challenge memory challenge = challenges[prop.challengeID];\n', '\n', '    return (prop.challengeID > 0 && challenge.resolved == false &&\n', '            voting.pollEnded(prop.challengeID));\n', '  }\n', '\n', '  /**\n', '  @notice Determines the number of tokens to awarded to the winning party in a challenge\n', '  @param _challengeID The challengeID to determine a reward for\n', '  */\n', '  function challengeWinnerReward(uint _challengeID) public view returns (uint) {\n', '    if(voting.getTotalNumberOfTokensForWinningOption(_challengeID) == 0) {\n', '      // Edge case, nobody voted, give all tokens to the challenger.\n', '      return 2 * challenges[_challengeID].stake;\n', '    }\n', '\n', '    return (2 * challenges[_challengeID].stake) - challenges[_challengeID].rewardPool;\n', '  }\n', '\n', '  /**\n', '  @notice gets the parameter keyed by the provided name value from the params mapping\n', '  @param _name the key whose value is to be determined\n', '  */\n', '  function get(string _name) public view returns (uint value) {\n', '    return params[keccak256(_name)];\n', '  }\n', '\n', '  /**\n', '  @dev                Getter for Challenge tokenClaims mappings\n', '  @param _challengeID The challengeID to query\n', '  @param _voter       The voter whose claim status to query for the provided challengeID\n', '  */\n', '  function tokenClaims(uint _challengeID, address _voter) public view returns (bool) {\n', '    return challenges[_challengeID].tokenClaims[_voter];\n', '  }\n', '\n', '  // ----------------\n', '  // PRIVATE FUNCTIONS\n', '  // ----------------\n', '\n', '  /**\n', '  @dev resolves a challenge for the provided _propID. It must be checked in advance whether the _propID has a challenge on it\n', '  @param _propID the proposal ID whose challenge is to be resolved.\n', '  */\n', '  function resolveChallenge(bytes32 _propID) private {\n', '    ParamProposal memory prop = proposals[_propID];\n', '    Challenge storage challenge = challenges[prop.challengeID];\n', '\n', '    // winner gets back their full staked deposit, and dispensationPct*loser&#39;s stake\n', '    uint reward = challengeWinnerReward(prop.challengeID);\n', '\n', '    challenge.winningTokens =\n', '      voting.getTotalNumberOfTokensForWinningOption(prop.challengeID);\n', '    challenge.resolved = true;\n', '\n', '    if (voting.isPassed(prop.challengeID)) { // The challenge failed\n', '      if(prop.processBy > now) {\n', '        set(prop.name, prop.value);\n', '      }\n', '      _ChallengeFailed(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);\n', '      require(token.transfer(prop.owner, reward));\n', '    }\n', '    else { // The challenge succeeded or nobody voted\n', '      _ChallengeSucceeded(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);\n', '      require(token.transfer(challenges[prop.challengeID].challenger, reward));\n', '    }\n', '  }\n', '\n', '  /**\n', '  @dev sets the param keted by the provided name to the provided value\n', '  @param _name the name of the param to be set\n', '  @param _value the value to set the param to be set\n', '  */\n', '  function set(string _name, uint _value) private {\n', '    params[keccak256(_name)] = _value;\n', '  }\n', '}\n', '\n', '// File: contracts/Registry.sol\n', '\n', 'contract Registry {\n', '\n', '    // ------\n', '    // EVENTS\n', '    // ------\n', '\n', '    event _Application(bytes32 indexed listingHash, uint deposit, uint appEndDate, string data, address indexed applicant);\n', '    event _Challenge(bytes32 indexed listingHash, uint challengeID, string data, uint commitEndDate, uint revealEndDate, address indexed challenger);\n', '    event _Deposit(bytes32 indexed listingHash, uint added, uint newTotal, address indexed owner);\n', '    event _Withdrawal(bytes32 indexed listingHash, uint withdrew, uint newTotal, address indexed owner);\n', '    event _ApplicationWhitelisted(bytes32 indexed listingHash);\n', '    event _ApplicationRemoved(bytes32 indexed listingHash);\n', '    event _ListingRemoved(bytes32 indexed listingHash);\n', '    event _ListingWithdrawn(bytes32 indexed listingHash);\n', '    event _TouchAndRemoved(bytes32 indexed listingHash);\n', '    event _ChallengeFailed(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens);\n', '    event _ChallengeSucceeded(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens);\n', '    event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter);\n', '\n', '    using SafeMath for uint;\n', '\n', '    struct Listing {\n', '        uint applicationExpiry; // Expiration date of apply stage\n', '        bool whitelisted;       // Indicates registry status\n', '        address owner;          // Owner of Listing\n', '        uint unstakedDeposit;   // Number of tokens in the listing not locked in a challenge\n', '        uint challengeID;       // Corresponds to a PollID in PLCRVoting\n', '    }\n', '\n', '    struct Challenge {\n', '        uint rewardPool;        // (remaining) Pool of tokens to be distributed to winning voters\n', '        address challenger;     // Owner of Challenge\n', '        bool resolved;          // Indication of if challenge is resolved\n', '        uint stake;             // Number of tokens at stake for either party during challenge\n', '        uint totalTokens;       // (remaining) Number of tokens used in voting by the winning side\n', '        mapping(address => bool) tokenClaims; // Indicates whether a voter has claimed a reward yet\n', '    }\n', '\n', '    // Maps challengeIDs to associated challenge data\n', '    mapping(uint => Challenge) public challenges;\n', '\n', '    // Maps listingHashes to associated listingHash data\n', '    mapping(bytes32 => Listing) public listings;\n', '\n', '    // Global Variables\n', '    EIP20Interface public token;\n', '    PLCRVoting public voting;\n', '    Parameterizer public parameterizer;\n', '    string public name;\n', '\n', '    // ------------\n', '    // CONSTRUCTOR:\n', '    // ------------\n', '\n', '    /**\n', '    @dev Contructor         Sets the addresses for token, voting, and parameterizer\n', '    @param _tokenAddr       Address of the TCR&#39;s intrinsic ERC20 token\n', '    @param _plcrAddr        Address of a PLCR voting contract for the provided token\n', '    @param _paramsAddr      Address of a Parameterizer contract \n', '    */\n', '    function Registry(\n', '        address _tokenAddr,\n', '        address _plcrAddr,\n', '        address _paramsAddr,\n', '        string _name\n', '    ) public {\n', '        token = EIP20Interface(_tokenAddr);\n', '        voting = PLCRVoting(_plcrAddr);\n', '        parameterizer = Parameterizer(_paramsAddr);\n', '        name = _name;\n', '    }\n', '\n', '    // --------------------\n', '    // PUBLISHER INTERFACE:\n', '    // --------------------\n', '\n', '    /**\n', '    @dev                Allows a user to start an application. Takes tokens from user and sets\n', '                        apply stage end time.\n', '    @param _listingHash The hash of a potential listing a user is applying to add to the registry\n', '    @param _amount      The number of ERC20 tokens a user is willing to potentially stake\n', '    @param _data        Extra data relevant to the application. Think IPFS hashes.\n', '    */\n', '    function apply(bytes32 _listingHash, uint _amount, string _data) external {\n', '        require(!isWhitelisted(_listingHash));\n', '        require(!appWasMade(_listingHash));\n', '        require(_amount >= parameterizer.get("minDeposit"));\n', '\n', '        // Sets owner\n', '        Listing storage listing = listings[_listingHash];\n', '        listing.owner = msg.sender;\n', '\n', '        // Sets apply stage end time\n', '        listing.applicationExpiry = block.timestamp.add(parameterizer.get("applyStageLen"));\n', '        listing.unstakedDeposit = _amount;\n', '\n', '        // Transfers tokens from user to Registry contract\n', '        require(token.transferFrom(listing.owner, this, _amount));\n', '\n', '        _Application(_listingHash, _amount, listing.applicationExpiry, _data, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev                Allows the owner of a listingHash to increase their unstaked deposit.\n', '    @param _listingHash A listingHash msg.sender is the owner of\n', '    @param _amount      The number of ERC20 tokens to increase a user&#39;s unstaked deposit\n', '    */\n', '    function deposit(bytes32 _listingHash, uint _amount) external {\n', '        Listing storage listing = listings[_listingHash];\n', '\n', '        require(listing.owner == msg.sender);\n', '\n', '        listing.unstakedDeposit += _amount;\n', '        require(token.transferFrom(msg.sender, this, _amount));\n', '\n', '        _Deposit(_listingHash, _amount, listing.unstakedDeposit, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev                Allows the owner of a listingHash to decrease their unstaked deposit.\n', '    @param _listingHash A listingHash msg.sender is the owner of.\n', '    @param _amount      The number of ERC20 tokens to withdraw from the unstaked deposit.\n', '    */\n', '    function withdraw(bytes32 _listingHash, uint _amount) external {\n', '        Listing storage listing = listings[_listingHash];\n', '\n', '        require(listing.owner == msg.sender);\n', '        require(_amount <= listing.unstakedDeposit);\n', '        require(listing.unstakedDeposit - _amount >= parameterizer.get("minDeposit"));\n', '\n', '        listing.unstakedDeposit -= _amount;\n', '        require(token.transfer(msg.sender, _amount));\n', '\n', '        _Withdrawal(_listingHash, _amount, listing.unstakedDeposit, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev                Allows the owner of a listingHash to remove the listingHash from the whitelist\n', '                        Returns all tokens to the owner of the listingHash\n', '    @param _listingHash A listingHash msg.sender is the owner of.\n', '    */\n', '    function exit(bytes32 _listingHash) external {\n', '        Listing storage listing = listings[_listingHash];\n', '\n', '        require(msg.sender == listing.owner);\n', '        require(isWhitelisted(_listingHash));\n', '\n', '        // Cannot exit during ongoing challenge\n', '        require(listing.challengeID == 0 || challenges[listing.challengeID].resolved);\n', '\n', '        // Remove listingHash & return tokens\n', '        resetListing(_listingHash);\n', '        _ListingWithdrawn(_listingHash);\n', '    }\n', '\n', '    // -----------------------\n', '    // TOKEN HOLDER INTERFACE:\n', '    // -----------------------\n', '\n', '    /**\n', '    @dev                Starts a poll for a listingHash which is either in the apply stage or\n', '                        already in the whitelist. Tokens are taken from the challenger and the\n', '                        applicant&#39;s deposits are locked.\n', '    @param _listingHash The listingHash being challenged, whether listed or in application\n', '    @param _data        Extra data relevant to the challenge. Think IPFS hashes.\n', '    */\n', '    function challenge(bytes32 _listingHash, string _data) external returns (uint challengeID) {\n', '        Listing storage listing = listings[_listingHash];\n', '        uint deposit = parameterizer.get("minDeposit");\n', '\n', '        // Listing must be in apply stage or already on the whitelist\n', '        require(appWasMade(_listingHash) || listing.whitelisted);\n', '        // Prevent multiple challenges\n', '        require(listing.challengeID == 0 || challenges[listing.challengeID].resolved);\n', '\n', '        if (listing.unstakedDeposit < deposit) {\n', '            // Not enough tokens, listingHash auto-delisted\n', '            resetListing(_listingHash);\n', '            _TouchAndRemoved(_listingHash);\n', '            return 0;\n', '        }\n', '\n', '        // Starts poll\n', '        uint pollID = voting.startPoll(\n', '            parameterizer.get("voteQuorum"),\n', '            parameterizer.get("commitStageLen"),\n', '            parameterizer.get("revealStageLen")\n', '        );\n', '\n', '        challenges[pollID] = Challenge({\n', '            challenger: msg.sender,\n', '            rewardPool: ((100 - parameterizer.get("dispensationPct")) * deposit) / 100,\n', '            stake: deposit,\n', '            resolved: false,\n', '            totalTokens: 0\n', '        });\n', '\n', '        // Updates listingHash to store most recent challenge\n', '        listing.challengeID = pollID;\n', '\n', '        // Locks tokens for listingHash during challenge\n', '        listing.unstakedDeposit -= deposit;\n', '\n', '        // Takes tokens from challenger\n', '        require(token.transferFrom(msg.sender, this, deposit));\n', '\n', '        var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);\n', '\n', '        _Challenge(_listingHash, pollID, _data, commitEndDate, revealEndDate, msg.sender);\n', '        return pollID;\n', '    }\n', '\n', '    /**\n', '    @dev                Updates a listingHash&#39;s status from &#39;application&#39; to &#39;listing&#39; or resolves\n', '                        a challenge if one exists.\n', '    @param _listingHash The listingHash whose status is being updated\n', '    */\n', '    function updateStatus(bytes32 _listingHash) public {\n', '        if (canBeWhitelisted(_listingHash)) {\n', '          whitelistApplication(_listingHash);\n', '        } else if (challengeCanBeResolved(_listingHash)) {\n', '          resolveChallenge(_listingHash);\n', '        } else {\n', '          revert();\n', '        }\n', '    }\n', '\n', '    // ----------------\n', '    // TOKEN FUNCTIONS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev                Called by a voter to claim their reward for each completed vote. Someone\n', '                        must call updateStatus() before this can be called.\n', '    @param _challengeID The PLCR pollID of the challenge a reward is being claimed for\n', '    @param _salt        The salt of a voter&#39;s commit hash in the given poll\n', '    */\n', '    function claimReward(uint _challengeID, uint _salt) public {\n', '        // Ensures the voter has not already claimed tokens and challenge results have been processed\n', '        require(challenges[_challengeID].tokenClaims[msg.sender] == false);\n', '        require(challenges[_challengeID].resolved == true);\n', '\n', '        uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID, _salt);\n', '        uint reward = voterReward(msg.sender, _challengeID, _salt);\n', '\n', '        // Subtracts the voter&#39;s information to preserve the participation ratios\n', '        // of other voters compared to the remaining pool of rewards\n', '        challenges[_challengeID].totalTokens -= voterTokens;\n', '        challenges[_challengeID].rewardPool -= reward;\n', '\n', '        // Ensures a voter cannot claim tokens again\n', '        challenges[_challengeID].tokenClaims[msg.sender] = true;\n', '\n', '        require(token.transfer(msg.sender, reward));\n', '\n', '        _RewardClaimed(_challengeID, reward, msg.sender);\n', '    }\n', '\n', '    // --------\n', '    // GETTERS:\n', '    // --------\n', '\n', '    /**\n', '    @dev                Calculates the provided voter&#39;s token reward for the given poll.\n', '    @param _voter       The address of the voter whose reward balance is to be returned\n', '    @param _challengeID The pollID of the challenge a reward balance is being queried for\n', '    @param _salt        The salt of the voter&#39;s commit hash in the given poll\n', '    @return             The uint indicating the voter&#39;s reward\n', '    */\n', '    function voterReward(address _voter, uint _challengeID, uint _salt)\n', '    public view returns (uint) {\n', '        uint totalTokens = challenges[_challengeID].totalTokens;\n', '        uint rewardPool = challenges[_challengeID].rewardPool;\n', '        uint voterTokens = voting.getNumPassingTokens(_voter, _challengeID, _salt);\n', '        return (voterTokens * rewardPool) / totalTokens;\n', '    }\n', '\n', '    /**\n', '    @dev                Determines whether the given listingHash be whitelisted.\n', '    @param _listingHash The listingHash whose status is to be examined\n', '    */\n', '    function canBeWhitelisted(bytes32 _listingHash) view public returns (bool) {\n', '        uint challengeID = listings[_listingHash].challengeID;\n', '\n', '        // Ensures that the application was made,\n', '        // the application period has ended,\n', '        // the listingHash can be whitelisted,\n', '        // and either: the challengeID == 0, or the challenge has been resolved.\n', '        if (\n', '            appWasMade(_listingHash) &&\n', '            listings[_listingHash].applicationExpiry < now &&\n', '            !isWhitelisted(_listingHash) &&\n', '            (challengeID == 0 || challenges[challengeID].resolved == true)\n', '        ) { return true; }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '    @dev                Returns true if the provided listingHash is whitelisted\n', '    @param _listingHash The listingHash whose status is to be examined\n', '    */\n', '    function isWhitelisted(bytes32 _listingHash) view public returns (bool whitelisted) {\n', '        return listings[_listingHash].whitelisted;\n', '    }\n', '\n', '    /**\n', '    @dev                Returns true if apply was called for this listingHash\n', '    @param _listingHash The listingHash whose status is to be examined\n', '    */\n', '    function appWasMade(bytes32 _listingHash) view public returns (bool exists) {\n', '        return listings[_listingHash].applicationExpiry > 0;\n', '    }\n', '\n', '    /**\n', '    @dev                Returns true if the application/listingHash has an unresolved challenge\n', '    @param _listingHash The listingHash whose status is to be examined\n', '    */\n', '    function challengeExists(bytes32 _listingHash) view public returns (bool) {\n', '        uint challengeID = listings[_listingHash].challengeID;\n', '\n', '        return (listings[_listingHash].challengeID > 0 && !challenges[challengeID].resolved);\n', '    }\n', '\n', '    /**\n', '    @dev                Determines whether voting has concluded in a challenge for a given\n', '                        listingHash. Throws if no challenge exists.\n', '    @param _listingHash A listingHash with an unresolved challenge\n', '    */\n', '    function challengeCanBeResolved(bytes32 _listingHash) view public returns (bool) {\n', '        uint challengeID = listings[_listingHash].challengeID;\n', '\n', '        require(challengeExists(_listingHash));\n', '\n', '        return voting.pollEnded(challengeID);\n', '    }\n', '\n', '    /**\n', '    @dev                Determines the number of tokens awarded to the winning party in a challenge.\n', '    @param _challengeID The challengeID to determine a reward for\n', '    */\n', '    function determineReward(uint _challengeID) public view returns (uint) {\n', '        require(!challenges[_challengeID].resolved && voting.pollEnded(_challengeID));\n', '\n', '        // Edge case, nobody voted, give all tokens to the challenger.\n', '        if (voting.getTotalNumberOfTokensForWinningOption(_challengeID) == 0) {\n', '            return 2 * challenges[_challengeID].stake;\n', '        }\n', '\n', '        return (2 * challenges[_challengeID].stake) - challenges[_challengeID].rewardPool;\n', '    }\n', '\n', '    /**\n', '    @dev                Getter for Challenge tokenClaims mappings\n', '    @param _challengeID The challengeID to query\n', '    @param _voter       The voter whose claim status to query for the provided challengeID\n', '    */\n', '    function tokenClaims(uint _challengeID, address _voter) public view returns (bool) {\n', '      return challenges[_challengeID].tokenClaims[_voter];\n', '    }\n', '\n', '    // ----------------\n', '    // PRIVATE FUNCTIONS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev                Determines the winner in a challenge. Rewards the winner tokens and\n', '                        either whitelists or de-whitelists the listingHash.\n', '    @param _listingHash A listingHash with a challenge that is to be resolved\n', '    */\n', '    function resolveChallenge(bytes32 _listingHash) private {\n', '        uint challengeID = listings[_listingHash].challengeID;\n', '\n', '        // Calculates the winner&#39;s reward,\n', '        // which is: (winner&#39;s full stake) + (dispensationPct * loser&#39;s stake)\n', '        uint reward = determineReward(challengeID);\n', '\n', '        // Sets flag on challenge being processed\n', '        challenges[challengeID].resolved = true;\n', '\n', '        // Stores the total tokens used for voting by the winning side for reward purposes\n', '        challenges[challengeID].totalTokens =\n', '            voting.getTotalNumberOfTokensForWinningOption(challengeID);\n', '\n', '        // Case: challenge failed\n', '        if (voting.isPassed(challengeID)) {\n', '            whitelistApplication(_listingHash);\n', '            // Unlock stake so that it can be retrieved by the applicant\n', '            listings[_listingHash].unstakedDeposit += reward;\n', '\n', '            _ChallengeFailed(_listingHash, challengeID, challenges[challengeID].rewardPool, challenges[challengeID].totalTokens);\n', '        }\n', '        // Case: challenge succeeded or nobody voted\n', '        else {\n', '            resetListing(_listingHash);\n', '            // Transfer the reward to the challenger\n', '            require(token.transfer(challenges[challengeID].challenger, reward));\n', '\n', '            _ChallengeSucceeded(_listingHash, challengeID, challenges[challengeID].rewardPool, challenges[challengeID].totalTokens);\n', '        }\n', '    }\n', '\n', '    /**\n', '    @dev                Called by updateStatus() if the applicationExpiry date passed without a\n', '                        challenge being made. Called by resolveChallenge() if an\n', '                        application/listing beat a challenge.\n', '    @param _listingHash The listingHash of an application/listingHash to be whitelisted\n', '    */\n', '    function whitelistApplication(bytes32 _listingHash) private {\n', '        if (!listings[_listingHash].whitelisted) { _ApplicationWhitelisted(_listingHash); }\n', '        listings[_listingHash].whitelisted = true;\n', '    }\n', '\n', '    /**\n', '    @dev                Deletes a listingHash from the whitelist and transfers tokens back to owner\n', '    @param _listingHash The listing hash to delete\n', '    */\n', '    function resetListing(bytes32 _listingHash) private {\n', '        Listing storage listing = listings[_listingHash];\n', '\n', '        // Emit events before deleting listing to check whether is whitelisted\n', '        if (listing.whitelisted) {\n', '            _ListingRemoved(_listingHash);\n', '        } else {\n', '            _ApplicationRemoved(_listingHash);\n', '        }\n', '\n', '        // Deleting listing to prevent reentry\n', '        address owner = listing.owner;\n', '        uint unstakedDeposit = listing.unstakedDeposit;\n', '        delete listings[_listingHash];\n', '        \n', '        // Transfers any remaining balance back to the owner\n', '        if (unstakedDeposit > 0){\n', '            require(token.transfer(owner, unstakedDeposit));\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '// File: attrstore/AttributeStore.sol\n', '\n', 'pragma solidity^0.4.11;\n', '\n', 'library AttributeStore {\n', '    struct Data {\n', '        mapping(bytes32 => uint) store;\n', '    }\n', '\n', '    function getAttribute(Data storage self, bytes32 _UUID, string _attrName)\n', '    public view returns (uint) {\n', '        bytes32 key = keccak256(_UUID, _attrName);\n', '        return self.store[key];\n', '    }\n', '\n', '    function setAttribute(Data storage self, bytes32 _UUID, string _attrName, uint _attrVal)\n', '    public {\n', '        bytes32 key = keccak256(_UUID, _attrName);\n', '        self.store[key] = _attrVal;\n', '    }\n', '}\n', '\n', '// File: dll/DLL.sol\n', '\n', 'pragma solidity^0.4.11;\n', '\n', 'library DLL {\n', '\n', '  uint constant NULL_NODE_ID = 0;\n', '\n', '  struct Node {\n', '    uint next;\n', '    uint prev;\n', '  }\n', '\n', '  struct Data {\n', '    mapping(uint => Node) dll;\n', '  }\n', '\n', '  function isEmpty(Data storage self) public view returns (bool) {\n', '    return getStart(self) == NULL_NODE_ID;\n', '  }\n', '\n', '  function contains(Data storage self, uint _curr) public view returns (bool) {\n', '    if (isEmpty(self) || _curr == NULL_NODE_ID) {\n', '      return false;\n', '    } \n', '\n', '    bool isSingleNode = (getStart(self) == _curr) && (getEnd(self) == _curr);\n', '    bool isNullNode = (getNext(self, _curr) == NULL_NODE_ID) && (getPrev(self, _curr) == NULL_NODE_ID);\n', '    return isSingleNode || !isNullNode;\n', '  }\n', '\n', '  function getNext(Data storage self, uint _curr) public view returns (uint) {\n', '    return self.dll[_curr].next;\n', '  }\n', '\n', '  function getPrev(Data storage self, uint _curr) public view returns (uint) {\n', '    return self.dll[_curr].prev;\n', '  }\n', '\n', '  function getStart(Data storage self) public view returns (uint) {\n', '    return getNext(self, NULL_NODE_ID);\n', '  }\n', '\n', '  function getEnd(Data storage self) public view returns (uint) {\n', '    return getPrev(self, NULL_NODE_ID);\n', '  }\n', '\n', '  /**\n', '  @dev Inserts a new node between _prev and _next. When inserting a node already existing in \n', '  the list it will be automatically removed from the old position.\n', '  @param _prev the node which _new will be inserted after\n', '  @param _curr the id of the new node being inserted\n', '  @param _next the node which _new will be inserted before\n', '  */\n', '  function insert(Data storage self, uint _prev, uint _curr, uint _next) public {\n', '    require(_curr != NULL_NODE_ID);\n', '\n', '    remove(self, _curr);\n', '\n', '    require(_prev == NULL_NODE_ID || contains(self, _prev));\n', '    require(_next == NULL_NODE_ID || contains(self, _next));\n', '\n', '    require(getNext(self, _prev) == _next);\n', '    require(getPrev(self, _next) == _prev);\n', '\n', '    self.dll[_curr].prev = _prev;\n', '    self.dll[_curr].next = _next;\n', '\n', '    self.dll[_prev].next = _curr;\n', '    self.dll[_next].prev = _curr;\n', '  }\n', '\n', '  function remove(Data storage self, uint _curr) public {\n', '    if (!contains(self, _curr)) {\n', '      return;\n', '    }\n', '\n', '    uint next = getNext(self, _curr);\n', '    uint prev = getPrev(self, _curr);\n', '\n', '    self.dll[next].prev = prev;\n', '    self.dll[prev].next = next;\n', '\n', '    delete self.dll[_curr];\n', '  }\n', '}\n', '\n', '// File: tokens/eip20/EIP20Interface.sol\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract EIP20Interface {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '// File: zeppelin/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: plcrvoting/PLCRVoting.sol\n', '\n', '/**\n', '@title Partial-Lock-Commit-Reveal Voting scheme with ERC20 tokens\n', '@author Team: Aspyn Palatnick, Cem Ozer, Yorke Rhodes\n', '*/\n', 'contract PLCRVoting {\n', '\n', '    // ============\n', '    // EVENTS:\n', '    // ============\n', '\n', '    event _VoteCommitted(uint indexed pollID, uint numTokens, address indexed voter);\n', '    event _VoteRevealed(uint indexed pollID, uint numTokens, uint votesFor, uint votesAgainst, uint indexed choice, address indexed voter);\n', '    event _PollCreated(uint voteQuorum, uint commitEndDate, uint revealEndDate, uint indexed pollID, address indexed creator);\n', '    event _VotingRightsGranted(uint numTokens, address indexed voter);\n', '    event _VotingRightsWithdrawn(uint numTokens, address indexed voter);\n', '    event _TokensRescued(uint indexed pollID, address indexed voter);\n', '\n', '    // ============\n', '    // DATA STRUCTURES:\n', '    // ============\n', '\n', '    using AttributeStore for AttributeStore.Data;\n', '    using DLL for DLL.Data;\n', '    using SafeMath for uint;\n', '\n', '    struct Poll {\n', '        uint commitEndDate;     /// expiration date of commit period for poll\n', '        uint revealEndDate;     /// expiration date of reveal period for poll\n', '        uint voteQuorum;\t    /// number of votes required for a proposal to pass\n', '        uint votesFor;\t\t    /// tally of votes supporting proposal\n', '        uint votesAgainst;      /// tally of votes countering proposal\n', '        mapping(address => bool) didCommit;  /// indicates whether an address committed a vote for this poll\n', '        mapping(address => bool) didReveal;   /// indicates whether an address revealed a vote for this poll\n', '    }\n', '\n', '    // ============\n', '    // STATE VARIABLES:\n', '    // ============\n', '\n', '    uint constant public INITIAL_POLL_NONCE = 0;\n', '    uint public pollNonce;\n', '\n', '    mapping(uint => Poll) public pollMap; // maps pollID to Poll struct\n', "    mapping(address => uint) public voteTokenBalance; // maps user's address to voteToken balance\n", '\n', '    mapping(address => DLL.Data) dllMap;\n', '    AttributeStore.Data store;\n', '\n', '    EIP20Interface public token;\n', '\n', '    // ============\n', '    // CONSTRUCTOR:\n', '    // ============\n', '\n', '    /**\n', '    @dev Initializes voteQuorum, commitDuration, revealDuration, and pollNonce in addition to token contract and trusted mapping\n', '    @param _tokenAddr The address where the ERC20 token contract is deployed\n', '    */\n', '    function PLCRVoting(address _tokenAddr) public {\n', '        token = EIP20Interface(_tokenAddr);\n', '        pollNonce = INITIAL_POLL_NONCE;\n', '    }\n', '\n', '    // ================\n', '    // TOKEN INTERFACE:\n', '    // ================\n', '\n', '    /**\n', '    @notice Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights\n', '    @dev Assumes that msg.sender has approved voting contract to spend on their behalf\n', '    @param _numTokens The number of votingTokens desired in exchange for ERC20 tokens\n', '    */\n', '    function requestVotingRights(uint _numTokens) external {\n', '        require(token.balanceOf(msg.sender) >= _numTokens);\n', '        voteTokenBalance[msg.sender] += _numTokens;\n', '        require(token.transferFrom(msg.sender, this, _numTokens));\n', '        _VotingRightsGranted(_numTokens, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @notice Withdraw _numTokens ERC20 tokens from the voting contract, revoking these voting rights\n', '    @param _numTokens The number of ERC20 tokens desired in exchange for voting rights\n', '    */\n', '    function withdrawVotingRights(uint _numTokens) external {\n', '        uint availableTokens = voteTokenBalance[msg.sender].sub(getLockedTokens(msg.sender));\n', '        require(availableTokens >= _numTokens);\n', '        voteTokenBalance[msg.sender] -= _numTokens;\n', '        require(token.transfer(msg.sender, _numTokens));\n', '        _VotingRightsWithdrawn(_numTokens, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev Unlocks tokens locked in unrevealed vote where poll has ended\n', '    @param _pollID Integer identifier associated with the target poll\n', '    */\n', '    function rescueTokens(uint _pollID) external {\n', '        require(isExpired(pollMap[_pollID].revealEndDate));\n', '        require(dllMap[msg.sender].contains(_pollID));\n', '\n', '        dllMap[msg.sender].remove(_pollID);\n', '        _TokensRescued(_pollID, msg.sender);\n', '    }\n', '\n', '    // =================\n', '    // VOTING INTERFACE:\n', '    // =================\n', '\n', '    /**\n', '    @notice Commits vote using hash of choice and secret salt to conceal vote until reveal\n', '    @param _pollID Integer identifier associated with target poll\n', "    @param _secretHash Commit keccak256 hash of voter's choice and salt (tightly packed in this order)\n", '    @param _numTokens The number of tokens to be committed towards the target poll\n', '    @param _prevPollID The ID of the poll that the user has voted the maximum number of tokens in which is still less than or equal to numTokens\n', '    */\n', '    function commitVote(uint _pollID, bytes32 _secretHash, uint _numTokens, uint _prevPollID) external {\n', '        require(commitPeriodActive(_pollID));\n', '        require(voteTokenBalance[msg.sender] >= _numTokens); // prevent user from overspending\n', '        require(_pollID != 0);                // prevent user from committing to zero node placeholder\n', '\n', "        // Check if _prevPollID exists in the user's DLL or if _prevPollID is 0\n", '        require(_prevPollID == 0 || dllMap[msg.sender].contains(_prevPollID));\n', '\n', '        uint nextPollID = dllMap[msg.sender].getNext(_prevPollID);\n', '\n', '        // if nextPollID is equal to _pollID, _pollID is being updated,\n', '        nextPollID = (nextPollID == _pollID) ? dllMap[msg.sender].getNext(_pollID) : nextPollID;\n', '\n', '        require(validPosition(_prevPollID, nextPollID, msg.sender, _numTokens));\n', '        dllMap[msg.sender].insert(_prevPollID, _pollID, nextPollID);\n', '\n', '        bytes32 UUID = attrUUID(msg.sender, _pollID);\n', '\n', '        store.setAttribute(UUID, "numTokens", _numTokens);\n', '        store.setAttribute(UUID, "commitHash", uint(_secretHash));\n', '\n', '        pollMap[_pollID].didCommit[msg.sender] = true;\n', '        _VoteCommitted(_pollID, _numTokens, msg.sender);\n', '    }\n', '\n', '    /**\n', "    @dev Compares previous and next poll's committed tokens for sorting purposes\n", '    @param _prevID Integer identifier associated with previous poll in sorted order\n', '    @param _nextID Integer identifier associated with next poll in sorted order\n', '    @param _voter Address of user to check DLL position for\n', '    @param _numTokens The number of tokens to be committed towards the poll (used for sorting)\n', '    @return valid Boolean indication of if the specified position maintains the sort\n', '    */\n', '    function validPosition(uint _prevID, uint _nextID, address _voter, uint _numTokens) public constant returns (bool valid) {\n', '        bool prevValid = (_numTokens >= getNumTokens(_voter, _prevID));\n', '        // if next is zero node, _numTokens does not need to be greater\n', '        bool nextValid = (_numTokens <= getNumTokens(_voter, _nextID) || _nextID == 0);\n', '        return prevValid && nextValid;\n', '    }\n', '\n', '    /**\n', '    @notice Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens\n', '    @param _pollID Integer identifier associated with target poll\n', '    @param _voteOption Vote choice used to generate commitHash for associated poll\n', '    @param _salt Secret number used to generate commitHash for associated poll\n', '    */\n', '    function revealVote(uint _pollID, uint _voteOption, uint _salt) external {\n', '        // Make sure the reveal period is active\n', '        require(revealPeriodActive(_pollID));\n', '        require(pollMap[_pollID].didCommit[msg.sender]);                         // make sure user has committed a vote for this poll\n', '        require(!pollMap[_pollID].didReveal[msg.sender]);                        // prevent user from revealing multiple times\n', '        require(keccak256(_voteOption, _salt) == getCommitHash(msg.sender, _pollID)); // compare resultant hash from inputs to original commitHash\n', '\n', '        uint numTokens = getNumTokens(msg.sender, _pollID);\n', '\n', '        if (_voteOption == 1) {// apply numTokens to appropriate poll choice\n', '            pollMap[_pollID].votesFor += numTokens;\n', '        } else {\n', '            pollMap[_pollID].votesAgainst += numTokens;\n', '        }\n', '\n', '        dllMap[msg.sender].remove(_pollID); // remove the node referring to this vote upon reveal\n', '        pollMap[_pollID].didReveal[msg.sender] = true;\n', '\n', '        _VoteRevealed(_pollID, numTokens, pollMap[_pollID].votesFor, pollMap[_pollID].votesAgainst, _voteOption, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @param _pollID Integer identifier associated with target poll\n', '    @param _salt Arbitrarily chosen integer used to generate secretHash\n', '    @return correctVotes Number of tokens voted for winning option\n', '    */\n', '    function getNumPassingTokens(address _voter, uint _pollID, uint _salt) public constant returns (uint correctVotes) {\n', '        require(pollEnded(_pollID));\n', '        require(pollMap[_pollID].didReveal[_voter]);\n', '\n', '        uint winningChoice = isPassed(_pollID) ? 1 : 0;\n', '        bytes32 winnerHash = keccak256(winningChoice, _salt);\n', '        bytes32 commitHash = getCommitHash(_voter, _pollID);\n', '\n', '        require(winnerHash == commitHash);\n', '\n', '        return getNumTokens(_voter, _pollID);\n', '    }\n', '\n', '    // ==================\n', '    // POLLING INTERFACE:\n', '    // ==================\n', '\n', '    /**\n', '    @dev Initiates a poll with canonical configured parameters at pollID emitted by PollCreated event\n', '    @param _voteQuorum Type of majority (out of 100) that is necessary for poll to be successful\n', '    @param _commitDuration Length of desired commit period in seconds\n', '    @param _revealDuration Length of desired reveal period in seconds\n', '    */\n', '    function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {\n', '        pollNonce = pollNonce + 1;\n', '\n', '        uint commitEndDate = block.timestamp.add(_commitDuration);\n', '        uint revealEndDate = commitEndDate.add(_revealDuration);\n', '\n', '        pollMap[pollNonce] = Poll({\n', '            voteQuorum: _voteQuorum,\n', '            commitEndDate: commitEndDate,\n', '            revealEndDate: revealEndDate,\n', '            votesFor: 0,\n', '            votesAgainst: 0\n', '        });\n', '\n', '        _PollCreated(_voteQuorum, commitEndDate, revealEndDate, pollNonce, msg.sender);\n', '        return pollNonce;\n', '    }\n', '\n', '    /**\n', '    @notice Determines if proposal has passed\n', '    @dev Check if votesFor out of totalVotes exceeds votesQuorum (requires pollEnded)\n', '    @param _pollID Integer identifier associated with target poll\n', '    */\n', '    function isPassed(uint _pollID) constant public returns (bool passed) {\n', '        require(pollEnded(_pollID));\n', '\n', '        Poll memory poll = pollMap[_pollID];\n', '        return (100 * poll.votesFor) > (poll.voteQuorum * (poll.votesFor + poll.votesAgainst));\n', '    }\n', '\n', '    // ----------------\n', '    // POLLING HELPERS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev Gets the total winning votes for reward distribution purposes\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Total number of votes committed to the winning option for specified poll\n', '    */\n', '    function getTotalNumberOfTokensForWinningOption(uint _pollID) constant public returns (uint numTokens) {\n', '        require(pollEnded(_pollID));\n', '\n', '        if (isPassed(_pollID))\n', '            return pollMap[_pollID].votesFor;\n', '        else\n', '            return pollMap[_pollID].votesAgainst;\n', '    }\n', '\n', '    /**\n', '    @notice Determines if poll is over\n', "    @dev Checks isExpired for specified poll's revealEndDate\n", '    @return Boolean indication of whether polling period is over\n', '    */\n', '    function pollEnded(uint _pollID) constant public returns (bool ended) {\n', '        require(pollExists(_pollID));\n', '\n', '        return isExpired(pollMap[_pollID].revealEndDate);\n', '    }\n', '\n', '    /**\n', '    @notice Checks if the commit period is still active for the specified poll\n', "    @dev Checks isExpired for the specified poll's commitEndDate\n", '    @param _pollID Integer identifier associated with target poll\n', '    @return Boolean indication of isCommitPeriodActive for target poll\n', '    */\n', '    function commitPeriodActive(uint _pollID) constant public returns (bool active) {\n', '        require(pollExists(_pollID));\n', '\n', '        return !isExpired(pollMap[_pollID].commitEndDate);\n', '    }\n', '\n', '    /**\n', '    @notice Checks if the reveal period is still active for the specified poll\n', "    @dev Checks isExpired for the specified poll's revealEndDate\n", '    @param _pollID Integer identifier associated with target poll\n', '    */\n', '    function revealPeriodActive(uint _pollID) constant public returns (bool active) {\n', '        require(pollExists(_pollID));\n', '\n', '        return !isExpired(pollMap[_pollID].revealEndDate) && !commitPeriodActive(_pollID);\n', '    }\n', '\n', '    /**\n', '    @dev Checks if user has committed for specified poll\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Boolean indication of whether user has committed\n', '    */\n', '    function didCommit(address _voter, uint _pollID) constant public returns (bool committed) {\n', '        require(pollExists(_pollID));\n', '\n', '        return pollMap[_pollID].didCommit[_voter];\n', '    }\n', '\n', '    /**\n', '    @dev Checks if user has revealed for specified poll\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Boolean indication of whether user has revealed\n', '    */\n', '    function didReveal(address _voter, uint _pollID) constant public returns (bool revealed) {\n', '        require(pollExists(_pollID));\n', '\n', '        return pollMap[_pollID].didReveal[_voter];\n', '    }\n', '\n', '    /**\n', '    @dev Checks if a poll exists\n', '    @param _pollID The pollID whose existance is to be evaluated.\n', '    @return Boolean Indicates whether a poll exists for the provided pollID\n', '    */\n', '    function pollExists(uint _pollID) constant public returns (bool exists) {\n', '        return (_pollID != 0 && _pollID <= pollNonce);\n', '    }\n', '\n', '    // ---------------------------\n', '    // DOUBLE-LINKED-LIST HELPERS:\n', '    // ---------------------------\n', '\n', '    /**\n', '    @dev Gets the bytes32 commitHash property of target poll\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Bytes32 hash property attached to target poll\n', '    */\n', '    function getCommitHash(address _voter, uint _pollID) constant public returns (bytes32 commitHash) {\n', '        return bytes32(store.getAttribute(attrUUID(_voter, _pollID), "commitHash"));\n', '    }\n', '\n', '    /**\n', '    @dev Wrapper for getAttribute with attrName="numTokens"\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Number of tokens committed to poll in sorted poll-linked-list\n', '    */\n', '    function getNumTokens(address _voter, uint _pollID) constant public returns (uint numTokens) {\n', '        return store.getAttribute(attrUUID(_voter, _pollID), "numTokens");\n', '    }\n', '\n', '    /**\n', '    @dev Gets top element of sorted poll-linked-list\n', '    @param _voter Address of user to check against\n', '    @return Integer identifier to poll with maximum number of tokens committed to it\n', '    */\n', '    function getLastNode(address _voter) constant public returns (uint pollID) {\n', '        return dllMap[_voter].getPrev(0);\n', '    }\n', '\n', '    /**\n', '    @dev Gets the numTokens property of getLastNode\n', '    @param _voter Address of user to check against\n', '    @return Maximum number of tokens committed in poll specified\n', '    */\n', '    function getLockedTokens(address _voter) constant public returns (uint numTokens) {\n', '        return getNumTokens(_voter, getLastNode(_voter));\n', '    }\n', '\n', '    /*\n', "    @dev Takes the last node in the user's DLL and iterates backwards through the list searching\n", '    for a node with a value less than or equal to the provided _numTokens value. When such a node\n', '    is found, if the provided _pollID matches the found nodeID, this operation is an in-place\n', '    update. In that case, return the previous node of the node being updated. Otherwise return the\n', '    first node that was found with a value less than or equal to the provided _numTokens.\n', '    @param _voter The voter whose DLL will be searched\n', '    @param _numTokens The value for the numTokens attribute in the node to be inserted\n', '    @return the node which the propoded node should be inserted after\n', '    */\n', '    function getInsertPointForNumTokens(address _voter, uint _numTokens, uint _pollID)\n', '    constant public returns (uint prevNode) {\n', '      // Get the last node in the list and the number of tokens in that node\n', '      uint nodeID = getLastNode(_voter);\n', '      uint tokensInNode = getNumTokens(_voter, nodeID);\n', '\n', '      // Iterate backwards through the list until reaching the root node\n', '      while(nodeID != 0) {\n', '        // Get the number of tokens in the current node\n', '        tokensInNode = getNumTokens(_voter, nodeID);\n', '        if(tokensInNode <= _numTokens) { // We found the insert point!\n', '          if(nodeID == _pollID) {\n', '            // This is an in-place update. Return the prev node of the node being updated\n', '            nodeID = dllMap[_voter].getPrev(nodeID);\n', '          }\n', '          // Return the insert point\n', '          return nodeID; \n', '        }\n', '        // We did not find the insert point. Continue iterating backwards through the list\n', '        nodeID = dllMap[_voter].getPrev(nodeID);\n', '      }\n', '\n', '      // The list is empty, or a smaller value than anything else in the list is being inserted\n', '      return nodeID;\n', '    }\n', '\n', '    // ----------------\n', '    // GENERAL HELPERS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev Checks if an expiration date has been reached\n', '    @param _terminationDate Integer timestamp of date to compare current timestamp with\n', '    @return expired Boolean indication of whether the terminationDate has passed\n', '    */\n', '    function isExpired(uint _terminationDate) constant public returns (bool expired) {\n', '        return (block.timestamp > _terminationDate);\n', '    }\n', '\n', '    /**\n', '    @dev Generates an identifier which associates a user and a poll together\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return UUID Hash which is deterministic from _user and _pollID\n', '    */\n', '    function attrUUID(address _user, uint _pollID) public pure returns (bytes32 UUID) {\n', '        return keccak256(_user, _pollID);\n', '    }\n', '}\n', '\n', '// File: contracts/Parameterizer.sol\n', '\n', 'pragma solidity^0.4.11;\n', '\n', '\n', '\n', '\n', 'contract Parameterizer {\n', '\n', '  // ------\n', '  // EVENTS\n', '  // ------\n', '\n', '  event _ReparameterizationProposal(string name, uint value, bytes32 propID, uint deposit, uint appEndDate, address indexed proposer);\n', '  event _NewChallenge(bytes32 indexed propID, uint challengeID, uint commitEndDate, uint revealEndDate, address indexed challenger);\n', '  event _ProposalAccepted(bytes32 indexed propID, string name, uint value);\n', '  event _ProposalExpired(bytes32 indexed propID);\n', '  event _ChallengeSucceeded(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);\n', '  event _ChallengeFailed(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);\n', '  event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter);\n', '\n', '\n', '  // ------\n', '  // DATA STRUCTURES\n', '  // ------\n', '\n', '  using SafeMath for uint;\n', '\n', '  struct ParamProposal {\n', '    uint appExpiry;\n', '    uint challengeID;\n', '    uint deposit;\n', '    string name;\n', '    address owner;\n', '    uint processBy;\n', '    uint value;\n', '  }\n', '\n', '  struct Challenge {\n', '    uint rewardPool;        // (remaining) pool of tokens distributed amongst winning voters\n', '    address challenger;     // owner of Challenge\n', '    bool resolved;          // indication of if challenge is resolved\n', '    uint stake;             // number of tokens at risk for either party during challenge\n', '    uint winningTokens;     // (remaining) amount of tokens used for voting by the winning side\n', '    mapping(address => bool) tokenClaims;\n', '  }\n', '\n', '  // ------\n', '  // STATE\n', '  // ------\n', '\n', '  mapping(bytes32 => uint) public params;\n', '\n', '  // maps challengeIDs to associated challenge data\n', '  mapping(uint => Challenge) public challenges;\n', '\n', '  // maps pollIDs to intended data change if poll passes\n', '  mapping(bytes32 => ParamProposal) public proposals;\n', '\n', '  // Global Variables\n', '  EIP20Interface public token;\n', '  PLCRVoting public voting;\n', '  uint public PROCESSBY = 604800; // 7 days\n', '\n', '  // ------------\n', '  // CONSTRUCTOR\n', '  // ------------\n', '\n', '  /**\n', '  @dev constructor\n', '  @param _tokenAddr        address of the token which parameterizes this system\n', '  @param _plcrAddr         address of a PLCR voting contract for the provided token\n', '  @param _minDeposit       minimum deposit for listing to be whitelisted\n', '  @param _pMinDeposit      minimum deposit to propose a reparameterization\n', '  @param _applyStageLen    period over which applicants wait to be whitelisted\n', '  @param _pApplyStageLen   period over which reparmeterization proposals wait to be processed\n', "  @param _dispensationPct  percentage of losing party's deposit distributed to winning party\n", "  @param _pDispensationPct percentage of losing party's deposit distributed to winning party in parameterizer\n", '  @param _commitStageLen  length of commit period for voting\n', '  @param _pCommitStageLen length of commit period for voting in parameterizer\n', '  @param _revealStageLen  length of reveal period for voting\n', '  @param _pRevealStageLen length of reveal period for voting in parameterizer\n', '  @param _voteQuorum       type of majority out of 100 necessary for vote success\n', '  @param _pVoteQuorum      type of majority out of 100 necessary for vote success in parameterizer\n', '  */\n', '  function Parameterizer(\n', '    address _tokenAddr,\n', '    address _plcrAddr,\n', '    uint _minDeposit,\n', '    uint _pMinDeposit,\n', '    uint _applyStageLen,\n', '    uint _pApplyStageLen,\n', '    uint _commitStageLen,\n', '    uint _pCommitStageLen,\n', '    uint _revealStageLen,\n', '    uint _pRevealStageLen,\n', '    uint _dispensationPct,\n', '    uint _pDispensationPct,\n', '    uint _voteQuorum,\n', '    uint _pVoteQuorum\n', '    ) public {\n', '      token = EIP20Interface(_tokenAddr);\n', '      voting = PLCRVoting(_plcrAddr);\n', '\n', '      set("minDeposit", _minDeposit);\n', '      set("pMinDeposit", _pMinDeposit);\n', '      set("applyStageLen", _applyStageLen);\n', '      set("pApplyStageLen", _pApplyStageLen);\n', '      set("commitStageLen", _commitStageLen);\n', '      set("pCommitStageLen", _pCommitStageLen);\n', '      set("revealStageLen", _revealStageLen);\n', '      set("pRevealStageLen", _pRevealStageLen);\n', '      set("dispensationPct", _dispensationPct);\n', '      set("pDispensationPct", _pDispensationPct);\n', '      set("voteQuorum", _voteQuorum);\n', '      set("pVoteQuorum", _pVoteQuorum);\n', '  }\n', '\n', '  // -----------------------\n', '  // TOKEN HOLDER INTERFACE\n', '  // -----------------------\n', '\n', '  /**\n', "  @notice propose a reparamaterization of the key _name's value to _value.\n", '  @param _name the name of the proposed param to be set\n', '  @param _value the proposed value to set the param to be set\n', '  */\n', '  function proposeReparameterization(string _name, uint _value) public returns (bytes32) {\n', '    uint deposit = get("pMinDeposit");\n', '    bytes32 propID = keccak256(_name, _value);\n', '\n', "    if (keccak256(_name) == keccak256('dispensationPct') ||\n", "       keccak256(_name) == keccak256('pDispensationPct')) {\n", '        require(_value <= 100);\n', '    }\n', '\n', '    require(!propExists(propID)); // Forbid duplicate proposals\n', '    require(get(_name) != _value); // Forbid NOOP reparameterizations\n', '\n', '    // attach name and value to pollID\n', '    proposals[propID] = ParamProposal({\n', '      appExpiry: now.add(get("pApplyStageLen")),\n', '      challengeID: 0,\n', '      deposit: deposit,\n', '      name: _name,\n', '      owner: msg.sender,\n', '      processBy: now.add(get("pApplyStageLen"))\n', '        .add(get("pCommitStageLen"))\n', '        .add(get("pRevealStageLen"))\n', '        .add(PROCESSBY),\n', '      value: _value\n', '    });\n', '\n', '    require(token.transferFrom(msg.sender, this, deposit)); // escrow tokens (deposit amt)\n', '\n', '    _ReparameterizationProposal(_name, _value, propID, deposit, proposals[propID].appExpiry, msg.sender);\n', '    return propID;\n', '  }\n', '\n', '  /**\n', '  @notice challenge the provided proposal ID, and put tokens at stake to do so.\n', '  @param _propID the proposal ID to challenge\n', '  */\n', '  function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {\n', '    ParamProposal memory prop = proposals[_propID];\n', '    uint deposit = prop.deposit;\n', '\n', '    require(propExists(_propID) && prop.challengeID == 0);\n', '\n', '    //start poll\n', '    uint pollID = voting.startPoll(\n', '      get("pVoteQuorum"),\n', '      get("pCommitStageLen"),\n', '      get("pRevealStageLen")\n', '    );\n', '\n', '    challenges[pollID] = Challenge({\n', '      challenger: msg.sender,\n', '      rewardPool: SafeMath.sub(100, get("pDispensationPct")).mul(deposit).div(100),\n', '      stake: deposit,\n', '      resolved: false,\n', '      winningTokens: 0\n', '    });\n', '\n', '    proposals[_propID].challengeID = pollID;       // update listing to store most recent challenge\n', '\n', '    //take tokens from challenger\n', '    require(token.transferFrom(msg.sender, this, deposit));\n', '\n', '    var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);\n', '\n', '    _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);\n', '    return pollID;\n', '  }\n', '\n', '  /**\n', '  @notice for the provided proposal ID, set it, resolve its challenge, or delete it depending on whether it can be set, has a challenge which can be resolved, or if its "process by" date has passed\n', '  @param _propID the proposal ID to make a determination and state transition for\n', '  */\n', '  function processProposal(bytes32 _propID) public {\n', '    ParamProposal storage prop = proposals[_propID];\n', '    address propOwner = prop.owner;\n', '    uint propDeposit = prop.deposit;\n', '\n', '    \n', '    // Before any token transfers, deleting the proposal will ensure that if reentrancy occurs the\n', '    // prop.owner and prop.deposit will be 0, thereby preventing theft\n', '   if (canBeSet(_propID)) {\n', '      // There is no challenge against the proposal. The processBy date for the proposal has not\n', "     // passed, but the proposal's appExpirty date has passed.\n", '      set(prop.name, prop.value);\n', '      _ProposalAccepted(_propID, prop.name, prop.value);\n', '      delete proposals[_propID];\n', '      require(token.transfer(propOwner, propDeposit));\n', '    } else if (challengeCanBeResolved(_propID)) {\n', '      // There is a challenge against the proposal.\n', '      resolveChallenge(_propID);\n', '    } else if (now > prop.processBy) {\n', '      // There is no challenge against the proposal, but the processBy date has passed.\n', '      _ProposalExpired(_propID);\n', '      delete proposals[_propID];\n', '      require(token.transfer(propOwner, propDeposit));\n', '    } else {\n', '      // There is no challenge against the proposal, and neither the appExpiry date nor the\n', '      // processBy date has passed.\n', '      revert();\n', '    }\n', '\n', '    assert(get("dispensationPct") <= 100);\n', '    assert(get("pDispensationPct") <= 100);\n', '\n', '    // verify that future proposal appExpiry and processBy times will not overflow\n', '    now.add(get("pApplyStageLen"))\n', '      .add(get("pCommitStageLen"))\n', '      .add(get("pRevealStageLen"))\n', '      .add(PROCESSBY);\n', '\n', '    delete proposals[_propID];\n', '  }\n', '\n', '  /**\n', '  @notice claim the tokens owed for the msg.sender in the provided challenge\n', '  @param _challengeID the challenge ID to claim tokens for\n', '  @param _salt the salt used to vote in the challenge being withdrawn for\n', '  */\n', '  function claimReward(uint _challengeID, uint _salt) public {\n', '    // ensure voter has not already claimed tokens and challenge results have been processed\n', '    require(challenges[_challengeID].tokenClaims[msg.sender] == false);\n', '    require(challenges[_challengeID].resolved == true);\n', '\n', '    uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID, _salt);\n', '    uint reward = voterReward(msg.sender, _challengeID, _salt);\n', '\n', "    // subtract voter's information to preserve the participation ratios of other voters\n", '    // compared to the remaining pool of rewards\n', '    challenges[_challengeID].winningTokens -= voterTokens;\n', '    challenges[_challengeID].rewardPool -= reward;\n', '\n', '    // ensures a voter cannot claim tokens again\n', '    challenges[_challengeID].tokenClaims[msg.sender] = true;\n', '\n', '    _RewardClaimed(_challengeID, reward, msg.sender);\n', '    require(token.transfer(msg.sender, reward));\n', '  }\n', '\n', '  // --------\n', '  // GETTERS\n', '  // --------\n', '\n', '  /**\n', "  @dev                Calculates the provided voter's token reward for the given poll.\n", '  @param _voter       The address of the voter whose reward balance is to be returned\n', "  @param _challengeID The ID of the challenge the voter's reward is being calculated for\n", "  @param _salt        The salt of the voter's commit hash in the given poll\n", "  @return             The uint indicating the voter's reward\n", '  */\n', '  function voterReward(address _voter, uint _challengeID, uint _salt)\n', '  public view returns (uint) {\n', '    uint winningTokens = challenges[_challengeID].winningTokens;\n', '    uint rewardPool = challenges[_challengeID].rewardPool;\n', '    uint voterTokens = voting.getNumPassingTokens(_voter, _challengeID, _salt);\n', '    return (voterTokens * rewardPool) / winningTokens;\n', '  }\n', '\n', '  /**\n', '  @notice Determines whether a proposal passed its application stage without a challenge\n', '  @param _propID The proposal ID for which to determine whether its application stage passed without a challenge\n', '  */\n', '  function canBeSet(bytes32 _propID) view public returns (bool) {\n', '    ParamProposal memory prop = proposals[_propID];\n', '\n', '    return (now > prop.appExpiry && now < prop.processBy && prop.challengeID == 0);\n', '  }\n', '\n', '  /**\n', '  @notice Determines whether a proposal exists for the provided proposal ID\n', '  @param _propID The proposal ID whose existance is to be determined\n', '  */\n', '  function propExists(bytes32 _propID) view public returns (bool) {\n', '    return proposals[_propID].processBy > 0;\n', '  }\n', '\n', '  /**\n', '  @notice Determines whether the provided proposal ID has a challenge which can be resolved\n', '  @param _propID The proposal ID whose challenge to inspect\n', '  */\n', '  function challengeCanBeResolved(bytes32 _propID) view public returns (bool) {\n', '    ParamProposal memory prop = proposals[_propID];\n', '    Challenge memory challenge = challenges[prop.challengeID];\n', '\n', '    return (prop.challengeID > 0 && challenge.resolved == false &&\n', '            voting.pollEnded(prop.challengeID));\n', '  }\n', '\n', '  /**\n', '  @notice Determines the number of tokens to awarded to the winning party in a challenge\n', '  @param _challengeID The challengeID to determine a reward for\n', '  */\n', '  function challengeWinnerReward(uint _challengeID) public view returns (uint) {\n', '    if(voting.getTotalNumberOfTokensForWinningOption(_challengeID) == 0) {\n', '      // Edge case, nobody voted, give all tokens to the challenger.\n', '      return 2 * challenges[_challengeID].stake;\n', '    }\n', '\n', '    return (2 * challenges[_challengeID].stake) - challenges[_challengeID].rewardPool;\n', '  }\n', '\n', '  /**\n', '  @notice gets the parameter keyed by the provided name value from the params mapping\n', '  @param _name the key whose value is to be determined\n', '  */\n', '  function get(string _name) public view returns (uint value) {\n', '    return params[keccak256(_name)];\n', '  }\n', '\n', '  /**\n', '  @dev                Getter for Challenge tokenClaims mappings\n', '  @param _challengeID The challengeID to query\n', '  @param _voter       The voter whose claim status to query for the provided challengeID\n', '  */\n', '  function tokenClaims(uint _challengeID, address _voter) public view returns (bool) {\n', '    return challenges[_challengeID].tokenClaims[_voter];\n', '  }\n', '\n', '  // ----------------\n', '  // PRIVATE FUNCTIONS\n', '  // ----------------\n', '\n', '  /**\n', '  @dev resolves a challenge for the provided _propID. It must be checked in advance whether the _propID has a challenge on it\n', '  @param _propID the proposal ID whose challenge is to be resolved.\n', '  */\n', '  function resolveChallenge(bytes32 _propID) private {\n', '    ParamProposal memory prop = proposals[_propID];\n', '    Challenge storage challenge = challenges[prop.challengeID];\n', '\n', "    // winner gets back their full staked deposit, and dispensationPct*loser's stake\n", '    uint reward = challengeWinnerReward(prop.challengeID);\n', '\n', '    challenge.winningTokens =\n', '      voting.getTotalNumberOfTokensForWinningOption(prop.challengeID);\n', '    challenge.resolved = true;\n', '\n', '    if (voting.isPassed(prop.challengeID)) { // The challenge failed\n', '      if(prop.processBy > now) {\n', '        set(prop.name, prop.value);\n', '      }\n', '      _ChallengeFailed(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);\n', '      require(token.transfer(prop.owner, reward));\n', '    }\n', '    else { // The challenge succeeded or nobody voted\n', '      _ChallengeSucceeded(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);\n', '      require(token.transfer(challenges[prop.challengeID].challenger, reward));\n', '    }\n', '  }\n', '\n', '  /**\n', '  @dev sets the param keted by the provided name to the provided value\n', '  @param _name the name of the param to be set\n', '  @param _value the value to set the param to be set\n', '  */\n', '  function set(string _name, uint _value) private {\n', '    params[keccak256(_name)] = _value;\n', '  }\n', '}\n', '\n', '// File: contracts/Registry.sol\n', '\n', 'contract Registry {\n', '\n', '    // ------\n', '    // EVENTS\n', '    // ------\n', '\n', '    event _Application(bytes32 indexed listingHash, uint deposit, uint appEndDate, string data, address indexed applicant);\n', '    event _Challenge(bytes32 indexed listingHash, uint challengeID, string data, uint commitEndDate, uint revealEndDate, address indexed challenger);\n', '    event _Deposit(bytes32 indexed listingHash, uint added, uint newTotal, address indexed owner);\n', '    event _Withdrawal(bytes32 indexed listingHash, uint withdrew, uint newTotal, address indexed owner);\n', '    event _ApplicationWhitelisted(bytes32 indexed listingHash);\n', '    event _ApplicationRemoved(bytes32 indexed listingHash);\n', '    event _ListingRemoved(bytes32 indexed listingHash);\n', '    event _ListingWithdrawn(bytes32 indexed listingHash);\n', '    event _TouchAndRemoved(bytes32 indexed listingHash);\n', '    event _ChallengeFailed(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens);\n', '    event _ChallengeSucceeded(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens);\n', '    event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter);\n', '\n', '    using SafeMath for uint;\n', '\n', '    struct Listing {\n', '        uint applicationExpiry; // Expiration date of apply stage\n', '        bool whitelisted;       // Indicates registry status\n', '        address owner;          // Owner of Listing\n', '        uint unstakedDeposit;   // Number of tokens in the listing not locked in a challenge\n', '        uint challengeID;       // Corresponds to a PollID in PLCRVoting\n', '    }\n', '\n', '    struct Challenge {\n', '        uint rewardPool;        // (remaining) Pool of tokens to be distributed to winning voters\n', '        address challenger;     // Owner of Challenge\n', '        bool resolved;          // Indication of if challenge is resolved\n', '        uint stake;             // Number of tokens at stake for either party during challenge\n', '        uint totalTokens;       // (remaining) Number of tokens used in voting by the winning side\n', '        mapping(address => bool) tokenClaims; // Indicates whether a voter has claimed a reward yet\n', '    }\n', '\n', '    // Maps challengeIDs to associated challenge data\n', '    mapping(uint => Challenge) public challenges;\n', '\n', '    // Maps listingHashes to associated listingHash data\n', '    mapping(bytes32 => Listing) public listings;\n', '\n', '    // Global Variables\n', '    EIP20Interface public token;\n', '    PLCRVoting public voting;\n', '    Parameterizer public parameterizer;\n', '    string public name;\n', '\n', '    // ------------\n', '    // CONSTRUCTOR:\n', '    // ------------\n', '\n', '    /**\n', '    @dev Contructor         Sets the addresses for token, voting, and parameterizer\n', "    @param _tokenAddr       Address of the TCR's intrinsic ERC20 token\n", '    @param _plcrAddr        Address of a PLCR voting contract for the provided token\n', '    @param _paramsAddr      Address of a Parameterizer contract \n', '    */\n', '    function Registry(\n', '        address _tokenAddr,\n', '        address _plcrAddr,\n', '        address _paramsAddr,\n', '        string _name\n', '    ) public {\n', '        token = EIP20Interface(_tokenAddr);\n', '        voting = PLCRVoting(_plcrAddr);\n', '        parameterizer = Parameterizer(_paramsAddr);\n', '        name = _name;\n', '    }\n', '\n', '    // --------------------\n', '    // PUBLISHER INTERFACE:\n', '    // --------------------\n', '\n', '    /**\n', '    @dev                Allows a user to start an application. Takes tokens from user and sets\n', '                        apply stage end time.\n', '    @param _listingHash The hash of a potential listing a user is applying to add to the registry\n', '    @param _amount      The number of ERC20 tokens a user is willing to potentially stake\n', '    @param _data        Extra data relevant to the application. Think IPFS hashes.\n', '    */\n', '    function apply(bytes32 _listingHash, uint _amount, string _data) external {\n', '        require(!isWhitelisted(_listingHash));\n', '        require(!appWasMade(_listingHash));\n', '        require(_amount >= parameterizer.get("minDeposit"));\n', '\n', '        // Sets owner\n', '        Listing storage listing = listings[_listingHash];\n', '        listing.owner = msg.sender;\n', '\n', '        // Sets apply stage end time\n', '        listing.applicationExpiry = block.timestamp.add(parameterizer.get("applyStageLen"));\n', '        listing.unstakedDeposit = _amount;\n', '\n', '        // Transfers tokens from user to Registry contract\n', '        require(token.transferFrom(listing.owner, this, _amount));\n', '\n', '        _Application(_listingHash, _amount, listing.applicationExpiry, _data, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev                Allows the owner of a listingHash to increase their unstaked deposit.\n', '    @param _listingHash A listingHash msg.sender is the owner of\n', "    @param _amount      The number of ERC20 tokens to increase a user's unstaked deposit\n", '    */\n', '    function deposit(bytes32 _listingHash, uint _amount) external {\n', '        Listing storage listing = listings[_listingHash];\n', '\n', '        require(listing.owner == msg.sender);\n', '\n', '        listing.unstakedDeposit += _amount;\n', '        require(token.transferFrom(msg.sender, this, _amount));\n', '\n', '        _Deposit(_listingHash, _amount, listing.unstakedDeposit, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev                Allows the owner of a listingHash to decrease their unstaked deposit.\n', '    @param _listingHash A listingHash msg.sender is the owner of.\n', '    @param _amount      The number of ERC20 tokens to withdraw from the unstaked deposit.\n', '    */\n', '    function withdraw(bytes32 _listingHash, uint _amount) external {\n', '        Listing storage listing = listings[_listingHash];\n', '\n', '        require(listing.owner == msg.sender);\n', '        require(_amount <= listing.unstakedDeposit);\n', '        require(listing.unstakedDeposit - _amount >= parameterizer.get("minDeposit"));\n', '\n', '        listing.unstakedDeposit -= _amount;\n', '        require(token.transfer(msg.sender, _amount));\n', '\n', '        _Withdrawal(_listingHash, _amount, listing.unstakedDeposit, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev                Allows the owner of a listingHash to remove the listingHash from the whitelist\n', '                        Returns all tokens to the owner of the listingHash\n', '    @param _listingHash A listingHash msg.sender is the owner of.\n', '    */\n', '    function exit(bytes32 _listingHash) external {\n', '        Listing storage listing = listings[_listingHash];\n', '\n', '        require(msg.sender == listing.owner);\n', '        require(isWhitelisted(_listingHash));\n', '\n', '        // Cannot exit during ongoing challenge\n', '        require(listing.challengeID == 0 || challenges[listing.challengeID].resolved);\n', '\n', '        // Remove listingHash & return tokens\n', '        resetListing(_listingHash);\n', '        _ListingWithdrawn(_listingHash);\n', '    }\n', '\n', '    // -----------------------\n', '    // TOKEN HOLDER INTERFACE:\n', '    // -----------------------\n', '\n', '    /**\n', '    @dev                Starts a poll for a listingHash which is either in the apply stage or\n', '                        already in the whitelist. Tokens are taken from the challenger and the\n', "                        applicant's deposits are locked.\n", '    @param _listingHash The listingHash being challenged, whether listed or in application\n', '    @param _data        Extra data relevant to the challenge. Think IPFS hashes.\n', '    */\n', '    function challenge(bytes32 _listingHash, string _data) external returns (uint challengeID) {\n', '        Listing storage listing = listings[_listingHash];\n', '        uint deposit = parameterizer.get("minDeposit");\n', '\n', '        // Listing must be in apply stage or already on the whitelist\n', '        require(appWasMade(_listingHash) || listing.whitelisted);\n', '        // Prevent multiple challenges\n', '        require(listing.challengeID == 0 || challenges[listing.challengeID].resolved);\n', '\n', '        if (listing.unstakedDeposit < deposit) {\n', '            // Not enough tokens, listingHash auto-delisted\n', '            resetListing(_listingHash);\n', '            _TouchAndRemoved(_listingHash);\n', '            return 0;\n', '        }\n', '\n', '        // Starts poll\n', '        uint pollID = voting.startPoll(\n', '            parameterizer.get("voteQuorum"),\n', '            parameterizer.get("commitStageLen"),\n', '            parameterizer.get("revealStageLen")\n', '        );\n', '\n', '        challenges[pollID] = Challenge({\n', '            challenger: msg.sender,\n', '            rewardPool: ((100 - parameterizer.get("dispensationPct")) * deposit) / 100,\n', '            stake: deposit,\n', '            resolved: false,\n', '            totalTokens: 0\n', '        });\n', '\n', '        // Updates listingHash to store most recent challenge\n', '        listing.challengeID = pollID;\n', '\n', '        // Locks tokens for listingHash during challenge\n', '        listing.unstakedDeposit -= deposit;\n', '\n', '        // Takes tokens from challenger\n', '        require(token.transferFrom(msg.sender, this, deposit));\n', '\n', '        var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);\n', '\n', '        _Challenge(_listingHash, pollID, _data, commitEndDate, revealEndDate, msg.sender);\n', '        return pollID;\n', '    }\n', '\n', '    /**\n', "    @dev                Updates a listingHash's status from 'application' to 'listing' or resolves\n", '                        a challenge if one exists.\n', '    @param _listingHash The listingHash whose status is being updated\n', '    */\n', '    function updateStatus(bytes32 _listingHash) public {\n', '        if (canBeWhitelisted(_listingHash)) {\n', '          whitelistApplication(_listingHash);\n', '        } else if (challengeCanBeResolved(_listingHash)) {\n', '          resolveChallenge(_listingHash);\n', '        } else {\n', '          revert();\n', '        }\n', '    }\n', '\n', '    // ----------------\n', '    // TOKEN FUNCTIONS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev                Called by a voter to claim their reward for each completed vote. Someone\n', '                        must call updateStatus() before this can be called.\n', '    @param _challengeID The PLCR pollID of the challenge a reward is being claimed for\n', "    @param _salt        The salt of a voter's commit hash in the given poll\n", '    */\n', '    function claimReward(uint _challengeID, uint _salt) public {\n', '        // Ensures the voter has not already claimed tokens and challenge results have been processed\n', '        require(challenges[_challengeID].tokenClaims[msg.sender] == false);\n', '        require(challenges[_challengeID].resolved == true);\n', '\n', '        uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID, _salt);\n', '        uint reward = voterReward(msg.sender, _challengeID, _salt);\n', '\n', "        // Subtracts the voter's information to preserve the participation ratios\n", '        // of other voters compared to the remaining pool of rewards\n', '        challenges[_challengeID].totalTokens -= voterTokens;\n', '        challenges[_challengeID].rewardPool -= reward;\n', '\n', '        // Ensures a voter cannot claim tokens again\n', '        challenges[_challengeID].tokenClaims[msg.sender] = true;\n', '\n', '        require(token.transfer(msg.sender, reward));\n', '\n', '        _RewardClaimed(_challengeID, reward, msg.sender);\n', '    }\n', '\n', '    // --------\n', '    // GETTERS:\n', '    // --------\n', '\n', '    /**\n', "    @dev                Calculates the provided voter's token reward for the given poll.\n", '    @param _voter       The address of the voter whose reward balance is to be returned\n', '    @param _challengeID The pollID of the challenge a reward balance is being queried for\n', "    @param _salt        The salt of the voter's commit hash in the given poll\n", "    @return             The uint indicating the voter's reward\n", '    */\n', '    function voterReward(address _voter, uint _challengeID, uint _salt)\n', '    public view returns (uint) {\n', '        uint totalTokens = challenges[_challengeID].totalTokens;\n', '        uint rewardPool = challenges[_challengeID].rewardPool;\n', '        uint voterTokens = voting.getNumPassingTokens(_voter, _challengeID, _salt);\n', '        return (voterTokens * rewardPool) / totalTokens;\n', '    }\n', '\n', '    /**\n', '    @dev                Determines whether the given listingHash be whitelisted.\n', '    @param _listingHash The listingHash whose status is to be examined\n', '    */\n', '    function canBeWhitelisted(bytes32 _listingHash) view public returns (bool) {\n', '        uint challengeID = listings[_listingHash].challengeID;\n', '\n', '        // Ensures that the application was made,\n', '        // the application period has ended,\n', '        // the listingHash can be whitelisted,\n', '        // and either: the challengeID == 0, or the challenge has been resolved.\n', '        if (\n', '            appWasMade(_listingHash) &&\n', '            listings[_listingHash].applicationExpiry < now &&\n', '            !isWhitelisted(_listingHash) &&\n', '            (challengeID == 0 || challenges[challengeID].resolved == true)\n', '        ) { return true; }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '    @dev                Returns true if the provided listingHash is whitelisted\n', '    @param _listingHash The listingHash whose status is to be examined\n', '    */\n', '    function isWhitelisted(bytes32 _listingHash) view public returns (bool whitelisted) {\n', '        return listings[_listingHash].whitelisted;\n', '    }\n', '\n', '    /**\n', '    @dev                Returns true if apply was called for this listingHash\n', '    @param _listingHash The listingHash whose status is to be examined\n', '    */\n', '    function appWasMade(bytes32 _listingHash) view public returns (bool exists) {\n', '        return listings[_listingHash].applicationExpiry > 0;\n', '    }\n', '\n', '    /**\n', '    @dev                Returns true if the application/listingHash has an unresolved challenge\n', '    @param _listingHash The listingHash whose status is to be examined\n', '    */\n', '    function challengeExists(bytes32 _listingHash) view public returns (bool) {\n', '        uint challengeID = listings[_listingHash].challengeID;\n', '\n', '        return (listings[_listingHash].challengeID > 0 && !challenges[challengeID].resolved);\n', '    }\n', '\n', '    /**\n', '    @dev                Determines whether voting has concluded in a challenge for a given\n', '                        listingHash. Throws if no challenge exists.\n', '    @param _listingHash A listingHash with an unresolved challenge\n', '    */\n', '    function challengeCanBeResolved(bytes32 _listingHash) view public returns (bool) {\n', '        uint challengeID = listings[_listingHash].challengeID;\n', '\n', '        require(challengeExists(_listingHash));\n', '\n', '        return voting.pollEnded(challengeID);\n', '    }\n', '\n', '    /**\n', '    @dev                Determines the number of tokens awarded to the winning party in a challenge.\n', '    @param _challengeID The challengeID to determine a reward for\n', '    */\n', '    function determineReward(uint _challengeID) public view returns (uint) {\n', '        require(!challenges[_challengeID].resolved && voting.pollEnded(_challengeID));\n', '\n', '        // Edge case, nobody voted, give all tokens to the challenger.\n', '        if (voting.getTotalNumberOfTokensForWinningOption(_challengeID) == 0) {\n', '            return 2 * challenges[_challengeID].stake;\n', '        }\n', '\n', '        return (2 * challenges[_challengeID].stake) - challenges[_challengeID].rewardPool;\n', '    }\n', '\n', '    /**\n', '    @dev                Getter for Challenge tokenClaims mappings\n', '    @param _challengeID The challengeID to query\n', '    @param _voter       The voter whose claim status to query for the provided challengeID\n', '    */\n', '    function tokenClaims(uint _challengeID, address _voter) public view returns (bool) {\n', '      return challenges[_challengeID].tokenClaims[_voter];\n', '    }\n', '\n', '    // ----------------\n', '    // PRIVATE FUNCTIONS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev                Determines the winner in a challenge. Rewards the winner tokens and\n', '                        either whitelists or de-whitelists the listingHash.\n', '    @param _listingHash A listingHash with a challenge that is to be resolved\n', '    */\n', '    function resolveChallenge(bytes32 _listingHash) private {\n', '        uint challengeID = listings[_listingHash].challengeID;\n', '\n', "        // Calculates the winner's reward,\n", "        // which is: (winner's full stake) + (dispensationPct * loser's stake)\n", '        uint reward = determineReward(challengeID);\n', '\n', '        // Sets flag on challenge being processed\n', '        challenges[challengeID].resolved = true;\n', '\n', '        // Stores the total tokens used for voting by the winning side for reward purposes\n', '        challenges[challengeID].totalTokens =\n', '            voting.getTotalNumberOfTokensForWinningOption(challengeID);\n', '\n', '        // Case: challenge failed\n', '        if (voting.isPassed(challengeID)) {\n', '            whitelistApplication(_listingHash);\n', '            // Unlock stake so that it can be retrieved by the applicant\n', '            listings[_listingHash].unstakedDeposit += reward;\n', '\n', '            _ChallengeFailed(_listingHash, challengeID, challenges[challengeID].rewardPool, challenges[challengeID].totalTokens);\n', '        }\n', '        // Case: challenge succeeded or nobody voted\n', '        else {\n', '            resetListing(_listingHash);\n', '            // Transfer the reward to the challenger\n', '            require(token.transfer(challenges[challengeID].challenger, reward));\n', '\n', '            _ChallengeSucceeded(_listingHash, challengeID, challenges[challengeID].rewardPool, challenges[challengeID].totalTokens);\n', '        }\n', '    }\n', '\n', '    /**\n', '    @dev                Called by updateStatus() if the applicationExpiry date passed without a\n', '                        challenge being made. Called by resolveChallenge() if an\n', '                        application/listing beat a challenge.\n', '    @param _listingHash The listingHash of an application/listingHash to be whitelisted\n', '    */\n', '    function whitelistApplication(bytes32 _listingHash) private {\n', '        if (!listings[_listingHash].whitelisted) { _ApplicationWhitelisted(_listingHash); }\n', '        listings[_listingHash].whitelisted = true;\n', '    }\n', '\n', '    /**\n', '    @dev                Deletes a listingHash from the whitelist and transfers tokens back to owner\n', '    @param _listingHash The listing hash to delete\n', '    */\n', '    function resetListing(bytes32 _listingHash) private {\n', '        Listing storage listing = listings[_listingHash];\n', '\n', '        // Emit events before deleting listing to check whether is whitelisted\n', '        if (listing.whitelisted) {\n', '            _ListingRemoved(_listingHash);\n', '        } else {\n', '            _ApplicationRemoved(_listingHash);\n', '        }\n', '\n', '        // Deleting listing to prevent reentry\n', '        address owner = listing.owner;\n', '        uint unstakedDeposit = listing.unstakedDeposit;\n', '        delete listings[_listingHash];\n', '        \n', '        // Transfers any remaining balance back to the owner\n', '        if (unstakedDeposit > 0){\n', '            require(token.transfer(owner, unstakedDeposit));\n', '        }\n', '    }\n', '}']
