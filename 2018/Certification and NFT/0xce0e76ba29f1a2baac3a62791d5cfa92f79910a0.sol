['pragma solidity 0.4.24;\n', '\n', '// File: contracts/ds-auth/auth.sol\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.4.24;\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/AssetPriceOracle.sol\n', '\n', 'contract AssetPriceOracle is DSAuth {\n', '    // Maximum value expressible with uint128 is 340282366920938463463374607431768211456.\n', '    // Using 18 decimals for price records (standard Ether precision), \n', '    // the possible values are between 0 and 340282366920938463463.374607431768211456.\n', '\n', '    struct AssetPriceRecord {\n', '        uint128 price;\n', '        bool isRecord;\n', '    }\n', '\n', '    mapping(uint128 => mapping(uint128 => AssetPriceRecord)) public assetPriceRecords;\n', '\n', '    event AssetPriceRecorded(\n', '        uint128 indexed assetId,\n', '        uint128 indexed blockNumber,\n', '        uint128 indexed price\n', '    );\n', '\n', '    constructor() public {\n', '    }\n', '    \n', '    function recordAssetPrice(uint128 assetId, uint128 blockNumber, uint128 price) public auth {\n', '        assetPriceRecords[assetId][blockNumber].price = price;\n', '        assetPriceRecords[assetId][blockNumber].isRecord = true;\n', '        emit AssetPriceRecorded(assetId, blockNumber, price);\n', '    }\n', '\n', '    function getAssetPrice(uint128 assetId, uint128 blockNumber) public view returns (uint128 price) {\n', '        AssetPriceRecord storage priceRecord = assetPriceRecords[assetId][blockNumber];\n', '        require(priceRecord.isRecord);\n', '        return priceRecord.price;\n', '    }\n', '\n', '    function () public {\n', '        // dont receive ether via fallback method (by not having &#39;payable&#39; modifier on this function).\n', '    }\n', '}\n', '\n', '// File: contracts/lib/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' * Source: https://github.com/facuspagnuolo/zeppelin-solidity/blob/feature/705_add_safe_math_int_ops/contracts/math/SafeMath.sol\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two unsigned integers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Multiplies two signed integers, throws on overflow.\n', '  */\n', '  function mul(int256 a, int256 b) internal pure returns (int256) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    int256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two unsigned integers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two signed integers, truncating the quotient.\n', '  */\n', '  function div(int256 a, int256 b) internal pure returns (int256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // Overflow only happens when the smallest negative int is multiplied by -1.\n', '    int256 INT256_MIN = int256((uint256(1) << 255));\n', '    assert(a != INT256_MIN || b != -1);\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two unsigned integers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two signed integers, throws on overflow.\n', '  */\n', '  function sub(int256 a, int256 b) internal pure returns (int256) {\n', '    int256 c = a - b;\n', '    assert((b >= 0 && c <= a) || (b < 0 && c > a));\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two unsigned integers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two signed integers, throws on overflow.\n', '  */\n', '  function add(int256 a, int256 b) internal pure returns (int256) {\n', '    int256 c = a + b;\n', '    assert((b >= 0 && c >= a) || (b < 0 && c < a));\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/ContractForDifference.sol\n', '\n', 'contract ContractForDifference is DSAuth {\n', '    using SafeMath for int256;\n', '\n', '    enum Position { Long, Short }\n', '    \n', '    /**\n', '     * A party to the contract. Either the maker or the taker.\n', '     */\n', '    struct Party {\n', '        address addr;\n', '        uint128 withdrawBalance; // Amount the Party can withdraw, as a result of settled contract.\n', '        Position position;\n', '        bool isPaid;\n', '    }\n', '    \n', '    struct Cfd {\n', '        Party maker;\n', '        Party taker;\n', '\n', '        uint128 assetId;\n', '        uint128 amount; // in Wei.\n', '        uint128 contractStartBlock; // Block number\n', '        uint128 contractEndBlock; // Block number\n', '\n', '        // CFD state variables\n', '        bool isTaken;\n', '        bool isSettled;\n', '        bool isRefunded;\n', '    }\n', '\n', '    uint128 public leverage = 1; // Global leverage of the CFD contract.\n', '    AssetPriceOracle public priceOracle;\n', '\n', '    mapping(uint128 => Cfd) public contracts;\n', '    uint128                 public numberOfContracts;\n', '\n', '    event LogMakeCfd (\n', '    uint128 indexed cfdId, \n', '    address indexed makerAddress, \n', '    Position indexed makerPosition,\n', '    uint128 assetId,\n', '    uint128 amount,\n', '    uint128 contractEndBlock);\n', '\n', '    event LogTakeCfd (\n', '    uint128 indexed cfdId,\n', '    address indexed makerAddress,\n', '    Position makerPosition,\n', '    address indexed takerAddress,\n', '    Position takerPosition,\n', '    uint128 assetId,\n', '    uint128 amount,\n', '    uint128 contractStartBlock,\n', '    uint128 contractEndBlock);\n', '\n', '    event LogCfdSettled (\n', '    uint128 indexed cfdId,\n', '    address indexed makerAddress,\n', '    address indexed takerAddress,\n', '    uint128 amount,\n', '    uint128 startPrice,\n', '    uint128 endPrice,\n', '    uint128 makerSettlement,\n', '    uint128 takerSettlement);\n', '\n', '    event LogCfdRefunded (\n', '    uint128 indexed cfdId,\n', '    address indexed makerAddress,\n', '    uint128 amount);\n', '\n', '    event LogCfdForceRefunded (\n', '    uint128 indexed cfdId,\n', '    address indexed makerAddress,\n', '    uint128 makerAmount,\n', '    address indexed takerAddress,\n', '    uint128 takerAmount);\n', '\n', '    event LogWithdrawal (\n', '    uint128 indexed cfdId,\n', '    address indexed withdrawalAddress,\n', '    uint128 amount);\n', '\n', '    // event Debug (\n', '    //     string description,\n', '    //     uint128 uintValue,\n', '    //     int128 intValue\n', '    // );\n', '\n', '    constructor(address priceOracleAddress) public {\n', '        priceOracle = AssetPriceOracle(priceOracleAddress);\n', '    }\n', '\n', '    function makeCfd(\n', '        address makerAddress,\n', '        uint128 assetId,\n', '        Position makerPosition,\n', '        uint128 contractEndBlock\n', '        )\n', '        public\n', '        payable\n', '        returns (uint128)\n', '    {\n', '        require(contractEndBlock > block.number); // Contract end block must be after current block.\n', '        require(msg.value > 0); // Contract Wei amount must be more than zero - contracts for zero Wei does not make sense.\n', '        require(makerAddress != address(0)); // Maker must provide a non-zero address.\n', '        \n', '        uint128 contractId = numberOfContracts;\n', '\n', '        /**\n', '         * Initialize CFD struct using tight variable packing pattern.\n', '         * See https://fravoll.github.io/solidity-patterns/tight_variable_packing.html\n', '         */\n', '        Party memory maker = Party(makerAddress, 0, makerPosition, false);\n', '        Party memory taker = Party(address(0), 0, Position.Long, false);\n', '        Cfd memory newCfd = Cfd(\n', '            maker,\n', '            taker,\n', '            assetId,\n', '            uint128(msg.value),\n', '            0,\n', '            contractEndBlock,\n', '            false,\n', '            false,\n', '            false\n', '        );\n', '\n', '        contracts[contractId] = newCfd;\n', '\n', '        // contracts[contractId].maker.addr = makerAddress;\n', '        // contracts[contractId].maker.position = makerPosition;\n', '        // contracts[contractId].assetId = assetId;\n', '        // contracts[contractId].amount = uint128(msg.value);\n', '        // contracts[contractId].contractEndBlock = contractEndBlock;\n', '\n', '        numberOfContracts++;\n', '        \n', '        emit LogMakeCfd(\n', '            contractId,\n', '            contracts[contractId].maker.addr,\n', '            contracts[contractId].maker.position,\n', '            contracts[contractId].assetId,\n', '            contracts[contractId].amount,\n', '            contracts[contractId].contractEndBlock\n', '        );\n', '\n', '        return contractId;\n', '    }\n', '\n', '    function getCfd(\n', '        uint128 cfdId\n', '        ) \n', '        public \n', '        view \n', '        returns (address makerAddress, Position makerPosition, address takerAddress, Position takerPosition, uint128 assetId, uint128 amount, uint128 startTime, uint128 endTime, bool isTaken, bool isSettled, bool isRefunded)\n', '        {\n', '        Cfd storage cfd = contracts[cfdId];\n', '        return (\n', '            cfd.maker.addr,\n', '            cfd.maker.position,\n', '            cfd.taker.addr,\n', '            cfd.taker.position,\n', '            cfd.assetId,\n', '            cfd.amount,\n', '            cfd.contractStartBlock,\n', '            cfd.contractEndBlock,\n', '            cfd.isTaken,\n', '            cfd.isSettled,\n', '            cfd.isRefunded\n', '        );\n', '    }\n', '\n', '    function takeCfd(\n', '        uint128 cfdId, \n', '        address takerAddress\n', '        ) \n', '        public\n', '        payable\n', '        returns (bool success) {\n', '        Cfd storage cfd = contracts[cfdId];\n', '        \n', '        require(cfd.isTaken != true);                  // Contract must not be taken.\n', '        require(cfd.isSettled != true);                // Contract must not be settled.\n', '        require(cfd.isRefunded != true);               // Contract must not be refunded.\n', '        require(cfd.maker.addr != address(0));         // Contract must have a maker,\n', '        require(cfd.taker.addr == address(0));         // and no taker.\n', '        // require(takerAddress != cfd.maker.addr);       // Maker and Taker must not be the same address. (disabled for now)\n', '        require(msg.value == cfd.amount);              // Takers deposit must match makers deposit.\n', '        require(takerAddress != address(0));           // Taker must provide a non-zero address.\n', '        require(block.number <= cfd.contractEndBlock); // Taker must take contract before end block.\n', '\n', '        cfd.taker.addr = takerAddress;\n', '        // Make taker position the inverse of maker position\n', '        cfd.taker.position = cfd.maker.position == Position.Long ? Position.Short : Position.Long;\n', '        cfd.contractStartBlock = uint128(block.number);\n', '        cfd.isTaken = true;\n', '\n', '        emit LogTakeCfd(\n', '            cfdId,\n', '            cfd.maker.addr,\n', '            cfd.maker.position,\n', '            cfd.taker.addr,\n', '            cfd.taker.position,\n', '            cfd.assetId,\n', '            cfd.amount,\n', '            cfd.contractStartBlock,\n', '            cfd.contractEndBlock\n', '        );\n', '            \n', '        return true;\n', '    }\n', '\n', '    function settleAndWithdrawCfd(\n', '        uint128 cfdId\n', '        )\n', '        public {\n', '        address makerAddr = contracts[cfdId].maker.addr;\n', '        address takerAddr = contracts[cfdId].taker.addr;\n', '\n', '        settleCfd(cfdId);\n', '        withdraw(cfdId, makerAddr);\n', '        withdraw(cfdId, takerAddr);\n', '    }\n', '\n', '    function settleCfd(\n', '        uint128 cfdId\n', '        )\n', '        public\n', '        returns (bool success) {\n', '        Cfd storage cfd = contracts[cfdId];\n', '\n', '        require(cfd.contractEndBlock <= block.number); // Contract must have met its end time.\n', '        require(!cfd.isSettled);                       // Contract must not be settled already.\n', '        require(!cfd.isRefunded);                      // Contract must not be refunded.\n', '        require(cfd.isTaken);                          // Contract must be taken.\n', '        require(cfd.maker.addr != address(0));         // Contract must have a maker address.\n', '        require(cfd.taker.addr != address(0));         // Contract must have a taker address.\n', '\n', '        // Get relevant variables\n', '        uint128 amount = cfd.amount;\n', '        uint128 startPrice = priceOracle.getAssetPrice(cfd.assetId, cfd.contractStartBlock);\n', '        uint128 endPrice = priceOracle.getAssetPrice(cfd.assetId, cfd.contractEndBlock);\n', '\n', '        /**\n', '         * Register settlements for maker and taker.\n', '         * Maker recieves any leftover wei from integer division.\n', '         */\n', '        uint128 takerSettlement = getSettlementAmount(amount, startPrice, endPrice, cfd.taker.position);\n', '        if (takerSettlement > 0) {\n', '            cfd.taker.withdrawBalance = takerSettlement;\n', '        }\n', '\n', '        uint128 makerSettlement = (amount * 2) - takerSettlement;\n', '        cfd.maker.withdrawBalance = makerSettlement;\n', '\n', '        // Mark contract as settled.\n', '        cfd.isSettled = true;\n', '\n', '        emit LogCfdSettled (\n', '            cfdId,\n', '            cfd.maker.addr,\n', '            cfd.taker.addr,\n', '            amount,\n', '            startPrice,\n', '            endPrice,\n', '            makerSettlement,\n', '            takerSettlement\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdraw(\n', '        uint128 cfdId, \n', '        address partyAddress\n', '    )\n', '    public {\n', '        Cfd storage cfd = contracts[cfdId];\n', '        Party storage party = partyAddress == cfd.maker.addr ? cfd.maker : cfd.taker;\n', '        require(party.withdrawBalance > 0); // The party must have a withdraw balance from previous settlement.\n', '        require(!party.isPaid); // The party must have already been paid out, fx from a refund.\n', '        \n', '        uint128 amount = party.withdrawBalance;\n', '        party.withdrawBalance = 0;\n', '        party.isPaid = true;\n', '        \n', '        party.addr.transfer(amount);\n', '\n', '        emit LogWithdrawal(\n', '            cfdId,\n', '            party.addr,\n', '            amount\n', '        );\n', '    }\n', '\n', '    function getSettlementAmount(\n', '        uint128 amountUInt,\n', '        uint128 entryPriceUInt,\n', '        uint128 exitPriceUInt,\n', '        Position position\n', '    )\n', '    public\n', '    view\n', '    returns (uint128) {\n', '        require(position == Position.Long || position == Position.Short);\n', '\n', '        // If price didn&#39;t change, settle for equal amount to long and short.\n', '        if (entryPriceUInt == exitPriceUInt) {return amountUInt;}\n', '\n', '        // If entry price is 0 and exit price is more than 0, all must go to long position and nothing to short.\n', '        if (entryPriceUInt == 0 && exitPriceUInt > 0) {\n', '            return position == Position.Long ? amountUInt * 2 : 0;\n', '        }\n', '\n', '        // Cast uint128 to int256 to support negative numbers and increase over- and underflow limits\n', '        int256 entryPrice = int256(entryPriceUInt);\n', '        int256 exitPrice = int256(exitPriceUInt);\n', '        int256 amount = int256(amountUInt);\n', '\n', '        // Price diff calc depends on which position we are calculating settlement for.\n', '        int256 priceDiff = position == Position.Long ? exitPrice.sub(entryPrice) : entryPrice.sub(exitPrice);\n', '        int256 settlement = amount.add(priceDiff.mul(amount).mul(leverage).div(entryPrice));\n', '        if (settlement < 0) {\n', '            return 0; // Calculated settlement was negative. But a party can&#39;t lose more than his deposit, so he&#39;s just awarded 0.\n', '        } else if (settlement > amount * 2) {\n', '            return amountUInt * 2; // Calculated settlement was more than the total deposits, so settle for the total deposits.\n', '        } else {\n', '            return uint128(settlement); // Settlement was more than zero and less than sum of deposit amounts, so we can settle it as is.\n', '        }\n', '    }\n', '\n', '    function refundCfd(\n', '        uint128 cfdId\n', '    )\n', '    public\n', '    returns (bool success) {\n', '        Cfd storage cfd = contracts[cfdId];\n', '        require(!cfd.isSettled);                // Contract must not be settled already.\n', '        require(!cfd.isTaken);                  // Contract must not be taken.\n', '        require(!cfd.isRefunded);               // Contract must not be refunded already.\n', '        require(msg.sender == cfd.maker.addr);  // Function caller must be the contract maker.\n', '\n', '        cfd.isRefunded = true;\n', '        cfd.maker.isPaid = true;\n', '        cfd.maker.addr.transfer(cfd.amount);\n', '\n', '        emit LogCfdRefunded(\n', '            cfdId,\n', '            cfd.maker.addr,\n', '            cfd.amount\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    function forceRefundCfd(\n', '        uint128 cfdId\n', '    )\n', '    public\n', '    auth\n', '    {\n', '        Cfd storage cfd = contracts[cfdId];\n', '        require(!cfd.isRefunded); // Contract must not be refunded already.\n', '\n', '        cfd.isRefunded = true;\n', '\n', '        // Refund Taker\n', '        uint128 takerAmount = 0;\n', '        if (cfd.taker.addr != address(0)) {\n', '            takerAmount = cfd.amount;\n', '            cfd.taker.withdrawBalance = 0; // Refunding must reset withdraw balance, if any.\n', '            cfd.taker.addr.transfer(cfd.amount);\n', '        }\n', '\n', '        // Refund Maker\n', '        cfd.maker.withdrawBalance = 0; // Refunding must reset withdraw balance, if any.\n', '        cfd.maker.addr.transfer(cfd.amount);\n', '        \n', '        emit LogCfdForceRefunded(\n', '            cfdId,\n', '            cfd.maker.addr,\n', '            cfd.amount,\n', '            cfd.taker.addr,\n', '            takerAmount\n', '        );\n', '    } \n', '\n', '    function () public {\n', '        // dont receive ether via fallback method (by not having &#39;payable&#39; modifier on this function).\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '// File: contracts/ds-auth/auth.sol\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.4.24;\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/AssetPriceOracle.sol\n', '\n', 'contract AssetPriceOracle is DSAuth {\n', '    // Maximum value expressible with uint128 is 340282366920938463463374607431768211456.\n', '    // Using 18 decimals for price records (standard Ether precision), \n', '    // the possible values are between 0 and 340282366920938463463.374607431768211456.\n', '\n', '    struct AssetPriceRecord {\n', '        uint128 price;\n', '        bool isRecord;\n', '    }\n', '\n', '    mapping(uint128 => mapping(uint128 => AssetPriceRecord)) public assetPriceRecords;\n', '\n', '    event AssetPriceRecorded(\n', '        uint128 indexed assetId,\n', '        uint128 indexed blockNumber,\n', '        uint128 indexed price\n', '    );\n', '\n', '    constructor() public {\n', '    }\n', '    \n', '    function recordAssetPrice(uint128 assetId, uint128 blockNumber, uint128 price) public auth {\n', '        assetPriceRecords[assetId][blockNumber].price = price;\n', '        assetPriceRecords[assetId][blockNumber].isRecord = true;\n', '        emit AssetPriceRecorded(assetId, blockNumber, price);\n', '    }\n', '\n', '    function getAssetPrice(uint128 assetId, uint128 blockNumber) public view returns (uint128 price) {\n', '        AssetPriceRecord storage priceRecord = assetPriceRecords[assetId][blockNumber];\n', '        require(priceRecord.isRecord);\n', '        return priceRecord.price;\n', '    }\n', '\n', '    function () public {\n', "        // dont receive ether via fallback method (by not having 'payable' modifier on this function).\n", '    }\n', '}\n', '\n', '// File: contracts/lib/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' * Source: https://github.com/facuspagnuolo/zeppelin-solidity/blob/feature/705_add_safe_math_int_ops/contracts/math/SafeMath.sol\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two unsigned integers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Multiplies two signed integers, throws on overflow.\n', '  */\n', '  function mul(int256 a, int256 b) internal pure returns (int256) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    int256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two unsigned integers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two signed integers, truncating the quotient.\n', '  */\n', '  function div(int256 a, int256 b) internal pure returns (int256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // Overflow only happens when the smallest negative int is multiplied by -1.\n', '    int256 INT256_MIN = int256((uint256(1) << 255));\n', '    assert(a != INT256_MIN || b != -1);\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two unsigned integers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two signed integers, throws on overflow.\n', '  */\n', '  function sub(int256 a, int256 b) internal pure returns (int256) {\n', '    int256 c = a - b;\n', '    assert((b >= 0 && c <= a) || (b < 0 && c > a));\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two unsigned integers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two signed integers, throws on overflow.\n', '  */\n', '  function add(int256 a, int256 b) internal pure returns (int256) {\n', '    int256 c = a + b;\n', '    assert((b >= 0 && c >= a) || (b < 0 && c < a));\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/ContractForDifference.sol\n', '\n', 'contract ContractForDifference is DSAuth {\n', '    using SafeMath for int256;\n', '\n', '    enum Position { Long, Short }\n', '    \n', '    /**\n', '     * A party to the contract. Either the maker or the taker.\n', '     */\n', '    struct Party {\n', '        address addr;\n', '        uint128 withdrawBalance; // Amount the Party can withdraw, as a result of settled contract.\n', '        Position position;\n', '        bool isPaid;\n', '    }\n', '    \n', '    struct Cfd {\n', '        Party maker;\n', '        Party taker;\n', '\n', '        uint128 assetId;\n', '        uint128 amount; // in Wei.\n', '        uint128 contractStartBlock; // Block number\n', '        uint128 contractEndBlock; // Block number\n', '\n', '        // CFD state variables\n', '        bool isTaken;\n', '        bool isSettled;\n', '        bool isRefunded;\n', '    }\n', '\n', '    uint128 public leverage = 1; // Global leverage of the CFD contract.\n', '    AssetPriceOracle public priceOracle;\n', '\n', '    mapping(uint128 => Cfd) public contracts;\n', '    uint128                 public numberOfContracts;\n', '\n', '    event LogMakeCfd (\n', '    uint128 indexed cfdId, \n', '    address indexed makerAddress, \n', '    Position indexed makerPosition,\n', '    uint128 assetId,\n', '    uint128 amount,\n', '    uint128 contractEndBlock);\n', '\n', '    event LogTakeCfd (\n', '    uint128 indexed cfdId,\n', '    address indexed makerAddress,\n', '    Position makerPosition,\n', '    address indexed takerAddress,\n', '    Position takerPosition,\n', '    uint128 assetId,\n', '    uint128 amount,\n', '    uint128 contractStartBlock,\n', '    uint128 contractEndBlock);\n', '\n', '    event LogCfdSettled (\n', '    uint128 indexed cfdId,\n', '    address indexed makerAddress,\n', '    address indexed takerAddress,\n', '    uint128 amount,\n', '    uint128 startPrice,\n', '    uint128 endPrice,\n', '    uint128 makerSettlement,\n', '    uint128 takerSettlement);\n', '\n', '    event LogCfdRefunded (\n', '    uint128 indexed cfdId,\n', '    address indexed makerAddress,\n', '    uint128 amount);\n', '\n', '    event LogCfdForceRefunded (\n', '    uint128 indexed cfdId,\n', '    address indexed makerAddress,\n', '    uint128 makerAmount,\n', '    address indexed takerAddress,\n', '    uint128 takerAmount);\n', '\n', '    event LogWithdrawal (\n', '    uint128 indexed cfdId,\n', '    address indexed withdrawalAddress,\n', '    uint128 amount);\n', '\n', '    // event Debug (\n', '    //     string description,\n', '    //     uint128 uintValue,\n', '    //     int128 intValue\n', '    // );\n', '\n', '    constructor(address priceOracleAddress) public {\n', '        priceOracle = AssetPriceOracle(priceOracleAddress);\n', '    }\n', '\n', '    function makeCfd(\n', '        address makerAddress,\n', '        uint128 assetId,\n', '        Position makerPosition,\n', '        uint128 contractEndBlock\n', '        )\n', '        public\n', '        payable\n', '        returns (uint128)\n', '    {\n', '        require(contractEndBlock > block.number); // Contract end block must be after current block.\n', '        require(msg.value > 0); // Contract Wei amount must be more than zero - contracts for zero Wei does not make sense.\n', '        require(makerAddress != address(0)); // Maker must provide a non-zero address.\n', '        \n', '        uint128 contractId = numberOfContracts;\n', '\n', '        /**\n', '         * Initialize CFD struct using tight variable packing pattern.\n', '         * See https://fravoll.github.io/solidity-patterns/tight_variable_packing.html\n', '         */\n', '        Party memory maker = Party(makerAddress, 0, makerPosition, false);\n', '        Party memory taker = Party(address(0), 0, Position.Long, false);\n', '        Cfd memory newCfd = Cfd(\n', '            maker,\n', '            taker,\n', '            assetId,\n', '            uint128(msg.value),\n', '            0,\n', '            contractEndBlock,\n', '            false,\n', '            false,\n', '            false\n', '        );\n', '\n', '        contracts[contractId] = newCfd;\n', '\n', '        // contracts[contractId].maker.addr = makerAddress;\n', '        // contracts[contractId].maker.position = makerPosition;\n', '        // contracts[contractId].assetId = assetId;\n', '        // contracts[contractId].amount = uint128(msg.value);\n', '        // contracts[contractId].contractEndBlock = contractEndBlock;\n', '\n', '        numberOfContracts++;\n', '        \n', '        emit LogMakeCfd(\n', '            contractId,\n', '            contracts[contractId].maker.addr,\n', '            contracts[contractId].maker.position,\n', '            contracts[contractId].assetId,\n', '            contracts[contractId].amount,\n', '            contracts[contractId].contractEndBlock\n', '        );\n', '\n', '        return contractId;\n', '    }\n', '\n', '    function getCfd(\n', '        uint128 cfdId\n', '        ) \n', '        public \n', '        view \n', '        returns (address makerAddress, Position makerPosition, address takerAddress, Position takerPosition, uint128 assetId, uint128 amount, uint128 startTime, uint128 endTime, bool isTaken, bool isSettled, bool isRefunded)\n', '        {\n', '        Cfd storage cfd = contracts[cfdId];\n', '        return (\n', '            cfd.maker.addr,\n', '            cfd.maker.position,\n', '            cfd.taker.addr,\n', '            cfd.taker.position,\n', '            cfd.assetId,\n', '            cfd.amount,\n', '            cfd.contractStartBlock,\n', '            cfd.contractEndBlock,\n', '            cfd.isTaken,\n', '            cfd.isSettled,\n', '            cfd.isRefunded\n', '        );\n', '    }\n', '\n', '    function takeCfd(\n', '        uint128 cfdId, \n', '        address takerAddress\n', '        ) \n', '        public\n', '        payable\n', '        returns (bool success) {\n', '        Cfd storage cfd = contracts[cfdId];\n', '        \n', '        require(cfd.isTaken != true);                  // Contract must not be taken.\n', '        require(cfd.isSettled != true);                // Contract must not be settled.\n', '        require(cfd.isRefunded != true);               // Contract must not be refunded.\n', '        require(cfd.maker.addr != address(0));         // Contract must have a maker,\n', '        require(cfd.taker.addr == address(0));         // and no taker.\n', '        // require(takerAddress != cfd.maker.addr);       // Maker and Taker must not be the same address. (disabled for now)\n', '        require(msg.value == cfd.amount);              // Takers deposit must match makers deposit.\n', '        require(takerAddress != address(0));           // Taker must provide a non-zero address.\n', '        require(block.number <= cfd.contractEndBlock); // Taker must take contract before end block.\n', '\n', '        cfd.taker.addr = takerAddress;\n', '        // Make taker position the inverse of maker position\n', '        cfd.taker.position = cfd.maker.position == Position.Long ? Position.Short : Position.Long;\n', '        cfd.contractStartBlock = uint128(block.number);\n', '        cfd.isTaken = true;\n', '\n', '        emit LogTakeCfd(\n', '            cfdId,\n', '            cfd.maker.addr,\n', '            cfd.maker.position,\n', '            cfd.taker.addr,\n', '            cfd.taker.position,\n', '            cfd.assetId,\n', '            cfd.amount,\n', '            cfd.contractStartBlock,\n', '            cfd.contractEndBlock\n', '        );\n', '            \n', '        return true;\n', '    }\n', '\n', '    function settleAndWithdrawCfd(\n', '        uint128 cfdId\n', '        )\n', '        public {\n', '        address makerAddr = contracts[cfdId].maker.addr;\n', '        address takerAddr = contracts[cfdId].taker.addr;\n', '\n', '        settleCfd(cfdId);\n', '        withdraw(cfdId, makerAddr);\n', '        withdraw(cfdId, takerAddr);\n', '    }\n', '\n', '    function settleCfd(\n', '        uint128 cfdId\n', '        )\n', '        public\n', '        returns (bool success) {\n', '        Cfd storage cfd = contracts[cfdId];\n', '\n', '        require(cfd.contractEndBlock <= block.number); // Contract must have met its end time.\n', '        require(!cfd.isSettled);                       // Contract must not be settled already.\n', '        require(!cfd.isRefunded);                      // Contract must not be refunded.\n', '        require(cfd.isTaken);                          // Contract must be taken.\n', '        require(cfd.maker.addr != address(0));         // Contract must have a maker address.\n', '        require(cfd.taker.addr != address(0));         // Contract must have a taker address.\n', '\n', '        // Get relevant variables\n', '        uint128 amount = cfd.amount;\n', '        uint128 startPrice = priceOracle.getAssetPrice(cfd.assetId, cfd.contractStartBlock);\n', '        uint128 endPrice = priceOracle.getAssetPrice(cfd.assetId, cfd.contractEndBlock);\n', '\n', '        /**\n', '         * Register settlements for maker and taker.\n', '         * Maker recieves any leftover wei from integer division.\n', '         */\n', '        uint128 takerSettlement = getSettlementAmount(amount, startPrice, endPrice, cfd.taker.position);\n', '        if (takerSettlement > 0) {\n', '            cfd.taker.withdrawBalance = takerSettlement;\n', '        }\n', '\n', '        uint128 makerSettlement = (amount * 2) - takerSettlement;\n', '        cfd.maker.withdrawBalance = makerSettlement;\n', '\n', '        // Mark contract as settled.\n', '        cfd.isSettled = true;\n', '\n', '        emit LogCfdSettled (\n', '            cfdId,\n', '            cfd.maker.addr,\n', '            cfd.taker.addr,\n', '            amount,\n', '            startPrice,\n', '            endPrice,\n', '            makerSettlement,\n', '            takerSettlement\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdraw(\n', '        uint128 cfdId, \n', '        address partyAddress\n', '    )\n', '    public {\n', '        Cfd storage cfd = contracts[cfdId];\n', '        Party storage party = partyAddress == cfd.maker.addr ? cfd.maker : cfd.taker;\n', '        require(party.withdrawBalance > 0); // The party must have a withdraw balance from previous settlement.\n', '        require(!party.isPaid); // The party must have already been paid out, fx from a refund.\n', '        \n', '        uint128 amount = party.withdrawBalance;\n', '        party.withdrawBalance = 0;\n', '        party.isPaid = true;\n', '        \n', '        party.addr.transfer(amount);\n', '\n', '        emit LogWithdrawal(\n', '            cfdId,\n', '            party.addr,\n', '            amount\n', '        );\n', '    }\n', '\n', '    function getSettlementAmount(\n', '        uint128 amountUInt,\n', '        uint128 entryPriceUInt,\n', '        uint128 exitPriceUInt,\n', '        Position position\n', '    )\n', '    public\n', '    view\n', '    returns (uint128) {\n', '        require(position == Position.Long || position == Position.Short);\n', '\n', "        // If price didn't change, settle for equal amount to long and short.\n", '        if (entryPriceUInt == exitPriceUInt) {return amountUInt;}\n', '\n', '        // If entry price is 0 and exit price is more than 0, all must go to long position and nothing to short.\n', '        if (entryPriceUInt == 0 && exitPriceUInt > 0) {\n', '            return position == Position.Long ? amountUInt * 2 : 0;\n', '        }\n', '\n', '        // Cast uint128 to int256 to support negative numbers and increase over- and underflow limits\n', '        int256 entryPrice = int256(entryPriceUInt);\n', '        int256 exitPrice = int256(exitPriceUInt);\n', '        int256 amount = int256(amountUInt);\n', '\n', '        // Price diff calc depends on which position we are calculating settlement for.\n', '        int256 priceDiff = position == Position.Long ? exitPrice.sub(entryPrice) : entryPrice.sub(exitPrice);\n', '        int256 settlement = amount.add(priceDiff.mul(amount).mul(leverage).div(entryPrice));\n', '        if (settlement < 0) {\n', "            return 0; // Calculated settlement was negative. But a party can't lose more than his deposit, so he's just awarded 0.\n", '        } else if (settlement > amount * 2) {\n', '            return amountUInt * 2; // Calculated settlement was more than the total deposits, so settle for the total deposits.\n', '        } else {\n', '            return uint128(settlement); // Settlement was more than zero and less than sum of deposit amounts, so we can settle it as is.\n', '        }\n', '    }\n', '\n', '    function refundCfd(\n', '        uint128 cfdId\n', '    )\n', '    public\n', '    returns (bool success) {\n', '        Cfd storage cfd = contracts[cfdId];\n', '        require(!cfd.isSettled);                // Contract must not be settled already.\n', '        require(!cfd.isTaken);                  // Contract must not be taken.\n', '        require(!cfd.isRefunded);               // Contract must not be refunded already.\n', '        require(msg.sender == cfd.maker.addr);  // Function caller must be the contract maker.\n', '\n', '        cfd.isRefunded = true;\n', '        cfd.maker.isPaid = true;\n', '        cfd.maker.addr.transfer(cfd.amount);\n', '\n', '        emit LogCfdRefunded(\n', '            cfdId,\n', '            cfd.maker.addr,\n', '            cfd.amount\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    function forceRefundCfd(\n', '        uint128 cfdId\n', '    )\n', '    public\n', '    auth\n', '    {\n', '        Cfd storage cfd = contracts[cfdId];\n', '        require(!cfd.isRefunded); // Contract must not be refunded already.\n', '\n', '        cfd.isRefunded = true;\n', '\n', '        // Refund Taker\n', '        uint128 takerAmount = 0;\n', '        if (cfd.taker.addr != address(0)) {\n', '            takerAmount = cfd.amount;\n', '            cfd.taker.withdrawBalance = 0; // Refunding must reset withdraw balance, if any.\n', '            cfd.taker.addr.transfer(cfd.amount);\n', '        }\n', '\n', '        // Refund Maker\n', '        cfd.maker.withdrawBalance = 0; // Refunding must reset withdraw balance, if any.\n', '        cfd.maker.addr.transfer(cfd.amount);\n', '        \n', '        emit LogCfdForceRefunded(\n', '            cfdId,\n', '            cfd.maker.addr,\n', '            cfd.amount,\n', '            cfd.taker.addr,\n', '            takerAmount\n', '        );\n', '    } \n', '\n', '    function () public {\n', "        // dont receive ether via fallback method (by not having 'payable' modifier on this function).\n", '    }\n', '}']
