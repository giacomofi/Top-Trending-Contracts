['pragma solidity ^0.4.20;\n', '\n', 'library SafeMath { //standart library for uint\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0 || b == 0){\n', '        return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function pow(uint256 a, uint256 b) internal pure returns (uint256){ //power function\n', '    if (b == 0){\n', '      return 1;\n', '    }\n', '    uint256 c = a**b;\n', '    assert (c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '//standart contract to identify owner\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  address public newOwner;\n', '\n', '  address public techSupport;\n', '\n', '  address public newTechSupport;\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyTechSupport() {\n', '    require(msg.sender == techSupport || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  function acceptOwnership() public {\n', '    if (msg.sender == newOwner) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '  function transferTechSupport (address _newSupport) public{\n', '    require (msg.sender == owner || msg.sender == techSupport);\n', '    newTechSupport = _newSupport;\n', '  }\n', '\n', '  function acceptSupport() public{\n', '    if(msg.sender == newTechSupport){\n', '      techSupport = newTechSupport;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '//Abstract Token contract\n', 'contract HeliosToken{\n', '  function setCrowdsaleContract (address) public;\n', '  function sendCrowdsaleTokens(address, uint256) public;\n', '  function endIco() public;\n', '}\n', '\n', '//Crowdsale contract\n', 'contract Crowdsale is Ownable{\n', '\n', '  using SafeMath for uint;\n', '\n', '  uint decimals = 2;\n', '  // Token contract address\n', '  HeliosToken public token;\n', '\n', '  // Constructor\n', '  function Crowdsale(address _tokenAddress) public{\n', '    token = HeliosToken(_tokenAddress);\n', '    techSupport = 0xcDDC1cE0b7D4C9B018b8a4b8f7Da2678D56E8619;\n', '\n', '    token.setCrowdsaleContract(address(this));\n', '    owner = 0xA957c13265Cb1b101401d10f5E0b69E0b36ef000;\n', '  }\n', '\n', '  //Crowdsale variables\n', '  uint public preIcoTokensSold = 0;\n', '  uint public tokensSold = 0;\n', '  uint public ethCollected = 0;\n', '\n', '  mapping (address => uint) contributorBalances;\n', '\n', '  uint public tokenPrice = 0.001 ether;\n', '\n', '  //preIco constants\n', '  uint public constant preIcoStart = 1525168800; //1525168800\n', '  uint public constant preIcoFinish = 1527847200;\n', '  uint public constant preIcoMinInvest = 50*(uint(10).pow(decimals)); //50 Tokens\n', '  uint public constant preIcoMaxCap = 500000*(uint(10).pow(decimals)); //500000 Tokens\n', '\n', '  // Ico constants\n', '  uint public constant icoStart = 1530439200; \n', '  uint public constant icoFinish = 1538388000; \n', '  uint public constant icoMinInvest = 10*(uint(10).pow(decimals)); //10 Tokens\n', '\n', '  uint public constant minCap = 1000000 * uint(10).pow(decimals);\n', '\n', '  function isPreIco (uint _time) public pure returns(bool) {\n', '    if((preIcoStart <= _time) && (_time < preIcoFinish)){\n', '      return true;\n', '    }\n', '  }\n', '  \n', '  //check is now ICO\n', '  function isIco(uint _time) public pure returns (bool){\n', '    if((icoStart <= _time) && (_time < icoFinish)){\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function timeBasedBonus(uint _time) public pure returns(uint) {\n', '    if(_time < preIcoStart || (_time > preIcoFinish && _time < icoStart)){\n', '      return 20;\n', '    }\n', '\n', '    if(isPreIco(_time)){\n', '      if(preIcoStart + 1 weeks > _time){\n', '        return 20;\n', '      }\n', '      if(preIcoStart + 2 weeks > _time){\n', '        return 15;\n', '      }\n', '      if(preIcoStart + 3 weeks > _time){\n', '        return 10;\n', '      }\n', '    }\n', '    if(isIco(_time)){\n', '      if(icoStart + 1 weeks > _time){\n', '        return 20;\n', '      }\n', '      if(icoStart + 2 weeks > _time){\n', '        return 15;\n', '      }\n', '      if(icoStart + 3 weeks > _time){\n', '        return 10;\n', '      }\n', '    }\n', '    return 0;\n', '  }\n', '  \n', '  event OnSuccessfullyBuy(address indexed _address, uint indexed _etherValue, bool indexed isBought, uint _tokenValue);\n', '\n', '  //fallback function (when investor send ether to contract)\n', '  function() public payable{\n', '    require(isPreIco(now) || isIco(now));\n', '    require(buy(msg.sender,msg.value, now)); //redirect to func buy\n', '  }\n', '\n', '  //function buy Tokens\n', '  function buy(address _address, uint _value, uint _time) internal returns (bool){\n', '    \n', '    uint tokensToSend = etherToTokens(_value,_time);\n', '\n', '    if (isPreIco(_time)){\n', '      require (tokensToSend >= preIcoMinInvest);\n', '      require (preIcoTokensSold.add(tokensToSend) <= preIcoMaxCap);\n', '      \n', '      token.sendCrowdsaleTokens(_address,tokensToSend);\n', '      preIcoTokensSold = preIcoTokensSold.add(tokensToSend);\n', '\n', '      tokensSold = tokensSold.add(tokensToSend);\n', '      distributeEther();\n', '\n', '    }else{\n', '      require (tokensToSend >= icoMinInvest);\n', '      token.sendCrowdsaleTokens(_address,tokensToSend);\n', '\n', '      contributorBalances[_address] = contributorBalances[_address].add(_value);\n', '\n', '      tokensSold = tokensSold.add(tokensToSend);\n', '\n', '      if (tokensSold >= minCap){\n', '        distributeEther();\n', '      }\n', '    }\n', '\n', '    emit OnSuccessfullyBuy(_address,_value,true, tokensToSend);\n', '    ethCollected = ethCollected.add(_value);\n', '\n', '    return true;\n', '  }\n', '\n', '  address public distributionAddress = 0x769EDcf3756A3Fd4D52B739E06dF060b7379C4Ef;\n', '  function distributeEther() internal {\n', '    distributionAddress.transfer(address(this).balance);\n', '  }\n', '  \n', '  event ManualTokensSended(address indexed _address, uint indexed _value, bool );\n', '  \n', '  function manualSendTokens (address _address, uint _tokens) public onlyTechSupport {\n', '    token.sendCrowdsaleTokens(_address, _tokens);\n', '    tokensSold = tokensSold.add(_tokens);\n', '    emit OnSuccessfullyBuy(_address,0,false,_tokens);\n', '  }\n', '\n', '  function manualSendEther (address _address, uint _value) public onlyTechSupport {\n', '    uint tokensToSend = etherToTokens(_value, 0);\n', '    tokensSold = tokensSold.add(tokensToSend);\n', '    ethCollected = ethCollected.add(_value);\n', '\n', '    token.sendCrowdsaleTokens(_address, tokensToSend);\n', '    emit OnSuccessfullyBuy(_address,_value,false, tokensToSend);\n', '  }\n', '  \n', '  //convert ether to tokens (without decimals)\n', '  function etherToTokens(uint _value, uint _time) public view returns(uint res) {\n', '    if(_time == 0){\n', '        _time = now;\n', '    }\n', '    res = _value.mul((uint)(10).pow(decimals))/tokenPrice;\n', '    uint bonus = timeBasedBonus(_time);\n', '    res = res.add(res.mul(bonus)/100);\n', '  }\n', '\n', '  event Refund(address indexed contributor, uint ethValue);  \n', '\n', '  function refund () public {\n', '    require (now > icoFinish && tokensSold < minCap);\n', '    require (contributorBalances[msg.sender] != 0);\n', '\n', '    msg.sender.transfer(contributorBalances[msg.sender]);\n', '\n', '    emit Refund(msg.sender, contributorBalances[msg.sender]);\n', '\n', '    contributorBalances[msg.sender] = 0;\n', '  }\n', '  \n', '  function endIco () public onlyTechSupport {\n', '    require(now > icoFinish + 5 days);\n', '    token.endIco();\n', '  }\n', '  \n', '}']