['pragma solidity ^0.4.19;\n', '\n', '// Wolf Crypto presale pooling contract\n', '// written by @iamdefinitelyahuman\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '  function transfer(address _to, uint256 _value) returns (bool success) {}\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '}\n', '\n', '\n', 'contract WhiteList {\n', '   function checkMemberLevel (address addr) view public returns (uint) {}\n', '}\n', '\n', '\n', 'contract PresalePool {\n', '\n', '  // SafeMath is a library to ensure that math operations do not have overflow errors\n', '  // https://zeppelin-solidity.readthedocs.io/en/latest/safemath.html\n', '  using SafeMath for uint;\n', '  \n', '  // The contract has 3 stages:\n', '  // 1 - The initial state. The owner is able to add addresses to the whitelist, and any whitelisted addresses can deposit or withdraw eth to the contract.\n', '  // 2 - The owner has closed the contract for further deposits. Whitelisted addresses can still withdraw eth from the contract.\n', '  // 3 - The eth is sent from the contract to the receiver. Unused eth can be claimed by contributors immediately. Once tokens are sent to the contract,\n', '  //     the owner enables withdrawals and contributors can withdraw their tokens.\n', '  uint8 public contractStage = 1;\n', '  \n', '  // These variables are set at the time of contract creation\n', '  // address that creates the contract\n', '  address public owner;\n', '  // maximum eth amount (in wei) that can be sent by a whitelisted address\n', '  uint[] public contributionCaps;\n', '  // the % of tokens kept by the contract owner\n', '  uint public feePct;\n', '  // the address that the pool will be paid out to\n', '  address public receiverAddress;\n', '  \n', '  // These constant variables do not change with each contract deployment\n', '  // minimum eth amount (in wei) that can be sent by a whitelisted address\n', '  uint constant public contributionMin = 100000000000000000;\n', '  // maximum gas price allowed for deposits in stage 1\n', '  uint constant public maxGasPrice = 50000000000;\n', '  // whitelisting contract\n', '  WhiteList constant public whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63);\n', '  \n', '  \n', '  // These variables are all initially set to 0 and will be set at some point during the contract\n', '  // epoch time that the next contribution caps become active\n', '  uint public nextCapTime;\n', '  // pending contribution caps\n', '  uint [] public nextContributionCaps;\n', '  // block number of the last change to the receiving address (set if receiving address is changed, stage 1 or 2)\n', '  uint public addressChangeBlock;\n', '  // amount of eth (in wei) present in the contract when it was submitted\n', '  uint public finalBalance;\n', '  // array containing eth amounts to be refunded in stage 3\n', '  uint[] public ethRefundAmount;\n', '  // default token contract to be used for withdrawing tokens in stage 3\n', '  address public activeToken;\n', '  \n', '  // data structure for holding the contribution amount, cap, eth refund status, and token withdrawal status for each whitelisted address\n', '  struct Contributor {\n', '    bool authorized;\n', '    uint ethRefund;\n', '    uint balance;\n', '    uint cap;\n', '    mapping (address => uint) tokensClaimed;\n', '  }\n', '  // mapping that holds the contributor struct for each whitelisted address\n', '  mapping (address => Contributor) whitelist;\n', '  \n', '  // data structure for holding information related to token withdrawals.\n', '  struct TokenAllocation {\n', '    ERC20 token;\n', '    uint[] pct;\n', '    uint balanceRemaining;\n', '  }\n', '  // mapping that holds the token allocation struct for each token address\n', '  mapping (address => TokenAllocation) distributionMap;\n', '  \n', '  \n', '  // modifier for functions that can only be accessed by the contract creator\n', '  modifier onlyOwner () {\n', '    require (msg.sender == owner);\n', '    _;\n', '  }\n', '  \n', '  // modifier to prevent re-entrancy exploits during contract > contract interaction\n', '  bool locked;\n', '  modifier noReentrancy() {\n', '    require(!locked);\n', '    locked = true;\n', '    _;\n', '    locked = false;\n', '  }\n', '  \n', '  // Events triggered throughout contract execution\n', '  // These can be watched via geth filters to keep up-to-date with the contract\n', '  event ContributorBalanceChanged (address contributor, uint totalBalance);\n', '  event ReceiverAddressSet ( address _addr);\n', '  event PoolSubmitted (address receiver, uint amount);\n', '  event WithdrawalsOpen (address tokenAddr);\n', '  event TokensWithdrawn (address receiver, address token, uint amount);\n', '  event EthRefundReceived (address sender, uint amount);\n', '  event EthRefunded (address receiver, uint amount);\n', '  event ERC223Received (address token, uint value);\n', '   \n', '  // These are internal functions used for calculating fees, eth and token allocations as %\n', '  // returns a value as a % accurate to 20 decimal points\n', '  function _toPct (uint numerator, uint denominator ) internal pure returns (uint) {\n', '    return numerator.mul(10 ** 20) / denominator;\n', '  }\n', '  \n', '  // returns % of any number, where % given was generated with toPct\n', '  function _applyPct (uint numerator, uint pct) internal pure returns (uint) {\n', '    return numerator.mul(pct) / (10 ** 20);\n', '  }\n', '  \n', '  // This function is called at the time of contract creation,\n', '  // it sets the initial variables and whitelists the contract owner.\n', '  function PresalePool(address receiverAddr, uint[] capAmounts, uint fee) public {\n', '    require (fee < 100);\n', '    require (capAmounts.length>1 && capAmounts.length<256);\n', '    for (uint8 i=1; i<capAmounts.length; i++) {\n', '      require (capAmounts[i] <= capAmounts[0]);\n', '    }\n', '    owner = msg.sender;\n', '    receiverAddress = receiverAddr;\n', '    contributionCaps = capAmounts;\n', '    feePct = _toPct(fee,100);\n', '    whitelist[msg.sender].authorized = true;\n', '  }\n', '  \n', '  // This function is called whenever eth is sent into the contract.\n', '  // The send will fail unless the contract is in stage one and the sender has been whitelisted.\n', '  // The amount sent is added to the balance in the Contributor struct associated with the sending address.\n', '  function () payable public {\n', '    if (contractStage == 1) {\n', '      _ethDeposit();\n', '    } else if (contractStage == 3) {\n', '      _ethRefund();\n', '    } else revert();\n', '  }\n', '  \n', '  // Internal function for handling eth deposits during contract stage one.\n', '  function _ethDeposit () internal {\n', '    assert (contractStage == 1);\n', '    require (tx.gasprice <= maxGasPrice);\n', '    require (this.balance <= contributionCaps[0]);\n', '    var c = whitelist[msg.sender];\n', '    uint newBalance = c.balance.add(msg.value);\n', '    require (newBalance >= contributionMin);\n', '    require (newBalance <= _checkCap(msg.sender));\n', '    c.balance = newBalance;\n', '    ContributorBalanceChanged(msg.sender, newBalance);\n', '  }\n', '  \n', '  // Internal function for handling eth refunds during stage three.\n', '  function _ethRefund () internal {\n', '    assert (contractStage == 3);\n', '    require (msg.sender == owner || msg.sender == receiverAddress);\n', '    require (msg.value >= contributionMin);\n', '    ethRefundAmount.push(msg.value);\n', '    EthRefundReceived(msg.sender, msg.value);\n', '  }\n', '  \n', '  // This function is called to withdraw eth or tokens from the contract.\n', '  // It can only be called by addresses that are whitelisted and show a balance greater than 0.\n', '  // If called during stages one or two, the full eth balance deposited into the contract is returned and the contributor&#39;s balance reset to 0.\n', '  // If called during stage three, the contributor&#39;s unused eth will be returned, as well as any available tokens.\n', '  // The token address may be provided optionally to withdraw tokens that are not currently the default token (airdrops).\n', '  function withdraw (address tokenAddr) public {\n', '    var c = whitelist[msg.sender];\n', '    require (c.balance > 0);\n', '    if (contractStage < 3) {\n', '      uint amountToTransfer = c.balance;\n', '      c.balance = 0;\n', '      msg.sender.transfer(amountToTransfer);\n', '      ContributorBalanceChanged(msg.sender, 0);\n', '    } else {\n', '      _withdraw(msg.sender,tokenAddr);\n', '    }  \n', '  }\n', '  \n', '  // This function allows the contract owner to force a withdrawal to any contributor.\n', '  function withdrawFor (address contributor, address tokenAddr) public onlyOwner {\n', '    require (contractStage == 3);\n', '    require (whitelist[contributor].balance > 0);\n', '    _withdraw(contributor,tokenAddr);\n', '  }\n', '  \n', '  // This internal function handles withdrawals during stage three.\n', '  // The associated events will fire to notify when a refund or token allocation is claimed.\n', '  function _withdraw (address receiver, address tokenAddr) internal {\n', '    assert (contractStage == 3);\n', '    var c = whitelist[receiver];\n', '    if (tokenAddr == 0x00) {\n', '      tokenAddr = activeToken;\n', '    }\n', '    var d = distributionMap[tokenAddr];\n', '    require ( (ethRefundAmount.length > c.ethRefund) || d.pct.length > c.tokensClaimed[tokenAddr] );\n', '    if (ethRefundAmount.length > c.ethRefund) {\n', '      uint pct = _toPct(c.balance,finalBalance);\n', '      uint ethAmount = 0;\n', '      for (uint i=c.ethRefund; i<ethRefundAmount.length; i++) {\n', '        ethAmount = ethAmount.add(_applyPct(ethRefundAmount[i],pct));\n', '      }\n', '      c.ethRefund = ethRefundAmount.length;\n', '      if (ethAmount > 0) {\n', '        receiver.transfer(ethAmount);\n', '        EthRefunded(receiver,ethAmount);\n', '      }\n', '    }\n', '    if (d.pct.length > c.tokensClaimed[tokenAddr]) {\n', '      uint tokenAmount = 0;\n', '      for (i=c.tokensClaimed[tokenAddr]; i<d.pct.length; i++) {\n', '        tokenAmount = tokenAmount.add(_applyPct(c.balance,d.pct[i]));\n', '      }\n', '      c.tokensClaimed[tokenAddr] = d.pct.length;\n', '      if (tokenAmount > 0) {\n', '        require(d.token.transfer(receiver,tokenAmount));\n', '        d.balanceRemaining = d.balanceRemaining.sub(tokenAmount);\n', '        TokensWithdrawn(receiver,tokenAddr,tokenAmount);\n', '      }  \n', '    }\n', '    \n', '  }\n', '  \n', '  // This function can only be executed by the owner, it adds an address to the whitelist.\n', '  // To execute, the contract must be in stage 1, the address cannot already be whitelisted, and the address cannot be a contract itself.\n', '  // Blocking contracts from being whitelisted prevents attacks from unexpected contract to contract interaction - very important!\n', '  function authorize (address addr, uint cap) public onlyOwner {\n', '    require (contractStage == 1);\n', '    _checkWhitelistContract(addr);\n', '    require (!whitelist[addr].authorized);\n', '    require ((cap > 0 && cap < contributionCaps.length) || (cap >= contributionMin && cap <= contributionCaps[0]) );\n', '    uint size;\n', '    assembly { size := extcodesize(addr) }\n', '    require (size == 0);\n', '    whitelist[addr].cap = cap;\n', '    whitelist[addr].authorized = true;\n', '  }\n', '  \n', '  // This function is used by the owner to authorize many addresses in a single call.\n', '  // Each address will be given the same cap, and the cap must be one of the standard levels.\n', '  function authorizeMany (address[] addr, uint cap) public onlyOwner {\n', '    require (addr.length < 255);\n', '    require (cap > 0 && cap < contributionCaps.length);\n', '    for (uint8 i=0; i<addr.length; i++) {\n', '      authorize(addr[i], cap);\n', '    }\n', '  }\n', '  \n', '  // This function is called by the owner to remove an address from the whitelist.\n', '  // It may only be executed during stages 1 and 2.  Any eth sent by the address is refunded and their personal cap is set to 0.\n', '  // It will throw if the address is still authorised in the whitelist contract.\n', '  function revoke (address addr) public onlyOwner {\n', '    require (contractStage < 3);\n', '    require (whitelist[addr].authorized);\n', '    require (whitelistContract.checkMemberLevel(addr) == 0);\n', '    whitelist[addr].authorized = false;\n', '    if (whitelist[addr].balance > 0) {\n', '      uint amountToTransfer = whitelist[addr].balance;\n', '      whitelist[addr].balance = 0;\n', '      addr.transfer(amountToTransfer);\n', '      ContributorBalanceChanged(addr, 0);\n', '    }\n', '  }\n', '  \n', '  // This function is called by the owner to modify the contribution cap of a whitelisted address.\n', '  // If the current contribution balance exceeds the new cap, the excess balance is refunded.\n', '  function modifyIndividualCap (address addr, uint cap) public onlyOwner {\n', '    require (contractStage < 3);\n', '    require (cap < contributionCaps.length || (cap >= contributionMin && cap <= contributionCaps[0]) );\n', '    _checkWhitelistContract(addr);\n', '    var c = whitelist[addr];\n', '    require (c.authorized);\n', '    uint amount = c.balance;\n', '    c.cap = cap;\n', '    uint capAmount = _checkCap(addr);\n', '    if (amount > capAmount) {\n', '      c.balance = capAmount;\n', '      addr.transfer(amount.sub(capAmount));\n', '      ContributorBalanceChanged(addr, capAmount);\n', '    }\n', '  }\n', '  \n', '  // This function is called by the owner to modify the cap for a contribution level.\n', '  // The cap cannot be decreased below the current balance or increased past the contract limit.\n', '  function modifyLevelCap (uint level, uint cap) public onlyOwner {\n', '    require (contractStage < 3);\n', '    require (level > 0 && level < contributionCaps.length);\n', '    require (this.balance <= cap && contributionCaps[0] >= cap);\n', '    contributionCaps[level] = cap;\n', '    nextCapTime = 0;\n', '  }\n', '  \n', '  // This function changes every level cap at once, with an optional delay.\n', '  // Modifying the caps immediately will cancel any delayed cap change.\n', '  function modifyAllLevelCaps (uint[] cap, uint time) public onlyOwner {\n', '    require (contractStage < 3);\n', '    require (cap.length == contributionCaps.length-1);\n', '    require (time == 0 || time>block.timestamp);\n', '    if (time == 0) {\n', '      for (uint8 i = 0; i < cap.length; i++) {\n', '        modifyLevelCap(i+1, cap[i]);\n', '      }\n', '    } else {\n', '      nextContributionCaps = contributionCaps;\n', '      nextCapTime = time;\n', '      for (i = 0; i < cap.length; i++) {\n', '        require (contributionCaps[i+1] <= cap[i] && contributionCaps[0] >= cap[i]);\n', '        nextContributionCaps[i+1] = cap[i];\n', '      }\n', '    }\n', '  }\n', '  \n', '  // This function can be called during stages one or two to modify the maximum balance of the contract.\n', '  // It can only be called by the owner. The amount cannot be set to lower than the current balance of the contract.\n', '  function modifyMaxContractBalance (uint amount) public onlyOwner {\n', '    require (contractStage < 3);\n', '    require (amount >= contributionMin);\n', '    require (amount >= this.balance);\n', '    contributionCaps[0] = amount;\n', '    nextCapTime = 0;\n', '    for (uint8 i=1; i<contributionCaps.length; i++) {\n', '      if (contributionCaps[i]>amount) contributionCaps[i]=amount;\n', '    }\n', '  }\n', '  \n', '  // This internal function returns the cap amount of a whitelisted address.\n', '  function _checkCap (address addr) internal returns (uint) {\n', '    _checkWhitelistContract(addr);\n', '    var c = whitelist[addr];\n', '    if (!c.authorized) return 0;\n', '    if (nextCapTime>0 && block.timestamp>nextCapTime) {\n', '      contributionCaps = nextContributionCaps;\n', '      nextCapTime = 0;\n', '    }\n', '    if (c.cap<contributionCaps.length) return contributionCaps[c.cap];\n', '    return c.cap; \n', '  }\n', '  \n', '  // This internal function checks if an address is whitelisted in the whitelist contract.\n', '  function _checkWhitelistContract (address addr) internal {\n', '    var c = whitelist[addr];\n', '    if (!c.authorized) {\n', '      var level = whitelistContract.checkMemberLevel(addr);\n', '      if (level == 0 || level >= contributionCaps.length) return;\n', '      c.cap = level;\n', '      c.authorized = true;\n', '    }\n', '  }\n', '  \n', '  // This callable function returns the total pool cap, current balance and remaining balance to be filled.\n', '  function checkPoolBalance () view public returns (uint poolCap, uint balance, uint remaining) {\n', '    if (contractStage == 1) {\n', '      remaining = contributionCaps[0].sub(this.balance);\n', '    } else {\n', '      remaining = 0;\n', '    }\n', '    return (contributionCaps[0],this.balance,remaining);\n', '  }\n', '  \n', '  // This callable function returns the balance, contribution cap, and remaining available balance of any contributor.\n', '  function checkContributorBalance (address addr) view public returns (uint balance, uint cap, uint remaining) {\n', '    var c = whitelist[addr];\n', '    if (!c.authorized) {\n', '      cap = whitelistContract.checkMemberLevel(addr);\n', '      if (cap == 0) return (0,0,0);\n', '    } else {\n', '      cap = c.cap;\n', '    }\n', '    balance = c.balance;\n', '    if (contractStage == 1) {\n', '      if (cap<contributionCaps.length) { \n', '        if (nextCapTime == 0 || nextCapTime > block.timestamp) {\n', '          cap = contributionCaps[cap];\n', '        } else {\n', '          cap = nextContributionCaps[cap];\n', '        }\n', '      }\n', '      remaining = cap.sub(balance);\n', '      if (contributionCaps[0].sub(this.balance) < remaining) remaining = contributionCaps[0].sub(this.balance);\n', '    } else {\n', '      remaining = 0;\n', '    }\n', '    return (balance, cap, remaining);\n', '  }\n', '  \n', '  // This callable function returns the token balance that a contributor can currently claim.\n', '  function checkAvailableTokens (address addr, address tokenAddr) view public returns (uint tokenAmount) {\n', '    var c = whitelist[addr];\n', '    var d = distributionMap[tokenAddr];\n', '    for (uint i = c.tokensClaimed[tokenAddr]; i < d.pct.length; i++) {\n', '      tokenAmount = tokenAmount.add(_applyPct(c.balance, d.pct[i]));\n', '    }\n', '    return tokenAmount;\n', '  }\n', '  \n', '  // This function closes further contributions to the contract, advancing it to stage two.\n', '  // It can only be called by the owner.  After this call has been made, whitelisted addresses\n', '  // can still remove their eth from the contract but cannot contribute any more.\n', '  function closeContributions () public onlyOwner {\n', '    require (contractStage == 1);\n', '    contractStage = 2;\n', '  }\n', '  \n', '  // This function reopens the contract to contributions and further whitelisting, returning it to stage one.\n', '  // It can only be called by the owner during stage two.\n', '  function reopenContributions () public onlyOwner {\n', '    require (contractStage == 2);\n', '    contractStage = 1;\n', '  }\n', '  \n', '  // This function sets the receiving address that the contract will send the pooled eth to.\n', '  // It can only be called by the contract owner if the receiver address has not already been set.\n', '  // After making this call, the contract will be unable to send the pooled eth for 6000 blocks.\n', '  // This limitation is so that if the owner acts maliciously in making the change, all whitelisted\n', '  // addresses have ~24 hours to withdraw their eth from the contract.\n', '  function setReceiverAddress (address addr) public onlyOwner {\n', '    require (addr != 0x00 && receiverAddress == 0x00);\n', '    require (contractStage < 3);\n', '    receiverAddress = addr;\n', '    addressChangeBlock = block.number;\n', '    ReceiverAddressSet(addr);\n', '  }\n', '\n', '  // This function sends the pooled eth to the receiving address, calculates the % of unused eth to be returned,\n', '  // and advances the contract to stage three. It can only be called by the contract owner during stages one or two.\n', '  // The amount to send (given in wei) must be specified during the call. As this function can only be executed once,\n', '  // it is VERY IMPORTANT not to get the amount wrong.\n', '  function submitPool (uint amountInWei) public onlyOwner noReentrancy {\n', '    require (contractStage < 3);\n', '    require (receiverAddress != 0x00);\n', '    require (block.number >= addressChangeBlock.add(6000));\n', '    require (contributionMin <= amountInWei && amountInWei <= this.balance);\n', '    finalBalance = this.balance;\n', '    require (receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());\n', '    if (this.balance > 0) ethRefundAmount.push(this.balance);\n', '    contractStage = 3;\n', '    PoolSubmitted(receiverAddress, amountInWei);\n', '  }\n', '  \n', '  // This function opens the contract up for token withdrawals.\n', '  // It can only be called by the owner during stage 3.  The owner specifies the address of an ERC20 token\n', '  // contract that this contract has a balance in, and optionally a bool to prevent this token from being\n', '  // the default withdrawal (in the event of an airdrop, for example).\n', '  function enableTokenWithdrawals (address tokenAddr, bool notDefault) public onlyOwner noReentrancy {\n', '    require (contractStage == 3);\n', '    if (notDefault) {\n', '      require (activeToken != 0x00);\n', '    } else {\n', '      activeToken = tokenAddr;\n', '    }\n', '    var d = distributionMap[tokenAddr];    \n', '    if (d.pct.length==0) d.token = ERC20(tokenAddr);\n', '    uint amount = d.token.balanceOf(this).sub(d.balanceRemaining);\n', '    require (amount > 0);\n', '    if (feePct > 0) {\n', '      require (d.token.transfer(owner,_applyPct(amount,feePct)));\n', '    }\n', '    amount = d.token.balanceOf(this).sub(d.balanceRemaining);\n', '    d.balanceRemaining = d.token.balanceOf(this);\n', '    d.pct.push(_toPct(amount,finalBalance));\n', '  }\n', '  \n', '  // This is a standard function required for ERC223 compatibility.\n', '  function tokenFallback (address from, uint value, bytes data) public {\n', '    ERC223Received (from, value);\n', '  }\n', '  \n', '}']
['pragma solidity ^0.4.19;\n', '\n', '// Wolf Crypto presale pooling contract\n', '// written by @iamdefinitelyahuman\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '  function transfer(address _to, uint256 _value) returns (bool success) {}\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '}\n', '\n', '\n', 'contract WhiteList {\n', '   function checkMemberLevel (address addr) view public returns (uint) {}\n', '}\n', '\n', '\n', 'contract PresalePool {\n', '\n', '  // SafeMath is a library to ensure that math operations do not have overflow errors\n', '  // https://zeppelin-solidity.readthedocs.io/en/latest/safemath.html\n', '  using SafeMath for uint;\n', '  \n', '  // The contract has 3 stages:\n', '  // 1 - The initial state. The owner is able to add addresses to the whitelist, and any whitelisted addresses can deposit or withdraw eth to the contract.\n', '  // 2 - The owner has closed the contract for further deposits. Whitelisted addresses can still withdraw eth from the contract.\n', '  // 3 - The eth is sent from the contract to the receiver. Unused eth can be claimed by contributors immediately. Once tokens are sent to the contract,\n', '  //     the owner enables withdrawals and contributors can withdraw their tokens.\n', '  uint8 public contractStage = 1;\n', '  \n', '  // These variables are set at the time of contract creation\n', '  // address that creates the contract\n', '  address public owner;\n', '  // maximum eth amount (in wei) that can be sent by a whitelisted address\n', '  uint[] public contributionCaps;\n', '  // the % of tokens kept by the contract owner\n', '  uint public feePct;\n', '  // the address that the pool will be paid out to\n', '  address public receiverAddress;\n', '  \n', '  // These constant variables do not change with each contract deployment\n', '  // minimum eth amount (in wei) that can be sent by a whitelisted address\n', '  uint constant public contributionMin = 100000000000000000;\n', '  // maximum gas price allowed for deposits in stage 1\n', '  uint constant public maxGasPrice = 50000000000;\n', '  // whitelisting contract\n', '  WhiteList constant public whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63);\n', '  \n', '  \n', '  // These variables are all initially set to 0 and will be set at some point during the contract\n', '  // epoch time that the next contribution caps become active\n', '  uint public nextCapTime;\n', '  // pending contribution caps\n', '  uint [] public nextContributionCaps;\n', '  // block number of the last change to the receiving address (set if receiving address is changed, stage 1 or 2)\n', '  uint public addressChangeBlock;\n', '  // amount of eth (in wei) present in the contract when it was submitted\n', '  uint public finalBalance;\n', '  // array containing eth amounts to be refunded in stage 3\n', '  uint[] public ethRefundAmount;\n', '  // default token contract to be used for withdrawing tokens in stage 3\n', '  address public activeToken;\n', '  \n', '  // data structure for holding the contribution amount, cap, eth refund status, and token withdrawal status for each whitelisted address\n', '  struct Contributor {\n', '    bool authorized;\n', '    uint ethRefund;\n', '    uint balance;\n', '    uint cap;\n', '    mapping (address => uint) tokensClaimed;\n', '  }\n', '  // mapping that holds the contributor struct for each whitelisted address\n', '  mapping (address => Contributor) whitelist;\n', '  \n', '  // data structure for holding information related to token withdrawals.\n', '  struct TokenAllocation {\n', '    ERC20 token;\n', '    uint[] pct;\n', '    uint balanceRemaining;\n', '  }\n', '  // mapping that holds the token allocation struct for each token address\n', '  mapping (address => TokenAllocation) distributionMap;\n', '  \n', '  \n', '  // modifier for functions that can only be accessed by the contract creator\n', '  modifier onlyOwner () {\n', '    require (msg.sender == owner);\n', '    _;\n', '  }\n', '  \n', '  // modifier to prevent re-entrancy exploits during contract > contract interaction\n', '  bool locked;\n', '  modifier noReentrancy() {\n', '    require(!locked);\n', '    locked = true;\n', '    _;\n', '    locked = false;\n', '  }\n', '  \n', '  // Events triggered throughout contract execution\n', '  // These can be watched via geth filters to keep up-to-date with the contract\n', '  event ContributorBalanceChanged (address contributor, uint totalBalance);\n', '  event ReceiverAddressSet ( address _addr);\n', '  event PoolSubmitted (address receiver, uint amount);\n', '  event WithdrawalsOpen (address tokenAddr);\n', '  event TokensWithdrawn (address receiver, address token, uint amount);\n', '  event EthRefundReceived (address sender, uint amount);\n', '  event EthRefunded (address receiver, uint amount);\n', '  event ERC223Received (address token, uint value);\n', '   \n', '  // These are internal functions used for calculating fees, eth and token allocations as %\n', '  // returns a value as a % accurate to 20 decimal points\n', '  function _toPct (uint numerator, uint denominator ) internal pure returns (uint) {\n', '    return numerator.mul(10 ** 20) / denominator;\n', '  }\n', '  \n', '  // returns % of any number, where % given was generated with toPct\n', '  function _applyPct (uint numerator, uint pct) internal pure returns (uint) {\n', '    return numerator.mul(pct) / (10 ** 20);\n', '  }\n', '  \n', '  // This function is called at the time of contract creation,\n', '  // it sets the initial variables and whitelists the contract owner.\n', '  function PresalePool(address receiverAddr, uint[] capAmounts, uint fee) public {\n', '    require (fee < 100);\n', '    require (capAmounts.length>1 && capAmounts.length<256);\n', '    for (uint8 i=1; i<capAmounts.length; i++) {\n', '      require (capAmounts[i] <= capAmounts[0]);\n', '    }\n', '    owner = msg.sender;\n', '    receiverAddress = receiverAddr;\n', '    contributionCaps = capAmounts;\n', '    feePct = _toPct(fee,100);\n', '    whitelist[msg.sender].authorized = true;\n', '  }\n', '  \n', '  // This function is called whenever eth is sent into the contract.\n', '  // The send will fail unless the contract is in stage one and the sender has been whitelisted.\n', '  // The amount sent is added to the balance in the Contributor struct associated with the sending address.\n', '  function () payable public {\n', '    if (contractStage == 1) {\n', '      _ethDeposit();\n', '    } else if (contractStage == 3) {\n', '      _ethRefund();\n', '    } else revert();\n', '  }\n', '  \n', '  // Internal function for handling eth deposits during contract stage one.\n', '  function _ethDeposit () internal {\n', '    assert (contractStage == 1);\n', '    require (tx.gasprice <= maxGasPrice);\n', '    require (this.balance <= contributionCaps[0]);\n', '    var c = whitelist[msg.sender];\n', '    uint newBalance = c.balance.add(msg.value);\n', '    require (newBalance >= contributionMin);\n', '    require (newBalance <= _checkCap(msg.sender));\n', '    c.balance = newBalance;\n', '    ContributorBalanceChanged(msg.sender, newBalance);\n', '  }\n', '  \n', '  // Internal function for handling eth refunds during stage three.\n', '  function _ethRefund () internal {\n', '    assert (contractStage == 3);\n', '    require (msg.sender == owner || msg.sender == receiverAddress);\n', '    require (msg.value >= contributionMin);\n', '    ethRefundAmount.push(msg.value);\n', '    EthRefundReceived(msg.sender, msg.value);\n', '  }\n', '  \n', '  // This function is called to withdraw eth or tokens from the contract.\n', '  // It can only be called by addresses that are whitelisted and show a balance greater than 0.\n', "  // If called during stages one or two, the full eth balance deposited into the contract is returned and the contributor's balance reset to 0.\n", "  // If called during stage three, the contributor's unused eth will be returned, as well as any available tokens.\n", '  // The token address may be provided optionally to withdraw tokens that are not currently the default token (airdrops).\n', '  function withdraw (address tokenAddr) public {\n', '    var c = whitelist[msg.sender];\n', '    require (c.balance > 0);\n', '    if (contractStage < 3) {\n', '      uint amountToTransfer = c.balance;\n', '      c.balance = 0;\n', '      msg.sender.transfer(amountToTransfer);\n', '      ContributorBalanceChanged(msg.sender, 0);\n', '    } else {\n', '      _withdraw(msg.sender,tokenAddr);\n', '    }  \n', '  }\n', '  \n', '  // This function allows the contract owner to force a withdrawal to any contributor.\n', '  function withdrawFor (address contributor, address tokenAddr) public onlyOwner {\n', '    require (contractStage == 3);\n', '    require (whitelist[contributor].balance > 0);\n', '    _withdraw(contributor,tokenAddr);\n', '  }\n', '  \n', '  // This internal function handles withdrawals during stage three.\n', '  // The associated events will fire to notify when a refund or token allocation is claimed.\n', '  function _withdraw (address receiver, address tokenAddr) internal {\n', '    assert (contractStage == 3);\n', '    var c = whitelist[receiver];\n', '    if (tokenAddr == 0x00) {\n', '      tokenAddr = activeToken;\n', '    }\n', '    var d = distributionMap[tokenAddr];\n', '    require ( (ethRefundAmount.length > c.ethRefund) || d.pct.length > c.tokensClaimed[tokenAddr] );\n', '    if (ethRefundAmount.length > c.ethRefund) {\n', '      uint pct = _toPct(c.balance,finalBalance);\n', '      uint ethAmount = 0;\n', '      for (uint i=c.ethRefund; i<ethRefundAmount.length; i++) {\n', '        ethAmount = ethAmount.add(_applyPct(ethRefundAmount[i],pct));\n', '      }\n', '      c.ethRefund = ethRefundAmount.length;\n', '      if (ethAmount > 0) {\n', '        receiver.transfer(ethAmount);\n', '        EthRefunded(receiver,ethAmount);\n', '      }\n', '    }\n', '    if (d.pct.length > c.tokensClaimed[tokenAddr]) {\n', '      uint tokenAmount = 0;\n', '      for (i=c.tokensClaimed[tokenAddr]; i<d.pct.length; i++) {\n', '        tokenAmount = tokenAmount.add(_applyPct(c.balance,d.pct[i]));\n', '      }\n', '      c.tokensClaimed[tokenAddr] = d.pct.length;\n', '      if (tokenAmount > 0) {\n', '        require(d.token.transfer(receiver,tokenAmount));\n', '        d.balanceRemaining = d.balanceRemaining.sub(tokenAmount);\n', '        TokensWithdrawn(receiver,tokenAddr,tokenAmount);\n', '      }  \n', '    }\n', '    \n', '  }\n', '  \n', '  // This function can only be executed by the owner, it adds an address to the whitelist.\n', '  // To execute, the contract must be in stage 1, the address cannot already be whitelisted, and the address cannot be a contract itself.\n', '  // Blocking contracts from being whitelisted prevents attacks from unexpected contract to contract interaction - very important!\n', '  function authorize (address addr, uint cap) public onlyOwner {\n', '    require (contractStage == 1);\n', '    _checkWhitelistContract(addr);\n', '    require (!whitelist[addr].authorized);\n', '    require ((cap > 0 && cap < contributionCaps.length) || (cap >= contributionMin && cap <= contributionCaps[0]) );\n', '    uint size;\n', '    assembly { size := extcodesize(addr) }\n', '    require (size == 0);\n', '    whitelist[addr].cap = cap;\n', '    whitelist[addr].authorized = true;\n', '  }\n', '  \n', '  // This function is used by the owner to authorize many addresses in a single call.\n', '  // Each address will be given the same cap, and the cap must be one of the standard levels.\n', '  function authorizeMany (address[] addr, uint cap) public onlyOwner {\n', '    require (addr.length < 255);\n', '    require (cap > 0 && cap < contributionCaps.length);\n', '    for (uint8 i=0; i<addr.length; i++) {\n', '      authorize(addr[i], cap);\n', '    }\n', '  }\n', '  \n', '  // This function is called by the owner to remove an address from the whitelist.\n', '  // It may only be executed during stages 1 and 2.  Any eth sent by the address is refunded and their personal cap is set to 0.\n', '  // It will throw if the address is still authorised in the whitelist contract.\n', '  function revoke (address addr) public onlyOwner {\n', '    require (contractStage < 3);\n', '    require (whitelist[addr].authorized);\n', '    require (whitelistContract.checkMemberLevel(addr) == 0);\n', '    whitelist[addr].authorized = false;\n', '    if (whitelist[addr].balance > 0) {\n', '      uint amountToTransfer = whitelist[addr].balance;\n', '      whitelist[addr].balance = 0;\n', '      addr.transfer(amountToTransfer);\n', '      ContributorBalanceChanged(addr, 0);\n', '    }\n', '  }\n', '  \n', '  // This function is called by the owner to modify the contribution cap of a whitelisted address.\n', '  // If the current contribution balance exceeds the new cap, the excess balance is refunded.\n', '  function modifyIndividualCap (address addr, uint cap) public onlyOwner {\n', '    require (contractStage < 3);\n', '    require (cap < contributionCaps.length || (cap >= contributionMin && cap <= contributionCaps[0]) );\n', '    _checkWhitelistContract(addr);\n', '    var c = whitelist[addr];\n', '    require (c.authorized);\n', '    uint amount = c.balance;\n', '    c.cap = cap;\n', '    uint capAmount = _checkCap(addr);\n', '    if (amount > capAmount) {\n', '      c.balance = capAmount;\n', '      addr.transfer(amount.sub(capAmount));\n', '      ContributorBalanceChanged(addr, capAmount);\n', '    }\n', '  }\n', '  \n', '  // This function is called by the owner to modify the cap for a contribution level.\n', '  // The cap cannot be decreased below the current balance or increased past the contract limit.\n', '  function modifyLevelCap (uint level, uint cap) public onlyOwner {\n', '    require (contractStage < 3);\n', '    require (level > 0 && level < contributionCaps.length);\n', '    require (this.balance <= cap && contributionCaps[0] >= cap);\n', '    contributionCaps[level] = cap;\n', '    nextCapTime = 0;\n', '  }\n', '  \n', '  // This function changes every level cap at once, with an optional delay.\n', '  // Modifying the caps immediately will cancel any delayed cap change.\n', '  function modifyAllLevelCaps (uint[] cap, uint time) public onlyOwner {\n', '    require (contractStage < 3);\n', '    require (cap.length == contributionCaps.length-1);\n', '    require (time == 0 || time>block.timestamp);\n', '    if (time == 0) {\n', '      for (uint8 i = 0; i < cap.length; i++) {\n', '        modifyLevelCap(i+1, cap[i]);\n', '      }\n', '    } else {\n', '      nextContributionCaps = contributionCaps;\n', '      nextCapTime = time;\n', '      for (i = 0; i < cap.length; i++) {\n', '        require (contributionCaps[i+1] <= cap[i] && contributionCaps[0] >= cap[i]);\n', '        nextContributionCaps[i+1] = cap[i];\n', '      }\n', '    }\n', '  }\n', '  \n', '  // This function can be called during stages one or two to modify the maximum balance of the contract.\n', '  // It can only be called by the owner. The amount cannot be set to lower than the current balance of the contract.\n', '  function modifyMaxContractBalance (uint amount) public onlyOwner {\n', '    require (contractStage < 3);\n', '    require (amount >= contributionMin);\n', '    require (amount >= this.balance);\n', '    contributionCaps[0] = amount;\n', '    nextCapTime = 0;\n', '    for (uint8 i=1; i<contributionCaps.length; i++) {\n', '      if (contributionCaps[i]>amount) contributionCaps[i]=amount;\n', '    }\n', '  }\n', '  \n', '  // This internal function returns the cap amount of a whitelisted address.\n', '  function _checkCap (address addr) internal returns (uint) {\n', '    _checkWhitelistContract(addr);\n', '    var c = whitelist[addr];\n', '    if (!c.authorized) return 0;\n', '    if (nextCapTime>0 && block.timestamp>nextCapTime) {\n', '      contributionCaps = nextContributionCaps;\n', '      nextCapTime = 0;\n', '    }\n', '    if (c.cap<contributionCaps.length) return contributionCaps[c.cap];\n', '    return c.cap; \n', '  }\n', '  \n', '  // This internal function checks if an address is whitelisted in the whitelist contract.\n', '  function _checkWhitelistContract (address addr) internal {\n', '    var c = whitelist[addr];\n', '    if (!c.authorized) {\n', '      var level = whitelistContract.checkMemberLevel(addr);\n', '      if (level == 0 || level >= contributionCaps.length) return;\n', '      c.cap = level;\n', '      c.authorized = true;\n', '    }\n', '  }\n', '  \n', '  // This callable function returns the total pool cap, current balance and remaining balance to be filled.\n', '  function checkPoolBalance () view public returns (uint poolCap, uint balance, uint remaining) {\n', '    if (contractStage == 1) {\n', '      remaining = contributionCaps[0].sub(this.balance);\n', '    } else {\n', '      remaining = 0;\n', '    }\n', '    return (contributionCaps[0],this.balance,remaining);\n', '  }\n', '  \n', '  // This callable function returns the balance, contribution cap, and remaining available balance of any contributor.\n', '  function checkContributorBalance (address addr) view public returns (uint balance, uint cap, uint remaining) {\n', '    var c = whitelist[addr];\n', '    if (!c.authorized) {\n', '      cap = whitelistContract.checkMemberLevel(addr);\n', '      if (cap == 0) return (0,0,0);\n', '    } else {\n', '      cap = c.cap;\n', '    }\n', '    balance = c.balance;\n', '    if (contractStage == 1) {\n', '      if (cap<contributionCaps.length) { \n', '        if (nextCapTime == 0 || nextCapTime > block.timestamp) {\n', '          cap = contributionCaps[cap];\n', '        } else {\n', '          cap = nextContributionCaps[cap];\n', '        }\n', '      }\n', '      remaining = cap.sub(balance);\n', '      if (contributionCaps[0].sub(this.balance) < remaining) remaining = contributionCaps[0].sub(this.balance);\n', '    } else {\n', '      remaining = 0;\n', '    }\n', '    return (balance, cap, remaining);\n', '  }\n', '  \n', '  // This callable function returns the token balance that a contributor can currently claim.\n', '  function checkAvailableTokens (address addr, address tokenAddr) view public returns (uint tokenAmount) {\n', '    var c = whitelist[addr];\n', '    var d = distributionMap[tokenAddr];\n', '    for (uint i = c.tokensClaimed[tokenAddr]; i < d.pct.length; i++) {\n', '      tokenAmount = tokenAmount.add(_applyPct(c.balance, d.pct[i]));\n', '    }\n', '    return tokenAmount;\n', '  }\n', '  \n', '  // This function closes further contributions to the contract, advancing it to stage two.\n', '  // It can only be called by the owner.  After this call has been made, whitelisted addresses\n', '  // can still remove their eth from the contract but cannot contribute any more.\n', '  function closeContributions () public onlyOwner {\n', '    require (contractStage == 1);\n', '    contractStage = 2;\n', '  }\n', '  \n', '  // This function reopens the contract to contributions and further whitelisting, returning it to stage one.\n', '  // It can only be called by the owner during stage two.\n', '  function reopenContributions () public onlyOwner {\n', '    require (contractStage == 2);\n', '    contractStage = 1;\n', '  }\n', '  \n', '  // This function sets the receiving address that the contract will send the pooled eth to.\n', '  // It can only be called by the contract owner if the receiver address has not already been set.\n', '  // After making this call, the contract will be unable to send the pooled eth for 6000 blocks.\n', '  // This limitation is so that if the owner acts maliciously in making the change, all whitelisted\n', '  // addresses have ~24 hours to withdraw their eth from the contract.\n', '  function setReceiverAddress (address addr) public onlyOwner {\n', '    require (addr != 0x00 && receiverAddress == 0x00);\n', '    require (contractStage < 3);\n', '    receiverAddress = addr;\n', '    addressChangeBlock = block.number;\n', '    ReceiverAddressSet(addr);\n', '  }\n', '\n', '  // This function sends the pooled eth to the receiving address, calculates the % of unused eth to be returned,\n', '  // and advances the contract to stage three. It can only be called by the contract owner during stages one or two.\n', '  // The amount to send (given in wei) must be specified during the call. As this function can only be executed once,\n', '  // it is VERY IMPORTANT not to get the amount wrong.\n', '  function submitPool (uint amountInWei) public onlyOwner noReentrancy {\n', '    require (contractStage < 3);\n', '    require (receiverAddress != 0x00);\n', '    require (block.number >= addressChangeBlock.add(6000));\n', '    require (contributionMin <= amountInWei && amountInWei <= this.balance);\n', '    finalBalance = this.balance;\n', '    require (receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());\n', '    if (this.balance > 0) ethRefundAmount.push(this.balance);\n', '    contractStage = 3;\n', '    PoolSubmitted(receiverAddress, amountInWei);\n', '  }\n', '  \n', '  // This function opens the contract up for token withdrawals.\n', '  // It can only be called by the owner during stage 3.  The owner specifies the address of an ERC20 token\n', '  // contract that this contract has a balance in, and optionally a bool to prevent this token from being\n', '  // the default withdrawal (in the event of an airdrop, for example).\n', '  function enableTokenWithdrawals (address tokenAddr, bool notDefault) public onlyOwner noReentrancy {\n', '    require (contractStage == 3);\n', '    if (notDefault) {\n', '      require (activeToken != 0x00);\n', '    } else {\n', '      activeToken = tokenAddr;\n', '    }\n', '    var d = distributionMap[tokenAddr];    \n', '    if (d.pct.length==0) d.token = ERC20(tokenAddr);\n', '    uint amount = d.token.balanceOf(this).sub(d.balanceRemaining);\n', '    require (amount > 0);\n', '    if (feePct > 0) {\n', '      require (d.token.transfer(owner,_applyPct(amount,feePct)));\n', '    }\n', '    amount = d.token.balanceOf(this).sub(d.balanceRemaining);\n', '    d.balanceRemaining = d.token.balanceOf(this);\n', '    d.pct.push(_toPct(amount,finalBalance));\n', '  }\n', '  \n', '  // This is a standard function required for ERC223 compatibility.\n', '  function tokenFallback (address from, uint value, bytes data) public {\n', '    ERC223Received (from, value);\n', '  }\n', '  \n', '}']
