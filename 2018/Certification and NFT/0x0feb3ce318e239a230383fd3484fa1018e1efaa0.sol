['pragma solidity ^0.4.14;\n', '\n', '/**\n', ' * Contract that exposes the needed erc20 token functions\n', ' */\n', '\n', 'contract ERC20Interface {\n', '  // Send _value amount of tokens to address _to\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '  // Get the account balance of another account with address _owner\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', '/**\n', ' * Contract that will forward any incoming Ether to its creator\n', ' */\n', 'contract Forwarder {\n', '  // Address to which any funds sent to this contract will be forwarded\n', '  address public parentAddress;\n', '  event ForwarderDeposited(address from, uint value, bytes data);\n', '\n', '  event TokensFlushed(\n', '    address tokenContractAddress, // The contract address of the token\n', '    uint value // Amount of token sent\n', '  );\n', '\n', '  /**\n', '   * Create the contract, and set the destination address to that of the creator\n', '   */\n', '  function Forwarder() {\n', '    parentAddress = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * Modifier that will execute internal code block only if the sender is a parent of the forwarder contract\n', '   */\n', '  modifier onlyParent {\n', '    if (msg.sender != parentAddress) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * Default function; Gets called when Ether is deposited, and forwards it to the destination address\n', '   */\n', '  function() payable {\n', '    if (!parentAddress.call.value(msg.value)(msg.data))\n', '      throw;\n', '    // Fire off the deposited event if we can forward it  \n', '    ForwarderDeposited(msg.sender, msg.value, msg.data);\n', '  }\n', '\n', '  /**\n', '   * Execute a token transfer of the full balance from the forwarder token to the main wallet contract\n', '   * @param tokenContractAddress the address of the erc20 token contract\n', '   */\n', '  function flushTokens(address tokenContractAddress) onlyParent {\n', '    ERC20Interface instance = ERC20Interface(tokenContractAddress);\n', '    var forwarderAddress = address(this);\n', '    var forwarderBalance = instance.balanceOf(forwarderAddress);\n', '    if (forwarderBalance == 0) {\n', '      return;\n', '    }\n', '    if (!instance.transfer(parentAddress, forwarderBalance)) {\n', '      throw;\n', '    }\n', '    TokensFlushed(tokenContractAddress, forwarderBalance);\n', '  }\n', '\n', '  /**\n', '   * It is possible that funds were sent to this address before the contract was deployed.\n', '   * We can flush those funds to the destination address.\n', '   */\n', '  function flush() {\n', '    if (!parentAddress.call.value(this.balance)())\n', '      throw;\n', '  }\n', '}\n', '\n', '/**\n', ' * Basic multi-signer wallet designed for use in a co-signing environment where 2 signatures are required to move funds.\n', ' * Typically used in a 2-of-3 signing configuration. Uses ecrecover to allow for 2 signatures in a single transaction.\n', ' */\n', 'contract WalletSimple {\n', '  // Events\n', '  event Deposited(address from, uint value, bytes data);\n', '  event SafeModeActivated(address msgSender);\n', '  event Transacted(\n', '    address msgSender, // Address of the sender of the message initiating the transaction\n', '    address otherSigner, // Address of the signer (second signature) used to initiate the transaction\n', '    bytes32 operation, // Operation hash (sha3 of toAddress, value, data, expireTime, sequenceId)\n', '    address toAddress, // The address the transaction was sent to\n', '    uint value, // Amount of Wei sent to the address\n', '    bytes data // Data sent when invoking the transaction\n', '  );\n', '  event TokenTransacted(\n', '    address msgSender, // Address of the sender of the message initiating the transaction\n', '    address otherSigner, // Address of the signer (second signature) used to initiate the transaction\n', '    bytes32 operation, // Operation hash (sha3 of toAddress, value, tokenContractAddress, expireTime, sequenceId)\n', '    address toAddress, // The address the transaction was sent to\n', '    uint value, // Amount of token sent\n', '    address tokenContractAddress // The contract address of the token\n', '  );\n', '\n', '  // Public fields\n', '  address[] public signers; // The addresses that can co-sign transactions on the wallet\n', '  bool public safeMode = false; // When active, wallet may only send to signer addresses\n', '\n', '  // Internal fields\n', '  uint constant SEQUENCE_ID_WINDOW_SIZE = 10;\n', '  uint[10] recentSequenceIds;\n', '\n', '  /**\n', '   * Modifier that will execute internal code block only if the sender is an authorized signer on this wallet\n', '   */\n', '  modifier onlysigner {\n', '    if (!isSigner(msg.sender)) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * Set up a simple multi-sig wallet by specifying the signers allowed to be used on this wallet.\n', '   * 2 signers will be required to send a transaction from this wallet.\n', '   * Note: The sender is NOT automatically added to the list of signers.\n', '   * Signers CANNOT be changed once they are set\n', '   *\n', '   * @param allowedSigners An array of signers on the wallet\n', '   */\n', '  function WalletSimple(address[] allowedSigners) {\n', '    if (allowedSigners.length != 3) {\n', '      // Invalid number of signers\n', '      throw;\n', '    }\n', '    signers = allowedSigners;\n', '  }\n', '\n', '  /**\n', '   * Gets called when a transaction is received without calling a method\n', '   */\n', '  function() payable {\n', '    if (msg.value > 0) {\n', '      // Fire deposited event if we are receiving funds\n', '      Deposited(msg.sender, msg.value, msg.data);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Create a new contract (and also address) that forwards funds to this contract\n', '   * returns address of newly created forwarder address\n', '   */\n', '  function createForwarder() onlysigner returns (address) {\n', '    return new Forwarder();\n', '  }\n', '\n', '  /**\n', '   * Execute a multi-signature transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\n', '   * The signature is a signed form (using eth.sign) of tightly packed toAddress, value, data, expireTime and sequenceId\n', '   * Sequence IDs are numbers starting from 1. They are used to prevent replay attacks and may not be repeated.\n', '   *\n', '   * @param toAddress the destination address to send an outgoing transaction\n', '   * @param value the amount in Wei to be sent\n', '   * @param data the data to send to the toAddress when invoking the transaction\n', '   * @param expireTime the number of seconds since 1970 for which this transaction is valid\n', '   * @param sequenceId the unique sequence id obtainable from getNextSequenceId\n', '   * @param signature the result of eth.sign on the operationHash sha3(toAddress, value, data, expireTime, sequenceId)\n', '   */\n', '  function sendMultiSig(address toAddress, uint value, bytes data, uint expireTime, uint sequenceId, bytes signature) onlysigner {\n', '    // Verify the other signer\n', '    var operationHash = sha3("ETHER", toAddress, value, data, expireTime, sequenceId);\n', '    \n', '    var otherSigner = verifyMultiSig(toAddress, operationHash, signature, expireTime, sequenceId);\n', '\n', '    // Success, send the transaction\n', '    if (!(toAddress.call.value(value)(data))) {\n', '      // Failed executing transaction\n', '      throw;\n', '    }\n', '    Transacted(msg.sender, otherSigner, operationHash, toAddress, value, data);\n', '  }\n', '  \n', '  /**\n', '   * Execute a multi-signature token transfer from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\n', '   * The signature is a signed form (using eth.sign) of tightly packed toAddress, value, tokenContractAddress, expireTime and sequenceId\n', '   * Sequence IDs are numbers starting from 1. They are used to prevent replay attacks and may not be repeated.\n', '   *\n', '   * @param toAddress the destination address to send an outgoing transaction\n', '   * @param value the amount in tokens to be sent\n', '   * @param tokenContractAddress the address of the erc20 token contract\n', '   * @param expireTime the number of seconds since 1970 for which this transaction is valid\n', '   * @param sequenceId the unique sequence id obtainable from getNextSequenceId\n', '   * @param signature the result of eth.sign on the operationHash sha3(toAddress, value, tokenContractAddress, expireTime, sequenceId)\n', '   */\n', '  function sendMultiSigToken(address toAddress, uint value, address tokenContractAddress, uint expireTime, uint sequenceId, bytes signature) onlysigner {\n', '    // Verify the other signer\n', '    var operationHash = sha3("ERC20", toAddress, value, tokenContractAddress, expireTime, sequenceId);\n', '    \n', '    var otherSigner = verifyMultiSig(toAddress, operationHash, signature, expireTime, sequenceId);\n', '    \n', '    ERC20Interface instance = ERC20Interface(tokenContractAddress);\n', '    if (!instance.transfer(toAddress, value)) {\n', '        throw;\n', '    }\n', '    TokenTransacted(msg.sender, otherSigner, operationHash, toAddress, value, tokenContractAddress);\n', '  }\n', '\n', '  /**\n', '   * Execute a token flush from one of the forwarder addresses. This transfer needs only a single signature and can be done by any signer\n', '   *\n', '   * @param forwarderAddress the address of the forwarder address to flush the tokens from\n', '   * @param tokenContractAddress the address of the erc20 token contract\n', '   */\n', '  function flushForwarderTokens(address forwarderAddress, address tokenContractAddress) onlysigner {    \n', '    Forwarder forwarder = Forwarder(forwarderAddress);\n', '    forwarder.flushTokens(tokenContractAddress);\n', '  }  \n', '  \n', '  /**\n', '   * Do common multisig verification for both eth sends and erc20token transfers\n', '   *\n', '   * @param toAddress the destination address to send an outgoing transaction\n', '   * @param operationHash the sha3 of the toAddress, value, data/tokenContractAddress and expireTime\n', '   * @param signature the tightly packed signature of r, s, and v as an array of 65 bytes (returned by eth.sign)\n', '   * @param expireTime the number of seconds since 1970 for which this transaction is valid\n', '   * @param sequenceId the unique sequence id obtainable from getNextSequenceId\n', '   * returns address of the address to send tokens or eth to\n', '   */\n', '  function verifyMultiSig(address toAddress, bytes32 operationHash, bytes signature, uint expireTime, uint sequenceId) private returns (address) {\n', '\n', '    var otherSigner = recoverAddressFromSignature(operationHash, signature);\n', '\n', '    // Verify if we are in safe mode. In safe mode, the wallet can only send to signers\n', '    if (safeMode && !isSigner(toAddress)) {\n', '      // We are in safe mode and the toAddress is not a signer. Disallow!\n', '      throw;\n', '    }\n', '    // Verify that the transaction has not expired\n', '    if (expireTime < block.timestamp) {\n', '      // Transaction expired\n', '      throw;\n', '    }\n', '\n', '    // Try to insert the sequence ID. Will throw if the sequence id was invalid\n', '    tryInsertSequenceId(sequenceId);\n', '\n', '    if (!isSigner(otherSigner)) {\n', '      // Other signer not on this wallet or operation does not match arguments\n', '      throw;\n', '    }\n', '    if (otherSigner == msg.sender) {\n', '      // Cannot approve own transaction\n', '      throw;\n', '    }\n', '\n', '    return otherSigner;\n', '  }\n', '\n', '  /**\n', '   * Irrevocably puts contract into safe mode. When in this mode, transactions may only be sent to signing addresses.\n', '   */\n', '  function activateSafeMode() onlysigner {\n', '    safeMode = true;\n', '    SafeModeActivated(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * Determine if an address is a signer on this wallet\n', '   * @param signer address to check\n', '   * returns boolean indicating whether address is signer or not\n', '   */\n', '  function isSigner(address signer) returns (bool) {\n', '    // Iterate through all signers on the wallet and\n', '    for (uint i = 0; i < signers.length; i++) {\n', '      if (signers[i] == signer) {\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '  /**\n', '   * Gets the second signer&#39;s address using ecrecover\n', '   * @param operationHash the sha3 of the toAddress, value, data/tokenContractAddress and expireTime\n', '   * @param signature the tightly packed signature of r, s, and v as an array of 65 bytes (returned by eth.sign)\n', '   * returns address recovered from the signature\n', '   */\n', '  function recoverAddressFromSignature(bytes32 operationHash, bytes signature) private returns (address) {\n', '    if (signature.length != 65) {\n', '      throw;\n', '    }\n', '    // We need to unpack the signature, which is given as an array of 65 bytes (from eth.sign)\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '    assembly {\n', '      r := mload(add(signature, 32))\n', '      s := mload(add(signature, 64))\n', '      v := and(mload(add(signature, 65)), 255)\n', '    }\n', '    if (v < 27) {\n', '      v += 27; // Ethereum versions are 27 or 28 as opposed to 0 or 1 which is submitted by some signing libs\n', '    }\n', '    return ecrecover(operationHash, v, r, s);\n', '  }\n', '\n', '  /**\n', '   * Verify that the sequence id has not been used before and inserts it. Throws if the sequence ID was not accepted.\n', '   * We collect a window of up to 10 recent sequence ids, and allow any sequence id that is not in the window and\n', '   * greater than the minimum element in the window.\n', '   * @param sequenceId to insert into array of stored ids\n', '   */\n', '  function tryInsertSequenceId(uint sequenceId) onlysigner private {\n', '    // Keep a pointer to the lowest value element in the window\n', '    uint lowestValueIndex = 0;\n', '    for (uint i = 0; i < SEQUENCE_ID_WINDOW_SIZE; i++) {\n', '      if (recentSequenceIds[i] == sequenceId) {\n', '        // This sequence ID has been used before. Disallow!\n', '        throw;\n', '      }\n', '      if (recentSequenceIds[i] < recentSequenceIds[lowestValueIndex]) {\n', '        lowestValueIndex = i;\n', '      }\n', '    }\n', '    if (sequenceId < recentSequenceIds[lowestValueIndex]) {\n', '      // The sequence ID being used is lower than the lowest value in the window\n', '      // so we cannot accept it as it may have been used before\n', '      throw;\n', '    }\n', '    if (sequenceId > (recentSequenceIds[lowestValueIndex] + 10000)) {\n', '      // Block sequence IDs which are much higher than the lowest value\n', '      // This prevents people blocking the contract by using very large sequence IDs quickly\n', '      throw;\n', '    }\n', '    recentSequenceIds[lowestValueIndex] = sequenceId;\n', '  }\n', '\n', '  /**\n', '   * Gets the next available sequence ID for signing when using executeAndConfirm\n', '   * returns the sequenceId one higher than the highest currently stored\n', '   */\n', '  function getNextSequenceId() returns (uint) {\n', '    uint highestSequenceId = 0;\n', '    for (uint i = 0; i < SEQUENCE_ID_WINDOW_SIZE; i++) {\n', '      if (recentSequenceIds[i] > highestSequenceId) {\n', '        highestSequenceId = recentSequenceIds[i];\n', '      }\n', '    }\n', '    return highestSequenceId + 1;\n', '  }\n', '}']