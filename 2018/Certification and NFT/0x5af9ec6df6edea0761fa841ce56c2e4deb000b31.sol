['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Mintable token\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '  event Burn(address sender,uint256 tokencount);\n', '\n', '  bool public mintingFinished = false ;\n', '  bool public transferAllowed = false ;\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', ' \n', '  \n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '    Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner canMint public returns (bool) {\n', '    mintingFinished = true;\n', '    MintFinished();\n', '    return true;\n', '  }\n', '  \n', '  function resumeMinting() onlyOwner public returns (bool) {\n', '    mintingFinished = false;\n', '    return true;\n', '  }\n', '\n', '  function burn(address _from) external onlyOwner returns (bool success) {\n', '\trequire(balances[_from] != 0);\n', '    uint256 tokencount = balances[_from];\n', '\t//address sender = _from;\n', '\tbalances[_from] = 0;\n', '    totalSupply_ = totalSupply_.sub(tokencount);\n', '    Burn(_from, tokencount);\n', '    return true;\n', '  }\n', '\n', '\n', 'function startTransfer() external onlyOwner\n', '  {\n', '  transferAllowed = true ;\n', '  }\n', '  \n', '  \n', '  function endTransfer() external onlyOwner\n', '  {\n', '  transferAllowed = false ;\n', '  }\n', '\n', '\n', 'function transfer(address _to, uint256 _value) public returns (bool) {\n', 'require(transferAllowed);\n', 'super.transfer(_to,_value);\n', 'return true;\n', '}\n', '\n', 'function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', 'require(transferAllowed);\n', 'super.transferFrom(_from,_to,_value);\n', 'return true;\n', '}\n', '\n', '\n', '}\n', '\n', '\n', '  \n', 'contract ZebiCoin is MintableToken {\n', '  string public constant name = "Zebi Coin";\n', '  string public constant symbol = "ZCO";\n', '  uint64 public constant decimals = 8;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ZCrowdsale\n', '*/\n', 'contract ZCrowdsale is Ownable{\n', '  using SafeMath for uint256;\n', '\n', '  // The token being sold\n', '   MintableToken public token;\n', '   \n', '  uint64 public tokenDecimals;\n', '\n', '  // start and end timestamps where investments are allowed (both inclusive)\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '  uint256 public minTransAmount;\n', '  uint256 public mintedTokensCap; //max 87 million tokens in presale.\n', '  \n', '   //contribution\n', '  mapping(address => uint256) contribution;\n', '  \n', '  //bad contributor\n', '  mapping(address => bool) cancelledList;\n', '\n', '  // address where funds are collected\n', '  address public wallet;\n', '\n', '  bool public withinRefundPeriod; \n', '  \n', '  // how many token units a buyer gets per ether\n', '  uint256 public ETHtoZCOrate;\n', '\n', '  // amount of raised money in wei without factoring refunds\n', '  uint256 public weiRaised;\n', '  \n', '  bool public stopped;\n', '  \n', '   modifier stopInEmergency {\n', '    require (!stopped);\n', '    _;\n', '  }\n', '  \n', '  \n', '  \n', '  modifier inCancelledList {\n', '    require(cancelledList[msg.sender]);\n', '    _;\n', '  }\n', '  \n', '  modifier inRefundPeriod {\n', '  require(withinRefundPeriod);\n', '  _;\n', ' }  \n', '\n', '  /**\n', '   * event for token purchase logging\n', '   */\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  \n', '  event TakeEth(address sender,uint256 value);\n', '  \n', '  event Withdraw(uint256 _value);\n', '  \n', '  event SetParticipantStatus(address _participant);\n', '   \n', '  event Refund(address sender,uint256 refundBalance);\n', '\n', '\n', '  function ZCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _ETHtoZCOrate, address _wallet,uint256 _minTransAmount,uint256 _mintedTokensCap) public {\n', '  \n', '\trequire(_startTime >= now);\n', '    require(_endTime >= _startTime);\n', '    require(_ETHtoZCOrate > 0);\n', '    require(_wallet != address(0));\n', '\t\n', '\ttoken = new ZebiCoin();\n', '\t//token = createTokenContract();\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '    ETHtoZCOrate = _ETHtoZCOrate;\n', '    wallet = _wallet;\n', '    minTransAmount = _minTransAmount;\n', '\ttokenDecimals = 8;\n', '    mintedTokensCap = _mintedTokensCap.mul(10**tokenDecimals);            // mintedTokensCap is in Zwei \n', '\t\n', '  }\n', '\n', '  // fallback function can be used to buy tokens\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '  \n', '    function finishMint() onlyOwner public returns (bool) {\n', '    token.finishMinting();\n', '    return true;\n', '  }\n', '  \n', '  function resumeMint() onlyOwner public returns (bool) {\n', '    token.resumeMinting();\n', '    return true;\n', '  }\n', ' \n', ' \n', '  function startTransfer() external onlyOwner\n', '  {\n', '  token.startTransfer() ;\n', '  }\n', '  \n', '  \n', '   function endTransfer() external onlyOwner\n', '  {\n', '  token.endTransfer() ;\n', '  }\n', '  \n', '  function transferTokenOwnership(address owner) external onlyOwner\n', '  {\n', '    \n', '\ttoken.transferOwnership(owner);\n', '  }\n', '  \n', '   \n', '  function viewCancelledList(address participant) public view returns(bool){\n', '  return cancelledList[participant];\n', '  \n', '  }  \n', '\n', '  // low level token purchase function\n', '  function buyTokens(address beneficiary) public payable {\n', '    require(beneficiary != address(0));\n', '    require(validPurchase());\n', '\n', '    uint256 weiAmount = msg.value;\n', '\n', '    // calculate token amount to be created\n', '    uint256 tokens = getTokenAmount(weiAmount);\n', '   \n', '    // update state\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    token.mint(beneficiary, tokens);\n', '\tcontribution[beneficiary] = contribution[beneficiary].add(weiAmount);\n', '    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '\n', '    forwardFunds();\n', '  }\n', '\n', '  \n', '  // creates the token to be sold.\n', '  // override this method to have crowdsale of a specific mintable token.\n', '  //function createTokenContract() internal returns (MintableToken) {\n', '  //  return new MintableToken();\n', '  // }\n', '\n', '  // returns value in zwei\n', '  // Override this method to have a way to add business logic to your crowdsale when buying\n', '  function getTokenAmount(uint256 weiAmount) public view returns(uint256) {                      \n', '  \n', '\tuint256 ETHtoZweiRate = ETHtoZCOrate.mul(10**tokenDecimals);\n', '    return  SafeMath.div((weiAmount.mul(ETHtoZweiRate)),(1 ether));\n', '  }\n', '\n', '  // send ether to the fund collection wallet\n', '  function forwardFunds() internal {\n', '    wallet.transfer(msg.value);\n', '  }\n', '\n', '  \n', '  function enableRefundPeriod() external onlyOwner{\n', '  withinRefundPeriod = true;\n', '  }\n', '  \n', '  function disableRefundPeriod() external onlyOwner{\n', '  withinRefundPeriod = false;\n', '  }\n', '  \n', '  \n', '   // called by the owner on emergency, triggers stopped state\n', '  function emergencyStop() external onlyOwner {\n', '    stopped = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function release() external onlyOwner {\n', '    stopped = false;\n', '  }\n', '\n', '  function viewContribution(address participant) public view returns(uint256){\n', '  return contribution[participant];\n', '  }  \n', '  \n', '  \n', '  // @return true if the transaction can buy tokens\n', '  function validPurchase() internal view returns (bool) {\n', '    bool withinPeriod = now >= startTime && now <= endTime;\n', '\t//Value(msg.value);\n', '    //bool nonZeroPurchase = msg.value != 0;\n', '\tbool validAmount = msg.value >= minTransAmount;\n', '\tbool withinmintedTokensCap = mintedTokensCap >= (token.totalSupply() + getTokenAmount(msg.value));\n', '    return withinPeriod && validAmount && withinmintedTokensCap;\n', '  }\n', '  \n', '   function refund() external inCancelledList inRefundPeriod {                                                    \n', '        require((contribution[msg.sender] > 0) && token.balanceOf(msg.sender)>0);\n', '       uint256 refundBalance = contribution[msg.sender];\t   \n', '       contribution[msg.sender] = 0;\n', '\t\ttoken.burn(msg.sender);\n', '        msg.sender.transfer(refundBalance); \n', '\t\tRefund(msg.sender,refundBalance);\n', '    } \n', '\t\n', '\tfunction forcedRefund(address _from) external onlyOwner {\n', '\t   require(cancelledList[_from]);\n', '\t   require((contribution[_from] > 0) && token.balanceOf(_from)>0);\n', '       uint256 refundBalance = contribution[_from];\t  \n', '       contribution[_from] = 0;\n', '\t\ttoken.burn(_from);\n', '        _from.transfer(refundBalance); \n', '\t\tRefund(_from,refundBalance);\n', '\t\n', '\t}\n', '\t\n', '\t\n', '\t\n', '\t//takes ethers from zebiwallet to smart contract \n', '    function takeEth() external payable {\n', '\t\tTakeEth(msg.sender,msg.value);\n', '    }\n', '\t\n', '\t//transfers ether from smartcontract to zebiwallet\n', '     function withdraw(uint256 _value) public onlyOwner {\n', '        wallet.transfer(_value);\n', '\t\tWithdraw(_value);\n', '    }\n', '\t function addCancellation (address _participant) external onlyOwner returns (bool success) {\n', '           cancelledList[_participant] = true;\n', '\t\t   return true;\n', '   } \n', '}\n', '\n', '\n', '\n', 'contract ZebiCoinCrowdsale is ZCrowdsale {\n', '\n', '  function ZebiCoinCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet,uint256 _minTransAmount,uint256 _mintedTokensCap)\n', '  ZCrowdsale(_startTime, _endTime, _rate, _wallet , _minTransAmount,_mintedTokensCap){\n', '  }\n', '\n', ' // creates the token to be sold.\n', ' // function createTokenContract() internal returns (MintableToken) {\n', ' //  return new ZebiCoin();\n', ' // }\n', '}\n', '\n', 'contract ZebiCoinTempMgr is Ownable{\n', '  using SafeMath for uint256;\n', '\n', '  // address where funds are collected\n', '  address public wallet;\n', '  \n', '  // instance of presale contract  \n', '  ZebiCoinCrowdsale public preSaleCSSC;\n', '  \n', '  // instance of token contract\n', '  ZebiCoin public tsc;\n', '   \n', '  // number of decimals allowed in ZCO \n', '  uint64 tokenDecimals;\n', '   \n', '  //bad contributor of presale\n', '  mapping(address => bool) preSaleCancelledList;\n', '\n', '  // contains token value in zwei\n', '  mapping(address => uint256) noncsAllocations;\n', '  \n', '  // check for refund period\n', '  bool public withinRefundPeriod; \n', '  \n', '  // amount refunded to each investor\n', '  mapping(address => uint256)  preSaleRefunds;\n', '  \n', '  \n', '  \n', '  modifier inPreSaleCancelledList {\n', '    require(preSaleCancelledList[msg.sender]);\n', '    _;\n', '  }\n', '  \n', '  modifier inRefundPeriod {\n', '  require(withinRefundPeriod);\n', '  _;\n', ' }\n', ' \n', ' \n', '  event TakeEth(address sender,uint256 value);\n', '  event Withdraw(uint256 _value);\n', '  event PreSaleRefund(address sender,uint256 refundBalance);\n', '  event AllocatenonCSTokens(address indexed beneficiary,uint256 amount);\n', '\n', '  \n', '  function ZebiCoinTempMgr(address presaleCrowdsale, address tokenAddress, address _wallet) public {\n', ' \n', '    wallet = _wallet;\n', '    preSaleCSSC = ZebiCoinCrowdsale(presaleCrowdsale);\n', '\ttsc = ZebiCoin(tokenAddress);\n', '    tokenDecimals = tsc.decimals();\n', '  }\n', '  \n', '  function finishMint() onlyOwner public returns (bool) {\n', '    tsc.finishMinting();\n', '    return true;\n', '  }\n', '  \n', '  function resumeMint() onlyOwner public returns (bool) {\n', '    tsc.resumeMinting();\n', '    return true;\n', '  }\n', ' \n', ' \n', '  function startTransfer() external onlyOwner{\n', '    tsc.startTransfer() ;\n', '  }\n', '  \n', '  function endTransfer() external onlyOwner{\n', '    tsc.endTransfer() ;\n', '  }\n', '  \n', '  function transferTokenOwnership(address owner) external onlyOwner{\n', '    tsc.transferOwnership(owner);\n', '  }\n', '  \n', '  function allocatenonCSTokens(address beneficiary,uint256 tokens) external onlyOwner\n', '  {\n', '\trequire(beneficiary != address(0));\n', '\tuint256 Zweitokens = tokens.mul(10**(tokenDecimals ));\n', '\tnoncsAllocations[beneficiary]= Zweitokens.add(noncsAllocations[beneficiary]);\n', '\ttsc.mint(beneficiary, Zweitokens);\n', '\tAllocatenonCSTokens(beneficiary,Zweitokens);\n', '  }\n', '\t\n', '  function revertNoncsallocation(address beneficiary) external onlyOwner\n', '  {\n', '\trequire(noncsAllocations[beneficiary]!=0);\n', '\tnoncsAllocations[beneficiary]=0;\n', '\ttsc.burn(beneficiary);\n', '  }\n', ' \n', '  function viewNoncsallocations(address participant) public view returns(uint256){\n', '    return noncsAllocations[participant];\n', '  }\n', '  \n', '  function viewPreSaleCancelledList(address participant) public view returns(bool){\n', '    return preSaleCancelledList[participant];\n', '  } \n', '  \n', '  function viewPreSaleRefunds(address participant) public view returns(uint256){\n', '    return preSaleRefunds[participant];\n', '  } \n', '  \n', '  function enableRefundPeriod() external onlyOwner{\n', '    withinRefundPeriod = true;\n', '  }\n', '  \n', '  function disableRefundPeriod() external onlyOwner{\n', '    withinRefundPeriod = false;\n', '  }\n', '  \n', '  function refund() external inPreSaleCancelledList inRefundPeriod {                                                    \n', '    require((preSaleCSSC.viewContribution(msg.sender) > 0) && tsc.balanceOf(msg.sender)>0);\n', '    uint256 refundBalance = preSaleCSSC.viewContribution(msg.sender);\t   \n', '    preSaleRefunds[msg.sender] = refundBalance;\n', '    tsc.burn(msg.sender);\n', '    msg.sender.transfer(refundBalance); \n', '\tPreSaleRefund(msg.sender,refundBalance);\n', '  } \n', '\t\n', '  function forcedRefund(address _from) external onlyOwner {\n', '\trequire(preSaleCancelledList[_from]);\n', '\trequire((preSaleCSSC.viewContribution(_from) > 0) && tsc.balanceOf(_from)>0);\n', '    uint256 refundBalance = preSaleCSSC.viewContribution(_from);\t  \n', '    preSaleRefunds[_from] = refundBalance;\n', '\ttsc.burn(_from);\n', '    _from.transfer(refundBalance); \n', '\tPreSaleRefund(_from,refundBalance);\n', '  }\n', '  \n', '  //takes ethers from zebiwallet to smart contract \n', '  function takeEth() external payable {\n', '\tTakeEth(msg.sender,msg.value);\n', '  }\n', '\t\n', '  //transfers ether from smartcontract to zebiwallet\n', '  function withdraw(uint256 _value) public onlyOwner {\n', '    wallet.transfer(_value);\n', '\tWithdraw(_value);\n', '  }\n', '\t\n', '  function addCancellation (address _participant) external onlyOwner returns (bool success) {\n', '    preSaleCancelledList[_participant] = true;\n', '\treturn true;\n', '  }\n', '  \n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ZebiMainCrowdsale\n', '*/\n', 'contract ZebiMainCrowdsale is Ownable{\n', ' \n', '  using SafeMath for uint256;\n', '\n', '  // The token being sold\n', '  ZebiCoin public token;\n', '  \n', '  //calender year count;\n', '  //uint256 calenderYearCounter;\n', '  \n', '  //lockeed tokens minted in current calender year\n', '  uint256 currentYearMinted;\n', '  \n', '  //calenderYearMintCap for Zebi\n', '  uint256 calenderYearMintCap;\n', '  //calender year start\n', '  uint256 calenderYearStart;\n', '  \n', '  //calenderYearEnd\n', '  uint256 calenderYearEnd;\n', '  \n', '  //mintinge vested token start time\n', '  uint256 vestedMintStartTime;\n', '  \n', '  \n', '  //flag : whethere remainingZCO after crowdsale allocated or not\n', '  //bool remainingZCOAllocated;\n', '  \n', '  //TODO\n', '  uint256 zebiZCOShare;\n', '  //TODO \n', '  uint256 crowdsaleZCOCap;\n', '  \n', '  //transaction Start time\n', '  uint256 transStartTime;\n', '  \n', '  // presale instance\n', '  ZebiCoinCrowdsale public zcc;\n', '  \n', '  // tempMngr instance\n', '  ZebiCoinTempMgr public tempMngr;\n', '   \n', '  // Number of decimals allowed for ZCO\n', '  uint64 public tokenDecimals;\n', '\n', '  // start and end timestamps where investments are allowed (both inclusive)\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '  //In seconds initialized in constructor only gold list members can buy\n', '  uint256 public goldListPeriod;\n', '  \n', '  //endTime of 2nd bonus period minus startTime in seconds initialized in constructor: 2nd period for bonuses\n', '  uint256 public postGoldPeriod;\n', '  \n', '  // Minimum amount to be invested in wei\n', '  uint256 public minTransAmount;\n', '  \n', '  // Hardcap in wei\n', '  uint256 public ethCap; \n', '  \n', '  // Contribution of each investor in main crowdsale\n', '  mapping(address => uint256) mainContribution;\n', '    \n', '  // Bad contributor\n', '  mapping(address => bool) mainCancelledList;\n', '  \n', '  // Gold Period Cap per address\n', '  uint256 goldPeriodCap;\n', '  \n', '  //is the transaction occurring during gold list period\n', '  bool goldListPeriodFlag;\n', '  \n', '  //goldListPeriod Contribution TODO\n', '  mapping(address=>uint256) goldListContribution;\n', '  // Gold List \n', '  mapping(address => bool) goldList;\n', '  //discounts mapping number of coins to percentage discount\n', '  // mapping(uint256 => uint256) discounts;\n', '  \n', '  // KYC Accepted List \n', '  mapping(address => bool) kycAcceptedList;\n', '  // Address where funds are collected\n', '  address public wallet;\n', '\n', '  bool public withinRefundPeriod; \n', '  \n', '  // amount refunded to each investor \n', '  mapping(address => uint256)  preSaleRefundsInMainSale;\n', '  \n', '  \n', '  uint256 public tokens;\n', '  \n', '  // net wei used to buy ZCOs in the transaction\n', '  uint256 public weiAmount;\n', '  \n', '  // how many token units a buyer gets per ether\n', '  uint256 public ETHtoZWeirate;\n', '\n', '  // amount of raised money in wei without factoring refunds\n', '  uint256 public mainWeiRaised;  \n', '  \n', '   \n', '  \n', '  modifier inCancelledList {\n', '    require(mainCancelledList[msg.sender]);\n', '    _;\n', '  }\n', '  \n', '  modifier inRefundPeriod {\n', '  require(withinRefundPeriod);\n', '  _;\n', '  }  \n', '\n', '\n', '  event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n', '  \n', '  event TakeEth(address sender,uint256 value);\n', '  \n', '  event Withdraw(uint256 _value);\n', '  \n', '  event SetParticipantStatus(address _participant);\n', '   \n', '  event Refund(address sender,uint256 refundBalance);\n', '\n', '\n', '  function ZebiMainCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _ETHtoZWeirate, address _wallet,uint256 _minTransAmount,uint256 _ethCap, address tokenAddress, address presaleAddress,address tempMngrAddress,uint256 _goldListPeriod,uint256 _postGoldPeriod,uint256 _goldPeriodCap,uint256 _vestedMintStartTime,uint256 _calenderYearStart) public {\n', '  \n', '\trequire(_startTime >= now);\n', '    require(_endTime >= _startTime);\n', '    require(_ETHtoZWeirate > 0);\n', '    require(_wallet != address(0));\n', '\t\n', '\ttoken = ZebiCoin(tokenAddress);\t\n', '\tzcc = ZebiCoinCrowdsale(presaleAddress);\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '    ETHtoZWeirate = _ETHtoZWeirate;\n', '    wallet = _wallet;\n', '    minTransAmount = _minTransAmount;\n', '\ttokenDecimals = token.decimals();\n', '    ethCap = _ethCap;       \n', '\ttempMngr=ZebiCoinTempMgr(tempMngrAddress);\n', '\tgoldListPeriod=_goldListPeriod;\n', '\tpostGoldPeriod=_postGoldPeriod;\n', '\tzebiZCOShare=SafeMath.mul(500000000,(10**tokenDecimals));\n', '\tcrowdsaleZCOCap=zebiZCOShare;\n', '\tgoldPeriodCap=_goldPeriodCap;\n', '\tcalenderYearMintCap = SafeMath.div((zebiZCOShare.mul(2)),8);\n', '\t//vestedMintStartTime=(startTime +((18 *30)*1 days)); \n', '\t//vestedMintStartTime=1567296000; //1 Sep 2019\n', '\tvestedMintStartTime=_vestedMintStartTime;\n', '\t//calenderYearStart=1546300800; //1 Jan 2019 0:0:0\n', '\tcalenderYearStart=_calenderYearStart;\n', '\t//calenderYearEnd=1577836799;   // 31 Dec 2019 23:59:59\n', '\tcalenderYearEnd=(calenderYearStart+1 years )- 1;\n', '  }\n', '\n', '  // Fallback function used to buy tokens\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '  \n', '  function finishMint() onlyOwner public returns (bool) {\n', '    token.finishMinting();\n', '    return true;\n', '  }\n', '  \n', '  function resumeMint() onlyOwner public returns (bool) {\n', '    token.resumeMinting();\n', '    return true;\n', '  }\n', ' \n', '  function startTransfer() external onlyOwner{\n', '    token.startTransfer() ;\n', '  }\n', '  \n', '  function endTransfer() external onlyOwner{\n', '    token.endTransfer() ;\n', '  }\n', '  \n', '  function transferTokenOwnership(address owner) external onlyOwner{\n', '    token.transferOwnership(owner);\n', '  }\n', '  \n', '  function viewCancelledList(address participant) public view returns(bool){\n', '    return mainCancelledList[participant];\n', '  } \n', '  \n', '  function viewGoldList(address participant) public view returns(bool){\n', '    return goldList[participant];\n', '  }\n', '  function addToGoldList (address _participant) external onlyOwner returns (bool ) {\n', '    goldList[_participant] = true;\n', '\treturn true;\n', '  }\n', '  function removeFromGoldList(address _participant) external onlyOwner returns(bool ){\n', '      goldList[_participant]=false;\n', '      return true;\n', '  }\n', '  function viewKYCAccepted(address participant) public view returns(bool){\n', '    return kycAcceptedList[participant];\n', '  }\n', '  function addToKYCList (address _participant) external onlyOwner returns (bool ) {\n', '    kycAcceptedList[_participant] = true;\n', '\treturn true;\n', '  }\n', '  function removeFromKYCList (address _participant) external onlyOwner returns (bool){\n', '      kycAcceptedList[_participant]=false;\n', '  }\n', '  function viewPreSaleRefundsInMainSale(address participant) public view returns(uint256){\n', '    return preSaleRefundsInMainSale[participant];\n', '  }\n', '  /*function addToPreSaleRefunds(address participant,uint256 amountInEth) external onlyOwner returns(bool){\n', '      preSaleRefundsInMainSale[participant]=amountInEth.add(preSaleRefundsInMainSale[participant]);\n', '      \n', '  }\n', '  function removeFromPreSaleRefunds(address participant,uint256 amountInEth) external onlyOwner returns(bool){\n', '      preSaleRefundsInMainSale[participant]=(preSaleRefundsInMainSale[participant]).sub(amountInEth);\n', '      \n', '  }*/\n', '\n', '  // Low level token purchase function\n', '  function buyTokens(address beneficiary) public payable {\n', '    transStartTime=now;\n', '    require(goldList[beneficiary]||kycAcceptedList[beneficiary]);\n', '    goldListPeriodFlag=false;\n', '\trequire(beneficiary != address(0));\n', '    require(validPurchase());\n', '    uint256 extraEth=0;\n', '    weiAmount = msg.value;\n', '   /* if(goldListPeriodFlag){\n', '        weiAmount=goldPeriodCap.sub(goldListContribution[msg.sender]);\n', '        extraEth=(msg.value).sub(weiAmount);\n', '    }*/\n', '    \n', '    //for partial fulfilment feature : return extra ether transferred by investor\n', '    if((msg.value>ethCap.sub(mainWeiRaised)) && !goldListPeriodFlag){\n', '\t\tweiAmount=ethCap.sub(mainWeiRaised);\n', '\t\textraEth=(msg.value).sub(weiAmount);\n', '\t }\n', '\t \n', '    // calculate token amount to be alloted\n', '     tokens = getTokenAmount(weiAmount);\n', '   \n', '    // update state\n', '    mainWeiRaised = mainWeiRaised.add(weiAmount);\n', '    token.mint(beneficiary, tokens);\n', '\tmainContribution[beneficiary] = mainContribution[beneficiary].add(weiAmount);\n', '\tif(goldListPeriodFlag){\n', '\t    goldListContribution[beneficiary] = goldListContribution[beneficiary].add(weiAmount);\n', '\t}\n', '\t\n', '    //TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '    TokenPurchase(beneficiary, weiAmount, tokens);\n', '\n', '    forwardFunds();\n', '    if(extraEth>0){\n', '        beneficiary.transfer(extraEth);\n', '    }\n', '    \n', ' \n', '  }\n', '\n', '\n', '  // returns value in zwei calculating number of tokens including bonuses\n', '  \n', '  function getTokenAmount(uint256 weiAmount1) public view returns(uint256) {                      \n', '    \n', '\t//uint256 ETHtoZweiRate = ETHtoZWeirate;\n', '    uint256 number = SafeMath.div((weiAmount1.mul(ETHtoZWeirate)),(1 ether));\n', '\tuint256 volumeBonus;\n', '\tuint256 timeBonus;\n', '\tif(number >= 400000000000000)\n', '\t{\n', '\tvolumeBonus = SafeMath.div((number.mul(25)),100);\n', '\t}\n', '\telse if(number>= 150000000000000) {\n', '\tvolumeBonus = SafeMath.div((number.mul(20)),100);\n', '\t    }\n', '\telse if(number>= 80000000000000) {\n', '\tvolumeBonus = SafeMath.div((number.mul(15)),100);\n', '\t    }\n', '\telse if(number>= 40000000000000) {\n', '\tvolumeBonus = SafeMath.div((number.mul(10)),100);\n', '\t    }\n', '\telse if(number>= 7500000000000) {\n', '\tvolumeBonus = SafeMath.div((number.mul(5)),100);\n', '\t    }\n', '\t else{\n', '\t     volumeBonus=0;\n', '\t }\n', '\t//\n', '\tif(goldListPeriodFlag){\n', '\t    timeBonus = SafeMath.div((number.mul(15)),100);\n', '\t}\n', '\telse if(transStartTime <= startTime + postGoldPeriod){\n', '\t    timeBonus = SafeMath.div((number.mul(10)),100);\n', '\t}\n', '\telse{\n', '\t    timeBonus=0;\n', '\t}\n', '    number=number+timeBonus+volumeBonus;\n', '    return number; \n', '\t\n', '  }\n', '\t\n', '\t\n', '\t\n', '  // send ether to the fund collection wallet\n', '  function forwardFunds() internal {\n', '    wallet.transfer(weiAmount);\n', '  }\n', '\n', '  \n', '  function enableRefundPeriod() external onlyOwner{\n', '    withinRefundPeriod = true;\n', '  }\n', '  \n', '  function disableRefundPeriod() external onlyOwner{\n', '    withinRefundPeriod = false;\n', '  }\n', ' \n', '  function viewContribution(address participant) public view returns(uint256){\n', '    return mainContribution[participant];\n', '  }  \n', '  \n', '  \n', '  // checks if the investor can buy tokens\n', '  \n', '  function validPurchase() internal view returns (bool) {\n', '    bool withinPeriod = transStartTime >= startTime && transStartTime <= endTime;\n', '\tbool validAmount = msg.value >= minTransAmount;\n', '\t//bool withinEthCap = ethCap >= (msg.value + mainWeiRaised);\n', '\tbool withinEthCap = ((ethCap.sub(mainWeiRaised))>0);\n', '\tbool goldPeriodValid=true;\n', '\tif(transStartTime <= (startTime + goldListPeriod)){\n', '\t    goldPeriodValid=(goldList[msg.sender])&&(goldListContribution[msg.sender]+msg.value <= goldPeriodCap);\n', '\t    goldListPeriodFlag=true;\n', '\t    \n', '\t}\n', '    return withinPeriod && validAmount && withinEthCap && goldPeriodValid;\n', '  }\n', '  \n', '  /*function mintLeftOverZCOToWallet() external onlyOwner returns (bool){\n', '      //uint256 Zweitokens = amount;\n', '      require(!remainingZCOAllocated);\n', '      require(now>endTime);\n', '      \n', '      //uint256 ETHtoZweiRate = ETHtoZWeirate.mul(10**tokenDecimals);\n', '      //uint256 remainingCap=ethCap.sub(mainWeiRaised);\n', '      //uint256 amount = SafeMath.div((remainingCap.mul(ETHtoZweiRate)),(1 ether));\n', '      //mainWeiRaised = mainWeiRaised.add(amount);\n', '      //uint256 zweitokens = SafeMath.mul(500000000,10**(tokenDecimals ));\n', '      uint256 zweitokens=crowdsaleZCOCap.sub(token.totalSupply());\n', '      //zweitokens=zweitokens.sub(token.totalSupply());\n', '      token.mint(wallet, zweitokens);\n', '      remainingZCOAllocated=true;\n', '      return true;\n', '  }*/\n', '  function mintAndAllocateZCO(address partnerAddress,uint256 amountInZWei) external onlyOwner returns(bool){\n', '      require((crowdsaleZCOCap.sub(token.totalSupply()))>=amountInZWei);\n', '      require(partnerAddress!=address(0));\n', '      //require(now>endTime);\n', '      //require(!remainingZCOAllocated);\n', '      token.mint(partnerAddress,amountInZWei);\n', '      return true;\n', '  }\n', '  \n', '  function mintvestedTokens (address partnerAddress,uint256 zweitokens) external onlyOwner returns(bool){\n', '      require(zweitokens<=zebiZCOShare && zweitokens>0);\n', '      \n', '      require(partnerAddress!=address(0));\n', '      require(now>=vestedMintStartTime);\n', '      //year\n', '      uint256 currentYearCounter=SafeMath.div((SafeMath.sub(now,calenderYearStart)),1 years);\n', '      //if(currentYearCounter>calenderYearCounter){\n', '      if(now>calenderYearEnd && currentYearCounter>=1){\n', '          //calenderYearCounter=currentYearCounter;\n', '          currentYearMinted=0;\n', '          calenderYearStart=calenderYearEnd+((currentYearCounter-1)*1 years) +1;\n', '          calenderYearEnd=(calenderYearStart+ 1 years )- 1;\n', '      }\n', '      \n', '      require(currentYearMinted+zweitokens<=calenderYearMintCap);\n', '      currentYearMinted=currentYearMinted+zweitokens;\n', '      token.mint(partnerAddress,zweitokens);\n', '      zebiZCOShare=zebiZCOShare.sub(zweitokens);\n', '  }\n', '  \n', '  \n', '  \n', '  function refund() external inCancelledList inRefundPeriod {  \n', '    require(mainCancelledList[msg.sender]);  \n', '    require((mainContribution[msg.sender] > 0) && token.balanceOf(msg.sender)>0);\n', '\tuint256 presaleContribution = zcc.viewContribution(msg.sender);\n', '    uint256 refundBalance = (mainContribution[msg.sender]).add(presaleContribution) ;\n', '    uint256 preSaleRefundTemp= tempMngr.viewPreSaleRefunds(msg.sender);\n', '    uint256 preSaleRefundMain=presaleContribution.sub(preSaleRefundTemp);\n', '    refundBalance=refundBalance.sub(preSaleRefundTemp);\n', '    refundBalance=refundBalance.sub(preSaleRefundsInMainSale[msg.sender]);\n', '    preSaleRefundsInMainSale[msg.sender]=preSaleRefundMain;\n', '    \n', '    mainContribution[msg.sender] = 0;\n', '\ttoken.burn(msg.sender);\n', '    msg.sender.transfer(refundBalance); \n', '\tRefund(msg.sender,refundBalance);\n', '  } \n', '\t\n', '  function forcedRefund(address _from) external onlyOwner {\n', '\trequire(mainCancelledList[_from]);\n', '\trequire((mainContribution[_from] > 0) && token.balanceOf(_from)>0);\n', '\tuint256 presaleContribution = zcc.viewContribution(_from);\n', '    uint256 refundBalance = (mainContribution[_from]).add(presaleContribution) ;\n', '    uint256 preSaleRefundTemp= tempMngr.viewPreSaleRefunds(_from);\n', '    uint256 preSaleRefundMain=presaleContribution.sub(preSaleRefundTemp);\n', '    refundBalance=refundBalance.sub(preSaleRefundTemp);\n', '    refundBalance=refundBalance.sub(preSaleRefundsInMainSale[_from]);\n', '    preSaleRefundsInMainSale[_from]=preSaleRefundMain;\n', '    mainContribution[_from] = 0;\n', '\ttoken.burn(_from);\n', '    _from.transfer(refundBalance); \n', '\tRefund(_from,refundBalance);\n', '  }\n', '\t\n', '\t\n', '  //takes ethers from zebiwallet to smart contract \n', '  function takeEth() external payable {\n', '\tTakeEth(msg.sender,msg.value);\n', '  }\n', '\t\n', '  //transfers ether from smartcontract to zebiwallet\n', '  function withdraw(uint256 _value) public onlyOwner {\n', '    wallet.transfer(_value);\n', '\tWithdraw(_value);\n', '  }\n', '\t\n', '  //Maintains list of investors with failed KYC validation\n', '  function addCancellation (address _participant) external onlyOwner returns (bool success) {\n', '    mainCancelledList[_participant] = true;\n', '\treturn true;\n', '  } \n', '\n', '  }']
['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Mintable token\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '  event Burn(address sender,uint256 tokencount);\n', '\n', '  bool public mintingFinished = false ;\n', '  bool public transferAllowed = false ;\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', ' \n', '  \n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '    Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner canMint public returns (bool) {\n', '    mintingFinished = true;\n', '    MintFinished();\n', '    return true;\n', '  }\n', '  \n', '  function resumeMinting() onlyOwner public returns (bool) {\n', '    mintingFinished = false;\n', '    return true;\n', '  }\n', '\n', '  function burn(address _from) external onlyOwner returns (bool success) {\n', '\trequire(balances[_from] != 0);\n', '    uint256 tokencount = balances[_from];\n', '\t//address sender = _from;\n', '\tbalances[_from] = 0;\n', '    totalSupply_ = totalSupply_.sub(tokencount);\n', '    Burn(_from, tokencount);\n', '    return true;\n', '  }\n', '\n', '\n', 'function startTransfer() external onlyOwner\n', '  {\n', '  transferAllowed = true ;\n', '  }\n', '  \n', '  \n', '  function endTransfer() external onlyOwner\n', '  {\n', '  transferAllowed = false ;\n', '  }\n', '\n', '\n', 'function transfer(address _to, uint256 _value) public returns (bool) {\n', 'require(transferAllowed);\n', 'super.transfer(_to,_value);\n', 'return true;\n', '}\n', '\n', 'function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', 'require(transferAllowed);\n', 'super.transferFrom(_from,_to,_value);\n', 'return true;\n', '}\n', '\n', '\n', '}\n', '\n', '\n', '  \n', 'contract ZebiCoin is MintableToken {\n', '  string public constant name = "Zebi Coin";\n', '  string public constant symbol = "ZCO";\n', '  uint64 public constant decimals = 8;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ZCrowdsale\n', '*/\n', 'contract ZCrowdsale is Ownable{\n', '  using SafeMath for uint256;\n', '\n', '  // The token being sold\n', '   MintableToken public token;\n', '   \n', '  uint64 public tokenDecimals;\n', '\n', '  // start and end timestamps where investments are allowed (both inclusive)\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '  uint256 public minTransAmount;\n', '  uint256 public mintedTokensCap; //max 87 million tokens in presale.\n', '  \n', '   //contribution\n', '  mapping(address => uint256) contribution;\n', '  \n', '  //bad contributor\n', '  mapping(address => bool) cancelledList;\n', '\n', '  // address where funds are collected\n', '  address public wallet;\n', '\n', '  bool public withinRefundPeriod; \n', '  \n', '  // how many token units a buyer gets per ether\n', '  uint256 public ETHtoZCOrate;\n', '\n', '  // amount of raised money in wei without factoring refunds\n', '  uint256 public weiRaised;\n', '  \n', '  bool public stopped;\n', '  \n', '   modifier stopInEmergency {\n', '    require (!stopped);\n', '    _;\n', '  }\n', '  \n', '  \n', '  \n', '  modifier inCancelledList {\n', '    require(cancelledList[msg.sender]);\n', '    _;\n', '  }\n', '  \n', '  modifier inRefundPeriod {\n', '  require(withinRefundPeriod);\n', '  _;\n', ' }  \n', '\n', '  /**\n', '   * event for token purchase logging\n', '   */\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  \n', '  event TakeEth(address sender,uint256 value);\n', '  \n', '  event Withdraw(uint256 _value);\n', '  \n', '  event SetParticipantStatus(address _participant);\n', '   \n', '  event Refund(address sender,uint256 refundBalance);\n', '\n', '\n', '  function ZCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _ETHtoZCOrate, address _wallet,uint256 _minTransAmount,uint256 _mintedTokensCap) public {\n', '  \n', '\trequire(_startTime >= now);\n', '    require(_endTime >= _startTime);\n', '    require(_ETHtoZCOrate > 0);\n', '    require(_wallet != address(0));\n', '\t\n', '\ttoken = new ZebiCoin();\n', '\t//token = createTokenContract();\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '    ETHtoZCOrate = _ETHtoZCOrate;\n', '    wallet = _wallet;\n', '    minTransAmount = _minTransAmount;\n', '\ttokenDecimals = 8;\n', '    mintedTokensCap = _mintedTokensCap.mul(10**tokenDecimals);            // mintedTokensCap is in Zwei \n', '\t\n', '  }\n', '\n', '  // fallback function can be used to buy tokens\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '  \n', '    function finishMint() onlyOwner public returns (bool) {\n', '    token.finishMinting();\n', '    return true;\n', '  }\n', '  \n', '  function resumeMint() onlyOwner public returns (bool) {\n', '    token.resumeMinting();\n', '    return true;\n', '  }\n', ' \n', ' \n', '  function startTransfer() external onlyOwner\n', '  {\n', '  token.startTransfer() ;\n', '  }\n', '  \n', '  \n', '   function endTransfer() external onlyOwner\n', '  {\n', '  token.endTransfer() ;\n', '  }\n', '  \n', '  function transferTokenOwnership(address owner) external onlyOwner\n', '  {\n', '    \n', '\ttoken.transferOwnership(owner);\n', '  }\n', '  \n', '   \n', '  function viewCancelledList(address participant) public view returns(bool){\n', '  return cancelledList[participant];\n', '  \n', '  }  \n', '\n', '  // low level token purchase function\n', '  function buyTokens(address beneficiary) public payable {\n', '    require(beneficiary != address(0));\n', '    require(validPurchase());\n', '\n', '    uint256 weiAmount = msg.value;\n', '\n', '    // calculate token amount to be created\n', '    uint256 tokens = getTokenAmount(weiAmount);\n', '   \n', '    // update state\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    token.mint(beneficiary, tokens);\n', '\tcontribution[beneficiary] = contribution[beneficiary].add(weiAmount);\n', '    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '\n', '    forwardFunds();\n', '  }\n', '\n', '  \n', '  // creates the token to be sold.\n', '  // override this method to have crowdsale of a specific mintable token.\n', '  //function createTokenContract() internal returns (MintableToken) {\n', '  //  return new MintableToken();\n', '  // }\n', '\n', '  // returns value in zwei\n', '  // Override this method to have a way to add business logic to your crowdsale when buying\n', '  function getTokenAmount(uint256 weiAmount) public view returns(uint256) {                      \n', '  \n', '\tuint256 ETHtoZweiRate = ETHtoZCOrate.mul(10**tokenDecimals);\n', '    return  SafeMath.div((weiAmount.mul(ETHtoZweiRate)),(1 ether));\n', '  }\n', '\n', '  // send ether to the fund collection wallet\n', '  function forwardFunds() internal {\n', '    wallet.transfer(msg.value);\n', '  }\n', '\n', '  \n', '  function enableRefundPeriod() external onlyOwner{\n', '  withinRefundPeriod = true;\n', '  }\n', '  \n', '  function disableRefundPeriod() external onlyOwner{\n', '  withinRefundPeriod = false;\n', '  }\n', '  \n', '  \n', '   // called by the owner on emergency, triggers stopped state\n', '  function emergencyStop() external onlyOwner {\n', '    stopped = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function release() external onlyOwner {\n', '    stopped = false;\n', '  }\n', '\n', '  function viewContribution(address participant) public view returns(uint256){\n', '  return contribution[participant];\n', '  }  \n', '  \n', '  \n', '  // @return true if the transaction can buy tokens\n', '  function validPurchase() internal view returns (bool) {\n', '    bool withinPeriod = now >= startTime && now <= endTime;\n', '\t//Value(msg.value);\n', '    //bool nonZeroPurchase = msg.value != 0;\n', '\tbool validAmount = msg.value >= minTransAmount;\n', '\tbool withinmintedTokensCap = mintedTokensCap >= (token.totalSupply() + getTokenAmount(msg.value));\n', '    return withinPeriod && validAmount && withinmintedTokensCap;\n', '  }\n', '  \n', '   function refund() external inCancelledList inRefundPeriod {                                                    \n', '        require((contribution[msg.sender] > 0) && token.balanceOf(msg.sender)>0);\n', '       uint256 refundBalance = contribution[msg.sender];\t   \n', '       contribution[msg.sender] = 0;\n', '\t\ttoken.burn(msg.sender);\n', '        msg.sender.transfer(refundBalance); \n', '\t\tRefund(msg.sender,refundBalance);\n', '    } \n', '\t\n', '\tfunction forcedRefund(address _from) external onlyOwner {\n', '\t   require(cancelledList[_from]);\n', '\t   require((contribution[_from] > 0) && token.balanceOf(_from)>0);\n', '       uint256 refundBalance = contribution[_from];\t  \n', '       contribution[_from] = 0;\n', '\t\ttoken.burn(_from);\n', '        _from.transfer(refundBalance); \n', '\t\tRefund(_from,refundBalance);\n', '\t\n', '\t}\n', '\t\n', '\t\n', '\t\n', '\t//takes ethers from zebiwallet to smart contract \n', '    function takeEth() external payable {\n', '\t\tTakeEth(msg.sender,msg.value);\n', '    }\n', '\t\n', '\t//transfers ether from smartcontract to zebiwallet\n', '     function withdraw(uint256 _value) public onlyOwner {\n', '        wallet.transfer(_value);\n', '\t\tWithdraw(_value);\n', '    }\n', '\t function addCancellation (address _participant) external onlyOwner returns (bool success) {\n', '           cancelledList[_participant] = true;\n', '\t\t   return true;\n', '   } \n', '}\n', '\n', '\n', '\n', 'contract ZebiCoinCrowdsale is ZCrowdsale {\n', '\n', '  function ZebiCoinCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet,uint256 _minTransAmount,uint256 _mintedTokensCap)\n', '  ZCrowdsale(_startTime, _endTime, _rate, _wallet , _minTransAmount,_mintedTokensCap){\n', '  }\n', '\n', ' // creates the token to be sold.\n', ' // function createTokenContract() internal returns (MintableToken) {\n', ' //  return new ZebiCoin();\n', ' // }\n', '}\n', '\n', 'contract ZebiCoinTempMgr is Ownable{\n', '  using SafeMath for uint256;\n', '\n', '  // address where funds are collected\n', '  address public wallet;\n', '  \n', '  // instance of presale contract  \n', '  ZebiCoinCrowdsale public preSaleCSSC;\n', '  \n', '  // instance of token contract\n', '  ZebiCoin public tsc;\n', '   \n', '  // number of decimals allowed in ZCO \n', '  uint64 tokenDecimals;\n', '   \n', '  //bad contributor of presale\n', '  mapping(address => bool) preSaleCancelledList;\n', '\n', '  // contains token value in zwei\n', '  mapping(address => uint256) noncsAllocations;\n', '  \n', '  // check for refund period\n', '  bool public withinRefundPeriod; \n', '  \n', '  // amount refunded to each investor\n', '  mapping(address => uint256)  preSaleRefunds;\n', '  \n', '  \n', '  \n', '  modifier inPreSaleCancelledList {\n', '    require(preSaleCancelledList[msg.sender]);\n', '    _;\n', '  }\n', '  \n', '  modifier inRefundPeriod {\n', '  require(withinRefundPeriod);\n', '  _;\n', ' }\n', ' \n', ' \n', '  event TakeEth(address sender,uint256 value);\n', '  event Withdraw(uint256 _value);\n', '  event PreSaleRefund(address sender,uint256 refundBalance);\n', '  event AllocatenonCSTokens(address indexed beneficiary,uint256 amount);\n', '\n', '  \n', '  function ZebiCoinTempMgr(address presaleCrowdsale, address tokenAddress, address _wallet) public {\n', ' \n', '    wallet = _wallet;\n', '    preSaleCSSC = ZebiCoinCrowdsale(presaleCrowdsale);\n', '\ttsc = ZebiCoin(tokenAddress);\n', '    tokenDecimals = tsc.decimals();\n', '  }\n', '  \n', '  function finishMint() onlyOwner public returns (bool) {\n', '    tsc.finishMinting();\n', '    return true;\n', '  }\n', '  \n', '  function resumeMint() onlyOwner public returns (bool) {\n', '    tsc.resumeMinting();\n', '    return true;\n', '  }\n', ' \n', ' \n', '  function startTransfer() external onlyOwner{\n', '    tsc.startTransfer() ;\n', '  }\n', '  \n', '  function endTransfer() external onlyOwner{\n', '    tsc.endTransfer() ;\n', '  }\n', '  \n', '  function transferTokenOwnership(address owner) external onlyOwner{\n', '    tsc.transferOwnership(owner);\n', '  }\n', '  \n', '  function allocatenonCSTokens(address beneficiary,uint256 tokens) external onlyOwner\n', '  {\n', '\trequire(beneficiary != address(0));\n', '\tuint256 Zweitokens = tokens.mul(10**(tokenDecimals ));\n', '\tnoncsAllocations[beneficiary]= Zweitokens.add(noncsAllocations[beneficiary]);\n', '\ttsc.mint(beneficiary, Zweitokens);\n', '\tAllocatenonCSTokens(beneficiary,Zweitokens);\n', '  }\n', '\t\n', '  function revertNoncsallocation(address beneficiary) external onlyOwner\n', '  {\n', '\trequire(noncsAllocations[beneficiary]!=0);\n', '\tnoncsAllocations[beneficiary]=0;\n', '\ttsc.burn(beneficiary);\n', '  }\n', ' \n', '  function viewNoncsallocations(address participant) public view returns(uint256){\n', '    return noncsAllocations[participant];\n', '  }\n', '  \n', '  function viewPreSaleCancelledList(address participant) public view returns(bool){\n', '    return preSaleCancelledList[participant];\n', '  } \n', '  \n', '  function viewPreSaleRefunds(address participant) public view returns(uint256){\n', '    return preSaleRefunds[participant];\n', '  } \n', '  \n', '  function enableRefundPeriod() external onlyOwner{\n', '    withinRefundPeriod = true;\n', '  }\n', '  \n', '  function disableRefundPeriod() external onlyOwner{\n', '    withinRefundPeriod = false;\n', '  }\n', '  \n', '  function refund() external inPreSaleCancelledList inRefundPeriod {                                                    \n', '    require((preSaleCSSC.viewContribution(msg.sender) > 0) && tsc.balanceOf(msg.sender)>0);\n', '    uint256 refundBalance = preSaleCSSC.viewContribution(msg.sender);\t   \n', '    preSaleRefunds[msg.sender] = refundBalance;\n', '    tsc.burn(msg.sender);\n', '    msg.sender.transfer(refundBalance); \n', '\tPreSaleRefund(msg.sender,refundBalance);\n', '  } \n', '\t\n', '  function forcedRefund(address _from) external onlyOwner {\n', '\trequire(preSaleCancelledList[_from]);\n', '\trequire((preSaleCSSC.viewContribution(_from) > 0) && tsc.balanceOf(_from)>0);\n', '    uint256 refundBalance = preSaleCSSC.viewContribution(_from);\t  \n', '    preSaleRefunds[_from] = refundBalance;\n', '\ttsc.burn(_from);\n', '    _from.transfer(refundBalance); \n', '\tPreSaleRefund(_from,refundBalance);\n', '  }\n', '  \n', '  //takes ethers from zebiwallet to smart contract \n', '  function takeEth() external payable {\n', '\tTakeEth(msg.sender,msg.value);\n', '  }\n', '\t\n', '  //transfers ether from smartcontract to zebiwallet\n', '  function withdraw(uint256 _value) public onlyOwner {\n', '    wallet.transfer(_value);\n', '\tWithdraw(_value);\n', '  }\n', '\t\n', '  function addCancellation (address _participant) external onlyOwner returns (bool success) {\n', '    preSaleCancelledList[_participant] = true;\n', '\treturn true;\n', '  }\n', '  \n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ZebiMainCrowdsale\n', '*/\n', 'contract ZebiMainCrowdsale is Ownable{\n', ' \n', '  using SafeMath for uint256;\n', '\n', '  // The token being sold\n', '  ZebiCoin public token;\n', '  \n', '  //calender year count;\n', '  //uint256 calenderYearCounter;\n', '  \n', '  //lockeed tokens minted in current calender year\n', '  uint256 currentYearMinted;\n', '  \n', '  //calenderYearMintCap for Zebi\n', '  uint256 calenderYearMintCap;\n', '  //calender year start\n', '  uint256 calenderYearStart;\n', '  \n', '  //calenderYearEnd\n', '  uint256 calenderYearEnd;\n', '  \n', '  //mintinge vested token start time\n', '  uint256 vestedMintStartTime;\n', '  \n', '  \n', '  //flag : whethere remainingZCO after crowdsale allocated or not\n', '  //bool remainingZCOAllocated;\n', '  \n', '  //TODO\n', '  uint256 zebiZCOShare;\n', '  //TODO \n', '  uint256 crowdsaleZCOCap;\n', '  \n', '  //transaction Start time\n', '  uint256 transStartTime;\n', '  \n', '  // presale instance\n', '  ZebiCoinCrowdsale public zcc;\n', '  \n', '  // tempMngr instance\n', '  ZebiCoinTempMgr public tempMngr;\n', '   \n', '  // Number of decimals allowed for ZCO\n', '  uint64 public tokenDecimals;\n', '\n', '  // start and end timestamps where investments are allowed (both inclusive)\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '  //In seconds initialized in constructor only gold list members can buy\n', '  uint256 public goldListPeriod;\n', '  \n', '  //endTime of 2nd bonus period minus startTime in seconds initialized in constructor: 2nd period for bonuses\n', '  uint256 public postGoldPeriod;\n', '  \n', '  // Minimum amount to be invested in wei\n', '  uint256 public minTransAmount;\n', '  \n', '  // Hardcap in wei\n', '  uint256 public ethCap; \n', '  \n', '  // Contribution of each investor in main crowdsale\n', '  mapping(address => uint256) mainContribution;\n', '    \n', '  // Bad contributor\n', '  mapping(address => bool) mainCancelledList;\n', '  \n', '  // Gold Period Cap per address\n', '  uint256 goldPeriodCap;\n', '  \n', '  //is the transaction occurring during gold list period\n', '  bool goldListPeriodFlag;\n', '  \n', '  //goldListPeriod Contribution TODO\n', '  mapping(address=>uint256) goldListContribution;\n', '  // Gold List \n', '  mapping(address => bool) goldList;\n', '  //discounts mapping number of coins to percentage discount\n', '  // mapping(uint256 => uint256) discounts;\n', '  \n', '  // KYC Accepted List \n', '  mapping(address => bool) kycAcceptedList;\n', '  // Address where funds are collected\n', '  address public wallet;\n', '\n', '  bool public withinRefundPeriod; \n', '  \n', '  // amount refunded to each investor \n', '  mapping(address => uint256)  preSaleRefundsInMainSale;\n', '  \n', '  \n', '  uint256 public tokens;\n', '  \n', '  // net wei used to buy ZCOs in the transaction\n', '  uint256 public weiAmount;\n', '  \n', '  // how many token units a buyer gets per ether\n', '  uint256 public ETHtoZWeirate;\n', '\n', '  // amount of raised money in wei without factoring refunds\n', '  uint256 public mainWeiRaised;  \n', '  \n', '   \n', '  \n', '  modifier inCancelledList {\n', '    require(mainCancelledList[msg.sender]);\n', '    _;\n', '  }\n', '  \n', '  modifier inRefundPeriod {\n', '  require(withinRefundPeriod);\n', '  _;\n', '  }  \n', '\n', '\n', '  event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n', '  \n', '  event TakeEth(address sender,uint256 value);\n', '  \n', '  event Withdraw(uint256 _value);\n', '  \n', '  event SetParticipantStatus(address _participant);\n', '   \n', '  event Refund(address sender,uint256 refundBalance);\n', '\n', '\n', '  function ZebiMainCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _ETHtoZWeirate, address _wallet,uint256 _minTransAmount,uint256 _ethCap, address tokenAddress, address presaleAddress,address tempMngrAddress,uint256 _goldListPeriod,uint256 _postGoldPeriod,uint256 _goldPeriodCap,uint256 _vestedMintStartTime,uint256 _calenderYearStart) public {\n', '  \n', '\trequire(_startTime >= now);\n', '    require(_endTime >= _startTime);\n', '    require(_ETHtoZWeirate > 0);\n', '    require(_wallet != address(0));\n', '\t\n', '\ttoken = ZebiCoin(tokenAddress);\t\n', '\tzcc = ZebiCoinCrowdsale(presaleAddress);\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '    ETHtoZWeirate = _ETHtoZWeirate;\n', '    wallet = _wallet;\n', '    minTransAmount = _minTransAmount;\n', '\ttokenDecimals = token.decimals();\n', '    ethCap = _ethCap;       \n', '\ttempMngr=ZebiCoinTempMgr(tempMngrAddress);\n', '\tgoldListPeriod=_goldListPeriod;\n', '\tpostGoldPeriod=_postGoldPeriod;\n', '\tzebiZCOShare=SafeMath.mul(500000000,(10**tokenDecimals));\n', '\tcrowdsaleZCOCap=zebiZCOShare;\n', '\tgoldPeriodCap=_goldPeriodCap;\n', '\tcalenderYearMintCap = SafeMath.div((zebiZCOShare.mul(2)),8);\n', '\t//vestedMintStartTime=(startTime +((18 *30)*1 days)); \n', '\t//vestedMintStartTime=1567296000; //1 Sep 2019\n', '\tvestedMintStartTime=_vestedMintStartTime;\n', '\t//calenderYearStart=1546300800; //1 Jan 2019 0:0:0\n', '\tcalenderYearStart=_calenderYearStart;\n', '\t//calenderYearEnd=1577836799;   // 31 Dec 2019 23:59:59\n', '\tcalenderYearEnd=(calenderYearStart+1 years )- 1;\n', '  }\n', '\n', '  // Fallback function used to buy tokens\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '  \n', '  function finishMint() onlyOwner public returns (bool) {\n', '    token.finishMinting();\n', '    return true;\n', '  }\n', '  \n', '  function resumeMint() onlyOwner public returns (bool) {\n', '    token.resumeMinting();\n', '    return true;\n', '  }\n', ' \n', '  function startTransfer() external onlyOwner{\n', '    token.startTransfer() ;\n', '  }\n', '  \n', '  function endTransfer() external onlyOwner{\n', '    token.endTransfer() ;\n', '  }\n', '  \n', '  function transferTokenOwnership(address owner) external onlyOwner{\n', '    token.transferOwnership(owner);\n', '  }\n', '  \n', '  function viewCancelledList(address participant) public view returns(bool){\n', '    return mainCancelledList[participant];\n', '  } \n', '  \n', '  function viewGoldList(address participant) public view returns(bool){\n', '    return goldList[participant];\n', '  }\n', '  function addToGoldList (address _participant) external onlyOwner returns (bool ) {\n', '    goldList[_participant] = true;\n', '\treturn true;\n', '  }\n', '  function removeFromGoldList(address _participant) external onlyOwner returns(bool ){\n', '      goldList[_participant]=false;\n', '      return true;\n', '  }\n', '  function viewKYCAccepted(address participant) public view returns(bool){\n', '    return kycAcceptedList[participant];\n', '  }\n', '  function addToKYCList (address _participant) external onlyOwner returns (bool ) {\n', '    kycAcceptedList[_participant] = true;\n', '\treturn true;\n', '  }\n', '  function removeFromKYCList (address _participant) external onlyOwner returns (bool){\n', '      kycAcceptedList[_participant]=false;\n', '  }\n', '  function viewPreSaleRefundsInMainSale(address participant) public view returns(uint256){\n', '    return preSaleRefundsInMainSale[participant];\n', '  }\n', '  /*function addToPreSaleRefunds(address participant,uint256 amountInEth) external onlyOwner returns(bool){\n', '      preSaleRefundsInMainSale[participant]=amountInEth.add(preSaleRefundsInMainSale[participant]);\n', '      \n', '  }\n', '  function removeFromPreSaleRefunds(address participant,uint256 amountInEth) external onlyOwner returns(bool){\n', '      preSaleRefundsInMainSale[participant]=(preSaleRefundsInMainSale[participant]).sub(amountInEth);\n', '      \n', '  }*/\n', '\n', '  // Low level token purchase function\n', '  function buyTokens(address beneficiary) public payable {\n', '    transStartTime=now;\n', '    require(goldList[beneficiary]||kycAcceptedList[beneficiary]);\n', '    goldListPeriodFlag=false;\n', '\trequire(beneficiary != address(0));\n', '    require(validPurchase());\n', '    uint256 extraEth=0;\n', '    weiAmount = msg.value;\n', '   /* if(goldListPeriodFlag){\n', '        weiAmount=goldPeriodCap.sub(goldListContribution[msg.sender]);\n', '        extraEth=(msg.value).sub(weiAmount);\n', '    }*/\n', '    \n', '    //for partial fulfilment feature : return extra ether transferred by investor\n', '    if((msg.value>ethCap.sub(mainWeiRaised)) && !goldListPeriodFlag){\n', '\t\tweiAmount=ethCap.sub(mainWeiRaised);\n', '\t\textraEth=(msg.value).sub(weiAmount);\n', '\t }\n', '\t \n', '    // calculate token amount to be alloted\n', '     tokens = getTokenAmount(weiAmount);\n', '   \n', '    // update state\n', '    mainWeiRaised = mainWeiRaised.add(weiAmount);\n', '    token.mint(beneficiary, tokens);\n', '\tmainContribution[beneficiary] = mainContribution[beneficiary].add(weiAmount);\n', '\tif(goldListPeriodFlag){\n', '\t    goldListContribution[beneficiary] = goldListContribution[beneficiary].add(weiAmount);\n', '\t}\n', '\t\n', '    //TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '    TokenPurchase(beneficiary, weiAmount, tokens);\n', '\n', '    forwardFunds();\n', '    if(extraEth>0){\n', '        beneficiary.transfer(extraEth);\n', '    }\n', '    \n', ' \n', '  }\n', '\n', '\n', '  // returns value in zwei calculating number of tokens including bonuses\n', '  \n', '  function getTokenAmount(uint256 weiAmount1) public view returns(uint256) {                      \n', '    \n', '\t//uint256 ETHtoZweiRate = ETHtoZWeirate;\n', '    uint256 number = SafeMath.div((weiAmount1.mul(ETHtoZWeirate)),(1 ether));\n', '\tuint256 volumeBonus;\n', '\tuint256 timeBonus;\n', '\tif(number >= 400000000000000)\n', '\t{\n', '\tvolumeBonus = SafeMath.div((number.mul(25)),100);\n', '\t}\n', '\telse if(number>= 150000000000000) {\n', '\tvolumeBonus = SafeMath.div((number.mul(20)),100);\n', '\t    }\n', '\telse if(number>= 80000000000000) {\n', '\tvolumeBonus = SafeMath.div((number.mul(15)),100);\n', '\t    }\n', '\telse if(number>= 40000000000000) {\n', '\tvolumeBonus = SafeMath.div((number.mul(10)),100);\n', '\t    }\n', '\telse if(number>= 7500000000000) {\n', '\tvolumeBonus = SafeMath.div((number.mul(5)),100);\n', '\t    }\n', '\t else{\n', '\t     volumeBonus=0;\n', '\t }\n', '\t//\n', '\tif(goldListPeriodFlag){\n', '\t    timeBonus = SafeMath.div((number.mul(15)),100);\n', '\t}\n', '\telse if(transStartTime <= startTime + postGoldPeriod){\n', '\t    timeBonus = SafeMath.div((number.mul(10)),100);\n', '\t}\n', '\telse{\n', '\t    timeBonus=0;\n', '\t}\n', '    number=number+timeBonus+volumeBonus;\n', '    return number; \n', '\t\n', '  }\n', '\t\n', '\t\n', '\t\n', '  // send ether to the fund collection wallet\n', '  function forwardFunds() internal {\n', '    wallet.transfer(weiAmount);\n', '  }\n', '\n', '  \n', '  function enableRefundPeriod() external onlyOwner{\n', '    withinRefundPeriod = true;\n', '  }\n', '  \n', '  function disableRefundPeriod() external onlyOwner{\n', '    withinRefundPeriod = false;\n', '  }\n', ' \n', '  function viewContribution(address participant) public view returns(uint256){\n', '    return mainContribution[participant];\n', '  }  \n', '  \n', '  \n', '  // checks if the investor can buy tokens\n', '  \n', '  function validPurchase() internal view returns (bool) {\n', '    bool withinPeriod = transStartTime >= startTime && transStartTime <= endTime;\n', '\tbool validAmount = msg.value >= minTransAmount;\n', '\t//bool withinEthCap = ethCap >= (msg.value + mainWeiRaised);\n', '\tbool withinEthCap = ((ethCap.sub(mainWeiRaised))>0);\n', '\tbool goldPeriodValid=true;\n', '\tif(transStartTime <= (startTime + goldListPeriod)){\n', '\t    goldPeriodValid=(goldList[msg.sender])&&(goldListContribution[msg.sender]+msg.value <= goldPeriodCap);\n', '\t    goldListPeriodFlag=true;\n', '\t    \n', '\t}\n', '    return withinPeriod && validAmount && withinEthCap && goldPeriodValid;\n', '  }\n', '  \n', '  /*function mintLeftOverZCOToWallet() external onlyOwner returns (bool){\n', '      //uint256 Zweitokens = amount;\n', '      require(!remainingZCOAllocated);\n', '      require(now>endTime);\n', '      \n', '      //uint256 ETHtoZweiRate = ETHtoZWeirate.mul(10**tokenDecimals);\n', '      //uint256 remainingCap=ethCap.sub(mainWeiRaised);\n', '      //uint256 amount = SafeMath.div((remainingCap.mul(ETHtoZweiRate)),(1 ether));\n', '      //mainWeiRaised = mainWeiRaised.add(amount);\n', '      //uint256 zweitokens = SafeMath.mul(500000000,10**(tokenDecimals ));\n', '      uint256 zweitokens=crowdsaleZCOCap.sub(token.totalSupply());\n', '      //zweitokens=zweitokens.sub(token.totalSupply());\n', '      token.mint(wallet, zweitokens);\n', '      remainingZCOAllocated=true;\n', '      return true;\n', '  }*/\n', '  function mintAndAllocateZCO(address partnerAddress,uint256 amountInZWei) external onlyOwner returns(bool){\n', '      require((crowdsaleZCOCap.sub(token.totalSupply()))>=amountInZWei);\n', '      require(partnerAddress!=address(0));\n', '      //require(now>endTime);\n', '      //require(!remainingZCOAllocated);\n', '      token.mint(partnerAddress,amountInZWei);\n', '      return true;\n', '  }\n', '  \n', '  function mintvestedTokens (address partnerAddress,uint256 zweitokens) external onlyOwner returns(bool){\n', '      require(zweitokens<=zebiZCOShare && zweitokens>0);\n', '      \n', '      require(partnerAddress!=address(0));\n', '      require(now>=vestedMintStartTime);\n', '      //year\n', '      uint256 currentYearCounter=SafeMath.div((SafeMath.sub(now,calenderYearStart)),1 years);\n', '      //if(currentYearCounter>calenderYearCounter){\n', '      if(now>calenderYearEnd && currentYearCounter>=1){\n', '          //calenderYearCounter=currentYearCounter;\n', '          currentYearMinted=0;\n', '          calenderYearStart=calenderYearEnd+((currentYearCounter-1)*1 years) +1;\n', '          calenderYearEnd=(calenderYearStart+ 1 years )- 1;\n', '      }\n', '      \n', '      require(currentYearMinted+zweitokens<=calenderYearMintCap);\n', '      currentYearMinted=currentYearMinted+zweitokens;\n', '      token.mint(partnerAddress,zweitokens);\n', '      zebiZCOShare=zebiZCOShare.sub(zweitokens);\n', '  }\n', '  \n', '  \n', '  \n', '  function refund() external inCancelledList inRefundPeriod {  \n', '    require(mainCancelledList[msg.sender]);  \n', '    require((mainContribution[msg.sender] > 0) && token.balanceOf(msg.sender)>0);\n', '\tuint256 presaleContribution = zcc.viewContribution(msg.sender);\n', '    uint256 refundBalance = (mainContribution[msg.sender]).add(presaleContribution) ;\n', '    uint256 preSaleRefundTemp= tempMngr.viewPreSaleRefunds(msg.sender);\n', '    uint256 preSaleRefundMain=presaleContribution.sub(preSaleRefundTemp);\n', '    refundBalance=refundBalance.sub(preSaleRefundTemp);\n', '    refundBalance=refundBalance.sub(preSaleRefundsInMainSale[msg.sender]);\n', '    preSaleRefundsInMainSale[msg.sender]=preSaleRefundMain;\n', '    \n', '    mainContribution[msg.sender] = 0;\n', '\ttoken.burn(msg.sender);\n', '    msg.sender.transfer(refundBalance); \n', '\tRefund(msg.sender,refundBalance);\n', '  } \n', '\t\n', '  function forcedRefund(address _from) external onlyOwner {\n', '\trequire(mainCancelledList[_from]);\n', '\trequire((mainContribution[_from] > 0) && token.balanceOf(_from)>0);\n', '\tuint256 presaleContribution = zcc.viewContribution(_from);\n', '    uint256 refundBalance = (mainContribution[_from]).add(presaleContribution) ;\n', '    uint256 preSaleRefundTemp= tempMngr.viewPreSaleRefunds(_from);\n', '    uint256 preSaleRefundMain=presaleContribution.sub(preSaleRefundTemp);\n', '    refundBalance=refundBalance.sub(preSaleRefundTemp);\n', '    refundBalance=refundBalance.sub(preSaleRefundsInMainSale[_from]);\n', '    preSaleRefundsInMainSale[_from]=preSaleRefundMain;\n', '    mainContribution[_from] = 0;\n', '\ttoken.burn(_from);\n', '    _from.transfer(refundBalance); \n', '\tRefund(_from,refundBalance);\n', '  }\n', '\t\n', '\t\n', '  //takes ethers from zebiwallet to smart contract \n', '  function takeEth() external payable {\n', '\tTakeEth(msg.sender,msg.value);\n', '  }\n', '\t\n', '  //transfers ether from smartcontract to zebiwallet\n', '  function withdraw(uint256 _value) public onlyOwner {\n', '    wallet.transfer(_value);\n', '\tWithdraw(_value);\n', '  }\n', '\t\n', '  //Maintains list of investors with failed KYC validation\n', '  function addCancellation (address _participant) external onlyOwner returns (bool success) {\n', '    mainCancelledList[_participant] = true;\n', '\treturn true;\n', '  } \n', '\n', '  }']
