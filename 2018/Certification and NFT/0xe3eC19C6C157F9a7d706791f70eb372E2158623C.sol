['pragma solidity ^0.4.18;\n', '// адрес теста https://ropsten.etherscan.io/token/0x1fcbe22ce0c2d211c51866966152a70490dd8045?a=0x1fcbe22ce0c2d211c51866966152a70490dd8045\n', 'contract owned {\n', '\n', '    address public owner;\n', '    address public candidat;\n', '   event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function owned() public payable {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function changeOwner(address _owner) public {\n', '        require(owner == msg.sender);\n', '        candidat = _owner;\n', '    }\n', '    function confirmOwner() public {\n', '        require(candidat == msg.sender);\n', '        emit OwnershipTransferred(owner,candidat);\n', '        owner = candidat;\n', '        candidat = address(0);\n', '    }\n', '}\n', ' \n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', ' \n', 'contract ERC20Interface {\n', '    //function totalSupply() public constant returns (uint);\n', '    //function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    //function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    uint256 public totalSupply;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint)) public allowance;\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract Cryptoloans is ERC20Interface, owned {\n', '    using SafeMath for uint256;\n', '    //uint256 public totalSupply;\n', '    //mapping (address => uint256) public balanceOf;\n', '    //mapping (address => mapping (address => uint)) public allowance;\n', '\n', '    //function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '    //    require(state != State.Disabled);\n', '    //    return allowance[_owner][_spender];\n', '    //}\n', '\n', '    //string  public standard    = &#39;Token 0.1&#39;;\n', '    string  public name        = &#39;Cryptoloans&#39;;\n', '    string  public symbol      = "LCN";\n', '    uint8   public decimals    = 18;\n', '    uint256 public tokensPerOneEther = 300;\n', '    uint    public min_tokens = 30;\n', '\n', '    // Fix for the ERC20 short address attack\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '    \n', '    enum State { Disabled, TokenSale, Failed, Enabled }\n', '    State   public state = State.Disabled;\n', '    \n', '    modifier inState(State _state) {\n', '        require(state == _state);\n', '        _;\n', '    }    \n', '\n', '    event NewState(State state);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '    function Cryptoloans() public payable owned() {\n', '        totalSupply = 10000000 * 10**uint(decimals);\n', '        balanceOf[this] = 540000 * 10**uint(decimals);\n', '        balanceOf[owner] = totalSupply - balanceOf[this];\n', '        emit Transfer(address(0), this, totalSupply);\n', '        emit Transfer(this, owner, balanceOf[owner]);\n', '    }\n', '\n', '    function () public payable {\n', '        require(state==State.TokenSale);\n', '        require(balanceOf[this] > 0);\n', '        uint256 tokens = tokensPerOneEther.mul(msg.value);//.div(1 ether);\n', '        require(min_tokens.mul(10**uint(decimals))<=tokens || tokens > balanceOf[this]);\n', '        if (tokens > balanceOf[this]) {\n', '            tokens = balanceOf[this];\n', '            uint256 valueWei = tokens.div(tokensPerOneEther);\n', '            msg.sender.transfer(msg.value - valueWei);\n', '        }\n', '        require(tokens > 0);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(tokens);\n', '        balanceOf[this] = balanceOf[this].sub(tokens);\n', '        emit Transfer(this, msg.sender, tokens);\n', '    }\n', '\n', '\tfunction _transfer(address _from, address _to, uint _value) internal\n', '\t{\n', '        require(state != State.Disabled);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]); // overflow\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '\t}\n', '\t\n', '\t\n', '    function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) returns(bool success){\n', '\t\t_transfer(msg.sender,_to,_value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32)  returns(bool success){\n', '        require(state != State.Disabled);\n', '\t\trequire(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public  returns(bool success){\n', '        require(state != State.Disabled);\n', '        require((_value == 0) || (allowance[msg.sender][_spender] == 0));\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    function withdrawBack() public { // failed tokensale\n', '        require(state == State.Failed);\n', '        require(balanceOf[msg.sender]>0);\n', '        uint256 amount = balanceOf[msg.sender].div(tokensPerOneEther);// ethers wei\n', '        uint256 balance_sender = balanceOf[msg.sender];\n', '        \n', '        require(address(this).balance>=amount && amount > 0);\n', '        balanceOf[this] = balanceOf[this].add(balance_sender);\n', '        balanceOf[msg.sender] = 0;\n', '        emit Transfer(msg.sender, this,  balance_sender);\n', '        msg.sender.transfer(amount);\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public returns (bool success) {\n', '        require(msg.sender==owner);\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '\n', '    \n', '    function killMe() public {\n', '        require(owner == msg.sender);\n', '        selfdestruct(owner);\n', '    }\n', '    \n', '    function startTokensSale(uint _volume_tokens, uint token_by_ether, uint min_in_token) public {\n', '        require(owner == msg.sender);\n', '        //require(state == State.Disabled);\n', '        require((_volume_tokens * 10**uint(decimals))<(balanceOf[owner]+balanceOf[this]));\n', '        tokensPerOneEther = token_by_ether;\n', '        min_tokens = min_in_token;\n', '        \n', '        //if(balanceOf[this]>0)\n', '        if(balanceOf[this]>(_volume_tokens * 10**uint(decimals)))\n', '            emit Transfer(this, owner, balanceOf[this]-(_volume_tokens * 10**uint(decimals)));\n', '        else if(balanceOf[this]<(_volume_tokens * 10**uint(decimals)))\n', '            emit Transfer(owner, this, (_volume_tokens * 10**uint(decimals)) - balanceOf[this]);\n', '\n', '        balanceOf[owner] = balanceOf[owner].add(balanceOf[this]).sub(_volume_tokens * 10**uint(decimals));\n', '        balanceOf[this] = _volume_tokens * 10**uint(decimals);\n', '        \n', '        if (state != State.TokenSale)\n', '        {\n', '            state = State.TokenSale;\n', '            emit NewState(state);\n', '        }\n', '    }\n', '    \n', '\n', '    function SetState(uint _state) public \n', '    {\n', '        require(owner == msg.sender);\n', '        State old = state;\n', '        //require(state!=_state);\n', '        if(_state==0)\n', '            state = State.Disabled;\n', '        else if(_state==1) \n', '            state = State.TokenSale;\n', '        else if(_state==2) \n', '            state = State.Failed;\n', '        else if(_state==3) \n', '            state = State.Enabled;\n', '        if(old!=state)\n', '            emit NewState(state);\n', '    }\n', '    \n', '\n', '    function withdraw() public {\n', '        require(owner == msg.sender);\n', '        owner.transfer(address(this).balance);\n', '    }\n', '\n', '}']