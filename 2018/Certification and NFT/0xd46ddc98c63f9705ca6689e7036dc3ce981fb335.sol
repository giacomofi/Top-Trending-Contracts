['pragma solidity ^0.4.23;\n', '\n', 'contract UTU {\n', '    string public name = "Upgrade Token Utility";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "UTU";\n', '\n', '    address public owner;\n', '    address public feesAddr;\n', '    address trancheAdmin;\n', '\n', '    uint256 public totalSupply = 50000000000000000000000000; // 50m e18\n', '    uint public trancheLevel = 1;\n', '    uint256 public circulatingSupply = 0;\n', '    uint maxTranche = 4;\n', '    uint loopCount = 0;\n', '    uint256 feePercent = 1500;  // the calculation expects % * 100 (so 10% is 1000)\n', '    uint256 trancheOneSaleTime;\n', '    bool public receiveEth = true;\n', '    bool payFees = true;\n', '    bool addTranches = true;\n', '    bool public initialTranches = false;\n', '    bool trancheOne = true;\n', '\n', '    // Storage\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => uint256) public trancheOneBalances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    // mining schedule\n', '    mapping(uint => uint256) public trancheTokens;\n', '    mapping(uint => uint256) public trancheRate;\n', '\n', '    // events (ERC20)\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    function UTU() {\n', '        owner = msg.sender;\n', '        feesAddr = msg.sender;\n', '        trancheAdmin = msg.sender;\n', '        trancheOneSaleTime = now + 182 days;    // 6 months\n', '        populateTrancheTokens();\n', '        populateTrancheRates();\n', '    }\n', '\n', '    function populateTrancheTokens() internal {\n', '        trancheTokens[1] = 1E25;\n', '        trancheTokens[2] = 2E25;\n', '        trancheTokens[3] = 1E25;\n', '        trancheTokens[4] = 1E25;\n', '    }\n', '\n', '    function populateTrancheRates() internal {\n', '        trancheRate[1] = 5E24;\n', '        trancheRate[2] = 8.643E19;\n', '        trancheRate[3] = 4.321E19;\n', '        trancheRate[4] = 2.161E19;\n', '        initialTranches = true;\n', '    }\n', '\n', '    function () payable public {\n', '        require((msg.value > 0) && (receiveEth));\n', '        allocateTokens(msg.value,0);\n', '    }\n', '\n', '    function allocateTokens(uint256 _submitted, uint256 _tokenCount) internal {\n', '        uint256 _tokensAfforded = 0;\n', '        loopCount++;\n', '\n', '        if((trancheLevel <= maxTranche) && (loopCount <= maxTranche)) {\n', '            _tokensAfforded = div(mul(_submitted, trancheRate[trancheLevel]), 1 ether);\n', '        }\n', '\n', '        if((_tokensAfforded >= trancheTokens[trancheLevel]) && (loopCount <= maxTranche)) {\n', '            _submitted = sub(_submitted, div(mul(trancheTokens[trancheLevel], 1 ether), trancheRate[trancheLevel]));\n', '            _tokenCount = add(_tokenCount, trancheTokens[trancheLevel]);\n', '\n', '            if(trancheLevel == 1) {\n', '                // we need to record tranche1 purchases so we can stop sale/transfer of them during the first 6 mths\n', '                trancheOneBalances[msg.sender] = add(trancheOneBalances[msg.sender], trancheTokens[trancheLevel]);\n', '            }\n', '\n', '            circulatingSupply = add(circulatingSupply, _tokensAfforded);\n', '            trancheTokens[trancheLevel] = 0;\n', '\n', '            trancheLevel++;\n', '\n', '            if(trancheLevel == 2) {\n', '                trancheOne = false;\n', '            }\n', '\n', '            allocateTokens(_submitted, _tokenCount);\n', '        }\n', '        else if((trancheTokens[trancheLevel] >= _tokensAfforded) && (_tokensAfforded > 0) && (loopCount <= maxTranche)) {\n', '            trancheTokens[trancheLevel] = sub(trancheTokens[trancheLevel], _tokensAfforded);\n', '            _tokenCount = add(_tokenCount, _tokensAfforded);\n', '            circulatingSupply = add(circulatingSupply, _tokensAfforded);\n', '\n', '            if(trancheLevel == 1) {\n', '                // we need to record tranche1 purchases\n', '                trancheOneBalances[msg.sender] = add(trancheOneBalances[msg.sender], _tokenCount);\n', '            }\n', '\n', "            // we've spent up - go around again and issue tokens to recipient\n", '            allocateTokens(0, _tokenCount);\n', '        }\n', '        else {\n', '            // 15% of the purchased tokens amount is fees\n', '            uint256 fees = 0;\n', '            if(payFees) {\n', '                fees = add(fees, ((_tokenCount * feePercent) / 10000));\n', '            }\n', '\n', '            balances[msg.sender] = add(balances[msg.sender], _tokenCount);\n', '            trancheTokens[maxTranche] = sub(trancheTokens[maxTranche], fees);\n', '            balances[feesAddr] = add(balances[feesAddr], fees);\n', '\n', '            if(trancheOne) {\n', '                trancheOneBalances[feesAddr] = add(trancheOneBalances[feesAddr], fees);\n', '            }\n', '\n', '            Transfer(this, msg.sender, _tokenCount);\n', '            Transfer(this, feesAddr, fees);\n', '            loopCount = 0;\n', '        }\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        if(_to == address(this)) {\n', '            // WARNING: if you transfer tokens back to the contract you will lose them\n', '            balances[msg.sender] = sub(balances[msg.sender], _value);\n', '            circulatingSupply = sub(circulatingSupply, _value);\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '        else {\n', '            if(now >= trancheOneSaleTime) {\n', '                balances[msg.sender] = sub(balances[msg.sender], _value);\n', '                balances[_to] = add(balances[_to], _value);\n', '                Transfer(msg.sender, _to, _value);\n', '            }\n', '            else {\n', '                if(_value <= sub(balances[msg.sender],trancheOneBalances[msg.sender])) {\n', '                    balances[msg.sender] = sub(balances[msg.sender], _value);\n', '                    balances[_to] = add(balances[_to], _value);\n', '                    Transfer(msg.sender, _to, _value);\n', '                }\n', "                else revert();  // you can't transfer tranche1 tokens during the first 6 months\n", '            }\n', '        }\n', '    }\n', '\n', '    function balanceOf(address _receiver) public constant returns (uint256) {\n', '        return balances[_receiver];\n', '    }\n', '\n', '    function trancheOneBalanceOf(address _receiver) public constant returns (uint256) {\n', '        return trancheOneBalances[_receiver];\n', '    }\n', '\n', '    function balanceInTranche() public constant returns (uint256) {\n', '        return trancheTokens[trancheLevel];\n', '    }\n', '\n', '    function balanceInSpecificTranche(uint256 _tranche) public constant returns (uint256) {\n', '        return trancheTokens[_tranche];\n', '    }\n', '\n', '    function rateOfSpecificTranche(uint256 _tranche) public constant returns (uint256) {\n', '        return trancheRate[_tranche];\n', '    }\n', '\n', '    function changeFeesAddress(address _devFees) public {\n', '        require(msg.sender == owner);\n', '        feesAddr = _devFees;\n', '    }\n', '\n', '    function payFeesToggle() public {\n', '        require(msg.sender == owner);\n', '        if(payFees) {\n', '            payFees = false;\n', '        }\n', '        else {\n', '            payFees = true;\n', '        }\n', '    }\n', '\n', '    // enables fee update - must be between 0 and 100 (%)\n', '    function updateFeeAmount(uint _newFee) public {\n', '        require(msg.sender == owner);\n', '        require((_newFee >= 0) && (_newFee <= 100));\n', '        feePercent = _newFee * 100;\n', '    }\n', '\n', '    function changeOwner(address _recipient) public {\n', '        require(msg.sender == owner);\n', '        owner = _recipient;\n', '    }\n', '\n', '    function changeTrancheAdmin(address _trancheAdmin) public {\n', '        require((msg.sender == owner) || (msg.sender == trancheAdmin));\n', '        trancheAdmin = _trancheAdmin;\n', '    }\n', '\n', '    function toggleReceiveEth() public {\n', '        require(msg.sender == owner);\n', '        if(receiveEth == true) {\n', '            receiveEth = false;\n', '        }\n', '        else receiveEth = true;\n', '    }\n', '\n', '    function otcPurchase(uint256 _tokens, address _recipient) public {\n', '        require(msg.sender == owner);\n', '        balances[_recipient] = add(balances[_recipient], _tokens);\n', '        Transfer(this, _recipient, _tokens);\n', '    }\n', '\n', '    function otcPurchaseAndEscrow(uint256 _tokens, address _recipient) public {\n', '        require(msg.sender == owner);\n', '        balances[_recipient] = add(balances[_recipient], _tokens);\n', '        trancheOneBalances[msg.sender] = add(trancheOneBalances[msg.sender], _tokens);\n', '        Transfer(this, _recipient, _tokens);\n', '    }\n', '\n', '    function safeWithdrawal(address _receiver, uint256 _value) public {\n', '        require(msg.sender == owner);\n', '        require(_value <= this.balance);\n', '        _receiver.transfer(_value);\n', '    }\n', '\n', '    function addTrancheRateAndTokens(uint256 _level, uint256 _tokens, uint256 _rate) public {\n', '        require(((msg.sender == owner) || (msg.sender == trancheAdmin)) && (addTranches == true));\n', '        require(add(_tokens, circulatingSupply) <= totalSupply);\n', '        trancheTokens[_level] = _tokens;\n', '        trancheRate[_level] = _rate;\n', '        maxTranche++;\n', '    }\n', '\n', '    function updateTrancheRate(uint256 _level, uint256 _rate) {\n', '        require((msg.sender == owner) || (msg.sender == trancheAdmin));\n', '        trancheRate[_level] = _rate;\n', '    }\n', '\n', '    // when all tranches have been added to the contract\n', '    function closeTrancheAddition() public {\n', '        require(msg.sender == owner);\n', '        addTranches = false;\n', '    }\n', '\n', '    function trancheOneSaleOpenTime() returns (uint256) {\n', '        return trancheOneSaleTime;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    // ERC20 compliance\n', '    function transferFrom(address _from, address _to, uint256 _tokens) public returns (bool success) {\n', '        require(balances[_from] >= _tokens);\n', '        balances[_from] = sub(balances[_from],_tokens);\n', '        allowed[_from][msg.sender] = sub(allowed[_from][msg.sender],_tokens);\n', '        balances[_to] = add(balances[_to],_tokens);\n', '        Transfer(_from, _to, _tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _tokens) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _tokens;\n', '        Approval(msg.sender, _spender, _tokens);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _tokenOwner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_tokenOwner][_spender];\n', '    }\n', '}']