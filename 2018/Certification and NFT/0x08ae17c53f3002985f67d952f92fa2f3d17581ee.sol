['pragma solidity ^0.4.3;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ERC677 is ERC20 {\n', '  function transferAndCall(address to, uint value, bytes data) public returns (bool success);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract PoolOwners is Ownable {\n', '\n', '    mapping(uint64 => address)  private ownerAddresses;\n', '    mapping(address => bool)    private whitelist;\n', '\n', '    mapping(address => uint256) public ownerPercentages;\n', '    mapping(address => uint256) public ownerShareTokens;\n', '    mapping(address => uint256) public tokenBalance;\n', '\n', '    mapping(address => mapping(address => uint256)) private balances;\n', '\n', '    uint64  public totalOwners = 0;\n', '    uint16  public distributionMinimum = 20;\n', '\n', '    bool   private contributionStarted = false;\n', '    bool   private distributionActive = false;\n', '\n', '    // Public Contribution Variables\n', '    uint256 private ethWei = 1000000000000000000; // 1 ether in wei\n', '    uint256 private valuation = ethWei * 4000; // 1 ether * 4000\n', '    uint256 private hardCap = ethWei * 1000; // 1 ether * 1000\n', '    address private wallet;\n', '    bool    private locked = false;\n', '\n', '    uint256 public totalContributed = 0;\n', '\n', '    // The contract hard-limit is 0.04 ETH due to the percentage precision, lowest % possible is 0.001%\n', '    // It&#39;s been set at 0.2 ETH to try and minimise the sheer number of contributors as that would up the distribution GAS cost\n', '    uint256 private minimumContribution = 200000000000000000; // 0.2 ETH\n', '\n', '    /**\n', '        Events\n', '     */\n', '\n', '    event Contribution(address indexed sender, uint256 share, uint256 amount);\n', '    event TokenDistribution(address indexed token, uint256 amount);\n', '    event TokenWithdrawal(address indexed token, address indexed owner, uint256 amount);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, uint256 amount);\n', '\n', '    /**\n', '        Modifiers\n', '     */\n', '\n', '    modifier onlyWhitelisted() {\n', '        require(whitelist[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        Contribution Methods\n', '     */\n', '\n', '    // Fallback, redirects to contribute\n', '    function() public payable { contribute(msg.sender); }\n', '\n', '    function contribute(address sender) internal {\n', '        // Make sure the shares aren&#39;t locked\n', '        require(!locked);\n', '\n', '        // Ensure the contribution phase has started\n', '        require(contributionStarted);\n', '\n', '        // Make sure they&#39;re in the whitelist\n', '        require(whitelist[sender]);\n', '\n', '        // Assert that the contribution is above or equal to the minimum contribution\n', '        require(msg.value >= minimumContribution);\n', '\n', '        // Make sure the contribution isn&#39;t above the hard cap\n', '        require(hardCap >= msg.value);\n', '\n', '        // Ensure the amount contributed is cleanly divisible by the minimum contribution\n', '        require((msg.value % minimumContribution) == 0);\n', '\n', '        // Make sure the contribution doesn&#39;t exceed the hardCap\n', '        require(hardCap >= SafeMath.add(totalContributed, msg.value));\n', '\n', '        // Increase the total contributed\n', '        totalContributed = SafeMath.add(totalContributed, msg.value);\n', '\n', '        // Calculated share\n', '        uint256 share = percent(msg.value, valuation, 5);\n', '\n', '        // Calculate and set the contributors % holding\n', '        if (ownerPercentages[sender] != 0) { // Existing contributor\n', '            ownerShareTokens[sender] = SafeMath.add(ownerShareTokens[sender], msg.value);\n', '            ownerPercentages[sender] = SafeMath.add(share, ownerPercentages[sender]);\n', '        } else { // New contributor\n', '            ownerAddresses[totalOwners] = sender;\n', '            totalOwners += 1;\n', '            ownerPercentages[sender] = share;\n', '            ownerShareTokens[sender] = msg.value;\n', '        }\n', '\n', '        // Transfer the ether to the wallet\n', '        wallet.transfer(msg.value);\n', '\n', '        // Fire event\n', '        emit Contribution(sender, share, msg.value);\n', '    }\n', '\n', '    // Add a wallet to the whitelist\n', '    function whitelistWallet(address contributor) external onlyOwner() {\n', '        // Is it actually an address?\n', '        require(contributor != address(0));\n', '\n', '        // Add address to whitelist\n', '        whitelist[contributor] = true;\n', '    }\n', '\n', '    // Start the contribution\n', '    function startContribution() external onlyOwner() {\n', '        require(!contributionStarted);\n', '        contributionStarted = true;\n', '    }\n', '\n', '    /**\n', '        Public Methods\n', '     */\n', '\n', '    // Set the owners share per owner, the balancing of shares is done externally\n', '    function setOwnerShare(address owner, uint256 value) public onlyOwner() {\n', '        // Make sure the shares aren&#39;t locked\n', '        require(!locked);\n', '\n', '        if (ownerShareTokens[owner] == 0) {\n', '            whitelist[owner] = true;\n', '            ownerAddresses[totalOwners] = owner;\n', '            totalOwners += 1;\n', '        }\n', '        ownerShareTokens[owner] = value;\n', '        ownerPercentages[owner] = percent(value, valuation, 5);\n', '    }\n', '\n', '    // Non-Standard token transfer, doesn&#39;t confine to any ERC\n', '    function sendOwnership(address receiver, uint256 amount) public onlyWhitelisted() {\n', '        // Require they have an actual balance\n', '        require(ownerShareTokens[msg.sender] > 0);\n', '\n', '        // Require the amount to be equal or less to their shares\n', '        require(ownerShareTokens[msg.sender] >= amount);\n', '\n', '        // Deduct the amount from the owner\n', '        ownerShareTokens[msg.sender] = SafeMath.sub(ownerShareTokens[msg.sender], amount);\n', '\n', '        // Remove the owner if the share is now 0\n', '        if (ownerShareTokens[msg.sender] == 0) {\n', '            ownerPercentages[msg.sender] = 0;\n', '            whitelist[receiver] = false; \n', '            \n', '        } else { // Recalculate percentage\n', '            ownerPercentages[msg.sender] = percent(ownerShareTokens[msg.sender], valuation, 5);\n', '        }\n', '\n', '        // Add the new share holder\n', '        if (ownerShareTokens[receiver] == 0) {\n', '            whitelist[receiver] = true;\n', '            ownerAddresses[totalOwners] = receiver;\n', '            totalOwners += 1;\n', '        }\n', '        ownerShareTokens[receiver] = SafeMath.add(ownerShareTokens[receiver], amount);\n', '        ownerPercentages[receiver] = SafeMath.add(ownerPercentages[receiver], percent(amount, valuation, 5));\n', '\n', '        emit OwnershipTransferred(msg.sender, receiver, amount);\n', '    }\n', '\n', '    // Lock the shares so contract owners cannot change them\n', '    function lockShares() public onlyOwner() {\n', '        require(!locked);\n', '        locked = true;\n', '    }\n', '\n', '    // Distribute the tokens in the contract to the contributors/creators\n', '    function distributeTokens(address token) public onlyWhitelisted() {\n', '        // Is this method already being called?\n', '        require(!distributionActive);\n', '        distributionActive = true;\n', '\n', '        // Get the token address\n', '        ERC677 erc677 = ERC677(token);\n', '\n', '        // Has the contract got a balance?\n', '        uint256 currentBalance = erc677.balanceOf(this) - tokenBalance[token];\n', '        require(currentBalance > ethWei * distributionMinimum);\n', '\n', '        // Add the current balance on to the total returned\n', '        tokenBalance[token] = SafeMath.add(tokenBalance[token], currentBalance);\n', '\n', '        // Loop through stakers and add the earned shares\n', '        // This is GAS expensive, but unless complex more bug prone logic was added there is no alternative\n', '        // This is due to the percentages needed to be calculated for all at once, or the amounts would differ\n', '        for (uint64 i = 0; i < totalOwners; i++) {\n', '            address owner = ownerAddresses[i];\n', '\n', '            // If the owner still has a share\n', '            if (ownerShareTokens[owner] > 0) {\n', '                // Calculate and transfer the ownership of shares with a precision of 5, for example: 12.345%\n', '                balances[owner][token] = SafeMath.add(SafeMath.div(SafeMath.mul(currentBalance, ownerPercentages[owner]), 100000), balances[owner][token]);\n', '            }\n', '        }\n', '        distributionActive = false;\n', '\n', '        // Emit the event\n', '        emit TokenDistribution(token, currentBalance);\n', '    }\n', '\n', '    // Withdraw tokens from the owners balance\n', '    function withdrawTokens(address token, uint256 amount) public {\n', '        // Can&#39;t withdraw nothing\n', '        require(amount > 0);\n', '\n', '        // Assert they&#39;re withdrawing what is in their balance\n', '        require(balances[msg.sender][token] >= amount);\n', '\n', '        // Substitute the amounts\n', '        balances[msg.sender][token] = SafeMath.sub(balances[msg.sender][token], amount);\n', '        tokenBalance[token] = SafeMath.sub(tokenBalance[token], amount);\n', '\n', '        // Transfer the tokens\n', '        ERC677 erc677 = ERC677(token);\n', '        require(erc677.transfer(msg.sender, amount) == true);\n', '\n', '        // Emit the event\n', '        emit TokenWithdrawal(token, msg.sender, amount);\n', '    }\n', '\n', '    // Sets the minimum balance needed for token distribution\n', '    function setDistributionMinimum(uint16 minimum) public onlyOwner() {\n', '        distributionMinimum = minimum;\n', '    }\n', '\n', '    // Sets the contribution ETH wallet\n', '    function setEthWallet(address _wallet) public onlyOwner() {\n', '        wallet = _wallet;\n', '    }\n', '\n', '    // Is an account whitelisted?\n', '    function isWhitelisted(address contributor) public view returns (bool) {\n', '        return whitelist[contributor];\n', '    }\n', '\n', '    // Get the owners token balance\n', '    function getOwnerBalance(address token) public view returns (uint256) {\n', '        return balances[msg.sender][token];\n', '    }\n', '\n', '    /**\n', '        Private Methods\n', '    */\n', '\n', '    // Credit to Rob Hitchens: https://stackoverflow.com/a/42739843\n', '    function percent(uint numerator, uint denominator, uint precision) private pure returns (uint quotient) {\n', '        uint _numerator = numerator * 10 ** (precision+1);\n', '        uint _quotient = ((_numerator / denominator) + 5) / 10;\n', '        return ( _quotient);\n', '    }\n', '}']
['pragma solidity ^0.4.3;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ERC677 is ERC20 {\n', '  function transferAndCall(address to, uint value, bytes data) public returns (bool success);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract PoolOwners is Ownable {\n', '\n', '    mapping(uint64 => address)  private ownerAddresses;\n', '    mapping(address => bool)    private whitelist;\n', '\n', '    mapping(address => uint256) public ownerPercentages;\n', '    mapping(address => uint256) public ownerShareTokens;\n', '    mapping(address => uint256) public tokenBalance;\n', '\n', '    mapping(address => mapping(address => uint256)) private balances;\n', '\n', '    uint64  public totalOwners = 0;\n', '    uint16  public distributionMinimum = 20;\n', '\n', '    bool   private contributionStarted = false;\n', '    bool   private distributionActive = false;\n', '\n', '    // Public Contribution Variables\n', '    uint256 private ethWei = 1000000000000000000; // 1 ether in wei\n', '    uint256 private valuation = ethWei * 4000; // 1 ether * 4000\n', '    uint256 private hardCap = ethWei * 1000; // 1 ether * 1000\n', '    address private wallet;\n', '    bool    private locked = false;\n', '\n', '    uint256 public totalContributed = 0;\n', '\n', '    // The contract hard-limit is 0.04 ETH due to the percentage precision, lowest % possible is 0.001%\n', "    // It's been set at 0.2 ETH to try and minimise the sheer number of contributors as that would up the distribution GAS cost\n", '    uint256 private minimumContribution = 200000000000000000; // 0.2 ETH\n', '\n', '    /**\n', '        Events\n', '     */\n', '\n', '    event Contribution(address indexed sender, uint256 share, uint256 amount);\n', '    event TokenDistribution(address indexed token, uint256 amount);\n', '    event TokenWithdrawal(address indexed token, address indexed owner, uint256 amount);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, uint256 amount);\n', '\n', '    /**\n', '        Modifiers\n', '     */\n', '\n', '    modifier onlyWhitelisted() {\n', '        require(whitelist[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        Contribution Methods\n', '     */\n', '\n', '    // Fallback, redirects to contribute\n', '    function() public payable { contribute(msg.sender); }\n', '\n', '    function contribute(address sender) internal {\n', "        // Make sure the shares aren't locked\n", '        require(!locked);\n', '\n', '        // Ensure the contribution phase has started\n', '        require(contributionStarted);\n', '\n', "        // Make sure they're in the whitelist\n", '        require(whitelist[sender]);\n', '\n', '        // Assert that the contribution is above or equal to the minimum contribution\n', '        require(msg.value >= minimumContribution);\n', '\n', "        // Make sure the contribution isn't above the hard cap\n", '        require(hardCap >= msg.value);\n', '\n', '        // Ensure the amount contributed is cleanly divisible by the minimum contribution\n', '        require((msg.value % minimumContribution) == 0);\n', '\n', "        // Make sure the contribution doesn't exceed the hardCap\n", '        require(hardCap >= SafeMath.add(totalContributed, msg.value));\n', '\n', '        // Increase the total contributed\n', '        totalContributed = SafeMath.add(totalContributed, msg.value);\n', '\n', '        // Calculated share\n', '        uint256 share = percent(msg.value, valuation, 5);\n', '\n', '        // Calculate and set the contributors % holding\n', '        if (ownerPercentages[sender] != 0) { // Existing contributor\n', '            ownerShareTokens[sender] = SafeMath.add(ownerShareTokens[sender], msg.value);\n', '            ownerPercentages[sender] = SafeMath.add(share, ownerPercentages[sender]);\n', '        } else { // New contributor\n', '            ownerAddresses[totalOwners] = sender;\n', '            totalOwners += 1;\n', '            ownerPercentages[sender] = share;\n', '            ownerShareTokens[sender] = msg.value;\n', '        }\n', '\n', '        // Transfer the ether to the wallet\n', '        wallet.transfer(msg.value);\n', '\n', '        // Fire event\n', '        emit Contribution(sender, share, msg.value);\n', '    }\n', '\n', '    // Add a wallet to the whitelist\n', '    function whitelistWallet(address contributor) external onlyOwner() {\n', '        // Is it actually an address?\n', '        require(contributor != address(0));\n', '\n', '        // Add address to whitelist\n', '        whitelist[contributor] = true;\n', '    }\n', '\n', '    // Start the contribution\n', '    function startContribution() external onlyOwner() {\n', '        require(!contributionStarted);\n', '        contributionStarted = true;\n', '    }\n', '\n', '    /**\n', '        Public Methods\n', '     */\n', '\n', '    // Set the owners share per owner, the balancing of shares is done externally\n', '    function setOwnerShare(address owner, uint256 value) public onlyOwner() {\n', "        // Make sure the shares aren't locked\n", '        require(!locked);\n', '\n', '        if (ownerShareTokens[owner] == 0) {\n', '            whitelist[owner] = true;\n', '            ownerAddresses[totalOwners] = owner;\n', '            totalOwners += 1;\n', '        }\n', '        ownerShareTokens[owner] = value;\n', '        ownerPercentages[owner] = percent(value, valuation, 5);\n', '    }\n', '\n', "    // Non-Standard token transfer, doesn't confine to any ERC\n", '    function sendOwnership(address receiver, uint256 amount) public onlyWhitelisted() {\n', '        // Require they have an actual balance\n', '        require(ownerShareTokens[msg.sender] > 0);\n', '\n', '        // Require the amount to be equal or less to their shares\n', '        require(ownerShareTokens[msg.sender] >= amount);\n', '\n', '        // Deduct the amount from the owner\n', '        ownerShareTokens[msg.sender] = SafeMath.sub(ownerShareTokens[msg.sender], amount);\n', '\n', '        // Remove the owner if the share is now 0\n', '        if (ownerShareTokens[msg.sender] == 0) {\n', '            ownerPercentages[msg.sender] = 0;\n', '            whitelist[receiver] = false; \n', '            \n', '        } else { // Recalculate percentage\n', '            ownerPercentages[msg.sender] = percent(ownerShareTokens[msg.sender], valuation, 5);\n', '        }\n', '\n', '        // Add the new share holder\n', '        if (ownerShareTokens[receiver] == 0) {\n', '            whitelist[receiver] = true;\n', '            ownerAddresses[totalOwners] = receiver;\n', '            totalOwners += 1;\n', '        }\n', '        ownerShareTokens[receiver] = SafeMath.add(ownerShareTokens[receiver], amount);\n', '        ownerPercentages[receiver] = SafeMath.add(ownerPercentages[receiver], percent(amount, valuation, 5));\n', '\n', '        emit OwnershipTransferred(msg.sender, receiver, amount);\n', '    }\n', '\n', '    // Lock the shares so contract owners cannot change them\n', '    function lockShares() public onlyOwner() {\n', '        require(!locked);\n', '        locked = true;\n', '    }\n', '\n', '    // Distribute the tokens in the contract to the contributors/creators\n', '    function distributeTokens(address token) public onlyWhitelisted() {\n', '        // Is this method already being called?\n', '        require(!distributionActive);\n', '        distributionActive = true;\n', '\n', '        // Get the token address\n', '        ERC677 erc677 = ERC677(token);\n', '\n', '        // Has the contract got a balance?\n', '        uint256 currentBalance = erc677.balanceOf(this) - tokenBalance[token];\n', '        require(currentBalance > ethWei * distributionMinimum);\n', '\n', '        // Add the current balance on to the total returned\n', '        tokenBalance[token] = SafeMath.add(tokenBalance[token], currentBalance);\n', '\n', '        // Loop through stakers and add the earned shares\n', '        // This is GAS expensive, but unless complex more bug prone logic was added there is no alternative\n', '        // This is due to the percentages needed to be calculated for all at once, or the amounts would differ\n', '        for (uint64 i = 0; i < totalOwners; i++) {\n', '            address owner = ownerAddresses[i];\n', '\n', '            // If the owner still has a share\n', '            if (ownerShareTokens[owner] > 0) {\n', '                // Calculate and transfer the ownership of shares with a precision of 5, for example: 12.345%\n', '                balances[owner][token] = SafeMath.add(SafeMath.div(SafeMath.mul(currentBalance, ownerPercentages[owner]), 100000), balances[owner][token]);\n', '            }\n', '        }\n', '        distributionActive = false;\n', '\n', '        // Emit the event\n', '        emit TokenDistribution(token, currentBalance);\n', '    }\n', '\n', '    // Withdraw tokens from the owners balance\n', '    function withdrawTokens(address token, uint256 amount) public {\n', "        // Can't withdraw nothing\n", '        require(amount > 0);\n', '\n', "        // Assert they're withdrawing what is in their balance\n", '        require(balances[msg.sender][token] >= amount);\n', '\n', '        // Substitute the amounts\n', '        balances[msg.sender][token] = SafeMath.sub(balances[msg.sender][token], amount);\n', '        tokenBalance[token] = SafeMath.sub(tokenBalance[token], amount);\n', '\n', '        // Transfer the tokens\n', '        ERC677 erc677 = ERC677(token);\n', '        require(erc677.transfer(msg.sender, amount) == true);\n', '\n', '        // Emit the event\n', '        emit TokenWithdrawal(token, msg.sender, amount);\n', '    }\n', '\n', '    // Sets the minimum balance needed for token distribution\n', '    function setDistributionMinimum(uint16 minimum) public onlyOwner() {\n', '        distributionMinimum = minimum;\n', '    }\n', '\n', '    // Sets the contribution ETH wallet\n', '    function setEthWallet(address _wallet) public onlyOwner() {\n', '        wallet = _wallet;\n', '    }\n', '\n', '    // Is an account whitelisted?\n', '    function isWhitelisted(address contributor) public view returns (bool) {\n', '        return whitelist[contributor];\n', '    }\n', '\n', '    // Get the owners token balance\n', '    function getOwnerBalance(address token) public view returns (uint256) {\n', '        return balances[msg.sender][token];\n', '    }\n', '\n', '    /**\n', '        Private Methods\n', '    */\n', '\n', '    // Credit to Rob Hitchens: https://stackoverflow.com/a/42739843\n', '    function percent(uint numerator, uint denominator, uint precision) private pure returns (uint quotient) {\n', '        uint _numerator = numerator * 10 ** (precision+1);\n', '        uint _quotient = ((_numerator / denominator) + 5) / 10;\n', '        return ( _quotient);\n', '    }\n', '}']
