['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' *  @title Smart City Crowdsale contract https://www.smartcitycoin.io\n', ' */\n', '\n', '\n', 'contract SmartCityToken {\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {}\n', '    \n', '    function setTokenStart(uint256 _newStartTime) public {}\n', '\n', '    function burn() public {}\n', '}\n', '\n', 'contract SmartCityCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '\t/// state\n', '    SmartCityToken public token; // Token Contract\n', '\t\n', '\taddress public owner; // Owner address\n', '\n', '\tmapping (address => bool) whitelist; // users whithelist\n', '\n', '    mapping(address => uint256) public balances; // the array of users along with amounts invested\n', '\t\n', '\tmapping(address => uint256) public purchases; // the array of users and tokens purchased\n', '\n', '    uint256 public raisedEth; // Amount of Ether raised\n', '\n', '    uint256 public startTime; // Crowdale start time\n', '\n', '    uint256 public tokensSoldTotal = 0; // Sold Tolkens counter\n', '\n', '    bool public crowdsaleEnded = false; // if the Campaign is over\n', '\t\n', '\tbool public paused = false; // if the Campaign is paused\n', '\n', '    uint256 public positionPrice = 5730 finney; // Initially 1 investement position costs 5.73 ETH, might be changed by owner afterwards\n', '\t\n', '\tuint256 public usedPositions = 0; // Initial number of used investment positions\n', '\t\n', '\tuint256 public availablePositions = 100; // Initial number of open investment positions\n', '\n', '    address walletAddress; // address of the wallet contract storing the funds\n', '\n', '\t/// constants\n', '    uint256 constant public tokensForSale = 164360928100000; // Total amount of tokens allocated for the Crowdsale\n', '\n', '\tuint256 constant public weiToTokenFactor = 10000000000000;\n', '\n', '\tuint256 constant public investmentPositions = 4370; // Total number of investment positions\n', '\n', '    uint256 constant public investmentLimit = 18262325344444; // the maximum amount of Ether an address is allowed to invest - limited to 1/9 of tokens allocated for sale\n', '\n', '\t/// events\n', '    event FundTransfer(address indexed _investorAddr, uint256 _amount, uint256 _amountRaised); // fired on transfering funds from investors\n', '\t\n', '\tevent Granted(address indexed party); // user is added to the whitelist\n', '\t\n', '\tevent Revoked(address indexed party); // user is removed from the whitelist\n', '\t\n', '\tevent Ended(uint256 raisedAmount); // Crowdsale is ended\n', '\n', '\t/// modifiers\n', '\tmodifier onlyWhenActive() {\n', '\t\trequire(now >= startTime && !crowdsaleEnded && !paused);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tmodifier whenPositionsAvailable() {\n', '\t\trequire(availablePositions > 0);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyWhitelisted(address party) {\n', '\t\trequire(whitelist[party]);\n', '\t\t_; \n', '\t}\n', '\t\n', '\tmodifier onlyNotOnList(address party) {\n', '\t\trequire(!whitelist[party]);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '    /**\n', '     *  @dev Crowdsale Contract initialization\n', '     *  @param _owner address Token owner address\n', '     *  @param _tokenAddress address Crowdsale end time\n', '     *  @param _walletAddress address Beneficiary address where the funds are collected\n', '     *  @param _start uint256 Crowdsale Start Time\n', '     */\n', '    function SmartCityCrowdsale (\n', '            address _tokenAddress,\n', '            address _owner,\n', '            address _walletAddress,\n', '            uint256 _start) public {\n', '\n', '        owner = _owner;\n', '        token = SmartCityToken(_tokenAddress);\n', '        walletAddress = _walletAddress;\n', '\n', '        startTime = _start; // Crowdsale Start Time\n', '    }\n', '\n', '    /**\n', '     *  @dev Investment can be done just by sending Ether to Crowdsale Contract\n', '     */\n', '    function() public payable {\n', '        invest();\n', '    }\n', '\n', '    /**\n', '     *  @dev Make an investment\n', '     */\n', '    function invest() public payable\n', '\t\t\t\tonlyWhitelisted(msg.sender)\n', '\t\t\t\twhenPositionsAvailable\n', '\t\t\t\tonlyWhenActive\n', '\t{\n', '\t\taddress _receiver = msg.sender;\n', '        uint256 amount = msg.value; // Transaction value in Wei\n', '\n', '        var (positionsCnt, tokensCnt) = getPositionsAndTokensCnt(amount); \n', '\n', '        require(positionsCnt > 0 && positionsCnt <= availablePositions && tokensCnt > 0);\n', '\n', '\t\trequire(purchases[_receiver].add(tokensCnt) <= investmentLimit); // Check the investment limit is not exceeded\n', '\n', '        require(tokensSoldTotal.add(tokensCnt) <= tokensForSale);\n', '\n', '        walletAddress.transfer(amount); // Send funds to the Wallet\n', '\t\t\n', '        balances[_receiver] = balances[_receiver].add(amount); // Add the amount invested to Investor&#39;s ballance\n', '\t\tpurchases[_receiver] = purchases[_receiver].add(tokensCnt); // Add tokens to Investor&#39;s purchases\n', '        raisedEth = raisedEth.add(amount); // Increase raised funds counter\n', '\t\tavailablePositions = availablePositions.sub(positionsCnt);\n', '\t\tusedPositions = usedPositions.add(positionsCnt);\n', '        tokensSoldTotal = tokensSoldTotal.add(tokensCnt); // Increase sold CITY counter\n', '\n', '        require(token.transferFrom(owner, _receiver, tokensCnt)); // Transfer CITY purchased to Investor\n', '\n', '        FundTransfer(_receiver, amount, raisedEth);\n', '\t\t\n', '\t\tif (usedPositions == investmentPositions) { // Sold Out\n', '\t\t\ttoken.burn();\n', '\t\t\tcrowdsaleEnded = true; // mark Crowdsale ended\n', '\t\t\t\n', '\t\t\tEnded(raisedEth);\n', '\t\t}\n', '    }\n', '    \n', '    /**\n', '     *  @dev Calculate the amount of Tokens purchased based on the value sent and current Token price\n', '     *  @param _value uint256 Amount invested\n', '     */\n', '    function getPositionsAndTokensCnt(uint256 _value) public constant onlyWhenActive returns(uint256 positionsCnt, uint256 tokensCnt) {\n', '\t\t\tif (_value % positionPrice != 0 || usedPositions >= investmentPositions) {\n', '\t\t\t\treturn(0, 0);\n', '\t\t\t}\n', '\t\t\telse {\n', '\t\t\t\tuint256 purchasedPositions = _value.div(positionPrice);\n', '\t\t\t\tuint256 purchasedTokens = ((tokensForSale.sub(tokensSoldTotal)).mul(purchasedPositions)).div(investmentPositions.sub(usedPositions));\n', '\t\t\t\treturn(purchasedPositions, purchasedTokens);\n', '\t\t\t}\n', '    }\n', '\n', '\tfunction getMinPurchase() public constant onlyWhenActive returns(uint256 minPurchase) {\n', '\t\treturn positionPrice;\n', '\t}\n', '\t\n', '\t/// Owner functions\n', '\t\n', '    /**\n', '     *  @dev To increace/reduce number of Investment Positions released for sale\n', '     */\n', '    function setAvailablePositions(uint256 newAvailablePositions) public onlyOwner {\n', '        require(newAvailablePositions <= investmentPositions.sub(usedPositions));\n', '\t\tavailablePositions = newAvailablePositions;\n', '    }\n', '\t\n', '\t/**\n', '     *  @dev Allows Investment Position price changes\n', '     */\n', '    function setPositionPrice(uint256 newPositionPrice) public onlyOwner {\n', '        require(newPositionPrice > 0);\n', '\t\tpositionPrice = newPositionPrice;\n', '    }\n', '\t\n', '\t /**\n', '     *  @dev Emergency function to pause Crowdsale.\n', '     */\n', '    function setPaused(bool _paused) public onlyOwner { paused = _paused; }\n', '\n', '\t/**\n', '    *   @dev Emergency function to drain the contract of any funds.\n', '    */\n', '\tfunction drain() public onlyOwner { walletAddress.transfer(this.balance); }\n', '\t\n', '\t/**\n', '    *   @dev Function to manually finalize Crowdsale.\n', '    */\n', '\tfunction endCrowdsale() public onlyOwner {\n', '\t\tusedPositions = investmentPositions;\n', '\t\tavailablePositions = 0;\n', '\t\ttoken.burn(); // burn all unsold tokens\n', '\t\tcrowdsaleEnded = true; // mark Crowdsale ended\n', '\t\t\n', '\t\tEnded(raisedEth);\n', '\t}\n', '\n', '\t/// Whitelist functions\n', '\tfunction grant(address _party) public onlyOwner onlyNotOnList(_party)\n', '\t{\n', '\t\twhitelist[_party] = true;\n', '\t\tGranted(_party);\n', '\t}\n', '\n', '\tfunction revoke(address _party) public onlyOwner onlyWhitelisted(_party)\n', '\t{\n', '\t\twhitelist[_party] = false;\n', '\t\tRevoked(_party);\n', '\t}\n', '\t\n', '\tfunction massGrant(address[] _parties) public onlyOwner\n', '\t{\n', '\t\tuint len = _parties.length;\n', '\t\t\n', '\t\tfor (uint i = 0; i < len; i++) {\n', '\t\t\twhitelist[_parties[i]] = true;\n', '\t\t\tGranted(_parties[i]);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction massRevoke(address[] _parties) public onlyOwner\n', '\t{\n', '\t\tuint len = _parties.length;\n', '\t\t\n', '\t\tfor (uint i = 0; i < len; i++) {\n', '\t\t\twhitelist[_parties[i]] = false;\n', '\t\t\tRevoked(_parties[i]);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction isWhitelisted(address _party) public constant returns (bool) {\n', '\t\treturn whitelist[_party];\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\t\n', '    /**\n', '    *            CITY 2.0 token by www.SmartCityCoin.io\n', '    * \n', '    *          .ossssss:                      `+sssss`      \n', '    *         ` +ssssss+` `.://++++++//:.`  .osssss+       \n', '    *            /sssssssssssssssssssssssss+ssssso`        \n', '    *             -sssssssssssssssssssssssssssss+`         \n', '    *            .+sssssssss+:--....--:/ossssssss+.        \n', '    *          `/ssssssssssso`         .sssssssssss/`      \n', '    *         .ossssss+sssssss-       :sssss+:ossssso.     \n', '    *        `ossssso. .ossssss:    `/sssss/  `/ssssss.    \n', '    *        ossssso`   `+ssssss+` .osssss:     /ssssss`   \n', '    *       :ssssss`      /sssssso:ssssso.       +o+/:-`   \n', '    *       osssss+        -sssssssssss+`                  \n', '    *       ssssss:         .ossssssss/                    \n', '    *       osssss/          `+ssssss-                     \n', '    *       /ssssso           :ssssss                      \n', '    *       .ssssss-          :ssssss                      \n', '    *        :ssssss-         :ssssss          `           \n', '    *         /ssssss/`       :ssssss        `/s+:`        \n', '    *          :sssssso:.     :ssssss      ./ssssss+`      \n', '    *           .+ssssssso/-.`:ssssss``.-/osssssss+.       \n', '    *             .+ssssssssssssssssssssssssssss+-         \n', '    *               `:+ssssssssssssssssssssss+:`           \n', '    *                  `.:+osssssssssssso+:.`              \n', '    *                        `/ssssss.`                    \n', '    *                         :ssssss                      \n', '    */']