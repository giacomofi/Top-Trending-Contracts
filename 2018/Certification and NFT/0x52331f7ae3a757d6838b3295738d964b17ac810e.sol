['pragma solidity ^0.4.23;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', 'contract ReentrancyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', '\n', 'contract ERC20TokenInterface {\n', '    function totalSupply() public constant returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Crowdsale is ReentrancyHandlingContract, Owned {\n', '    \n', '    enum state { pendingStart, crowdsale, crowdsaleEnded }\n', '    struct ContributorData {\n', '        uint contributionAmount;\n', '        uint tokensIssued;\n', '    }\n', '    struct Tier {\n', '        uint minContribution;\n', '        uint maxContribution;\n', '        uint bonus;\n', '        bool tierActive;\n', '    }\n', '    mapping (address => uint) public verifiedAddresses;\n', '    mapping(uint => Tier) public tierList;\n', '    uint public nextFreeTier = 1;\n', '    \n', '\n', '    state public crowdsaleState = state.pendingStart;\n', '    \n', '    address public multisigAddress;\n', '\n', '    uint public crowdsaleStartBlock;\n', '    uint public crowdsaleEndedBlock;\n', '\n', '    mapping(address => ContributorData) public contributorList;\n', '    uint public nextContributorIndex;\n', '    mapping(uint => address) public contributorIndexes;\n', '\n', '    uint public minCap;\n', '    uint public maxCap;\n', '    uint public ethRaised;\n', '    uint public tokensIssued = 0;\n', '    uint public blocksInADay;\n', '    uint public ethToTokenConversion;\n', '\n', '    event CrowdsaleStarted(uint blockNumber);\n', '    event CrowdsaleEnded(uint blockNumber);\n', '    event ErrorSendingETH(address to, uint amount);\n', '    event MinCapReached(uint blockNumber);\n', '    event MaxCapReached(uint blockNumber);\n', '\n', '    function() noReentrancy payable public {\n', '        require(crowdsaleState != state.crowdsaleEnded);\n', '        require(isAddressVerified(msg.sender));\n', '        \n', '        bool stateChanged = checkCrowdsaleState();\n', '\n', '        if (crowdsaleState == state.crowdsale) {\n', '            processTransaction(msg.sender, msg.value);\n', '        } else {\n', '            refundTransaction(stateChanged);\n', '        }\n', '    }\n', '\n', '    function checkCrowdsaleState() internal returns (bool) {\n', '        if (tokensIssued == maxCap && crowdsaleState != state.crowdsaleEnded) {\n', '            crowdsaleState = state.crowdsaleEnded;\n', '            emit CrowdsaleEnded(block.number);\n', '            return true;\n', '        }\n', '\n', '        if (block.number >= crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {\n', '            if (crowdsaleState != state.crowdsale) {\n', '                crowdsaleState = state.crowdsale;\n', '                emit CrowdsaleStarted(block.number);\n', '                return true;\n', '            }\n', '        } else {\n', '            if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {\n', '                crowdsaleState = state.crowdsaleEnded;\n', '                emit CrowdsaleEnded(block.number);\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function refundTransaction(bool _stateChanged) internal {\n', '        if (_stateChanged) {\n', '            msg.sender.transfer(msg.value);\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    function setEthToTokenConversion(uint _ratio) onlyOwner public {\n', '        require(crowdsaleState == state.pendingStart);\n', '        ethToTokenConversion = _ratio;\n', '    }\n', '    \n', '    function setMaxCap(uint _maxCap) onlyOwner public {\n', '        require(crowdsaleState == state.pendingStart);\n', '        maxCap = _maxCap;\n', '    }\n', '    \n', '    function calculateEthToToken(uint _eth, uint _bonus) constant public returns(uint) {\n', '        uint bonusTokens;\n', '        if (_bonus != 0) {\n', '            bonusTokens = ((_eth * ethToTokenConversion) * _bonus) / 100;\n', '        } \n', '        return (_eth * ethToTokenConversion) + bonusTokens;\n', '    }\n', '\n', '    function calculateTokenToEth(uint _token, uint _bonus) constant public returns(uint) {\n', '        uint ethTokenWithBonus = ethToTokenConversion;\n', '        if (_bonus != 0){\n', '            ethTokenWithBonus = ((ethToTokenConversion * _bonus) / 100) + ethToTokenConversion;\n', '        }\n', '        return _token / ethTokenWithBonus;\n', '    }\n', '\n', '    function processTransaction(address _contributor, uint _amount) internal {\n', '        uint contributionAmount = 0;\n', '        uint returnAmount = 0;\n', '        uint tokensToGive = 0;\n', '        uint contributorTier;\n', '        uint minContribution;\n', '        uint maxContribution;\n', '        uint bonus;\n', '        (contributorTier, minContribution, maxContribution, bonus) = getContributorData(_contributor); \n', '\n', '        if (block.number >= crowdsaleStartBlock && block.number < crowdsaleStartBlock + blocksInADay){\n', '            require(_amount >= minContribution);\n', '            require(contributorTier == 1 || contributorTier == 2 || contributorTier == 5 || contributorTier == 6 || contributorTier == 7 || contributorTier == 8);\n', '            if (_amount > maxContribution && maxContribution != 0){\n', '                contributionAmount = maxContribution;\n', '                returnAmount = _amount - maxContribution;\n', '            } else {\n', '                contributionAmount = _amount;\n', '            }\n', '            tokensToGive = calculateEthToToken(contributionAmount, bonus);\n', '        } else if (block.number >= crowdsaleStartBlock + blocksInADay && block.number < crowdsaleStartBlock + 2 * blocksInADay) {\n', '            require(_amount >= minContribution);\n', '            require(contributorTier == 3 || contributorTier == 5 || contributorTier == 6 || contributorTier == 7 || contributorTier == 8);\n', '            if (_amount > maxContribution && maxContribution != 0) {\n', '                contributionAmount = maxContribution;\n', '                returnAmount = _amount - maxContribution;\n', '            } else {\n', '                contributionAmount = _amount;\n', '            }\n', '            tokensToGive = calculateEthToToken(contributionAmount, bonus);\n', '        } else {\n', '            require(_amount >= minContribution);\n', '            if (_amount > maxContribution && maxContribution != 0) {\n', '                contributionAmount = maxContribution;\n', '                returnAmount = _amount - maxContribution;\n', '            } else {\n', '                contributionAmount = _amount;\n', '            }\n', '            if(contributorTier == 5 || contributorTier == 6 || contributorTier == 7 || contributorTier == 8){\n', '                tokensToGive = calculateEthToToken(contributionAmount, bonus);\n', '            }else{\n', '                tokensToGive = calculateEthToToken(contributionAmount, 0);\n', '            }\n', '        }\n', '\n', '        if (tokensToGive > (maxCap - tokensIssued)) {\n', '            if (block.number >= crowdsaleStartBlock && block.number < crowdsaleStartBlock + blocksInADay){\n', '                contributionAmount = calculateTokenToEth(maxCap - tokensIssued, bonus);\n', '            }else if (block.number >= crowdsaleStartBlock + blocksInADay && block.number < crowdsaleStartBlock + 2 * blocksInADay) {\n', '                contributionAmount = calculateTokenToEth(maxCap - tokensIssued, bonus);\n', '            }else{\n', '                if(contributorTier == 5 || contributorTier == 6 || contributorTier == 7 || contributorTier == 8){\n', '                    contributionAmount = calculateTokenToEth(maxCap - tokensIssued, bonus);\n', '                }else{\n', '                    contributionAmount = calculateTokenToEth(maxCap - tokensIssued, 0);\n', '                }\n', '            }\n', '\n', '            returnAmount = _amount - contributionAmount;\n', '            tokensToGive = maxCap - tokensIssued;\n', '            emit MaxCapReached(block.number);\n', '        }\n', '\n', '        if (contributorList[_contributor].contributionAmount == 0) {\n', '            contributorIndexes[nextContributorIndex] = _contributor;\n', '            nextContributorIndex += 1;\n', '        }\n', '\n', '        contributorList[_contributor].contributionAmount += contributionAmount;\n', '        ethRaised += contributionAmount;\n', '\n', '        if (tokensToGive > 0) {\n', '            contributorList[_contributor].tokensIssued += tokensToGive;\n', '            tokensIssued += tokensToGive;\n', '        }\n', '        if (returnAmount != 0) {\n', '            _contributor.transfer(returnAmount);\n', '        } \n', '    }\n', '\n', '    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n', '        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '\n', '    function withdrawEth() onlyOwner public {\n', '        require(address(this).balance != 0);\n', '        require(tokensIssued >= minCap);\n', '\n', '        multisigAddress.transfer(address(this).balance);\n', '    }\n', '\n', '    function investorCount() constant public returns(uint) {\n', '        return nextContributorIndex;\n', '    }\n', '\n', '    function setCrowdsaleStartBlock(uint _block) onlyOwner public {\n', '        require(crowdsaleState == state.pendingStart);\n', '        crowdsaleStartBlock = _block;\n', '    }\n', '\n', '    function setCrowdsaleEndBlock(uint _block) onlyOwner public {\n', '        require(crowdsaleState == state.pendingStart);\n', '        crowdsaleEndedBlock = _block;\n', '    }\n', '    \n', '    function isAddressVerified(address _address) public view returns (bool) {\n', '        if (verifiedAddresses[_address] == 0){\n', '            return false;\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function getContributorData(address _contributor) public view returns (uint, uint, uint, uint) {\n', '        uint contributorTier = verifiedAddresses[_contributor];\n', '        return (contributorTier, tierList[contributorTier].minContribution, tierList[contributorTier].maxContribution, tierList[contributorTier].bonus);\n', '    }\n', '    \n', '    function addAddress(address _newAddress, uint _tier) public onlyOwner {\n', '        require(verifiedAddresses[_newAddress] == 0);\n', '        \n', '        verifiedAddresses[_newAddress] = _tier;\n', '    }\n', '    \n', '    function removeAddress(address _oldAddress) public onlyOwner {\n', '        require(verifiedAddresses[_oldAddress] != 0);\n', '        \n', '        verifiedAddresses[_oldAddress] = 0;\n', '    }\n', '    \n', '    function batchAddAddresses(address[] _addresses, uint[] _tiers) public onlyOwner {\n', '        require(_addresses.length == _tiers.length);\n', '        for (uint cnt = 0; cnt < _addresses.length; cnt++) {\n', '            assert(verifiedAddresses[_addresses[cnt]] != 0);\n', '            verifiedAddresses[_addresses[cnt]] = _tiers[cnt];\n', '        }\n', '    }\n', '}\n', '\n', 'contract MoneyRebelCrowdsaleContract is Crowdsale {\n', '  \n', '    constructor() public {\n', '\n', '        crowdsaleStartBlock = 5578000;\n', '        crowdsaleEndedBlock = 5618330;\n', '\n', '        minCap = 0 * 10**18;\n', '        maxCap = 744428391 * 10**18;\n', '\n', '        ethToTokenConversion = 13888;\n', '\n', '        blocksInADay = 5760;\n', '\n', '        multisigAddress = 0x352C30f3092556CD42fE39cbCF585f33CE1C20bc;\n', ' \n', '        tierList[1] = Tier(2*10**17,35*10**18,10, true);\n', '        tierList[2] = Tier(2*10**17,35*10**18,10, true);\n', '        tierList[3] = Tier(2*10**17,25*10**18,0, true);\n', '        tierList[4] = Tier(2*10**17,100000*10**18,0, true);\n', '        tierList[5] = Tier(2*10**17,100000*10**18,8, true);\n', '        tierList[6] = Tier(2*10**17,100000*10**18,10, true); \n', '        tierList[7] = Tier(2*10**17,100000*10**18,12, true);\n', '        tierList[8] = Tier(2*10**17,100000*10**18,15, true);\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', 'contract ReentrancyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', '\n', 'contract ERC20TokenInterface {\n', '    function totalSupply() public constant returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Crowdsale is ReentrancyHandlingContract, Owned {\n', '    \n', '    enum state { pendingStart, crowdsale, crowdsaleEnded }\n', '    struct ContributorData {\n', '        uint contributionAmount;\n', '        uint tokensIssued;\n', '    }\n', '    struct Tier {\n', '        uint minContribution;\n', '        uint maxContribution;\n', '        uint bonus;\n', '        bool tierActive;\n', '    }\n', '    mapping (address => uint) public verifiedAddresses;\n', '    mapping(uint => Tier) public tierList;\n', '    uint public nextFreeTier = 1;\n', '    \n', '\n', '    state public crowdsaleState = state.pendingStart;\n', '    \n', '    address public multisigAddress;\n', '\n', '    uint public crowdsaleStartBlock;\n', '    uint public crowdsaleEndedBlock;\n', '\n', '    mapping(address => ContributorData) public contributorList;\n', '    uint public nextContributorIndex;\n', '    mapping(uint => address) public contributorIndexes;\n', '\n', '    uint public minCap;\n', '    uint public maxCap;\n', '    uint public ethRaised;\n', '    uint public tokensIssued = 0;\n', '    uint public blocksInADay;\n', '    uint public ethToTokenConversion;\n', '\n', '    event CrowdsaleStarted(uint blockNumber);\n', '    event CrowdsaleEnded(uint blockNumber);\n', '    event ErrorSendingETH(address to, uint amount);\n', '    event MinCapReached(uint blockNumber);\n', '    event MaxCapReached(uint blockNumber);\n', '\n', '    function() noReentrancy payable public {\n', '        require(crowdsaleState != state.crowdsaleEnded);\n', '        require(isAddressVerified(msg.sender));\n', '        \n', '        bool stateChanged = checkCrowdsaleState();\n', '\n', '        if (crowdsaleState == state.crowdsale) {\n', '            processTransaction(msg.sender, msg.value);\n', '        } else {\n', '            refundTransaction(stateChanged);\n', '        }\n', '    }\n', '\n', '    function checkCrowdsaleState() internal returns (bool) {\n', '        if (tokensIssued == maxCap && crowdsaleState != state.crowdsaleEnded) {\n', '            crowdsaleState = state.crowdsaleEnded;\n', '            emit CrowdsaleEnded(block.number);\n', '            return true;\n', '        }\n', '\n', '        if (block.number >= crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {\n', '            if (crowdsaleState != state.crowdsale) {\n', '                crowdsaleState = state.crowdsale;\n', '                emit CrowdsaleStarted(block.number);\n', '                return true;\n', '            }\n', '        } else {\n', '            if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {\n', '                crowdsaleState = state.crowdsaleEnded;\n', '                emit CrowdsaleEnded(block.number);\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function refundTransaction(bool _stateChanged) internal {\n', '        if (_stateChanged) {\n', '            msg.sender.transfer(msg.value);\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    function setEthToTokenConversion(uint _ratio) onlyOwner public {\n', '        require(crowdsaleState == state.pendingStart);\n', '        ethToTokenConversion = _ratio;\n', '    }\n', '    \n', '    function setMaxCap(uint _maxCap) onlyOwner public {\n', '        require(crowdsaleState == state.pendingStart);\n', '        maxCap = _maxCap;\n', '    }\n', '    \n', '    function calculateEthToToken(uint _eth, uint _bonus) constant public returns(uint) {\n', '        uint bonusTokens;\n', '        if (_bonus != 0) {\n', '            bonusTokens = ((_eth * ethToTokenConversion) * _bonus) / 100;\n', '        } \n', '        return (_eth * ethToTokenConversion) + bonusTokens;\n', '    }\n', '\n', '    function calculateTokenToEth(uint _token, uint _bonus) constant public returns(uint) {\n', '        uint ethTokenWithBonus = ethToTokenConversion;\n', '        if (_bonus != 0){\n', '            ethTokenWithBonus = ((ethToTokenConversion * _bonus) / 100) + ethToTokenConversion;\n', '        }\n', '        return _token / ethTokenWithBonus;\n', '    }\n', '\n', '    function processTransaction(address _contributor, uint _amount) internal {\n', '        uint contributionAmount = 0;\n', '        uint returnAmount = 0;\n', '        uint tokensToGive = 0;\n', '        uint contributorTier;\n', '        uint minContribution;\n', '        uint maxContribution;\n', '        uint bonus;\n', '        (contributorTier, minContribution, maxContribution, bonus) = getContributorData(_contributor); \n', '\n', '        if (block.number >= crowdsaleStartBlock && block.number < crowdsaleStartBlock + blocksInADay){\n', '            require(_amount >= minContribution);\n', '            require(contributorTier == 1 || contributorTier == 2 || contributorTier == 5 || contributorTier == 6 || contributorTier == 7 || contributorTier == 8);\n', '            if (_amount > maxContribution && maxContribution != 0){\n', '                contributionAmount = maxContribution;\n', '                returnAmount = _amount - maxContribution;\n', '            } else {\n', '                contributionAmount = _amount;\n', '            }\n', '            tokensToGive = calculateEthToToken(contributionAmount, bonus);\n', '        } else if (block.number >= crowdsaleStartBlock + blocksInADay && block.number < crowdsaleStartBlock + 2 * blocksInADay) {\n', '            require(_amount >= minContribution);\n', '            require(contributorTier == 3 || contributorTier == 5 || contributorTier == 6 || contributorTier == 7 || contributorTier == 8);\n', '            if (_amount > maxContribution && maxContribution != 0) {\n', '                contributionAmount = maxContribution;\n', '                returnAmount = _amount - maxContribution;\n', '            } else {\n', '                contributionAmount = _amount;\n', '            }\n', '            tokensToGive = calculateEthToToken(contributionAmount, bonus);\n', '        } else {\n', '            require(_amount >= minContribution);\n', '            if (_amount > maxContribution && maxContribution != 0) {\n', '                contributionAmount = maxContribution;\n', '                returnAmount = _amount - maxContribution;\n', '            } else {\n', '                contributionAmount = _amount;\n', '            }\n', '            if(contributorTier == 5 || contributorTier == 6 || contributorTier == 7 || contributorTier == 8){\n', '                tokensToGive = calculateEthToToken(contributionAmount, bonus);\n', '            }else{\n', '                tokensToGive = calculateEthToToken(contributionAmount, 0);\n', '            }\n', '        }\n', '\n', '        if (tokensToGive > (maxCap - tokensIssued)) {\n', '            if (block.number >= crowdsaleStartBlock && block.number < crowdsaleStartBlock + blocksInADay){\n', '                contributionAmount = calculateTokenToEth(maxCap - tokensIssued, bonus);\n', '            }else if (block.number >= crowdsaleStartBlock + blocksInADay && block.number < crowdsaleStartBlock + 2 * blocksInADay) {\n', '                contributionAmount = calculateTokenToEth(maxCap - tokensIssued, bonus);\n', '            }else{\n', '                if(contributorTier == 5 || contributorTier == 6 || contributorTier == 7 || contributorTier == 8){\n', '                    contributionAmount = calculateTokenToEth(maxCap - tokensIssued, bonus);\n', '                }else{\n', '                    contributionAmount = calculateTokenToEth(maxCap - tokensIssued, 0);\n', '                }\n', '            }\n', '\n', '            returnAmount = _amount - contributionAmount;\n', '            tokensToGive = maxCap - tokensIssued;\n', '            emit MaxCapReached(block.number);\n', '        }\n', '\n', '        if (contributorList[_contributor].contributionAmount == 0) {\n', '            contributorIndexes[nextContributorIndex] = _contributor;\n', '            nextContributorIndex += 1;\n', '        }\n', '\n', '        contributorList[_contributor].contributionAmount += contributionAmount;\n', '        ethRaised += contributionAmount;\n', '\n', '        if (tokensToGive > 0) {\n', '            contributorList[_contributor].tokensIssued += tokensToGive;\n', '            tokensIssued += tokensToGive;\n', '        }\n', '        if (returnAmount != 0) {\n', '            _contributor.transfer(returnAmount);\n', '        } \n', '    }\n', '\n', '    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n', '        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '\n', '    function withdrawEth() onlyOwner public {\n', '        require(address(this).balance != 0);\n', '        require(tokensIssued >= minCap);\n', '\n', '        multisigAddress.transfer(address(this).balance);\n', '    }\n', '\n', '    function investorCount() constant public returns(uint) {\n', '        return nextContributorIndex;\n', '    }\n', '\n', '    function setCrowdsaleStartBlock(uint _block) onlyOwner public {\n', '        require(crowdsaleState == state.pendingStart);\n', '        crowdsaleStartBlock = _block;\n', '    }\n', '\n', '    function setCrowdsaleEndBlock(uint _block) onlyOwner public {\n', '        require(crowdsaleState == state.pendingStart);\n', '        crowdsaleEndedBlock = _block;\n', '    }\n', '    \n', '    function isAddressVerified(address _address) public view returns (bool) {\n', '        if (verifiedAddresses[_address] == 0){\n', '            return false;\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function getContributorData(address _contributor) public view returns (uint, uint, uint, uint) {\n', '        uint contributorTier = verifiedAddresses[_contributor];\n', '        return (contributorTier, tierList[contributorTier].minContribution, tierList[contributorTier].maxContribution, tierList[contributorTier].bonus);\n', '    }\n', '    \n', '    function addAddress(address _newAddress, uint _tier) public onlyOwner {\n', '        require(verifiedAddresses[_newAddress] == 0);\n', '        \n', '        verifiedAddresses[_newAddress] = _tier;\n', '    }\n', '    \n', '    function removeAddress(address _oldAddress) public onlyOwner {\n', '        require(verifiedAddresses[_oldAddress] != 0);\n', '        \n', '        verifiedAddresses[_oldAddress] = 0;\n', '    }\n', '    \n', '    function batchAddAddresses(address[] _addresses, uint[] _tiers) public onlyOwner {\n', '        require(_addresses.length == _tiers.length);\n', '        for (uint cnt = 0; cnt < _addresses.length; cnt++) {\n', '            assert(verifiedAddresses[_addresses[cnt]] != 0);\n', '            verifiedAddresses[_addresses[cnt]] = _tiers[cnt];\n', '        }\n', '    }\n', '}\n', '\n', 'contract MoneyRebelCrowdsaleContract is Crowdsale {\n', '  \n', '    constructor() public {\n', '\n', '        crowdsaleStartBlock = 5578000;\n', '        crowdsaleEndedBlock = 5618330;\n', '\n', '        minCap = 0 * 10**18;\n', '        maxCap = 744428391 * 10**18;\n', '\n', '        ethToTokenConversion = 13888;\n', '\n', '        blocksInADay = 5760;\n', '\n', '        multisigAddress = 0x352C30f3092556CD42fE39cbCF585f33CE1C20bc;\n', ' \n', '        tierList[1] = Tier(2*10**17,35*10**18,10, true);\n', '        tierList[2] = Tier(2*10**17,35*10**18,10, true);\n', '        tierList[3] = Tier(2*10**17,25*10**18,0, true);\n', '        tierList[4] = Tier(2*10**17,100000*10**18,0, true);\n', '        tierList[5] = Tier(2*10**17,100000*10**18,8, true);\n', '        tierList[6] = Tier(2*10**17,100000*10**18,10, true); \n', '        tierList[7] = Tier(2*10**17,100000*10**18,12, true);\n', '        tierList[8] = Tier(2*10**17,100000*10**18,15, true);\n', '    }\n', '}']
