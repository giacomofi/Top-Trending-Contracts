['pragma solidity ^0.4.24;\n', '\n', '// *-----------------------------------------------------------------------*\n', '//       __ _    ________   __________  _____   __\n', '//      / /| |  / / ____/  / ____/ __ \\/  _/ | / /\n', '//     / / | | / / __/    / /   / / / // //  |/ / \n', '//    / /__| |/ / /___   / /___/ /_/ // // /|  /  \n', '//   /_____/___/_____/   \\____/\\____/___/_/ |_/  \n', '// *-----------------------------------------------------------------------*\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @ multiSig\n', ' */\n', 'contract Ownable {\n', '\n', '    // _from: oldOwner _to: newOwner\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '    event SubmitPrps(ProposalType indexed _prpsType);\n', '    event SignPrps(uint256 indexed _prpsIdx, ProposalType indexed _prpsType, address indexed _from);\n', '\n', '    // owner proposal type enum\n', '    enum ProposalType {\n', '        freeze,\n', '        unfreeze,\n', '        transferOwner\n', '    }\n', '    // owner proposal\n', '    struct Proposal {\n', '        ProposalType prpsType;\n', '        address fromAddr;\n', '        address toAddr;\n', '        mapping(address => bool) signed;\n', '        bool finalized;\n', '    }\n', '    // require sign owner number\n', '    uint256 public requiredSignNum;\n', '    // all owner address\n', '    address[] public owners;\n', '    // owner proposal list\n', '    Proposal[] public proposals;\n', '    // is owner mapping\n', '    mapping(address => bool) public isOwnerMap;\n', '\n', '    constructor() public{\n', '    }\n', '\n', '    // is owner\n', '    modifier isOwner{\n', '        require(isOwnerMap[msg.sender], "");\n', '        _;\n', '    }\n', '    // is most owner sign proposal\n', '    modifier multiSig(uint256 _prpsIdx) {\n', '        // is more than half(多數決)\n', '        require(signOwnerCount(_prpsIdx) >= requiredSignNum, "");\n', '        // proposal is not finalized\n', '        require(proposals[_prpsIdx].finalized == false, "");\n', '        _;\n', '    }\n', '    // proposal is exist\n', '    modifier isPrpsExists(uint256 _prpsIdx) {\n', '        require(_prpsIdx >= 0, "");\n', '        require(_prpsIdx < proposals.length, "");\n', '        _;\n', '    }\n', '    modifier checkOwner(address _fromAddr, address _toAddr) {\n', '        require(_toAddr != address(0), "");\n', '        require(_toAddr != msg.sender, "");\n', '        require(_fromAddr != msg.sender, "");\n', '        _;\n', '    }\n', '    // is right proposal type\n', '    modifier checkPrpsType(ProposalType _prpsType) {\n', '        require(_prpsType == ProposalType.freeze || _prpsType == ProposalType.unfreeze || _prpsType == ProposalType.transferOwner, "");\n', '        _;\n', '    }\n', '    // check already sign prps\n', '    modifier checkSignPrps(uint256 _prpsIdx) {\n', '        // proposal is not finalized\n', '        require(proposals[_prpsIdx].finalized == false, "");\n', '        // owner is not signed\n', '        require(proposals[_prpsIdx].signed[msg.sender] == false, "");\n', '        _;\n', '    }\n', '\n', '\n', '    // any owner submit not certified proposal\n', '    function submitProposal(ProposalType _prpsType, address _fromAddr, address _toAddr) public isOwner checkOwner(_fromAddr, _toAddr) checkPrpsType(_prpsType) {\n', '        Proposal memory _proposal;\n', '        _proposal.prpsType = _prpsType;\n', '        _proposal.finalized = false;\n', '        _proposal.fromAddr = _fromAddr;\n', '        _proposal.toAddr = _toAddr;\n', '        proposals.push(_proposal);\n', '        emit SubmitPrps(_prpsType);\n', '    }\n', '\n', '    // owner sign an proposal\n', '    function signProposal(uint256 _prpsIdx) public isOwner isPrpsExists(_prpsIdx) checkSignPrps(_prpsIdx){\n', '        proposals[_prpsIdx].signed[msg.sender] = true;\n', '        emit SignPrps(_prpsIdx, proposals[_prpsIdx].prpsType, msg.sender);\n', '    }\n', '\n', '    // get proposal owner sign number(多數決)\n', '    function signOwnerCount(uint256 _prpsIdx) public view isPrpsExists(_prpsIdx) returns(uint256) {\n', '        uint256 signedCount = 0;\n', '        for(uint256 i = 0; i < owners.length; i++) {\n', '            if(proposals[_prpsIdx].signed[owners[i]] == true){\n', '                signedCount++;\n', '            }\n', '        }\n', '        return signedCount;\n', '    }\n', '\n', '    // proposal count nums\n', '    function getProposalCount() public view returns(uint256){\n', '        return proposals.length;\n', '    }\n', '    \n', '    // get proposal sign status info\n', '    function getProposalInfo(uint256 _prpsIdx) public view isPrpsExists(_prpsIdx) returns(ProposalType _prpsType, uint256 _signedCount, bool _isFinalized, address _fromAddr, address _toAddr){\n', '\n', '        Proposal memory _proposal = proposals[_prpsIdx];\n', '        uint256 signCount = signOwnerCount(_prpsIdx);\n', '        return (_proposal.prpsType, signCount, _proposal.finalized, _proposal.fromAddr, _proposal.toAddr);\n', '    }\n', '\n', '    // Transfer owner\n', '    function transferOwnership(uint256 _prpsIdx) public isOwner isPrpsExists(_prpsIdx) multiSig(_prpsIdx) {\n', '\n', '        // is right enum proposalType\n', '        require(proposals[_prpsIdx].prpsType == ProposalType.transferOwner, "");\n', '        address oldOwnerAddr = proposals[_prpsIdx].fromAddr;\n', '        address newOwnerAddr = proposals[_prpsIdx].toAddr;\n', '        require(oldOwnerAddr != address(0), "");\n', '        require(newOwnerAddr != address(0), "");\n', '        require(oldOwnerAddr != newOwnerAddr, "");\n', '        for(uint256 i = 0; i < owners.length; i++) {\n', '            if( owners[i] == oldOwnerAddr){\n', '                owners[i] = newOwnerAddr;\n', '                delete isOwnerMap[oldOwnerAddr];\n', '                isOwnerMap[newOwnerAddr] = true;\n', '            }\n', '        }\n', '        proposals[_prpsIdx].finalized = true;\n', '        emit OwnershipTransferred(oldOwnerAddr, newOwnerAddr);\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' */\n', 'contract Pausable is Ownable {\n', '\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    modifier whenNotPaused {\n', '        require(!paused, "");\n', '        _;\n', '    }\n', '    modifier whenPaused {\n', '        require(paused, "");\n', '        _;\n', '    }\n', '\n', '    // Pause contract   \n', '    function pause() public isOwner whenNotPaused returns (bool) {\n', '        paused = true;\n', '        emit Pause();\n', '        return true;\n', '    }\n', '\n', '    // Unpause contract\n', '    function unpause() public isOwner whenPaused returns (bool) {\n', '        paused = false;\n', '        emit Unpause();\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' */\n', 'contract ERC20 {\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n', '    // _from: _owner _to: _spender\n', '    event Approval(address indexed _from, address indexed _to, uint256 _amount);\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address _owner) public view returns (uint256);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '    function allowance(address _owner, address _spender) public view returns (uint256);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Token\n', ' */\n', 'contract ERC20Token is ERC20 {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    uint256 public totalToken;\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalToken;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        require(_owner != address(0), "");\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Transfer token by internal\n', '    function _transfer(address _from, address _to, uint256 _value) internal {\n', '        require(_to != address(0), "");\n', '        require(balances[_from] >= _value, "");\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0), "");\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){\n', '        require(_from != address(0), "");\n', '        require(_to != address(0), "");\n', '        require(_value > 0, "");\n', '        require(balances[_from] >= _value, "");\n', '        require(allowed[_from][msg.sender] >= _value, "");\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool){\n', '        require(_spender != address(0), "");\n', '        require(_value > 0, "");\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256){\n', '        require(_owner != address(0), "");\n', '        require(_spender != address(0), "");\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title LVECoin\n', ' */\n', 'contract LVECoin is ERC20Token, Pausable {\n', '\n', '    string public  constant name        = "LVECoin";\n', '    string public  constant symbol      = "LVE";\n', '    uint256 public constant decimals    = 18;\n', '    // issue all token\n', '    uint256 private initialToken        = 2000000000 * (10 ** decimals);\n', '    \n', '    // _to: _freezeAddr\n', '    event Freeze(address indexed _to);\n', '    // _to: _unfreezeAddr\n', '    event Unfreeze(address indexed _to);\n', '    event WithdrawalEther(address indexed _to, uint256 _amount);\n', '    \n', '    // freeze account mapping\n', '    mapping(address => bool) public freezeAccountMap;  \n', '    // wallet Address\n', '    address private walletAddr;\n', '    // owner sign threshold\n', '    uint256 private signThreshold       = 3;\n', '\n', '    constructor(address[] _initOwners, address _walletAddr) public{\n', '        require(_initOwners.length == signThreshold, "");\n', '        require(_walletAddr != address(0), "");\n', '\n', '        // init owners\n', '        requiredSignNum = _initOwners.length.div(2).add(1);\n', '        owners = _initOwners;\n', '        for(uint i = 0; i < _initOwners.length; i++) {\n', '            isOwnerMap[_initOwners[i]] = true;\n', '        }\n', '\n', '        totalToken = initialToken;\n', '        walletAddr = _walletAddr;\n', '        balances[msg.sender] = totalToken;\n', '        emit Transfer(0x0, msg.sender, totalToken);\n', '    }\n', '\n', '\n', '    // is freezeable account\n', '    modifier freezeable(address _addr) {\n', '        require(_addr != address(0), "");\n', '        require(!freezeAccountMap[_addr], "");\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public whenNotPaused freezeable(msg.sender) returns (bool) {\n', '        require(_to != address(0), "");\n', '        return super.transfer(_to, _value);\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused freezeable(msg.sender) returns (bool) {\n', '        require(_from != address(0), "");\n', '        require(_to != address(0), "");\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '    function approve(address _spender, uint256 _value) public whenNotPaused freezeable(msg.sender) returns (bool) {\n', '        require(_spender != address(0), "");\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '    // freeze account\n', '    function freezeAccount(uint256 _prpsIdx) public isOwner isPrpsExists(_prpsIdx) multiSig(_prpsIdx) returns (bool) {\n', '\n', '        // is right enum proposalType\n', '        require(proposals[_prpsIdx].prpsType == ProposalType.freeze, "");\n', '        address freezeAddr = proposals[_prpsIdx].toAddr;\n', '        require(freezeAddr != address(0), "");\n', '        // proposals execute over\n', '        proposals[_prpsIdx].finalized = true;\n', '        freezeAccountMap[freezeAddr] = true;\n', '        emit Freeze(freezeAddr);\n', '        return true;\n', '    }\n', '    \n', '    // unfreeze account\n', '    function unfreezeAccount(uint256 _prpsIdx) public isOwner isPrpsExists(_prpsIdx) multiSig(_prpsIdx) returns (bool) {\n', '\n', '        // is right enum proposalType\n', '        require(proposals[_prpsIdx].prpsType == ProposalType.unfreeze, "");\n', '        address freezeAddr = proposals[_prpsIdx].toAddr;\n', '        require(freezeAddr != address(0), "");\n', '        // proposals execute over\n', '        proposals[_prpsIdx].finalized = true;\n', '        freezeAccountMap[freezeAddr] = false;\n', '        emit Unfreeze(freezeAddr);\n', '        return true;\n', '    }\n', '\n', '    // if send ether then send ether to owner\n', '    function() public payable {\n', '        require(msg.value > 0, "");\n', '        walletAddr.transfer(msg.value);\n', '        emit WithdrawalEther(walletAddr, msg.value);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// *-----------------------------------------------------------------------*\n', '//       __ _    ________   __________  _____   __\n', '//      / /| |  / / ____/  / ____/ __ \\/  _/ | / /\n', '//     / / | | / / __/    / /   / / / // //  |/ / \n', '//    / /__| |/ / /___   / /___/ /_/ // // /|  /  \n', '//   /_____/___/_____/   \\____/\\____/___/_/ |_/  \n', '// *-----------------------------------------------------------------------*\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @ multiSig\n', ' */\n', 'contract Ownable {\n', '\n', '    // _from: oldOwner _to: newOwner\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '    event SubmitPrps(ProposalType indexed _prpsType);\n', '    event SignPrps(uint256 indexed _prpsIdx, ProposalType indexed _prpsType, address indexed _from);\n', '\n', '    // owner proposal type enum\n', '    enum ProposalType {\n', '        freeze,\n', '        unfreeze,\n', '        transferOwner\n', '    }\n', '    // owner proposal\n', '    struct Proposal {\n', '        ProposalType prpsType;\n', '        address fromAddr;\n', '        address toAddr;\n', '        mapping(address => bool) signed;\n', '        bool finalized;\n', '    }\n', '    // require sign owner number\n', '    uint256 public requiredSignNum;\n', '    // all owner address\n', '    address[] public owners;\n', '    // owner proposal list\n', '    Proposal[] public proposals;\n', '    // is owner mapping\n', '    mapping(address => bool) public isOwnerMap;\n', '\n', '    constructor() public{\n', '    }\n', '\n', '    // is owner\n', '    modifier isOwner{\n', '        require(isOwnerMap[msg.sender], "");\n', '        _;\n', '    }\n', '    // is most owner sign proposal\n', '    modifier multiSig(uint256 _prpsIdx) {\n', '        // is more than half(多數決)\n', '        require(signOwnerCount(_prpsIdx) >= requiredSignNum, "");\n', '        // proposal is not finalized\n', '        require(proposals[_prpsIdx].finalized == false, "");\n', '        _;\n', '    }\n', '    // proposal is exist\n', '    modifier isPrpsExists(uint256 _prpsIdx) {\n', '        require(_prpsIdx >= 0, "");\n', '        require(_prpsIdx < proposals.length, "");\n', '        _;\n', '    }\n', '    modifier checkOwner(address _fromAddr, address _toAddr) {\n', '        require(_toAddr != address(0), "");\n', '        require(_toAddr != msg.sender, "");\n', '        require(_fromAddr != msg.sender, "");\n', '        _;\n', '    }\n', '    // is right proposal type\n', '    modifier checkPrpsType(ProposalType _prpsType) {\n', '        require(_prpsType == ProposalType.freeze || _prpsType == ProposalType.unfreeze || _prpsType == ProposalType.transferOwner, "");\n', '        _;\n', '    }\n', '    // check already sign prps\n', '    modifier checkSignPrps(uint256 _prpsIdx) {\n', '        // proposal is not finalized\n', '        require(proposals[_prpsIdx].finalized == false, "");\n', '        // owner is not signed\n', '        require(proposals[_prpsIdx].signed[msg.sender] == false, "");\n', '        _;\n', '    }\n', '\n', '\n', '    // any owner submit not certified proposal\n', '    function submitProposal(ProposalType _prpsType, address _fromAddr, address _toAddr) public isOwner checkOwner(_fromAddr, _toAddr) checkPrpsType(_prpsType) {\n', '        Proposal memory _proposal;\n', '        _proposal.prpsType = _prpsType;\n', '        _proposal.finalized = false;\n', '        _proposal.fromAddr = _fromAddr;\n', '        _proposal.toAddr = _toAddr;\n', '        proposals.push(_proposal);\n', '        emit SubmitPrps(_prpsType);\n', '    }\n', '\n', '    // owner sign an proposal\n', '    function signProposal(uint256 _prpsIdx) public isOwner isPrpsExists(_prpsIdx) checkSignPrps(_prpsIdx){\n', '        proposals[_prpsIdx].signed[msg.sender] = true;\n', '        emit SignPrps(_prpsIdx, proposals[_prpsIdx].prpsType, msg.sender);\n', '    }\n', '\n', '    // get proposal owner sign number(多數決)\n', '    function signOwnerCount(uint256 _prpsIdx) public view isPrpsExists(_prpsIdx) returns(uint256) {\n', '        uint256 signedCount = 0;\n', '        for(uint256 i = 0; i < owners.length; i++) {\n', '            if(proposals[_prpsIdx].signed[owners[i]] == true){\n', '                signedCount++;\n', '            }\n', '        }\n', '        return signedCount;\n', '    }\n', '\n', '    // proposal count nums\n', '    function getProposalCount() public view returns(uint256){\n', '        return proposals.length;\n', '    }\n', '    \n', '    // get proposal sign status info\n', '    function getProposalInfo(uint256 _prpsIdx) public view isPrpsExists(_prpsIdx) returns(ProposalType _prpsType, uint256 _signedCount, bool _isFinalized, address _fromAddr, address _toAddr){\n', '\n', '        Proposal memory _proposal = proposals[_prpsIdx];\n', '        uint256 signCount = signOwnerCount(_prpsIdx);\n', '        return (_proposal.prpsType, signCount, _proposal.finalized, _proposal.fromAddr, _proposal.toAddr);\n', '    }\n', '\n', '    // Transfer owner\n', '    function transferOwnership(uint256 _prpsIdx) public isOwner isPrpsExists(_prpsIdx) multiSig(_prpsIdx) {\n', '\n', '        // is right enum proposalType\n', '        require(proposals[_prpsIdx].prpsType == ProposalType.transferOwner, "");\n', '        address oldOwnerAddr = proposals[_prpsIdx].fromAddr;\n', '        address newOwnerAddr = proposals[_prpsIdx].toAddr;\n', '        require(oldOwnerAddr != address(0), "");\n', '        require(newOwnerAddr != address(0), "");\n', '        require(oldOwnerAddr != newOwnerAddr, "");\n', '        for(uint256 i = 0; i < owners.length; i++) {\n', '            if( owners[i] == oldOwnerAddr){\n', '                owners[i] = newOwnerAddr;\n', '                delete isOwnerMap[oldOwnerAddr];\n', '                isOwnerMap[newOwnerAddr] = true;\n', '            }\n', '        }\n', '        proposals[_prpsIdx].finalized = true;\n', '        emit OwnershipTransferred(oldOwnerAddr, newOwnerAddr);\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' */\n', 'contract Pausable is Ownable {\n', '\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    modifier whenNotPaused {\n', '        require(!paused, "");\n', '        _;\n', '    }\n', '    modifier whenPaused {\n', '        require(paused, "");\n', '        _;\n', '    }\n', '\n', '    // Pause contract   \n', '    function pause() public isOwner whenNotPaused returns (bool) {\n', '        paused = true;\n', '        emit Pause();\n', '        return true;\n', '    }\n', '\n', '    // Unpause contract\n', '    function unpause() public isOwner whenPaused returns (bool) {\n', '        paused = false;\n', '        emit Unpause();\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' */\n', 'contract ERC20 {\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n', '    // _from: _owner _to: _spender\n', '    event Approval(address indexed _from, address indexed _to, uint256 _amount);\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address _owner) public view returns (uint256);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '    function allowance(address _owner, address _spender) public view returns (uint256);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Token\n', ' */\n', 'contract ERC20Token is ERC20 {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    uint256 public totalToken;\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalToken;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        require(_owner != address(0), "");\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Transfer token by internal\n', '    function _transfer(address _from, address _to, uint256 _value) internal {\n', '        require(_to != address(0), "");\n', '        require(balances[_from] >= _value, "");\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0), "");\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){\n', '        require(_from != address(0), "");\n', '        require(_to != address(0), "");\n', '        require(_value > 0, "");\n', '        require(balances[_from] >= _value, "");\n', '        require(allowed[_from][msg.sender] >= _value, "");\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool){\n', '        require(_spender != address(0), "");\n', '        require(_value > 0, "");\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256){\n', '        require(_owner != address(0), "");\n', '        require(_spender != address(0), "");\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title LVECoin\n', ' */\n', 'contract LVECoin is ERC20Token, Pausable {\n', '\n', '    string public  constant name        = "LVECoin";\n', '    string public  constant symbol      = "LVE";\n', '    uint256 public constant decimals    = 18;\n', '    // issue all token\n', '    uint256 private initialToken        = 2000000000 * (10 ** decimals);\n', '    \n', '    // _to: _freezeAddr\n', '    event Freeze(address indexed _to);\n', '    // _to: _unfreezeAddr\n', '    event Unfreeze(address indexed _to);\n', '    event WithdrawalEther(address indexed _to, uint256 _amount);\n', '    \n', '    // freeze account mapping\n', '    mapping(address => bool) public freezeAccountMap;  \n', '    // wallet Address\n', '    address private walletAddr;\n', '    // owner sign threshold\n', '    uint256 private signThreshold       = 3;\n', '\n', '    constructor(address[] _initOwners, address _walletAddr) public{\n', '        require(_initOwners.length == signThreshold, "");\n', '        require(_walletAddr != address(0), "");\n', '\n', '        // init owners\n', '        requiredSignNum = _initOwners.length.div(2).add(1);\n', '        owners = _initOwners;\n', '        for(uint i = 0; i < _initOwners.length; i++) {\n', '            isOwnerMap[_initOwners[i]] = true;\n', '        }\n', '\n', '        totalToken = initialToken;\n', '        walletAddr = _walletAddr;\n', '        balances[msg.sender] = totalToken;\n', '        emit Transfer(0x0, msg.sender, totalToken);\n', '    }\n', '\n', '\n', '    // is freezeable account\n', '    modifier freezeable(address _addr) {\n', '        require(_addr != address(0), "");\n', '        require(!freezeAccountMap[_addr], "");\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public whenNotPaused freezeable(msg.sender) returns (bool) {\n', '        require(_to != address(0), "");\n', '        return super.transfer(_to, _value);\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused freezeable(msg.sender) returns (bool) {\n', '        require(_from != address(0), "");\n', '        require(_to != address(0), "");\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '    function approve(address _spender, uint256 _value) public whenNotPaused freezeable(msg.sender) returns (bool) {\n', '        require(_spender != address(0), "");\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '    // freeze account\n', '    function freezeAccount(uint256 _prpsIdx) public isOwner isPrpsExists(_prpsIdx) multiSig(_prpsIdx) returns (bool) {\n', '\n', '        // is right enum proposalType\n', '        require(proposals[_prpsIdx].prpsType == ProposalType.freeze, "");\n', '        address freezeAddr = proposals[_prpsIdx].toAddr;\n', '        require(freezeAddr != address(0), "");\n', '        // proposals execute over\n', '        proposals[_prpsIdx].finalized = true;\n', '        freezeAccountMap[freezeAddr] = true;\n', '        emit Freeze(freezeAddr);\n', '        return true;\n', '    }\n', '    \n', '    // unfreeze account\n', '    function unfreezeAccount(uint256 _prpsIdx) public isOwner isPrpsExists(_prpsIdx) multiSig(_prpsIdx) returns (bool) {\n', '\n', '        // is right enum proposalType\n', '        require(proposals[_prpsIdx].prpsType == ProposalType.unfreeze, "");\n', '        address freezeAddr = proposals[_prpsIdx].toAddr;\n', '        require(freezeAddr != address(0), "");\n', '        // proposals execute over\n', '        proposals[_prpsIdx].finalized = true;\n', '        freezeAccountMap[freezeAddr] = false;\n', '        emit Unfreeze(freezeAddr);\n', '        return true;\n', '    }\n', '\n', '    // if send ether then send ether to owner\n', '    function() public payable {\n', '        require(msg.value > 0, "");\n', '        walletAddr.transfer(msg.value);\n', '        emit WithdrawalEther(walletAddr, msg.value);\n', '    }\n', '\n', '}']
