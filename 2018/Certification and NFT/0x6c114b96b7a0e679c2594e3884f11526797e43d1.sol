['pragma solidity 0.4.20;\n', '\n', 'contract IAugur {\n', '    function createChildUniverse(bytes32 _parentPayoutDistributionHash, uint256[] _parentPayoutNumerators, bool _parentInvalid) public returns (IUniverse);\n', '    function isKnownUniverse(IUniverse _universe) public view returns (bool);\n', '    function trustedTransfer(ERC20 _token, address _from, address _to, uint256 _amount) public returns (bool);\n', '    function logMarketCreated(bytes32 _topic, string _description, string _extraInfo, IUniverse _universe, address _market, address _marketCreator, bytes32[] _outcomes, int256 _minPrice, int256 _maxPrice, IMarket.MarketType _marketType) public returns (bool);\n', '    function logMarketCreated(bytes32 _topic, string _description, string _extraInfo, IUniverse _universe, address _market, address _marketCreator, int256 _minPrice, int256 _maxPrice, IMarket.MarketType _marketType) public returns (bool);\n', '    function logInitialReportSubmitted(IUniverse _universe, address _reporter, address _market, uint256 _amountStaked, bool _isDesignatedReporter, uint256[] _payoutNumerators, bool _invalid) public returns (bool);\n', '    function disputeCrowdsourcerCreated(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] _payoutNumerators, uint256 _size, bool _invalid) public returns (bool);\n', '    function logDisputeCrowdsourcerContribution(IUniverse _universe, address _reporter, address _market, address _disputeCrowdsourcer, uint256 _amountStaked) public returns (bool);\n', '    function logDisputeCrowdsourcerCompleted(IUniverse _universe, address _market, address _disputeCrowdsourcer) public returns (bool);\n', '    function logInitialReporterRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256 _reportingFeesReceived, uint256[] _payoutNumerators) public returns (bool);\n', '    function logDisputeCrowdsourcerRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256 _reportingFeesReceived, uint256[] _payoutNumerators) public returns (bool);\n', '    function logFeeWindowRedeemed(IUniverse _universe, address _reporter, uint256 _amountRedeemed, uint256 _reportingFeesReceived) public returns (bool);\n', '    function logMarketFinalized(IUniverse _universe) public returns (bool);\n', '    function logMarketMigrated(IMarket _market, IUniverse _originalUniverse) public returns (bool);\n', '    function logReportingParticipantDisavowed(IUniverse _universe, IMarket _market) public returns (bool);\n', '    function logMarketParticipantsDisavowed(IUniverse _universe) public returns (bool);\n', '    function logOrderCanceled(IUniverse _universe, address _shareToken, address _sender, bytes32 _orderId, Order.Types _orderType, uint256 _tokenRefund, uint256 _sharesRefund) public returns (bool);\n', '    function logOrderCreated(Order.Types _orderType, uint256 _amount, uint256 _price, address _creator, uint256 _moneyEscrowed, uint256 _sharesEscrowed, bytes32 _tradeGroupId, bytes32 _orderId, IUniverse _universe, address _shareToken) public returns (bool);\n', '    function logOrderFilled(IUniverse _universe, address _shareToken, address _filler, bytes32 _orderId, uint256 _numCreatorShares, uint256 _numCreatorTokens, uint256 _numFillerShares, uint256 _numFillerTokens, uint256 _marketCreatorFees, uint256 _reporterFees, uint256 _amountFilled, bytes32 _tradeGroupId) public returns (bool);\n', '    function logCompleteSetsPurchased(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\n', '    function logCompleteSetsSold(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\n', '    function logTradingProceedsClaimed(IUniverse _universe, address _shareToken, address _sender, address _market, uint256 _numShares, uint256 _numPayoutTokens, uint256 _finalTokenBalance) public returns (bool);\n', '    function logUniverseForked() public returns (bool);\n', '    function logFeeWindowTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n', '    function logReputationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n', '    function logDisputeCrowdsourcerTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n', '    function logShareTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n', '    function logReputationTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n', '    function logReputationTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n', '    function logShareTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n', '    function logShareTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n', '    function logFeeWindowBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n', '    function logFeeWindowMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n', '    function logDisputeCrowdsourcerTokensBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n', '    function logDisputeCrowdsourcerTokensMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n', '    function logFeeWindowCreated(IFeeWindow _feeWindow, uint256 _id) public returns (bool);\n', '    function logFeeTokenTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n', '    function logFeeTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n', '    function logFeeTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n', '    function logTimestampSet(uint256 _newTimestamp) public returns (bool);\n', '    function logInitialReporterTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\n', '    function logMarketTransferred(IUniverse _universe, address _from, address _to) public returns (bool);\n', '    function logMarketMailboxTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\n', '    function logEscapeHatchChanged(bool _isOn) public returns (bool);\n', '}\n', '\n', 'contract IControlled {\n', '    function getController() public view returns (IController);\n', '    function setController(IController _controller) public returns(bool);\n', '}\n', '\n', 'contract Controlled is IControlled {\n', '    IController internal controller;\n', '\n', '    modifier onlyWhitelistedCallers {\n', '        require(controller.assertIsWhitelisted(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyCaller(bytes32 _key) {\n', '        require(msg.sender == controller.lookup(_key));\n', '        _;\n', '    }\n', '\n', '    modifier onlyControllerCaller {\n', '        require(IController(msg.sender) == controller);\n', '        _;\n', '    }\n', '\n', '    modifier onlyInGoodTimes {\n', '        require(controller.stopInEmergency());\n', '        _;\n', '    }\n', '\n', '    modifier onlyInBadTimes {\n', '        require(controller.onlyInEmergency());\n', '        _;\n', '    }\n', '\n', '    function Controlled() public {\n', '        controller = IController(msg.sender);\n', '    }\n', '\n', '    function getController() public view returns(IController) {\n', '        return controller;\n', '    }\n', '\n', '    function setController(IController _controller) public onlyControllerCaller returns(bool) {\n', '        controller = _controller;\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract IController {\n', '    function assertIsWhitelisted(address _target) public view returns(bool);\n', '    function lookup(bytes32 _key) public view returns(address);\n', '    function stopInEmergency() public view returns(bool);\n', '    function onlyInEmergency() public view returns(bool);\n', '    function getAugur() public view returns (IAugur);\n', '    function getTimestamp() public view returns (uint256);\n', '}\n', '\n', 'contract DelegationTarget is Controlled {\n', '    bytes32 public controllerLookupName;\n', '}\n', '\n', 'contract IOwnable {\n', '    function getOwner() public view returns (address);\n', '    function transferOwnership(address newOwner) public returns (bool);\n', '}\n', '\n', 'contract ITyped {\n', '    function getTypeName() public view returns (bytes32);\n', '}\n', '\n', 'contract Initializable {\n', '    bool private initialized = false;\n', '\n', '    modifier afterInitialized {\n', '        require(initialized);\n', '        _;\n', '    }\n', '\n', '    modifier beforeInitialized {\n', '        require(!initialized);\n', '        _;\n', '    }\n', '\n', '    function endInitialization() internal beforeInitialized returns (bool) {\n', '        initialized = true;\n', '        return true;\n', '    }\n', '\n', '    function getInitialized() public view returns (bool) {\n', '        return initialized;\n', '    }\n', '}\n', '\n', 'library SafeMathUint256 {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a <= b) {\n', '            return a;\n', '        } else {\n', '            return b;\n', '        }\n', '    }\n', '\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a >= b) {\n', '            return a;\n', '        } else {\n', '            return b;\n', '        }\n', '    }\n', '\n', '    function getUint256Min() internal pure returns (uint256) {\n', '        return 0;\n', '    }\n', '\n', '    function getUint256Max() internal pure returns (uint256) {\n', '        return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n', '    }\n', '\n', '    function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\n', '        return a % b == 0;\n', '    }\n', '\n', '    // Float [fixed point] Operations\n', '    function fxpMul(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n', '        return div(mul(a, b), base);\n', '    }\n', '\n', '    function fxpDiv(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n', '        return div(mul(a, base), b);\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function balanceOf(address _who) public view returns (uint256);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function totalSupply() public view returns (uint256);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMathUint256 for uint256;\n', '\n', '    uint256 internal supply;\n', '    mapping(address => uint256) internal balances;\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns(bool) {\n', '        return internalTransfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '    * @dev allows internal token transfers\n', '    * @param _from The source address\n', '    * @param _to The destination address\n', '    */\n', '    function internalTransfer(address _from, address _to, uint256 _value) internal returns (bool) {\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(_from, _to, _value);\n', '        onTokenTransfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return supply;\n', '    }\n', '\n', '    // Subclasses of this token generally want to send additional logs through the centralized Augur log emitter contract\n', '    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '    using SafeMathUint256 for uint256;\n', '\n', '    // Approvals of this amount are simply considered an everlasting approval which is not decremented when transfers occur\n', '    uint256 public constant ETERNAL_APPROVAL_VALUE = 2 ** 256 - 1;\n', '\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    /**\n', '    * @dev Transfer tokens from one address to another\n', '    * @param _from address The address which you want to send tokens from\n', '    * @param _to address The address which you want to transfer to\n', '    * @param _value uint256 the amout of tokens to be transfered\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '        if (_allowance != ETERNAL_APPROVAL_VALUE) {\n', '            allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        }\n', '        internalTransfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        approveInternal(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    * @param _owner address The address which owns the funds.\n', '    * @param _spender address The address which will spend the funds.\n', '    * @return A uint256 specifing the amount of tokens still avaible for the spender.\n', '    */\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '   /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * Approve should be called when allowed[_spender] == 0. To increment allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        approveInternal(msg.sender, _spender, allowed[msg.sender][_spender].add(_addedValue));\n', '        return true;\n', '    }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            approveInternal(msg.sender, _spender, 0);\n', '        } else {\n', '            approveInternal(msg.sender, _spender, oldValue.sub(_subtractedValue));\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function approveInternal(address _owner, address _spender, uint256 _value) internal returns (bool) {\n', '        allowed[_owner][_spender] = _value;\n', '        Approval(_owner, _spender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract VariableSupplyToken is StandardToken {\n', '    using SafeMathUint256 for uint256;\n', '\n', '    event Mint(address indexed target, uint256 value);\n', '    event Burn(address indexed target, uint256 value);\n', '\n', '    /**\n', '    * @dev mint tokens for a specified address\n', '    * @param _target The address to mint tokens for.\n', '    * @param _amount The amount to be minted.\n', '    */\n', '    function mint(address _target, uint256 _amount) internal returns (bool) {\n', '        balances[_target] = balances[_target].add(_amount);\n', '        supply = supply.add(_amount);\n', '        Mint(_target, _amount);\n', '        onMint(_target, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev burn tokens belonging to a specified address\n', '    * @param _target The address to burn tokens for.\n', '    * @param _amount The amount to be burned.\n', '    */\n', '    function burn(address _target, uint256 _amount) internal returns (bool) {\n', '        balances[_target] = balances[_target].sub(_amount);\n', '        supply = supply.sub(_amount);\n', '        Burn(_target, _amount);\n', '        onBurn(_target, _amount);\n', '        return true;\n', '    }\n', '\n', '    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\n', '    function onMint(address, uint256) internal returns (bool);\n', '\n', '    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\n', '    function onBurn(address, uint256) internal returns (bool);\n', '}\n', '\n', 'contract IFeeToken is ERC20, Initializable {\n', '    function initialize(IFeeWindow _feeWindow) public returns (bool);\n', '    function getFeeWindow() public view returns (IFeeWindow);\n', '    function feeWindowBurn(address _target, uint256 _amount) public returns (bool);\n', '    function mintForReportingParticipant(address _target, uint256 _amount) public returns (bool);\n', '}\n', '\n', 'contract IFeeWindow is ITyped, ERC20 {\n', '    function initialize(IUniverse _universe, uint256 _feeWindowId) public returns (bool);\n', '    function getUniverse() public view returns (IUniverse);\n', '    function getReputationToken() public view returns (IReputationToken);\n', '    function getStartTime() public view returns (uint256);\n', '    function getEndTime() public view returns (uint256);\n', '    function getNumMarkets() public view returns (uint256);\n', '    function getNumInvalidMarkets() public view returns (uint256);\n', '    function getNumIncorrectDesignatedReportMarkets() public view returns (uint256);\n', '    function getNumDesignatedReportNoShows() public view returns (uint256);\n', '    function getFeeToken() public view returns (IFeeToken);\n', '    function isActive() public view returns (bool);\n', '    function isOver() public view returns (bool);\n', '    function onMarketFinalized() public returns (bool);\n', '    function buy(uint256 _attotokens) public returns (bool);\n', '    function redeem(address _sender) public returns (bool);\n', '    function redeemForReportingParticipant() public returns (bool);\n', '    function mintFeeTokens(uint256 _amount) public returns (bool);\n', '    function trustedUniverseBuy(address _buyer, uint256 _attotokens) public returns (bool);\n', '}\n', '\n', 'contract IMailbox {\n', '    function initialize(address _owner, IMarket _market) public returns (bool);\n', '    function depositEther() public payable returns (bool);\n', '}\n', '\n', 'contract IMarket is ITyped, IOwnable {\n', '    enum MarketType {\n', '        YES_NO,\n', '        CATEGORICAL,\n', '        SCALAR\n', '    }\n', '\n', '    function initialize(IUniverse _universe, uint256 _endTime, uint256 _feePerEthInAttoeth, ICash _cash, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public payable returns (bool _success);\n', '    function derivePayoutDistributionHash(uint256[] _payoutNumerators, bool _invalid) public view returns (bytes32);\n', '    function getUniverse() public view returns (IUniverse);\n', '    function getFeeWindow() public view returns (IFeeWindow);\n', '    function getNumberOfOutcomes() public view returns (uint256);\n', '    function getNumTicks() public view returns (uint256);\n', '    function getDenominationToken() public view returns (ICash);\n', '    function getShareToken(uint256 _outcome)  public view returns (IShareToken);\n', '    function getMarketCreatorSettlementFeeDivisor() public view returns (uint256);\n', '    function getForkingMarket() public view returns (IMarket _market);\n', '    function getEndTime() public view returns (uint256);\n', '    function getMarketCreatorMailbox() public view returns (IMailbox);\n', '    function getWinningPayoutDistributionHash() public view returns (bytes32);\n', '    function getWinningPayoutNumerator(uint256 _outcome) public view returns (uint256);\n', '    function getReputationToken() public view returns (IReputationToken);\n', '    function getFinalizationTime() public view returns (uint256);\n', '    function getInitialReporterAddress() public view returns (address);\n', '    function deriveMarketCreatorFeeAmount(uint256 _amount) public view returns (uint256);\n', '    function isContainerForShareToken(IShareToken _shadyTarget) public view returns (bool);\n', '    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n', '    function isInvalid() public view returns (bool);\n', '    function finalize() public returns (bool);\n', '    function designatedReporterWasCorrect() public view returns (bool);\n', '    function designatedReporterShowed() public view returns (bool);\n', '    function isFinalized() public view returns (bool);\n', '    function finalizeFork() public returns (bool);\n', '    function assertBalances() public view returns (bool);\n', '}\n', '\n', 'contract IReportingParticipant {\n', '    function getStake() public view returns (uint256);\n', '    function getPayoutDistributionHash() public view returns (bytes32);\n', '    function liquidateLosing() public returns (bool);\n', '    function redeem(address _redeemer) public returns (bool);\n', '    function isInvalid() public view returns (bool);\n', '    function isDisavowed() public view returns (bool);\n', '    function migrate() public returns (bool);\n', '    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\n', '    function getMarket() public view returns (IMarket);\n', '    function getSize() public view returns (uint256);\n', '}\n', '\n', 'contract IDisputeCrowdsourcer is IReportingParticipant, ERC20 {\n', '    function initialize(IMarket market, uint256 _size, bytes32 _payoutDistributionHash, uint256[] _payoutNumerators, bool _invalid) public returns (bool);\n', '    function contribute(address _participant, uint256 _amount) public returns (uint256);\n', '}\n', '\n', 'contract IReputationToken is ITyped, ERC20 {\n', '    function initialize(IUniverse _universe) public returns (bool);\n', '    function migrateOut(IReputationToken _destination, uint256 _attotokens) public returns (bool);\n', '    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool);\n', '    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n', '    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n', '    function trustedFeeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n', '    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n', '    function getUniverse() public view returns (IUniverse);\n', '    function getTotalMigrated() public view returns (uint256);\n', '    function getTotalTheoreticalSupply() public view returns (uint256);\n', '    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool);\n', '}\n', '\n', 'contract IUniverse is ITyped {\n', '    function initialize(IUniverse _parentUniverse, bytes32 _parentPayoutDistributionHash) external returns (bool);\n', '    function fork() public returns (bool);\n', '    function getParentUniverse() public view returns (IUniverse);\n', '    function createChildUniverse(uint256[] _parentPayoutNumerators, bool _invalid) public returns (IUniverse);\n', '    function getChildUniverse(bytes32 _parentPayoutDistributionHash) public view returns (IUniverse);\n', '    function getReputationToken() public view returns (IReputationToken);\n', '    function getForkingMarket() public view returns (IMarket);\n', '    function getForkEndTime() public view returns (uint256);\n', '    function getForkReputationGoal() public view returns (uint256);\n', '    function getParentPayoutDistributionHash() public view returns (bytes32);\n', '    function getDisputeRoundDurationInSeconds() public view returns (uint256);\n', '    function getOrCreateFeeWindowByTimestamp(uint256 _timestamp) public returns (IFeeWindow);\n', '    function getOrCreateCurrentFeeWindow() public returns (IFeeWindow);\n', '    function getOrCreateNextFeeWindow() public returns (IFeeWindow);\n', '    function getOpenInterestInAttoEth() public view returns (uint256);\n', '    function getRepMarketCapInAttoeth() public view returns (uint256);\n', '    function getTargetRepMarketCapInAttoeth() public view returns (uint256);\n', '    function getOrCacheValidityBond() public returns (uint256);\n', '    function getOrCacheDesignatedReportStake() public returns (uint256);\n', '    function getOrCacheDesignatedReportNoShowBond() public returns (uint256);\n', '    function getOrCacheReportingFeeDivisor() public returns (uint256);\n', '    function getDisputeThresholdForFork() public view returns (uint256);\n', '    function getInitialReportMinValue() public view returns (uint256);\n', '    function calculateFloatingValue(uint256 _badMarkets, uint256 _totalMarkets, uint256 _targetDivisor, uint256 _previousValue, uint256 _defaultValue, uint256 _floor) public pure returns (uint256 _newValue);\n', '    function getOrCacheMarketCreationCost() public returns (uint256);\n', '    function getCurrentFeeWindow() public view returns (IFeeWindow);\n', '    function getOrCreateFeeWindowBefore(IFeeWindow _feeWindow) public returns (IFeeWindow);\n', '    function isParentOf(IUniverse _shadyChild) public view returns (bool);\n', '    function updateTentativeWinningChildUniverse(bytes32 _parentPayoutDistributionHash) public returns (bool);\n', '    function isContainerForFeeWindow(IFeeWindow _shadyTarget) public view returns (bool);\n', '    function isContainerForMarket(IMarket _shadyTarget) public view returns (bool);\n', '    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n', '    function isContainerForShareToken(IShareToken _shadyTarget) public view returns (bool);\n', '    function isContainerForFeeToken(IFeeToken _shadyTarget) public view returns (bool);\n', '    function addMarketTo() public returns (bool);\n', '    function removeMarketFrom() public returns (bool);\n', '    function decrementOpenInterest(uint256 _amount) public returns (bool);\n', '    function decrementOpenInterestFromMarket(uint256 _amount) public returns (bool);\n', '    function incrementOpenInterest(uint256 _amount) public returns (bool);\n', '    function incrementOpenInterestFromMarket(uint256 _amount) public returns (bool);\n', '    function getWinningChildUniverse() public view returns (IUniverse);\n', '    function isForking() public view returns (bool);\n', '}\n', '\n', 'library Reporting {\n', '    uint256 private constant DESIGNATED_REPORTING_DURATION_SECONDS = 3 days;\n', '    uint256 private constant DISPUTE_ROUND_DURATION_SECONDS = 7 days;\n', '    uint256 private constant CLAIM_PROCEEDS_WAIT_TIME = 3 days;\n', '    uint256 private constant FORK_DURATION_SECONDS = 60 days;\n', '\n', '    uint256 private constant INITIAL_REP_SUPPLY = 11 * 10 ** 6 * 10 ** 18; // 11 Million REP\n', '\n', '    uint256 private constant DEFAULT_VALIDITY_BOND = 1 ether / 100;\n', '    uint256 private constant VALIDITY_BOND_FLOOR = 1 ether / 100;\n', '    uint256 private constant DEFAULT_REPORTING_FEE_DIVISOR = 100; // 1% fees\n', '    uint256 private constant MAXIMUM_REPORTING_FEE_DIVISOR = 10000; // Minimum .01% fees\n', '    uint256 private constant MINIMUM_REPORTING_FEE_DIVISOR = 3; // Maximum 33.3~% fees. Note than anything less than a value of 2 here will likely result in bugs such as divide by 0 cases.\n', '\n', '    uint256 private constant TARGET_INVALID_MARKETS_DIVISOR = 100; // 1% of markets are expected to be invalid\n', '    uint256 private constant TARGET_INCORRECT_DESIGNATED_REPORT_MARKETS_DIVISOR = 100; // 1% of markets are expected to have an incorrect designate report\n', '    uint256 private constant TARGET_DESIGNATED_REPORT_NO_SHOWS_DIVISOR = 100; // 1% of markets are expected to have an incorrect designate report\n', '    uint256 private constant TARGET_REP_MARKET_CAP_MULTIPLIER = 15; // We multiply and divide by constants since we want to multiply by a fractional amount (7.5)\n', '    uint256 private constant TARGET_REP_MARKET_CAP_DIVISOR = 2;\n', '\n', '    uint256 private constant FORK_MIGRATION_PERCENTAGE_BONUS_DIVISOR = 20; // 5% bonus to any REP migrated during a fork\n', '\n', '    function getDesignatedReportingDurationSeconds() internal pure returns (uint256) { return DESIGNATED_REPORTING_DURATION_SECONDS; }\n', '    function getDisputeRoundDurationSeconds() internal pure returns (uint256) { return DISPUTE_ROUND_DURATION_SECONDS; }\n', '    function getClaimTradingProceedsWaitTime() internal pure returns (uint256) { return CLAIM_PROCEEDS_WAIT_TIME; }\n', '    function getForkDurationSeconds() internal pure returns (uint256) { return FORK_DURATION_SECONDS; }\n', '    function getDefaultValidityBond() internal pure returns (uint256) { return DEFAULT_VALIDITY_BOND; }\n', '    function getValidityBondFloor() internal pure returns (uint256) { return VALIDITY_BOND_FLOOR; }\n', '    function getTargetInvalidMarketsDivisor() internal pure returns (uint256) { return TARGET_INVALID_MARKETS_DIVISOR; }\n', '    function getTargetIncorrectDesignatedReportMarketsDivisor() internal pure returns (uint256) { return TARGET_INCORRECT_DESIGNATED_REPORT_MARKETS_DIVISOR; }\n', '    function getTargetDesignatedReportNoShowsDivisor() internal pure returns (uint256) { return TARGET_DESIGNATED_REPORT_NO_SHOWS_DIVISOR; }\n', '    function getTargetRepMarketCapMultiplier() internal pure returns (uint256) { return TARGET_REP_MARKET_CAP_MULTIPLIER; }\n', '    function getTargetRepMarketCapDivisor() internal pure returns (uint256) { return TARGET_REP_MARKET_CAP_DIVISOR; }\n', '    function getForkMigrationPercentageBonusDivisor() internal pure returns (uint256) { return FORK_MIGRATION_PERCENTAGE_BONUS_DIVISOR; }\n', '    function getMaximumReportingFeeDivisor() internal pure returns (uint256) { return MAXIMUM_REPORTING_FEE_DIVISOR; }\n', '    function getMinimumReportingFeeDivisor() internal pure returns (uint256) { return MINIMUM_REPORTING_FEE_DIVISOR; }\n', '    function getDefaultReportingFeeDivisor() internal pure returns (uint256) { return DEFAULT_REPORTING_FEE_DIVISOR; }\n', '    function getInitialREPSupply() internal pure returns (uint256) { return INITIAL_REP_SUPPLY; }\n', '}\n', '\n', 'contract ReputationToken is DelegationTarget, ITyped, Initializable, VariableSupplyToken, IReputationToken {\n', '    using SafeMathUint256 for uint256;\n', '\n', '    string constant public name = "Reputation";\n', '    string constant public symbol = "REP";\n', '    uint8 constant public decimals = 18;\n', '    IUniverse private universe;\n', '    uint256 private totalMigrated;\n', '    mapping(address => uint256) migratedToSibling;\n', '    uint256 private parentTotalTheoreticalSupply;\n', '    uint256 private totalTheoreticalSupply;\n', '\n', '    // Auto migration related state\n', '    bool private isMigratingFromLegacy;\n', '    uint256 private targetSupply;\n', '\n', '    /**\n', '     * @dev modifier to allow actions only when the contract IS paused\n', '     */\n', '    modifier whenMigratingFromLegacy() {\n', '        require(isMigratingFromLegacy);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev modifier to allow actions only when the contract IS paused\n', '     */\n', '    modifier whenNotMigratingFromLegacy() {\n', '        require(!isMigratingFromLegacy);\n', '        _;\n', '    }\n', '\n', '    function initialize(IUniverse _universe) public onlyInGoodTimes beforeInitialized returns (bool) {\n', '        endInitialization();\n', '        require(_universe != address(0));\n', '        universe = _universe;\n', '        updateParentTotalTheoreticalSupply();\n', '        ERC20 _legacyRepToken = getLegacyRepToken();\n', '        // Initialize migration related state. If this is Genesis universe REP the balances from the Legacy contract must be migrated before we enable usage\n', '        isMigratingFromLegacy = _universe.getParentUniverse() == IUniverse(0);\n', '        targetSupply = _legacyRepToken.totalSupply();\n', '        return true;\n', '    }\n', '\n', '    function migrateOutByPayout(uint256[] _payoutNumerators, bool _invalid, uint256 _attotokens) public onlyInGoodTimes whenNotMigratingFromLegacy afterInitialized returns (bool) {\n', '        require(_attotokens > 0);\n', '        IUniverse _destinationUniverse = universe.createChildUniverse(_payoutNumerators, _invalid);\n', '        IReputationToken _destination = _destinationUniverse.getReputationToken();\n', '        burn(msg.sender, _attotokens);\n', '        _destination.migrateIn(msg.sender, _attotokens);\n', '        return true;\n', '    }\n', '\n', '    function migrateOut(IReputationToken _destination, uint256 _attotokens) public onlyInGoodTimes whenNotMigratingFromLegacy afterInitialized returns (bool) {\n', '        require(_attotokens > 0);\n', '        assertReputationTokenIsLegitSibling(_destination);\n', '        burn(msg.sender, _attotokens);\n', '        _destination.migrateIn(msg.sender, _attotokens);\n', '        return true;\n', '    }\n', '\n', '    function migrateIn(address _reporter, uint256 _attotokens) public onlyInGoodTimes whenNotMigratingFromLegacy afterInitialized returns (bool) {\n', '        IUniverse _parentUniverse = universe.getParentUniverse();\n', '        require(ReputationToken(msg.sender) == _parentUniverse.getReputationToken());\n', '        mint(_reporter, _attotokens);\n', '        totalMigrated += _attotokens;\n', '        // Award a bonus if migration is done before the fork period is over, even if it has finalized\n', '        if (controller.getTimestamp() < _parentUniverse.getForkEndTime()) {\n', '            uint256 _bonus = _attotokens.div(Reporting.getForkMigrationPercentageBonusDivisor());\n', '            mint(_reporter, _bonus);\n', '            totalTheoreticalSupply += _bonus;\n', '        }\n', '        // Update the fork tenative winner and finalize if we can\n', '        if (!_parentUniverse.getForkingMarket().isFinalized()) {\n', '            _parentUniverse.updateTentativeWinningChildUniverse(universe.getParentPayoutDistributionHash());\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function mintForReportingParticipant(uint256 _amountMigrated) public onlyInGoodTimes whenNotMigratingFromLegacy afterInitialized returns (bool) {\n', '        IUniverse _parentUniverse = universe.getParentUniverse();\n', '        IReportingParticipant _reportingParticipant = IReportingParticipant(msg.sender);\n', '        require(_parentUniverse.isContainerForReportingParticipant(_reportingParticipant));\n', '        uint256 _bonus = _amountMigrated.div(2);\n', '        mint(_reportingParticipant, _bonus);\n', '        totalTheoreticalSupply += _bonus;\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public whenNotMigratingFromLegacy returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public whenNotMigratingFromLegacy returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public onlyInGoodTimes whenNotMigratingFromLegacy afterInitialized returns (bool) {\n', '        require(IUniverse(msg.sender) == universe);\n', '        return internalTransfer(_source, _destination, _attotokens);\n', '    }\n', '\n', '    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public onlyInGoodTimes whenNotMigratingFromLegacy afterInitialized returns (bool) {\n', '        require(universe.isContainerForMarket(IMarket(msg.sender)));\n', '        return internalTransfer(_source, _destination, _attotokens);\n', '    }\n', '\n', '    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public onlyInGoodTimes whenNotMigratingFromLegacy afterInitialized returns (bool) {\n', '        require(universe.isContainerForReportingParticipant(IReportingParticipant(msg.sender)));\n', '        return internalTransfer(_source, _destination, _attotokens);\n', '    }\n', '\n', '    function trustedFeeWindowTransfer(address _source, address _destination, uint256 _attotokens) public onlyInGoodTimes whenNotMigratingFromLegacy afterInitialized returns (bool) {\n', '        require(universe.isContainerForFeeWindow(IFeeWindow(msg.sender)));\n', '        return internalTransfer(_source, _destination, _attotokens);\n', '    }\n', '\n', '    function assertReputationTokenIsLegitSibling(IReputationToken _shadyReputationToken) private view returns (bool) {\n', '        IUniverse _shadyUniverse = _shadyReputationToken.getUniverse();\n', '        require(universe.isParentOf(_shadyUniverse));\n', '        IUniverse _legitUniverse = _shadyUniverse;\n', '        require(_legitUniverse.getReputationToken() == _shadyReputationToken);\n', '        return true;\n', '    }\n', '\n', '    function getTypeName() public view returns (bytes32) {\n', '        return "ReputationToken";\n', '    }\n', '\n', '    function getUniverse() public view returns (IUniverse) {\n', '        return universe;\n', '    }\n', '\n', '    function getTotalMigrated() public view returns (uint256) {\n', '        return totalMigrated;\n', '    }\n', '\n', '    function getLegacyRepToken() public view returns (ERC20) {\n', '        return ERC20(controller.lookup("LegacyReputationToken"));\n', '    }\n', '\n', '    function updateSiblingMigrationTotal(IReputationToken _token) public whenNotMigratingFromLegacy returns (bool) {\n', '        require(_token != this);\n', '        IUniverse _shadyUniverse = _token.getUniverse();\n', '        require(_token == universe.getParentUniverse().getChildUniverse(_shadyUniverse.getParentPayoutDistributionHash()).getReputationToken());\n', '        totalTheoreticalSupply += migratedToSibling[_token];\n', '        migratedToSibling[_token] = _token.getTotalMigrated();\n', '        totalTheoreticalSupply -= migratedToSibling[_token];\n', '        return true;\n', '    }\n', '\n', '    function updateParentTotalTheoreticalSupply() public whenNotMigratingFromLegacy returns (bool) {\n', '        IUniverse _parentUniverse = universe.getParentUniverse();\n', '        totalTheoreticalSupply -= parentTotalTheoreticalSupply;\n', '        if (_parentUniverse == IUniverse(0)) {\n', '            parentTotalTheoreticalSupply = Reporting.getInitialREPSupply();\n', '        } else {\n', '            parentTotalTheoreticalSupply = _parentUniverse.getReputationToken().getTotalTheoreticalSupply();\n', '        }\n', '        totalTheoreticalSupply += parentTotalTheoreticalSupply;\n', '        return true;\n', '    }\n', '\n', '    function getTotalTheoreticalSupply() public view returns (uint256) {\n', '        return totalTheoreticalSupply;\n', '    }\n', '\n', '    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool) {\n', '        controller.getAugur().logReputationTokensTransferred(universe, _from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function onMint(address _target, uint256 _amount) internal returns (bool) {\n', '        controller.getAugur().logReputationTokenMinted(universe, _target, _amount);\n', '        return true;\n', '    }\n', '\n', '    function onBurn(address _target, uint256 _amount) internal returns (bool) {\n', '        controller.getAugur().logReputationTokenBurned(universe, _target, _amount);\n', '        return true;\n', '    }\n', '\n', '        /**\n', '     * @dev Copies the balance of a batch of addresses from the legacy contract\n', '     * @param _holders Array of addresses to migrate balance\n', '     * @return True if operation was completed\n', '     */\n', '    function migrateBalancesFromLegacyRep(address[] _holders) public onlyInGoodTimes whenMigratingFromLegacy afterInitialized returns (bool) {\n', '        ERC20 _legacyRepToken = getLegacyRepToken();\n', '        for (uint256 i = 0; i < _holders.length; i++) {\n', '            migrateBalanceFromLegacyRep(_holders[i], _legacyRepToken);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Copies the balance of a single addresses from the legacy contract\n', '     * @param _holder Address to migrate balance\n', '     * @return True if balance was copied, false if was already copied or address had no balance\n', '     */\n', '    function migrateBalanceFromLegacyRep(address _holder, ERC20 _legacyRepToken) private onlyInGoodTimes whenMigratingFromLegacy afterInitialized returns (bool) {\n', '        if (balances[_holder] > 0) {\n', '            return false; // Already copied, move on\n', '        }\n', '\n', '        uint256 amount = _legacyRepToken.balanceOf(_holder);\n', '        if (amount == 0) {\n', '            return false; // Has no balance in legacy contract, move on\n', '        }\n', '\n', '        mint(_holder, amount);\n', '\n', '        if (targetSupply == supply) {\n', '            isMigratingFromLegacy = false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Copies the allowances of a batch of addresses from the legacy contract. This is an optional step which may only be done before the migration is complete but is not required to complete it.\n', '     * @param _owners Array of owner addresses to migrate allowances\n', '     * @param _spenders Array of spender addresses to migrate allowances\n', '     * @return True if operation was completed\n', '     */\n', '    function migrateAllowancesFromLegacyRep(address[] _owners, address[] _spenders) public onlyInGoodTimes whenMigratingFromLegacy afterInitialized returns (bool) {\n', '        ERC20 _legacyRepToken = getLegacyRepToken();\n', '        for (uint256 i = 0; i < _owners.length; i++) {\n', '            address _owner = _owners[i];\n', '            address _spender = _spenders[i];\n', '            uint256 _allowance = _legacyRepToken.allowance(_owner, _spender);\n', '            approveInternal(_owner, _spender, _allowance);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function getIsMigratingFromLegacy() public view returns (bool) {\n', '        return isMigratingFromLegacy;\n', '    }\n', '\n', '    function getTargetSupply() public view returns (uint256) {\n', '        return targetSupply;\n', '    }\n', '}\n', '\n', 'contract ICash is ERC20 {\n', '    function depositEther() external payable returns(bool);\n', '    function depositEtherFor(address _to) external payable returns(bool);\n', '    function withdrawEther(uint256 _amount) external returns(bool);\n', '    function withdrawEtherTo(address _to, uint256 _amount) external returns(bool);\n', '    function withdrawEtherToIfPossible(address _to, uint256 _amount) external returns (bool);\n', '}\n', '\n', 'contract IOrders {\n', '    function saveOrder(Order.Types _type, IMarket _market, uint256 _fxpAmount, uint256 _price, address _sender, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed, bytes32 _betterOrderId, bytes32 _worseOrderId, bytes32 _tradeGroupId) public returns (bytes32 _orderId);\n', '    function removeOrder(bytes32 _orderId) public returns (bool);\n', '    function getMarket(bytes32 _orderId) public view returns (IMarket);\n', '    function getOrderType(bytes32 _orderId) public view returns (Order.Types);\n', '    function getOutcome(bytes32 _orderId) public view returns (uint256);\n', '    function getAmount(bytes32 _orderId) public view returns (uint256);\n', '    function getPrice(bytes32 _orderId) public view returns (uint256);\n', '    function getOrderCreator(bytes32 _orderId) public view returns (address);\n', '    function getOrderSharesEscrowed(bytes32 _orderId) public view returns (uint256);\n', '    function getOrderMoneyEscrowed(bytes32 _orderId) public view returns (uint256);\n', '    function getBetterOrderId(bytes32 _orderId) public view returns (bytes32);\n', '    function getWorseOrderId(bytes32 _orderId) public view returns (bytes32);\n', '    function getBestOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n', '    function getWorstOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n', '    function getLastOutcomePrice(IMarket _market, uint256 _outcome) public view returns (uint256);\n', '    function getOrderId(Order.Types _type, IMarket _market, uint256 _fxpAmount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) public pure returns (bytes32);\n', '    function getTotalEscrowed(IMarket _market) public view returns (uint256);\n', '    function isBetterPrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n', '    function isWorsePrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n', '    function assertIsNotBetterPrice(Order.Types _type, uint256 _price, bytes32 _betterOrderId) public view returns (bool);\n', '    function assertIsNotWorsePrice(Order.Types _type, uint256 _price, bytes32 _worseOrderId) public returns (bool);\n', '    function recordFillOrder(bytes32 _orderId, uint256 _sharesFilled, uint256 _tokensFilled) public returns (bool);\n', '    function setPrice(IMarket _market, uint256 _outcome, uint256 _price) external returns (bool);\n', '    function incrementTotalEscrowed(IMarket _market, uint256 _amount) external returns (bool);\n', '    function decrementTotalEscrowed(IMarket _market, uint256 _amount) external returns (bool);\n', '}\n', '\n', 'contract IShareToken is ITyped, ERC20 {\n', '    function initialize(IMarket _market, uint256 _outcome) external returns (bool);\n', '    function createShares(address _owner, uint256 _amount) external returns (bool);\n', '    function destroyShares(address, uint256 balance) external returns (bool);\n', '    function getMarket() external view returns (IMarket);\n', '    function getOutcome() external view returns (uint256);\n', '    function trustedOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n', '    function trustedFillOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n', '    function trustedCancelOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n', '}\n', '\n', 'library Order {\n', '    using SafeMathUint256 for uint256;\n', '\n', '    enum Types {\n', '        Bid, Ask\n', '    }\n', '\n', '    enum TradeDirections {\n', '        Long, Short\n', '    }\n', '\n', '    struct Data {\n', '        // Contracts\n', '        IOrders orders;\n', '        IMarket market;\n', '        IAugur augur;\n', '\n', '        // Order\n', '        bytes32 id;\n', '        address creator;\n', '        uint256 outcome;\n', '        Order.Types orderType;\n', '        uint256 amount;\n', '        uint256 price;\n', '        uint256 sharesEscrowed;\n', '        uint256 moneyEscrowed;\n', '        bytes32 betterOrderId;\n', '        bytes32 worseOrderId;\n', '    }\n', '\n', '    //\n', '    // Constructor\n', '    //\n', '\n', '    // No validation is needed here as it is simply a librarty function for organizing data\n', '    function create(IController _controller, address _creator, uint256 _outcome, Order.Types _type, uint256 _attoshares, uint256 _price, IMarket _market, bytes32 _betterOrderId, bytes32 _worseOrderId) internal view returns (Data) {\n', '        require(_outcome < _market.getNumberOfOutcomes());\n', '        require(_price < _market.getNumTicks());\n', '\n', '        IOrders _orders = IOrders(_controller.lookup("Orders"));\n', '        IAugur _augur = _controller.getAugur();\n', '\n', '        return Data({\n', '            orders: _orders,\n', '            market: _market,\n', '            augur: _augur,\n', '            id: 0,\n', '            creator: _creator,\n', '            outcome: _outcome,\n', '            orderType: _type,\n', '            amount: _attoshares,\n', '            price: _price,\n', '            sharesEscrowed: 0,\n', '            moneyEscrowed: 0,\n', '            betterOrderId: _betterOrderId,\n', '            worseOrderId: _worseOrderId\n', '        });\n', '    }\n', '\n', '    //\n', '    // "public" functions\n', '    //\n', '\n', '    function getOrderId(Order.Data _orderData) internal view returns (bytes32) {\n', '        if (_orderData.id == bytes32(0)) {\n', '            bytes32 _orderId = _orderData.orders.getOrderId(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, block.number, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed);\n', '            require(_orderData.orders.getAmount(_orderId) == 0);\n', '            _orderData.id = _orderId;\n', '        }\n', '        return _orderData.id;\n', '    }\n', '\n', '    function getOrderTradingTypeFromMakerDirection(Order.TradeDirections _creatorDirection) internal pure returns (Order.Types) {\n', '        return (_creatorDirection == Order.TradeDirections.Long) ? Order.Types.Bid : Order.Types.Ask;\n', '    }\n', '\n', '    function getOrderTradingTypeFromFillerDirection(Order.TradeDirections _fillerDirection) internal pure returns (Order.Types) {\n', '        return (_fillerDirection == Order.TradeDirections.Long) ? Order.Types.Ask : Order.Types.Bid;\n', '    }\n', '\n', '    function escrowFunds(Order.Data _orderData) internal returns (bool) {\n', '        if (_orderData.orderType == Order.Types.Ask) {\n', '            return escrowFundsForAsk(_orderData);\n', '        } else if (_orderData.orderType == Order.Types.Bid) {\n', '            return escrowFundsForBid(_orderData);\n', '        }\n', '    }\n', '\n', '    function saveOrder(Order.Data _orderData, bytes32 _tradeGroupId) internal returns (bytes32) {\n', '        return _orderData.orders.saveOrder(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed, _orderData.betterOrderId, _orderData.worseOrderId, _tradeGroupId);\n', '    }\n', '\n', '    //\n', '    // Private functions\n', '    //\n', '\n', '    function escrowFundsForBid(Order.Data _orderData) private returns (bool) {\n', '        require(_orderData.moneyEscrowed == 0);\n', '        require(_orderData.sharesEscrowed == 0);\n', '        uint256 _attosharesToCover = _orderData.amount;\n', '        uint256 _numberOfOutcomes = _orderData.market.getNumberOfOutcomes();\n', '\n', '        // Figure out how many almost-complete-sets (just missing `outcome` share) the creator has\n', '        uint256 _attosharesHeld = 2**254;\n', '        for (uint256 _i = 0; _i < _numberOfOutcomes; _i++) {\n', '            if (_i != _orderData.outcome) {\n', '                uint256 _creatorShareTokenBalance = _orderData.market.getShareToken(_i).balanceOf(_orderData.creator);\n', '                _attosharesHeld = SafeMathUint256.min(_creatorShareTokenBalance, _attosharesHeld);\n', '            }\n', '        }\n', '\n', '        // Take shares into escrow if they have any almost-complete-sets\n', '        if (_attosharesHeld > 0) {\n', '            _orderData.sharesEscrowed = SafeMathUint256.min(_attosharesHeld, _attosharesToCover);\n', '            _attosharesToCover -= _orderData.sharesEscrowed;\n', '            for (_i = 0; _i < _numberOfOutcomes; _i++) {\n', '                if (_i != _orderData.outcome) {\n', '                    _orderData.market.getShareToken(_i).trustedOrderTransfer(_orderData.creator, _orderData.market, _orderData.sharesEscrowed);\n', '                }\n', '            }\n', '        }\n', '        // If not able to cover entire order with shares alone, then cover remaining with tokens\n', '        if (_attosharesToCover > 0) {\n', '            _orderData.moneyEscrowed = _attosharesToCover.mul(_orderData.price);\n', '            require(_orderData.augur.trustedTransfer(_orderData.market.getDenominationToken(), _orderData.creator, _orderData.market, _orderData.moneyEscrowed));\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function escrowFundsForAsk(Order.Data _orderData) private returns (bool) {\n', '        require(_orderData.moneyEscrowed == 0);\n', '        require(_orderData.sharesEscrowed == 0);\n', '        IShareToken _shareToken = _orderData.market.getShareToken(_orderData.outcome);\n', '        uint256 _attosharesToCover = _orderData.amount;\n', '\n', '        // Figure out how many shares of the outcome the creator has\n', '        uint256 _attosharesHeld = _shareToken.balanceOf(_orderData.creator);\n', '\n', '        // Take shares in escrow if user has shares\n', '        if (_attosharesHeld > 0) {\n', '            _orderData.sharesEscrowed = SafeMathUint256.min(_attosharesHeld, _attosharesToCover);\n', '            _attosharesToCover -= _orderData.sharesEscrowed;\n', '            _shareToken.trustedOrderTransfer(_orderData.creator, _orderData.market, _orderData.sharesEscrowed);\n', '        }\n', '\n', '        // If not able to cover entire order with shares alone, then cover remaining with tokens\n', '        if (_attosharesToCover > 0) {\n', '            _orderData.moneyEscrowed = _orderData.market.getNumTicks().sub(_orderData.price).mul(_attosharesToCover);\n', '            require(_orderData.augur.trustedTransfer(_orderData.market.getDenominationToken(), _orderData.creator, _orderData.market, _orderData.moneyEscrowed));\n', '        }\n', '\n', '        return true;\n', '    }\n', '}']