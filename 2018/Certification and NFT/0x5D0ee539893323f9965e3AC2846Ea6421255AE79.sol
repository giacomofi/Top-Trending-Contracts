['pragma solidity ^0.4.18; // solhint-disable-line\n', '\n', '\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0a6e6f7e6f4a6b72636567706f64246965">[email&#160;protected]</a>> (https://github.com/dete)\n', 'contract ERC721 {\n', '  // Required methods\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '  function implementsERC721() public pure returns (bool);\n', '  function ownerOf(uint256 _tokenId) public view returns (address addr);\n', '  function takeOwnership(uint256 _tokenId) public;\n', '  function totalSupply() public view returns (uint256 total);\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function transfer(address _to, uint256 _tokenId) public;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 tokenId);\n', '  event Approval(address indexed owner, address indexed approved, uint256 tokenId);\n', '\n', '  // Optional\n', '  // function name() public view returns (string name);\n', '  // function symbol() public view returns (string symbol);\n', '  // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n', '  //function tokenUri(uint256 _tokenId) public view returns (string);\n', '}\n', '\n', '\n', 'contract HiPrecious is ERC721 {\n', '\n', '  /*** EVENTS ***/\n', '\n', '  /// @dev The Birth event is fired whenever a new precious comes into existence.\n', '  event Birth(uint256 tokenId, string name, address owner);\n', '\n', '  /// @dev Transfer event as defined in current draft of ERC721.\n', '  ///  ownership is assigned, including births.\n', '  event Transfer(address from, address to, uint256 tokenId);\n', '\n', '  /*** CONSTANTS ***/\n', '\n', '  /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '  string public constant NAME = "HiPrecious"; // solhint-disable-line\n', '  string public constant SYMBOL = "HIP"; // solhint-disable-line\n', '\n', '  /*** STORAGE ***/\n', '\n', '  /// @dev A mapping from precious IDs to the address that owns them. All preciouses have\n', '  ///  some valid owner address.\n', '  mapping (uint256 => address) public preciousIndexToOwner;\n', '\n', '  // @dev A mapping from owner address to count of precious that address owns.\n', '  //  Used internally inside balanceOf() to resolve ownership count.\n', '  mapping (address => uint256) private ownershipPreciousCount;\n', '\n', '  /// @dev A mapping from HiPreciousIDs to an address that has been approved to call\n', '  ///  transferFrom(). Each Precious can only have one approved address for transfer\n', '  ///  at any time. A zero value means no approval is outstanding.\n', '  mapping (uint256 => address) public preciousIndexToApproved;\n', '\n', '  // Addresses of the main roles in HiPrecious.\n', '  address public daVinciAddress; //CPO Product\n', '  address public cresusAddress;  //CFO Finance\n', '  \n', '  \n', ' function () public payable {} // Give the ability of receiving ether\n', '\n', '  /*** DATATYPES ***/\n', '\n', '  struct Precious {\n', '    string name;  // Edition name like &#39;Monroe&#39;\n', '    uint256 number; //  Like 12 means #12 out of the edition.worldQuantity possible (here in the example 15)\n', '    uint256 editionId;  // id to find the edition in which this precious Belongs to. Stored in allEditions[precious.editionId]\n', '    uint256 collectionId; // id to find the collection in which this precious Belongs to. Stored in allCollections[precious.collectionId]\n', '    string tokenURI;\n', '  }\n', '\n', '  struct Edition {\n', '    uint256 id;\n', '    string name; // Like &#39;Lee&#39;\n', '    uint256 worldQuantity; // The number of precious composing this edition (ex: if 15 then there will never be more precious in this edition)\n', '    uint256[] preciousIds; // The list of precious ids which compose this edition.\n', '    uint256 collectionId;\n', '  }\n', '\n', '  struct Collection {\n', '    uint256 id;\n', '    string name; // Like &#39;China&#39;\n', '    uint256[] editionIds; // The list of edition ids which compose this collection Ex: allEditions.get[editionIds[0]].name = &#39;Lee01&#39;dawd&#39;\n', '  }\n', '\n', '  Precious[] private allPreciouses;\n', '  Edition[] private allEditions;\n', '  Collection[] private allCollections;\n', '\n', '  /*** ACCESS MODIFIERS ***/\n', '  /// @dev Access modifier for CEO-only functionality\n', '  modifier onlyDaVinci() {\n', '    require(msg.sender == daVinciAddress);\n', '    _;\n', '  }\n', '\n', '  /// @dev Access modifier for CFO-only functionality\n', '  modifier onlyCresus() {\n', '    require(msg.sender == cresusAddress);\n', '    _;\n', '  }\n', '\n', '  /// Access modifier for contract owner only functionality\n', '  modifier onlyCLevel() {\n', '    require(msg.sender == daVinciAddress || msg.sender == cresusAddress);\n', '    _;\n', '  }\n', '\n', '  /*** CONSTRUCTOR ***/\n', '  function HiPrecious() public {\n', '    daVinciAddress = msg.sender;\n', '    cresusAddress = msg.sender;\n', '  }\n', '\n', '  /*** PUBLIC FUNCTIONS ***/\n', '  /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().\n', '  /// @param _to The address to be granted transfer approval. Pass address(0) to\n', '  ///  clear all approvals.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function approve(\n', '    address _to,\n', '    uint256 _tokenId\n', '  ) public {\n', '    // Caller must own token.\n', '    require(_owns(msg.sender, _tokenId));\n', '\n', '    preciousIndexToApproved[_tokenId] = _to;\n', '\n', '    emit Approval(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /// For querying balance of a particular account\n', '  /// @param _owner The address for balance query\n', '  /// @dev Required for ERC-721 compliance.\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return ownershipPreciousCount[_owner];\n', '  }\n', '\n', '  /// @dev Creates a new Collection with the given name.\n', '  function createContractCollection(string _name) public onlyDaVinci {\n', '    _createCollection(_name);\n', '  }\n', '\n', '  /// @dev Creates a new Edition with the given name and worldQuantity which will never be overcome.\n', '  function createContractEditionForCollection(string _name, uint256 _collectionId, uint256 _worldQuantity) public onlyDaVinci {\n', '    _createEdition(_name, _collectionId, _worldQuantity);\n', '  }\n', '  \n', '    /// @dev Creates a new Precious with the given name.\n', '  function createContractPreciousForEdition(address _to, uint256 _editionId, string _tokenURI) public onlyDaVinci {\n', '    _createPrecious(_to, _editionId, _tokenURI);\n', '  }\n', '\n', '  /// @notice Returns all the relevant information about a specific precious.\n', '  /// @param _tokenId The tokenId of the precious of interest.\n', '  function getPrecious(uint256 _tokenId) public view returns (\n', '    string preciousName,\n', '    uint256 number,\n', '    uint256 editionId,\n', '    uint256 collectionId,\n', '    address owner\n', '  ) {\n', '    Precious storage precious = allPreciouses[_tokenId];\n', '    preciousName = precious.name;\n', '    number = precious.number;\n', '    editionId = precious.editionId;\n', '    collectionId = precious.collectionId;\n', '    owner = preciousIndexToOwner[_tokenId];\n', '  }\n', '\n', '  /// @notice Returns all the relevant information about a specific edition.\n', '  /// @param _editionId The tokenId of the edition of interest.\n', '  function getEdition(uint256 _editionId) public view returns (\n', '    uint256 id,\n', '    string editionName,\n', '    uint256 worldQuantity,\n', '    uint256[] preciousIds\n', '  ) {\n', '    Edition storage edition = allEditions[_editionId-1];\n', '    id = edition.id;\n', '    editionName = edition.name;\n', '    worldQuantity = edition.worldQuantity;\n', '    preciousIds = edition.preciousIds;\n', '  }\n', '\n', '  /// @notice Returns all the relevant information about a specific collection.\n', '  /// @param _collectionId The tokenId of the collection of interest.\n', '  function getCollection(uint256 _collectionId) public view returns (\n', '    uint256 id,\n', '    string collectionName,\n', '    uint256[] editionIds\n', '  ) {\n', '    Collection storage collection = allCollections[_collectionId-1];\n', '    id = collection.id;\n', '    collectionName = collection.name;\n', '    editionIds = collection.editionIds;\n', '  }\n', '\n', '\n', '  function implementsERC721() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function name() public pure returns (string) {\n', '    return NAME;\n', '  }\n', '\n', '  /// For querying owner of token\n', '  /// @param _tokenId The tokenID for owner inquiry\n', '  /// @dev Required for ERC-721 compliance.\n', '  function ownerOf(uint256 _tokenId)\n', '    public\n', '    view\n', '    returns (address owner)\n', '  {\n', '    owner = preciousIndexToOwner[_tokenId];\n', '    require(owner != address(0));\n', '  }\n', '\n', '  function payout(address _to) public onlyCresus {\n', '    _payout(_to);\n', '  }\n', '\n', '  /// @dev Assigns a new address to act as the CPO. Only available to the current CPO.\n', '  /// @param _newDaVinci The address of the new CPO\n', '  function setDaVinci(address _newDaVinci) public onlyDaVinci {\n', '    require(_newDaVinci != address(0));\n', '\n', '    daVinciAddress = _newDaVinci;\n', '  }\n', '\n', '  /// @dev Assigns a new address to act as the CFO. Only available to the current CFO.\n', '  /// @param _newCresus The address of the new CFO\n', '  function setCresus(address _newCresus) public onlyCresus {\n', '    require(_newCresus != address(0));\n', '\n', '    cresusAddress = _newCresus;\n', '  }\n', '\n', '  function tokenURI(uint256 _tokenId) public view returns (string){\n', '      require(_tokenId<allPreciouses.length);\n', '      return allPreciouses[_tokenId].tokenURI;\n', '  }\n', '  \n', '  function setTokenURI(uint256 _tokenId, string newURI) public onlyDaVinci{\n', '      require(_tokenId<allPreciouses.length);\n', '      Precious storage precious = allPreciouses[_tokenId];\n', '      precious.tokenURI = newURI;\n', '  }\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function symbol() public pure returns (string) {\n', '    return SYMBOL;\n', '  }\n', '\n', '  /// @notice Allow pre-approved user to take ownership of a token\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function takeOwnership(uint256 _tokenId) public {\n', '    address newOwner = msg.sender;\n', '    address oldOwner = preciousIndexToOwner[_tokenId];\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure transfer is approved\n', '    require(_approved(newOwner, _tokenId));\n', '\n', '    _transfer(oldOwner, newOwner, _tokenId);\n', '  }\n', '\n', '  /// @param _owner The owner whose celebrity tokens we are interested in.\n', '  /// @dev This method MUST NEVER be called by smart contract code. First, it&#39;s fairly\n', '  ///  expensive (it walks the entire allPreciouses array looking for preciouses belonging to owner),\n', '  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '  ///  not contract-to-contract calls.\n', '  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n', '    uint256 tokenCount = balanceOf(_owner);\n', '    if (tokenCount == 0) {\n', '        // Return an empty array\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 totalPreciouses = totalSupply();\n', '      uint256 resultIndex = 0;\n', '\n', '      uint256 preciousId;\n', '      for (preciousId = 0; preciousId <= totalPreciouses; preciousId++) {\n', '        if (preciousIndexToOwner[preciousId] == _owner) {\n', '          result[resultIndex] = preciousId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  }\n', '\n', '  /// For querying totalSupply of preciouses\n', '  /// @dev Required for ERC-721 compliance.\n', '  function totalSupply() public view returns (uint256 total) {\n', '    return allPreciouses.length;\n', '  }\n', '\n', '  /// Owner initates the transfer of the token to another account\n', '  /// @param _to The address for the token to be transferred to.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function transfer(\n', '    address _to,\n', '    uint256 _tokenId\n', '  ) public {\n', '    require(_owns(msg.sender, _tokenId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /// Third-party initiates transfer of token from address _from to address _to\n', '  /// @param _from The address for the token to be transferred from.\n', '  /// @param _to The address for the token to be transferred to.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  ) public {\n', '    require(_owns(_from, _tokenId));\n', '    require(_approved(_to, _tokenId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /*** PRIVATE FUNCTIONS ***/\n', '  /// Safety check on _to address to prevent against an unexpected 0x0 default.\n', '  function _addressNotNull(address _to) private pure returns (bool) {\n', '    return _to != address(0);\n', '  }\n', '\n', '  /// For checking approval of transfer for address _to\n', '  function _approved(address _to, uint256 _tokenId) private view returns (bool) {\n', '    return preciousIndexToApproved[_tokenId] == _to;\n', '  }\n', '\n', '  /// For creating Collections\n', '  function _createCollection(string _name) private onlyDaVinci{\n', '    uint256 newCollectionId = allCollections.length+1;\n', '    uint256[] storage newEditionIds;\n', '    Collection memory _collection = Collection({\n', '      id: newCollectionId,\n', '      name: _name,\n', '      editionIds: newEditionIds\n', '    });\n', '\n', '    allCollections.push(_collection);\n', '  }\n', '\n', '  /// For creating Editions\n', '  function _createEdition(string _name, uint256 _collectionId, uint256 _worldQuantity) private onlyDaVinci{\n', '    Collection storage collection = allCollections[_collectionId-1]; //Would retrieve Bad instruction if not exist\n', '\n', '    uint256 newEditionId = allEditions.length+1;\n', '    uint256[] storage newPreciousIds;\n', '\n', '    Edition memory _edition = Edition({\n', '      id: newEditionId,\n', '      name: _name,\n', '      worldQuantity: _worldQuantity,\n', '      preciousIds: newPreciousIds,\n', '      collectionId: _collectionId\n', '    });\n', '\n', '    allEditions.push(_edition);\n', '    collection.editionIds.push(newEditionId);\n', '  }\n', '\n', '  /// For creating Precious\n', '  function _createPrecious(address _owner, uint256 _editionId, string _tokenURI) private onlyDaVinci{\n', '    Edition storage edition = allEditions[_editionId-1]; //if _editionId doesn&#39;t exist in array, exits.\n', '    \n', '    //Check if we can still print precious for that specific edition\n', '    require(edition.preciousIds.length < edition.worldQuantity);\n', '\n', '    //string memory preciousName = edition.name + &#39;_&#39; + edition.preciousIds.length+1 + &#39;/&#39; + edition.worldQuantity; NOT DOABLE IN SOLIDITY\n', '\n', '    Precious memory _precious = Precious({\n', '      name: edition.name,\n', '      number: edition.preciousIds.length+1,\n', '      editionId: _editionId,\n', '      collectionId: edition.collectionId,\n', '      tokenURI: _tokenURI\n', '    });\n', '\n', '    uint256 newPreciousId = allPreciouses.push(_precious) - 1;\n', '    edition.preciousIds.push(newPreciousId);\n', '\n', '    // It&#39;s probably never going to happen, 4 billion preciouses are A LOT, but\n', '    // let&#39;s just be 100% sure we never let this happen.\n', '    require(newPreciousId == uint256(uint32(newPreciousId)));\n', '\n', '    emit Birth(newPreciousId, edition.name, _owner);\n', '\n', '    // This will assign ownership, and also emit the Transfer event as\n', '    // per ERC721 draft\n', '    _transfer(address(0), _owner, newPreciousId);\n', '  }\n', '\n', '  /// Check for token ownership\n', '  function _owns(address claimant, uint256 _tokenId) private view returns (bool) {\n', '    return claimant == preciousIndexToOwner[_tokenId];\n', '  }\n', '\n', '  /// For paying out balance on contract\n', '  function _payout(address _to) private {\n', '    if (_to == address(0)) {\n', '      cresusAddress.transfer(address(this).balance);\n', '    } else {\n', '      _to.transfer(address(this).balance);\n', '    }\n', '  }\n', '\n', '  /// @dev Assigns ownership of a specific Precious to an address.\n', '  function _transfer(address _from, address _to, uint256 _tokenId) private {\n', '    // Since the number of preciouses is capped to 2^32 we can&#39;t overflow this\n', '    ownershipPreciousCount[_to]++;\n', '    //transfer ownership\n', '    preciousIndexToOwner[_tokenId] = _to;\n', '\n', '    // When creating new preciouses _from is 0x0, but we can&#39;t account that address.\n', '    if (_from != address(0)) {\n', '      ownershipPreciousCount[_from]--;\n', '      // clear any previously approved ownership exchange\n', '      delete preciousIndexToApproved[_tokenId];\n', '    }\n', '\n', '    // Emit the transfer event.\n', '    emit Transfer(_from, _to, _tokenId);\n', '  }\n', '}\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']