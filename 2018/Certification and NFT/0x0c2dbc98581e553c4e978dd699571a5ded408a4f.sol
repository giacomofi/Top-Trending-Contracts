['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * DO NOT SEND ETH TO THIS CONTRACT ON MAINNET.  ITS ONLY DEPLOYED ON MAINNET TO\n', ' * DISPROVE SOME FALSE CLAIMS ABOUT FOMO3D AND JEKYLL ISLAND INTERACTION.  YOU \n', ' * CAN TEST ALL THE PAYABLE FUNCTIONS SENDING 0 ETH.  OR BETTER YET COPY THIS TO \n', ' * THE TESTNETS.\n', ' * \n', ' * IF YOU SEND ETH TO THIS CONTRACT IT CANNOT BE RECOVERED.  THERE IS NO WITHDRAW.\n', ' * \n', ' * THE CHECK BALANCE FUNCTIONS ARE FOR WHEN TESTING ON TESTNET TO SHOW THAT ALTHOUGH \n', ' * THE CORP BANK COULD BE FORCED TO REVERT TX&#39;S OR TRY AND BURN UP ALL/MOST GAS\n', ' * FOMO3D STILL MOVES ON WITHOUT RISK OF LOCKING UP.  AND IN CASES OF REVERT OR  \n', ' * OOG INSIDE CORP BANK.  ALL WE AT TEAM JUST WOULD ACCOMPLISH IS JUSTING OURSELVES \n', ' * OUT OF THE ETH THAT WAS TO BE SENT TO JEKYLL ISLAND.  FOREVER LEAVING IT UNCLAIMABLE\n', ' * IN FOMO3D CONTACT.  SO WE CAN ONLY HARM OURSELVES IF WE TRIED SUCH A USELESS \n', ' * THING.  AND FOMO3D WILL CONTINUE ON, UNAFFECTED\n', ' */\n', '\n', '// this is deployed on mainnet at:  0x38aEfE9e8E0Fc938475bfC6d7E52aE28D39FEBD8\n', 'contract Fomo3d {\n', '    // create some data tracking vars for testing\n', '    bool public depositSuccessful_;\n', '    uint256 public successfulTransactions_;\n', '    uint256 public gasBefore_;\n', '    uint256 public gasAfter_;\n', '    \n', '    // create forwarder instance\n', '    Forwarder Jekyll_Island_Inc;\n', '    \n', '    // take addr for forwarder in constructor arguments\n', '    constructor(address _addr)\n', '        public\n', '    {\n', '        // set up forwarder to point to its contract location\n', '        Jekyll_Island_Inc = Forwarder(_addr);\n', '    }\n', '\n', '    // some fomo3d function that deposits to Forwarder\n', '    function someFunction()\n', '        public\n', '        payable\n', '    {\n', '        // grab gas left\n', '        gasBefore_ = gasleft();\n', '        \n', '        // deposit to forwarder, uses low level call so forwards all gas\n', '        if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256("deposit()"))))  \n', '        {\n', '            // give fomo3d work to do that needs gas. what better way than storage \n', '            // write calls, since their so costly.\n', '            depositSuccessful_ = false;\n', '            gasAfter_ = gasleft();\n', '        } else {\n', '            depositSuccessful_ = true;\n', '            successfulTransactions_++;\n', '            gasAfter_ = gasleft();\n', '        }\n', '    }\n', '    \n', '    // some fomo3d function that deposits to Forwarder\n', '    function someFunction2()\n', '        public\n', '        payable\n', '    {\n', '        // grab gas left\n', '        gasBefore_ = gasleft();\n', '        \n', '        // deposit to forwarder, uses low level call so forwards all gas\n', '        if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256("deposit2()"))))  \n', '        {\n', '            // give fomo3d work to do that needs gas. what better way than storage \n', '            // write calls, since their so costly.\n', '            depositSuccessful_ = false;\n', '            gasAfter_ = gasleft();\n', '        } else {\n', '            depositSuccessful_ = true;\n', '            successfulTransactions_++;\n', '            gasAfter_ = gasleft();\n', '        }\n', '    }\n', '    \n', '    // some fomo3d function that deposits to Forwarder\n', '    function someFunction3()\n', '        public\n', '        payable\n', '    {\n', '        // grab gas left\n', '        gasBefore_ = gasleft();\n', '        \n', '        // deposit to forwarder, uses low level call so forwards all gas\n', '        if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256("deposit3()"))))  \n', '        {\n', '            // give fomo3d work to do that needs gas. what better way than storage \n', '            // write calls, since their so costly.\n', '            depositSuccessful_ = false;\n', '            gasAfter_ = gasleft();\n', '        } else {\n', '            depositSuccessful_ = true;\n', '            successfulTransactions_++;\n', '            gasAfter_ = gasleft();\n', '        }\n', '    }\n', '    \n', '    // some fomo3d function that deposits to Forwarder\n', '    function someFunction4()\n', '        public\n', '        payable\n', '    {\n', '        // grab gas left\n', '        gasBefore_ = gasleft();\n', '        \n', '        // deposit to forwarder, uses low level call so forwards all gas\n', '        if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256("deposit4()"))))  \n', '        {\n', '            // give fomo3d work to do that needs gas. what better way than storage \n', '            // write calls, since their so costly.\n', '            depositSuccessful_ = false;\n', '            gasAfter_ = gasleft();\n', '        } else {\n', '            depositSuccessful_ = true;\n', '            successfulTransactions_++;\n', '            gasAfter_ = gasleft();\n', '        }\n', '    }\n', '    \n', '    // for data tracking lets make a function to check this contracts balance\n', '    function checkBalance()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return(address(this).balance);\n', '    }\n', '    \n', '}\n', '\n', '\n', '// heres a sample forwarder with a copy of the jekyll island forwarder (requirements on \n', '// msg.sender removed for simplicity since its irrelevant to testing this.  and some\n', '// tracking vars added for test.)\n', '\n', '// this is deployed on mainnet at:  0x8F59323d8400CC0deE71ee91f92961989D508160\n', 'contract Forwarder {\n', '    // lets create some tracking vars \n', '    bool public depositSuccessful_;\n', '    uint256 public successfulTransactions_;\n', '    uint256 public gasBefore_;\n', '    uint256 public gasAfter_;\n', '    \n', '    // create an instance of the jekyll island bank \n', '    Bank currentCorpBank_;\n', '    \n', '    // take an address in the constructor arguments to set up bank with \n', '    constructor(address _addr)\n', '        public\n', '    {\n', '        // point the created instance to the address given\n', '        currentCorpBank_ = Bank(_addr);\n', '    }\n', '    \n', '    function deposit()\n', '        public \n', '        payable\n', '        returns(bool)\n', '    {\n', '        // grab gas at start\n', '        gasBefore_ = gasleft();\n', '        \n', '        if (currentCorpBank_.deposit.value(msg.value)(msg.sender) == true) {\n', '            depositSuccessful_ = true;    \n', '            successfulTransactions_++;\n', '            gasAfter_ = gasleft();\n', '            return(true);\n', '        } else {\n', '            depositSuccessful_ = false;\n', '            gasAfter_ = gasleft();\n', '            return(false);\n', '        }\n', '    }\n', '    \n', '    function deposit2()\n', '        public \n', '        payable\n', '        returns(bool)\n', '    {\n', '        // grab gas at start\n', '        gasBefore_ = gasleft();\n', '        \n', '        if (currentCorpBank_.deposit2.value(msg.value)(msg.sender) == true) {\n', '            depositSuccessful_ = true;    \n', '            successfulTransactions_++;\n', '            gasAfter_ = gasleft();\n', '            return(true);\n', '        } else {\n', '            depositSuccessful_ = false;\n', '            gasAfter_ = gasleft();\n', '            return(false);\n', '        }\n', '    }\n', '    \n', '    function deposit3()\n', '        public \n', '        payable\n', '        returns(bool)\n', '    {\n', '        // grab gas at start\n', '        gasBefore_ = gasleft();\n', '        \n', '        if (currentCorpBank_.deposit3.value(msg.value)(msg.sender) == true) {\n', '            depositSuccessful_ = true;    \n', '            successfulTransactions_++;\n', '            gasAfter_ = gasleft();\n', '            return(true);\n', '        } else {\n', '            depositSuccessful_ = false;\n', '            gasAfter_ = gasleft();\n', '            return(false);\n', '        }\n', '    }\n', '    \n', '    function deposit4()\n', '        public \n', '        payable\n', '        returns(bool)\n', '    {\n', '        // grab gas at start\n', '        gasBefore_ = gasleft();\n', '        \n', '        if (currentCorpBank_.deposit4.value(msg.value)(msg.sender) == true) {\n', '            depositSuccessful_ = true;    \n', '            successfulTransactions_++;\n', '            gasAfter_ = gasleft();\n', '            return(true);\n', '        } else {\n', '            depositSuccessful_ = false;\n', '            gasAfter_ = gasleft();\n', '            return(false);\n', '        }\n', '    }\n', '    \n', '    // for data tracking lets make a function to check this contracts balance\n', '    function checkBalance()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return(address(this).balance);\n', '    }\n', '    \n', '}\n', '\n', '// heres the bank with various ways someone could try and migrate to a bank that \n', '// screws the tx.  to show none of them effect fomo3d.\n', '\n', '// this is deployed on mainnet at:  0x0C2DBC98581e553C4E978Dd699571a5DED408a4F\n', 'contract Bank {\n', '    // lets use storage writes to this to burn up all gas\n', '    uint256 public i = 1000000;\n', '    uint256 public x;\n', '    address public fomo3d;\n', '    \n', '    /**\n', '     * this version will use up most gas.  but return just enough to make it back\n', '     * to fomo3d.  yet not enough for fomo3d to finish its execution (according to \n', '     * the theory of the exploit.  which when you run this you&#39;ll find due to my \n', '     * use of ! in the call from fomo3d to forwarder, and the use of a normal function \n', '     * call from forwarder to bank, this fails to stop fomo3d from continuing)\n', '     */\n', '    function deposit(address _fomo3daddress)\n', '        external\n', '        payable\n', '        returns(bool)\n', '    {\n', '        // burn all gas leaving just enough to get back to fomo3d  and it to do\n', '        // a write call in a attempt to make Fomo3d OOG (doesn&#39;t work cause fomo3d \n', '        // protects itself from this behavior)\n', '        while (i > 41000)\n', '        {\n', '            i = gasleft();\n', '        }\n', '        \n', '        return(true);\n', '    }\n', '    \n', '    /**\n', '     * this version just tries a plain revert.  (pssst... fomo3d doesn&#39;t care)\n', '     */\n', '    function deposit2(address _fomo3daddress)\n', '        external\n', '        payable\n', '        returns(bool)\n', '    {\n', '        // straight up revert (since we use low level call in fomo3d it doesn&#39;t \n', '        // care if we revert the internal tx to bank.  this behavior would only \n', '        // screw over team just, not effect fomo3d)\n', '        revert();\n', '    }\n', '    \n', '    /**\n', '     * this one tries an infinite loop (another fail.  fomo3d trudges on)\n', '     */\n', '    function deposit3(address _fomo3daddress)\n', '        external\n', '        payable\n', '        returns(bool)\n', '    {\n', '        // this infinite loop still does not stop fomo3d from running.\n', '        while(1 == 1) {\n', '            x++;\n', '            fomo3d = _fomo3daddress;\n', '        }\n', '        return(true);\n', '    }\n', '    \n', '    /**\n', '     * this one just runs a set length loops that OOG&#39;s (and.. again.. fomo3d still works)\n', '     */\n', '    function deposit4(address _fomo3daddress)\n', '        public\n', '        payable\n', '        returns(bool)\n', '    {\n', '        // burn all gas (fomo3d still keeps going)\n', '        for (uint256 i = 0; i <= 1000; i++)\n', '        {\n', '            x++;\n', '            fomo3d = _fomo3daddress;\n', '        }\n', '    }\n', '    \n', '    // for data tracking lets make a function to check this contracts balance\n', '    function checkBalance()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return(address(this).balance);\n', '    }\n', '}']