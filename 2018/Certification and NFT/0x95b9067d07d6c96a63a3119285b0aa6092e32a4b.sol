['//File: contracts/acl/IACL.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', 'interface IACL {\n', '    function initialize(address permissionsCreator) public;\n', '    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n', '}\n', '\n', '//File: contracts/kernel/IKernel.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', 'interface IKernel {\n', '    event SetApp(bytes32 indexed namespace, bytes32 indexed name, bytes32 indexed id, address app);\n', '\n', '    function acl() public view returns (IACL);\n', '    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n', '\n', '    function setApp(bytes32 namespace, bytes32 name, address app) public returns (bytes32 id);\n', '    function getApp(bytes32 id) public view returns (address);\n', '}\n', '//File: contracts/apps/AppStorage.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', 'contract AppStorage {\n', '    IKernel public kernel;\n', '    bytes32 public appId;\n', '    address internal pinnedCode; // used by Proxy Pinned\n', '    uint256 internal initializationBlock; // used by Initializable\n', '    uint256[95] private storageOffset; // forces App storage to start at after 100 slots\n', '    uint256 private offset;\n', '}\n', '\n', '//File: contracts/common/Initializable.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', 'contract Initializable is AppStorage {\n', '    modifier onlyInit {\n', '        require(initializationBlock == 0);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @return Block number in which the contract was initialized\n', '    */\n', '    function getInitializationBlock() public view returns (uint256) {\n', '        return initializationBlock;\n', '    }\n', '\n', '    /**\n', '    * @dev Function to be called by top level contract after initialization has finished.\n', '    */\n', '    function initialized() internal onlyInit {\n', '        initializationBlock = getBlockNumber();\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the current block number.\n', '    *      Using a function rather than `block.number` allows us to easily mock the block number in\n', '    *      tests.\n', '    */\n', '    function getBlockNumber() internal view returns (uint256) {\n', '        return block.number;\n', '    }\n', '}\n', '\n', '//File: contracts/evmscript/IEVMScriptExecutor.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', 'interface IEVMScriptExecutor {\n', '    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n', '}\n', '\n', '//File: contracts/evmscript/IEVMScriptRegistry.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', 'contract EVMScriptRegistryConstants {\n', '    bytes32 constant public EVMSCRIPT_REGISTRY_APP_ID = keccak256("evmreg.aragonpm.eth");\n', '    bytes32 constant public EVMSCRIPT_REGISTRY_APP = keccak256(keccak256("app"), EVMSCRIPT_REGISTRY_APP_ID);\n', '}\n', '\n', '\n', 'interface IEVMScriptRegistry {\n', '    function addScriptExecutor(address executor) external returns (uint id);\n', '    function disableScriptExecutor(uint256 executorId) external;\n', '\n', '    function getScriptExecutor(bytes script) public view returns (address);\n', '}\n', '//File: contracts/evmscript/ScriptHelpers.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', 'library ScriptHelpers {\n', '    // To test with JS and compare with actual encoder. Maintaining for reference.\n', '    // t = function() { return IEVMScriptExecutor.at(&#39;0x4bcdd59d6c77774ee7317fc1095f69ec84421e49&#39;).contract.execScript.getData(...[].slice.call(arguments)).slice(10).match(/.{1,64}/g) }\n', '    // run = function() { return ScriptHelpers.new().then(sh => { sh.abiEncode.call(...[].slice.call(arguments)).then(a => console.log(a.slice(2).match(/.{1,64}/g)) ) }) }\n', '    // This is truly not beautiful but lets no daydream to the day solidity gets reflection features\n', '\n', '    function abiEncode(bytes _a, bytes _b, address[] _c) public pure returns (bytes d) {\n', '        return encode(_a, _b, _c);\n', '    }\n', '\n', '    function encode(bytes memory _a, bytes memory _b, address[] memory _c) internal pure returns (bytes memory d) {\n', '        // A is positioned after the 3 position words\n', '        uint256 aPosition = 0x60;\n', '        uint256 bPosition = aPosition + 32 * abiLength(_a);\n', '        uint256 cPosition = bPosition + 32 * abiLength(_b);\n', '        uint256 length = cPosition + 32 * abiLength(_c);\n', '\n', '        d = new bytes(length);\n', '        assembly {\n', '            // Store positions\n', '            mstore(add(d, 0x20), aPosition)\n', '            mstore(add(d, 0x40), bPosition)\n', '            mstore(add(d, 0x60), cPosition)\n', '        }\n', '\n', '        // Copy memory to correct position\n', '        copy(d, getPtr(_a), aPosition, _a.length);\n', '        copy(d, getPtr(_b), bPosition, _b.length);\n', '        copy(d, getPtr(_c), cPosition, _c.length * 32); // 1 word per address\n', '    }\n', '\n', '    function abiLength(bytes memory _a) internal pure returns (uint256) {\n', '        // 1 for length +\n', '        // memory words + 1 if not divisible for 32 to offset word\n', '        return 1 + (_a.length / 32) + (_a.length % 32 > 0 ? 1 : 0);\n', '    }\n', '\n', '    function abiLength(address[] _a) internal pure returns (uint256) {\n', '        // 1 for length + 1 per item\n', '        return 1 + _a.length;\n', '    }\n', '\n', '    function copy(bytes _d, uint256 _src, uint256 _pos, uint256 _length) internal pure {\n', '        uint dest;\n', '        assembly {\n', '            dest := add(add(_d, 0x20), _pos)\n', '        }\n', '        memcpy(dest, _src, _length + 32);\n', '    }\n', '\n', '    function getPtr(bytes memory _x) internal pure returns (uint256 ptr) {\n', '        assembly {\n', '            ptr := _x\n', '        }\n', '    }\n', '\n', '    function getPtr(address[] memory _x) internal pure returns (uint256 ptr) {\n', '        assembly {\n', '            ptr := _x\n', '        }\n', '    }\n', '\n', '    function getSpecId(bytes _script) internal pure returns (uint32) {\n', '        return uint32At(_script, 0);\n', '    }\n', '\n', '    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n', '        assembly {\n', '            result := mload(add(_data, add(0x20, _location)))\n', '        }\n', '    }\n', '\n', '    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {\n', '        uint256 word = uint256At(_data, _location);\n', '\n', '        assembly {\n', '            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\n', '            0x1000000000000000000000000)\n', '        }\n', '    }\n', '\n', '    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {\n', '        uint256 word = uint256At(_data, _location);\n', '\n', '        assembly {\n', '            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),\n', '            0x100000000000000000000000000000000000000000000000000000000)\n', '        }\n', '    }\n', '\n', '    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n', '        assembly {\n', '            result := add(_data, add(0x20, _location))\n', '        }\n', '    }\n', '\n', '    function toBytes(bytes4 _sig) internal pure returns (bytes) {\n', '        bytes memory payload = new bytes(4);\n', '        payload[0] = bytes1(_sig);\n', '        payload[1] = bytes1(_sig << 8);\n', '        payload[2] = bytes1(_sig << 16);\n', '        payload[3] = bytes1(_sig << 24);\n', '        return payload;\n', '    }\n', '\n', '    function memcpy(uint _dest, uint _src, uint _len) public pure {\n', '        uint256 src = _src;\n', '        uint256 dest = _dest;\n', '        uint256 len = _len;\n', '\n', '        // Copy word-length chunks while possible\n', '        for (; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '}\n', '//File: contracts/evmscript/EVMScriptRunner.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract EVMScriptRunner is AppStorage, EVMScriptRegistryConstants {\n', '    using ScriptHelpers for bytes;\n', '\n', '    function runScript(bytes _script, bytes _input, address[] _blacklist) protectState internal returns (bytes output) {\n', '        // TODO: Too much data flying around, maybe extracting spec id here is cheaper\n', '        address executorAddr = getExecutor(_script);\n', '        require(executorAddr != address(0));\n', '\n', '        bytes memory calldataArgs = _script.encode(_input, _blacklist);\n', '        bytes4 sig = IEVMScriptExecutor(0).execScript.selector;\n', '\n', '        require(executorAddr.delegatecall(sig, calldataArgs));\n', '\n', '        return returnedDataDecoded();\n', '    }\n', '\n', '    function getExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n', '        return IEVMScriptExecutor(getExecutorRegistry().getScriptExecutor(_script));\n', '    }\n', '\n', '    // TODO: Internal\n', '    function getExecutorRegistry() internal view returns (IEVMScriptRegistry) {\n', '        address registryAddr = kernel.getApp(EVMSCRIPT_REGISTRY_APP);\n', '        return IEVMScriptRegistry(registryAddr);\n', '    }\n', '\n', '    /**\n', '    * @dev copies and returns last&#39;s call data. Needs to ABI decode first\n', '    */\n', '    function returnedDataDecoded() internal view returns (bytes ret) {\n', '        assembly {\n', '            let size := returndatasize\n', '            switch size\n', '            case 0 {}\n', '            default {\n', '                ret := mload(0x40) // free mem ptr get\n', '                mstore(0x40, add(ret, add(size, 0x20))) // free mem ptr set\n', '                returndatacopy(ret, 0x20, sub(size, 0x20)) // copy return data\n', '            }\n', '        }\n', '        return ret;\n', '    }\n', '\n', '    modifier protectState {\n', '        address preKernel = kernel;\n', '        bytes32 preAppId = appId;\n', '        _; // exec\n', '        require(kernel == preKernel);\n', '        require(appId == preAppId);\n', '    }\n', '}\n', '//File: contracts/acl/ACLSyntaxSugar.sol\n', 'pragma solidity 0.4.18;\n', '\n', '\n', 'contract ACLSyntaxSugar {\n', '    function arr() internal pure returns (uint256[] r) {}\n', '\n', '    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a));\n', '    }\n', '\n', '    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b));\n', '    }\n', '\n', '    function arr(address _a) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a));\n', '    }\n', '\n', '    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b));\n', '    }\n', '\n', '    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), _b, _c);\n', '    }\n', '\n', '    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b));\n', '    }\n', '\n', '    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n', '    }\n', '\n', '    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b), uint256(_c));\n', '    }\n', '\n', '    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b), uint256(_c));\n', '    }\n', '\n', '    function arr(uint256 _a) internal pure returns (uint256[] r) {\n', '        r = new uint256[](1);\n', '        r[0] = _a;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n', '        r = new uint256[](2);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n', '        r = new uint256[](3);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '        r[2] = _c;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n', '        r = new uint256[](4);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '        r[2] = _c;\n', '        r[3] = _d;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n', '        r = new uint256[](5);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '        r[2] = _c;\n', '        r[3] = _d;\n', '        r[4] = _e;\n', '    }\n', '}\n', '\n', '\n', 'contract ACLHelpers {\n', '    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n', '        return uint8(_x >> (8 * 30));\n', '    }\n', '\n', '    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n', '        return uint8(_x >> (8 * 31));\n', '    }\n', '\n', '    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n', '        a = uint32(_x);\n', '        b = uint32(_x >> (8 * 4));\n', '        c = uint32(_x >> (8 * 8));\n', '    }\n', '}\n', '\n', '//File: contracts/apps/AragonApp.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract AragonApp is AppStorage, Initializable, ACLSyntaxSugar, EVMScriptRunner {\n', '    modifier auth(bytes32 _role) {\n', '        require(canPerform(msg.sender, _role, new uint256[](0)));\n', '        _;\n', '    }\n', '\n', '    modifier authP(bytes32 _role, uint256[] params) {\n', '        require(canPerform(msg.sender, _role, params));\n', '        _;\n', '    }\n', '\n', '    function canPerform(address _sender, bytes32 _role, uint256[] params) public view returns (bool) {\n', '        bytes memory how; // no need to init memory as it is never used\n', '        if (params.length > 0) {\n', '            uint256 byteLength = params.length * 32;\n', '            assembly {\n', '                how := params // forced casting\n', '                mstore(how, byteLength)\n', '            }\n', '        }\n', '        return address(kernel) == 0 || kernel.hasPermission(_sender, address(this), _role, how);\n', '    }\n', '}\n', '\n', '//File: contracts/apm/Repo.sol\n', 'pragma solidity ^0.4.15;\n', '\n', '\n', '\n', '\n', 'contract Repo is AragonApp {\n', '    struct Version {\n', '        uint16[3] semanticVersion;\n', '        address contractAddress;\n', '        bytes contentURI;\n', '    }\n', '\n', '    Version[] versions;\n', '    mapping (bytes32 => uint256) versionIdForSemantic;\n', '    mapping (address => uint256) latestVersionIdForContract;\n', '\n', '    bytes32 constant public CREATE_VERSION_ROLE = bytes32(1);\n', '\n', '    event NewVersion(uint256 versionId, uint16[3] semanticVersion);\n', '\n', '    /**\n', '    * @notice Create new version for repo\n', '    * @param _newSemanticVersion Semantic version for new repo version\n', '    * @param _contractAddress address for smart contract logic for version (if set to 0, it uses last versions&#39; contractAddress)\n', '    * @param _contentURI External URI for fetching new version&#39;s content\n', '    */\n', '    function newVersion(\n', '        uint16[3] _newSemanticVersion,\n', '        address _contractAddress,\n', '        bytes _contentURI\n', '    ) auth(CREATE_VERSION_ROLE) public\n', '    {\n', '        address contractAddress = _contractAddress;\n', '        if (versions.length > 0) {\n', '            Version storage lastVersion = versions[versions.length - 1];\n', '            require(isValidBump(lastVersion.semanticVersion, _newSemanticVersion));\n', '            if (contractAddress == 0) {\n', '                contractAddress = lastVersion.contractAddress;\n', '            }\n', '            // Only allows smart contract change on major version bumps\n', '            require(lastVersion.contractAddress == contractAddress || _newSemanticVersion[0] > lastVersion.semanticVersion[0]);\n', '        } else {\n', '            versions.length += 1;\n', '            uint16[3] memory zeroVersion;\n', '            require(isValidBump(zeroVersion, _newSemanticVersion));\n', '        }\n', '\n', '        uint versionId = versions.push(Version(_newSemanticVersion, contractAddress, _contentURI)) - 1;\n', '        versionIdForSemantic[semanticVersionHash(_newSemanticVersion)] = versionId;\n', '        latestVersionIdForContract[contractAddress] = versionId;\n', '\n', '        NewVersion(versionId, _newSemanticVersion);\n', '    }\n', '\n', '    function getLatest() public view returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI) {\n', '        return getByVersionId(versions.length - 1);\n', '    }\n', '\n', '    function getLatestForContractAddress(address _contractAddress) public view returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI) {\n', '        return getByVersionId(latestVersionIdForContract[_contractAddress]);\n', '    }\n', '\n', '    function getBySemanticVersion(uint16[3] _semanticVersion) public view returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI) {\n', '        return getByVersionId(versionIdForSemantic[semanticVersionHash(_semanticVersion)]);\n', '    }\n', '\n', '    function getByVersionId(uint _versionId) public view returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI) {\n', '        require(_versionId > 0);\n', '        Version storage version = versions[_versionId];\n', '        return (version.semanticVersion, version.contractAddress, version.contentURI);\n', '    }\n', '\n', '    function getVersionsCount() public view returns (uint256) {\n', '        uint256 len = versions.length;\n', '        return len > 0 ? len - 1 : 0;\n', '    }\n', '\n', '    function isValidBump(uint16[3] _oldVersion, uint16[3] _newVersion) public pure returns (bool) {\n', '        bool hasBumped;\n', '        uint i = 0;\n', '        while (i < 3) {\n', '            if (hasBumped) {\n', '                if (_newVersion[i] != 0) {\n', '                    return false;\n', '                }\n', '            } else if (_newVersion[i] != _oldVersion[i]) {\n', '                if (_oldVersion[i] > _newVersion[i] || _newVersion[i] - _oldVersion[i] != 1) {\n', '                    return false;\n', '                }\n', '                hasBumped = true;\n', '            }\n', '            i++;\n', '        }\n', '        return hasBumped;\n', '    }\n', '\n', '    function semanticVersionHash(uint16[3] version) internal pure returns (bytes32) {\n', '        return keccak256(version[0], version[1], version[2]);\n', '    }\n', '}']