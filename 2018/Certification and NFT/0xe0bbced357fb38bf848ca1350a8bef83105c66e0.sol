['pragma solidity 0.4.18;\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    // The one who sent the contract to the blockchain, will automatically become the owner of the contract\n', '    function owned() internal {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // The function containing this modifier can only call the owner of the contract\n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    // Change the owner of the contract\n', '    function changeOwner(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '// Functions for safe operation with input values (subtraction and addition)\n', 'library SafeMath {\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// ERC20 interface https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint256 balance);\n', '    function allowance(address owner, address spender) public constant returns (uint256 remaining);\n', '    function transfer(address to, uint256 value) public returns (bool success);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool success);\n', '    function approve(address spender, uint256 value) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract AdvancedToken is ERC20, owned {\n', '    using SafeMath for uint256;\n', '\n', '    // Stores the balances of all holders of the tokens, including the owner of the contract\n', '    mapping (address => uint256) internal balances;\n', '\n', '    // The event informs that N tokens have been destroyed\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    // Creates the required number of tokens on the specified account\n', '    function mintTokens(address _who, uint256 amount) internal returns(bool) {\n', '        require(_who != address(0));\n', '        totalSupply = totalSupply.add(amount);\n', '        balances[_who] = balances[_who].add(amount);\n', '        Transfer(this, _who, amount);\n', '        return true;\n', '    }\n', '\n', '    // Burns tokens on the contract, without affecting the token holders and the owner of the contract\n', '    function burnTokens(uint256 _value) public onlyOwner {\n', '        require(balances[this] > 0);\n', '        balances[this] = balances[this].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Burn(this, _value);\n', '    }\n', '\n', '    // Withdraws tokens from the contract if they accidentally or on purpose was it placed there\n', '    function withdrawTokens(uint256 _value) public onlyOwner {\n', '        require(balances[this] > 0 && balances[this] >= _value);\n', '        balances[this] = balances[this].sub(_value);\n', '        balances[msg.sender] = balances[msg.sender].add(_value);\n', '        Transfer(this, msg.sender, _value);\n', '    }\n', '\n', '    // Withdraws all the ether from the contract to the owner account\n', '    function withdrawEther(uint256 _value) public onlyOwner {\n', '        require(this.balance >= _value);\n', '        owner.transfer(_value);\n', '    }\n', '}\n', '\n', 'contract ICO is AdvancedToken {\n', '    using SafeMath for uint256;\n', '\n', '    enum State { Presale, waitingForICO, ICO, Active }\n', '    State public contract_state = State.Presale;\n', '\n', '    uint256 private startTime;\n', '    uint256 private presaleMaxSupply;\n', '    uint256 private marketMaxSupply;\n', '\n', '    event NewState(State state);\n', '\n', '    // Purchasing tokens is only allowed for Presale and ICO contract states\n', '    modifier crowdsaleState {\n', '        require(contract_state == State.Presale || contract_state == State.ICO);\n', '        _;\n', '    }\n', '\n', '    // Call functions transfer transferFrom and approve, is only allowed with Active state of the contract\n', '    modifier activeState {\n', '        require(contract_state == State.Active);\n', '        _;\n', '    }\n', '\n', '    // The initialization values when the contract has been mined to the blockchain\n', '    function ICO() internal {\n', '        startTime = 1528205440; // pomeriggio\n', '        presaleMaxSupply = 0 * 1 ether;\n', '        marketMaxSupply = 450000000 * 1 ether;\n', '    }\n', '\n', '    // The function of purchasing tokens\n', '    function () private payable crowdsaleState {\n', '        require(msg.value >= 0.01 ether);\n', '        require(now >= startTime);\n', '        uint256 currentMaxSupply;\n', '        uint256 tokensPerEther = 5000;\n', '        uint256 _tokens = tokensPerEther * msg.value;\n', '        uint256 bonus = 0;\n', '\n', '        // PRE-SALE calculation of bonuses\n', '        // NOTE: PRE-SALE will be not used for TESTERIUM\n', '        if (contract_state == State.Presale) {\n', '            // PRE-SALE supply limit\n', '            currentMaxSupply = presaleMaxSupply;\n', '            // For the tests replace days to minutes\n', '            if (now <= startTime + 1 days) {\n', '                bonus = 25;\n', '            } else if (now <= startTime + 2 days) {\n', '                bonus = 20;\n', '            }\n', '        // ICO supply limit\n', '        } else {\n', '            currentMaxSupply = marketMaxSupply;\n', '        }\n', '\n', '        _tokens += _tokens * bonus / 100;\n', '        uint256 restTokens = currentMaxSupply - totalSupply;\n', '        // If supplied tokens more that the rest of the tokens, will refund the excess ether\n', '        if (_tokens > restTokens) {\n', '            uint256 bonusTokens = restTokens - restTokens / (100 + bonus) * 100;\n', '            // The wei that the investor will spend for this purchase\n', '            uint256 spentWei = (restTokens - bonusTokens) / tokensPerEther;\n', '            // Verify that not return more than the incoming ether\n', '            assert(spentWei < msg.value);\n', '            // Will refund extra ether\n', '            msg.sender.transfer(msg.value - spentWei);\n', '            _tokens = restTokens;\n', '        }\n', '        mintTokens(msg.sender, _tokens);\n', '    }\n', '\n', '    // Finish the PRE-SALE period, is required the Presale state of the contract\n', '    function finishPresale() public onlyOwner returns (bool success) {\n', '        require(contract_state == State.Presale);\n', '        contract_state = State.waitingForICO;\n', '        NewState(contract_state);\n', '        return true;\n', '    }\n', '\n', '    // Start the ICO period, is required the waitingForICO state of the contract\n', '    function startICO() public onlyOwner returns (bool success) {\n', '        require(contract_state == State.waitingForICO);\n', '        contract_state = State.ICO;\n', '        NewState(contract_state);\n', '        return true;\n', '    }\n', '\n', '    // Our tokens\n', '    function finishICO() public onlyOwner returns (bool success) {\n', '        require(contract_state == State.ICO);\n', '        mintTokens(owner, 50000000000000000000000000);\n', '        contract_state = State.Active;\n', '        NewState(contract_state);\n', '        return true;\n', '    }\n', '}\n', '\n', '// See ERC20 interface above\n', 'contract TESTERIUM is ICO {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name     = "ZATA TOKEN";\n', '    string public constant symbol   = "L.E.N.T.O.";\n', '    uint8  public constant decimals = 18;\n', '\n', '    mapping (address => mapping (address => uint256)) private allowed;\n', '\n', '    function balanceOf(address _who) public constant returns (uint256 available) {\n', '        return balances[_who];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public activeState returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[msg.sender] >= _value);\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public activeState returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public activeState returns (bool success) {\n', '        require(_spender != address(0));\n', '        require(balances[msg.sender] >= _value);\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '}']
['pragma solidity 0.4.18;\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    // The one who sent the contract to the blockchain, will automatically become the owner of the contract\n', '    function owned() internal {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // The function containing this modifier can only call the owner of the contract\n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    // Change the owner of the contract\n', '    function changeOwner(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '// Functions for safe operation with input values (subtraction and addition)\n', 'library SafeMath {\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// ERC20 interface https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint256 balance);\n', '    function allowance(address owner, address spender) public constant returns (uint256 remaining);\n', '    function transfer(address to, uint256 value) public returns (bool success);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool success);\n', '    function approve(address spender, uint256 value) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract AdvancedToken is ERC20, owned {\n', '    using SafeMath for uint256;\n', '\n', '    // Stores the balances of all holders of the tokens, including the owner of the contract\n', '    mapping (address => uint256) internal balances;\n', '\n', '    // The event informs that N tokens have been destroyed\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    // Creates the required number of tokens on the specified account\n', '    function mintTokens(address _who, uint256 amount) internal returns(bool) {\n', '        require(_who != address(0));\n', '        totalSupply = totalSupply.add(amount);\n', '        balances[_who] = balances[_who].add(amount);\n', '        Transfer(this, _who, amount);\n', '        return true;\n', '    }\n', '\n', '    // Burns tokens on the contract, without affecting the token holders and the owner of the contract\n', '    function burnTokens(uint256 _value) public onlyOwner {\n', '        require(balances[this] > 0);\n', '        balances[this] = balances[this].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Burn(this, _value);\n', '    }\n', '\n', '    // Withdraws tokens from the contract if they accidentally or on purpose was it placed there\n', '    function withdrawTokens(uint256 _value) public onlyOwner {\n', '        require(balances[this] > 0 && balances[this] >= _value);\n', '        balances[this] = balances[this].sub(_value);\n', '        balances[msg.sender] = balances[msg.sender].add(_value);\n', '        Transfer(this, msg.sender, _value);\n', '    }\n', '\n', '    // Withdraws all the ether from the contract to the owner account\n', '    function withdrawEther(uint256 _value) public onlyOwner {\n', '        require(this.balance >= _value);\n', '        owner.transfer(_value);\n', '    }\n', '}\n', '\n', 'contract ICO is AdvancedToken {\n', '    using SafeMath for uint256;\n', '\n', '    enum State { Presale, waitingForICO, ICO, Active }\n', '    State public contract_state = State.Presale;\n', '\n', '    uint256 private startTime;\n', '    uint256 private presaleMaxSupply;\n', '    uint256 private marketMaxSupply;\n', '\n', '    event NewState(State state);\n', '\n', '    // Purchasing tokens is only allowed for Presale and ICO contract states\n', '    modifier crowdsaleState {\n', '        require(contract_state == State.Presale || contract_state == State.ICO);\n', '        _;\n', '    }\n', '\n', '    // Call functions transfer transferFrom and approve, is only allowed with Active state of the contract\n', '    modifier activeState {\n', '        require(contract_state == State.Active);\n', '        _;\n', '    }\n', '\n', '    // The initialization values when the contract has been mined to the blockchain\n', '    function ICO() internal {\n', '        startTime = 1528205440; // pomeriggio\n', '        presaleMaxSupply = 0 * 1 ether;\n', '        marketMaxSupply = 450000000 * 1 ether;\n', '    }\n', '\n', '    // The function of purchasing tokens\n', '    function () private payable crowdsaleState {\n', '        require(msg.value >= 0.01 ether);\n', '        require(now >= startTime);\n', '        uint256 currentMaxSupply;\n', '        uint256 tokensPerEther = 5000;\n', '        uint256 _tokens = tokensPerEther * msg.value;\n', '        uint256 bonus = 0;\n', '\n', '        // PRE-SALE calculation of bonuses\n', '        // NOTE: PRE-SALE will be not used for TESTERIUM\n', '        if (contract_state == State.Presale) {\n', '            // PRE-SALE supply limit\n', '            currentMaxSupply = presaleMaxSupply;\n', '            // For the tests replace days to minutes\n', '            if (now <= startTime + 1 days) {\n', '                bonus = 25;\n', '            } else if (now <= startTime + 2 days) {\n', '                bonus = 20;\n', '            }\n', '        // ICO supply limit\n', '        } else {\n', '            currentMaxSupply = marketMaxSupply;\n', '        }\n', '\n', '        _tokens += _tokens * bonus / 100;\n', '        uint256 restTokens = currentMaxSupply - totalSupply;\n', '        // If supplied tokens more that the rest of the tokens, will refund the excess ether\n', '        if (_tokens > restTokens) {\n', '            uint256 bonusTokens = restTokens - restTokens / (100 + bonus) * 100;\n', '            // The wei that the investor will spend for this purchase\n', '            uint256 spentWei = (restTokens - bonusTokens) / tokensPerEther;\n', '            // Verify that not return more than the incoming ether\n', '            assert(spentWei < msg.value);\n', '            // Will refund extra ether\n', '            msg.sender.transfer(msg.value - spentWei);\n', '            _tokens = restTokens;\n', '        }\n', '        mintTokens(msg.sender, _tokens);\n', '    }\n', '\n', '    // Finish the PRE-SALE period, is required the Presale state of the contract\n', '    function finishPresale() public onlyOwner returns (bool success) {\n', '        require(contract_state == State.Presale);\n', '        contract_state = State.waitingForICO;\n', '        NewState(contract_state);\n', '        return true;\n', '    }\n', '\n', '    // Start the ICO period, is required the waitingForICO state of the contract\n', '    function startICO() public onlyOwner returns (bool success) {\n', '        require(contract_state == State.waitingForICO);\n', '        contract_state = State.ICO;\n', '        NewState(contract_state);\n', '        return true;\n', '    }\n', '\n', '    // Our tokens\n', '    function finishICO() public onlyOwner returns (bool success) {\n', '        require(contract_state == State.ICO);\n', '        mintTokens(owner, 50000000000000000000000000);\n', '        contract_state = State.Active;\n', '        NewState(contract_state);\n', '        return true;\n', '    }\n', '}\n', '\n', '// See ERC20 interface above\n', 'contract TESTERIUM is ICO {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name     = "ZATA TOKEN";\n', '    string public constant symbol   = "L.E.N.T.O.";\n', '    uint8  public constant decimals = 18;\n', '\n', '    mapping (address => mapping (address => uint256)) private allowed;\n', '\n', '    function balanceOf(address _who) public constant returns (uint256 available) {\n', '        return balances[_who];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public activeState returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[msg.sender] >= _value);\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public activeState returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public activeState returns (bool success) {\n', '        require(_spender != address(0));\n', '        require(balances[msg.sender] >= _value);\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '}']
