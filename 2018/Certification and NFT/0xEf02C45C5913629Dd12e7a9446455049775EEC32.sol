['pragma solidity ^0.4.8;\n', '\n', 'contract RuletkaIo {\n', '    \n', '    /*** EVENTS ***/\n', '    \n', '    /// @dev A russian Roulette has been executed between 6 players\n', '    /// in room roomId and unfortunately, victim got shot and didn&#39;t \n', '    /// make it out alive... RIP\n', '    event partyOver(uint256 roomId, address victim, address[] winners);\n', '\n', '    /// @dev A new player has enter a room\n', '    event newPlayer(uint256 roomId, address player);\n', '    \n', '    /// @dev A room is full, we close the door. Game can start.\n', '    event fullRoom(uint256 roomId);\n', '    \n', '    /// @dev A safety mechanism has been triggered to empty the room and refund entirely the players (Should never happen)\n', '    event  roomRefunded(uint256 _roomId, address[] refundedPlayers);\n', '\n', '    /*** Founders addresses ***/\n', '    address CTO;\n', '    address CEO;\n', '    \n', '     Room[] private allRooms;\n', '\n', '    function () public payable {} // Give the ability of receiving ether\n', '\n', '    function RuletkaIo() public {\n', '        CTO = msg.sender;\n', '        CEO = msg.sender;\n', '    }\n', '    \n', '    /*** ACCESS MODIFIERS ***/\n', '    /// @dev Access modifier for CTO-only functionality\n', '    modifier onlyCTO() {\n', '        require(msg.sender == CTO);\n', '        _;\n', '    }\n', '    \n', '    /// @dev Assigns a new address to act as the CTO.\n', '    /// @param _newCTO The address of the new CTO\n', '    function setCTO(address _newCTO) public onlyCTO {\n', '        require(_newCTO != address(0));\n', '        CTO = _newCTO;\n', '    }\n', '    \n', '    /// @dev Assigns a new address to act as the CEO.\n', '    /// @param _newCEO The address of the new CEO\n', '    function setCEO(address _newCEO) public onlyCTO {\n', '        require(_newCEO != address(0));\n', '        CEO = _newCEO;\n', '    }\n', '    \n', '    /*** DATATYPES ***/\n', '      struct Room {\n', '        string name;\n', '        uint256 entryPrice; //  The price to enter the room and play Russian Roulette\n', '        uint256 balance;\n', '        address[] players;\n', '      }\n', '    \n', '    \n', '    /// For creating Room\n', '  function createRoom(string _name, uint256 _entryPrice) public onlyCTO{\n', '    address[] memory players;\n', '    Room memory _room = Room({\n', '      name: _name,\n', '      players: players,\n', '      balance: 0,\n', '      entryPrice: _entryPrice\n', '    });\n', '\n', '    allRooms.push(_room);\n', '  }\n', '    \n', '    function enter(uint256 _roomId) public payable {\n', '        Room storage room = allRooms[_roomId-1]; //if _roomId doesn&#39;t exist in array, exits.\n', '        \n', '        require(room.players.length < 6);\n', '        require(msg.value >= room.entryPrice);\n', '        \n', '        room.players.push(msg.sender);\n', '        room.balance += room.entryPrice;\n', '        \n', '        emit newPlayer(_roomId, msg.sender);\n', '        \n', '        if(room.players.length == 6){\n', '            executeRoom(_roomId);\n', '        }\n', '    }\n', '    \n', '    function enterWithReferral(uint256 _roomId, address referrer) public payable {\n', '        \n', '        Room storage room = allRooms[_roomId-1]; //if _roomId doesn&#39;t exist in array, exits.\n', '        \n', '        require(room.players.length < 6);\n', '        require(msg.value >= room.entryPrice);\n', '        \n', '        uint256 referrerCut = SafeMath.div(room.entryPrice, 100); // Referrer get one percent of the bet as reward\n', '        referrer.transfer(referrerCut);\n', '         \n', '        room.players.push(msg.sender);\n', '        room.balance += room.entryPrice - referrerCut;\n', '        \n', '        emit newPlayer(_roomId, msg.sender);\n', '        \n', '        if(room.players.length == 6){\n', '            emit fullRoom(_roomId);\n', '            executeRoom(_roomId);\n', '        }\n', '    }\n', '    \n', '    function executeRoom(uint256 _roomId) public {\n', '        \n', '        Room storage room = allRooms[_roomId-1]; //if _roomId doesn&#39;t exist in array, exits.\n', '        \n', '        //Check if the room is really full before shooting people...\n', '        require(room.players.length == 6);\n', '        \n', '        uint256 halfFee = SafeMath.div(room.entryPrice, 20);\n', '        CTO.transfer(halfFee);\n', '        CEO.transfer(halfFee);\n', '        room.balance -= halfFee * 2;\n', '        \n', '        uint256 deadSeat = random();\n', '        \n', '        distributeFunds(_roomId, deadSeat);\n', '        \n', '        delete room.players;\n', '    }\n', '    \n', '    function distributeFunds(uint256 _roomId, uint256 _deadSeat) private returns(uint256) {\n', '        \n', '        Room storage room = allRooms[_roomId-1]; //if _roomId doesn&#39;t exist in array, exits.\n', '        uint256 balanceToDistribute = SafeMath.div(room.balance,5);\n', '        \n', '        address victim = room.players[_deadSeat];\n', '        address[] memory winners = new address[](5);\n', '        uint256 j = 0; \n', '        for (uint i = 0; i<6; i++) {\n', '            if(i != _deadSeat){\n', '               room.players[i].transfer(balanceToDistribute);\n', '               room.balance -= balanceToDistribute;\n', '               winners[j] = room.players[i];\n', '               j++;\n', '            }\n', '        }\n', '        \n', '        emit partyOver(_roomId, victim, winners);\n', '       \n', '        return address(this).balance;\n', '    }\n', '    \n', '     /// @dev Empty the room and refund each player. Safety mechanism which shouldn&#39;t be used.\n', '    /// @param _roomId The Room id to empty and refund\n', '    function refundPlayersInRoom(uint256 _roomId) public onlyCTO{\n', '        Room storage room = allRooms[_roomId-1]; //if _roomId doesn&#39;t exist in array, exits.\n', '        uint256 nbrOfPlayers = room.players.length;\n', '        uint256 balanceToRefund = SafeMath.div(room.balance,nbrOfPlayers);\n', '        for (uint i = 0; i<nbrOfPlayers; i++) {\n', '             room.players[i].transfer(balanceToRefund);\n', '             room.balance -= balanceToRefund;\n', '        }\n', '        \n', '        emit roomRefunded(_roomId, room.players);\n', '        delete room.players;\n', '    }\n', '    \n', '    \n', '    /// @dev A clean and efficient way to generate random and make sure that it\n', '    /// will remain the same accross the executing nodes of random value \n', '    /// Ethereum Blockchain. We base our computation on the block.timestamp\n', '    /// and difficulty which will remain the same accross the nodes to ensure\n', '    /// same result for the same execution.\n', '    function random() private view returns (uint256) {\n', '        return uint256(uint256(keccak256(block.timestamp, block.difficulty))%6);\n', '    }\n', '    \n', '    function getRoom(uint256 _roomId) public view returns (\n', '    string name,\n', '    address[] players,\n', '    uint256 entryPrice,\n', '    uint256 balance\n', '  ) {\n', '    Room storage room = allRooms[_roomId-1];\n', '    name = room.name;\n', '    players = room.players;\n', '    entryPrice = room.entryPrice;\n', '    balance = room.balance;\n', '  }\n', '  \n', '  function payout(address _to) public onlyCTO {\n', '    _payout(_to);\n', '  }\n', '\n', '  /// For paying out balance on contract\n', '  function _payout(address _to) private {\n', '    if (_to == address(0)) {\n', '      CTO.transfer(SafeMath.div(address(this).balance, 2));\n', '      CEO.transfer(address(this).balance);\n', '    } else {\n', '      _to.transfer(address(this).balance);\n', '    }\n', '  }\n', '  \n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']