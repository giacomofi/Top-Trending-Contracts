['pragma solidity ^0.4.23;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    require(c / a == b, "Overflow - Multiplication");\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a, "Underflow - Subtraction");\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    require(c >= a, "Overflow - Addition");\n', '    return c;\n', '  }\n', '}\n', '\n', 'library Contract {\n', '\n', '  using SafeMath for uint;\n', '\n', '  // Modifiers: //\n', '\n', '  // Runs two functions before and after a function -\n', '  modifier conditions(function () pure first, function () pure last) {\n', '    first();\n', '    _;\n', '    last();\n', '  }\n', '\n', '  bytes32 internal constant EXEC_PERMISSIONS = keccak256(&#39;script_exec_permissions&#39;);\n', '\n', '  // Sets up contract execution - reads execution id and sender from storage and\n', '  // places in memory, creating getters. Calling this function should be the first\n', '  // action an application does as part of execution, as it sets up memory for\n', '  // execution. Additionally, application functions in the main file should be\n', '  // external, so that memory is not touched prior to calling this function.\n', '  // The 3rd slot allocated will hold a pointer to a storage buffer, which will\n', '  // be reverted to abstract storage to store data, emit events, and forward\n', '  // wei on behalf of the application.\n', '  function authorize(address _script_exec) internal view {\n', '    // Initialize memory\n', '    initialize();\n', '\n', '    // Check that the sender is authorized as a script exec contract for this exec id\n', '    bytes32 perms = EXEC_PERMISSIONS;\n', '    bool authorized;\n', '    assembly {\n', '      // Place the script exec address at 0, and the exec permissions seed after it\n', '      mstore(0, _script_exec)\n', '      mstore(0x20, perms)\n', '      // Hash the resulting 0x34 bytes, and place back into memory at 0\n', '      mstore(0, keccak256(0x0c, 0x34))\n', '      // Place the exec id after the hash -\n', '      mstore(0x20, mload(0x80))\n', '      // Hash the previous hash with the execution id, and check the result\n', '      authorized := sload(keccak256(0, 0x40))\n', '    }\n', '    if (!authorized)\n', '      revert("Sender is not authorized as a script exec address");\n', '  }\n', '\n', '  // Sets up contract execution when initializing an instance of the application\n', '  // First, reads execution id and sender from storage (execution id should be 0xDEAD),\n', '  // then places them in memory, creating getters. Calling this function should be the first\n', '  // action an application does as part of execution, as it sets up memory for\n', '  // execution. Additionally, application functions in the main file should be\n', '  // external, so that memory is not touched prior to calling this function.\n', '  // The 3rd slot allocated will hold a pointer to a storage buffer, which will\n', '  // be reverted to abstract storage to store data, emit events, and forward\n', '  // wei on behalf of the application.\n', '  function initialize() internal view {\n', '    // No memory should have been allocated yet - expect the free memory pointer\n', '    // to point to 0x80 - and throw if it does not\n', '    require(freeMem() == 0x80, "Memory allocated prior to execution");\n', '    // Next, set up memory for execution\n', '    assembly {\n', '      mstore(0x80, sload(0))     // Execution id, read from storage\n', '      mstore(0xa0, sload(1))     // Original sender address, read from storage\n', '      mstore(0xc0, 0)            // Pointer to storage buffer\n', '      mstore(0xe0, 0)            // Bytes4 value of the current action requestor being used\n', '      mstore(0x100, 0)           // Enum representing the next type of function to be called (when pushing to buffer)\n', '      mstore(0x120, 0)           // Number of storage slots written to in buffer\n', '      mstore(0x140, 0)           // Number of events pushed to buffer\n', '      mstore(0x160, 0)           // Number of payment destinations pushed to buffer\n', '\n', '      // Update free memory pointer -\n', '      mstore(0x40, 0x180)\n', '    }\n', '    // Ensure that the sender and execution id returned from storage are expected values -\n', '    assert(execID() != bytes32(0) && sender() != address(0));\n', '  }\n', '\n', '  // Calls the passed-in function, performing a memory state check before and after the check\n', '  // is executed.\n', '  function checks(function () view _check) conditions(validState, validState) internal view {\n', '    _check();\n', '  }\n', '\n', '  // Calls the passed-in function, performing a memory state check before and after the check\n', '  // is executed.\n', '  function checks(function () pure _check) conditions(validState, validState) internal pure {\n', '    _check();\n', '  }\n', '\n', '  // Ensures execution completed successfully, and reverts the created storage buffer\n', '  // back to the sender.\n', '  function commit() conditions(validState, none) internal pure {\n', '    // Check value of storage buffer pointer - should be at least 0x180\n', '    bytes32 ptr = buffPtr();\n', '    require(ptr >= 0x180, "Invalid buffer pointer");\n', '\n', '    assembly {\n', '      // Get the size of the buffer\n', '      let size := mload(add(0x20, ptr))\n', '      mstore(ptr, 0x20) // Place dynamic data offset before buffer\n', '      // Revert to storage\n', '      revert(ptr, add(0x40, size))\n', '    }\n', '  }\n', '\n', '  // Helpers: //\n', '\n', '  // Checks to ensure the application was correctly executed -\n', '  function validState() private pure {\n', '    if (freeMem() < 0x180)\n', '      revert(&#39;Expected Contract.execute()&#39;);\n', '\n', '    if (buffPtr() != 0 && buffPtr() < 0x180)\n', '      revert(&#39;Invalid buffer pointer&#39;);\n', '\n', '    assert(execID() != bytes32(0) && sender() != address(0));\n', '  }\n', '\n', '  // Returns a pointer to the execution storage buffer -\n', '  function buffPtr() private pure returns (bytes32 ptr) {\n', '    assembly { ptr := mload(0xc0) }\n', '  }\n', '\n', '  // Returns the location pointed to by the free memory pointer -\n', '  function freeMem() private pure returns (bytes32 ptr) {\n', '    assembly { ptr := mload(0x40) }\n', '  }\n', '\n', '  // Returns the current storage action\n', '  function currentAction() private pure returns (bytes4 action) {\n', '    if (buffPtr() == bytes32(0))\n', '      return bytes4(0);\n', '\n', '    assembly { action := mload(0xe0) }\n', '  }\n', '\n', '  // If the current action is not storing, reverts\n', '  function isStoring() private pure {\n', '    if (currentAction() != STORES)\n', '      revert(&#39;Invalid current action - expected STORES&#39;);\n', '  }\n', '\n', '  // If the current action is not emitting, reverts\n', '  function isEmitting() private pure {\n', '    if (currentAction() != EMITS)\n', '      revert(&#39;Invalid current action - expected EMITS&#39;);\n', '  }\n', '\n', '  // If the current action is not paying, reverts\n', '  function isPaying() private pure {\n', '    if (currentAction() != PAYS)\n', '      revert(&#39;Invalid current action - expected PAYS&#39;);\n', '  }\n', '\n', '  // Initializes a storage buffer in memory -\n', '  function startBuffer() private pure {\n', '    assembly {\n', '      // Get a pointer to free memory, and place at 0xc0 (storage buffer pointer)\n', '      let ptr := msize()\n', '      mstore(0xc0, ptr)\n', '      // Clear bytes at pointer -\n', '      mstore(ptr, 0)            // temp ptr\n', '      mstore(add(0x20, ptr), 0) // buffer length\n', '      // Update free memory pointer -\n', '      mstore(0x40, add(0x40, ptr))\n', '      // Set expected next function to &#39;NONE&#39; -\n', '      mstore(0x100, 1)\n', '    }\n', '  }\n', '\n', '  // Checks whether or not it is valid to create a STORES action request -\n', '  function validStoreBuff() private pure {\n', '    // Get pointer to current buffer - if zero, create a new buffer -\n', '    if (buffPtr() == bytes32(0))\n', '      startBuffer();\n', '\n', '    // Ensure that the current action is not &#39;storing&#39;, and that the buffer has not already\n', '    // completed a STORES action -\n', '    if (stored() != 0 || currentAction() == STORES)\n', '      revert(&#39;Duplicate request - stores&#39;);\n', '  }\n', '\n', '  // Checks whether or not it is valid to create an EMITS action request -\n', '  function validEmitBuff() private pure {\n', '    // Get pointer to current buffer - if zero, create a new buffer -\n', '    if (buffPtr() == bytes32(0))\n', '      startBuffer();\n', '\n', '    // Ensure that the current action is not &#39;emitting&#39;, and that the buffer has not already\n', '    // completed an EMITS action -\n', '    if (emitted() != 0 || currentAction() == EMITS)\n', '      revert(&#39;Duplicate request - emits&#39;);\n', '  }\n', '\n', '  // Checks whether or not it is valid to create a PAYS action request -\n', '  function validPayBuff() private pure {\n', '    // Get pointer to current buffer - if zero, create a new buffer -\n', '    if (buffPtr() == bytes32(0))\n', '      startBuffer();\n', '\n', '    // Ensure that the current action is not &#39;paying&#39;, and that the buffer has not already\n', '    // completed an PAYS action -\n', '    if (paid() != 0 || currentAction() == PAYS)\n', '      revert(&#39;Duplicate request - pays&#39;);\n', '  }\n', '\n', '  // Placeholder function when no pre or post condition for a function is needed\n', '  function none() private pure { }\n', '\n', '  // Runtime getters: //\n', '\n', '  // Returns the execution id from memory -\n', '  function execID() internal pure returns (bytes32 exec_id) {\n', '    assembly { exec_id := mload(0x80) }\n', '    require(exec_id != bytes32(0), "Execution id overwritten, or not read");\n', '  }\n', '\n', '  // Returns the original sender from memory -\n', '  function sender() internal pure returns (address addr) {\n', '    assembly { addr := mload(0xa0) }\n', '    require(addr != address(0), "Sender address overwritten, or not read");\n', '  }\n', '\n', '  // Reading from storage: //\n', '\n', '  // Reads from storage, resolving the passed-in location to its true location in storage\n', '  // by hashing with the exec id. Returns the data read from that location\n', '  function read(bytes32 _location) internal view returns (bytes32 data) {\n', '    data = keccak256(_location, execID());\n', '    assembly { data := sload(data) }\n', '  }\n', '\n', '  // Storing data, emitting events, and forwarding payments: //\n', '\n', '  bytes4 internal constant EMITS = bytes4(keccak256(&#39;Emit((bytes32[],bytes)[])&#39;));\n', '  bytes4 internal constant STORES = bytes4(keccak256(&#39;Store(bytes32[])&#39;));\n', '  bytes4 internal constant PAYS = bytes4(keccak256(&#39;Pay(bytes32[])&#39;));\n', '  bytes4 internal constant THROWS = bytes4(keccak256(&#39;Error(string)&#39;));\n', '\n', '  // Function enums -\n', '  enum NextFunction {\n', '    INVALID, NONE, STORE_DEST, VAL_SET, VAL_INC, VAL_DEC, EMIT_LOG, PAY_DEST, PAY_AMT\n', '  }\n', '\n', '  // Checks that a call pushing a storage destination to the buffer is expected and valid\n', '  function validStoreDest() private pure {\n', '    // Ensure that the next function expected pushes a storage destination -\n', '    if (expected() != NextFunction.STORE_DEST)\n', '      revert(&#39;Unexpected function order - expected storage destination to be pushed&#39;);\n', '\n', '    // Ensure that the current buffer is pushing STORES actions -\n', '    isStoring();\n', '  }\n', '\n', '  // Checks that a call pushing a storage value to the buffer is expected and valid\n', '  function validStoreVal() private pure {\n', '    // Ensure that the next function expected pushes a storage value -\n', '    if (\n', '      expected() != NextFunction.VAL_SET &&\n', '      expected() != NextFunction.VAL_INC &&\n', '      expected() != NextFunction.VAL_DEC\n', '    ) revert(&#39;Unexpected function order - expected storage value to be pushed&#39;);\n', '\n', '    // Ensure that the current buffer is pushing STORES actions -\n', '    isStoring();\n', '  }\n', '\n', '  // Checks that a call pushing a payment destination to the buffer is expected and valid\n', '  function validPayDest() private pure {\n', '    // Ensure that the next function expected pushes a payment destination -\n', '    if (expected() != NextFunction.PAY_DEST)\n', '      revert(&#39;Unexpected function order - expected payment destination to be pushed&#39;);\n', '\n', '    // Ensure that the current buffer is pushing PAYS actions -\n', '    isPaying();\n', '  }\n', '\n', '  // Checks that a call pushing a payment amount to the buffer is expected and valid\n', '  function validPayAmt() private pure {\n', '    // Ensure that the next function expected pushes a payment amount -\n', '    if (expected() != NextFunction.PAY_AMT)\n', '      revert(&#39;Unexpected function order - expected payment amount to be pushed&#39;);\n', '\n', '    // Ensure that the current buffer is pushing PAYS actions -\n', '    isPaying();\n', '  }\n', '\n', '  // Checks that a call pushing an event to the buffer is expected and valid\n', '  function validEvent() private pure {\n', '    // Ensure that the next function expected pushes an event -\n', '    if (expected() != NextFunction.EMIT_LOG)\n', '      revert(&#39;Unexpected function order - expected event to be pushed&#39;);\n', '\n', '    // Ensure that the current buffer is pushing EMITS actions -\n', '    isEmitting();\n', '  }\n', '\n', '  // Begins creating a storage buffer - values and locations pushed will be committed\n', '  // to storage at the end of execution\n', '  function storing() conditions(validStoreBuff, isStoring) internal pure {\n', '    bytes4 action_req = STORES;\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push requestor to the end of buffer, as well as to the &#39;current action&#39; slot -\n', '      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n', '      // Push &#39;0&#39; to the end of the 4 bytes just pushed - this will be the length of the STORES action\n', '      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n', '      // Increment buffer length - 0x24 plus the previous length\n', '      mstore(ptr, add(0x24, mload(ptr)))\n', '      // Set the current action being executed (STORES) -\n', '      mstore(0xe0, action_req)\n', '      // Set the expected next function - STORE_DEST\n', '      mstore(0x100, 2)\n', '      // Set a pointer to the length of the current request within the buffer\n', '      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '  }\n', '\n', '  // Sets a passed in location to a value passed in via &#39;to&#39;\n', '  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push storage destination to the end of the buffer -\n', '      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n', '      // Increment buffer length - 0x20 plus the previous length\n', '      mstore(ptr, add(0x20, mload(ptr)))\n', '      // Set the expected next function - VAL_SET\n', '      mstore(0x100, 3)\n', '      // Increment STORES action length -\n', '      mstore(\n', '        mload(sub(ptr, 0x20)),\n', '        add(1, mload(mload(sub(ptr, 0x20))))\n', '      )\n', '      // Update number of storage slots pushed to -\n', '      mstore(0x120, add(1, mload(0x120)))\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '    return _field;\n', '  }\n', '\n', '  // Sets a previously-passed-in destination in storage to the value\n', '  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push storage value to the end of the buffer -\n', '      mstore(add(0x20, add(ptr, mload(ptr))), _val)\n', '      // Increment buffer length - 0x20 plus the previous length\n', '      mstore(ptr, add(0x20, mload(ptr)))\n', '      // Set the expected next function - STORE_DEST\n', '      mstore(0x100, 2)\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '  }\n', '\n', '  // Sets a previously-passed-in destination in storage to the value\n', '  function to(bytes32 _field, uint _val) internal pure {\n', '    to(_field, bytes32(_val));\n', '  }\n', '\n', '  // Sets a previously-passed-in destination in storage to the value\n', '  function to(bytes32 _field, address _val) internal pure {\n', '    to(_field, bytes32(_val));\n', '  }\n', '\n', '  // Sets a previously-passed-in destination in storage to the value\n', '  function to(bytes32 _field, bool _val) internal pure {\n', '    to(\n', '      _field,\n', '      _val ? bytes32(1) : bytes32(0)\n', '    );\n', '  }\n', '\n', '  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n', '    // Read value stored at the location in storage -\n', '    val = keccak256(_field, execID());\n', '    assembly {\n', '      val := sload(val)\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push storage destination to the end of the buffer -\n', '      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n', '      // Increment buffer length - 0x20 plus the previous length\n', '      mstore(ptr, add(0x20, mload(ptr)))\n', '      // Set the expected next function - VAL_INC\n', '      mstore(0x100, 4)\n', '      // Increment STORES action length -\n', '      mstore(\n', '        mload(sub(ptr, 0x20)),\n', '        add(1, mload(mload(sub(ptr, 0x20))))\n', '      )\n', '      // Update number of storage slots pushed to -\n', '      mstore(0x120, add(1, mload(0x120)))\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '    return val;\n', '  }\n', '\n', '  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\n', '    // Read value stored at the location in storage -\n', '    val = keccak256(_field, execID());\n', '    assembly {\n', '      val := sload(val)\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push storage destination to the end of the buffer -\n', '      mstore(add(0x20, add(ptr, mload(ptr))), _field)\n', '      // Increment buffer length - 0x20 plus the previous length\n', '      mstore(ptr, add(0x20, mload(ptr)))\n', '      // Set the expected next function - VAL_DEC\n', '      mstore(0x100, 5)\n', '      // Increment STORES action length -\n', '      mstore(\n', '        mload(sub(ptr, 0x20)),\n', '        add(1, mload(mload(sub(ptr, 0x20))))\n', '      )\n', '      // Update number of storage slots pushed to -\n', '      mstore(0x120, add(1, mload(0x120)))\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '    return val;\n', '  }\n', '\n', '  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n', '    // Check the expected function type - if it is VAL_INC, perform safe-add on the value\n', '    // If it is VAL_DEC, perform safe-sub on the value\n', '    if (expected() == NextFunction.VAL_INC)\n', '      _amt = _amt.add(uint(_val));\n', '    else if (expected() == NextFunction.VAL_DEC)\n', '      _amt = uint(_val).sub(_amt);\n', '    else\n', '      revert(&#39;Expected VAL_INC or VAL_DEC&#39;);\n', '\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push storage value to the end of the buffer -\n', '      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n', '      // Increment buffer length - 0x20 plus the previous length\n', '      mstore(ptr, add(0x20, mload(ptr)))\n', '      // Set the expected next function - STORE_DEST\n', '      mstore(0x100, 2)\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '  }\n', '\n', '  // Decreases the value at some field by a maximum amount, and sets it to 0 if there will be underflow\n', '  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\n', '    // Check the expected function type - if it is VAL_DEC, set the new amount to the difference of\n', '    // _val and _amt, to a minimum of 0\n', '    if (expected() == NextFunction.VAL_DEC) {\n', '      if (_amt >= uint(_val))\n', '        _amt = 0;\n', '      else\n', '        _amt = uint(_val).sub(_amt);\n', '    } else {\n', '      revert(&#39;Expected VAL_DEC&#39;);\n', '    }\n', '\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push storage value to the end of the buffer -\n', '      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\n', '      // Increment buffer length - 0x20 plus the previous length\n', '      mstore(ptr, add(0x20, mload(ptr)))\n', '      // Set the expected next function - STORE_DEST\n', '      mstore(0x100, 2)\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '  }\n', '\n', '  // Begins creating an event log buffer - topics and data pushed will be emitted by\n', '  // storage at the end of execution\n', '  function emitting() conditions(validEmitBuff, isEmitting) internal pure {\n', '    bytes4 action_req = EMITS;\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push requestor to the end of buffer, as well as to the &#39;current action&#39; slot -\n', '      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n', '      // Push &#39;0&#39; to the end of the 4 bytes just pushed - this will be the length of the EMITS action\n', '      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n', '      // Increment buffer length - 0x24 plus the previous length\n', '      mstore(ptr, add(0x24, mload(ptr)))\n', '      // Set the current action being executed (EMITS) -\n', '      mstore(0xe0, action_req)\n', '      // Set the expected next function - EMIT_LOG\n', '      mstore(0x100, 6)\n', '      // Set a pointer to the length of the current request within the buffer\n', '      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '  }\n', '\n', '  function log(bytes32 _data) conditions(validEvent, validEvent) internal pure {\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push 0 to the end of the buffer - event will have 0 topics\n', '      mstore(add(0x20, add(ptr, mload(ptr))), 0)\n', '      // If _data is zero, set data size to 0 in buffer and push -\n', '      if eq(_data, 0) {\n', '        mstore(add(0x40, add(ptr, mload(ptr))), 0)\n', '        // Increment buffer length - 0x40 plus the original length\n', '        mstore(ptr, add(0x40, mload(ptr)))\n', '      }\n', '      // If _data is not zero, set size to 0x20 and push to buffer -\n', '      if iszero(eq(_data, 0)) {\n', '        // Push data size (0x20) to the end of the buffer\n', '        mstore(add(0x40, add(ptr, mload(ptr))), 0x20)\n', '        // Push data to the end of the buffer\n', '        mstore(add(0x60, add(ptr, mload(ptr))), _data)\n', '        // Increment buffer length - 0x60 plus the original length\n', '        mstore(ptr, add(0x60, mload(ptr)))\n', '      }\n', '      // Increment EMITS action length -\n', '      mstore(\n', '        mload(sub(ptr, 0x20)),\n', '        add(1, mload(mload(sub(ptr, 0x20))))\n', '      )\n', '      // Update number of events pushed to buffer -\n', '      mstore(0x140, add(1, mload(0x140)))\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '  }\n', '\n', '  function log(bytes32[1] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push 1 to the end of the buffer - event will have 1 topic\n', '      mstore(add(0x20, add(ptr, mload(ptr))), 1)\n', '      // Push topic to end of buffer\n', '      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n', '      // If _data is zero, set data size to 0 in buffer and push -\n', '      if eq(_data, 0) {\n', '        mstore(add(0x60, add(ptr, mload(ptr))), 0)\n', '        // Increment buffer length - 0x60 plus the original length\n', '        mstore(ptr, add(0x60, mload(ptr)))\n', '      }\n', '      // If _data is not zero, set size to 0x20 and push to buffer -\n', '      if iszero(eq(_data, 0)) {\n', '        // Push data size (0x20) to the end of the buffer\n', '        mstore(add(0x60, add(ptr, mload(ptr))), 0x20)\n', '        // Push data to the end of the buffer\n', '        mstore(add(0x80, add(ptr, mload(ptr))), _data)\n', '        // Increment buffer length - 0x80 plus the original length\n', '        mstore(ptr, add(0x80, mload(ptr)))\n', '      }\n', '      // Increment EMITS action length -\n', '      mstore(\n', '        mload(sub(ptr, 0x20)),\n', '        add(1, mload(mload(sub(ptr, 0x20))))\n', '      )\n', '      // Update number of events pushed to buffer -\n', '      mstore(0x140, add(1, mload(0x140)))\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '  }\n', '\n', '  function log(bytes32[2] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push 2 to the end of the buffer - event will have 2 topics\n', '      mstore(add(0x20, add(ptr, mload(ptr))), 2)\n', '      // Push topics to end of buffer\n', '      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n', '      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n', '      // If _data is zero, set data size to 0 in buffer and push -\n', '      if eq(_data, 0) {\n', '        mstore(add(0x80, add(ptr, mload(ptr))), 0)\n', '        // Increment buffer length - 0x80 plus the original length\n', '        mstore(ptr, add(0x80, mload(ptr)))\n', '      }\n', '      // If _data is not zero, set size to 0x20 and push to buffer -\n', '      if iszero(eq(_data, 0)) {\n', '        // Push data size (0x20) to the end of the buffer\n', '        mstore(add(0x80, add(ptr, mload(ptr))), 0x20)\n', '        // Push data to the end of the buffer\n', '        mstore(add(0xa0, add(ptr, mload(ptr))), _data)\n', '        // Increment buffer length - 0xa0 plus the original length\n', '        mstore(ptr, add(0xa0, mload(ptr)))\n', '      }\n', '      // Increment EMITS action length -\n', '      mstore(\n', '        mload(sub(ptr, 0x20)),\n', '        add(1, mload(mload(sub(ptr, 0x20))))\n', '      )\n', '      // Update number of events pushed to buffer -\n', '      mstore(0x140, add(1, mload(0x140)))\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '  }\n', '\n', '  function log(bytes32[3] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push 3 to the end of the buffer - event will have 3 topics\n', '      mstore(add(0x20, add(ptr, mload(ptr))), 3)\n', '      // Push topics to end of buffer\n', '      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n', '      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n', '      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n', '      // If _data is zero, set data size to 0 in buffer and push -\n', '      if eq(_data, 0) {\n', '        mstore(add(0xa0, add(ptr, mload(ptr))), 0)\n', '        // Increment buffer length - 0xa0 plus the original length\n', '        mstore(ptr, add(0xa0, mload(ptr)))\n', '      }\n', '      // If _data is not zero, set size to 0x20 and push to buffer -\n', '      if iszero(eq(_data, 0)) {\n', '        // Push data size (0x20) to the end of the buffer\n', '        mstore(add(0xa0, add(ptr, mload(ptr))), 0x20)\n', '        // Push data to the end of the buffer\n', '        mstore(add(0xc0, add(ptr, mload(ptr))), _data)\n', '        // Increment buffer length - 0xc0 plus the original length\n', '        mstore(ptr, add(0xc0, mload(ptr)))\n', '      }\n', '      // Increment EMITS action length -\n', '      mstore(\n', '        mload(sub(ptr, 0x20)),\n', '        add(1, mload(mload(sub(ptr, 0x20))))\n', '      )\n', '      // Update number of events pushed to buffer -\n', '      mstore(0x140, add(1, mload(0x140)))\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '  }\n', '\n', '  function log(bytes32[4] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push 4 to the end of the buffer - event will have 4 topics\n', '      mstore(add(0x20, add(ptr, mload(ptr))), 4)\n', '      // Push topics to end of buffer\n', '      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\n', '      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\n', '      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\n', '      mstore(add(0xa0, add(ptr, mload(ptr))), mload(add(0x60, _topics)))\n', '      // If _data is zero, set data size to 0 in buffer and push -\n', '      if eq(_data, 0) {\n', '        mstore(add(0xc0, add(ptr, mload(ptr))), 0)\n', '        // Increment buffer length - 0xc0 plus the original length\n', '        mstore(ptr, add(0xc0, mload(ptr)))\n', '      }\n', '      // If _data is not zero, set size to 0x20 and push to buffer -\n', '      if iszero(eq(_data, 0)) {\n', '        // Push data size (0x20) to the end of the buffer\n', '        mstore(add(0xc0, add(ptr, mload(ptr))), 0x20)\n', '        // Push data to the end of the buffer\n', '        mstore(add(0xe0, add(ptr, mload(ptr))), _data)\n', '        // Increment buffer length - 0xe0 plus the original length\n', '        mstore(ptr, add(0xe0, mload(ptr)))\n', '      }\n', '      // Increment EMITS action length -\n', '      mstore(\n', '        mload(sub(ptr, 0x20)),\n', '        add(1, mload(mload(sub(ptr, 0x20))))\n', '      )\n', '      // Update number of events pushed to buffer -\n', '      mstore(0x140, add(1, mload(0x140)))\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '  }\n', '\n', '  // Begins creating a storage buffer - destinations entered will be forwarded wei\n', '  // before the end of execution\n', '  function paying() conditions(validPayBuff, isPaying) internal pure {\n', '    bytes4 action_req = PAYS;\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push requestor to the end of buffer, as well as to the &#39;current action&#39; slot -\n', '      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\n', '      // Push &#39;0&#39; to the end of the 4 bytes just pushed - this will be the length of the PAYS action\n', '      mstore(add(0x24, add(ptr, mload(ptr))), 0)\n', '      // Increment buffer length - 0x24 plus the previous length\n', '      mstore(ptr, add(0x24, mload(ptr)))\n', '      // Set the current action being executed (PAYS) -\n', '      mstore(0xe0, action_req)\n', '      // Set the expected next function - PAY_AMT\n', '      mstore(0x100, 8)\n', '      // Set a pointer to the length of the current request within the buffer\n', '      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '  }\n', '\n', '  // Pushes an amount of wei to forward to the buffer\n', '  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push payment amount to the end of the buffer -\n', '      mstore(add(0x20, add(ptr, mload(ptr))), _amount)\n', '      // Increment buffer length - 0x20 plus the previous length\n', '      mstore(ptr, add(0x20, mload(ptr)))\n', '      // Set the expected next function - PAY_DEST\n', '      mstore(0x100, 7)\n', '      // Increment PAYS action length -\n', '      mstore(\n', '        mload(sub(ptr, 0x20)),\n', '        add(1, mload(mload(sub(ptr, 0x20))))\n', '      )\n', '      // Update number of payment destinations to be pushed to -\n', '      mstore(0x160, add(1, mload(0x160)))\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '    return _amount;\n', '  }\n', '\n', '  // Push an address to forward wei to, to the buffer\n', '  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\n', '    assembly {\n', '      // Get pointer to buffer length -\n', '      let ptr := add(0x20, mload(0xc0))\n', '      // Push payment destination to the end of the buffer -\n', '      mstore(add(0x20, add(ptr, mload(ptr))), _dest)\n', '      // Increment buffer length - 0x20 plus the previous length\n', '      mstore(ptr, add(0x20, mload(ptr)))\n', '      // Set the expected next function - PAY_AMT\n', '      mstore(0x100, 8)\n', '    }\n', '    // Update free memory pointer\n', '    setFreeMem();\n', '  }\n', '\n', '  // Sets the free memory pointer to point beyond all accessed memory\n', '  function setFreeMem() private pure {\n', '    assembly { mstore(0x40, msize) }\n', '  }\n', '\n', '  // Returns the enum representing the next expected function to be called -\n', '  function expected() private pure returns (NextFunction next) {\n', '    assembly { next := mload(0x100) }\n', '  }\n', '\n', '  // Returns the number of events pushed to the storage buffer -\n', '  function emitted() internal pure returns (uint num_emitted) {\n', '    if (buffPtr() == bytes32(0))\n', '      return 0;\n', '\n', '    // Load number emitted from buffer -\n', '    assembly { num_emitted := mload(0x140) }\n', '  }\n', '\n', '  // Returns the number of storage slots pushed to the storage buffer -\n', '  function stored() internal pure returns (uint num_stored) {\n', '    if (buffPtr() == bytes32(0))\n', '      return 0;\n', '\n', '    // Load number stored from buffer -\n', '    assembly { num_stored := mload(0x120) }\n', '  }\n', '\n', '  // Returns the number of payment destinations and amounts pushed to the storage buffer -\n', '  function paid() internal pure returns (uint num_paid) {\n', '    if (buffPtr() == bytes32(0))\n', '      return 0;\n', '\n', '    // Load number paid from buffer -\n', '    assembly { num_paid := mload(0x160) }\n', '  }\n', '}\n', '\n', 'library Purchase {\n', '\n', '  using Contract for *;\n', '  using SafeMath for uint;\n', '\n', '  // event Purchase(bytes32 indexed exec_id, uint256 indexed current_rate, uint256 indexed current_time, uint256 tokens)\n', '  bytes32 internal constant BUY_SIG = keccak256(&#39;Purchase(bytes32,uint256,uint256,uint256)&#39;);\n', '\n', '  // Returns the event topics for a &#39;Purchase&#39; event -\n', '  function PURCHASE(bytes32 _exec_id, uint _current_rate) private view returns (bytes32[4] memory)\n', '    { return [BUY_SIG, _exec_id, bytes32(_current_rate), bytes32(now)]; }\n', '\n', '  // Implements the logic to create the storage buffer for a Crowdsale Purchase\n', '  function buy() internal view {\n', '    bool sale_is_whitelisted = Contract.read(Sale.isWhitelisted()) != 0 ? true : false;\n', '    bool sender_has_contributed = Contract.read(Sale.hasContributed(Contract.sender())) != 0 ? true : false;\n', '\n', '    // Calculate current sale rate from start time, start and end rates, and duration\n', '  \tuint current_rate = getCurrentRate(\n', '  \t  uint(Contract.read(Sale.startTime())),\n', '  \t  uint(Contract.read(Sale.startRate())),\n', '  \t  uint(Contract.read(Sale.endRate())),\n', '  \t  uint(Contract.read(Sale.totalDuration()))\n', '  \t);\n', '\n', '  \t// If sender has already purchased tokens then change minimum contribution amount to 0;\n', '  \tuint min_contribution;\n', '    // If the sale is whitelisted -\n', '    if (sale_is_whitelisted && !sender_has_contributed)\n', '      min_contribution = uint(Contract.read(Sale.whitelistMinTok(Contract.sender())));\n', '    else if (!sale_is_whitelisted && !sender_has_contributed)\n', '      min_contribution = uint(Contract.read(Sale.globalMinPurchaseAmt()));\n', '\n', '  \t// Get total amount of wei that can be spent and number of tokens purchased\n', '  \tuint spend_amount;\n', '  \tuint tokens_purchased;\n', '  \t(spend_amount, tokens_purchased) = getPurchaseInfo(\n', '  \t  uint(Contract.read(Sale.tokenDecimals())),\n', '  \t  current_rate,\n', '  \t  uint(Contract.read(Sale.tokensRemaining())),\n', '  \t  sale_is_whitelisted,\n', '  \t  uint(Contract.read(Sale.whitelistMaxTok(Contract.sender()))),\n', '  \t  min_contribution\n', '  \t);\n', '    // Sanity checks -\n', '    assert(spend_amount != 0 && spend_amount <= msg.value && tokens_purchased != 0);\n', '\n', '    // Set up payment buffer -\n', '    Contract.paying();\n', '    // Forward spent wei to team wallet -\n', '    Contract.pay(spend_amount).toAcc(address(Contract.read(Sale.wallet())));\n', '\n', '    // Move buffer to storing values -\n', '    Contract.storing();\n', '\n', '  \t// Update purchaser&#39;s token balance -\n', '  \tContract.increase(Sale.balances(Contract.sender())).by(tokens_purchased);\n', '\n', '  \t// Update tokens remaining in sale -\n', '  \tContract.decrease(Sale.tokensRemaining()).by(tokens_purchased);\n', '\n', '    // Update total tokens sold -\n', '    Contract.increase(Sale.tokensSold()).by(tokens_purchased);\n', '\n', '  \t// Update total wei raised -\n', '  \tContract.increase(Sale.totalWeiRaised()).by(spend_amount);\n', '\n', '    // If the sender had not previously contributed to the sale,\n', '    // increase unique contributor count and mark the sender as having contributed\n', '  \tif (sender_has_contributed == false) {\n', '  \t  Contract.increase(Sale.contributors()).by(1);\n', '  \t  Contract.set(Sale.hasContributed(Contract.sender())).to(true);\n', '  \t}\n', '\n', '    // If the sale is whitelisted, update the spender&#39;s whitelist information -\n', '\t  if (sale_is_whitelisted) {\n', '\t    Contract.set(Sale.whitelistMinTok(Contract.sender())).to(uint(0));\n', '      Contract.decrease(Sale.whitelistMaxTok(Contract.sender())).by(tokens_purchased);\n', '\t  }\n', '\n', '  \tContract.emitting();\n', '\n', '  \t// Add purchase signature and topics\n', '  \tContract.log(\n', '  \t  PURCHASE(Contract.execID(), current_rate), bytes32(tokens_purchased)\n', '  \t);\n', '  }\n', '\n', '  // Calculate current purchase rate\n', '  function getCurrentRate(uint _start_time,\tuint _start_rate,\tuint _end_rate,\tuint _duration) internal view\n', '  returns (uint current_rate) {\n', '  \t// If the sale has not yet started, set current rate to 0\n', '  \tif (now < _start_time) {\n', '  \t  current_rate = 0;\n', '  \t  return;\n', '  \t}\n', '\n', '  \tuint elapsed = now.sub(_start_time);\n', '  \t// If the sale duration is up, set current rate to 0\n', '  \tif (elapsed >= _duration) {\n', '  \t  current_rate = 0;\n', '  \t  return;\n', '  \t}\n', '\n', '  \t// Add precision to the time elapsed -\n', '  \telapsed = elapsed.mul(10 ** 18);\n', '\n', '  \t// Temporary variable\n', '  \tuint temp_rate = _start_rate.sub(_end_rate).mul(elapsed).div(_duration);\n', '\n', '    // Remove precision\n', '  \ttemp_rate = temp_rate.div(10 ** 18);\n', '\n', '  \t// Current rate is start rate minus temp rate\n', '  \tcurrent_rate = _start_rate.sub(temp_rate);\n', '  }\n', '\n', '  // Calculates amount to spend, amount left able to be spent, and number of tokens purchased\n', '  function getPurchaseInfo(\n', '  \tuint _decimals, uint _current_rate, uint _tokens_remaining,\n', '  \tbool _sale_whitelisted,\tuint _token_spend_remaining, uint _min_purchase_amount\n', '  ) internal view returns (uint spend_amount, uint tokens_purchased) {\n', '  \t// Get amount of wei able to be spent, given the number of tokens remaining -\n', '    if (msg.value.mul(10 ** _decimals).div(_current_rate) > _tokens_remaining)\n', '      spend_amount = _current_rate.mul(_tokens_remaining).div(10 ** _decimals);\n', '    else\n', '      spend_amount = msg.value;\n', '\n', '    // Get number of tokens able to be purchased with the amount spent -\n', '    tokens_purchased = spend_amount.mul(10 ** _decimals).div(_current_rate);\n', '\n', '    // If the sale is whitelisted, adjust purchase size so that it does not go over the user&#39;s max cap -\n', '    if (_sale_whitelisted && tokens_purchased > _token_spend_remaining) {\n', '      tokens_purchased = _token_spend_remaining;\n', '      spend_amount = tokens_purchased.mul(_current_rate).div(10 ** _decimals);\n', '    }\n', '\n', '    // Ensure spend amount is valid -\n', '    if (spend_amount == 0 || spend_amount > msg.value)\n', '      revert("Invalid spend amount");\n', '\n', '    // Ensure amount of tokens to purchase is not greater than the amount of tokens remaining in the sale -\n', '    if (tokens_purchased > _tokens_remaining || tokens_purchased == 0)\n', '      revert("Invalid purchase amount");\n', '\n', '    // Ensure the number of tokens purchased meets the sender&#39;s minimum contribution requirement\n', '    if (tokens_purchased < _min_purchase_amount)\n', '      revert("Purchase is under minimum contribution amount");\n', '  }\n', '}\n', '\n', 'library Sale {\n', '\n', '  using Contract for *;\n', '\n', '  /// SALE ///\n', '\n', '  // Whether the crowdsale and token are configured, and the sale is ready to run\n', '  function isConfigured() internal pure returns (bytes32)\n', '    { return keccak256("sale_is_configured"); }\n', '\n', '  // Whether or not the crowdsale is post-purchase\n', '  function isFinished() internal pure returns (bytes32)\n', '    { return keccak256("sale_is_completed"); }\n', '\n', '  // Storage location of the crowdsale&#39;s start time\n', '  function startTime() internal pure returns (bytes32)\n', '    { return keccak256("sale_start_time"); }\n', '\n', '  // Storage location of the amount of time the crowdsale will take, accounting for all tiers\n', '  function totalDuration() internal pure returns (bytes32)\n', '    { return keccak256("sale_total_duration"); }\n', '\n', '  // Returns the storage location of number of tokens remaining in crowdsale\n', '  function tokensRemaining() internal pure returns (bytes32)\n', '    { return keccak256("sale_tokens_remaining"); }\n', '\n', '  // Returns the storage location of crowdsale&#39;s starting sale rate\n', '  function startRate() internal pure returns (bytes32)\n', '    { return keccak256("sale_start_rate"); }\n', '\n', '  // Returns the storage location of crowdsale&#39;s ending sale rate\n', '  function endRate() internal pure returns (bytes32)\n', '    { return keccak256("sale_end_rate"); }\n', '\n', '  // Storage location of the amount of tokens sold in the crowdsale so far\n', '  function tokensSold() internal pure returns (bytes32)\n', '    { return keccak256("sale_tokens_sold"); }\n', '\n', '  // Storage location of the minimum amount of tokens allowed to be purchased\n', '  function globalMinPurchaseAmt() internal pure returns (bytes32)\n', '    { return keccak256("sale_min_purchase_amt"); }\n', '\n', '  // Stores the amount of unique contributors so far in this crowdsale\n', '  function contributors() internal pure returns (bytes32)\n', '    { return keccak256("sale_contributors"); }\n', '\n', '  // Maps addresses to a boolean indicating whether or not this address has contributed\n', '  function hasContributed(address _purchaser) internal pure returns (bytes32)\n', '    { return keccak256(_purchaser, contributors()); }\n', '\n', '  /// FUNDS ///\n', '\n', '  // Storage location of team funds wallet\n', '  function wallet() internal pure returns (bytes32)\n', '    { return keccak256("sale_destination_wallet"); }\n', '\n', '  // Storage location of amount of wei raised during the crowdsale, total\n', '  function totalWeiRaised() internal pure returns (bytes32)\n', '    { return keccak256("sale_tot_wei_raised"); }\n', '\n', '  /// WHITELIST ///\n', '\n', '  // Whether or not the sale is whitelist-enabled\n', '  function isWhitelisted() internal pure returns (bytes32)\n', '    { return keccak256(&#39;sale_is_whitelisted&#39;); }\n', '\n', '  // Stores the sale&#39;s whitelist\n', '  function saleWhitelist() internal pure returns (bytes32)\n', '    { return keccak256("sale_whitelist"); }\n', '\n', '  // Stores a spender&#39;s maximum number of tokens allowed to be purchased\n', '  function whitelistMaxTok(address _spender) internal pure returns (bytes32)\n', '    { return keccak256(_spender, "max_tok", saleWhitelist()); }\n', '\n', '  // Stores a spender&#39;s minimum token purchase amount\n', '  function whitelistMinTok(address _spender) internal pure returns (bytes32)\n', '    { return keccak256(_spender, "min_tok", saleWhitelist()); }\n', '\n', '  /// TOKEN ///\n', '\n', '  // Storage location for token decimals\n', '  function tokenDecimals() internal pure returns (bytes32)\n', '    { return keccak256("token_decimals"); }\n', '\n', '  // Storage seed for user balances mapping\n', '  bytes32 internal constant TOKEN_BALANCES = keccak256("token_balances");\n', '\n', '  function balances(address _owner) internal pure returns (bytes32)\n', '    { return keccak256(_owner, TOKEN_BALANCES); }\n', '\n', '  /// CHECKS ///\n', '\n', '  // Ensures the sale has been configured, and that the sale has not finished\n', '  function validState() internal view {\n', '    // Ensure ETH was sent with the transaction\n', '    if (msg.value == 0)\n', '      revert(&#39;no wei sent&#39;);\n', '\n', '    // Ensure the sale has started\n', '    if (uint(Contract.read(startTime())) > now)\n', '      revert(&#39;sale has not started&#39;);\n', '\n', '    // Ensure the team wallet is correct\n', '    if (Contract.read(wallet()) == 0)\n', '  \t  revert(&#39;invalid Crowdsale wallet&#39;);\n', '\n', '    // Ensure the sale was configured\n', '    if (Contract.read(isConfigured()) == 0)\n', '      revert(&#39;sale not initialized&#39;);\n', '\n', '    // Ensure the sale is not finished\n', '    if (Contract.read(isFinished()) != 0)\n', '      revert(&#39;sale already finalized&#39;);\n', '\n', '    // Ensure the sale is not sold out\n', '  \tif (Contract.read(tokensRemaining()) == 0)\n', '  \t  revert(&#39;Crowdsale is sold out&#39;);\n', '\n', '  \t// Ensure the start and end rate were correctly set\n', '  \tif (Contract.read(startRate()) <= Contract.read(endRate()))\n', '  \t  revert("end sale rate is greater than starting sale rate");\n', '\n', '  \t// Ensure the sale is not over\n', '  \tif (now > uint(Contract.read(startTime())) + uint(Contract.read(totalDuration())))\n', '  \t  revert("the crowdsale is over");\n', '  }\n', '\n', '  // Ensures both storage and events have been pushed to the buffer\n', '  function emitStoreAndPay() internal pure {\n', '    if (Contract.emitted() == 0 || Contract.stored() == 0 || Contract.paid() != 1)\n', '      revert(&#39;invalid state change&#39;);\n', '  }\n', '\n', '  /// FUNCTIONS ///\n', '\n', '  // Allows the sender to purchase tokens -\n', '  function buy() external view {\n', '    // Begin execution - reads execution id and original sender address from storage\n', '    Contract.authorize(msg.sender);\n', '    // Check that the sale is initialized and not yet finalized -\n', '    Contract.checks(validState);\n', '    // Execute approval function -\n', '    Purchase.buy();\n', '    // Check for valid storage buffer\n', '    Contract.checks(emitStoreAndPay);\n', '    // Commit state changes to storage -\n', '    Contract.commit();\n', '  }\n', '}']