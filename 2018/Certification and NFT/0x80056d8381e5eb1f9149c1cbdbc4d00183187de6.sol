['pragma solidity 0.4.21;\n', '\n', 'interface TokenToken {\n', '    function pause() public;\n', '    function unpause() public;\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function getTotalSupply() public view returns(uint);\n', '    function finishMinting() public returns (bool);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', '// File: contracts/TeamAndAdvisorsAllocation.sol\n', '\n', '/**\n', ' * @title Team and Advisors Token Allocation contract\n', ' */\n', '\n', 'contract TeamAndAdvisorsAllocation is Ownable {\n', '    using SafeMath for uint;\n', '\n', '    uint256 public unlockedAt;\n', '    uint256 public canSelfDestruct;\n', '    uint256 public tokensCreated;\n', '    uint256 public allocatedTokens;\n', '    uint256 private totalTeamAndAdvisorsAllocation = 4000000e18; // 4 mm\n', '\n', '    mapping (address => uint256) public teamAndAdvisorsAllocations;\n', '\n', '    TokenToken public token;\n', '\n', '    /**\n', '     * @dev constructor function that sets owner and token for the TeamAndAdvisorsAllocation contract\n', '     * @param _token Token contract address for TokenToken\n', '     */\n', '    function TeamAndAdvisorsAllocation(address _token) public {\n', '        token = TokenToken(_token);\n', '        unlockedAt = now.add(3 days);\n', '        canSelfDestruct = now.add(4 days);\n', '    }\n', '\n', '    /**\n', '     * @dev Adds founders&#39; token allocation\n', '     * @param teamOrAdvisorsAddress Address of a founder\n', '     * @param allocationValue Number of tokens allocated to a founder\n', '     * @return true if address is correctly added\n', '     */\n', '    function addTeamAndAdvisorsAllocation(address teamOrAdvisorsAddress, uint256 allocationValue)\n', '    external\n', '    onlyOwner\n', '    returns(bool)\n', '    {\n', '        assert(teamAndAdvisorsAllocations[teamOrAdvisorsAddress] == 0); // can only add once.\n', '\n', '        allocatedTokens = allocatedTokens.add(allocationValue);\n', '        require(allocatedTokens <= totalTeamAndAdvisorsAllocation);\n', '\n', '        teamAndAdvisorsAllocations[teamOrAdvisorsAddress] = allocationValue;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow company to unlock allocated tokens by transferring them whitelisted addresses.\n', '     * Need to be called by each address\n', '     */\n', '    function unlock() external {\n', '        assert(now >= unlockedAt);\n', '\n', '        // During first unlock attempt fetch total number of locked tokens.\n', '        if (tokensCreated == 0) {\n', '            tokensCreated = token.balanceOf(this);\n', '        }\n', '\n', '        uint256 transferAllocation = teamAndAdvisorsAllocations[msg.sender];\n', '        teamAndAdvisorsAllocations[msg.sender] = 0;\n', '\n', '        // Will fail if allocation (and therefore toTransfer) is 0.\n', '        require(token.transfer(msg.sender, transferAllocation));\n', '    }\n', '\n', '    /**\n', '     * @dev allow for selfdestruct possibility and sending funds to owner\n', '     */\n', '    function kill() public onlyOwner {\n', '        assert(now >= canSelfDestruct);\n', '        uint256 balance = token.balanceOf(this);\n', '\n', '        if (balance > 0) {\n', '            token.transfer(owner, balance);\n', '        }\n', '\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '// File: contracts/Whitelist.sol\n', '\n', 'contract Whitelist is Ownable {\n', '    mapping(address => bool) public allowedAddresses;\n', '\n', '    event WhitelistUpdated(uint256 timestamp, string operation, address indexed member);\n', '\n', '    function addToWhitelist(address[] _addresses) public onlyOwner {\n', '        for (uint256 i = 0; i < _addresses.length; i++) {\n', '            allowedAddresses[_addresses[i]] = true;\n', '            WhitelistUpdated(now, "Added", _addresses[i]);\n', '        }\n', '    }\n', '\n', '    function removeFromWhitelist(address[] _addresses) public onlyOwner {\n', '        for (uint256 i = 0; i < _addresses.length; i++) {\n', '            allowedAddresses[_addresses[i]] = false;\n', '            WhitelistUpdated(now, "Removed", _addresses[i]);\n', '        }\n', '    }\n', '\n', '    function isWhitelisted(address _address) public view returns (bool) {\n', '        return allowedAddresses[_address];\n', '    }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/crowdsale/TokenCrowdsale.sol\n', '\n', '/**\n', ' * @title Crowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale.\n', ' * Crowdsales have a start and end timestamps, where investors can make\n', ' * token purchases and the crowdsale will assign them tokens based\n', ' * on a token per ETH rate. Funds collected are forwarded to a wallet\n', ' * as they arrive.\n', ' */\n', 'contract Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    // start and end timestamps where investments are allowed (both inclusive)\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '\n', '    // address where funds are collected\n', '    address public wallet;\n', '\n', '    // how many token units a buyer gets per wei\n', '    uint256 public rate;\n', '\n', '    // amount of raised money in wei\n', '    uint256 public weiRaised;\n', '\n', '    // token contract to be set\n', '    TokenToken public token;\n', '\n', '    /**\n', '     * event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '\n', '    function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {\n', '        require(_startTime >= now);\n', '        require(_endTime > _startTime);\n', '        require(_rate > 0);\n', '        require(_wallet != address(0));\n', '\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        rate = _rate;\n', '        wallet = _wallet;\n', '    }\n', '\n', '    // fallback function can be used to buy tokens\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    // low level token purchase function\n', '    function buyTokens(address beneficiary) public payable {\n', '        require(beneficiary != address(0));\n', '        require(validPurchase());\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // calculate token amount to be created\n', '        uint256 tokens = weiAmount.mul(rate);\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '\n', '        token.mint(beneficiary, tokens);\n', '        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '\n', '        forwardFunds();\n', '    }\n', '\n', '    // send ether to the fund collection wallet\n', '    // override to create custom fund forwarding mechanisms\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    // @return true if the transaction can buy tokens\n', '    function validPurchase() internal view returns (bool) {\n', '        bool withinPeriod = now >= startTime && now <= endTime;\n', '        bool nonZeroPurchase = msg.value != 0;\n', '        return withinPeriod && nonZeroPurchase;\n', '    }\n', '\n', '    // @return true if crowdsale event has ended\n', '    function hasEnded() public view returns (bool) {\n', '        return now > endTime;\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/crowdsale/FinalizableCrowdsale.sol\n', '\n', '/**\n', ' * @title FinalizableCrowdsale\n', ' * @dev Extension of Crowdsale where an owner can do extra work\n', ' * after finishing.\n', ' */\n', 'contract FinalizableCrowdsale is Crowdsale, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    bool public isFinalized = false;\n', '\n', '    event Finalized();\n', '\n', '    /**\n', '     * @dev Must be called after crowdsale ends, to do some extra finalization\n', '     * work. Calls the contract&#39;s finalization function.\n', '     */\n', '    function finalize() onlyOwner public {\n', '        require(!isFinalized);\n', '        require(hasEnded());\n', '\n', '        finalization();\n', '        Finalized();\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Can be overridden to add finalization logic. The overriding function\n', '     * should call super.finalization() to ensure the chain of finalization is\n', '     * executed entirely.\n', '     */\n', '    function finalization() internal {\n', '    }\n', '}\n', '\n', '// File: contracts/TokenCrowdsale.sol\n', '\n', '/**\n', ' * @title Token Crowdsale contract - crowdsale contract for the Token tokens.\n', ' */\n', '\n', 'contract TokenCrowdsale is FinalizableCrowdsale, Pausable {\n', '    uint256 constant public REWARD_SHARE =                   4500000e18; // 4.5 mm\n', '    uint256 constant public NON_VESTED_TEAM_ADVISORS_SHARE = 37500000e18; //  37.5 mm\n', '    uint256 constant public PRE_CROWDSALE_CAP =              500000e18; //  0.5 mm\n', '    uint256 constant public PUBLIC_CROWDSALE_CAP =           7500000e18; // 7.5 mm\n', '    uint256 constant public TOTAL_TOKENS_FOR_CROWDSALE = PRE_CROWDSALE_CAP + PUBLIC_CROWDSALE_CAP;\n', '    uint256 constant public TOTAL_TOKENS_SUPPLY =            50000000e18; // 50 mm\n', '    uint256 constant public PERSONAL_CAP =                   2500000e18; //   2.5 mm\n', '\n', '    address public rewardWallet;\n', '    address public teamAndAdvisorsAllocation;\n', '\n', '    // remainderPurchaser and remainderTokens info saved in the contract\n', '    // used for reference for contract owner to send refund if any to last purchaser after end of crowdsale\n', '    address public remainderPurchaser;\n', '    uint256 public remainderAmount;\n', '\n', '    mapping (address => uint256) public trackBuyersPurchases;\n', '\n', '    // external contracts\n', '    Whitelist public whitelist;\n', '\n', '    event PrivateInvestorTokenPurchase(address indexed investor, uint256 tokensPurchased);\n', '    event TokenRateChanged(uint256 previousRate, uint256 newRate);\n', '\n', '    /**\n', '     * @dev Contract constructor function\n', '     * @param _startTime The timestamp of the beginning of the crowdsale\n', '     * @param _endTime Timestamp when the crowdsale will finish\n', '     * @param _whitelist contract containing the whitelisted addresses\n', '     * @param _rate The token rate per ETH\n', '     * @param _wallet Multisig wallet that will hold the crowdsale funds.\n', '     * @param _rewardWallet wallet that will hold tokens bounty and rewards campaign\n', '     */\n', '    function TokenCrowdsale\n', '    (\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        address _whitelist,\n', '        uint256 _rate,\n', '        address _wallet,\n', '        address _rewardWallet\n', '    )\n', '    public\n', '    FinalizableCrowdsale()\n', '    Crowdsale(_startTime, _endTime, _rate, _wallet)\n', '    {\n', '\n', '        require(_whitelist != address(0) && _wallet != address(0) && _rewardWallet != address(0));\n', '        whitelist = Whitelist(_whitelist);\n', '        rewardWallet = _rewardWallet;\n', '\n', '    }\n', '\n', '    function setTokenContractAddress(address _token) onlyOwner {\n', '        token = TokenToken(_token);\n', '    }\n', '\n', '    modifier whitelisted(address beneficiary) {\n', '        require(whitelist.isWhitelisted(beneficiary));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev change crowdsale rate\n', '     * @param newRate Figure that corresponds to the new rate per token\n', '     */\n', '    function setRate(uint256 newRate) external onlyOwner {\n', '        require(newRate != 0);\n', '\n', '        TokenRateChanged(rate, newRate);\n', '        rate = newRate;\n', '    }\n', '\n', '    /**\n', '     * @dev Mint tokens for pre crowdsale putchases before crowdsale starts\n', '     * @param investorsAddress Purchaser&#39;s address\n', '     * @param tokensPurchased Tokens purchased during pre crowdsale\n', '     */\n', '    function mintTokenForPreCrowdsale(address investorsAddress, uint256 tokensPurchased)\n', '    external\n', '    onlyOwner\n', '    {\n', '        require(now < startTime && investorsAddress != address(0));\n', '        require(token.getTotalSupply().add(tokensPurchased) <= PRE_CROWDSALE_CAP);\n', '\n', '        token.mint(investorsAddress, tokensPurchased);\n', '        PrivateInvestorTokenPurchase(investorsAddress, tokensPurchased);\n', '    }\n', '\n', '    /**\n', '     * @dev Set the address which should receive the vested team tokens share on finalization\n', '     * @param _teamAndAdvisorsAllocation address of team and advisor allocation contract\n', '     */\n', '    function setTeamWalletAddress(address _teamAndAdvisorsAllocation) public onlyOwner {\n', '        require(_teamAndAdvisorsAllocation != address(0x0));\n', '        teamAndAdvisorsAllocation = _teamAndAdvisorsAllocation;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev payable function that allow token purchases\n', '     * @param beneficiary Address of the purchaser\n', '     */\n', '    function buyTokens(address beneficiary)\n', '    public\n', '    whenNotPaused\n', '    whitelisted(beneficiary)\n', '    payable\n', '    {\n', '        require(beneficiary != address(0));\n', '        require(msg.sender == beneficiary);\n', '        require(validPurchase() && token.getTotalSupply() < TOTAL_TOKENS_FOR_CROWDSALE);\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // calculate token amount to be created\n', '        uint256 tokens = weiAmount.mul(rate);\n', '\n', '        require(trackBuyersPurchases[msg.sender].add(tokens) <= PERSONAL_CAP);\n', '\n', '        trackBuyersPurchases[beneficiary] = trackBuyersPurchases[beneficiary].add(tokens);\n', '\n', '        //remainder logic\n', '        if (token.getTotalSupply().add(tokens) > TOTAL_TOKENS_FOR_CROWDSALE) {\n', '            tokens = TOTAL_TOKENS_FOR_CROWDSALE.sub(token.getTotalSupply());\n', '            weiAmount = tokens.div(rate);\n', '\n', '            // save info so as to refund purchaser after crowdsale&#39;s end\n', '            remainderPurchaser = msg.sender;\n', '            remainderAmount = msg.value.sub(weiAmount);\n', '        }\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '\n', '        token.mint(beneficiary, tokens);\n', '        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '\n', '        forwardFunds();\n', '    }\n', '\n', '    // overriding Crowdsale#hasEnded to add cap logic\n', '    // @return true if crowdsale event has ended\n', '    function hasEnded() public view returns (bool) {\n', '        if (token.getTotalSupply() == TOTAL_TOKENS_FOR_CROWDSALE) {\n', '            return true;\n', '        }\n', '\n', '        return super.hasEnded();\n', '    }\n', '\n', '    /**\n', '     * @dev finalizes crowdsale\n', '     */\n', '    function finalization() internal {\n', '        // This must have been set manually prior to finalize().\n', '        require(teamAndAdvisorsAllocation != address(0x0));\n', '\n', '        // final minting\n', '        token.mint(teamAndAdvisorsAllocation, NON_VESTED_TEAM_ADVISORS_SHARE);\n', '        token.mint(rewardWallet, REWARD_SHARE);\n', '\n', '        if (TOTAL_TOKENS_SUPPLY > token.getTotalSupply()) {\n', '            uint256 remainingTokens = TOTAL_TOKENS_SUPPLY.sub(token.getTotalSupply());\n', '\n', '            token.mint(wallet, remainingTokens);\n', '        }\n', '\n', '        token.finishMinting();\n', '        TokenToken(token).unpause();\n', '        super.finalization();\n', '    }\n', '}']
['pragma solidity 0.4.21;\n', '\n', 'interface TokenToken {\n', '    function pause() public;\n', '    function unpause() public;\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function getTotalSupply() public view returns(uint);\n', '    function finishMinting() public returns (bool);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', '// File: contracts/TeamAndAdvisorsAllocation.sol\n', '\n', '/**\n', ' * @title Team and Advisors Token Allocation contract\n', ' */\n', '\n', 'contract TeamAndAdvisorsAllocation is Ownable {\n', '    using SafeMath for uint;\n', '\n', '    uint256 public unlockedAt;\n', '    uint256 public canSelfDestruct;\n', '    uint256 public tokensCreated;\n', '    uint256 public allocatedTokens;\n', '    uint256 private totalTeamAndAdvisorsAllocation = 4000000e18; // 4 mm\n', '\n', '    mapping (address => uint256) public teamAndAdvisorsAllocations;\n', '\n', '    TokenToken public token;\n', '\n', '    /**\n', '     * @dev constructor function that sets owner and token for the TeamAndAdvisorsAllocation contract\n', '     * @param _token Token contract address for TokenToken\n', '     */\n', '    function TeamAndAdvisorsAllocation(address _token) public {\n', '        token = TokenToken(_token);\n', '        unlockedAt = now.add(3 days);\n', '        canSelfDestruct = now.add(4 days);\n', '    }\n', '\n', '    /**\n', "     * @dev Adds founders' token allocation\n", '     * @param teamOrAdvisorsAddress Address of a founder\n', '     * @param allocationValue Number of tokens allocated to a founder\n', '     * @return true if address is correctly added\n', '     */\n', '    function addTeamAndAdvisorsAllocation(address teamOrAdvisorsAddress, uint256 allocationValue)\n', '    external\n', '    onlyOwner\n', '    returns(bool)\n', '    {\n', '        assert(teamAndAdvisorsAllocations[teamOrAdvisorsAddress] == 0); // can only add once.\n', '\n', '        allocatedTokens = allocatedTokens.add(allocationValue);\n', '        require(allocatedTokens <= totalTeamAndAdvisorsAllocation);\n', '\n', '        teamAndAdvisorsAllocations[teamOrAdvisorsAddress] = allocationValue;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow company to unlock allocated tokens by transferring them whitelisted addresses.\n', '     * Need to be called by each address\n', '     */\n', '    function unlock() external {\n', '        assert(now >= unlockedAt);\n', '\n', '        // During first unlock attempt fetch total number of locked tokens.\n', '        if (tokensCreated == 0) {\n', '            tokensCreated = token.balanceOf(this);\n', '        }\n', '\n', '        uint256 transferAllocation = teamAndAdvisorsAllocations[msg.sender];\n', '        teamAndAdvisorsAllocations[msg.sender] = 0;\n', '\n', '        // Will fail if allocation (and therefore toTransfer) is 0.\n', '        require(token.transfer(msg.sender, transferAllocation));\n', '    }\n', '\n', '    /**\n', '     * @dev allow for selfdestruct possibility and sending funds to owner\n', '     */\n', '    function kill() public onlyOwner {\n', '        assert(now >= canSelfDestruct);\n', '        uint256 balance = token.balanceOf(this);\n', '\n', '        if (balance > 0) {\n', '            token.transfer(owner, balance);\n', '        }\n', '\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '// File: contracts/Whitelist.sol\n', '\n', 'contract Whitelist is Ownable {\n', '    mapping(address => bool) public allowedAddresses;\n', '\n', '    event WhitelistUpdated(uint256 timestamp, string operation, address indexed member);\n', '\n', '    function addToWhitelist(address[] _addresses) public onlyOwner {\n', '        for (uint256 i = 0; i < _addresses.length; i++) {\n', '            allowedAddresses[_addresses[i]] = true;\n', '            WhitelistUpdated(now, "Added", _addresses[i]);\n', '        }\n', '    }\n', '\n', '    function removeFromWhitelist(address[] _addresses) public onlyOwner {\n', '        for (uint256 i = 0; i < _addresses.length; i++) {\n', '            allowedAddresses[_addresses[i]] = false;\n', '            WhitelistUpdated(now, "Removed", _addresses[i]);\n', '        }\n', '    }\n', '\n', '    function isWhitelisted(address _address) public view returns (bool) {\n', '        return allowedAddresses[_address];\n', '    }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/crowdsale/TokenCrowdsale.sol\n', '\n', '/**\n', ' * @title Crowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale.\n', ' * Crowdsales have a start and end timestamps, where investors can make\n', ' * token purchases and the crowdsale will assign them tokens based\n', ' * on a token per ETH rate. Funds collected are forwarded to a wallet\n', ' * as they arrive.\n', ' */\n', 'contract Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    // start and end timestamps where investments are allowed (both inclusive)\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '\n', '    // address where funds are collected\n', '    address public wallet;\n', '\n', '    // how many token units a buyer gets per wei\n', '    uint256 public rate;\n', '\n', '    // amount of raised money in wei\n', '    uint256 public weiRaised;\n', '\n', '    // token contract to be set\n', '    TokenToken public token;\n', '\n', '    /**\n', '     * event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '\n', '    function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {\n', '        require(_startTime >= now);\n', '        require(_endTime > _startTime);\n', '        require(_rate > 0);\n', '        require(_wallet != address(0));\n', '\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        rate = _rate;\n', '        wallet = _wallet;\n', '    }\n', '\n', '    // fallback function can be used to buy tokens\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    // low level token purchase function\n', '    function buyTokens(address beneficiary) public payable {\n', '        require(beneficiary != address(0));\n', '        require(validPurchase());\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // calculate token amount to be created\n', '        uint256 tokens = weiAmount.mul(rate);\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '\n', '        token.mint(beneficiary, tokens);\n', '        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '\n', '        forwardFunds();\n', '    }\n', '\n', '    // send ether to the fund collection wallet\n', '    // override to create custom fund forwarding mechanisms\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    // @return true if the transaction can buy tokens\n', '    function validPurchase() internal view returns (bool) {\n', '        bool withinPeriod = now >= startTime && now <= endTime;\n', '        bool nonZeroPurchase = msg.value != 0;\n', '        return withinPeriod && nonZeroPurchase;\n', '    }\n', '\n', '    // @return true if crowdsale event has ended\n', '    function hasEnded() public view returns (bool) {\n', '        return now > endTime;\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/crowdsale/FinalizableCrowdsale.sol\n', '\n', '/**\n', ' * @title FinalizableCrowdsale\n', ' * @dev Extension of Crowdsale where an owner can do extra work\n', ' * after finishing.\n', ' */\n', 'contract FinalizableCrowdsale is Crowdsale, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    bool public isFinalized = false;\n', '\n', '    event Finalized();\n', '\n', '    /**\n', '     * @dev Must be called after crowdsale ends, to do some extra finalization\n', "     * work. Calls the contract's finalization function.\n", '     */\n', '    function finalize() onlyOwner public {\n', '        require(!isFinalized);\n', '        require(hasEnded());\n', '\n', '        finalization();\n', '        Finalized();\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Can be overridden to add finalization logic. The overriding function\n', '     * should call super.finalization() to ensure the chain of finalization is\n', '     * executed entirely.\n', '     */\n', '    function finalization() internal {\n', '    }\n', '}\n', '\n', '// File: contracts/TokenCrowdsale.sol\n', '\n', '/**\n', ' * @title Token Crowdsale contract - crowdsale contract for the Token tokens.\n', ' */\n', '\n', 'contract TokenCrowdsale is FinalizableCrowdsale, Pausable {\n', '    uint256 constant public REWARD_SHARE =                   4500000e18; // 4.5 mm\n', '    uint256 constant public NON_VESTED_TEAM_ADVISORS_SHARE = 37500000e18; //  37.5 mm\n', '    uint256 constant public PRE_CROWDSALE_CAP =              500000e18; //  0.5 mm\n', '    uint256 constant public PUBLIC_CROWDSALE_CAP =           7500000e18; // 7.5 mm\n', '    uint256 constant public TOTAL_TOKENS_FOR_CROWDSALE = PRE_CROWDSALE_CAP + PUBLIC_CROWDSALE_CAP;\n', '    uint256 constant public TOTAL_TOKENS_SUPPLY =            50000000e18; // 50 mm\n', '    uint256 constant public PERSONAL_CAP =                   2500000e18; //   2.5 mm\n', '\n', '    address public rewardWallet;\n', '    address public teamAndAdvisorsAllocation;\n', '\n', '    // remainderPurchaser and remainderTokens info saved in the contract\n', '    // used for reference for contract owner to send refund if any to last purchaser after end of crowdsale\n', '    address public remainderPurchaser;\n', '    uint256 public remainderAmount;\n', '\n', '    mapping (address => uint256) public trackBuyersPurchases;\n', '\n', '    // external contracts\n', '    Whitelist public whitelist;\n', '\n', '    event PrivateInvestorTokenPurchase(address indexed investor, uint256 tokensPurchased);\n', '    event TokenRateChanged(uint256 previousRate, uint256 newRate);\n', '\n', '    /**\n', '     * @dev Contract constructor function\n', '     * @param _startTime The timestamp of the beginning of the crowdsale\n', '     * @param _endTime Timestamp when the crowdsale will finish\n', '     * @param _whitelist contract containing the whitelisted addresses\n', '     * @param _rate The token rate per ETH\n', '     * @param _wallet Multisig wallet that will hold the crowdsale funds.\n', '     * @param _rewardWallet wallet that will hold tokens bounty and rewards campaign\n', '     */\n', '    function TokenCrowdsale\n', '    (\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        address _whitelist,\n', '        uint256 _rate,\n', '        address _wallet,\n', '        address _rewardWallet\n', '    )\n', '    public\n', '    FinalizableCrowdsale()\n', '    Crowdsale(_startTime, _endTime, _rate, _wallet)\n', '    {\n', '\n', '        require(_whitelist != address(0) && _wallet != address(0) && _rewardWallet != address(0));\n', '        whitelist = Whitelist(_whitelist);\n', '        rewardWallet = _rewardWallet;\n', '\n', '    }\n', '\n', '    function setTokenContractAddress(address _token) onlyOwner {\n', '        token = TokenToken(_token);\n', '    }\n', '\n', '    modifier whitelisted(address beneficiary) {\n', '        require(whitelist.isWhitelisted(beneficiary));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev change crowdsale rate\n', '     * @param newRate Figure that corresponds to the new rate per token\n', '     */\n', '    function setRate(uint256 newRate) external onlyOwner {\n', '        require(newRate != 0);\n', '\n', '        TokenRateChanged(rate, newRate);\n', '        rate = newRate;\n', '    }\n', '\n', '    /**\n', '     * @dev Mint tokens for pre crowdsale putchases before crowdsale starts\n', "     * @param investorsAddress Purchaser's address\n", '     * @param tokensPurchased Tokens purchased during pre crowdsale\n', '     */\n', '    function mintTokenForPreCrowdsale(address investorsAddress, uint256 tokensPurchased)\n', '    external\n', '    onlyOwner\n', '    {\n', '        require(now < startTime && investorsAddress != address(0));\n', '        require(token.getTotalSupply().add(tokensPurchased) <= PRE_CROWDSALE_CAP);\n', '\n', '        token.mint(investorsAddress, tokensPurchased);\n', '        PrivateInvestorTokenPurchase(investorsAddress, tokensPurchased);\n', '    }\n', '\n', '    /**\n', '     * @dev Set the address which should receive the vested team tokens share on finalization\n', '     * @param _teamAndAdvisorsAllocation address of team and advisor allocation contract\n', '     */\n', '    function setTeamWalletAddress(address _teamAndAdvisorsAllocation) public onlyOwner {\n', '        require(_teamAndAdvisorsAllocation != address(0x0));\n', '        teamAndAdvisorsAllocation = _teamAndAdvisorsAllocation;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev payable function that allow token purchases\n', '     * @param beneficiary Address of the purchaser\n', '     */\n', '    function buyTokens(address beneficiary)\n', '    public\n', '    whenNotPaused\n', '    whitelisted(beneficiary)\n', '    payable\n', '    {\n', '        require(beneficiary != address(0));\n', '        require(msg.sender == beneficiary);\n', '        require(validPurchase() && token.getTotalSupply() < TOTAL_TOKENS_FOR_CROWDSALE);\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // calculate token amount to be created\n', '        uint256 tokens = weiAmount.mul(rate);\n', '\n', '        require(trackBuyersPurchases[msg.sender].add(tokens) <= PERSONAL_CAP);\n', '\n', '        trackBuyersPurchases[beneficiary] = trackBuyersPurchases[beneficiary].add(tokens);\n', '\n', '        //remainder logic\n', '        if (token.getTotalSupply().add(tokens) > TOTAL_TOKENS_FOR_CROWDSALE) {\n', '            tokens = TOTAL_TOKENS_FOR_CROWDSALE.sub(token.getTotalSupply());\n', '            weiAmount = tokens.div(rate);\n', '\n', "            // save info so as to refund purchaser after crowdsale's end\n", '            remainderPurchaser = msg.sender;\n', '            remainderAmount = msg.value.sub(weiAmount);\n', '        }\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '\n', '        token.mint(beneficiary, tokens);\n', '        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '\n', '        forwardFunds();\n', '    }\n', '\n', '    // overriding Crowdsale#hasEnded to add cap logic\n', '    // @return true if crowdsale event has ended\n', '    function hasEnded() public view returns (bool) {\n', '        if (token.getTotalSupply() == TOTAL_TOKENS_FOR_CROWDSALE) {\n', '            return true;\n', '        }\n', '\n', '        return super.hasEnded();\n', '    }\n', '\n', '    /**\n', '     * @dev finalizes crowdsale\n', '     */\n', '    function finalization() internal {\n', '        // This must have been set manually prior to finalize().\n', '        require(teamAndAdvisorsAllocation != address(0x0));\n', '\n', '        // final minting\n', '        token.mint(teamAndAdvisorsAllocation, NON_VESTED_TEAM_ADVISORS_SHARE);\n', '        token.mint(rewardWallet, REWARD_SHARE);\n', '\n', '        if (TOTAL_TOKENS_SUPPLY > token.getTotalSupply()) {\n', '            uint256 remainingTokens = TOTAL_TOKENS_SUPPLY.sub(token.getTotalSupply());\n', '\n', '            token.mint(wallet, remainingTokens);\n', '        }\n', '\n', '        token.finishMinting();\n', '        TokenToken(token).unpause();\n', '        super.finalization();\n', '    }\n', '}']
