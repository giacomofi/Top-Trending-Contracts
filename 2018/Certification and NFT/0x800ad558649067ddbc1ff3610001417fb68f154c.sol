['pragma solidity ^0.4.21;\n', '\n', 'contract Issuer {\n', '    \n', '    address internal issuer = 0x692202c797ca194be918114780db7796e9397c13;\n', '    \n', '    function changeIssuer(address _to) public {\n', '        \n', '        require(msg.sender == issuer); \n', '        \n', '        issuer = _to;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    \n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '    \n', '}\n', '\n', 'library StringHelper {\n', '\n', '    function stringToUint(string s) pure internal returns (uint result) {\n', '        bytes memory b = bytes(s);\n', '        uint i;\n', '        result = 0;\n', '        for (i = 0; i < b.length; i++) {\n', '            uint c = uint(b[i]);\n', '            if (c >= 48 && c <= 57) {\n', '                result = result * 10 + (c - 48);\n', '            }\n', '        }\n', '    }\n', '    \n', '}\n', '\n', 'library SafeMath {\n', '    \n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    \n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    \n', '}\n', '\n', 'contract ERC20 is Issuer, ERC20Interface {\n', '\n', '    using SafeMath for uint;\n', '\n', '    bool public locked = true;\n', '    \n', '    string public constant name = "Ethnamed";\n', '    string public constant symbol = "NAME";\n', '    uint8 public constant decimals = 18;\n', '    uint internal tokenPrice;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    \n', '    struct Contributor {\n', '        mapping(address => uint) allowed;\n', '        uint balance;\n', '    }\n', '    \n', '    mapping(address => Contributor) contributors;\n', '    \n', '    function ERC20() public {\n', '        tokenPrice = 10**uint(decimals);\n', '        Contributor storage contributor = contributors[issuer];\n', '        contributor.balance = totalSupply();\n', '        emit Transfer(address(0), issuer, totalSupply());\n', '    }\n', '    \n', '    function unlock() public {\n', '        require(msg.sender == issuer);\n', '        locked = false;\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint) {\n', '        return 1000000 * tokenPrice;\n', '    }\n', '    \n', '    function balanceOf(address _tokenOwner) public view returns (uint) {\n', '        Contributor storage contributor = contributors[_tokenOwner];\n', '        return contributor.balance;\n', '    }\n', '    \n', '    function transfer(address _to, uint _tokens) public returns (bool) {\n', '        require(!locked || msg.sender == issuer);\n', '        Contributor storage sender = contributors[msg.sender];\n', '        Contributor storage recepient = contributors[_to];\n', '        sender.balance = sender.balance.sub(_tokens);\n', '        recepient.balance = recepient.balance.add(_tokens);\n', '        emit Transfer(msg.sender, _to, _tokens);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address _tokenOwner, address _spender) public view returns (uint) {\n', '        Contributor storage owner = contributors[_tokenOwner];\n', '        return owner.allowed[_spender];\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint _tokens) public returns (bool) {\n', '        \n', '        Contributor storage owner = contributors[_from];\n', '        \n', '        require(owner.allowed[msg.sender] >= _tokens);\n', '        \n', '        Contributor storage receiver = contributors[_to];\n', '        \n', '        owner.balance = owner.balance.sub(_tokens);\n', '        owner.allowed[msg.sender] = owner.allowed[msg.sender].sub(_tokens);\n', '        \n', '        receiver.balance = receiver.balance.add(_tokens);\n', '        \n', '        emit Transfer(_from, _to, _tokens);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function approve(address _spender, uint _tokens) public returns (bool) {\n', '        \n', '        require(!locked);\n', '        \n', '        Contributor storage owner = contributors[msg.sender];\n', '        owner.allowed[_spender] = _tokens;\n', '        \n', '        emit Approval(msg.sender, _spender, _tokens);\n', '        return true;\n', '    }\n', '    \n', '}\n', '\n', 'contract DEXified is ERC20 {\n', '\n', '    using SafeMath for uint;\n', '\n', '    //use struct Contributor from ERC20\n', '    //use bool locked from ERC20\n', '    \n', '    struct Sales {\n', '        address[] items;\n', '        mapping(address => uint) lookup;\n', '    }\n', '    \n', '    struct Offer {\n', '        uint256 tokens;\n', '        uint256 price;\n', '    }\n', '    \n', '    mapping(address => Offer) exchange;\n', '    \n', '    uint256 public market = 0;\n', '    \n', '    //Credits to https://github.com/k06a\n', '    Sales internal sales;\n', '    \n', '    function sellers(uint index) public view returns (address) {\n', '        return sales.items[index];\n', '    }\n', '    \n', '    function getOffer(address _owner) public view returns (uint256[2]) {\n', '        Offer storage offer = exchange[_owner];\n', '        return ([offer.price , offer.tokens]);\n', '    }\n', '    \n', '    function addSeller(address item) private {\n', '        if (sales.lookup[item] > 0) {\n', '            return;\n', '        }\n', '        sales.lookup[item] = sales.items.push(item);\n', '    }\n', '\n', '    function removeSeller(address item) private {\n', '        uint index = sales.lookup[item];\n', '        if (index == 0) {\n', '            return;\n', '        }\n', '        if (index < sales.items.length) {\n', '            address lastItem = sales.items[sales.items.length - 1];\n', '            sales.items[index - 1] = lastItem;\n', '            sales.lookup[lastItem] = index;\n', '        }\n', '        sales.items.length -= 1;\n', '        delete sales.lookup[item];\n', '    }\n', '    \n', '    \n', '    function setOffer(address _owner, uint256 _price, uint256 _value) internal {\n', '        exchange[_owner].price = _price;\n', '        market =  market.sub(exchange[_owner].tokens);\n', '        exchange[_owner].tokens = _value;\n', '        market =  market.add(_value);\n', '        if (_value == 0) {\n', '            removeSeller(_owner);\n', '        }\n', '        else {\n', '            addSeller(_owner);\n', '        }\n', '    }\n', '    \n', '\n', '    function offerToSell(uint256 _price, uint256 _value) public {\n', '        require(!locked);\n', '        setOffer(msg.sender, _price, _value);\n', '    }\n', '    \n', '    function executeOffer(address _owner) public payable {\n', '        require(!locked);\n', '        Offer storage offer = exchange[_owner];\n', '        require(offer.tokens > 0);\n', '        require(msg.value == offer.price);\n', '        _owner.transfer(msg.value);\n', '        \n', '        Contributor storage owner_c  = contributors[_owner];\n', '        Contributor storage sender_c = contributors[msg.sender];\n', '        \n', '        require(owner_c.balance >= offer.tokens);\n', '        owner_c.balance = owner_c.balance.sub(offer.tokens);\n', '        sender_c.balance =  sender_c.balance.add(offer.tokens);\n', '        emit Transfer(_owner, msg.sender, offer.tokens);\n', '        setOffer(_owner, 0, 0);\n', '    }\n', '    \n', '}\n', '\n', 'contract Ethnamed is DEXified {\n', '\n', '    using SafeMath for uint;\n', '    using StringHelper for string;\n', '    \n', '    struct Name {\n', '        string record;\n', '        address owner;\n', '        uint expires;\n', '        uint balance;\n', '    }\n', '    \n', '    function withdraw(address _to) public {\n', '\n', '        require(msg.sender == issuer); \n', '        \n', '        _to.transfer(address(this).balance);\n', '    }\n', '    \n', '    mapping (string => Name) internal registry;\n', '    \n', '    mapping (bytes32 => string) internal lookup;\n', '    \n', '    function resolve(string _name) public view returns (string) {\n', '        return registry[_name].record;\n', '    }\n', '    \n', '    function whois(bytes32 _hash) public view returns (string) {\n', '        return lookup[_hash];\n', '    }\n', '    \n', '    function transferOwnership(string _name, address _to) public {\n', '        \n', '        require(registry[_name].owner == msg.sender);\n', '        \n', '        registry[_name].owner = _to;\n', '    }\n', '\n', '    function removeName(string _name) internal {\n', '        Name storage item = registry[_name];\n', '        \n', '        bytes32 hash = keccak256(item.record);\n', '        \n', '        delete registry[_name];\n', '        \n', '        delete lookup[hash];\n', '    }\n', '\n', '    function removeExpiredName(string _name) public {\n', '        \n', '        require(registry[_name].expires < now);\n', '        \n', '        removeName(_name);\n', '    }\n', '    \n', '    function removeNameByOwner(string _name) public {\n', '        \n', '        Name storage item = registry[_name];\n', '        \n', '        require(item.owner == msg.sender);\n', '        \n', '        removeName(_name);\n', '    }\n', '    \n', '\n', '    function sendTo(string _name) public payable {\n', '        \n', '        if (registry[_name].owner == address(0)) {\n', '            registry[_name].balance = registry[_name].balance.add(msg.value);\n', '        }\n', '        else {\n', '            registry[_name].owner.transfer(msg.value);\n', '        }\n', '    \n', '    }\n', '    \n', '    \n', '    \n', '    function setupCore(string _name, string _record, address _owner, uint _life) internal {\n', '        \n', '        Name storage item = registry[_name];\n', '        \n', '        require(item.owner == msg.sender || item.owner == 0x0);\n', '        item.record = _record;\n', '        item.owner = _owner;\n', '        if (item.balance > 0) {\n', '            item.owner.transfer(item.balance);\n', '            item.balance = 0;\n', '        }\n', '        item.expires = now + _life;\n', '        bytes32 hash = keccak256(_record);\n', '        lookup[hash] = _name;\n', '        \n', '    }\n', '\n', '    function setupViaAuthority(\n', '        string _length,\n', '        string _name,\n', '        string _record,\n', '        string _blockExpiry,\n', '        address _owner,\n', '        uint8 _v, \n', '        bytes32 _r, \n', '        bytes32 _s,\n', '        uint _life\n', '    ) internal {\n', '        \n', '        require(_blockExpiry.stringToUint() >= block.number);\n', '        \n', '        require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n", _length, _name, "r=", _record, "e=", _blockExpiry), _v, _r, _s) == issuer);\n', '        \n', '        setupCore(_name, _record, _owner, _life);\n', '        \n', '    }\n', '\n', '    function setOrUpdateRecord2(\n', '        string _length,\n', '        string _name,\n', '        string _record,\n', '        string _blockExpiry,\n', '        address _owner,\n', '        uint8 _v, \n', '        bytes32 _r, \n', '        bytes32 _s\n', '    ) public {\n', '        \n', '        Contributor storage contributor = contributors[msg.sender];\n', '        \n', '        require(contributor.balance >= tokenPrice);\n', '        \n', '        contributor.balance = contributor.balance.sub(tokenPrice);\n', '        \n', '        uint life = 48 weeks;\n', '     \n', '        setupViaAuthority(_length, _name, _record, _blockExpiry, _owner, _v, _r, _s, life);   \n', '    }\n', '\n', '    function setOrUpdateRecord(\n', '        string _length,\n', '        string _name,\n', '        string _record,\n', '        string _blockExpiry,\n', '        address _owner,\n', '        uint8 _v, \n', '        bytes32 _r, \n', '        bytes32 _s\n', '    ) public payable {\n', '        \n', '        uint life = msg.value == 0.01  ether ?  48 weeks : \n', '                    msg.value == 0.008 ether ?  24 weeks :\n', '                    msg.value == 0.006 ether ?  12 weeks :\n', '                    msg.value == 0.002 ether ?  4  weeks :\n', '                    0;\n', '                       \n', '        require(life > 0);\n', '        \n', '        setupViaAuthority(_length, _name, _record, _blockExpiry, _owner, _v, _r, _s, life);\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract Issuer {\n', '    \n', '    address internal issuer = 0x692202c797ca194be918114780db7796e9397c13;\n', '    \n', '    function changeIssuer(address _to) public {\n', '        \n', '        require(msg.sender == issuer); \n', '        \n', '        issuer = _to;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    \n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '    \n', '}\n', '\n', 'library StringHelper {\n', '\n', '    function stringToUint(string s) pure internal returns (uint result) {\n', '        bytes memory b = bytes(s);\n', '        uint i;\n', '        result = 0;\n', '        for (i = 0; i < b.length; i++) {\n', '            uint c = uint(b[i]);\n', '            if (c >= 48 && c <= 57) {\n', '                result = result * 10 + (c - 48);\n', '            }\n', '        }\n', '    }\n', '    \n', '}\n', '\n', 'library SafeMath {\n', '    \n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    \n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    \n', '}\n', '\n', 'contract ERC20 is Issuer, ERC20Interface {\n', '\n', '    using SafeMath for uint;\n', '\n', '    bool public locked = true;\n', '    \n', '    string public constant name = "Ethnamed";\n', '    string public constant symbol = "NAME";\n', '    uint8 public constant decimals = 18;\n', '    uint internal tokenPrice;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    \n', '    struct Contributor {\n', '        mapping(address => uint) allowed;\n', '        uint balance;\n', '    }\n', '    \n', '    mapping(address => Contributor) contributors;\n', '    \n', '    function ERC20() public {\n', '        tokenPrice = 10**uint(decimals);\n', '        Contributor storage contributor = contributors[issuer];\n', '        contributor.balance = totalSupply();\n', '        emit Transfer(address(0), issuer, totalSupply());\n', '    }\n', '    \n', '    function unlock() public {\n', '        require(msg.sender == issuer);\n', '        locked = false;\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint) {\n', '        return 1000000 * tokenPrice;\n', '    }\n', '    \n', '    function balanceOf(address _tokenOwner) public view returns (uint) {\n', '        Contributor storage contributor = contributors[_tokenOwner];\n', '        return contributor.balance;\n', '    }\n', '    \n', '    function transfer(address _to, uint _tokens) public returns (bool) {\n', '        require(!locked || msg.sender == issuer);\n', '        Contributor storage sender = contributors[msg.sender];\n', '        Contributor storage recepient = contributors[_to];\n', '        sender.balance = sender.balance.sub(_tokens);\n', '        recepient.balance = recepient.balance.add(_tokens);\n', '        emit Transfer(msg.sender, _to, _tokens);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address _tokenOwner, address _spender) public view returns (uint) {\n', '        Contributor storage owner = contributors[_tokenOwner];\n', '        return owner.allowed[_spender];\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint _tokens) public returns (bool) {\n', '        \n', '        Contributor storage owner = contributors[_from];\n', '        \n', '        require(owner.allowed[msg.sender] >= _tokens);\n', '        \n', '        Contributor storage receiver = contributors[_to];\n', '        \n', '        owner.balance = owner.balance.sub(_tokens);\n', '        owner.allowed[msg.sender] = owner.allowed[msg.sender].sub(_tokens);\n', '        \n', '        receiver.balance = receiver.balance.add(_tokens);\n', '        \n', '        emit Transfer(_from, _to, _tokens);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function approve(address _spender, uint _tokens) public returns (bool) {\n', '        \n', '        require(!locked);\n', '        \n', '        Contributor storage owner = contributors[msg.sender];\n', '        owner.allowed[_spender] = _tokens;\n', '        \n', '        emit Approval(msg.sender, _spender, _tokens);\n', '        return true;\n', '    }\n', '    \n', '}\n', '\n', 'contract DEXified is ERC20 {\n', '\n', '    using SafeMath for uint;\n', '\n', '    //use struct Contributor from ERC20\n', '    //use bool locked from ERC20\n', '    \n', '    struct Sales {\n', '        address[] items;\n', '        mapping(address => uint) lookup;\n', '    }\n', '    \n', '    struct Offer {\n', '        uint256 tokens;\n', '        uint256 price;\n', '    }\n', '    \n', '    mapping(address => Offer) exchange;\n', '    \n', '    uint256 public market = 0;\n', '    \n', '    //Credits to https://github.com/k06a\n', '    Sales internal sales;\n', '    \n', '    function sellers(uint index) public view returns (address) {\n', '        return sales.items[index];\n', '    }\n', '    \n', '    function getOffer(address _owner) public view returns (uint256[2]) {\n', '        Offer storage offer = exchange[_owner];\n', '        return ([offer.price , offer.tokens]);\n', '    }\n', '    \n', '    function addSeller(address item) private {\n', '        if (sales.lookup[item] > 0) {\n', '            return;\n', '        }\n', '        sales.lookup[item] = sales.items.push(item);\n', '    }\n', '\n', '    function removeSeller(address item) private {\n', '        uint index = sales.lookup[item];\n', '        if (index == 0) {\n', '            return;\n', '        }\n', '        if (index < sales.items.length) {\n', '            address lastItem = sales.items[sales.items.length - 1];\n', '            sales.items[index - 1] = lastItem;\n', '            sales.lookup[lastItem] = index;\n', '        }\n', '        sales.items.length -= 1;\n', '        delete sales.lookup[item];\n', '    }\n', '    \n', '    \n', '    function setOffer(address _owner, uint256 _price, uint256 _value) internal {\n', '        exchange[_owner].price = _price;\n', '        market =  market.sub(exchange[_owner].tokens);\n', '        exchange[_owner].tokens = _value;\n', '        market =  market.add(_value);\n', '        if (_value == 0) {\n', '            removeSeller(_owner);\n', '        }\n', '        else {\n', '            addSeller(_owner);\n', '        }\n', '    }\n', '    \n', '\n', '    function offerToSell(uint256 _price, uint256 _value) public {\n', '        require(!locked);\n', '        setOffer(msg.sender, _price, _value);\n', '    }\n', '    \n', '    function executeOffer(address _owner) public payable {\n', '        require(!locked);\n', '        Offer storage offer = exchange[_owner];\n', '        require(offer.tokens > 0);\n', '        require(msg.value == offer.price);\n', '        _owner.transfer(msg.value);\n', '        \n', '        Contributor storage owner_c  = contributors[_owner];\n', '        Contributor storage sender_c = contributors[msg.sender];\n', '        \n', '        require(owner_c.balance >= offer.tokens);\n', '        owner_c.balance = owner_c.balance.sub(offer.tokens);\n', '        sender_c.balance =  sender_c.balance.add(offer.tokens);\n', '        emit Transfer(_owner, msg.sender, offer.tokens);\n', '        setOffer(_owner, 0, 0);\n', '    }\n', '    \n', '}\n', '\n', 'contract Ethnamed is DEXified {\n', '\n', '    using SafeMath for uint;\n', '    using StringHelper for string;\n', '    \n', '    struct Name {\n', '        string record;\n', '        address owner;\n', '        uint expires;\n', '        uint balance;\n', '    }\n', '    \n', '    function withdraw(address _to) public {\n', '\n', '        require(msg.sender == issuer); \n', '        \n', '        _to.transfer(address(this).balance);\n', '    }\n', '    \n', '    mapping (string => Name) internal registry;\n', '    \n', '    mapping (bytes32 => string) internal lookup;\n', '    \n', '    function resolve(string _name) public view returns (string) {\n', '        return registry[_name].record;\n', '    }\n', '    \n', '    function whois(bytes32 _hash) public view returns (string) {\n', '        return lookup[_hash];\n', '    }\n', '    \n', '    function transferOwnership(string _name, address _to) public {\n', '        \n', '        require(registry[_name].owner == msg.sender);\n', '        \n', '        registry[_name].owner = _to;\n', '    }\n', '\n', '    function removeName(string _name) internal {\n', '        Name storage item = registry[_name];\n', '        \n', '        bytes32 hash = keccak256(item.record);\n', '        \n', '        delete registry[_name];\n', '        \n', '        delete lookup[hash];\n', '    }\n', '\n', '    function removeExpiredName(string _name) public {\n', '        \n', '        require(registry[_name].expires < now);\n', '        \n', '        removeName(_name);\n', '    }\n', '    \n', '    function removeNameByOwner(string _name) public {\n', '        \n', '        Name storage item = registry[_name];\n', '        \n', '        require(item.owner == msg.sender);\n', '        \n', '        removeName(_name);\n', '    }\n', '    \n', '\n', '    function sendTo(string _name) public payable {\n', '        \n', '        if (registry[_name].owner == address(0)) {\n', '            registry[_name].balance = registry[_name].balance.add(msg.value);\n', '        }\n', '        else {\n', '            registry[_name].owner.transfer(msg.value);\n', '        }\n', '    \n', '    }\n', '    \n', '    \n', '    \n', '    function setupCore(string _name, string _record, address _owner, uint _life) internal {\n', '        \n', '        Name storage item = registry[_name];\n', '        \n', '        require(item.owner == msg.sender || item.owner == 0x0);\n', '        item.record = _record;\n', '        item.owner = _owner;\n', '        if (item.balance > 0) {\n', '            item.owner.transfer(item.balance);\n', '            item.balance = 0;\n', '        }\n', '        item.expires = now + _life;\n', '        bytes32 hash = keccak256(_record);\n', '        lookup[hash] = _name;\n', '        \n', '    }\n', '\n', '    function setupViaAuthority(\n', '        string _length,\n', '        string _name,\n', '        string _record,\n', '        string _blockExpiry,\n', '        address _owner,\n', '        uint8 _v, \n', '        bytes32 _r, \n', '        bytes32 _s,\n', '        uint _life\n', '    ) internal {\n', '        \n', '        require(_blockExpiry.stringToUint() >= block.number);\n', '        \n', '        require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n", _length, _name, "r=", _record, "e=", _blockExpiry), _v, _r, _s) == issuer);\n', '        \n', '        setupCore(_name, _record, _owner, _life);\n', '        \n', '    }\n', '\n', '    function setOrUpdateRecord2(\n', '        string _length,\n', '        string _name,\n', '        string _record,\n', '        string _blockExpiry,\n', '        address _owner,\n', '        uint8 _v, \n', '        bytes32 _r, \n', '        bytes32 _s\n', '    ) public {\n', '        \n', '        Contributor storage contributor = contributors[msg.sender];\n', '        \n', '        require(contributor.balance >= tokenPrice);\n', '        \n', '        contributor.balance = contributor.balance.sub(tokenPrice);\n', '        \n', '        uint life = 48 weeks;\n', '     \n', '        setupViaAuthority(_length, _name, _record, _blockExpiry, _owner, _v, _r, _s, life);   \n', '    }\n', '\n', '    function setOrUpdateRecord(\n', '        string _length,\n', '        string _name,\n', '        string _record,\n', '        string _blockExpiry,\n', '        address _owner,\n', '        uint8 _v, \n', '        bytes32 _r, \n', '        bytes32 _s\n', '    ) public payable {\n', '        \n', '        uint life = msg.value == 0.01  ether ?  48 weeks : \n', '                    msg.value == 0.008 ether ?  24 weeks :\n', '                    msg.value == 0.006 ether ?  12 weeks :\n', '                    msg.value == 0.002 ether ?  4  weeks :\n', '                    0;\n', '                       \n', '        require(life > 0);\n', '        \n', '        setupViaAuthority(_length, _name, _record, _blockExpiry, _owner, _v, _r, _s, life);\n', '    }\n', '}']
