['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' *  @title Smart City Crowdsale contract http://www.smartcitycoin.io\n', ' */\n', '\n', 'contract SmartCityToken {\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {}\n', '    \n', '    function setTokenStart(uint256 _newStartTime) public {}\n', '\n', '    function burn() public {}\n', '}\n', '\n', 'contract SmartCityCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    // State\n', '\n', '    struct Account {\n', '        uint256 accounted;   // received amount and bonus\n', '        uint256 received;    // received amount\n', '    }\n', '\n', '    /// Crowdsale participants\n', '    mapping (address => Account) public buyins;\n', '\n', '    /// Balances of Fixed Price sale participants.\n', '    mapping(address => uint256) public purchases;\n', '\n', '    /// Total amount of ether received.\n', '    uint256 public totalReceived = 0;\n', '\n', '    /// Total amount of ether accounted.\n', '    uint256 public totalAccounted = 0;\n', '\n', '    /// Total tokens purchased during Phase 2.\n', '    uint256 public tokensPurchased = 0;\n', '\n', '    /// Total amount of ether which has been finalised.\n', '    uint256 public totalFinalised = 0;\n', '    \n', '    /// Phase 1 end time.\n', '    uint256 public firstPhaseEndTime;\n', '    \n', '    /// Phase 2 start time.\n', '    uint256 public secondPhaseStartTime;\n', '    \n', '    /// Campaign end time.\n', '    uint256 public endTime;\n', '\n', '    /// The price per token aftre Phase 1. Works also as an effective price in Phase 2 for Phase 1 participants.\n', '    uint256 public auctionEndPrice;\n', '    \n', '    /// The price for token within Phase 2 which is effective for those who did not participate in Phase 1\n', '    uint256 public fixedPrice;\n', '\n', '    /// The current percentage of bonus.\n', '    uint256 public currentBonus = 15;\n', '\n', '    /// Bonus that will be applied to purchases if Target is reached in Phase 1. Initially zero.\n', '    uint256 public auctionSuccessBonus = 0;\n', '    \n', '    /// Must be false for any public function to be called.\n', '    bool public paused = false;\n', '    \n', '    /// Campaign is ended\n', '    bool public campaignEnded = false;\n', '\n', '    // Constants after constructor:\n', '\n', '    /// CITY token contract.\n', '    SmartCityToken public tokenContract;\n', '\n', '    /// The owner address.\n', '    address public owner;\n', '\n', '    /// The wallet address.\n', '    address public wallet;\n', '\n', '    /// Sale start time.\n', '    uint256 public startTime;\n', '\n', '    /// Amount of tokens allocated for Phase 1.\n', '    /// Once totalAccounted / currentPrice is greater than this value, Phase 1 ends.\n', '    uint256 public tokenCapPhaseOne;\n', '    \n', '    /// Amount of tokens allocated for Phase 2\n', '    uint256 public tokenCapPhaseTwo;\n', '\n', '\n', '    // Static constants:\n', '\n', '    /// Target\n', '    uint256 constant public FUNDING_GOAL = 109573 ether;\n', '    \n', '    /// Minimum token price after Phase 1 for Phase 2 to be started.\n', '    uint256 constant public TOKEN_MIN_PRICE_THRESHOLD = 100000000; // 0,00001 ETH per 1 CITY\n', '    \n', '    /// Maximum duration of Phase 1\n', '    uint256 constant public FIRST_PHASE_MAX_SPAN = 21 days;\n', '    \n', '    /// Maximum duration of Phase 2\n', '    uint256 constant public SECOND_PHASE_MAX_SPAN = 33 days;\n', '    \n', '    /// Minimum investment amount\n', '    uint256 constant public DUST_LIMIT = 5 finney;\n', '\n', '    /// Number of days from Phase 1 beginning when bonus is available. Bonus percentage drops by 1 percent a day.\n', '    uint256 constant public BONUS_DURATION = 15;\n', '    \n', '    /// Percentage of bonus that will be applied to all purchases if Target is reached in Phase 1\n', '    uint256 constant public SUCCESS_BONUS = 15;\n', '    \n', '    /// token price in Phase 2 is by 20 % higher when resulting auction price\n', '    /// for those who did not participate in auction\n', '    uint256 constant public SECOND_PHASE_PRICE_FACTOR = 20;\n', '\n', '    /// 1e15\n', '    uint256 constant public FACTOR = 1 finney;\n', '\n', '    /// Divisor of the token.\n', '    uint256 constant public DIVISOR = 100000;\n', '\n', '    // Events\n', '\n', '    /// Buyin event.\n', '    event Buyin(address indexed receiver, uint256 accounted, uint256 received, uint256 price);\n', '\n', '    /// Phase 1 just ended.\n', '    event PhaseOneEnded(uint256 price);\n', '    \n', '    /// Phase 2 is engagaed.\n', '    event PhaseTwoStared(uint256 fixedPrice);\n', '\n', '    /// Investement event.\n', '    event Invested(address indexed receiver, uint256 received, uint256 tokens);\n', '\n', '    /// The campaign just ended.\n', '    event Ended(bool goalReached);\n', '\n', '    /// Finalised the purchase for receiver.\n', '    event Finalised(address indexed receiver, uint256 tokens);\n', '\n', '    /// Campaign is over. All accounts finalised.\n', '    event Retired();\n', '    \n', '    // Modifiers\n', '    \n', '    /// Ensure the sale is ended.\n', '    modifier when_ended { require (now >= endTime); _; }\n', '\n', '    /// Ensure sale is not paused.\n', '    modifier when_not_halted { require (!paused); _; }\n', '\n', '    /// Ensure `_receiver` is a participant.\n', '    modifier only_investors(address _receiver) { require (buyins[_receiver].accounted != 0 || purchases[_receiver] != 0); _; }\n', '\n', '    /// Ensure sender is owner.\n', '    modifier only_owner { require (msg.sender == owner); _; }\n', '    \n', '    /// Ensure sale is in progress.\n', '    modifier when_active { require (!campaignEnded); _;}\n', '\n', '    /// Ensure phase 1 is in progress\n', '    modifier only_in_phase_1 { require (now >= startTime && now < firstPhaseEndTime); _; }\n', '    \n', '    /// Ensure phase 1 is over\n', '    modifier after_phase_1 { require (now >= firstPhaseEndTime); _; }\n', '\n', '    /// Ensure phase 2 is in progress\n', '    modifier only_in_phase_2 { require (now >= secondPhaseStartTime && now < endTime); _; }\n', '\n', '    /// Ensure the value sent is above threshold.\n', '    modifier reject_dust { require ( msg.value >= DUST_LIMIT ); _; }\n', '\n', '    // Constructor\n', '\n', '    function SmartCityCrowdsale(\n', '        address _tokenAddress,\n', '        address _owner,\n', '        address _walletAddress,\n', '        uint256 _startTime,\n', '        uint256 _tokenCapPhaseOne,\n', '        uint256 _tokenCapPhaseTwo\n', '    )\n', '        public\n', '    {\n', '        tokenContract = SmartCityToken(_tokenAddress);\n', '        wallet = _walletAddress;\n', '        owner = _owner;\n', '        startTime = _startTime;\n', '        firstPhaseEndTime = startTime.add(FIRST_PHASE_MAX_SPAN);\n', '        secondPhaseStartTime = 253402300799; // initialise by setting to 9999/12/31\n', '        endTime = secondPhaseStartTime.add(SECOND_PHASE_MAX_SPAN);\n', '        tokenCapPhaseOne = _tokenCapPhaseOne;\n', '        tokenCapPhaseTwo = _tokenCapPhaseTwo;\n', '    }\n', '\n', '    /// The default fallback function\n', '    /// Calls buyin or invest function depending on current campaign phase\n', '    /// Throws if campaign has already ended\n', '    function()\n', '        public\n', '        payable\n', '        when_not_halted\n', '        when_active\n', '    {\n', '        if (now >= startTime && now < firstPhaseEndTime) { // phase 1 is ongoing\n', '            _buyin(msg.sender, msg.value);\n', '        }\n', '        else {\n', '            _invest(msg.sender, msg.value);\n', '        }\n', '    }\n', '\n', '    // Phase 1 functions\n', '\n', '    /// buyin function.\n', '    function buyin()\n', '        public\n', '        payable\n', '        when_not_halted\n', '        when_active\n', '        only_in_phase_1\n', '        reject_dust\n', '    {\n', '        _buyin(msg.sender, msg.value);\n', '    }\n', '    \n', '    ///  buyinAs function. takes the receiver address as an argument\n', '    function buyinAs(address _receiver)\n', '        public\n', '        payable\n', '        when_not_halted\n', '        when_active\n', '        only_in_phase_1\n', '        reject_dust\n', '    {\n', '        require (_receiver != address(0));\n', '        _buyin(_receiver, msg.value);\n', '    }\n', '    \n', '    /// internal buyin functionality\n', '    function _buyin(address _receiver, uint256 _value)\n', '        internal\n', '    {\n', '        if (currentBonus > 0) {\n', '            uint256 daysSinceStart = (now.sub(startTime)).div(86400); // # of days\n', '\n', '            if (daysSinceStart < BONUS_DURATION &&\n', '                BONUS_DURATION.sub(daysSinceStart) != currentBonus) {\n', '                currentBonus = BONUS_DURATION.sub(daysSinceStart);\n', '            }\n', '            if (daysSinceStart >= BONUS_DURATION) {\n', '                currentBonus = 0;\n', '            }\n', '        }\n', '\n', '        uint256 accounted;\n', '        bool refund;\n', '        uint256 price;\n', '\n', '        (accounted, refund, price) = theDeal(_value);\n', '\n', '        // effective cap should not be exceeded, throw\n', '        require (!refund);\n', '\n', '        // change state\n', '        buyins[_receiver].accounted = buyins[_receiver].accounted.add(accounted);\n', '        buyins[_receiver].received = buyins[_receiver].received.add(_value);\n', '        totalAccounted = totalAccounted.add(accounted);\n', '        totalReceived = totalReceived.add(_value);\n', '        firstPhaseEndTime = calculateEndTime();\n', '\n', '        Buyin(_receiver, accounted, _value, price);\n', '\n', '        // send to wallet\n', '        wallet.transfer(_value);\n', '    }\n', '\n', '    /// The current end time of the sale assuming that nobody else buys in.\n', '    function calculateEndTime()\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_1\n', '        returns (uint256)\n', '    {\n', '        uint256 res = (FACTOR.mul(240000).div(DIVISOR.mul(totalAccounted.div(tokenCapPhaseOne)).add(FACTOR.mul(4).div(100)))).add(startTime).sub(4848);\n', '\n', '        if (res >= firstPhaseEndTime) {\n', '            return firstPhaseEndTime;\n', '        }\n', '        else {\n', '            return res;\n', '        }\n', '    }\n', '    \n', '\n', '    /// The current price for a token\n', '    function currentPrice()\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_1\n', '        returns (uint256 weiPerIndivisibleTokenPart)\n', '    {\n', '        return ((FACTOR.mul(240000).div(now.sub(startTime).add(4848))).sub(FACTOR.mul(4).div(100))).div(DIVISOR);\n', '    }\n', '\n', '    /// Returns the total tokens which can be purchased right now.\n', '    function tokensAvailable()\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_1\n', '        returns (uint256 tokens)\n', '    {\n', '        uint256 _currentCap = totalAccounted.div(currentPrice());\n', '        if (_currentCap >= tokenCapPhaseOne) {\n', '            return 0;\n', '        }\n', '        return tokenCapPhaseOne.sub(_currentCap);\n', '    }\n', '\n', '    /// The largest purchase than can be done right now. For informational puproses only\n', '    function maxPurchase()\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_1\n', '        returns (uint256 spend)\n', '    {\n', '        return tokenCapPhaseOne.mul(currentPrice()).sub(totalAccounted);\n', '    }\n', '\n', '    /// Returns the number of tokens available per given price.\n', '    /// If this number exceeds tokens being currently available, returns refund = true\n', '    function theDeal(uint256 _value)\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_1\n', '        returns (uint256 accounted, bool refund, uint256 price)\n', '    {\n', '        uint256 _bonus = auctionBonus(_value);\n', '\n', '        price = currentPrice();\n', '        accounted = _value.add(_bonus);\n', '\n', '        uint256 available = tokensAvailable();\n', '        uint256 tokens = accounted.div(price);\n', '        refund = (tokens > available);\n', '    }\n', '\n', '    /// Returns bonus for given amount\n', '    function auctionBonus(uint256 _value)\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_1\n', '        returns (uint256 extra)\n', '    {\n', '        return _value.mul(currentBonus).div(100);\n', '    }\n', '\n', '    // After Phase 1\n', '    \n', '    /// Checks the results of the first phase\n', '    /// Changes state only once\n', '    function finaliseFirstPhase()\n', '        public\n', '        when_not_halted\n', '        when_active\n', '        after_phase_1\n', '        returns(uint256)\n', '    {\n', '        if (auctionEndPrice == 0) {\n', '            auctionEndPrice = totalAccounted.div(tokenCapPhaseOne);\n', '            PhaseOneEnded(auctionEndPrice);\n', '\n', '            // check if second phase should be engaged\n', '            if (totalAccounted >= FUNDING_GOAL ) {\n', '                // funding goal is reached: phase 2 is not engaged, all auction participants receive additional bonus, campaign is ended\n', '                auctionSuccessBonus = SUCCESS_BONUS;\n', '                endTime = firstPhaseEndTime;\n', '                campaignEnded = true;\n', '                \n', '                tokenContract.setTokenStart(endTime);\n', '\n', '                Ended(true);\n', '            }\n', '            \n', '            else if (auctionEndPrice >= TOKEN_MIN_PRICE_THRESHOLD) {\n', '                // funding goal is not reached, auctionEndPrice is above or equal to threshold value: engage phase 2\n', '                fixedPrice = auctionEndPrice.add(auctionEndPrice.mul(SECOND_PHASE_PRICE_FACTOR).div(100));\n', '                secondPhaseStartTime = now;\n', '                endTime = secondPhaseStartTime.add(SECOND_PHASE_MAX_SPAN);\n', '\n', '                PhaseTwoStared(fixedPrice);\n', '            }\n', '            else if (auctionEndPrice < TOKEN_MIN_PRICE_THRESHOLD && auctionEndPrice > 0){\n', '                // funding goal is not reached, auctionEndPrice is below threshold value: phase 2 is not engaged, campaign is ended\n', '                endTime = firstPhaseEndTime;\n', '                campaignEnded = true;\n', '\n', '                tokenContract.setTokenStart(endTime);\n', '\n', '                Ended(false);\n', '            }\n', '            else { // no one came, we are all alone in this world :(\n', '                auctionEndPrice = 1 wei;\n', '                endTime = firstPhaseEndTime;\n', '                campaignEnded = true;\n', '\n', '                tokenContract.setTokenStart(endTime);\n', '\n', '                Ended(false);\n', '\n', '                Retired();\n', '            }\n', '        }\n', '        \n', '        return auctionEndPrice;\n', '    }\n', '\n', '    // Phase 2 functions\n', '\n', '    /// Make an investment during second phase\n', '    function invest()\n', '        public\n', '        payable\n', '        when_not_halted\n', '        when_active\n', '        only_in_phase_2\n', '        reject_dust\n', '    {\n', '        _invest(msg.sender, msg.value);\n', '    }\n', '    \n', '    ///\n', '    function investAs(address _receiver)\n', '        public\n', '        payable\n', '        when_not_halted\n', '        when_active\n', '        only_in_phase_2\n', '        reject_dust\n', '    {\n', '        require (_receiver != address(0));\n', '        _invest(_receiver, msg.value);\n', '    }\n', '    \n', '    /// internal invest functionality\n', '    function _invest(address _receiver, uint256 _value)\n', '        internal\n', '    {\n', '        uint256 tokensCnt = getTokens(_receiver, _value); \n', '\n', '        require(tokensCnt > 0);\n', '        require(tokensPurchased.add(tokensCnt) <= tokenCapPhaseTwo); // should not exceed available tokens\n', '        require(_value <= maxTokenPurchase(_receiver)); // should not go above target\n', '\n', '        purchases[_receiver] = purchases[_receiver].add(_value);\n', '        totalReceived = totalReceived.add(_value);\n', '        totalAccounted = totalAccounted.add(_value);\n', '        tokensPurchased = tokensPurchased.add(tokensCnt);\n', '\n', '        Invested(_receiver, _value, tokensCnt);\n', '        \n', '        // send to wallet\n', '        wallet.transfer(_value);\n', '\n', '        // check if we&#39;ve reached the target\n', '        if (totalAccounted >= FUNDING_GOAL) {\n', '            endTime = now;\n', '            campaignEnded = true;\n', '            \n', '            tokenContract.setTokenStart(endTime);\n', '            \n', '            Ended(true);\n', '        }\n', '    }\n', '    \n', '    /// Tokens currently available for purchase in Phase 2\n', '    function getTokens(address _receiver, uint256 _value)\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_2\n', '        returns(uint256 tokensCnt)\n', '    {\n', '        // auction participants have better price in second phase\n', '        if (buyins[_receiver].received > 0) {\n', '            tokensCnt = _value.div(auctionEndPrice);\n', '        }\n', '        else {\n', '            tokensCnt = _value.div(fixedPrice);\n', '        }\n', '\n', '    }\n', '    \n', '    /// Maximum current purchase amount in Phase 2\n', '    function maxTokenPurchase(address _receiver)\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_2\n', '        returns(uint256 spend)\n', '    {\n', '        uint256 availableTokens = tokenCapPhaseTwo.sub(tokensPurchased);\n', '        uint256 fundingGoalOffset = FUNDING_GOAL.sub(totalReceived);\n', '        uint256 maxInvestment;\n', '        \n', '        if (buyins[_receiver].received > 0) {\n', '            maxInvestment = availableTokens.mul(auctionEndPrice);\n', '        }\n', '        else {\n', '            maxInvestment = availableTokens.mul(fixedPrice);\n', '        }\n', '\n', '        if (maxInvestment > fundingGoalOffset) {\n', '            return fundingGoalOffset;\n', '        }\n', '        else {\n', '            return maxInvestment;\n', '        }\n', '    }\n', '\n', '    // After sale end\n', '    \n', '    /// Finalise purchase: transfers the tokens to caller address\n', '    function finalise()\n', '        public\n', '        when_not_halted\n', '        when_ended\n', '        only_investors(msg.sender)\n', '    {\n', '        finaliseAs(msg.sender);\n', '    }\n', '\n', '    /// Finalise purchase for address provided: transfers the tokens purchased by given participant to their address\n', '    function finaliseAs(address _receiver)\n', '        public\n', '        when_not_halted\n', '        when_ended\n', '        only_investors(_receiver)\n', '    {\n', '        bool auctionParticipant;\n', '        uint256 total;\n', '        uint256 tokens;\n', '        uint256 bonus;\n', '        uint256 totalFixed;\n', '        uint256 tokensFixed;\n', '\n', '        // first time calling finalise after phase 2 has ended but target was not reached\n', '        if (!campaignEnded) {\n', '            campaignEnded = true;\n', '            \n', '            tokenContract.setTokenStart(endTime);\n', '            \n', '            Ended(false);\n', '        }\n', '\n', '        if (buyins[_receiver].accounted != 0) {\n', '            auctionParticipant = true;\n', '\n', '            total = buyins[_receiver].accounted;\n', '            tokens = total.div(auctionEndPrice);\n', '            \n', '            if (auctionSuccessBonus > 0) {\n', '                bonus = tokens.mul(auctionSuccessBonus).div(100);\n', '            }\n', '            totalFinalised = totalFinalised.add(total);\n', '            delete buyins[_receiver];\n', '        }\n', '        \n', '        if (purchases[_receiver] != 0) {\n', '            totalFixed = purchases[_receiver];\n', '            \n', '            if (auctionParticipant) {\n', '                tokensFixed = totalFixed.div(auctionEndPrice);\n', '            }\n', '            else {\n', '                tokensFixed = totalFixed.div(fixedPrice);\n', '            }\n', '            totalFinalised = totalFinalised.add(totalFixed);\n', '            delete purchases[_receiver];\n', '        }\n', '\n', '        tokens = tokens.add(bonus).add(tokensFixed);\n', '\n', '        require (tokenContract.transferFrom(owner, _receiver, tokens));\n', '\n', '        Finalised(_receiver, tokens);\n', '\n', '        if (totalFinalised == totalAccounted) {\n', '            tokenContract.burn(); // burn all unsold tokens\n', '            Retired();\n', '        }\n', '    }\n', '\n', '    // Owner functions\n', '\n', '    /// Emergency function to pause buy-in and finalisation.\n', '    function setPaused(bool _paused) public only_owner { paused = _paused; }\n', '\n', '    /// Emergency function to drain the contract of any funds.\n', '    function drain() public only_owner { wallet.transfer(this.balance); }\n', '    \n', '    /// Returns true if the campaign is in progress.\n', '    function isActive() public constant returns (bool) { return now >= startTime && now < endTime; }\n', '\n', '    /// Returns true if all purchases are finished.\n', '    function allFinalised() public constant returns (bool) { return now >= endTime && totalAccounted == totalFinalised; }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '    /**\n', '    *            CITY token by www.SmartCityCoin.io\n', '    * \n', '    *          .ossssss:                      `+sssss`      \n', '    *         ` +ssssss+` `.://++++++//:.`  .osssss+       \n', '    *            /sssssssssssssssssssssssss+ssssso`        \n', '    *             -sssssssssssssssssssssssssssss+`         \n', '    *            .+sssssssss+:--....--:/ossssssss+.        \n', '    *          `/ssssssssssso`         .sssssssssss/`      \n', '    *         .ossssss+sssssss-       :sssss+:ossssso.     \n', '    *        `ossssso. .ossssss:    `/sssss/  `/ssssss.    \n', '    *        ossssso`   `+ssssss+` .osssss:     /ssssss`   \n', '    *       :ssssss`      /sssssso:ssssso.       +o+/:-`   \n', '    *       osssss+        -sssssssssss+`                  \n', '    *       ssssss:         .ossssssss/                    \n', '    *       osssss/          `+ssssss-                     \n', '    *       /ssssso           :ssssss                      \n', '    *       .ssssss-          :ssssss                      \n', '    *        :ssssss-         :ssssss          `           \n', '    *         /ssssss/`       :ssssss        `/s+:`        \n', '    *          :sssssso:.     :ssssss      ./ssssss+`      \n', '    *           .+ssssssso/-.`:ssssss``.-/osssssss+.       \n', '    *             .+ssssssssssssssssssssssssssss+-         \n', '    *               `:+ssssssssssssssssssssss+:`           \n', '    *                  `.:+osssssssssssso+:.`              \n', '    *                        `/ssssss.`                    \n', '    *                         :ssssss                      \n', '    */']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' *  @title Smart City Crowdsale contract http://www.smartcitycoin.io\n', ' */\n', '\n', 'contract SmartCityToken {\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {}\n', '    \n', '    function setTokenStart(uint256 _newStartTime) public {}\n', '\n', '    function burn() public {}\n', '}\n', '\n', 'contract SmartCityCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    // State\n', '\n', '    struct Account {\n', '        uint256 accounted;   // received amount and bonus\n', '        uint256 received;    // received amount\n', '    }\n', '\n', '    /// Crowdsale participants\n', '    mapping (address => Account) public buyins;\n', '\n', '    /// Balances of Fixed Price sale participants.\n', '    mapping(address => uint256) public purchases;\n', '\n', '    /// Total amount of ether received.\n', '    uint256 public totalReceived = 0;\n', '\n', '    /// Total amount of ether accounted.\n', '    uint256 public totalAccounted = 0;\n', '\n', '    /// Total tokens purchased during Phase 2.\n', '    uint256 public tokensPurchased = 0;\n', '\n', '    /// Total amount of ether which has been finalised.\n', '    uint256 public totalFinalised = 0;\n', '    \n', '    /// Phase 1 end time.\n', '    uint256 public firstPhaseEndTime;\n', '    \n', '    /// Phase 2 start time.\n', '    uint256 public secondPhaseStartTime;\n', '    \n', '    /// Campaign end time.\n', '    uint256 public endTime;\n', '\n', '    /// The price per token aftre Phase 1. Works also as an effective price in Phase 2 for Phase 1 participants.\n', '    uint256 public auctionEndPrice;\n', '    \n', '    /// The price for token within Phase 2 which is effective for those who did not participate in Phase 1\n', '    uint256 public fixedPrice;\n', '\n', '    /// The current percentage of bonus.\n', '    uint256 public currentBonus = 15;\n', '\n', '    /// Bonus that will be applied to purchases if Target is reached in Phase 1. Initially zero.\n', '    uint256 public auctionSuccessBonus = 0;\n', '    \n', '    /// Must be false for any public function to be called.\n', '    bool public paused = false;\n', '    \n', '    /// Campaign is ended\n', '    bool public campaignEnded = false;\n', '\n', '    // Constants after constructor:\n', '\n', '    /// CITY token contract.\n', '    SmartCityToken public tokenContract;\n', '\n', '    /// The owner address.\n', '    address public owner;\n', '\n', '    /// The wallet address.\n', '    address public wallet;\n', '\n', '    /// Sale start time.\n', '    uint256 public startTime;\n', '\n', '    /// Amount of tokens allocated for Phase 1.\n', '    /// Once totalAccounted / currentPrice is greater than this value, Phase 1 ends.\n', '    uint256 public tokenCapPhaseOne;\n', '    \n', '    /// Amount of tokens allocated for Phase 2\n', '    uint256 public tokenCapPhaseTwo;\n', '\n', '\n', '    // Static constants:\n', '\n', '    /// Target\n', '    uint256 constant public FUNDING_GOAL = 109573 ether;\n', '    \n', '    /// Minimum token price after Phase 1 for Phase 2 to be started.\n', '    uint256 constant public TOKEN_MIN_PRICE_THRESHOLD = 100000000; // 0,00001 ETH per 1 CITY\n', '    \n', '    /// Maximum duration of Phase 1\n', '    uint256 constant public FIRST_PHASE_MAX_SPAN = 21 days;\n', '    \n', '    /// Maximum duration of Phase 2\n', '    uint256 constant public SECOND_PHASE_MAX_SPAN = 33 days;\n', '    \n', '    /// Minimum investment amount\n', '    uint256 constant public DUST_LIMIT = 5 finney;\n', '\n', '    /// Number of days from Phase 1 beginning when bonus is available. Bonus percentage drops by 1 percent a day.\n', '    uint256 constant public BONUS_DURATION = 15;\n', '    \n', '    /// Percentage of bonus that will be applied to all purchases if Target is reached in Phase 1\n', '    uint256 constant public SUCCESS_BONUS = 15;\n', '    \n', '    /// token price in Phase 2 is by 20 % higher when resulting auction price\n', '    /// for those who did not participate in auction\n', '    uint256 constant public SECOND_PHASE_PRICE_FACTOR = 20;\n', '\n', '    /// 1e15\n', '    uint256 constant public FACTOR = 1 finney;\n', '\n', '    /// Divisor of the token.\n', '    uint256 constant public DIVISOR = 100000;\n', '\n', '    // Events\n', '\n', '    /// Buyin event.\n', '    event Buyin(address indexed receiver, uint256 accounted, uint256 received, uint256 price);\n', '\n', '    /// Phase 1 just ended.\n', '    event PhaseOneEnded(uint256 price);\n', '    \n', '    /// Phase 2 is engagaed.\n', '    event PhaseTwoStared(uint256 fixedPrice);\n', '\n', '    /// Investement event.\n', '    event Invested(address indexed receiver, uint256 received, uint256 tokens);\n', '\n', '    /// The campaign just ended.\n', '    event Ended(bool goalReached);\n', '\n', '    /// Finalised the purchase for receiver.\n', '    event Finalised(address indexed receiver, uint256 tokens);\n', '\n', '    /// Campaign is over. All accounts finalised.\n', '    event Retired();\n', '    \n', '    // Modifiers\n', '    \n', '    /// Ensure the sale is ended.\n', '    modifier when_ended { require (now >= endTime); _; }\n', '\n', '    /// Ensure sale is not paused.\n', '    modifier when_not_halted { require (!paused); _; }\n', '\n', '    /// Ensure `_receiver` is a participant.\n', '    modifier only_investors(address _receiver) { require (buyins[_receiver].accounted != 0 || purchases[_receiver] != 0); _; }\n', '\n', '    /// Ensure sender is owner.\n', '    modifier only_owner { require (msg.sender == owner); _; }\n', '    \n', '    /// Ensure sale is in progress.\n', '    modifier when_active { require (!campaignEnded); _;}\n', '\n', '    /// Ensure phase 1 is in progress\n', '    modifier only_in_phase_1 { require (now >= startTime && now < firstPhaseEndTime); _; }\n', '    \n', '    /// Ensure phase 1 is over\n', '    modifier after_phase_1 { require (now >= firstPhaseEndTime); _; }\n', '\n', '    /// Ensure phase 2 is in progress\n', '    modifier only_in_phase_2 { require (now >= secondPhaseStartTime && now < endTime); _; }\n', '\n', '    /// Ensure the value sent is above threshold.\n', '    modifier reject_dust { require ( msg.value >= DUST_LIMIT ); _; }\n', '\n', '    // Constructor\n', '\n', '    function SmartCityCrowdsale(\n', '        address _tokenAddress,\n', '        address _owner,\n', '        address _walletAddress,\n', '        uint256 _startTime,\n', '        uint256 _tokenCapPhaseOne,\n', '        uint256 _tokenCapPhaseTwo\n', '    )\n', '        public\n', '    {\n', '        tokenContract = SmartCityToken(_tokenAddress);\n', '        wallet = _walletAddress;\n', '        owner = _owner;\n', '        startTime = _startTime;\n', '        firstPhaseEndTime = startTime.add(FIRST_PHASE_MAX_SPAN);\n', '        secondPhaseStartTime = 253402300799; // initialise by setting to 9999/12/31\n', '        endTime = secondPhaseStartTime.add(SECOND_PHASE_MAX_SPAN);\n', '        tokenCapPhaseOne = _tokenCapPhaseOne;\n', '        tokenCapPhaseTwo = _tokenCapPhaseTwo;\n', '    }\n', '\n', '    /// The default fallback function\n', '    /// Calls buyin or invest function depending on current campaign phase\n', '    /// Throws if campaign has already ended\n', '    function()\n', '        public\n', '        payable\n', '        when_not_halted\n', '        when_active\n', '    {\n', '        if (now >= startTime && now < firstPhaseEndTime) { // phase 1 is ongoing\n', '            _buyin(msg.sender, msg.value);\n', '        }\n', '        else {\n', '            _invest(msg.sender, msg.value);\n', '        }\n', '    }\n', '\n', '    // Phase 1 functions\n', '\n', '    /// buyin function.\n', '    function buyin()\n', '        public\n', '        payable\n', '        when_not_halted\n', '        when_active\n', '        only_in_phase_1\n', '        reject_dust\n', '    {\n', '        _buyin(msg.sender, msg.value);\n', '    }\n', '    \n', '    ///  buyinAs function. takes the receiver address as an argument\n', '    function buyinAs(address _receiver)\n', '        public\n', '        payable\n', '        when_not_halted\n', '        when_active\n', '        only_in_phase_1\n', '        reject_dust\n', '    {\n', '        require (_receiver != address(0));\n', '        _buyin(_receiver, msg.value);\n', '    }\n', '    \n', '    /// internal buyin functionality\n', '    function _buyin(address _receiver, uint256 _value)\n', '        internal\n', '    {\n', '        if (currentBonus > 0) {\n', '            uint256 daysSinceStart = (now.sub(startTime)).div(86400); // # of days\n', '\n', '            if (daysSinceStart < BONUS_DURATION &&\n', '                BONUS_DURATION.sub(daysSinceStart) != currentBonus) {\n', '                currentBonus = BONUS_DURATION.sub(daysSinceStart);\n', '            }\n', '            if (daysSinceStart >= BONUS_DURATION) {\n', '                currentBonus = 0;\n', '            }\n', '        }\n', '\n', '        uint256 accounted;\n', '        bool refund;\n', '        uint256 price;\n', '\n', '        (accounted, refund, price) = theDeal(_value);\n', '\n', '        // effective cap should not be exceeded, throw\n', '        require (!refund);\n', '\n', '        // change state\n', '        buyins[_receiver].accounted = buyins[_receiver].accounted.add(accounted);\n', '        buyins[_receiver].received = buyins[_receiver].received.add(_value);\n', '        totalAccounted = totalAccounted.add(accounted);\n', '        totalReceived = totalReceived.add(_value);\n', '        firstPhaseEndTime = calculateEndTime();\n', '\n', '        Buyin(_receiver, accounted, _value, price);\n', '\n', '        // send to wallet\n', '        wallet.transfer(_value);\n', '    }\n', '\n', '    /// The current end time of the sale assuming that nobody else buys in.\n', '    function calculateEndTime()\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_1\n', '        returns (uint256)\n', '    {\n', '        uint256 res = (FACTOR.mul(240000).div(DIVISOR.mul(totalAccounted.div(tokenCapPhaseOne)).add(FACTOR.mul(4).div(100)))).add(startTime).sub(4848);\n', '\n', '        if (res >= firstPhaseEndTime) {\n', '            return firstPhaseEndTime;\n', '        }\n', '        else {\n', '            return res;\n', '        }\n', '    }\n', '    \n', '\n', '    /// The current price for a token\n', '    function currentPrice()\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_1\n', '        returns (uint256 weiPerIndivisibleTokenPart)\n', '    {\n', '        return ((FACTOR.mul(240000).div(now.sub(startTime).add(4848))).sub(FACTOR.mul(4).div(100))).div(DIVISOR);\n', '    }\n', '\n', '    /// Returns the total tokens which can be purchased right now.\n', '    function tokensAvailable()\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_1\n', '        returns (uint256 tokens)\n', '    {\n', '        uint256 _currentCap = totalAccounted.div(currentPrice());\n', '        if (_currentCap >= tokenCapPhaseOne) {\n', '            return 0;\n', '        }\n', '        return tokenCapPhaseOne.sub(_currentCap);\n', '    }\n', '\n', '    /// The largest purchase than can be done right now. For informational puproses only\n', '    function maxPurchase()\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_1\n', '        returns (uint256 spend)\n', '    {\n', '        return tokenCapPhaseOne.mul(currentPrice()).sub(totalAccounted);\n', '    }\n', '\n', '    /// Returns the number of tokens available per given price.\n', '    /// If this number exceeds tokens being currently available, returns refund = true\n', '    function theDeal(uint256 _value)\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_1\n', '        returns (uint256 accounted, bool refund, uint256 price)\n', '    {\n', '        uint256 _bonus = auctionBonus(_value);\n', '\n', '        price = currentPrice();\n', '        accounted = _value.add(_bonus);\n', '\n', '        uint256 available = tokensAvailable();\n', '        uint256 tokens = accounted.div(price);\n', '        refund = (tokens > available);\n', '    }\n', '\n', '    /// Returns bonus for given amount\n', '    function auctionBonus(uint256 _value)\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_1\n', '        returns (uint256 extra)\n', '    {\n', '        return _value.mul(currentBonus).div(100);\n', '    }\n', '\n', '    // After Phase 1\n', '    \n', '    /// Checks the results of the first phase\n', '    /// Changes state only once\n', '    function finaliseFirstPhase()\n', '        public\n', '        when_not_halted\n', '        when_active\n', '        after_phase_1\n', '        returns(uint256)\n', '    {\n', '        if (auctionEndPrice == 0) {\n', '            auctionEndPrice = totalAccounted.div(tokenCapPhaseOne);\n', '            PhaseOneEnded(auctionEndPrice);\n', '\n', '            // check if second phase should be engaged\n', '            if (totalAccounted >= FUNDING_GOAL ) {\n', '                // funding goal is reached: phase 2 is not engaged, all auction participants receive additional bonus, campaign is ended\n', '                auctionSuccessBonus = SUCCESS_BONUS;\n', '                endTime = firstPhaseEndTime;\n', '                campaignEnded = true;\n', '                \n', '                tokenContract.setTokenStart(endTime);\n', '\n', '                Ended(true);\n', '            }\n', '            \n', '            else if (auctionEndPrice >= TOKEN_MIN_PRICE_THRESHOLD) {\n', '                // funding goal is not reached, auctionEndPrice is above or equal to threshold value: engage phase 2\n', '                fixedPrice = auctionEndPrice.add(auctionEndPrice.mul(SECOND_PHASE_PRICE_FACTOR).div(100));\n', '                secondPhaseStartTime = now;\n', '                endTime = secondPhaseStartTime.add(SECOND_PHASE_MAX_SPAN);\n', '\n', '                PhaseTwoStared(fixedPrice);\n', '            }\n', '            else if (auctionEndPrice < TOKEN_MIN_PRICE_THRESHOLD && auctionEndPrice > 0){\n', '                // funding goal is not reached, auctionEndPrice is below threshold value: phase 2 is not engaged, campaign is ended\n', '                endTime = firstPhaseEndTime;\n', '                campaignEnded = true;\n', '\n', '                tokenContract.setTokenStart(endTime);\n', '\n', '                Ended(false);\n', '            }\n', '            else { // no one came, we are all alone in this world :(\n', '                auctionEndPrice = 1 wei;\n', '                endTime = firstPhaseEndTime;\n', '                campaignEnded = true;\n', '\n', '                tokenContract.setTokenStart(endTime);\n', '\n', '                Ended(false);\n', '\n', '                Retired();\n', '            }\n', '        }\n', '        \n', '        return auctionEndPrice;\n', '    }\n', '\n', '    // Phase 2 functions\n', '\n', '    /// Make an investment during second phase\n', '    function invest()\n', '        public\n', '        payable\n', '        when_not_halted\n', '        when_active\n', '        only_in_phase_2\n', '        reject_dust\n', '    {\n', '        _invest(msg.sender, msg.value);\n', '    }\n', '    \n', '    ///\n', '    function investAs(address _receiver)\n', '        public\n', '        payable\n', '        when_not_halted\n', '        when_active\n', '        only_in_phase_2\n', '        reject_dust\n', '    {\n', '        require (_receiver != address(0));\n', '        _invest(_receiver, msg.value);\n', '    }\n', '    \n', '    /// internal invest functionality\n', '    function _invest(address _receiver, uint256 _value)\n', '        internal\n', '    {\n', '        uint256 tokensCnt = getTokens(_receiver, _value); \n', '\n', '        require(tokensCnt > 0);\n', '        require(tokensPurchased.add(tokensCnt) <= tokenCapPhaseTwo); // should not exceed available tokens\n', '        require(_value <= maxTokenPurchase(_receiver)); // should not go above target\n', '\n', '        purchases[_receiver] = purchases[_receiver].add(_value);\n', '        totalReceived = totalReceived.add(_value);\n', '        totalAccounted = totalAccounted.add(_value);\n', '        tokensPurchased = tokensPurchased.add(tokensCnt);\n', '\n', '        Invested(_receiver, _value, tokensCnt);\n', '        \n', '        // send to wallet\n', '        wallet.transfer(_value);\n', '\n', "        // check if we've reached the target\n", '        if (totalAccounted >= FUNDING_GOAL) {\n', '            endTime = now;\n', '            campaignEnded = true;\n', '            \n', '            tokenContract.setTokenStart(endTime);\n', '            \n', '            Ended(true);\n', '        }\n', '    }\n', '    \n', '    /// Tokens currently available for purchase in Phase 2\n', '    function getTokens(address _receiver, uint256 _value)\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_2\n', '        returns(uint256 tokensCnt)\n', '    {\n', '        // auction participants have better price in second phase\n', '        if (buyins[_receiver].received > 0) {\n', '            tokensCnt = _value.div(auctionEndPrice);\n', '        }\n', '        else {\n', '            tokensCnt = _value.div(fixedPrice);\n', '        }\n', '\n', '    }\n', '    \n', '    /// Maximum current purchase amount in Phase 2\n', '    function maxTokenPurchase(address _receiver)\n', '        public\n', '        constant\n', '        when_active\n', '        only_in_phase_2\n', '        returns(uint256 spend)\n', '    {\n', '        uint256 availableTokens = tokenCapPhaseTwo.sub(tokensPurchased);\n', '        uint256 fundingGoalOffset = FUNDING_GOAL.sub(totalReceived);\n', '        uint256 maxInvestment;\n', '        \n', '        if (buyins[_receiver].received > 0) {\n', '            maxInvestment = availableTokens.mul(auctionEndPrice);\n', '        }\n', '        else {\n', '            maxInvestment = availableTokens.mul(fixedPrice);\n', '        }\n', '\n', '        if (maxInvestment > fundingGoalOffset) {\n', '            return fundingGoalOffset;\n', '        }\n', '        else {\n', '            return maxInvestment;\n', '        }\n', '    }\n', '\n', '    // After sale end\n', '    \n', '    /// Finalise purchase: transfers the tokens to caller address\n', '    function finalise()\n', '        public\n', '        when_not_halted\n', '        when_ended\n', '        only_investors(msg.sender)\n', '    {\n', '        finaliseAs(msg.sender);\n', '    }\n', '\n', '    /// Finalise purchase for address provided: transfers the tokens purchased by given participant to their address\n', '    function finaliseAs(address _receiver)\n', '        public\n', '        when_not_halted\n', '        when_ended\n', '        only_investors(_receiver)\n', '    {\n', '        bool auctionParticipant;\n', '        uint256 total;\n', '        uint256 tokens;\n', '        uint256 bonus;\n', '        uint256 totalFixed;\n', '        uint256 tokensFixed;\n', '\n', '        // first time calling finalise after phase 2 has ended but target was not reached\n', '        if (!campaignEnded) {\n', '            campaignEnded = true;\n', '            \n', '            tokenContract.setTokenStart(endTime);\n', '            \n', '            Ended(false);\n', '        }\n', '\n', '        if (buyins[_receiver].accounted != 0) {\n', '            auctionParticipant = true;\n', '\n', '            total = buyins[_receiver].accounted;\n', '            tokens = total.div(auctionEndPrice);\n', '            \n', '            if (auctionSuccessBonus > 0) {\n', '                bonus = tokens.mul(auctionSuccessBonus).div(100);\n', '            }\n', '            totalFinalised = totalFinalised.add(total);\n', '            delete buyins[_receiver];\n', '        }\n', '        \n', '        if (purchases[_receiver] != 0) {\n', '            totalFixed = purchases[_receiver];\n', '            \n', '            if (auctionParticipant) {\n', '                tokensFixed = totalFixed.div(auctionEndPrice);\n', '            }\n', '            else {\n', '                tokensFixed = totalFixed.div(fixedPrice);\n', '            }\n', '            totalFinalised = totalFinalised.add(totalFixed);\n', '            delete purchases[_receiver];\n', '        }\n', '\n', '        tokens = tokens.add(bonus).add(tokensFixed);\n', '\n', '        require (tokenContract.transferFrom(owner, _receiver, tokens));\n', '\n', '        Finalised(_receiver, tokens);\n', '\n', '        if (totalFinalised == totalAccounted) {\n', '            tokenContract.burn(); // burn all unsold tokens\n', '            Retired();\n', '        }\n', '    }\n', '\n', '    // Owner functions\n', '\n', '    /// Emergency function to pause buy-in and finalisation.\n', '    function setPaused(bool _paused) public only_owner { paused = _paused; }\n', '\n', '    /// Emergency function to drain the contract of any funds.\n', '    function drain() public only_owner { wallet.transfer(this.balance); }\n', '    \n', '    /// Returns true if the campaign is in progress.\n', '    function isActive() public constant returns (bool) { return now >= startTime && now < endTime; }\n', '\n', '    /// Returns true if all purchases are finished.\n', '    function allFinalised() public constant returns (bool) { return now >= endTime && totalAccounted == totalFinalised; }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '    /**\n', '    *            CITY token by www.SmartCityCoin.io\n', '    * \n', '    *          .ossssss:                      `+sssss`      \n', '    *         ` +ssssss+` `.://++++++//:.`  .osssss+       \n', '    *            /sssssssssssssssssssssssss+ssssso`        \n', '    *             -sssssssssssssssssssssssssssss+`         \n', '    *            .+sssssssss+:--....--:/ossssssss+.        \n', '    *          `/ssssssssssso`         .sssssssssss/`      \n', '    *         .ossssss+sssssss-       :sssss+:ossssso.     \n', '    *        `ossssso. .ossssss:    `/sssss/  `/ssssss.    \n', '    *        ossssso`   `+ssssss+` .osssss:     /ssssss`   \n', '    *       :ssssss`      /sssssso:ssssso.       +o+/:-`   \n', '    *       osssss+        -sssssssssss+`                  \n', '    *       ssssss:         .ossssssss/                    \n', '    *       osssss/          `+ssssss-                     \n', '    *       /ssssso           :ssssss                      \n', '    *       .ssssss-          :ssssss                      \n', '    *        :ssssss-         :ssssss          `           \n', '    *         /ssssss/`       :ssssss        `/s+:`        \n', '    *          :sssssso:.     :ssssss      ./ssssss+`      \n', '    *           .+ssssssso/-.`:ssssss``.-/osssssss+.       \n', '    *             .+ssssssssssssssssssssssssssss+-         \n', '    *               `:+ssssssssssssssssssssss+:`           \n', '    *                  `.:+osssssssssssso+:.`              \n', '    *                        `/ssssss.`                    \n', '    *                         :ssssss                      \n', '    */']
