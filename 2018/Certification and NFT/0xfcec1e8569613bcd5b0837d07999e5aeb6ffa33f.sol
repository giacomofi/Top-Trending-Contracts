['pragma solidity ^0.4.23;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to relinquish control of the contract.\n', '    */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '  * @title StockPortfolio\n', '  * @author aflesher\n', '  * @dev StockPortfolio is smart contract for keeping a record\n', '  * @dev stock purchases. Trades can more or less be validated\n', '  * @dev using the trade timestamp and comparing the data to\n', '  * @dev historical values.\n', '  */\n', 'contract StockPortfolio is Ownable {\n', '\n', '    struct Position {\n', '        uint32 quantity;\n', '        uint32 avgPrice;\n', '    }\n', '\n', '    mapping (bytes12 => Position) positions;\n', '    bytes12[] private holdings;\n', '    bytes6[] private markets;\n', '\n', '    event Bought(bytes6 market, bytes6 symbol, uint32 quantity, uint32 price, uint256 timestamp);\n', '    event Sold(bytes6 market, bytes6 symbol, uint32 quantity, uint32 price, int64 profits, uint256 timestamp);\n', '    event ForwardSplit(bytes6 market, bytes6 symbol, uint8 multiple, uint256 timestamp);\n', '    event ReverseSplit(bytes6 market, bytes6 symbol, uint8 divisor, uint256 timestamp);\n', '\n', '    // Profits have to be separated because of different curriences so\n', '    // separate them by market. Market profit to currency can be worked\n', '    // out by client\n', '    mapping (bytes6 => int) public profits;\n', '\n', '    constructor () public {\n', '        markets.push(0x6e7973650000); //nyse 0\n', '        markets.push(0x6e6173646171); //nasdaq 1\n', '        markets.push(0x747378000000); //tsx 2\n', '        markets.push(0x747378760000); //tsxv 3\n', '        markets.push(0x6f7463000000); //otc 4\n', '        markets.push(0x637365000000); //cse 5\n', '    }\n', '\n', '    function () public payable {}\n', '\n', '    /**\n', '     * @dev Adds to or creates new position\n', '     * @param _marketIndex The index of the market\n', '     * @param _symbol A stock symbol\n', '     * @param _quantity Quantity of shares to buy\n', '     * @param _price Price per share * 100 ($10.24 = 1024)\n', '     */\n', '    function buy\n', '    (\n', '        uint8 _marketIndex,\n', '        bytes6 _symbol,\n', '        uint32 _quantity,\n', '        uint32 _price\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        _buy(_marketIndex, _symbol, _quantity, _price);\n', '    }\n', '\n', '    /**\n', '     * @dev Adds to or creates a series of positions\n', '     * @param _marketIndexes The indexes of the markets\n', '     * @param _symbols Stock symbols\n', '     * @param _quantities Quantities of shares to buy\n', '     * @param _prices Prices per share * 100 ($10.24 = 1024)\n', '     */\n', '    function bulkBuy\n', '    (\n', '        uint8[] _marketIndexes,\n', '        bytes6[] _symbols,\n', '        uint32[] _quantities,\n', '        uint32[] _prices\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        for (uint i = 0; i < _symbols.length; i++) {\n', '            _buy(_marketIndexes[i], _symbols[i], _quantities[i], _prices[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Tracks a stock split\n', '     * @param _marketIndex The index of the market\n', '     * @param _symbol A stock symbol\n', '     * @param _multiple Number of new shares per share created\n', '     */\n', '    function split\n', '    (\n', '        uint8 _marketIndex,\n', '        bytes6 _symbol,\n', '        uint8 _multiple\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        bytes6 market = markets[_marketIndex];\n', '        bytes12 stockKey = getStockKey(market, _symbol);\n', '        Position storage position = positions[stockKey];\n', '        require(position.quantity > 0);\n', '        uint32 quantity = (_multiple * position.quantity) - position.quantity;\n', '        position.avgPrice = (position.quantity * position.avgPrice) / (position.quantity + quantity);\n', '        position.quantity += quantity;\n', '\n', '        emit ForwardSplit(market, _symbol, _multiple, now);\n', '    }\n', '\n', '    /**\n', '     * @dev Tracks a reverse stock split\n', '     * @param _marketIndex The index of the market\n', '     * @param _symbol A stock symbol\n', '     * @param _divisor Number of existing shares that will equal 1 new share\n', '     * @param _price The current stock price. Remainder shares will sold at this price\n', '     */\n', '    function reverseSplit\n', '    (\n', '        uint8 _marketIndex,\n', '        bytes6 _symbol,\n', '        uint8 _divisor,\n', '        uint32 _price\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        bytes6 market = markets[_marketIndex];\n', '        bytes12 stockKey = getStockKey(market, _symbol);\n', '        Position storage position = positions[stockKey];\n', '        require(position.quantity > 0);\n', '        uint32 quantity = position.quantity / _divisor;\n', '        uint32 extraQuantity = position.quantity - (quantity * _divisor);\n', '        if (extraQuantity > 0) {\n', '            _sell(_marketIndex, _symbol, extraQuantity, _price);\n', '        }\n', '        position.avgPrice = position.avgPrice * _divisor;\n', '        position.quantity = quantity;\n', '\n', '        emit ReverseSplit(market, _symbol, _divisor, now);\n', '    }\n', '\n', '    /**\n', '     * @dev Sells a position, adds a new trade and adds profits/lossses\n', '     * @param _symbol Stock symbol\n', '     * @param _quantity Quantity of shares to sale\n', '     * @param _price Price per share * 100 ($10.24 = 1024)\n', '     */\n', '    function sell\n', '    (\n', '        uint8 _marketIndex,\n', '        bytes6 _symbol,\n', '        uint32 _quantity,\n', '        uint32 _price\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        _sell(_marketIndex, _symbol, _quantity, _price);\n', '    }\n', '\n', '    /**\n', '     * @dev Sells positions, adds a new trades and adds profits/lossses\n', '     * @param _symbols Stock symbols\n', '     * @param _quantities Quantities of shares to sale\n', '     * @param _prices Prices per share * 100 ($10.24 = 1024)\n', '     */\n', '    function bulkSell\n', '    (\n', '        uint8[] _marketIndexes,\n', '        bytes6[] _symbols,\n', '        uint32[] _quantities,\n', '        uint32[] _prices\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        for (uint i = 0; i < _symbols.length; i++) {\n', '            _sell(_marketIndexes[i], _symbols[i], _quantities[i], _prices[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Get the number of markets\n', '     * @return uint\n', '     */\n', '    function getMarketsCount() public view returns(uint) {\n', '        return markets.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Get a market at a given index\n', '     * @param _index The market index\n', '     * @return bytes6 market name\n', '     */\n', '    function getMarket(uint _index) public view returns(bytes6) {\n', '        return markets[_index];\n', '    }\n', '\n', '    /**\n', '     * @dev Get profits\n', '     * @param _market The market name\n', '     * @return int\n', '     */\n', '    function getProfits(bytes6 _market) public view returns(int) {\n', '        return profits[_market];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets a position\n', '     * @param _stockKey The stock key\n', '     * @return quantity Quantity of shares held\n', '     * @return avgPrice Average price paid for shares\n', '     */\n', '    function getPosition\n', '    (\n', '        bytes12 _stockKey\n', '    )\n', '        public\n', '        view\n', '        returns\n', '        (\n', '            uint32 quantity,\n', '            uint32 avgPrice\n', '        )\n', '    {\n', '        Position storage position = positions[_stockKey];\n', '        quantity = position.quantity;\n', '        avgPrice = position.avgPrice;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets a postion at the given index\n', '     * @param _index The index of the holding\n', '     * @return market Market name\n', '     * @return stock Stock name\n', '     * @return quantity Quantity of shares held\n', '     * @return avgPrice Average price paid for shares\n', '     */  \n', '    function getPositionFromHolding\n', '    (\n', '        uint _index\n', '    )\n', '        public\n', '        view\n', '        returns\n', '        (\n', '            bytes6 market, \n', '            bytes6 symbol,\n', '            uint32 quantity,\n', '            uint32 avgPrice\n', '        )\n', '    {\n', '        bytes12 stockKey = holdings[_index];\n', '        (market, symbol) = recoverStockKey(stockKey);\n', '        Position storage position = positions[stockKey];\n', '        quantity = position.quantity;\n', '        avgPrice = position.avgPrice;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the number of stocks being held\n', '     * @return uint\n', '     */\n', '    function getHoldingsCount() public view returns(uint) {\n', '        return holdings.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the stock key at the given index\n', '     * @return bytes32 The unique stock key\n', '     */\n', '    function getHolding(uint _index) public view returns(bytes12) {\n', '        return holdings[_index];\n', '    }\n', '\n', '    /**\n', '     * @dev Generates a unique key for a stock by combining the market and symbol\n', '     * @param _market Stock market\n', '     * @param _symbol Stock symbol\n', '     * @return key The key\n', '     */\n', '    function getStockKey(bytes6 _market, bytes6 _symbol) public pure returns(bytes12 key) {\n', '        bytes memory combined = new bytes(12);\n', '        for (uint i = 0; i < 6; i++) {\n', '            combined[i] = _market[i];\n', '        }\n', '        for (uint j = 0; j < 6; j++) {\n', '            combined[j + 6] = _symbol[j];\n', '        }\n', '        assembly {\n', '            key := mload(add(combined, 32))\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev Splits a unique key for a stock and returns the market and symbol\n', '     * @param _key Unique stock key\n', '     * @return market Stock market\n', '     * @return symbol Stock symbol\n', '     */\n', '    function recoverStockKey(bytes12 _key) public pure returns(bytes6 market, bytes6 symbol) {\n', '        bytes memory _market = new bytes(6);\n', '        bytes memory _symbol = new bytes(6);\n', '        for (uint i = 0; i < 6; i++) {\n', '            _market[i] = _key[i];\n', '        }\n', '        for (uint j = 0; j < 6; j++) {\n', '            _symbol[j] = _key[j + 6];\n', '        }\n', '        assembly {\n', '            market := mload(add(_market, 32))\n', '            symbol := mload(add(_symbol, 32))\n', '        }\n', '    }\n', '\n', '    function addMarket(bytes6 _market) public onlyOwner {\n', '        markets.push(_market);\n', '    }\n', '\n', '    function _addHolding(bytes12 _stockKey) private {\n', '        holdings.push(_stockKey);\n', '    }\n', '\n', '    function _removeHolding(bytes12 _stockKey) private {\n', '        if (holdings.length == 0) {\n', '            return;\n', '        }\n', '        bool found = false;\n', '        for (uint i = 0; i < holdings.length; i++) {\n', '            if (found) {\n', '                holdings[i - 1] = holdings[i];\n', '            }\n', '\n', '            if (holdings[i] == _stockKey) {\n', '                found = true;\n', '            }\n', '        }\n', '        if (found) {\n', '            delete holdings[holdings.length - 1];\n', '            holdings.length--;\n', '        }\n', '    }\n', '\n', '    function _sell\n', '    (\n', '        uint8 _marketIndex,\n', '        bytes6 _symbol,\n', '        uint32 _quantity,\n', '        uint32 _price\n', '    )\n', '        private\n', '    {\n', '        bytes6 market = markets[_marketIndex];\n', '        bytes12 stockKey = getStockKey(market, _symbol);\n', '        Position storage position = positions[stockKey];\n', '        require(position.quantity >= _quantity);\n', '        int64 profit = int64(_quantity * _price) - int64(_quantity * position.avgPrice);\n', '        position.quantity -= _quantity;\n', '        if (position.quantity <= 0) {\n', '            _removeHolding(stockKey);\n', '            delete positions[stockKey];\n', '        }\n', '        profits[market] += profit;\n', '        emit Sold(market, _symbol, _quantity, _price, profit, now);\n', '    }\n', '\n', '    function _buy\n', '    (\n', '        uint8 _marketIndex,\n', '        bytes6 _symbol,\n', '        uint32 _quantity,\n', '        uint32 _price\n', '    )\n', '        private\n', '    {\n', '        bytes6 market = markets[_marketIndex];\n', '        bytes12 stockKey = getStockKey(market, _symbol);\n', '        Position storage position = positions[stockKey];\n', '        if (position.quantity == 0) {\n', '            _addHolding(stockKey);\n', '        }\n', '        position.avgPrice = ((position.quantity * position.avgPrice) + (_quantity * _price)) /\n', '            (position.quantity + _quantity);\n', '        position.quantity += _quantity;\n', '\n', '        emit Bought(market, _symbol, _quantity, _price, now);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to relinquish control of the contract.\n', '    */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '  * @title StockPortfolio\n', '  * @author aflesher\n', '  * @dev StockPortfolio is smart contract for keeping a record\n', '  * @dev stock purchases. Trades can more or less be validated\n', '  * @dev using the trade timestamp and comparing the data to\n', '  * @dev historical values.\n', '  */\n', 'contract StockPortfolio is Ownable {\n', '\n', '    struct Position {\n', '        uint32 quantity;\n', '        uint32 avgPrice;\n', '    }\n', '\n', '    mapping (bytes12 => Position) positions;\n', '    bytes12[] private holdings;\n', '    bytes6[] private markets;\n', '\n', '    event Bought(bytes6 market, bytes6 symbol, uint32 quantity, uint32 price, uint256 timestamp);\n', '    event Sold(bytes6 market, bytes6 symbol, uint32 quantity, uint32 price, int64 profits, uint256 timestamp);\n', '    event ForwardSplit(bytes6 market, bytes6 symbol, uint8 multiple, uint256 timestamp);\n', '    event ReverseSplit(bytes6 market, bytes6 symbol, uint8 divisor, uint256 timestamp);\n', '\n', '    // Profits have to be separated because of different curriences so\n', '    // separate them by market. Market profit to currency can be worked\n', '    // out by client\n', '    mapping (bytes6 => int) public profits;\n', '\n', '    constructor () public {\n', '        markets.push(0x6e7973650000); //nyse 0\n', '        markets.push(0x6e6173646171); //nasdaq 1\n', '        markets.push(0x747378000000); //tsx 2\n', '        markets.push(0x747378760000); //tsxv 3\n', '        markets.push(0x6f7463000000); //otc 4\n', '        markets.push(0x637365000000); //cse 5\n', '    }\n', '\n', '    function () public payable {}\n', '\n', '    /**\n', '     * @dev Adds to or creates new position\n', '     * @param _marketIndex The index of the market\n', '     * @param _symbol A stock symbol\n', '     * @param _quantity Quantity of shares to buy\n', '     * @param _price Price per share * 100 ($10.24 = 1024)\n', '     */\n', '    function buy\n', '    (\n', '        uint8 _marketIndex,\n', '        bytes6 _symbol,\n', '        uint32 _quantity,\n', '        uint32 _price\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        _buy(_marketIndex, _symbol, _quantity, _price);\n', '    }\n', '\n', '    /**\n', '     * @dev Adds to or creates a series of positions\n', '     * @param _marketIndexes The indexes of the markets\n', '     * @param _symbols Stock symbols\n', '     * @param _quantities Quantities of shares to buy\n', '     * @param _prices Prices per share * 100 ($10.24 = 1024)\n', '     */\n', '    function bulkBuy\n', '    (\n', '        uint8[] _marketIndexes,\n', '        bytes6[] _symbols,\n', '        uint32[] _quantities,\n', '        uint32[] _prices\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        for (uint i = 0; i < _symbols.length; i++) {\n', '            _buy(_marketIndexes[i], _symbols[i], _quantities[i], _prices[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Tracks a stock split\n', '     * @param _marketIndex The index of the market\n', '     * @param _symbol A stock symbol\n', '     * @param _multiple Number of new shares per share created\n', '     */\n', '    function split\n', '    (\n', '        uint8 _marketIndex,\n', '        bytes6 _symbol,\n', '        uint8 _multiple\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        bytes6 market = markets[_marketIndex];\n', '        bytes12 stockKey = getStockKey(market, _symbol);\n', '        Position storage position = positions[stockKey];\n', '        require(position.quantity > 0);\n', '        uint32 quantity = (_multiple * position.quantity) - position.quantity;\n', '        position.avgPrice = (position.quantity * position.avgPrice) / (position.quantity + quantity);\n', '        position.quantity += quantity;\n', '\n', '        emit ForwardSplit(market, _symbol, _multiple, now);\n', '    }\n', '\n', '    /**\n', '     * @dev Tracks a reverse stock split\n', '     * @param _marketIndex The index of the market\n', '     * @param _symbol A stock symbol\n', '     * @param _divisor Number of existing shares that will equal 1 new share\n', '     * @param _price The current stock price. Remainder shares will sold at this price\n', '     */\n', '    function reverseSplit\n', '    (\n', '        uint8 _marketIndex,\n', '        bytes6 _symbol,\n', '        uint8 _divisor,\n', '        uint32 _price\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        bytes6 market = markets[_marketIndex];\n', '        bytes12 stockKey = getStockKey(market, _symbol);\n', '        Position storage position = positions[stockKey];\n', '        require(position.quantity > 0);\n', '        uint32 quantity = position.quantity / _divisor;\n', '        uint32 extraQuantity = position.quantity - (quantity * _divisor);\n', '        if (extraQuantity > 0) {\n', '            _sell(_marketIndex, _symbol, extraQuantity, _price);\n', '        }\n', '        position.avgPrice = position.avgPrice * _divisor;\n', '        position.quantity = quantity;\n', '\n', '        emit ReverseSplit(market, _symbol, _divisor, now);\n', '    }\n', '\n', '    /**\n', '     * @dev Sells a position, adds a new trade and adds profits/lossses\n', '     * @param _symbol Stock symbol\n', '     * @param _quantity Quantity of shares to sale\n', '     * @param _price Price per share * 100 ($10.24 = 1024)\n', '     */\n', '    function sell\n', '    (\n', '        uint8 _marketIndex,\n', '        bytes6 _symbol,\n', '        uint32 _quantity,\n', '        uint32 _price\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        _sell(_marketIndex, _symbol, _quantity, _price);\n', '    }\n', '\n', '    /**\n', '     * @dev Sells positions, adds a new trades and adds profits/lossses\n', '     * @param _symbols Stock symbols\n', '     * @param _quantities Quantities of shares to sale\n', '     * @param _prices Prices per share * 100 ($10.24 = 1024)\n', '     */\n', '    function bulkSell\n', '    (\n', '        uint8[] _marketIndexes,\n', '        bytes6[] _symbols,\n', '        uint32[] _quantities,\n', '        uint32[] _prices\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        for (uint i = 0; i < _symbols.length; i++) {\n', '            _sell(_marketIndexes[i], _symbols[i], _quantities[i], _prices[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Get the number of markets\n', '     * @return uint\n', '     */\n', '    function getMarketsCount() public view returns(uint) {\n', '        return markets.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Get a market at a given index\n', '     * @param _index The market index\n', '     * @return bytes6 market name\n', '     */\n', '    function getMarket(uint _index) public view returns(bytes6) {\n', '        return markets[_index];\n', '    }\n', '\n', '    /**\n', '     * @dev Get profits\n', '     * @param _market The market name\n', '     * @return int\n', '     */\n', '    function getProfits(bytes6 _market) public view returns(int) {\n', '        return profits[_market];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets a position\n', '     * @param _stockKey The stock key\n', '     * @return quantity Quantity of shares held\n', '     * @return avgPrice Average price paid for shares\n', '     */\n', '    function getPosition\n', '    (\n', '        bytes12 _stockKey\n', '    )\n', '        public\n', '        view\n', '        returns\n', '        (\n', '            uint32 quantity,\n', '            uint32 avgPrice\n', '        )\n', '    {\n', '        Position storage position = positions[_stockKey];\n', '        quantity = position.quantity;\n', '        avgPrice = position.avgPrice;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets a postion at the given index\n', '     * @param _index The index of the holding\n', '     * @return market Market name\n', '     * @return stock Stock name\n', '     * @return quantity Quantity of shares held\n', '     * @return avgPrice Average price paid for shares\n', '     */  \n', '    function getPositionFromHolding\n', '    (\n', '        uint _index\n', '    )\n', '        public\n', '        view\n', '        returns\n', '        (\n', '            bytes6 market, \n', '            bytes6 symbol,\n', '            uint32 quantity,\n', '            uint32 avgPrice\n', '        )\n', '    {\n', '        bytes12 stockKey = holdings[_index];\n', '        (market, symbol) = recoverStockKey(stockKey);\n', '        Position storage position = positions[stockKey];\n', '        quantity = position.quantity;\n', '        avgPrice = position.avgPrice;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the number of stocks being held\n', '     * @return uint\n', '     */\n', '    function getHoldingsCount() public view returns(uint) {\n', '        return holdings.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the stock key at the given index\n', '     * @return bytes32 The unique stock key\n', '     */\n', '    function getHolding(uint _index) public view returns(bytes12) {\n', '        return holdings[_index];\n', '    }\n', '\n', '    /**\n', '     * @dev Generates a unique key for a stock by combining the market and symbol\n', '     * @param _market Stock market\n', '     * @param _symbol Stock symbol\n', '     * @return key The key\n', '     */\n', '    function getStockKey(bytes6 _market, bytes6 _symbol) public pure returns(bytes12 key) {\n', '        bytes memory combined = new bytes(12);\n', '        for (uint i = 0; i < 6; i++) {\n', '            combined[i] = _market[i];\n', '        }\n', '        for (uint j = 0; j < 6; j++) {\n', '            combined[j + 6] = _symbol[j];\n', '        }\n', '        assembly {\n', '            key := mload(add(combined, 32))\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev Splits a unique key for a stock and returns the market and symbol\n', '     * @param _key Unique stock key\n', '     * @return market Stock market\n', '     * @return symbol Stock symbol\n', '     */\n', '    function recoverStockKey(bytes12 _key) public pure returns(bytes6 market, bytes6 symbol) {\n', '        bytes memory _market = new bytes(6);\n', '        bytes memory _symbol = new bytes(6);\n', '        for (uint i = 0; i < 6; i++) {\n', '            _market[i] = _key[i];\n', '        }\n', '        for (uint j = 0; j < 6; j++) {\n', '            _symbol[j] = _key[j + 6];\n', '        }\n', '        assembly {\n', '            market := mload(add(_market, 32))\n', '            symbol := mload(add(_symbol, 32))\n', '        }\n', '    }\n', '\n', '    function addMarket(bytes6 _market) public onlyOwner {\n', '        markets.push(_market);\n', '    }\n', '\n', '    function _addHolding(bytes12 _stockKey) private {\n', '        holdings.push(_stockKey);\n', '    }\n', '\n', '    function _removeHolding(bytes12 _stockKey) private {\n', '        if (holdings.length == 0) {\n', '            return;\n', '        }\n', '        bool found = false;\n', '        for (uint i = 0; i < holdings.length; i++) {\n', '            if (found) {\n', '                holdings[i - 1] = holdings[i];\n', '            }\n', '\n', '            if (holdings[i] == _stockKey) {\n', '                found = true;\n', '            }\n', '        }\n', '        if (found) {\n', '            delete holdings[holdings.length - 1];\n', '            holdings.length--;\n', '        }\n', '    }\n', '\n', '    function _sell\n', '    (\n', '        uint8 _marketIndex,\n', '        bytes6 _symbol,\n', '        uint32 _quantity,\n', '        uint32 _price\n', '    )\n', '        private\n', '    {\n', '        bytes6 market = markets[_marketIndex];\n', '        bytes12 stockKey = getStockKey(market, _symbol);\n', '        Position storage position = positions[stockKey];\n', '        require(position.quantity >= _quantity);\n', '        int64 profit = int64(_quantity * _price) - int64(_quantity * position.avgPrice);\n', '        position.quantity -= _quantity;\n', '        if (position.quantity <= 0) {\n', '            _removeHolding(stockKey);\n', '            delete positions[stockKey];\n', '        }\n', '        profits[market] += profit;\n', '        emit Sold(market, _symbol, _quantity, _price, profit, now);\n', '    }\n', '\n', '    function _buy\n', '    (\n', '        uint8 _marketIndex,\n', '        bytes6 _symbol,\n', '        uint32 _quantity,\n', '        uint32 _price\n', '    )\n', '        private\n', '    {\n', '        bytes6 market = markets[_marketIndex];\n', '        bytes12 stockKey = getStockKey(market, _symbol);\n', '        Position storage position = positions[stockKey];\n', '        if (position.quantity == 0) {\n', '            _addHolding(stockKey);\n', '        }\n', '        position.avgPrice = ((position.quantity * position.avgPrice) + (_quantity * _price)) /\n', '            (position.quantity + _quantity);\n', '        position.quantity += _quantity;\n', '\n', '        emit Bought(market, _symbol, _quantity, _price, now);\n', '    }\n', '\n', '}']
