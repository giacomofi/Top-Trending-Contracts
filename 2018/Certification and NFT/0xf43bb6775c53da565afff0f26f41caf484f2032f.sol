['pragma solidity 0.4.19;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Helps contracts guard agains reentrancy attacks.\n', ' * @author Remco Bloemen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="80f2e5ede3efc0b2">[email&#160;protected]</a>Ï€.com>\n', ' * @notice If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancy_lock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancy_lock);\n', '    reentrancy_lock = true;\n', '    _;\n', '    reentrancy_lock = false;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * EtherButton\n', ' *\n', ' * A game of financial hot potato. Players pay to click EtherButton.\n', ' * Each player is given 105% of their payment by each subsequent player.\n', ' * A seven hour timer resets after every click. The round advances once the timer reaches zero.\n', ' * \n', ' * Bonus:\n', ' *  For every player payout, an additional 1% is stored as an end-of-round bonus.\n', ' *  Each player is entitled to their bonus if they click EtherButton during the *next* round.\n', ' *  0.500 ETH is given to the last player of every round and their bonus is unlocked immediately.\n', ' *  Unclaimed bonuses are rolled into future rounds.\n', ' **/\n', 'contract EtherButton is Ownable, ReentrancyGuard {\n', '  // Use basic math operators which have integer overflow protection built into them.\n', '  // Simplifies code greatly by reducing the need to constantly check inputs for overflow.\n', '  using SafeMath for uint;\n', '\n', '  // Best practices say to prefix events with Log to avoid confusion.\n', '  // https://consensys.github.io/smart-contract-best-practices/recommendations/#differentiate-functions-and-events\n', '  event LogClick(\n', '    uint _id,\n', '    uint _price,\n', '    uint _previousPrice,\n', '    uint _endTime,\n', '    uint _clickCount,\n', '    uint _totalBonus,\n', '    address _activePlayer,\n', '    uint _activePlayerClickCount,\n', '    uint _previousRoundTotalBonus\n', '  );\n', '  event LogClaimBonus(address _recipient, uint _bonus);\n', '  event LogPlayerPayout(address _recipient, uint _amount);\n', '  event LogSendPaymentFailure(address _recipient, uint _amount);\n', '\n', '  // Represent fractions as numerator/denominator because Solidity doesn&#39;t support decimals.\n', '  // It&#39;s okay to use ".5 ether" because it converts to "500000000000000000 wei"\n', '  uint public constant INITIAL_PRICE = .5 ether;\n', '  uint public constant ROUND_DURATION = 7 hours;\n', '  // 5% price increase is allocated to the player.\n', '  uint private constant PLAYER_PROFIT_NUMERATOR = 5;\n', '  uint private constant PLAYER_PROFIT_DENOMINATOR = 100;\n', '  // 1% price increase is allocated to player bonuses.\n', '  uint private constant BONUS_NUMERATOR = 1;\n', '  uint private constant BONUS_DENOMINATOR = 100; \n', '  // 2.5% price increase is allocated to the owner.\n', '  uint private constant OWNER_FEE_NUMERATOR = 25;\n', '  uint private constant OWNER_FEE_DENOMINATOR = 1000;\n', '\n', '  // EtherButton is comprised of many rounds. Each round contains\n', '  // an isolated instance of game state.\n', '  struct Round {\n', '    uint id;\n', '    uint price;\n', '    uint previousPrice;\n', '    uint endTime;\n', '    uint clickCount;\n', '    uint totalBonus;\n', '    uint claimedBonus;\n', '    address activePlayer;\n', '    mapping (address => uint) playerClickCounts;\n', '    mapping (address => bool) bonusClaimedList;\n', '  }\n', '\n', '  // A list of all the rounds which have been played as well as\n', '  // the id of the current (active) round.\n', '  mapping (uint => Round) public Rounds;\n', '  uint public RoundId;\n', '\n', '  /**\n', '   * Create the contract with an initial &#39;Round 0&#39;. This round has already expired which will cause the first\n', '   * player interaction to start Round 1. This is simpler than introducing athe concept of a &#39;paused&#39; round.\n', '  **/\n', '  function EtherButton() public {\n', '    initializeRound();\n', '    Rounds[RoundId].endTime = now.sub(1);\n', '  }\n', '\n', '  /**\n', '   * Performs a single &#39;click&#39; of EtherButton.\n', '   *\n', '   * Advances the round if the previous round&#39;s endTime has passed. This needs to be done\n', '   * just-in-time because code isn&#39;t able to execute on a timer - it needs funding.\n', '   *\n', '   * Refunds the player any extra money they may have sent. Pays the last player and the owner.\n', '   * Marks the player as the active player so that they&#39;re next to be paid.\n', '   *\n', '   * Emits an event showing the current state of EtherButton and returns the state, too.\n', '  **/\n', '  function click() nonReentrant external payable {\n', '    // Owner is not allowed to play.\n', '    require(msg.sender != owner);\n', '\n', '    // There&#39;s no way to advance the round exactly at a specific time because the contract only runs\n', '    // when value is sent to it. So, round advancement must be done just-in-time whenever a player pays to click.\n', '    // Only advance the round when a player clicks because the next round&#39;s timer will begin immediately.\n', '    if (getIsRoundOver(RoundId)) {\n', '      advanceRound(); \n', '    }\n', '\n', '    Round storage round = Rounds[RoundId];\n', '\n', '    // Safe-guard against spam clicks from a single player.\n', '    require(msg.sender != round.activePlayer);\n', '    // Safe-guard against underpayment.\n', '    require(msg.value >= round.price);\n', '\n', '    // Refund player extra value beyond price. If EtherButton is very popular then its price may\n', '    // attempt to increase multiple times in a single block. In this situation, the first attempt\n', '    // would be successful, but subsequent attempts would fail due to insufficient funding. \n', '    // To combat this issue, a player may send more value than necessary to\n', '    // increase the chance of the price being payable with the amount of value they sent.\n', '    if (msg.value > round.price) {\n', '      sendPayment(msg.sender, msg.value.sub(round.price));\n', '    }\n', '\n', '    // Pay the active player and owner for each click past the first.\n', '    if (round.activePlayer != address(0)) {\n', '      // Pay the player first because that seems respectful.\n', '      // Log the player payouts to show on the website.\n', '      uint playerPayout = getPlayerPayout(round.previousPrice);\n', '      sendPayment(round.activePlayer, playerPayout);\n', '      LogPlayerPayout(round.activePlayer, playerPayout);\n', '\n', '      // Pay the contract owner as fee for game creation. Thank you! <3\n', '      sendPayment(owner, getOwnerFee(round.previousPrice));\n', '\n', '      // Keep track of bonuses collected at same time as sending payouts to ensure financial consistency.\n', '      round.totalBonus = round.totalBonus.add(getBonusFee(round.previousPrice));\n', '    }\n', '\n', '    // Update round state to reflect the additional click\n', '    round.activePlayer = msg.sender;\n', '    round.playerClickCounts[msg.sender] = round.playerClickCounts[msg.sender].add(1);\n', '    round.clickCount = round.clickCount.add(1);\n', '    round.previousPrice = round.price;\n', '    // Increment the price by 8.50%\n', '    round.price = getNextPrice(round.price);\n', '    // Reset the round timer\n', '    round.endTime = now.add(ROUND_DURATION);\n', '    \n', '    // Log an event with relevant information from the round&#39;s state.\n', '    LogClick(\n', '      round.id,\n', '      round.price,\n', '      round.previousPrice,\n', '      round.endTime,\n', '      round.clickCount,\n', '      round.totalBonus,\n', '      msg.sender,\n', '      round.playerClickCounts[msg.sender],\n', '      Rounds[RoundId.sub(1)].totalBonus\n', '    );\n', '  }\n', '\n', '  /**\n', '   * Provides bonus payments to players who wish to claim them.\n', '   * Bonuses accrue over the course of a round for those playing in the round.\n', '   * Bonuses may be claimed once the next round starts, but will remain locked until\n', '   * players participate in that round. The last active player of the previous round\n', '   * has their bonus unlocked immediately without need to play in the next round.\n', '   **/\n', '  function claimBonus() nonReentrant external {\n', '    // NOTE: The only way to advance the round is to run the &#39;click&#39; method. When a round is over, it will have expired,\n', '    // but RoundId will not have (yet) incremented. So, claimBonus needs to check the previous round. This allows EtherButton\n', '    // to never enter a &#39;paused&#39; state, which is less code (aka more reliable) but it does have some edge cases.\n', '    uint roundId = getIsRoundOver(RoundId) ? RoundId.add(1) : RoundId;\n', '    uint previousRoundId = roundId.sub(1);\n', '    bool isBonusClaimed = getIsBonusClaimed(previousRoundId, msg.sender);\n', '\n', '    // If player has already claimed their bonus exit early to keep code simple and cheap to run.\n', '    if (isBonusClaimed) {\n', '      return;\n', '    }\n', '\n', '    // If a player can&#39;t claim their bonus because they haven&#39;t played during the current round\n', '    // and they were not the last player in the previous round then exit as they&#39;re not authorized.\n', '    bool isBonusUnlockExempt = getIsBonusUnlockExempt(previousRoundId, msg.sender);\n', '    bool isBonusUnlocked = getPlayerClickCount(roundId, msg.sender) > 0;\n', '    if (!isBonusUnlockExempt && !isBonusUnlocked) {\n', '      return;\n', '    }\n', '\n', '    // If player is owed money from participation in previous round - send it.\n', '    Round storage previousRound = Rounds[previousRoundId];\n', '    uint playerClickCount = previousRound.playerClickCounts[msg.sender];\n', '    uint roundClickCount = previousRound.clickCount;\n', '    // NOTE: Be sure to multiply first to avoid decimal precision math.\n', '    uint bonus = previousRound.totalBonus.mul(playerClickCount).div(roundClickCount);\n', '\n', '    // If the current player is owed a refund from previous round fulfill that now.\n', '    // This is better than forcing the player to make a separate requests for\n', '    // bonuses and refund payouts.\n', '    if (previousRound.activePlayer == msg.sender) {\n', '      bonus = bonus.add(INITIAL_PRICE);\n', '    }\n', '\n', '    previousRound.bonusClaimedList[msg.sender] = true;\n', '    previousRound.claimedBonus = previousRound.claimedBonus.add(bonus);\n', '    sendPayment(msg.sender, bonus);\n', '\n', '    // Let the EtherButton website know a bonus was claimed successfully so it may update.\n', '    LogClaimBonus(msg.sender, bonus);\n', '  }\n', '\n', '  /**\n', '   * Returns true once the given player has claimed their bonus for the given round.\n', '   * Bonuses are only able to be claimed once per round per player.\n', '   **/\n', '  function getIsBonusClaimed(uint roundId, address player) public view returns (bool) {\n', '    return Rounds[roundId].bonusClaimedList[player];\n', '  }\n', '\n', '  /**\n', '   * Returns the number of times the given player has clicked EtherButton during the given round.\n', '   **/\n', '  function getPlayerClickCount(uint roundId, address player) public view returns (uint) {\n', '    return Rounds[roundId].playerClickCounts[player];\n', '  }\n', '\n', '  /**\n', '   * Returns true if the given player does not need to be unlocked to claim their bonus.\n', '   * This is true when they were the last player to click EtherButton in the previous round.\n', '   * That player deserves freebies for losing. So, they get their bonus unlocked early.\n', '   **/\n', '  function getIsBonusUnlockExempt(uint roundId, address player) public view returns (bool) {\n', '    return Rounds[roundId].activePlayer == player;\n', '  }\n', '\n', '  /**\n', '   * Returns true if enough time has elapsed since the active player clicked the\n', '   * button to consider the given round complete.\n', '   **/\n', '  function getIsRoundOver(uint roundId) private view returns (bool) {\n', '    return now > Rounds[roundId].endTime;\n', '  }\n', '\n', '  /**\n', '   * Signal the completion of a round and the start of the next by moving RoundId forward one.\n', '   * As clean-up before the round change occurs, join all unclaimed player bonuses together and move them\n', '   * forward one round. Just-in-time initialize the next round&#39;s state once RoundId is pointing to it because\n', '   * an unknown number of rounds may be played. So, it&#39;s impossible to initialize all rounds at contract creation.\n', '   **/\n', '  function advanceRound() private {\n', '    if (RoundId > 1) {\n', '      // Take all of the previous rounds unclaimed bonuses and roll them forward.\n', '      Round storage previousRound = Rounds[RoundId.sub(1)];      \n', '      // If the active player of the previous round didn&#39;t claim their refund then they lose the ability to claim it.\n', '      // Their refund is also rolled into the bonuses for the next round.\n', '      uint remainingBonus = previousRound.totalBonus.add(INITIAL_PRICE).sub(previousRound.claimedBonus);\n', '      Rounds[RoundId].totalBonus = Rounds[RoundId].totalBonus.add(remainingBonus);\n', '    }\n', '\n', '    RoundId = RoundId.add(1);\n', '    initializeRound();\n', '  }\n', '\n', '  /**\n', '   * Sets the current round&#39;s default values. Initialize the price to 0.500 ETH,\n', '   * the endTime to 7 hours past the current time and sets the round id. The round is\n', '   * also started as the endTime is now ticking down.\n', '   **/\n', '  function initializeRound() private {\n', '    Rounds[RoundId].id = RoundId;\n', '    Rounds[RoundId].endTime = block.timestamp.add(ROUND_DURATION);\n', '    Rounds[RoundId].price = INITIAL_PRICE;\n', '  }\n', '\n', '  /**\n', '   * Sends an amount of Ether to the recipient. Returns true if it was successful.\n', '   * Logs payment failures to provide documentation on attacks against the contract.\n', '   **/\n', '  function sendPayment(address recipient, uint amount) private returns (bool) {\n', '    assert(recipient != address(0));\n', '    assert(amount > 0);\n', '\n', '    // It&#39;s considered good practice to require users to pull payments rather than pushing\n', '    // payments to them. Since EtherButton pays the previous player immediately, it has to mitigate\n', '    // a denial-of-service attack. A malicious contract might always reject money which is sent to it.\n', '    // This contract could be used to disrupt EtherButton if an assumption is made that money will\n', '    // always be sent successfully.\n', '    // https://github.com/ConsenSys/smart-contract-best-practices/blob/master/docs/recommendations.md#favor-pull-over-push-for-external-calls\n', '    // Intentionally not using recipient.transfer to prevent this DOS attack vector.\n', '    bool result = recipient.send(amount);\n', '\n', '    // NOTE: Initially, this was written to allow users to reclaim funds on failure.\n', '    // This was removed due to concerns of allowing attackers to retrieve their funds. It is\n', '    // not possible for a regular wallet to reject a payment.\n', '    if (!result) {\n', '      // Log the failure so attempts to compromise the contract are documented.\n', '      LogSendPaymentFailure(recipient, amount);\n', '    }\n', '\n', '    return result;\n', '  }\n', '\n', '  /**\n', '    Returns the next price to click EtherButton. The returned value should be \n', '    8.50% larger than the current price:\n', '      - 5.00% is paid to the player.\n', '      - 1.00% is paid as bonuses.\n', '      - 2.50% is paid to the owner.\n', '   **/\n', '  function getNextPrice(uint price) private pure returns (uint) {\n', '    uint playerFee = getPlayerFee(price);\n', '    assert(playerFee > 0);\n', '\n', '    uint bonusFee = getBonusFee(price);\n', '    assert(bonusFee > 0);\n', '\n', '    uint ownerFee = getOwnerFee(price);\n', '    assert(ownerFee > 0);\n', '\n', '    return price.add(playerFee).add(bonusFee).add(ownerFee);\n', '  }\n', '\n', '  /**\n', '   * Returns 1.00% of the given price. Be sure to multiply before dividing to avoid decimals.\n', '   **/\n', '  function getBonusFee(uint price) private pure returns (uint) {\n', '    return price.mul(BONUS_NUMERATOR).div(BONUS_DENOMINATOR);\n', '  }\n', '\n', '  /**\n', '   * Returns 2.50% of the given price. Be sure to multiply before dividing to avoid decimals.\n', '   **/\n', '  function getOwnerFee(uint price) private pure returns (uint) {\n', '    return price.mul(OWNER_FEE_NUMERATOR).div(OWNER_FEE_DENOMINATOR);\n', '  }\n', '\n', '  /**\n', '   * Returns 5.00% of the given price. Be sure to multiply before dividing to avoid decimals.\n', '   **/\n', '  function getPlayerFee(uint price) private pure returns (uint) {\n', '    return price.mul(PLAYER_PROFIT_NUMERATOR).div(PLAYER_PROFIT_DENOMINATOR);\n', '  }\n', '\n', '  /**\n', '   * Returns the total amount of Ether the active player will receive. This is\n', '   * 105.00% of their initial price paid.\n', '   **/\n', '  function getPlayerPayout(uint price) private pure returns (uint) {\n', '    return price.add(getPlayerFee(price));\n', '  }\n', '}']
['pragma solidity 0.4.19;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Helps contracts guard agains reentrancy attacks.\n', ' * @author Remco Bloemen <remco@2Ï€.com>\n', ' * @notice If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancy_lock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancy_lock);\n', '    reentrancy_lock = true;\n', '    _;\n', '    reentrancy_lock = false;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * EtherButton\n', ' *\n', ' * A game of financial hot potato. Players pay to click EtherButton.\n', ' * Each player is given 105% of their payment by each subsequent player.\n', ' * A seven hour timer resets after every click. The round advances once the timer reaches zero.\n', ' * \n', ' * Bonus:\n', ' *  For every player payout, an additional 1% is stored as an end-of-round bonus.\n', ' *  Each player is entitled to their bonus if they click EtherButton during the *next* round.\n', ' *  0.500 ETH is given to the last player of every round and their bonus is unlocked immediately.\n', ' *  Unclaimed bonuses are rolled into future rounds.\n', ' **/\n', 'contract EtherButton is Ownable, ReentrancyGuard {\n', '  // Use basic math operators which have integer overflow protection built into them.\n', '  // Simplifies code greatly by reducing the need to constantly check inputs for overflow.\n', '  using SafeMath for uint;\n', '\n', '  // Best practices say to prefix events with Log to avoid confusion.\n', '  // https://consensys.github.io/smart-contract-best-practices/recommendations/#differentiate-functions-and-events\n', '  event LogClick(\n', '    uint _id,\n', '    uint _price,\n', '    uint _previousPrice,\n', '    uint _endTime,\n', '    uint _clickCount,\n', '    uint _totalBonus,\n', '    address _activePlayer,\n', '    uint _activePlayerClickCount,\n', '    uint _previousRoundTotalBonus\n', '  );\n', '  event LogClaimBonus(address _recipient, uint _bonus);\n', '  event LogPlayerPayout(address _recipient, uint _amount);\n', '  event LogSendPaymentFailure(address _recipient, uint _amount);\n', '\n', "  // Represent fractions as numerator/denominator because Solidity doesn't support decimals.\n", '  // It\'s okay to use ".5 ether" because it converts to "500000000000000000 wei"\n', '  uint public constant INITIAL_PRICE = .5 ether;\n', '  uint public constant ROUND_DURATION = 7 hours;\n', '  // 5% price increase is allocated to the player.\n', '  uint private constant PLAYER_PROFIT_NUMERATOR = 5;\n', '  uint private constant PLAYER_PROFIT_DENOMINATOR = 100;\n', '  // 1% price increase is allocated to player bonuses.\n', '  uint private constant BONUS_NUMERATOR = 1;\n', '  uint private constant BONUS_DENOMINATOR = 100; \n', '  // 2.5% price increase is allocated to the owner.\n', '  uint private constant OWNER_FEE_NUMERATOR = 25;\n', '  uint private constant OWNER_FEE_DENOMINATOR = 1000;\n', '\n', '  // EtherButton is comprised of many rounds. Each round contains\n', '  // an isolated instance of game state.\n', '  struct Round {\n', '    uint id;\n', '    uint price;\n', '    uint previousPrice;\n', '    uint endTime;\n', '    uint clickCount;\n', '    uint totalBonus;\n', '    uint claimedBonus;\n', '    address activePlayer;\n', '    mapping (address => uint) playerClickCounts;\n', '    mapping (address => bool) bonusClaimedList;\n', '  }\n', '\n', '  // A list of all the rounds which have been played as well as\n', '  // the id of the current (active) round.\n', '  mapping (uint => Round) public Rounds;\n', '  uint public RoundId;\n', '\n', '  /**\n', "   * Create the contract with an initial 'Round 0'. This round has already expired which will cause the first\n", "   * player interaction to start Round 1. This is simpler than introducing athe concept of a 'paused' round.\n", '  **/\n', '  function EtherButton() public {\n', '    initializeRound();\n', '    Rounds[RoundId].endTime = now.sub(1);\n', '  }\n', '\n', '  /**\n', "   * Performs a single 'click' of EtherButton.\n", '   *\n', "   * Advances the round if the previous round's endTime has passed. This needs to be done\n", "   * just-in-time because code isn't able to execute on a timer - it needs funding.\n", '   *\n', '   * Refunds the player any extra money they may have sent. Pays the last player and the owner.\n', "   * Marks the player as the active player so that they're next to be paid.\n", '   *\n', '   * Emits an event showing the current state of EtherButton and returns the state, too.\n', '  **/\n', '  function click() nonReentrant external payable {\n', '    // Owner is not allowed to play.\n', '    require(msg.sender != owner);\n', '\n', "    // There's no way to advance the round exactly at a specific time because the contract only runs\n", '    // when value is sent to it. So, round advancement must be done just-in-time whenever a player pays to click.\n', "    // Only advance the round when a player clicks because the next round's timer will begin immediately.\n", '    if (getIsRoundOver(RoundId)) {\n', '      advanceRound(); \n', '    }\n', '\n', '    Round storage round = Rounds[RoundId];\n', '\n', '    // Safe-guard against spam clicks from a single player.\n', '    require(msg.sender != round.activePlayer);\n', '    // Safe-guard against underpayment.\n', '    require(msg.value >= round.price);\n', '\n', '    // Refund player extra value beyond price. If EtherButton is very popular then its price may\n', '    // attempt to increase multiple times in a single block. In this situation, the first attempt\n', '    // would be successful, but subsequent attempts would fail due to insufficient funding. \n', '    // To combat this issue, a player may send more value than necessary to\n', '    // increase the chance of the price being payable with the amount of value they sent.\n', '    if (msg.value > round.price) {\n', '      sendPayment(msg.sender, msg.value.sub(round.price));\n', '    }\n', '\n', '    // Pay the active player and owner for each click past the first.\n', '    if (round.activePlayer != address(0)) {\n', '      // Pay the player first because that seems respectful.\n', '      // Log the player payouts to show on the website.\n', '      uint playerPayout = getPlayerPayout(round.previousPrice);\n', '      sendPayment(round.activePlayer, playerPayout);\n', '      LogPlayerPayout(round.activePlayer, playerPayout);\n', '\n', '      // Pay the contract owner as fee for game creation. Thank you! <3\n', '      sendPayment(owner, getOwnerFee(round.previousPrice));\n', '\n', '      // Keep track of bonuses collected at same time as sending payouts to ensure financial consistency.\n', '      round.totalBonus = round.totalBonus.add(getBonusFee(round.previousPrice));\n', '    }\n', '\n', '    // Update round state to reflect the additional click\n', '    round.activePlayer = msg.sender;\n', '    round.playerClickCounts[msg.sender] = round.playerClickCounts[msg.sender].add(1);\n', '    round.clickCount = round.clickCount.add(1);\n', '    round.previousPrice = round.price;\n', '    // Increment the price by 8.50%\n', '    round.price = getNextPrice(round.price);\n', '    // Reset the round timer\n', '    round.endTime = now.add(ROUND_DURATION);\n', '    \n', "    // Log an event with relevant information from the round's state.\n", '    LogClick(\n', '      round.id,\n', '      round.price,\n', '      round.previousPrice,\n', '      round.endTime,\n', '      round.clickCount,\n', '      round.totalBonus,\n', '      msg.sender,\n', '      round.playerClickCounts[msg.sender],\n', '      Rounds[RoundId.sub(1)].totalBonus\n', '    );\n', '  }\n', '\n', '  /**\n', '   * Provides bonus payments to players who wish to claim them.\n', '   * Bonuses accrue over the course of a round for those playing in the round.\n', '   * Bonuses may be claimed once the next round starts, but will remain locked until\n', '   * players participate in that round. The last active player of the previous round\n', '   * has their bonus unlocked immediately without need to play in the next round.\n', '   **/\n', '  function claimBonus() nonReentrant external {\n', "    // NOTE: The only way to advance the round is to run the 'click' method. When a round is over, it will have expired,\n", '    // but RoundId will not have (yet) incremented. So, claimBonus needs to check the previous round. This allows EtherButton\n', "    // to never enter a 'paused' state, which is less code (aka more reliable) but it does have some edge cases.\n", '    uint roundId = getIsRoundOver(RoundId) ? RoundId.add(1) : RoundId;\n', '    uint previousRoundId = roundId.sub(1);\n', '    bool isBonusClaimed = getIsBonusClaimed(previousRoundId, msg.sender);\n', '\n', '    // If player has already claimed their bonus exit early to keep code simple and cheap to run.\n', '    if (isBonusClaimed) {\n', '      return;\n', '    }\n', '\n', "    // If a player can't claim their bonus because they haven't played during the current round\n", "    // and they were not the last player in the previous round then exit as they're not authorized.\n", '    bool isBonusUnlockExempt = getIsBonusUnlockExempt(previousRoundId, msg.sender);\n', '    bool isBonusUnlocked = getPlayerClickCount(roundId, msg.sender) > 0;\n', '    if (!isBonusUnlockExempt && !isBonusUnlocked) {\n', '      return;\n', '    }\n', '\n', '    // If player is owed money from participation in previous round - send it.\n', '    Round storage previousRound = Rounds[previousRoundId];\n', '    uint playerClickCount = previousRound.playerClickCounts[msg.sender];\n', '    uint roundClickCount = previousRound.clickCount;\n', '    // NOTE: Be sure to multiply first to avoid decimal precision math.\n', '    uint bonus = previousRound.totalBonus.mul(playerClickCount).div(roundClickCount);\n', '\n', '    // If the current player is owed a refund from previous round fulfill that now.\n', '    // This is better than forcing the player to make a separate requests for\n', '    // bonuses and refund payouts.\n', '    if (previousRound.activePlayer == msg.sender) {\n', '      bonus = bonus.add(INITIAL_PRICE);\n', '    }\n', '\n', '    previousRound.bonusClaimedList[msg.sender] = true;\n', '    previousRound.claimedBonus = previousRound.claimedBonus.add(bonus);\n', '    sendPayment(msg.sender, bonus);\n', '\n', '    // Let the EtherButton website know a bonus was claimed successfully so it may update.\n', '    LogClaimBonus(msg.sender, bonus);\n', '  }\n', '\n', '  /**\n', '   * Returns true once the given player has claimed their bonus for the given round.\n', '   * Bonuses are only able to be claimed once per round per player.\n', '   **/\n', '  function getIsBonusClaimed(uint roundId, address player) public view returns (bool) {\n', '    return Rounds[roundId].bonusClaimedList[player];\n', '  }\n', '\n', '  /**\n', '   * Returns the number of times the given player has clicked EtherButton during the given round.\n', '   **/\n', '  function getPlayerClickCount(uint roundId, address player) public view returns (uint) {\n', '    return Rounds[roundId].playerClickCounts[player];\n', '  }\n', '\n', '  /**\n', '   * Returns true if the given player does not need to be unlocked to claim their bonus.\n', '   * This is true when they were the last player to click EtherButton in the previous round.\n', '   * That player deserves freebies for losing. So, they get their bonus unlocked early.\n', '   **/\n', '  function getIsBonusUnlockExempt(uint roundId, address player) public view returns (bool) {\n', '    return Rounds[roundId].activePlayer == player;\n', '  }\n', '\n', '  /**\n', '   * Returns true if enough time has elapsed since the active player clicked the\n', '   * button to consider the given round complete.\n', '   **/\n', '  function getIsRoundOver(uint roundId) private view returns (bool) {\n', '    return now > Rounds[roundId].endTime;\n', '  }\n', '\n', '  /**\n', '   * Signal the completion of a round and the start of the next by moving RoundId forward one.\n', '   * As clean-up before the round change occurs, join all unclaimed player bonuses together and move them\n', "   * forward one round. Just-in-time initialize the next round's state once RoundId is pointing to it because\n", "   * an unknown number of rounds may be played. So, it's impossible to initialize all rounds at contract creation.\n", '   **/\n', '  function advanceRound() private {\n', '    if (RoundId > 1) {\n', '      // Take all of the previous rounds unclaimed bonuses and roll them forward.\n', '      Round storage previousRound = Rounds[RoundId.sub(1)];      \n', "      // If the active player of the previous round didn't claim their refund then they lose the ability to claim it.\n", '      // Their refund is also rolled into the bonuses for the next round.\n', '      uint remainingBonus = previousRound.totalBonus.add(INITIAL_PRICE).sub(previousRound.claimedBonus);\n', '      Rounds[RoundId].totalBonus = Rounds[RoundId].totalBonus.add(remainingBonus);\n', '    }\n', '\n', '    RoundId = RoundId.add(1);\n', '    initializeRound();\n', '  }\n', '\n', '  /**\n', "   * Sets the current round's default values. Initialize the price to 0.500 ETH,\n", '   * the endTime to 7 hours past the current time and sets the round id. The round is\n', '   * also started as the endTime is now ticking down.\n', '   **/\n', '  function initializeRound() private {\n', '    Rounds[RoundId].id = RoundId;\n', '    Rounds[RoundId].endTime = block.timestamp.add(ROUND_DURATION);\n', '    Rounds[RoundId].price = INITIAL_PRICE;\n', '  }\n', '\n', '  /**\n', '   * Sends an amount of Ether to the recipient. Returns true if it was successful.\n', '   * Logs payment failures to provide documentation on attacks against the contract.\n', '   **/\n', '  function sendPayment(address recipient, uint amount) private returns (bool) {\n', '    assert(recipient != address(0));\n', '    assert(amount > 0);\n', '\n', "    // It's considered good practice to require users to pull payments rather than pushing\n", '    // payments to them. Since EtherButton pays the previous player immediately, it has to mitigate\n', '    // a denial-of-service attack. A malicious contract might always reject money which is sent to it.\n', '    // This contract could be used to disrupt EtherButton if an assumption is made that money will\n', '    // always be sent successfully.\n', '    // https://github.com/ConsenSys/smart-contract-best-practices/blob/master/docs/recommendations.md#favor-pull-over-push-for-external-calls\n', '    // Intentionally not using recipient.transfer to prevent this DOS attack vector.\n', '    bool result = recipient.send(amount);\n', '\n', '    // NOTE: Initially, this was written to allow users to reclaim funds on failure.\n', '    // This was removed due to concerns of allowing attackers to retrieve their funds. It is\n', '    // not possible for a regular wallet to reject a payment.\n', '    if (!result) {\n', '      // Log the failure so attempts to compromise the contract are documented.\n', '      LogSendPaymentFailure(recipient, amount);\n', '    }\n', '\n', '    return result;\n', '  }\n', '\n', '  /**\n', '    Returns the next price to click EtherButton. The returned value should be \n', '    8.50% larger than the current price:\n', '      - 5.00% is paid to the player.\n', '      - 1.00% is paid as bonuses.\n', '      - 2.50% is paid to the owner.\n', '   **/\n', '  function getNextPrice(uint price) private pure returns (uint) {\n', '    uint playerFee = getPlayerFee(price);\n', '    assert(playerFee > 0);\n', '\n', '    uint bonusFee = getBonusFee(price);\n', '    assert(bonusFee > 0);\n', '\n', '    uint ownerFee = getOwnerFee(price);\n', '    assert(ownerFee > 0);\n', '\n', '    return price.add(playerFee).add(bonusFee).add(ownerFee);\n', '  }\n', '\n', '  /**\n', '   * Returns 1.00% of the given price. Be sure to multiply before dividing to avoid decimals.\n', '   **/\n', '  function getBonusFee(uint price) private pure returns (uint) {\n', '    return price.mul(BONUS_NUMERATOR).div(BONUS_DENOMINATOR);\n', '  }\n', '\n', '  /**\n', '   * Returns 2.50% of the given price. Be sure to multiply before dividing to avoid decimals.\n', '   **/\n', '  function getOwnerFee(uint price) private pure returns (uint) {\n', '    return price.mul(OWNER_FEE_NUMERATOR).div(OWNER_FEE_DENOMINATOR);\n', '  }\n', '\n', '  /**\n', '   * Returns 5.00% of the given price. Be sure to multiply before dividing to avoid decimals.\n', '   **/\n', '  function getPlayerFee(uint price) private pure returns (uint) {\n', '    return price.mul(PLAYER_PROFIT_NUMERATOR).div(PLAYER_PROFIT_DENOMINATOR);\n', '  }\n', '\n', '  /**\n', '   * Returns the total amount of Ether the active player will receive. This is\n', '   * 105.00% of their initial price paid.\n', '   **/\n', '  function getPlayerPayout(uint price) private pure returns (uint) {\n', '    return price.add(getPlayerFee(price));\n', '  }\n', '}']
