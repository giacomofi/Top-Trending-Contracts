['pragma solidity ^0.4.23;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract TrueTogetherToken {\n', '\n', '    string public constant name = "TRUE Together Token";\n', '    string public constant symbol = "TTR";\n', '    uint256 public constant decimals = 18;\n', '    uint256 _totalSupply = 100000000 * 10 ** decimals;\n', '    address public founder = 0x0;\n', '    uint256 public voteEndTime;\n', '    uint256 airdropNum = 1 ether;\n', '    uint256 public distributed = 0;\n', '\n', '    mapping (address => bool) touched;\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => uint256) public frozen;\n', '    mapping (address => uint256) public totalVotes;\n', '\t\n', '    mapping (address => mapping (address => uint256)) public votingInfo;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Vote(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    constructor() public { \n', '        founder = msg.sender;\n', '        voteEndTime = 1534348800;\n', '    }\n', '\n', '    function totalSupply() view public returns (uint256 supply) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) public returns (uint256 balance) {\n', '        if (!touched[_owner] && SafeMath.add(distributed, airdropNum) < _totalSupply && now < voteEndTime) {\n', '            touched[_owner] = true;\n', '            distributed = SafeMath.add(distributed, airdropNum);\n', '            balances[_owner] = SafeMath.add(balances[_owner], airdropNum);\n', '            emit Transfer(this, _owner, airdropNum);\n', '        }\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        require (_to != 0x0);\n', '\n', '        if (now > voteEndTime) {\n', '            require((balances[msg.sender] >= _value));\n', '            balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n', '            balances[_to] = SafeMath.add(balances[_to], _value);\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\t \n', '        } else {\n', '            require(balances[msg.sender] >= SafeMath.add(frozen[msg.sender], _value));\n', '            balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n', '            balances[_to] = SafeMath.add(balances[_to], _value);\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\t \n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require (_to != 0x0);\n', '\n', '        if (now > voteEndTime) {\n', '            require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n', '            balances[_from] = SafeMath.sub(balances[_from], _value);\n', '            balances[_to] = SafeMath.add(balances[_to], _value);\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\t \n', '        } else {\n', '            require(balances[_from] >= SafeMath.add(frozen[_from], _value) && allowed[_from][msg.sender] >= _value);\n', '            balances[_from] = SafeMath.sub(balances[_from], _value);\n', '            balances[_to] = SafeMath.add(balances[_to], _value);\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\t \n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function distribute(address _to, uint256 _amount) public returns (bool success) {\n', '        require(msg.sender == founder);\n', '        require(SafeMath.add(distributed, _amount) <= _totalSupply);\n', '\n', '        distributed = SafeMath.add(distributed, _amount);\n', '        balances[_to] = SafeMath.add(balances[_to], _amount);\n', '        touched[_to] = true;\n', '        emit Transfer(this, _to, _amount);\n', '        return true;\n', '    }\n', '\t\n', '    function distributeMultiple(address[] _tos, uint256[] _values) public returns (bool success) {\n', '        require(msg.sender == founder);\n', '\t\t\n', '        uint256 total = 0;\n', '        uint256 i = 0; \n', '        for (i = 0; i < _tos.length; i++) {\n', '            total = SafeMath.add(total, _values[i]);\n', '        }\n', '\n', '        require(SafeMath.add(distributed, total) < _totalSupply);\n', '\n', '        for (i = 0; i < _tos.length; i++) {\n', '            distributed = SafeMath.add(distributed, _values[i]);\n', '            balances[_tos[i]] = SafeMath.add(balances[_tos[i]], _values[i]);\n', '            touched[_tos[i]] = true;\n', '            emit Transfer(this, _tos[i], _values[i]);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function vote(address _to, uint256 _value) public returns (bool success) {\n', '        require(_to != 0x0 && now < voteEndTime);\n', '        require(balances[msg.sender] >= SafeMath.add(frozen[msg.sender], _value));\n', '\n', '        frozen[msg.sender] = SafeMath.add(frozen[msg.sender], _value);\n', '        totalVotes[_to] = SafeMath.add(totalVotes[_to], _value);\n', '        votingInfo[_to][msg.sender] = SafeMath.add(votingInfo[_to][msg.sender], _value);\n', '        emit Vote(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function voteAll(address _to) public returns (bool success) {\n', '        require(_to != 0x0 && now < voteEndTime);\n', '        require(balances[msg.sender] > frozen[msg.sender]);\n', '        \n', '        uint256 votesNum = SafeMath.sub(balances[msg.sender], frozen[msg.sender]);\n', '        frozen[msg.sender] = balances[msg.sender];\n', '        totalVotes[_to] = SafeMath.add(totalVotes[_to], votesNum);\n', '        votingInfo[_to][msg.sender] = SafeMath.add(votingInfo[_to][msg.sender], votesNum);\n', '        emit Vote(msg.sender, _to, votesNum);\n', '        return true;\n', '    }\n', '\t\n', '    function setEndTime(uint256 _endTime) public {\n', '        require(msg.sender == founder);\n', '        voteEndTime = _endTime;\n', '    }\n', '\t\n', '    function ticketsOf(address _owner) view public returns (uint256 tickets) {\n', '        return SafeMath.sub(balances[_owner], frozen[_owner]);\n', '    }\n', '\n', '    function changeFounder(address newFounder) public {\n', '        require(msg.sender == founder);\n', '\n', '        founder = newFounder;\n', '    }\n', '\n', '    function kill() public {\n', '        require(msg.sender == founder);\n', '\n', '        selfdestruct(founder);\n', '    }\n', '}']