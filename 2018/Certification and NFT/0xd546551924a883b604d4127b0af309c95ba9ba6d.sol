['pragma solidity ^0.4.19;\n', '\n', '// \n', '// UberDelta Exchange Contract - v1.0.0\n', '// \n', '//  www.uberdelta.com\n', '//\n', '\n', 'contract Token {\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }\n', '  \n', '  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    require(b > 0); //gentler than an assert.\n', '    c = a / b;\n', '    return c;\n', '  }\n', '\n', '\n', '  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract OwnerManager {\n', '\n', '  address public owner;\n', '  address public newOwner;\n', '  address public manager;\n', '\n', '  event OwnershipTransferProposed(address indexed _from, address indexed _to);\n', '  event OwnershipTransferConfirmed(address indexed _from, address indexed _to);\n', '  event NewManager(address indexed _newManager);\n', '\n', '\n', '  modifier onlyOwner {\n', '    assert(msg.sender == owner);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyManager {\n', '    assert(msg.sender == manager);\n', '    _;\n', '  }\n', '\n', '\n', '  function OwnerManager() public{\n', '    owner = msg.sender;\n', '    manager = msg.sender;\n', '  }\n', '\n', '\n', '  function transferOwnership(address _newOwner) onlyOwner external{\n', '    require(_newOwner != owner);\n', '    \n', '    OwnershipTransferProposed(owner, _newOwner);\n', '    \n', '    newOwner = _newOwner;\n', '  }\n', '\n', '\n', '  function confirmOwnership() external {\n', '    assert(msg.sender == newOwner);\n', '    \n', '    OwnershipTransferConfirmed(owner, newOwner);\n', '    \n', '    owner = newOwner;\n', '  }\n', '\n', '\n', '  function newManager(address _newManager) onlyOwner external{\n', '    require(_newManager != address(0x0));\n', '    \n', '    NewManager(_newManager);\n', '    \n', '    manager = _newManager;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Helper is OwnerManager {\n', '\n', '  mapping (address => bool) public isHelper;\n', '\n', '  modifier onlyHelper {\n', '    assert(isHelper[msg.sender] == true);\n', '    _;\n', '  }\n', '\n', '  event ChangeHelper(\n', '    address indexed helper,\n', '    bool status\n', '  );\n', '\n', '  function Helper() public{\n', '    isHelper[msg.sender] = true;\n', '  }\n', '\n', '  function changeHelper(address _helper, bool _status) external onlyManager {\n', '\t  ChangeHelper(_helper, _status);\n', '    isHelper[_helper] = _status;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Compliance {\n', '  function canDeposit(address _user) public view returns (bool isAllowed);\n', '  function canTrade(address _token, address _user) public view returns (bool isAllowed);\n', '  function validateTrade(\n', '    address _token,\n', '    address _getUser,\n', '    address _giveUser\n', '  )\n', '    public\n', '    view\n', '    returns (bool isAllowed)\n', '  ;\n', '}\n', '\n', 'contract OptionRegistry {\n', '  function registerOptionPair(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  )\n', '  public\n', '  returns(bool)\n', '  ;\n', '  \n', '  function isOptionPairRegistered(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  )\n', '  public\n', '  view\n', '  returns(bool)  \n', '  ;\n', '  \n', '}\n', '\n', 'contract EOS {\n', '    function register(string key) public;\n', '}\n', '\n', 'contract UberDelta is SafeMath, OwnerManager, Helper {\n', '\n', '  // The account that will receive fees\n', '  address public feeAccount;\n', '  \n', '  // The account that will receive lost ERC20 tokens\n', '  address public sweepAccount;\n', '  \n', '  // The address of the compliance engine\n', '  address public complianceAddress;\n', '  \n', '  // The address of the options registry\n', '  address public optionsRegistryAddress;\n', '  \n', '  // The address of the next exchange contract\n', '  address public newExchange;\n', '\n', '  // Turn off deposits and trades, allow upgrade and withdraw\n', '  bool public contractLocked;\n', '  \n', '  bytes32 signedTradeHash = keccak256(\n', '    "address contractAddress",\n', '    "address takerTokenAddress",\n', '    "uint256 takerTokenAmount",\n', '    "address makerTokenAddress",\n', '    "uint256 makerTokenAmount",\n', '    "uint256 tradeExpires",\n', '    "uint256 salt",\n', '    "address maker",\n', '    "address restrictedTo"\n', '  );\n', '  \n', '  bytes32 signedWithdrawHash = keccak256(\n', '    "address contractAddress",\n', '    "uint256 amount",\n', '    "uint256 fee",\n', '    "uint256 withdrawExpires",\n', '    "uint256 salt",\n', '    "address maker",\n', '    "address restrictedTo"\n', '  );\n', '\n', '\n', '  // Balance per token, for each user.\n', '  mapping (address => mapping (address => uint256)) public balances;\n', '  \n', '  // global token balance tracking (to detect lost tokens)\n', '  mapping (address => uint256) public globalBalance;\n', '  \n', '  // List of orders created by calling the exchange contract directly.\n', '  mapping (bytes32 => bool) public orders;\n', '  \n', '  // Lists the amount of each order that has been filled or cancelled.\n', '  mapping (bytes32 => uint256) public orderFills;\n', '  \n', '  // Tokens that need to be checked through the compliance engine.\n', '  mapping (address => bool) public restrictedTokens;\n', '\n', '  // Mapping of fees by user class (default class == 0x0)\n', '  mapping (uint256 => uint256) public feeByClass;\n', '  \n', '  // Mapping of users to user classes.\n', '  mapping (address => uint256) public userClass; \n', '  \n', '  \n', '  /*******************************************\n', '  / Exchange Regular Events\n', '  /******************************************/\n', '  \n', '  // Note: Order creation is usually off-chain\n', '  event Order(\n', '    bytes32 indexed tradePair,\n', '    address indexed maker,\n', '    address[4] addressData,\n', '    uint256[4] numberData\n', '  );\n', '  \n', '  event Cancel(\n', '    bytes32 indexed tradePair,\n', '    address indexed maker,\n', '    address[4] addressData,\n', '    uint256[4] numberData,\n', '    uint256 status\n', '  );\n', '  \n', '   event FailedTrade( \n', '    bytes32 indexed tradePair,\n', '    address indexed taker,\n', '    bytes32 hash,\n', '    uint256 failReason\n', '  ); \n', '  \n', '  event Trade( \n', '    bytes32 indexed tradePair,\n', '    address indexed maker,\n', '    address indexed taker,\n', '    address makerToken,\n', '    address takerToken,\n', '    address restrictedTo,\n', '    uint256[4] numberData,\n', '    uint256 tradeAmount,\n', '    bool fillOrKill\n', '  );\n', '  \n', '  event Deposit(\n', '    address indexed token,\n', '    address indexed toUser,\n', '    address indexed sender,\n', '    uint256 amount\n', '  );\n', '  \n', '  event Withdraw(\n', '    address indexed token,\n', '    address indexed toUser,\n', '    uint256 amount\n', '  );\n', '\n', '  event InternalTransfer(\n', '    address indexed token,\n', '    address indexed toUser,\n', '    address indexed sender,\n', '    uint256 amount\n', '  );\n', '\n', '  event TokenSweep(\n', '    address indexed token,\n', '    address indexed sweeper,\n', '    uint256 amount,\n', '    uint256 balance\n', '  );\n', '  \n', '  event RestrictToken(\n', '    address indexed token,\n', '    bool status\n', '  );\n', '  \n', '  event NewExchange(\n', '    address newExchange\n', '  );\n', '  \n', '  event ChangeFeeAccount(\n', '    address feeAccount\n', '  );\n', '  \n', '  event ChangeSweepAccount(\n', '    address sweepAccount\n', '  );\n', '  \n', '  event ChangeClassFee(\n', '    uint256 indexed class,\n', '    uint256 fee\n', '  );\n', '  \n', '  event ChangeUserClass(\n', '    address indexed user,\n', '    uint256 class\n', '  );\n', '  \n', '  event LockContract(\n', '    bool status\n', '  );\n', '  \n', '  event UpdateComplianceAddress(\n', '    address newComplianceAddress\n', '  );\n', '  \n', '  event UpdateOptionsRegistryAddress(\n', '    address newOptionsRegistryAddress\n', '  );\n', '  \n', '  event Upgrade(\n', '    address indexed user,\n', '    address indexed token,\n', '    address newExchange,\n', '    uint256 amount\n', '  );\n', '  \n', '  event RemoteWithdraw(\n', '    address indexed maker,\n', '    address indexed sender,\n', '    uint256 withdrawAmount,\n', '    uint256 feeAmount,\n', '    uint256 withdrawExpires,\n', '    uint256 salt,\n', '    address restrictedTo\n', '  );\n', '  \n', '  event CancelRemoteWithdraw(\n', '    address indexed maker,\n', '    uint256 withdrawAmount,\n', '    uint256 feeAmount,\n', '    uint256 withdrawExpires,\n', '    uint256 salt,\n', '    address restrictedTo,\n', '    uint256 status\n', '  );\n', '\n', '  //Constructor Function, set initial values.\n', '  function UberDelta() public {\n', '    feeAccount = owner;\n', '    sweepAccount = owner;\n', '    feeByClass[0x0] = 3000000000000000;\n', '    contractLocked = false;\n', '    complianceAddress = this;\n', '    optionsRegistryAddress = this;\n', '  }\n', '\n', '\n', '  // Prevent raw sends of Eth.\n', '  function() public {\n', '    revert();\n', '  }\n', '  \n', '  \n', '  \n', '  /*******************************************\n', '  / Contract Control Functions\n', '  /******************************************/\n', '  function changeNewExchange(address _newExchange) external onlyOwner {\n', '    //since _newExchange being zero turns off the upgrade function, lets\n', '    //allow this to be reset to 0x0.\n', '    \n', '    newExchange = _newExchange;\n', '    \n', '    NewExchange(_newExchange);\n', '  }\n', '\n', '\n', '  function changeFeeAccount(address _feeAccount) external onlyManager {\n', '    require(_feeAccount != address(0x0));\n', '    \n', '    feeAccount = _feeAccount;\n', '    \n', '    ChangeFeeAccount(_feeAccount);\n', '  }\n', '\n', '  function changeSweepAccount(address _sweepAccount) external onlyManager {\n', '    require(_sweepAccount != address(0x0));\n', '    \n', '    sweepAccount = _sweepAccount;\n', '    \n', '    ChangeSweepAccount(_sweepAccount);\n', '  }\n', '\n', '  function changeClassFee(uint256 _class, uint256 _fee) external onlyManager {\n', '    require(_fee <= 10000000000000000); //Max 1%.\n', '\n', '    feeByClass[_class] = _fee;\n', '\n', '    ChangeClassFee(_class, _fee);\n', '  }\n', '  \n', '  function changeUserClass(address _user, uint256 _newClass) external onlyHelper {\n', '    userClass[_user] = _newClass;\n', '    \n', '    ChangeUserClass(_user, _newClass);\n', '  }\n', '  \n', '  //Turn off deposits and trades, but still allow withdrawals and upgrades.\n', '  function lockContract(bool _lock) external onlyManager {\n', '    contractLocked = _lock;\n', '    \n', '    LockContract(_lock);\n', '  }\n', '  \n', '  function updateComplianceAddress(address _newComplianceAddress)\n', '    external\n', '    onlyManager\n', '  {\n', '    complianceAddress = _newComplianceAddress;\n', '    \n', '    UpdateComplianceAddress(_newComplianceAddress);\n', '  }\n', '\n', '  function updateOptionsRegistryAddress(address _newOptionsRegistryAddress)\n', '    external\n', '    onlyManager\n', '  {\n', '    optionsRegistryAddress = _newOptionsRegistryAddress;\n', '    \n', '    UpdateOptionsRegistryAddress(_newOptionsRegistryAddress);\n', '  }\n', '\n', '\n', '  // restriction function for tokens that need additional verifications\n', '  function tokenRestriction(address _newToken, bool _status) external onlyHelper {\n', '    restrictedTokens[_newToken] = _status;\n', '    \n', '    RestrictToken(_newToken, _status);\n', '  }\n', '\n', '  \n', '  //Turn off deposits and trades, but still allow withdrawals and upgrades.\n', '  modifier notLocked() {\n', '    require(!contractLocked);\n', '    _;\n', '  }\n', '  \n', '  \n', '  /*******************************************************\n', '  / Deposit/Withdrawal/Transfer\n', '  /\n', '  / In all of the following functions, it should be noted\n', '  / that the 0x0 address is used to represent ETH.\n', '  /******************************************************/\n', '  \n', '  // SafeMath sanity checks inputs in deposit(), withdraw(), and token functions.\n', '  \n', '  // Deposit ETH in the contract to trade with\n', '  function deposit() external notLocked payable returns(uint256) {\n', '    require(Compliance(complianceAddress).canDeposit(msg.sender)); \n', '    // defaults to true until we change compliance code\n', '    \n', '    balances[address(0x0)][msg.sender] = safeAdd(balances[address(0x0)][msg.sender], msg.value);\n', '    globalBalance[address(0x0)] = safeAdd(globalBalance[address(0x0)], msg.value);\n', '\n', '    Deposit(0x0, msg.sender, msg.sender, msg.value);\n', '    \n', '    return(msg.value);\n', '  }\n', '\n', '  // Withdraw ETH from the contract to your wallet  (internal transaction on etherscan)\n', '  function withdraw(uint256 _amount) external returns(uint256) {\n', '    //require(balances[address(0x0)][msg.sender] >= _amount);\n', '    //handled by safeSub.\n', '    \n', '    balances[address(0x0)][msg.sender] = safeSub(balances[address(0x0)][msg.sender], _amount);\n', '    globalBalance[address(0x0)] = safeSub(globalBalance[address(0x0)], _amount);\n', ' \n', '    //transfer has a built in require\n', '    msg.sender.transfer(_amount);\n', '    \n', '    Withdraw(0x0, msg.sender, _amount);\n', '    \n', '    return(_amount);\n', '  }\n', '\n', '\n', '  // Deposit ERC20 tokens in the contract to trade with\n', '  // Token(_token).approve(this, _amount) must be called in advance\n', '  // ERC223 tokens must be deposited by a transfer to this contract ( see tokenFallBack(..) )\n', '  function depositToken(address _token, uint256 _amount) external notLocked returns(uint256) {\n', '    require(_token != address(0x0));\n', '    \n', '    require(Compliance(complianceAddress).canDeposit(msg.sender));\n', '\n', '    balances[_token][msg.sender] = safeAdd(balances[_token][msg.sender], _amount);\n', '    globalBalance[_token] = safeAdd(globalBalance[_token], _amount);\n', '    \n', '    require(Token(_token).transferFrom(msg.sender, this, _amount));\n', '\n', '    Deposit(_token, msg.sender, msg.sender, _amount);\n', '    \n', '    return(_amount);\n', '  }\n', '\n', '  // Withdraw ERC20/223 tokens from the contract back to your wallet\n', '  function withdrawToken(address _token, uint256 _amount)\n', '    external\n', '    returns (uint256)\n', '  {\n', '    if (_token == address(0x0)){\n', '      //keep the nulls to reduce gas usage.\n', '      //require(balances[_token)][msg.sender] >= _amount);\n', '      //handled by safeSub.\n', '      balances[address(0x0)][msg.sender] = safeSub(balances[address(0x0)][msg.sender], _amount);\n', '      globalBalance[address(0x0)] = safeSub(globalBalance[address(0x0)], _amount);\n', '\n', '      //transfer has a built in require\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      //require(balances[_token][msg.sender] >= _amount);\n', '      //handled by safeSub \n', ' \n', '      balances[_token][msg.sender] = safeSub(balances[_token][msg.sender], _amount);\n', '      globalBalance[_token] = safeSub(globalBalance[_token], _amount);\n', '\n', '      require(Token(_token).transfer(msg.sender, _amount));\n', '    }    \n', '\n', '    Withdraw(_token, msg.sender, _amount);\n', '    \n', '    return _amount;\n', '  }\n', '\n', '  // Deposit ETH in the contract on behalf of another address\n', '  // Warning: afterwards, only _user will be able to trade or withdraw these funds\n', '  function depositToUser(address _toUser) external payable notLocked returns (bool success) {\n', '    require(\n', '        (_toUser != address(0x0))\n', '     && (_toUser != address(this))\n', '     && (Compliance(complianceAddress).canDeposit(_toUser))\n', '    );\n', '    \n', '    balances[address(0x0)][_toUser] = safeAdd(balances[address(0x0)][_toUser], msg.value);\n', '    globalBalance[address(0x0)] = safeAdd(globalBalance[address(0x0)], msg.value);\n', '    \n', '    Deposit(0x0, _toUser, msg.sender, msg.value);\n', '    \n', '    return true;\n', '  }\n', '\n', '  // Deposit ERC20 tokens in the contract on behalf of another address\n', '  // Token(_token).approve(this, _amount) must be called in advance\n', '  // Warning: afterwards, only _toUser will be able to trade or withdraw these funds\n', '  // ERC223 tokens must be deposited by a transfer to this contract ( see tokenFallBack(..) )\n', '  function depositTokenToUser(\n', '    address _toUser,\n', '    address _token,\n', '    uint256 _amount\n', '  )\n', '    external\n', '    notLocked\n', '    returns (bool success)\n', '  {\n', '    require(\n', '        (_token != address(0x0))\n', '\n', '     && (_toUser  != address(0x0))\n', '     && (_toUser  != address(this))\n', '     && (_toUser  != _token)\n', '     && (Compliance(complianceAddress).canDeposit(_toUser))\n', '    );\n', '    \n', '    balances[_token][_toUser] = safeAdd(balances[_token][_toUser], _amount);\n', '    globalBalance[_token] = safeAdd(globalBalance[_token], _amount);\n', '\n', '    require(Token(_token).transferFrom(msg.sender, this, _amount));\n', '\n', '    Deposit(_token, _toUser, msg.sender, _amount);\n', '    \n', '    return true;\n', '  }\n', '\n', '\n', '  //ERC223 Token Acceptor function, called when an ERC2223 token is transferred to this contract\n', '  // provide _sendTo to make it a deposit on behalf of another address (depositToUser)\n', '  function tokenFallback(\n', '    address _from,  // user calling the function\n', '    uint256 _value, // the number of tokens\n', '    bytes _sendTo     // "deposit to other user" if exactly 20 bytes sent\n', '    \n', '  )\n', '    external\n', '    notLocked\n', '  {\n', '    //first lets figure out who this is going to.\n', '    address toUser = _from;     //probably this\n', '    if (_sendTo.length == 20){  //but use data for sendTo otherwise.\n', '\n', '      // I&#39;m about 90% sure I don&#39;t need to do the casting here, but for\n', '      // like twenty gas, I&#39;ll take the protection from potentially\n', '      // stomping on weird memory locations.\n', '      \n', '      uint256 asmAddress;\n', '      assembly { //uses 50 gas\n', '        asmAddress := calldataload(120)\n', '      }\n', '      toUser = address(asmAddress);\n', '    }\n', '    \n', '    //sanity checks.\n', '    require(\n', '        (toUser != address(0x0))\n', '     && (toUser != address(this))\n', '     && (toUser != msg.sender)  // msg.sender is the token\n', '     && (Compliance(complianceAddress).canDeposit(toUser))\n', '    );\n', '    \n', '    // check if a contract is calling this\n', '    uint256 codeLength;\n', '    assembly {\n', '      codeLength := extcodesize(caller)\n', '    }\n', '    require(codeLength > 0);    \n', '    \n', '    globalBalance[msg.sender] = safeAdd(globalBalance[msg.sender], _value);\n', '    balances[msg.sender][toUser] = safeAdd(balances[msg.sender][toUser], _value);\n', '    \n', '    //sanity check, and as a perk, we check for balanceOf();\n', '    require(Token(msg.sender).balanceOf(this) >= _value);\n', '\n', '    Deposit(msg.sender, toUser, _from, _value);\n', '  }\n', '\n', '  // Move deposited tokens or ETH (0x0) from one to another address within the contract\n', '  function internalTransfer(\n', '    address _toUser,\n', '    address _token,\n', '    uint256 _amount\n', '  )\n', '    external\n', '    notLocked \n', '    returns(uint256)\n', '  {\n', '    require(\n', '        (balances[_token][msg.sender] >= _amount)\n', '     && (_toUser != address(0x0))\n', '     && (_toUser != address(this))\n', '     && (_toUser != _token)\n', '     && (Compliance(complianceAddress).canDeposit(_toUser))\n', '    );\n', ' \n', '    balances[_token][msg.sender] = safeSub(balances[_token][msg.sender], _amount);\n', '    balances[_token][_toUser] = safeAdd(balances[_token][_toUser], _amount);\n', '\n', '    InternalTransfer(_token, _toUser, msg.sender, _amount);\n', '    \n', '    return(_amount);\n', '  }\n', '  \n', '  // return the token/ETH balance a user has deposited in the contract\n', '  function balanceOf(address _token, address _user) external view returns (uint) {\n', '    return balances[_token][_user];\n', '  }\n', '\n', '  \n', '  // In order to see the ERC20 total balance, we&#39;re calling an external contract,\n', '  // and this contract claims to be ERC20, but we don&#39;t know what&#39;s really there.\n', '  // We can&#39;t rely on the EVM or solidity to enforce "view", so even though a\n', '  // normal token can rely on itself to be non-malicious, we can&#39;t.\n', '  // We have no idea what potentially evil tokens we&#39;ll be interacting with.\n', '  // The call to check the reported balance needs to go after the state changes,\n', '  // even though it&#39;s un-natural. Now, on one hand, this function might at first\n', '  // appear safe, since we&#39;re only allowing the sweeper address to access\n', '  // *this function,* but we are reading the state of the globalBalance.\n', '  // In theory, a malicious token could do the following:\n', '  //  1a) Check if the caller of balanceOf is our contract, if it&#39;s not, act normally.\n', '  //  1b) If the caller is our contract, it does the following:\n', '  //  2) Read our contracts globalBalance for its own address.\n', '  //  3) Sets our contract&#39;s balance of the token (in the token controller) to our internal globalBalance\n', '  //  4) Allocates some other address the difference in globalBalance and actual balance for our contract.\n', '  //  5) Report back to this function exactly the amount we had in globalBalance.\n', '  // (which, by then is true, since they were stolen).\n', '  // Now we&#39;re always going to see 0 extra tokens, and our users have had their tokens perminantly lost.\n', '  // bonus: this is why there is no "sweep all" function.\n', '    \n', '  // Detect ERC20 tokens that have been sent to the contract without a deposit (lost tokens),\n', '  // which are not included in globalBalance[..]\n', '  function sweepTokenAmount(address _token, uint256 _amount) external returns(uint256) {\n', '    assert(msg.sender == sweepAccount);\n', '\n', '    balances[_token][sweepAccount] = safeAdd(balances[_token][sweepAccount], _amount);\n', '    globalBalance[_token] = safeAdd(globalBalance[_token], _amount);\n', '    \n', '    //You go last!\n', '\tif(_token != address(0x0)) { \n', '      require(globalBalance[_token] <= Token(_token).balanceOf(this));\n', '\t} else {\n', '\t  // if another contract performs selfdestruct(UberDelta),\n', '    // ETH can get in here without being in globalBalance\n', '\t  require(globalBalance[address(0x0)] <= this.balance); \n', '\t}\n', '    \n', '    TokenSweep(_token, msg.sender, _amount, balances[_token][sweepAccount]);\n', '    \n', '    return(_amount);\n', '  }\n', '  \n', '  \n', '  /*******************************************\n', '  / Regular Trading functions\n', '  /******************************************/\n', '  \n', '  //now contracts can place orders!\n', '  \n', '  \n', '  // Normal order creation happens off-chain and orders are signed by creators,\n', '  // this function allows for on-chain orders to be created\n', '  function order(\n', '    address[4] _addressData,\n', '    uint256[4] _numberData //web3 isn&#39;t ready for structs.\n', '  )\n', '    external\n', '    notLocked\n', '    returns (bool success)\n', '  {\n', '  \n', '//    _addressData[2] is maker;\n', '    if (msg.sender != _addressData[2]) { return false; }\n', '    \n', '    bytes32 hash = getHash(_addressData, _numberData);\n', '\n', '    orders[hash] = true;\n', '\n', '    Order(\n', '      (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '      msg.sender,\n', '      _addressData,\n', '      _numberData);\n', '    \n', '    return true;\n', '  }  \n', '\n', '\n', '  function tradeBalances(\n', '    address _takerTokenAddress,\n', '    uint256 _takerTokenAmount,\n', '    address _makerTokenAddress,\n', '    uint256 _makerTokenAmount,\n', '    address _maker,\n', '    uint256 _tradeAmount\n', '  )\n', '    internal\n', '  {\n', '    require(_takerTokenAmount > 0); //safeDiv\n', '\n', '    // We charge only the takers this fee\n', '    uint256 feeValue = safeMul(_tradeAmount, feeByClass[userClass[msg.sender]]) / (1 ether);\n', '    \n', '    balances[_takerTokenAddress][_maker] =\n', '      safeAdd(balances[_takerTokenAddress][_maker], _tradeAmount);\n', '    balances[_takerTokenAddress][msg.sender] =\n', '      safeSub(balances[_takerTokenAddress][msg.sender], safeAdd(_tradeAmount, feeValue));\n', '    \n', '    balances[_makerTokenAddress][_maker] =\n', '      safeSub(\n', '        balances[_makerTokenAddress][_maker],\n', '        safeMul(_makerTokenAmount, _tradeAmount) / _takerTokenAmount\n', '      );\n', '    balances[_makerTokenAddress][msg.sender] =\n', '      safeAdd(\n', '        balances[_makerTokenAddress][msg.sender],\n', '        safeMul(_makerTokenAmount, _tradeAmount) / _takerTokenAmount\n', '      );\n', '    \n', '    balances[_takerTokenAddress][feeAccount] =\n', '      safeAdd(balances[_takerTokenAddress][feeAccount], feeValue);\n', '  }\n', '\n', '\n', '  function trade(\n', '    address[4] _addressData,\n', '    uint256[4] _numberData, //web3 isn&#39;t ready for structs.\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s,\n', '    uint256 _amount,\n', '    bool _fillOrKill\n', '  )\n', '    external\n', '    notLocked\n', '    returns(uint256 tradeAmount)\n', '  {\n', '  \n', '//      _addressData[0], // takerTokenAddress;\n', '//      _numberData[0], // takerTokenAmount;\n', '//      _addressData[1], // makerTokenAddress;\n', '//      _numberData[1], // makerTokenAmount;\n', '//      _numberData[2], // tradeExpires;\n', '//      _numberData[3], // salt;\n', '//      _addressData[2], // maker;\n', '//      _addressData[3] // restrictedTo;\n', '    \n', '    bytes32 hash = getHash(_addressData, _numberData);\n', '    \n', '    tradeAmount = safeSub(_numberData[0], orderFills[hash]); //avail to trade\n', '    \n', '    //balance of giveToken / amount I said I&#39;d give of giveToken * amount I said I want of getToken\n', '    if (\n', '      tradeAmount > safeDiv(\n', '        safeMul(balances[_addressData[1]][_addressData[2]], _numberData[0]),\n', '        _numberData[1]\n', '      )\n', '    )\n', '    {\n', '      tradeAmount = safeDiv(\n', '        safeMul(balances[_addressData[1]][_addressData[2]], _numberData[0]),\n', '        _numberData[1]\n', '      );\n', '    }\n', '    \n', '    if (tradeAmount > _amount) { tradeAmount = _amount; }\n', '    \n', '        //_numberData[0] is takerTokenAmount\n', '    if (tradeAmount == 0) { //idfk. There&#39;s nothing there to get. Canceled? Traded?\n', '      if (orderFills[hash] < _numberData[0]) { //Maker seems to be missing tokens?\n', '        FailedTrade(\n', '          (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '          msg.sender,\n', '          hash,\n', '          0\n', '        );\n', '      } else {  // either cancelled or already traded.\n', '        FailedTrade(\n', '          (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '          msg.sender,\n', '          hash,\n', '          1\n', '        );\n', '      }\n', '      return 0;\n', '    }\n', '    \n', '    \n', '    if (block.number > _numberData[2]) { //order is expired\n', '      FailedTrade(\n', '        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '        msg.sender,\n', '        hash,\n', '        2\n', '      );\n', '      return 0;\n', '    }\n', '\n', '\n', '    if ((_fillOrKill == true) && (tradeAmount < _amount)) { //didnt fill, so kill\n', '      FailedTrade(\n', '        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '        msg.sender,\n', '        hash,\n', '        3\n', '      );\n', '      return 0;\n', '    }\n', '    \n', '        \n', '    uint256 feeValue = safeMul(_amount, feeByClass[userClass[msg.sender]]) / (1 ether);\n', '\n', '    //if they trade more than they have, get 0.\n', '    if ( (_amount + feeValue) > balances[_addressData[0]][msg.sender])  { \n', '      FailedTrade(\n', '        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '        msg.sender,\n', '        hash,\n', '        4\n', '      );\n', '      return 0;\n', '    }\n', '    \n', '    if ( //not a valid order.\n', '        (ecrecover(keccak256(signedTradeHash, hash), _v, _r, _s) != _addressData[2])\n', '        && (! orders[hash])\n', '    )\n', '    {\n', '      FailedTrade(\n', '        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '        msg.sender,\n', '        hash,\n', '        5\n', '      );\n', '      return 0;\n', '    }\n', '\n', '    \n', '    if ((_addressData[3] != address(0x0)) && (_addressData[3] != msg.sender)) { //check restrictedTo\n', '      FailedTrade(\n', '        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '        msg.sender,\n', '        hash,\n', '        6\n', '      );\n', '      return 0;\n', '    }\n', '        \n', '    \n', '    if ( //if there&#39;s a compliance restriction.\n', '      ((_addressData[0] != address(0x0)) //if not Eth, and restricted, check with Compliance.\n', '        && (restrictedTokens[_addressData[0]] )\n', '        && ! Compliance(complianceAddress).validateTrade(_addressData[0], _addressData[2], msg.sender)\n', '      )\n', '      || ((_addressData[1] != address(0x0))  //ditto\n', '        && (restrictedTokens[_addressData[1]])\n', '        && ! Compliance(complianceAddress).validateTrade(_addressData[1], _addressData[2], msg.sender)\n', '      )\n', '    )\n', '    {\n', '      FailedTrade(\n', '        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '        msg.sender,\n', '        hash,\n', '        7\n', '      );\n', '      return 0;\n', '    }\n', '    \n', '    //Do the thing!\n', '    \n', '    tradeBalances(\n', '      _addressData[0], // takerTokenAddress;\n', '      _numberData[0], // takerTokenAmount;\n', '      _addressData[1], // makerTokenAddress;\n', '      _numberData[1], // makerTokenAmount;\n', '      _addressData[2], // maker;\n', '      tradeAmount\n', '    );\n', '\n', '    orderFills[hash] = safeAdd(orderFills[hash], tradeAmount);\n', '\n', '    Trade(\n', '      (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '      _addressData[2],\n', '      msg.sender,\n', '      _addressData[1],\n', '      _addressData[0],\n', '      _addressData[3],\n', '      _numberData,\n', '      tradeAmount,\n', '      _fillOrKill\n', '    );\n', '    \n', '    return(tradeAmount);\n', '  }\n', '  \n', '  \n', '  // Cancel a signed order, once this is confirmed nobody will be able to trade it anymore\n', '  function cancelOrder(\n', '    address[4] _addressData,\n', '    uint256[4] _numberData //web3 isn&#39;t ready for structs.\n', '  )\n', '    external\n', '    returns(uint256 amountCancelled)\n', '  {\n', '    \n', '    require(msg.sender == _addressData[2]);\n', '    \n', '    //  msg.sender can &#39;cancel&#39; nonexistent orders since they&#39;re offchain.\n', '    bytes32 hash = getHash(_addressData, _numberData);\n', ' \n', '    amountCancelled = safeSub(_numberData[0],orderFills[hash]);\n', '    \n', '    orderFills[hash] = _numberData[0];\n', ' \n', '    //event trigger is moved ahead of balance resetting to allow expression of the already-filled amount\n', '//    _numberData[0] is takerTokenAmount;\n', '    Cancel(\n', '      (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '      msg.sender,\n', '      _addressData,\n', '      _numberData,\n', '      amountCancelled);\n', '\n', '    return amountCancelled;    \n', '  }\n', '\n', '\n', '\n', '  /**************************\n', '  / Remote Withdraw\n', '  ***************************/\n', '  \n', '  // Perform an ETH withdraw transaction for someone else based on their signed message\n', '  // Useful if the owner of the funds does not have enough ETH for gas fees in their wallet.\n', '  // msg.sender receives fee for the effort and gas costs\n', '  function remoteWithdraw(\n', '    uint256 _withdrawAmount,\n', '    uint256 _feeAmount,\n', '    uint256 _withdrawExpires,\n', '    uint256 _salt,\n', '    address _maker,\n', '    address _restrictedTo, //0x0 = anyone\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s\n', '  )\n', '    external\n', '    notLocked\n', '    returns(bool)\n', '  {\n', '    //is the withdraw possible?\n', '    require(\n', '        (balances[address(0x0)][_maker] >= safeAdd(_withdrawAmount, _feeAmount))\n', '     && (\n', '            (_restrictedTo == address(0x0))\n', '         || (_restrictedTo == msg.sender)\n', '        )\n', '     && ((_feeAmount == 0) || (Compliance(complianceAddress).canDeposit(msg.sender)))\n', '    );\n', '    \n', '    //has this withdraw happened already? (and generate the hash)\n', '\n', '    bytes32 hash = keccak256(\n', '      this, \n', '      _withdrawAmount,\n', '      _feeAmount,\n', '      _withdrawExpires,\n', '      _salt,\n', '      _maker,\n', '      _restrictedTo\n', '    );\n', '\n', '    require(orderFills[hash] == 0);\n', '\n', '    //is this real?\n', '    require(\n', '      ecrecover(keccak256(signedWithdrawHash, hash), _v, _r, _s) == _maker\n', '    );\n', '    \n', '    //only once.\n', '    orderFills[hash] = 1;\n', '\n', '    balances[address(0x0)][_maker] =\n', '      safeSub(balances[address(0x0)][_maker], safeAdd(_withdrawAmount, _feeAmount));\n', '    // pay fee to the user performing the remote withdraw\n', '    balances[address(0x0)][msg.sender] = safeAdd(balances[address(0x0)][msg.sender], _feeAmount);\n', '    \n', '    globalBalance[address(0x0)] = safeSub(globalBalance[address(0x0)], _withdrawAmount);\n', '\n', '    RemoteWithdraw(\n', '      _maker,\n', '      msg.sender,\n', '      _withdrawAmount,\n', '      _feeAmount,\n', '      _withdrawExpires,\n', '      _salt,\n', '      _restrictedTo\n', '    );\n', '\n', '    //implicit require included.\n', '    _maker.transfer(_withdrawAmount);\n', '    \n', '    return(true);\n', '  }\n', '\n', '  // cancel a signed request for a remote withdraw\n', '  function cancelRemoteWithdraw(\n', '    uint256 _withdrawAmount,\n', '    uint256 _feeAmount,\n', '    uint256 _withdrawExpires,\n', '    uint256 _salt,\n', '    address _restrictedTo //0x0 = anyone\n', '  )\n', '    external\n', '  {\n', '      // msg.sender can cancel nonexsistent orders.\n', '    bytes32 hash = keccak256(\n', '      this, \n', '      _withdrawAmount,\n', '      _feeAmount,\n', '      _withdrawExpires,\n', '      _salt,\n', '      msg.sender,\n', '      _restrictedTo\n', '    );\n', '    \n', '    CancelRemoteWithdraw(\n', '      msg.sender,\n', '      _withdrawAmount,\n', '      _feeAmount,\n', '      _withdrawExpires,\n', '      _salt,\n', '      _restrictedTo,\n', '      orderFills[hash]\n', '    );\n', '    \n', '    //set to completed after, event shows pre-cancel status.\n', '    orderFills[hash] = 1;\n', '  }\n', '  \n', '  \n', ' \n', '\n', '  /**************************\n', '  /Upgrade Function\n', '  ***************************/\n', '      \n', '  // move tokens/ETH over to a new upgraded smart contract  (avoids having to withdraw & deposit)\n', '  function upgrade(address _token) external returns(uint256 moveBalance) {\n', '    require (newExchange != address(0x0));\n', '\n', '    moveBalance = balances[_token][msg.sender];\n', '\n', '    globalBalance[_token] = safeSub(globalBalance[_token], moveBalance);\n', '    balances[_token][msg.sender] = 0;\n', '\n', '    if (_token != address(0x0)){\n', '      require(Token(_token).approve(newExchange, moveBalance));\n', '      require(UberDelta(newExchange).depositTokenToUser(msg.sender, _token, moveBalance));\n', '    } else {\n', '      require(UberDelta(newExchange).depositToUser.value(moveBalance)(msg.sender));\n', '    }\n', '\n', '    Upgrade(msg.sender, _token, newExchange, moveBalance);\n', '    \n', '    return(moveBalance);\n', '  }\n', '\n', '\n', '  \n', '  /*******************************************\n', '  / Data View functions\n', '  /******************************************/\n', '  \n', '  function testTrade(\n', '    address[4] _addressData,\n', '    uint256[4] _numberData, //web3 isn&#39;t ready for structs.\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s,\n', '    uint256 _amount,\n', '    address _sender,\n', '    bool _fillOrKill\n', '  )\n', '    public\n', '    view\n', '    returns(uint256)\n', '  {\n', '    uint256 feeValue = safeMul(_amount, feeByClass[userClass[_sender]]) / (1 ether);\n', '\n', '    if (\n', '      contractLocked\n', '      ||\n', '      ((_addressData[0] != address(0x0)) //if not Eth, and restricted, check with Compliance.\n', '        && (restrictedTokens[_addressData[0]] )\n', '        && ! Compliance(complianceAddress).validateTrade(_addressData[0], _addressData[2], _sender)\n', '      )\n', '      || ((_addressData[1] != address(0x0))  //ditto\n', '        && (restrictedTokens[_addressData[1]])\n', '        && ! Compliance(complianceAddress).validateTrade(_addressData[1], _addressData[2], _sender)\n', '      )\n', '         //if they trade more than they have, get 0.\n', '      || ((_amount + feeValue) > balances[_addressData[0]][_sender]) \n', '      || ((_addressData[3] != address(0x0)) && (_addressData[3] != _sender)) //check restrictedTo\n', '    )\n', '    {\n', '      return 0;\n', '    }\n', '      \n', '    uint256 tradeAmount = availableVolume(\n', '        _addressData,\n', '        _numberData,\n', '        _v,\n', '        _r,\n', '        _s\n', '    );\n', '    \n', '    if (tradeAmount > _amount) { tradeAmount = _amount; }\n', '    \n', '    if ((_fillOrKill == true) && (tradeAmount < _amount)) {\n', '      return 0;\n', '    }\n', '\n', '    return tradeAmount;\n', '  }\n', '\n', '\n', '  // get how much of an order is left (unfilled)\n', '  // return value in order of _takerTokenAddress\n', '  function availableVolume(\n', '    address[4] _addressData,\n', '    uint256[4] _numberData, //web3 isn&#39;t ready for structs.\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s\n', '  )\n', '    public\n', '    view\n', '    returns(uint256 amountRemaining)\n', '  {     \n', '//    _addressData[0] // takerTokenAddress;\n', '//    _numberData[0] // takerTokenAmount;\n', '//    _addressData[1] // makerTokenAddress;\n', '//    _numberData[1] // makerTokenAmount;\n', '//    _numberData[2] // tradeExpires;\n', '//    _numberData[3] // salt;\n', '//    _addressData[2] // maker;\n', '//    _addressData[3] // restrictedTo;\n', '\n', '    bytes32 hash = getHash(_addressData, _numberData);\n', '\n', '    if (\n', '      (block.number > _numberData[2])\n', '      || ( \n', '        (ecrecover(keccak256(signedTradeHash, hash), _v, _r, _s) != _addressData[2])\n', '        && (! orders[hash])\n', '      )\n', '    ) { return 0; }\n', '\n', '    //uint256 amountRemaining = safeSub(myTrade.takerTokenAmount, orderFills[hash]);\n', '     amountRemaining = safeSub(_numberData[0], orderFills[hash]);\n', '\n', '    if (\n', '      amountRemaining < safeDiv(\n', '        safeMul(balances[_addressData[1]][_addressData[2]], _numberData[0]),\n', '        _numberData[1]\n', '      )\n', '    ) return amountRemaining;\n', '\n', '    return (\n', '      safeDiv(\n', '        safeMul(balances[_addressData[1]][_addressData[2]], _numberData[0]),\n', '        _numberData[1]\n', '      )\n', '    );\n', '  }\n', '\n', '\n', '  // get how much of an order has been filled\n', '  // return value in order of _takerTokenAddress\n', '  function getUserFee(\n', '    address _user\n', '  )\n', '    external\n', '    view\n', '    returns(uint256)\n', '  {\n', '    return feeByClass[userClass[_user]];\n', '  }\n', '\n', '\n', '  // get how much of an order has been filled\n', '  // return value in order of _takerTokenAddress\n', '  function amountFilled(\n', '    address[4] _addressData,\n', '    uint256[4] _numberData //web3 isn&#39;t ready for structs.\n', '  )\n', '    external\n', '    view\n', '    returns(uint256)\n', '  {\n', '    bytes32 hash = getHash(_addressData, _numberData);\n', '\n', '    return orderFills[hash];\n', '  }\n', '\n', '  \n', '  // check if a request for a remote withdraw is still valid\n', '  function testRemoteWithdraw(\n', '    uint256 _withdrawAmount,\n', '    uint256 _feeAmount,\n', '    uint256 _withdrawExpires,\n', '    uint256 _salt,\n', '    address _maker,\n', '    address _restrictedTo,\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s,\n', '    address _sender\n', '  )\n', '    external\n', '    view\n', '    returns(uint256)\n', '  {\n', '    bytes32 hash = keccak256(\n', '      this,\n', '      _withdrawAmount,\n', '      _feeAmount,\n', '      _withdrawExpires,\n', '      _salt,\n', '      _maker,\n', '      _restrictedTo\n', '    );\n', '\n', '    if (\n', '      contractLocked\n', '      ||\n', '      (balances[address(0x0)][_maker] < safeAdd(_withdrawAmount, _feeAmount))\n', '      ||((_restrictedTo != address(0x0)) && (_restrictedTo != _sender))\n', '      || (orderFills[hash] != 0)\n', '      || (ecrecover(keccak256(signedWithdrawHash, hash), _v, _r, _s) != _maker)\n', '      || ((_feeAmount > 0) && (! Compliance(complianceAddress).canDeposit(_sender)))\n', '    )\n', '    {\n', '      return 0;\n', '    } else {\n', '      return _withdrawAmount;\n', '    }\n', '  }\n', '  \n', '  \n', '  \n', '  function getHash(\n', '    address[4] _addressData,\n', '    uint256[4] _numberData //web3 isn&#39;t ready for structs.\n', '  )\n', '    public\n', '    view\n', '    returns(bytes32)\n', '  {\n', '    return(\n', '      keccak256(\n', '        this,\n', '        _addressData[0], // takerTokenAddress;\n', '        _numberData[0], // takerTokenAmount;\n', '        _addressData[1], // makerTokenAddress;\n', '        _numberData[1], // makerTokenAmount;\n', '        _numberData[2], // tradeExpires;\n', '        _numberData[3], // salt;\n', '        _addressData[2], // maker;\n', '        _addressData[3] // restrictedTo;\n', '      )\n', '    );\n', '  }\n', '  \n', '  \n', '\n', '  /***********************************\n', '  / Compliance View Code\n', '  ************************************/\n', '  //since the compliance code might move, we should have a way to always\n', '  //call a function to this contract to get the current values\n', '\n', '    function testCanDeposit(\n', '    address _user\n', '  )\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    return(Compliance(complianceAddress).canDeposit(_user));\n', '  }\n', '  \n', '  function testCanTrade(\n', '    address _token,\n', '    address _user\n', '  )\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    return(Compliance(complianceAddress).canTrade(_token, _user));\n', '  }\n', '\n', '  \n', '  function testValidateTrade(\n', '    address _token,\n', '    address _getUser,\n', '    address _giveUser\n', '  )\n', '    external\n', '    view\n', '    returns (bool isAllowed)\n', '  {\n', '    return(Compliance(complianceAddress).validateTrade(_token, _getUser, _giveUser));\n', '  }\n', '  \n', '\n', '\n', '  /**************************\n', '  / Default Compliance Code\n', '  ***************************/\n', '  // These will eventually live in a different contract.\n', '  // every can deposit by default, later a registry?\n', '  // For now, always say no if called for trades. \n', '  // the earliest use may be halting trade in a token.\n', '  function canDeposit(\n', '    address _user\n', '  )\n', '    public\n', '    view\n', '    returns (bool isAllowed)\n', '  {\n', '    return(true);\n', '  }\n', '  \n', '  function canTrade(\n', '    address _token,\n', '    address _user\n', '  )\n', '    public\n', '    view\n', '    returns (bool isAllowed)\n', '  {\n', '    return(false);\n', '  }\n', '\n', '  \n', '  function validateTrade(\n', '    address _token,\n', '    address _getUser,\n', '    address _giveUser\n', '  )\n', '    public\n', '    view\n', '    returns (bool isAllowed)\n', '  {\n', '    return(false);\n', '  }\n', '  \n', '\n', '\n', '  /***********************************\n', '  / THIS IS WHERE OPTIONS LIVE!!!!\n', '  /**********************************/\n', '  \n', '  \n', '  mapping (address => uint256) public exercisedOptions;\n', '  \n', '  //get asset for tickets\n', '  event CollapseOption(\n', '    address indexed user,\n', '    address indexed holderTicketAddress,\n', '    address indexed writerTicketAddress,\n', '    uint256 ticketsCollapsed,\n', '    bytes32 optionPair //assetTokenAddress xor strikeTokenAddress\n', '  );    \n', '  \n', '  //get holderticket + asset for strike\n', '  event ExcerciseUnwind(\n', '    address indexed user,\n', '    address indexed holderTicketAddress,\n', '    uint256 ticketsUnwound,\n', '    bytes32 optionPair,\n', '    bool fillOrKill\n', '  );  \n', '  \n', '  //get asset for writerticket\n', '  event ExpireOption(\n', '    address indexed user,\n', '    address indexed writerTicketAddress,\n', '    uint256 ticketsExpired,\n', '    bytes32 optionPair\n', '  );  \n', '  \n', '  //get tickets for asset\n', '  event CreateOption(\n', '    address indexed user,\n', '    address indexed holderTicketAddress,\n', '    address indexed writerTicketAddress,\n', '    uint256 ticketsCreated,\n', '    bytes32 optionPair\n', '  );  \n', '  \n', '  //get assset for strike + holderticket\n', '  event ExcerciseOption(\n', '    address indexed user,\n', '    address indexed holderTicketAddress,\n', '    uint256 ticketsExcercised,\n', '    bytes32 optionPair //assetTokenAddress xor strikeTokenAddress\n', '  );  \n', '  \n', '  /******************\n', '  / optionFunctions\n', '  ******************/\n', '  \n', '  //if before expiry, deposit asset, get buy ticket, write ticket\n', '  // 1 ticket gets (10^18) option units credited to them.\n', '  function createOptionPair( //#65\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires,\n', '    uint256 _ticketAmount //tickets times (1 ether)\n', '  )\n', '    external\n', '    notLocked\n', '    returns (uint256 ticketsCreated)\n', '  {\n', '    //if before expiry\n', '    require (block.number < _optionExpires); //option would be expired\n', '    \n', '    //if they have the asset\n', '    //[checked by safemath during locking]\n', '\n', '    //lock asset to 0x0.\n', '    //the percent of one contract times _assetTokenAmount = amount moving\n', '    //creation fee?\n', '    balances[_assetTokenAddress][0x0] =\n', '      safeAdd(\n', '        balances[_assetTokenAddress][0x0],\n', '        safeDiv(safeMul(_assetTokenAmount, _ticketAmount), 1 ether)\n', '      );\n', '\n', '    balances[_assetTokenAddress][msg.sender] =\n', '      safeSub(\n', '        balances[_assetTokenAddress][msg.sender],\n', '        safeDiv(safeMul(_assetTokenAmount, _ticketAmount), 1 ether)\n', '      );\n', '    \n', '    \n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    address writerTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      true\n', '    );\n', '    \n', '    //issue write option\n', '    balances[writerTicketAddress][msg.sender] =\n', '      safeAdd(balances[writerTicketAddress][msg.sender], _ticketAmount);\n', '    globalBalance[writerTicketAddress] =\n', '      safeAdd(globalBalance[writerTicketAddress], _ticketAmount);\n', '\n', '    //issue hold option\n', '    balances[holderTicketAddress][msg.sender] =\n', '      safeAdd(balances[holderTicketAddress][msg.sender], _ticketAmount);\n', '    globalBalance[holderTicketAddress] =\n', '      safeAdd(globalBalance[holderTicketAddress], _ticketAmount);\n', '\n', '    CreateOption(\n', '      msg.sender,\n', '      holderTicketAddress,\n', '      writerTicketAddress,\n', '      _ticketAmount,\n', '      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress))\n', '    );\n', '    \n', '    //check if we need to register, and do if we do.\n', '    if (\n', '      OptionRegistry(optionsRegistryAddress).isOptionPairRegistered(\n', '        _assetTokenAddress,\n', '        _assetTokenAmount,\n', '        _strikeTokenAddress,\n', '        _strikeTokenAmount,\n', '        _optionExpires\n', '      )\n', '      == false\n', '    )\n', '    {\n', '      require(\n', '        OptionRegistry(optionsRegistryAddress).registerOptionPair(\n', '          _assetTokenAddress,\n', '          _assetTokenAmount,\n', '          _strikeTokenAddress,\n', '          _strikeTokenAmount,\n', '          _optionExpires\n', '        )\n', '      );\n', '    }\n', '    return _ticketAmount;\n', '  }\n', '  \n', '  //if own buy & writer ticket get asset, void tickets\n', '  // 1 ticket gets 10^18 option units voided.\n', '  function collapseOptionPair( //#66\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires,\n', '    uint256 _ticketAmount\n', '  )\n', '    external\n', '    returns (uint256 ticketsCollapsed)\n', '  {\n', '    \n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    address writerTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      true\n', '    );\n', '    \n', '    //if they have the write option\n', '    //if they have the hold option\n', '    require (\n', '      (balances[holderTicketAddress][msg.sender] >= _ticketAmount)\n', '      && (balances[writerTicketAddress][msg.sender] >= _ticketAmount)\n', '    );\n', '    //I guess it can be expired, since you have both legs.\n', '    \n', '    //void write option\n', '    balances[writerTicketAddress][msg.sender] =\n', '      safeSub(balances[writerTicketAddress][msg.sender], _ticketAmount);\n', '    globalBalance[writerTicketAddress] =\n', '      safeSub(globalBalance[writerTicketAddress], _ticketAmount);\n', '\n', '    //void hold option\n', '    balances[holderTicketAddress][msg.sender] =\n', '      safeSub(balances[holderTicketAddress][msg.sender], _ticketAmount);\n', '    globalBalance[holderTicketAddress] =\n', '      safeSub(globalBalance[holderTicketAddress], _ticketAmount);\n', ' \n', '    //unlock asset\n', '    balances[_assetTokenAddress][0x0] = safeSub(\n', '      balances[_assetTokenAddress][0x0],\n', '      safeDiv(safeMul(_assetTokenAmount, _ticketAmount), 1 ether)\n', '    );\n', '\n', '    balances[_assetTokenAddress][msg.sender] = safeAdd(\n', '      balances[_assetTokenAddress][msg.sender],\n', '      safeDiv(safeMul(_assetTokenAmount, _ticketAmount), 1 ether)\n', '    );\n', '    \n', '    //emit event\n', '    CollapseOption(\n', '      msg.sender,\n', '      holderTicketAddress,\n', '      writerTicketAddress,\n', '      _ticketAmount,\n', '      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress))\n', '    );\n', '    \n', '    return _ticketAmount;\n', '  }\n', '\n', '  /*about invisableHandOfAdamSmith():\n', '    q: why would someone ever want to buy an out-of-the-money,\n', '       collaterized call option at strike price?\n', '\n', '    a: if an american option is executed, and the collateral&#39;s movement\n', '       makes it later out of the money, the value of the option would\n', '       need to be calculated by including the "pre-executed" amount.\n', '       * \n', '       This would prevent an external actor performing weird arb trades\n', '       (write a billion tickets, collapse a billion tickets, profit!).\n', '       Skip the middle man! Writers are more likely to get 100% token or\n', '       strike at expiry, based on market value, and holders still have\n', '       their option intact.\n', '       * \n', '       Arbers gonna arb. Let them do their thing.\n', '*/\n', '\n', '  //if there have been executions, Adam Smith can deposit asset, get strike, up to execution amount.\n', '//  function invisibleHandOfAdamSmith( //#67\n', '\n', '  function optionExcerciseUnwind(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires,\n', '    uint256 _ticketAmount,\n', '    bool _fillOrKill //do we want? probably...\n', '  )\n', '    external\n', '    notLocked\n', '    returns (uint256 ticketsUnwound) //(amountTraded)\n', '  {\n', '    //only before, equal to expiry\n', '    require(block.number <= _optionExpires);\n', '    \n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    //if strike-pool[hash] != 0 {\n', '    ticketsUnwound = exercisedOptions[holderTicketAddress];\n', '\n', '    //fill or kill.\n', '    require((_fillOrKill == false) || (ticketsUnwound >= _ticketAmount));\n', '\n', '    //get amount to trade.\n', '    if (ticketsUnwound > _ticketAmount) ticketsUnwound = _ticketAmount;\n', '    \n', '    require(ticketsUnwound > 0);\n', '    //cant buy zero, either because not avail, or you asked for zero.\n', ' \n', '    //check compliance, like a trade!\n', '    require(\n', '      (! restrictedTokens[holderTicketAddress]) //if it is not restricted\n', '    || Compliance(complianceAddress).canTrade(holderTicketAddress, msg.sender) // or compliance says yes.\n', '    );\n', '\n', '    //debit balance of caller of asset tokens, credit 0x0\n', '    balances[_assetTokenAddress][msg.sender] = safeSub(\n', '      balances[_assetTokenAddress][msg.sender],\n', '      safeDiv(safeMul(_assetTokenAmount, ticketsUnwound), 1 ether)\n', '    );\n', '\n', '    balances[_assetTokenAddress][0x0] = safeAdd(\n', '      balances[_assetTokenAddress][0x0],\n', '      safeDiv(safeMul(_assetTokenAmount, ticketsUnwound), 1 ether)\n', '    );\n', '    \n', '    //debit balance of exercisedOptions of holdOption, credit caller.\n', '    //no change in global balances.\n', '    exercisedOptions[holderTicketAddress] =\n', '      safeSub(exercisedOptions[holderTicketAddress], ticketsUnwound);\n', '    balances[holderTicketAddress][msg.sender] =\n', '      safeAdd(balances[holderTicketAddress][msg.sender], ticketsUnwound);\n', '\n', '    //debit balance of 0x0 of strike, credit caller.\n', '    balances[_strikeTokenAddress][0x0] = safeSub(\n', '      balances[_strikeTokenAddress][0x0],\n', '      safeDiv(safeMul(_strikeTokenAmount, ticketsUnwound), 1 ether)\n', '    );\n', '\n', '    balances[_strikeTokenAddress][msg.sender] = safeAdd(\n', '      balances[_strikeTokenAddress][msg.sender],\n', '      safeDiv(safeMul(_strikeTokenAmount, ticketsUnwound), 1 ether)\n', '    );\n', '    \n', '    //emit event.\n', '    ExcerciseUnwind(\n', '      msg.sender,\n', '      holderTicketAddress,\n', '      ticketsUnwound,\n', '      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress)),\n', '      _fillOrKill\n', '    );\n', '    \n', '    return ticketsUnwound;\n', '  }\n', '  \n', '  //if before expiry, and own hold ticket, then pay strike, get asset, void hold ticket\n', '  function excerciseOption( //#68\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires,\n', '    uint256 _ticketAmount\n', '  )\n', '  external \n', '  returns (uint256 ticketsExcercised)\n', '  {  \n', '    //only holder before, equal to expiry\n', '    require(block.number <= _optionExpires);\n', '    \n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    //get balance of tickets\n', '    ticketsExcercised = balances[holderTicketAddress][msg.sender];\n', '    require(ticketsExcercised >= _ticketAmount); //its just a balance here.\n', '    \n', '    //get amount to trade.\n', '    if (ticketsExcercised > _ticketAmount) ticketsExcercised = _ticketAmount;\n', '    \n', '    //cant execute zero, either you have zero, or you asked for zero.\n', '    require(ticketsExcercised > 0);\n', '    \n', '    //debit balance of caller for holdOption, credit exercisedOptions    \n', '    balances[holderTicketAddress][msg.sender] =\n', '      safeSub(balances[holderTicketAddress][msg.sender], ticketsExcercised);\n', '    exercisedOptions[holderTicketAddress] =\n', '      safeAdd(exercisedOptions[holderTicketAddress], ticketsExcercised);\n', '        \n', '    //debit balance of caller for strikeToken, credit 0x0\n', '    balances[_strikeTokenAddress][msg.sender] = safeSub(\n', '      balances[_strikeTokenAddress][msg.sender],\n', '      safeDiv(safeMul(_strikeTokenAmount, ticketsExcercised), 1 ether)\n', '    );\n', '\n', '    balances[_strikeTokenAddress][0x0] = safeAdd(\n', '      balances[_strikeTokenAddress][0x0],\n', '      safeDiv(safeMul(_strikeTokenAmount, ticketsExcercised), 1 ether)\n', '    );\n', '    \n', '    //debit balance of 0x0 of asset, credit caller.   \n', '    balances[_assetTokenAddress][0x0] = safeSub(\n', '      balances[_assetTokenAddress][0x0],\n', '      safeDiv(safeMul(_assetTokenAmount, ticketsExcercised), 1 ether)\n', '    );\n', '    \n', '    balances[_assetTokenAddress][msg.sender] = safeAdd(\n', '      balances[_assetTokenAddress][msg.sender],\n', '      safeDiv(safeMul(_assetTokenAmount, ticketsExcercised), 1 ether)\n', '    );\n', '\n', '    \n', '    //no change in global balances.\n', '    //emit event.\n', '    ExcerciseOption(\n', '      msg.sender,\n', '      holderTicketAddress,\n', '      ticketsExcercised,\n', '      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress))\n', '    );\n', '    \n', '    return ticketsExcercised;\n', '  }\n', '\n', '  \n', '  //if after expiry, get collateral, void option.\n', '  function expireOption( //#69\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires,\n', '    uint256 _ticketAmount\n', '  )\n', '  external \n', '  returns (uint256 ticketsExpired)\n', '  {\n', '  //only writer, only after expiry\n', '    require(block.number > _optionExpires);\n', '        \n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    address writerTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      true\n', '    );\n', '    \n', '    //get balance of tickets\n', '    ticketsExpired = balances[writerTicketAddress][msg.sender];\n', '    require(ticketsExpired >= _ticketAmount); //its just a balance here.\n', '    \n', '    //get amount to trade.\n', '    if (ticketsExpired > _ticketAmount) ticketsExpired = _ticketAmount;\n', '    \n', '    //cant execute zero, either you have zero, or you asked for zero.\n', '    require(ticketsExpired > 0);\n', '    \n', '    // debit holder tickets from user, add to exercisedOptions.\n', '    balances[writerTicketAddress][msg.sender] =\n', '      safeSub(balances[writerTicketAddress][msg.sender], ticketsExpired);\n', '    exercisedOptions[writerTicketAddress] =\n', '      safeAdd(exercisedOptions[writerTicketAddress], ticketsExpired);\n', '    \n', '    //calculate amounts\n', '    uint256 strikeTokenAmount =\n', '      safeDiv(\n', '        safeMul(\n', '          safeDiv(safeMul(ticketsExpired, _strikeTokenAmount), 1 ether), //tickets\n', '          exercisedOptions[holderTicketAddress]\n', '        ),\n', '        globalBalance[holderTicketAddress]\n', '      );\n', '\n', '    uint256 assetTokenAmount =\n', '      safeDiv(\n', '        safeMul(\n', '          safeDiv(safeMul(ticketsExpired, _assetTokenAmount), 1 ether), //tickets\n', '          safeSub(globalBalance[holderTicketAddress], exercisedOptions[holderTicketAddress])\n', '        ),\n', '        globalBalance[holderTicketAddress]\n', '      );\n', '    \n', '\n', '    //debit zero, add to msg.sender\n', '    balances[_strikeTokenAddress][0x0] =\n', '      safeSub(balances[_strikeTokenAddress][0x0], strikeTokenAmount);\n', '    balances[_assetTokenAddress][0x0] =\n', '      safeSub(balances[_assetTokenAddress][0x0], assetTokenAmount);\n', '    balances[_strikeTokenAddress][msg.sender] =\n', '      safeAdd(balances[_strikeTokenAddress][msg.sender], strikeTokenAmount);\n', '    balances[_assetTokenAddress][msg.sender] =\n', '      safeAdd(balances[_assetTokenAddress][msg.sender], assetTokenAmount);\n', '  \n', '  //set inactive\n', '\n', '    ExpireOption( //#69]\n', '      msg.sender,\n', '      writerTicketAddress,\n', '      ticketsExpired,\n', '      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress))\n', '    );\n', '    return ticketsExpired;\n', '  }\n', '\n', '\n', '  //get an option&#39;s Hash&#39;s address\n', '  //  (•_•)  ( •_•)>⌐■-■  (⌐■_■)\n', '  //\n', '  //going from 32 bytes to 20 bytes still gives us 160 bits of hash goodness.\n', '  //that&#39;s still a crazy large number, and used by ethereum for addresses.\n', '  function getOptionAddress(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires,\n', '    bool _isWriter\n', '  )\n', '    public\n', '    view\n', '    returns(address)\n', '  {\n', '    return(\n', '      address(\n', '        keccak256(\n', '          _assetTokenAddress,\n', '          _assetTokenAmount,\n', '          _strikeTokenAddress,\n', '          _strikeTokenAmount,\n', '          _optionExpires,\n', '          _isWriter\n', '        )\n', '      )\n', '    );\n', '  }\n', '\n', '  /***********************************\n', '  / Options View Code\n', '  ************************************/\n', '  //since the options code might move, we should have a way to always\n', '  //call a function to this contract to get the current values\n', '  \n', '  function testIsOptionPairRegistered(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  )\n', '  external\n', '  view\n', '  returns(bool)\n', '  {\n', '    return(\n', '      OptionRegistry(optionsRegistryAddress).isOptionPairRegistered(\n', '        _assetTokenAddress,\n', '        _assetTokenAmount,\n', '        _strikeTokenAddress,\n', '        _strikeTokenAmount,\n', '        _optionExpires\n', '      )\n', '    );\n', '  }\n', '  \n', '\n', '  /***********************************\n', '  / Default Options Registration Code\n', '  ************************************/\n', '  // Register emits an event and adds it to restrictedToken.\n', '  // We&#39;ll deal with any other needed registration later.\n', '  // Set up for upgradeable external contract.\n', '  // return bools.\n', '  \n', '  event RegisterOptionsPair(\n', '    bytes32 indexed optionPair, //assetTokenAddress xor strikeTokenAddress\n', '    address indexed writerTicketAddress,\n', '    address indexed holderTicketAddress,\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  );  \n', '  \n', '    \n', '  function registerOptionPair(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  )\n', '  public\n', '  returns(bool)\n', '  {\n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '//    if (\n', '//      isOptionPairRegistered(\n', '//        _assetTokenAddress,\n', '//        _assetTokenAmount,\n', '//        _strikeTokenAddress,\n', '//        _strikeTokenAmount,\n', '//        _optionExpires\n', '//      )\n', '//    )\n', '    //cheaper not to make call gaswise, same result.\n', '    \n', '    if (restrictedTokens[holderTicketAddress]) {\n', '      return false;\n', '    //return halts execution, but else is better for readibility\n', '    } else {\n', '\n', '      address writerTicketAddress = getOptionAddress(\n', '        _assetTokenAddress,\n', '        _assetTokenAmount,\n', '        _strikeTokenAddress,\n', '        _strikeTokenAmount,\n', '        _optionExpires,\n', '        true\n', '      );\n', '    \n', '      restrictedTokens[holderTicketAddress] = true;\n', '      restrictedTokens[writerTicketAddress] = true;\n', '    \n', '      //an external contract would need to call something like this:\n', '      // after being registered as a helper contract on the main site.\n', '      //UberDelta(uberdeltaAddress).tokenRestriction(holderTicketAddress, true);\n', '      //UberDelta(uberdeltaAddress).tokenRestriction(writerTicketAddress, true);\n', '    \n', '      RegisterOptionsPair(\n', '        (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress)),\n', '        holderTicketAddress,\n', '        writerTicketAddress,\n', '        _assetTokenAddress,\n', '        _assetTokenAmount,\n', '        _strikeTokenAddress,\n', '        _strikeTokenAmount,\n', '        _optionExpires\n', '      );\n', '    \n', '      return(true);\n', '    }\n', '  }\n', '  \n', '  \n', '  // for v1, we&#39;ll simply return if there&#39;s a restriction.\n', '  function isOptionPairRegistered(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  )\n', '  public\n', '  view\n', '  returns(bool)\n', '  {\n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    return(restrictedTokens[holderTicketAddress]);\n', '  }\n', '  \n', '  \n', '  function getOptionPair(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  )\n', '  public\n', '  view\n', '  returns(address holderTicketAddress, address writerTicketAddress)\n', '  {\n', '    holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    writerTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      true\n', '    );\n', '    \n', '    return(holderTicketAddress, writerTicketAddress);\n', '  }\n', '  \n', '  \n', '  /******************\n', '  / EOS Registration\n', '  ******************/\n', '  // some users will accidentally keep EOS on the exchange during the snapshot.\n', '  function EOSRegistration (string _key) external onlyOwner{\n', '    EOS(0xd0a6E6C54DbC68Db5db3A091B171A77407Ff7ccf).register(_key);\n', '  }\n', '  \n', '}']
['pragma solidity ^0.4.19;\n', '\n', '// \n', '// UberDelta Exchange Contract - v1.0.0\n', '// \n', '//  www.uberdelta.com\n', '//\n', '\n', 'contract Token {\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }\n', '  \n', '  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    require(b > 0); //gentler than an assert.\n', '    c = a / b;\n', '    return c;\n', '  }\n', '\n', '\n', '  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract OwnerManager {\n', '\n', '  address public owner;\n', '  address public newOwner;\n', '  address public manager;\n', '\n', '  event OwnershipTransferProposed(address indexed _from, address indexed _to);\n', '  event OwnershipTransferConfirmed(address indexed _from, address indexed _to);\n', '  event NewManager(address indexed _newManager);\n', '\n', '\n', '  modifier onlyOwner {\n', '    assert(msg.sender == owner);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyManager {\n', '    assert(msg.sender == manager);\n', '    _;\n', '  }\n', '\n', '\n', '  function OwnerManager() public{\n', '    owner = msg.sender;\n', '    manager = msg.sender;\n', '  }\n', '\n', '\n', '  function transferOwnership(address _newOwner) onlyOwner external{\n', '    require(_newOwner != owner);\n', '    \n', '    OwnershipTransferProposed(owner, _newOwner);\n', '    \n', '    newOwner = _newOwner;\n', '  }\n', '\n', '\n', '  function confirmOwnership() external {\n', '    assert(msg.sender == newOwner);\n', '    \n', '    OwnershipTransferConfirmed(owner, newOwner);\n', '    \n', '    owner = newOwner;\n', '  }\n', '\n', '\n', '  function newManager(address _newManager) onlyOwner external{\n', '    require(_newManager != address(0x0));\n', '    \n', '    NewManager(_newManager);\n', '    \n', '    manager = _newManager;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Helper is OwnerManager {\n', '\n', '  mapping (address => bool) public isHelper;\n', '\n', '  modifier onlyHelper {\n', '    assert(isHelper[msg.sender] == true);\n', '    _;\n', '  }\n', '\n', '  event ChangeHelper(\n', '    address indexed helper,\n', '    bool status\n', '  );\n', '\n', '  function Helper() public{\n', '    isHelper[msg.sender] = true;\n', '  }\n', '\n', '  function changeHelper(address _helper, bool _status) external onlyManager {\n', '\t  ChangeHelper(_helper, _status);\n', '    isHelper[_helper] = _status;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Compliance {\n', '  function canDeposit(address _user) public view returns (bool isAllowed);\n', '  function canTrade(address _token, address _user) public view returns (bool isAllowed);\n', '  function validateTrade(\n', '    address _token,\n', '    address _getUser,\n', '    address _giveUser\n', '  )\n', '    public\n', '    view\n', '    returns (bool isAllowed)\n', '  ;\n', '}\n', '\n', 'contract OptionRegistry {\n', '  function registerOptionPair(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  )\n', '  public\n', '  returns(bool)\n', '  ;\n', '  \n', '  function isOptionPairRegistered(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  )\n', '  public\n', '  view\n', '  returns(bool)  \n', '  ;\n', '  \n', '}\n', '\n', 'contract EOS {\n', '    function register(string key) public;\n', '}\n', '\n', 'contract UberDelta is SafeMath, OwnerManager, Helper {\n', '\n', '  // The account that will receive fees\n', '  address public feeAccount;\n', '  \n', '  // The account that will receive lost ERC20 tokens\n', '  address public sweepAccount;\n', '  \n', '  // The address of the compliance engine\n', '  address public complianceAddress;\n', '  \n', '  // The address of the options registry\n', '  address public optionsRegistryAddress;\n', '  \n', '  // The address of the next exchange contract\n', '  address public newExchange;\n', '\n', '  // Turn off deposits and trades, allow upgrade and withdraw\n', '  bool public contractLocked;\n', '  \n', '  bytes32 signedTradeHash = keccak256(\n', '    "address contractAddress",\n', '    "address takerTokenAddress",\n', '    "uint256 takerTokenAmount",\n', '    "address makerTokenAddress",\n', '    "uint256 makerTokenAmount",\n', '    "uint256 tradeExpires",\n', '    "uint256 salt",\n', '    "address maker",\n', '    "address restrictedTo"\n', '  );\n', '  \n', '  bytes32 signedWithdrawHash = keccak256(\n', '    "address contractAddress",\n', '    "uint256 amount",\n', '    "uint256 fee",\n', '    "uint256 withdrawExpires",\n', '    "uint256 salt",\n', '    "address maker",\n', '    "address restrictedTo"\n', '  );\n', '\n', '\n', '  // Balance per token, for each user.\n', '  mapping (address => mapping (address => uint256)) public balances;\n', '  \n', '  // global token balance tracking (to detect lost tokens)\n', '  mapping (address => uint256) public globalBalance;\n', '  \n', '  // List of orders created by calling the exchange contract directly.\n', '  mapping (bytes32 => bool) public orders;\n', '  \n', '  // Lists the amount of each order that has been filled or cancelled.\n', '  mapping (bytes32 => uint256) public orderFills;\n', '  \n', '  // Tokens that need to be checked through the compliance engine.\n', '  mapping (address => bool) public restrictedTokens;\n', '\n', '  // Mapping of fees by user class (default class == 0x0)\n', '  mapping (uint256 => uint256) public feeByClass;\n', '  \n', '  // Mapping of users to user classes.\n', '  mapping (address => uint256) public userClass; \n', '  \n', '  \n', '  /*******************************************\n', '  / Exchange Regular Events\n', '  /******************************************/\n', '  \n', '  // Note: Order creation is usually off-chain\n', '  event Order(\n', '    bytes32 indexed tradePair,\n', '    address indexed maker,\n', '    address[4] addressData,\n', '    uint256[4] numberData\n', '  );\n', '  \n', '  event Cancel(\n', '    bytes32 indexed tradePair,\n', '    address indexed maker,\n', '    address[4] addressData,\n', '    uint256[4] numberData,\n', '    uint256 status\n', '  );\n', '  \n', '   event FailedTrade( \n', '    bytes32 indexed tradePair,\n', '    address indexed taker,\n', '    bytes32 hash,\n', '    uint256 failReason\n', '  ); \n', '  \n', '  event Trade( \n', '    bytes32 indexed tradePair,\n', '    address indexed maker,\n', '    address indexed taker,\n', '    address makerToken,\n', '    address takerToken,\n', '    address restrictedTo,\n', '    uint256[4] numberData,\n', '    uint256 tradeAmount,\n', '    bool fillOrKill\n', '  );\n', '  \n', '  event Deposit(\n', '    address indexed token,\n', '    address indexed toUser,\n', '    address indexed sender,\n', '    uint256 amount\n', '  );\n', '  \n', '  event Withdraw(\n', '    address indexed token,\n', '    address indexed toUser,\n', '    uint256 amount\n', '  );\n', '\n', '  event InternalTransfer(\n', '    address indexed token,\n', '    address indexed toUser,\n', '    address indexed sender,\n', '    uint256 amount\n', '  );\n', '\n', '  event TokenSweep(\n', '    address indexed token,\n', '    address indexed sweeper,\n', '    uint256 amount,\n', '    uint256 balance\n', '  );\n', '  \n', '  event RestrictToken(\n', '    address indexed token,\n', '    bool status\n', '  );\n', '  \n', '  event NewExchange(\n', '    address newExchange\n', '  );\n', '  \n', '  event ChangeFeeAccount(\n', '    address feeAccount\n', '  );\n', '  \n', '  event ChangeSweepAccount(\n', '    address sweepAccount\n', '  );\n', '  \n', '  event ChangeClassFee(\n', '    uint256 indexed class,\n', '    uint256 fee\n', '  );\n', '  \n', '  event ChangeUserClass(\n', '    address indexed user,\n', '    uint256 class\n', '  );\n', '  \n', '  event LockContract(\n', '    bool status\n', '  );\n', '  \n', '  event UpdateComplianceAddress(\n', '    address newComplianceAddress\n', '  );\n', '  \n', '  event UpdateOptionsRegistryAddress(\n', '    address newOptionsRegistryAddress\n', '  );\n', '  \n', '  event Upgrade(\n', '    address indexed user,\n', '    address indexed token,\n', '    address newExchange,\n', '    uint256 amount\n', '  );\n', '  \n', '  event RemoteWithdraw(\n', '    address indexed maker,\n', '    address indexed sender,\n', '    uint256 withdrawAmount,\n', '    uint256 feeAmount,\n', '    uint256 withdrawExpires,\n', '    uint256 salt,\n', '    address restrictedTo\n', '  );\n', '  \n', '  event CancelRemoteWithdraw(\n', '    address indexed maker,\n', '    uint256 withdrawAmount,\n', '    uint256 feeAmount,\n', '    uint256 withdrawExpires,\n', '    uint256 salt,\n', '    address restrictedTo,\n', '    uint256 status\n', '  );\n', '\n', '  //Constructor Function, set initial values.\n', '  function UberDelta() public {\n', '    feeAccount = owner;\n', '    sweepAccount = owner;\n', '    feeByClass[0x0] = 3000000000000000;\n', '    contractLocked = false;\n', '    complianceAddress = this;\n', '    optionsRegistryAddress = this;\n', '  }\n', '\n', '\n', '  // Prevent raw sends of Eth.\n', '  function() public {\n', '    revert();\n', '  }\n', '  \n', '  \n', '  \n', '  /*******************************************\n', '  / Contract Control Functions\n', '  /******************************************/\n', '  function changeNewExchange(address _newExchange) external onlyOwner {\n', '    //since _newExchange being zero turns off the upgrade function, lets\n', '    //allow this to be reset to 0x0.\n', '    \n', '    newExchange = _newExchange;\n', '    \n', '    NewExchange(_newExchange);\n', '  }\n', '\n', '\n', '  function changeFeeAccount(address _feeAccount) external onlyManager {\n', '    require(_feeAccount != address(0x0));\n', '    \n', '    feeAccount = _feeAccount;\n', '    \n', '    ChangeFeeAccount(_feeAccount);\n', '  }\n', '\n', '  function changeSweepAccount(address _sweepAccount) external onlyManager {\n', '    require(_sweepAccount != address(0x0));\n', '    \n', '    sweepAccount = _sweepAccount;\n', '    \n', '    ChangeSweepAccount(_sweepAccount);\n', '  }\n', '\n', '  function changeClassFee(uint256 _class, uint256 _fee) external onlyManager {\n', '    require(_fee <= 10000000000000000); //Max 1%.\n', '\n', '    feeByClass[_class] = _fee;\n', '\n', '    ChangeClassFee(_class, _fee);\n', '  }\n', '  \n', '  function changeUserClass(address _user, uint256 _newClass) external onlyHelper {\n', '    userClass[_user] = _newClass;\n', '    \n', '    ChangeUserClass(_user, _newClass);\n', '  }\n', '  \n', '  //Turn off deposits and trades, but still allow withdrawals and upgrades.\n', '  function lockContract(bool _lock) external onlyManager {\n', '    contractLocked = _lock;\n', '    \n', '    LockContract(_lock);\n', '  }\n', '  \n', '  function updateComplianceAddress(address _newComplianceAddress)\n', '    external\n', '    onlyManager\n', '  {\n', '    complianceAddress = _newComplianceAddress;\n', '    \n', '    UpdateComplianceAddress(_newComplianceAddress);\n', '  }\n', '\n', '  function updateOptionsRegistryAddress(address _newOptionsRegistryAddress)\n', '    external\n', '    onlyManager\n', '  {\n', '    optionsRegistryAddress = _newOptionsRegistryAddress;\n', '    \n', '    UpdateOptionsRegistryAddress(_newOptionsRegistryAddress);\n', '  }\n', '\n', '\n', '  // restriction function for tokens that need additional verifications\n', '  function tokenRestriction(address _newToken, bool _status) external onlyHelper {\n', '    restrictedTokens[_newToken] = _status;\n', '    \n', '    RestrictToken(_newToken, _status);\n', '  }\n', '\n', '  \n', '  //Turn off deposits and trades, but still allow withdrawals and upgrades.\n', '  modifier notLocked() {\n', '    require(!contractLocked);\n', '    _;\n', '  }\n', '  \n', '  \n', '  /*******************************************************\n', '  / Deposit/Withdrawal/Transfer\n', '  /\n', '  / In all of the following functions, it should be noted\n', '  / that the 0x0 address is used to represent ETH.\n', '  /******************************************************/\n', '  \n', '  // SafeMath sanity checks inputs in deposit(), withdraw(), and token functions.\n', '  \n', '  // Deposit ETH in the contract to trade with\n', '  function deposit() external notLocked payable returns(uint256) {\n', '    require(Compliance(complianceAddress).canDeposit(msg.sender)); \n', '    // defaults to true until we change compliance code\n', '    \n', '    balances[address(0x0)][msg.sender] = safeAdd(balances[address(0x0)][msg.sender], msg.value);\n', '    globalBalance[address(0x0)] = safeAdd(globalBalance[address(0x0)], msg.value);\n', '\n', '    Deposit(0x0, msg.sender, msg.sender, msg.value);\n', '    \n', '    return(msg.value);\n', '  }\n', '\n', '  // Withdraw ETH from the contract to your wallet  (internal transaction on etherscan)\n', '  function withdraw(uint256 _amount) external returns(uint256) {\n', '    //require(balances[address(0x0)][msg.sender] >= _amount);\n', '    //handled by safeSub.\n', '    \n', '    balances[address(0x0)][msg.sender] = safeSub(balances[address(0x0)][msg.sender], _amount);\n', '    globalBalance[address(0x0)] = safeSub(globalBalance[address(0x0)], _amount);\n', ' \n', '    //transfer has a built in require\n', '    msg.sender.transfer(_amount);\n', '    \n', '    Withdraw(0x0, msg.sender, _amount);\n', '    \n', '    return(_amount);\n', '  }\n', '\n', '\n', '  // Deposit ERC20 tokens in the contract to trade with\n', '  // Token(_token).approve(this, _amount) must be called in advance\n', '  // ERC223 tokens must be deposited by a transfer to this contract ( see tokenFallBack(..) )\n', '  function depositToken(address _token, uint256 _amount) external notLocked returns(uint256) {\n', '    require(_token != address(0x0));\n', '    \n', '    require(Compliance(complianceAddress).canDeposit(msg.sender));\n', '\n', '    balances[_token][msg.sender] = safeAdd(balances[_token][msg.sender], _amount);\n', '    globalBalance[_token] = safeAdd(globalBalance[_token], _amount);\n', '    \n', '    require(Token(_token).transferFrom(msg.sender, this, _amount));\n', '\n', '    Deposit(_token, msg.sender, msg.sender, _amount);\n', '    \n', '    return(_amount);\n', '  }\n', '\n', '  // Withdraw ERC20/223 tokens from the contract back to your wallet\n', '  function withdrawToken(address _token, uint256 _amount)\n', '    external\n', '    returns (uint256)\n', '  {\n', '    if (_token == address(0x0)){\n', '      //keep the nulls to reduce gas usage.\n', '      //require(balances[_token)][msg.sender] >= _amount);\n', '      //handled by safeSub.\n', '      balances[address(0x0)][msg.sender] = safeSub(balances[address(0x0)][msg.sender], _amount);\n', '      globalBalance[address(0x0)] = safeSub(globalBalance[address(0x0)], _amount);\n', '\n', '      //transfer has a built in require\n', '      msg.sender.transfer(_amount);\n', '    } else {\n', '      //require(balances[_token][msg.sender] >= _amount);\n', '      //handled by safeSub \n', ' \n', '      balances[_token][msg.sender] = safeSub(balances[_token][msg.sender], _amount);\n', '      globalBalance[_token] = safeSub(globalBalance[_token], _amount);\n', '\n', '      require(Token(_token).transfer(msg.sender, _amount));\n', '    }    \n', '\n', '    Withdraw(_token, msg.sender, _amount);\n', '    \n', '    return _amount;\n', '  }\n', '\n', '  // Deposit ETH in the contract on behalf of another address\n', '  // Warning: afterwards, only _user will be able to trade or withdraw these funds\n', '  function depositToUser(address _toUser) external payable notLocked returns (bool success) {\n', '    require(\n', '        (_toUser != address(0x0))\n', '     && (_toUser != address(this))\n', '     && (Compliance(complianceAddress).canDeposit(_toUser))\n', '    );\n', '    \n', '    balances[address(0x0)][_toUser] = safeAdd(balances[address(0x0)][_toUser], msg.value);\n', '    globalBalance[address(0x0)] = safeAdd(globalBalance[address(0x0)], msg.value);\n', '    \n', '    Deposit(0x0, _toUser, msg.sender, msg.value);\n', '    \n', '    return true;\n', '  }\n', '\n', '  // Deposit ERC20 tokens in the contract on behalf of another address\n', '  // Token(_token).approve(this, _amount) must be called in advance\n', '  // Warning: afterwards, only _toUser will be able to trade or withdraw these funds\n', '  // ERC223 tokens must be deposited by a transfer to this contract ( see tokenFallBack(..) )\n', '  function depositTokenToUser(\n', '    address _toUser,\n', '    address _token,\n', '    uint256 _amount\n', '  )\n', '    external\n', '    notLocked\n', '    returns (bool success)\n', '  {\n', '    require(\n', '        (_token != address(0x0))\n', '\n', '     && (_toUser  != address(0x0))\n', '     && (_toUser  != address(this))\n', '     && (_toUser  != _token)\n', '     && (Compliance(complianceAddress).canDeposit(_toUser))\n', '    );\n', '    \n', '    balances[_token][_toUser] = safeAdd(balances[_token][_toUser], _amount);\n', '    globalBalance[_token] = safeAdd(globalBalance[_token], _amount);\n', '\n', '    require(Token(_token).transferFrom(msg.sender, this, _amount));\n', '\n', '    Deposit(_token, _toUser, msg.sender, _amount);\n', '    \n', '    return true;\n', '  }\n', '\n', '\n', '  //ERC223 Token Acceptor function, called when an ERC2223 token is transferred to this contract\n', '  // provide _sendTo to make it a deposit on behalf of another address (depositToUser)\n', '  function tokenFallback(\n', '    address _from,  // user calling the function\n', '    uint256 _value, // the number of tokens\n', '    bytes _sendTo     // "deposit to other user" if exactly 20 bytes sent\n', '    \n', '  )\n', '    external\n', '    notLocked\n', '  {\n', '    //first lets figure out who this is going to.\n', '    address toUser = _from;     //probably this\n', '    if (_sendTo.length == 20){  //but use data for sendTo otherwise.\n', '\n', "      // I'm about 90% sure I don't need to do the casting here, but for\n", "      // like twenty gas, I'll take the protection from potentially\n", '      // stomping on weird memory locations.\n', '      \n', '      uint256 asmAddress;\n', '      assembly { //uses 50 gas\n', '        asmAddress := calldataload(120)\n', '      }\n', '      toUser = address(asmAddress);\n', '    }\n', '    \n', '    //sanity checks.\n', '    require(\n', '        (toUser != address(0x0))\n', '     && (toUser != address(this))\n', '     && (toUser != msg.sender)  // msg.sender is the token\n', '     && (Compliance(complianceAddress).canDeposit(toUser))\n', '    );\n', '    \n', '    // check if a contract is calling this\n', '    uint256 codeLength;\n', '    assembly {\n', '      codeLength := extcodesize(caller)\n', '    }\n', '    require(codeLength > 0);    \n', '    \n', '    globalBalance[msg.sender] = safeAdd(globalBalance[msg.sender], _value);\n', '    balances[msg.sender][toUser] = safeAdd(balances[msg.sender][toUser], _value);\n', '    \n', '    //sanity check, and as a perk, we check for balanceOf();\n', '    require(Token(msg.sender).balanceOf(this) >= _value);\n', '\n', '    Deposit(msg.sender, toUser, _from, _value);\n', '  }\n', '\n', '  // Move deposited tokens or ETH (0x0) from one to another address within the contract\n', '  function internalTransfer(\n', '    address _toUser,\n', '    address _token,\n', '    uint256 _amount\n', '  )\n', '    external\n', '    notLocked \n', '    returns(uint256)\n', '  {\n', '    require(\n', '        (balances[_token][msg.sender] >= _amount)\n', '     && (_toUser != address(0x0))\n', '     && (_toUser != address(this))\n', '     && (_toUser != _token)\n', '     && (Compliance(complianceAddress).canDeposit(_toUser))\n', '    );\n', ' \n', '    balances[_token][msg.sender] = safeSub(balances[_token][msg.sender], _amount);\n', '    balances[_token][_toUser] = safeAdd(balances[_token][_toUser], _amount);\n', '\n', '    InternalTransfer(_token, _toUser, msg.sender, _amount);\n', '    \n', '    return(_amount);\n', '  }\n', '  \n', '  // return the token/ETH balance a user has deposited in the contract\n', '  function balanceOf(address _token, address _user) external view returns (uint) {\n', '    return balances[_token][_user];\n', '  }\n', '\n', '  \n', "  // In order to see the ERC20 total balance, we're calling an external contract,\n", "  // and this contract claims to be ERC20, but we don't know what's really there.\n", '  // We can\'t rely on the EVM or solidity to enforce "view", so even though a\n', "  // normal token can rely on itself to be non-malicious, we can't.\n", "  // We have no idea what potentially evil tokens we'll be interacting with.\n", '  // The call to check the reported balance needs to go after the state changes,\n', "  // even though it's un-natural. Now, on one hand, this function might at first\n", "  // appear safe, since we're only allowing the sweeper address to access\n", '  // *this function,* but we are reading the state of the globalBalance.\n', '  // In theory, a malicious token could do the following:\n', "  //  1a) Check if the caller of balanceOf is our contract, if it's not, act normally.\n", '  //  1b) If the caller is our contract, it does the following:\n', '  //  2) Read our contracts globalBalance for its own address.\n', "  //  3) Sets our contract's balance of the token (in the token controller) to our internal globalBalance\n", '  //  4) Allocates some other address the difference in globalBalance and actual balance for our contract.\n', '  //  5) Report back to this function exactly the amount we had in globalBalance.\n', '  // (which, by then is true, since they were stolen).\n', "  // Now we're always going to see 0 extra tokens, and our users have had their tokens perminantly lost.\n", '  // bonus: this is why there is no "sweep all" function.\n', '    \n', '  // Detect ERC20 tokens that have been sent to the contract without a deposit (lost tokens),\n', '  // which are not included in globalBalance[..]\n', '  function sweepTokenAmount(address _token, uint256 _amount) external returns(uint256) {\n', '    assert(msg.sender == sweepAccount);\n', '\n', '    balances[_token][sweepAccount] = safeAdd(balances[_token][sweepAccount], _amount);\n', '    globalBalance[_token] = safeAdd(globalBalance[_token], _amount);\n', '    \n', '    //You go last!\n', '\tif(_token != address(0x0)) { \n', '      require(globalBalance[_token] <= Token(_token).balanceOf(this));\n', '\t} else {\n', '\t  // if another contract performs selfdestruct(UberDelta),\n', '    // ETH can get in here without being in globalBalance\n', '\t  require(globalBalance[address(0x0)] <= this.balance); \n', '\t}\n', '    \n', '    TokenSweep(_token, msg.sender, _amount, balances[_token][sweepAccount]);\n', '    \n', '    return(_amount);\n', '  }\n', '  \n', '  \n', '  /*******************************************\n', '  / Regular Trading functions\n', '  /******************************************/\n', '  \n', '  //now contracts can place orders!\n', '  \n', '  \n', '  // Normal order creation happens off-chain and orders are signed by creators,\n', '  // this function allows for on-chain orders to be created\n', '  function order(\n', '    address[4] _addressData,\n', "    uint256[4] _numberData //web3 isn't ready for structs.\n", '  )\n', '    external\n', '    notLocked\n', '    returns (bool success)\n', '  {\n', '  \n', '//    _addressData[2] is maker;\n', '    if (msg.sender != _addressData[2]) { return false; }\n', '    \n', '    bytes32 hash = getHash(_addressData, _numberData);\n', '\n', '    orders[hash] = true;\n', '\n', '    Order(\n', '      (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '      msg.sender,\n', '      _addressData,\n', '      _numberData);\n', '    \n', '    return true;\n', '  }  \n', '\n', '\n', '  function tradeBalances(\n', '    address _takerTokenAddress,\n', '    uint256 _takerTokenAmount,\n', '    address _makerTokenAddress,\n', '    uint256 _makerTokenAmount,\n', '    address _maker,\n', '    uint256 _tradeAmount\n', '  )\n', '    internal\n', '  {\n', '    require(_takerTokenAmount > 0); //safeDiv\n', '\n', '    // We charge only the takers this fee\n', '    uint256 feeValue = safeMul(_tradeAmount, feeByClass[userClass[msg.sender]]) / (1 ether);\n', '    \n', '    balances[_takerTokenAddress][_maker] =\n', '      safeAdd(balances[_takerTokenAddress][_maker], _tradeAmount);\n', '    balances[_takerTokenAddress][msg.sender] =\n', '      safeSub(balances[_takerTokenAddress][msg.sender], safeAdd(_tradeAmount, feeValue));\n', '    \n', '    balances[_makerTokenAddress][_maker] =\n', '      safeSub(\n', '        balances[_makerTokenAddress][_maker],\n', '        safeMul(_makerTokenAmount, _tradeAmount) / _takerTokenAmount\n', '      );\n', '    balances[_makerTokenAddress][msg.sender] =\n', '      safeAdd(\n', '        balances[_makerTokenAddress][msg.sender],\n', '        safeMul(_makerTokenAmount, _tradeAmount) / _takerTokenAmount\n', '      );\n', '    \n', '    balances[_takerTokenAddress][feeAccount] =\n', '      safeAdd(balances[_takerTokenAddress][feeAccount], feeValue);\n', '  }\n', '\n', '\n', '  function trade(\n', '    address[4] _addressData,\n', "    uint256[4] _numberData, //web3 isn't ready for structs.\n", '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s,\n', '    uint256 _amount,\n', '    bool _fillOrKill\n', '  )\n', '    external\n', '    notLocked\n', '    returns(uint256 tradeAmount)\n', '  {\n', '  \n', '//      _addressData[0], // takerTokenAddress;\n', '//      _numberData[0], // takerTokenAmount;\n', '//      _addressData[1], // makerTokenAddress;\n', '//      _numberData[1], // makerTokenAmount;\n', '//      _numberData[2], // tradeExpires;\n', '//      _numberData[3], // salt;\n', '//      _addressData[2], // maker;\n', '//      _addressData[3] // restrictedTo;\n', '    \n', '    bytes32 hash = getHash(_addressData, _numberData);\n', '    \n', '    tradeAmount = safeSub(_numberData[0], orderFills[hash]); //avail to trade\n', '    \n', "    //balance of giveToken / amount I said I'd give of giveToken * amount I said I want of getToken\n", '    if (\n', '      tradeAmount > safeDiv(\n', '        safeMul(balances[_addressData[1]][_addressData[2]], _numberData[0]),\n', '        _numberData[1]\n', '      )\n', '    )\n', '    {\n', '      tradeAmount = safeDiv(\n', '        safeMul(balances[_addressData[1]][_addressData[2]], _numberData[0]),\n', '        _numberData[1]\n', '      );\n', '    }\n', '    \n', '    if (tradeAmount > _amount) { tradeAmount = _amount; }\n', '    \n', '        //_numberData[0] is takerTokenAmount\n', "    if (tradeAmount == 0) { //idfk. There's nothing there to get. Canceled? Traded?\n", '      if (orderFills[hash] < _numberData[0]) { //Maker seems to be missing tokens?\n', '        FailedTrade(\n', '          (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '          msg.sender,\n', '          hash,\n', '          0\n', '        );\n', '      } else {  // either cancelled or already traded.\n', '        FailedTrade(\n', '          (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '          msg.sender,\n', '          hash,\n', '          1\n', '        );\n', '      }\n', '      return 0;\n', '    }\n', '    \n', '    \n', '    if (block.number > _numberData[2]) { //order is expired\n', '      FailedTrade(\n', '        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '        msg.sender,\n', '        hash,\n', '        2\n', '      );\n', '      return 0;\n', '    }\n', '\n', '\n', '    if ((_fillOrKill == true) && (tradeAmount < _amount)) { //didnt fill, so kill\n', '      FailedTrade(\n', '        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '        msg.sender,\n', '        hash,\n', '        3\n', '      );\n', '      return 0;\n', '    }\n', '    \n', '        \n', '    uint256 feeValue = safeMul(_amount, feeByClass[userClass[msg.sender]]) / (1 ether);\n', '\n', '    //if they trade more than they have, get 0.\n', '    if ( (_amount + feeValue) > balances[_addressData[0]][msg.sender])  { \n', '      FailedTrade(\n', '        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '        msg.sender,\n', '        hash,\n', '        4\n', '      );\n', '      return 0;\n', '    }\n', '    \n', '    if ( //not a valid order.\n', '        (ecrecover(keccak256(signedTradeHash, hash), _v, _r, _s) != _addressData[2])\n', '        && (! orders[hash])\n', '    )\n', '    {\n', '      FailedTrade(\n', '        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '        msg.sender,\n', '        hash,\n', '        5\n', '      );\n', '      return 0;\n', '    }\n', '\n', '    \n', '    if ((_addressData[3] != address(0x0)) && (_addressData[3] != msg.sender)) { //check restrictedTo\n', '      FailedTrade(\n', '        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '        msg.sender,\n', '        hash,\n', '        6\n', '      );\n', '      return 0;\n', '    }\n', '        \n', '    \n', "    if ( //if there's a compliance restriction.\n", '      ((_addressData[0] != address(0x0)) //if not Eth, and restricted, check with Compliance.\n', '        && (restrictedTokens[_addressData[0]] )\n', '        && ! Compliance(complianceAddress).validateTrade(_addressData[0], _addressData[2], msg.sender)\n', '      )\n', '      || ((_addressData[1] != address(0x0))  //ditto\n', '        && (restrictedTokens[_addressData[1]])\n', '        && ! Compliance(complianceAddress).validateTrade(_addressData[1], _addressData[2], msg.sender)\n', '      )\n', '    )\n', '    {\n', '      FailedTrade(\n', '        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '        msg.sender,\n', '        hash,\n', '        7\n', '      );\n', '      return 0;\n', '    }\n', '    \n', '    //Do the thing!\n', '    \n', '    tradeBalances(\n', '      _addressData[0], // takerTokenAddress;\n', '      _numberData[0], // takerTokenAmount;\n', '      _addressData[1], // makerTokenAddress;\n', '      _numberData[1], // makerTokenAmount;\n', '      _addressData[2], // maker;\n', '      tradeAmount\n', '    );\n', '\n', '    orderFills[hash] = safeAdd(orderFills[hash], tradeAmount);\n', '\n', '    Trade(\n', '      (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '      _addressData[2],\n', '      msg.sender,\n', '      _addressData[1],\n', '      _addressData[0],\n', '      _addressData[3],\n', '      _numberData,\n', '      tradeAmount,\n', '      _fillOrKill\n', '    );\n', '    \n', '    return(tradeAmount);\n', '  }\n', '  \n', '  \n', '  // Cancel a signed order, once this is confirmed nobody will be able to trade it anymore\n', '  function cancelOrder(\n', '    address[4] _addressData,\n', "    uint256[4] _numberData //web3 isn't ready for structs.\n", '  )\n', '    external\n', '    returns(uint256 amountCancelled)\n', '  {\n', '    \n', '    require(msg.sender == _addressData[2]);\n', '    \n', "    //  msg.sender can 'cancel' nonexistent orders since they're offchain.\n", '    bytes32 hash = getHash(_addressData, _numberData);\n', ' \n', '    amountCancelled = safeSub(_numberData[0],orderFills[hash]);\n', '    \n', '    orderFills[hash] = _numberData[0];\n', ' \n', '    //event trigger is moved ahead of balance resetting to allow expression of the already-filled amount\n', '//    _numberData[0] is takerTokenAmount;\n', '    Cancel(\n', '      (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\n', '      msg.sender,\n', '      _addressData,\n', '      _numberData,\n', '      amountCancelled);\n', '\n', '    return amountCancelled;    \n', '  }\n', '\n', '\n', '\n', '  /**************************\n', '  / Remote Withdraw\n', '  ***************************/\n', '  \n', '  // Perform an ETH withdraw transaction for someone else based on their signed message\n', '  // Useful if the owner of the funds does not have enough ETH for gas fees in their wallet.\n', '  // msg.sender receives fee for the effort and gas costs\n', '  function remoteWithdraw(\n', '    uint256 _withdrawAmount,\n', '    uint256 _feeAmount,\n', '    uint256 _withdrawExpires,\n', '    uint256 _salt,\n', '    address _maker,\n', '    address _restrictedTo, //0x0 = anyone\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s\n', '  )\n', '    external\n', '    notLocked\n', '    returns(bool)\n', '  {\n', '    //is the withdraw possible?\n', '    require(\n', '        (balances[address(0x0)][_maker] >= safeAdd(_withdrawAmount, _feeAmount))\n', '     && (\n', '            (_restrictedTo == address(0x0))\n', '         || (_restrictedTo == msg.sender)\n', '        )\n', '     && ((_feeAmount == 0) || (Compliance(complianceAddress).canDeposit(msg.sender)))\n', '    );\n', '    \n', '    //has this withdraw happened already? (and generate the hash)\n', '\n', '    bytes32 hash = keccak256(\n', '      this, \n', '      _withdrawAmount,\n', '      _feeAmount,\n', '      _withdrawExpires,\n', '      _salt,\n', '      _maker,\n', '      _restrictedTo\n', '    );\n', '\n', '    require(orderFills[hash] == 0);\n', '\n', '    //is this real?\n', '    require(\n', '      ecrecover(keccak256(signedWithdrawHash, hash), _v, _r, _s) == _maker\n', '    );\n', '    \n', '    //only once.\n', '    orderFills[hash] = 1;\n', '\n', '    balances[address(0x0)][_maker] =\n', '      safeSub(balances[address(0x0)][_maker], safeAdd(_withdrawAmount, _feeAmount));\n', '    // pay fee to the user performing the remote withdraw\n', '    balances[address(0x0)][msg.sender] = safeAdd(balances[address(0x0)][msg.sender], _feeAmount);\n', '    \n', '    globalBalance[address(0x0)] = safeSub(globalBalance[address(0x0)], _withdrawAmount);\n', '\n', '    RemoteWithdraw(\n', '      _maker,\n', '      msg.sender,\n', '      _withdrawAmount,\n', '      _feeAmount,\n', '      _withdrawExpires,\n', '      _salt,\n', '      _restrictedTo\n', '    );\n', '\n', '    //implicit require included.\n', '    _maker.transfer(_withdrawAmount);\n', '    \n', '    return(true);\n', '  }\n', '\n', '  // cancel a signed request for a remote withdraw\n', '  function cancelRemoteWithdraw(\n', '    uint256 _withdrawAmount,\n', '    uint256 _feeAmount,\n', '    uint256 _withdrawExpires,\n', '    uint256 _salt,\n', '    address _restrictedTo //0x0 = anyone\n', '  )\n', '    external\n', '  {\n', '      // msg.sender can cancel nonexsistent orders.\n', '    bytes32 hash = keccak256(\n', '      this, \n', '      _withdrawAmount,\n', '      _feeAmount,\n', '      _withdrawExpires,\n', '      _salt,\n', '      msg.sender,\n', '      _restrictedTo\n', '    );\n', '    \n', '    CancelRemoteWithdraw(\n', '      msg.sender,\n', '      _withdrawAmount,\n', '      _feeAmount,\n', '      _withdrawExpires,\n', '      _salt,\n', '      _restrictedTo,\n', '      orderFills[hash]\n', '    );\n', '    \n', '    //set to completed after, event shows pre-cancel status.\n', '    orderFills[hash] = 1;\n', '  }\n', '  \n', '  \n', ' \n', '\n', '  /**************************\n', '  /Upgrade Function\n', '  ***************************/\n', '      \n', '  // move tokens/ETH over to a new upgraded smart contract  (avoids having to withdraw & deposit)\n', '  function upgrade(address _token) external returns(uint256 moveBalance) {\n', '    require (newExchange != address(0x0));\n', '\n', '    moveBalance = balances[_token][msg.sender];\n', '\n', '    globalBalance[_token] = safeSub(globalBalance[_token], moveBalance);\n', '    balances[_token][msg.sender] = 0;\n', '\n', '    if (_token != address(0x0)){\n', '      require(Token(_token).approve(newExchange, moveBalance));\n', '      require(UberDelta(newExchange).depositTokenToUser(msg.sender, _token, moveBalance));\n', '    } else {\n', '      require(UberDelta(newExchange).depositToUser.value(moveBalance)(msg.sender));\n', '    }\n', '\n', '    Upgrade(msg.sender, _token, newExchange, moveBalance);\n', '    \n', '    return(moveBalance);\n', '  }\n', '\n', '\n', '  \n', '  /*******************************************\n', '  / Data View functions\n', '  /******************************************/\n', '  \n', '  function testTrade(\n', '    address[4] _addressData,\n', "    uint256[4] _numberData, //web3 isn't ready for structs.\n", '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s,\n', '    uint256 _amount,\n', '    address _sender,\n', '    bool _fillOrKill\n', '  )\n', '    public\n', '    view\n', '    returns(uint256)\n', '  {\n', '    uint256 feeValue = safeMul(_amount, feeByClass[userClass[_sender]]) / (1 ether);\n', '\n', '    if (\n', '      contractLocked\n', '      ||\n', '      ((_addressData[0] != address(0x0)) //if not Eth, and restricted, check with Compliance.\n', '        && (restrictedTokens[_addressData[0]] )\n', '        && ! Compliance(complianceAddress).validateTrade(_addressData[0], _addressData[2], _sender)\n', '      )\n', '      || ((_addressData[1] != address(0x0))  //ditto\n', '        && (restrictedTokens[_addressData[1]])\n', '        && ! Compliance(complianceAddress).validateTrade(_addressData[1], _addressData[2], _sender)\n', '      )\n', '         //if they trade more than they have, get 0.\n', '      || ((_amount + feeValue) > balances[_addressData[0]][_sender]) \n', '      || ((_addressData[3] != address(0x0)) && (_addressData[3] != _sender)) //check restrictedTo\n', '    )\n', '    {\n', '      return 0;\n', '    }\n', '      \n', '    uint256 tradeAmount = availableVolume(\n', '        _addressData,\n', '        _numberData,\n', '        _v,\n', '        _r,\n', '        _s\n', '    );\n', '    \n', '    if (tradeAmount > _amount) { tradeAmount = _amount; }\n', '    \n', '    if ((_fillOrKill == true) && (tradeAmount < _amount)) {\n', '      return 0;\n', '    }\n', '\n', '    return tradeAmount;\n', '  }\n', '\n', '\n', '  // get how much of an order is left (unfilled)\n', '  // return value in order of _takerTokenAddress\n', '  function availableVolume(\n', '    address[4] _addressData,\n', "    uint256[4] _numberData, //web3 isn't ready for structs.\n", '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s\n', '  )\n', '    public\n', '    view\n', '    returns(uint256 amountRemaining)\n', '  {     \n', '//    _addressData[0] // takerTokenAddress;\n', '//    _numberData[0] // takerTokenAmount;\n', '//    _addressData[1] // makerTokenAddress;\n', '//    _numberData[1] // makerTokenAmount;\n', '//    _numberData[2] // tradeExpires;\n', '//    _numberData[3] // salt;\n', '//    _addressData[2] // maker;\n', '//    _addressData[3] // restrictedTo;\n', '\n', '    bytes32 hash = getHash(_addressData, _numberData);\n', '\n', '    if (\n', '      (block.number > _numberData[2])\n', '      || ( \n', '        (ecrecover(keccak256(signedTradeHash, hash), _v, _r, _s) != _addressData[2])\n', '        && (! orders[hash])\n', '      )\n', '    ) { return 0; }\n', '\n', '    //uint256 amountRemaining = safeSub(myTrade.takerTokenAmount, orderFills[hash]);\n', '     amountRemaining = safeSub(_numberData[0], orderFills[hash]);\n', '\n', '    if (\n', '      amountRemaining < safeDiv(\n', '        safeMul(balances[_addressData[1]][_addressData[2]], _numberData[0]),\n', '        _numberData[1]\n', '      )\n', '    ) return amountRemaining;\n', '\n', '    return (\n', '      safeDiv(\n', '        safeMul(balances[_addressData[1]][_addressData[2]], _numberData[0]),\n', '        _numberData[1]\n', '      )\n', '    );\n', '  }\n', '\n', '\n', '  // get how much of an order has been filled\n', '  // return value in order of _takerTokenAddress\n', '  function getUserFee(\n', '    address _user\n', '  )\n', '    external\n', '    view\n', '    returns(uint256)\n', '  {\n', '    return feeByClass[userClass[_user]];\n', '  }\n', '\n', '\n', '  // get how much of an order has been filled\n', '  // return value in order of _takerTokenAddress\n', '  function amountFilled(\n', '    address[4] _addressData,\n', "    uint256[4] _numberData //web3 isn't ready for structs.\n", '  )\n', '    external\n', '    view\n', '    returns(uint256)\n', '  {\n', '    bytes32 hash = getHash(_addressData, _numberData);\n', '\n', '    return orderFills[hash];\n', '  }\n', '\n', '  \n', '  // check if a request for a remote withdraw is still valid\n', '  function testRemoteWithdraw(\n', '    uint256 _withdrawAmount,\n', '    uint256 _feeAmount,\n', '    uint256 _withdrawExpires,\n', '    uint256 _salt,\n', '    address _maker,\n', '    address _restrictedTo,\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s,\n', '    address _sender\n', '  )\n', '    external\n', '    view\n', '    returns(uint256)\n', '  {\n', '    bytes32 hash = keccak256(\n', '      this,\n', '      _withdrawAmount,\n', '      _feeAmount,\n', '      _withdrawExpires,\n', '      _salt,\n', '      _maker,\n', '      _restrictedTo\n', '    );\n', '\n', '    if (\n', '      contractLocked\n', '      ||\n', '      (balances[address(0x0)][_maker] < safeAdd(_withdrawAmount, _feeAmount))\n', '      ||((_restrictedTo != address(0x0)) && (_restrictedTo != _sender))\n', '      || (orderFills[hash] != 0)\n', '      || (ecrecover(keccak256(signedWithdrawHash, hash), _v, _r, _s) != _maker)\n', '      || ((_feeAmount > 0) && (! Compliance(complianceAddress).canDeposit(_sender)))\n', '    )\n', '    {\n', '      return 0;\n', '    } else {\n', '      return _withdrawAmount;\n', '    }\n', '  }\n', '  \n', '  \n', '  \n', '  function getHash(\n', '    address[4] _addressData,\n', "    uint256[4] _numberData //web3 isn't ready for structs.\n", '  )\n', '    public\n', '    view\n', '    returns(bytes32)\n', '  {\n', '    return(\n', '      keccak256(\n', '        this,\n', '        _addressData[0], // takerTokenAddress;\n', '        _numberData[0], // takerTokenAmount;\n', '        _addressData[1], // makerTokenAddress;\n', '        _numberData[1], // makerTokenAmount;\n', '        _numberData[2], // tradeExpires;\n', '        _numberData[3], // salt;\n', '        _addressData[2], // maker;\n', '        _addressData[3] // restrictedTo;\n', '      )\n', '    );\n', '  }\n', '  \n', '  \n', '\n', '  /***********************************\n', '  / Compliance View Code\n', '  ************************************/\n', '  //since the compliance code might move, we should have a way to always\n', '  //call a function to this contract to get the current values\n', '\n', '    function testCanDeposit(\n', '    address _user\n', '  )\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    return(Compliance(complianceAddress).canDeposit(_user));\n', '  }\n', '  \n', '  function testCanTrade(\n', '    address _token,\n', '    address _user\n', '  )\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    return(Compliance(complianceAddress).canTrade(_token, _user));\n', '  }\n', '\n', '  \n', '  function testValidateTrade(\n', '    address _token,\n', '    address _getUser,\n', '    address _giveUser\n', '  )\n', '    external\n', '    view\n', '    returns (bool isAllowed)\n', '  {\n', '    return(Compliance(complianceAddress).validateTrade(_token, _getUser, _giveUser));\n', '  }\n', '  \n', '\n', '\n', '  /**************************\n', '  / Default Compliance Code\n', '  ***************************/\n', '  // These will eventually live in a different contract.\n', '  // every can deposit by default, later a registry?\n', '  // For now, always say no if called for trades. \n', '  // the earliest use may be halting trade in a token.\n', '  function canDeposit(\n', '    address _user\n', '  )\n', '    public\n', '    view\n', '    returns (bool isAllowed)\n', '  {\n', '    return(true);\n', '  }\n', '  \n', '  function canTrade(\n', '    address _token,\n', '    address _user\n', '  )\n', '    public\n', '    view\n', '    returns (bool isAllowed)\n', '  {\n', '    return(false);\n', '  }\n', '\n', '  \n', '  function validateTrade(\n', '    address _token,\n', '    address _getUser,\n', '    address _giveUser\n', '  )\n', '    public\n', '    view\n', '    returns (bool isAllowed)\n', '  {\n', '    return(false);\n', '  }\n', '  \n', '\n', '\n', '  /***********************************\n', '  / THIS IS WHERE OPTIONS LIVE!!!!\n', '  /**********************************/\n', '  \n', '  \n', '  mapping (address => uint256) public exercisedOptions;\n', '  \n', '  //get asset for tickets\n', '  event CollapseOption(\n', '    address indexed user,\n', '    address indexed holderTicketAddress,\n', '    address indexed writerTicketAddress,\n', '    uint256 ticketsCollapsed,\n', '    bytes32 optionPair //assetTokenAddress xor strikeTokenAddress\n', '  );    \n', '  \n', '  //get holderticket + asset for strike\n', '  event ExcerciseUnwind(\n', '    address indexed user,\n', '    address indexed holderTicketAddress,\n', '    uint256 ticketsUnwound,\n', '    bytes32 optionPair,\n', '    bool fillOrKill\n', '  );  \n', '  \n', '  //get asset for writerticket\n', '  event ExpireOption(\n', '    address indexed user,\n', '    address indexed writerTicketAddress,\n', '    uint256 ticketsExpired,\n', '    bytes32 optionPair\n', '  );  \n', '  \n', '  //get tickets for asset\n', '  event CreateOption(\n', '    address indexed user,\n', '    address indexed holderTicketAddress,\n', '    address indexed writerTicketAddress,\n', '    uint256 ticketsCreated,\n', '    bytes32 optionPair\n', '  );  \n', '  \n', '  //get assset for strike + holderticket\n', '  event ExcerciseOption(\n', '    address indexed user,\n', '    address indexed holderTicketAddress,\n', '    uint256 ticketsExcercised,\n', '    bytes32 optionPair //assetTokenAddress xor strikeTokenAddress\n', '  );  \n', '  \n', '  /******************\n', '  / optionFunctions\n', '  ******************/\n', '  \n', '  //if before expiry, deposit asset, get buy ticket, write ticket\n', '  // 1 ticket gets (10^18) option units credited to them.\n', '  function createOptionPair( //#65\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires,\n', '    uint256 _ticketAmount //tickets times (1 ether)\n', '  )\n', '    external\n', '    notLocked\n', '    returns (uint256 ticketsCreated)\n', '  {\n', '    //if before expiry\n', '    require (block.number < _optionExpires); //option would be expired\n', '    \n', '    //if they have the asset\n', '    //[checked by safemath during locking]\n', '\n', '    //lock asset to 0x0.\n', '    //the percent of one contract times _assetTokenAmount = amount moving\n', '    //creation fee?\n', '    balances[_assetTokenAddress][0x0] =\n', '      safeAdd(\n', '        balances[_assetTokenAddress][0x0],\n', '        safeDiv(safeMul(_assetTokenAmount, _ticketAmount), 1 ether)\n', '      );\n', '\n', '    balances[_assetTokenAddress][msg.sender] =\n', '      safeSub(\n', '        balances[_assetTokenAddress][msg.sender],\n', '        safeDiv(safeMul(_assetTokenAmount, _ticketAmount), 1 ether)\n', '      );\n', '    \n', '    \n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    address writerTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      true\n', '    );\n', '    \n', '    //issue write option\n', '    balances[writerTicketAddress][msg.sender] =\n', '      safeAdd(balances[writerTicketAddress][msg.sender], _ticketAmount);\n', '    globalBalance[writerTicketAddress] =\n', '      safeAdd(globalBalance[writerTicketAddress], _ticketAmount);\n', '\n', '    //issue hold option\n', '    balances[holderTicketAddress][msg.sender] =\n', '      safeAdd(balances[holderTicketAddress][msg.sender], _ticketAmount);\n', '    globalBalance[holderTicketAddress] =\n', '      safeAdd(globalBalance[holderTicketAddress], _ticketAmount);\n', '\n', '    CreateOption(\n', '      msg.sender,\n', '      holderTicketAddress,\n', '      writerTicketAddress,\n', '      _ticketAmount,\n', '      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress))\n', '    );\n', '    \n', '    //check if we need to register, and do if we do.\n', '    if (\n', '      OptionRegistry(optionsRegistryAddress).isOptionPairRegistered(\n', '        _assetTokenAddress,\n', '        _assetTokenAmount,\n', '        _strikeTokenAddress,\n', '        _strikeTokenAmount,\n', '        _optionExpires\n', '      )\n', '      == false\n', '    )\n', '    {\n', '      require(\n', '        OptionRegistry(optionsRegistryAddress).registerOptionPair(\n', '          _assetTokenAddress,\n', '          _assetTokenAmount,\n', '          _strikeTokenAddress,\n', '          _strikeTokenAmount,\n', '          _optionExpires\n', '        )\n', '      );\n', '    }\n', '    return _ticketAmount;\n', '  }\n', '  \n', '  //if own buy & writer ticket get asset, void tickets\n', '  // 1 ticket gets 10^18 option units voided.\n', '  function collapseOptionPair( //#66\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires,\n', '    uint256 _ticketAmount\n', '  )\n', '    external\n', '    returns (uint256 ticketsCollapsed)\n', '  {\n', '    \n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    address writerTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      true\n', '    );\n', '    \n', '    //if they have the write option\n', '    //if they have the hold option\n', '    require (\n', '      (balances[holderTicketAddress][msg.sender] >= _ticketAmount)\n', '      && (balances[writerTicketAddress][msg.sender] >= _ticketAmount)\n', '    );\n', '    //I guess it can be expired, since you have both legs.\n', '    \n', '    //void write option\n', '    balances[writerTicketAddress][msg.sender] =\n', '      safeSub(balances[writerTicketAddress][msg.sender], _ticketAmount);\n', '    globalBalance[writerTicketAddress] =\n', '      safeSub(globalBalance[writerTicketAddress], _ticketAmount);\n', '\n', '    //void hold option\n', '    balances[holderTicketAddress][msg.sender] =\n', '      safeSub(balances[holderTicketAddress][msg.sender], _ticketAmount);\n', '    globalBalance[holderTicketAddress] =\n', '      safeSub(globalBalance[holderTicketAddress], _ticketAmount);\n', ' \n', '    //unlock asset\n', '    balances[_assetTokenAddress][0x0] = safeSub(\n', '      balances[_assetTokenAddress][0x0],\n', '      safeDiv(safeMul(_assetTokenAmount, _ticketAmount), 1 ether)\n', '    );\n', '\n', '    balances[_assetTokenAddress][msg.sender] = safeAdd(\n', '      balances[_assetTokenAddress][msg.sender],\n', '      safeDiv(safeMul(_assetTokenAmount, _ticketAmount), 1 ether)\n', '    );\n', '    \n', '    //emit event\n', '    CollapseOption(\n', '      msg.sender,\n', '      holderTicketAddress,\n', '      writerTicketAddress,\n', '      _ticketAmount,\n', '      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress))\n', '    );\n', '    \n', '    return _ticketAmount;\n', '  }\n', '\n', '  /*about invisableHandOfAdamSmith():\n', '    q: why would someone ever want to buy an out-of-the-money,\n', '       collaterized call option at strike price?\n', '\n', "    a: if an american option is executed, and the collateral's movement\n", '       makes it later out of the money, the value of the option would\n', '       need to be calculated by including the "pre-executed" amount.\n', '       * \n', '       This would prevent an external actor performing weird arb trades\n', '       (write a billion tickets, collapse a billion tickets, profit!).\n', '       Skip the middle man! Writers are more likely to get 100% token or\n', '       strike at expiry, based on market value, and holders still have\n', '       their option intact.\n', '       * \n', '       Arbers gonna arb. Let them do their thing.\n', '*/\n', '\n', '  //if there have been executions, Adam Smith can deposit asset, get strike, up to execution amount.\n', '//  function invisibleHandOfAdamSmith( //#67\n', '\n', '  function optionExcerciseUnwind(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires,\n', '    uint256 _ticketAmount,\n', '    bool _fillOrKill //do we want? probably...\n', '  )\n', '    external\n', '    notLocked\n', '    returns (uint256 ticketsUnwound) //(amountTraded)\n', '  {\n', '    //only before, equal to expiry\n', '    require(block.number <= _optionExpires);\n', '    \n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    //if strike-pool[hash] != 0 {\n', '    ticketsUnwound = exercisedOptions[holderTicketAddress];\n', '\n', '    //fill or kill.\n', '    require((_fillOrKill == false) || (ticketsUnwound >= _ticketAmount));\n', '\n', '    //get amount to trade.\n', '    if (ticketsUnwound > _ticketAmount) ticketsUnwound = _ticketAmount;\n', '    \n', '    require(ticketsUnwound > 0);\n', '    //cant buy zero, either because not avail, or you asked for zero.\n', ' \n', '    //check compliance, like a trade!\n', '    require(\n', '      (! restrictedTokens[holderTicketAddress]) //if it is not restricted\n', '    || Compliance(complianceAddress).canTrade(holderTicketAddress, msg.sender) // or compliance says yes.\n', '    );\n', '\n', '    //debit balance of caller of asset tokens, credit 0x0\n', '    balances[_assetTokenAddress][msg.sender] = safeSub(\n', '      balances[_assetTokenAddress][msg.sender],\n', '      safeDiv(safeMul(_assetTokenAmount, ticketsUnwound), 1 ether)\n', '    );\n', '\n', '    balances[_assetTokenAddress][0x0] = safeAdd(\n', '      balances[_assetTokenAddress][0x0],\n', '      safeDiv(safeMul(_assetTokenAmount, ticketsUnwound), 1 ether)\n', '    );\n', '    \n', '    //debit balance of exercisedOptions of holdOption, credit caller.\n', '    //no change in global balances.\n', '    exercisedOptions[holderTicketAddress] =\n', '      safeSub(exercisedOptions[holderTicketAddress], ticketsUnwound);\n', '    balances[holderTicketAddress][msg.sender] =\n', '      safeAdd(balances[holderTicketAddress][msg.sender], ticketsUnwound);\n', '\n', '    //debit balance of 0x0 of strike, credit caller.\n', '    balances[_strikeTokenAddress][0x0] = safeSub(\n', '      balances[_strikeTokenAddress][0x0],\n', '      safeDiv(safeMul(_strikeTokenAmount, ticketsUnwound), 1 ether)\n', '    );\n', '\n', '    balances[_strikeTokenAddress][msg.sender] = safeAdd(\n', '      balances[_strikeTokenAddress][msg.sender],\n', '      safeDiv(safeMul(_strikeTokenAmount, ticketsUnwound), 1 ether)\n', '    );\n', '    \n', '    //emit event.\n', '    ExcerciseUnwind(\n', '      msg.sender,\n', '      holderTicketAddress,\n', '      ticketsUnwound,\n', '      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress)),\n', '      _fillOrKill\n', '    );\n', '    \n', '    return ticketsUnwound;\n', '  }\n', '  \n', '  //if before expiry, and own hold ticket, then pay strike, get asset, void hold ticket\n', '  function excerciseOption( //#68\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires,\n', '    uint256 _ticketAmount\n', '  )\n', '  external \n', '  returns (uint256 ticketsExcercised)\n', '  {  \n', '    //only holder before, equal to expiry\n', '    require(block.number <= _optionExpires);\n', '    \n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    //get balance of tickets\n', '    ticketsExcercised = balances[holderTicketAddress][msg.sender];\n', '    require(ticketsExcercised >= _ticketAmount); //its just a balance here.\n', '    \n', '    //get amount to trade.\n', '    if (ticketsExcercised > _ticketAmount) ticketsExcercised = _ticketAmount;\n', '    \n', '    //cant execute zero, either you have zero, or you asked for zero.\n', '    require(ticketsExcercised > 0);\n', '    \n', '    //debit balance of caller for holdOption, credit exercisedOptions    \n', '    balances[holderTicketAddress][msg.sender] =\n', '      safeSub(balances[holderTicketAddress][msg.sender], ticketsExcercised);\n', '    exercisedOptions[holderTicketAddress] =\n', '      safeAdd(exercisedOptions[holderTicketAddress], ticketsExcercised);\n', '        \n', '    //debit balance of caller for strikeToken, credit 0x0\n', '    balances[_strikeTokenAddress][msg.sender] = safeSub(\n', '      balances[_strikeTokenAddress][msg.sender],\n', '      safeDiv(safeMul(_strikeTokenAmount, ticketsExcercised), 1 ether)\n', '    );\n', '\n', '    balances[_strikeTokenAddress][0x0] = safeAdd(\n', '      balances[_strikeTokenAddress][0x0],\n', '      safeDiv(safeMul(_strikeTokenAmount, ticketsExcercised), 1 ether)\n', '    );\n', '    \n', '    //debit balance of 0x0 of asset, credit caller.   \n', '    balances[_assetTokenAddress][0x0] = safeSub(\n', '      balances[_assetTokenAddress][0x0],\n', '      safeDiv(safeMul(_assetTokenAmount, ticketsExcercised), 1 ether)\n', '    );\n', '    \n', '    balances[_assetTokenAddress][msg.sender] = safeAdd(\n', '      balances[_assetTokenAddress][msg.sender],\n', '      safeDiv(safeMul(_assetTokenAmount, ticketsExcercised), 1 ether)\n', '    );\n', '\n', '    \n', '    //no change in global balances.\n', '    //emit event.\n', '    ExcerciseOption(\n', '      msg.sender,\n', '      holderTicketAddress,\n', '      ticketsExcercised,\n', '      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress))\n', '    );\n', '    \n', '    return ticketsExcercised;\n', '  }\n', '\n', '  \n', '  //if after expiry, get collateral, void option.\n', '  function expireOption( //#69\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires,\n', '    uint256 _ticketAmount\n', '  )\n', '  external \n', '  returns (uint256 ticketsExpired)\n', '  {\n', '  //only writer, only after expiry\n', '    require(block.number > _optionExpires);\n', '        \n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    address writerTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      true\n', '    );\n', '    \n', '    //get balance of tickets\n', '    ticketsExpired = balances[writerTicketAddress][msg.sender];\n', '    require(ticketsExpired >= _ticketAmount); //its just a balance here.\n', '    \n', '    //get amount to trade.\n', '    if (ticketsExpired > _ticketAmount) ticketsExpired = _ticketAmount;\n', '    \n', '    //cant execute zero, either you have zero, or you asked for zero.\n', '    require(ticketsExpired > 0);\n', '    \n', '    // debit holder tickets from user, add to exercisedOptions.\n', '    balances[writerTicketAddress][msg.sender] =\n', '      safeSub(balances[writerTicketAddress][msg.sender], ticketsExpired);\n', '    exercisedOptions[writerTicketAddress] =\n', '      safeAdd(exercisedOptions[writerTicketAddress], ticketsExpired);\n', '    \n', '    //calculate amounts\n', '    uint256 strikeTokenAmount =\n', '      safeDiv(\n', '        safeMul(\n', '          safeDiv(safeMul(ticketsExpired, _strikeTokenAmount), 1 ether), //tickets\n', '          exercisedOptions[holderTicketAddress]\n', '        ),\n', '        globalBalance[holderTicketAddress]\n', '      );\n', '\n', '    uint256 assetTokenAmount =\n', '      safeDiv(\n', '        safeMul(\n', '          safeDiv(safeMul(ticketsExpired, _assetTokenAmount), 1 ether), //tickets\n', '          safeSub(globalBalance[holderTicketAddress], exercisedOptions[holderTicketAddress])\n', '        ),\n', '        globalBalance[holderTicketAddress]\n', '      );\n', '    \n', '\n', '    //debit zero, add to msg.sender\n', '    balances[_strikeTokenAddress][0x0] =\n', '      safeSub(balances[_strikeTokenAddress][0x0], strikeTokenAmount);\n', '    balances[_assetTokenAddress][0x0] =\n', '      safeSub(balances[_assetTokenAddress][0x0], assetTokenAmount);\n', '    balances[_strikeTokenAddress][msg.sender] =\n', '      safeAdd(balances[_strikeTokenAddress][msg.sender], strikeTokenAmount);\n', '    balances[_assetTokenAddress][msg.sender] =\n', '      safeAdd(balances[_assetTokenAddress][msg.sender], assetTokenAmount);\n', '  \n', '  //set inactive\n', '\n', '    ExpireOption( //#69]\n', '      msg.sender,\n', '      writerTicketAddress,\n', '      ticketsExpired,\n', '      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress))\n', '    );\n', '    return ticketsExpired;\n', '  }\n', '\n', '\n', "  //get an option's Hash's address\n", '  //  (•_•)  ( •_•)>⌐■-■  (⌐■_■)\n', '  //\n', '  //going from 32 bytes to 20 bytes still gives us 160 bits of hash goodness.\n', "  //that's still a crazy large number, and used by ethereum for addresses.\n", '  function getOptionAddress(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires,\n', '    bool _isWriter\n', '  )\n', '    public\n', '    view\n', '    returns(address)\n', '  {\n', '    return(\n', '      address(\n', '        keccak256(\n', '          _assetTokenAddress,\n', '          _assetTokenAmount,\n', '          _strikeTokenAddress,\n', '          _strikeTokenAmount,\n', '          _optionExpires,\n', '          _isWriter\n', '        )\n', '      )\n', '    );\n', '  }\n', '\n', '  /***********************************\n', '  / Options View Code\n', '  ************************************/\n', '  //since the options code might move, we should have a way to always\n', '  //call a function to this contract to get the current values\n', '  \n', '  function testIsOptionPairRegistered(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  )\n', '  external\n', '  view\n', '  returns(bool)\n', '  {\n', '    return(\n', '      OptionRegistry(optionsRegistryAddress).isOptionPairRegistered(\n', '        _assetTokenAddress,\n', '        _assetTokenAmount,\n', '        _strikeTokenAddress,\n', '        _strikeTokenAmount,\n', '        _optionExpires\n', '      )\n', '    );\n', '  }\n', '  \n', '\n', '  /***********************************\n', '  / Default Options Registration Code\n', '  ************************************/\n', '  // Register emits an event and adds it to restrictedToken.\n', "  // We'll deal with any other needed registration later.\n", '  // Set up for upgradeable external contract.\n', '  // return bools.\n', '  \n', '  event RegisterOptionsPair(\n', '    bytes32 indexed optionPair, //assetTokenAddress xor strikeTokenAddress\n', '    address indexed writerTicketAddress,\n', '    address indexed holderTicketAddress,\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  );  \n', '  \n', '    \n', '  function registerOptionPair(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  )\n', '  public\n', '  returns(bool)\n', '  {\n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '//    if (\n', '//      isOptionPairRegistered(\n', '//        _assetTokenAddress,\n', '//        _assetTokenAmount,\n', '//        _strikeTokenAddress,\n', '//        _strikeTokenAmount,\n', '//        _optionExpires\n', '//      )\n', '//    )\n', '    //cheaper not to make call gaswise, same result.\n', '    \n', '    if (restrictedTokens[holderTicketAddress]) {\n', '      return false;\n', '    //return halts execution, but else is better for readibility\n', '    } else {\n', '\n', '      address writerTicketAddress = getOptionAddress(\n', '        _assetTokenAddress,\n', '        _assetTokenAmount,\n', '        _strikeTokenAddress,\n', '        _strikeTokenAmount,\n', '        _optionExpires,\n', '        true\n', '      );\n', '    \n', '      restrictedTokens[holderTicketAddress] = true;\n', '      restrictedTokens[writerTicketAddress] = true;\n', '    \n', '      //an external contract would need to call something like this:\n', '      // after being registered as a helper contract on the main site.\n', '      //UberDelta(uberdeltaAddress).tokenRestriction(holderTicketAddress, true);\n', '      //UberDelta(uberdeltaAddress).tokenRestriction(writerTicketAddress, true);\n', '    \n', '      RegisterOptionsPair(\n', '        (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress)),\n', '        holderTicketAddress,\n', '        writerTicketAddress,\n', '        _assetTokenAddress,\n', '        _assetTokenAmount,\n', '        _strikeTokenAddress,\n', '        _strikeTokenAmount,\n', '        _optionExpires\n', '      );\n', '    \n', '      return(true);\n', '    }\n', '  }\n', '  \n', '  \n', "  // for v1, we'll simply return if there's a restriction.\n", '  function isOptionPairRegistered(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  )\n', '  public\n', '  view\n', '  returns(bool)\n', '  {\n', '    address holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    return(restrictedTokens[holderTicketAddress]);\n', '  }\n', '  \n', '  \n', '  function getOptionPair(\n', '    address _assetTokenAddress,\n', '    uint256 _assetTokenAmount,\n', '    address _strikeTokenAddress,\n', '    uint256 _strikeTokenAmount,\n', '    uint256 _optionExpires\n', '  )\n', '  public\n', '  view\n', '  returns(address holderTicketAddress, address writerTicketAddress)\n', '  {\n', '    holderTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      false\n', '    );\n', '    \n', '    writerTicketAddress = getOptionAddress(\n', '      _assetTokenAddress,\n', '      _assetTokenAmount,\n', '      _strikeTokenAddress,\n', '      _strikeTokenAmount,\n', '      _optionExpires,\n', '      true\n', '    );\n', '    \n', '    return(holderTicketAddress, writerTicketAddress);\n', '  }\n', '  \n', '  \n', '  /******************\n', '  / EOS Registration\n', '  ******************/\n', '  // some users will accidentally keep EOS on the exchange during the snapshot.\n', '  function EOSRegistration (string _key) external onlyOwner{\n', '    EOS(0xd0a6E6C54DbC68Db5db3A091B171A77407Ff7ccf).register(_key);\n', '  }\n', '  \n', '}']
