['pragma solidity ^0.4.21;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '// END OF library SafeMath\n', '\n', 'contract Roles {\n', '    // Master Key access, always ONE and ONE ONLY \n', '    address public superAdmin ;\n', '\n', '    address public canary ; \n', '\n', '\n', '    // initiators and validators can be many\n', '    mapping (address => bool) public initiators ; \n', '    mapping (address => bool) public validators ;  \n', '    address[] validatorsAcct ; \n', '\n', '    // keep track of the current qty. of initiators around \n', '    uint public qtyInitiators ; \n', '\n', '    // hard-code the max amount of validators/voters in the system \n', '    // this is required to initialize the storage for each new proposal \n', '    uint constant public maxValidators = 20 ; \n', '\n', '    // keep track of the current qty. of active validators around \n', '    uint public qtyValidators ; \n', '\n', '    event superAdminOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event initiatorAdded(address indexed newInitiator);\n', '    event validatorAdded(address indexed newValidator);\n', '    event initiatorRemoved(address indexed removedInitiator);\n', '    event validatorRemoved(address indexed addedValidator);\n', '    event canaryOwnershipTransferred(address indexed previousOwner, address indexed newOwner) ; \n', '\n', '\n', '    \n', '    constructor() public \n', '    { \n', '      superAdmin = msg.sender ;\n', '      \n', '    }\n', '\n', '    modifier onlySuperAdmin {\n', '        require( msg.sender == superAdmin );\n', '        _;\n', '    }\n', '\n', '    modifier onlyCanary {\n', '        require( msg.sender == canary );\n', '        _;\n', '    }\n', '\n', '    modifier onlyInitiators {\n', '        require( initiators[msg.sender] );\n', '        _;\n', '    }\n', '    \n', '    modifier onlyValidators {\n', '        require( validators[msg.sender] );\n', '        _;\n', '    }\n', '    \n', '\n', 'function transferSuperAdminOwnership(address newOwner) public onlySuperAdmin \n', '{\n', '  require(newOwner != address(0)) ;\n', '  superAdmin = newOwner ;\n', '  emit superAdminOwnershipTransferred(superAdmin, newOwner) ;  \n', '}\n', '\n', 'function transferCanaryOwnership(address newOwner) public onlySuperAdmin \n', '{\n', '  require(newOwner != address(0)) ;\n', '  canary = newOwner ;\n', '  emit canaryOwnershipTransferred(canary, newOwner) ;  \n', '}\n', '\n', '\n', 'function addValidator(address _validatorAddr) public onlySuperAdmin \n', '{\n', '  require(_validatorAddr != address(0));\n', '  require(!validators[_validatorAddr]) ; \n', '  validators[_validatorAddr] = true ; \n', '  validatorsAcct.push(_validatorAddr) ; \n', '  qtyValidators++ ; \n', '  emit validatorAdded(_validatorAddr) ;  \n', '}\n', '\n', 'function revokeValidator(address _validatorAddr) public onlySuperAdmin\n', '{\n', '  require(_validatorAddr != address(0));\n', '  require(validators[_validatorAddr]) ; \n', '  validators[_validatorAddr] = false ; \n', '  \n', '  for(uint i = 0 ; i < qtyValidators ; i++ ) \n', '    {\n', '      if (validatorsAcct[i] == _validatorAddr)\n', '         validatorsAcct[i] = address(0) ; \n', '    }\n', '  qtyValidators-- ; \n', '  emit validatorRemoved(_validatorAddr) ;  \n', '}\n', '\n', 'function addInitiator(address _initiatorAddr) public onlySuperAdmin\n', '{\n', '  require(_initiatorAddr != address(0));\n', '  require(!initiators[_initiatorAddr]) ;\n', '  initiators[_initiatorAddr] = true ; \n', '  qtyInitiators++ ; \n', '  emit initiatorAdded(_initiatorAddr) ; \n', '}\n', '\n', 'function revokeInitiator(address _initiatorAddr) public onlySuperAdmin\n', '{\n', '  require(_initiatorAddr != address(0));\n', '  require(initiators[_initiatorAddr]) ; \n', '  initiators[_initiatorAddr] = false ;\n', '  qtyInitiators-- ; \n', '  emit initiatorRemoved(_initiatorAddr) ; \n', '}\n', '  \n', '\n', '} // END OF Roles contract \n', '\n', '\n', 'contract Storage {\n', '\n', '  // We store here the whole storage implementation, decoupling the logic \n', '  // which will be defined in FKXIdentitiesV1, FKXIdentitiesV2..., FKXIdentitiesV1n\n', '\n', 'uint scoringThreshold ; \n', '\n', 'struct Proposal \n', '  {\n', '    string ipfsAddress ; \n', '    uint timestamp ; \n', '    uint totalAffirmativeVotes ; \n', '    uint totalNegativeVotes ; \n', '    uint totalVoters ; \n', '    address[] votersAcct ; \n', '    mapping (address => uint) votes ; \n', '  }\n', '\n', '// storage to keep track of all the proposals \n', 'mapping (bytes32 => Proposal) public proposals ; \n', 'uint256 totalProposals ; \n', '\n', '// helper array to keep track of all rootHashes proposals\n', 'bytes32[] rootHashesProposals ; \n', '\n', '\n', '// storage records the final && immutable ipfsAddresses validated by majority consensus of validators\n', 'mapping (bytes32 => string) public ipfsAddresses ; \n', '\n', '// Helper vector to track all keys (rootHasshes) added to ipfsAddresses\n', 'bytes32[] ipfsAddressesAcct ;\n', '\n', '}\n', '\n', '\n', 'contract Registry is Storage, Roles {\n', '\n', '    address public logic_contract;\n', '\n', '    function setLogicContract(address _c) public onlySuperAdmin returns (bool success){\n', '        logic_contract = _c;\n', '        return true;\n', '    }\n', '\n', '    function () payable public {\n', '        address target = logic_contract;\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            calldatacopy(ptr, 0, calldatasize)\n', '            let result := delegatecall(gas, target, ptr, calldatasize, 0, 0)\n', '            let size := returndatasize\n', '            returndatacopy(ptr, 0, size)\n', '            switch result\n', '            case 0 { revert(ptr, size) }\n', '            case 1 { return(ptr, size) }\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract FKXIdentitiesV1 is Storage, Roles {\n', '\n', 'using SafeMath for uint256;\n', '\n', 'event newProposalLogged(address indexed initiator, bytes32 rootHash, string ipfsAddress ) ; \n', 'event newVoteLogged(address indexed voter, bool vote) ;\n', 'event newIpfsAddressAdded(bytes32 rootHash, string ipfsAddress ) ; \n', '\n', '\n', 'constructor() public \n', '{\n', '  qtyInitiators = 0 ; \n', '  qtyValidators = 0 ; \n', '  scoringThreshold = 10 ;\n', '}\n', '\n', '// Set the score parameter that once reached would eliminate/revoke\n', '// validators with scores greater than _scoreMax from the list of authorized validators\n', 'function setScoringThreshold(uint _scoreMax) public onlySuperAdmin\n', '{\n', '  scoringThreshold = _scoreMax ; \n', '}\n', '\n', '\n', '// An initiator writes a new proposal in the proposal storage area \n', '\n', 'function propose(bytes32 _rootHash, string _ipfsAddress) public onlyInitiators\n', '{\n', '  // proposal should not be present already, i.e timestamp has to be in an uninitialized state, i.e. zero \n', '  require(proposals[_rootHash].timestamp == 0 ) ;\n', '\n', '  // writes the proposal for the _ipfsAddress, timestamp it &#39;now&#39; and set the qty to zero (i.e. no votes yet)\n', '  address[] memory newVoterAcct = new address[](maxValidators) ; \n', '  Proposal memory newProposal = Proposal( _ipfsAddress , now, 0, 0, 0, newVoterAcct ) ; \n', '  proposals[_rootHash] = newProposal ; \n', '  emit newProposalLogged(msg.sender, _rootHash, _ipfsAddress ) ; \n', '  rootHashesProposals.push(_rootHash) ; \n', '  totalProposals++ ; \n', '}\n', '\n', '\n', '// obtain, for a given rootHash, the definitive immutable stored _ipfsAddress \n', 'function getIpfsAddress(bytes32 _rootHash) constant public returns (string _ipfsAddress)\n', '{\n', '  return ipfsAddresses[_rootHash] ; \n', '}\n', '\n', '// obtain, for a given rootHash, the proposed (not definitively voted yet) _ipfsAddress\n', 'function getProposedIpfs(bytes32 _rootHash) constant public returns (string _ipfsAddress)\n', '{\n', '  return proposals[_rootHash].ipfsAddress ; \n', '}\n', '\n', '// how many voters have voted for a given proposal? \n', 'function howManyVoters(bytes32 _rootHash) constant public returns (uint)\n', '{\n', '  return proposals[_rootHash].totalVoters ; \n', '}\n', '\n', '// Validator casts one vote to the proposed ipfsAddress stored in the _rootHash key in the proposals storage area \n', '// if _vote == true means voting affirmatively, else if _vote == false, means voting negatively\n', 'function vote(bytes32 _rootHash, bool _vote) public onlyValidators\n', '{\n', '  // if timestamp == 0 it means such proposal does not exist, i.e. was never timestamped hence \n', '  //  contains the &#39;zero&#39; uninitialized value\n', '  require(proposals[_rootHash].timestamp > 0) ;\n', '\n', '  // checks this validator have not already voted for this proposal\n', '  // 0 no voted yet\n', '  // 1 voted affirmatively\n', '  // 2 voted negatively \n', '\n', '  require(proposals[_rootHash].votes[msg.sender]==0) ; \n', '\n', '  // add this validator address to the array of voters. \n', '  proposals[_rootHash].votersAcct.push(msg.sender) ; \n', '\n', '  if (_vote ) \n', '    { \n', '      proposals[_rootHash].votes[msg.sender] = 1 ; // 1 means votes affirmatively\n', '      proposals[_rootHash].totalAffirmativeVotes++ ; \n', '    } \n', '       else \n', '        { proposals[_rootHash].votes[msg.sender] = 2 ; // 2 means votes negatively\n', '          proposals[_rootHash].totalNegativeVotes++ ; \n', '        } \n', '\n', '  emit newVoteLogged(msg.sender, _vote) ;\n', '  proposals[_rootHash].totalVoters++ ; \n', '\n', '  // check if a majority consensus was obtained and if so, it records the final result in the definitive \n', '  // immutable storage area: ipfsAddresses \n', '  if ( isConsensusObtained(proposals[_rootHash].totalAffirmativeVotes) )\n', '  {\n', '  // need to make sure the consensuated vote had not already been written to the storage area ipfsAddresses\n', '  // so we don&#39;t write duplicate info again, just to save some gas :) and also b/c it&#39;s the right thing to do \n', '  // to minimize entropy in the universe... hence, we need to check for an empty string\n', '    bytes memory tempEmptyString = bytes(ipfsAddresses[_rootHash]) ; \n', '    if ( tempEmptyString.length == 0 ) \n', '      { \n', '        ipfsAddresses[_rootHash] = proposals[_rootHash].ipfsAddress ;  \n', '        emit newIpfsAddressAdded(_rootHash, ipfsAddresses[_rootHash] ) ;\n', '        ipfsAddressesAcct.push(_rootHash) ; \n', '\n', '      } \n', '\n', '  }\n', '\n', '} \n', '\n', '\n', '// returns the total number of ipfsAddresses ever stored in the definitive immutable storage &#39;ipfsAddresses&#39;\n', 'function getTotalQtyIpfsAddresses() constant public returns (uint)\n', '{ \n', '  return ipfsAddressesAcct.length ; \n', '}\n', '\n', '// returns one rootHash which is stored at a specific _index position\n', 'function getOneByOneRootHash(uint _index) constant public returns (bytes32 _rootHash )\n', '{\n', '  require( _index <= (getTotalQtyIpfsAddresses()-1) ) ; \n', '  return ipfsAddressesAcct[_index] ; \n', '}\n', '\n', '// consensus obtained it is true if and only if n+1 validators voted affirmatively for a proposal \n', '// where n == the total qty. of validators (qtyValidators)\n', 'function isConsensusObtained(uint _totalAffirmativeVotes) constant public returns (bool)\n', '{\n', ' // multiplying by 10000 (10 thousand) for decimal precision management\n', ' // note: This scales up to 9999 validators only\n', '\n', ' require (qtyValidators > 0) ; // prevents division by zero \n', ' uint dTotalVotes = _totalAffirmativeVotes * 10000 ; \n', ' return (dTotalVotes / qtyValidators > 5000 ) ;\n', '\n', '}\n', '\n', '\n', '// Validators:\n', '// returns one proposal (the first one) greater than, STRICTLY GREATER THAN the given _timestampFrom \n', '// timestamp > _timestampFrom \n', 'function getProposals(uint _timestampFrom) constant public returns (bytes32 _rootHash)\n', '{\n', '   // returns the first rootHash corresponding to a timestamp greater than the parameter \n', '   uint max = rootHashesProposals.length ; \n', '\n', '   for(uint i = 0 ; i < max ; i++ ) \n', '    {\n', '      if (proposals[rootHashesProposals[i]].timestamp > _timestampFrom)\n', '         return rootHashesProposals[i] ; \n', '    }\n', '\n', '}\n', '\n', '// returns, for one proposal \n', '// identified by a rootHash, the timestamp UNIX epoch time associated with it\n', '\n', 'function getTimestampProposal(bytes32 _rootHash) constant public returns (uint _timeStamp) \n', '{\n', '  return proposals[_rootHash].timestamp ; \n', '}\n', '\n', '\n', '\n', '// returns the total quantity of active validators\n', '// only &#39;active&#39; ones quantity  \n', 'function getQtyValidators() constant public returns (uint)\n', '{\n', '  return qtyValidators ; \n', '}\n', '\n', '// It returns the address of an active validator in the specific &#39;_t&#39; vector position of active validators \n', '// vector positions start at zero and ends at &#39;getQtyValidators - 1&#39; so in order to get all vaidators \n', '// you have to iterate one by one from 0 to &#39; getQtyValidators -1 &#39;\n', 'function getValidatorAddress(int _t) constant public returns (address _validatorAddr)\n', '{\n', '   int x = -1 ; \n', '   uint size = validatorsAcct.length ; \n', '\n', '   for ( uint i = 0 ; i < size ; i++ )\n', '   {\n', '\n', '      if ( validators[validatorsAcct[i]] ) x++ ; \n', '      if ( x == _t ) return (validatorsAcct[i]) ;  \n', '   }\n', '}\n', ' \n', '// returns true if the rootHash was impacted, i.e. it&#39;s available and exists in the ipfsAddresses array\n', '// and false if otherwise\n', '\n', 'function getStatusForRootHash(bytes32 _rootHash) constant public returns (bool)\n', '{\n', ' bytes memory tempEmptyStringTest = bytes(ipfsAddresses[_rootHash]); // Uses memory\n', ' if (tempEmptyStringTest.length == 0) {\n', '    // emptyStringTest is an empty string, hence the _rootHash was not impacted there so does not exist\n', '    return false ; \n', '} else {\n', '    // emptyStringTest is not an empty string\n', '    return true ; \n', '}\n', '\n', '} \n', '\n', '} // END OF FKXIdentities contract \n', '\n', '\n', '// DEBUG info below IGNORE \n', '// rootHash examples below, always 32 bytes in the format:\n', '// 0x12207D5A99F603F231D53A4F39D1521F98D2E8BB279CF29BEBFD0687DC98458E\n', '// 0x12207D5A99F603F231D53A4F39D1521F98D2E8BB279CF29BEBFD0687DC98458F\n', '// ipfs address, string: "whatever here",\n', '\n', '// JUN-5 v1 contract deployed at https://rinkeby.etherscan.io/address/0xbe2ee825339c25749fb8ff8f6621d304fb2e2be5\n', '// JUN-5 v1 contract deployed at https://ropsten.etherscan.io/address/0xbe2ee825339c25749fb8ff8f6621d304fb2e2be5\n', '\n', '// SuperOwner account is: 0xFA8f851b63E3742Eb5909C0735017C75b999B043 (macbook chrome)\n', '\n', '\n', '// returns the vote status for a given proposal for a specific validator Address \n', '// 0 no voted yet / blank vote \n', '// 1 voted affirmatively\n', '// 2 voted negatively \n', '// function getVoterStatus(bytes32 _rootHash, address _validatorAddr) constant public returns (uint _voteStatus)\n', '// {\n', '\n', ' // proposals[_rootHash].votes[_validatorAddr] ; \n', '\n', '// }']