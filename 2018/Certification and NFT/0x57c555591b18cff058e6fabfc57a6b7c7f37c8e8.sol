['pragma solidity ^0.4.19;\n', '\n', '/// @title Voting with delegation.\n', 'contract Ballot {\n', '    // This declares a new complex type which will\n', '    // be used for variables later.\n', '    // It will represent a vote for one batch votes in blockchain.\n', '    struct Voter {\n', '        uint weight; // vote number of specified voter and voted proposal\n', "        bytes32 voterName; // voter's name\n", '        uint proposalId; // index of the voted proposal\n', '    }\n', '\n', '    // This is a type for a single proposal.\n', '    struct Proposal {\n', "        uint proposalId;// proposal's id, equals to proposals' index\n", "        bytes32 proposalName;   // proposal's description\n", '        uint voteCount; // number of accumulated votes\n', '    }\n', '\n', '    address public chairperson;\n', '\n', '    // A dynamically-sized array of `Proposal` structs.\n', '    Proposal[] public proposals;\n', '\n', '    event BatchVote(address indexed _from);\n', '\n', '    modifier onlyChairperson {\n', '      require(msg.sender == chairperson);\n', '      _;\n', '    }\n', '\n', '    function transferChairperson(address newChairperson) onlyChairperson  public {\n', '        chairperson = newChairperson;\n', '    }\n', '\n', '    /// Create a new ballot to choose one of `proposalNames`.\n', '    function Ballot(bytes32[] proposalNames) public {\n', '        chairperson = msg.sender;\n', '\n', '        // For each of the provided proposal names,\n', '        // create a new proposal object and add it\n', '        // to the end of the array.\n', '        for (uint i = 0; i < proposalNames.length; i++) {\n', '            // `Proposal({...})` creates a temporary\n', '            // Proposal object and `proposals.push(...)`\n', '            // appends it to the end of `proposals`.\n', '            proposals.push(Proposal({\n', '                proposalId: proposals.length,\n', '                proposalName: proposalNames[i],\n', '                voteCount: 0\n', '            }));\n', '        }\n', '    }\n', '\n', '    function addProposals(bytes32[] proposalNames) onlyChairperson public {\n', '        // For each of the provided proposal names,\n', '        // create a new proposal object and add it\n', '        // to the end of the array.\n', '        for (uint i = 0; i < proposalNames.length; i++) {\n', '            // `Proposal({...})` creates a temporary\n', '            // Proposal object and `proposals.push(...)`\n', '            // appends it to the end of `proposals`.\n', '            proposals.push(Proposal({\n', '                proposalId: proposals.length,\n', '                proposalName: proposalNames[i],\n', '                voteCount: 0\n', '            }));\n', '        }\n', '    }\n', '\n', '\n', '    /// batch vote (delegated to chairperson)\n', '    function vote(uint[] weights, bytes32[] voterNames, uint[] proposalIds) onlyChairperson public {\n', '\n', '        require(weights.length == voterNames.length);\n', '        require(weights.length == proposalIds.length);\n', '        require(voterNames.length == proposalIds.length);\n', '\n', '        for (uint i = 0; i < weights.length; i++) {\n', '            Voter memory voter = Voter({\n', '              weight: weights[i],\n', '              voterName: voterNames[i],\n', '              proposalId: proposalIds[i]\n', '            });\n', '            proposals[voter.proposalId-1].voteCount += voter.weight;\n', '        }\n', '\n', '        BatchVote(msg.sender);\n', '    }\n', '\n', '    /// @dev Computes the winning proposal taking all\n', '    /// previous votes into account.\n', '    function winningProposal() internal\n', '            returns (uint winningProposal)\n', '    {\n', '        uint winningVoteCount = 0;\n', '        for (uint p = 0; p < proposals.length; p++) {\n', '            if (proposals[p].voteCount > winningVoteCount) {\n', '                winningVoteCount = proposals[p].voteCount;\n', '                winningProposal = p;\n', '            }\n', '        }\n', '    }\n', '\n', '    // Calls winningProposal() function to get the index\n', '    // of the winner contained in the proposals array and then\n', '    // returns the name of the winner\n', '    function winnerName() public view\n', '            returns (bytes32 winnerName)\n', '    {\n', '        winnerName = proposals[winningProposal()].proposalName;\n', '    }\n', '\n', '    function resetBallot(bytes32[] proposalNames) onlyChairperson public {\n', '\n', '        delete proposals;\n', '\n', '        // For each of the provided proposal names,\n', '        // create a new proposal object and add it\n', '        // to the end of the array.\n', '        for (uint i = 0; i < proposalNames.length; i++) {\n', '            // `Proposal({...})` creates a temporary\n', '            // Proposal object and `proposals.push(...)`\n', '            // appends it to the end of `proposals`.\n', '            proposals.push(Proposal({\n', '                proposalId: proposals.length,\n', '                proposalName: proposalNames[i],\n', '                voteCount: 0\n', '            }));\n', '        }\n', '    }\n', '\n', '    function batchSearchProposalsId(bytes32[] proposalsName) public view\n', '          returns (uint[] proposalsId) {\n', '      proposalsId = new uint[](proposalsName.length);\n', '      for (uint i = 0; i < proposalsName.length; i++) {\n', '        uint proposalId = searchProposalId(proposalsName[i]);\n', '        proposalsId[i]=proposalId;\n', '      }\n', '    }\n', '\n', '    function searchProposalId(bytes32 proposalName) public view\n', '          returns (uint proposalId) {\n', '      for (uint i = 0; i < proposals.length; i++) {\n', '          if(proposals[i].proposalName == proposalName){\n', '            proposalId = proposals[i].proposalId;\n', '          }\n', '      }\n', '    }\n', '\n', '    // proposal rank by voteCount\n', '    function proposalsRank() public view\n', '          returns (uint[] rankByProposalId,\n', '          bytes32[] rankByName,\n', '          uint[] rankByvoteCount) {\n', '\n', '    uint n = proposals.length;\n', '    Proposal[] memory arr = new Proposal[](n);\n', '\n', '    uint i;\n', '    for(i=0; i<n; i++) {\n', '      arr[i] = proposals[i];\n', '    }\n', '\n', '    uint[] memory stack = new uint[](n+ 2);\n', '\n', '    //Push initial lower and higher bound\n', '    uint top = 1;\n', '    stack[top] = 0;\n', '    top = top + 1;\n', '    stack[top] = n-1;\n', '\n', '    //Keep popping from stack while is not empty\n', '    while (top > 0) {\n', '\n', '      uint h = stack[top];\n', '      top = top - 1;\n', '      uint l = stack[top];\n', '      top = top - 1;\n', '\n', '      i = l;\n', '      uint x = arr[h].voteCount;\n', '\n', '      for(uint j=l; j<h; j++){\n', '        if  (arr[j].voteCount <= x) {\n', '          //Move smaller element\n', '          (arr[i], arr[j]) = (arr[j],arr[i]);\n', '          i = i + 1;\n', '        }\n', '      }\n', '      (arr[i], arr[h]) = (arr[h],arr[i]);\n', '      uint p = i;\n', '\n', '      //Push left side to stack\n', '      if (p > l + 1) {\n', '        top = top + 1;\n', '        stack[top] = l;\n', '        top = top + 1;\n', '        stack[top] = p - 1;\n', '      }\n', '\n', '      //Push right side to stack\n', '      if (p+1 < h) {\n', '        top = top + 1;\n', '        stack[top] = p + 1;\n', '        top = top + 1;\n', '        stack[top] = h;\n', '      }\n', '    }\n', '\n', '    rankByProposalId = new uint[](n);\n', '    rankByName = new bytes32[](n);\n', '    rankByvoteCount = new uint[](n);\n', '    for(i=0; i<n; i++) {\n', '      rankByProposalId[i]= arr[n-1-i].proposalId;\n', '      rankByName[i]=arr[n-1-i].proposalName;\n', '      rankByvoteCount[i]=arr[n-1-i].voteCount;\n', '    }\n', '  }\n', '}']