['pragma solidity ^0.4.21;\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', '    // this function isn&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function owner() public view returns (address) {}\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'contract IERC20Token {\n', '    // these functions aren&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function name() public view returns (string) {}\n', '    function symbol() public view returns (string) {}\n', '    function decimals() public view returns (uint8) {}\n', '    function totalSupply() public view returns (uint256) {}\n', '    function balanceOf(address _owner) public view returns (uint256) { _owner; }\n', '    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '/*\n', '    Smart Token interface\n', '*/\n', 'contract ISmartToken is IOwned, IERC20Token {\n', '    function disableTransfers(bool _disable) public;\n', '    function issue(address _to, uint256 _amount) public;\n', '    function destroy(address _from, uint256 _amount) public;\n', '}\n', '\n', '/*\n', '    Contract Registry interface\n', '*/\n', 'contract IContractRegistry {\n', '    function getAddress(bytes32 _contractName) public view returns (address);\n', '}\n', '\n', '/*\n', '    Contract Features interface\n', '*/\n', 'contract IContractFeatures {\n', '    function isSupported(address _contract, uint256 _features) public view returns (bool);\n', '    function enableFeatures(uint256 _features, bool _enable) public;\n', '}\n', '\n', '/*\n', '    Whitelist interface\n', '*/\n', 'contract IWhitelist {\n', '    function isWhitelisted(address _address) public view returns (bool);\n', '}\n', '\n', '/*\n', '    Bancor Converter interface\n', '*/\n', 'contract IBancorConverter {\n', '    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256);\n', '    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\n', '    function conversionWhitelist() public view returns (IWhitelist) {}\n', '    // deprecated, backward compatibility\n', '    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\n', '}\n', '\n', '/*\n', '    Bancor Converter Factory interface\n', '*/\n', 'contract IBancorConverterFactory {\n', '    function createConverter(\n', '        ISmartToken _token,\n', '        IContractRegistry _registry,\n', '        uint32 _maxConversionFee,\n', '        IERC20Token _connectorToken,\n', '        uint32 _connectorWeight\n', '    )\n', '    public returns (address);\n', '}\n', '\n', '/*\n', '    Bancor converter dedicated interface\n', '*/\n', 'contract IBancorConverterExtended is IBancorConverter, IOwned {\n', '    function token() public view returns (ISmartToken) {}\n', '    function quickBuyPath(uint256 _index) public view returns (IERC20Token) { _index; }\n', '    function maxConversionFee() public view returns (uint32) {}\n', '    function conversionFee() public view returns (uint32) {}\n', '    function connectorTokenCount() public view returns (uint16);\n', '    function reserveTokenCount() public view returns (uint16);\n', '    function connectorTokens(uint256 _index) public view returns (IERC20Token) { _index; }\n', '    function reserveTokens(uint256 _index) public view returns (IERC20Token) { _index; }\n', '    function setConversionWhitelist(IWhitelist _whitelist) public view;\n', '    function getQuickBuyPathLength() public view returns (uint256);\n', '    function transferTokenOwnership(address _newOwner) public view;\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public view;\n', '    function acceptTokenOwnership() public view;\n', '    function transferManagement(address _newManager) public view;\n', '    function acceptManagement() public;\n', '    function setConversionFee(uint32 _conversionFee) public view;\n', '    function setQuickBuyPath(IERC20Token[] _path) public view;\n', '    function addConnector(IERC20Token _token, uint32 _weight, bool _enableVirtualBalance) public view;\n', '    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);\n', '    function getReserveBalance(IERC20Token _reserveToken) public view returns (uint256);\n', '    function connectors(address _address) public view returns (\n', '        uint256 virtualBalance, \n', '        uint32 weight, \n', '        bool isVirtualBalanceEnabled, \n', '        bool isPurchaseEnabled, \n', '        bool isSet\n', '    );\n', '    function reserves(address _address) public view returns (\n', '        uint256 virtualBalance, \n', '        uint32 weight, \n', '        bool isVirtualBalanceEnabled, \n', '        bool isPurchaseEnabled, \n', '        bool isSet\n', '    );\n', '}\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still needs to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '/**\n', '    Id definitions for bancor contracts\n', '\n', '    Can be used in conjunction with the contract registry to get contract addresses\n', '*/\n', 'contract ContractIds {\n', '    bytes32 public constant BANCOR_NETWORK = "BancorNetwork";\n', '    bytes32 public constant BANCOR_FORMULA = "BancorFormula";\n', '    bytes32 public constant CONTRACT_FEATURES = "ContractFeatures";\n', '}\n', '\n', '/**\n', '    Id definitions for bancor contract features\n', '\n', '    Can be used to query the ContractFeatures contract to check whether a certain feature is supported by a contract\n', '*/\n', 'contract FeatureIds {\n', '    // converter features\n', '    uint256 public constant CONVERTER_CONVERSION_WHITELIST = 1 << 0;\n', '}\n', '\n', '/*\n', '    Bancor Converter Upgrader\n', '\n', '    The Bancor converter upgrader contract allows upgrading an older Bancor converter\n', '    contract (0.4 and up) to the latest version.\n', '    To begin the upgrade process, first transfer the converter ownership to the upgrader\n', '    contract and then call the upgrade function.\n', '    At the end of the process, the ownership of the newly upgraded converter will be transferred\n', '    back to the original owner.\n', '    The address of the new converter is available in the ConverterUpgrade event.\n', '*/\n', 'contract BancorConverterUpgrader is Owned, ContractIds, FeatureIds {\n', '    string public version = &#39;0.2&#39;;\n', '\n', '    IContractRegistry public registry;                      // contract registry contract address\n', '    IBancorConverterFactory public bancorConverterFactory;  // bancor converter factory contract\n', '\n', '    // triggered when the contract accept a converter ownership\n', '    event ConverterOwned(address indexed _converter, address indexed _owner);\n', '    // triggered when the upgrading process is done\n', '    event ConverterUpgrade(address indexed _oldConverter, address indexed _newConverter);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function BancorConverterUpgrader(IBancorConverterFactory _bancorConverterFactory, IContractRegistry _registry) public {\n', '        bancorConverterFactory = _bancorConverterFactory;\n', '        registry = _registry;\n', '    }\n', '\n', '    /*\n', '        @dev allows the owner to update the factory contract address\n', '\n', '        @param _bancorConverterFactory    address of a bancor converter factory contract\n', '    */\n', '    function setBancorConverterFactory(IBancorConverterFactory _bancorConverterFactory) public ownerOnly {\n', '        bancorConverterFactory = _bancorConverterFactory;\n', '    }\n', '\n', '    /*\n', '        @dev allows the owner to update the contract registry contract address\n', '\n', '        @param _registry   address of a contract registry contract\n', '    */\n', '    function setContractRegistry(IContractRegistry _registry) public ownerOnly {\n', '        registry = _registry;\n', '    }\n', '\n', '    /**\n', '        @dev upgrade an old converter to the latest version\n', '        will throw if ownership wasn&#39;t transferred to the upgrader before calling this function.\n', '        ownership of the new converter will be transferred back to the original owner.\n', '        fires the ConverterUpgrade event upon success.\n', '\n', '        @param _oldConverter   old converter contract address\n', '        @param _version        old converter version\n', '    */\n', '    function upgrade(IBancorConverterExtended _oldConverter, bytes32 _version) public {\n', '        bool formerVersions = false;\n', '        if (_version == "0.4")\n', '            formerVersions = true;\n', '        acceptConverterOwnership(_oldConverter);\n', '        IBancorConverterExtended newConverter = createConverter(_oldConverter);\n', '        copyConnectors(_oldConverter, newConverter, formerVersions);\n', '        copyConversionFee(_oldConverter, newConverter);\n', '        copyQuickBuyPath(_oldConverter, newConverter);\n', '        transferConnectorsBalances(_oldConverter, newConverter, formerVersions);                \n', '        ISmartToken token = _oldConverter.token();\n', '\n', '        if (token.owner() == address(_oldConverter)) {\n', '            _oldConverter.transferTokenOwnership(newConverter);\n', '            newConverter.acceptTokenOwnership();\n', '        }\n', '\n', '        _oldConverter.transferOwnership(msg.sender);\n', '        newConverter.transferOwnership(msg.sender);\n', '        newConverter.transferManagement(msg.sender);\n', '\n', '        emit ConverterUpgrade(address(_oldConverter), address(newConverter));\n', '    }\n', '\n', '    /**\n', '        @dev the first step when upgrading a converter is to transfer the ownership to the local contract.\n', '        the upgrader contract then needs to accept the ownership transfer before initiating\n', '        the upgrade process.\n', '        fires the ConverterOwned event upon success\n', '\n', '        @param _oldConverter       converter to accept ownership of\n', '    */\n', '    function acceptConverterOwnership(IBancorConverterExtended _oldConverter) private {\n', '        require(msg.sender == _oldConverter.owner());\n', '        _oldConverter.acceptOwnership();\n', '        emit ConverterOwned(_oldConverter, this);\n', '    }\n', '\n', '    /**\n', '        @dev creates a new converter with same basic data as the original old converter\n', '        the newly created converter will have no connectors at this step.\n', '\n', '        @param _oldConverter    old converter contract address\n', '\n', '        @return the new converter  new converter contract address\n', '    */\n', '    function createConverter(IBancorConverterExtended _oldConverter) private returns(IBancorConverterExtended) {\n', '        IWhitelist whitelist;\n', '        ISmartToken token = _oldConverter.token();\n', '        uint32 maxConversionFee = _oldConverter.maxConversionFee();\n', '\n', '        address converterAdderess  = bancorConverterFactory.createConverter(\n', '            token,\n', '            registry,\n', '            maxConversionFee,\n', '            IERC20Token(address(0)),\n', '            0\n', '        );\n', '\n', '        IBancorConverterExtended converter = IBancorConverterExtended(converterAdderess);\n', '        converter.acceptOwnership();\n', '        converter.acceptManagement();\n', '\n', '        // get the contract features address from the registry\n', '        IContractFeatures features = IContractFeatures(registry.getAddress(ContractIds.CONTRACT_FEATURES));\n', '\n', '        if (features.isSupported(_oldConverter, FeatureIds.CONVERTER_CONVERSION_WHITELIST)) {\n', '            whitelist = _oldConverter.conversionWhitelist();\n', '            if (whitelist != address(0))\n', '                converter.setConversionWhitelist(whitelist);\n', '        }\n', '\n', '        return converter;\n', '    }\n', '\n', '    /**\n', '        @dev copies the connectors from the old converter to the new one.\n', '        note that this will not work for an unlimited number of connectors due to block gas limit constraints.\n', '\n', '        @param _oldConverter    old converter contract address\n', '        @param _newConverter    new converter contract address\n', '        @param _isLegacyVersion true if the converter version is under 0.5\n', '    */\n', '    function copyConnectors(IBancorConverterExtended _oldConverter, IBancorConverterExtended _newConverter, bool _isLegacyVersion)\n', '        private\n', '    {\n', '        uint256 virtualBalance;\n', '        uint32 weight;\n', '        bool isVirtualBalanceEnabled;\n', '        bool isPurchaseEnabled;\n', '        bool isSet;\n', '        uint16 connectorTokenCount = _isLegacyVersion ? _oldConverter.reserveTokenCount() : _oldConverter.connectorTokenCount();\n', '\n', '        for (uint16 i = 0; i < connectorTokenCount; i++) {\n', '            address connectorAddress = _isLegacyVersion ? _oldConverter.reserveTokens(i) : _oldConverter.connectorTokens(i);\n', '            (virtualBalance, weight, isVirtualBalanceEnabled, isPurchaseEnabled, isSet) = readConnector(\n', '                _oldConverter,\n', '                connectorAddress,\n', '                _isLegacyVersion\n', '            );\n', '\n', '            IERC20Token connectorToken = IERC20Token(connectorAddress);\n', '            _newConverter.addConnector(connectorToken, weight, isVirtualBalanceEnabled);\n', '        }\n', '    }\n', '\n', '    /**\n', '        @dev copies the conversion fee from the old converter to the new one\n', '\n', '        @param _oldConverter    old converter contract address\n', '        @param _newConverter    new converter contract address\n', '    */\n', '    function copyConversionFee(IBancorConverterExtended _oldConverter, IBancorConverterExtended _newConverter) private {\n', '        uint32 conversionFee = _oldConverter.conversionFee();\n', '        _newConverter.setConversionFee(conversionFee);\n', '    }\n', '\n', '    /**\n', '        @dev copies the quick buy path from the old converter to the new one\n', '\n', '        @param _oldConverter    old converter contract address\n', '        @param _newConverter    new converter contract address\n', '    */\n', '    function copyQuickBuyPath(IBancorConverterExtended _oldConverter, IBancorConverterExtended _newConverter) private {\n', '        uint256 quickBuyPathLength = _oldConverter.getQuickBuyPathLength();\n', '        if (quickBuyPathLength <= 0)\n', '            return;\n', '\n', '        IERC20Token[] memory path = new IERC20Token[](quickBuyPathLength);\n', '        for (uint256 i = 0; i < quickBuyPathLength; i++) {\n', '            path[i] = _oldConverter.quickBuyPath(i);\n', '        }\n', '\n', '        _newConverter.setQuickBuyPath(path);\n', '    }\n', '\n', '    /**\n', '        @dev transfers the balance of each connector in the old converter to the new one.\n', '        note that the function assumes that the new converter already has the exact same number of\n', '        also, this will not work for an unlimited number of connectors due to block gas limit constraints.\n', '\n', '        @param _oldConverter    old converter contract address\n', '        @param _newConverter    new converter contract address\n', '        @param _isLegacyVersion true if the converter version is under 0.5\n', '    */\n', '    function transferConnectorsBalances(IBancorConverterExtended _oldConverter, IBancorConverterExtended _newConverter, bool _isLegacyVersion)\n', '        private\n', '    {\n', '        uint256 connectorBalance;\n', '        uint16 connectorTokenCount = _isLegacyVersion ? _oldConverter.reserveTokenCount() : _oldConverter.connectorTokenCount();\n', '\n', '        for (uint16 i = 0; i < connectorTokenCount; i++) {\n', '            address connectorAddress = _isLegacyVersion ? _oldConverter.reserveTokens(i) : _oldConverter.connectorTokens(i);\n', '            IERC20Token connector = IERC20Token(connectorAddress);\n', '            connectorBalance = _isLegacyVersion ? _oldConverter.getReserveBalance(connector) : _oldConverter.getConnectorBalance(connector);\n', '            _oldConverter.withdrawTokens(connector, address(_newConverter), connectorBalance);\n', '        }\n', '    }\n', '\n', '    /**\n', '        @dev returns the connector settings\n', '\n', '        @param _converter       old converter contract address\n', '        @param _address         connector&#39;s address to read from\n', '        @param _isLegacyVersion true if the converter version is under 0.5\n', '\n', '        @return connector&#39;s settings\n', '    */\n', '    function readConnector(IBancorConverterExtended _converter, address _address, bool _isLegacyVersion) \n', '        private\n', '        view\n', '        returns(uint256 virtualBalance, uint32 weight, bool isVirtualBalanceEnabled, bool isPurchaseEnabled, bool isSet)\n', '    {\n', '        return _isLegacyVersion ? _converter.reserves(_address) : _converter.connectors(_address);\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', "    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n", '    function owner() public view returns (address) {}\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'contract IERC20Token {\n', "    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n", '    function name() public view returns (string) {}\n', '    function symbol() public view returns (string) {}\n', '    function decimals() public view returns (uint8) {}\n', '    function totalSupply() public view returns (uint256) {}\n', '    function balanceOf(address _owner) public view returns (uint256) { _owner; }\n', '    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '/*\n', '    Smart Token interface\n', '*/\n', 'contract ISmartToken is IOwned, IERC20Token {\n', '    function disableTransfers(bool _disable) public;\n', '    function issue(address _to, uint256 _amount) public;\n', '    function destroy(address _from, uint256 _amount) public;\n', '}\n', '\n', '/*\n', '    Contract Registry interface\n', '*/\n', 'contract IContractRegistry {\n', '    function getAddress(bytes32 _contractName) public view returns (address);\n', '}\n', '\n', '/*\n', '    Contract Features interface\n', '*/\n', 'contract IContractFeatures {\n', '    function isSupported(address _contract, uint256 _features) public view returns (bool);\n', '    function enableFeatures(uint256 _features, bool _enable) public;\n', '}\n', '\n', '/*\n', '    Whitelist interface\n', '*/\n', 'contract IWhitelist {\n', '    function isWhitelisted(address _address) public view returns (bool);\n', '}\n', '\n', '/*\n', '    Bancor Converter interface\n', '*/\n', 'contract IBancorConverter {\n', '    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256);\n', '    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\n', '    function conversionWhitelist() public view returns (IWhitelist) {}\n', '    // deprecated, backward compatibility\n', '    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\n', '}\n', '\n', '/*\n', '    Bancor Converter Factory interface\n', '*/\n', 'contract IBancorConverterFactory {\n', '    function createConverter(\n', '        ISmartToken _token,\n', '        IContractRegistry _registry,\n', '        uint32 _maxConversionFee,\n', '        IERC20Token _connectorToken,\n', '        uint32 _connectorWeight\n', '    )\n', '    public returns (address);\n', '}\n', '\n', '/*\n', '    Bancor converter dedicated interface\n', '*/\n', 'contract IBancorConverterExtended is IBancorConverter, IOwned {\n', '    function token() public view returns (ISmartToken) {}\n', '    function quickBuyPath(uint256 _index) public view returns (IERC20Token) { _index; }\n', '    function maxConversionFee() public view returns (uint32) {}\n', '    function conversionFee() public view returns (uint32) {}\n', '    function connectorTokenCount() public view returns (uint16);\n', '    function reserveTokenCount() public view returns (uint16);\n', '    function connectorTokens(uint256 _index) public view returns (IERC20Token) { _index; }\n', '    function reserveTokens(uint256 _index) public view returns (IERC20Token) { _index; }\n', '    function setConversionWhitelist(IWhitelist _whitelist) public view;\n', '    function getQuickBuyPathLength() public view returns (uint256);\n', '    function transferTokenOwnership(address _newOwner) public view;\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public view;\n', '    function acceptTokenOwnership() public view;\n', '    function transferManagement(address _newManager) public view;\n', '    function acceptManagement() public;\n', '    function setConversionFee(uint32 _conversionFee) public view;\n', '    function setQuickBuyPath(IERC20Token[] _path) public view;\n', '    function addConnector(IERC20Token _token, uint32 _weight, bool _enableVirtualBalance) public view;\n', '    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);\n', '    function getReserveBalance(IERC20Token _reserveToken) public view returns (uint256);\n', '    function connectors(address _address) public view returns (\n', '        uint256 virtualBalance, \n', '        uint32 weight, \n', '        bool isVirtualBalanceEnabled, \n', '        bool isPurchaseEnabled, \n', '        bool isSet\n', '    );\n', '    function reserves(address _address) public view returns (\n', '        uint256 virtualBalance, \n', '        uint32 weight, \n', '        bool isVirtualBalanceEnabled, \n', '        bool isPurchaseEnabled, \n', '        bool isSet\n', '    );\n', '}\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still needs to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '/**\n', '    Id definitions for bancor contracts\n', '\n', '    Can be used in conjunction with the contract registry to get contract addresses\n', '*/\n', 'contract ContractIds {\n', '    bytes32 public constant BANCOR_NETWORK = "BancorNetwork";\n', '    bytes32 public constant BANCOR_FORMULA = "BancorFormula";\n', '    bytes32 public constant CONTRACT_FEATURES = "ContractFeatures";\n', '}\n', '\n', '/**\n', '    Id definitions for bancor contract features\n', '\n', '    Can be used to query the ContractFeatures contract to check whether a certain feature is supported by a contract\n', '*/\n', 'contract FeatureIds {\n', '    // converter features\n', '    uint256 public constant CONVERTER_CONVERSION_WHITELIST = 1 << 0;\n', '}\n', '\n', '/*\n', '    Bancor Converter Upgrader\n', '\n', '    The Bancor converter upgrader contract allows upgrading an older Bancor converter\n', '    contract (0.4 and up) to the latest version.\n', '    To begin the upgrade process, first transfer the converter ownership to the upgrader\n', '    contract and then call the upgrade function.\n', '    At the end of the process, the ownership of the newly upgraded converter will be transferred\n', '    back to the original owner.\n', '    The address of the new converter is available in the ConverterUpgrade event.\n', '*/\n', 'contract BancorConverterUpgrader is Owned, ContractIds, FeatureIds {\n', "    string public version = '0.2';\n", '\n', '    IContractRegistry public registry;                      // contract registry contract address\n', '    IBancorConverterFactory public bancorConverterFactory;  // bancor converter factory contract\n', '\n', '    // triggered when the contract accept a converter ownership\n', '    event ConverterOwned(address indexed _converter, address indexed _owner);\n', '    // triggered when the upgrading process is done\n', '    event ConverterUpgrade(address indexed _oldConverter, address indexed _newConverter);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function BancorConverterUpgrader(IBancorConverterFactory _bancorConverterFactory, IContractRegistry _registry) public {\n', '        bancorConverterFactory = _bancorConverterFactory;\n', '        registry = _registry;\n', '    }\n', '\n', '    /*\n', '        @dev allows the owner to update the factory contract address\n', '\n', '        @param _bancorConverterFactory    address of a bancor converter factory contract\n', '    */\n', '    function setBancorConverterFactory(IBancorConverterFactory _bancorConverterFactory) public ownerOnly {\n', '        bancorConverterFactory = _bancorConverterFactory;\n', '    }\n', '\n', '    /*\n', '        @dev allows the owner to update the contract registry contract address\n', '\n', '        @param _registry   address of a contract registry contract\n', '    */\n', '    function setContractRegistry(IContractRegistry _registry) public ownerOnly {\n', '        registry = _registry;\n', '    }\n', '\n', '    /**\n', '        @dev upgrade an old converter to the latest version\n', "        will throw if ownership wasn't transferred to the upgrader before calling this function.\n", '        ownership of the new converter will be transferred back to the original owner.\n', '        fires the ConverterUpgrade event upon success.\n', '\n', '        @param _oldConverter   old converter contract address\n', '        @param _version        old converter version\n', '    */\n', '    function upgrade(IBancorConverterExtended _oldConverter, bytes32 _version) public {\n', '        bool formerVersions = false;\n', '        if (_version == "0.4")\n', '            formerVersions = true;\n', '        acceptConverterOwnership(_oldConverter);\n', '        IBancorConverterExtended newConverter = createConverter(_oldConverter);\n', '        copyConnectors(_oldConverter, newConverter, formerVersions);\n', '        copyConversionFee(_oldConverter, newConverter);\n', '        copyQuickBuyPath(_oldConverter, newConverter);\n', '        transferConnectorsBalances(_oldConverter, newConverter, formerVersions);                \n', '        ISmartToken token = _oldConverter.token();\n', '\n', '        if (token.owner() == address(_oldConverter)) {\n', '            _oldConverter.transferTokenOwnership(newConverter);\n', '            newConverter.acceptTokenOwnership();\n', '        }\n', '\n', '        _oldConverter.transferOwnership(msg.sender);\n', '        newConverter.transferOwnership(msg.sender);\n', '        newConverter.transferManagement(msg.sender);\n', '\n', '        emit ConverterUpgrade(address(_oldConverter), address(newConverter));\n', '    }\n', '\n', '    /**\n', '        @dev the first step when upgrading a converter is to transfer the ownership to the local contract.\n', '        the upgrader contract then needs to accept the ownership transfer before initiating\n', '        the upgrade process.\n', '        fires the ConverterOwned event upon success\n', '\n', '        @param _oldConverter       converter to accept ownership of\n', '    */\n', '    function acceptConverterOwnership(IBancorConverterExtended _oldConverter) private {\n', '        require(msg.sender == _oldConverter.owner());\n', '        _oldConverter.acceptOwnership();\n', '        emit ConverterOwned(_oldConverter, this);\n', '    }\n', '\n', '    /**\n', '        @dev creates a new converter with same basic data as the original old converter\n', '        the newly created converter will have no connectors at this step.\n', '\n', '        @param _oldConverter    old converter contract address\n', '\n', '        @return the new converter  new converter contract address\n', '    */\n', '    function createConverter(IBancorConverterExtended _oldConverter) private returns(IBancorConverterExtended) {\n', '        IWhitelist whitelist;\n', '        ISmartToken token = _oldConverter.token();\n', '        uint32 maxConversionFee = _oldConverter.maxConversionFee();\n', '\n', '        address converterAdderess  = bancorConverterFactory.createConverter(\n', '            token,\n', '            registry,\n', '            maxConversionFee,\n', '            IERC20Token(address(0)),\n', '            0\n', '        );\n', '\n', '        IBancorConverterExtended converter = IBancorConverterExtended(converterAdderess);\n', '        converter.acceptOwnership();\n', '        converter.acceptManagement();\n', '\n', '        // get the contract features address from the registry\n', '        IContractFeatures features = IContractFeatures(registry.getAddress(ContractIds.CONTRACT_FEATURES));\n', '\n', '        if (features.isSupported(_oldConverter, FeatureIds.CONVERTER_CONVERSION_WHITELIST)) {\n', '            whitelist = _oldConverter.conversionWhitelist();\n', '            if (whitelist != address(0))\n', '                converter.setConversionWhitelist(whitelist);\n', '        }\n', '\n', '        return converter;\n', '    }\n', '\n', '    /**\n', '        @dev copies the connectors from the old converter to the new one.\n', '        note that this will not work for an unlimited number of connectors due to block gas limit constraints.\n', '\n', '        @param _oldConverter    old converter contract address\n', '        @param _newConverter    new converter contract address\n', '        @param _isLegacyVersion true if the converter version is under 0.5\n', '    */\n', '    function copyConnectors(IBancorConverterExtended _oldConverter, IBancorConverterExtended _newConverter, bool _isLegacyVersion)\n', '        private\n', '    {\n', '        uint256 virtualBalance;\n', '        uint32 weight;\n', '        bool isVirtualBalanceEnabled;\n', '        bool isPurchaseEnabled;\n', '        bool isSet;\n', '        uint16 connectorTokenCount = _isLegacyVersion ? _oldConverter.reserveTokenCount() : _oldConverter.connectorTokenCount();\n', '\n', '        for (uint16 i = 0; i < connectorTokenCount; i++) {\n', '            address connectorAddress = _isLegacyVersion ? _oldConverter.reserveTokens(i) : _oldConverter.connectorTokens(i);\n', '            (virtualBalance, weight, isVirtualBalanceEnabled, isPurchaseEnabled, isSet) = readConnector(\n', '                _oldConverter,\n', '                connectorAddress,\n', '                _isLegacyVersion\n', '            );\n', '\n', '            IERC20Token connectorToken = IERC20Token(connectorAddress);\n', '            _newConverter.addConnector(connectorToken, weight, isVirtualBalanceEnabled);\n', '        }\n', '    }\n', '\n', '    /**\n', '        @dev copies the conversion fee from the old converter to the new one\n', '\n', '        @param _oldConverter    old converter contract address\n', '        @param _newConverter    new converter contract address\n', '    */\n', '    function copyConversionFee(IBancorConverterExtended _oldConverter, IBancorConverterExtended _newConverter) private {\n', '        uint32 conversionFee = _oldConverter.conversionFee();\n', '        _newConverter.setConversionFee(conversionFee);\n', '    }\n', '\n', '    /**\n', '        @dev copies the quick buy path from the old converter to the new one\n', '\n', '        @param _oldConverter    old converter contract address\n', '        @param _newConverter    new converter contract address\n', '    */\n', '    function copyQuickBuyPath(IBancorConverterExtended _oldConverter, IBancorConverterExtended _newConverter) private {\n', '        uint256 quickBuyPathLength = _oldConverter.getQuickBuyPathLength();\n', '        if (quickBuyPathLength <= 0)\n', '            return;\n', '\n', '        IERC20Token[] memory path = new IERC20Token[](quickBuyPathLength);\n', '        for (uint256 i = 0; i < quickBuyPathLength; i++) {\n', '            path[i] = _oldConverter.quickBuyPath(i);\n', '        }\n', '\n', '        _newConverter.setQuickBuyPath(path);\n', '    }\n', '\n', '    /**\n', '        @dev transfers the balance of each connector in the old converter to the new one.\n', '        note that the function assumes that the new converter already has the exact same number of\n', '        also, this will not work for an unlimited number of connectors due to block gas limit constraints.\n', '\n', '        @param _oldConverter    old converter contract address\n', '        @param _newConverter    new converter contract address\n', '        @param _isLegacyVersion true if the converter version is under 0.5\n', '    */\n', '    function transferConnectorsBalances(IBancorConverterExtended _oldConverter, IBancorConverterExtended _newConverter, bool _isLegacyVersion)\n', '        private\n', '    {\n', '        uint256 connectorBalance;\n', '        uint16 connectorTokenCount = _isLegacyVersion ? _oldConverter.reserveTokenCount() : _oldConverter.connectorTokenCount();\n', '\n', '        for (uint16 i = 0; i < connectorTokenCount; i++) {\n', '            address connectorAddress = _isLegacyVersion ? _oldConverter.reserveTokens(i) : _oldConverter.connectorTokens(i);\n', '            IERC20Token connector = IERC20Token(connectorAddress);\n', '            connectorBalance = _isLegacyVersion ? _oldConverter.getReserveBalance(connector) : _oldConverter.getConnectorBalance(connector);\n', '            _oldConverter.withdrawTokens(connector, address(_newConverter), connectorBalance);\n', '        }\n', '    }\n', '\n', '    /**\n', '        @dev returns the connector settings\n', '\n', '        @param _converter       old converter contract address\n', "        @param _address         connector's address to read from\n", '        @param _isLegacyVersion true if the converter version is under 0.5\n', '\n', "        @return connector's settings\n", '    */\n', '    function readConnector(IBancorConverterExtended _converter, address _address, bool _isLegacyVersion) \n', '        private\n', '        view\n', '        returns(uint256 virtualBalance, uint32 weight, bool isVirtualBalanceEnabled, bool isPurchaseEnabled, bool isSet)\n', '    {\n', '        return _isLegacyVersion ? _converter.reserves(_address) : _converter.connectors(_address);\n', '    }\n', '}']
