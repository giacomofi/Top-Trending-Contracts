['pragma solidity ^0.4.24;\n', '\n', 'interface POUInterface {\n', '\n', '    function totalStaked(address) external view returns(uint256);\n', '    function numApplications(address) external view returns(uint256);\n', '\n', '}\n', '\n', '\n', 'interface SaleInterface {\n', '    function saleTokensPerUnit() external view returns(uint256);\n', '    function extraTokensPerUnit() external view returns(uint256);\n', '    function unitContributions(address) external view returns(uint256);\n', '    function disbursementHandler() external view returns(address);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Interface for token controllers. The controller specifies whether a transfer can be done.\n', 'contract TokenControllerI {\n', '\n', '    /// @dev Specifies whether a transfer is allowed or not.\n', '    /// @return True if the transfer is allowed\n', '    function transferAllowed(address _from, address _to)\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', 'contract FoamTokenController is TokenControllerI, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    POUInterface public registry;\n', '    POUInterface public signaling;\n', '    SaleInterface public sale;\n', '    SaleInterface public saft;\n', '\n', '    uint256 public platformLaunchDate;\n', '\n', '    uint256 public saleTokensPerUnit;\n', '    uint256 public extraTokensPerUnit;\n', '\n', '    mapping (address => bool) public isProtocolContract;\n', '\n', '    mapping(address => address) public proposedPair;\n', '    mapping(address => address) public pair;\n', '\n', '    mapping(address => bool) public isBlacklisted;\n', '    mapping(address => bool) public pouCompleted;\n', '\n', '    event ProposeWhitelisted(address _whitelistor, address _whitelistee);\n', '    event ConfirmWhitelisted(address _whitelistor, address _whitelistee);\n', '    event PoUCompleted(address contributor, address secondAddress, bool isComplete);\n', '\n', '    // this is one of the TF multisigs.\n', '    // We can then send the tokens onwards to wherever FOAM request for the tokens to be.\n', '    address acceptedAddress = 0x36A9b165ef64767230A7Aded71B04F0911bB1283;\n', '\n', '    constructor(POUInterface _registry, POUInterface _signaling, SaleInterface _sale, SaleInterface _saft, uint256 _launchDate) public {\n', '        require(_registry != address(0), "registry contract must have a valid address");\n', '        require(_signaling != address(0), "signaling contract must have a valid address");\n', '        require(_sale != address(0), "sale contract must have a valid address");\n', '        require(_saft != address(0), "saft contract must have a valid address");\n', '        require(_launchDate != 0 && _launchDate <= now, "platform cannot have launched in the future");\n', '\n', '        registry = _registry;\n', '        signaling = _signaling;\n', '        sale = _sale;\n', '        saft = _saft;\n', '        platformLaunchDate = _launchDate;\n', '\n', '        isProtocolContract[address(registry)] = true;\n', '        isProtocolContract[address(signaling)] = true;\n', '\n', '        saleTokensPerUnit = sale.saleTokensPerUnit();\n', '        extraTokensPerUnit = sale.extraTokensPerUnit();\n', '    }\n', '\n', '    function setWhitelisted(address _whitelisted) public {\n', '        require(_whitelisted != 0, "cannot whitelist the zero address");\n', '\n', '        require(pair[msg.sender] == 0, "sender\'s address must not be paired yet");\n', '        require(pair[_whitelisted] == 0, "proposed whitelist address must not be paired yet");\n', '\n', '        require(sale.unitContributions(msg.sender) != 0, "sender must have purchased tokens during the sale");\n', '        require(sale.unitContributions(_whitelisted) == 0, "proposed whitelist address must not have purchased tokens during the sale");\n', '\n', '        proposedPair[msg.sender] = _whitelisted;\n', '        emit ProposeWhitelisted(msg.sender, _whitelisted);\n', '    }\n', '\n', '    function confirmWhitelisted(address _whitelistor) public {\n', '        require(pair[msg.sender] == 0, "sender\'s address must not be paired yet");\n', '        require(pair[_whitelistor] == 0, "whitelistor\'s address must not be paired yet");\n', '\n', '        require(proposedPair[_whitelistor] == msg.sender, "whitelistor\'s proposed address must be the sender");\n', '\n', '        pair[msg.sender] = _whitelistor;\n', '        pair[_whitelistor] = msg.sender;\n', '\n', '        emit ConfirmWhitelisted(_whitelistor, msg.sender);\n', '    }\n', '\n', '    function setAcceptedAddress(address _newAcceptedAddress) public onlyOwner {\n', '      require(_newAcceptedAddress != address(0), "blacklist bypass address cannot be the zero address");\n', '      acceptedAddress = _newAcceptedAddress;\n', '    }\n', '\n', '    function pairAddresses(address[] froms, address[] tos) public onlyOwner {\n', '      require(froms.length == tos.length, "pair arrays must be same size");\n', '      for (uint256 i = 0; i < froms.length; i++) {\n', '        pair[froms[i]] = tos[i];\n', '        pair[tos[i]] = froms[i];\n', '      }\n', '    }\n', '\n', '    function blacklistAddresses(address[] _addresses, bool _isBlacklisted) public onlyOwner {\n', '        for (uint256 i = 0; i < _addresses.length; i++) {\n', '            isBlacklisted[_addresses[i]] = _isBlacklisted;\n', '        }\n', '    }\n', '\n', '    function setPoUCompleted(address _user, bool _isCompleted) public onlyOwner {\n', '        pouCompleted[_user] = _isCompleted;\n', '    }\n', '\n', '    function changeRegistry(POUInterface _newRegistry) public onlyOwner {\n', '        require(_newRegistry != address(0), "registry contract must have a valid address");\n', '        isProtocolContract[address(registry)] = false;\n', '        isProtocolContract[address(_newRegistry)] = true;\n', '        registry = _newRegistry;\n', '    }\n', '\n', '    function changeSignaling(POUInterface _newSignaling) public onlyOwner {\n', '        require(_newSignaling != address(0), "signaling contract must have a valid address");\n', '        isProtocolContract[address(signaling)] = false;\n', '        isProtocolContract[address(_newSignaling)] = true;\n', '        signaling = _newSignaling;\n', '    }\n', '\n', '    function setPlatformLaunchDate(uint256 _launchDate) public onlyOwner {\n', '        require(_launchDate != 0 && _launchDate <= now, "platform cannot have launched in the future");\n', '        platformLaunchDate = _launchDate;\n', '    }\n', '\n', '    function setProtocolContract(address _contract, bool _isProtocolContract) public onlyOwner {\n', '        isProtocolContract[_contract] = _isProtocolContract;\n', '    }\n', '\n', '    function setProtocolContracts(address[] _addresses, bool _isProtocolContract) public onlyOwner {\n', '      for (uint256 i = 0; i < _addresses.length; i++) {\n', '        isProtocolContract[_addresses[i]] = _isProtocolContract;\n', '      }\n', '    }\n', '\n', '    function setSaleContract(SaleInterface _sale) public onlyOwner {\n', '      require(_sale != address(0), "sale contract must have a valid address");\n', '      sale = _sale;\n', '    }\n', '\n', '    function setSaftContract(SaleInterface _saft) public onlyOwner {\n', '      require(_saft != address(0), "saft contract must have a valid address");\n', '      saft = _saft;\n', '    }\n', '\n', '    function transferAllowed(address _from, address _to)\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        if(isBlacklisted[_from]) {\n', '            return _to == acceptedAddress;\n', '        }\n', '\n', '        bool protocolTransfer = isProtocolContract[_from] || isProtocolContract[_to];\n', '        bool whitelistedTransfer = pair[_from] == _to && pair[_to] == _from;\n', '\n', '        if (protocolTransfer || whitelistedTransfer || platformLaunchDate + 365 days <= now) {\n', '            return true;\n', '        } else if (platformLaunchDate + 45 days > now) {\n', '            return false;\n', '        }\n', '        return purchaseCheck(_from);\n', '    }\n', '\n', '    function purchaseCheck(address _contributor) public returns (bool) {\n', '        if(pouCompleted[_contributor]){\n', '            return true;\n', '        }\n', '\n', '        address secondAddress = pair[_contributor];\n', '        if(secondAddress != address(0) && pouCompleted[secondAddress]) {\n', '            return true;\n', '        }\n', '\n', '        uint256 contributed = sale.unitContributions(_contributor).add(saft.unitContributions(_contributor));\n', '\n', '        if (contributed == 0) {\n', '            if (secondAddress == 0) {\n', '                return true;\n', '            } else {\n', '                contributed = sale.unitContributions(secondAddress).add(saft.unitContributions(secondAddress));\n', '            }\n', '        }\n', '\n', '\n', '        uint256 tokensStaked = registry.totalStaked(_contributor).add(signaling.totalStaked(_contributor));\n', '        uint256 PoICreated = registry.numApplications(_contributor).add(signaling.numApplications(_contributor));\n', '\n', '        if (secondAddress != 0) {\n', '            tokensStaked = tokensStaked.add(registry.totalStaked(secondAddress)).add(signaling.totalStaked(secondAddress));\n', '            PoICreated = PoICreated.add(registry.numApplications(secondAddress)).add(signaling.numApplications(secondAddress));\n', '        }\n', '\n', '        uint256 tokensBought = contributed.mul(saleTokensPerUnit.add(extraTokensPerUnit));\n', '\n', '        bool enoughStaked;\n', '        if (contributed <= 10000) {\n', '            enoughStaked = tokensStaked >= tokensBought.mul(25).div(100);\n', '        } else {\n', '            enoughStaked = tokensStaked >= tokensBought.mul(50).div(100);\n', '        }\n', '\n', '        bool isComplete = enoughStaked && PoICreated >= 10;\n', '        if (isComplete == true) {\n', '          pouCompleted[_contributor] = true;\n', '          if (secondAddress != address(0)) {\n', '            pouCompleted[secondAddress] = true;\n', '          }\n', '          emit PoUCompleted(_contributor, secondAddress, isComplete);\n', '        }\n', '\n', '        return isComplete;\n', '    }\n', '}']