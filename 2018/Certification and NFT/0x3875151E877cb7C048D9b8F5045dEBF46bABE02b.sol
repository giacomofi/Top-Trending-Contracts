['pragma solidity ^0.4.13;\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    function DSAuth() public {\n', '        owner = msg.sender;\n', '        LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'contract DSExec {\n', '    function tryExec( address target, bytes calldata, uint value)\n', '             internal\n', '             returns (bool call_ret)\n', '    {\n', '        return target.call.value(value)(calldata);\n', '    }\n', '    function exec( address target, bytes calldata, uint value)\n', '             internal\n', '    {\n', '        if(!tryExec(target, calldata, value)) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    // Convenience aliases\n', '    function exec( address t, bytes c )\n', '        internal\n', '    {\n', '        exec(t, c, 0);\n', '    }\n', '    function exec( address t, uint256 v )\n', '        internal\n', '    {\n', '        bytes memory c; exec(t, c, v);\n', '    }\n', '    function tryExec( address t, bytes c )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return tryExec(t, c, 0);\n', '    }\n', '    function tryExec( address t, uint256 v )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        bytes memory c; return tryExec(t, c, v);\n', '    }\n', '}\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  guy,\n', '        bytes32  indexed  foo,\n', '        bytes32  indexed  bar,\n', '        uint              wad,\n', '        bytes             fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', 'contract DSGroup is DSExec, DSNote {\n', '    address[]  public  members;\n', '    uint       public  quorum;\n', '    uint       public  window;\n', '    uint       public  actionCount;\n', '\n', '    mapping (uint => Action)                     public  actions;\n', '    mapping (uint => mapping (address => bool))  public  confirmedBy;\n', '    mapping (address => bool)                    public  isMember;\n', '\n', '    // Legacy events\n', '    event Proposed   (uint id, bytes calldata);\n', '    event Confirmed  (uint id, address member);\n', '    event Triggered  (uint id);\n', '\n', '    struct Action {\n', '        address  target;\n', '        bytes    calldata;\n', '        uint     value;\n', '\n', '        uint     confirmations;\n', '        uint     deadline;\n', '        bool     triggered;\n', '    }\n', '\n', '    function DSGroup(\n', '        address[]  members_,\n', '        uint       quorum_,\n', '        uint       window_\n', '    ) {\n', '        members  = members_;\n', '        quorum   = quorum_;\n', '        window   = window_;\n', '\n', '        for (uint i = 0; i < members.length; i++) {\n', '            isMember[members[i]] = true;\n', '        }\n', '    }\n', '\n', '    function memberCount() constant returns (uint) {\n', '        return members.length;\n', '    }\n', '\n', '    function target(uint id) constant returns (address) {\n', '        return actions[id].target;\n', '    }\n', '    function calldata(uint id) constant returns (bytes) {\n', '        return actions[id].calldata;\n', '    }\n', '    function value(uint id) constant returns (uint) {\n', '        return actions[id].value;\n', '    }\n', '\n', '    function confirmations(uint id) constant returns (uint) {\n', '        return actions[id].confirmations;\n', '    }\n', '    function deadline(uint id) constant returns (uint) {\n', '        return actions[id].deadline;\n', '    }\n', '    function triggered(uint id) constant returns (bool) {\n', '        return actions[id].triggered;\n', '    }\n', '\n', '    function confirmed(uint id) constant returns (bool) {\n', '        return confirmations(id) >= quorum;\n', '    }\n', '    function expired(uint id) constant returns (bool) {\n', '        return now > deadline(id);\n', '    }\n', '\n', '    function deposit() note payable {\n', '    }\n', '\n', '    function propose(\n', '        address  target,\n', '        bytes    calldata,\n', '        uint     value\n', '    ) onlyMembers note returns (uint id) {\n', '        id = ++actionCount;\n', '\n', '        actions[id].target    = target;\n', '        actions[id].calldata  = calldata;\n', '        actions[id].value     = value;\n', '        actions[id].deadline  = now + window;\n', '\n', '        Proposed(id, calldata);\n', '    }\n', '\n', '    function confirm(uint id) onlyMembers onlyActive(id) note {\n', '        assert(!confirmedBy[id][msg.sender]);\n', '\n', '        confirmedBy[id][msg.sender] = true;\n', '        actions[id].confirmations++;\n', '\n', '        Confirmed(id, msg.sender);\n', '    }\n', '\n', '    function trigger(uint id) onlyMembers onlyActive(id) note {\n', '        assert(confirmed(id));\n', '\n', '        actions[id].triggered = true;\n', '        exec(actions[id].target, actions[id].calldata, actions[id].value);\n', '\n', '        Triggered(id);\n', '    }\n', '\n', '    modifier onlyMembers {\n', '        assert(isMember[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyActive(uint id) {\n', '        assert(!expired(id));\n', '        assert(!triggered(id));\n', '        _;\n', '    }\n', '\n', '    //------------------------------------------------------------------\n', '    // Legacy functions\n', '    //------------------------------------------------------------------\n', '\n', '    function getInfo() constant returns (\n', '        uint  quorum_,\n', '        uint  memberCount,\n', '        uint  window_,\n', '        uint  actionCount_\n', '    ) {\n', '        return (quorum, members.length, window, actionCount);\n', '    }\n', '\n', '    function getActionStatus(uint id) constant returns (\n', '        uint     confirmations,\n', '        uint     deadline,\n', '        bool     triggered,\n', '        address  target,\n', '        uint     value\n', '    ) {\n', '        return (\n', '            actions[id].confirmations,\n', '            actions[id].deadline,\n', '            actions[id].triggered,\n', '            actions[id].target,\n', '            actions[id].value\n', '        );\n', '    }\n', '}\n', '\n', 'contract DSGroupFactory is DSNote {\n', '    mapping (address => bool)  public  isGroup;\n', '\n', '    function newGroup(\n', '        address[]  members,\n', '        uint       quorum,\n', '        uint       window\n', '    ) note returns (DSGroup group) {\n', '        group = new DSGroup(members, quorum, window);\n', '        isGroup[group] = true;\n', '    }\n', '}\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', '    // It&#39;s O(log n), instead of O(n) for naive repeated multiplication.\n', '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract DSThing is DSAuth, DSNote, DSMath {\n', '\n', '    function S(string s) internal pure returns (bytes4) {\n', '        return bytes4(keccak256(s));\n', '    }\n', '\n', '}\n', '\n', 'interface AssetInterface {\n', '    /*\n', '     * Implements ERC 20 standard.\n', '     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\n', '     * https://github.com/ethereum/EIPs/issues/20\n', '     *\n', '     *  Added support for the ERC 223 "tokenFallback" method in a "transfer" function with a payload.\n', '     *  https://github.com/ethereum/EIPs/issues/223\n', '     */\n', '\n', '    // Events\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    // There is no ERC223 compatible Transfer event, with `_data` included.\n', '\n', '    //ERC 223\n', '    // PUBLIC METHODS\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool success);\n', '\n', '    // ERC 20\n', '    // PUBLIC METHODS\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    // PUBLIC VIEW METHODS\n', '    function balanceOf(address _owner) view public returns (uint balance);\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '}\n', '\n', 'contract DBC {\n', '\n', '    // MODIFIERS\n', '\n', '    modifier pre_cond(bool condition) {\n', '        require(condition);\n', '        _;\n', '    }\n', '\n', '    modifier post_cond(bool condition) {\n', '        _;\n', '        assert(condition);\n', '    }\n', '\n', '    modifier invariant(bool condition) {\n', '        require(condition);\n', '        _;\n', '        assert(condition);\n', '    }\n', '}\n', '\n', 'contract Owned is DBC {\n', '\n', '    // FIELDS\n', '\n', '    address public owner;\n', '\n', '    // NON-CONSTANT METHODS\n', '\n', '    function Owned() { owner = msg.sender; }\n', '\n', '    function changeOwner(address ofNewOwner) pre_cond(isOwner()) { owner = ofNewOwner; }\n', '\n', '    // PRE, POST, INVARIANT CONDITIONS\n', '\n', '    function isOwner() internal returns (bool) { return msg.sender == owner; }\n', '\n', '}\n', '\n', 'contract CanonicalRegistrar is DSThing, DBC {\n', '\n', '    // TYPES\n', '\n', '    struct Asset {\n', '        bool exists; // True if asset is registered here\n', '        bytes32 name; // Human-readable name of the Asset as in ERC223 token standard\n', '        bytes8 symbol; // Human-readable symbol of the Asset as in ERC223 token standard\n', '        uint decimals; // Decimal, order of magnitude of precision, of the Asset as in ERC223 token standard\n', '        string url; // URL for additional information of Asset\n', '        string ipfsHash; // Same as url but for ipfs\n', '        address breakIn; // Break in contract on destination chain\n', '        address breakOut; // Break out contract on this chain; A way to leave\n', '        uint[] standards; // compliance with standards like ERC20, ERC223, ERC777, etc. (the uint is the standard number)\n', '        bytes4[] functionSignatures; // Whitelisted function signatures that can be called using `useExternalFunction` in Fund contract. Note: Adhere to a naming convention for `Fund<->Asset` as much as possible. I.e. name same concepts with the same functionSignature.\n', '        uint price; // Price of asset quoted against `QUOTE_ASSET` * 10 ** decimals\n', '        uint timestamp; // Timestamp of last price update of this asset\n', '    }\n', '\n', '    struct Exchange {\n', '        bool exists;\n', '        address adapter; // adapter contract for this exchange\n', '        // One-time note: takesCustody is inverse case of isApproveOnly\n', '        bool takesCustody; // True in case of exchange implementation which requires  are approved when an order is made instead of transfer\n', '        bytes4[] functionSignatures; // Whitelisted function signatures that can be called using `useExternalFunction` in Fund contract. Note: Adhere to a naming convention for `Fund<->ExchangeAdapter` as much as possible. I.e. name same concepts with the same functionSignature.\n', '    }\n', '    // TODO: populate each field here\n', '    // TODO: add whitelistFunction function\n', '\n', '    // FIELDS\n', '\n', '    // Methods fields\n', '    mapping (address => Asset) public assetInformation;\n', '    address[] public registeredAssets;\n', '\n', '    mapping (address => Exchange) public exchangeInformation;\n', '    address[] public registeredExchanges;\n', '\n', '    // METHODS\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /// @notice Registers an Asset information entry\n', '    /// @dev Pre: Only registrar owner should be able to register\n', '    /// @dev Post: Address ofAsset is registered\n', '    /// @param ofAsset Address of asset to be registered\n', '    /// @param inputName Human-readable name of the Asset as in ERC223 token standard\n', '    /// @param inputSymbol Human-readable symbol of the Asset as in ERC223 token standard\n', '    /// @param inputDecimals Human-readable symbol of the Asset as in ERC223 token standard\n', '    /// @param inputUrl Url for extended information of the asset\n', '    /// @param inputIpfsHash Same as url but for ipfs\n', '    /// @param breakInBreakOut Address of break in and break out contracts on destination chain\n', '    /// @param inputStandards Integers of EIP standards this asset adheres to\n', '    /// @param inputFunctionSignatures Function signatures for whitelisted asset functions\n', '    function registerAsset(\n', '        address ofAsset,\n', '        bytes32 inputName,\n', '        bytes8 inputSymbol,\n', '        uint inputDecimals,\n', '        string inputUrl,\n', '        string inputIpfsHash,\n', '        address[2] breakInBreakOut,\n', '        uint[] inputStandards,\n', '        bytes4[] inputFunctionSignatures\n', '    )\n', '        auth\n', '        pre_cond(!assetInformation[ofAsset].exists)\n', '    {\n', '        assetInformation[ofAsset].exists = true;\n', '        registeredAssets.push(ofAsset);\n', '        updateAsset(\n', '            ofAsset,\n', '            inputName,\n', '            inputSymbol,\n', '            inputDecimals,\n', '            inputUrl,\n', '            inputIpfsHash,\n', '            breakInBreakOut,\n', '            inputStandards,\n', '            inputFunctionSignatures\n', '        );\n', '        assert(assetInformation[ofAsset].exists);\n', '    }\n', '\n', '    /// @notice Register an exchange information entry\n', '    /// @dev Pre: Only registrar owner should be able to register\n', '    /// @dev Post: Address ofExchange is registered\n', '    /// @param ofExchange Address of the exchange\n', '    /// @param ofExchangeAdapter Address of exchange adapter for this exchange\n', '    /// @param inputTakesCustody Whether this exchange takes custody of tokens before trading\n', '    /// @param inputFunctionSignatures Function signatures for whitelisted exchange functions\n', '    function registerExchange(\n', '        address ofExchange,\n', '        address ofExchangeAdapter,\n', '        bool inputTakesCustody,\n', '        bytes4[] inputFunctionSignatures\n', '    )\n', '        auth\n', '        pre_cond(!exchangeInformation[ofExchange].exists)\n', '    {\n', '        exchangeInformation[ofExchange].exists = true;\n', '        registeredExchanges.push(ofExchange);\n', '        updateExchange(\n', '            ofExchange,\n', '            ofExchangeAdapter,\n', '            inputTakesCustody,\n', '            inputFunctionSignatures\n', '        );\n', '        assert(exchangeInformation[ofExchange].exists);\n', '    }\n', '\n', '    /// @notice Updates description information of a registered Asset\n', '    /// @dev Pre: Owner can change an existing entry\n', '    /// @dev Post: Changed Name, Symbol, URL and/or IPFSHash\n', '    /// @param ofAsset Address of the asset to be updated\n', '    /// @param inputName Human-readable name of the Asset as in ERC223 token standard\n', '    /// @param inputSymbol Human-readable symbol of the Asset as in ERC223 token standard\n', '    /// @param inputUrl Url for extended information of the asset\n', '    /// @param inputIpfsHash Same as url but for ipfs\n', '    function updateAsset(\n', '        address ofAsset,\n', '        bytes32 inputName,\n', '        bytes8 inputSymbol,\n', '        uint inputDecimals,\n', '        string inputUrl,\n', '        string inputIpfsHash,\n', '        address[2] ofBreakInBreakOut,\n', '        uint[] inputStandards,\n', '        bytes4[] inputFunctionSignatures\n', '    )\n', '        auth\n', '        pre_cond(assetInformation[ofAsset].exists)\n', '    {\n', '        Asset asset = assetInformation[ofAsset];\n', '        asset.name = inputName;\n', '        asset.symbol = inputSymbol;\n', '        asset.decimals = inputDecimals;\n', '        asset.url = inputUrl;\n', '        asset.ipfsHash = inputIpfsHash;\n', '        asset.breakIn = ofBreakInBreakOut[0];\n', '        asset.breakOut = ofBreakInBreakOut[1];\n', '        asset.standards = inputStandards;\n', '        asset.functionSignatures = inputFunctionSignatures;\n', '    }\n', '\n', '    function updateExchange(\n', '        address ofExchange,\n', '        address ofExchangeAdapter,\n', '        bool inputTakesCustody,\n', '        bytes4[] inputFunctionSignatures\n', '    )\n', '        auth\n', '        pre_cond(exchangeInformation[ofExchange].exists)\n', '    {\n', '        Exchange exchange = exchangeInformation[ofExchange];\n', '        exchange.adapter = ofExchangeAdapter;\n', '        exchange.takesCustody = inputTakesCustody;\n', '        exchange.functionSignatures = inputFunctionSignatures;\n', '    }\n', '\n', '    // TODO: check max size of array before remaking this becomes untenable\n', '    /// @notice Deletes an existing entry\n', '    /// @dev Owner can delete an existing entry\n', '    /// @param ofAsset address for which specific information is requested\n', '    function removeAsset(\n', '        address ofAsset,\n', '        uint assetIndex\n', '    )\n', '        auth\n', '        pre_cond(assetInformation[ofAsset].exists)\n', '    {\n', '        require(registeredAssets[assetIndex] == ofAsset);\n', '        delete assetInformation[ofAsset]; // Sets exists boolean to false\n', '        delete registeredAssets[assetIndex];\n', '        for (uint i = assetIndex; i < registeredAssets.length-1; i++) {\n', '            registeredAssets[i] = registeredAssets[i+1];\n', '        }\n', '        registeredAssets.length--;\n', '        assert(!assetInformation[ofAsset].exists);\n', '    }\n', '\n', '    /// @notice Deletes an existing entry\n', '    /// @dev Owner can delete an existing entry\n', '    /// @param ofExchange address for which specific information is requested\n', '    /// @param exchangeIndex index of the exchange in array\n', '    function removeExchange(\n', '        address ofExchange,\n', '        uint exchangeIndex\n', '    )\n', '        auth\n', '        pre_cond(exchangeInformation[ofExchange].exists)\n', '    {\n', '        require(registeredExchanges[exchangeIndex] == ofExchange);\n', '        delete exchangeInformation[ofExchange];\n', '        delete registeredExchanges[exchangeIndex];\n', '        for (uint i = exchangeIndex; i < registeredExchanges.length-1; i++) {\n', '            registeredExchanges[i] = registeredExchanges[i+1];\n', '        }\n', '        registeredExchanges.length--;\n', '        assert(!exchangeInformation[ofExchange].exists);\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    // get asset specific information\n', '    function getName(address ofAsset) view returns (bytes32) { return assetInformation[ofAsset].name; }\n', '    function getSymbol(address ofAsset) view returns (bytes8) { return assetInformation[ofAsset].symbol; }\n', '    function getDecimals(address ofAsset) view returns (uint) { return assetInformation[ofAsset].decimals; }\n', '    function assetIsRegistered(address ofAsset) view returns (bool) { return assetInformation[ofAsset].exists; }\n', '    function getRegisteredAssets() view returns (address[]) { return registeredAssets; }\n', '    function assetMethodIsAllowed(\n', '        address ofAsset, bytes4 querySignature\n', '    )\n', '        returns (bool)\n', '    {\n', '        bytes4[] memory signatures = assetInformation[ofAsset].functionSignatures;\n', '        for (uint i = 0; i < signatures.length; i++) {\n', '            if (signatures[i] == querySignature) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    // get exchange-specific information\n', '    function exchangeIsRegistered(address ofExchange) view returns (bool) { return exchangeInformation[ofExchange].exists; }\n', '    function getRegisteredExchanges() view returns (address[]) { return registeredExchanges; }\n', '    function getExchangeInformation(address ofExchange)\n', '        view\n', '        returns (address, bool)\n', '    {\n', '        Exchange exchange = exchangeInformation[ofExchange];\n', '        return (\n', '            exchange.adapter,\n', '            exchange.takesCustody\n', '        );\n', '    }\n', '    function getExchangeFunctionSignatures(address ofExchange)\n', '        view\n', '        returns (bytes4[])\n', '    {\n', '        return exchangeInformation[ofExchange].functionSignatures;\n', '    }\n', '    function exchangeMethodIsAllowed(\n', '        address ofExchange, bytes4 querySignature\n', '    )\n', '        returns (bool)\n', '    {\n', '        bytes4[] memory signatures = exchangeInformation[ofExchange].functionSignatures;\n', '        for (uint i = 0; i < signatures.length; i++) {\n', '            if (signatures[i] == querySignature) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '}\n', '\n', 'interface SimplePriceFeedInterface {\n', '\n', '    // EVENTS\n', '\n', '    event PriceUpdated(bytes32 hash);\n', '\n', '    // PUBLIC METHODS\n', '\n', '    function update(address[] ofAssets, uint[] newPrices) external;\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    // Get price feed operation specific information\n', '    function getQuoteAsset() view returns (address);\n', '    function getLastUpdateId() view returns (uint);\n', '    // Get asset specific information as updated in price feed\n', '    function getPrice(address ofAsset) view returns (uint price, uint timestamp);\n', '    function getPrices(address[] ofAssets) view returns (uint[] prices, uint[] timestamps);\n', '}\n', '\n', 'contract SimplePriceFeed is SimplePriceFeedInterface, DSThing, DBC {\n', '\n', '    // TYPES\n', '    struct Data {\n', '        uint price;\n', '        uint timestamp;\n', '    }\n', '\n', '    // FIELDS\n', '    mapping(address => Data) public assetsToPrices;\n', '\n', '    // Constructor fields\n', '    address public QUOTE_ASSET; // Asset of a portfolio against which all other assets are priced\n', '\n', '    // Contract-level variables\n', '    uint public updateId;        // Update counter for this pricefeed; used as a check during investment\n', '    CanonicalRegistrar public registrar;\n', '    CanonicalPriceFeed public superFeed;\n', '\n', '    // METHODS\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @param ofQuoteAsset Address of quote asset\n', '    /// @param ofRegistrar Address of canonical registrar\n', '    /// @param ofSuperFeed Address of superfeed\n', '    function SimplePriceFeed(\n', '        address ofRegistrar,\n', '        address ofQuoteAsset,\n', '        address ofSuperFeed\n', '    ) {\n', '        registrar = CanonicalRegistrar(ofRegistrar);\n', '        QUOTE_ASSET = ofQuoteAsset;\n', '        superFeed = CanonicalPriceFeed(ofSuperFeed);\n', '    }\n', '\n', '    // EXTERNAL METHODS\n', '\n', '    /// @dev Only Owner; Same sized input arrays\n', '    /// @dev Updates price of asset relative to QUOTE_ASSET\n', '    /** Ex:\n', '     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\n', '     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\n', '     *  and let EUR-T decimals == 8.\n', '     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\n', '     */\n', '    /// @param ofAssets list of asset addresses\n', '    /// @param newPrices list of prices for each of the assets\n', '    function update(address[] ofAssets, uint[] newPrices)\n', '        external\n', '        auth\n', '    {\n', '        _updatePrices(ofAssets, newPrices);\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    // Get pricefeed specific information\n', '    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\n', '    function getLastUpdateId() view returns (uint) { return updateId; }\n', '\n', '    /**\n', '    @notice Gets price of an asset multiplied by ten to the power of assetDecimals\n', '    @dev Asset has been registered\n', '    @param ofAsset Asset for which price should be returned\n', '    @return {\n', '      "price": "Price formatting: mul(exchangePrice, 10 ** decimal), to avoid floating numbers",\n', '      "timestamp": "When the asset&#39;s price was updated"\n', '    }\n', '    */\n', '    function getPrice(address ofAsset)\n', '        view\n', '        returns (uint price, uint timestamp)\n', '    {\n', '        Data data = assetsToPrices[ofAsset];\n', '        return (data.price, data.timestamp);\n', '    }\n', '\n', '    /**\n', '    @notice Price of a registered asset in format (bool areRecent, uint[] prices, uint[] decimals)\n', '    @dev Convention for price formatting: mul(price, 10 ** decimal), to avoid floating numbers\n', '    @param ofAssets Assets for which prices should be returned\n', '    @return {\n', '        "prices":       "Array of prices",\n', '        "timestamps":   "Array of timestamps",\n', '    }\n', '    */\n', '    function getPrices(address[] ofAssets)\n', '        view\n', '        returns (uint[], uint[])\n', '    {\n', '        uint[] memory prices = new uint[](ofAssets.length);\n', '        uint[] memory timestamps = new uint[](ofAssets.length);\n', '        for (uint i; i < ofAssets.length; i++) {\n', '            var (price, timestamp) = getPrice(ofAssets[i]);\n', '            prices[i] = price;\n', '            timestamps[i] = timestamp;\n', '        }\n', '        return (prices, timestamps);\n', '    }\n', '\n', '    // INTERNAL METHODS\n', '\n', '    /// @dev Internal so that feeds inheriting this one are not obligated to have an exposed update(...) method, but can still perform updates\n', '    function _updatePrices(address[] ofAssets, uint[] newPrices)\n', '        internal\n', '        pre_cond(ofAssets.length == newPrices.length)\n', '    {\n', '        updateId++;\n', '        for (uint i = 0; i < ofAssets.length; ++i) {\n', '            require(registrar.assetIsRegistered(ofAssets[i]));\n', '            require(assetsToPrices[ofAssets[i]].timestamp != now); // prevent two updates in one block\n', '            assetsToPrices[ofAssets[i]].timestamp = now;\n', '            assetsToPrices[ofAssets[i]].price = newPrices[i];\n', '        }\n', '        emit PriceUpdated(keccak256(ofAssets, newPrices));\n', '    }\n', '}\n', '\n', 'contract StakingPriceFeed is SimplePriceFeed {\n', '\n', '    OperatorStaking public stakingContract;\n', '    AssetInterface public stakingToken;\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @param ofQuoteAsset Address of quote asset\n', '    /// @param ofRegistrar Address of canonical registrar\n', '    /// @param ofSuperFeed Address of superfeed\n', '    function StakingPriceFeed(\n', '        address ofRegistrar,\n', '        address ofQuoteAsset,\n', '        address ofSuperFeed\n', '    )\n', '        SimplePriceFeed(ofRegistrar, ofQuoteAsset, ofSuperFeed)\n', '    {\n', '        stakingContract = OperatorStaking(ofSuperFeed); // canonical feed *is* staking contract\n', '        stakingToken = AssetInterface(stakingContract.stakingToken());\n', '    }\n', '\n', '    // EXTERNAL METHODS\n', '\n', '    /// @param amount Number of tokens to stake for this feed\n', '    /// @param data Data may be needed for some future applications (can be empty for now)\n', '    function depositStake(uint amount, bytes data)\n', '        external\n', '        auth\n', '    {\n', '        require(stakingToken.transferFrom(msg.sender, address(this), amount));\n', '        require(stakingToken.approve(stakingContract, amount));\n', '        stakingContract.stake(amount, data);\n', '    }\n', '\n', '    /// @param amount Number of tokens to unstake for this feed\n', '    /// @param data Data may be needed for some future applications (can be empty for now)\n', '    function unstake(uint amount, bytes data) {\n', '        stakingContract.unstake(amount, data);\n', '    }\n', '\n', '    function withdrawStake()\n', '        external\n', '        auth\n', '    {\n', '        uint amountToWithdraw = stakingContract.stakeToWithdraw(address(this));\n', '        stakingContract.withdrawStake();\n', '        require(stakingToken.transfer(msg.sender, amountToWithdraw));\n', '    }\n', '}\n', '\n', 'contract OperatorStaking is DBC {\n', '\n', '    // EVENTS\n', '\n', '    event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\n', '    event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\n', '    event StakeBurned(address indexed user, uint256 amount, bytes data);\n', '\n', '    // TYPES\n', '\n', '    struct StakeData {\n', '        uint amount;\n', '        address staker;\n', '    }\n', '\n', '    // Circular linked list\n', '    struct Node {\n', '        StakeData data;\n', '        uint prev;\n', '        uint next;\n', '    }\n', '\n', '    // FIELDS\n', '\n', '    // INTERNAL FIELDS\n', '    Node[] internal stakeNodes; // Sorted circular linked list nodes containing stake data (Built on top https://programtheblockchain.com/posts/2018/03/30/storage-patterns-doubly-linked-list/)\n', '\n', '    // PUBLIC FIELDS\n', '    uint public minimumStake;\n', '    uint public numOperators;\n', '    uint public withdrawalDelay;\n', '    mapping (address => bool) public isRanked;\n', '    mapping (address => uint) public latestUnstakeTime;\n', '    mapping (address => uint) public stakeToWithdraw;\n', '    mapping (address => uint) public stakedAmounts;\n', '    uint public numStakers; // Current number of stakers (Needed because of array holes)\n', '    AssetInterface public stakingToken;\n', '\n', '    // TODO: consider renaming "operator" depending on how this is implemented\n', '    //  (i.e. is pricefeed staking itself?)\n', '    function OperatorStaking(\n', '        AssetInterface _stakingToken,\n', '        uint _minimumStake,\n', '        uint _numOperators,\n', '        uint _withdrawalDelay\n', '    )\n', '        public\n', '    {\n', '        require(address(_stakingToken) != address(0));\n', '        stakingToken = _stakingToken;\n', '        minimumStake = _minimumStake;\n', '        numOperators = _numOperators;\n', '        withdrawalDelay = _withdrawalDelay;\n', '        StakeData memory temp = StakeData({ amount: 0, staker: address(0) });\n', '        stakeNodes.push(Node(temp, 0, 0));\n', '    }\n', '\n', '    // METHODS : STAKING\n', '\n', '    function stake(\n', '        uint amount,\n', '        bytes data\n', '    )\n', '        public\n', '        pre_cond(amount >= minimumStake)\n', '    {\n', '        uint tailNodeId = stakeNodes[0].prev;\n', '        stakedAmounts[msg.sender] += amount;\n', '        updateStakerRanking(msg.sender);\n', '        require(stakingToken.transferFrom(msg.sender, address(this), amount));\n', '    }\n', '\n', '    function unstake(\n', '        uint amount,\n', '        bytes data\n', '    )\n', '        public\n', '    {\n', '        uint preStake = stakedAmounts[msg.sender];\n', '        uint postStake = preStake - amount;\n', '        require(postStake >= minimumStake || postStake == 0);\n', '        require(stakedAmounts[msg.sender] >= amount);\n', '        latestUnstakeTime[msg.sender] = block.timestamp;\n', '        stakedAmounts[msg.sender] -= amount;\n', '        stakeToWithdraw[msg.sender] += amount;\n', '        updateStakerRanking(msg.sender);\n', '        emit Unstaked(msg.sender, amount, stakedAmounts[msg.sender], data);\n', '    }\n', '\n', '    function withdrawStake()\n', '        public\n', '        pre_cond(stakeToWithdraw[msg.sender] > 0)\n', '        pre_cond(block.timestamp >= latestUnstakeTime[msg.sender] + withdrawalDelay)\n', '    {\n', '        uint amount = stakeToWithdraw[msg.sender];\n', '        stakeToWithdraw[msg.sender] = 0;\n', '        require(stakingToken.transfer(msg.sender, amount));\n', '    }\n', '\n', '    // VIEW FUNCTIONS\n', '\n', '    function isValidNode(uint id) view returns (bool) {\n', '        // 0 is a sentinel and therefore invalid.\n', '        // A valid node is the head or has a previous node.\n', '        return id != 0 && (id == stakeNodes[0].next || stakeNodes[id].prev != 0);\n', '    }\n', '\n', '    function searchNode(address staker) view returns (uint) {\n', '        uint current = stakeNodes[0].next;\n', '        while (isValidNode(current)) {\n', '            if (staker == stakeNodes[current].data.staker) {\n', '                return current;\n', '            }\n', '            current = stakeNodes[current].next;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function isOperator(address user) view returns (bool) {\n', '        address[] memory operators = getOperators();\n', '        for (uint i; i < operators.length; i++) {\n', '            if (operators[i] == user) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function getOperators()\n', '        view\n', '        returns (address[])\n', '    {\n', '        uint arrLength = (numOperators > numStakers) ?\n', '            numStakers :\n', '            numOperators;\n', '        address[] memory operators = new address[](arrLength);\n', '        uint current = stakeNodes[0].next;\n', '        for (uint i; i < arrLength; i++) {\n', '            operators[i] = stakeNodes[current].data.staker;\n', '            current = stakeNodes[current].next;\n', '        }\n', '        return operators;\n', '    }\n', '\n', '    function getStakersAndAmounts()\n', '        view\n', '        returns (address[], uint[])\n', '    {\n', '        address[] memory stakers = new address[](numStakers);\n', '        uint[] memory amounts = new uint[](numStakers);\n', '        uint current = stakeNodes[0].next;\n', '        for (uint i; i < numStakers; i++) {\n', '            stakers[i] = stakeNodes[current].data.staker;\n', '            amounts[i] = stakeNodes[current].data.amount;\n', '            current = stakeNodes[current].next;\n', '        }\n', '        return (stakers, amounts);\n', '    }\n', '\n', '    function totalStakedFor(address user)\n', '        view\n', '        returns (uint)\n', '    {\n', '        return stakedAmounts[user];\n', '    }\n', '\n', '    // INTERNAL METHODS\n', '\n', '    // DOUBLY-LINKED LIST\n', '\n', '    function insertNodeSorted(uint amount, address staker) internal returns (uint) {\n', '        uint current = stakeNodes[0].next;\n', '        if (current == 0) return insertNodeAfter(0, amount, staker);\n', '        while (isValidNode(current)) {\n', '            if (amount > stakeNodes[current].data.amount) {\n', '                break;\n', '            }\n', '            current = stakeNodes[current].next;\n', '        }\n', '        return insertNodeBefore(current, amount, staker);\n', '    }\n', '\n', '    function insertNodeAfter(uint id, uint amount, address staker) internal returns (uint newID) {\n', '\n', '        // 0 is allowed here to insert at the beginning.\n', '        require(id == 0 || isValidNode(id));\n', '\n', '        Node storage node = stakeNodes[id];\n', '\n', '        stakeNodes.push(Node({\n', '            data: StakeData(amount, staker),\n', '            prev: id,\n', '            next: node.next\n', '        }));\n', '\n', '        newID = stakeNodes.length - 1;\n', '\n', '        stakeNodes[node.next].prev = newID;\n', '        node.next = newID;\n', '        numStakers++;\n', '    }\n', '\n', '    function insertNodeBefore(uint id, uint amount, address staker) internal returns (uint) {\n', '        return insertNodeAfter(stakeNodes[id].prev, amount, staker);\n', '    }\n', '\n', '    function removeNode(uint id) internal {\n', '        require(isValidNode(id));\n', '\n', '        Node storage node = stakeNodes[id];\n', '\n', '        stakeNodes[node.next].prev = node.prev;\n', '        stakeNodes[node.prev].next = node.next;\n', '\n', '        delete stakeNodes[id];\n', '        numStakers--;\n', '    }\n', '\n', '    // UPDATING OPERATORS\n', '\n', '    function updateStakerRanking(address _staker) internal {\n', '        uint newStakedAmount = stakedAmounts[_staker];\n', '        if (newStakedAmount == 0) {\n', '            isRanked[_staker] = false;\n', '            removeStakerFromArray(_staker);\n', '        } else if (isRanked[_staker]) {\n', '            removeStakerFromArray(_staker);\n', '            insertNodeSorted(newStakedAmount, _staker);\n', '        } else {\n', '            isRanked[_staker] = true;\n', '            insertNodeSorted(newStakedAmount, _staker);\n', '        }\n', '    }\n', '\n', '    function removeStakerFromArray(address _staker) internal {\n', '        uint id = searchNode(_staker);\n', '        require(id > 0);\n', '        removeNode(id);\n', '    }\n', '\n', '}\n', '\n', 'contract CanonicalPriceFeed is OperatorStaking, SimplePriceFeed, CanonicalRegistrar {\n', '\n', '    // EVENTS\n', '    event SetupPriceFeed(address ofPriceFeed);\n', '\n', '    struct HistoricalPrices {\n', '        address[] assets;\n', '        uint[] prices;\n', '        uint timestamp;\n', '    }\n', '\n', '    // FIELDS\n', '    bool public updatesAreAllowed = true;\n', '    uint public minimumPriceCount = 1;\n', '    uint public VALIDITY;\n', '    uint public INTERVAL;\n', '    mapping (address => bool) public isStakingFeed; // If the Staking Feed has been created through this contract\n', '    HistoricalPrices[] public priceHistory;\n', '\n', '    // METHODS\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @dev Define and register a quote asset against which all prices are measured/based against\n', '    /// @param ofStakingAsset Address of staking asset (may or may not be quoteAsset)\n', '    /// @param ofQuoteAsset Address of quote asset\n', '    /// @param quoteAssetName Name of quote asset\n', '    /// @param quoteAssetSymbol Symbol for quote asset\n', '    /// @param quoteAssetDecimals Decimal places for quote asset\n', '    /// @param quoteAssetUrl URL related to quote asset\n', '    /// @param quoteAssetIpfsHash IPFS hash associated with quote asset\n', '    /// @param quoteAssetBreakInBreakOut Break-in/break-out for quote asset on destination chain\n', '    /// @param quoteAssetStandards EIP standards quote asset adheres to\n', '    /// @param quoteAssetFunctionSignatures Whitelisted functions of quote asset contract\n', '    // /// @param interval Number of seconds between pricefeed updates (this interval is not enforced on-chain, but should be followed by the datafeed maintainer)\n', '    // /// @param validity Number of seconds that datafeed update information is valid for\n', '    /// @param ofGovernance Address of contract governing the Canonical PriceFeed\n', '    function CanonicalPriceFeed(\n', '        address ofStakingAsset,\n', '        address ofQuoteAsset, // Inital entry in asset registrar contract is Melon (QUOTE_ASSET)\n', '        bytes32 quoteAssetName,\n', '        bytes8 quoteAssetSymbol,\n', '        uint quoteAssetDecimals,\n', '        string quoteAssetUrl,\n', '        string quoteAssetIpfsHash,\n', '        address[2] quoteAssetBreakInBreakOut,\n', '        uint[] quoteAssetStandards,\n', '        bytes4[] quoteAssetFunctionSignatures,\n', '        uint[2] updateInfo, // interval, validity\n', '        uint[3] stakingInfo, // minStake, numOperators, unstakeDelay\n', '        address ofGovernance\n', '    )\n', '        OperatorStaking(\n', '            AssetInterface(ofStakingAsset), stakingInfo[0], stakingInfo[1], stakingInfo[2]\n', '        )\n', '        SimplePriceFeed(address(this), ofQuoteAsset, address(0))\n', '    {\n', '        registerAsset(\n', '            ofQuoteAsset,\n', '            quoteAssetName,\n', '            quoteAssetSymbol,\n', '            quoteAssetDecimals,\n', '            quoteAssetUrl,\n', '            quoteAssetIpfsHash,\n', '            quoteAssetBreakInBreakOut,\n', '            quoteAssetStandards,\n', '            quoteAssetFunctionSignatures\n', '        );\n', '        INTERVAL = updateInfo[0];\n', '        VALIDITY = updateInfo[1];\n', '        setOwner(ofGovernance);\n', '    }\n', '\n', '    // EXTERNAL METHODS\n', '\n', '    /// @notice Create a new StakingPriceFeed\n', '    function setupStakingPriceFeed() external {\n', '        address ofStakingPriceFeed = new StakingPriceFeed(\n', '            address(this),\n', '            stakingToken,\n', '            address(this)\n', '        );\n', '        isStakingFeed[ofStakingPriceFeed] = true;\n', '        StakingPriceFeed(ofStakingPriceFeed).setOwner(msg.sender);\n', '        emit SetupPriceFeed(ofStakingPriceFeed);\n', '    }\n', '\n', '    /// @dev override inherited update function to prevent manual update from authority\n', '    function update() external { revert(); }\n', '\n', '    /// @dev Burn state for a pricefeed operator\n', '    /// @param user Address of pricefeed operator to burn the stake from\n', '    function burnStake(address user)\n', '        external\n', '        auth\n', '    {\n', '        uint totalToBurn = add(stakedAmounts[user], stakeToWithdraw[user]);\n', '        stakedAmounts[user] = 0;\n', '        stakeToWithdraw[user] = 0;\n', '        updateStakerRanking(user);\n', '        emit StakeBurned(user, totalToBurn, "");\n', '    }\n', '\n', '    // PUBLIC METHODS\n', '\n', '    // STAKING\n', '\n', '    function stake(\n', '        uint amount,\n', '        bytes data\n', '    )\n', '        public\n', '        pre_cond(isStakingFeed[msg.sender])\n', '    {\n', '        OperatorStaking.stake(amount, data);\n', '    }\n', '\n', '    // function stakeFor(\n', '    //     address user,\n', '    //     uint amount,\n', '    //     bytes data\n', '    // )\n', '    //     public\n', '    //     pre_cond(isStakingFeed[user])\n', '    // {\n', '\n', '    //     OperatorStaking.stakeFor(user, amount, data);\n', '    // }\n', '\n', '    // AGGREGATION\n', '\n', '    /// @dev Only Owner; Same sized input arrays\n', '    /// @dev Updates price of asset relative to QUOTE_ASSET\n', '    /** Ex:\n', '     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\n', '     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\n', '     *  and let EUR-T decimals == 8.\n', '     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\n', '     */\n', '    /// @param ofAssets list of asset addresses\n', '    function collectAndUpdate(address[] ofAssets)\n', '        public\n', '        auth\n', '        pre_cond(updatesAreAllowed)\n', '    {\n', '        uint[] memory newPrices = pricesToCommit(ofAssets);\n', '        priceHistory.push(\n', '            HistoricalPrices({assets: ofAssets, prices: newPrices, timestamp: block.timestamp})\n', '        );\n', '        _updatePrices(ofAssets, newPrices);\n', '    }\n', '\n', '    function pricesToCommit(address[] ofAssets)\n', '        view\n', '        returns (uint[])\n', '    {\n', '        address[] memory operators = getOperators();\n', '        uint[] memory newPrices = new uint[](ofAssets.length);\n', '        for (uint i = 0; i < ofAssets.length; i++) {\n', '            uint[] memory assetPrices = new uint[](operators.length);\n', '            for (uint j = 0; j < operators.length; j++) {\n', '                SimplePriceFeed feed = SimplePriceFeed(operators[j]);\n', '                var (price, timestamp) = feed.assetsToPrices(ofAssets[i]);\n', '                if (now > add(timestamp, VALIDITY)) {\n', '                    continue; // leaves a zero in the array (dealt with later)\n', '                }\n', '                assetPrices[j] = price;\n', '            }\n', '            newPrices[i] = medianize(assetPrices);\n', '        }\n', '        return newPrices;\n', '    }\n', '\n', '    /// @dev from MakerDao medianizer contract\n', '    function medianize(uint[] unsorted)\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint numValidEntries;\n', '        for (uint i = 0; i < unsorted.length; i++) {\n', '            if (unsorted[i] != 0) {\n', '                numValidEntries++;\n', '            }\n', '        }\n', '        if (numValidEntries < minimumPriceCount) {\n', '            revert();\n', '        }\n', '        uint counter;\n', '        uint[] memory out = new uint[](numValidEntries);\n', '        for (uint j = 0; j < unsorted.length; j++) {\n', '            uint item = unsorted[j];\n', '            if (item != 0) {    // skip zero (invalid) entries\n', '                if (counter == 0 || item >= out[counter - 1]) {\n', '                    out[counter] = item;  // item is larger than last in array (we are home)\n', '                } else {\n', '                    uint k = 0;\n', '                    while (item >= out[k]) {\n', '                        k++;  // get to where element belongs (between smaller and larger items)\n', '                    }\n', '                    for (uint l = counter; l > k; l--) {\n', '                        out[l] = out[l - 1];    // bump larger elements rightward to leave slot\n', '                    }\n', '                    out[k] = item;\n', '                }\n', '                counter++;\n', '            }\n', '        }\n', '\n', '        uint value;\n', '        if (counter % 2 == 0) {\n', '            uint value1 = uint(out[(counter / 2) - 1]);\n', '            uint value2 = uint(out[(counter / 2)]);\n', '            value = add(value1, value2) / 2;\n', '        } else {\n', '            value = out[(counter - 1) / 2];\n', '        }\n', '        return value;\n', '    }\n', '\n', '    function setMinimumPriceCount(uint newCount) auth { minimumPriceCount = newCount; }\n', '    function enableUpdates() auth { updatesAreAllowed = true; }\n', '    function disableUpdates() auth { updatesAreAllowed = false; }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    // FEED INFORMATION\n', '\n', '    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\n', '    function getInterval() view returns (uint) { return INTERVAL; }\n', '    function getValidity() view returns (uint) { return VALIDITY; }\n', '    function getLastUpdateId() view returns (uint) { return updateId; }\n', '\n', '    // PRICES\n', '\n', '    /// @notice Whether price of asset has been updated less than VALIDITY seconds ago\n', '    /// @param ofAsset Asset in registrar\n', '    /// @return isRecent Price information ofAsset is recent\n', '    function hasRecentPrice(address ofAsset)\n', '        view\n', '        pre_cond(assetIsRegistered(ofAsset))\n', '        returns (bool isRecent)\n', '    {\n', '        var ( , timestamp) = getPrice(ofAsset);\n', '        return (sub(now, timestamp) <= VALIDITY);\n', '    }\n', '\n', '    /// @notice Whether prices of assets have been updated less than VALIDITY seconds ago\n', '    /// @param ofAssets All assets in registrar\n', '    /// @return isRecent Price information ofAssets array is recent\n', '    function hasRecentPrices(address[] ofAssets)\n', '        view\n', '        returns (bool areRecent)\n', '    {\n', '        for (uint i; i < ofAssets.length; i++) {\n', '            if (!hasRecentPrice(ofAssets[i])) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function getPriceInfo(address ofAsset)\n', '        view\n', '        returns (bool isRecent, uint price, uint assetDecimals)\n', '    {\n', '        isRecent = hasRecentPrice(ofAsset);\n', '        (price, ) = getPrice(ofAsset);\n', '        assetDecimals = getDecimals(ofAsset);\n', '    }\n', '\n', '    /**\n', '    @notice Gets inverted price of an asset\n', '    @dev Asset has been initialised and its price is non-zero\n', '    @dev Existing price ofAssets quoted in QUOTE_ASSET (convention)\n', '    @param ofAsset Asset for which inverted price should be return\n', '    @return {\n', '        "isRecent": "Whether the price is fresh, given VALIDITY interval",\n', '        "invertedPrice": "Price based (instead of quoted) against QUOTE_ASSET",\n', '        "assetDecimals": "Decimal places for this asset"\n', '    }\n', '    */\n', '    function getInvertedPriceInfo(address ofAsset)\n', '        view\n', '        returns (bool isRecent, uint invertedPrice, uint assetDecimals)\n', '    {\n', '        uint inputPrice;\n', '        // inputPrice quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\n', '        (isRecent, inputPrice, assetDecimals) = getPriceInfo(ofAsset);\n', '\n', '        // outputPrice based in QUOTE_ASSET and multiplied by 10 ** quoteDecimal\n', '        uint quoteDecimals = getDecimals(QUOTE_ASSET);\n', '\n', '        return (\n', '            isRecent,\n', '            mul(10 ** uint(quoteDecimals), 10 ** uint(assetDecimals)) / inputPrice,\n', '            quoteDecimals   // TODO: check on this; shouldn&#39;t it be assetDecimals?\n', '        );\n', '    }\n', '\n', '    /**\n', '    @notice Gets reference price of an asset pair\n', '    @dev One of the address is equal to quote asset\n', '    @dev either ofBase == QUOTE_ASSET or ofQuote == QUOTE_ASSET\n', '    @param ofBase Address of base asset\n', '    @param ofQuote Address of quote asset\n', '    @return {\n', '        "isRecent": "Whether the price is fresh, given VALIDITY interval",\n', '        "referencePrice": "Reference price",\n', '        "decimal": "Decimal places for this asset"\n', '    }\n', '    */\n', '    function getReferencePriceInfo(address ofBase, address ofQuote)\n', '        view\n', '        returns (bool isRecent, uint referencePrice, uint decimal)\n', '    {\n', '        if (getQuoteAsset() == ofQuote) {\n', '            (isRecent, referencePrice, decimal) = getPriceInfo(ofBase);\n', '        } else if (getQuoteAsset() == ofBase) {\n', '            (isRecent, referencePrice, decimal) = getInvertedPriceInfo(ofQuote);\n', '        } else {\n', '            revert(); // no suitable reference price available\n', '        }\n', '    }\n', '\n', '    /// @notice Gets price of Order\n', '    /// @param sellAsset Address of the asset to be sold\n', '    /// @param buyAsset Address of the asset to be bought\n', '    /// @param sellQuantity Quantity in base units being sold of sellAsset\n', '    /// @param buyQuantity Quantity in base units being bought of buyAsset\n', '    /// @return orderPrice Price as determined by an order\n', '    function getOrderPriceInfo(\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    )\n', '        view\n', '        returns (uint orderPrice)\n', '    {\n', '        return mul(buyQuantity, 10 ** uint(getDecimals(sellAsset))) / sellQuantity;\n', '    }\n', '\n', '    /// @notice Checks whether data exists for a given asset pair\n', '    /// @dev Prices are only upated against QUOTE_ASSET\n', '    /// @param sellAsset Asset for which check to be done if data exists\n', '    /// @param buyAsset Asset for which check to be done if data exists\n', '    /// @return Whether assets exist for given asset pair\n', '    function existsPriceOnAssetPair(address sellAsset, address buyAsset)\n', '        view\n', '        returns (bool isExistent)\n', '    {\n', '        return\n', '            hasRecentPrice(sellAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\n', '            hasRecentPrice(buyAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\n', '            (buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET) && // One asset must be QUOTE_ASSET\n', '            (buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET); // Pair must consists of diffrent assets\n', '    }\n', '\n', '    /// @return Sparse array of addresses of owned pricefeeds\n', '    function getPriceFeedsByOwner(address _owner)\n', '        view\n', '        returns(address[])\n', '    {\n', '        address[] memory ofPriceFeeds = new address[](numStakers);\n', '        if (numStakers == 0) return ofPriceFeeds;\n', '        uint current = stakeNodes[0].next;\n', '        for (uint i; i < numStakers; i++) {\n', '            StakingPriceFeed stakingFeed = StakingPriceFeed(stakeNodes[current].data.staker);\n', '            if (stakingFeed.owner() == _owner) {\n', '                ofPriceFeeds[i] = address(stakingFeed);\n', '            }\n', '            current = stakeNodes[current].next;\n', '        }\n', '        return ofPriceFeeds;\n', '    }\n', '\n', '    function getHistoryLength() returns (uint) { return priceHistory.length; }\n', '\n', '    function getHistoryAt(uint id) returns (address[], uint[], uint) {\n', '        address[] memory assets = priceHistory[id].assets;\n', '        uint[] memory prices = priceHistory[id].prices;\n', '        uint timestamp = priceHistory[id].timestamp;\n', '        return (assets, prices, timestamp);\n', '    }\n', '}\n', '\n', 'interface VersionInterface {\n', '\n', '    // EVENTS\n', '\n', '    event FundUpdated(uint id);\n', '\n', '    // PUBLIC METHODS\n', '\n', '    function shutDown() external;\n', '\n', '    function setupFund(\n', '        bytes32 ofFundName,\n', '        address ofQuoteAsset,\n', '        uint ofManagementFee,\n', '        uint ofPerformanceFee,\n', '        address ofCompliance,\n', '        address ofRiskMgmt,\n', '        address[] ofExchanges,\n', '        address[] ofDefaultAssets,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    );\n', '    function shutDownFund(address ofFund);\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    function getNativeAsset() view returns (address);\n', '    function getFundById(uint withId) view returns (address);\n', '    function getLastFundId() view returns (uint);\n', '    function getFundByManager(address ofManager) view returns (address);\n', '    function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed);\n', '\n', '}']