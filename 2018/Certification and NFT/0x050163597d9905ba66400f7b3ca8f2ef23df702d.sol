['pragma solidity ^0.4.19;\n', '\n', 'interface ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * Owned Contract\n', ' *\n', ' * This is a contract trait to inherit from. Contracts that inherit from Owned\n', ' * are able to modify functions to be only callable by the owner of the\n', ' * contract.\n', ' *\n', ' * By default it is impossible to change the owner of the contract.\n', ' */\n', 'contract Owned {\n', '  /**\n', '   * Contract owner.\n', '   *\n', '   * This value is set at contract creation time.\n', '   */\n', '  address owner;\n', '\n', '  /**\n', '   * Contract constructor.\n', '   *\n', '   * This sets the owner of the Owned contract at the time of contract\n', '   * creation.\n', '   */\n', '  function Owned() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * Modify method to only allow the owner to call it.\n', '   */\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '}\n', '\n', '/**\n', ' * Chi Token Sale Contract with revenue sharing\n', ' *\n', ' * The intention of this contract is to run until the total value of 2000 ETH\n', ' * is sold out. There is no time limit placed on the contract.\n', ' *\n', ' * The total number of CHI tokens allocated to the contract is equal to the\n', ' * maximum number of tokens that can be acquired. This maximum number is\n', ' * calculating the purchase of 2000 ETH of tokens, and adding the bonus tokens\n', ' * for that purchase.\n', ' *\n', ' * The bonus tiers thresholds are calculated using the absolute number of sold\n', ' * tokens (by this contract), and are as follows:\n', ' *  - the 1st 150.000 tokens (0 - 149.999) get a bonus of 75%;\n', ' *  - the 2nd 150.000 tokens (150.000 - 299.999) get a bonus of 60%;\n', ' *  - the 3rd 150.000 tokens (300.000 - 449.999) get a bonus of 50%;\n', ' *  - the 4th 150.000 tokens (450.000 - 599.999) get a bonus of 40%;\n', ' *  - the 5th 150.000 tokens (600.000 - 749.999) get a bonus of 30%;\n', ' *  - the 6th 150.000 tokens (750.000 - 899.999) get a bonus of 20%;\n', ' *  - the next 300.000 tokens (900.000 - 1.199.999) get a bonus of 10%;\n', ' *  - the next 300.000 tokens (1.200.000 - 1.499.999) get a bonus of 5%; and\n', ' *  - the next 500.000 tokens (1.500.000 - 1.999.999) get a bonus of 2%.\n', ' *\n', ' * The maximum number of tokens this contract is able to hand out, can be\n', ' * calculated using the following Python code:\n', ' *  https://pyfiddle.io/fiddle/9bbc870a-534e-47b1-87c3-5f000bdd7d74/\n', ' */\n', 'contract ChiSale is Owned {\n', '    // For simplicity reasons, all values are calculated using uint256. Both\n', '    // values could technically be reduced to a lower bit value: percentage\n', '    // fits in `uint8`, and threshold fits within `uint64`. This contract is\n', '    // not optimized for storage and does not use bit packing to store multiple\n', '    // smaller `uint` values in a single larger `uint`.\n', '    struct BonusTier {\n', '        uint256 percentage;\n', '        uint256 threshold;\n', '    }\n', '\n', '    // The list of bonus tiers is set at contract construction and does not\n', '    // mutate.\n', '    BonusTier[] private bonusTiers;\n', '\n', '    // The number of sold tokens is to keep track of the active bonus tier. The\n', '    // number is updated every time a purchase is made.\n', '    uint256 private tokensSold;\n', '\n', '    // The bonus index is always up-to-date with the latest bonus tier. It is\n', '    // automatically updated when a new threshold is hit.\n', '    uint8 private bonusIndex;\n', '\n', '    // The maximum bonus threshold indicated the threshold of the final bonus\n', '    // tier. This is also the maximum number of tokens a buyer is able to\n', '    // purchase.\n', '    uint256 private maxBonusThreshold;\n', '\n', '    // The price per CHI token is constant, and equal to the value determined\n', '    // by the Aethian Crystal Bank: 0.001 ether per CHI, which is equal to 1\n', '    // ether for 1000 CHI.\n', '    uint256 private constant TOKEN_PRICE = 0.001 ether;\n', '\n', '    // The revenue share percentage is the percentage that the referrer of the\n', '    // buyer receives, after the buyer makes a purchase using their address as\n', '    // referral address. The referral address is the address that receives the\n', '    // revenue share percentage.\n', '    uint256 private constant REVENUE_SHARE_PERCENTAGE = 22;\n', '\n', '    // The CHI token contract implements ERC-20.\n', '    ERC20 private chiContract;\n', '\n', '    // Log the CHI purchase event. The purchase events are filterable by buyer\n', '    // and referrer to allow for quick look-ups for specific users.\n', '    event LogChiPurchase(\n', '        address indexed buyer,\n', '        address indexed referrer,\n', '        uint256 number,\n', '        uint256 timestamp\n', '    );\n', '\n', '    /**\n', '     * CHI Sale contract constructor\n', '     *\n', '     * The CHI contract address and bonus numbers are passed in dynamically\n', '     * to allow for testing using different Ethereum networks and different\n', '     * bonus numbers.\n', '     */\n', '    function ChiSale(\n', '        address chiAddress,\n', '        uint256[] bonusThresholds,\n', '        uint256[] bonusPercentages\n', '    )\n', '        public\n', '        Owned()\n', '    {\n', '        // Explicitly check the lengths of the bonus percentage and threshold\n', '        // arrays to prevent human error. This does not prevent the creator\n', '        // from inputting the wrong numbers, however.\n', '        require(bonusThresholds.length == bonusPercentages.length);\n', '\n', '        // Explicitly check that the number of bonus tiers is less than 256, as\n', '        // it should fit within the 8 bit unsigned integer value that is used\n', '        // as the index counter.\n', '        require(bonusThresholds.length < 256);\n', '\n', '        // Loop through one array, whilst simultaneously reading data from the\n', '        // other array. This is possible because both arrays are of the same\n', '        // length, as checked in the line above.\n', '        for (uint8 i = 0; i < bonusThresholds.length; i++) {\n', '\n', '            // Guard against human error, by checking that the new bonus\n', '            // threshold is always a higher value than the previous threshold.\n', '            if (i > 0) {\n', '                require(bonusThresholds[i] > bonusThresholds[i - 1]);\n', '            }\n', '\n', '            // It is already guaranteed that bonus thresholds are in ascending\n', '            // order. For this reason, the maximum bonus threshold can be set\n', '            // by selecting the final value in the bonus thresholds array.\n', '            if (i > bonusThresholds.length - 1) {\n', '                maxBonusThreshold = bonusThresholds[i];\n', '            }\n', '\n', '            bonusTiers.push(BonusTier({\n', '                percentage: bonusPercentages[i],\n', '                threshold: bonusThresholds[i]\n', '            }));\n', '        }\n', '\n', '        // The CHI token contract address is passed as argument to allow for\n', '        // easier testing on the development and testing networks.\n', '        chiContract = ERC20(chiAddress);\n', '\n', '        // The default value of an unsigned integer is already zero, however,\n', '        // for verbosity and readability purposes, both counters are explicitly\n', '        // set to zero.\n', '        tokensSold = 0;\n', '        bonusIndex = 0;\n', '    }\n', '\n', '    function buy(address referralAddress) external payable {\n', '        // Calculate the number of tokens to buy. This can be 0, if the buyer\n', '        // sends an ether value that is less than the price indicated by\n', '        // `TOKEN_PRICE`.\n', '        uint256 tokensToBuy = msg.value / TOKEN_PRICE;\n', '\n', '        // Get the current CHI token balance of this contract. If this number\n', '        // is zero, no more tokens can will be sold.\n', '        uint256 tokenBalance = chiContract.balanceOf(address(this));\n', '\n', '        // A buyer can send more than the required amount for buying a number\n', '        // of tokens. In this case the remainder is calculated, that will be\n', '        // sent back at the end of the transaction.\n', '        uint256 remainder = msg.value % TOKEN_PRICE;\n', '\n', '        // Explicitly guard against the scenario wherein human error occurs,\n', '        // and fewer tokens have been transferred to the contract than dictated\n', '        // by the bonus tiers. This situation can still be resolved at a later\n', '        // date by calling `resetMaxBonusThreshold`.\n', '        if (maxBonusThreshold < tokenBalance) {\n', '            maxBonusThreshold = tokenBalance;\n', '        }\n', '\n', '        // A scenario is possible wherein a buyer attempts to buy more tokens\n', '        // than the contract is offering. In this case the purchase is limited\n', '        // to the available number of tokens.\n', '        if (tokensToBuy > maxBonusThreshold) {\n', '            tokensToBuy = maxBonusThreshold;\n', '\n', '            // The actual number of tokens that can be bought is multiplied by\n', '            // the token price to calculate the actual purchase price of the\n', '            // transaction. This is then subtracted from the total value of\n', '            // ether sent in the transaction to end up with the remainder that\n', '            // will be sent back to the buyer.\n', '            remainder = msg.value - tokensToBuy * TOKEN_PRICE;\n', '        }\n', '\n', '        // The sale contract has a bonus structure. The number of bonus tokens\n', '        // is calculated in a different method. This method will always return\n', '        // a number (of bonus tokens) without error; this number can be zero.\n', '        uint256 bonusTokens = calculateBonusTokens(tokensToBuy);\n', '\n', '        // Update the number of tokens sold. This number does not include the\n', '        // number of bonus tokens that were given out, only the number of\n', '        // tokens that were &#39;bought&#39;.\n', '        tokensSold += tokensToBuy;\n', '\n', '        // Guard against transfers where the contract attempts to transfer more\n', '        // CHI tokens than it has available. In reality, this can never occur\n', '        // as the proper amount of tokens should have been deposited within the\n', '        // contract in accordance to the number calculated by the Python script\n', '        // linked above. This is simply a guard against human error.\n', '        if (tokenBalance < tokensToBuy + bonusTokens) {\n', '            chiContract.transfer(msg.sender, tokenBalance);\n', '        } else {\n', '            chiContract.transfer(msg.sender, tokensToBuy + bonusTokens);\n', '        }\n', '\n', '        // The referral address has a default value set to the contract address\n', '        // of this CHI sale contract in the web application. The application\n', '        // changes this value to a different referral address if a special link\n', '        // is followed. If the referral address does not equal this contract&#39;s\n', '        // address, the revenue share percentage is paid out to that address.\n', '        if (referralAddress != address(this) && referralAddress != address(0)) {\n', '\n', '            // The value `msg.value * REVENUE_SHARE_PERCENTAGE / 100` is always\n', '            // guaranteed to be a valid number (i.e. accepted by the `transfer`\n', '            // method). The value cannot overflow as the maximum number of Wei\n', '            // in `msg.value` fits in 128 bits. Multiplying this number by\n', '            // `REVENUE_SHARE_PERCENTAGE` still safely fits within the current\n', '            // 256 bit range. The value is sent using `send` to make sure the\n', '            // purchase does not fail if someone uses an invalid address.\n', '            referralAddress.send(\n', '                msg.value * REVENUE_SHARE_PERCENTAGE / 100\n', '            );\n', '        }\n', '\n', '        // In the case where a buyer sent in too much ether, or there weren&#39;t\n', '        // enough tokens available, the remaining ether is sent back to the\n', '        // buyer.\n', '        if (remainder > 0) {\n', '            msg.sender.transfer(remainder);\n', '        }\n', '\n', '        LogChiPurchase(msg.sender, referralAddress, tokensToBuy, now);\n', '    }\n', '\n', '    /**\n', '     * Reset the maximum bonus threshold to the correct value.\n', '     *\n', '     * This number is lowered if the contract has fewer tokens available than\n', '     * indicated by the maximum bonus threshold. In this case, the correct\n', '     * number of tokens should be deposited before calling this method to\n', '     * restore the numbers.\n', '     */\n', '    function resetMaxBonusThreshold() external onlyOwner {\n', '        maxBonusThreshold = bonusTiers[bonusTiers.length - 1].threshold;\n', '    }\n', '\n', '    /**\n', '     * Withdraw all ether from the contract.\n', '     *\n', '     * This withdrawal is separate from the CHI withdrawal method to allow for\n', '     * intermittent withdrawals as the contract has no set time period to run\n', '     * for.\n', '     */\n', '    function withdrawEther() external onlyOwner {\n', '        // The transfer method cannot fail with the current given input, as a\n', '        // transfer of 0 Wei is also a valid transfer call.\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '    /**\n', '     * Withdraw remaining CHI from the contract.\n', '     *\n', '     * The intent of this method is to retrieve the remaining bonus tokens\n', '     * after the sale has concluded successfully, but not all bonus tokens have\n', '     * been handed out (due to rounding).\n', '     */\n', '    function withdrawChi() external onlyOwner {\n', '        // This CHI transfer cannot fail as the available balance is first\n', '        // retrieved from the CHI token contract. The deterministic nature of\n', '        // the Ethereum blockchain guarantees that no other operations occur\n', '        // in between the balance retrieval call and the transfer call.\n', '        chiContract.transfer(msg.sender, chiContract.balanceOf(address(this)));\n', '    }\n', '\n', '    /**\n', '     * Get the number of bonus tiers.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The number of bonus tiers in the sale contract.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method returns a 256 bit unsigned integer because that is the\n', '     * return type of the `length` method on arrays. Type casting it would be\n', '     * a needless gas cost.\n', '     */\n', '    function getBonusTierCount() external view returns (uint256) {\n', '        return bonusTiers.length;\n', '    }\n', '\n', '    /**\n', '     * Get bonus percentage and threshold of a given bonus tier.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * bonusTierIndex : uint8\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The first 256 bit unsigned integer is the bonus percentage of the\n', '     *     given bonus tier.\n', '     * uint256\n', '     *     The second 256 bit unsigned integer is the bonus threshold of the\n', '     *     given bonus tier.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Both percentage and threshold are 256 bit unsigned integers, even though\n', '     * they technically respectively fit within an 8 bit unsigned integer and\n', '     * a 64 bit unsigned integer. For simplicity purposes, they are kept as 256\n', '     * bit values.\n', '     */\n', '    function getBonusTier(\n', '        uint8 bonusTierIndex\n', '    )\n', '        external\n', '        view\n', '        returns (uint256, uint256)\n', '    {\n', '        return (\n', '            bonusTiers[bonusTierIndex].percentage,\n', '            bonusTiers[bonusTierIndex].threshold\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Get bonus percentage and threshold of the current bonus tier.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The first 256 bit unsigned integer is the bonus percentage of the\n', '     *     current bonus tier.\n', '     * uint256\n', '     *     The second 256 bit unsigned integer is the bonus threshold of the\n', '     *     current bonus tier.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Both percentage and threshold are 256 bit unsigned integers, even though\n', '     * they technically respectively fit within an 8 bit unsigned integer and\n', '     * a 64 bit unsigned integer. For simplicity purposes, they are kept as 256\n', '     * bit values.\n', '     */\n', '    function getCurrentBonusTier()\n', '        external\n', '        view\n', '        returns (uint256 percentage, uint256 threshold)\n', '    {\n', '        return (\n', '            bonusTiers[bonusIndex].percentage,\n', '            bonusTiers[bonusIndex].threshold\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Get the next bonus tier index.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint8\n', '     *     The index of the next bonus tier.\n', '     */\n', '    function getNextBonusIndex()\n', '        external\n', '        view\n', '        returns (uint8)\n', '    {\n', '        return bonusIndex + 1;\n', '    }\n', '\n', '    /**\n', '     * Get the number of sold tokens.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The number of sold tokens.\n', '     */\n', '    function getSoldTokens() external view returns (uint256) {\n', '        return tokensSold;\n', '    }\n', '\n', '    /**\n', '     * Calculate the number of bonus tokens to send the buyer.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * boughtTokens : uint256\n', '     *     The number of tokens the buyer has bought, and to calculate the\n', '     *     number of bonus tokens of.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The number of bonus tokens to send the buyer.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method modifies contract state by incrementing the bonus tier index\n', '     * whenever a bonus tier is completely exhausted. This is done for\n', '     * simplicity purposes. A different approach would have been to move the\n', '     * loop to a different segment of the contract.\n', '     */\n', '    function calculateBonusTokens(\n', '        uint256 boughtTokens\n', '    )\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        // Immediate return if all bonus tokens have already been handed out.\n', '        if (bonusIndex == bonusTiers.length) {\n', '            return 0;\n', '        }\n', '\n', '        // The number of bonus tokens always starts at zero. If the buyer does\n', '        // not hit any of the bonus thresholds, or if the buyer buys a low\n', '        // number of tokens that causes the bonus to round down to zero, this\n', '        // zero value is returned.\n', '        uint256 bonusTokens = 0;\n', '\n', '        // Copy the number of bought tokens to an `lvalue` to allow mutation.\n', '        uint256 _boughtTokens = boughtTokens;\n', '\n', '        // Copy the number of sold tokens to an `lvalue` to allow mutation.\n', '        uint256 _tokensSold = tokensSold;\n', '\n', '        while (_boughtTokens > 0) {\n', '            uint256 threshold = bonusTiers[bonusIndex].threshold;\n', '            uint256 bonus = bonusTiers[bonusIndex].percentage;\n', '\n', '            // There are two possible scenarios for the active bonus tier:\n', '            //  1: the buyer purchases equal or more CHI tokens than available\n', '            //     in the current bonus tier; and\n', '            //  2: the buyer purchases less CHI tokens than available in the\n', '            //     current bonus tier.\n', '            if (_tokensSold + _boughtTokens >= threshold) {\n', '                // The number of remaining tokens within the threshold is equal\n', '                // to the threshold minus the number of tokens that have been\n', '                // sold already.\n', '                _boughtTokens -= threshold - _tokensSold;\n', '\n', '                // The number of bonus tokens is equal to the remaining number\n', '                // of tokens in the bonus tier multiplied by the bonus tier&#39;s\n', '                // percentage. A different bonus will be calculated for the\n', '                // remaining bought tokens. The number is first multiplied by\n', '                // the bonus percentage to work to the advantage of the buyer,\n', '                // as the minimum number of tokens that need to be bought for a\n', '                // bonus to be counted would be equal to `100 / bonus` (rounded\n', '                // down), in comparison to requiring a minimum of 100 tokens in\n', '                // the other case.\n', '                bonusTokens += (threshold - _tokensSold) * bonus / 100;\n', '\n', '                // The number of sold tokens is &#39;normally&#39; incremented by the\n', '                // number of tokens that have been bought (in that bonus tier).\n', '                // However, when all remaining tokens in a bonus tier are\n', '                // purchased, the resulting operation looks as follows:\n', '                //  _tokensSold = _tokensSold + (threshold - _tokensSold)\n', '                // which can be simplified to the current operation.\n', '                _tokensSold = threshold;\n', '\n', '                // If the bonus tier limit has not been reached, the bonus\n', '                // index is incremented, because all tokens in the current\n', '                // bonus tier have been sold.\n', '                if (bonusIndex < bonusTiers.length) {\n', '                    bonusIndex += 1;\n', '                }\n', '            } else {\n', '\n', '                // In the case where the number of bought tokens does not hit\n', '                // the bonus threshold. No bonus changes have to be made, and\n', '                // the number of sold tokens can be incremented by the bought\n', '                // number of tokens.\n', '                _tokensSold += _boughtTokens;\n', '\n', '                // The number of bonus tokens is equal to the number of bought\n', '                // tokens multiplied by the bonus factor of the active bonus\n', '                // tier.\n', '                bonusTokens += _boughtTokens * bonus / 100;\n', '\n', '                // Reset the bought tokens to zero.\n', '                _boughtTokens = 0;\n', '            }\n', '        }\n', '\n', '        return bonusTokens;\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'interface ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * Owned Contract\n', ' *\n', ' * This is a contract trait to inherit from. Contracts that inherit from Owned\n', ' * are able to modify functions to be only callable by the owner of the\n', ' * contract.\n', ' *\n', ' * By default it is impossible to change the owner of the contract.\n', ' */\n', 'contract Owned {\n', '  /**\n', '   * Contract owner.\n', '   *\n', '   * This value is set at contract creation time.\n', '   */\n', '  address owner;\n', '\n', '  /**\n', '   * Contract constructor.\n', '   *\n', '   * This sets the owner of the Owned contract at the time of contract\n', '   * creation.\n', '   */\n', '  function Owned() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * Modify method to only allow the owner to call it.\n', '   */\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '}\n', '\n', '/**\n', ' * Chi Token Sale Contract with revenue sharing\n', ' *\n', ' * The intention of this contract is to run until the total value of 2000 ETH\n', ' * is sold out. There is no time limit placed on the contract.\n', ' *\n', ' * The total number of CHI tokens allocated to the contract is equal to the\n', ' * maximum number of tokens that can be acquired. This maximum number is\n', ' * calculating the purchase of 2000 ETH of tokens, and adding the bonus tokens\n', ' * for that purchase.\n', ' *\n', ' * The bonus tiers thresholds are calculated using the absolute number of sold\n', ' * tokens (by this contract), and are as follows:\n', ' *  - the 1st 150.000 tokens (0 - 149.999) get a bonus of 75%;\n', ' *  - the 2nd 150.000 tokens (150.000 - 299.999) get a bonus of 60%;\n', ' *  - the 3rd 150.000 tokens (300.000 - 449.999) get a bonus of 50%;\n', ' *  - the 4th 150.000 tokens (450.000 - 599.999) get a bonus of 40%;\n', ' *  - the 5th 150.000 tokens (600.000 - 749.999) get a bonus of 30%;\n', ' *  - the 6th 150.000 tokens (750.000 - 899.999) get a bonus of 20%;\n', ' *  - the next 300.000 tokens (900.000 - 1.199.999) get a bonus of 10%;\n', ' *  - the next 300.000 tokens (1.200.000 - 1.499.999) get a bonus of 5%; and\n', ' *  - the next 500.000 tokens (1.500.000 - 1.999.999) get a bonus of 2%.\n', ' *\n', ' * The maximum number of tokens this contract is able to hand out, can be\n', ' * calculated using the following Python code:\n', ' *  https://pyfiddle.io/fiddle/9bbc870a-534e-47b1-87c3-5f000bdd7d74/\n', ' */\n', 'contract ChiSale is Owned {\n', '    // For simplicity reasons, all values are calculated using uint256. Both\n', '    // values could technically be reduced to a lower bit value: percentage\n', '    // fits in `uint8`, and threshold fits within `uint64`. This contract is\n', '    // not optimized for storage and does not use bit packing to store multiple\n', '    // smaller `uint` values in a single larger `uint`.\n', '    struct BonusTier {\n', '        uint256 percentage;\n', '        uint256 threshold;\n', '    }\n', '\n', '    // The list of bonus tiers is set at contract construction and does not\n', '    // mutate.\n', '    BonusTier[] private bonusTiers;\n', '\n', '    // The number of sold tokens is to keep track of the active bonus tier. The\n', '    // number is updated every time a purchase is made.\n', '    uint256 private tokensSold;\n', '\n', '    // The bonus index is always up-to-date with the latest bonus tier. It is\n', '    // automatically updated when a new threshold is hit.\n', '    uint8 private bonusIndex;\n', '\n', '    // The maximum bonus threshold indicated the threshold of the final bonus\n', '    // tier. This is also the maximum number of tokens a buyer is able to\n', '    // purchase.\n', '    uint256 private maxBonusThreshold;\n', '\n', '    // The price per CHI token is constant, and equal to the value determined\n', '    // by the Aethian Crystal Bank: 0.001 ether per CHI, which is equal to 1\n', '    // ether for 1000 CHI.\n', '    uint256 private constant TOKEN_PRICE = 0.001 ether;\n', '\n', '    // The revenue share percentage is the percentage that the referrer of the\n', '    // buyer receives, after the buyer makes a purchase using their address as\n', '    // referral address. The referral address is the address that receives the\n', '    // revenue share percentage.\n', '    uint256 private constant REVENUE_SHARE_PERCENTAGE = 22;\n', '\n', '    // The CHI token contract implements ERC-20.\n', '    ERC20 private chiContract;\n', '\n', '    // Log the CHI purchase event. The purchase events are filterable by buyer\n', '    // and referrer to allow for quick look-ups for specific users.\n', '    event LogChiPurchase(\n', '        address indexed buyer,\n', '        address indexed referrer,\n', '        uint256 number,\n', '        uint256 timestamp\n', '    );\n', '\n', '    /**\n', '     * CHI Sale contract constructor\n', '     *\n', '     * The CHI contract address and bonus numbers are passed in dynamically\n', '     * to allow for testing using different Ethereum networks and different\n', '     * bonus numbers.\n', '     */\n', '    function ChiSale(\n', '        address chiAddress,\n', '        uint256[] bonusThresholds,\n', '        uint256[] bonusPercentages\n', '    )\n', '        public\n', '        Owned()\n', '    {\n', '        // Explicitly check the lengths of the bonus percentage and threshold\n', '        // arrays to prevent human error. This does not prevent the creator\n', '        // from inputting the wrong numbers, however.\n', '        require(bonusThresholds.length == bonusPercentages.length);\n', '\n', '        // Explicitly check that the number of bonus tiers is less than 256, as\n', '        // it should fit within the 8 bit unsigned integer value that is used\n', '        // as the index counter.\n', '        require(bonusThresholds.length < 256);\n', '\n', '        // Loop through one array, whilst simultaneously reading data from the\n', '        // other array. This is possible because both arrays are of the same\n', '        // length, as checked in the line above.\n', '        for (uint8 i = 0; i < bonusThresholds.length; i++) {\n', '\n', '            // Guard against human error, by checking that the new bonus\n', '            // threshold is always a higher value than the previous threshold.\n', '            if (i > 0) {\n', '                require(bonusThresholds[i] > bonusThresholds[i - 1]);\n', '            }\n', '\n', '            // It is already guaranteed that bonus thresholds are in ascending\n', '            // order. For this reason, the maximum bonus threshold can be set\n', '            // by selecting the final value in the bonus thresholds array.\n', '            if (i > bonusThresholds.length - 1) {\n', '                maxBonusThreshold = bonusThresholds[i];\n', '            }\n', '\n', '            bonusTiers.push(BonusTier({\n', '                percentage: bonusPercentages[i],\n', '                threshold: bonusThresholds[i]\n', '            }));\n', '        }\n', '\n', '        // The CHI token contract address is passed as argument to allow for\n', '        // easier testing on the development and testing networks.\n', '        chiContract = ERC20(chiAddress);\n', '\n', '        // The default value of an unsigned integer is already zero, however,\n', '        // for verbosity and readability purposes, both counters are explicitly\n', '        // set to zero.\n', '        tokensSold = 0;\n', '        bonusIndex = 0;\n', '    }\n', '\n', '    function buy(address referralAddress) external payable {\n', '        // Calculate the number of tokens to buy. This can be 0, if the buyer\n', '        // sends an ether value that is less than the price indicated by\n', '        // `TOKEN_PRICE`.\n', '        uint256 tokensToBuy = msg.value / TOKEN_PRICE;\n', '\n', '        // Get the current CHI token balance of this contract. If this number\n', '        // is zero, no more tokens can will be sold.\n', '        uint256 tokenBalance = chiContract.balanceOf(address(this));\n', '\n', '        // A buyer can send more than the required amount for buying a number\n', '        // of tokens. In this case the remainder is calculated, that will be\n', '        // sent back at the end of the transaction.\n', '        uint256 remainder = msg.value % TOKEN_PRICE;\n', '\n', '        // Explicitly guard against the scenario wherein human error occurs,\n', '        // and fewer tokens have been transferred to the contract than dictated\n', '        // by the bonus tiers. This situation can still be resolved at a later\n', '        // date by calling `resetMaxBonusThreshold`.\n', '        if (maxBonusThreshold < tokenBalance) {\n', '            maxBonusThreshold = tokenBalance;\n', '        }\n', '\n', '        // A scenario is possible wherein a buyer attempts to buy more tokens\n', '        // than the contract is offering. In this case the purchase is limited\n', '        // to the available number of tokens.\n', '        if (tokensToBuy > maxBonusThreshold) {\n', '            tokensToBuy = maxBonusThreshold;\n', '\n', '            // The actual number of tokens that can be bought is multiplied by\n', '            // the token price to calculate the actual purchase price of the\n', '            // transaction. This is then subtracted from the total value of\n', '            // ether sent in the transaction to end up with the remainder that\n', '            // will be sent back to the buyer.\n', '            remainder = msg.value - tokensToBuy * TOKEN_PRICE;\n', '        }\n', '\n', '        // The sale contract has a bonus structure. The number of bonus tokens\n', '        // is calculated in a different method. This method will always return\n', '        // a number (of bonus tokens) without error; this number can be zero.\n', '        uint256 bonusTokens = calculateBonusTokens(tokensToBuy);\n', '\n', '        // Update the number of tokens sold. This number does not include the\n', '        // number of bonus tokens that were given out, only the number of\n', "        // tokens that were 'bought'.\n", '        tokensSold += tokensToBuy;\n', '\n', '        // Guard against transfers where the contract attempts to transfer more\n', '        // CHI tokens than it has available. In reality, this can never occur\n', '        // as the proper amount of tokens should have been deposited within the\n', '        // contract in accordance to the number calculated by the Python script\n', '        // linked above. This is simply a guard against human error.\n', '        if (tokenBalance < tokensToBuy + bonusTokens) {\n', '            chiContract.transfer(msg.sender, tokenBalance);\n', '        } else {\n', '            chiContract.transfer(msg.sender, tokensToBuy + bonusTokens);\n', '        }\n', '\n', '        // The referral address has a default value set to the contract address\n', '        // of this CHI sale contract in the web application. The application\n', '        // changes this value to a different referral address if a special link\n', "        // is followed. If the referral address does not equal this contract's\n", '        // address, the revenue share percentage is paid out to that address.\n', '        if (referralAddress != address(this) && referralAddress != address(0)) {\n', '\n', '            // The value `msg.value * REVENUE_SHARE_PERCENTAGE / 100` is always\n', '            // guaranteed to be a valid number (i.e. accepted by the `transfer`\n', '            // method). The value cannot overflow as the maximum number of Wei\n', '            // in `msg.value` fits in 128 bits. Multiplying this number by\n', '            // `REVENUE_SHARE_PERCENTAGE` still safely fits within the current\n', '            // 256 bit range. The value is sent using `send` to make sure the\n', '            // purchase does not fail if someone uses an invalid address.\n', '            referralAddress.send(\n', '                msg.value * REVENUE_SHARE_PERCENTAGE / 100\n', '            );\n', '        }\n', '\n', "        // In the case where a buyer sent in too much ether, or there weren't\n", '        // enough tokens available, the remaining ether is sent back to the\n', '        // buyer.\n', '        if (remainder > 0) {\n', '            msg.sender.transfer(remainder);\n', '        }\n', '\n', '        LogChiPurchase(msg.sender, referralAddress, tokensToBuy, now);\n', '    }\n', '\n', '    /**\n', '     * Reset the maximum bonus threshold to the correct value.\n', '     *\n', '     * This number is lowered if the contract has fewer tokens available than\n', '     * indicated by the maximum bonus threshold. In this case, the correct\n', '     * number of tokens should be deposited before calling this method to\n', '     * restore the numbers.\n', '     */\n', '    function resetMaxBonusThreshold() external onlyOwner {\n', '        maxBonusThreshold = bonusTiers[bonusTiers.length - 1].threshold;\n', '    }\n', '\n', '    /**\n', '     * Withdraw all ether from the contract.\n', '     *\n', '     * This withdrawal is separate from the CHI withdrawal method to allow for\n', '     * intermittent withdrawals as the contract has no set time period to run\n', '     * for.\n', '     */\n', '    function withdrawEther() external onlyOwner {\n', '        // The transfer method cannot fail with the current given input, as a\n', '        // transfer of 0 Wei is also a valid transfer call.\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '    /**\n', '     * Withdraw remaining CHI from the contract.\n', '     *\n', '     * The intent of this method is to retrieve the remaining bonus tokens\n', '     * after the sale has concluded successfully, but not all bonus tokens have\n', '     * been handed out (due to rounding).\n', '     */\n', '    function withdrawChi() external onlyOwner {\n', '        // This CHI transfer cannot fail as the available balance is first\n', '        // retrieved from the CHI token contract. The deterministic nature of\n', '        // the Ethereum blockchain guarantees that no other operations occur\n', '        // in between the balance retrieval call and the transfer call.\n', '        chiContract.transfer(msg.sender, chiContract.balanceOf(address(this)));\n', '    }\n', '\n', '    /**\n', '     * Get the number of bonus tiers.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The number of bonus tiers in the sale contract.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method returns a 256 bit unsigned integer because that is the\n', '     * return type of the `length` method on arrays. Type casting it would be\n', '     * a needless gas cost.\n', '     */\n', '    function getBonusTierCount() external view returns (uint256) {\n', '        return bonusTiers.length;\n', '    }\n', '\n', '    /**\n', '     * Get bonus percentage and threshold of a given bonus tier.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * bonusTierIndex : uint8\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The first 256 bit unsigned integer is the bonus percentage of the\n', '     *     given bonus tier.\n', '     * uint256\n', '     *     The second 256 bit unsigned integer is the bonus threshold of the\n', '     *     given bonus tier.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Both percentage and threshold are 256 bit unsigned integers, even though\n', '     * they technically respectively fit within an 8 bit unsigned integer and\n', '     * a 64 bit unsigned integer. For simplicity purposes, they are kept as 256\n', '     * bit values.\n', '     */\n', '    function getBonusTier(\n', '        uint8 bonusTierIndex\n', '    )\n', '        external\n', '        view\n', '        returns (uint256, uint256)\n', '    {\n', '        return (\n', '            bonusTiers[bonusTierIndex].percentage,\n', '            bonusTiers[bonusTierIndex].threshold\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Get bonus percentage and threshold of the current bonus tier.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The first 256 bit unsigned integer is the bonus percentage of the\n', '     *     current bonus tier.\n', '     * uint256\n', '     *     The second 256 bit unsigned integer is the bonus threshold of the\n', '     *     current bonus tier.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Both percentage and threshold are 256 bit unsigned integers, even though\n', '     * they technically respectively fit within an 8 bit unsigned integer and\n', '     * a 64 bit unsigned integer. For simplicity purposes, they are kept as 256\n', '     * bit values.\n', '     */\n', '    function getCurrentBonusTier()\n', '        external\n', '        view\n', '        returns (uint256 percentage, uint256 threshold)\n', '    {\n', '        return (\n', '            bonusTiers[bonusIndex].percentage,\n', '            bonusTiers[bonusIndex].threshold\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Get the next bonus tier index.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint8\n', '     *     The index of the next bonus tier.\n', '     */\n', '    function getNextBonusIndex()\n', '        external\n', '        view\n', '        returns (uint8)\n', '    {\n', '        return bonusIndex + 1;\n', '    }\n', '\n', '    /**\n', '     * Get the number of sold tokens.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The number of sold tokens.\n', '     */\n', '    function getSoldTokens() external view returns (uint256) {\n', '        return tokensSold;\n', '    }\n', '\n', '    /**\n', '     * Calculate the number of bonus tokens to send the buyer.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * boughtTokens : uint256\n', '     *     The number of tokens the buyer has bought, and to calculate the\n', '     *     number of bonus tokens of.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The number of bonus tokens to send the buyer.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method modifies contract state by incrementing the bonus tier index\n', '     * whenever a bonus tier is completely exhausted. This is done for\n', '     * simplicity purposes. A different approach would have been to move the\n', '     * loop to a different segment of the contract.\n', '     */\n', '    function calculateBonusTokens(\n', '        uint256 boughtTokens\n', '    )\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        // Immediate return if all bonus tokens have already been handed out.\n', '        if (bonusIndex == bonusTiers.length) {\n', '            return 0;\n', '        }\n', '\n', '        // The number of bonus tokens always starts at zero. If the buyer does\n', '        // not hit any of the bonus thresholds, or if the buyer buys a low\n', '        // number of tokens that causes the bonus to round down to zero, this\n', '        // zero value is returned.\n', '        uint256 bonusTokens = 0;\n', '\n', '        // Copy the number of bought tokens to an `lvalue` to allow mutation.\n', '        uint256 _boughtTokens = boughtTokens;\n', '\n', '        // Copy the number of sold tokens to an `lvalue` to allow mutation.\n', '        uint256 _tokensSold = tokensSold;\n', '\n', '        while (_boughtTokens > 0) {\n', '            uint256 threshold = bonusTiers[bonusIndex].threshold;\n', '            uint256 bonus = bonusTiers[bonusIndex].percentage;\n', '\n', '            // There are two possible scenarios for the active bonus tier:\n', '            //  1: the buyer purchases equal or more CHI tokens than available\n', '            //     in the current bonus tier; and\n', '            //  2: the buyer purchases less CHI tokens than available in the\n', '            //     current bonus tier.\n', '            if (_tokensSold + _boughtTokens >= threshold) {\n', '                // The number of remaining tokens within the threshold is equal\n', '                // to the threshold minus the number of tokens that have been\n', '                // sold already.\n', '                _boughtTokens -= threshold - _tokensSold;\n', '\n', '                // The number of bonus tokens is equal to the remaining number\n', "                // of tokens in the bonus tier multiplied by the bonus tier's\n", '                // percentage. A different bonus will be calculated for the\n', '                // remaining bought tokens. The number is first multiplied by\n', '                // the bonus percentage to work to the advantage of the buyer,\n', '                // as the minimum number of tokens that need to be bought for a\n', '                // bonus to be counted would be equal to `100 / bonus` (rounded\n', '                // down), in comparison to requiring a minimum of 100 tokens in\n', '                // the other case.\n', '                bonusTokens += (threshold - _tokensSold) * bonus / 100;\n', '\n', "                // The number of sold tokens is 'normally' incremented by the\n", '                // number of tokens that have been bought (in that bonus tier).\n', '                // However, when all remaining tokens in a bonus tier are\n', '                // purchased, the resulting operation looks as follows:\n', '                //  _tokensSold = _tokensSold + (threshold - _tokensSold)\n', '                // which can be simplified to the current operation.\n', '                _tokensSold = threshold;\n', '\n', '                // If the bonus tier limit has not been reached, the bonus\n', '                // index is incremented, because all tokens in the current\n', '                // bonus tier have been sold.\n', '                if (bonusIndex < bonusTiers.length) {\n', '                    bonusIndex += 1;\n', '                }\n', '            } else {\n', '\n', '                // In the case where the number of bought tokens does not hit\n', '                // the bonus threshold. No bonus changes have to be made, and\n', '                // the number of sold tokens can be incremented by the bought\n', '                // number of tokens.\n', '                _tokensSold += _boughtTokens;\n', '\n', '                // The number of bonus tokens is equal to the number of bought\n', '                // tokens multiplied by the bonus factor of the active bonus\n', '                // tier.\n', '                bonusTokens += _boughtTokens * bonus / 100;\n', '\n', '                // Reset the bought tokens to zero.\n', '                _boughtTokens = 0;\n', '            }\n', '        }\n', '\n', '        return bonusTokens;\n', '    }\n', '}']
