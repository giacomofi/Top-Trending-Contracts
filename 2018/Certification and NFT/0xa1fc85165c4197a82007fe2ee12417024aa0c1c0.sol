['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract LavaWalletInterface {\n', '\n', '  function depositTokens(address from, address token, uint256 tokens ) public returns (bool success);\n', '  function withdrawTokens(address token, uint256 tokens) public returns (bool success);\n', '  function withdrawTokensFrom( address from, address to,address token,  uint tokens) public returns (bool success);\n', '  function balanceOf(address token,address user) public constant returns (uint);\n', '  function approveTokens(address spender, address token, uint tokens) public returns (bool success);\n', '  function transferTokens(address to, address token, uint tokens) public returns (bool success);\n', '  function transferTokensFrom( address from, address to,address token,  uint tokens) public returns (bool success);\n', '  function getLavaTypedDataHash(bytes methodname, address from, address to, address token, uint256 tokens, uint256 relayerReward,\n', '                                    uint256 expires, uint256 nonce) public constant returns (bytes32);\n', '  function approveTokensWithSignature(address from, address to, address token, uint256 tokens, uint256 relayerReward,\n', '                                    uint256 expires, uint256 nonce, bytes signature) public returns (bool success);\n', '  function transferTokensFromWithSignature(address from, address to,  address token, uint256 tokens,  uint256 relayerReward,\n', '                                    uint256 expires, uint256 nonce, bytes signature) public returns (bool success);\n', '  function withdrawTokensFromWithSignature(address from, address to,  address token, uint256 tokens,  uint256 relayerReward,\n', '                                    uint256 expires, uint256 nonce, bytes signature) public returns (bool success);\n', '  function tokenAllowance(address token, address tokenOwner, address spender) public constant returns (uint remaining);\n', '  function burnSignature(bytes methodname, address from, address to, address token, uint256 tokens, uint256 relayerReward,\n', '                                    uint256 expires, uint256 nonce,  bytes signature) public returns (bool success);\n', '  function signatureBurnStatus(bytes32 digest) public view returns (uint);\n', '  function approveAndCall(bytes methodname, address from, address to, address token, uint256 tokens, uint256 relayerReward,\n', '                                    uint256 expires, uint256 nonce, bytes signature ) public returns (bool success);\n', '\n', '  event Deposit(address token, address user, uint amount, uint balance);\n', '  event Withdraw(address token, address user, uint amount, uint balance);\n', '  event Transfer(address indexed from, address indexed to,address token, uint tokens);\n', '  event Approval(address indexed tokenOwner, address indexed spender,address token, uint tokens);\n', '\n', '}\n', '\n', 'contract ApproveAndCallFallBack {\n', '\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '\n', '}\n', '\n', '\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '\n', '    address public newOwner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '\n', '    function Owned() public {\n', '\n', '        owner = msg.sender;\n', '\n', '    }\n', '\n', '\n', '    modifier onlyOwner {\n', '\n', '        require(msg.sender == owner);\n', '\n', '        _;\n', '\n', '    }\n', '\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '\n', '        newOwner = _newOwner;\n', '\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '\n', '        require(msg.sender == newOwner);\n', '\n', '        OwnershipTransferred(owner, newOwner);\n', '\n', '        owner = newOwner;\n', '\n', '        newOwner = address(0);\n', '\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract LavaDeposit is Owned {\n', '\n', '\n', '  using SafeMath for uint;\n', '\n', '  // balances[tokenContractAddress][EthereumAccountAddress] = 0\n', '   mapping(address => mapping (address => uint256)) balances;\n', '\n', '\n', '   address public walletContract;\n', '\n', '  event Deposit(address token, address from, address to, uint amount);\n', '\n', '  function LavaDeposit(address wContract) public  {\n', '    walletContract = wContract;\n', '  }\n', '\n', '\n', '  //do not allow ether to enter\n', '  function() public payable {\n', '      revert();\n', '  }\n', '\n', '\n', '   //Remember you need pre-approval for this - nice with ApproveAndCall\n', '  function depositTokensForAccount(address from, address to, address token, uint256 tokens ) public returns (bool success)\n', '  {\n', '      //we already have approval so lets do a transferFrom - transfer the tokens into this contract\n', '\n', '       if(!ERC20Interface(token).transferFrom(from, this, tokens)) revert();\n', '\n', '      //now deposit the tokens into lavawallet and they are still assigned to this contract\n', '       if(!ERC20Interface(token).approve(walletContract, tokens)) revert();\n', '\n', '       if(!LavaWalletInterface(walletContract).depositTokens(this, token, tokens)) revert();\n', '\n', '      //transfer the tokens into the lava balance of the &#39;to&#39; account\n', '       if(!LavaWalletInterface(walletContract).transferTokens(to, token, tokens)) revert();\n', '\n', '       Deposit(token, from, to, tokens);\n', '\n', '      return true;\n', '  }\n', '\n', '       /*\n', '         Receive approval to spend tokens and perform any action all in one transaction\n', '       */\n', '     function receiveApproval(address from, uint256 tokens, address token, bytes data) public returns (bool success) {\n', '\n', '       require(data.length == 20);\n', '\n', '       //find the address from the data\n', '       address to = bytesToAddr(data);\n', '\n', '       return depositTokensForAccount(from, to, token, tokens );\n', '\n', '     }\n', '\n', '     function bytesToAddr (bytes b) constant returns (address) {\n', '      uint result = 0;\n', '      for (uint i = b.length-1; i+1 > 0; i--) {\n', '        uint c = uint(b[i]);\n', '        uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\n', '        result += to_inc;\n', '      }\n', '      return address(result);\n', '    }\n', '\n', '\n', ' // ------------------------------------------------------------------------\n', '\n', ' // Owner can transfer out any accidentally sent ERC20 tokens \n', '\n', ' // ------------------------------------------------------------------------\n', '\n', ' function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '\n', '    //find actual balance of the contract\n', '     uint tokenBalance = ERC20Interface(tokenAddress).balanceOf(this);\n', '\n', '\n', '     if(!ERC20Interface(tokenAddress).transfer(owner, tokens)) revert();\n', '\n', '\n', '     return true;\n', '\n', ' }\n', '\n', '\n', '\n', '\n', '}']