['/* LeewayHertz - AIG - Investment v0.79 - Pre-Prod\n', '*  Developed and Deployed by LeewayHertz Blockchain Team C - Dhruv Govila, Rajat Singla, Jayesh Chaudhari, Deepak Shokeen, Raghav Gulati, Rohit Tandon\n', '*  Global Repo Name: CA-LHTAIGLenderPlatform\n', '*/\n', '\n', 'contract AIGInvestment {\n', '    uint constant LONG_PHASE = 4;               \n', '    uint constant SHORT_PHASE = 5;              \n', '    uint constant HOUSE_EDGE = 2;               \n', '    uint constant SAFEGUARD_THRESHOLD = 36000;  \n', '    uint constant ARCHIVE_SIZE = 100;           \n', '\n', '    uint public minWager = 500 finney;\n', '    uint public maxNumInterests = 25;\n', '    uint public bankroll = 0;\n', '    int public profit = 0;\n', '\n', '    address public investor;\n', '    uint public investorBankroll = 0;\n', '    int public investorProfit = 0;\n', '    bool public isInvestorLocked = false;\n', '\n', '    struct Interest {\n', '        uint id;\n', '        address borrower;\n', '        uint8 pick;\n', '        bool isMirrored;\n', '        uint wager;\n', '        uint payout;\n', '        uint8 die;\n', '        uint timestamp;\n', '        address lender;\n', '    }\n', '\n', '    struct Generation {\n', '        bytes32 seedHashA;\n', '        bytes32 seedHashB;\n', '        bytes32 seedA;\n', '        bytes32 seedB;\n', '        uint minWager;\n', '        uint maxPayout;\n', '        uint ofage;\n', '        uint death;\n', '        uint beneficiary;\n', '        Interest[] interests;\n', '        bool hasAction;\n', '        Action action;\n', '        int payoutId;\n', '    }\n', '\n', '    uint public oldestGen = 0;\n', '    uint public nextGen = 0;\n', '    mapping (uint => Generation) generations;\n', '\n', '    address public owner;\n', '    address public seedSourceA;\n', '    address public seedSourceB;\n', '\n', '    bytes32 public nextSeedHashA;\n', '    bytes32 public nextSeedHashB;\n', '    bool public hasNextSeedHashA;\n', '    bool public hasNextSeedHashB;\n', '\n', '    uint public outstandingPayouts;\n', '    uint public totalInterests;\n', '\n', '    struct Suitability {\n', '        bool isSuitable;\n', '        uint gen;\n', '    }\n', '\n', '    struct ParserResult {\n', '        bool hasResult;\n', '        uint8 pick;\n', '        bool isMirrored;\n', '        uint8 die;\n', '    }\n', '\n', '    enum ActionType { Withdrawal, InvestorDeposit, InvestorWithdrawal }\n', '\n', '    struct Action {\n', '        ActionType actionType;\n', '        address sender;\n', '        uint amount;\n', '    }\n', '\n', '    modifier onlyowner { if (msg.sender == owner) _; }\n', '    modifier onlyseedsources { if (msg.sender == seedSourceA ||\n', '                                   msg.sender == seedSourceB) _; }\n', '\n', '    event InterestResolved(uint indexed id, uint8 contractDie, bool lenderPrincipals);\n', '\n', '    function AIGInvestment() {\n', '        \n', '    }\n', '\n', '    function numberOfHealthyGenerations() returns (uint n) {\n', '        n = 0;\n', '        for (uint i = oldestGen; i < nextGen; i++) {\n', '            if (generations[i].death == 0) {\n', '                n++;\n', '            }\n', '        }\n', '    }\n', '\n', '    function needsBirth() constant returns (bool needed) {\n', '        return numberOfHealthyGenerations() < 3;\n', '    }\n', '\n', '    function roomForBirth() constant returns (bool hasRoom) {\n', '        return numberOfHealthyGenerations() < 4;\n', '    }\n', '\n', '    function birth(bytes32 freshSeedHash) onlyseedsources {\n', '        if (msg.sender == seedSourceA) {\n', '            nextSeedHashA = freshSeedHash;\n', '            hasNextSeedHashA = true;\n', '        } else {\n', '            nextSeedHashB = freshSeedHash;\n', '            hasNextSeedHashB = true;\n', '        }\n', '\n', '        if (!hasNextSeedHashA || !hasNextSeedHashB || !roomForBirth()) {\n', '            return;\n', '        }\n', '\n', '        \n', '        generations[nextGen].seedHashA = nextSeedHashA;\n', '        generations[nextGen].seedHashB = nextSeedHashB;\n', '        generations[nextGen].minWager = minWager;\n', '        generations[nextGen].maxPayout = (bankroll + investorBankroll) / 100;\n', '        generations[nextGen].ofage = block.number + SHORT_PHASE;\n', '        nextGen += 1;\n', '\n', '        hasNextSeedHashA = false;\n', '        hasNextSeedHashB = false;\n', '    }\n', '\n', '    function parseMsgData(bytes data) internal constant returns (ParserResult) {\n', '        ParserResult memory result;\n', '\n', '        if (data.length != 8) {\n', '            result.hasResult = false;\n', '            return result;\n', '        }\n', '\n', '        \n', '        uint8 start = (uint8(data[0]) - 48) * 10 + (uint8(data[1]) - 48);\n', '        uint8 end = (uint8(data[3]) - 48) * 10 + (uint8(data[4]) - 48);\n', '        uint8 die = (uint8(data[6]) - 48) * 10 + (uint8(data[7]) - 48);\n', '\n', '        if (start == 1) {\n', '            result.hasResult = true;\n', '            result.pick = end + 1;\n', '            result.isMirrored = false;\n', '            result.die = die;\n', '        } else if (end == 20) {\n', '            result.hasResult = true;\n', '            result.pick = start;\n', '            result.isMirrored = true;\n', '            result.die = die;\n', '        } else {\n', '            result.hasResult = false;\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    function _parseMsgData(bytes data) constant returns (bool hasResult,\n', '                                                         uint8 pick,\n', '                                                         bool isMirrored,\n', '                                                         uint8 die) {\n', '        ParserResult memory result = parseMsgData(data);\n', '\n', '        hasResult = result.hasResult;\n', '        pick = result.pick;\n', '        isMirrored = result.isMirrored;\n', '        die = result.die;\n', '    }\n', '\n', '    function () {\n', '        ParserResult memory result = parseMsgData(msg.data);\n', '\n', '        if (result.hasResult) {\n', '            interest(result.pick, result.isMirrored, result.die);\n', '        } else {\n', '            interest(11, true,\n', '                toDie(sha3(block.blockhash(block.number - 1), totalInterests)));\n', '        }\n', '    }\n', '\n', '    function interest(uint8 pick, bool isMirrored, uint8 die) returns (int) {\n', '        if (pick < 2 || pick > 20) {\n', '            msg.sender.send(msg.value);\n', '            return -1;\n', '        }\n', '\n', '        if (die < 1 || die > 20) {\n', '            msg.sender.send(msg.value);\n', '            return -1;\n', '        }\n', '\n', '        Suitability memory suitability = findSuitableGen();\n', '        uint suitableGen = suitability.gen;\n', '\n', '        if (!suitability.isSuitable) {\n', '            msg.sender.send(msg.value);\n', '            return -1;\n', '        }\n', '\n', '        if (msg.value < generations[suitableGen].minWager) {\n', '            msg.sender.send(msg.value);\n', '            return -1;\n', '        }\n', '\n', '        uint payout = calculatePayout(pick, isMirrored, msg.value);\n', '        if (payout > generations[suitableGen].maxPayout) {\n', '            msg.sender.send(msg.value);\n', '            return -1;\n', '        }\n', '\n', '        if (outstandingPayouts + payout > bankroll + investorBankroll) {\n', '            msg.sender.send(msg.value);\n', '            return -1;\n', '        }\n', '\n', '        uint idx = generations[suitableGen].interests.length;\n', '        generations[suitableGen].interests.length += 1;\n', '        generations[suitableGen].interests[idx].id = totalInterests;\n', '        generations[suitableGen].interests[idx].lender = msg.sender;\n', '        generations[suitableGen].interests[idx].pick = pick;\n', '        generations[suitableGen].interests[idx].isMirrored = isMirrored;\n', '        generations[suitableGen].interests[idx].wager = msg.value;\n', '        generations[suitableGen].interests[idx].payout = payout;\n', '        generations[suitableGen].interests[idx].die = die;\n', '        generations[suitableGen].interests[idx].timestamp = now;\n', '\n', '        totalInterests += 1;\n', '        outstandingPayouts += payout;\n', '        becomeMortal(suitableGen);\n', '\n', '        return int(totalInterests - 1);  \n', '    }\n', '\n', '    function calculatePayout(uint8 pick, bool isMirrored,\n', '                             uint value) constant returns (uint) {\n', '        \n', '        \n', '        \n', '        uint numPrincipalningOutcomes;\n', '        if (isMirrored) {\n', '            numPrincipalningOutcomes = 21 - pick;\n', '        } else {\n', '            numPrincipalningOutcomes = pick - 1;\n', '        }\n', '        uint payoutFactor = (100 - HOUSE_EDGE) * (20000 / numPrincipalningOutcomes);\n', '        uint payout = (value * payoutFactor) / 100000;\n', '        return payout;\n', '    }\n', '\n', '    function becomeMortal(uint gen) internal {\n', '        if (generations[gen].death != 0) {\n', '            return;\n', '        }\n', '\n', '        generations[gen].death = block.number + SHORT_PHASE;\n', '    }\n', '\n', '    function isSuitableGen(uint gen, uint offset) constant returns (bool) {\n', '        return block.number + offset >= generations[gen].ofage\n', '               && (generations[gen].death == 0\n', '                   || block.number + offset < generations[gen].death)\n', '               && generations[gen].interests.length < maxNumInterests;\n', '    }\n', '\n', '    function findSuitableGen() internal constant returns (Suitability\n', '                                                          suitability) {\n', '        suitability.isSuitable = false;\n', '        for (uint i = oldestGen; i < nextGen; i++) {\n', '            if (isSuitableGen(i, 0)) {\n', '                suitability.gen = i;\n', '                suitability.isSuitable = true;\n', '                return;\n', '            }\n', '        }\n', '    }\n', '\n', '    function needsbeneficiary(uint offset) constant returns (bool needed) {\n', '        if (oldestGen >= nextGen) {\n', '            return false;\n', '        }\n', '\n', '        return generations[oldestGen].death != 0 &&\n', '               generations[oldestGen].death + LONG_PHASE <= block.number + offset;\n', '    }\n', '\n', '    function beneficiary(bytes32 seed, int payoutId) onlyseedsources {\n', '        if (!needsbeneficiary(0)) {\n', '            return;\n', '        }\n', '\n', '        uint gen = oldestGen;\n', '        if (msg.sender == seedSourceA\n', '                && sha3(seed) == generations[gen].seedHashA) {\n', '            generations[gen].seedA = seed;\n', '        } else if (msg.sender == seedSourceB\n', '                        && sha3(seed) == generations[gen].seedHashB) {\n', '            generations[gen].seedB = seed;\n', '        }\n', '\n', '        if (sha3(generations[gen].seedA) != generations[gen].seedHashA\n', '                || sha3(generations[gen].seedB) != generations[gen].seedHashB) {\n', '            return;\n', '        }\n', '\n', '        \n', '        for (uint i = 0; i < generations[gen].interests.length; i++) {\n', '            uint8 contractDie = toContractDie(generations[gen].seedA,\n', '                                              generations[gen].seedB,\n', '                                              generations[gen].interests[i].id);\n', '            uint8 pick = generations[gen].interests[i].pick;\n', '            bool isMirrored = generations[gen].interests[i].isMirrored;\n', '            uint payout = generations[gen].interests[i].payout;\n', '\n', '            bool lenderPrincipals = interestResolution(contractDie,\n', '                                            generations[gen].interests[i].die,\n', '                                            pick, isMirrored);\n', '            if (lenderPrincipals) {\n', '                generations[gen].interests[i].lender.send(payout);\n', '            }\n', '\n', '            InterestResolved(generations[gen].interests[i].id, contractDie, lenderPrincipals);\n', '            outstandingPayouts -= payout;\n', '\n', '            \n', '            if (investorBankroll >= bankroll) {\n', '                \n', '                uint investorShare = generations[gen].interests[i].wager / 2;\n', '                uint ownerShare = generations[gen].interests[i].wager - investorShare;\n', '\n', '                investorBankroll += investorShare;\n', '                investorProfit += int(investorShare);\n', '                bankroll += ownerShare;\n', '                profit += int(ownerShare);\n', '\n', '                if (lenderPrincipals) {\n', '                    investorShare = payout / 2;\n', '                    ownerShare = payout - investorShare;\n', '                    if (ownerShare > bankroll) {\n', '                        ownerShare = bankroll;\n', '                        investorShare = payout - ownerShare;\n', '                    } else if (investorShare > investorBankroll) {\n', '                        investorShare = investorBankroll;\n', '                        ownerShare = payout - investorShare;\n', '                    }\n', '\n', '                    investorBankroll -= investorShare;\n', '                    investorProfit -= int(investorShare);\n', '                    bankroll -= ownerShare;\n', '                    profit -= int(ownerShare);\n', '                }\n', '            } else {\n', '                bankroll += generations[gen].interests[i].wager;\n', '                profit += int(generations[gen].interests[i].wager);\n', '\n', '                if (lenderPrincipals) {\n', '                    bankroll -= payout;\n', '                    profit -= int(payout);\n', '                }\n', '            }\n', '        }\n', '        performAction(gen);\n', '\n', '        \n', '        generations[gen].beneficiary = block.number;\n', '        generations[gen].payoutId = payoutId;\n', '\n', '        \n', '        oldestGen += 1;\n', '        if (oldestGen >= ARCHIVE_SIZE) {\n', '            delete generations[oldestGen - ARCHIVE_SIZE];\n', '        }\n', '    }\n', '\n', '    function performAction(uint gen) internal {\n', '        if (!generations[gen].hasAction) {\n', '            return;\n', '        }\n', '\n', '        uint amount = generations[gen].action.amount;\n', '        uint maxWithdrawal;\n', '        if (generations[gen].action.actionType == ActionType.Withdrawal) {\n', '            maxWithdrawal = (bankroll + investorBankroll) - outstandingPayouts;\n', '\n', '            if (amount <= maxWithdrawal && amount <= bankroll) {\n', '                owner.send(amount);\n', '                bankroll -= amount;\n', '            }\n', '        } else if (generations[gen].action.actionType ==\n', '                   ActionType.InvestorDeposit) {\n', '            if (investor == 0) {\n', '                investor = generations[gen].action.sender;\n', '                investorBankroll = generations[gen].action.amount;\n', '            } else if (investor == generations[gen].action.sender) {\n', '                investorBankroll += generations[gen].action.amount;\n', '            } else {\n', '                uint investorLoss = 0;\n', '                if (investorProfit < 0) {\n', '                    investorLoss = uint(investorProfit * -1);\n', '                }\n', '\n', '                if (amount > investorBankroll + investorLoss) {\n', '                    \n', '                    \n', '                    investor.send(investorBankroll + investorLoss);\n', '                    investor = generations[gen].action.sender;\n', '                    investorBankroll = amount - investorLoss;\n', '                    investorProfit = 0;\n', '                } else {\n', '                    \n', '                    generations[gen].action.sender.send(amount);\n', '                }\n', '            }\n', '        } else if (generations[gen].action.actionType ==\n', '                   ActionType.InvestorWithdrawal) {\n', '            maxWithdrawal = (bankroll + investorBankroll) - outstandingPayouts;\n', '\n', '            if (amount <= maxWithdrawal && amount <= investorBankroll\n', '                    && investor == generations[gen].action.sender) {\n', '                investor.send(amount);\n', '                investorBankroll -= amount;\n', '            }\n', '        }\n', '    }\n', '\n', '    function emergencybeneficiary() {\n', '        if (generations[oldestGen].death == 0 ||\n', '                block.number - generations[oldestGen].death < SAFEGUARD_THRESHOLD) {\n', '            return;\n', '        }\n', '\n', '        \n', '        for (uint i = 0; i < generations[oldestGen].interests.length; i++) {\n', '            uint wager = generations[oldestGen].interests[i].wager;\n', '            uint payout = generations[oldestGen].interests[i].payout;\n', '\n', '            generations[oldestGen].interests[i].lender.send(wager);\n', '            outstandingPayouts -= payout;\n', '        }\n', '        performAction(oldestGen);\n', '\n', '        generations[oldestGen].beneficiary = block.number;\n', '        generations[oldestGen].payoutId = -1;\n', '\n', '        oldestGen += 1;\n', '        if (oldestGen >= ARCHIVE_SIZE) {\n', '            delete generations[oldestGen - ARCHIVE_SIZE];\n', '        }\n', '    }\n', '\n', '    function beneficiaryAndBirth(bytes32 seed, int payoutId,\n', '                             bytes32 freshSeedHash) onlyseedsources {\n', '        \n', '        beneficiary(seed, payoutId);\n', '        birth(freshSeedHash);\n', '    }\n', '\n', '    function lookupGeneration(uint gen) constant returns (bytes32 seedHashA,\n', '                                                          bytes32 seedHashB,\n', '                                                          bytes32 seedA,\n', '                                                          bytes32 seedB,\n', '                                                          uint minWager,\n', '                                                          uint maxPayout,\n', '                                                          uint ofage,\n', '                                                          uint death,\n', '                                                          uint beneficiary,\n', '                                                          uint numInterests,\n', '                                                          bool hasAction,\n', '                                                          int payoutId) {\n', '        seedHashA = generations[gen].seedHashA;\n', '        seedHashB = generations[gen].seedHashB;\n', '        seedA = generations[gen].seedA;\n', '        seedB = generations[gen].seedB;\n', '        minWager = generations[gen].minWager;\n', '        maxPayout = generations[gen].maxPayout;\n', '        ofage = generations[gen].ofage;\n', '        death = generations[gen].death;\n', '        beneficiary = generations[gen].beneficiary;\n', '        numInterests = generations[gen].interests.length;\n', '        hasAction = generations[gen].hasAction;\n', '        payoutId = generations[gen].payoutId;\n', '    }\n', '\n', '    function lookupInterest(uint gen, uint interest) constant returns (uint id,\n', '                                                             address lender,\n', '                                                             uint8 pick,\n', '                                                             bool isMirrored,\n', '                                                             uint wager,\n', '                                                             uint payout,\n', '                                                             uint8 die,\n', '                                                             uint timestamp) {\n', '        id = generations[gen].interests[interest].id;\n', '        lender = generations[gen].interests[interest].lender;\n', '        pick = generations[gen].interests[interest].pick;\n', '        isMirrored = generations[gen].interests[interest].isMirrored;\n', '        wager = generations[gen].interests[interest].wager;\n', '        payout = generations[gen].interests[interest].payout;\n', '        die = generations[gen].interests[interest].die;\n', '        timestamp = generations[gen].interests[interest].timestamp;\n', '    }\n', '\n', '    function findRecentInterest(address lender) constant returns (int id, uint gen,\n', '                                                             uint interest) {\n', '        for (uint i = nextGen - 1; i >= oldestGen; i--) {\n', '            for (uint j = generations[i].interests.length - 1; j >= 0; j--) {\n', '                if (generations[i].interests[j].lender == lender) {\n', '                    id = int(generations[i].interests[j].id);\n', '                    gen = i;\n', '                    interest = j;\n', '                    return;\n', '                }\n', '            }\n', '        }\n', '\n', '        id = -1;\n', '        return;\n', '    }\n', '\n', '    function toDie(bytes32 data) constant returns (uint8 die) {\n', '        \n', '        \n', '        \n', '        \n', '        \n', '        uint256 FACTOR = 5789604461865809771178549250434395392663499233282028201972879200395656481997;\n', '        return uint8(uint256(data) / FACTOR) + 1;\n', '    }\n', '\n', '    function toContractDie(bytes32 seedA, bytes32 seedB,\n', '                           uint nonce) constant returns (uint8 die) {\n', '        return toDie(sha3(seedA, seedB, nonce));\n', '    }\n', '\n', '    function hash(bytes32 data) constant returns (bytes32 hash) {\n', '        return sha3(data);\n', '    }\n', '\n', '    function combineInterest(uint8 dieA, uint8 dieB) constant returns (uint8 die) {\n', '        die = dieA + dieB;\n', '        if (die > 20) {\n', '            die -= 20;\n', '        }\n', '    }\n', '\n', '    function interestResolution(uint8 contractDie, uint8 lenderDie,\n', '                           uint8 pick, bool isMirrored) constant returns (bool) {\n', '        uint8 die = combineInterest(contractDie, lenderDie);\n', '        return (isMirrored && die >= pick) || (!isMirrored && die < pick);\n', '    }\n', '\n', '    function lowerMinWager(uint _minWager) onlyowner {\n', '        if (_minWager < minWager) {\n', '            minWager = _minWager;\n', '        }\n', '    }\n', '\n', '    function raiseMaxNumInterests(uint _maxNumInterests) onlyowner {\n', '        if (_maxNumInterests > maxNumInterests) {\n', '            maxNumInterests = _maxNumInterests;\n', '        }\n', '    }\n', '\n', '    function setOwner(address _owner) onlyowner {\n', '        owner = _owner;\n', '    }\n', '\n', '    function deposit() onlyowner {\n', '        bankroll += msg.value;\n', '    }\n', '\n', '    function withdraw(uint amount) onlyowner {\n', '        Suitability memory suitability = findSuitableGen();\n', '        uint suitableGen = suitability.gen;\n', '\n', '        if (!suitability.isSuitable) {\n', '            return;\n', '        }\n', '\n', '        if (generations[suitableGen].hasAction) {\n', '            return;\n', '        }\n', '\n', '        generations[suitableGen].action.actionType = ActionType.Withdrawal;\n', '        generations[suitableGen].action.amount = amount;\n', '        generations[suitableGen].hasAction = true;\n', '        becomeMortal(suitableGen);\n', '    }\n', '\n', '    function investorDeposit() {\n', '        if (isInvestorLocked && msg.sender != investor) {\n', '            return;\n', '        }\n', '\n', '        Suitability memory suitability = findSuitableGen();\n', '        uint suitableGen = suitability.gen;\n', '\n', '        if (!suitability.isSuitable) {\n', '            return;\n', '        }\n', '\n', '        if (generations[suitableGen].hasAction) {\n', '            return;\n', '        }\n', '\n', '        generations[suitableGen].action.actionType = ActionType.InvestorDeposit;\n', '        generations[suitableGen].action.sender = msg.sender;\n', '        generations[suitableGen].action.amount = msg.value;\n', '        generations[suitableGen].hasAction = true;\n', '        becomeMortal(suitableGen);\n', '    }\n', '\n', '    function investorWithdraw(uint amount) {\n', '        Suitability memory suitability = findSuitableGen();\n', '        uint suitableGen = suitability.gen;\n', '\n', '        if (!suitability.isSuitable) {\n', '            return;\n', '        }\n', '\n', '        if (generations[suitableGen].hasAction) {\n', '            return;\n', '        }\n', '\n', '        generations[suitableGen].action.actionType = ActionType.InvestorWithdrawal;\n', '        generations[suitableGen].action.sender = msg.sender;\n', '        generations[suitableGen].action.amount = amount;\n', '        generations[suitableGen].hasAction = true;\n', '        becomeMortal(suitableGen);\n', '    }\n', '\n', '    function setInvestorLock(bool _isInvestorLocked) onlyowner {\n', '        isInvestorLocked = _isInvestorLocked;\n', '    }\n', '\n', '    function setSeedSourceA(address _seedSourceA) {\n', '        if (msg.sender == seedSourceA || seedSourceA == 0) {\n', '            seedSourceA = _seedSourceA;\n', '        }\n', '    }\n', '\n', '    function setSeedSourceB(address _seedSourceB) {\n', '        if (msg.sender == seedSourceB || seedSourceB == 0) {\n', '            seedSourceB = _seedSourceB;\n', '        }\n', '    }\n', '}']