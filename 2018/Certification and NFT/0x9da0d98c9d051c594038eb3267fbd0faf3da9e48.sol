['pragma solidity ^0.4.24;\n', '\n', '/*********************************************************************************\n', ' *********************************************************************************\n', ' *\n', ' * Name of the project: JeiCoin Gold Token\n', ' * BiJust\n', ' * Ethernity.live\n', '*\n', ' * v1.5\n', ' *\n', ' *********************************************************************************\n', ' ********************************************************************************/\n', '\n', ' /* ERC20 contract interface */\n', '\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) constant returns (uint256);\n', '    function transfer(address to, uint256 value) returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '// The Token. A TokenWithDates ERC20 token\n', 'contract JeiCoinToken {\n', '\n', '    // Token public variables\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals; \n', '    string public version = &#39;v1.5&#39;;\n', '    uint256 public totalSupply;\n', '    uint public price;\n', '    bool public locked;\n', '    uint multiplier;\n', '\n', '    address public rootAddress;\n', '    address public Owner;\n', '\n', '    mapping(address => uint256) public balances;\n', '    mapping(address => mapping(address => uint256)) public allowed;\n', '    mapping(address => bool) public freezed;\n', '\n', '    mapping(address => uint) public maxIndex; // To store index of last batch: points to the next one\n', '    mapping(address => uint) public minIndex; // To store index of first batch\n', '    mapping(address => mapping(uint => Batch)) public batches; // To store batches with quantities and ages\n', '\n', '    struct Batch {\n', '        uint quant;\n', '        uint age;\n', '    }\n', '\n', '    // ERC20 events\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '\n', '    // Modifiers\n', '\n', '    modifier onlyOwner() {\n', '        if ( msg.sender != rootAddress && msg.sender != Owner ) revert();\n', '        _;\n', '    }\n', '\n', '    modifier onlyRoot() {\n', '        if ( msg.sender != rootAddress ) revert();\n', '        _;\n', '    }\n', '\n', '    modifier isUnlocked() {\n', '    \tif ( locked && msg.sender != rootAddress && msg.sender != Owner ) revert();\n', '\t\t_;    \t\n', '    }\n', '\n', '    modifier isUnfreezed(address _to) {\n', '    \tif ( freezed[msg.sender] || freezed[_to] ) revert();\n', '    \t_;\n', '    }\n', '\n', '    // Safe math\n', '    function safeSub(uint x, uint y) pure internal returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '\n', '    // Token constructor\n', '    constructor(address _root) {        \n', '        locked = false;\n', '        name = &#39;JeiCoin Gold&#39;; \n', '        symbol = &#39;JEIG&#39;; \n', '        decimals = 18; \n', '        multiplier = 10 ** uint(decimals);\n', '        totalSupply = 63000000 * multiplier; // 63,000,000 tokens\n', '        if (_root != 0x0) rootAddress = _root; else rootAddress = msg.sender;  \n', '        Owner = msg.sender;\n', '\n', '        // Asign total supply to the balance and to the first batch\n', '        balances[rootAddress] = totalSupply; \n', '        batches[rootAddress][0].quant = totalSupply;\n', '        batches[rootAddress][0].age = now;\n', '        maxIndex[rootAddress] = 1;\n', '    }\n', '\n', '\n', '    // Only root function\n', '\n', '    function changeRoot(address _newRootAddress) onlyRoot returns(bool){\n', '        rootAddress = _newRootAddress;\n', '        return true;\n', '    }\n', '\n', '    // Only owner functions\n', '\n', '    // To send ERC20 tokens sent accidentally\n', '    function sendToken(address _token,address _to , uint _value) onlyOwner returns(bool) {\n', '        ERC20Basic Token = ERC20Basic(_token);\n', '        require(Token.transfer(_to, _value));\n', '        return true;\n', '    }\n', '\n', '    function changeOwner(address _newOwner) onlyOwner returns(bool) {\n', '        Owner = _newOwner;\n', '        return true;\n', '    }\n', '       \n', '    function unlock() onlyOwner returns(bool) {\n', '        locked = false;\n', '        return true;\n', '    }\n', '\n', '    function lock() onlyOwner returns(bool) {\n', '        locked = true;\n', '        return true;\n', '    }\n', '\n', '    function freeze(address _address) onlyOwner returns(bool) {\n', '        freezed[_address] = true;\n', '        return true;\n', '    }\n', '\n', '    function unfreeze(address _address) onlyOwner returns(bool) {\n', '        freezed[_address] = false;\n', '        return true;\n', '    }\n', '\n', '    function burn(uint256 _value) onlyOwner returns(bool) {\n', '        require (balances[msg.sender] >= _value);\n', '        balances[msg.sender] = balances[msg.sender] - _value;\n', '        totalSupply = safeSub( totalSupply,  _value );\n', '        emit Transfer(msg.sender, 0x0,_value);\n', '        return true;\n', '    }\n', '\n', '    // Public token functions\n', '    // Standard transfer function\n', '    function transfer(address _to, uint _value) isUnlocked public returns (bool success) {\n', '        require(msg.sender != _to);\n', '        if (balances[msg.sender] < _value) return false;\n', '        if (freezed[msg.sender] || freezed[_to]) return false; // Check if destination address is freezed\n', '        balances[msg.sender] = balances[msg.sender] - _value;\n', '        balances[_to] = balances[_to] + _value;\n', '\n', '        updateBatches(msg.sender, _to, _value);\n', '\n', '        emit Transfer(msg.sender,_to,_value);\n', '        return true;\n', '        }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) isUnlocked public returns(bool) {\n', '        require(_from != _to);\n', '        if ( freezed[_from] || freezed[_to] ) return false; // Check if destination address is freezed\n', '        if ( balances[_from] < _value ) return false; // Check if the sender has enough\n', '    \tif ( _value > allowed[_from][msg.sender] ) return false; // Check allowance\n', '\n', '        balances[_from] = balances[_from] - _value; // Subtract from the sender\n', '        balances[_to] = balances[_to] + _value; // Add the same to the recipient\n', '\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\n', '\n', '        updateBatches(_from, _to, _value);\n', '\n', '        emit Transfer(_from,_to,_value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns(bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    // Public getters\n', '\n', '    function isLocked() public view returns(bool) {\n', '        return locked;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns(uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns(uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    // To read batches from external tokens\n', '\n', '    function getBatch(address _address , uint _batch) public view returns(uint _quant,uint _age) {\n', '        return (batches[_address][_batch].quant , batches[_address][_batch].age);\n', '    }\n', '\n', '    function getFirstBatch(address _address) public view returns(uint _quant,uint _age) {\n', '        return (batches[_address][minIndex[_address]].quant , batches[_address][minIndex[_address]].age);\n', '    }\n', '\n', '    // Private function to register quantity and age of batches from sender and receiver (TokenWithDates)\n', '    function updateBatches(address _from,address _to,uint _value) private {\n', '        // Discounting tokens from batches AT SOURCE\n', '        uint count = _value;\n', '        uint i = minIndex[_from];\n', '         while(count > 0) { // To iterate over the mapping. // && i < maxIndex is just a protection from infinite loop, that should not happen anyways\n', '            uint _quant = batches[_from][i].quant;\n', '            if ( count >= _quant ) { // If there is more to send than the batch\n', '                // Empty batch and continue counting\n', '                count -= _quant; // First rest the batch to the count\n', '                batches[_from][i].quant = 0; // Then empty the batch\n', '                minIndex[_from] = i + 1;\n', '                } else { // If this batch is enough to send everything\n', '                    // Empty counter and adjust the batch\n', '                    batches[_from][i].quant -= count; // First adjust the batch, just in case anything rest\n', '                    count = 0; // Then empty the counter and thus stop loop\n', '                    }\n', '            i++;\n', '        } // Closes while loop\n', '\n', '        // Counting tokens for batches AT TARGET\n', '        // Prepare struct\n', '        Batch memory thisBatch;\n', '        thisBatch.quant = _value;\n', '        thisBatch.age = now;\n', '        // Assign batch and move the index\n', '        batches[_to][maxIndex[_to]] = thisBatch;\n', '        maxIndex[_to]++;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/*********************************************************************************\n', ' *********************************************************************************\n', ' *\n', ' * Name of the project: JeiCoin Gold Token\n', ' * BiJust\n', ' * Ethernity.live\n', '*\n', ' * v1.5\n', ' *\n', ' *********************************************************************************\n', ' ********************************************************************************/\n', '\n', ' /* ERC20 contract interface */\n', '\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) constant returns (uint256);\n', '    function transfer(address to, uint256 value) returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '// The Token. A TokenWithDates ERC20 token\n', 'contract JeiCoinToken {\n', '\n', '    // Token public variables\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals; \n', "    string public version = 'v1.5';\n", '    uint256 public totalSupply;\n', '    uint public price;\n', '    bool public locked;\n', '    uint multiplier;\n', '\n', '    address public rootAddress;\n', '    address public Owner;\n', '\n', '    mapping(address => uint256) public balances;\n', '    mapping(address => mapping(address => uint256)) public allowed;\n', '    mapping(address => bool) public freezed;\n', '\n', '    mapping(address => uint) public maxIndex; // To store index of last batch: points to the next one\n', '    mapping(address => uint) public minIndex; // To store index of first batch\n', '    mapping(address => mapping(uint => Batch)) public batches; // To store batches with quantities and ages\n', '\n', '    struct Batch {\n', '        uint quant;\n', '        uint age;\n', '    }\n', '\n', '    // ERC20 events\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '\n', '    // Modifiers\n', '\n', '    modifier onlyOwner() {\n', '        if ( msg.sender != rootAddress && msg.sender != Owner ) revert();\n', '        _;\n', '    }\n', '\n', '    modifier onlyRoot() {\n', '        if ( msg.sender != rootAddress ) revert();\n', '        _;\n', '    }\n', '\n', '    modifier isUnlocked() {\n', '    \tif ( locked && msg.sender != rootAddress && msg.sender != Owner ) revert();\n', '\t\t_;    \t\n', '    }\n', '\n', '    modifier isUnfreezed(address _to) {\n', '    \tif ( freezed[msg.sender] || freezed[_to] ) revert();\n', '    \t_;\n', '    }\n', '\n', '    // Safe math\n', '    function safeSub(uint x, uint y) pure internal returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '\n', '    // Token constructor\n', '    constructor(address _root) {        \n', '        locked = false;\n', "        name = 'JeiCoin Gold'; \n", "        symbol = 'JEIG'; \n", '        decimals = 18; \n', '        multiplier = 10 ** uint(decimals);\n', '        totalSupply = 63000000 * multiplier; // 63,000,000 tokens\n', '        if (_root != 0x0) rootAddress = _root; else rootAddress = msg.sender;  \n', '        Owner = msg.sender;\n', '\n', '        // Asign total supply to the balance and to the first batch\n', '        balances[rootAddress] = totalSupply; \n', '        batches[rootAddress][0].quant = totalSupply;\n', '        batches[rootAddress][0].age = now;\n', '        maxIndex[rootAddress] = 1;\n', '    }\n', '\n', '\n', '    // Only root function\n', '\n', '    function changeRoot(address _newRootAddress) onlyRoot returns(bool){\n', '        rootAddress = _newRootAddress;\n', '        return true;\n', '    }\n', '\n', '    // Only owner functions\n', '\n', '    // To send ERC20 tokens sent accidentally\n', '    function sendToken(address _token,address _to , uint _value) onlyOwner returns(bool) {\n', '        ERC20Basic Token = ERC20Basic(_token);\n', '        require(Token.transfer(_to, _value));\n', '        return true;\n', '    }\n', '\n', '    function changeOwner(address _newOwner) onlyOwner returns(bool) {\n', '        Owner = _newOwner;\n', '        return true;\n', '    }\n', '       \n', '    function unlock() onlyOwner returns(bool) {\n', '        locked = false;\n', '        return true;\n', '    }\n', '\n', '    function lock() onlyOwner returns(bool) {\n', '        locked = true;\n', '        return true;\n', '    }\n', '\n', '    function freeze(address _address) onlyOwner returns(bool) {\n', '        freezed[_address] = true;\n', '        return true;\n', '    }\n', '\n', '    function unfreeze(address _address) onlyOwner returns(bool) {\n', '        freezed[_address] = false;\n', '        return true;\n', '    }\n', '\n', '    function burn(uint256 _value) onlyOwner returns(bool) {\n', '        require (balances[msg.sender] >= _value);\n', '        balances[msg.sender] = balances[msg.sender] - _value;\n', '        totalSupply = safeSub( totalSupply,  _value );\n', '        emit Transfer(msg.sender, 0x0,_value);\n', '        return true;\n', '    }\n', '\n', '    // Public token functions\n', '    // Standard transfer function\n', '    function transfer(address _to, uint _value) isUnlocked public returns (bool success) {\n', '        require(msg.sender != _to);\n', '        if (balances[msg.sender] < _value) return false;\n', '        if (freezed[msg.sender] || freezed[_to]) return false; // Check if destination address is freezed\n', '        balances[msg.sender] = balances[msg.sender] - _value;\n', '        balances[_to] = balances[_to] + _value;\n', '\n', '        updateBatches(msg.sender, _to, _value);\n', '\n', '        emit Transfer(msg.sender,_to,_value);\n', '        return true;\n', '        }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) isUnlocked public returns(bool) {\n', '        require(_from != _to);\n', '        if ( freezed[_from] || freezed[_to] ) return false; // Check if destination address is freezed\n', '        if ( balances[_from] < _value ) return false; // Check if the sender has enough\n', '    \tif ( _value > allowed[_from][msg.sender] ) return false; // Check allowance\n', '\n', '        balances[_from] = balances[_from] - _value; // Subtract from the sender\n', '        balances[_to] = balances[_to] + _value; // Add the same to the recipient\n', '\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\n', '\n', '        updateBatches(_from, _to, _value);\n', '\n', '        emit Transfer(_from,_to,_value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns(bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    // Public getters\n', '\n', '    function isLocked() public view returns(bool) {\n', '        return locked;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns(uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns(uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    // To read batches from external tokens\n', '\n', '    function getBatch(address _address , uint _batch) public view returns(uint _quant,uint _age) {\n', '        return (batches[_address][_batch].quant , batches[_address][_batch].age);\n', '    }\n', '\n', '    function getFirstBatch(address _address) public view returns(uint _quant,uint _age) {\n', '        return (batches[_address][minIndex[_address]].quant , batches[_address][minIndex[_address]].age);\n', '    }\n', '\n', '    // Private function to register quantity and age of batches from sender and receiver (TokenWithDates)\n', '    function updateBatches(address _from,address _to,uint _value) private {\n', '        // Discounting tokens from batches AT SOURCE\n', '        uint count = _value;\n', '        uint i = minIndex[_from];\n', '         while(count > 0) { // To iterate over the mapping. // && i < maxIndex is just a protection from infinite loop, that should not happen anyways\n', '            uint _quant = batches[_from][i].quant;\n', '            if ( count >= _quant ) { // If there is more to send than the batch\n', '                // Empty batch and continue counting\n', '                count -= _quant; // First rest the batch to the count\n', '                batches[_from][i].quant = 0; // Then empty the batch\n', '                minIndex[_from] = i + 1;\n', '                } else { // If this batch is enough to send everything\n', '                    // Empty counter and adjust the batch\n', '                    batches[_from][i].quant -= count; // First adjust the batch, just in case anything rest\n', '                    count = 0; // Then empty the counter and thus stop loop\n', '                    }\n', '            i++;\n', '        } // Closes while loop\n', '\n', '        // Counting tokens for batches AT TARGET\n', '        // Prepare struct\n', '        Batch memory thisBatch;\n', '        thisBatch.quant = _value;\n', '        thisBatch.age = now;\n', '        // Assign batch and move the index\n', '        batches[_to][maxIndex[_to]] = thisBatch;\n', '        maxIndex[_to]++;\n', '    }\n', '\n', '}']
