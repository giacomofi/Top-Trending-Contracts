['pragma solidity ^0.4.21;\n', '\n', '// File: contracts/auth/AuthorizedList.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract AuthorizedList {\n', '\n', '    bytes32 constant APHRODITE = keccak256("Goddess of Love!");\n', '    bytes32 constant CUPID = keccak256("Aphrodite&#39;s Little Helper.");\n', '    bytes32 constant BULKTRANSFER = keccak256("Bulk Transfer User.");\n', '    mapping (address => mapping(bytes32 => bool)) internal authorized;\n', '    mapping (bytes32 => bool) internal contractPermissions;\n', '\n', '}\n', '\n', '// File: contracts/auth/Authorized.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Authorized is AuthorizedList {\n', '\n', '    function Authorized() public {\n', '        /// Set the initial permission for msg.sender (contract creator), it can then add permissions for others\n', '        authorized[msg.sender][APHRODITE] = true;\n', '    }\n', '\n', '    /// Check if _address is authorized to access functionality with _authorization level\n', '    modifier ifAuthorized(address _address, bytes32 _authorization) {\n', '        require(authorized[_address][_authorization] || authorized[_address][APHRODITE]);\n', '        _;\n', '    }\n', '\n', '    /// @dev Check if _address is authorized for _authorization\n', '    function isAuthorized(address _address, bytes32 _authorization) public view returns (bool) {\n', '        return authorized[_address][_authorization];\n', '    }\n', '\n', '    /// @dev Change authorization for _address \n', '    /// @param _address Address whose permission is to be changed\n', '    /// @param _authorization Authority to be changed\n', '    function toggleAuthorization(address _address, bytes32 _authorization) public ifAuthorized(msg.sender, APHRODITE) {\n', '\n', '        /// Prevent inadvertent self locking out, cannot change own authority\n', '        require(_address != msg.sender);\n', '\n', '        /// No need for lower level authorization to linger\n', '        if (_authorization == APHRODITE && !authorized[_address][APHRODITE]) {\n', '            authorized[_address][CUPID] = false;\n', '        }\n', '\n', '        authorized[_address][_authorization] = !authorized[_address][_authorization];\n', '    }\n', '}\n', '\n', '// File: contracts/managed/Pausable.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Pausable is AuthorizedList, Authorized {\n', '\n', '    event Pause();\n', '    event Unpause();\n', '\n', '\n', '    /// @dev We deploy in UNpaused state, should it be paused?\n', '    bool public paused = false;\n', '\n', '    /// Make sure access control is initialized\n', '    function Pausable() public AuthorizedList() Authorized() { }\n', '\n', '\n', '    /// @dev modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '\n', '    /// @dev modifier to allow actions only when the contract is paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '\n', '    /// @dev called by an authorized msg.sender to pause, triggers stopped state\n', '    /// Multiple addresses may be authorized to call this method\n', '    function pause() public whenNotPaused ifAuthorized(msg.sender, CUPID) returns (bool) {\n', '        emit Pause();\n', '        paused = true;\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    /// @dev called by an authorized msg.sender to unpause, returns to normal state\n', '    /// Multiple addresses may be authorized to call this method\n', '    function unpause() public whenPaused ifAuthorized(msg.sender, CUPID) returns (bool) {\n', '        emit Unpause();\n', '        paused = false;\n', '    \n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/math/SafeMath.sol\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /* Not needed\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // require(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // require(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '    */\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts/token/IERC20Basic.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract IERC20Basic {\n', '\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address _who) public view returns (uint256);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '}\n', '\n', '// File: contracts/token/IERC20.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract IERC20 is IERC20Basic {\n', '\n', '    function allowance(address _tokenholder, address _tokenspender) view public returns (uint256);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function approve(address _tokenspender, uint256 _value) public returns (bool);\n', '    event Approval(address indexed _tokenholder, address indexed _tokenspender, uint256 _value);\n', '\n', '}\n', '\n', '// File: contracts/token/RecoverCurrency.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '/// @title Authorized account can reclaim ERC20Basic tokens.\n', 'contract RecoverCurrency is AuthorizedList, Authorized {\n', '\n', '    event EtherRecovered(address indexed _to, uint256 _value);\n', '\n', '    function recoverEther() external ifAuthorized(msg.sender, APHRODITE) {\n', '        msg.sender.transfer(address(this).balance);\n', '        emit EtherRecovered(msg.sender, address(this).balance);\n', '    }\n', '\n', '    /// @dev Reclaim all ERC20Basic compatible tokens\n', '    /// @param _address The address of the token contract\n', '    function recoverToken(address _address) external ifAuthorized(msg.sender, APHRODITE) {\n', '        require(_address != address(0));\n', '        IERC20Basic token = IERC20Basic(_address);\n', '        uint256 balance = token.balanceOf(address(this));\n', '        token.transfer(msg.sender, balance);\n', '    }\n', '}\n', '\n', '// File: contracts/managed/Freezable.sol\n', '\n', '/*\n', ' * Created by Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title Freezable\n', ' * @dev allows authorized accounts to add/remove other accounts to the list of fozen accounts.\n', ' * Accounts in the list cannot transfer and approve and their balances and allowances cannot be retrieved.\n', ' */\n', 'contract Freezable is AuthorizedList, Authorized {\n', '\n', '    event Frozen(address indexed _account);\n', '    event Unfrozen(address indexed _account);\n', '    \n', '    mapping (address => bool) public frozenAccounts;\n', '\n', '    /// Make sure access control is initialized\n', '    function Freezable() public AuthorizedList() Authorized() { }\n', '\n', '    /**\n', '    * @dev Throws if called by any account that&#39;s frozen.\n', '    */\n', '    modifier notFrozen {\n', '        require(!frozenAccounts[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev check if an account is frozen\n', '    * @param account address to check\n', '    * @return true iff the address is in the list of frozen accounts and hasn&#39;t been unfrozen\n', '    */\n', '    function isFrozen(address account) public view returns (bool) {\n', '        return frozenAccounts[account];\n', '    }\n', '\n', '    /**\n', '    * @dev add an address to the list of frozen accounts\n', '    * @param account address to freeze\n', '    * @return true if the address was added to the list of frozen accounts, false if the address was already in the list \n', '    */\n', '    function freezeAccount(address account) public ifAuthorized(msg.sender, APHRODITE) returns (bool success) {\n', '        if (!frozenAccounts[account]) {\n', '            frozenAccounts[account] = true;\n', '            emit Frozen(account);\n', '            success = true; \n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev remove an address from the list of frozen accounts\n', '    * @param account address to unfreeze\n', '    * @return true if the address was removed from the list of frozen accounts, \n', '    * false if the address wasn&#39;t in the list in the first place \n', '    */\n', '    function unfreezeAccount(address account) public ifAuthorized(msg.sender, APHRODITE) returns (bool success) {\n', '        if (frozenAccounts[account]) {\n', '            frozenAccounts[account] = false;\n', '            emit Unfrozen(account);\n', '            success = true;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/storage/AllowancesLedger.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, \n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, \n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE \n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, \n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract AllowancesLedger {\n', '\n', '    mapping (address => mapping (address => uint256)) public allowances;\n', '\n', '}\n', '\n', '// File: contracts/storage/TokenLedger.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract TokenLedger is AuthorizedList, Authorized {\n', '\n', '    mapping(address => uint256) public balances;\n', '    uint256 public totalsupply;\n', '\n', '    struct SeenAddressRecord {\n', '        bool seen;\n', '        uint256 accountArrayIndex;\n', '    }\n', '\n', '    // Iterable accounts\n', '    address[] internal accounts;\n', '    mapping(address => SeenAddressRecord) internal seenBefore;\n', '\n', '    /// @dev Keeping track of addresses in an array is useful as mappings are not iterable\n', '    /// @return Number of addresses holding this token\n', '    function numberAccounts() public view ifAuthorized(msg.sender, APHRODITE) returns (uint256) {\n', '        return accounts.length;\n', '    }\n', '\n', '    /// @dev Keeping track of addresses in an array is useful as mappings are not iterable\n', '    function returnAccounts() public view ifAuthorized(msg.sender, APHRODITE) returns (address[] holders) {\n', '        return accounts;\n', '    }\n', '\n', '    function balanceOf(uint256 _id) public view ifAuthorized(msg.sender, CUPID) returns (uint256 balance) {\n', '        require (_id < accounts.length);\n', '        return balances[accounts[_id]];\n', '    }\n', '}\n', '\n', '// File: contracts/storage/TokenSettings.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract TokenSettings is AuthorizedList, Authorized {\n', '\n', '    /// These strings should be set temporarily for testing on Rinkeby/Ropsten/Kovan to somethin else\n', '    /// to avoid people squatting on names\n', '    /// Change back to "intimate" and "ITM" for mainnet deployment\n', '\n', '    string public name = "intimate";\n', '    string public symbol = "ITM";\n', '\n', '    uint256 public INITIAL_SUPPLY = 100000000 * 10**18;  // 100 million of subdivisible tokens\n', '    uint8 public constant decimals = 18;\n', '\n', '\n', '    /// @dev Change token name\n', '    /// @param _name string\n', '    function setName(string _name) public ifAuthorized(msg.sender, APHRODITE) {\n', '        name = _name;\n', '    }\n', '\n', '    /// @dev Change token symbol\n', '    /// @param _symbol string\n', '    function setSymbol(string _symbol) public ifAuthorized(msg.sender, APHRODITE) {\n', '        symbol = _symbol;\n', '    }\n', '}\n', '\n', '// File: contracts/storage/BasicTokenStorage.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '\n', '\n', '/// Collect all the state variables for the token&#39;s functions into a single contract\n', 'contract BasicTokenStorage is AuthorizedList, Authorized, TokenSettings, AllowancesLedger, TokenLedger {\n', '\n', '    /// @dev Ensure that authorization is set\n', '    function BasicTokenStorage() public Authorized() TokenSettings() AllowancesLedger() TokenLedger() { }\n', '\n', '    /// @dev Keep track of addresses seen before, push new ones into accounts list\n', '    /// @param _tokenholder address to check for "newness"\n', '    function trackAddresses(address _tokenholder) internal {\n', '        if (!seenBefore[_tokenholder].seen) {\n', '            seenBefore[_tokenholder].seen = true;\n', '            accounts.push(_tokenholder);\n', '            seenBefore[_tokenholder].accountArrayIndex = accounts.length - 1;\n', '        }\n', '    }\n', '\n', '    /// @dev remove address from seenBefore and accounts\n', '    /// @param _tokenholder address to remove\n', '    function removeSeenAddress(address _tokenholder) internal {\n', '        uint index = seenBefore[_tokenholder].accountArrayIndex;\n', '        require(index < accounts.length);\n', '\n', '        if (index != accounts.length - 1) {\n', '            accounts[index] = accounts[accounts.length - 1];\n', '        } \n', '        accounts.length--;\n', '        delete seenBefore[_tokenholder];\n', '    }\n', '}\n', '\n', '// File: contracts/token/BasicToken.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract BasicToken is IERC20Basic, BasicTokenStorage, Pausable, Freezable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    event Transfer(address indexed _tokenholder, address indexed _tokenrecipient, uint256 _value);\n', '    event BulkTransfer(address indexed _tokenholder, uint256 _howmany);\n', '\n', '    /// @dev Return the total token supply\n', '    function totalSupply() public view whenNotPaused returns (uint256) {\n', '        return totalsupply;\n', '    }\n', '\n', '    /// @dev transfer token for a specified address\n', '    /// @param _to The address to transfer to.\n', '    /// @param _value The amount to be transferred.\n', '    function transfer(address _to, uint256 _value) public whenNotPaused notFrozen returns (bool) {\n', '\n', '        /// No transfers to 0x0 address, use burn instead, if implemented\n', '        require(_to != address(0));\n', '\n', '        /// No useless operations\n', '        require(msg.sender != _to);\n', '\n', '        /// This will revert if not enough funds\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '\n', '        if (balances[msg.sender] == 0) {\n', '            removeSeenAddress(msg.sender);\n', '        }\n', '\n', '        /// _to might be a completely new address, so check and store if so\n', '        trackAddresses(_to);\n', '\n', '        /// This will revert on overflow\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        /// Emit the Transfer event\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev bulkTransfer tokens to a list of specified addresses, not an ERC20 function\n', '    /// @param _tos The list of addresses to transfer to.\n', '    /// @param _values The list of amounts to be transferred.\n', '    function bulkTransfer(address[] _tos, uint256[] _values) public whenNotPaused notFrozen ifAuthorized(msg.sender, BULKTRANSFER) returns (bool) {\n', '\n', '        require (_tos.length == _values.length);\n', '\n', '        uint256 sourceBalance = balances[msg.sender];\n', '\n', '        /// Temporarily set balance to 0 to mitigate the possibility of re-entrancy attacks\n', '        balances[msg.sender] = 0;\n', '\n', '        for (uint256 i = 0; i < _tos.length; i++) {\n', '            uint256 currentValue = _values[i];\n', '            address _to = _tos[i];\n', '            require(_to != address(0));\n', '            require(currentValue <= sourceBalance);\n', '            require(msg.sender != _to);\n', '\n', '            sourceBalance = sourceBalance.sub(currentValue);\n', '            balances[_to] = balances[_to].add(currentValue);\n', '\n', '            trackAddresses(_to);\n', '\n', '            emit Transfer(msg.sender, _tos[i], currentValue);\n', '        }\n', '\n', '        /// Set to the remaining balance\n', '        balances[msg.sender] = sourceBalance;\n', '\n', '        emit BulkTransfer(msg.sender, _tos.length);\n', '\n', '        if (balances[msg.sender] == 0) {\n', '            removeSeenAddress(msg.sender);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    /// @dev Gets balance of the specified account.\n', '    /// @param _tokenholder Address of interest\n', '    /// @return Balance for the passed address\n', '    function balanceOf(address _tokenholder) public view whenNotPaused returns (uint256 balance) {\n', '        require(!isFrozen(_tokenholder));\n', '        return balances[_tokenholder];\n', '    }\n', '}\n', '\n', '// File: contracts/token/StandardToken.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract StandardToken is IERC20Basic, BasicToken, IERC20 {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    event Approval(address indexed _tokenholder, address indexed _tokenspender, uint256 _value);\n', '\n', '    /// @dev Implements ERC20 transferFrom from one address to another\n', '    /// @param _from The source address  for tokens\n', '    /// @param _to The destination address for tokens\n', '    /// @param _value The number/amount to transfer\n', '    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused notFrozen returns (bool) {\n', '\n', '        // Don&#39;t send tokens to 0x0 address, use burn function that updates totalSupply\n', '        // and don&#39;t waste gas sending tokens to yourself\n', '        require(_to != address(0) && _from != _to);\n', '\n', '        require(!isFrozen(_from) && !isFrozen(_to));\n', '\n', '        /// This will revert if _value is larger than the allowance\n', '        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '\n', '        /// _to might be a completely new address, so check and store if so\n', '        trackAddresses(_to);\n', '\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        /// Emit the Transfer event\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    /// @param _tokenspender The address which will spend the funds.\n', '    /// @param _value The amount of tokens to be spent.\n', '    function approve(address _tokenspender, uint256 _value) public whenNotPaused notFrozen returns (bool) {\n', '\n', '        require(_tokenspender != address(0) && msg.sender != _tokenspender);\n', '\n', '        require(!isFrozen(_tokenspender));\n', '\n', '        /// To mitigate reentrancy race condition, set allowance for _tokenspender to 0\n', '        /// first and then set the new value\n', '        /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_value == 0) || (allowances[msg.sender][_tokenspender] == 0));\n', '\n', '        /// Allow _tokenspender to transfer up to _value in tokens from msg.sender\n', '        allowances[msg.sender][_tokenspender] = _value;\n', '\n', '        /// Emit the Approval event\n', '        emit Approval(msg.sender, _tokenspender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    /// @dev Function to check the amount of tokens that a spender can spend\n', '    /// @param _tokenholder Token owner account address\n', '    /// @param _tokenspender Account address authorized to transfer tokens\n', '    /// @return Amount of tokens still available to _tokenspender to transfer.\n', '    function allowance(address _tokenholder, address _tokenspender) public view whenNotPaused returns (uint256) {\n', '        require(!isFrozen(_tokenholder) && !isFrozen(_tokenspender));\n', '        return allowances[_tokenholder][_tokenspender];\n', '    }\n', '}\n', '\n', '// File: contracts/sales/IntimateShoppe.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * Derived from some public sources and substantially extended/adapted for intimate&#39;s use.\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract IntimateShoppe is Pausable, RecoverCurrency {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /// List of contributors, i.e. msg.sender(s) who has sent in Ether\n', '    address[] internal contributors;\n', '\n', '    /// List of contributions for each contributor\n', '    mapping (address => uint256[]) internal contributions;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    /// @dev event for token purchase logging\n', '    /// @param _seller_wallet_address account that sends tokens\n', '    /// @param _buyer_address who got the tokens in exchange for ether\n', '    /// @param _value weis paid for purchase\n', '    /// @param _amount of tokens purchased\n', '    event ITMTokenPurchase(address indexed _seller_wallet_address, address indexed _buyer_address, uint256 _value, uint256 _amount);\n', '\n', '    /// @dev Starting and ending times for sale period\n', '    event SetPeriod(uint256 _startTime, uint256 _endTime);\n', '\n', '\n', '    /// The ITM token object\n', '    StandardToken public token;\n', '\n', '    /// address of the ITM token\n', '    address public token_address;\n', '\n', '    /// start and end timestamps in between which investments are allowed (both inclusive)\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '\n', '    /// address where funds are collected, it could a simple address or multi-sig wallet contract\n', '    address public wallet_address;\n', '\n', '    /// how many token units a buyer gets per wei\n', '    uint256 public rate = 600;\n', '\n', '    /// upper limit for tokens to be sold in this public offering\n', '    /// NOTE: Since decimals are set at 1e18, if one sets a limit of one(1) ITM, this number should be\n', '    /// 1 * 1e18\n', '    uint256 public capTokens;\n', '\n', '    /// Maxiumum acceptable Ether amount \n', '    uint256 public maxValue = 100 ether;\n', '\n', '    /// Minimum acceptable Ether amount, 1 ITM worth\n', '    uint256 public minValue = uint256(1 ether)/600;\n', '\n', '    /// amount of raised money in wei\n', '    uint256 public weiRaised = 0;\n', '    uint256 public tokensSold = 0;\n', '\n', '    /// High water line for contract balance\n', '    uint256 internal highWater = 1 ether;\n', '\n', '    /// What round it is\n', '    uint8 public round = 0;\n', '\n', '    /// @param _startTime is the absolute time from which to start accepting Ether\n', '    /// @param _duration is the period of time in seconds how long the sale would last, so if a sale lasts 1 month\n', '    /// then the _duration = 30(31)*24*60*60 seconds\n', '    function IntimateShoppe(\n', '        uint256 _startTime, \n', '        uint256 _duration, \n', '        uint256 _rate, \n', '        address _wallet_address, \n', '        address _token_address, \n', '        uint256 _cap,\n', '        uint8 _round) public Authorized() {\n', '\n', '        require(_startTime >= 0 && _duration > 0);\n', '        require(_rate > 0);\n', '        require(_wallet_address != address(0x0));\n', '        require(_token_address != address(0x0));\n', '        require(_cap > 0);\n', '\n', '        round = _round;\n', '\n', '        startTime = _startTime;\n', '        endTime = startTime + _duration;\n', '\n', '        rate = _rate;\n', '        minValue = uint256(1 ether)/_rate;\n', '        capTokens = _cap;\n', '        wallet_address = _wallet_address;\n', '        token_address = _token_address;\n', '        token = StandardToken(token_address);\n', '    }\n', '\n', '    /// @dev Log contributors and their contributions\n', '    /// @param _sender A Contributor&#39;s address\n', '    /// @param _value Amount of Ether said contributor sent\n', '    function trackContributions(address _sender, uint256 _value) internal {\n', '        if (contributions[_sender].length == 0) {\n', '            contributors.push(_sender);\n', '        }\n', '        contributions[_sender].push(_value);\n', '    }\n', '\n', '    /// @dev Retrieve contributors\n', '    /// @return A list of contributors\n', '    function getContributors() external view ifAuthorized(msg.sender, APHRODITE) returns (address[]) {\n', '        return contributors;\n', '    }\n', '\n', '    /// @dev Retrieve contributions by a single contributor \n', '    /// @param _contributor The account associated with contributions\n', '    /// @return A list of ether amounts that _contributor sent in\n', '    /// Using the function above one can get a list first, and then get individual Ether payments\n', '    /// and aggregate them if needed\n', '    function getContributionsForAddress(address _contributor) external view ifAuthorized(msg.sender, APHRODITE) returns (uint256[]) {\n', '        return contributions[_contributor];\n', '    }\n', '\n', '    /// @dev If a sale is done using multiple rounds, allowing for better pricing structure, depending on\n', '    /// on market demand and value of the ITM token. Is also set via the constructor\n', '    /// @param _round Round label/count\n', '    function setRound(uint8 _round) public ifAuthorized(msg.sender, APHRODITE) {\n', '        round = _round;\n', '    }\n', '\n', '    /// @dev Sets the maximum Value in Ether to purchase tokens\n', '    /// @param _maxValue Amount in wei\n', '    function setMaxValue(uint256 _maxValue) public ifAuthorized(msg.sender, APHRODITE) {\n', '        /// Cannot be modified once sale is ongoing\n', '        require(now < startTime || now > endTime);\n', '        maxValue = _maxValue;\n', '    }\n', '\n', '    /// @dev Sets the mininum Value in Ether to purchase tokens\n', '    /// @param _minValue Amount in wei\n', '    function setMinValue(uint256 _minValue) public ifAuthorized(msg.sender, APHRODITE) {\n', '        /// Cannot be modified once sale is ongoing\n', '        require(now < startTime || now > endTime);\n', '        minValue = _minValue;\n', '    }\n', '\n', '\n', '    /// @dev Reset the starting and ending times for the next round\n', '    /// @param _startTime Start of the sale round\n', '    /// @param _duration End of the sale round\n', '    function setTimes(uint256 _startTime, uint256 _duration) public ifAuthorized(msg.sender, APHRODITE) {\n', '        /// Can&#39;t reset times if sale ongoing already, make sure everything else is set before\n', '        require(now < startTime || now > endTime);\n', '\n', '        require(_startTime >= 0 && _duration > 0);\n', '        startTime = _startTime;\n', '        endTime = startTime + _duration;\n', '        emit SetPeriod(startTime, endTime);\n', '    }\n', '\n', '\n', '    /// @dev Set the cap, i.e. how many token units  we will sell in this round\n', '    /// @param _capTokens How many token units are offered in a round\n', '    function setCap(uint256 _capTokens) public ifAuthorized(msg.sender, APHRODITE) {\n', '        /// Cannot be modified once sale is ongoing\n', '        require(now < startTime || now > endTime);\n', '        require(_capTokens > 0);\n', '        capTokens = _capTokens;\n', '    }\n', '\n', '    /// @dev Set the rate, i.e. how many units per wei do we give\n', '    /// @param _rate How many token units are offered for 1 wei, 1 or more.\n', '    function setRate(uint256 _rate) public ifAuthorized(msg.sender, APHRODITE) {\n', '        require(_rate > 0);\n', '        rate = _rate;\n', '    }\n', '\n', '    /// @dev Change the wallet address\n', '    /// @param _wallet_address replacement wallet address\n', '    function changeCompanyWallet(address _wallet_address) public ifAuthorized(msg.sender, APHRODITE) {\n', '        wallet_address = _wallet_address;\n', '    }\n', '\n', '    /// @dev highWater determines at what contract balance Ether is forwarded to wallet_address\n', '    /// @return highWater\n', '    function getHighWater() public view ifAuthorized(msg.sender, APHRODITE) returns (uint256) {\n', '        return highWater;\n', '    }\n', '\n', '    /// @dev Set the high water line/ceiling\n', '    /// @param _highWater Sets the threshold to shift Ether to another address\n', '    function setHighWater(uint256 _highWater) public ifAuthorized(msg.sender, APHRODITE) {\n', '        highWater = _highWater;\n', '    }\n', '\n', '\n', '    /// fallback function used to buy tokens\n', '    function () payable public {\n', '        /// Make certain msg.value sent is within permitted bounds\n', '        require(msg.value >= minValue && msg.value <= maxValue);\n', '        backTokenOwner();\n', '    }\n', '\n', '    /// @dev Main purchase function\n', '    function backTokenOwner() whenNotPaused internal {\n', '\n', '        // Within the current sale period\n', '        require(now >= startTime && now <= endTime);\n', '\n', '        // Transfer Ether from this contract to the company&#39;s or foundation&#39;s wallet_address\n', '\n', '        if (address(this).balance >= highWater) {\n', '            //wallet_address.transfer(msg.value);\n', '            wallet_address.transfer(address(this).balance);\n', '            emit Transfer(this, wallet_address, address(this).balance);\n', '        }\n', '\n', '        /// Keep data about buyers&#39;s addresses and amounts\n', '        /// If this functionality is not wanted, comment out the next line\n', '        trackContributions(msg.sender, msg.value);\n', '\n', '        uint256 tokens = msg.value.mul(rate);\n', '\n', '        /// Transfer purchased tokens to the public buyer\n', '\n', '        /// Note that the address authorized to control the token contract needs to set "wallet_address" allowance\n', '        /// using ERC20 approve function before this contract can transfer tokens.\n', '   \n', '        if (token.transferFrom(wallet_address, msg.sender, tokens)) {\n', '\n', '            token.freezeAccount(msg.sender);\n', '\n', '            weiRaised = weiRaised.add(msg.value);\n', '            tokensSold = tokensSold.add(tokens);\n', '            emit ITMTokenPurchase(wallet_address, msg.sender, msg.value, tokens);\n', '\n', '            // Check the cap and revert if exceeded\n', '            require(tokensSold <= capTokens);\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '// File: contracts/auth/AuthorizedList.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract AuthorizedList {\n', '\n', '    bytes32 constant APHRODITE = keccak256("Goddess of Love!");\n', '    bytes32 constant CUPID = keccak256("Aphrodite\'s Little Helper.");\n', '    bytes32 constant BULKTRANSFER = keccak256("Bulk Transfer User.");\n', '    mapping (address => mapping(bytes32 => bool)) internal authorized;\n', '    mapping (bytes32 => bool) internal contractPermissions;\n', '\n', '}\n', '\n', '// File: contracts/auth/Authorized.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Authorized is AuthorizedList {\n', '\n', '    function Authorized() public {\n', '        /// Set the initial permission for msg.sender (contract creator), it can then add permissions for others\n', '        authorized[msg.sender][APHRODITE] = true;\n', '    }\n', '\n', '    /// Check if _address is authorized to access functionality with _authorization level\n', '    modifier ifAuthorized(address _address, bytes32 _authorization) {\n', '        require(authorized[_address][_authorization] || authorized[_address][APHRODITE]);\n', '        _;\n', '    }\n', '\n', '    /// @dev Check if _address is authorized for _authorization\n', '    function isAuthorized(address _address, bytes32 _authorization) public view returns (bool) {\n', '        return authorized[_address][_authorization];\n', '    }\n', '\n', '    /// @dev Change authorization for _address \n', '    /// @param _address Address whose permission is to be changed\n', '    /// @param _authorization Authority to be changed\n', '    function toggleAuthorization(address _address, bytes32 _authorization) public ifAuthorized(msg.sender, APHRODITE) {\n', '\n', '        /// Prevent inadvertent self locking out, cannot change own authority\n', '        require(_address != msg.sender);\n', '\n', '        /// No need for lower level authorization to linger\n', '        if (_authorization == APHRODITE && !authorized[_address][APHRODITE]) {\n', '            authorized[_address][CUPID] = false;\n', '        }\n', '\n', '        authorized[_address][_authorization] = !authorized[_address][_authorization];\n', '    }\n', '}\n', '\n', '// File: contracts/managed/Pausable.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Pausable is AuthorizedList, Authorized {\n', '\n', '    event Pause();\n', '    event Unpause();\n', '\n', '\n', '    /// @dev We deploy in UNpaused state, should it be paused?\n', '    bool public paused = false;\n', '\n', '    /// Make sure access control is initialized\n', '    function Pausable() public AuthorizedList() Authorized() { }\n', '\n', '\n', '    /// @dev modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '\n', '    /// @dev modifier to allow actions only when the contract is paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '\n', '    /// @dev called by an authorized msg.sender to pause, triggers stopped state\n', '    /// Multiple addresses may be authorized to call this method\n', '    function pause() public whenNotPaused ifAuthorized(msg.sender, CUPID) returns (bool) {\n', '        emit Pause();\n', '        paused = true;\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    /// @dev called by an authorized msg.sender to unpause, returns to normal state\n', '    /// Multiple addresses may be authorized to call this method\n', '    function unpause() public whenPaused ifAuthorized(msg.sender, CUPID) returns (bool) {\n', '        emit Unpause();\n', '        paused = false;\n', '    \n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/math/SafeMath.sol\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /* Not needed\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // require(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // require(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '    */\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts/token/IERC20Basic.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract IERC20Basic {\n', '\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address _who) public view returns (uint256);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '}\n', '\n', '// File: contracts/token/IERC20.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract IERC20 is IERC20Basic {\n', '\n', '    function allowance(address _tokenholder, address _tokenspender) view public returns (uint256);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function approve(address _tokenspender, uint256 _value) public returns (bool);\n', '    event Approval(address indexed _tokenholder, address indexed _tokenspender, uint256 _value);\n', '\n', '}\n', '\n', '// File: contracts/token/RecoverCurrency.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '/// @title Authorized account can reclaim ERC20Basic tokens.\n', 'contract RecoverCurrency is AuthorizedList, Authorized {\n', '\n', '    event EtherRecovered(address indexed _to, uint256 _value);\n', '\n', '    function recoverEther() external ifAuthorized(msg.sender, APHRODITE) {\n', '        msg.sender.transfer(address(this).balance);\n', '        emit EtherRecovered(msg.sender, address(this).balance);\n', '    }\n', '\n', '    /// @dev Reclaim all ERC20Basic compatible tokens\n', '    /// @param _address The address of the token contract\n', '    function recoverToken(address _address) external ifAuthorized(msg.sender, APHRODITE) {\n', '        require(_address != address(0));\n', '        IERC20Basic token = IERC20Basic(_address);\n', '        uint256 balance = token.balanceOf(address(this));\n', '        token.transfer(msg.sender, balance);\n', '    }\n', '}\n', '\n', '// File: contracts/managed/Freezable.sol\n', '\n', '/*\n', ' * Created by Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title Freezable\n', ' * @dev allows authorized accounts to add/remove other accounts to the list of fozen accounts.\n', ' * Accounts in the list cannot transfer and approve and their balances and allowances cannot be retrieved.\n', ' */\n', 'contract Freezable is AuthorizedList, Authorized {\n', '\n', '    event Frozen(address indexed _account);\n', '    event Unfrozen(address indexed _account);\n', '    \n', '    mapping (address => bool) public frozenAccounts;\n', '\n', '    /// Make sure access control is initialized\n', '    function Freezable() public AuthorizedList() Authorized() { }\n', '\n', '    /**\n', "    * @dev Throws if called by any account that's frozen.\n", '    */\n', '    modifier notFrozen {\n', '        require(!frozenAccounts[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev check if an account is frozen\n', '    * @param account address to check\n', "    * @return true iff the address is in the list of frozen accounts and hasn't been unfrozen\n", '    */\n', '    function isFrozen(address account) public view returns (bool) {\n', '        return frozenAccounts[account];\n', '    }\n', '\n', '    /**\n', '    * @dev add an address to the list of frozen accounts\n', '    * @param account address to freeze\n', '    * @return true if the address was added to the list of frozen accounts, false if the address was already in the list \n', '    */\n', '    function freezeAccount(address account) public ifAuthorized(msg.sender, APHRODITE) returns (bool success) {\n', '        if (!frozenAccounts[account]) {\n', '            frozenAccounts[account] = true;\n', '            emit Frozen(account);\n', '            success = true; \n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev remove an address from the list of frozen accounts\n', '    * @param account address to unfreeze\n', '    * @return true if the address was removed from the list of frozen accounts, \n', "    * false if the address wasn't in the list in the first place \n", '    */\n', '    function unfreezeAccount(address account) public ifAuthorized(msg.sender, APHRODITE) returns (bool success) {\n', '        if (frozenAccounts[account]) {\n', '            frozenAccounts[account] = false;\n', '            emit Unfrozen(account);\n', '            success = true;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/storage/AllowancesLedger.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, \n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, \n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE \n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, \n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract AllowancesLedger {\n', '\n', '    mapping (address => mapping (address => uint256)) public allowances;\n', '\n', '}\n', '\n', '// File: contracts/storage/TokenLedger.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract TokenLedger is AuthorizedList, Authorized {\n', '\n', '    mapping(address => uint256) public balances;\n', '    uint256 public totalsupply;\n', '\n', '    struct SeenAddressRecord {\n', '        bool seen;\n', '        uint256 accountArrayIndex;\n', '    }\n', '\n', '    // Iterable accounts\n', '    address[] internal accounts;\n', '    mapping(address => SeenAddressRecord) internal seenBefore;\n', '\n', '    /// @dev Keeping track of addresses in an array is useful as mappings are not iterable\n', '    /// @return Number of addresses holding this token\n', '    function numberAccounts() public view ifAuthorized(msg.sender, APHRODITE) returns (uint256) {\n', '        return accounts.length;\n', '    }\n', '\n', '    /// @dev Keeping track of addresses in an array is useful as mappings are not iterable\n', '    function returnAccounts() public view ifAuthorized(msg.sender, APHRODITE) returns (address[] holders) {\n', '        return accounts;\n', '    }\n', '\n', '    function balanceOf(uint256 _id) public view ifAuthorized(msg.sender, CUPID) returns (uint256 balance) {\n', '        require (_id < accounts.length);\n', '        return balances[accounts[_id]];\n', '    }\n', '}\n', '\n', '// File: contracts/storage/TokenSettings.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', 'contract TokenSettings is AuthorizedList, Authorized {\n', '\n', '    /// These strings should be set temporarily for testing on Rinkeby/Ropsten/Kovan to somethin else\n', '    /// to avoid people squatting on names\n', '    /// Change back to "intimate" and "ITM" for mainnet deployment\n', '\n', '    string public name = "intimate";\n', '    string public symbol = "ITM";\n', '\n', '    uint256 public INITIAL_SUPPLY = 100000000 * 10**18;  // 100 million of subdivisible tokens\n', '    uint8 public constant decimals = 18;\n', '\n', '\n', '    /// @dev Change token name\n', '    /// @param _name string\n', '    function setName(string _name) public ifAuthorized(msg.sender, APHRODITE) {\n', '        name = _name;\n', '    }\n', '\n', '    /// @dev Change token symbol\n', '    /// @param _symbol string\n', '    function setSymbol(string _symbol) public ifAuthorized(msg.sender, APHRODITE) {\n', '        symbol = _symbol;\n', '    }\n', '}\n', '\n', '// File: contracts/storage/BasicTokenStorage.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '\n', '\n', "/// Collect all the state variables for the token's functions into a single contract\n", 'contract BasicTokenStorage is AuthorizedList, Authorized, TokenSettings, AllowancesLedger, TokenLedger {\n', '\n', '    /// @dev Ensure that authorization is set\n', '    function BasicTokenStorage() public Authorized() TokenSettings() AllowancesLedger() TokenLedger() { }\n', '\n', '    /// @dev Keep track of addresses seen before, push new ones into accounts list\n', '    /// @param _tokenholder address to check for "newness"\n', '    function trackAddresses(address _tokenholder) internal {\n', '        if (!seenBefore[_tokenholder].seen) {\n', '            seenBefore[_tokenholder].seen = true;\n', '            accounts.push(_tokenholder);\n', '            seenBefore[_tokenholder].accountArrayIndex = accounts.length - 1;\n', '        }\n', '    }\n', '\n', '    /// @dev remove address from seenBefore and accounts\n', '    /// @param _tokenholder address to remove\n', '    function removeSeenAddress(address _tokenholder) internal {\n', '        uint index = seenBefore[_tokenholder].accountArrayIndex;\n', '        require(index < accounts.length);\n', '\n', '        if (index != accounts.length - 1) {\n', '            accounts[index] = accounts[accounts.length - 1];\n', '        } \n', '        accounts.length--;\n', '        delete seenBefore[_tokenholder];\n', '    }\n', '}\n', '\n', '// File: contracts/token/BasicToken.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract BasicToken is IERC20Basic, BasicTokenStorage, Pausable, Freezable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    event Transfer(address indexed _tokenholder, address indexed _tokenrecipient, uint256 _value);\n', '    event BulkTransfer(address indexed _tokenholder, uint256 _howmany);\n', '\n', '    /// @dev Return the total token supply\n', '    function totalSupply() public view whenNotPaused returns (uint256) {\n', '        return totalsupply;\n', '    }\n', '\n', '    /// @dev transfer token for a specified address\n', '    /// @param _to The address to transfer to.\n', '    /// @param _value The amount to be transferred.\n', '    function transfer(address _to, uint256 _value) public whenNotPaused notFrozen returns (bool) {\n', '\n', '        /// No transfers to 0x0 address, use burn instead, if implemented\n', '        require(_to != address(0));\n', '\n', '        /// No useless operations\n', '        require(msg.sender != _to);\n', '\n', '        /// This will revert if not enough funds\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '\n', '        if (balances[msg.sender] == 0) {\n', '            removeSeenAddress(msg.sender);\n', '        }\n', '\n', '        /// _to might be a completely new address, so check and store if so\n', '        trackAddresses(_to);\n', '\n', '        /// This will revert on overflow\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        /// Emit the Transfer event\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev bulkTransfer tokens to a list of specified addresses, not an ERC20 function\n', '    /// @param _tos The list of addresses to transfer to.\n', '    /// @param _values The list of amounts to be transferred.\n', '    function bulkTransfer(address[] _tos, uint256[] _values) public whenNotPaused notFrozen ifAuthorized(msg.sender, BULKTRANSFER) returns (bool) {\n', '\n', '        require (_tos.length == _values.length);\n', '\n', '        uint256 sourceBalance = balances[msg.sender];\n', '\n', '        /// Temporarily set balance to 0 to mitigate the possibility of re-entrancy attacks\n', '        balances[msg.sender] = 0;\n', '\n', '        for (uint256 i = 0; i < _tos.length; i++) {\n', '            uint256 currentValue = _values[i];\n', '            address _to = _tos[i];\n', '            require(_to != address(0));\n', '            require(currentValue <= sourceBalance);\n', '            require(msg.sender != _to);\n', '\n', '            sourceBalance = sourceBalance.sub(currentValue);\n', '            balances[_to] = balances[_to].add(currentValue);\n', '\n', '            trackAddresses(_to);\n', '\n', '            emit Transfer(msg.sender, _tos[i], currentValue);\n', '        }\n', '\n', '        /// Set to the remaining balance\n', '        balances[msg.sender] = sourceBalance;\n', '\n', '        emit BulkTransfer(msg.sender, _tos.length);\n', '\n', '        if (balances[msg.sender] == 0) {\n', '            removeSeenAddress(msg.sender);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    /// @dev Gets balance of the specified account.\n', '    /// @param _tokenholder Address of interest\n', '    /// @return Balance for the passed address\n', '    function balanceOf(address _tokenholder) public view whenNotPaused returns (uint256 balance) {\n', '        require(!isFrozen(_tokenholder));\n', '        return balances[_tokenholder];\n', '    }\n', '}\n', '\n', '// File: contracts/token/StandardToken.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract StandardToken is IERC20Basic, BasicToken, IERC20 {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    event Approval(address indexed _tokenholder, address indexed _tokenspender, uint256 _value);\n', '\n', '    /// @dev Implements ERC20 transferFrom from one address to another\n', '    /// @param _from The source address  for tokens\n', '    /// @param _to The destination address for tokens\n', '    /// @param _value The number/amount to transfer\n', '    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused notFrozen returns (bool) {\n', '\n', "        // Don't send tokens to 0x0 address, use burn function that updates totalSupply\n", "        // and don't waste gas sending tokens to yourself\n", '        require(_to != address(0) && _from != _to);\n', '\n', '        require(!isFrozen(_from) && !isFrozen(_to));\n', '\n', '        /// This will revert if _value is larger than the allowance\n', '        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '\n', '        /// _to might be a completely new address, so check and store if so\n', '        trackAddresses(_to);\n', '\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        /// Emit the Transfer event\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    /// @param _tokenspender The address which will spend the funds.\n', '    /// @param _value The amount of tokens to be spent.\n', '    function approve(address _tokenspender, uint256 _value) public whenNotPaused notFrozen returns (bool) {\n', '\n', '        require(_tokenspender != address(0) && msg.sender != _tokenspender);\n', '\n', '        require(!isFrozen(_tokenspender));\n', '\n', '        /// To mitigate reentrancy race condition, set allowance for _tokenspender to 0\n', '        /// first and then set the new value\n', '        /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_value == 0) || (allowances[msg.sender][_tokenspender] == 0));\n', '\n', '        /// Allow _tokenspender to transfer up to _value in tokens from msg.sender\n', '        allowances[msg.sender][_tokenspender] = _value;\n', '\n', '        /// Emit the Approval event\n', '        emit Approval(msg.sender, _tokenspender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    /// @dev Function to check the amount of tokens that a spender can spend\n', '    /// @param _tokenholder Token owner account address\n', '    /// @param _tokenspender Account address authorized to transfer tokens\n', '    /// @return Amount of tokens still available to _tokenspender to transfer.\n', '    function allowance(address _tokenholder, address _tokenspender) public view whenNotPaused returns (uint256) {\n', '        require(!isFrozen(_tokenholder) && !isFrozen(_tokenspender));\n', '        return allowances[_tokenholder][_tokenspender];\n', '    }\n', '}\n', '\n', '// File: contracts/sales/IntimateShoppe.sol\n', '\n', '/*\n', ' * Created by: alexo (Big Deeper Advisors, Inc)\n', ' * For: Input Strategic Partners (ISP) and Intimate.io\n', ' *\n', " * Derived from some public sources and substantially extended/adapted for intimate's use.\n", ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n', ' * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n', ' * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\n', ' * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n', ' * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract IntimateShoppe is Pausable, RecoverCurrency {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /// List of contributors, i.e. msg.sender(s) who has sent in Ether\n', '    address[] internal contributors;\n', '\n', '    /// List of contributions for each contributor\n', '    mapping (address => uint256[]) internal contributions;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    /// @dev event for token purchase logging\n', '    /// @param _seller_wallet_address account that sends tokens\n', '    /// @param _buyer_address who got the tokens in exchange for ether\n', '    /// @param _value weis paid for purchase\n', '    /// @param _amount of tokens purchased\n', '    event ITMTokenPurchase(address indexed _seller_wallet_address, address indexed _buyer_address, uint256 _value, uint256 _amount);\n', '\n', '    /// @dev Starting and ending times for sale period\n', '    event SetPeriod(uint256 _startTime, uint256 _endTime);\n', '\n', '\n', '    /// The ITM token object\n', '    StandardToken public token;\n', '\n', '    /// address of the ITM token\n', '    address public token_address;\n', '\n', '    /// start and end timestamps in between which investments are allowed (both inclusive)\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '\n', '    /// address where funds are collected, it could a simple address or multi-sig wallet contract\n', '    address public wallet_address;\n', '\n', '    /// how many token units a buyer gets per wei\n', '    uint256 public rate = 600;\n', '\n', '    /// upper limit for tokens to be sold in this public offering\n', '    /// NOTE: Since decimals are set at 1e18, if one sets a limit of one(1) ITM, this number should be\n', '    /// 1 * 1e18\n', '    uint256 public capTokens;\n', '\n', '    /// Maxiumum acceptable Ether amount \n', '    uint256 public maxValue = 100 ether;\n', '\n', '    /// Minimum acceptable Ether amount, 1 ITM worth\n', '    uint256 public minValue = uint256(1 ether)/600;\n', '\n', '    /// amount of raised money in wei\n', '    uint256 public weiRaised = 0;\n', '    uint256 public tokensSold = 0;\n', '\n', '    /// High water line for contract balance\n', '    uint256 internal highWater = 1 ether;\n', '\n', '    /// What round it is\n', '    uint8 public round = 0;\n', '\n', '    /// @param _startTime is the absolute time from which to start accepting Ether\n', '    /// @param _duration is the period of time in seconds how long the sale would last, so if a sale lasts 1 month\n', '    /// then the _duration = 30(31)*24*60*60 seconds\n', '    function IntimateShoppe(\n', '        uint256 _startTime, \n', '        uint256 _duration, \n', '        uint256 _rate, \n', '        address _wallet_address, \n', '        address _token_address, \n', '        uint256 _cap,\n', '        uint8 _round) public Authorized() {\n', '\n', '        require(_startTime >= 0 && _duration > 0);\n', '        require(_rate > 0);\n', '        require(_wallet_address != address(0x0));\n', '        require(_token_address != address(0x0));\n', '        require(_cap > 0);\n', '\n', '        round = _round;\n', '\n', '        startTime = _startTime;\n', '        endTime = startTime + _duration;\n', '\n', '        rate = _rate;\n', '        minValue = uint256(1 ether)/_rate;\n', '        capTokens = _cap;\n', '        wallet_address = _wallet_address;\n', '        token_address = _token_address;\n', '        token = StandardToken(token_address);\n', '    }\n', '\n', '    /// @dev Log contributors and their contributions\n', "    /// @param _sender A Contributor's address\n", '    /// @param _value Amount of Ether said contributor sent\n', '    function trackContributions(address _sender, uint256 _value) internal {\n', '        if (contributions[_sender].length == 0) {\n', '            contributors.push(_sender);\n', '        }\n', '        contributions[_sender].push(_value);\n', '    }\n', '\n', '    /// @dev Retrieve contributors\n', '    /// @return A list of contributors\n', '    function getContributors() external view ifAuthorized(msg.sender, APHRODITE) returns (address[]) {\n', '        return contributors;\n', '    }\n', '\n', '    /// @dev Retrieve contributions by a single contributor \n', '    /// @param _contributor The account associated with contributions\n', '    /// @return A list of ether amounts that _contributor sent in\n', '    /// Using the function above one can get a list first, and then get individual Ether payments\n', '    /// and aggregate them if needed\n', '    function getContributionsForAddress(address _contributor) external view ifAuthorized(msg.sender, APHRODITE) returns (uint256[]) {\n', '        return contributions[_contributor];\n', '    }\n', '\n', '    /// @dev If a sale is done using multiple rounds, allowing for better pricing structure, depending on\n', '    /// on market demand and value of the ITM token. Is also set via the constructor\n', '    /// @param _round Round label/count\n', '    function setRound(uint8 _round) public ifAuthorized(msg.sender, APHRODITE) {\n', '        round = _round;\n', '    }\n', '\n', '    /// @dev Sets the maximum Value in Ether to purchase tokens\n', '    /// @param _maxValue Amount in wei\n', '    function setMaxValue(uint256 _maxValue) public ifAuthorized(msg.sender, APHRODITE) {\n', '        /// Cannot be modified once sale is ongoing\n', '        require(now < startTime || now > endTime);\n', '        maxValue = _maxValue;\n', '    }\n', '\n', '    /// @dev Sets the mininum Value in Ether to purchase tokens\n', '    /// @param _minValue Amount in wei\n', '    function setMinValue(uint256 _minValue) public ifAuthorized(msg.sender, APHRODITE) {\n', '        /// Cannot be modified once sale is ongoing\n', '        require(now < startTime || now > endTime);\n', '        minValue = _minValue;\n', '    }\n', '\n', '\n', '    /// @dev Reset the starting and ending times for the next round\n', '    /// @param _startTime Start of the sale round\n', '    /// @param _duration End of the sale round\n', '    function setTimes(uint256 _startTime, uint256 _duration) public ifAuthorized(msg.sender, APHRODITE) {\n', "        /// Can't reset times if sale ongoing already, make sure everything else is set before\n", '        require(now < startTime || now > endTime);\n', '\n', '        require(_startTime >= 0 && _duration > 0);\n', '        startTime = _startTime;\n', '        endTime = startTime + _duration;\n', '        emit SetPeriod(startTime, endTime);\n', '    }\n', '\n', '\n', '    /// @dev Set the cap, i.e. how many token units  we will sell in this round\n', '    /// @param _capTokens How many token units are offered in a round\n', '    function setCap(uint256 _capTokens) public ifAuthorized(msg.sender, APHRODITE) {\n', '        /// Cannot be modified once sale is ongoing\n', '        require(now < startTime || now > endTime);\n', '        require(_capTokens > 0);\n', '        capTokens = _capTokens;\n', '    }\n', '\n', '    /// @dev Set the rate, i.e. how many units per wei do we give\n', '    /// @param _rate How many token units are offered for 1 wei, 1 or more.\n', '    function setRate(uint256 _rate) public ifAuthorized(msg.sender, APHRODITE) {\n', '        require(_rate > 0);\n', '        rate = _rate;\n', '    }\n', '\n', '    /// @dev Change the wallet address\n', '    /// @param _wallet_address replacement wallet address\n', '    function changeCompanyWallet(address _wallet_address) public ifAuthorized(msg.sender, APHRODITE) {\n', '        wallet_address = _wallet_address;\n', '    }\n', '\n', '    /// @dev highWater determines at what contract balance Ether is forwarded to wallet_address\n', '    /// @return highWater\n', '    function getHighWater() public view ifAuthorized(msg.sender, APHRODITE) returns (uint256) {\n', '        return highWater;\n', '    }\n', '\n', '    /// @dev Set the high water line/ceiling\n', '    /// @param _highWater Sets the threshold to shift Ether to another address\n', '    function setHighWater(uint256 _highWater) public ifAuthorized(msg.sender, APHRODITE) {\n', '        highWater = _highWater;\n', '    }\n', '\n', '\n', '    /// fallback function used to buy tokens\n', '    function () payable public {\n', '        /// Make certain msg.value sent is within permitted bounds\n', '        require(msg.value >= minValue && msg.value <= maxValue);\n', '        backTokenOwner();\n', '    }\n', '\n', '    /// @dev Main purchase function\n', '    function backTokenOwner() whenNotPaused internal {\n', '\n', '        // Within the current sale period\n', '        require(now >= startTime && now <= endTime);\n', '\n', "        // Transfer Ether from this contract to the company's or foundation's wallet_address\n", '\n', '        if (address(this).balance >= highWater) {\n', '            //wallet_address.transfer(msg.value);\n', '            wallet_address.transfer(address(this).balance);\n', '            emit Transfer(this, wallet_address, address(this).balance);\n', '        }\n', '\n', "        /// Keep data about buyers's addresses and amounts\n", '        /// If this functionality is not wanted, comment out the next line\n', '        trackContributions(msg.sender, msg.value);\n', '\n', '        uint256 tokens = msg.value.mul(rate);\n', '\n', '        /// Transfer purchased tokens to the public buyer\n', '\n', '        /// Note that the address authorized to control the token contract needs to set "wallet_address" allowance\n', '        /// using ERC20 approve function before this contract can transfer tokens.\n', '   \n', '        if (token.transferFrom(wallet_address, msg.sender, tokens)) {\n', '\n', '            token.freezeAccount(msg.sender);\n', '\n', '            weiRaised = weiRaised.add(msg.value);\n', '            tokensSold = tokensSold.add(tokens);\n', '            emit ITMTokenPurchase(wallet_address, msg.sender, msg.value, tokens);\n', '\n', '            // Check the cap and revert if exceeded\n', '            require(tokensSold <= capTokens);\n', '        }\n', '    }\n', '}']
