['pragma solidity ^0.4.18;\n', '\n', '// Interface for contracts with buying functionality, for example, crowdsales.\n', 'contract Buyable {\n', '  function buy (address receiver) public payable;\n', '}\n', '\n', ' /// @title SafeMath contract - math operations with safety checks\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure  returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal pure returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '\n', ' /// @title ERC20 interface see https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint);\n', '  function allowance(address owner, address spender) public constant returns (uint);  \n', '  function transfer(address to, uint value) public returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '  function approve(address spender, uint value) public returns (bool ok);\n', '  function decimals() public constant returns (uint value);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', ' /// @title Ownable contract - base contract with an owner\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', '\n', ' /// @title TokenAdr token sale contract\n', 'contract TokenAdrTokenSale is Ownable, SafeMath, Buyable {\n', '\n', '   /// State machine\n', '   /// Preparing: Waiting for ICO start\n', '   /// Selling: Active sale\n', '   /// ProlongedSelling: Prolonged active sale\n', "   /// TokenShortage: ICO period isn't over yet, but there are no tokens on the contract\n", '   /// Finished: ICO has finished\n', '  enum Status {Unknown, Preparing, Selling, ProlongedSelling, TokenShortage, Finished}\n', '\n', '  /// A new investment was made\n', '  event Invested(address investor, uint weiAmount, uint tokenAmount);\n', '\n', '  /// Contract owner withdrew some tokens to team wallet\n', '  event Withdraw(uint tokenAmount);\n', '\n', '  /// Token unit price changed\n', '  event TokenPriceChanged(uint newTokenPrice);\n', '\n', '  /// SNTR token address\n', '  ERC20 public token;\n', '\n', '  /// wallet address to transfer invested ETH\n', '  address public ethMultisigWallet;\n', '\n', '  /// wallet address to withdraw unused tokens\n', '  address public tokenMultisigWallet;\n', '\n', '  /// ICO start time\n', '  uint public startTime;\n', '\n', '  /// ICO duration in seconds\n', '  uint public duration;\n', '\n', '  /// Prolonged ICO duration in seconds, 0 if no prolongation is planned\n', '  uint public prolongedDuration;\n', '\n', '  /// Token price in wei\n', '  uint public tokenPrice;\n', '\n', '  /// Minimal investment amount in wei\n', '  uint public minInvestment;\n', '\n', '  /// List of addresses allowed to send ETH to this contract, empty if anyone is allowed\n', '  address[] public allowedSenders;\n', '\n', '  /// The number of tokens already sold through this contract\n', '  uint public tokensSoldAmount = 0;\n', '\n', '  ///  How many wei of funding we have raised\n', '  uint public weiRaisedAmount = 0;\n', '\n', '  ///  How many distinct addresses have invested\n', '  uint public investorCount = 0;\n', '\n', '  ///  Was prolongation permitted by owner or not\n', '  bool public prolongationPermitted;\n', '\n', '  ///  How much ETH each address has invested to this crowdsale\n', '  mapping (address => uint256) public investedAmountOf;\n', '\n', '  ///  How much tokens this crowdsale has credited for each investor address\n', '  mapping (address => uint256) public tokenAmountOf;\n', '\n', '  /// Multiplier for token value\n', '  uint public tokenValueMultiplier;\n', '\n', '  /// Stop trigger in excess\n', '  bool public stopped;\n', '\n', '  /// @dev Constructor\n', '  /// @param _token token address\n', '  /// @param _ethMultisigWallet wallet address to transfer invested ETH\n', '  /// @param _tokenMultisigWallet wallet address to withdraw unused tokens\n', '  /// @param _startTime ICO start time\n', '  /// @param _duration ICO duration in seconds\n', '  /// @param _prolongedDuration Prolonged ICO duration in seconds, 0 if no prolongation is planned\n', '  /// @param _tokenPrice Token price in wei\n', '  /// @param _minInvestment Minimal investment amount in wei\n', '  /// @param _allowedSenders List of addresses allowed to send ETH to this contract, empty if anyone is allowed\n', '  function TokenAdrTokenSale(address _token, address _ethMultisigWallet, address _tokenMultisigWallet,\n', '            uint _startTime, uint _duration, uint _prolongedDuration, uint _tokenPrice, uint _minInvestment, address[] _allowedSenders) public {\n', '    require(_token != 0);\n', '    require(_ethMultisigWallet != 0);\n', '    require(_tokenMultisigWallet != 0);\n', '    require(_duration > 0);\n', '    require(_tokenPrice > 0);\n', '    require(_minInvestment > 0);\n', '\n', '    token = ERC20(_token);\n', '    ethMultisigWallet = _ethMultisigWallet;\n', '    tokenMultisigWallet = _tokenMultisigWallet;\n', '    startTime = _startTime;\n', '    duration = _duration;\n', '    prolongedDuration = _prolongedDuration;\n', '    tokenPrice = _tokenPrice;\n', '    minInvestment = _minInvestment;\n', '    allowedSenders = _allowedSenders;\n', '    tokenValueMultiplier = 10 ** token.decimals();\n', '  }\n', '\n', '  /// @dev Sell tokens to specified address\n', '  /// @param receiver receiver of bought tokens\n', '  function buy (address receiver) public payable {\n', '    require(!stopped);\n', '    require(getCurrentStatus() == Status.Selling || getCurrentStatus() == Status.ProlongedSelling);\n', '    require(msg.value >= minInvestment);\n', '\n', '    // Check if current sender is allowed to participate in this crowdsale\n', '    var senderAllowed = false;\n', '    if (allowedSenders.length > 0) {\n', '      for (uint i = 0; i < allowedSenders.length; i++)\n', '        if (allowedSenders[i] == receiver) {\n', '          senderAllowed = true;\n', '          break;\n', '        }\n', '    }\n', '    else\n', '      senderAllowed = true;\n', '\n', '    assert(senderAllowed);\n', '\n', '    uint weiAmount = msg.value;\n', '    uint tokenAmount = safeDiv(safeMul(weiAmount, tokenValueMultiplier), tokenPrice);\n', '    assert(tokenAmount > 0);\n', '\n', '    uint changeWei = 0;\n', '    var currentContractTokens = token.balanceOf(address(this));\n', '    if (currentContractTokens < tokenAmount) {\n', '      var changeTokenAmount = safeSub(tokenAmount, currentContractTokens);\n', '      changeWei = safeDiv(safeMul(changeTokenAmount, tokenPrice), tokenValueMultiplier);\n', '      tokenAmount = currentContractTokens;\n', '      weiAmount = safeSub(weiAmount, changeWei);\n', '    }\n', '\n', '    if(investedAmountOf[receiver] == 0) {\n', '       // A new investor\n', '       investorCount++;\n', '    }\n', '    // Update investor-amount mappings\n', '    investedAmountOf[receiver] = safeAdd(investedAmountOf[receiver], weiAmount);\n', '    tokenAmountOf[receiver] = safeAdd(tokenAmountOf[receiver], tokenAmount);\n', '    // Update totals\n', '    weiRaisedAmount = safeAdd(weiRaisedAmount, weiAmount);\n', '    tokensSoldAmount = safeAdd(tokensSoldAmount, tokenAmount);\n', '\n', '    // Transfer the invested ETH to the multisig wallet;\n', '    ethMultisigWallet.transfer(weiAmount);\n', '\n', '    // Transfer the bought tokens to the ETH sender\n', '    var transferSuccess = token.transfer(receiver, tokenAmount);\n', '    assert(transferSuccess);\n', '\n', '    // Return change if any\n', '    if (changeWei > 0) {\n', '      receiver.transfer(changeWei);\n', '    }\n', '\n', '    // Tell us the investment succeeded\n', '    Invested(receiver, weiAmount, tokenAmount);\n', '  }\n', '\n', '  /// @dev Sell tokens to ETH sender\n', '  function() public payable {\n', '    buy(msg.sender);\n', '  }\n', '\n', '   /// @dev Token sale state machine management.\n', '   /// @return Status current status\n', '  function getCurrentStatus() public constant returns (Status) {\n', '    if (startTime > now)\n', '      return Status.Preparing;\n', '    if (now > startTime + duration + prolongedDuration)\n', '      return Status.Finished;\n', '    if (now > startTime + duration && !prolongationPermitted)\n', '      return Status.Finished;\n', '    if (token.balanceOf(address(this)) <= 0)\n', '      return Status.TokenShortage;\n', '    if (now > startTime + duration)\n', '      return Status.ProlongedSelling;\n', '    if (now >= startTime)\n', '        return Status.Selling;\n', '    return Status.Unknown;\n', '  }\n', '\n', '  /// @dev Withdraw remaining tokens to the team wallet\n', '  /// @param value Amount of tokens to withdraw\n', '  function withdrawTokens(uint value) public onlyOwner {\n', '    require(value <= token.balanceOf(address(this)));\n', '    // Return the specified amount of tokens to team wallet\n', '    token.transfer(tokenMultisigWallet, value);\n', '    Withdraw(value);\n', '  }\n', '\n', '  /// @dev Change current token price\n', '  /// @param newTokenPrice New token unit price in wei\n', '  function changeTokenPrice(uint newTokenPrice) public onlyOwner {\n', '    require(newTokenPrice > 0);\n', '\n', '    tokenPrice = newTokenPrice;\n', '    TokenPriceChanged(newTokenPrice);\n', '  }\n', '\n', '  /// @dev Prolong ICO if owner decides to do it\n', '  function prolong() public onlyOwner {\n', '    require(!prolongationPermitted && prolongedDuration > 0);\n', '    prolongationPermitted = true;\n', '  }\n', '\n', '  /// @dev Called by the owner on excess, triggers stopped state\n', '  function stopSale() public onlyOwner {\n', '    stopped = true;\n', '  }\n', '\n', '  /// @dev Called by the owner on end of excess, returns to normal state\n', '  function resumeSale() public onlyOwner {\n', '    require(stopped);\n', '    stopped = false;\n', '  }\n', '\n', '  /// @dev Called by the owner to destroy contract\n', '  function kill() public onlyOwner {\n', '    selfdestruct(owner);\n', '  }\n', '}']