['pragma solidity ^0.4.24;\n', '\n', '// File: @0xcert/ethereum-utils/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @dev Math operations with safety checks that throw on error. This contract is based\n', ' * on the source code at https://goo.gl/iyQsmU.\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '   * @dev Multiplies two numbers, throws on overflow.\n', '   * @param _a Factor number.\n', '   * @param _b Factor number.\n', '   */\n', '  function mul(\n', '    uint256 _a,\n', '    uint256 _b\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Integer division of two numbers, truncating the quotient.\n', '   * @param _a Dividend number.\n', '   * @param _b Divisor number.\n', '   */\n', '  function div(\n', '    uint256 _a,\n', '    uint256 _b\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    uint256 c = _a / _b;\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '   * @param _a Minuend number.\n', '   * @param _b Subtrahend number.\n', '   */\n', '  function sub(\n', '    uint256 _a,\n', '    uint256 _b\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds two numbers, throws on overflow.\n', '   * @param _a Number.\n', '   * @param _b Number.\n', '   */\n', '  function add(\n', '    uint256 _a,\n', '    uint256 _b\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    uint256 c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721Enumerable.sol\n', '\n', '/**\n', ' * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\n', ' * See https://goo.gl/pc9yoS.\n', ' */\n', 'interface ERC721Enumerable {\n', '\n', '  /**\n', '   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\n', '   * assigned and queryable owner not equal to the zero address.\n', '   */\n', '  function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\n', '   * @param _index A counter less than `totalSupply()`.\n', '   */\n', '  function tokenByIndex(\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\n', '   * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\n', '   * representing invalid NFTs.\n', '   * @param _owner An address where we are interested in NFTs owned by them.\n', '   * @param _index A counter less than `balanceOf(_owner)`.\n', '   */\n', '  function tokenOfOwnerByIndex(\n', '    address _owner,\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721.sol\n', '\n', '/**\n', ' * @dev ERC-721 non-fungible token standard. See https://goo.gl/pc9yoS.\n', ' */\n', 'interface ERC721 {\n', '\n', '  /**\n', '   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n', '   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n', '   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n', '   * transfer, the approved address for that NFT (if any) is reset to none.\n', '   */\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n', '   * address indicates there is no approved address. When a Transfer event emits, this also\n', '   * indicates that the approved address for that NFT (if any) is reset to none.\n', '   */\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _approved,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n', '   * all NFTs of the owner.\n', '   */\n', '  event ApprovalForAll(\n', '    address indexed _owner,\n', '    address indexed _operator,\n', '    bool _approved\n', '  );\n', '\n', '  /**\n', '   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n', '   * considered invalid, and this function throws for queries about the zero address.\n', '   * @param _owner Address for whom to query the balance.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n', '   * invalid, and queries about them do throw.\n', '   * @param _tokenId The identifier for an NFT.\n', '   */\n', '  function ownerOf(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n', '   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n', '   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n', '   * function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received`\n', '   * on `_to` and throws if the return value is not `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   * @param _data Additional data with no specified format, sent in call to `_to`.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice This works identically to the other function with an extra data parameter, except this\n', '   * function just sets data to ""\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n', '   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n', '   * address. Throws if `_tokenId` is not a valid NFT.\n', '   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n', '   * they mayb be permanently lost.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Set or reaffirm the approved address for an NFT.\n', '   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n', '   * the current NFT owner, or an authorized operator of the current owner.\n', '   * @param _approved The new approved NFT controller.\n', '   * @param _tokenId The NFT to approve.\n', '   */\n', '  function approve(\n', '    address _approved,\n', '    uint256 _tokenId\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Enables or disables approval for a third party ("operator") to manage all of\n', '   * `msg.sender`&#39;s assets. It also emits the ApprovalForAll event.\n', '   * @notice The contract MUST allow multiple operators per owner.\n', '   * @param _operator Address to add to the set of authorized operators.\n', '   * @param _approved True if the operators is approved, false to revoke approval.\n', '   */\n', '  function setApprovalForAll(\n', '    address _operator,\n', '    bool _approved\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Get the approved address for a single NFT.\n', '   * @notice Throws if `_tokenId` is not a valid NFT.\n', '   * @param _tokenId The NFT to find the approved address for.\n', '   */\n', '  function getApproved(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '  /**\n', '   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\n', '   * @param _owner The address that owns the NFTs.\n', '   * @param _operator The address that acts on behalf of the owner.\n', '   */\n', '  function isApprovedForAll(\n', '    address _owner,\n', '    address _operator\n', '  )\n', '    external\n', '    view\n', '    returns (bool);\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721TokenReceiver.sol\n', '\n', '/**\n', ' * @dev ERC-721 interface for accepting safe transfers. See https://goo.gl/pc9yoS.\n', ' */\n', 'interface ERC721TokenReceiver {\n', '\n', '  /**\n', '   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\n', '   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\n', '   * of other than the magic value MUST result in the transaction being reverted.\n', '   * Returns `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))` unless throwing.\n', '   * @notice The contract address is always the message sender. A wallet/broker/auction application\n', '   * MUST implement the wallet interface if it will accept safe transfers.\n', '   * @param _from The sending address.\n', '   * @param _tokenId The NFT identifier which is being transfered.\n', '   * @param _data Additional data with no specified format.\n', '   */\n', '  function onERC721Received(\n', '    address _from,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    external\n', '    returns(bytes4);\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @dev The contract has an owner address, and provides basic authorization control whitch\n', ' * simplifies the implementation of user permissions. This contract is based on the source code\n', ' * at https://goo.gl/n2ZGVt.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  /**\n', '   * @dev An event which is triggered when the owner is changed.\n', '   * @param previousOwner The address of the previous owner.\n', '   * @param newOwner The address of the new owner.\n', '   */\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The constructor sets the original `owner` of the contract to the sender account.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(\n', '    address _newOwner\n', '  )\n', '    onlyOwner\n', '    public\n', '  {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/utils/AddressUtils.sol\n', '\n', '/**\n', ' * @dev Utility library of inline functions on addresses.\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * @dev Returns whether the target address is a contract.\n', '   * @param _addr Address to check.\n', '   */\n', '  function isContract(\n', '    address _addr\n', '  )\n', '    internal\n', '    view\n', '    returns (bool)\n', '  {\n', '    uint256 size;\n', '\n', '    /**\n', '     * XXX Currently there is no better way to check if there is a contract in an address than to\n', '     * check the size of the code at that address.\n', '     * See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\n', '     * TODO: Check this again before the Serenity release, because all addresses will be\n', '     * contracts then.\n', '     */\n', '    assembly { size := extcodesize(_addr) } // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/utils/ERC165.sol\n', '\n', '/**\n', ' * @dev A standard for detecting smart contract interfaces. See https://goo.gl/cxQCse.\n', ' */\n', 'interface ERC165 {\n', '\n', '  /**\n', '   * @dev Checks if the smart contract includes a specific interface.\n', '   * @notice This function uses less than 30,000 gas.\n', '   * @param _interfaceID The interface identifier, as specified in ERC-165.\n', '   */\n', '  function supportsInterface(\n', '    bytes4 _interfaceID\n', '  )\n', '    external\n', '    view\n', '    returns (bool);\n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/utils/SupportsInterface.sol\n', '\n', '/**\n', ' * @dev Implementation of standard for detect smart contract interfaces.\n', ' */\n', 'contract SupportsInterface is ERC165 {\n', '\n', '  /**\n', '   * @dev Mapping of supported intefraces.\n', '   * @notice You must not set element 0xffffffff to true.\n', '   */\n', '  mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x01ffc9a7] = true; // ERC165\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check which interfaces are suported by this contract.\n', '   * @param _interfaceID Id of the interface.\n', '   */\n', '  function supportsInterface(\n', '    bytes4 _interfaceID\n', '  )\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    return supportedInterfaces[_interfaceID];\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/NFToken.sol\n', '\n', '/**\n', ' * @dev Implementation of ERC-721 non-fungible token standard.\n', ' */\n', 'contract NFToken is\n', '  Ownable,\n', '  ERC721,\n', '  SupportsInterface\n', '{\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  /**\n', '   * @dev A mapping from NFT ID to the address that owns it.\n', '   */\n', '  mapping (uint256 => address) internal idToOwner;\n', '\n', '  /**\n', '   * @dev Mapping from NFT ID to approved address.\n', '   */\n', '  mapping (uint256 => address) internal idToApprovals;\n', '\n', '   /**\n', '   * @dev Mapping from owner address to count of his tokens.\n', '   */\n', '  mapping (address => uint256) internal ownerToNFTokenCount;\n', '\n', '  /**\n', '   * @dev Mapping from owner address to mapping of operator addresses.\n', '   */\n', '  mapping (address => mapping (address => bool)) internal ownerToOperators;\n', '\n', '  /**\n', '   * @dev Magic value of a smart contract that can recieve NFT.\n', '   * Equal to: keccak256("onERC721Received(address,uint256,bytes)").\n', '   */\n', '  bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  /**\n', '   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n', '   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n', '   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n', '   * transfer, the approved address for that NFT (if any) is reset to none.\n', '   * @param _from Sender of NFT (if address is zero address it indicates token creation).\n', '   * @param _to Receiver of NFT (if address is zero address it indicates token destruction).\n', '   * @param _tokenId The NFT that got transfered.\n', '   */\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n', '   * address indicates there is no approved address. When a Transfer event emits, this also\n', '   * indicates that the approved address for that NFT (if any) is reset to none.\n', '   * @param _owner Owner of NFT.\n', '   * @param _approved Address that we are approving.\n', '   * @param _tokenId NFT which we are approving.\n', '   */\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _approved,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n', '   * all NFTs of the owner.\n', '   * @param _owner Owner of NFT.\n', '   * @param _operator Address to which we are setting operator rights.\n', '   * @param _approved Status of operator rights(true if operator rights are given and false if\n', '   * revoked).\n', '   */\n', '  event ApprovalForAll(\n', '    address indexed _owner,\n', '    address indexed _operator,\n', '    bool _approved\n', '  );\n', '\n', '  /**\n', '   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\n', '   * @param _tokenId ID of the NFT to validate.\n', '   */\n', '  modifier canOperate(\n', '    uint256 _tokenId\n', '  ) {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender]);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Guarantees that the msg.sender is allowed to transfer NFT.\n', '   * @param _tokenId ID of the NFT to transfer.\n', '   */\n', '  modifier canTransfer(\n', '    uint256 _tokenId\n', '  ) {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(\n', '      tokenOwner == msg.sender\n', '      || getApproved(_tokenId) == msg.sender\n', '      || ownerToOperators[tokenOwner][msg.sender]\n', '    );\n', '\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Guarantees that _tokenId is a valid Token.\n', '   * @param _tokenId ID of the NFT to validate.\n', '   */\n', '  modifier validNFToken(\n', '    uint256 _tokenId\n', '  ) {\n', '    require(idToOwner[_tokenId] != address(0));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x80ac58cd] = true; // ERC721\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n', '   * considered invalid, and this function throws for queries about the zero address.\n', '   * @param _owner Address for whom to query the balance.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    view\n', '    returns (uint256)\n', '  {\n', '    require(_owner != address(0));\n', '    return ownerToNFTokenCount[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n', '   * invalid, and queries about them do throw.\n', '   * @param _tokenId The identifier for an NFT.\n', '   */\n', '  function ownerOf(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns (address _owner)\n', '  {\n', '    _owner = idToOwner[_tokenId];\n', '    require(_owner != address(0));\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n', '   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n', '   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n', '   * function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received`\n', '   * on `_to` and throws if the return value is not `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   * @param _data Additional data with no specified format, sent in call to `_to`.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    external\n', '  {\n', '    _safeTransferFrom(_from, _to, _tokenId, _data);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice This works identically to the other function with an extra data parameter, except this\n', '   * function just sets data to ""\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '  {\n', '    _safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n', '   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n', '   * address. Throws if `_tokenId` is not a valid NFT.\n', '   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n', '   * they maybe be permanently lost.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    canTransfer(_tokenId)\n', '    validNFToken(_tokenId)\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(tokenOwner == _from);\n', '    require(_to != address(0));\n', '\n', '    _transfer(_to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Set or reaffirm the approved address for an NFT.\n', '   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n', '   * the current NFT owner, or an authorized operator of the current owner.\n', '   * @param _approved Address to be approved for the given NFT ID.\n', '   * @param _tokenId ID of the token to be approved.\n', '   */\n', '  function approve(\n', '    address _approved,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    canOperate(_tokenId)\n', '    validNFToken(_tokenId)\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(_approved != tokenOwner);\n', '\n', '    idToApprovals[_tokenId] = _approved;\n', '    emit Approval(tokenOwner, _approved, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Enables or disables approval for a third party ("operator") to manage all of\n', '   * `msg.sender`&#39;s assets. It also emits the ApprovalForAll event.\n', '   * @notice This works even if sender doesn&#39;t own any tokens at the time.\n', '   * @param _operator Address to add to the set of authorized operators.\n', '   * @param _approved True if the operators is approved, false to revoke approval.\n', '   */\n', '  function setApprovalForAll(\n', '    address _operator,\n', '    bool _approved\n', '  )\n', '    external\n', '  {\n', '    require(_operator != address(0));\n', '    ownerToOperators[msg.sender][_operator] = _approved;\n', '    emit ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /**\n', '   * @dev Get the approved address for a single NFT.\n', '   * @notice Throws if `_tokenId` is not a valid NFT.\n', '   * @param _tokenId ID of the NFT to query the approval of.\n', '   */\n', '  function getApproved(\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '    view\n', '    validNFToken(_tokenId)\n', '    returns (address)\n', '  {\n', '    return idToApprovals[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Checks if `_operator` is an approved operator for `_owner`.\n', '   * @param _owner The address that owns the NFTs.\n', '   * @param _operator The address that acts on behalf of the owner.\n', '   */\n', '  function isApprovedForAll(\n', '    address _owner,\n', '    address _operator\n', '  )\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    require(_owner != address(0));\n', '    require(_operator != address(0));\n', '    return ownerToOperators[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '   * @dev Actually perform the safeTransferFrom.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   * @param _data Additional data with no specified format, sent in call to `_to`.\n', '   */\n', '  function _safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    internal\n', '    canTransfer(_tokenId)\n', '    validNFToken(_tokenId)\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(tokenOwner == _from);\n', '    require(_to != address(0));\n', '\n', '    _transfer(_to, _tokenId);\n', '\n', '    if (_to.isContract()) {\n', '      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, _data);\n', '      require(retval == MAGIC_ON_ERC721_RECEIVED);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Actually preforms the transfer.\n', '   * @notice Does NO checks.\n', '   * @param _to Address of a new owner.\n', '   * @param _tokenId The NFT that is being transferred.\n', '   */\n', '  function _transfer(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    private\n', '  {\n', '    address from = idToOwner[_tokenId];\n', '\n', '    clearApproval(from, _tokenId);\n', '    removeNFToken(from, _tokenId);\n', '    addNFToken(_to, _tokenId);\n', '\n', '    emit Transfer(from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @notice This is a private function which should be called from user-implemented external\n', '   * mint function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _to The address that will own the minted NFT.\n', '   * @param _tokenId of the NFT to be minted by the msg.sender.\n', '   */\n', '  function _mint(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    require(_to != address(0));\n', '    require(_tokenId != 0);\n', '    require(idToOwner[_tokenId] == address(0));\n', '\n', '    addNFToken(_to, _tokenId);\n', '\n', '    emit Transfer(address(0), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a NFT.\n', '   * @notice This is a private function which should be called from user-implemented external\n', '   * burn function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _owner Address of the NFT owner.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function _burn(\n', '    address _owner,\n', '    uint256 _tokenId\n', '  )\n', '    validNFToken(_tokenId)\n', '    internal\n', '  {\n', '    clearApproval(_owner, _tokenId);\n', '    removeNFToken(_owner, _tokenId);\n', '    emit Transfer(_owner, address(0), _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Clears the current approval of a given NFT ID.\n', '   * @param _tokenId ID of the NFT to be transferred.\n', '   */\n', '  function clearApproval(\n', '    address _owner,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    delete idToApprovals[_tokenId];\n', '    emit Approval(_owner, 0, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Removes a NFT from owner.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _from Address from wich we want to remove the NFT.\n', '   * @param _tokenId Which NFT we want to remove.\n', '   */\n', '  function removeNFToken(\n', '    address _from,\n', '    uint256 _tokenId\n', '  )\n', '   internal\n', '  {\n', '    require(idToOwner[_tokenId] == _from);\n', '    assert(ownerToNFTokenCount[_from] > 0);\n', '    ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from].sub(1);\n', '    delete idToOwner[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Assignes a new NFT to owner.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _to Address to wich we want to add the NFT.\n', '   * @param _tokenId Which NFT we want to add.\n', '   */\n', '  function addNFToken(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    require(idToOwner[_tokenId] == address(0));\n', '\n', '    idToOwner[_tokenId] = _to;\n', '    ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/NFTokenEnumerable.sol\n', '\n', '/**\n', ' * @dev Optional enumeration implementation for ERC-721 non-fungible token standard.\n', ' */\n', 'contract NFTokenEnumerable is\n', '  NFToken,\n', '  ERC721Enumerable\n', '{\n', '\n', '  /**\n', '   * @dev Array of all NFT IDs.\n', '   */\n', '  uint256[] internal tokens;\n', '\n', '  /**\n', '   * @dev Mapping from owner address to a list of owned NFT IDs.\n', '   */\n', '  mapping(uint256 => uint256) internal idToIndex;\n', '\n', '  /**\n', '   * @dev Mapping from owner to list of owned NFT IDs.\n', '   */\n', '  mapping(address => uint256[]) internal ownerToIds;\n', '\n', '  /**\n', '   * @dev Mapping from NFT ID to its index in the owner tokens list.\n', '   */\n', '  mapping(uint256 => uint256) internal idToOwnerIndex;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @notice This is a private function which should be called from user-implemented external\n', '   * mint function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _to The address that will own the minted NFT.\n', '   * @param _tokenId of the NFT to be minted by the msg.sender.\n', '   */\n', '  function _mint(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    super._mint(_to, _tokenId);\n', '    tokens.push(_tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a NFT.\n', '   * @notice This is a private function which should be called from user-implemented external\n', '   * burn function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _owner Address of the NFT owner.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function _burn(\n', '    address _owner,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    assert(tokens.length > 0);\n', '    super._burn(_owner, _tokenId);\n', '\n', '    uint256 tokenIndex = idToIndex[_tokenId];\n', '    uint256 lastTokenIndex = tokens.length.sub(1);\n', '    uint256 lastToken = tokens[lastTokenIndex];\n', '\n', '    tokens[tokenIndex] = lastToken;\n', '    tokens[lastTokenIndex] = 0;\n', '\n', '    tokens.length--;\n', '    idToIndex[_tokenId] = 0;\n', '    idToIndex[lastToken] = tokenIndex;\n', '  }\n', '\n', '  /**\n', '   * @dev Removes a NFT from an address.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _from Address from wich we want to remove the NFT.\n', '   * @param _tokenId Which NFT we want to remove.\n', '   */\n', '  function removeNFToken(\n', '    address _from,\n', '    uint256 _tokenId\n', '  )\n', '   internal\n', '  {\n', '    super.removeNFToken(_from, _tokenId);\n', '    assert(ownerToIds[_from].length > 0);\n', '\n', '    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\n', '    uint256 lastTokenIndex = ownerToIds[_from].length.sub(1);\n', '    uint256 lastToken = ownerToIds[_from][lastTokenIndex];\n', '\n', '    ownerToIds[_from][tokenToRemoveIndex] = lastToken;\n', '    ownerToIds[_from][lastTokenIndex] = 0;\n', '\n', '    ownerToIds[_from].length--;\n', '    idToOwnerIndex[_tokenId] = 0;\n', '    idToOwnerIndex[lastToken] = tokenToRemoveIndex;\n', '  }\n', '\n', '  /**\n', '   * @dev Assignes a new NFT to an address.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _to Address to wich we want to add the NFT.\n', '   * @param _tokenId Which NFT we want to add.\n', '   */\n', '  function addNFToken(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    super.addNFToken(_to, _tokenId);\n', '\n', '    uint256 length = ownerToIds[_to].length;\n', '    ownerToIds[_to].push(_tokenId);\n', '    idToOwnerIndex[_tokenId] = length;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the count of all existing NFTokens.\n', '   */\n', '  function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return tokens.length;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns NFT ID by its index.\n', '   * @param _index A counter less than `totalSupply()`.\n', '   */\n', '  function tokenByIndex(\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256)\n', '  {\n', '    require(_index < tokens.length);\n', '    return tokens[_index];\n', '  }\n', '\n', '  /**\n', '   * @dev returns the n-th NFT ID from a list of owner&#39;s tokens.\n', '   * @param _owner Token owner&#39;s address.\n', '   * @param _index Index number representing n-th token in owner&#39;s list of tokens.\n', '   */\n', '  function tokenOfOwnerByIndex(\n', '    address _owner,\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256)\n', '  {\n', '    require(_index < ownerToIds[_owner].length);\n', '    return ownerToIds[_owner][_index];\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721Metadata.sol\n', '\n', '/**\n', ' * @dev Optional metadata extension for ERC-721 non-fungible token standard.\n', ' * See https://goo.gl/pc9yoS.\n', ' */\n', 'interface ERC721Metadata {\n', '\n', '  /**\n', '   * @dev Returns a descriptive name for a collection of NFTs in this contract.\n', '   */\n', '  function name()\n', '    external\n', '    view\n', '    returns (string _name);\n', '\n', '  /**\n', '   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\n', '   */\n', '  function symbol()\n', '    external\n', '    view\n', '    returns (string _symbol);\n', '\n', '  /**\n', '   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\n', '   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\n', '   * that conforms to the "ERC721 Metadata JSON Schema".\n', '   */\n', '  function tokenURI(uint256 _tokenId)\n', '    external\n', '    view\n', '    returns (string);\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/NFTokenMetadata.sol\n', '\n', '/**\n', ' * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\n', ' */\n', 'contract NFTokenMetadata is\n', '  NFToken,\n', '  ERC721Metadata\n', '{\n', '\n', '  /**\n', '   * @dev A descriptive name for a collection of NFTs.\n', '   */\n', '  string internal nftName;\n', '\n', '  /**\n', '   * @dev An abbreviated name for NFTokens.\n', '   */\n', '  string internal nftSymbol;\n', '\n', '  /**\n', '   * @dev Mapping from NFT ID to metadata uri.\n', '   */\n', '  mapping (uint256 => string) internal idToUri;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   * @notice When implementing this contract don&#39;t forget to set nftName and nftSymbol.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a NFT.\n', '   * @notice This is a internal function which should be called from user-implemented external\n', '   * burn function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _owner Address of the NFT owner.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function _burn(\n', '    address _owner,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    super._burn(_owner, _tokenId);\n', '\n', '    if (bytes(idToUri[_tokenId]).length != 0) {\n', '      delete idToUri[_tokenId];\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\n', '   * @notice this is a internal function which should be called from user-implemented external\n', '   * function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _tokenId Id for which we want uri.\n', '   * @param _uri String representing RFC 3986 URI.\n', '   */\n', '  function _setTokenUri(\n', '    uint256 _tokenId,\n', '    string _uri\n', '  )\n', '    validNFToken(_tokenId)\n', '    internal\n', '  {\n', '    idToUri[_tokenId] = _uri;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns a descriptive name for a collection of NFTokens.\n', '   */\n', '  function name()\n', '    external\n', '    view\n', '    returns (string _name)\n', '  {\n', '    _name = nftName;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns an abbreviated name for NFTokens.\n', '   */\n', '  function symbol()\n', '    external\n', '    view\n', '    returns (string _symbol)\n', '  {\n', '    _symbol = nftSymbol;\n', '  }\n', '\n', '  /**\n', '   * @dev A distinct URI (RFC 3986) for a given NFT.\n', '   * @param _tokenId Id for which we want uri.\n', '   */\n', '  function tokenURI(\n', '    uint256 _tokenId\n', '  )\n', '    validNFToken(_tokenId)\n', '    external\n', '    view\n', '    returns (string)\n', '  {\n', '    return idToUri[_tokenId];\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-xcert/contracts/tokens/Xcert.sol\n', '\n', '/**\n', ' * @dev Xcert implementation.\n', ' */\n', 'contract Xcert is NFTokenEnumerable, NFTokenMetadata {\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  /**\n', '   * @dev Unique ID which determines each Xcert smart contract type by its JSON convention.\n', '   * @notice Calculated as bytes4(keccak256(jsonSchema)).\n', '   */\n', '  bytes4 internal nftConventionId;\n', '\n', '  /**\n', '   * @dev Maps NFT ID to proof.\n', '   */\n', '  mapping (uint256 => string) internal idToProof;\n', '\n', '  /**\n', '   * @dev Maps NFT ID to protocol config.\n', '   */\n', '  mapping (uint256 => bytes32[]) internal config;\n', '\n', '  /**\n', '   * @dev Maps NFT ID to convention data.\n', '   */\n', '  mapping (uint256 => bytes32[]) internal data;\n', '\n', '  /**\n', '   * @dev Maps address to authorization of contract.\n', '   */\n', '  mapping (address => bool) internal addressToAuthorized;\n', '\n', '  /**\n', '   * @dev Emits when an address is authorized to some contract control or the authorization is revoked.\n', '   * The _target has some contract controle like minting new NFTs.\n', '   * @param _target Address to set authorized state.\n', '   * @param _authorized True if the _target is authorised, false to revoke authorization.\n', '   */\n', '  event AuthorizedAddress(\n', '    address indexed _target,\n', '    bool _authorized\n', '  );\n', '\n', '  /**\n', '   * @dev Guarantees that msg.sender is allowed to mint a new NFT.\n', '   */\n', '  modifier isAuthorized() {\n', '    require(msg.sender == owner || addressToAuthorized[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   * @notice When implementing this contract don&#39;t forget to set nftConventionId, nftName and\n', '   * nftSymbol.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x6be14f75] = true; // Xcert\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @param _to The address that will own the minted NFT.\n', '   * @param _id The NFT to be minted by the msg.sender.\n', '   * @param _uri An URI pointing to NFT metadata.\n', '   * @param _proof Cryptographic asset imprint.\n', '   * @param _config Array of protocol config values where 0 index represents token expiration\n', '   * timestamp, other indexes are not yet definied but are ready for future xcert upgrades.\n', '   * @param _data Array of convention data values.\n', '   */\n', '  function mint(\n', '    address _to,\n', '    uint256 _id,\n', '    string _uri,\n', '    string _proof,\n', '    bytes32[] _config,\n', '    bytes32[] _data\n', '  )\n', '    external\n', '    isAuthorized()\n', '  {\n', '    require(_config.length > 0);\n', '    require(bytes(_proof).length > 0);\n', '    super._mint(_to, _id);\n', '    super._setTokenUri(_id, _uri);\n', '    idToProof[_id] = _proof;\n', '    config[_id] = _config;\n', '    data[_id] = _data;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns a bytes4 of keccak256 of json schema representing 0xcert protocol convention.\n', '   */\n', '  function conventionId()\n', '    external\n', '    view\n', '    returns (bytes4 _conventionId)\n', '  {\n', '    _conventionId = nftConventionId;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns proof for NFT.\n', '   * @param _tokenId Id of the NFT.\n', '   */\n', '  function tokenProof(\n', '    uint256 _tokenId\n', '  )\n', '    validNFToken(_tokenId)\n', '    external\n', '    view\n', '    returns(string)\n', '  {\n', '    return idToProof[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns convention data value for a given index field.\n', '   * @param _tokenId Id of the NFT we want to get value for key.\n', '   * @param _index for which we want to get value.\n', '   */\n', '  function tokenDataValue(\n', '    uint256 _tokenId,\n', '    uint256 _index\n', '  )\n', '    validNFToken(_tokenId)\n', '    public\n', '    view\n', '    returns(bytes32 value)\n', '  {\n', '    require(_index < data[_tokenId].length);\n', '    value = data[_tokenId][_index];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns expiration date from 0 index of token config values.\n', '   * @param _tokenId Id of the NFT we want to get expiration time of.\n', '   */\n', '  function tokenExpirationTime(\n', '    uint256 _tokenId\n', '  )\n', '    validNFToken(_tokenId)\n', '    external\n', '    view\n', '    returns(bytes32)\n', '  {\n', '    return config[_tokenId][0];\n', '  }\n', '\n', '  /**\n', '   * @dev Sets authorised address for minting.\n', '   * @param _target Address to set authorized state.\n', '   * @param _authorized True if the _target is authorised, false to revoke authorization.\n', '   */\n', '  function setAuthorizedAddress(\n', '    address _target,\n', '    bool _authorized\n', '  )\n', '    onlyOwner\n', '    external\n', '  {\n', '    require(_target != address(0));\n', '    addressToAuthorized[_target] = _authorized;\n', '    emit AuthorizedAddress(_target, _authorized);\n', '  }\n', '\n', '  /**\n', '   * @dev Sets mint authorised address.\n', '   * @param _target Address for which we want to check if it is authorized.\n', '   * @return Is authorized or not.\n', '   */\n', '  function isAuthorizedAddress(\n', '    address _target\n', '  )\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    require(_target != address(0));\n', '    return addressToAuthorized[_target];\n', '  }\n', '}\n', '\n', '// File: @0xcert/ethereum-erc20/contracts/tokens/ERC20.sol\n', '\n', '/**\n', ' * @title A standard interface for tokens.\n', ' */\n', 'interface ERC20 {\n', '\n', '  /**\n', '   * @dev Returns the name of the token.\n', '   */\n', '  function name()\n', '    external\n', '    view\n', '    returns (string _name);\n', '\n', '  /**\n', '   * @dev Returns the symbol of the token.\n', '   */\n', '  function symbol()\n', '    external\n', '    view\n', '    returns (string _symbol);\n', '\n', '  /**\n', '   * @dev Returns the number of decimals the token uses.\n', '   */\n', '  function decimals()\n', '    external\n', '    view\n', '    returns (uint8 _decimals);\n', '\n', '  /**\n', '   * @dev Returns the total token supply.\n', '   */\n', '  function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256 _totalSupply);\n', '\n', '  /**\n', '   * @dev Returns the account balance of another account with address _owner.\n', '   * @param _owner The address from which the balance will be retrieved.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    view\n', '    returns (uint256 _balance);\n', '\n', '  /**\n', '   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\n', '   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\n', '   * @param _to The address of the recipient.\n', '   * @param _value The amount of token to be transferred.\n', '   */\n', '  function transfer(\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    external\n', '    returns (bool _success);\n', '\n', '  /**\n', '   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\n', '   * Transfer event.\n', '   * @param _from The address of the sender.\n', '   * @param _to The address of the recipient.\n', '   * @param _value The amount of token to be transferred.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    external\n', '    returns (bool _success);\n', '\n', '  /**\n', '   * @dev Allows _spender to withdraw from your account multiple times, up to\n', '   * the _value amount. If this function is called again it overwrites the current\n', '   * allowance with _value.\n', '   * @param _spender The address of the account able to transfer the tokens.\n', '   * @param _value The amount of tokens to be approved for transfer.\n', '   */\n', '  function approve(\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    external\n', '    returns (bool _success);\n', '\n', '  /**\n', '   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\n', '   * @param _owner The address of the account owning tokens.\n', '   * @param _spender The address of the account able to transfer the tokens.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '  )\n', '    external\n', '    view\n', '    returns (uint256 _remaining);\n', '\n', '  /**\n', '   * @dev Triggers when tokens are transferred, including zero value transfers.\n', '   */\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 _value\n', '  );\n', '\n', '  /**\n', '   * @dev Triggers on any successful call to approve(address _spender, uint256 _value).\n', '   */\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _spender,\n', '    uint256 _value\n', '  );\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc20/contracts/tokens/Token.sol\n', '\n', '/**\n', ' * @title ERC20 standard token implementation.\n', ' * @dev Standard ERC20 token. This contract follows the implementation at https://goo.gl/mLbAPJ.\n', ' */\n', 'contract Token is\n', '  ERC20\n', '{\n', '  using SafeMath for uint256;\n', '\n', '  /**\n', '   * Token name.\n', '   */\n', '  string internal tokenName;\n', '\n', '  /**\n', '   * Token symbol.\n', '   */\n', '  string internal tokenSymbol;\n', '\n', '  /**\n', '   * Number of decimals.\n', '   */\n', '  uint8 internal tokenDecimals;\n', '\n', '  /**\n', '   * Total supply of tokens.\n', '   */\n', '  uint256 internal tokenTotalSupply;\n', '\n', '  /**\n', '   * Balance information map.\n', '   */\n', '  mapping (address => uint256) internal balances;\n', '\n', '  /**\n', '   * Token allowance mapping.\n', '   */\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  /**\n', '   * @dev Trigger when tokens are transferred, including zero value transfers.\n', '   */\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 _value\n', '  );\n', '\n', '  /**\n', '   * @dev Trigger on any successful call to approve(address _spender, uint256 _value).\n', '   */\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _spender,\n', '    uint256 _value\n', '  );\n', '\n', '  /**\n', '   * @dev Returns the name of the token.\n', '   */\n', '  function name()\n', '    external\n', '    view\n', '    returns (string _name)\n', '  {\n', '    _name = tokenName;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the symbol of the token.\n', '   */\n', '  function symbol()\n', '    external\n', '    view\n', '    returns (string _symbol)\n', '  {\n', '    _symbol = tokenSymbol;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number of decimals the token uses.\n', '   */\n', '  function decimals()\n', '    external\n', '    view\n', '    returns (uint8 _decimals)\n', '  {\n', '    _decimals = tokenDecimals;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the total token supply.\n', '   */\n', '  function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256 _totalSupply)\n', '  {\n', '    _totalSupply = tokenTotalSupply;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the account balance of another account with address _owner.\n', '   * @param _owner The address from which the balance will be retrieved.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    view\n', '    returns (uint256 _balance)\n', '  {\n', '    _balance = balances[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\n', '   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\n', '   * @param _to The address of the recipient.\n', '   * @param _value The amount of token to be transferred.\n', '   */\n', '  function transfer(\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool _success)\n', '  {\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '\n', '    emit Transfer(msg.sender, _to, _value);\n', '    _success = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows _spender to withdraw from your account multiple times, up to the _value amount. If\n', '   * this function is called again it overwrites the current allowance with _value.\n', '   * @param _spender The address of the account able to transfer the tokens.\n', '   * @param _value The amount of tokens to be approved for transfer.\n', '   */\n', '  function approve(\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool _success)\n', '  {\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '\n', '    emit Approval(msg.sender, _spender, _value);\n', '    _success = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\n', '   * @param _owner The address of the account owning tokens.\n', '   * @param _spender The address of the account able to transfer the tokens.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '  )\n', '    external\n', '    view\n', '    returns (uint256 _remaining)\n', '  {\n', '    _remaining = allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\n', '   * Transfer event.\n', '   * @param _from The address of the sender.\n', '   * @param _to The address of the recipient.\n', '   * @param _value The amount of token to be transferred.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool _success)\n', '  {\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '    emit Transfer(_from, _to, _value);\n', '    _success = true;\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-zxc/contracts/tokens/Zxc.sol\n', '\n', '/*\n', ' * @title ZXC protocol token.\n', ' * @dev Standard ERC20 token used by the 0xcert protocol. This contract follows the implementation\n', ' * at https://goo.gl/twbPwp.\n', ' */\n', 'contract Zxc is\n', '  Token,\n', '  Ownable\n', '{\n', '  using SafeMath for uint256;\n', '\n', '  /**\n', '   * Transfer feature state.\n', '   */\n', '  bool internal transferEnabled;\n', '\n', '  /**\n', '   * Crowdsale smart contract address.\n', '   */\n', '  address public crowdsaleAddress;\n', '\n', '  /**\n', '   * @dev An event which is triggered when tokens are burned.\n', '   * @param _burner The address which burns tokens.\n', '   * @param _value The amount of burned tokens.\n', '   */\n', '  event Burn(\n', '    address indexed _burner,\n', '    uint256 _value\n', '  );\n', '\n', '  /**\n', '   * @dev Assures that the provided address is a valid destination to transfer tokens to.\n', '   * @param _to Target address.\n', '   */\n', '  modifier validDestination(\n', '    address _to\n', '  )\n', '  {\n', '    require(_to != address(0x0));\n', '    require(_to != address(this));\n', '    require(_to != address(crowdsaleAddress));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Assures that tokens can be transfered.\n', '   */\n', '  modifier onlyWhenTransferAllowed()\n', '  {\n', '    require(transferEnabled || msg.sender == crowdsaleAddress);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    tokenName = "0xcert Protocol Token";\n', '    tokenSymbol = "ZXC";\n', '    tokenDecimals = 18;\n', '    tokenTotalSupply = 400000000000000000000000000;\n', '    transferEnabled = false;\n', '\n', '    balances[owner] = tokenTotalSupply;\n', '    emit Transfer(address(0x0), owner, tokenTotalSupply);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers token to a specified address.\n', '   * @param _to The address to transfer to.\n', '   * @param _value The amount to be transferred.\n', '   */\n', '  function transfer(\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    onlyWhenTransferAllowed()\n', '    validDestination(_to)\n', '    public\n', '    returns (bool _success)\n', '  {\n', '    _success = super.transfer(_to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers tokens from one address to another.\n', '   * @param _from address The address which you want to send tokens from.\n', '   * @param _to address The address which you want to transfer to.\n', '   * @param _value uint256 The amount of tokens to be transferred.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    onlyWhenTransferAllowed()\n', '    validDestination(_to)\n', '    public\n', '    returns (bool _success)\n', '  {\n', '    _success = super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Enables token transfers.\n', '   */\n', '  function enableTransfer()\n', '    onlyOwner()\n', '    external\n', '  {\n', '    transferEnabled = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens. This function is based on BurnableToken implementation\n', '   * at goo.gl/GZEhaq.\n', '   * @notice Only owner is allowed to perform this operation.\n', '   * @param _value The amount of tokens to be burned.\n', '   */\n', '  function burn(\n', '    uint256 _value\n', '  )\n', '    onlyOwner()\n', '    external\n', '  {\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[owner] = balances[owner].sub(_value);\n', '    tokenTotalSupply = tokenTotalSupply.sub(_value);\n', '\n', '    emit Burn(owner, _value);\n', '    emit Transfer(owner, address(0x0), _value);\n', '  }\n', '\n', '  /**\n', '    * @dev Set crowdsale address which can distribute tokens even when onlyWhenTransferAllowed is\n', '    * false.\n', '    * @param crowdsaleAddr Address of token offering contract.\n', '    */\n', '  function setCrowdsaleAddress(\n', '    address crowdsaleAddr\n', '  )\n', '    external\n', '    onlyOwner()\n', '  {\n', '    crowdsaleAddress = crowdsaleAddr;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/crowdsale/ZxcCrowdsale.sol\n', '\n', '/**\n', ' * @title ZXC crowdsale contract.\n', ' * @dev Crowdsale contract for distributing ZXC tokens.\n', ' * Start timestamps for the token sale stages (start dates are inclusive, end exclusive):\n', ' *   - Token presale with 10% bonus: 2018/06/26 - 2018/07/04\n', ' *   - Token sale with 5% bonus: 2018/07/04 - 2018/07/05\n', ' *   - Token sale with 0% bonus: 2018/07/05 - 2018/07/18\n', ' */\n', 'contract ZxcCrowdsale\n', '{\n', '  using SafeMath for uint256;\n', '\n', '  /**\n', '   * @dev Token being sold.\n', '   */\n', '  Zxc public token;\n', '\n', '  /**\n', '   * @dev Xcert KYC token.\n', '   */\n', '  Xcert public xcertKyc;\n', '\n', '  /**\n', '   * @dev Start time of the presale.\n', '   */\n', '  uint256 public startTimePresale;\n', '\n', '  /**\n', '   * @dev Start time of the token sale with bonus.\n', '   */\n', '  uint256 public startTimeSaleWithBonus;\n', '\n', '  /**\n', '   * @dev Start time of the token sale with no bonus.\n', '   */\n', '  uint256 public startTimeSaleNoBonus;\n', '\n', '  /**\n', '   * @dev Presale bonus expressed as percentage integer (10% = 10).\n', '   */\n', '  uint256 public bonusPresale;\n', '\n', '  /**\n', '   * @dev Token sale bonus expressed as percentage integer (10% = 10).\n', '   */\n', '  uint256 public bonusSale;\n', '\n', '  /**\n', '   * @dev End timestamp to end the crowdsale.\n', '   */\n', '  uint256 public endTime;\n', '\n', '  /**\n', '   * @dev Minimum required wei deposit for public presale period.\n', '   */\n', '  uint256 public minimumPresaleWeiDeposit;\n', '\n', '  /**\n', '   * @dev Total amount of ZXC tokens offered for the presale.\n', '   */\n', '  uint256 public preSaleZxcCap;\n', '\n', '  /**\n', '   * @dev Total supply of ZXC tokens for the sale.\n', '   */\n', '  uint256 public crowdSaleZxcSupply;\n', '\n', '  /**\n', '   * @dev Amount of ZXC tokens sold.\n', '   */\n', '  uint256 public zxcSold;\n', '\n', '  /**\n', '   * @dev Address where funds are collected.\n', '   */\n', '  address public wallet;\n', '\n', '  /**\n', '   * @dev How many token units buyer gets per wei.\n', '   */\n', '  uint256 public rate;\n', '\n', '  /**\n', '   * @dev An event which is triggered when tokens are bought.\n', '   * @param _from The address sending tokens.\n', '   * @param _to The address receiving tokens.\n', '   * @param _weiAmount Purchase amount in wei.\n', '   * @param _tokenAmount The amount of purchased tokens.\n', '   */\n', '  event TokenPurchase(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 _weiAmount,\n', '    uint256 _tokenAmount\n', '  );\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   * @param _walletAddress Address of the wallet which collects funds.\n', '   * @param _tokenAddress Address of the ZXC token contract.\n', '   * @param _xcertKycAddress Address of the Xcert KYC token contract.\n', '   * @param _startTimePresale Start time of presale stage.\n', '   * @param _startTimeSaleWithBonus Start time of public sale stage with bonus.\n', '   * @param _startTimeSaleNoBonus Start time of public sale stage with no bonus.\n', '   * @param _endTime Time when sale ends.\n', '   * @param _rate ZXC/ETH exchange rate.\n', '   * @param _presaleZxcCap Maximum number of ZXC offered for the presale.\n', '   * @param _crowdSaleZxcSupply Supply of ZXC tokens offered for the sale. Includes _presaleZxcCap.\n', '   * @param _bonusPresale Bonus token percentage for presale.\n', '   * @param _bonusSale Bonus token percentage for public sale stage with bonus.\n', '   * @param _minimumPresaleWeiDeposit Minimum required deposit in wei.\n', '   */\n', '  constructor(\n', '    address _walletAddress,\n', '    address _tokenAddress,\n', '    address _xcertKycAddress,\n', '    uint256 _startTimePresale,  // 1529971200: date -d &#39;2018-06-26 00:00:00 UTC&#39; +%s\n', '    uint256 _startTimeSaleWithBonus, // 1530662400: date -d &#39;2018-07-04 00:00:00 UTC&#39; +%s\n', '    uint256 _startTimeSaleNoBonus,  //1530748800: date -d &#39;2018-07-05 00:00:00 UTC&#39; +%s\n', '    uint256 _endTime,  // 1531872000: date -d &#39;2018-07-18 00:00:00 UTC&#39; +%s\n', '    uint256 _rate,  // 10000: 1 ETH = 10,000 ZXC\n', '    uint256 _presaleZxcCap, // 195M\n', '    uint256 _crowdSaleZxcSupply, // 250M\n', '    uint256 _bonusPresale,  // 10 (%)\n', '    uint256 _bonusSale,  // 5 (%)\n', '    uint256 _minimumPresaleWeiDeposit  // 1 ether;\n', '  )\n', '    public\n', '  {\n', '    require(_walletAddress != address(0));\n', '    require(_tokenAddress != address(0));\n', '    require(_xcertKycAddress != address(0));\n', '    require(_tokenAddress != _walletAddress);\n', '    require(_tokenAddress != _xcertKycAddress);\n', '    require(_xcertKycAddress != _walletAddress);\n', '\n', '    token = Zxc(_tokenAddress);\n', '    xcertKyc = Xcert(_xcertKycAddress);\n', '\n', '    uint8 _tokenDecimals = token.decimals();\n', '    require(_tokenDecimals == 18);  // Sanity check.\n', '    wallet = _walletAddress;\n', '\n', '    // Bonus should be > 0% and <= 100%\n', '    require(_bonusPresale > 0 && _bonusPresale <= 100);\n', '    require(_bonusSale > 0 && _bonusSale <= 100);\n', '\n', '    bonusPresale = _bonusPresale;\n', '    bonusSale = _bonusSale;\n', '\n', '    require(_startTimePresale >= now);\n', '    require(_startTimeSaleWithBonus > _startTimePresale);\n', '    require(_startTimeSaleNoBonus > _startTimeSaleWithBonus);\n', '\n', '    startTimePresale = _startTimePresale;\n', '    startTimeSaleWithBonus = _startTimeSaleWithBonus;\n', '    startTimeSaleNoBonus = _startTimeSaleNoBonus;\n', '    endTime = _endTime;\n', '\n', '    require(_rate > 0);\n', '    rate = _rate;\n', '\n', '    require(_crowdSaleZxcSupply > 0);\n', '    require(token.totalSupply() >= _crowdSaleZxcSupply);\n', '    crowdSaleZxcSupply = _crowdSaleZxcSupply;\n', '\n', '    require(_presaleZxcCap > 0 && _presaleZxcCap <= _crowdSaleZxcSupply);\n', '    preSaleZxcCap = _presaleZxcCap;\n', '\n', '    zxcSold = 0;\n', '\n', '    require(_minimumPresaleWeiDeposit > 0);\n', '    minimumPresaleWeiDeposit = _minimumPresaleWeiDeposit;\n', '  }\n', '\n', '  /**\n', '   * @dev Fallback function can be used to buy tokens.\n', '   */\n', '  function()\n', '    external\n', '    payable\n', '  {\n', '    buyTokens();\n', '  }\n', '\n', '  /**\n', '   * @dev Low level token purchase function.\n', '   */\n', '  function buyTokens()\n', '    public\n', '    payable\n', '  {\n', '    uint256 tokens;\n', '\n', '    // Sender needs Xcert KYC token.\n', '    uint256 balance = xcertKyc.balanceOf(msg.sender);\n', '    require(balance > 0);\n', '    \n', '    if (isInTimeRange(startTimePresale, startTimeSaleWithBonus)) {\n', '      uint256 tokenId = xcertKyc.tokenOfOwnerByIndex(msg.sender, balance.sub(1));\n', '      uint256 kycLevel = uint(xcertKyc.tokenDataValue(tokenId, 0));\n', '      require(kycLevel > 1);\n', '      require(msg.value >= minimumPresaleWeiDeposit);\n', '      tokens = getTokenAmount(msg.value, bonusPresale);\n', '      require(tokens <= preSaleZxcCap);\n', '    }\n', '    else if (isInTimeRange(startTimeSaleWithBonus, startTimeSaleNoBonus)) {\n', '      tokens = getTokenAmount(msg.value, bonusSale);\n', '    }\n', '    else if (isInTimeRange(startTimeSaleNoBonus, endTime)) {\n', '      tokens = getTokenAmount(msg.value, uint256(0));\n', '    }\n', '    else {\n', '      revert("Purchase outside of token sale time windows");\n', '    }\n', '\n', '    require(zxcSold.add(tokens) <= crowdSaleZxcSupply);\n', '    zxcSold = zxcSold.add(tokens);\n', '\n', '    wallet.transfer(msg.value);\n', '    require(token.transferFrom(token.owner(), msg.sender, tokens));\n', '    emit TokenPurchase(msg.sender, msg.sender, msg.value, tokens);\n', '  }\n', '\n', '  /**\n', '   * @return true if crowdsale event has ended\n', '   */\n', '  function hasEnded()\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    bool capReached = zxcSold >= crowdSaleZxcSupply;\n', '    bool endTimeReached = now >= endTime;\n', '    return capReached || endTimeReached;\n', '  }\n', '\n', '  /**\n', '   * @dev Check if currently active period is a given time period.\n', '   * @param _startTime Starting timestamp (inclusive).\n', '   * @param _endTime Ending timestamp (exclusive).\n', '   * @return bool\n', '   */\n', '  function isInTimeRange(\n', '    uint256 _startTime,\n', '    uint256 _endTime\n', '  )\n', '    internal\n', '    view\n', '    returns(bool)\n', '  {\n', '    if (now >= _startTime && now < _endTime) {\n', '      return true;\n', '    }\n', '    else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Calculate amount of tokens for a given wei amount. Apply special bonuses depending on\n', '   * @param weiAmount Amount of wei for token purchase.\n', '   * @param bonusPercent Percentage of bonus tokens.\n', '   * @return Number of tokens with possible bonus.\n', '   */\n', '  function getTokenAmount(\n', '    uint256 weiAmount,\n', '    uint256 bonusPercent\n', '  )\n', '    internal\n', '    view\n', '    returns(uint256)\n', '  {\n', '    uint256 tokens = weiAmount.mul(rate);\n', '\n', '    if (bonusPercent > 0) {\n', '      uint256 bonusTokens = tokens.mul(bonusPercent).div(uint256(100)); // tokens * bonus (%) / 100%\n', '      tokens = tokens.add(bonusTokens);\n', '    }\n', '\n', '    return tokens;\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// File: @0xcert/ethereum-utils/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @dev Math operations with safety checks that throw on error. This contract is based\n', ' * on the source code at https://goo.gl/iyQsmU.\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '   * @dev Multiplies two numbers, throws on overflow.\n', '   * @param _a Factor number.\n', '   * @param _b Factor number.\n', '   */\n', '  function mul(\n', '    uint256 _a,\n', '    uint256 _b\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Integer division of two numbers, truncating the quotient.\n', '   * @param _a Dividend number.\n', '   * @param _b Divisor number.\n', '   */\n', '  function div(\n', '    uint256 _a,\n', '    uint256 _b\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    uint256 c = _a / _b;\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '   * @param _a Minuend number.\n', '   * @param _b Subtrahend number.\n', '   */\n', '  function sub(\n', '    uint256 _a,\n', '    uint256 _b\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds two numbers, throws on overflow.\n', '   * @param _a Number.\n', '   * @param _b Number.\n', '   */\n', '  function add(\n', '    uint256 _a,\n', '    uint256 _b\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    uint256 c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721Enumerable.sol\n', '\n', '/**\n', ' * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\n', ' * See https://goo.gl/pc9yoS.\n', ' */\n', 'interface ERC721Enumerable {\n', '\n', '  /**\n', '   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\n', '   * assigned and queryable owner not equal to the zero address.\n', '   */\n', '  function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\n', '   * @param _index A counter less than `totalSupply()`.\n', '   */\n', '  function tokenByIndex(\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\n', '   * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\n', '   * representing invalid NFTs.\n', '   * @param _owner An address where we are interested in NFTs owned by them.\n', '   * @param _index A counter less than `balanceOf(_owner)`.\n', '   */\n', '  function tokenOfOwnerByIndex(\n', '    address _owner,\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721.sol\n', '\n', '/**\n', ' * @dev ERC-721 non-fungible token standard. See https://goo.gl/pc9yoS.\n', ' */\n', 'interface ERC721 {\n', '\n', '  /**\n', '   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n', '   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n', '   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n', '   * transfer, the approved address for that NFT (if any) is reset to none.\n', '   */\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n', '   * address indicates there is no approved address. When a Transfer event emits, this also\n', '   * indicates that the approved address for that NFT (if any) is reset to none.\n', '   */\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _approved,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n', '   * all NFTs of the owner.\n', '   */\n', '  event ApprovalForAll(\n', '    address indexed _owner,\n', '    address indexed _operator,\n', '    bool _approved\n', '  );\n', '\n', '  /**\n', '   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n', '   * considered invalid, and this function throws for queries about the zero address.\n', '   * @param _owner Address for whom to query the balance.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n', '   * invalid, and queries about them do throw.\n', '   * @param _tokenId The identifier for an NFT.\n', '   */\n', '  function ownerOf(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n', '   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n', '   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n', '   * function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received`\n', '   * on `_to` and throws if the return value is not `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   * @param _data Additional data with no specified format, sent in call to `_to`.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice This works identically to the other function with an extra data parameter, except this\n', '   * function just sets data to ""\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n', '   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n', '   * address. Throws if `_tokenId` is not a valid NFT.\n', '   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n', '   * they mayb be permanently lost.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Set or reaffirm the approved address for an NFT.\n', '   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n', '   * the current NFT owner, or an authorized operator of the current owner.\n', '   * @param _approved The new approved NFT controller.\n', '   * @param _tokenId The NFT to approve.\n', '   */\n', '  function approve(\n', '    address _approved,\n', '    uint256 _tokenId\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Enables or disables approval for a third party ("operator") to manage all of\n', "   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n", '   * @notice The contract MUST allow multiple operators per owner.\n', '   * @param _operator Address to add to the set of authorized operators.\n', '   * @param _approved True if the operators is approved, false to revoke approval.\n', '   */\n', '  function setApprovalForAll(\n', '    address _operator,\n', '    bool _approved\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Get the approved address for a single NFT.\n', '   * @notice Throws if `_tokenId` is not a valid NFT.\n', '   * @param _tokenId The NFT to find the approved address for.\n', '   */\n', '  function getApproved(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '  /**\n', '   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\n', '   * @param _owner The address that owns the NFTs.\n', '   * @param _operator The address that acts on behalf of the owner.\n', '   */\n', '  function isApprovedForAll(\n', '    address _owner,\n', '    address _operator\n', '  )\n', '    external\n', '    view\n', '    returns (bool);\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721TokenReceiver.sol\n', '\n', '/**\n', ' * @dev ERC-721 interface for accepting safe transfers. See https://goo.gl/pc9yoS.\n', ' */\n', 'interface ERC721TokenReceiver {\n', '\n', '  /**\n', '   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\n', '   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\n', '   * of other than the magic value MUST result in the transaction being reverted.\n', '   * Returns `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))` unless throwing.\n', '   * @notice The contract address is always the message sender. A wallet/broker/auction application\n', '   * MUST implement the wallet interface if it will accept safe transfers.\n', '   * @param _from The sending address.\n', '   * @param _tokenId The NFT identifier which is being transfered.\n', '   * @param _data Additional data with no specified format.\n', '   */\n', '  function onERC721Received(\n', '    address _from,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    external\n', '    returns(bytes4);\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @dev The contract has an owner address, and provides basic authorization control whitch\n', ' * simplifies the implementation of user permissions. This contract is based on the source code\n', ' * at https://goo.gl/n2ZGVt.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  /**\n', '   * @dev An event which is triggered when the owner is changed.\n', '   * @param previousOwner The address of the previous owner.\n', '   * @param newOwner The address of the new owner.\n', '   */\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The constructor sets the original `owner` of the contract to the sender account.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(\n', '    address _newOwner\n', '  )\n', '    onlyOwner\n', '    public\n', '  {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/utils/AddressUtils.sol\n', '\n', '/**\n', ' * @dev Utility library of inline functions on addresses.\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * @dev Returns whether the target address is a contract.\n', '   * @param _addr Address to check.\n', '   */\n', '  function isContract(\n', '    address _addr\n', '  )\n', '    internal\n', '    view\n', '    returns (bool)\n', '  {\n', '    uint256 size;\n', '\n', '    /**\n', '     * XXX Currently there is no better way to check if there is a contract in an address than to\n', '     * check the size of the code at that address.\n', '     * See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\n', '     * TODO: Check this again before the Serenity release, because all addresses will be\n', '     * contracts then.\n', '     */\n', '    assembly { size := extcodesize(_addr) } // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/utils/ERC165.sol\n', '\n', '/**\n', ' * @dev A standard for detecting smart contract interfaces. See https://goo.gl/cxQCse.\n', ' */\n', 'interface ERC165 {\n', '\n', '  /**\n', '   * @dev Checks if the smart contract includes a specific interface.\n', '   * @notice This function uses less than 30,000 gas.\n', '   * @param _interfaceID The interface identifier, as specified in ERC-165.\n', '   */\n', '  function supportsInterface(\n', '    bytes4 _interfaceID\n', '  )\n', '    external\n', '    view\n', '    returns (bool);\n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/utils/SupportsInterface.sol\n', '\n', '/**\n', ' * @dev Implementation of standard for detect smart contract interfaces.\n', ' */\n', 'contract SupportsInterface is ERC165 {\n', '\n', '  /**\n', '   * @dev Mapping of supported intefraces.\n', '   * @notice You must not set element 0xffffffff to true.\n', '   */\n', '  mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x01ffc9a7] = true; // ERC165\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check which interfaces are suported by this contract.\n', '   * @param _interfaceID Id of the interface.\n', '   */\n', '  function supportsInterface(\n', '    bytes4 _interfaceID\n', '  )\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    return supportedInterfaces[_interfaceID];\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/NFToken.sol\n', '\n', '/**\n', ' * @dev Implementation of ERC-721 non-fungible token standard.\n', ' */\n', 'contract NFToken is\n', '  Ownable,\n', '  ERC721,\n', '  SupportsInterface\n', '{\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  /**\n', '   * @dev A mapping from NFT ID to the address that owns it.\n', '   */\n', '  mapping (uint256 => address) internal idToOwner;\n', '\n', '  /**\n', '   * @dev Mapping from NFT ID to approved address.\n', '   */\n', '  mapping (uint256 => address) internal idToApprovals;\n', '\n', '   /**\n', '   * @dev Mapping from owner address to count of his tokens.\n', '   */\n', '  mapping (address => uint256) internal ownerToNFTokenCount;\n', '\n', '  /**\n', '   * @dev Mapping from owner address to mapping of operator addresses.\n', '   */\n', '  mapping (address => mapping (address => bool)) internal ownerToOperators;\n', '\n', '  /**\n', '   * @dev Magic value of a smart contract that can recieve NFT.\n', '   * Equal to: keccak256("onERC721Received(address,uint256,bytes)").\n', '   */\n', '  bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  /**\n', '   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n', '   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n', '   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n', '   * transfer, the approved address for that NFT (if any) is reset to none.\n', '   * @param _from Sender of NFT (if address is zero address it indicates token creation).\n', '   * @param _to Receiver of NFT (if address is zero address it indicates token destruction).\n', '   * @param _tokenId The NFT that got transfered.\n', '   */\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n', '   * address indicates there is no approved address. When a Transfer event emits, this also\n', '   * indicates that the approved address for that NFT (if any) is reset to none.\n', '   * @param _owner Owner of NFT.\n', '   * @param _approved Address that we are approving.\n', '   * @param _tokenId NFT which we are approving.\n', '   */\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _approved,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n', '   * all NFTs of the owner.\n', '   * @param _owner Owner of NFT.\n', '   * @param _operator Address to which we are setting operator rights.\n', '   * @param _approved Status of operator rights(true if operator rights are given and false if\n', '   * revoked).\n', '   */\n', '  event ApprovalForAll(\n', '    address indexed _owner,\n', '    address indexed _operator,\n', '    bool _approved\n', '  );\n', '\n', '  /**\n', '   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\n', '   * @param _tokenId ID of the NFT to validate.\n', '   */\n', '  modifier canOperate(\n', '    uint256 _tokenId\n', '  ) {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender]);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Guarantees that the msg.sender is allowed to transfer NFT.\n', '   * @param _tokenId ID of the NFT to transfer.\n', '   */\n', '  modifier canTransfer(\n', '    uint256 _tokenId\n', '  ) {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(\n', '      tokenOwner == msg.sender\n', '      || getApproved(_tokenId) == msg.sender\n', '      || ownerToOperators[tokenOwner][msg.sender]\n', '    );\n', '\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Guarantees that _tokenId is a valid Token.\n', '   * @param _tokenId ID of the NFT to validate.\n', '   */\n', '  modifier validNFToken(\n', '    uint256 _tokenId\n', '  ) {\n', '    require(idToOwner[_tokenId] != address(0));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x80ac58cd] = true; // ERC721\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n', '   * considered invalid, and this function throws for queries about the zero address.\n', '   * @param _owner Address for whom to query the balance.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    view\n', '    returns (uint256)\n', '  {\n', '    require(_owner != address(0));\n', '    return ownerToNFTokenCount[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n', '   * invalid, and queries about them do throw.\n', '   * @param _tokenId The identifier for an NFT.\n', '   */\n', '  function ownerOf(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns (address _owner)\n', '  {\n', '    _owner = idToOwner[_tokenId];\n', '    require(_owner != address(0));\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n', '   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n', '   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n', '   * function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received`\n', '   * on `_to` and throws if the return value is not `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   * @param _data Additional data with no specified format, sent in call to `_to`.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    external\n', '  {\n', '    _safeTransferFrom(_from, _to, _tokenId, _data);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice This works identically to the other function with an extra data parameter, except this\n', '   * function just sets data to ""\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '  {\n', '    _safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n', '   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n', '   * address. Throws if `_tokenId` is not a valid NFT.\n', '   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n', '   * they maybe be permanently lost.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    canTransfer(_tokenId)\n', '    validNFToken(_tokenId)\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(tokenOwner == _from);\n', '    require(_to != address(0));\n', '\n', '    _transfer(_to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Set or reaffirm the approved address for an NFT.\n', '   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n', '   * the current NFT owner, or an authorized operator of the current owner.\n', '   * @param _approved Address to be approved for the given NFT ID.\n', '   * @param _tokenId ID of the token to be approved.\n', '   */\n', '  function approve(\n', '    address _approved,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    canOperate(_tokenId)\n', '    validNFToken(_tokenId)\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(_approved != tokenOwner);\n', '\n', '    idToApprovals[_tokenId] = _approved;\n', '    emit Approval(tokenOwner, _approved, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Enables or disables approval for a third party ("operator") to manage all of\n', "   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n", "   * @notice This works even if sender doesn't own any tokens at the time.\n", '   * @param _operator Address to add to the set of authorized operators.\n', '   * @param _approved True if the operators is approved, false to revoke approval.\n', '   */\n', '  function setApprovalForAll(\n', '    address _operator,\n', '    bool _approved\n', '  )\n', '    external\n', '  {\n', '    require(_operator != address(0));\n', '    ownerToOperators[msg.sender][_operator] = _approved;\n', '    emit ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /**\n', '   * @dev Get the approved address for a single NFT.\n', '   * @notice Throws if `_tokenId` is not a valid NFT.\n', '   * @param _tokenId ID of the NFT to query the approval of.\n', '   */\n', '  function getApproved(\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '    view\n', '    validNFToken(_tokenId)\n', '    returns (address)\n', '  {\n', '    return idToApprovals[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Checks if `_operator` is an approved operator for `_owner`.\n', '   * @param _owner The address that owns the NFTs.\n', '   * @param _operator The address that acts on behalf of the owner.\n', '   */\n', '  function isApprovedForAll(\n', '    address _owner,\n', '    address _operator\n', '  )\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    require(_owner != address(0));\n', '    require(_operator != address(0));\n', '    return ownerToOperators[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '   * @dev Actually perform the safeTransferFrom.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   * @param _data Additional data with no specified format, sent in call to `_to`.\n', '   */\n', '  function _safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    internal\n', '    canTransfer(_tokenId)\n', '    validNFToken(_tokenId)\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(tokenOwner == _from);\n', '    require(_to != address(0));\n', '\n', '    _transfer(_to, _tokenId);\n', '\n', '    if (_to.isContract()) {\n', '      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, _data);\n', '      require(retval == MAGIC_ON_ERC721_RECEIVED);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Actually preforms the transfer.\n', '   * @notice Does NO checks.\n', '   * @param _to Address of a new owner.\n', '   * @param _tokenId The NFT that is being transferred.\n', '   */\n', '  function _transfer(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    private\n', '  {\n', '    address from = idToOwner[_tokenId];\n', '\n', '    clearApproval(from, _tokenId);\n', '    removeNFToken(from, _tokenId);\n', '    addNFToken(_to, _tokenId);\n', '\n', '    emit Transfer(from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @notice This is a private function which should be called from user-implemented external\n', '   * mint function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _to The address that will own the minted NFT.\n', '   * @param _tokenId of the NFT to be minted by the msg.sender.\n', '   */\n', '  function _mint(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    require(_to != address(0));\n', '    require(_tokenId != 0);\n', '    require(idToOwner[_tokenId] == address(0));\n', '\n', '    addNFToken(_to, _tokenId);\n', '\n', '    emit Transfer(address(0), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a NFT.\n', '   * @notice This is a private function which should be called from user-implemented external\n', '   * burn function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _owner Address of the NFT owner.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function _burn(\n', '    address _owner,\n', '    uint256 _tokenId\n', '  )\n', '    validNFToken(_tokenId)\n', '    internal\n', '  {\n', '    clearApproval(_owner, _tokenId);\n', '    removeNFToken(_owner, _tokenId);\n', '    emit Transfer(_owner, address(0), _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Clears the current approval of a given NFT ID.\n', '   * @param _tokenId ID of the NFT to be transferred.\n', '   */\n', '  function clearApproval(\n', '    address _owner,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    delete idToApprovals[_tokenId];\n', '    emit Approval(_owner, 0, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Removes a NFT from owner.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _from Address from wich we want to remove the NFT.\n', '   * @param _tokenId Which NFT we want to remove.\n', '   */\n', '  function removeNFToken(\n', '    address _from,\n', '    uint256 _tokenId\n', '  )\n', '   internal\n', '  {\n', '    require(idToOwner[_tokenId] == _from);\n', '    assert(ownerToNFTokenCount[_from] > 0);\n', '    ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from].sub(1);\n', '    delete idToOwner[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Assignes a new NFT to owner.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _to Address to wich we want to add the NFT.\n', '   * @param _tokenId Which NFT we want to add.\n', '   */\n', '  function addNFToken(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    require(idToOwner[_tokenId] == address(0));\n', '\n', '    idToOwner[_tokenId] = _to;\n', '    ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/NFTokenEnumerable.sol\n', '\n', '/**\n', ' * @dev Optional enumeration implementation for ERC-721 non-fungible token standard.\n', ' */\n', 'contract NFTokenEnumerable is\n', '  NFToken,\n', '  ERC721Enumerable\n', '{\n', '\n', '  /**\n', '   * @dev Array of all NFT IDs.\n', '   */\n', '  uint256[] internal tokens;\n', '\n', '  /**\n', '   * @dev Mapping from owner address to a list of owned NFT IDs.\n', '   */\n', '  mapping(uint256 => uint256) internal idToIndex;\n', '\n', '  /**\n', '   * @dev Mapping from owner to list of owned NFT IDs.\n', '   */\n', '  mapping(address => uint256[]) internal ownerToIds;\n', '\n', '  /**\n', '   * @dev Mapping from NFT ID to its index in the owner tokens list.\n', '   */\n', '  mapping(uint256 => uint256) internal idToOwnerIndex;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @notice This is a private function which should be called from user-implemented external\n', '   * mint function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _to The address that will own the minted NFT.\n', '   * @param _tokenId of the NFT to be minted by the msg.sender.\n', '   */\n', '  function _mint(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    super._mint(_to, _tokenId);\n', '    tokens.push(_tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a NFT.\n', '   * @notice This is a private function which should be called from user-implemented external\n', '   * burn function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _owner Address of the NFT owner.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function _burn(\n', '    address _owner,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    assert(tokens.length > 0);\n', '    super._burn(_owner, _tokenId);\n', '\n', '    uint256 tokenIndex = idToIndex[_tokenId];\n', '    uint256 lastTokenIndex = tokens.length.sub(1);\n', '    uint256 lastToken = tokens[lastTokenIndex];\n', '\n', '    tokens[tokenIndex] = lastToken;\n', '    tokens[lastTokenIndex] = 0;\n', '\n', '    tokens.length--;\n', '    idToIndex[_tokenId] = 0;\n', '    idToIndex[lastToken] = tokenIndex;\n', '  }\n', '\n', '  /**\n', '   * @dev Removes a NFT from an address.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _from Address from wich we want to remove the NFT.\n', '   * @param _tokenId Which NFT we want to remove.\n', '   */\n', '  function removeNFToken(\n', '    address _from,\n', '    uint256 _tokenId\n', '  )\n', '   internal\n', '  {\n', '    super.removeNFToken(_from, _tokenId);\n', '    assert(ownerToIds[_from].length > 0);\n', '\n', '    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\n', '    uint256 lastTokenIndex = ownerToIds[_from].length.sub(1);\n', '    uint256 lastToken = ownerToIds[_from][lastTokenIndex];\n', '\n', '    ownerToIds[_from][tokenToRemoveIndex] = lastToken;\n', '    ownerToIds[_from][lastTokenIndex] = 0;\n', '\n', '    ownerToIds[_from].length--;\n', '    idToOwnerIndex[_tokenId] = 0;\n', '    idToOwnerIndex[lastToken] = tokenToRemoveIndex;\n', '  }\n', '\n', '  /**\n', '   * @dev Assignes a new NFT to an address.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _to Address to wich we want to add the NFT.\n', '   * @param _tokenId Which NFT we want to add.\n', '   */\n', '  function addNFToken(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    super.addNFToken(_to, _tokenId);\n', '\n', '    uint256 length = ownerToIds[_to].length;\n', '    ownerToIds[_to].push(_tokenId);\n', '    idToOwnerIndex[_tokenId] = length;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the count of all existing NFTokens.\n', '   */\n', '  function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return tokens.length;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns NFT ID by its index.\n', '   * @param _index A counter less than `totalSupply()`.\n', '   */\n', '  function tokenByIndex(\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256)\n', '  {\n', '    require(_index < tokens.length);\n', '    return tokens[_index];\n', '  }\n', '\n', '  /**\n', "   * @dev returns the n-th NFT ID from a list of owner's tokens.\n", "   * @param _owner Token owner's address.\n", "   * @param _index Index number representing n-th token in owner's list of tokens.\n", '   */\n', '  function tokenOfOwnerByIndex(\n', '    address _owner,\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256)\n', '  {\n', '    require(_index < ownerToIds[_owner].length);\n', '    return ownerToIds[_owner][_index];\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721Metadata.sol\n', '\n', '/**\n', ' * @dev Optional metadata extension for ERC-721 non-fungible token standard.\n', ' * See https://goo.gl/pc9yoS.\n', ' */\n', 'interface ERC721Metadata {\n', '\n', '  /**\n', '   * @dev Returns a descriptive name for a collection of NFTs in this contract.\n', '   */\n', '  function name()\n', '    external\n', '    view\n', '    returns (string _name);\n', '\n', '  /**\n', '   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\n', '   */\n', '  function symbol()\n', '    external\n', '    view\n', '    returns (string _symbol);\n', '\n', '  /**\n', '   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\n', '   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\n', '   * that conforms to the "ERC721 Metadata JSON Schema".\n', '   */\n', '  function tokenURI(uint256 _tokenId)\n', '    external\n', '    view\n', '    returns (string);\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/NFTokenMetadata.sol\n', '\n', '/**\n', ' * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\n', ' */\n', 'contract NFTokenMetadata is\n', '  NFToken,\n', '  ERC721Metadata\n', '{\n', '\n', '  /**\n', '   * @dev A descriptive name for a collection of NFTs.\n', '   */\n', '  string internal nftName;\n', '\n', '  /**\n', '   * @dev An abbreviated name for NFTokens.\n', '   */\n', '  string internal nftSymbol;\n', '\n', '  /**\n', '   * @dev Mapping from NFT ID to metadata uri.\n', '   */\n', '  mapping (uint256 => string) internal idToUri;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', "   * @notice When implementing this contract don't forget to set nftName and nftSymbol.\n", '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a NFT.\n', '   * @notice This is a internal function which should be called from user-implemented external\n', '   * burn function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _owner Address of the NFT owner.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function _burn(\n', '    address _owner,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    super._burn(_owner, _tokenId);\n', '\n', '    if (bytes(idToUri[_tokenId]).length != 0) {\n', '      delete idToUri[_tokenId];\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\n', '   * @notice this is a internal function which should be called from user-implemented external\n', '   * function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _tokenId Id for which we want uri.\n', '   * @param _uri String representing RFC 3986 URI.\n', '   */\n', '  function _setTokenUri(\n', '    uint256 _tokenId,\n', '    string _uri\n', '  )\n', '    validNFToken(_tokenId)\n', '    internal\n', '  {\n', '    idToUri[_tokenId] = _uri;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns a descriptive name for a collection of NFTokens.\n', '   */\n', '  function name()\n', '    external\n', '    view\n', '    returns (string _name)\n', '  {\n', '    _name = nftName;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns an abbreviated name for NFTokens.\n', '   */\n', '  function symbol()\n', '    external\n', '    view\n', '    returns (string _symbol)\n', '  {\n', '    _symbol = nftSymbol;\n', '  }\n', '\n', '  /**\n', '   * @dev A distinct URI (RFC 3986) for a given NFT.\n', '   * @param _tokenId Id for which we want uri.\n', '   */\n', '  function tokenURI(\n', '    uint256 _tokenId\n', '  )\n', '    validNFToken(_tokenId)\n', '    external\n', '    view\n', '    returns (string)\n', '  {\n', '    return idToUri[_tokenId];\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-xcert/contracts/tokens/Xcert.sol\n', '\n', '/**\n', ' * @dev Xcert implementation.\n', ' */\n', 'contract Xcert is NFTokenEnumerable, NFTokenMetadata {\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  /**\n', '   * @dev Unique ID which determines each Xcert smart contract type by its JSON convention.\n', '   * @notice Calculated as bytes4(keccak256(jsonSchema)).\n', '   */\n', '  bytes4 internal nftConventionId;\n', '\n', '  /**\n', '   * @dev Maps NFT ID to proof.\n', '   */\n', '  mapping (uint256 => string) internal idToProof;\n', '\n', '  /**\n', '   * @dev Maps NFT ID to protocol config.\n', '   */\n', '  mapping (uint256 => bytes32[]) internal config;\n', '\n', '  /**\n', '   * @dev Maps NFT ID to convention data.\n', '   */\n', '  mapping (uint256 => bytes32[]) internal data;\n', '\n', '  /**\n', '   * @dev Maps address to authorization of contract.\n', '   */\n', '  mapping (address => bool) internal addressToAuthorized;\n', '\n', '  /**\n', '   * @dev Emits when an address is authorized to some contract control or the authorization is revoked.\n', '   * The _target has some contract controle like minting new NFTs.\n', '   * @param _target Address to set authorized state.\n', '   * @param _authorized True if the _target is authorised, false to revoke authorization.\n', '   */\n', '  event AuthorizedAddress(\n', '    address indexed _target,\n', '    bool _authorized\n', '  );\n', '\n', '  /**\n', '   * @dev Guarantees that msg.sender is allowed to mint a new NFT.\n', '   */\n', '  modifier isAuthorized() {\n', '    require(msg.sender == owner || addressToAuthorized[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', "   * @notice When implementing this contract don't forget to set nftConventionId, nftName and\n", '   * nftSymbol.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x6be14f75] = true; // Xcert\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @param _to The address that will own the minted NFT.\n', '   * @param _id The NFT to be minted by the msg.sender.\n', '   * @param _uri An URI pointing to NFT metadata.\n', '   * @param _proof Cryptographic asset imprint.\n', '   * @param _config Array of protocol config values where 0 index represents token expiration\n', '   * timestamp, other indexes are not yet definied but are ready for future xcert upgrades.\n', '   * @param _data Array of convention data values.\n', '   */\n', '  function mint(\n', '    address _to,\n', '    uint256 _id,\n', '    string _uri,\n', '    string _proof,\n', '    bytes32[] _config,\n', '    bytes32[] _data\n', '  )\n', '    external\n', '    isAuthorized()\n', '  {\n', '    require(_config.length > 0);\n', '    require(bytes(_proof).length > 0);\n', '    super._mint(_to, _id);\n', '    super._setTokenUri(_id, _uri);\n', '    idToProof[_id] = _proof;\n', '    config[_id] = _config;\n', '    data[_id] = _data;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns a bytes4 of keccak256 of json schema representing 0xcert protocol convention.\n', '   */\n', '  function conventionId()\n', '    external\n', '    view\n', '    returns (bytes4 _conventionId)\n', '  {\n', '    _conventionId = nftConventionId;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns proof for NFT.\n', '   * @param _tokenId Id of the NFT.\n', '   */\n', '  function tokenProof(\n', '    uint256 _tokenId\n', '  )\n', '    validNFToken(_tokenId)\n', '    external\n', '    view\n', '    returns(string)\n', '  {\n', '    return idToProof[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns convention data value for a given index field.\n', '   * @param _tokenId Id of the NFT we want to get value for key.\n', '   * @param _index for which we want to get value.\n', '   */\n', '  function tokenDataValue(\n', '    uint256 _tokenId,\n', '    uint256 _index\n', '  )\n', '    validNFToken(_tokenId)\n', '    public\n', '    view\n', '    returns(bytes32 value)\n', '  {\n', '    require(_index < data[_tokenId].length);\n', '    value = data[_tokenId][_index];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns expiration date from 0 index of token config values.\n', '   * @param _tokenId Id of the NFT we want to get expiration time of.\n', '   */\n', '  function tokenExpirationTime(\n', '    uint256 _tokenId\n', '  )\n', '    validNFToken(_tokenId)\n', '    external\n', '    view\n', '    returns(bytes32)\n', '  {\n', '    return config[_tokenId][0];\n', '  }\n', '\n', '  /**\n', '   * @dev Sets authorised address for minting.\n', '   * @param _target Address to set authorized state.\n', '   * @param _authorized True if the _target is authorised, false to revoke authorization.\n', '   */\n', '  function setAuthorizedAddress(\n', '    address _target,\n', '    bool _authorized\n', '  )\n', '    onlyOwner\n', '    external\n', '  {\n', '    require(_target != address(0));\n', '    addressToAuthorized[_target] = _authorized;\n', '    emit AuthorizedAddress(_target, _authorized);\n', '  }\n', '\n', '  /**\n', '   * @dev Sets mint authorised address.\n', '   * @param _target Address for which we want to check if it is authorized.\n', '   * @return Is authorized or not.\n', '   */\n', '  function isAuthorizedAddress(\n', '    address _target\n', '  )\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    require(_target != address(0));\n', '    return addressToAuthorized[_target];\n', '  }\n', '}\n', '\n', '// File: @0xcert/ethereum-erc20/contracts/tokens/ERC20.sol\n', '\n', '/**\n', ' * @title A standard interface for tokens.\n', ' */\n', 'interface ERC20 {\n', '\n', '  /**\n', '   * @dev Returns the name of the token.\n', '   */\n', '  function name()\n', '    external\n', '    view\n', '    returns (string _name);\n', '\n', '  /**\n', '   * @dev Returns the symbol of the token.\n', '   */\n', '  function symbol()\n', '    external\n', '    view\n', '    returns (string _symbol);\n', '\n', '  /**\n', '   * @dev Returns the number of decimals the token uses.\n', '   */\n', '  function decimals()\n', '    external\n', '    view\n', '    returns (uint8 _decimals);\n', '\n', '  /**\n', '   * @dev Returns the total token supply.\n', '   */\n', '  function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256 _totalSupply);\n', '\n', '  /**\n', '   * @dev Returns the account balance of another account with address _owner.\n', '   * @param _owner The address from which the balance will be retrieved.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    view\n', '    returns (uint256 _balance);\n', '\n', '  /**\n', '   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\n', '   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\n', '   * @param _to The address of the recipient.\n', '   * @param _value The amount of token to be transferred.\n', '   */\n', '  function transfer(\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    external\n', '    returns (bool _success);\n', '\n', '  /**\n', '   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\n', '   * Transfer event.\n', '   * @param _from The address of the sender.\n', '   * @param _to The address of the recipient.\n', '   * @param _value The amount of token to be transferred.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    external\n', '    returns (bool _success);\n', '\n', '  /**\n', '   * @dev Allows _spender to withdraw from your account multiple times, up to\n', '   * the _value amount. If this function is called again it overwrites the current\n', '   * allowance with _value.\n', '   * @param _spender The address of the account able to transfer the tokens.\n', '   * @param _value The amount of tokens to be approved for transfer.\n', '   */\n', '  function approve(\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    external\n', '    returns (bool _success);\n', '\n', '  /**\n', '   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\n', '   * @param _owner The address of the account owning tokens.\n', '   * @param _spender The address of the account able to transfer the tokens.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '  )\n', '    external\n', '    view\n', '    returns (uint256 _remaining);\n', '\n', '  /**\n', '   * @dev Triggers when tokens are transferred, including zero value transfers.\n', '   */\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 _value\n', '  );\n', '\n', '  /**\n', '   * @dev Triggers on any successful call to approve(address _spender, uint256 _value).\n', '   */\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _spender,\n', '    uint256 _value\n', '  );\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc20/contracts/tokens/Token.sol\n', '\n', '/**\n', ' * @title ERC20 standard token implementation.\n', ' * @dev Standard ERC20 token. This contract follows the implementation at https://goo.gl/mLbAPJ.\n', ' */\n', 'contract Token is\n', '  ERC20\n', '{\n', '  using SafeMath for uint256;\n', '\n', '  /**\n', '   * Token name.\n', '   */\n', '  string internal tokenName;\n', '\n', '  /**\n', '   * Token symbol.\n', '   */\n', '  string internal tokenSymbol;\n', '\n', '  /**\n', '   * Number of decimals.\n', '   */\n', '  uint8 internal tokenDecimals;\n', '\n', '  /**\n', '   * Total supply of tokens.\n', '   */\n', '  uint256 internal tokenTotalSupply;\n', '\n', '  /**\n', '   * Balance information map.\n', '   */\n', '  mapping (address => uint256) internal balances;\n', '\n', '  /**\n', '   * Token allowance mapping.\n', '   */\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  /**\n', '   * @dev Trigger when tokens are transferred, including zero value transfers.\n', '   */\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 _value\n', '  );\n', '\n', '  /**\n', '   * @dev Trigger on any successful call to approve(address _spender, uint256 _value).\n', '   */\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _spender,\n', '    uint256 _value\n', '  );\n', '\n', '  /**\n', '   * @dev Returns the name of the token.\n', '   */\n', '  function name()\n', '    external\n', '    view\n', '    returns (string _name)\n', '  {\n', '    _name = tokenName;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the symbol of the token.\n', '   */\n', '  function symbol()\n', '    external\n', '    view\n', '    returns (string _symbol)\n', '  {\n', '    _symbol = tokenSymbol;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number of decimals the token uses.\n', '   */\n', '  function decimals()\n', '    external\n', '    view\n', '    returns (uint8 _decimals)\n', '  {\n', '    _decimals = tokenDecimals;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the total token supply.\n', '   */\n', '  function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256 _totalSupply)\n', '  {\n', '    _totalSupply = tokenTotalSupply;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the account balance of another account with address _owner.\n', '   * @param _owner The address from which the balance will be retrieved.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    view\n', '    returns (uint256 _balance)\n', '  {\n', '    _balance = balances[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\n', '   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\n', '   * @param _to The address of the recipient.\n', '   * @param _value The amount of token to be transferred.\n', '   */\n', '  function transfer(\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool _success)\n', '  {\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '\n', '    emit Transfer(msg.sender, _to, _value);\n', '    _success = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows _spender to withdraw from your account multiple times, up to the _value amount. If\n', '   * this function is called again it overwrites the current allowance with _value.\n', '   * @param _spender The address of the account able to transfer the tokens.\n', '   * @param _value The amount of tokens to be approved for transfer.\n', '   */\n', '  function approve(\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool _success)\n', '  {\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '\n', '    emit Approval(msg.sender, _spender, _value);\n', '    _success = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\n', '   * @param _owner The address of the account owning tokens.\n', '   * @param _spender The address of the account able to transfer the tokens.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '  )\n', '    external\n', '    view\n', '    returns (uint256 _remaining)\n', '  {\n', '    _remaining = allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\n', '   * Transfer event.\n', '   * @param _from The address of the sender.\n', '   * @param _to The address of the recipient.\n', '   * @param _value The amount of token to be transferred.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool _success)\n', '  {\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '    emit Transfer(_from, _to, _value);\n', '    _success = true;\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-zxc/contracts/tokens/Zxc.sol\n', '\n', '/*\n', ' * @title ZXC protocol token.\n', ' * @dev Standard ERC20 token used by the 0xcert protocol. This contract follows the implementation\n', ' * at https://goo.gl/twbPwp.\n', ' */\n', 'contract Zxc is\n', '  Token,\n', '  Ownable\n', '{\n', '  using SafeMath for uint256;\n', '\n', '  /**\n', '   * Transfer feature state.\n', '   */\n', '  bool internal transferEnabled;\n', '\n', '  /**\n', '   * Crowdsale smart contract address.\n', '   */\n', '  address public crowdsaleAddress;\n', '\n', '  /**\n', '   * @dev An event which is triggered when tokens are burned.\n', '   * @param _burner The address which burns tokens.\n', '   * @param _value The amount of burned tokens.\n', '   */\n', '  event Burn(\n', '    address indexed _burner,\n', '    uint256 _value\n', '  );\n', '\n', '  /**\n', '   * @dev Assures that the provided address is a valid destination to transfer tokens to.\n', '   * @param _to Target address.\n', '   */\n', '  modifier validDestination(\n', '    address _to\n', '  )\n', '  {\n', '    require(_to != address(0x0));\n', '    require(_to != address(this));\n', '    require(_to != address(crowdsaleAddress));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Assures that tokens can be transfered.\n', '   */\n', '  modifier onlyWhenTransferAllowed()\n', '  {\n', '    require(transferEnabled || msg.sender == crowdsaleAddress);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    tokenName = "0xcert Protocol Token";\n', '    tokenSymbol = "ZXC";\n', '    tokenDecimals = 18;\n', '    tokenTotalSupply = 400000000000000000000000000;\n', '    transferEnabled = false;\n', '\n', '    balances[owner] = tokenTotalSupply;\n', '    emit Transfer(address(0x0), owner, tokenTotalSupply);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers token to a specified address.\n', '   * @param _to The address to transfer to.\n', '   * @param _value The amount to be transferred.\n', '   */\n', '  function transfer(\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    onlyWhenTransferAllowed()\n', '    validDestination(_to)\n', '    public\n', '    returns (bool _success)\n', '  {\n', '    _success = super.transfer(_to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers tokens from one address to another.\n', '   * @param _from address The address which you want to send tokens from.\n', '   * @param _to address The address which you want to transfer to.\n', '   * @param _value uint256 The amount of tokens to be transferred.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    onlyWhenTransferAllowed()\n', '    validDestination(_to)\n', '    public\n', '    returns (bool _success)\n', '  {\n', '    _success = super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Enables token transfers.\n', '   */\n', '  function enableTransfer()\n', '    onlyOwner()\n', '    external\n', '  {\n', '    transferEnabled = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens. This function is based on BurnableToken implementation\n', '   * at goo.gl/GZEhaq.\n', '   * @notice Only owner is allowed to perform this operation.\n', '   * @param _value The amount of tokens to be burned.\n', '   */\n', '  function burn(\n', '    uint256 _value\n', '  )\n', '    onlyOwner()\n', '    external\n', '  {\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[owner] = balances[owner].sub(_value);\n', '    tokenTotalSupply = tokenTotalSupply.sub(_value);\n', '\n', '    emit Burn(owner, _value);\n', '    emit Transfer(owner, address(0x0), _value);\n', '  }\n', '\n', '  /**\n', '    * @dev Set crowdsale address which can distribute tokens even when onlyWhenTransferAllowed is\n', '    * false.\n', '    * @param crowdsaleAddr Address of token offering contract.\n', '    */\n', '  function setCrowdsaleAddress(\n', '    address crowdsaleAddr\n', '  )\n', '    external\n', '    onlyOwner()\n', '  {\n', '    crowdsaleAddress = crowdsaleAddr;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/crowdsale/ZxcCrowdsale.sol\n', '\n', '/**\n', ' * @title ZXC crowdsale contract.\n', ' * @dev Crowdsale contract for distributing ZXC tokens.\n', ' * Start timestamps for the token sale stages (start dates are inclusive, end exclusive):\n', ' *   - Token presale with 10% bonus: 2018/06/26 - 2018/07/04\n', ' *   - Token sale with 5% bonus: 2018/07/04 - 2018/07/05\n', ' *   - Token sale with 0% bonus: 2018/07/05 - 2018/07/18\n', ' */\n', 'contract ZxcCrowdsale\n', '{\n', '  using SafeMath for uint256;\n', '\n', '  /**\n', '   * @dev Token being sold.\n', '   */\n', '  Zxc public token;\n', '\n', '  /**\n', '   * @dev Xcert KYC token.\n', '   */\n', '  Xcert public xcertKyc;\n', '\n', '  /**\n', '   * @dev Start time of the presale.\n', '   */\n', '  uint256 public startTimePresale;\n', '\n', '  /**\n', '   * @dev Start time of the token sale with bonus.\n', '   */\n', '  uint256 public startTimeSaleWithBonus;\n', '\n', '  /**\n', '   * @dev Start time of the token sale with no bonus.\n', '   */\n', '  uint256 public startTimeSaleNoBonus;\n', '\n', '  /**\n', '   * @dev Presale bonus expressed as percentage integer (10% = 10).\n', '   */\n', '  uint256 public bonusPresale;\n', '\n', '  /**\n', '   * @dev Token sale bonus expressed as percentage integer (10% = 10).\n', '   */\n', '  uint256 public bonusSale;\n', '\n', '  /**\n', '   * @dev End timestamp to end the crowdsale.\n', '   */\n', '  uint256 public endTime;\n', '\n', '  /**\n', '   * @dev Minimum required wei deposit for public presale period.\n', '   */\n', '  uint256 public minimumPresaleWeiDeposit;\n', '\n', '  /**\n', '   * @dev Total amount of ZXC tokens offered for the presale.\n', '   */\n', '  uint256 public preSaleZxcCap;\n', '\n', '  /**\n', '   * @dev Total supply of ZXC tokens for the sale.\n', '   */\n', '  uint256 public crowdSaleZxcSupply;\n', '\n', '  /**\n', '   * @dev Amount of ZXC tokens sold.\n', '   */\n', '  uint256 public zxcSold;\n', '\n', '  /**\n', '   * @dev Address where funds are collected.\n', '   */\n', '  address public wallet;\n', '\n', '  /**\n', '   * @dev How many token units buyer gets per wei.\n', '   */\n', '  uint256 public rate;\n', '\n', '  /**\n', '   * @dev An event which is triggered when tokens are bought.\n', '   * @param _from The address sending tokens.\n', '   * @param _to The address receiving tokens.\n', '   * @param _weiAmount Purchase amount in wei.\n', '   * @param _tokenAmount The amount of purchased tokens.\n', '   */\n', '  event TokenPurchase(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 _weiAmount,\n', '    uint256 _tokenAmount\n', '  );\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   * @param _walletAddress Address of the wallet which collects funds.\n', '   * @param _tokenAddress Address of the ZXC token contract.\n', '   * @param _xcertKycAddress Address of the Xcert KYC token contract.\n', '   * @param _startTimePresale Start time of presale stage.\n', '   * @param _startTimeSaleWithBonus Start time of public sale stage with bonus.\n', '   * @param _startTimeSaleNoBonus Start time of public sale stage with no bonus.\n', '   * @param _endTime Time when sale ends.\n', '   * @param _rate ZXC/ETH exchange rate.\n', '   * @param _presaleZxcCap Maximum number of ZXC offered for the presale.\n', '   * @param _crowdSaleZxcSupply Supply of ZXC tokens offered for the sale. Includes _presaleZxcCap.\n', '   * @param _bonusPresale Bonus token percentage for presale.\n', '   * @param _bonusSale Bonus token percentage for public sale stage with bonus.\n', '   * @param _minimumPresaleWeiDeposit Minimum required deposit in wei.\n', '   */\n', '  constructor(\n', '    address _walletAddress,\n', '    address _tokenAddress,\n', '    address _xcertKycAddress,\n', "    uint256 _startTimePresale,  // 1529971200: date -d '2018-06-26 00:00:00 UTC' +%s\n", "    uint256 _startTimeSaleWithBonus, // 1530662400: date -d '2018-07-04 00:00:00 UTC' +%s\n", "    uint256 _startTimeSaleNoBonus,  //1530748800: date -d '2018-07-05 00:00:00 UTC' +%s\n", "    uint256 _endTime,  // 1531872000: date -d '2018-07-18 00:00:00 UTC' +%s\n", '    uint256 _rate,  // 10000: 1 ETH = 10,000 ZXC\n', '    uint256 _presaleZxcCap, // 195M\n', '    uint256 _crowdSaleZxcSupply, // 250M\n', '    uint256 _bonusPresale,  // 10 (%)\n', '    uint256 _bonusSale,  // 5 (%)\n', '    uint256 _minimumPresaleWeiDeposit  // 1 ether;\n', '  )\n', '    public\n', '  {\n', '    require(_walletAddress != address(0));\n', '    require(_tokenAddress != address(0));\n', '    require(_xcertKycAddress != address(0));\n', '    require(_tokenAddress != _walletAddress);\n', '    require(_tokenAddress != _xcertKycAddress);\n', '    require(_xcertKycAddress != _walletAddress);\n', '\n', '    token = Zxc(_tokenAddress);\n', '    xcertKyc = Xcert(_xcertKycAddress);\n', '\n', '    uint8 _tokenDecimals = token.decimals();\n', '    require(_tokenDecimals == 18);  // Sanity check.\n', '    wallet = _walletAddress;\n', '\n', '    // Bonus should be > 0% and <= 100%\n', '    require(_bonusPresale > 0 && _bonusPresale <= 100);\n', '    require(_bonusSale > 0 && _bonusSale <= 100);\n', '\n', '    bonusPresale = _bonusPresale;\n', '    bonusSale = _bonusSale;\n', '\n', '    require(_startTimePresale >= now);\n', '    require(_startTimeSaleWithBonus > _startTimePresale);\n', '    require(_startTimeSaleNoBonus > _startTimeSaleWithBonus);\n', '\n', '    startTimePresale = _startTimePresale;\n', '    startTimeSaleWithBonus = _startTimeSaleWithBonus;\n', '    startTimeSaleNoBonus = _startTimeSaleNoBonus;\n', '    endTime = _endTime;\n', '\n', '    require(_rate > 0);\n', '    rate = _rate;\n', '\n', '    require(_crowdSaleZxcSupply > 0);\n', '    require(token.totalSupply() >= _crowdSaleZxcSupply);\n', '    crowdSaleZxcSupply = _crowdSaleZxcSupply;\n', '\n', '    require(_presaleZxcCap > 0 && _presaleZxcCap <= _crowdSaleZxcSupply);\n', '    preSaleZxcCap = _presaleZxcCap;\n', '\n', '    zxcSold = 0;\n', '\n', '    require(_minimumPresaleWeiDeposit > 0);\n', '    minimumPresaleWeiDeposit = _minimumPresaleWeiDeposit;\n', '  }\n', '\n', '  /**\n', '   * @dev Fallback function can be used to buy tokens.\n', '   */\n', '  function()\n', '    external\n', '    payable\n', '  {\n', '    buyTokens();\n', '  }\n', '\n', '  /**\n', '   * @dev Low level token purchase function.\n', '   */\n', '  function buyTokens()\n', '    public\n', '    payable\n', '  {\n', '    uint256 tokens;\n', '\n', '    // Sender needs Xcert KYC token.\n', '    uint256 balance = xcertKyc.balanceOf(msg.sender);\n', '    require(balance > 0);\n', '    \n', '    if (isInTimeRange(startTimePresale, startTimeSaleWithBonus)) {\n', '      uint256 tokenId = xcertKyc.tokenOfOwnerByIndex(msg.sender, balance.sub(1));\n', '      uint256 kycLevel = uint(xcertKyc.tokenDataValue(tokenId, 0));\n', '      require(kycLevel > 1);\n', '      require(msg.value >= minimumPresaleWeiDeposit);\n', '      tokens = getTokenAmount(msg.value, bonusPresale);\n', '      require(tokens <= preSaleZxcCap);\n', '    }\n', '    else if (isInTimeRange(startTimeSaleWithBonus, startTimeSaleNoBonus)) {\n', '      tokens = getTokenAmount(msg.value, bonusSale);\n', '    }\n', '    else if (isInTimeRange(startTimeSaleNoBonus, endTime)) {\n', '      tokens = getTokenAmount(msg.value, uint256(0));\n', '    }\n', '    else {\n', '      revert("Purchase outside of token sale time windows");\n', '    }\n', '\n', '    require(zxcSold.add(tokens) <= crowdSaleZxcSupply);\n', '    zxcSold = zxcSold.add(tokens);\n', '\n', '    wallet.transfer(msg.value);\n', '    require(token.transferFrom(token.owner(), msg.sender, tokens));\n', '    emit TokenPurchase(msg.sender, msg.sender, msg.value, tokens);\n', '  }\n', '\n', '  /**\n', '   * @return true if crowdsale event has ended\n', '   */\n', '  function hasEnded()\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    bool capReached = zxcSold >= crowdSaleZxcSupply;\n', '    bool endTimeReached = now >= endTime;\n', '    return capReached || endTimeReached;\n', '  }\n', '\n', '  /**\n', '   * @dev Check if currently active period is a given time period.\n', '   * @param _startTime Starting timestamp (inclusive).\n', '   * @param _endTime Ending timestamp (exclusive).\n', '   * @return bool\n', '   */\n', '  function isInTimeRange(\n', '    uint256 _startTime,\n', '    uint256 _endTime\n', '  )\n', '    internal\n', '    view\n', '    returns(bool)\n', '  {\n', '    if (now >= _startTime && now < _endTime) {\n', '      return true;\n', '    }\n', '    else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Calculate amount of tokens for a given wei amount. Apply special bonuses depending on\n', '   * @param weiAmount Amount of wei for token purchase.\n', '   * @param bonusPercent Percentage of bonus tokens.\n', '   * @return Number of tokens with possible bonus.\n', '   */\n', '  function getTokenAmount(\n', '    uint256 weiAmount,\n', '    uint256 bonusPercent\n', '  )\n', '    internal\n', '    view\n', '    returns(uint256)\n', '  {\n', '    uint256 tokens = weiAmount.mul(rate);\n', '\n', '    if (bonusPercent > 0) {\n', '      uint256 bonusTokens = tokens.mul(bonusPercent).div(uint256(100)); // tokens * bonus (%) / 100%\n', '      tokens = tokens.add(bonusTokens);\n', '    }\n', '\n', '    return tokens;\n', '  }\n', '}']
