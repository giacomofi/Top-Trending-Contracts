['pragma solidity 0.4.24;\n', '\n', '// File: contracts\\safe_math_lib.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts\\database.sol\n', '\n', 'contract database {\n', '\n', '    /* libraries */\n', '    using SafeMath for uint256;\n', '\n', '    /* struct declarations */\n', '    struct participant {\n', '        address eth_address; // your eth address\n', '        uint256 topl_address; // your topl address\n', '        uint256 arbits; // the amount of a arbits you have\n', '        uint256 num_of_pro_rata_tokens_alloted;\n', '        bool arbits_kyc_whitelist; // if you pass arbits level kyc you get this\n', '        uint8 num_of_uses;\n', '    }\n', '\n', '    /* variable declarations */\n', '    // permission variables\n', '    mapping(address => bool) public sale_owners;\n', '    mapping(address => bool) public owners;\n', '    mapping(address => bool) public masters;\n', '    mapping(address => bool) public kycers;\n', '\n', '    // database mapping\n', '    mapping(address => participant) public participants;\n', '    address[] public participant_keys;\n', '\n', '    // sale open variables\n', '    bool public arbits_presale_open = false; // Presale variables\n', '    bool public iconiq_presale_open = false; // ^^^^^^^^^^^^^^^^^\n', '    bool public arbits_sale_open = false; // Main sale variables\n', '\n', '    // sale state variables\n', '    uint256 public pre_kyc_bonus_denominator;\n', '    uint256 public pre_kyc_bonus_numerator;\n', '    uint256 public pre_kyc_iconiq_bonus_denominator;\n', '    uint256 public pre_kyc_iconiq_bonus_numerator;\n', '\n', '    uint256 public contrib_arbits_min;\n', '    uint256 public contrib_arbits_max;\n', '\n', '    // presale variables\n', '    uint256 public presale_arbits_per_ether;        // two different prices, but same cap\n', '    uint256 public presale_iconiq_arbits_per_ether; // and sold values\n', '    uint256 public presale_arbits_total = 18000000;\n', '    uint256 public presale_arbits_sold;\n', '\n', '    // main sale variables\n', '    uint256 public sale_arbits_per_ether;\n', '    uint256 public sale_arbits_total;\n', '    uint256 public sale_arbits_sold;\n', '\n', '    /* constructor */\n', '    constructor() public {\n', '        owners[msg.sender] = true;\n', '    }\n', '\n', '    /* permission functions */\n', '    function add_owner(address __subject) public only_owner {\n', '        owners[__subject] = true;\n', '    }\n', '\n', '    function remove_owner(address __subject) public only_owner {\n', '        owners[__subject] = false;\n', '    }\n', '\n', '    function add_master(address _subject) public only_owner {\n', '        masters[_subject] = true;\n', '    }\n', '\n', '    function remove_master(address _subject) public only_owner {\n', '        masters[_subject] = false;\n', '    }\n', '\n', '    function add_kycer(address _subject) public only_owner {\n', '        kycers[_subject] = true;\n', '    }\n', '\n', '    function remove_kycer(address _subject) public only_owner {\n', '        kycers[_subject] = false;\n', '    }\n', '\n', '    /* modifiers */\n', '    modifier log_participant_update(address __eth_address) {\n', '        participant_keys.push(__eth_address); // logs the given address in participant_keys\n', '        _;\n', '    }\n', '\n', '    modifier only_owner() {\n', '        require(owners[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier only_kycer() {\n', '        require(kycers[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier only_master_or_owner() {\n', '        require(masters[msg.sender] || owners[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /* database functions */\n', '    // GENERAL VARIABLE getters & setters\n', '    // getters    \n', '    function get_sale_owner(address _a) public view returns(bool) {\n', '        return sale_owners[_a];\n', '    }\n', '    \n', '    function get_contrib_arbits_min() public view returns(uint256) {\n', '        return contrib_arbits_min;\n', '    }\n', '\n', '    function get_contrib_arbits_max() public view returns(uint256) {\n', '        return contrib_arbits_max;\n', '    }\n', '\n', '    function get_pre_kyc_bonus_numerator() public view returns(uint256) {\n', '        return pre_kyc_bonus_numerator;\n', '    }\n', '\n', '    function get_pre_kyc_bonus_denominator() public view returns(uint256) {\n', '        return pre_kyc_bonus_denominator;\n', '    }\n', '\n', '    function get_pre_kyc_iconiq_bonus_numerator() public view returns(uint256) {\n', '        return pre_kyc_iconiq_bonus_numerator;\n', '    }\n', '\n', '    function get_pre_kyc_iconiq_bonus_denominator() public view returns(uint256) {\n', '        return pre_kyc_iconiq_bonus_denominator;\n', '    }\n', '\n', '    function get_presale_iconiq_arbits_per_ether() public view returns(uint256) {\n', '        return (presale_iconiq_arbits_per_ether);\n', '    }\n', '\n', '    function get_presale_arbits_per_ether() public view returns(uint256) {\n', '        return (presale_arbits_per_ether);\n', '    }\n', '\n', '    function get_presale_arbits_total() public view returns(uint256) {\n', '        return (presale_arbits_total);\n', '    }\n', '\n', '    function get_presale_arbits_sold() public view returns(uint256) {\n', '        return (presale_arbits_sold);\n', '    }\n', '\n', '    function get_sale_arbits_per_ether() public view returns(uint256) {\n', '        return (sale_arbits_per_ether);\n', '    }\n', '\n', '    function get_sale_arbits_total() public view returns(uint256) {\n', '        return (sale_arbits_total);\n', '    }\n', '\n', '    function get_sale_arbits_sold() public view returns(uint256) {\n', '        return (sale_arbits_sold);\n', '    }\n', '\n', '    // setters\n', '    function set_sale_owner(address _a, bool _v) public only_master_or_owner {\n', '        sale_owners[_a] = _v;\n', '    }\n', '\n', '    function set_contrib_arbits_min(uint256 _v) public only_master_or_owner {\n', '        contrib_arbits_min = _v;\n', '    }\n', '\n', '    function set_contrib_arbits_max(uint256 _v) public only_master_or_owner {\n', '        contrib_arbits_max = _v;\n', '    }\n', '\n', '    function set_pre_kyc_bonus_numerator(uint256 _v) public only_master_or_owner {\n', '        pre_kyc_bonus_numerator = _v;\n', '    }\n', '\n', '    function set_pre_kyc_bonus_denominator(uint256 _v) public only_master_or_owner {\n', '        pre_kyc_bonus_denominator = _v;\n', '    }\n', '\n', '    function set_pre_kyc_iconiq_bonus_numerator(uint256 _v) public only_master_or_owner {\n', '        pre_kyc_iconiq_bonus_numerator = _v;\n', '    }\n', '\n', '    function set_pre_kyc_iconiq_bonus_denominator(uint256 _v) public only_master_or_owner {\n', '        pre_kyc_iconiq_bonus_denominator = _v;\n', '    }\n', '\n', '    function set_presale_iconiq_arbits_per_ether(uint256 _v) public only_master_or_owner {\n', '        presale_iconiq_arbits_per_ether = _v;\n', '    }\n', '\n', '    function set_presale_arbits_per_ether(uint256 _v) public only_master_or_owner {\n', '        presale_arbits_per_ether = _v;\n', '    }\n', '\n', '    function set_presale_arbits_total(uint256 _v) public only_master_or_owner {\n', '        presale_arbits_total = _v;\n', '    }\n', '\n', '    function set_presale_arbits_sold(uint256 _v) public only_master_or_owner {\n', '        presale_arbits_sold = _v;\n', '    }\n', '\n', '    function set_sale_arbits_per_ether(uint256 _v) public only_master_or_owner {\n', '        sale_arbits_per_ether = _v;\n', '    }\n', '\n', '    function set_sale_arbits_total(uint256 _v) public only_master_or_owner {\n', '        sale_arbits_total = _v;\n', '    }\n', '\n', '    function set_sale_arbits_sold(uint256 _v) public only_master_or_owner {\n', '        sale_arbits_sold = _v;\n', '    }\n', '\n', '    // PARTICIPANT SPECIFIC getters and setters\n', '    // getters\n', '    function get_participant(address _a) public view returns(\n', '        address,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        bool,\n', '        uint8\n', '    ) {\n', '        participant storage subject = participants[_a];\n', '        return (\n', '            subject.eth_address,\n', '            subject.topl_address,\n', '            subject.arbits,\n', '            subject.num_of_pro_rata_tokens_alloted,\n', '            subject.arbits_kyc_whitelist,\n', '            subject.num_of_uses\n', '        );\n', '    }\n', '\n', '    function get_participant_num_of_uses(address _a) public view returns(uint8) {\n', '        return (participants[_a].num_of_uses);\n', '    }\n', '\n', '    function get_participant_topl_address(address _a) public view returns(uint256) {\n', '        return (participants[_a].topl_address);\n', '    }\n', '\n', '    function get_participant_arbits(address _a) public view returns(uint256) {\n', '        return (participants[_a].arbits);\n', '    }\n', '\n', '    function get_participant_num_of_pro_rata_tokens_alloted(address _a) public view returns(uint256) {\n', '        return (participants[_a].num_of_pro_rata_tokens_alloted);\n', '    }\n', '\n', '    function get_participant_arbits_kyc_whitelist(address _a) public view returns(bool) {\n', '        return (participants[_a].arbits_kyc_whitelist);\n', '    }\n', '\n', '    // setters\n', '    function set_participant(\n', '        address _a,\n', '        uint256 _ta,\n', '        uint256 _arbits,\n', '        uint256 _prta,\n', '        bool _v3,\n', '        uint8 _nou\n', '    ) public only_master_or_owner log_participant_update(_a) {\n', '        participant storage subject = participants[_a];\n', '        subject.eth_address = _a;\n', '        subject.topl_address = _ta;\n', '        subject.arbits = _arbits;\n', '        subject.num_of_pro_rata_tokens_alloted = _prta;\n', '        subject.arbits_kyc_whitelist = _v3;\n', '        subject.num_of_uses = _nou;\n', '    }\n', '\n', '    function set_participant_num_of_uses(\n', '        address _a,\n', '        uint8 _v\n', '    ) public only_master_or_owner log_participant_update(_a) {\n', '        participants[_a].num_of_uses = _v;\n', '    }\n', '\n', '    function set_participant_topl_address(\n', '        address _a,\n', '        uint256 _ta\n', '    ) public only_master_or_owner log_participant_update(_a) {\n', '        participants[_a].topl_address = _ta;\n', '    }\n', '\n', '    function set_participant_arbits(\n', '        address _a,\n', '        uint256 _v\n', '    ) public only_master_or_owner log_participant_update(_a) {\n', '        participants[_a].arbits = _v;\n', '    }\n', '\n', '    function set_participant_num_of_pro_rata_tokens_alloted(\n', '        address _a,\n', '        uint256 _v\n', '    ) public only_master_or_owner log_participant_update(_a) {\n', '        participants[_a].num_of_pro_rata_tokens_alloted = _v;\n', '    }\n', '\n', '    function set_participant_arbits_kyc_whitelist(\n', '        address _a,\n', '        bool _v\n', '    ) public only_kycer log_participant_update(_a) {\n', '        participants[_a].arbits_kyc_whitelist = _v;\n', '    }\n', '\n', '\n', '    //\n', '    // STATE FLAG FUNCTIONS: Getter, setter, and toggling functions for state flags.\n', '\n', '    // GETTERS\n', '    function get_iconiq_presale_open() public view only_master_or_owner returns(bool) {\n', '        return iconiq_presale_open;\n', '    }\n', '\n', '    function get_arbits_presale_open() public view only_master_or_owner returns(bool) {\n', '        return arbits_presale_open;\n', '    }\n', '\n', '    function get_arbits_sale_open() public view only_master_or_owner returns(bool) {\n', '        return arbits_sale_open;\n', '    }\n', '\n', '    // SETTERS\n', '    function set_iconiq_presale_open(bool _v) public only_master_or_owner {\n', '        iconiq_presale_open = _v;\n', '    }\n', '\n', '    function set_arbits_presale_open(bool _v) public only_master_or_owner {\n', '        arbits_presale_open = _v;\n', '    }\n', '\n', '    function set_arbits_sale_open(bool _v) public only_master_or_owner {\n', '        arbits_sale_open = _v;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts\\topl_database_lib.sol\n', '\n', '// This library serves as an wrapper to the database.sol contract\n', '\n', 'library topl_database_lib {\n', '\n', '    //// PARTICIPANT SPECIFIC FUNCTIONS\n', '    // getters\n', '    function get_participant(address db, address _a) internal view returns(\n', '        address,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        bool,\n', '        uint8\n', '    ) {\n', '        return database(db).get_participant(_a);\n', '    }\n', '\n', '    function get_topl_address(address db, address _a) internal view returns(uint256) {\n', '        return database(db).get_participant_topl_address(_a);\n', '    }\n', '\n', '    function get_arbits(address db, address _a) internal view returns(uint256) {\n', '        return database(db).get_participant_arbits(_a);\n', '    }\n', '\n', '    function get_iconiq_tokens(address db, address _a) internal view returns(uint256) {\n', '        return database(db).get_participant_num_of_pro_rata_tokens_alloted(_a);\n', '    }\n', '\n', '    function get_arbits_whitelist(address db, address _a) internal view returns(bool) {\n', '        return database(db).get_participant_arbits_kyc_whitelist(_a);\n', '    }\n', '\n', '    function get_num_of_uses(address db, address _a) internal view returns(uint8) {\n', '        return database(db).get_participant_num_of_uses(_a);\n', '    }\n', '\n', '    // setters\n', '    function set_participant(\n', '        address db,\n', '        address _a,\n', '        uint256 _ta,\n', '        uint256 _arbits,\n', '        uint256 _prta,\n', '        bool _v3,\n', '        uint8 _nou\n', '    ) internal {\n', '        database(db).set_participant(_a, _ta, _arbits, _prta, _v3, _nou);\n', '        emit e_set_participant(_a, _ta, _arbits, _prta, _v3, _nou);\n', '    }\n', '\n', '    function set_topl_address(address db, address _a, uint256 _ta) internal {\n', '        database(db).set_participant_topl_address(_a, _ta);\n', '        emit e_set_topl_address(_a, _ta);\n', '    }\n', '\n', '    function set_arbits(address db, address _a, uint256 _v) internal {\n', '        database(db).set_participant_arbits(_a, _v);\n', '        emit e_set_arbits(_a, _v);\n', '    }\n', '\n', '    function set_iconiq_tokens(address db, address _a, uint256 _v) internal {\n', '        database(db).set_participant_num_of_pro_rata_tokens_alloted(_a, _v);\n', '        emit e_set_iconiq_tokens(_a, _v);\n', '    }\n', '\n', '    function set_arbits_whitelist(address db, address _a, bool _v) internal {\n', '        database(db).set_participant_arbits_kyc_whitelist(_a, _v);\n', '        emit e_set_arbits_whitelist(_a, _v);\n', '    }\n', '\n', '    function set_num_of_uses(address db, address _a, uint8 _v) internal {\n', '        database(db).set_participant_num_of_uses(_a, _v);\n', '        emit e_set_num_of_uses(_a, _v);\n', '    }\n', '\n', '    // modifiers\n', '    function add_arbits(address db, address _a, uint256 _v) internal {\n', '        uint256 c = database(db).get_participant_arbits(_a) + _v;     // safe math check\n', '        assert(c >= database(db).get_participant_arbits(_a)); //\n', '        database(db).set_participant_arbits(\n', '            _a,\n', '            (database(db).get_participant_arbits(_a) + _v)\n', '        );\n', '        emit e_add_arbits(_a, _v);\n', '    }\n', '\n', '    function sub_arbits(address db, address _a, uint256 _v) internal {\n', '        assert(_v <= database(db).get_participant_arbits(_a)); // safe math check\n', '        database(db).set_participant_arbits(\n', '            _a,\n', '            (database(db).get_participant_arbits(_a) - _v)\n', '        );\n', '        emit e_sub_arbits(_a, _v);\n', '    }\n', '\n', '    //// ICONIQ SALE SPECIFIC FUNCTIONS\n', '    // getters\n', '    function get_pre_kyc_iconiq_bonus_numerator(address db) internal view returns(uint256) {\n', '        return database(db).get_pre_kyc_iconiq_bonus_numerator();\n', '    }\n', '\n', '    function get_pre_kyc_iconiq_bonus_denominator(address db) internal view returns(uint256) {\n', '        return database(db).get_pre_kyc_iconiq_bonus_denominator();\n', '    }\n', '\n', '    function get_iconiq_presale_open(address db) internal view returns(bool) {\n', '        return database(db).get_iconiq_presale_open();\n', '    }\n', '\n', '    function get_presale_iconiq_arbits_per_ether(address db) internal view returns(uint256) {\n', '        return database(db).get_presale_iconiq_arbits_per_ether();\n', '    }\n', '\n', '    // setters\n', '    function set_pre_kyc_iconiq_bonus_numerator(address db, uint256 _v) internal {\n', '        database(db).set_pre_kyc_iconiq_bonus_numerator(_v);\n', '        emit e_set_pre_kyc_iconiq_bonus_numerator(_v);\n', '    }\n', '\n', '    function set_pre_kyc_iconiq_bonus_denominator(address db, uint256 _v) internal {\n', '        database(db).set_pre_kyc_iconiq_bonus_denominator(_v);\n', '        emit e_set_pre_kyc_iconiq_bonus_denominator(_v);\n', '    }\n', '\n', '    function set_iconiq_presale_open(address db, bool _v) internal {\n', '        database(db).set_iconiq_presale_open(_v);\n', '        emit e_set_iconiq_presale_open(_v);\n', '    }\n', '\n', '    function set_presale_iconiq_arbits_per_ether(address db, uint256 _v) internal {\n', '        database(db).set_presale_iconiq_arbits_per_ether(_v);\n', '        emit e_set_presale_iconiq_arbits_per_ether(_v);\n', '    }\n', '\n', '    //// PUBLIC PRESALE SPECIFIC FUNCTIONS (arbit_presale)\n', '    // getters\n', '    function get_pre_kyc_bonus_numerator(address db) internal view returns(uint256) {\n', '        return database(db).get_pre_kyc_bonus_numerator();\n', '    }\n', '\n', '    function get_pre_kyc_bonus_denominator(address db) internal view returns(uint256) {\n', '        return database(db).get_pre_kyc_bonus_denominator();\n', '    }\n', '\n', '    function get_arbits_presale_open(address db) internal view returns(bool) {\n', '        return database(db).get_arbits_presale_open();\n', '    }\n', '\n', '    function get_presale_arbits_per_ether(address db) internal view returns(uint256) {\n', '        return database(db).get_presale_arbits_per_ether();\n', '    }\n', '\n', '    // setters\n', '    function set_pre_kyc_bonus_numerator(address db, uint256 _v) internal {\n', '        database(db).set_pre_kyc_bonus_numerator(_v);\n', '        emit e_set_pre_kyc_bonus_numerator(_v);\n', '    }\n', '\n', '    function set_pre_kyc_bonus_denominator(address db, uint256 _v) internal {\n', '        database(db).set_pre_kyc_bonus_denominator(_v);\n', '        emit e_set_pre_kyc_bonus_denominator(_v);\n', '    }\n', '\n', '    function set_arbits_presale_open(address db, bool _v) internal {\n', '        database(db).set_arbits_presale_open(_v);\n', '        emit e_set_arbits_presale_open(_v);\n', '    }\n', '\n', '    // this function is not strictly only used by arbit_presale since it is used for rollover\n', '    // when an iconiq member goes over their allotment.\n', '    function set_presale_arbits_per_ether(address db, uint256 _v) internal {\n', '        database(db).set_presale_arbits_per_ether(_v);\n', '        emit e_set_presale_arbits_per_ether(_v);\n', '    }\n', '\n', '    //// "GLOABL" SALE FUNCTIONS (applies across the entire presale)\n', '    // getters\n', '    function get_presale_arbits_total(address db) internal view returns(uint256) {\n', '        return database(db).get_presale_arbits_total();\n', '    }\n', '\n', '    function get_presale_arbits_sold(address db) internal view returns(uint256) {\n', '        return database(db).get_presale_arbits_sold();\n', '    }\n', '\n', '    function get_arbits_max_contribution(address db) internal view returns(uint256) {\n', '        return database(db).get_contrib_arbits_max();\n', '    }\n', '\n', '    function get_arbits_min_contribution(address db) internal view returns(uint256) {\n', '        return database(db).get_contrib_arbits_min();\n', '    }\n', '\n', '    // setters\n', '    function set_presale_arbits_total(address db, uint256 _v) internal {\n', '        database(db).set_presale_arbits_total(_v);\n', '        emit e_set_presale_arbits_total(_v);\n', '    }\n', '\n', '    function set_presale_arbits_sold(address db, uint256 _v) internal {\n', '        database(db).set_presale_arbits_sold(_v);\n', '        emit e_set_presale_arbits_sold(_v);\n', '    }\n', '\n', '    function set_arbits_max_contribution(address db, uint256 _v) internal {\n', '        database(db).set_contrib_arbits_max(_v);\n', '        emit e_set_arbits_max_contribution(_v);\n', '    }\n', '\n', '    function set_arbits_min_contribution(address db, uint256 _v) internal {\n', '        database(db).set_contrib_arbits_min(_v);\n', '        emit e_set_arbits_min_contribution(_v);\n', '    }\n', '\n', '    // modifiers\n', '    function add_presale_arbits_sold(address db, uint256 _v) internal {\n', '        uint256 c = database(db).get_presale_arbits_sold() + _v;     // safe math check\n', '        assert(c >= database(db).get_presale_arbits_sold()); //\n', '        database(db).set_presale_arbits_sold(\n', '            (database(db).get_presale_arbits_sold() + _v)\n', '        );\n', '        emit e_add_presale_arbits_sold(_v);\n', '    }\n', '\n', '    function sub_presale_arbits_sold(address db, uint256 _v) internal {\n', '        assert(_v <= database(db).get_presale_arbits_sold()); // safe math check\n', '        database(db).set_presale_arbits_sold(\n', '            (database(db).get_presale_arbits_sold() - _v)\n', '        );\n', '        emit e_sub_presale_arbits_sold(_v);\n', '    }\n', '    \n', '    function set_sale_owner(address db, address _a, bool _v) internal {\n', '        database(db).set_sale_owner(_a, _v);\n', '    }\n', '\n', '    function get_sale_owner(address db, address _a) internal view returns(bool) {\n', '        return database(db).get_sale_owner(_a);\n', '    }\n', '\n', '    event e_set_sale_owner(address, bool);\n', '    event e_set_num_of_uses(address, uint8);\n', '    event e_set_arbits_whitelist(address, bool);\n', '    event e_set_participant(address, uint256, uint256, uint256, bool, uint8);\n', '    event e_set_topl_address(address, uint256);\n', '    event e_set_arbits(address, uint256);\n', '    event e_set_iconiq_tokens(address, uint256);\n', '    event e_add_arbits(address, uint256);\n', '    event e_sub_arbits(address, uint256);\n', '    event e_set_pre_kyc_bonus_numerator(uint256);\n', '    event e_set_pre_kyc_bonus_denominator(uint256);\n', '    event e_set_iconiq_presale_open(bool);\n', '    event e_set_arbits_presale_open(bool);\n', '    event e_set_presale_iconiq_arbits_per_ether(uint256);\n', '    event e_set_presale_arbits_per_ether(uint256);\n', '    event e_set_presale_arbits_total(uint256);\n', '    event e_set_presale_arbits_sold(uint256);\n', '    event e_add_presale_arbits_sold(uint256);\n', '    event e_sub_presale_arbits_sold(uint256);\n', '    event e_set_arbits_max_contribution(uint256);\n', '    event e_set_arbits_min_contribution(uint256);\n', '    event e_set_pre_kyc_iconiq_bonus_numerator(uint256);\n', '    event e_set_pre_kyc_iconiq_bonus_denominator(uint256);\n', '}\n', '\n', '// File: contracts\\iconiq_presale.sol\n', '\n', 'contract iconiq_presale {\n', '\n', '    // libraries\n', '    using topl_database_lib for address;\n', '    using SafeMath for uint256;\n', '\n', '    // contract level vars\n', '    address public owner;\n', '    address public db;\n', '\n', '    // helpful data structs\n', '    struct participant {\n', '        address eth_address; // your eth address\n', '        uint256 topl_address; // your topl address\n', '        uint256 arbits; // the amount of a arbits you have\n', '        uint256 num_of_pro_rata_tokens_alloted;\n', '        bool arbits_kyc_whitelist; // if you pass arbits level kyc you get this\n', '        uint8 num_of_uses;\n', '    }\n', '\n', '    // permissions\n', '    constructor(address __db) public {\n', '        db = __db;\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function owner_linkage() public { // must be called after the sale contract has been linked to the database contract via database&#39;s add master function\n', '        db.set_sale_owner(owner, true);\n', '    }\n', '\n', '    modifier only_owner() {\n', '        require(db.get_sale_owner(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function add_owner(address __subject) public only_owner {\n', '        db.set_sale_owner(__subject, true);\n', '        emit e_add_owner(msg.sender, __subject);\n', '    }\n', '\n', '    function remove_owner(address __subject) public only_owner {\n', '        db.set_sale_owner(__subject, false);\n', '        emit e_remove_owner(msg.sender, __subject);\n', '    }\n', '\n', '    // functionality\n', '    function participate_in_arbits_presale_crypto() public payable presale_open use_count {\n', '        /////////////////////////////////////////////////////////////////////\n', '                                                                           //\n', '        (                                                                  //\n', '            address p1,                                                    //\n', '            uint256 p2,                                                    // LOAD\n', '            uint256 p3,                                                    // PARTICIPANT\n', '            uint256 p4,                                                    // DATA\n', '            bool p5,                                                       // FROM\n', '            uint8 p6                                                       // DATABASE\n', '        ) = db.get_participant(msg.sender);                                //\n', '        participant memory subject = participant(p1, p2, p3, p4, p5, p6);  //\n', '                                                                           //\n', '        /////////////////////////////////////////////////////////////////////\n', '\n', '        // Note: The num_of_pro_rata_tokens_alloted struct field of iconiq members is set by a contract\n', '        // connected to the database contract that is outside the scope of this audit.\n', '\n', '        ///////////////////////////////////////////////////////\n', '                                                             // Iconiq\n', '        require(subject.num_of_pro_rata_tokens_alloted > 0); // Member\n', '                                                             // Check\n', '        ///////////////////////////////////////////////////////\n', '\n', '        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '                                                                                                                                           //\n', '        uint256 subject_tokens_to_add_at_iconiq_price = msg.value.mul(db.get_presale_iconiq_arbits_per_ether()).div(1 ether);  //\n', '        uint256 subject_tokens_to_add_at_reg_price = msg.value.mul(db.get_presale_arbits_per_ether()).div(1 ether);            //\n', '        uint256 amount_of_pro_rata_tokens_subject_can_get = subject.num_of_pro_rata_tokens_alloted;                                        //\n', '        uint256 subject_tokens_to_add = 0;                                                                                                 //\n', '        if (amount_of_pro_rata_tokens_subject_can_get >= subject.arbits.add(subject_tokens_to_add_at_iconiq_price)) {                      //\n', '            subject_tokens_to_add = subject_tokens_to_add_at_iconiq_price;  // everything at ICONIQ rate                                   //\n', '        } else {                                                                                                                           //\n', '            if (subject.arbits < amount_of_pro_rata_tokens_subject_can_get) {                                                              //\n', '                uint256 delta = amount_of_pro_rata_tokens_subject_can_get.sub(subject.arbits);  // some at ICONIQ rate and some not        //\n', '                subject_tokens_to_add = delta.add(                                              //                                         //\n', '                    subject_tokens_to_add_at_iconiq_price                                       //                                         // Arbits\n', '                    .sub(delta)                                                                 //                                         // Purchased\n', '                    .mul(db.get_presale_arbits_per_ether())                                     //                                         // Calculation\n', '                    .div(db.get_presale_iconiq_arbits_per_ether())                              //                                         //\n', '                );                                                                              //                                         //\n', '            } else {                                                                                                                       //\n', '                subject_tokens_to_add = subject_tokens_to_add_at_reg_price;  // nothing at ICONIQ rate                                     //\n', '            }                                                                                                                              //\n', '        }                                                                                                                                  //\n', '        if (subject.arbits_kyc_whitelist) {                                                                                                //\n', '            subject_tokens_to_add = subject_tokens_to_add         // pre-kyc bonus                                                         //\n', '                .mul(db.get_pre_kyc_iconiq_bonus_numerator())     //                                                                       //\n', '                .div(db.get_pre_kyc_iconiq_bonus_denominator());  //                                                                       //\n', '        }                                                                                                                                  //\n', '                                                                                                                                           //\n', '        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '        // Note: users must send ether in amounts that are evenly divide tokens_per_ether.\n', '        // Ex: If tokens_per_ether = 4 and a user sends .9 ether they will receive 3 tokens and forfeit .15 ether.\n', '        // The correct interaction would be to send some increment of .25 ether.\n', '\n', '        //////////////////////////////////////////////////////////////////////////////////////////////////////\n', '                                                                                                            //\n', '        require(db.get_presale_arbits_total() >= db.get_presale_arbits_sold().add(subject_tokens_to_add));  // Sale\n', '        require(db.get_arbits_max_contribution() >= subject_tokens_to_add); // max                  // Limit\n', '        require(db.get_arbits_min_contribution() <= subject_tokens_to_add); // min                  // Checks\n', '                                                                                                            //\n', '        //////////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '        /////////////////////////////////////////////////////////////////////////////\n', '                                                                                   //\n', '        db.add_presale_arbits_sold(subject_tokens_to_add); // update sold counter  // Update\n', '        db.add_arbits(msg.sender, subject_tokens_to_add); // update arbits         // Database\n', '                                                                                   //\n', '        /////////////////////////////////////////////////////////////////////////////\n', '\n', '        ///////////////////////////////////////////////////////////////////////\n', '                                                                             //\n', '        emit e_participate_in_arbits_presale_crypto(msg.sender, msg.value);  // Event\n', '                                                                             //\n', '        ///////////////////////////////////////////////////////////////////////\n', '    }\n', '\n', '    function() public payable {\n', '        participate_in_arbits_presale_crypto(); // allows users to participate without an explicit function call\n', '        emit e_fallback(msg.sender, msg.value);\n', '    }\n', '\n', '    // owner withdraw\n', '    function kill_and_withdraw(address withdraw_to) public only_owner {\n', '        emit e_kill_and_withdraw(withdraw_to);\n', '        selfdestruct(withdraw_to);\n', '    }\n', '\n', '    function withdraw_some_amount(address withdraw_to, uint256 amount) public only_owner {\n', '        withdraw_to.transfer(amount); // amount in wei, throws if error\n', '        emit e_withdraw_some_amount(withdraw_to, amount);\n', '    }\n', '\n', '    // sale settings\n', '    function set_sale_open() public only_owner {\n', '        require(db.get_presale_arbits_per_ether() > 0);\n', '        require(db.get_presale_iconiq_arbits_per_ether() > 0);\n', '        require(db.get_arbits_max_contribution() > 0);\n', '        require(db.get_arbits_min_contribution() > 0);\n', '        require(db.get_pre_kyc_iconiq_bonus_numerator() > 0);\n', '        require(db.get_pre_kyc_iconiq_bonus_denominator() > 0);\n', '        db.set_iconiq_presale_open(true);\n', '    }\n', '\n', '    function set_sale_closed() public only_owner {\n', '        db.set_iconiq_presale_open(false);\n', '    }\n', '\n', '    function set_iconiq_arbits_per_ether(uint256 _v) public only_owner {\n', '        db.set_presale_iconiq_arbits_per_ether(_v); // this is the pro rata rate\n', '    }\n', '\n', '    function set_iconiq_pre_kyc_bonus_numerator(uint256 _v) public only_owner {\n', '        db.set_pre_kyc_iconiq_bonus_numerator(_v);\n', '    }\n', '\n', '    function set_iconiq_pre_kyc_bonus_denominator(uint256 _v) public only_owner {\n', '        db.set_pre_kyc_iconiq_bonus_denominator(_v);\n', '    }\n', '\n', '    // general modifiers\n', '    modifier presale_open() {\n', '        require(db.get_iconiq_presale_open());\n', '        _;\n', '    }\n', '\n', '    modifier use_count() {\n', '        uint8 uses = db.get_num_of_uses(msg.sender);\n', '        require(uses < 5);\n', '        db.set_num_of_uses(msg.sender, uses + 1);\n', '        _;\n', '    }\n', '\n', '    // helpers\n', '    function is_presale_open() public view returns(bool) {\n', '        return db.get_iconiq_presale_open();\n', '    }\n', '\n', '    function am_i_on_the_whitelist() public view returns(bool) {\n', '        return db.get_arbits_whitelist(msg.sender);\n', '    }\n', '\n', '    function how_many_arbits_do_i_have() public view returns(uint256) {\n', '        return db.get_arbits(msg.sender);\n', '    }\n', '\n', '    // events\n', '    //\n', '    // All storage calls are logged via events emitted in the library functions.\n', '    // Because web3 bugs out when when libraries call events that aren&#39;t defined in\n', '    // the parent contract. We redefine them here.\n', '    //\n', '    // contract level events\n', '    event e_add_owner(address, address); // adder, addie <-------- These are words now!\n', '    event e_remove_owner(address, address); // remover, removie <_/\n', '    event e_participate_in_arbits_presale_crypto(address, uint256); // msg.sender, msg.value\n', '    event e_fallback(address, uint256); // msg.sender, msg.value (used to gather data on what %\n', '    // of people just send ether vs sending a function call\n', '    event e_kill_and_withdraw(address); // person that just took all our money\n', '    event e_withdraw_some_amount(address, uint256); // withdrawal address, amount withdrawn\n', '}']
['pragma solidity 0.4.24;\n', '\n', '// File: contracts\\safe_math_lib.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts\\database.sol\n', '\n', 'contract database {\n', '\n', '    /* libraries */\n', '    using SafeMath for uint256;\n', '\n', '    /* struct declarations */\n', '    struct participant {\n', '        address eth_address; // your eth address\n', '        uint256 topl_address; // your topl address\n', '        uint256 arbits; // the amount of a arbits you have\n', '        uint256 num_of_pro_rata_tokens_alloted;\n', '        bool arbits_kyc_whitelist; // if you pass arbits level kyc you get this\n', '        uint8 num_of_uses;\n', '    }\n', '\n', '    /* variable declarations */\n', '    // permission variables\n', '    mapping(address => bool) public sale_owners;\n', '    mapping(address => bool) public owners;\n', '    mapping(address => bool) public masters;\n', '    mapping(address => bool) public kycers;\n', '\n', '    // database mapping\n', '    mapping(address => participant) public participants;\n', '    address[] public participant_keys;\n', '\n', '    // sale open variables\n', '    bool public arbits_presale_open = false; // Presale variables\n', '    bool public iconiq_presale_open = false; // ^^^^^^^^^^^^^^^^^\n', '    bool public arbits_sale_open = false; // Main sale variables\n', '\n', '    // sale state variables\n', '    uint256 public pre_kyc_bonus_denominator;\n', '    uint256 public pre_kyc_bonus_numerator;\n', '    uint256 public pre_kyc_iconiq_bonus_denominator;\n', '    uint256 public pre_kyc_iconiq_bonus_numerator;\n', '\n', '    uint256 public contrib_arbits_min;\n', '    uint256 public contrib_arbits_max;\n', '\n', '    // presale variables\n', '    uint256 public presale_arbits_per_ether;        // two different prices, but same cap\n', '    uint256 public presale_iconiq_arbits_per_ether; // and sold values\n', '    uint256 public presale_arbits_total = 18000000;\n', '    uint256 public presale_arbits_sold;\n', '\n', '    // main sale variables\n', '    uint256 public sale_arbits_per_ether;\n', '    uint256 public sale_arbits_total;\n', '    uint256 public sale_arbits_sold;\n', '\n', '    /* constructor */\n', '    constructor() public {\n', '        owners[msg.sender] = true;\n', '    }\n', '\n', '    /* permission functions */\n', '    function add_owner(address __subject) public only_owner {\n', '        owners[__subject] = true;\n', '    }\n', '\n', '    function remove_owner(address __subject) public only_owner {\n', '        owners[__subject] = false;\n', '    }\n', '\n', '    function add_master(address _subject) public only_owner {\n', '        masters[_subject] = true;\n', '    }\n', '\n', '    function remove_master(address _subject) public only_owner {\n', '        masters[_subject] = false;\n', '    }\n', '\n', '    function add_kycer(address _subject) public only_owner {\n', '        kycers[_subject] = true;\n', '    }\n', '\n', '    function remove_kycer(address _subject) public only_owner {\n', '        kycers[_subject] = false;\n', '    }\n', '\n', '    /* modifiers */\n', '    modifier log_participant_update(address __eth_address) {\n', '        participant_keys.push(__eth_address); // logs the given address in participant_keys\n', '        _;\n', '    }\n', '\n', '    modifier only_owner() {\n', '        require(owners[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier only_kycer() {\n', '        require(kycers[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier only_master_or_owner() {\n', '        require(masters[msg.sender] || owners[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /* database functions */\n', '    // GENERAL VARIABLE getters & setters\n', '    // getters    \n', '    function get_sale_owner(address _a) public view returns(bool) {\n', '        return sale_owners[_a];\n', '    }\n', '    \n', '    function get_contrib_arbits_min() public view returns(uint256) {\n', '        return contrib_arbits_min;\n', '    }\n', '\n', '    function get_contrib_arbits_max() public view returns(uint256) {\n', '        return contrib_arbits_max;\n', '    }\n', '\n', '    function get_pre_kyc_bonus_numerator() public view returns(uint256) {\n', '        return pre_kyc_bonus_numerator;\n', '    }\n', '\n', '    function get_pre_kyc_bonus_denominator() public view returns(uint256) {\n', '        return pre_kyc_bonus_denominator;\n', '    }\n', '\n', '    function get_pre_kyc_iconiq_bonus_numerator() public view returns(uint256) {\n', '        return pre_kyc_iconiq_bonus_numerator;\n', '    }\n', '\n', '    function get_pre_kyc_iconiq_bonus_denominator() public view returns(uint256) {\n', '        return pre_kyc_iconiq_bonus_denominator;\n', '    }\n', '\n', '    function get_presale_iconiq_arbits_per_ether() public view returns(uint256) {\n', '        return (presale_iconiq_arbits_per_ether);\n', '    }\n', '\n', '    function get_presale_arbits_per_ether() public view returns(uint256) {\n', '        return (presale_arbits_per_ether);\n', '    }\n', '\n', '    function get_presale_arbits_total() public view returns(uint256) {\n', '        return (presale_arbits_total);\n', '    }\n', '\n', '    function get_presale_arbits_sold() public view returns(uint256) {\n', '        return (presale_arbits_sold);\n', '    }\n', '\n', '    function get_sale_arbits_per_ether() public view returns(uint256) {\n', '        return (sale_arbits_per_ether);\n', '    }\n', '\n', '    function get_sale_arbits_total() public view returns(uint256) {\n', '        return (sale_arbits_total);\n', '    }\n', '\n', '    function get_sale_arbits_sold() public view returns(uint256) {\n', '        return (sale_arbits_sold);\n', '    }\n', '\n', '    // setters\n', '    function set_sale_owner(address _a, bool _v) public only_master_or_owner {\n', '        sale_owners[_a] = _v;\n', '    }\n', '\n', '    function set_contrib_arbits_min(uint256 _v) public only_master_or_owner {\n', '        contrib_arbits_min = _v;\n', '    }\n', '\n', '    function set_contrib_arbits_max(uint256 _v) public only_master_or_owner {\n', '        contrib_arbits_max = _v;\n', '    }\n', '\n', '    function set_pre_kyc_bonus_numerator(uint256 _v) public only_master_or_owner {\n', '        pre_kyc_bonus_numerator = _v;\n', '    }\n', '\n', '    function set_pre_kyc_bonus_denominator(uint256 _v) public only_master_or_owner {\n', '        pre_kyc_bonus_denominator = _v;\n', '    }\n', '\n', '    function set_pre_kyc_iconiq_bonus_numerator(uint256 _v) public only_master_or_owner {\n', '        pre_kyc_iconiq_bonus_numerator = _v;\n', '    }\n', '\n', '    function set_pre_kyc_iconiq_bonus_denominator(uint256 _v) public only_master_or_owner {\n', '        pre_kyc_iconiq_bonus_denominator = _v;\n', '    }\n', '\n', '    function set_presale_iconiq_arbits_per_ether(uint256 _v) public only_master_or_owner {\n', '        presale_iconiq_arbits_per_ether = _v;\n', '    }\n', '\n', '    function set_presale_arbits_per_ether(uint256 _v) public only_master_or_owner {\n', '        presale_arbits_per_ether = _v;\n', '    }\n', '\n', '    function set_presale_arbits_total(uint256 _v) public only_master_or_owner {\n', '        presale_arbits_total = _v;\n', '    }\n', '\n', '    function set_presale_arbits_sold(uint256 _v) public only_master_or_owner {\n', '        presale_arbits_sold = _v;\n', '    }\n', '\n', '    function set_sale_arbits_per_ether(uint256 _v) public only_master_or_owner {\n', '        sale_arbits_per_ether = _v;\n', '    }\n', '\n', '    function set_sale_arbits_total(uint256 _v) public only_master_or_owner {\n', '        sale_arbits_total = _v;\n', '    }\n', '\n', '    function set_sale_arbits_sold(uint256 _v) public only_master_or_owner {\n', '        sale_arbits_sold = _v;\n', '    }\n', '\n', '    // PARTICIPANT SPECIFIC getters and setters\n', '    // getters\n', '    function get_participant(address _a) public view returns(\n', '        address,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        bool,\n', '        uint8\n', '    ) {\n', '        participant storage subject = participants[_a];\n', '        return (\n', '            subject.eth_address,\n', '            subject.topl_address,\n', '            subject.arbits,\n', '            subject.num_of_pro_rata_tokens_alloted,\n', '            subject.arbits_kyc_whitelist,\n', '            subject.num_of_uses\n', '        );\n', '    }\n', '\n', '    function get_participant_num_of_uses(address _a) public view returns(uint8) {\n', '        return (participants[_a].num_of_uses);\n', '    }\n', '\n', '    function get_participant_topl_address(address _a) public view returns(uint256) {\n', '        return (participants[_a].topl_address);\n', '    }\n', '\n', '    function get_participant_arbits(address _a) public view returns(uint256) {\n', '        return (participants[_a].arbits);\n', '    }\n', '\n', '    function get_participant_num_of_pro_rata_tokens_alloted(address _a) public view returns(uint256) {\n', '        return (participants[_a].num_of_pro_rata_tokens_alloted);\n', '    }\n', '\n', '    function get_participant_arbits_kyc_whitelist(address _a) public view returns(bool) {\n', '        return (participants[_a].arbits_kyc_whitelist);\n', '    }\n', '\n', '    // setters\n', '    function set_participant(\n', '        address _a,\n', '        uint256 _ta,\n', '        uint256 _arbits,\n', '        uint256 _prta,\n', '        bool _v3,\n', '        uint8 _nou\n', '    ) public only_master_or_owner log_participant_update(_a) {\n', '        participant storage subject = participants[_a];\n', '        subject.eth_address = _a;\n', '        subject.topl_address = _ta;\n', '        subject.arbits = _arbits;\n', '        subject.num_of_pro_rata_tokens_alloted = _prta;\n', '        subject.arbits_kyc_whitelist = _v3;\n', '        subject.num_of_uses = _nou;\n', '    }\n', '\n', '    function set_participant_num_of_uses(\n', '        address _a,\n', '        uint8 _v\n', '    ) public only_master_or_owner log_participant_update(_a) {\n', '        participants[_a].num_of_uses = _v;\n', '    }\n', '\n', '    function set_participant_topl_address(\n', '        address _a,\n', '        uint256 _ta\n', '    ) public only_master_or_owner log_participant_update(_a) {\n', '        participants[_a].topl_address = _ta;\n', '    }\n', '\n', '    function set_participant_arbits(\n', '        address _a,\n', '        uint256 _v\n', '    ) public only_master_or_owner log_participant_update(_a) {\n', '        participants[_a].arbits = _v;\n', '    }\n', '\n', '    function set_participant_num_of_pro_rata_tokens_alloted(\n', '        address _a,\n', '        uint256 _v\n', '    ) public only_master_or_owner log_participant_update(_a) {\n', '        participants[_a].num_of_pro_rata_tokens_alloted = _v;\n', '    }\n', '\n', '    function set_participant_arbits_kyc_whitelist(\n', '        address _a,\n', '        bool _v\n', '    ) public only_kycer log_participant_update(_a) {\n', '        participants[_a].arbits_kyc_whitelist = _v;\n', '    }\n', '\n', '\n', '    //\n', '    // STATE FLAG FUNCTIONS: Getter, setter, and toggling functions for state flags.\n', '\n', '    // GETTERS\n', '    function get_iconiq_presale_open() public view only_master_or_owner returns(bool) {\n', '        return iconiq_presale_open;\n', '    }\n', '\n', '    function get_arbits_presale_open() public view only_master_or_owner returns(bool) {\n', '        return arbits_presale_open;\n', '    }\n', '\n', '    function get_arbits_sale_open() public view only_master_or_owner returns(bool) {\n', '        return arbits_sale_open;\n', '    }\n', '\n', '    // SETTERS\n', '    function set_iconiq_presale_open(bool _v) public only_master_or_owner {\n', '        iconiq_presale_open = _v;\n', '    }\n', '\n', '    function set_arbits_presale_open(bool _v) public only_master_or_owner {\n', '        arbits_presale_open = _v;\n', '    }\n', '\n', '    function set_arbits_sale_open(bool _v) public only_master_or_owner {\n', '        arbits_sale_open = _v;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts\\topl_database_lib.sol\n', '\n', '// This library serves as an wrapper to the database.sol contract\n', '\n', 'library topl_database_lib {\n', '\n', '    //// PARTICIPANT SPECIFIC FUNCTIONS\n', '    // getters\n', '    function get_participant(address db, address _a) internal view returns(\n', '        address,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        bool,\n', '        uint8\n', '    ) {\n', '        return database(db).get_participant(_a);\n', '    }\n', '\n', '    function get_topl_address(address db, address _a) internal view returns(uint256) {\n', '        return database(db).get_participant_topl_address(_a);\n', '    }\n', '\n', '    function get_arbits(address db, address _a) internal view returns(uint256) {\n', '        return database(db).get_participant_arbits(_a);\n', '    }\n', '\n', '    function get_iconiq_tokens(address db, address _a) internal view returns(uint256) {\n', '        return database(db).get_participant_num_of_pro_rata_tokens_alloted(_a);\n', '    }\n', '\n', '    function get_arbits_whitelist(address db, address _a) internal view returns(bool) {\n', '        return database(db).get_participant_arbits_kyc_whitelist(_a);\n', '    }\n', '\n', '    function get_num_of_uses(address db, address _a) internal view returns(uint8) {\n', '        return database(db).get_participant_num_of_uses(_a);\n', '    }\n', '\n', '    // setters\n', '    function set_participant(\n', '        address db,\n', '        address _a,\n', '        uint256 _ta,\n', '        uint256 _arbits,\n', '        uint256 _prta,\n', '        bool _v3,\n', '        uint8 _nou\n', '    ) internal {\n', '        database(db).set_participant(_a, _ta, _arbits, _prta, _v3, _nou);\n', '        emit e_set_participant(_a, _ta, _arbits, _prta, _v3, _nou);\n', '    }\n', '\n', '    function set_topl_address(address db, address _a, uint256 _ta) internal {\n', '        database(db).set_participant_topl_address(_a, _ta);\n', '        emit e_set_topl_address(_a, _ta);\n', '    }\n', '\n', '    function set_arbits(address db, address _a, uint256 _v) internal {\n', '        database(db).set_participant_arbits(_a, _v);\n', '        emit e_set_arbits(_a, _v);\n', '    }\n', '\n', '    function set_iconiq_tokens(address db, address _a, uint256 _v) internal {\n', '        database(db).set_participant_num_of_pro_rata_tokens_alloted(_a, _v);\n', '        emit e_set_iconiq_tokens(_a, _v);\n', '    }\n', '\n', '    function set_arbits_whitelist(address db, address _a, bool _v) internal {\n', '        database(db).set_participant_arbits_kyc_whitelist(_a, _v);\n', '        emit e_set_arbits_whitelist(_a, _v);\n', '    }\n', '\n', '    function set_num_of_uses(address db, address _a, uint8 _v) internal {\n', '        database(db).set_participant_num_of_uses(_a, _v);\n', '        emit e_set_num_of_uses(_a, _v);\n', '    }\n', '\n', '    // modifiers\n', '    function add_arbits(address db, address _a, uint256 _v) internal {\n', '        uint256 c = database(db).get_participant_arbits(_a) + _v;     // safe math check\n', '        assert(c >= database(db).get_participant_arbits(_a)); //\n', '        database(db).set_participant_arbits(\n', '            _a,\n', '            (database(db).get_participant_arbits(_a) + _v)\n', '        );\n', '        emit e_add_arbits(_a, _v);\n', '    }\n', '\n', '    function sub_arbits(address db, address _a, uint256 _v) internal {\n', '        assert(_v <= database(db).get_participant_arbits(_a)); // safe math check\n', '        database(db).set_participant_arbits(\n', '            _a,\n', '            (database(db).get_participant_arbits(_a) - _v)\n', '        );\n', '        emit e_sub_arbits(_a, _v);\n', '    }\n', '\n', '    //// ICONIQ SALE SPECIFIC FUNCTIONS\n', '    // getters\n', '    function get_pre_kyc_iconiq_bonus_numerator(address db) internal view returns(uint256) {\n', '        return database(db).get_pre_kyc_iconiq_bonus_numerator();\n', '    }\n', '\n', '    function get_pre_kyc_iconiq_bonus_denominator(address db) internal view returns(uint256) {\n', '        return database(db).get_pre_kyc_iconiq_bonus_denominator();\n', '    }\n', '\n', '    function get_iconiq_presale_open(address db) internal view returns(bool) {\n', '        return database(db).get_iconiq_presale_open();\n', '    }\n', '\n', '    function get_presale_iconiq_arbits_per_ether(address db) internal view returns(uint256) {\n', '        return database(db).get_presale_iconiq_arbits_per_ether();\n', '    }\n', '\n', '    // setters\n', '    function set_pre_kyc_iconiq_bonus_numerator(address db, uint256 _v) internal {\n', '        database(db).set_pre_kyc_iconiq_bonus_numerator(_v);\n', '        emit e_set_pre_kyc_iconiq_bonus_numerator(_v);\n', '    }\n', '\n', '    function set_pre_kyc_iconiq_bonus_denominator(address db, uint256 _v) internal {\n', '        database(db).set_pre_kyc_iconiq_bonus_denominator(_v);\n', '        emit e_set_pre_kyc_iconiq_bonus_denominator(_v);\n', '    }\n', '\n', '    function set_iconiq_presale_open(address db, bool _v) internal {\n', '        database(db).set_iconiq_presale_open(_v);\n', '        emit e_set_iconiq_presale_open(_v);\n', '    }\n', '\n', '    function set_presale_iconiq_arbits_per_ether(address db, uint256 _v) internal {\n', '        database(db).set_presale_iconiq_arbits_per_ether(_v);\n', '        emit e_set_presale_iconiq_arbits_per_ether(_v);\n', '    }\n', '\n', '    //// PUBLIC PRESALE SPECIFIC FUNCTIONS (arbit_presale)\n', '    // getters\n', '    function get_pre_kyc_bonus_numerator(address db) internal view returns(uint256) {\n', '        return database(db).get_pre_kyc_bonus_numerator();\n', '    }\n', '\n', '    function get_pre_kyc_bonus_denominator(address db) internal view returns(uint256) {\n', '        return database(db).get_pre_kyc_bonus_denominator();\n', '    }\n', '\n', '    function get_arbits_presale_open(address db) internal view returns(bool) {\n', '        return database(db).get_arbits_presale_open();\n', '    }\n', '\n', '    function get_presale_arbits_per_ether(address db) internal view returns(uint256) {\n', '        return database(db).get_presale_arbits_per_ether();\n', '    }\n', '\n', '    // setters\n', '    function set_pre_kyc_bonus_numerator(address db, uint256 _v) internal {\n', '        database(db).set_pre_kyc_bonus_numerator(_v);\n', '        emit e_set_pre_kyc_bonus_numerator(_v);\n', '    }\n', '\n', '    function set_pre_kyc_bonus_denominator(address db, uint256 _v) internal {\n', '        database(db).set_pre_kyc_bonus_denominator(_v);\n', '        emit e_set_pre_kyc_bonus_denominator(_v);\n', '    }\n', '\n', '    function set_arbits_presale_open(address db, bool _v) internal {\n', '        database(db).set_arbits_presale_open(_v);\n', '        emit e_set_arbits_presale_open(_v);\n', '    }\n', '\n', '    // this function is not strictly only used by arbit_presale since it is used for rollover\n', '    // when an iconiq member goes over their allotment.\n', '    function set_presale_arbits_per_ether(address db, uint256 _v) internal {\n', '        database(db).set_presale_arbits_per_ether(_v);\n', '        emit e_set_presale_arbits_per_ether(_v);\n', '    }\n', '\n', '    //// "GLOABL" SALE FUNCTIONS (applies across the entire presale)\n', '    // getters\n', '    function get_presale_arbits_total(address db) internal view returns(uint256) {\n', '        return database(db).get_presale_arbits_total();\n', '    }\n', '\n', '    function get_presale_arbits_sold(address db) internal view returns(uint256) {\n', '        return database(db).get_presale_arbits_sold();\n', '    }\n', '\n', '    function get_arbits_max_contribution(address db) internal view returns(uint256) {\n', '        return database(db).get_contrib_arbits_max();\n', '    }\n', '\n', '    function get_arbits_min_contribution(address db) internal view returns(uint256) {\n', '        return database(db).get_contrib_arbits_min();\n', '    }\n', '\n', '    // setters\n', '    function set_presale_arbits_total(address db, uint256 _v) internal {\n', '        database(db).set_presale_arbits_total(_v);\n', '        emit e_set_presale_arbits_total(_v);\n', '    }\n', '\n', '    function set_presale_arbits_sold(address db, uint256 _v) internal {\n', '        database(db).set_presale_arbits_sold(_v);\n', '        emit e_set_presale_arbits_sold(_v);\n', '    }\n', '\n', '    function set_arbits_max_contribution(address db, uint256 _v) internal {\n', '        database(db).set_contrib_arbits_max(_v);\n', '        emit e_set_arbits_max_contribution(_v);\n', '    }\n', '\n', '    function set_arbits_min_contribution(address db, uint256 _v) internal {\n', '        database(db).set_contrib_arbits_min(_v);\n', '        emit e_set_arbits_min_contribution(_v);\n', '    }\n', '\n', '    // modifiers\n', '    function add_presale_arbits_sold(address db, uint256 _v) internal {\n', '        uint256 c = database(db).get_presale_arbits_sold() + _v;     // safe math check\n', '        assert(c >= database(db).get_presale_arbits_sold()); //\n', '        database(db).set_presale_arbits_sold(\n', '            (database(db).get_presale_arbits_sold() + _v)\n', '        );\n', '        emit e_add_presale_arbits_sold(_v);\n', '    }\n', '\n', '    function sub_presale_arbits_sold(address db, uint256 _v) internal {\n', '        assert(_v <= database(db).get_presale_arbits_sold()); // safe math check\n', '        database(db).set_presale_arbits_sold(\n', '            (database(db).get_presale_arbits_sold() - _v)\n', '        );\n', '        emit e_sub_presale_arbits_sold(_v);\n', '    }\n', '    \n', '    function set_sale_owner(address db, address _a, bool _v) internal {\n', '        database(db).set_sale_owner(_a, _v);\n', '    }\n', '\n', '    function get_sale_owner(address db, address _a) internal view returns(bool) {\n', '        return database(db).get_sale_owner(_a);\n', '    }\n', '\n', '    event e_set_sale_owner(address, bool);\n', '    event e_set_num_of_uses(address, uint8);\n', '    event e_set_arbits_whitelist(address, bool);\n', '    event e_set_participant(address, uint256, uint256, uint256, bool, uint8);\n', '    event e_set_topl_address(address, uint256);\n', '    event e_set_arbits(address, uint256);\n', '    event e_set_iconiq_tokens(address, uint256);\n', '    event e_add_arbits(address, uint256);\n', '    event e_sub_arbits(address, uint256);\n', '    event e_set_pre_kyc_bonus_numerator(uint256);\n', '    event e_set_pre_kyc_bonus_denominator(uint256);\n', '    event e_set_iconiq_presale_open(bool);\n', '    event e_set_arbits_presale_open(bool);\n', '    event e_set_presale_iconiq_arbits_per_ether(uint256);\n', '    event e_set_presale_arbits_per_ether(uint256);\n', '    event e_set_presale_arbits_total(uint256);\n', '    event e_set_presale_arbits_sold(uint256);\n', '    event e_add_presale_arbits_sold(uint256);\n', '    event e_sub_presale_arbits_sold(uint256);\n', '    event e_set_arbits_max_contribution(uint256);\n', '    event e_set_arbits_min_contribution(uint256);\n', '    event e_set_pre_kyc_iconiq_bonus_numerator(uint256);\n', '    event e_set_pre_kyc_iconiq_bonus_denominator(uint256);\n', '}\n', '\n', '// File: contracts\\iconiq_presale.sol\n', '\n', 'contract iconiq_presale {\n', '\n', '    // libraries\n', '    using topl_database_lib for address;\n', '    using SafeMath for uint256;\n', '\n', '    // contract level vars\n', '    address public owner;\n', '    address public db;\n', '\n', '    // helpful data structs\n', '    struct participant {\n', '        address eth_address; // your eth address\n', '        uint256 topl_address; // your topl address\n', '        uint256 arbits; // the amount of a arbits you have\n', '        uint256 num_of_pro_rata_tokens_alloted;\n', '        bool arbits_kyc_whitelist; // if you pass arbits level kyc you get this\n', '        uint8 num_of_uses;\n', '    }\n', '\n', '    // permissions\n', '    constructor(address __db) public {\n', '        db = __db;\n', '        owner = msg.sender;\n', '    }\n', '\n', "    function owner_linkage() public { // must be called after the sale contract has been linked to the database contract via database's add master function\n", '        db.set_sale_owner(owner, true);\n', '    }\n', '\n', '    modifier only_owner() {\n', '        require(db.get_sale_owner(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function add_owner(address __subject) public only_owner {\n', '        db.set_sale_owner(__subject, true);\n', '        emit e_add_owner(msg.sender, __subject);\n', '    }\n', '\n', '    function remove_owner(address __subject) public only_owner {\n', '        db.set_sale_owner(__subject, false);\n', '        emit e_remove_owner(msg.sender, __subject);\n', '    }\n', '\n', '    // functionality\n', '    function participate_in_arbits_presale_crypto() public payable presale_open use_count {\n', '        /////////////////////////////////////////////////////////////////////\n', '                                                                           //\n', '        (                                                                  //\n', '            address p1,                                                    //\n', '            uint256 p2,                                                    // LOAD\n', '            uint256 p3,                                                    // PARTICIPANT\n', '            uint256 p4,                                                    // DATA\n', '            bool p5,                                                       // FROM\n', '            uint8 p6                                                       // DATABASE\n', '        ) = db.get_participant(msg.sender);                                //\n', '        participant memory subject = participant(p1, p2, p3, p4, p5, p6);  //\n', '                                                                           //\n', '        /////////////////////////////////////////////////////////////////////\n', '\n', '        // Note: The num_of_pro_rata_tokens_alloted struct field of iconiq members is set by a contract\n', '        // connected to the database contract that is outside the scope of this audit.\n', '\n', '        ///////////////////////////////////////////////////////\n', '                                                             // Iconiq\n', '        require(subject.num_of_pro_rata_tokens_alloted > 0); // Member\n', '                                                             // Check\n', '        ///////////////////////////////////////////////////////\n', '\n', '        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '                                                                                                                                           //\n', '        uint256 subject_tokens_to_add_at_iconiq_price = msg.value.mul(db.get_presale_iconiq_arbits_per_ether()).div(1 ether);  //\n', '        uint256 subject_tokens_to_add_at_reg_price = msg.value.mul(db.get_presale_arbits_per_ether()).div(1 ether);            //\n', '        uint256 amount_of_pro_rata_tokens_subject_can_get = subject.num_of_pro_rata_tokens_alloted;                                        //\n', '        uint256 subject_tokens_to_add = 0;                                                                                                 //\n', '        if (amount_of_pro_rata_tokens_subject_can_get >= subject.arbits.add(subject_tokens_to_add_at_iconiq_price)) {                      //\n', '            subject_tokens_to_add = subject_tokens_to_add_at_iconiq_price;  // everything at ICONIQ rate                                   //\n', '        } else {                                                                                                                           //\n', '            if (subject.arbits < amount_of_pro_rata_tokens_subject_can_get) {                                                              //\n', '                uint256 delta = amount_of_pro_rata_tokens_subject_can_get.sub(subject.arbits);  // some at ICONIQ rate and some not        //\n', '                subject_tokens_to_add = delta.add(                                              //                                         //\n', '                    subject_tokens_to_add_at_iconiq_price                                       //                                         // Arbits\n', '                    .sub(delta)                                                                 //                                         // Purchased\n', '                    .mul(db.get_presale_arbits_per_ether())                                     //                                         // Calculation\n', '                    .div(db.get_presale_iconiq_arbits_per_ether())                              //                                         //\n', '                );                                                                              //                                         //\n', '            } else {                                                                                                                       //\n', '                subject_tokens_to_add = subject_tokens_to_add_at_reg_price;  // nothing at ICONIQ rate                                     //\n', '            }                                                                                                                              //\n', '        }                                                                                                                                  //\n', '        if (subject.arbits_kyc_whitelist) {                                                                                                //\n', '            subject_tokens_to_add = subject_tokens_to_add         // pre-kyc bonus                                                         //\n', '                .mul(db.get_pre_kyc_iconiq_bonus_numerator())     //                                                                       //\n', '                .div(db.get_pre_kyc_iconiq_bonus_denominator());  //                                                                       //\n', '        }                                                                                                                                  //\n', '                                                                                                                                           //\n', '        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '        // Note: users must send ether in amounts that are evenly divide tokens_per_ether.\n', '        // Ex: If tokens_per_ether = 4 and a user sends .9 ether they will receive 3 tokens and forfeit .15 ether.\n', '        // The correct interaction would be to send some increment of .25 ether.\n', '\n', '        //////////////////////////////////////////////////////////////////////////////////////////////////////\n', '                                                                                                            //\n', '        require(db.get_presale_arbits_total() >= db.get_presale_arbits_sold().add(subject_tokens_to_add));  // Sale\n', '        require(db.get_arbits_max_contribution() >= subject_tokens_to_add); // max                  // Limit\n', '        require(db.get_arbits_min_contribution() <= subject_tokens_to_add); // min                  // Checks\n', '                                                                                                            //\n', '        //////////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '        /////////////////////////////////////////////////////////////////////////////\n', '                                                                                   //\n', '        db.add_presale_arbits_sold(subject_tokens_to_add); // update sold counter  // Update\n', '        db.add_arbits(msg.sender, subject_tokens_to_add); // update arbits         // Database\n', '                                                                                   //\n', '        /////////////////////////////////////////////////////////////////////////////\n', '\n', '        ///////////////////////////////////////////////////////////////////////\n', '                                                                             //\n', '        emit e_participate_in_arbits_presale_crypto(msg.sender, msg.value);  // Event\n', '                                                                             //\n', '        ///////////////////////////////////////////////////////////////////////\n', '    }\n', '\n', '    function() public payable {\n', '        participate_in_arbits_presale_crypto(); // allows users to participate without an explicit function call\n', '        emit e_fallback(msg.sender, msg.value);\n', '    }\n', '\n', '    // owner withdraw\n', '    function kill_and_withdraw(address withdraw_to) public only_owner {\n', '        emit e_kill_and_withdraw(withdraw_to);\n', '        selfdestruct(withdraw_to);\n', '    }\n', '\n', '    function withdraw_some_amount(address withdraw_to, uint256 amount) public only_owner {\n', '        withdraw_to.transfer(amount); // amount in wei, throws if error\n', '        emit e_withdraw_some_amount(withdraw_to, amount);\n', '    }\n', '\n', '    // sale settings\n', '    function set_sale_open() public only_owner {\n', '        require(db.get_presale_arbits_per_ether() > 0);\n', '        require(db.get_presale_iconiq_arbits_per_ether() > 0);\n', '        require(db.get_arbits_max_contribution() > 0);\n', '        require(db.get_arbits_min_contribution() > 0);\n', '        require(db.get_pre_kyc_iconiq_bonus_numerator() > 0);\n', '        require(db.get_pre_kyc_iconiq_bonus_denominator() > 0);\n', '        db.set_iconiq_presale_open(true);\n', '    }\n', '\n', '    function set_sale_closed() public only_owner {\n', '        db.set_iconiq_presale_open(false);\n', '    }\n', '\n', '    function set_iconiq_arbits_per_ether(uint256 _v) public only_owner {\n', '        db.set_presale_iconiq_arbits_per_ether(_v); // this is the pro rata rate\n', '    }\n', '\n', '    function set_iconiq_pre_kyc_bonus_numerator(uint256 _v) public only_owner {\n', '        db.set_pre_kyc_iconiq_bonus_numerator(_v);\n', '    }\n', '\n', '    function set_iconiq_pre_kyc_bonus_denominator(uint256 _v) public only_owner {\n', '        db.set_pre_kyc_iconiq_bonus_denominator(_v);\n', '    }\n', '\n', '    // general modifiers\n', '    modifier presale_open() {\n', '        require(db.get_iconiq_presale_open());\n', '        _;\n', '    }\n', '\n', '    modifier use_count() {\n', '        uint8 uses = db.get_num_of_uses(msg.sender);\n', '        require(uses < 5);\n', '        db.set_num_of_uses(msg.sender, uses + 1);\n', '        _;\n', '    }\n', '\n', '    // helpers\n', '    function is_presale_open() public view returns(bool) {\n', '        return db.get_iconiq_presale_open();\n', '    }\n', '\n', '    function am_i_on_the_whitelist() public view returns(bool) {\n', '        return db.get_arbits_whitelist(msg.sender);\n', '    }\n', '\n', '    function how_many_arbits_do_i_have() public view returns(uint256) {\n', '        return db.get_arbits(msg.sender);\n', '    }\n', '\n', '    // events\n', '    //\n', '    // All storage calls are logged via events emitted in the library functions.\n', "    // Because web3 bugs out when when libraries call events that aren't defined in\n", '    // the parent contract. We redefine them here.\n', '    //\n', '    // contract level events\n', '    event e_add_owner(address, address); // adder, addie <-------- These are words now!\n', '    event e_remove_owner(address, address); // remover, removie <_/\n', '    event e_participate_in_arbits_presale_crypto(address, uint256); // msg.sender, msg.value\n', '    event e_fallback(address, uint256); // msg.sender, msg.value (used to gather data on what %\n', '    // of people just send ether vs sending a function call\n', '    event e_kill_and_withdraw(address); // person that just took all our money\n', '    event e_withdraw_some_amount(address, uint256); // withdrawal address, amount withdrawn\n', '}']
