['pragma solidity ^0.4.25;\n', '\n', '/// Code for ERC20+alpha token\n', '/// @author A. Vidovic\n', 'contract WWBCToken {\n', '    string public name = &#39;wowbit classic&#39;;      //fancy name\n', '    uint8 public decimals = 18;                 //How many decimals to show. It&#39;s like comparing 1 wei to 1 ether.\n', '    string public symbol = &#39;wwbc&#39;;              //Identifier\n', '    string public version = &#39;1.0&#39;;\n', '\n', '    uint256 weisPerEth = 1000000000000000000;\n', '    /// total amount of tokens\n', '    uint256 public totalSupply = 3333333333 * weisPerEth;\n', '    uint256 public tokenWeisPerEth = 303030303030303030303;  // 1 ETH = 0.0033 WWBC\n', '    address owner0;     // just in case an owner change would be mistaken\n', '    address owner;\n', '    uint256 public saleCap = 0 * weisPerEth;\n', '    uint256 public notAttributed = totalSupply - saleCap;\n', '\n', '    constructor(\n', '        uint256 _initialAmount,\n', '        uint256 _saleCap,\n', '        string _tokenName,\n', '        string _tokenSymbol,\n', '        uint8 _decimalUnits\n', '        ) public {\n', '        totalSupply = _initialAmount * weisPerEth;           // Update total supply\n', '        saleCap = _saleCap * weisPerEth;\n', '        notAttributed = totalSupply - saleCap;               // saleCap is an attributed amount\n', '        name = _tokenName;                                   // Set the name for display purposes\n', '        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n', '        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n', '\n', '        owner0 = msg.sender;\n', '        owner = msg.sender;\n', '        \n', '        balances[owner] = 100 * weisPerEth;                  // initial allocation for test purposes\n', '        notAttributed -= balances[owner];\n', '        emit Transfer(0, owner, balances[owner]);\n', '    }\n', '    \n', '    modifier ownerOnly {\n', '        require(owner == msg.sender || owner0 == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _newOwner) public ownerOnly {\n', '        if (owner0 == 0) {\n', '            if (owner == 0) {\n', '                owner0 = _newOwner;\n', '            } else {\n', '                owner0 = owner;\n', '            }\n', '        }\n', '        owner = _newOwner;\n', '    }\n', '    \n', '    function addToTotalSupply(uint256 _delta) public ownerOnly returns (uint256 availableAmount) {\n', '        totalSupply += _delta * weisPerEth;\n', '        notAttributed += _delta * weisPerEth;\n', '        return notAttributed;\n', '    }\n', '    \n', '    function withdraw() public ownerOnly {\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '    \n', '    function setSaleCap(uint256 _saleCap) public ownerOnly returns (uint256 toBeSold) {\n', '        notAttributed += saleCap;           // restore remaining previous saleCap to notAttributed pool\n', '        saleCap = _saleCap * weisPerEth;\n', '        if (saleCap > notAttributed) {      // not oversold amount \n', '            saleCap = notAttributed;\n', '        }\n', '        notAttributed -= saleCap;           // attribute this new cap\n', '        return saleCap;\n', '    }\n', '    \n', '    bool public onSaleFlag = false;\n', '    \n', '    function setSaleFlag(bool _saleFlag) public ownerOnly {\n', '        onSaleFlag = _saleFlag;\n', '    }\n', '    \n', '    bool public useWhitelistFlag = false;\n', '    \n', '    function setUseWhitelistFlag(bool _useWhitelistFlag) public ownerOnly {\n', '        useWhitelistFlag = _useWhitelistFlag;\n', '    }\n', '    \n', '    function calcTokenSold(uint256 _ethValue) public view returns (uint256 tokenValue) {\n', '        return _ethValue * tokenWeisPerEth / weisPerEth;\n', '    }\n', '    \n', '    uint256 public percentFrozenWhenBought = 75;   // % of tokens you buy that you can&#39;t use right away\n', '    uint256 public percentUnfrozenAfterBuyPerPeriod = 25;  //  % of bought tokens you get to use after each period\n', '    uint public buyUnfreezePeriodSeconds = 30 * 24 * 3600;  // aforementioned period\n', '    \n', '    function setPercentFrozenWhenBought(uint256 _percentFrozenWhenBought) public ownerOnly {\n', '        percentFrozenWhenBought = _percentFrozenWhenBought;\n', '    }\n', '    \n', '    function setPercentUnfrozenAfterBuyPerPeriod(uint256 _percentUnfrozenAfterBuyPerPeriod) public ownerOnly {\n', '        percentUnfrozenAfterBuyPerPeriod = _percentUnfrozenAfterBuyPerPeriod;\n', '    }\n', '    \n', '    function setBuyUnfreezePeriodSeconds(uint _buyUnfreezePeriodSeconds) public ownerOnly {\n', '        buyUnfreezePeriodSeconds = _buyUnfreezePeriodSeconds;\n', '    }\n', '    \n', '    function buy() payable public {\n', '        if (useWhitelistFlag) {\n', '            if (!isWhitelist(msg.sender)) {\n', '                emit NotWhitelisted(msg.sender);\n', '                revert();\n', '            }\n', '        }\n', '        if (saleCap>0) {\n', '            uint256 tokens = calcTokenSold(msg.value);\n', '            if (tokens<=saleCap) {\n', '                if (tokens > 0) { \n', '                    lastUnfrozenTimestamps[msg.sender] = block.timestamp;\n', '                    boughtTokens[msg.sender] += tokens;\n', '                    frozenTokens[msg.sender] += tokens * percentFrozenWhenBought / 100;\n', '                    balances[msg.sender] += tokens * ( 100 - percentFrozenWhenBought) / 100;\n', '                    saleCap -= tokens;\n', '                    emit Transfer(0, msg.sender, tokens);\n', '                } else {\n', '                    revert();\n', '                }\n', '            } else {\n', '                emit NotEnoughTokensLeftForSale(saleCap);\n', '                revert();\n', '            }\n', '        } else {\n', '            emit NotEnoughTokensLeftForSale(saleCap);\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function () payable public {\n', '        //if ether is sent to this address and token sale is not ON, send it back.\n', '        if (!onSaleFlag) {\n', '            revert();\n', '        } else {\n', '            buy();\n', '        }\n', '    }\n', '    \n', '    mapping (address => uint256) public boughtTokens;  // there is some kind of lockup even for those who bought tokens\n', '    mapping (address => uint) public lastUnfrozenTimestamps;\n', '    mapping (address => uint256) public frozenTokens;\n', '    \n', '    uint256 public percentFrozenWhenAwarded = 100;   // % of tokens you are awarded that you can&#39;t use right away\n', '    uint256 public percentUnfrozenAfterAwardedPerPeriod = 25;  //  % of bought tokens you get to use after each period\n', '    uint public awardedInitialWaitSeconds = 6 * 30 * 24 * 3600;  // initial waiting period for hodlers\n', '    uint public awardedUnfreezePeriodSeconds = 30 * 24 * 3600;  // aforementioned period\n', '    \n', '    function setPercentFrozenWhenAwarded(uint256 _percentFrozenWhenAwarded) public ownerOnly {\n', '        percentFrozenWhenAwarded = _percentFrozenWhenAwarded;\n', '    }\n', '    \n', '    function setPercentUnfrozenAfterAwardedPerPeriod(uint256 _percentUnfrozenAfterAwardedPerPeriod) public ownerOnly {\n', '        percentUnfrozenAfterAwardedPerPeriod = _percentUnfrozenAfterAwardedPerPeriod;\n', '    }\n', '    \n', '    function setAwardedInitialWaitSeconds(uint _awardedInitialWaitSeconds) public ownerOnly {\n', '        awardedInitialWaitSeconds = _awardedInitialWaitSeconds;\n', '    }\n', '    \n', '    function setAwardedUnfreezePeriodSeconds(uint _awardedUnfreezePeriodSeconds) public ownerOnly {\n', '        awardedUnfreezePeriodSeconds = _awardedUnfreezePeriodSeconds;\n', '    }\n', '    \n', '    function award(address _to, uint256 _nbTokens) public ownerOnly {\n', '        if (notAttributed>0) {\n', '            uint256 tokens = _nbTokens * weisPerEth;\n', '            if (tokens<=notAttributed) {\n', '                if (tokens > 0) {\n', '                    awardedTimestamps[_to] = block.timestamp;\n', '                    awardedTokens[_to] += tokens;\n', '                    frozenAwardedTokens[_to] += tokens * percentFrozenWhenAwarded / 100;\n', '                    balances[_to] += tokens * ( 100 - percentFrozenWhenAwarded) / 100;\n', '                    notAttributed -= tokens;\n', '                    emit Transfer(0, _to, tokens);\n', '                }\n', '            } else {\n', '                emit NotEnoughTokensLeft(notAttributed);\n', '            }\n', '        } else {\n', '            emit NotEnoughTokensLeft(notAttributed);\n', '        }\n', '    }\n', '    \n', '    mapping (address => uint256) public awardedTokens;\n', '    mapping (address => uint) public awardedTimestamps;\n', '    mapping (address => uint) public lastUnfrozenAwardedTimestamps;\n', '    mapping (address => uint256) public frozenAwardedTokens;\n', '    \n', '    /// transfer tokens from unattributed pool without any lockup (e.g. for human sale)\n', '    function grant(address _to, uint256 _nbTokens) public ownerOnly {\n', '        if (notAttributed>0) {\n', '            uint256 tokens = _nbTokens * weisPerEth;\n', '            if (tokens<=notAttributed) {\n', '                if (tokens > 0) {\n', '                    balances[_to] += tokens;\n', '                    notAttributed -= tokens;\n', '                    emit Transfer(0, _to, tokens);\n', '                }\n', '            } else {\n', '                emit NotEnoughTokensLeft(notAttributed);\n', '            }\n', '        } else {\n', '            emit NotEnoughTokensLeft(notAttributed);\n', '        }\n', '    }\n', '    \n', '    function setWhitelist(address _addr, bool _wlStatus) public ownerOnly {\n', '        whitelist[_addr] = _wlStatus;\n', '    }\n', '    \n', '    function isWhitelist(address _addr) public view returns (bool isWhitelisted) {\n', '        return whitelist[_addr]==true;\n', '    }\n', '    \n', '    mapping (address => bool) public whitelist;\n', '    \n', '    function setSaleAddr(address _addr, bool _saleStatus) public ownerOnly {\n', '        saleAddrs[_addr] = _saleStatus;\n', '    }\n', '    \n', '    function isSaleAddr(address _addr) public view returns (bool isASaleAddr) {\n', '        return saleAddrs[_addr]==true;\n', '    }\n', '    \n', '    mapping (address => bool) public saleAddrs;            // marks sale addresses : transfer recipients from those addresses are subjected to buy lockout rules\n', '    \n', '    bool public manualSaleFlag = false;\n', '    \n', '    function setManualSaleFlag(bool _manualSaleFlag) public ownerOnly {\n', '        manualSaleFlag = _manualSaleFlag;\n', '    }\n', '    \n', '    mapping (address => uint256) public balances;      // available on hand\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    \n', '\n', '    function setBlockedAccount(address _addr, bool _blockedStatus) public ownerOnly {\n', '        blockedAccounts[_addr] = _blockedStatus;\n', '    }\n', '    \n', '    function isBlockedAccount(address _addr) public view returns (bool isAccountBlocked) {\n', '        return blockedAccounts[_addr]==true;\n', '    }\n', '    \n', '    mapping (address => bool) public blockedAccounts;  // mechanism allowing to stop thieves from profiting\n', '    \n', '    /// Used to empty blocked accounts of stolen tokens and return them to rightful owners\n', '    function moveTokens(address _from, address _to, uint256 _amount) public ownerOnly  returns (bool success) {\n', '        if (_amount>0 && balances[_from] >= _amount) {\n', '            balances[_from] -= _amount;\n', '            balances[_to] += _amount;\n', '            emit Transfer(_from, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function unfreezeBoughtTokens(address _owner) public {\n', '        if (frozenTokens[_owner] > 0) {\n', '            uint elapsed = block.timestamp - lastUnfrozenTimestamps[_owner];\n', '            if (elapsed > buyUnfreezePeriodSeconds) {\n', '                uint256 tokensToUnfreeze = boughtTokens[_owner] * percentUnfrozenAfterBuyPerPeriod / 100;\n', '                if (tokensToUnfreeze > frozenTokens[_owner]) {\n', '                    tokensToUnfreeze = frozenTokens[_owner];\n', '                }\n', '                balances[_owner] += tokensToUnfreeze;\n', '                frozenTokens[_owner] -= tokensToUnfreeze;\n', '                lastUnfrozenTimestamps[_owner] = block.timestamp;\n', '            }\n', '        } \n', '    }\n', '\n', '    function unfreezeAwardedTokens(address _owner) public {\n', '        if (frozenAwardedTokens[_owner] > 0) {\n', '            uint elapsed = 0;\n', '            uint waitTime = awardedInitialWaitSeconds;\n', '            if (lastUnfrozenAwardedTimestamps[_owner]<=0) {\n', '                elapsed = block.timestamp - awardedTimestamps[_owner];\n', '            } else {\n', '                elapsed = block.timestamp - lastUnfrozenAwardedTimestamps[_owner];\n', '                waitTime = awardedUnfreezePeriodSeconds;\n', '            }\n', '            if (elapsed > waitTime) {\n', '                uint256 tokensToUnfreeze = awardedTokens[_owner] * percentUnfrozenAfterAwardedPerPeriod / 100;\n', '                if (tokensToUnfreeze > frozenAwardedTokens[_owner]) {\n', '                    tokensToUnfreeze = frozenAwardedTokens[_owner];\n', '                }\n', '                balances[_owner] += tokensToUnfreeze;\n', '                frozenAwardedTokens[_owner] -= tokensToUnfreeze;\n', '                lastUnfrozenAwardedTimestamps[_owner] = block.timestamp;\n', '            }\n', '        } \n', '    }\n', '    \n', '    function unfreezeTokens(address _owner) public returns (uint256 frozenAmount) {\n', '        unfreezeBoughtTokens(_owner);\n', '        unfreezeAwardedTokens(_owner);\n', '        return frozenTokens[_owner] + frozenAwardedTokens[_owner];\n', '    }\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public returns (uint256 balance) {\n', '        unfreezeTokens(_owner);\n', '        return balances[_owner];\n', '    }\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        //Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\n', '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (!isBlockedAccount(msg.sender) && (balanceOf(msg.sender) >= _value && _value > 0)) {\n', '            if (isSaleAddr(msg.sender)) {\n', '                if (manualSaleFlag) {\n', '                    boughtTokens[_to] += _value;\n', '                    lastUnfrozenTimestamps[_to] = block.timestamp;\n', '                    frozenTokens[_to] += _value * percentFrozenWhenBought / 100;\n', '                    balances[_to] += _value * ( 100 - percentFrozenWhenBought) / 100;\n', '                } else {\n', '                    return false;\n', '                }\n', '            } else {\n', '                balances[_to] += _value;\n', '            }\n', '            balances[msg.sender] -= _value;\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { \n', '            return false; \n', '        }\n', '    }\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (!isBlockedAccount(msg.sender) && (balanceOf(_from) >= _value && allowed[_from][msg.sender] >= _value) && _value > 0) {\n', '            if (isSaleAddr(_from)) {\n', '                if (manualSaleFlag) {\n', '                    boughtTokens[_to] += _value;\n', '                    lastUnfrozenTimestamps[_to] = block.timestamp;\n', '                    frozenTokens[_to] += _value * percentFrozenWhenBought / 100;\n', '                    balances[_to] += _value * ( 100 - percentFrozenWhenBought) / 100;\n', '                } else {\n', '                    return false;\n', '                }\n', '            } else {\n', '                balances[_to] += _value;\n', '            }\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { \n', '            return false; \n', '        }\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event NotEnoughTokensLeftForSale(uint256 _tokensLeft);\n', '    event NotEnoughTokensLeft(uint256 _tokensLeft);\n', '    event NotWhitelisted(address _addr);\n', '}']