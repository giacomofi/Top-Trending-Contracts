['pragma solidity ^0.4.19;\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 {\n', '  // Required:\n', '    function approve(address to, uint256 tokenId) public; \n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function implementsERC721() public pure returns (bool);\n', '    function ownerOf(uint256 tokenId) public view returns (address addr);\n', '    function takeOwnership(uint256 tokenId) public;\n', '    function totalSupply() public view returns (uint256 total);\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function transfer(address to, uint256 tokenId) public;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /** ERC721Metadata */ \n', '    function name() external view returns (string name);\n', '    function symbol() external view returns (string symbol);\n', '    function tokenURI(uint256 _tokenId) external view returns (string uri); \n', '  }\n', '\n', '\n', '\n', '/**\n', ' * @title ExoPlanets crypto game\n', ' * ExoPlanets is a space exploration crypto game with real data from NASA, that will allow the players to own ExoPlanets, \n', ' * evolve life and civilizations all the way to the “Space Age” and send exploration ships to other \n', ' * planets for resources and tokens mining.\n', ' * ExoPlanets is based on the ERC721 standard with several extensions (cryptoMatch, lifeRate..) to\n', ' * make the gaming experience more realistic (and exciting).\n', ' */\n', 'contract ExoplanetToken is ERC721 {\n', '\n', '    using SafeMath for uint256; \n', '    event Birth(uint256 indexed tokenId, string name, uint32 numOfTokensBonusOnPurchase, address owner);\n', '    event TokenSold(uint256 tokenId, uint256 oldPriceInEther, uint256 newPriceInEther, address prevOwner, address winner, string name);\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event ContractUpgrade(address newContract);\n', '\n', '    string public constant NAME = "ExoPlanets"; \n', '\n', '    string public constant SYMBOL = "XPL"; \n', '\n', '    string public constant BASE_URL = "https://exoplanets.io/metadata/planet_"; \n', '\n', '    uint32 private constant NUM_EXOPLANETS_LIMIT = 4700;  \n', '\n', '    uint256 private constant STEP_1 =  5.0 ether; \n', '    uint256 private constant STEP_2 = 10.0 ether;\n', '    uint256 private constant STEP_3 = 26.0 ether;\n', '    uint256 private constant STEP_4 = 36.0 ether;\n', '    uint256 private constant STEP_5 = 47.0 ether;\n', '    uint256 private constant STEP_6 = 59.0 ether;\n', '    uint256 private constant STEP_7 = 67.85 ether;\n', '    uint256 private constant STEP_8 = 76.67 ether;\n', '\n', '    mapping (uint256 => address) public currentOwner;\n', '    mapping (address => uint256) private numOwnedTokens;\n', '    mapping (uint256 => address) public approvedToTransfer;\n', '    mapping (uint256 => uint256) private currentPrice;\n', '    address public ceoAddress;\n', '    address public cooAddress;\n', '\n', '    bool public inPresaleMode = true;\n', '    bool public paused = false; \n', '    address public newContractAddress;\n', '\n', '    struct ExoplanetRec { \n', '        uint8 lifeRate; \n', '        uint32 priceInExoTokens; \n', '        uint32 numOfTokensBonusOnPurchase; \n', '        string name;\n', '        string cryptoMatch; \n', '        string techBonus1;\n', '        string techBonus2;\n', '        string techBonus3;\n', '        string scientificData;\n', '    }\n', '\n', '    ExoplanetRec[] private exoplanets;\n', '\n', '    modifier onlyCEO() {\n', '      require(msg.sender == ceoAddress);\n', '      _;  \n', '    }\n', '\n', '    modifier whenNotPaused() { \n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused() { \n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() public onlyCEO() whenNotPaused() {\n', '      paused = true;\n', '    }\n', '\n', '    function unpause() public onlyCEO() whenPaused() {\n', '      paused = false;\n', '    }\n', '\n', '   \n', '    function setNewAddress(address _v2Address) public onlyCEO() whenPaused() {\n', '      newContractAddress = _v2Address;\n', '      ContractUpgrade(_v2Address);\n', '    }\n', '\n', '\n', '    modifier onlyCOO() {\n', '      require(msg.sender == cooAddress);\n', '      _;\n', '    }\n', '\n', '    modifier presaleModeActive() {\n', '      require(inPresaleMode);\n', '      _;\n', '    }\n', '\n', '    \n', '    modifier afterPresaleMode() {\n', '      require(!inPresaleMode);\n', '      _;\n', '    }\n', '\n', '    \n', '\n', '    modifier onlyCLevel() {\n', '      require(\n', '        msg.sender == ceoAddress ||\n', '        msg.sender == cooAddress\n', '      );\n', '      _;\n', '    }\n', '\n', '    function setCEO(address newCEO) public onlyCEO {\n', '      require(newCEO != address(0));\n', '      ceoAddress = newCEO;\n', '    }\n', '\n', '    function setCOO(address newCOO) public onlyCEO {\n', '      require(newCOO != address(0));\n', '      cooAddress = newCOO;\n', '    }\n', '    \n', '    function setPresaleMode(bool newMode) public onlyCEO {\n', '      inPresaleMode = newMode;\n', '    }    \n', '\n', '    \n', '    function ExoplanetToken() public {\n', '        ceoAddress = msg.sender;\n', '        cooAddress = msg.sender;\n', '    }\n', '\n', '    function approve(address to, uint256 tokenId) public {\n', '    \n', '        require(owns(msg.sender, tokenId));\n', '\n', '        approvedToTransfer[tokenId] = to;\n', '\n', '        Approval(msg.sender, to, tokenId);\n', '    }\n', '\n', '    function balanceOf(address owner) public view returns (uint256 balance) {\n', '        balance = numOwnedTokens[owner];\n', '    }\n', '\n', '\n', '    function createContractExoplanet(\n', '          string name, uint256 priceInEther, uint32 priceInExoTokens, \n', '          string cryptoMatch, uint32 numOfTokensBonusOnPurchase, \n', '          uint8 lifeRate, string scientificData) public onlyCLevel { \n', '\n', '        _createExoplanet(name, address(this), priceInEther, priceInExoTokens, \n', '              cryptoMatch, numOfTokensBonusOnPurchase, lifeRate, scientificData);\n', '    }\n', '\n', '    \n', '    function getName(uint256 tokenId) public view returns (string) {\n', '      return exoplanets[tokenId].name;\n', '    }\n', '\n', '    function getPriceInExoTokens(uint256 tokenId) public view returns (uint32) {\n', '      return exoplanets[tokenId].priceInExoTokens;\n', '    }\n', '\n', '    function getLifeRate(uint256 tokenId) public view returns (uint8) {\n', '      return exoplanets[tokenId].lifeRate;\n', '    }\n', '\n', '    function getNumOfTokensBonusOnPurchase(uint256 tokenId) public view returns (uint32) {\n', '      return exoplanets[tokenId].numOfTokensBonusOnPurchase;\n', '    }\n', '\n', '    function getCryptoMatch(uint256 tokenId) public view returns (string) {\n', '      return exoplanets[tokenId].cryptoMatch;\n', '    }\n', '\n', '    function getTechBonus1(uint256 tokenId) public view returns (string) {\n', '      return exoplanets[tokenId].techBonus1;\n', '    }\n', '\n', '    function getTechBonus2(uint256 tokenId) public view returns (string) {\n', '      return exoplanets[tokenId].techBonus2;\n', '    }\n', '\n', '    function getTechBonus3(uint256 tokenId) public view returns (string) {\n', '      return exoplanets[tokenId].techBonus3;\n', '    }\n', '\n', '    function getScientificData(uint256 tokenId) public view returns (string) {\n', '      return exoplanets[tokenId].scientificData;\n', '    }\n', '\n', '  \n', '    function setTechBonus1(uint256 tokenId, string newVal) public {\n', '\n', '      require(owns(msg.sender, tokenId)); \n', '      exoplanets[tokenId].techBonus1 = newVal;\n', '    }\n', '\n', '    function setTechBonus2(uint256 tokenId, string newVal) public {\n', '      require(owns(msg.sender, tokenId)); \n', '      exoplanets[tokenId].techBonus2 = newVal;\n', '    }\n', '\n', '    function setTechBonus3(uint256 tokenId, string newVal) public {\n', '      require(owns(msg.sender, tokenId)); \n', '      exoplanets[tokenId].techBonus3 = newVal;\n', '    }\n', '\n', '    function setPriceInEth(uint256 tokenId, uint256 newPrice) public afterPresaleMode() {\n', '      require(owns(msg.sender, tokenId)); \n', '      currentPrice[tokenId] = newPrice;\n', '    }\n', '\n', '    function setPriceInExoTokens(uint256 tokenId, uint32 newPrice) public afterPresaleMode() {\n', '      require(owns(msg.sender, tokenId)); \n', '      exoplanets[tokenId].priceInExoTokens = newPrice;\n', '    }\n', '\n', '    function setScientificData(uint256 tokenId, string newData) public onlyCLevel { \n', '      exoplanets[tokenId].scientificData = newData;\n', '    }\n', '\n', '\n', '    function getExoplanet(uint256 tokenId) public view returns ( \n', '      string exoplanetName,\n', '      uint256 sellingPriceInEther,\n', '      address owner,\n', '      uint8 lifeRate,\n', '      uint32 priceInExoTokens,\n', '      uint32 numOfTokensBonusOnPurchase,\n', '      string cryptoMatch,\n', '      string scientificData) {\n', '\n', '\n', '      ExoplanetRec storage exoplanet = exoplanets[tokenId];       \n', '      exoplanetName = exoplanet.name;\n', '      lifeRate = exoplanet.lifeRate;\n', '      priceInExoTokens = exoplanet.priceInExoTokens;\n', '      numOfTokensBonusOnPurchase = exoplanet.numOfTokensBonusOnPurchase;\n', '      cryptoMatch = exoplanet.cryptoMatch;\n', '      scientificData = exoplanet.scientificData;\n', '      \n', '      sellingPriceInEther = currentPrice[tokenId];\n', '      owner = currentOwner[tokenId];\n', '    }  \n', '\n', '\n', '    function implementsERC721() public pure returns (bool) {\n', '      return true;\n', '    }\n', '\n', '    function ownerOf(uint256 tokenId) public view returns (address owner) {   \n', '      owner = currentOwner[tokenId];\n', '    }\n', '\n', '\n', '    function transferUnownedPlanet(address newOwner, uint256 tokenId) public onlyCLevel { \n', '      \n', '      require(currentOwner[tokenId] == address(this));\n', '\n', '      require(newOwner != address(0));\n', '\n', '      _transfer(currentOwner[tokenId], newOwner, tokenId);    \n', '\n', '      TokenSold(tokenId, currentPrice[tokenId], currentPrice[tokenId], address(this), newOwner, exoplanets[tokenId].name);\n', '    }\n', '\n', '\n', '    function purchase(uint256 tokenId) public payable whenNotPaused() presaleModeActive() {\n', '    \n', '      require(currentOwner[tokenId] != msg.sender);\n', '\n', '      require(addressNotNull(msg.sender));\n', '\n', '      uint256 planetPrice = currentPrice[tokenId]; \n', '\n', '      require(msg.value >= planetPrice);\n', '\n', '\n', '      uint256 purchaseExcess = msg.value.sub(planetPrice); \n', '\n', '      uint paymentPrcnt;\n', '      uint stepPrcnt;\n', '\n', '      if (planetPrice <= STEP_1) {        \n', '        paymentPrcnt = 93; \n', '        stepPrcnt = 200;\n', '      } else if (planetPrice <= STEP_2) {\n', '        paymentPrcnt = 93; \n', '        stepPrcnt = 150;\n', '      } else if (planetPrice <= STEP_3) {\n', '        paymentPrcnt = 93; \n', '        stepPrcnt = 135;\n', '      } else if (planetPrice <= STEP_4) {\n', '        paymentPrcnt = 94; \n', '        stepPrcnt = 125;\n', '      } else if (planetPrice <= STEP_5) {\n', '        paymentPrcnt = 94; \n', '        stepPrcnt = 119;\n', '      } else if (planetPrice <= STEP_6) {\n', '        paymentPrcnt = 95; \n', '        stepPrcnt = 117;    \n', '      } else if (planetPrice <= STEP_7) {\n', '        paymentPrcnt = 95; \n', '        stepPrcnt = 115;\n', '      } else if (planetPrice <= STEP_8) {\n', '        paymentPrcnt = 95; \n', '        stepPrcnt = 113;\n', '      } else {  \n', '        paymentPrcnt = 96; \n', '        stepPrcnt = 110;\n', '      }\n', '\n', '      currentPrice[tokenId] = planetPrice.mul(stepPrcnt).div(100);\n', '\n', '      uint256 payment = uint256(planetPrice.mul(paymentPrcnt).div(100));\n', '\n', '      address seller = currentOwner[tokenId];\n', '      \n', '      if (seller != address(this)) {  \n', '        seller.transfer(payment); \n', '      }\n', '\n', '      _transfer(seller, msg.sender, tokenId); \n', '\n', '      TokenSold(tokenId, planetPrice, currentPrice[tokenId], seller, msg.sender, exoplanets[tokenId].name);\n', '\n', '      msg.sender.transfer(purchaseExcess); \n', '    }\n', '\n', '\n', '    function priceOf(uint256 tokenId) public view returns (uint256) {\n', '      return currentPrice[tokenId];\n', '    }\n', '\n', '\n', '    function takeOwnership(uint256 tokenId) public whenNotPaused() { \n', '\n', '      require(addressNotNull(msg.sender));\n', '\n', '      require(approved(msg.sender, tokenId));\n', '\n', '      _transfer(currentOwner[tokenId], msg.sender, tokenId);\n', '    }\n', '\n', '    \n', '    function tokensOfOwner(address owner) public view returns(uint256[] ownerTokens) {\n', '      uint256 tokenCount = balanceOf(owner);\n', '      if (tokenCount == 0) {\n', '        return new uint256[](0);\n', '      } else {\n', '        uint256[] memory result = new uint256[](tokenCount);\n', '        uint256 totalExoplanets = totalSupply();\n', '        uint256 resultIndex = 0;\n', '\n', '        uint256 exoplanetId;\n', '        for (exoplanetId = 0; exoplanetId <= totalExoplanets; exoplanetId++) {\n', '          if (currentOwner[exoplanetId] == owner) {\n', '            result[resultIndex] = exoplanetId;\n', '            resultIndex++;\n', '          }\n', '        }\n', '        return result;\n', '      }\n', '    }\n', '\n', '    function name() external view returns (string name) {\n', '      name = NAME;\n', '    }\n', '\n', '\n', '    function symbol() external view returns (string symbol) {\n', '      symbol = SYMBOL;\n', '    }\n', '\n', '\n', '    function tokenURI(uint256 _tokenId) external view returns (string uri) {\n', '      uri = appendNumToString(BASE_URL, _tokenId);\n', '    }\n', '\n', '\n', '    function totalSupply() public view returns (uint256 total) { \n', '      total = exoplanets.length;\n', '    }\n', '\n', '    \n', '    function transfer(address to, uint256 tokenId) public whenNotPaused() {\n', '      require(owns(msg.sender, tokenId));\n', '      require(addressNotNull(to));\n', '      _transfer(msg.sender, to, tokenId);\n', '    }\n', '\n', '   \n', '    function transferFrom(address from, address to, uint256 tokenId) public whenNotPaused() {\n', '      require(approved(from, tokenId));\n', '      require(addressNotNull(to));\n', '      _transfer(from, to, tokenId);\n', '    }\n', '\n', '   \n', '    function addressNotNull(address addr) private pure returns (bool) {\n', '      return addr != address(0);\n', '    }\n', '\n', '   \n', '    function approved(address to, uint256 tokenId) private view returns (bool) {\n', '      return approvedToTransfer[tokenId] == to;\n', '    }\n', '\n', '    \n', '    function _createExoplanet(\n', '        string name, address owner, uint256 priceInEther, uint32 priceInExoTokens, \n', '        string cryptoMatch, uint32 numOfTokensBonusOnPurchase, uint8 lifeRate, \n', '        string scientificData) private {\n', '\n', '      \n', '      require(totalSupply() < NUM_EXOPLANETS_LIMIT);\n', '\n', '      ExoplanetRec memory _exoplanet = ExoplanetRec({  \n', '        name: name,\n', '        priceInExoTokens: priceInExoTokens,\n', '        cryptoMatch: cryptoMatch,\n', '        numOfTokensBonusOnPurchase: numOfTokensBonusOnPurchase,\n', '        lifeRate: lifeRate,\n', '        techBonus1: "",\n', '        techBonus2: "",\n', '        techBonus3: "",\n', '        scientificData: scientificData\n', '      });\n', '      uint256 newExoplanetId = exoplanets.push(_exoplanet) - 1;\n', '\n', '      \n', '      require(newExoplanetId == uint256(uint32(newExoplanetId)));\n', '\n', '      Birth(newExoplanetId, name, numOfTokensBonusOnPurchase, owner);\n', '\n', '      currentPrice[newExoplanetId] = priceInEther;\n', '\n', '      \n', '      _transfer(address(0), owner, newExoplanetId);\n', '    }\n', '\n', '\n', '    \n', '    function owns(address claimant, uint256 tokenId) private view returns (bool) {\n', '      return claimant == currentOwner[tokenId];\n', '    }\n', '\n', '    function payout() public onlyCLevel {\n', '      ceoAddress.transfer(this.balance);\n', '    }\n', '\n', '    function payoutPartial(uint256 amount) public onlyCLevel {\n', '      require(amount <= this.balance);\n', '      ceoAddress.transfer(amount);\n', '    }\n', '\n', '    \n', '    function _transfer(address from, address to, uint256 tokenId) private {\n', '      \n', '      numOwnedTokens[to]++;\n', '\n', '      \n', '      currentOwner[tokenId] = to;\n', '\n', '      \n', '      if (from != address(0)) {\n', '        numOwnedTokens[from]--;\n', '      \n', '        delete approvedToTransfer[tokenId];\n', '      }\n', '\n', '     \n', '      Transfer(from, to, tokenId);\n', '    }\n', '\n', '    function appendNumToString(string baseUrl, uint256 tokenId) private pure returns (string) {\n', '      string memory _b = numToString(tokenId);\n', '      bytes memory bytes_a = bytes(baseUrl);\n', '      bytes memory bytes_b = bytes(_b);\n', '      string memory length_ab = new string(bytes_a.length + bytes_b.length);\n', '      bytes memory bytes_c = bytes(length_ab);\n', '      uint k = 0;\n', '      for (uint i = 0; i < bytes_a.length; i++) {\n', '        bytes_c[k++] = bytes_a[i];\n', '      }\n', '      for (i = 0; i < bytes_b.length; i++) {\n', '        bytes_c[k++] = bytes_b[i];\n', '      }\n', '      return string(bytes_c);\n', '    }\n', '\n', '    function numToString(uint256 tokenId) private pure returns (string str) {\n', '      uint uintVal = uint(tokenId);\n', '      bytes32 bytes32Val = uintToBytes32(uintVal);  \n', '      return bytes32ToString(bytes32Val);\n', '    }\n', '\n', '    function uintToBytes32(uint v) private pure returns (bytes32 ret) {\n', '      if (v == 0) {\n', '          ret = &#39;0&#39;;\n', '      }\n', '      else {\n', '          while (v > 0) {\n', '              ret = bytes32(uint(ret) / (2 ** 8));\n', '              ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));\n', '              v /= 10;\n', '          }\n', '      }\n', '      return ret;\n', '    }    \n', '\n', '    function bytes32ToString(bytes32 x) private pure returns (string) {\n', '      bytes memory bytesString = new bytes(32);\n', '      uint charCount = 0;\n', '      for (uint j = 0; j < 32; j++) {\n', '          byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '          if (char != 0) {\n', '              bytesString[charCount] = char;\n', '              charCount++;\n', '          }\n', '      }\n', '      bytes memory bytesStringTrimmed = new bytes(charCount);\n', '      for (j = 0; j < charCount; j++) {\n', '          bytesStringTrimmed[j] = bytesString[j];\n', '      }\n', '      return string(bytesStringTrimmed);\n', '    }    \n', '\n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a == 0) {\n', '        return 0;\n', '      }\n', '      uint256 c = a * b;\n', '      assert(c / a == b);\n', '      return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '      uint256 c = a / b;\n', '      // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '      return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 {\n', '  // Required:\n', '    function approve(address to, uint256 tokenId) public; \n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function implementsERC721() public pure returns (bool);\n', '    function ownerOf(uint256 tokenId) public view returns (address addr);\n', '    function takeOwnership(uint256 tokenId) public;\n', '    function totalSupply() public view returns (uint256 total);\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function transfer(address to, uint256 tokenId) public;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /** ERC721Metadata */ \n', '    function name() external view returns (string name);\n', '    function symbol() external view returns (string symbol);\n', '    function tokenURI(uint256 _tokenId) external view returns (string uri); \n', '  }\n', '\n', '\n', '\n', '/**\n', ' * @title ExoPlanets crypto game\n', ' * ExoPlanets is a space exploration crypto game with real data from NASA, that will allow the players to own ExoPlanets, \n', ' * evolve life and civilizations all the way to the “Space Age” and send exploration ships to other \n', ' * planets for resources and tokens mining.\n', ' * ExoPlanets is based on the ERC721 standard with several extensions (cryptoMatch, lifeRate..) to\n', ' * make the gaming experience more realistic (and exciting).\n', ' */\n', 'contract ExoplanetToken is ERC721 {\n', '\n', '    using SafeMath for uint256; \n', '    event Birth(uint256 indexed tokenId, string name, uint32 numOfTokensBonusOnPurchase, address owner);\n', '    event TokenSold(uint256 tokenId, uint256 oldPriceInEther, uint256 newPriceInEther, address prevOwner, address winner, string name);\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event ContractUpgrade(address newContract);\n', '\n', '    string public constant NAME = "ExoPlanets"; \n', '\n', '    string public constant SYMBOL = "XPL"; \n', '\n', '    string public constant BASE_URL = "https://exoplanets.io/metadata/planet_"; \n', '\n', '    uint32 private constant NUM_EXOPLANETS_LIMIT = 4700;  \n', '\n', '    uint256 private constant STEP_1 =  5.0 ether; \n', '    uint256 private constant STEP_2 = 10.0 ether;\n', '    uint256 private constant STEP_3 = 26.0 ether;\n', '    uint256 private constant STEP_4 = 36.0 ether;\n', '    uint256 private constant STEP_5 = 47.0 ether;\n', '    uint256 private constant STEP_6 = 59.0 ether;\n', '    uint256 private constant STEP_7 = 67.85 ether;\n', '    uint256 private constant STEP_8 = 76.67 ether;\n', '\n', '    mapping (uint256 => address) public currentOwner;\n', '    mapping (address => uint256) private numOwnedTokens;\n', '    mapping (uint256 => address) public approvedToTransfer;\n', '    mapping (uint256 => uint256) private currentPrice;\n', '    address public ceoAddress;\n', '    address public cooAddress;\n', '\n', '    bool public inPresaleMode = true;\n', '    bool public paused = false; \n', '    address public newContractAddress;\n', '\n', '    struct ExoplanetRec { \n', '        uint8 lifeRate; \n', '        uint32 priceInExoTokens; \n', '        uint32 numOfTokensBonusOnPurchase; \n', '        string name;\n', '        string cryptoMatch; \n', '        string techBonus1;\n', '        string techBonus2;\n', '        string techBonus3;\n', '        string scientificData;\n', '    }\n', '\n', '    ExoplanetRec[] private exoplanets;\n', '\n', '    modifier onlyCEO() {\n', '      require(msg.sender == ceoAddress);\n', '      _;  \n', '    }\n', '\n', '    modifier whenNotPaused() { \n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused() { \n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() public onlyCEO() whenNotPaused() {\n', '      paused = true;\n', '    }\n', '\n', '    function unpause() public onlyCEO() whenPaused() {\n', '      paused = false;\n', '    }\n', '\n', '   \n', '    function setNewAddress(address _v2Address) public onlyCEO() whenPaused() {\n', '      newContractAddress = _v2Address;\n', '      ContractUpgrade(_v2Address);\n', '    }\n', '\n', '\n', '    modifier onlyCOO() {\n', '      require(msg.sender == cooAddress);\n', '      _;\n', '    }\n', '\n', '    modifier presaleModeActive() {\n', '      require(inPresaleMode);\n', '      _;\n', '    }\n', '\n', '    \n', '    modifier afterPresaleMode() {\n', '      require(!inPresaleMode);\n', '      _;\n', '    }\n', '\n', '    \n', '\n', '    modifier onlyCLevel() {\n', '      require(\n', '        msg.sender == ceoAddress ||\n', '        msg.sender == cooAddress\n', '      );\n', '      _;\n', '    }\n', '\n', '    function setCEO(address newCEO) public onlyCEO {\n', '      require(newCEO != address(0));\n', '      ceoAddress = newCEO;\n', '    }\n', '\n', '    function setCOO(address newCOO) public onlyCEO {\n', '      require(newCOO != address(0));\n', '      cooAddress = newCOO;\n', '    }\n', '    \n', '    function setPresaleMode(bool newMode) public onlyCEO {\n', '      inPresaleMode = newMode;\n', '    }    \n', '\n', '    \n', '    function ExoplanetToken() public {\n', '        ceoAddress = msg.sender;\n', '        cooAddress = msg.sender;\n', '    }\n', '\n', '    function approve(address to, uint256 tokenId) public {\n', '    \n', '        require(owns(msg.sender, tokenId));\n', '\n', '        approvedToTransfer[tokenId] = to;\n', '\n', '        Approval(msg.sender, to, tokenId);\n', '    }\n', '\n', '    function balanceOf(address owner) public view returns (uint256 balance) {\n', '        balance = numOwnedTokens[owner];\n', '    }\n', '\n', '\n', '    function createContractExoplanet(\n', '          string name, uint256 priceInEther, uint32 priceInExoTokens, \n', '          string cryptoMatch, uint32 numOfTokensBonusOnPurchase, \n', '          uint8 lifeRate, string scientificData) public onlyCLevel { \n', '\n', '        _createExoplanet(name, address(this), priceInEther, priceInExoTokens, \n', '              cryptoMatch, numOfTokensBonusOnPurchase, lifeRate, scientificData);\n', '    }\n', '\n', '    \n', '    function getName(uint256 tokenId) public view returns (string) {\n', '      return exoplanets[tokenId].name;\n', '    }\n', '\n', '    function getPriceInExoTokens(uint256 tokenId) public view returns (uint32) {\n', '      return exoplanets[tokenId].priceInExoTokens;\n', '    }\n', '\n', '    function getLifeRate(uint256 tokenId) public view returns (uint8) {\n', '      return exoplanets[tokenId].lifeRate;\n', '    }\n', '\n', '    function getNumOfTokensBonusOnPurchase(uint256 tokenId) public view returns (uint32) {\n', '      return exoplanets[tokenId].numOfTokensBonusOnPurchase;\n', '    }\n', '\n', '    function getCryptoMatch(uint256 tokenId) public view returns (string) {\n', '      return exoplanets[tokenId].cryptoMatch;\n', '    }\n', '\n', '    function getTechBonus1(uint256 tokenId) public view returns (string) {\n', '      return exoplanets[tokenId].techBonus1;\n', '    }\n', '\n', '    function getTechBonus2(uint256 tokenId) public view returns (string) {\n', '      return exoplanets[tokenId].techBonus2;\n', '    }\n', '\n', '    function getTechBonus3(uint256 tokenId) public view returns (string) {\n', '      return exoplanets[tokenId].techBonus3;\n', '    }\n', '\n', '    function getScientificData(uint256 tokenId) public view returns (string) {\n', '      return exoplanets[tokenId].scientificData;\n', '    }\n', '\n', '  \n', '    function setTechBonus1(uint256 tokenId, string newVal) public {\n', '\n', '      require(owns(msg.sender, tokenId)); \n', '      exoplanets[tokenId].techBonus1 = newVal;\n', '    }\n', '\n', '    function setTechBonus2(uint256 tokenId, string newVal) public {\n', '      require(owns(msg.sender, tokenId)); \n', '      exoplanets[tokenId].techBonus2 = newVal;\n', '    }\n', '\n', '    function setTechBonus3(uint256 tokenId, string newVal) public {\n', '      require(owns(msg.sender, tokenId)); \n', '      exoplanets[tokenId].techBonus3 = newVal;\n', '    }\n', '\n', '    function setPriceInEth(uint256 tokenId, uint256 newPrice) public afterPresaleMode() {\n', '      require(owns(msg.sender, tokenId)); \n', '      currentPrice[tokenId] = newPrice;\n', '    }\n', '\n', '    function setPriceInExoTokens(uint256 tokenId, uint32 newPrice) public afterPresaleMode() {\n', '      require(owns(msg.sender, tokenId)); \n', '      exoplanets[tokenId].priceInExoTokens = newPrice;\n', '    }\n', '\n', '    function setScientificData(uint256 tokenId, string newData) public onlyCLevel { \n', '      exoplanets[tokenId].scientificData = newData;\n', '    }\n', '\n', '\n', '    function getExoplanet(uint256 tokenId) public view returns ( \n', '      string exoplanetName,\n', '      uint256 sellingPriceInEther,\n', '      address owner,\n', '      uint8 lifeRate,\n', '      uint32 priceInExoTokens,\n', '      uint32 numOfTokensBonusOnPurchase,\n', '      string cryptoMatch,\n', '      string scientificData) {\n', '\n', '\n', '      ExoplanetRec storage exoplanet = exoplanets[tokenId];       \n', '      exoplanetName = exoplanet.name;\n', '      lifeRate = exoplanet.lifeRate;\n', '      priceInExoTokens = exoplanet.priceInExoTokens;\n', '      numOfTokensBonusOnPurchase = exoplanet.numOfTokensBonusOnPurchase;\n', '      cryptoMatch = exoplanet.cryptoMatch;\n', '      scientificData = exoplanet.scientificData;\n', '      \n', '      sellingPriceInEther = currentPrice[tokenId];\n', '      owner = currentOwner[tokenId];\n', '    }  \n', '\n', '\n', '    function implementsERC721() public pure returns (bool) {\n', '      return true;\n', '    }\n', '\n', '    function ownerOf(uint256 tokenId) public view returns (address owner) {   \n', '      owner = currentOwner[tokenId];\n', '    }\n', '\n', '\n', '    function transferUnownedPlanet(address newOwner, uint256 tokenId) public onlyCLevel { \n', '      \n', '      require(currentOwner[tokenId] == address(this));\n', '\n', '      require(newOwner != address(0));\n', '\n', '      _transfer(currentOwner[tokenId], newOwner, tokenId);    \n', '\n', '      TokenSold(tokenId, currentPrice[tokenId], currentPrice[tokenId], address(this), newOwner, exoplanets[tokenId].name);\n', '    }\n', '\n', '\n', '    function purchase(uint256 tokenId) public payable whenNotPaused() presaleModeActive() {\n', '    \n', '      require(currentOwner[tokenId] != msg.sender);\n', '\n', '      require(addressNotNull(msg.sender));\n', '\n', '      uint256 planetPrice = currentPrice[tokenId]; \n', '\n', '      require(msg.value >= planetPrice);\n', '\n', '\n', '      uint256 purchaseExcess = msg.value.sub(planetPrice); \n', '\n', '      uint paymentPrcnt;\n', '      uint stepPrcnt;\n', '\n', '      if (planetPrice <= STEP_1) {        \n', '        paymentPrcnt = 93; \n', '        stepPrcnt = 200;\n', '      } else if (planetPrice <= STEP_2) {\n', '        paymentPrcnt = 93; \n', '        stepPrcnt = 150;\n', '      } else if (planetPrice <= STEP_3) {\n', '        paymentPrcnt = 93; \n', '        stepPrcnt = 135;\n', '      } else if (planetPrice <= STEP_4) {\n', '        paymentPrcnt = 94; \n', '        stepPrcnt = 125;\n', '      } else if (planetPrice <= STEP_5) {\n', '        paymentPrcnt = 94; \n', '        stepPrcnt = 119;\n', '      } else if (planetPrice <= STEP_6) {\n', '        paymentPrcnt = 95; \n', '        stepPrcnt = 117;    \n', '      } else if (planetPrice <= STEP_7) {\n', '        paymentPrcnt = 95; \n', '        stepPrcnt = 115;\n', '      } else if (planetPrice <= STEP_8) {\n', '        paymentPrcnt = 95; \n', '        stepPrcnt = 113;\n', '      } else {  \n', '        paymentPrcnt = 96; \n', '        stepPrcnt = 110;\n', '      }\n', '\n', '      currentPrice[tokenId] = planetPrice.mul(stepPrcnt).div(100);\n', '\n', '      uint256 payment = uint256(planetPrice.mul(paymentPrcnt).div(100));\n', '\n', '      address seller = currentOwner[tokenId];\n', '      \n', '      if (seller != address(this)) {  \n', '        seller.transfer(payment); \n', '      }\n', '\n', '      _transfer(seller, msg.sender, tokenId); \n', '\n', '      TokenSold(tokenId, planetPrice, currentPrice[tokenId], seller, msg.sender, exoplanets[tokenId].name);\n', '\n', '      msg.sender.transfer(purchaseExcess); \n', '    }\n', '\n', '\n', '    function priceOf(uint256 tokenId) public view returns (uint256) {\n', '      return currentPrice[tokenId];\n', '    }\n', '\n', '\n', '    function takeOwnership(uint256 tokenId) public whenNotPaused() { \n', '\n', '      require(addressNotNull(msg.sender));\n', '\n', '      require(approved(msg.sender, tokenId));\n', '\n', '      _transfer(currentOwner[tokenId], msg.sender, tokenId);\n', '    }\n', '\n', '    \n', '    function tokensOfOwner(address owner) public view returns(uint256[] ownerTokens) {\n', '      uint256 tokenCount = balanceOf(owner);\n', '      if (tokenCount == 0) {\n', '        return new uint256[](0);\n', '      } else {\n', '        uint256[] memory result = new uint256[](tokenCount);\n', '        uint256 totalExoplanets = totalSupply();\n', '        uint256 resultIndex = 0;\n', '\n', '        uint256 exoplanetId;\n', '        for (exoplanetId = 0; exoplanetId <= totalExoplanets; exoplanetId++) {\n', '          if (currentOwner[exoplanetId] == owner) {\n', '            result[resultIndex] = exoplanetId;\n', '            resultIndex++;\n', '          }\n', '        }\n', '        return result;\n', '      }\n', '    }\n', '\n', '    function name() external view returns (string name) {\n', '      name = NAME;\n', '    }\n', '\n', '\n', '    function symbol() external view returns (string symbol) {\n', '      symbol = SYMBOL;\n', '    }\n', '\n', '\n', '    function tokenURI(uint256 _tokenId) external view returns (string uri) {\n', '      uri = appendNumToString(BASE_URL, _tokenId);\n', '    }\n', '\n', '\n', '    function totalSupply() public view returns (uint256 total) { \n', '      total = exoplanets.length;\n', '    }\n', '\n', '    \n', '    function transfer(address to, uint256 tokenId) public whenNotPaused() {\n', '      require(owns(msg.sender, tokenId));\n', '      require(addressNotNull(to));\n', '      _transfer(msg.sender, to, tokenId);\n', '    }\n', '\n', '   \n', '    function transferFrom(address from, address to, uint256 tokenId) public whenNotPaused() {\n', '      require(approved(from, tokenId));\n', '      require(addressNotNull(to));\n', '      _transfer(from, to, tokenId);\n', '    }\n', '\n', '   \n', '    function addressNotNull(address addr) private pure returns (bool) {\n', '      return addr != address(0);\n', '    }\n', '\n', '   \n', '    function approved(address to, uint256 tokenId) private view returns (bool) {\n', '      return approvedToTransfer[tokenId] == to;\n', '    }\n', '\n', '    \n', '    function _createExoplanet(\n', '        string name, address owner, uint256 priceInEther, uint32 priceInExoTokens, \n', '        string cryptoMatch, uint32 numOfTokensBonusOnPurchase, uint8 lifeRate, \n', '        string scientificData) private {\n', '\n', '      \n', '      require(totalSupply() < NUM_EXOPLANETS_LIMIT);\n', '\n', '      ExoplanetRec memory _exoplanet = ExoplanetRec({  \n', '        name: name,\n', '        priceInExoTokens: priceInExoTokens,\n', '        cryptoMatch: cryptoMatch,\n', '        numOfTokensBonusOnPurchase: numOfTokensBonusOnPurchase,\n', '        lifeRate: lifeRate,\n', '        techBonus1: "",\n', '        techBonus2: "",\n', '        techBonus3: "",\n', '        scientificData: scientificData\n', '      });\n', '      uint256 newExoplanetId = exoplanets.push(_exoplanet) - 1;\n', '\n', '      \n', '      require(newExoplanetId == uint256(uint32(newExoplanetId)));\n', '\n', '      Birth(newExoplanetId, name, numOfTokensBonusOnPurchase, owner);\n', '\n', '      currentPrice[newExoplanetId] = priceInEther;\n', '\n', '      \n', '      _transfer(address(0), owner, newExoplanetId);\n', '    }\n', '\n', '\n', '    \n', '    function owns(address claimant, uint256 tokenId) private view returns (bool) {\n', '      return claimant == currentOwner[tokenId];\n', '    }\n', '\n', '    function payout() public onlyCLevel {\n', '      ceoAddress.transfer(this.balance);\n', '    }\n', '\n', '    function payoutPartial(uint256 amount) public onlyCLevel {\n', '      require(amount <= this.balance);\n', '      ceoAddress.transfer(amount);\n', '    }\n', '\n', '    \n', '    function _transfer(address from, address to, uint256 tokenId) private {\n', '      \n', '      numOwnedTokens[to]++;\n', '\n', '      \n', '      currentOwner[tokenId] = to;\n', '\n', '      \n', '      if (from != address(0)) {\n', '        numOwnedTokens[from]--;\n', '      \n', '        delete approvedToTransfer[tokenId];\n', '      }\n', '\n', '     \n', '      Transfer(from, to, tokenId);\n', '    }\n', '\n', '    function appendNumToString(string baseUrl, uint256 tokenId) private pure returns (string) {\n', '      string memory _b = numToString(tokenId);\n', '      bytes memory bytes_a = bytes(baseUrl);\n', '      bytes memory bytes_b = bytes(_b);\n', '      string memory length_ab = new string(bytes_a.length + bytes_b.length);\n', '      bytes memory bytes_c = bytes(length_ab);\n', '      uint k = 0;\n', '      for (uint i = 0; i < bytes_a.length; i++) {\n', '        bytes_c[k++] = bytes_a[i];\n', '      }\n', '      for (i = 0; i < bytes_b.length; i++) {\n', '        bytes_c[k++] = bytes_b[i];\n', '      }\n', '      return string(bytes_c);\n', '    }\n', '\n', '    function numToString(uint256 tokenId) private pure returns (string str) {\n', '      uint uintVal = uint(tokenId);\n', '      bytes32 bytes32Val = uintToBytes32(uintVal);  \n', '      return bytes32ToString(bytes32Val);\n', '    }\n', '\n', '    function uintToBytes32(uint v) private pure returns (bytes32 ret) {\n', '      if (v == 0) {\n', "          ret = '0';\n", '      }\n', '      else {\n', '          while (v > 0) {\n', '              ret = bytes32(uint(ret) / (2 ** 8));\n', '              ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));\n', '              v /= 10;\n', '          }\n', '      }\n', '      return ret;\n', '    }    \n', '\n', '    function bytes32ToString(bytes32 x) private pure returns (string) {\n', '      bytes memory bytesString = new bytes(32);\n', '      uint charCount = 0;\n', '      for (uint j = 0; j < 32; j++) {\n', '          byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '          if (char != 0) {\n', '              bytesString[charCount] = char;\n', '              charCount++;\n', '          }\n', '      }\n', '      bytes memory bytesStringTrimmed = new bytes(charCount);\n', '      for (j = 0; j < charCount; j++) {\n', '          bytesStringTrimmed[j] = bytesString[j];\n', '      }\n', '      return string(bytesStringTrimmed);\n', '    }    \n', '\n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a == 0) {\n', '        return 0;\n', '      }\n', '      uint256 c = a * b;\n', '      assert(c / a == b);\n', '      return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '      uint256 c = a / b;\n', "      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '      return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '    }\n', '}']
