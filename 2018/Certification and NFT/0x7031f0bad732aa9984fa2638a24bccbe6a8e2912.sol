['pragma solidity ^0.4.18;\n', '// File: contracts/TulipsSaleInterface.sol\n', '\n', '/** @title Crypto Tulips Initial Sale Interface\n', '* @dev This interface sets the standard for initial sale\n', '* contract. All future sale contracts should follow this.\n', '*/\n', 'interface TulipsSaleInterface {\n', '    function putOnInitialSale(uint256 tulipId) external;\n', '    function createAuction(\n', '        uint256 _tulipId,\n', '        uint256 _startingPrice,\n', '        uint256 _endingPrice,\n', '        uint256 _duration,\n', '        address _transferFrom\n', '    )external;\n', '}\n', '\n', '// File: contracts/ERC721.sol\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\n', 'contract ERC721 {\n', '    // Required methods\n', '    function totalSupply() public view returns (uint256 total);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) external view returns (address owner);\n', '    function approve(address _to, uint256 _tokenId) external;\n', '    function transfer(address _to, uint256 _tokenId) external;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '\n', '    // Events\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event Approval(address owner, address approved, uint256 tokenId);\n', '}\n', '\n', '// File: contracts/ERC721MetaData.sol\n', '\n', '/// @title The external contract that is responsible for generatingmetadata for the tulips,\n', '/// Taken from crypto kitties source. May change with our own implementation\n', 'contract ERC721Metadata {\n', '    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\n', '    function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {\n', '        if (_tokenId == 1) {\n', '            buffer[0] = "Hello World! :D";\n', '            count = 15;\n', '        } else if (_tokenId == 2) {\n', '            buffer[0] = "I would definitely choose a medi";\n', '            buffer[1] = "um length string.";\n', '            count = 49;\n', '        } else if (_tokenId == 3) {\n', '            buffer[0] = "Lorem ipsum dolor sit amet, mi e";\n', '            buffer[1] = "st accumsan dapibus augue lorem,";\n', '            buffer[2] = " tristique vestibulum id, libero";\n', '            buffer[3] = " suscipit varius sapien aliquam.";\n', '            count = 128;\n', '        }\n', '    }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '// File: contracts/TulipsRoles.sol\n', '\n', '/*\n', '* @title Crypto Tulips SaleAuction\n', '* @dev .\n', '*/\n', 'contract TulipsRoles is Pausable {\n', '\n', '    modifier onlyFinancial() {\n', '        require(msg.sender == address(financialAccount));\n', '        _;\n', '    }\n', '\n', '    modifier onlyOperations() {\n', '        require(msg.sender == address(operationsAccount));\n', '        _;\n', '    }\n', '\n', '    function TulipsRoles() Ownable() public {\n', '        financialAccount = msg.sender;\n', '        operationsAccount = msg.sender;\n', '    }\n', '\n', '    address public financialAccount;\n', '    address public operationsAccount;\n', '\n', '    function transferFinancial(address newFinancial) public onlyOwner {\n', '        require(newFinancial != address(0));\n', '        financialAccount = newFinancial;\n', '    }\n', '\n', '    function transferOperations(address newOperations) public onlyOwner {\n', '        require(newOperations != address(0));\n', '        operationsAccount = newOperations;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/TulipsStorage.sol\n', '\n', 'contract TulipsStorage is TulipsRoles {\n', '\n', '    //// DATA\n', '\n', '    /*\n', '    * Main tulip struct.\n', '    * Visual Info is the dna used to create the tulip image\n', '    * Visual Hash hash of the image file to confirm validity if needed.\n', '    */\n', '    struct Tulip {\n', '        uint256 visualInfo;\n', '        bytes32 visualHash;\n', '    }\n', '\n', '    //// STORAGE\n', '    /*\n', '    * @dev Array of all tulips created indexed with tulipID.\n', '    */\n', '    Tulip[] public tulips;\n', '\n', '    /*\n', "    * @dev Maps tulipId's to owner addreses\n", '    */\n', '    mapping (uint256 => address) public tulipIdToOwner;\n', '\n', '    /*\n', '    * @dev Maps owner adress to number of tulips owned.\n', "    * Bookkeeping for compliance with ERC20 and ERC721. Doesn't mean much in terms of\n", '    * value of individual unfungable assets.\n', '    */\n', '    mapping (address => uint256) tulipOwnershipCount;\n', '\n', '    /// @dev Maps tulipId to approved reciever of a pending token transfer.\n', '    mapping (uint256 => address) public tulipIdToApprovedTranserAddress;\n', '}\n', '\n', '// File: contracts/TulipsTokenInterface.sol\n', '\n', '/*\n', '* @title Crypto Tulips Token Interface\n', '* @dev This contract provides interface to ERC721 support.\n', '*/\n', 'contract TulipsTokenInterface is TulipsStorage, ERC721 {\n', '\n', '    //// TOKEN SPECS & META DATA\n', '\n', '    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '    string public constant name = "CryptoTulips";\n', '    string public constant symbol = "CT";\n', '\n', '    /*\n', '    * @dev This external contract will return Tulip metadata. We are making this changable in case\n', '    * we need to update our current uri scheme later on.\n', '    */\n', '    ERC721Metadata public erc721Metadata;\n', '\n', '    /// @dev Set the address of the external contract that generates the metadata.\n', '    function setMetadataAddress(address _contractAddress) public onlyOperations {\n', '        erc721Metadata = ERC721Metadata(_contractAddress);\n', '    }\n', '\n', '    //// EVENTS\n', '\n', '    /*\n', '    * @dev Transfer event as defined in ERC721.\n', '    */\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '\n', '    /*\n', '    * @dev Approval event as defined in ERC721.\n', '    */\n', '    event Approval(address owner, address approved, uint256 tokenId);\n', '\n', '    //// TRANSFER DATA\n', '\n', '    /*\n', '    * @dev Maps tulipId to approved transfer address\n', '    */\n', '    mapping (uint256 => address) public tulipIdToApproved;\n', '\n', '\n', '    //// PUBLIC FACING FUNCTIONS\n', '    /*\n', '    * @notice Returns total number of Tulips created so far.\n', '    */\n', '    function totalSupply() public view returns (uint) {\n', '        return tulips.length - 1;\n', '    }\n', '\n', '    /*\n', '    * @notice Returns the number of Tulips owned by given address.\n', '    * @param _owner The Tulip owner.\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256 count) {\n', '        return tulipOwnershipCount[_owner];\n', '    }\n', '\n', '    /*\n', '    * @notice Returns the owner of the given Tulip\n', '    */\n', '    function ownerOf(uint256 _tulipId)\n', '        external\n', '        view\n', '        returns (address owner)\n', '    {\n', '        owner = tulipIdToOwner[_tulipId];\n', '\n', '        // If owner adress is empty this is still a fresh Tulip waiting for its first owner.\n', '        require(owner != address(0));\n', '    }\n', '\n', '    /*\n', '    * @notice Unlocks the tulip for transfer. The reciever can calltransferFrom() to\n', '    * get ownership of the tulip. This is a safer method since you can revoke the transfer\n', '    * if you mistakenly send it to an invalid address.\n', '    * @param _to The reciever address. Set to address(0) to revoke the approval.\n', '    * @param _tulipId The tulip to be transfered\n', '    */\n', '    function approve(\n', '        address _to,\n', '        uint256 _tulipId\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        // Only an owner can grant transfer approval.\n', '        require(tulipIdToOwner[_tulipId] == msg.sender);\n', '\n', '        // Register the approval\n', '        _approve(_tulipId, _to);\n', '\n', '        // Emit approval event.\n', '        Approval(msg.sender, _to, _tulipId);\n', '    }\n', '\n', '    /*\n', '    * @notice Transfers a tulip to another address without confirmation.\n', "    * If the reciever's address is invalid tulip may be lost! Use approve() and transferFrom() instead.\n", '    * @param _to The reciever address.\n', '    * @param _tulipId The tulip to be transfered\n', '    */\n', '    function transfer(\n', '        address _to,\n', '        uint256 _tulipId\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        // Safety checks for common mistakes.\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '\n', '        // You can only send tulips you own.\n', '        require(tulipIdToOwner[_tulipId] == msg.sender);\n', '\n', '        // Do the transfer\n', '        _transfer(msg.sender, _to, _tulipId);\n', '    }\n', '\n', '    /*\n', '    * @notice This method allows the caller to recieve a tulip if the caller is the approved address\n', '    * caller can also give another address to recieve the tulip.\n', '    * @param _from Current owner of the tulip.\n', '    * @param _to New owner of the tulip\n', '    * @param _tulipId The tulip to be transfered\n', '    */\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tulipId\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        // Safety checks for common mistakes.\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '\n', '        // Check for approval and valid ownership\n', '        require(tulipIdToApproved[_tulipId] == msg.sender);\n', '        require(tulipIdToOwner[_tulipId] == _from);\n', '\n', '        // Do the transfer\n', '        _transfer(_from, _to, _tulipId);\n', '    }\n', '\n', '    /// @notice Returns metadata for the tulip.\n', '    /// @param _tulipId The tulip to recieve information on\n', '    function tokenMetadata(uint256 _tulipId, string _preferredTransport) external view returns (string infoUrl) {\n', '        // We will set the meta data scheme in an external contract\n', '        require(erc721Metadata != address(0));\n', '\n', '        // Contracts cannot return string to each other so we do this\n', '        bytes32[4] memory buffer;\n', '        uint256 count;\n', '        (buffer, count) = erc721Metadata.getMetadata(_tulipId, _preferredTransport);\n', '\n', '        return _toString(buffer, count);\n', '    }\n', '\n', '    //// INTERNAL FUNCTIONS THAT ACTUALLY DO STUFF\n', '    // These are called by public facing functions after sanity checks\n', '\n', '    function _transfer(address _from, address _to, uint256 _tulipId) internal {\n', '        // Increase total Tulips owned by _to address\n', '        tulipOwnershipCount[_to]++;\n', '\n', '        // Decrease total Tulips owned by _from address, if _from address is not empty\n', '        if (_from != address(0)) {\n', '            tulipOwnershipCount[_from]--;\n', '        }\n', '\n', '        // Update mapping of tulipID -> ownerAddress\n', '        tulipIdToOwner[_tulipId] = _to;\n', '\n', '        // Emit the transfer event.\n', '        Transfer(_from, _to, _tulipId);\n', '    }\n', '\n', '    function _approve(uint256 _tulipId, address _approved) internal{\n', '        tulipIdToApproved[_tulipId] = _approved;\n', '        // Approve event is only sent on public facing function\n', '    }\n', '\n', '    //// UTILITY FUNCTIONS\n', '\n', '    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\n', '    ///  This method is licenced under the Apache License.\n', '    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n', '    function _toString(bytes32[4] _rawBytes, uint256 _stringLength)private view returns (string) {\n', '        var outputString = new string(_stringLength);\n', '        uint256 outputPtr;\n', '        uint256 bytesPtr;\n', '\n', '        assembly {\n', '            outputPtr := add(outputString, 32)\n', '            bytesPtr := _rawBytes\n', '        }\n', '\n', '        _memcpy(outputPtr, bytesPtr, _stringLength);\n', '\n', '        return outputString;\n', '    }\n', '\n', '    function _memcpy(uint dest, uint src, uint len) private view {\n', '        // Copy word-length chunks while possible\n', '        for(; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/TulipsCreation.sol\n', '\n', '/*\n', '* @title Crypto Tulips Creation Mechanisms & Core Contract\n', '* @dev This contract provides methods in which we create new tulips.\n', '*/\n', 'contract TulipsCreation is TulipsTokenInterface {\n', '\n', '    //// STATS & LIMITS\n', '    uint256 public constant TOTAL_TULIP_SUPPLY = 100000;\n', '    uint256 public totalTulipCount;\n', '\n', '    //// Sale contract\n', '    TulipsSaleInterface public initialSaleContract;\n', '\n', '    //// EVENTS\n', '\n', '    /*\n', '    * @dev Announces creation of a new tulip.\n', '    */\n', '    event TulipCreation(uint256 tulipId, uint256 visualInfo);\n', '\n', '    /*\n', '    * We have this in case we have to change the initial sale contract\n', '    */\n', '    function setSaleAuction(address _initialSaleContractAddress) external onlyOwner {\n', '        initialSaleContract = TulipsSaleInterface(_initialSaleContractAddress);\n', '    }\n', '\n', '    function getSaleAuctionAddress() external view returns(address){\n', '        return address(initialSaleContract);\n', '    }\n', '\n', '    //// CREATION INTERFACE\n', '    /*\n', '    * @dev This function mints a new Tulip .\n', '    * @param _visualInfo Visual information used to generate tulip image.\n', '    * @param _visualHash Keccak hash of generated image.\n', '    */\n', '    function createTulip( uint256 _visualInfo, bytes32 _visualHash )  external onlyOperations\n', '        returns (uint)\n', '    {\n', '        require(totalTulipCount<TOTAL_TULIP_SUPPLY);\n', '\n', '        Tulip memory tulip = Tulip({\n', '            visualInfo: _visualInfo,\n', '            visualHash: _visualHash\n', '        });\n', '\n', '        uint256 tulipId = tulips.push(tulip) - 1;\n', '\n', '        // New created tulip is owned by initial sale auction at first\n', '        tulipIdToOwner[tulipId] = address(initialSaleContract);\n', '        initialSaleContract.putOnInitialSale(tulipId);\n', '\n', '        totalTulipCount++;\n', '\n', '        // Let the world know about this new tulip\n', '        TulipCreation(\n', '            tulipId, _visualInfo\n', '        );\n', '\n', '        return tulipId;\n', '    }\n', '\n', '    /*\n', '    * @dev This method authorizes for transfer and puts tulip on auction on a single call.\n', '    * This could be done in two seperate calls approve() and createAuction()\n', '    * but this way we can offer a single operation version that canbe triggered from web ui.\n', '    */\n', '    function putOnAuction(\n', '        uint256 _tulipId,\n', '        uint256 _startingPrice,\n', '        uint256 _endingPrice,\n', '        uint256 _duration\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '\n', '        require(tulipIdToOwner[_tulipId] == msg.sender);\n', '\n', '        tulipIdToApproved[_tulipId] = address(initialSaleContract);\n', '\n', '        initialSaleContract.createAuction(\n', '            _tulipId,\n', '            _startingPrice,\n', '            _endingPrice,\n', '            _duration,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '\n', '}']