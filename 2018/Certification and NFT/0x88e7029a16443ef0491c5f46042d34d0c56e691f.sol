['pragma solidity ^0.4.21;\n', '/*\n', ' * Abstract Token Smart Contract.  Copyright &#169; 2017 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="81ece8eae9e0e8edaff7ede0e5e8ece8f3eef7c1e6ece0e8edafe2eeec">[email&#160;protected]</a>>\n', ' */\n', '\n', '/**\n', ' * ERC-20 standard token interface, as defined\n', ' * <a href="http://github.com/ethereum/EIPs/issues/20">here</a>.\n', ' */\n', 'contract Token {\n', '  /**\n', '   * Get total number of tokens in circulation.\n', '   *\n', '   * @return total number of tokens in circulation\n', '   */\n', '  function totalSupply () public constant returns (uint256 supply);\n', '\n', '  /**\n', '   * Get number of tokens currently belonging to given owner.\n', '   *\n', '   * @param _owner address to get number of tokens currently belonging to the\n', '   *        owner of\n', '   * @return number of tokens currently belonging to the owner of given address\n', '   */\n', '  function balanceOf (address _owner) public constant returns (uint256 balance);\n', '\n', '  /**\n', '   * Transfer given number of tokens from message sender to given recipient.\n', '   *\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer to the owner of given address\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transfer (address _to, uint256 _value) public returns (bool success);\n', '\n', '  /**\n', '   * Transfer given number of tokens from given owner to given recipient.\n', '   *\n', '   * @param _from address to transfer tokens from the owner of\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer from given owner to given\n', '   *        recipient\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transferFrom (address _from, address _to, uint256 _value)\n', '  public returns (bool success);\n', '\n', '  /**\n', '   * Allow given spender to transfer given number of tokens from message sender.\n', '   *\n', '   * @param _spender address to allow the owner of to transfer tokens from\n', '   *        message sender\n', '   * @param _value number of tokens to allow to transfer\n', '   * @return true if token transfer was successfully approved, false otherwise\n', '   */\n', '  function approve (address _spender, uint256 _value) public returns (bool success);\n', '\n', '  /**\n', '   * Tell how many tokens given spender is currently allowed to transfer from\n', '   * given owner.\n', '   *\n', '   * @param _owner address to get number of tokens allowed to be transferred\n', '   *        from the owner of\n', '   * @param _spender address to get number of tokens allowed to be transferred\n', '   *        by the owner of\n', '   * @return number of tokens given spender is currently allowed to transfer\n', '   *         from given owner\n', '   */\n', '  function allowance (address _owner, address _spender) constant\n', '  public returns (uint256 remaining);\n', '\n', '  /**\n', '   * Logged when tokens were transferred from one owner to another.\n', '   *\n', '   * @param _from address of the owner, tokens were transferred from\n', '   * @param _to address of the owner, tokens were transferred to\n', '   * @param _value number of tokens transferred\n', '   */\n', '  event Transfer (address indexed _from, address indexed _to, uint256 _value);\n', '\n', '  /**\n', '   * Logged when owner approved his tokens to be transferred by some spender.\n', '   *\n', '   * @param _owner owner who approved his tokens to be transferred\n', '   * @param _spender spender who were allowed to transfer the tokens belonging\n', '   *        to the owner\n', '   * @param _value number of tokens belonging to the owner, approved to be\n', '   *        transferred by the spender\n', '   */\n', '  event Approval (\n', '    address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '/*\n', ' * Safe Math Smart Contract.  Copyright &#169; 2016â€“2017 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b9d4d0d2d1d8d0d597cfd5d8ddd0d4d0cbd6cff9ded4d8d0d597dad6d4">[email&#160;protected]</a>>\n', ' */\n', '\n', '/**\n', ' * Provides methods to safely add, subtract and multiply uint256 numbers.\n', ' */\n', 'contract SafeMath {\n', '  uint256 constant private MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '  /**\n', '   * Add two uint256 values, throw in case of overflow.\n', '   *\n', '   * @param x first value to add\n', '   * @param y second value to add\n', '   * @return x + y\n', '   */\n', '  function safeAdd (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    assert (x <= MAX_UINT256 - y);\n', '    return x + y;\n', '  }\n', '\n', '  /**\n', '   * Subtract one uint256 value from another, throw in case of underflow.\n', '   *\n', '   * @param x value to subtract from\n', '   * @param y value to subtract\n', '   * @return x - y\n', '   */\n', '  function safeSub (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    assert (x >= y);\n', '    return x - y;\n', '  }\n', '\n', '  /**\n', '   * Multiply two uint256 values, throw in case of overflow.\n', '   *\n', '   * @param x first value to multiply\n', '   * @param y second value to multiply\n', '   * @return x * y\n', '   */\n', '  function safeMul (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    if (y == 0) return 0; // Prevent division by zero at the next line\n', '    assert (x <= MAX_UINT256 / y);\n', '    return x * y;\n', '  }\n', '}\n', '/**\n', ' * Abstract Token Smart Contract that could be used as a base contract for\n', ' * ERC-20 token contracts.\n', ' */\n', '\n', 'contract AbstractToken is Token, SafeMath {\n', '  /**\n', '   * Create new Abstract Token contract.\n', '   */\n', '  function AbstractToken () public {\n', '    // Do nothing\n', '  }\n', '\n', '  /**\n', '   * Get number of tokens currently belonging to given owner.\n', '   *\n', '   * @param _owner address to get number of tokens currently belonging to the\n', '   *        owner of\n', '   * @return number of tokens currently belonging to the owner of given address\n', '   */\n', '  function balanceOf (address _owner) public constant returns (uint256 balance) {\n', '    return accounts [_owner];\n', '  }\n', '\n', '  /**\n', '   * Get number of tokens currently belonging to given owner and available for transfer.\n', '   *\n', '   * @param _owner address to get number of tokens currently belonging to the\n', '   *        owner of\n', '   * @return number of tokens currently belonging to the owner of given address\n', '   */\n', '  function transferrableBalanceOf (address _owner) public constant returns (uint256 balance) {\n', '    if (holds[_owner] > accounts[_owner]) {\n', '        return 0;\n', '    } else {\n', '        return safeSub(accounts[_owner], holds[_owner]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Transfer given number of tokens from message sender to given recipient.\n', '   *\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer to the owner of given address\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transfer (address _to, uint256 _value) public returns (bool success) {\n', '    require (transferrableBalanceOf(msg.sender) >= _value);\n', '    if (_value > 0 && msg.sender != _to) {\n', '      accounts [msg.sender] = safeSub (accounts [msg.sender], _value);\n', '      if (!hasAccount[_to]) {\n', '          hasAccount[_to] = true;\n', '          accountList.push(_to);\n', '      }\n', '      accounts [_to] = safeAdd (accounts [_to], _value);\n', '    }\n', '    emit Transfer (msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Transfer given number of tokens from given owner to given recipient.\n', '   *\n', '   * @param _from address to transfer tokens from the owner of\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer from given owner to given\n', '   *        recipient\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transferFrom (address _from, address _to, uint256 _value)\n', '  public returns (bool success) {\n', '    require (allowances [_from][msg.sender] >= _value);\n', '    require (transferrableBalanceOf(_from) >= _value);\n', '\n', '    allowances [_from][msg.sender] =\n', '      safeSub (allowances [_from][msg.sender], _value);\n', '\n', '    if (_value > 0 && _from != _to) {\n', '      accounts [_from] = safeSub (accounts [_from], _value);\n', '      if (!hasAccount[_to]) {\n', '          hasAccount[_to] = true;\n', '          accountList.push(_to);\n', '      }\n', '      accounts [_to] = safeAdd (accounts [_to], _value);\n', '    }\n', '    emit Transfer (_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Allow given spender to transfer given number of tokens from message sender.\n', '   *\n', '   * @param _spender address to allow the owner of to transfer tokens from\n', '   *        message sender\n', '   * @param _value number of tokens to allow to transfer\n', '   * @return true if token transfer was successfully approved, false otherwise\n', '   */\n', '  function approve (address _spender, uint256 _value) public returns (bool success) {\n', '    allowances [msg.sender][_spender] = _value;\n', '    emit Approval (msg.sender, _spender, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Tell how many tokens given spender is currently allowed to transfer from\n', '   * given owner.\n', '   *\n', '   * @param _owner address to get number of tokens allowed to be transferred\n', '   *        from the owner of\n', '   * @param _spender address to get number of tokens allowed to be transferred\n', '   *        by the owner of\n', '   * @return number of tokens given spender is currently allowed to transfer\n', '   *         from given owner\n', '   */\n', '  function allowance (address _owner, address _spender) public constant\n', '  returns (uint256 remaining) {\n', '    return allowances [_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * Mapping from addresses of token holders to the numbers of tokens belonging\n', '   * to these token holders.\n', '   */\n', '  mapping (address => uint256) accounts;\n', '\n', '  /**\n', '   * Mapping from address of token holders to a boolean to indicate if they have\n', '   * already been added to the system.\n', '   */\n', '  mapping (address => bool) internal hasAccount;\n', '  \n', '  /**\n', '   * List of available accounts.\n', '   */\n', '  address [] internal accountList;\n', '  \n', '  /**\n', '   * Mapping from addresses of token holders to the mapping of addresses of\n', '   * spenders to the allowances set by these token holders to these spenders.\n', '   */\n', '  mapping (address => mapping (address => uint256)) private allowances;\n', '\n', '  /**\n', '   * Mapping from addresses of token holds which cannot be spent until released.\n', '   */\n', '  mapping (address =>  uint256) internal holds;\n', '}\n', '/**\n', ' * Ponder token smart contract.\n', ' */\n', '\n', '\n', 'contract PonderAirdropToken is AbstractToken {\n', '  /**\n', '   * Address of the owner of this smart contract.\n', '   */\n', '  mapping (address => bool) private owners;\n', '\n', '  /**\n', '   * True if tokens transfers are currently frozen, false otherwise.\n', '   */\n', '  bool frozen = false;\n', '\n', '  /**\n', '   * Create new Ponder token smart contract, with given number of tokens issued\n', '   * and given to msg.sender, and make msg.sender the owner of this smart\n', '   * contract.\n', '   */\n', '  function PonderAirdropToken () public {\n', '    owners[msg.sender] = true;\n', '    accounts [msg.sender] = totalSupply();\n', '    hasAccount [msg.sender] = true;\n', '    accountList.push(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * Get total number of tokens in circulation.\n', '   *\n', '   * @return total number of tokens in circulation\n', '   */\n', '  function totalSupply () public constant returns (uint256 supply) {\n', '    return 480000000 * (uint256(10) ** decimals());\n', '  }\n', '\n', '  /**\n', '   * Get name of this token.\n', '   *\n', '   * @return name of this token\n', '   */\n', '  function name () public pure returns (string result) {\n', '    return "Ponder Airdrop Token";\n', '  }\n', '\n', '  /**\n', '   * Get symbol of this token.\n', '   *\n', '   * @return symbol of this token\n', '   */\n', '  function symbol () public pure returns (string result) {\n', '    return "PONA";\n', '  }\n', '\n', '  /**\n', '   * Get number of decimals for this token.\n', '   *\n', '   * @return number of decimals for this token\n', '   */\n', '  function decimals () public pure returns (uint8 result) {\n', '    return 18;\n', '  }\n', '\n', '  /**\n', '   * Transfer given number of tokens from message sender to given recipient.\n', '   *\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer to the owner of given address\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transfer (address _to, uint256 _value) public returns (bool success) {\n', '    if (frozen) return false;\n', '    else return AbstractToken.transfer (_to, _value);\n', '  }\n', '\n', '  /**\n', '   * Transfer given number of tokens from given owner to given recipient.\n', '   *\n', '   * @param _from address to transfer tokens from the owner of\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer from given owner to given\n', '   *        recipient\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transferFrom (address _from, address _to, uint256 _value)\n', '    public returns (bool success) {\n', '    if (frozen) return false;\n', '    else return AbstractToken.transferFrom (_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * Change how many tokens given spender is allowed to transfer from message\n', '   * spender.  In order to prevent double spending of allowance, this method\n', '   * receives assumed current allowance value as an argument.  If actual\n', '   * allowance differs from an assumed one, this method just returns false.\n', '   *\n', '   * @param _spender address to allow the owner of to transfer tokens from\n', '   *        message sender\n', '   * @param _currentValue assumed number of tokens currently allowed to be\n', '   *        transferred\n', '   * @param _newValue number of tokens to allow to transfer\n', '   * @return true if token transfer was successfully approved, false otherwise\n', '   */\n', '  function approve (address _spender, uint256 _currentValue, uint256 _newValue)\n', '    public returns (bool success) {\n', '    if (allowance (msg.sender, _spender) == _currentValue)\n', '      return approve (_spender, _newValue);\n', '    else return false;\n', '  }\n', '\n', '  /**\n', '   * Set new owner for the smart contract.\n', '   * May only be called by smart contract owner.\n', '   *\n', '   * @param _address of new or existing owner of the smart contract\n', '   * @param _value boolean stating if the _address should be an owner or not\n', '   */\n', '  function setOwner (address _address, bool _value) public {\n', '    require (owners[msg.sender]);\n', '    // if removing the _address from owners list, make sure owner is not \n', '    // removing himself (which could lead to an ownerless contract).\n', '    require (_value == true || _address != msg.sender);\n', '\n', '    owners[_address] = _value;\n', '  }\n', '\n', '  /**\n', '   * Initialize the token holders by contract owner\n', '   *\n', '   * @param _to addresses to allocate token for\n', '   * @param _value number of tokens to be allocated\n', '   */  \n', '  function initAccounts (address [] _to, uint256 [] _value) public {\n', '      require (owners[msg.sender]);\n', '      require (_to.length == _value.length);\n', '      for (uint256 i=0; i < _to.length; i++){\n', '          uint256 amountToAdd;\n', '          uint256 amountToSub;\n', '          if (_value[i] > accounts[_to[i]]){\n', '            amountToAdd = safeSub(_value[i], accounts[_to[i]]);\n', '          }else{\n', '            amountToSub = safeSub(accounts[_to[i]], _value[i]);\n', '          }\n', '          accounts [msg.sender] = safeAdd (accounts [msg.sender], amountToSub);\n', '          accounts [msg.sender] = safeSub (accounts [msg.sender], amountToAdd);\n', '          if (!hasAccount[_to[i]]) {\n', '              hasAccount[_to[i]] = true;\n', '              accountList.push(_to[i]);\n', '          }\n', '          accounts [_to[i]] = _value[i];\n', '          if (amountToAdd > 0){\n', '            emit Transfer (msg.sender, _to[i], amountToAdd);\n', '          }\n', '      }\n', '  }\n', '\n', '  /**\n', '   * Initialize the token holders and hold amounts by contract owner\n', '   *\n', '   * @param _to addresses to allocate token for\n', '   * @param _value number of tokens to be allocated\n', '   * @param _holds number of tokens to hold from transferring\n', '   */  \n', '  function initAccounts (address [] _to, uint256 [] _value, uint256 [] _holds) public {\n', '    setHolds(_to, _holds);\n', '    initAccounts(_to, _value);\n', '  }\n', '  \n', '  /**\n', '   * Set the number of tokens to hold from transferring for a list of \n', '   * token holders.\n', '   * \n', '   * @param _account list of account holders\n', '   * @param _value list of token amounts to hold\n', '   */\n', '  function setHolds (address [] _account, uint256 [] _value) public {\n', '    require (owners[msg.sender]);\n', '    require (_account.length == _value.length);\n', '    for (uint256 i=0; i < _account.length; i++){\n', '        holds[_account[i]] = _value[i];\n', '    }\n', '  }\n', '  \n', '  /**\n', '   * Get the number of account holders (for owner use)\n', '   *\n', '   * @return uint256\n', '   */  \n', '  function getNumAccounts () public constant returns (uint256 count) {\n', '    require (owners[msg.sender]);\n', '    return accountList.length;\n', '  }\n', '  \n', '  /**\n', '   * Get a list of account holder eth addresses (for owner use)\n', '   *\n', '   * @param _start index of the account holder list\n', '   * @param _count of items to return\n', '   * @return array of addresses\n', '   */  \n', '  function getAccounts (uint256 _start, uint256 _count) public constant returns (address [] addresses){\n', '    require (owners[msg.sender]);\n', '    require (_start >= 0 && _count >= 1);\n', '    if (_start == 0 && _count >= accountList.length) {\n', '      return accountList;\n', '    }\n', '    address [] memory _slice = new address[](_count);\n', '    for (uint256 i=0; i < _count; i++){\n', '      _slice[i] = accountList[i + _start];\n', '    }\n', '    return _slice;\n', '  }\n', '  \n', '  /**\n', '   * Freeze token transfers.\n', '   * May only be called by smart contract owner.\n', '   */\n', '  function freezeTransfers () public {\n', '    require (owners[msg.sender]);\n', '\n', '    if (!frozen) {\n', '      frozen = true;\n', '      emit Freeze ();\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Unfreeze token transfers.\n', '   * May only be called by smart contract owner.\n', '   */\n', '  function unfreezeTransfers () public {\n', '    require (owners[msg.sender]);\n', '\n', '    if (frozen) {\n', '      frozen = false;\n', '      emit Unfreeze ();\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Logged when token transfers were frozen.\n', '   */\n', '  event Freeze ();\n', '\n', '  /**\n', '   * Logged when token transfers were unfrozen.\n', '   */\n', '  event Unfreeze ();\n', '\n', '  /**\n', '   * Kill the token.\n', '   */\n', '  function kill() public { \n', '    if (owners[msg.sender]) selfdestruct(msg.sender);\n', '  }\n', '}']
['pragma solidity ^0.4.21;\n', '/*\n', ' * Abstract Token Smart Contract.  Copyright Â© 2017 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n', ' */\n', '\n', '/**\n', ' * ERC-20 standard token interface, as defined\n', ' * <a href="http://github.com/ethereum/EIPs/issues/20">here</a>.\n', ' */\n', 'contract Token {\n', '  /**\n', '   * Get total number of tokens in circulation.\n', '   *\n', '   * @return total number of tokens in circulation\n', '   */\n', '  function totalSupply () public constant returns (uint256 supply);\n', '\n', '  /**\n', '   * Get number of tokens currently belonging to given owner.\n', '   *\n', '   * @param _owner address to get number of tokens currently belonging to the\n', '   *        owner of\n', '   * @return number of tokens currently belonging to the owner of given address\n', '   */\n', '  function balanceOf (address _owner) public constant returns (uint256 balance);\n', '\n', '  /**\n', '   * Transfer given number of tokens from message sender to given recipient.\n', '   *\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer to the owner of given address\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transfer (address _to, uint256 _value) public returns (bool success);\n', '\n', '  /**\n', '   * Transfer given number of tokens from given owner to given recipient.\n', '   *\n', '   * @param _from address to transfer tokens from the owner of\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer from given owner to given\n', '   *        recipient\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transferFrom (address _from, address _to, uint256 _value)\n', '  public returns (bool success);\n', '\n', '  /**\n', '   * Allow given spender to transfer given number of tokens from message sender.\n', '   *\n', '   * @param _spender address to allow the owner of to transfer tokens from\n', '   *        message sender\n', '   * @param _value number of tokens to allow to transfer\n', '   * @return true if token transfer was successfully approved, false otherwise\n', '   */\n', '  function approve (address _spender, uint256 _value) public returns (bool success);\n', '\n', '  /**\n', '   * Tell how many tokens given spender is currently allowed to transfer from\n', '   * given owner.\n', '   *\n', '   * @param _owner address to get number of tokens allowed to be transferred\n', '   *        from the owner of\n', '   * @param _spender address to get number of tokens allowed to be transferred\n', '   *        by the owner of\n', '   * @return number of tokens given spender is currently allowed to transfer\n', '   *         from given owner\n', '   */\n', '  function allowance (address _owner, address _spender) constant\n', '  public returns (uint256 remaining);\n', '\n', '  /**\n', '   * Logged when tokens were transferred from one owner to another.\n', '   *\n', '   * @param _from address of the owner, tokens were transferred from\n', '   * @param _to address of the owner, tokens were transferred to\n', '   * @param _value number of tokens transferred\n', '   */\n', '  event Transfer (address indexed _from, address indexed _to, uint256 _value);\n', '\n', '  /**\n', '   * Logged when owner approved his tokens to be transferred by some spender.\n', '   *\n', '   * @param _owner owner who approved his tokens to be transferred\n', '   * @param _spender spender who were allowed to transfer the tokens belonging\n', '   *        to the owner\n', '   * @param _value number of tokens belonging to the owner, approved to be\n', '   *        transferred by the spender\n', '   */\n', '  event Approval (\n', '    address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '/*\n', ' * Safe Math Smart Contract.  Copyright Â© 2016â€“2017 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n', ' */\n', '\n', '/**\n', ' * Provides methods to safely add, subtract and multiply uint256 numbers.\n', ' */\n', 'contract SafeMath {\n', '  uint256 constant private MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '  /**\n', '   * Add two uint256 values, throw in case of overflow.\n', '   *\n', '   * @param x first value to add\n', '   * @param y second value to add\n', '   * @return x + y\n', '   */\n', '  function safeAdd (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    assert (x <= MAX_UINT256 - y);\n', '    return x + y;\n', '  }\n', '\n', '  /**\n', '   * Subtract one uint256 value from another, throw in case of underflow.\n', '   *\n', '   * @param x value to subtract from\n', '   * @param y value to subtract\n', '   * @return x - y\n', '   */\n', '  function safeSub (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    assert (x >= y);\n', '    return x - y;\n', '  }\n', '\n', '  /**\n', '   * Multiply two uint256 values, throw in case of overflow.\n', '   *\n', '   * @param x first value to multiply\n', '   * @param y second value to multiply\n', '   * @return x * y\n', '   */\n', '  function safeMul (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    if (y == 0) return 0; // Prevent division by zero at the next line\n', '    assert (x <= MAX_UINT256 / y);\n', '    return x * y;\n', '  }\n', '}\n', '/**\n', ' * Abstract Token Smart Contract that could be used as a base contract for\n', ' * ERC-20 token contracts.\n', ' */\n', '\n', 'contract AbstractToken is Token, SafeMath {\n', '  /**\n', '   * Create new Abstract Token contract.\n', '   */\n', '  function AbstractToken () public {\n', '    // Do nothing\n', '  }\n', '\n', '  /**\n', '   * Get number of tokens currently belonging to given owner.\n', '   *\n', '   * @param _owner address to get number of tokens currently belonging to the\n', '   *        owner of\n', '   * @return number of tokens currently belonging to the owner of given address\n', '   */\n', '  function balanceOf (address _owner) public constant returns (uint256 balance) {\n', '    return accounts [_owner];\n', '  }\n', '\n', '  /**\n', '   * Get number of tokens currently belonging to given owner and available for transfer.\n', '   *\n', '   * @param _owner address to get number of tokens currently belonging to the\n', '   *        owner of\n', '   * @return number of tokens currently belonging to the owner of given address\n', '   */\n', '  function transferrableBalanceOf (address _owner) public constant returns (uint256 balance) {\n', '    if (holds[_owner] > accounts[_owner]) {\n', '        return 0;\n', '    } else {\n', '        return safeSub(accounts[_owner], holds[_owner]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Transfer given number of tokens from message sender to given recipient.\n', '   *\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer to the owner of given address\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transfer (address _to, uint256 _value) public returns (bool success) {\n', '    require (transferrableBalanceOf(msg.sender) >= _value);\n', '    if (_value > 0 && msg.sender != _to) {\n', '      accounts [msg.sender] = safeSub (accounts [msg.sender], _value);\n', '      if (!hasAccount[_to]) {\n', '          hasAccount[_to] = true;\n', '          accountList.push(_to);\n', '      }\n', '      accounts [_to] = safeAdd (accounts [_to], _value);\n', '    }\n', '    emit Transfer (msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Transfer given number of tokens from given owner to given recipient.\n', '   *\n', '   * @param _from address to transfer tokens from the owner of\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer from given owner to given\n', '   *        recipient\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transferFrom (address _from, address _to, uint256 _value)\n', '  public returns (bool success) {\n', '    require (allowances [_from][msg.sender] >= _value);\n', '    require (transferrableBalanceOf(_from) >= _value);\n', '\n', '    allowances [_from][msg.sender] =\n', '      safeSub (allowances [_from][msg.sender], _value);\n', '\n', '    if (_value > 0 && _from != _to) {\n', '      accounts [_from] = safeSub (accounts [_from], _value);\n', '      if (!hasAccount[_to]) {\n', '          hasAccount[_to] = true;\n', '          accountList.push(_to);\n', '      }\n', '      accounts [_to] = safeAdd (accounts [_to], _value);\n', '    }\n', '    emit Transfer (_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Allow given spender to transfer given number of tokens from message sender.\n', '   *\n', '   * @param _spender address to allow the owner of to transfer tokens from\n', '   *        message sender\n', '   * @param _value number of tokens to allow to transfer\n', '   * @return true if token transfer was successfully approved, false otherwise\n', '   */\n', '  function approve (address _spender, uint256 _value) public returns (bool success) {\n', '    allowances [msg.sender][_spender] = _value;\n', '    emit Approval (msg.sender, _spender, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Tell how many tokens given spender is currently allowed to transfer from\n', '   * given owner.\n', '   *\n', '   * @param _owner address to get number of tokens allowed to be transferred\n', '   *        from the owner of\n', '   * @param _spender address to get number of tokens allowed to be transferred\n', '   *        by the owner of\n', '   * @return number of tokens given spender is currently allowed to transfer\n', '   *         from given owner\n', '   */\n', '  function allowance (address _owner, address _spender) public constant\n', '  returns (uint256 remaining) {\n', '    return allowances [_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * Mapping from addresses of token holders to the numbers of tokens belonging\n', '   * to these token holders.\n', '   */\n', '  mapping (address => uint256) accounts;\n', '\n', '  /**\n', '   * Mapping from address of token holders to a boolean to indicate if they have\n', '   * already been added to the system.\n', '   */\n', '  mapping (address => bool) internal hasAccount;\n', '  \n', '  /**\n', '   * List of available accounts.\n', '   */\n', '  address [] internal accountList;\n', '  \n', '  /**\n', '   * Mapping from addresses of token holders to the mapping of addresses of\n', '   * spenders to the allowances set by these token holders to these spenders.\n', '   */\n', '  mapping (address => mapping (address => uint256)) private allowances;\n', '\n', '  /**\n', '   * Mapping from addresses of token holds which cannot be spent until released.\n', '   */\n', '  mapping (address =>  uint256) internal holds;\n', '}\n', '/**\n', ' * Ponder token smart contract.\n', ' */\n', '\n', '\n', 'contract PonderAirdropToken is AbstractToken {\n', '  /**\n', '   * Address of the owner of this smart contract.\n', '   */\n', '  mapping (address => bool) private owners;\n', '\n', '  /**\n', '   * True if tokens transfers are currently frozen, false otherwise.\n', '   */\n', '  bool frozen = false;\n', '\n', '  /**\n', '   * Create new Ponder token smart contract, with given number of tokens issued\n', '   * and given to msg.sender, and make msg.sender the owner of this smart\n', '   * contract.\n', '   */\n', '  function PonderAirdropToken () public {\n', '    owners[msg.sender] = true;\n', '    accounts [msg.sender] = totalSupply();\n', '    hasAccount [msg.sender] = true;\n', '    accountList.push(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * Get total number of tokens in circulation.\n', '   *\n', '   * @return total number of tokens in circulation\n', '   */\n', '  function totalSupply () public constant returns (uint256 supply) {\n', '    return 480000000 * (uint256(10) ** decimals());\n', '  }\n', '\n', '  /**\n', '   * Get name of this token.\n', '   *\n', '   * @return name of this token\n', '   */\n', '  function name () public pure returns (string result) {\n', '    return "Ponder Airdrop Token";\n', '  }\n', '\n', '  /**\n', '   * Get symbol of this token.\n', '   *\n', '   * @return symbol of this token\n', '   */\n', '  function symbol () public pure returns (string result) {\n', '    return "PONA";\n', '  }\n', '\n', '  /**\n', '   * Get number of decimals for this token.\n', '   *\n', '   * @return number of decimals for this token\n', '   */\n', '  function decimals () public pure returns (uint8 result) {\n', '    return 18;\n', '  }\n', '\n', '  /**\n', '   * Transfer given number of tokens from message sender to given recipient.\n', '   *\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer to the owner of given address\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transfer (address _to, uint256 _value) public returns (bool success) {\n', '    if (frozen) return false;\n', '    else return AbstractToken.transfer (_to, _value);\n', '  }\n', '\n', '  /**\n', '   * Transfer given number of tokens from given owner to given recipient.\n', '   *\n', '   * @param _from address to transfer tokens from the owner of\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer from given owner to given\n', '   *        recipient\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transferFrom (address _from, address _to, uint256 _value)\n', '    public returns (bool success) {\n', '    if (frozen) return false;\n', '    else return AbstractToken.transferFrom (_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * Change how many tokens given spender is allowed to transfer from message\n', '   * spender.  In order to prevent double spending of allowance, this method\n', '   * receives assumed current allowance value as an argument.  If actual\n', '   * allowance differs from an assumed one, this method just returns false.\n', '   *\n', '   * @param _spender address to allow the owner of to transfer tokens from\n', '   *        message sender\n', '   * @param _currentValue assumed number of tokens currently allowed to be\n', '   *        transferred\n', '   * @param _newValue number of tokens to allow to transfer\n', '   * @return true if token transfer was successfully approved, false otherwise\n', '   */\n', '  function approve (address _spender, uint256 _currentValue, uint256 _newValue)\n', '    public returns (bool success) {\n', '    if (allowance (msg.sender, _spender) == _currentValue)\n', '      return approve (_spender, _newValue);\n', '    else return false;\n', '  }\n', '\n', '  /**\n', '   * Set new owner for the smart contract.\n', '   * May only be called by smart contract owner.\n', '   *\n', '   * @param _address of new or existing owner of the smart contract\n', '   * @param _value boolean stating if the _address should be an owner or not\n', '   */\n', '  function setOwner (address _address, bool _value) public {\n', '    require (owners[msg.sender]);\n', '    // if removing the _address from owners list, make sure owner is not \n', '    // removing himself (which could lead to an ownerless contract).\n', '    require (_value == true || _address != msg.sender);\n', '\n', '    owners[_address] = _value;\n', '  }\n', '\n', '  /**\n', '   * Initialize the token holders by contract owner\n', '   *\n', '   * @param _to addresses to allocate token for\n', '   * @param _value number of tokens to be allocated\n', '   */  \n', '  function initAccounts (address [] _to, uint256 [] _value) public {\n', '      require (owners[msg.sender]);\n', '      require (_to.length == _value.length);\n', '      for (uint256 i=0; i < _to.length; i++){\n', '          uint256 amountToAdd;\n', '          uint256 amountToSub;\n', '          if (_value[i] > accounts[_to[i]]){\n', '            amountToAdd = safeSub(_value[i], accounts[_to[i]]);\n', '          }else{\n', '            amountToSub = safeSub(accounts[_to[i]], _value[i]);\n', '          }\n', '          accounts [msg.sender] = safeAdd (accounts [msg.sender], amountToSub);\n', '          accounts [msg.sender] = safeSub (accounts [msg.sender], amountToAdd);\n', '          if (!hasAccount[_to[i]]) {\n', '              hasAccount[_to[i]] = true;\n', '              accountList.push(_to[i]);\n', '          }\n', '          accounts [_to[i]] = _value[i];\n', '          if (amountToAdd > 0){\n', '            emit Transfer (msg.sender, _to[i], amountToAdd);\n', '          }\n', '      }\n', '  }\n', '\n', '  /**\n', '   * Initialize the token holders and hold amounts by contract owner\n', '   *\n', '   * @param _to addresses to allocate token for\n', '   * @param _value number of tokens to be allocated\n', '   * @param _holds number of tokens to hold from transferring\n', '   */  \n', '  function initAccounts (address [] _to, uint256 [] _value, uint256 [] _holds) public {\n', '    setHolds(_to, _holds);\n', '    initAccounts(_to, _value);\n', '  }\n', '  \n', '  /**\n', '   * Set the number of tokens to hold from transferring for a list of \n', '   * token holders.\n', '   * \n', '   * @param _account list of account holders\n', '   * @param _value list of token amounts to hold\n', '   */\n', '  function setHolds (address [] _account, uint256 [] _value) public {\n', '    require (owners[msg.sender]);\n', '    require (_account.length == _value.length);\n', '    for (uint256 i=0; i < _account.length; i++){\n', '        holds[_account[i]] = _value[i];\n', '    }\n', '  }\n', '  \n', '  /**\n', '   * Get the number of account holders (for owner use)\n', '   *\n', '   * @return uint256\n', '   */  \n', '  function getNumAccounts () public constant returns (uint256 count) {\n', '    require (owners[msg.sender]);\n', '    return accountList.length;\n', '  }\n', '  \n', '  /**\n', '   * Get a list of account holder eth addresses (for owner use)\n', '   *\n', '   * @param _start index of the account holder list\n', '   * @param _count of items to return\n', '   * @return array of addresses\n', '   */  \n', '  function getAccounts (uint256 _start, uint256 _count) public constant returns (address [] addresses){\n', '    require (owners[msg.sender]);\n', '    require (_start >= 0 && _count >= 1);\n', '    if (_start == 0 && _count >= accountList.length) {\n', '      return accountList;\n', '    }\n', '    address [] memory _slice = new address[](_count);\n', '    for (uint256 i=0; i < _count; i++){\n', '      _slice[i] = accountList[i + _start];\n', '    }\n', '    return _slice;\n', '  }\n', '  \n', '  /**\n', '   * Freeze token transfers.\n', '   * May only be called by smart contract owner.\n', '   */\n', '  function freezeTransfers () public {\n', '    require (owners[msg.sender]);\n', '\n', '    if (!frozen) {\n', '      frozen = true;\n', '      emit Freeze ();\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Unfreeze token transfers.\n', '   * May only be called by smart contract owner.\n', '   */\n', '  function unfreezeTransfers () public {\n', '    require (owners[msg.sender]);\n', '\n', '    if (frozen) {\n', '      frozen = false;\n', '      emit Unfreeze ();\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Logged when token transfers were frozen.\n', '   */\n', '  event Freeze ();\n', '\n', '  /**\n', '   * Logged when token transfers were unfrozen.\n', '   */\n', '  event Unfreeze ();\n', '\n', '  /**\n', '   * Kill the token.\n', '   */\n', '  function kill() public { \n', '    if (owners[msg.sender]) selfdestruct(msg.sender);\n', '  }\n', '}']
