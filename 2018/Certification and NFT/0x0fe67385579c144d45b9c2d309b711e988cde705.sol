['pragma solidity ^ 0.4.19;\n', '\n', '// DopeRaider Districts Contract\n', '// by gasmasters.io\n', '// contact: team@doperaider.com\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', 'contract ERC721 {\n', '  function implementsERC721() public pure returns(bool);\n', '  function totalSupply() public view returns(uint256 total);\n', '  function balanceOf(address _owner) public view returns(uint256 balance);\n', '  function ownerOf(uint256 _tokenId) public view returns(address owner);\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function transfer(address _to, uint256 _tokenId) public;\n', '  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '  // Optional\n', '  // function name() public view returns (string name);\n', '  // function symbol() public view returns (string symbol);\n', '  // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n', '  // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n', '}\n', '\n', '// File: contracts/NarcoCoreInterface.sol\n', '\n', 'contract NarcosCoreInterface is ERC721 {\n', '  function getNarco(uint256 _id)\n', '  public\n', '  view\n', '  returns(\n', '    string  narcoName,\n', '    uint256 weedTotal,\n', '    uint256 cokeTotal,\n', '    uint16[6] skills,\n', '    uint8[4] consumables,\n', '    string genes,\n', '    uint8 homeLocation,\n', '    uint16 level,\n', '    uint256[6] cooldowns,\n', '    uint256 id,\n', '    uint16[9] stats\n', '  );\n', '\n', '  function updateWeedTotal(uint256 _narcoId, bool _add, uint16 _total) public;\n', '  function updateCokeTotal(uint256 _narcoId, bool _add,  uint16 _total) public;\n', '  function updateConsumable(uint256 _narcoId, uint256 _index, uint8 _new) public;\n', '  function updateSkill(uint256 _narcoId, uint256 _index, uint16 _new) public;\n', '  function incrementStat(uint256 _narcoId, uint256 _index) public;\n', '  function setCooldown(uint256 _narcoId , uint256 _index , uint256 _new) public;\n', '  function getRemainingCapacity(uint256 _id) public view returns (uint8 capacity);\n', '}\n', '\n', '\n', '// File: contracts/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = true;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '\n', '// File: contracts/Districts/DistrictsAdmin.sol\n', '\n', 'contract DistrictsAdmin is Ownable, Pausable {\n', '  event ContractUpgrade(address newContract);\n', '\n', '  address public newContractAddress;\n', '  address public coreAddress;\n', '\n', '  NarcosCoreInterface public narcoCore;\n', '\n', '  function setNarcosCoreAddress(address _address) public onlyOwner {\n', '    _setNarcosCoreAddress(_address);\n', '  }\n', '\n', '  function _setNarcosCoreAddress(address _address) internal {\n', '    NarcosCoreInterface candidateContract = NarcosCoreInterface(_address);\n', '    require(candidateContract.implementsERC721());\n', '    coreAddress = _address;\n', '    narcoCore = candidateContract;\n', '  }\n', '\n', '  /// @dev Used to mark the smart contract as upgraded, in case there is a serious\n', '  ///  breaking bug. This method does nothing but keep track of the new contract and\n', '  ///  emit a message indicating that the new address is set. It&#39;s up to clients of this\n', '  ///  contract to update to the new contract address in that case.\n', '  /// @param _v2Address new address\n', '  function setNewAddress(address _v2Address) public onlyOwner whenPaused {\n', '    newContractAddress = _v2Address;\n', '\n', '    ContractUpgrade(_v2Address);\n', '  }\n', '\n', '  modifier onlyDopeRaiderContract() {\n', '    require(msg.sender == coreAddress);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '// File: contracts/DistrictsCore.sol\n', '\n', 'contract DistrictsCore is DistrictsAdmin {\n', '\n', '  // DISTRICT EVENTS\n', '  event NarcoArrived(uint8 indexed location, uint256 indexed narcoId); // who just arrived here\n', '  event NarcoLeft(uint8 indexed location, uint256 indexed narcoId); // who just left here\n', '  event TravelBust(uint256 indexed narcoId, uint16 confiscatedWeed, uint16 confiscatedCoke);\n', '  event Hijacked(uint256 indexed hijacker, uint256 indexed victim , uint16 stolenWeed , uint16 stolenCoke);\n', '  event HijackDefended(uint256 indexed hijacker, uint256 indexed victim);\n', '  event EscapedHijack(uint256 indexed hijacker, uint256 indexed victim , uint8 escapeLocation);\n', '\n', '  uint256 public airLiftPrice = 0.01 ether; // home dorothy price\n', '  uint256 public hijackPrice = 0.002 ether; // universal hijackPrice\n', '  uint256 public travelPrice = 0.001 ether; // universal travelPrice\n', '  uint256 public spreadPercent = 5; // universal spread between buy and sell\n', '  uint256 public devFeePercent = 2; // on various actions\n', '  uint256 public currentDevFees = 0;\n', '  uint256 public bustRange = 10;\n', '\n', '  function setAirLiftPrice(uint256 _price) public onlyOwner{\n', '    airLiftPrice = _price;\n', '  }\n', '\n', '  function setBustRange(uint256 _range) public onlyOwner{\n', '    bustRange = _range;\n', '  }\n', '\n', '  function setHijackPrice(uint256 _price) public onlyOwner{\n', '    hijackPrice = _price;\n', '  }\n', '\n', '  function setTravelPrice(uint256 _price) public onlyOwner{\n', '    travelPrice = _price;\n', '  }\n', '\n', '  function setSpreadPercent(uint256 _spread) public onlyOwner{\n', '    spreadPercent = _spread;\n', '  }\n', '\n', '  function setDevFeePercent(uint256 _fee) public onlyOwner{\n', '    devFeePercent = _fee;\n', '  }\n', '\n', '  function isDopeRaiderDistrictsCore() public pure returns(bool){ return true; }\n', '\n', '\n', '  // Market Items\n', '\n', '  struct MarketItem{\n', '    uint256 id;\n', '    string itemName;\n', '    uint8 skillAffected;\n', '    uint8 upgradeAmount;\n', '    uint8 levelRequired; // the level a narco must have before they\n', '  }\n', '\n', '  // there is a fixed amount of items - they are not tokens bc iterations will be needed.\n', '  // 0,1 = weed , coke , 2 - 4 consumables , 5-23 items\n', '  MarketItem[24] public marketItems;\n', '\n', '  function configureMarketItem(uint256 _id, uint8 _skillAffected, uint8  _upgradeAmount, uint8 _levelRequired, string _itemName) public onlyOwner{\n', '    marketItems[_id].skillAffected = _skillAffected;\n', '    marketItems[_id].upgradeAmount = _upgradeAmount;\n', '    marketItems[_id].levelRequired = _levelRequired;\n', '    marketItems[_id].itemName = _itemName;\n', '    marketItems[_id].id = _id;\n', '  }\n', '\n', '\n', '  struct District {\n', '    uint256[6] exits;\n', '    uint256 weedPot;\n', '    uint256 weedAmountHere;\n', '    uint256 cokePot;\n', '    uint256 cokeAmountHere;\n', '    uint256[24] marketPrices;\n', '    bool[24] isStocked;\n', '    bool hasMarket;\n', '    string name;\n', '  }\n', '\n', '  District[8] public districts; // there is no &#39;0&#39; district - this will be used to indicate no exit\n', '\n', '  // for keeping track of who is where\n', '  mapping(uint256 => uint8) narcoIndexToLocation;\n', '\n', '  function DistrictsCore() public {\n', '  }\n', '\n', '  function getDistrict(uint256 _id) public view returns(uint256[6] exits, bool hasMarket, uint256[24] prices, bool[24] isStocked, uint256 weedPot, uint256 cokePot, uint256 weedAmountHere, uint256 cokeAmountHere, string name){\n', '    District storage district = districts[_id];\n', '    exits = district.exits;\n', '    hasMarket = district.hasMarket;\n', '    prices = district.marketPrices;\n', '\n', '    // minimum prices for w/c set in the districts configuration file\n', '    prices[0] = max(prices[0], (((district.weedPot / district.weedAmountHere)/100)*(100+spreadPercent)));// Smeti calc this is the buy price (contract sells)\n', '    prices[1] = max(prices[1], (((district.cokePot / district.cokeAmountHere)/100)*(100+spreadPercent)));  // Smeti calc this is the buy price (contract sells)\n', '    isStocked = district.isStocked;\n', '    weedPot = district.weedPot;\n', '    cokePot = district.cokePot;\n', '    weedAmountHere = district.weedAmountHere;\n', '    cokeAmountHere = district.cokeAmountHere;\n', '    name = district.name;\n', '  }\n', '\n', '  function createNamedDistrict(uint256 _index, string _name, bool _hasMarket) public onlyOwner{\n', '    districts[_index].name = _name;\n', '    districts[_index].hasMarket = _hasMarket;\n', '    districts[_index].weedAmountHere = 1;\n', '    districts[_index].cokeAmountHere = 1;\n', '    districts[_index].weedPot = 0.001 ether;\n', '    districts[_index].cokePot = 0.001 ether;\n', '  }\n', '\n', '  function configureDistrict(uint256 _index, uint256[6]_exits, uint256[24] _prices, bool[24] _isStocked) public onlyOwner{\n', '    districts[_index].exits = _exits; // clockwise starting at noon\n', '    districts[_index].marketPrices = _prices;\n', '    districts[_index].isStocked = _isStocked;\n', '  }\n', '\n', '  // callable by other contracts to control economy\n', '  function increaseDistrictWeed(uint256 _district, uint256 _quantity) public onlyDopeRaiderContract{\n', '    districts[_district].weedAmountHere += _quantity;\n', '  }\n', '  function increaseDistrictCoke(uint256 _district, uint256 _quantity) public onlyDopeRaiderContract{\n', '    districts[_district].cokeAmountHere += _quantity;\n', '  }\n', '\n', '  function getNarcoLocation(uint256 _narcoId) public view returns(uint8 location){\n', '    location = narcoIndexToLocation[_narcoId];\n', '    // could be they have not travelled, so just return their home location\n', '    if (location == 0) {\n', '      (\n', '            ,\n', '            ,\n', '            ,\n', '            ,\n', '            ,\n', '            ,\n', '        location\n', '        ,\n', '        ,\n', '        ,\n', '        ,\n', '        ) = narcoCore.getNarco(_narcoId);\n', '\n', '    }\n', '\n', '  }\n', '\n', '  function getNarcoHomeLocation(uint256 _narcoId) public view returns(uint8 location){\n', '      (\n', '            ,\n', '            ,\n', '            ,\n', '            ,\n', '            ,\n', '            ,\n', '        location\n', '        ,\n', '        ,\n', '        ,\n', '        ,\n', '        ) = narcoCore.getNarco(_narcoId);\n', '  }\n', '\n', '  // function to be called when wanting to add funds to all districts\n', '  function floatEconony() public payable onlyOwner {\n', '        if(msg.value>0){\n', '          for (uint district=1;district<8;district++){\n', '              districts[district].weedPot+=(msg.value/14);\n', '              districts[district].cokePot+=(msg.value/14);\n', '            }\n', '        }\n', '    }\n', '\n', '  // function to be called when wanting to add funds to a district\n', '  function distributeRevenue(uint256 _district , uint8 _splitW, uint8 _splitC) public payable onlyDopeRaiderContract {\n', '        if(msg.value>0){\n', '         _distributeRevenue(msg.value, _district, _splitW, _splitC);\n', '        }\n', '  }\n', '\n', '  uint256 public localRevenuePercent = 80;\n', '\n', '  function setLocalRevenuPercent(uint256 _lrp) public onlyOwner{\n', '    localRevenuePercent = _lrp;\n', '  }\n', '\n', '  function _distributeRevenue(uint256 _grossRevenue, uint256 _district , uint8 _splitW, uint8 _splitC) internal {\n', '          // subtract dev fees\n', '          uint256 onePc = _grossRevenue/100;\n', '          uint256 netRevenue = onePc*(100-devFeePercent);\n', '          uint256 devFee = onePc*(devFeePercent);\n', '\n', '          uint256 districtRevenue = (netRevenue/100)*localRevenuePercent;\n', '          uint256 federalRevenue = (netRevenue/100)*(100-localRevenuePercent);\n', '\n', '          // distribute district revenue\n', '          // split evenly between weed and coke pots\n', '          districts[_district].weedPot+=(districtRevenue/100)*_splitW;\n', '          districts[_district].cokePot+=(districtRevenue/100)*_splitC;\n', '\n', '          // distribute federal revenue\n', '           for (uint district=1;district<8;district++){\n', '              districts[district].weedPot+=(federalRevenue/14);\n', '              districts[district].cokePot+=(federalRevenue/14);\n', '            }\n', '\n', '          // acrue dev fee\n', '          currentDevFees+=devFee;\n', '  }\n', '\n', '  function withdrawFees() external onlyOwner {\n', '        if (currentDevFees<=address(this).balance){\n', '          currentDevFees = 0;\n', '          msg.sender.transfer(currentDevFees);\n', '        }\n', '    }\n', '\n', '\n', '  function buyItem(uint256 _narcoId, uint256 _district, uint256 _itemIndex, uint256 _quantity) public payable whenNotPaused{\n', '    require(narcoCore.ownerOf(_narcoId) == msg.sender); // must be owner\n', '\n', '    uint256 narcoWeedTotal;\n', '    uint256 narcoCokeTotal;\n', '    uint16[6] memory narcoSkills;\n', '    uint8[4] memory narcoConsumables;\n', '    uint16 narcoLevel;\n', '\n', '    (\n', '                ,\n', '      narcoWeedTotal,\n', '      narcoCokeTotal,\n', '      narcoSkills,\n', '      narcoConsumables,\n', '                ,\n', '                ,\n', '      narcoLevel,\n', '                ,\n', '                ,\n', '    ) = narcoCore.getNarco(_narcoId);\n', '\n', '    require(getNarcoLocation(_narcoId) == uint8(_district)); // right place to buy\n', '    require(uint8(_quantity) > 0 && districts[_district].isStocked[_itemIndex] == true); // there is enough of it\n', '    require(marketItems[_itemIndex].levelRequired <= narcoLevel || _district==7); //  must be level to buy this item or black market\n', '    require(narcoCore.getRemainingCapacity(_narcoId) >= _quantity || _itemIndex>=6); // narco can carry it or not a consumable\n', '\n', '    // progression through the upgrades for non consumable items (>=6)\n', '    if (_itemIndex>=6) {\n', '      if (marketItems[_itemIndex].skillAffected!=5){\n', '            // regular items\n', '            require (marketItems[_itemIndex].levelRequired==0 || narcoSkills[marketItems[_itemIndex].skillAffected]<marketItems[_itemIndex].upgradeAmount);\n', '          }else{\n', '            // capacity has 20 + requirement\n', '            require (narcoSkills[5]<20+marketItems[_itemIndex].upgradeAmount);\n', '      }\n', '    }\n', '\n', '    uint256 costPrice = districts[_district].marketPrices[_itemIndex] * _quantity;\n', '\n', '    if (_itemIndex ==0 ) {\n', '      costPrice = max(districts[_district].marketPrices[0], (((districts[_district].weedPot / districts[_district].weedAmountHere)/100)*(100+spreadPercent))) * _quantity;\n', '    }\n', '    if (_itemIndex ==1 ) {\n', '      costPrice = max(districts[_district].marketPrices[1], (((districts[_district].cokePot / districts[_district].cokeAmountHere)/100)*(100+spreadPercent))) * _quantity;\n', '    }\n', '\n', '    require(msg.value >= costPrice); // paid enough?\n', '    // ok purchase here\n', '    if (_itemIndex > 1 && _itemIndex < 6) {\n', '      // consumable\n', '      narcoCore.updateConsumable(_narcoId, _itemIndex - 2, uint8(narcoConsumables[_itemIndex - 2] + _quantity));\n', '       _distributeRevenue(costPrice, _district , 50, 50);\n', '    }\n', '\n', '    if (_itemIndex >= 6) {\n', '        // skills boost\n', '        // check which skill is updated by this item\n', '        narcoCore.updateSkill(\n', '          _narcoId,\n', '          marketItems[_itemIndex].skillAffected,\n', '          uint16(narcoSkills[marketItems[_itemIndex].skillAffected] + (marketItems[_itemIndex].upgradeAmount * _quantity))\n', '        );\n', '        _distributeRevenue(costPrice, _district , 50, 50);\n', '    }\n', '    if (_itemIndex == 0) {\n', '        // weedTotal\n', '        narcoCore.updateWeedTotal(_narcoId, true,  uint16(_quantity));\n', '        districts[_district].weedAmountHere += uint8(_quantity);\n', '        _distributeRevenue(costPrice, _district , 100, 0);\n', '    }\n', '    if (_itemIndex == 1) {\n', '       // cokeTotal\n', '       narcoCore.updateCokeTotal(_narcoId, true, uint16(_quantity));\n', '       districts[_district].cokeAmountHere += uint8(_quantity);\n', '       _distributeRevenue(costPrice, _district , 0, 100);\n', '    }\n', '\n', '    // allow overbid\n', '    if (msg.value>costPrice){\n', '        msg.sender.transfer(msg.value-costPrice);\n', '    }\n', '\n', '  }\n', '\n', '\n', '  function sellItem(uint256 _narcoId, uint256 _district, uint256 _itemIndex, uint256 _quantity) public whenNotPaused{\n', '    require(narcoCore.ownerOf(_narcoId) == msg.sender); // must be owner\n', '    require(_itemIndex < marketItems.length && _district < 8 && _district > 0 && _quantity > 0); // valid item and district and quantity\n', '\n', '    uint256 narcoWeedTotal;\n', '    uint256 narcoCokeTotal;\n', '\n', '    (\n', '                ,\n', '      narcoWeedTotal,\n', '      narcoCokeTotal,\n', '                ,\n', '                ,\n', '                ,\n', '                ,\n', '                ,\n', '                ,\n', '                ,\n', '            ) = narcoCore.getNarco(_narcoId);\n', '\n', '\n', '    require(getNarcoLocation(_narcoId) == _district); // right place to buy\n', '    // at this time only weed and coke can be sold to the contract\n', '    require((_itemIndex == 0 && narcoWeedTotal >= _quantity) || (_itemIndex == 1 && narcoCokeTotal >= _quantity));\n', '\n', '    uint256 salePrice = 0;\n', '\n', '    if (_itemIndex == 0) {\n', '      salePrice = districts[_district].weedPot / districts[_district].weedAmountHere;  // Smeti calc this is the sell price (contract buys)\n', '    }\n', '    if (_itemIndex == 1) {\n', '      salePrice = districts[_district].cokePot / districts[_district].cokeAmountHere;  // Smeti calc this is the sell price (contract buys)\n', '    }\n', '    require(salePrice > 0); // yeah that old chestnut lol\n', '\n', '    // do the updates\n', '    if (_itemIndex == 0) {\n', '      narcoCore.updateWeedTotal(_narcoId, false, uint16(_quantity));\n', '      districts[_district].weedPot-=salePrice*_quantity;\n', '      districts[_district].weedAmountHere -= _quantity;\n', '    }\n', '    if (_itemIndex == 1) {\n', '      narcoCore.updateCokeTotal(_narcoId, false, uint16(_quantity));\n', '      districts[_district].cokePot-=salePrice*_quantity;\n', '      districts[_district].cokeAmountHere -= _quantity;\n', '    }\n', '    narcoCore.incrementStat(_narcoId, 0); // dealsCompleted\n', '    // transfer the amount to the seller - should be owner of, but for now...\n', '    msg.sender.transfer(salePrice*_quantity);\n', '\n', '  }\n', '\n', '\n', '\n', '  // allow a Narco to travel between districts\n', '  // travelling is done by taking "exit" --> index into the loctions\n', '  function travelTo(uint256 _narcoId, uint256 _exitId) public payable whenNotPaused{\n', '    require(narcoCore.ownerOf(_narcoId) == msg.sender); // must be owner\n', '    require((msg.value >= travelPrice && _exitId < 7) || (msg.value >= airLiftPrice && _exitId==7));\n', '\n', '    // exitId ==7 is a special exit for airlifting narcos back to their home location\n', '\n', '\n', '    uint256 narcoWeedTotal;\n', '    uint256 narcoCokeTotal;\n', '    uint16[6] memory narcoSkills;\n', '    uint8[4] memory narcoConsumables;\n', '    uint256[6] memory narcoCooldowns;\n', '\n', '    (\n', '                ,\n', '      narcoWeedTotal,\n', '      narcoCokeTotal,\n', '      narcoSkills,\n', '      narcoConsumables,\n', '                ,\n', '                ,\n', '                ,\n', '      narcoCooldowns,\n', '                ,\n', '    ) = narcoCore.getNarco(_narcoId);\n', '\n', '    // travel cooldown must have expired and narco must have some gas\n', '    require(now>narcoCooldowns[0] && narcoConsumables[0]>0);\n', '\n', '    uint8 sourceLocation = getNarcoLocation(_narcoId);\n', '    District storage sourceDistrict = districts[sourceLocation]; // find out source\n', '    require(_exitId==7 || sourceDistrict.exits[_exitId] != 0); // must be a valid exit\n', '\n', '    // decrease the weed pot and cocaine pot for the destination district\n', '    uint256 localWeedTotal = districts[sourceLocation].weedAmountHere;\n', '    uint256 localCokeTotal = districts[sourceLocation].cokeAmountHere;\n', '\n', '    if (narcoWeedTotal < localWeedTotal) {\n', '      districts[sourceLocation].weedAmountHere -= narcoWeedTotal;\n', '    } else {\n', '      districts[sourceLocation].weedAmountHere = 1; // always drop to 1\n', '    }\n', '\n', '    if (narcoCokeTotal < localCokeTotal) {\n', '      districts[sourceLocation].cokeAmountHere -= narcoCokeTotal;\n', '    } else {\n', '      districts[sourceLocation].cokeAmountHere = 1; // always drop to 1\n', '    }\n', '\n', '    // do the move\n', '    uint8 targetLocation = getNarcoHomeLocation(_narcoId);\n', '    if (_exitId<7){\n', '      targetLocation =  uint8(sourceDistrict.exits[_exitId]);\n', '    }\n', '\n', '    narcoIndexToLocation[_narcoId] = targetLocation;\n', '\n', '    // distribute the travel revenue\n', '    _distributeRevenue(travelPrice, targetLocation , 50, 50);\n', '\n', '    // increase the weed pot and cocaine pot for the destination district with the travel cost\n', '    districts[targetLocation].weedAmountHere += narcoWeedTotal;\n', '    districts[targetLocation].cokeAmountHere += narcoCokeTotal;\n', '\n', '    // consume some gas (gas index = 0)\n', '    narcoCore.updateConsumable(_narcoId, 0 , narcoConsumables[0]-1);\n', '    // set travel cooldown (speed skill = 0)\n', '    //narcoCore.setCooldown( _narcoId ,  0 , now + min(3 minutes,(455-(5*narcoSkills[0])* 1 seconds)));\n', '    narcoCore.setCooldown( _narcoId ,  0 , now + (455-(5*narcoSkills[0])* 1 seconds));\n', '\n', '    // update travel stat\n', '    narcoCore.incrementStat(_narcoId, 7);\n', '    // Travel risk\n', '     uint64 bustChance=random(50+(5*narcoSkills[0])); // 0  = speed skill\n', '\n', '     if (bustChance<=bustRange){\n', '      busted(_narcoId,targetLocation,narcoWeedTotal,narcoCokeTotal);\n', '     }\n', '\n', '     NarcoArrived(targetLocation, _narcoId); // who just arrived here\n', '     NarcoLeft(sourceLocation, _narcoId); // who just left here\n', '\n', '  }\n', '\n', '  function busted(uint256 _narcoId, uint256 targetLocation, uint256 narcoWeedTotal, uint256 narcoCokeTotal) private  {\n', '       uint256 bustedWeed=narcoWeedTotal/2; // %50\n', '       uint256 bustedCoke=narcoCokeTotal/2; // %50\n', '       districts[targetLocation].weedAmountHere -= bustedWeed; // smeti fix\n', '       districts[targetLocation].cokeAmountHere -= bustedCoke; // smeti fix\n', '       districts[7].weedAmountHere += bustedWeed; // smeti fix\n', '       districts[7].cokeAmountHere += bustedCoke; // smeti fix\n', '       narcoCore.updateWeedTotal(_narcoId, false, uint16(bustedWeed)); // 50% weed\n', '       narcoCore.updateCokeTotal(_narcoId, false, uint16(bustedCoke)); // 50% coke\n', '       narcoCore.updateWeedTotal(0, true, uint16(bustedWeed)); // 50% weed confiscated into office lardass\n', '       narcoCore.updateCokeTotal(0, true, uint16(bustedCoke)); // 50% coke confiscated into office lardass\n', '       TravelBust(_narcoId, uint16(bustedWeed), uint16(bustedCoke));\n', '  }\n', '\n', '\n', '  function hijack(uint256 _hijackerId, uint256 _victimId)  public payable whenNotPaused{\n', '    require(narcoCore.ownerOf(_hijackerId) == msg.sender); // must be owner\n', '    require(msg.value >= hijackPrice);\n', '\n', '    // has the victim escaped?\n', '    if (getNarcoLocation(_hijackerId)!=getNarcoLocation(_victimId)){\n', '        EscapedHijack(_hijackerId, _victimId , getNarcoLocation(_victimId));\n', '        narcoCore.incrementStat(_victimId, 6); // lucky escape\n', '    }else\n', '    {\n', '      // hijack calculation\n', '      uint256 hijackerWeedTotal;\n', '      uint256 hijackerCokeTotal;\n', '      uint16[6] memory hijackerSkills;\n', '      uint8[4] memory hijackerConsumables;\n', '      uint256[6] memory hijackerCooldowns;\n', '\n', '      (\n', '                  ,\n', '        hijackerWeedTotal,\n', '        hijackerCokeTotal,\n', '        hijackerSkills,\n', '        hijackerConsumables,\n', '                  ,\n', '                  ,\n', '                  ,\n', '        hijackerCooldowns,\n', '                  ,\n', '      ) = narcoCore.getNarco(_hijackerId);\n', '\n', '      // does hijacker have capacity to carry any loot?\n', '\n', '      uint256 victimWeedTotal;\n', '      uint256 victimCokeTotal;\n', '      uint16[6] memory victimSkills;\n', '      uint256[6] memory victimCooldowns;\n', '      uint8 victimHomeLocation;\n', '      (\n', '                  ,\n', '        victimWeedTotal,\n', '        victimCokeTotal,\n', '        victimSkills,\n', '                  ,\n', '                  ,\n', '       victimHomeLocation,\n', '                  ,\n', '        victimCooldowns,\n', '                  ,\n', '      ) = narcoCore.getNarco(_victimId);\n', '\n', '      // victim is not in home location , or is officer lardass\n', '      require(getNarcoLocation(_victimId)!=victimHomeLocation || _victimId==0);\n', '      require(hijackerConsumables[3] >0); // narco has ammo\n', '\n', '      require(now>hijackerCooldowns[3]); // must be outside cooldown\n', '\n', '      // consume the ammo\n', '      narcoCore.updateConsumable(_hijackerId, 3 , hijackerConsumables[3]-1);\n', '      // attempt the hijack\n', '\n', '      // 3 = attackIndex\n', '      // 4 = defenseIndex\n', '\n', '      if (uint8(random((hijackerSkills[3]+victimSkills[4]))+1) >victimSkills[4]) {\n', '        // successful hijacking\n', '\n', '        doHijack(_hijackerId  , _victimId , victimWeedTotal , victimCokeTotal);\n', '\n', '        // heist character\n', '        if (_victimId==0){\n', '             narcoCore.incrementStat(_hijackerId, 5); // raidSuccessful\n', '        }\n', '\n', '      }else{\n', '        // successfully defended\n', '        narcoCore.incrementStat(_victimId, 4); // defendedSuccessfully\n', '        HijackDefended( _hijackerId,_victimId);\n', '      }\n', '\n', '    } // end if escaped\n', '\n', '    //narcoCore.setCooldown( _hijackerId ,  3 , now + min(3 minutes,(455-(5*hijackerSkills[3])* 1 seconds))); // cooldown\n', '     narcoCore.setCooldown( _hijackerId ,  3 , now + (455-(5*hijackerSkills[3])* 1 seconds)); // cooldown\n', '\n', '      // distribute the hijack revenue\n', '      _distributeRevenue(hijackPrice, getNarcoLocation(_hijackerId) , 50, 50);\n', '\n', '  } // end hijack function\n', '\n', '  function doHijack(uint256 _hijackerId  , uint256 _victimId ,  uint256 victimWeedTotal , uint256 victimCokeTotal) private {\n', '\n', '        uint256 hijackerCapacity =  narcoCore.getRemainingCapacity(_hijackerId);\n', '\n', '        // fill pockets starting with coke\n', '        uint16 stolenCoke = uint16(min(hijackerCapacity , (victimCokeTotal/2))); // steal 50%\n', '        uint16 stolenWeed = uint16(min(hijackerCapacity - stolenCoke, (victimWeedTotal/2))); // steal 50%\n', '\n', '        // 50% chance to start with weed\n', '        if (random(100)>50){\n', '           stolenWeed = uint16(min(hijackerCapacity , (victimWeedTotal/2))); // steal 50%\n', '           stolenCoke = uint16(min(hijackerCapacity - stolenWeed, (victimCokeTotal/2))); // steal 50\n', '        }\n', '\n', '        // steal some loot this calculation tbd\n', '        // for now just take all coke / weed\n', '        if (stolenWeed>0){\n', '          narcoCore.updateWeedTotal(_hijackerId, true, stolenWeed);\n', '          narcoCore.updateWeedTotal(_victimId,false, stolenWeed);\n', '        }\n', '        if (stolenCoke>0){\n', '          narcoCore.updateCokeTotal(_hijackerId, true , stolenCoke);\n', '          narcoCore.updateCokeTotal(_victimId,false, stolenCoke);\n', '        }\n', '\n', '        narcoCore.incrementStat(_hijackerId, 3); // hijackSuccessful\n', '        Hijacked(_hijackerId, _victimId , stolenWeed, stolenCoke);\n', '\n', '\n', '  }\n', '\n', '\n', '  // pseudo random - but does that matter?\n', '  uint64 _seed = 0;\n', '  function random(uint64 upper) private returns (uint64 randomNumber) {\n', '     _seed = uint64(keccak256(keccak256(block.blockhash(block.number-1), _seed), now));\n', '     return _seed % upper;\n', '   }\n', '\n', '   function min(uint a, uint b) private pure returns (uint) {\n', '            return a < b ? a : b;\n', '   }\n', '   function max(uint a, uint b) private pure returns (uint) {\n', '            return a > b ? a : b;\n', '   }\n', '\n', '  // never call this from a contract\n', '  /// @param _loc that we are interested in\n', '  function narcosByDistrict(uint8 _loc) public view returns(uint256[] narcosHere) {\n', '    uint256 tokenCount = numberOfNarcosByDistrict(_loc);\n', '    uint256 totalNarcos = narcoCore.totalSupply();\n', '    uint256[] memory result = new uint256[](tokenCount);\n', '    uint256 narcoId;\n', '    uint256 resultIndex = 0;\n', '    for (narcoId = 0; narcoId <= totalNarcos; narcoId++) {\n', '      if (getNarcoLocation(narcoId) == _loc) {\n', '        result[resultIndex] = narcoId;\n', '        resultIndex++;\n', '      }\n', '    }\n', '    return result;\n', '  }\n', '\n', '  function numberOfNarcosByDistrict(uint8 _loc) public view returns(uint256 number) {\n', '    uint256 count = 0;\n', '    uint256 narcoId;\n', '    for (narcoId = 0; narcoId <= narcoCore.totalSupply(); narcoId++) {\n', '      if (getNarcoLocation(narcoId) == _loc) {\n', '        count++;\n', '      }\n', '    }\n', '    return count;\n', '  }\n', '\n', '}']
['pragma solidity ^ 0.4.19;\n', '\n', '// DopeRaider Districts Contract\n', '// by gasmasters.io\n', '// contact: team@doperaider.com\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', 'contract ERC721 {\n', '  function implementsERC721() public pure returns(bool);\n', '  function totalSupply() public view returns(uint256 total);\n', '  function balanceOf(address _owner) public view returns(uint256 balance);\n', '  function ownerOf(uint256 _tokenId) public view returns(address owner);\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function transfer(address _to, uint256 _tokenId) public;\n', '  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '  // Optional\n', '  // function name() public view returns (string name);\n', '  // function symbol() public view returns (string symbol);\n', '  // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n', '  // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n', '}\n', '\n', '// File: contracts/NarcoCoreInterface.sol\n', '\n', 'contract NarcosCoreInterface is ERC721 {\n', '  function getNarco(uint256 _id)\n', '  public\n', '  view\n', '  returns(\n', '    string  narcoName,\n', '    uint256 weedTotal,\n', '    uint256 cokeTotal,\n', '    uint16[6] skills,\n', '    uint8[4] consumables,\n', '    string genes,\n', '    uint8 homeLocation,\n', '    uint16 level,\n', '    uint256[6] cooldowns,\n', '    uint256 id,\n', '    uint16[9] stats\n', '  );\n', '\n', '  function updateWeedTotal(uint256 _narcoId, bool _add, uint16 _total) public;\n', '  function updateCokeTotal(uint256 _narcoId, bool _add,  uint16 _total) public;\n', '  function updateConsumable(uint256 _narcoId, uint256 _index, uint8 _new) public;\n', '  function updateSkill(uint256 _narcoId, uint256 _index, uint16 _new) public;\n', '  function incrementStat(uint256 _narcoId, uint256 _index) public;\n', '  function setCooldown(uint256 _narcoId , uint256 _index , uint256 _new) public;\n', '  function getRemainingCapacity(uint256 _id) public view returns (uint8 capacity);\n', '}\n', '\n', '\n', '// File: contracts/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = true;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '\n', '// File: contracts/Districts/DistrictsAdmin.sol\n', '\n', 'contract DistrictsAdmin is Ownable, Pausable {\n', '  event ContractUpgrade(address newContract);\n', '\n', '  address public newContractAddress;\n', '  address public coreAddress;\n', '\n', '  NarcosCoreInterface public narcoCore;\n', '\n', '  function setNarcosCoreAddress(address _address) public onlyOwner {\n', '    _setNarcosCoreAddress(_address);\n', '  }\n', '\n', '  function _setNarcosCoreAddress(address _address) internal {\n', '    NarcosCoreInterface candidateContract = NarcosCoreInterface(_address);\n', '    require(candidateContract.implementsERC721());\n', '    coreAddress = _address;\n', '    narcoCore = candidateContract;\n', '  }\n', '\n', '  /// @dev Used to mark the smart contract as upgraded, in case there is a serious\n', '  ///  breaking bug. This method does nothing but keep track of the new contract and\n', "  ///  emit a message indicating that the new address is set. It's up to clients of this\n", '  ///  contract to update to the new contract address in that case.\n', '  /// @param _v2Address new address\n', '  function setNewAddress(address _v2Address) public onlyOwner whenPaused {\n', '    newContractAddress = _v2Address;\n', '\n', '    ContractUpgrade(_v2Address);\n', '  }\n', '\n', '  modifier onlyDopeRaiderContract() {\n', '    require(msg.sender == coreAddress);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '// File: contracts/DistrictsCore.sol\n', '\n', 'contract DistrictsCore is DistrictsAdmin {\n', '\n', '  // DISTRICT EVENTS\n', '  event NarcoArrived(uint8 indexed location, uint256 indexed narcoId); // who just arrived here\n', '  event NarcoLeft(uint8 indexed location, uint256 indexed narcoId); // who just left here\n', '  event TravelBust(uint256 indexed narcoId, uint16 confiscatedWeed, uint16 confiscatedCoke);\n', '  event Hijacked(uint256 indexed hijacker, uint256 indexed victim , uint16 stolenWeed , uint16 stolenCoke);\n', '  event HijackDefended(uint256 indexed hijacker, uint256 indexed victim);\n', '  event EscapedHijack(uint256 indexed hijacker, uint256 indexed victim , uint8 escapeLocation);\n', '\n', '  uint256 public airLiftPrice = 0.01 ether; // home dorothy price\n', '  uint256 public hijackPrice = 0.002 ether; // universal hijackPrice\n', '  uint256 public travelPrice = 0.001 ether; // universal travelPrice\n', '  uint256 public spreadPercent = 5; // universal spread between buy and sell\n', '  uint256 public devFeePercent = 2; // on various actions\n', '  uint256 public currentDevFees = 0;\n', '  uint256 public bustRange = 10;\n', '\n', '  function setAirLiftPrice(uint256 _price) public onlyOwner{\n', '    airLiftPrice = _price;\n', '  }\n', '\n', '  function setBustRange(uint256 _range) public onlyOwner{\n', '    bustRange = _range;\n', '  }\n', '\n', '  function setHijackPrice(uint256 _price) public onlyOwner{\n', '    hijackPrice = _price;\n', '  }\n', '\n', '  function setTravelPrice(uint256 _price) public onlyOwner{\n', '    travelPrice = _price;\n', '  }\n', '\n', '  function setSpreadPercent(uint256 _spread) public onlyOwner{\n', '    spreadPercent = _spread;\n', '  }\n', '\n', '  function setDevFeePercent(uint256 _fee) public onlyOwner{\n', '    devFeePercent = _fee;\n', '  }\n', '\n', '  function isDopeRaiderDistrictsCore() public pure returns(bool){ return true; }\n', '\n', '\n', '  // Market Items\n', '\n', '  struct MarketItem{\n', '    uint256 id;\n', '    string itemName;\n', '    uint8 skillAffected;\n', '    uint8 upgradeAmount;\n', '    uint8 levelRequired; // the level a narco must have before they\n', '  }\n', '\n', '  // there is a fixed amount of items - they are not tokens bc iterations will be needed.\n', '  // 0,1 = weed , coke , 2 - 4 consumables , 5-23 items\n', '  MarketItem[24] public marketItems;\n', '\n', '  function configureMarketItem(uint256 _id, uint8 _skillAffected, uint8  _upgradeAmount, uint8 _levelRequired, string _itemName) public onlyOwner{\n', '    marketItems[_id].skillAffected = _skillAffected;\n', '    marketItems[_id].upgradeAmount = _upgradeAmount;\n', '    marketItems[_id].levelRequired = _levelRequired;\n', '    marketItems[_id].itemName = _itemName;\n', '    marketItems[_id].id = _id;\n', '  }\n', '\n', '\n', '  struct District {\n', '    uint256[6] exits;\n', '    uint256 weedPot;\n', '    uint256 weedAmountHere;\n', '    uint256 cokePot;\n', '    uint256 cokeAmountHere;\n', '    uint256[24] marketPrices;\n', '    bool[24] isStocked;\n', '    bool hasMarket;\n', '    string name;\n', '  }\n', '\n', "  District[8] public districts; // there is no '0' district - this will be used to indicate no exit\n", '\n', '  // for keeping track of who is where\n', '  mapping(uint256 => uint8) narcoIndexToLocation;\n', '\n', '  function DistrictsCore() public {\n', '  }\n', '\n', '  function getDistrict(uint256 _id) public view returns(uint256[6] exits, bool hasMarket, uint256[24] prices, bool[24] isStocked, uint256 weedPot, uint256 cokePot, uint256 weedAmountHere, uint256 cokeAmountHere, string name){\n', '    District storage district = districts[_id];\n', '    exits = district.exits;\n', '    hasMarket = district.hasMarket;\n', '    prices = district.marketPrices;\n', '\n', '    // minimum prices for w/c set in the districts configuration file\n', '    prices[0] = max(prices[0], (((district.weedPot / district.weedAmountHere)/100)*(100+spreadPercent)));// Smeti calc this is the buy price (contract sells)\n', '    prices[1] = max(prices[1], (((district.cokePot / district.cokeAmountHere)/100)*(100+spreadPercent)));  // Smeti calc this is the buy price (contract sells)\n', '    isStocked = district.isStocked;\n', '    weedPot = district.weedPot;\n', '    cokePot = district.cokePot;\n', '    weedAmountHere = district.weedAmountHere;\n', '    cokeAmountHere = district.cokeAmountHere;\n', '    name = district.name;\n', '  }\n', '\n', '  function createNamedDistrict(uint256 _index, string _name, bool _hasMarket) public onlyOwner{\n', '    districts[_index].name = _name;\n', '    districts[_index].hasMarket = _hasMarket;\n', '    districts[_index].weedAmountHere = 1;\n', '    districts[_index].cokeAmountHere = 1;\n', '    districts[_index].weedPot = 0.001 ether;\n', '    districts[_index].cokePot = 0.001 ether;\n', '  }\n', '\n', '  function configureDistrict(uint256 _index, uint256[6]_exits, uint256[24] _prices, bool[24] _isStocked) public onlyOwner{\n', '    districts[_index].exits = _exits; // clockwise starting at noon\n', '    districts[_index].marketPrices = _prices;\n', '    districts[_index].isStocked = _isStocked;\n', '  }\n', '\n', '  // callable by other contracts to control economy\n', '  function increaseDistrictWeed(uint256 _district, uint256 _quantity) public onlyDopeRaiderContract{\n', '    districts[_district].weedAmountHere += _quantity;\n', '  }\n', '  function increaseDistrictCoke(uint256 _district, uint256 _quantity) public onlyDopeRaiderContract{\n', '    districts[_district].cokeAmountHere += _quantity;\n', '  }\n', '\n', '  function getNarcoLocation(uint256 _narcoId) public view returns(uint8 location){\n', '    location = narcoIndexToLocation[_narcoId];\n', '    // could be they have not travelled, so just return their home location\n', '    if (location == 0) {\n', '      (\n', '            ,\n', '            ,\n', '            ,\n', '            ,\n', '            ,\n', '            ,\n', '        location\n', '        ,\n', '        ,\n', '        ,\n', '        ,\n', '        ) = narcoCore.getNarco(_narcoId);\n', '\n', '    }\n', '\n', '  }\n', '\n', '  function getNarcoHomeLocation(uint256 _narcoId) public view returns(uint8 location){\n', '      (\n', '            ,\n', '            ,\n', '            ,\n', '            ,\n', '            ,\n', '            ,\n', '        location\n', '        ,\n', '        ,\n', '        ,\n', '        ,\n', '        ) = narcoCore.getNarco(_narcoId);\n', '  }\n', '\n', '  // function to be called when wanting to add funds to all districts\n', '  function floatEconony() public payable onlyOwner {\n', '        if(msg.value>0){\n', '          for (uint district=1;district<8;district++){\n', '              districts[district].weedPot+=(msg.value/14);\n', '              districts[district].cokePot+=(msg.value/14);\n', '            }\n', '        }\n', '    }\n', '\n', '  // function to be called when wanting to add funds to a district\n', '  function distributeRevenue(uint256 _district , uint8 _splitW, uint8 _splitC) public payable onlyDopeRaiderContract {\n', '        if(msg.value>0){\n', '         _distributeRevenue(msg.value, _district, _splitW, _splitC);\n', '        }\n', '  }\n', '\n', '  uint256 public localRevenuePercent = 80;\n', '\n', '  function setLocalRevenuPercent(uint256 _lrp) public onlyOwner{\n', '    localRevenuePercent = _lrp;\n', '  }\n', '\n', '  function _distributeRevenue(uint256 _grossRevenue, uint256 _district , uint8 _splitW, uint8 _splitC) internal {\n', '          // subtract dev fees\n', '          uint256 onePc = _grossRevenue/100;\n', '          uint256 netRevenue = onePc*(100-devFeePercent);\n', '          uint256 devFee = onePc*(devFeePercent);\n', '\n', '          uint256 districtRevenue = (netRevenue/100)*localRevenuePercent;\n', '          uint256 federalRevenue = (netRevenue/100)*(100-localRevenuePercent);\n', '\n', '          // distribute district revenue\n', '          // split evenly between weed and coke pots\n', '          districts[_district].weedPot+=(districtRevenue/100)*_splitW;\n', '          districts[_district].cokePot+=(districtRevenue/100)*_splitC;\n', '\n', '          // distribute federal revenue\n', '           for (uint district=1;district<8;district++){\n', '              districts[district].weedPot+=(federalRevenue/14);\n', '              districts[district].cokePot+=(federalRevenue/14);\n', '            }\n', '\n', '          // acrue dev fee\n', '          currentDevFees+=devFee;\n', '  }\n', '\n', '  function withdrawFees() external onlyOwner {\n', '        if (currentDevFees<=address(this).balance){\n', '          currentDevFees = 0;\n', '          msg.sender.transfer(currentDevFees);\n', '        }\n', '    }\n', '\n', '\n', '  function buyItem(uint256 _narcoId, uint256 _district, uint256 _itemIndex, uint256 _quantity) public payable whenNotPaused{\n', '    require(narcoCore.ownerOf(_narcoId) == msg.sender); // must be owner\n', '\n', '    uint256 narcoWeedTotal;\n', '    uint256 narcoCokeTotal;\n', '    uint16[6] memory narcoSkills;\n', '    uint8[4] memory narcoConsumables;\n', '    uint16 narcoLevel;\n', '\n', '    (\n', '                ,\n', '      narcoWeedTotal,\n', '      narcoCokeTotal,\n', '      narcoSkills,\n', '      narcoConsumables,\n', '                ,\n', '                ,\n', '      narcoLevel,\n', '                ,\n', '                ,\n', '    ) = narcoCore.getNarco(_narcoId);\n', '\n', '    require(getNarcoLocation(_narcoId) == uint8(_district)); // right place to buy\n', '    require(uint8(_quantity) > 0 && districts[_district].isStocked[_itemIndex] == true); // there is enough of it\n', '    require(marketItems[_itemIndex].levelRequired <= narcoLevel || _district==7); //  must be level to buy this item or black market\n', '    require(narcoCore.getRemainingCapacity(_narcoId) >= _quantity || _itemIndex>=6); // narco can carry it or not a consumable\n', '\n', '    // progression through the upgrades for non consumable items (>=6)\n', '    if (_itemIndex>=6) {\n', '      if (marketItems[_itemIndex].skillAffected!=5){\n', '            // regular items\n', '            require (marketItems[_itemIndex].levelRequired==0 || narcoSkills[marketItems[_itemIndex].skillAffected]<marketItems[_itemIndex].upgradeAmount);\n', '          }else{\n', '            // capacity has 20 + requirement\n', '            require (narcoSkills[5]<20+marketItems[_itemIndex].upgradeAmount);\n', '      }\n', '    }\n', '\n', '    uint256 costPrice = districts[_district].marketPrices[_itemIndex] * _quantity;\n', '\n', '    if (_itemIndex ==0 ) {\n', '      costPrice = max(districts[_district].marketPrices[0], (((districts[_district].weedPot / districts[_district].weedAmountHere)/100)*(100+spreadPercent))) * _quantity;\n', '    }\n', '    if (_itemIndex ==1 ) {\n', '      costPrice = max(districts[_district].marketPrices[1], (((districts[_district].cokePot / districts[_district].cokeAmountHere)/100)*(100+spreadPercent))) * _quantity;\n', '    }\n', '\n', '    require(msg.value >= costPrice); // paid enough?\n', '    // ok purchase here\n', '    if (_itemIndex > 1 && _itemIndex < 6) {\n', '      // consumable\n', '      narcoCore.updateConsumable(_narcoId, _itemIndex - 2, uint8(narcoConsumables[_itemIndex - 2] + _quantity));\n', '       _distributeRevenue(costPrice, _district , 50, 50);\n', '    }\n', '\n', '    if (_itemIndex >= 6) {\n', '        // skills boost\n', '        // check which skill is updated by this item\n', '        narcoCore.updateSkill(\n', '          _narcoId,\n', '          marketItems[_itemIndex].skillAffected,\n', '          uint16(narcoSkills[marketItems[_itemIndex].skillAffected] + (marketItems[_itemIndex].upgradeAmount * _quantity))\n', '        );\n', '        _distributeRevenue(costPrice, _district , 50, 50);\n', '    }\n', '    if (_itemIndex == 0) {\n', '        // weedTotal\n', '        narcoCore.updateWeedTotal(_narcoId, true,  uint16(_quantity));\n', '        districts[_district].weedAmountHere += uint8(_quantity);\n', '        _distributeRevenue(costPrice, _district , 100, 0);\n', '    }\n', '    if (_itemIndex == 1) {\n', '       // cokeTotal\n', '       narcoCore.updateCokeTotal(_narcoId, true, uint16(_quantity));\n', '       districts[_district].cokeAmountHere += uint8(_quantity);\n', '       _distributeRevenue(costPrice, _district , 0, 100);\n', '    }\n', '\n', '    // allow overbid\n', '    if (msg.value>costPrice){\n', '        msg.sender.transfer(msg.value-costPrice);\n', '    }\n', '\n', '  }\n', '\n', '\n', '  function sellItem(uint256 _narcoId, uint256 _district, uint256 _itemIndex, uint256 _quantity) public whenNotPaused{\n', '    require(narcoCore.ownerOf(_narcoId) == msg.sender); // must be owner\n', '    require(_itemIndex < marketItems.length && _district < 8 && _district > 0 && _quantity > 0); // valid item and district and quantity\n', '\n', '    uint256 narcoWeedTotal;\n', '    uint256 narcoCokeTotal;\n', '\n', '    (\n', '                ,\n', '      narcoWeedTotal,\n', '      narcoCokeTotal,\n', '                ,\n', '                ,\n', '                ,\n', '                ,\n', '                ,\n', '                ,\n', '                ,\n', '            ) = narcoCore.getNarco(_narcoId);\n', '\n', '\n', '    require(getNarcoLocation(_narcoId) == _district); // right place to buy\n', '    // at this time only weed and coke can be sold to the contract\n', '    require((_itemIndex == 0 && narcoWeedTotal >= _quantity) || (_itemIndex == 1 && narcoCokeTotal >= _quantity));\n', '\n', '    uint256 salePrice = 0;\n', '\n', '    if (_itemIndex == 0) {\n', '      salePrice = districts[_district].weedPot / districts[_district].weedAmountHere;  // Smeti calc this is the sell price (contract buys)\n', '    }\n', '    if (_itemIndex == 1) {\n', '      salePrice = districts[_district].cokePot / districts[_district].cokeAmountHere;  // Smeti calc this is the sell price (contract buys)\n', '    }\n', '    require(salePrice > 0); // yeah that old chestnut lol\n', '\n', '    // do the updates\n', '    if (_itemIndex == 0) {\n', '      narcoCore.updateWeedTotal(_narcoId, false, uint16(_quantity));\n', '      districts[_district].weedPot-=salePrice*_quantity;\n', '      districts[_district].weedAmountHere -= _quantity;\n', '    }\n', '    if (_itemIndex == 1) {\n', '      narcoCore.updateCokeTotal(_narcoId, false, uint16(_quantity));\n', '      districts[_district].cokePot-=salePrice*_quantity;\n', '      districts[_district].cokeAmountHere -= _quantity;\n', '    }\n', '    narcoCore.incrementStat(_narcoId, 0); // dealsCompleted\n', '    // transfer the amount to the seller - should be owner of, but for now...\n', '    msg.sender.transfer(salePrice*_quantity);\n', '\n', '  }\n', '\n', '\n', '\n', '  // allow a Narco to travel between districts\n', '  // travelling is done by taking "exit" --> index into the loctions\n', '  function travelTo(uint256 _narcoId, uint256 _exitId) public payable whenNotPaused{\n', '    require(narcoCore.ownerOf(_narcoId) == msg.sender); // must be owner\n', '    require((msg.value >= travelPrice && _exitId < 7) || (msg.value >= airLiftPrice && _exitId==7));\n', '\n', '    // exitId ==7 is a special exit for airlifting narcos back to their home location\n', '\n', '\n', '    uint256 narcoWeedTotal;\n', '    uint256 narcoCokeTotal;\n', '    uint16[6] memory narcoSkills;\n', '    uint8[4] memory narcoConsumables;\n', '    uint256[6] memory narcoCooldowns;\n', '\n', '    (\n', '                ,\n', '      narcoWeedTotal,\n', '      narcoCokeTotal,\n', '      narcoSkills,\n', '      narcoConsumables,\n', '                ,\n', '                ,\n', '                ,\n', '      narcoCooldowns,\n', '                ,\n', '    ) = narcoCore.getNarco(_narcoId);\n', '\n', '    // travel cooldown must have expired and narco must have some gas\n', '    require(now>narcoCooldowns[0] && narcoConsumables[0]>0);\n', '\n', '    uint8 sourceLocation = getNarcoLocation(_narcoId);\n', '    District storage sourceDistrict = districts[sourceLocation]; // find out source\n', '    require(_exitId==7 || sourceDistrict.exits[_exitId] != 0); // must be a valid exit\n', '\n', '    // decrease the weed pot and cocaine pot for the destination district\n', '    uint256 localWeedTotal = districts[sourceLocation].weedAmountHere;\n', '    uint256 localCokeTotal = districts[sourceLocation].cokeAmountHere;\n', '\n', '    if (narcoWeedTotal < localWeedTotal) {\n', '      districts[sourceLocation].weedAmountHere -= narcoWeedTotal;\n', '    } else {\n', '      districts[sourceLocation].weedAmountHere = 1; // always drop to 1\n', '    }\n', '\n', '    if (narcoCokeTotal < localCokeTotal) {\n', '      districts[sourceLocation].cokeAmountHere -= narcoCokeTotal;\n', '    } else {\n', '      districts[sourceLocation].cokeAmountHere = 1; // always drop to 1\n', '    }\n', '\n', '    // do the move\n', '    uint8 targetLocation = getNarcoHomeLocation(_narcoId);\n', '    if (_exitId<7){\n', '      targetLocation =  uint8(sourceDistrict.exits[_exitId]);\n', '    }\n', '\n', '    narcoIndexToLocation[_narcoId] = targetLocation;\n', '\n', '    // distribute the travel revenue\n', '    _distributeRevenue(travelPrice, targetLocation , 50, 50);\n', '\n', '    // increase the weed pot and cocaine pot for the destination district with the travel cost\n', '    districts[targetLocation].weedAmountHere += narcoWeedTotal;\n', '    districts[targetLocation].cokeAmountHere += narcoCokeTotal;\n', '\n', '    // consume some gas (gas index = 0)\n', '    narcoCore.updateConsumable(_narcoId, 0 , narcoConsumables[0]-1);\n', '    // set travel cooldown (speed skill = 0)\n', '    //narcoCore.setCooldown( _narcoId ,  0 , now + min(3 minutes,(455-(5*narcoSkills[0])* 1 seconds)));\n', '    narcoCore.setCooldown( _narcoId ,  0 , now + (455-(5*narcoSkills[0])* 1 seconds));\n', '\n', '    // update travel stat\n', '    narcoCore.incrementStat(_narcoId, 7);\n', '    // Travel risk\n', '     uint64 bustChance=random(50+(5*narcoSkills[0])); // 0  = speed skill\n', '\n', '     if (bustChance<=bustRange){\n', '      busted(_narcoId,targetLocation,narcoWeedTotal,narcoCokeTotal);\n', '     }\n', '\n', '     NarcoArrived(targetLocation, _narcoId); // who just arrived here\n', '     NarcoLeft(sourceLocation, _narcoId); // who just left here\n', '\n', '  }\n', '\n', '  function busted(uint256 _narcoId, uint256 targetLocation, uint256 narcoWeedTotal, uint256 narcoCokeTotal) private  {\n', '       uint256 bustedWeed=narcoWeedTotal/2; // %50\n', '       uint256 bustedCoke=narcoCokeTotal/2; // %50\n', '       districts[targetLocation].weedAmountHere -= bustedWeed; // smeti fix\n', '       districts[targetLocation].cokeAmountHere -= bustedCoke; // smeti fix\n', '       districts[7].weedAmountHere += bustedWeed; // smeti fix\n', '       districts[7].cokeAmountHere += bustedCoke; // smeti fix\n', '       narcoCore.updateWeedTotal(_narcoId, false, uint16(bustedWeed)); // 50% weed\n', '       narcoCore.updateCokeTotal(_narcoId, false, uint16(bustedCoke)); // 50% coke\n', '       narcoCore.updateWeedTotal(0, true, uint16(bustedWeed)); // 50% weed confiscated into office lardass\n', '       narcoCore.updateCokeTotal(0, true, uint16(bustedCoke)); // 50% coke confiscated into office lardass\n', '       TravelBust(_narcoId, uint16(bustedWeed), uint16(bustedCoke));\n', '  }\n', '\n', '\n', '  function hijack(uint256 _hijackerId, uint256 _victimId)  public payable whenNotPaused{\n', '    require(narcoCore.ownerOf(_hijackerId) == msg.sender); // must be owner\n', '    require(msg.value >= hijackPrice);\n', '\n', '    // has the victim escaped?\n', '    if (getNarcoLocation(_hijackerId)!=getNarcoLocation(_victimId)){\n', '        EscapedHijack(_hijackerId, _victimId , getNarcoLocation(_victimId));\n', '        narcoCore.incrementStat(_victimId, 6); // lucky escape\n', '    }else\n', '    {\n', '      // hijack calculation\n', '      uint256 hijackerWeedTotal;\n', '      uint256 hijackerCokeTotal;\n', '      uint16[6] memory hijackerSkills;\n', '      uint8[4] memory hijackerConsumables;\n', '      uint256[6] memory hijackerCooldowns;\n', '\n', '      (\n', '                  ,\n', '        hijackerWeedTotal,\n', '        hijackerCokeTotal,\n', '        hijackerSkills,\n', '        hijackerConsumables,\n', '                  ,\n', '                  ,\n', '                  ,\n', '        hijackerCooldowns,\n', '                  ,\n', '      ) = narcoCore.getNarco(_hijackerId);\n', '\n', '      // does hijacker have capacity to carry any loot?\n', '\n', '      uint256 victimWeedTotal;\n', '      uint256 victimCokeTotal;\n', '      uint16[6] memory victimSkills;\n', '      uint256[6] memory victimCooldowns;\n', '      uint8 victimHomeLocation;\n', '      (\n', '                  ,\n', '        victimWeedTotal,\n', '        victimCokeTotal,\n', '        victimSkills,\n', '                  ,\n', '                  ,\n', '       victimHomeLocation,\n', '                  ,\n', '        victimCooldowns,\n', '                  ,\n', '      ) = narcoCore.getNarco(_victimId);\n', '\n', '      // victim is not in home location , or is officer lardass\n', '      require(getNarcoLocation(_victimId)!=victimHomeLocation || _victimId==0);\n', '      require(hijackerConsumables[3] >0); // narco has ammo\n', '\n', '      require(now>hijackerCooldowns[3]); // must be outside cooldown\n', '\n', '      // consume the ammo\n', '      narcoCore.updateConsumable(_hijackerId, 3 , hijackerConsumables[3]-1);\n', '      // attempt the hijack\n', '\n', '      // 3 = attackIndex\n', '      // 4 = defenseIndex\n', '\n', '      if (uint8(random((hijackerSkills[3]+victimSkills[4]))+1) >victimSkills[4]) {\n', '        // successful hijacking\n', '\n', '        doHijack(_hijackerId  , _victimId , victimWeedTotal , victimCokeTotal);\n', '\n', '        // heist character\n', '        if (_victimId==0){\n', '             narcoCore.incrementStat(_hijackerId, 5); // raidSuccessful\n', '        }\n', '\n', '      }else{\n', '        // successfully defended\n', '        narcoCore.incrementStat(_victimId, 4); // defendedSuccessfully\n', '        HijackDefended( _hijackerId,_victimId);\n', '      }\n', '\n', '    } // end if escaped\n', '\n', '    //narcoCore.setCooldown( _hijackerId ,  3 , now + min(3 minutes,(455-(5*hijackerSkills[3])* 1 seconds))); // cooldown\n', '     narcoCore.setCooldown( _hijackerId ,  3 , now + (455-(5*hijackerSkills[3])* 1 seconds)); // cooldown\n', '\n', '      // distribute the hijack revenue\n', '      _distributeRevenue(hijackPrice, getNarcoLocation(_hijackerId) , 50, 50);\n', '\n', '  } // end hijack function\n', '\n', '  function doHijack(uint256 _hijackerId  , uint256 _victimId ,  uint256 victimWeedTotal , uint256 victimCokeTotal) private {\n', '\n', '        uint256 hijackerCapacity =  narcoCore.getRemainingCapacity(_hijackerId);\n', '\n', '        // fill pockets starting with coke\n', '        uint16 stolenCoke = uint16(min(hijackerCapacity , (victimCokeTotal/2))); // steal 50%\n', '        uint16 stolenWeed = uint16(min(hijackerCapacity - stolenCoke, (victimWeedTotal/2))); // steal 50%\n', '\n', '        // 50% chance to start with weed\n', '        if (random(100)>50){\n', '           stolenWeed = uint16(min(hijackerCapacity , (victimWeedTotal/2))); // steal 50%\n', '           stolenCoke = uint16(min(hijackerCapacity - stolenWeed, (victimCokeTotal/2))); // steal 50\n', '        }\n', '\n', '        // steal some loot this calculation tbd\n', '        // for now just take all coke / weed\n', '        if (stolenWeed>0){\n', '          narcoCore.updateWeedTotal(_hijackerId, true, stolenWeed);\n', '          narcoCore.updateWeedTotal(_victimId,false, stolenWeed);\n', '        }\n', '        if (stolenCoke>0){\n', '          narcoCore.updateCokeTotal(_hijackerId, true , stolenCoke);\n', '          narcoCore.updateCokeTotal(_victimId,false, stolenCoke);\n', '        }\n', '\n', '        narcoCore.incrementStat(_hijackerId, 3); // hijackSuccessful\n', '        Hijacked(_hijackerId, _victimId , stolenWeed, stolenCoke);\n', '\n', '\n', '  }\n', '\n', '\n', '  // pseudo random - but does that matter?\n', '  uint64 _seed = 0;\n', '  function random(uint64 upper) private returns (uint64 randomNumber) {\n', '     _seed = uint64(keccak256(keccak256(block.blockhash(block.number-1), _seed), now));\n', '     return _seed % upper;\n', '   }\n', '\n', '   function min(uint a, uint b) private pure returns (uint) {\n', '            return a < b ? a : b;\n', '   }\n', '   function max(uint a, uint b) private pure returns (uint) {\n', '            return a > b ? a : b;\n', '   }\n', '\n', '  // never call this from a contract\n', '  /// @param _loc that we are interested in\n', '  function narcosByDistrict(uint8 _loc) public view returns(uint256[] narcosHere) {\n', '    uint256 tokenCount = numberOfNarcosByDistrict(_loc);\n', '    uint256 totalNarcos = narcoCore.totalSupply();\n', '    uint256[] memory result = new uint256[](tokenCount);\n', '    uint256 narcoId;\n', '    uint256 resultIndex = 0;\n', '    for (narcoId = 0; narcoId <= totalNarcos; narcoId++) {\n', '      if (getNarcoLocation(narcoId) == _loc) {\n', '        result[resultIndex] = narcoId;\n', '        resultIndex++;\n', '      }\n', '    }\n', '    return result;\n', '  }\n', '\n', '  function numberOfNarcosByDistrict(uint8 _loc) public view returns(uint256 number) {\n', '    uint256 count = 0;\n', '    uint256 narcoId;\n', '    for (narcoId = 0; narcoId <= narcoCore.totalSupply(); narcoId++) {\n', '      if (getNarcoLocation(narcoId) == _loc) {\n', '        count++;\n', '      }\n', '    }\n', '    return count;\n', '  }\n', '\n', '}']
