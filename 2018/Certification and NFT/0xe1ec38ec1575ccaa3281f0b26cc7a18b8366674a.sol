['pragma solidity ^0.4.24;\n', '\n', '// TokenLoot v2.0 2e59d4\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/TokenLoot.sol\n', '\n', '/// @title Token Loot Contract\n', '/// @author Julia Altenried, Yuriy Kashnikov\n', '\n', 'contract TokenLoot is Ownable {\n', '\n', '  // FIELDS\n', '  /* signer address, verified in &#39;receiveTokenLoot&#39; method, can be set by owner only */\n', '  address public neverdieSigner;\n', '  /* Nonces */\n', '  mapping (address => uint256) public nonces;\n', '  /* Tokens */\n', '  address[] public tokens;\n', '\n', '  // EVENTS\n', '  event ReceiveLoot(address indexed sender,\n', '                    uint256 nonce,\n', '                    address[] tokens,\n', '                    uint256[] amounts);\n', ' \n', '\n', '  // SETTERS\n', '  function setNeverdieSignerAddress(address _to) public onlyOwner {\n', '    neverdieSigner = _to;\n', '  }\n', '\n', '  function setTokens(address[] _tokens) public onlyOwner {\n', '    for (uint256 i = 0; i < tokens.length; i++) {\n', '      tokens[i] = _tokens[i];\n', '    }\n', '    for (uint256 j = _tokens.length; j < _tokens.length; j++) {\n', '      tokens.push(_tokens[j]);\n', '    }\n', '  }\n', '\n', '  /// @param _tokens tokens addresses\n', '  /// @param _signer signer address, verified further in swap functions\n', '  constructor(address[] _tokens, address _signer) {\n', '    for (uint256 i = 0; i < _tokens.length; i++) {\n', '      tokens.push(_tokens[i]);\n', '    }\n', '    neverdieSigner = _signer;\n', '  }\n', '\n', '  function receiveTokenLoot(uint256[] _amounts, \n', '                            uint256 _nonce, \n', '                            uint8 _v, \n', '                            bytes32 _r, \n', '                            bytes32 _s) {\n', '\n', '    // reject if the new nonce is lower or equal to the current one\n', '    require(_nonce > nonces[msg.sender],\n', '            "wrong nonce");\n', '    nonces[msg.sender] = _nonce;\n', '\n', '    // verify signature\n', '    address signer = ecrecover(keccak256(msg.sender, \n', '                                         _nonce,\n', '                                         _amounts), _v, _r, _s);\n', '    require(signer == neverdieSigner,\n', '            "signature verification failed");\n', '\n', '    // transer tokens\n', '    \n', '    for (uint256 i = 0; i < _amounts.length; i++) {\n', '      if (_amounts[i] > 0) {\n', '        assert(ERC20(tokens[i]).transfer(msg.sender, _amounts[i]));\n', '      }\n', '    }\n', '    \n', '\n', '    // emit event\n', '    ReceiveLoot(msg.sender, _nonce, tokens, _amounts);\n', '  }\n', '\n', '  /// @dev fallback function to reject any ether coming directly to the contract\n', '  function () payable public { \n', '      revert(); \n', '  }\n', '\n', '  /// @dev withdraw all SKL and XP tokens\n', '  function withdraw() public onlyOwner {\n', '    for (uint256 i = 0; i < tokens.length; i++) {\n', '      uint256 amount = ERC20(tokens[i]).balanceOf(this);\n', '      if (amount > 0) ERC20(tokens[i]).transfer(msg.sender, amount);\n', '    }\n', '  }\n', '\n', '  /// @dev kill contract, but before transfer all SKL and XP tokens \n', '  function kill() onlyOwner public {\n', '    withdraw();\n', '    selfdestruct(owner);\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// TokenLoot v2.0 2e59d4\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/TokenLoot.sol\n', '\n', '/// @title Token Loot Contract\n', '/// @author Julia Altenried, Yuriy Kashnikov\n', '\n', 'contract TokenLoot is Ownable {\n', '\n', '  // FIELDS\n', "  /* signer address, verified in 'receiveTokenLoot' method, can be set by owner only */\n", '  address public neverdieSigner;\n', '  /* Nonces */\n', '  mapping (address => uint256) public nonces;\n', '  /* Tokens */\n', '  address[] public tokens;\n', '\n', '  // EVENTS\n', '  event ReceiveLoot(address indexed sender,\n', '                    uint256 nonce,\n', '                    address[] tokens,\n', '                    uint256[] amounts);\n', ' \n', '\n', '  // SETTERS\n', '  function setNeverdieSignerAddress(address _to) public onlyOwner {\n', '    neverdieSigner = _to;\n', '  }\n', '\n', '  function setTokens(address[] _tokens) public onlyOwner {\n', '    for (uint256 i = 0; i < tokens.length; i++) {\n', '      tokens[i] = _tokens[i];\n', '    }\n', '    for (uint256 j = _tokens.length; j < _tokens.length; j++) {\n', '      tokens.push(_tokens[j]);\n', '    }\n', '  }\n', '\n', '  /// @param _tokens tokens addresses\n', '  /// @param _signer signer address, verified further in swap functions\n', '  constructor(address[] _tokens, address _signer) {\n', '    for (uint256 i = 0; i < _tokens.length; i++) {\n', '      tokens.push(_tokens[i]);\n', '    }\n', '    neverdieSigner = _signer;\n', '  }\n', '\n', '  function receiveTokenLoot(uint256[] _amounts, \n', '                            uint256 _nonce, \n', '                            uint8 _v, \n', '                            bytes32 _r, \n', '                            bytes32 _s) {\n', '\n', '    // reject if the new nonce is lower or equal to the current one\n', '    require(_nonce > nonces[msg.sender],\n', '            "wrong nonce");\n', '    nonces[msg.sender] = _nonce;\n', '\n', '    // verify signature\n', '    address signer = ecrecover(keccak256(msg.sender, \n', '                                         _nonce,\n', '                                         _amounts), _v, _r, _s);\n', '    require(signer == neverdieSigner,\n', '            "signature verification failed");\n', '\n', '    // transer tokens\n', '    \n', '    for (uint256 i = 0; i < _amounts.length; i++) {\n', '      if (_amounts[i] > 0) {\n', '        assert(ERC20(tokens[i]).transfer(msg.sender, _amounts[i]));\n', '      }\n', '    }\n', '    \n', '\n', '    // emit event\n', '    ReceiveLoot(msg.sender, _nonce, tokens, _amounts);\n', '  }\n', '\n', '  /// @dev fallback function to reject any ether coming directly to the contract\n', '  function () payable public { \n', '      revert(); \n', '  }\n', '\n', '  /// @dev withdraw all SKL and XP tokens\n', '  function withdraw() public onlyOwner {\n', '    for (uint256 i = 0; i < tokens.length; i++) {\n', '      uint256 amount = ERC20(tokens[i]).balanceOf(this);\n', '      if (amount > 0) ERC20(tokens[i]).transfer(msg.sender, amount);\n', '    }\n', '  }\n', '\n', '  /// @dev kill contract, but before transfer all SKL and XP tokens \n', '  function kill() onlyOwner public {\n', '    withdraw();\n', '    selfdestruct(owner);\n', '  }\n', '\n', '}']
