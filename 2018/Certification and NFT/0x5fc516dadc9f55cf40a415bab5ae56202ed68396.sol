['pragma solidity ^0.4.21;\n', '\n', '/*  ChiMarket is a contract that allows for buying and selling of CHI tokens for\n', '    used in the Aethia game (see https://aethia.co). The contract is designed to\n', '    discover the price of CHI (in ETH) through market forces (i.e. supply and\n', '    demand). The contract dynamically determines the price for each trade such that\n', '    the value of ETH and the value of CHI held by the contract are always the same.\n', '    \n', '    This mechanism guarantees that you can always buy and sell any amount of CHI,\n', '    although the price might be outrageously high or low, depending on the amount\n', '    you are trying to buy/sell.\n', '    \n', '    The contract provides to functions that can be used to query how much ETH\n', '    the contract is willing to pay for your CHI, or how much ETH you&#39;ll need to \n', '    buy CHI. You can call those functions without generating a transaction,\n', '    for example in the "Read Smart Contract" tab on Etherscan. This will give \n', '    you an estimate only, because the price might change by the time your TX confirms. \n', '    To avoid price surprises, this contract only supports limit buy and sells.\n', '    \n', '    Limit buy and sell functions are used to convert CHI/ETH into ETH/CHI. limitSell\n', '    also takes a limit argument, which is the lowest amount of ETH you are willing\n', '    to accept for your trade. On the buy side, you should send more ETH than rrequired\n', '    to provide a cushin. You will always get the exact current price, the \n', '    limit argument is just to provide safety in case price changes dramatically.\n', '    If you send extra ETH, the excess will be returned to you in the same TX.\n', '*/\n', '\n', '// Interface to ERC721 functions used in this contract\n', 'interface ERC20token {\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '}\n', '// Interface to ERC721 functions used in this contract\n', 'interface ERC721Token {\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '}\n', '\n', 'contract ChiMarket {\n', '    ERC20token ChiToken = ERC20token(0x71E1f8E809Dc8911FCAC95043bC94929a36505A5);\n', '    address owner;\n', '    uint256 market_halfspread;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function ChiMarket() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // Calculate the amount of ETH the contract pays out on a SELL\n', '    function calcSELLoffer(uint256 chi_amount) public view returns(uint256){\n', '        uint256 eth_balance = address(this).balance;\n', '        uint256 chi_balance = ChiToken.balanceOf(this);\n', '        uint256 eth_amount;\n', '        require(eth_balance > 0 && chi_balance > 0);\n', '\n', '        require(chi_balance + chi_amount >= chi_balance); // don&#39;t allow overflow\n', '        eth_amount = (chi_amount * eth_balance) / (chi_balance + chi_amount);\n', '        require(1000 * eth_amount >= eth_amount); // don&#39;t allow overflow\n', '        eth_amount = ((1000 - market_halfspread) * eth_amount) / 1000;\n', '        return eth_amount;\n', '    }\n', '\n', '    // Calculate the amount of ETH the contract requires on a BUY\n', '    // When this function is called from a payable function, the balance is updated\n', '    // already, so we need to subtract it through _offset_eth. Otherwise _offset_eth\n', '    // should be set to 0.\n', '    function calcBUYoffer(uint256 _chi_amount, uint256 _offset_eth) public view returns(uint256){\n', '        require(address(this).balance > _offset_eth); // no overflow\n', '        uint256 eth_balance = address(this).balance - _offset_eth;\n', '        uint256 chi_balance = ChiToken.balanceOf(this);\n', '        uint256 eth_amount;\n', '        require(eth_balance > 0 && chi_balance > 0);\n', '        require(chi_balance > _chi_amount); // must have enough CHI\n', '        \n', '        require(chi_balance - _chi_amount <= chi_balance); // don&#39;t allow overflow\n', '        eth_amount = (_chi_amount * eth_balance) / (chi_balance - _chi_amount);\n', '        require(1000 * eth_amount >= eth_amount); // don&#39;t allow overflow\n', '        eth_amount = (1000 * eth_amount) / (1000 - market_halfspread);\n', '        return eth_amount;\n', '    }\n', '\n', '    // CHI buying function\n', '    // All of the ETH included in the TX is converted to CHI\n', '    // requires at least _min_chi_amount of CHI for that ETH, otherwise TX fails\n', '    function limitBuy(uint256 _chi_amount) public payable{\n', '        require(_chi_amount > 0);\n', '        uint256 eth_amount = calcBUYoffer(_chi_amount, msg.value);\n', '        require(eth_amount <= msg.value);\n', '        uint256 return_ETH_amount = msg.value - eth_amount;\n', '        require(return_ETH_amount < msg.value);\n', '\n', '        if(return_ETH_amount > 0){\n', '            msg.sender.transfer(return_ETH_amount); // return extra ETH\n', '        }\n', '        require(ChiToken.transfer(msg.sender, _chi_amount)); // send CHI tokens\n', '    }\n', '\n', '    // CHI selling function.\n', '    // sell _chi_amount of CHI\n', '    // require at least _min_eth_amount for that CHI, otherwise TX fails\n', '    // Make sure to set CHI allowance before calling this function\n', '    function limitSell(uint256 _chi_amount, uint256 _min_eth_amount) public {\n', '        require(ChiToken.allowance(msg.sender, this) >= _chi_amount);\n', '        uint256 eth_amount = calcSELLoffer(_chi_amount);\n', '        require(eth_amount >= _min_eth_amount);\n', '        require(eth_amount > 0);\n', '\n', '        require(ChiToken.transferFrom(msg.sender, this, _chi_amount));\n', '        msg.sender.transfer(eth_amount);\n', '    }\n', '\n', '    // Allows owner to move CHI (e.g. to an updated contract), also to rescue \n', '    // other ERC20 tokens sent by mistake.    \n', '    function moveERC20Tokens(address _tokenContract, address _to, uint _val) public onlyOwner {\n', '        ERC20token token = ERC20token(_tokenContract);\n', '        require(token.transfer(_to, _val));\n', '    }\n', '\n', '    // Hopefully this doesn&#39;t get used, but it allows for gotchi rescue if someone sends\n', '    // their gotchi (or a cat) to the contract by mistake.\n', '    function moveERC721Tokens(address _tokenContract, address _to, uint256 _tid) public onlyOwner {\n', '        ERC721Token token = ERC721Token(_tokenContract);\n', '        token.transferFrom(this, _to, _tid);\n', '    }\n', '\n', '    // Allows the owner to move ether, for example to an updated contract  \n', '    function moveEther(address _target, uint256 _amount) public onlyOwner {\n', '        require(_amount <= address(this).balance);\n', '        _target.transfer(_amount);\n', '    }\n', '\n', '    // Set the market spread (actually it&#39;s half of the spread).    \n', '    function setSpread(uint256 _halfspread) public onlyOwner {\n', '        require(_halfspread <= 50);\n', '        market_halfspread = _halfspread;        \n', '    }\n', ' \n', '    // Allows for deposit of ETH and CHI at the same time (to avoid temporary imbalance\n', '    // in the market)\n', '    function depositBoth(uint256 _chi_amount) public payable onlyOwner {\n', '        require(ChiToken.allowance(msg.sender, this) >= _chi_amount);\n', '        require(ChiToken.transferFrom(msg.sender, this, _chi_amount));\n', '    }\n', '\n', '    // Allows for withdrawal of ETH and CHI at the same time (to avoid temporary imbalance\n', '    // in the market)\n', '    function withdrawBoth(uint256 _chi_amount, uint256 _eth_amount) public onlyOwner {\n', '        uint256 eth_balance = address(this).balance;\n', '        uint256 chi_balance = ChiToken.balanceOf(this);\n', '        require(_chi_amount <= chi_balance);\n', '        require(_eth_amount <= eth_balance);\n', '        \n', '        msg.sender.transfer(_eth_amount);\n', '        require(ChiToken.transfer(msg.sender, _chi_amount));\n', '    }\n', ' \n', '    // change the owner\n', '    function setOwner(address _owner) public onlyOwner {\n', '        owner = _owner;    \n', '    }\n', '\n', '    // empty fallback payable to allow ETH deposits to the contract    \n', '    function() public payable{\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/*  ChiMarket is a contract that allows for buying and selling of CHI tokens for\n', '    used in the Aethia game (see https://aethia.co). The contract is designed to\n', '    discover the price of CHI (in ETH) through market forces (i.e. supply and\n', '    demand). The contract dynamically determines the price for each trade such that\n', '    the value of ETH and the value of CHI held by the contract are always the same.\n', '    \n', '    This mechanism guarantees that you can always buy and sell any amount of CHI,\n', '    although the price might be outrageously high or low, depending on the amount\n', '    you are trying to buy/sell.\n', '    \n', '    The contract provides to functions that can be used to query how much ETH\n', "    the contract is willing to pay for your CHI, or how much ETH you'll need to \n", '    buy CHI. You can call those functions without generating a transaction,\n', '    for example in the "Read Smart Contract" tab on Etherscan. This will give \n', '    you an estimate only, because the price might change by the time your TX confirms. \n', '    To avoid price surprises, this contract only supports limit buy and sells.\n', '    \n', '    Limit buy and sell functions are used to convert CHI/ETH into ETH/CHI. limitSell\n', '    also takes a limit argument, which is the lowest amount of ETH you are willing\n', '    to accept for your trade. On the buy side, you should send more ETH than rrequired\n', '    to provide a cushin. You will always get the exact current price, the \n', '    limit argument is just to provide safety in case price changes dramatically.\n', '    If you send extra ETH, the excess will be returned to you in the same TX.\n', '*/\n', '\n', '// Interface to ERC721 functions used in this contract\n', 'interface ERC20token {\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '}\n', '// Interface to ERC721 functions used in this contract\n', 'interface ERC721Token {\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '}\n', '\n', 'contract ChiMarket {\n', '    ERC20token ChiToken = ERC20token(0x71E1f8E809Dc8911FCAC95043bC94929a36505A5);\n', '    address owner;\n', '    uint256 market_halfspread;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function ChiMarket() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // Calculate the amount of ETH the contract pays out on a SELL\n', '    function calcSELLoffer(uint256 chi_amount) public view returns(uint256){\n', '        uint256 eth_balance = address(this).balance;\n', '        uint256 chi_balance = ChiToken.balanceOf(this);\n', '        uint256 eth_amount;\n', '        require(eth_balance > 0 && chi_balance > 0);\n', '\n', "        require(chi_balance + chi_amount >= chi_balance); // don't allow overflow\n", '        eth_amount = (chi_amount * eth_balance) / (chi_balance + chi_amount);\n', "        require(1000 * eth_amount >= eth_amount); // don't allow overflow\n", '        eth_amount = ((1000 - market_halfspread) * eth_amount) / 1000;\n', '        return eth_amount;\n', '    }\n', '\n', '    // Calculate the amount of ETH the contract requires on a BUY\n', '    // When this function is called from a payable function, the balance is updated\n', '    // already, so we need to subtract it through _offset_eth. Otherwise _offset_eth\n', '    // should be set to 0.\n', '    function calcBUYoffer(uint256 _chi_amount, uint256 _offset_eth) public view returns(uint256){\n', '        require(address(this).balance > _offset_eth); // no overflow\n', '        uint256 eth_balance = address(this).balance - _offset_eth;\n', '        uint256 chi_balance = ChiToken.balanceOf(this);\n', '        uint256 eth_amount;\n', '        require(eth_balance > 0 && chi_balance > 0);\n', '        require(chi_balance > _chi_amount); // must have enough CHI\n', '        \n', "        require(chi_balance - _chi_amount <= chi_balance); // don't allow overflow\n", '        eth_amount = (_chi_amount * eth_balance) / (chi_balance - _chi_amount);\n', "        require(1000 * eth_amount >= eth_amount); // don't allow overflow\n", '        eth_amount = (1000 * eth_amount) / (1000 - market_halfspread);\n', '        return eth_amount;\n', '    }\n', '\n', '    // CHI buying function\n', '    // All of the ETH included in the TX is converted to CHI\n', '    // requires at least _min_chi_amount of CHI for that ETH, otherwise TX fails\n', '    function limitBuy(uint256 _chi_amount) public payable{\n', '        require(_chi_amount > 0);\n', '        uint256 eth_amount = calcBUYoffer(_chi_amount, msg.value);\n', '        require(eth_amount <= msg.value);\n', '        uint256 return_ETH_amount = msg.value - eth_amount;\n', '        require(return_ETH_amount < msg.value);\n', '\n', '        if(return_ETH_amount > 0){\n', '            msg.sender.transfer(return_ETH_amount); // return extra ETH\n', '        }\n', '        require(ChiToken.transfer(msg.sender, _chi_amount)); // send CHI tokens\n', '    }\n', '\n', '    // CHI selling function.\n', '    // sell _chi_amount of CHI\n', '    // require at least _min_eth_amount for that CHI, otherwise TX fails\n', '    // Make sure to set CHI allowance before calling this function\n', '    function limitSell(uint256 _chi_amount, uint256 _min_eth_amount) public {\n', '        require(ChiToken.allowance(msg.sender, this) >= _chi_amount);\n', '        uint256 eth_amount = calcSELLoffer(_chi_amount);\n', '        require(eth_amount >= _min_eth_amount);\n', '        require(eth_amount > 0);\n', '\n', '        require(ChiToken.transferFrom(msg.sender, this, _chi_amount));\n', '        msg.sender.transfer(eth_amount);\n', '    }\n', '\n', '    // Allows owner to move CHI (e.g. to an updated contract), also to rescue \n', '    // other ERC20 tokens sent by mistake.    \n', '    function moveERC20Tokens(address _tokenContract, address _to, uint _val) public onlyOwner {\n', '        ERC20token token = ERC20token(_tokenContract);\n', '        require(token.transfer(_to, _val));\n', '    }\n', '\n', "    // Hopefully this doesn't get used, but it allows for gotchi rescue if someone sends\n", '    // their gotchi (or a cat) to the contract by mistake.\n', '    function moveERC721Tokens(address _tokenContract, address _to, uint256 _tid) public onlyOwner {\n', '        ERC721Token token = ERC721Token(_tokenContract);\n', '        token.transferFrom(this, _to, _tid);\n', '    }\n', '\n', '    // Allows the owner to move ether, for example to an updated contract  \n', '    function moveEther(address _target, uint256 _amount) public onlyOwner {\n', '        require(_amount <= address(this).balance);\n', '        _target.transfer(_amount);\n', '    }\n', '\n', "    // Set the market spread (actually it's half of the spread).    \n", '    function setSpread(uint256 _halfspread) public onlyOwner {\n', '        require(_halfspread <= 50);\n', '        market_halfspread = _halfspread;        \n', '    }\n', ' \n', '    // Allows for deposit of ETH and CHI at the same time (to avoid temporary imbalance\n', '    // in the market)\n', '    function depositBoth(uint256 _chi_amount) public payable onlyOwner {\n', '        require(ChiToken.allowance(msg.sender, this) >= _chi_amount);\n', '        require(ChiToken.transferFrom(msg.sender, this, _chi_amount));\n', '    }\n', '\n', '    // Allows for withdrawal of ETH and CHI at the same time (to avoid temporary imbalance\n', '    // in the market)\n', '    function withdrawBoth(uint256 _chi_amount, uint256 _eth_amount) public onlyOwner {\n', '        uint256 eth_balance = address(this).balance;\n', '        uint256 chi_balance = ChiToken.balanceOf(this);\n', '        require(_chi_amount <= chi_balance);\n', '        require(_eth_amount <= eth_balance);\n', '        \n', '        msg.sender.transfer(_eth_amount);\n', '        require(ChiToken.transfer(msg.sender, _chi_amount));\n', '    }\n', ' \n', '    // change the owner\n', '    function setOwner(address _owner) public onlyOwner {\n', '        owner = _owner;    \n', '    }\n', '\n', '    // empty fallback payable to allow ETH deposits to the contract    \n', '    function() public payable{\n', '    }\n', '}']
