['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    \n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title EjectableOwnable\n', ' * @dev The EjectableOwnable contract provides the function to remove the ownership of the contract.\n', ' */\n', 'contract EjectableOwnable is Ownable {\n', '    \n', '    /**\n', '     * @dev Remove the ownership by setting the owner address to null, \n', '     * after calling this function, all onlyOwner function will be be able to be called by anyone anymore, \n', '     * the contract will achieve truly decentralisation.\n', '    */\n', '    function removeOwnership() onlyOwner public {\n', '        owner = 0x0;\n', '    }\n', '    \n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    \n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '  \n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  \n', '}\n', '\n', '\n', '/**\n', ' * @title PullPayment\n', ' * @dev Base contract supporting async send for pull payments. Inherit from this\n', ' * contract and use asyncSend instead of send.\n', ' */\n', 'contract PullPayment {\n', '    \n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) public payments;\n', '  uint256 public totalPayments;\n', '\n', '  /**\n', '   * @dev withdraw accumulated balance, called by payee.\n', '   */\n', '  function withdrawPayments() public {\n', '    address payee = msg.sender;\n', '    uint256 payment = payments[payee];\n', '\n', '    require(payment != 0);\n', '    require(this.balance >= payment);\n', '\n', '    totalPayments = totalPayments.sub(payment);\n', '    payments[payee] = 0;\n', '\n', '    assert(payee.send(payment));\n', '  }\n', '\n', '  /**\n', '   * @dev Called by the payer to store the sent amount as credit to be pulled.\n', '   * @param dest The destination address of the funds.\n', '   * @param amount The amount to transfer.\n', '   */\n', '  function asyncSend(address dest, uint256 amount) internal {\n', '    payments[dest] = payments[dest].add(amount);\n', '    totalPayments = totalPayments.add(amount);\n', '  }\n', '  \n', '}\n', '\n', '\n', '/**\n', ' * @title Destructible\n', ' * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n', ' */\n', 'contract Destructible is Ownable {\n', '\n', '  function Destructible() public payable { }\n', '\n', '  /**\n', '   * @dev Transfers the current balance to the owner and terminates the contract.\n', '   */\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function destroyAndSend(address _recipient) onlyOwner public {\n', '    selfdestruct(_recipient);\n', '  }\n', '  \n', '}\n', '\n', '\n', 'contract EDStructs {\n', '    \n', '    /**\n', '     * @dev The main Dungeon struct. Every dungeon in the game is represented by this structure.\n', '     * A dungeon is consists of an unlimited number of floors for your heroes to challenge, \n', '     * the power level of a dungeon is encoded in the floorGenes. Some dungeons are in fact more "challenging" than others,\n', '     * the secret formula for that is left for user to find out.\n', '     * \n', '     * Each dungeon also has a "training area", heroes can perform trainings and upgrade their stat,\n', '     * and some dungeons are more effective in the training, which is also a secret formula!\n', '     * \n', '     * When player challenge or do training in a dungeon, the fee will be collected as the dungeon rewards,\n', '     * which will be rewarded to the player who successfully challenged the current floor.\n', '     * \n', '     * Each dungeon fits in fits into three 256-bit words.\n', '     */\n', '    struct Dungeon {\n', '        \n', '        // Each dungeon has an ID which is the index in the storage array.\n', '\n', '        // The timestamp of the block when this dungeon is created.\n', '        uint32 creationTime;\n', '        \n', '        // The status of the dungeon, each dungeon can have 5 status, namely:\n', '        // 0: Active | 1: Transport Only | 2: Challenge Only | 3: Train Only | 4: InActive\n', '        uint8 status;\n', '        \n', '        // The dungeon&#39;s difficulty, the higher the difficulty, \n', '        // normally, the "rarer" the seedGenes, the higher the diffculty,\n', '        // and the higher the contribution fee it is to challenge, train, and transport to the dungeon,\n', '        // the formula for the contribution fee is in DungeonChallenge and DungeonTraining contracts.\n', '        // A dungeon&#39;s difficulty never change.\n', '        uint8 difficulty;\n', '        \n', '        // The dungeon&#39;s capacity, maximum number of players allowed to stay on this dungeon.\n', '        // The capacity of the newbie dungeon (Holyland) is set at 0 (which is infinity).\n', '        // Using 16-bit unsigned integers can have a maximum of 65535 in capacity.\n', '        // A dungeon&#39;s capacity never change.\n', '        uint16 capacity;\n', '        \n', '        // The current floor number, a dungeon is consists of an umlimited number of floors,\n', '        // when there is heroes successfully challenged a floor, the next floor will be\n', '        // automatically generated. Using 32-bit unsigned integer can have a maximum of 4 billion floors.\n', '        uint32 floorNumber;\n', '        \n', '        // The timestamp of the block when the current floor is generated.\n', '        uint32 floorCreationTime;\n', '        \n', '        // Current accumulated rewards, successful challenger will get a large proportion of it.\n', '        uint128 rewards;\n', '        \n', '        // The seed genes of the dungeon, it is used as the base gene for first floor, \n', '        // some dungeons are rarer and some are more common, the exact details are, \n', '        // of course, top secret of the game! \n', '        // A dungeon&#39;s seedGenes never change.\n', '        uint seedGenes;\n', '        \n', '        // The genes for current floor, it encodes the difficulty level of the current floor.\n', '        // We considered whether to store the entire array of genes for all floors, but\n', '        // in order to save some precious gas we&#39;re willing to sacrifice some functionalities with that.\n', '        uint floorGenes;\n', '        \n', '    }\n', '    \n', '    /**\n', '     * @dev The main Hero struct. Every hero in the game is represented by this structure.\n', '     */\n', '    struct Hero {\n', '\n', '        // Each hero has an ID which is the index in the storage array.\n', '        \n', '        // The timestamp of the block when this dungeon is created.\n', '        uint64 creationTime;\n', '        \n', '        // The timestamp of the block where a challenge is performed, used to calculate when a hero is allowed to engage in another challenge.\n', '        uint64 cooldownStartTime;\n', '        \n', '        // Every time a hero challenge a dungeon, its cooldown index will be incremented by one.\n', '        uint32 cooldownIndex;\n', '        \n', '        // The seed of the hero, the gene encodes the power level of the hero.\n', '        // This is another top secret of the game! Hero&#39;s gene can be upgraded via\n', '        // training in a dungeon.\n', '        uint genes;\n', '        \n', '    }\n', '    \n', '}\n', '\n', '\n', '/**\n', ' * @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens.\n', ' */\n', 'contract ERC721 {\n', '    \n', '    // Events\n', '    event Transfer(address indexed from, address indexed to, uint indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint indexed tokenId);\n', '    \n', '    // ERC20 compatible functions.\n', '    // function name() public constant returns (string);\n', '    // function symbol() public constant returns (string);\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address _owner) public view returns (uint);\n', '    \n', '    // Functions that define ownership.\n', '    function ownerOf(uint _tokenId) external view returns (address);\n', '    function transfer(address _to, uint _tokenId) external;\n', '    \n', '    // Approval related functions, mainly used in auction contracts.\n', '    function approve(address _to, uint _tokenId) external;\n', '    function approvedFor(uint _tokenId) external view returns (address);\n', '    function transferFrom(address _from, address _to, uint _tokenId) external;\n', '    \n', '    /**\n', '     * @dev Each non-fungible token owner can own more than one token at one time. \n', '     * Because each token is referenced by its unique ID, however, \n', '     * it can get difficult to keep track of the individual tokens that a user may own. \n', '     * To do this, the contract keeps a record of the IDs of each token that each user owns.\n', '     */\n', '    mapping(address => uint[]) public ownerTokens;\n', '\n', '}\n', '\n', '\n', 'contract DungeonTokenInterface is ERC721, EDStructs {\n', '\n', '    /**\n', '     * @notice Limits the number of dungeons the contract owner can ever create.\n', '     */\n', '    uint public constant DUNGEON_CREATION_LIMIT = 1024;\n', '    \n', '    /**\n', '     * @dev Name of token.\n', '     */\n', '    string public constant name = "Dungeon";\n', '    \n', '    /**\n', '     * @dev Symbol of token.\n', '     */\n', '    string public constant symbol = "DUNG";\n', '    \n', '    /**\n', '     * @dev An array containing the Dungeon struct, which contains all the dungeons in existance.\n', '     *  The ID for each dungeon is the index of this array.\n', '     */ \n', '    Dungeon[] public dungeons;\n', '\n', '    /**\n', '     * @dev The external function that creates a new dungeon and stores it, only contract owners\n', '     *  can create new token, and will be restricted by the DUNGEON_CREATION_LIMIT.\n', '     *  Will generate a Mint event, a  NewDungeonFloor event, and a Transfer event.\n', '     */ \n', '    function createDungeon(uint _difficulty, uint _capacity, uint _floorNumber, uint _seedGenes, uint _floorGenes, address _owner) external returns (uint);\n', '    \n', '    /**\n', '     * @dev The external function to set dungeon status by its ID, \n', '     *  refer to DungeonStructs for more information about dungeon status.\n', '     *  Only contract owners can alter dungeon state.\n', '     */ \n', '    function setDungeonStatus(uint _id, uint _newStatus) external;\n', '    \n', '    /**\n', '     * @dev The external function to add additional dungeon rewards by its ID, \n', '     *  only contract owners can alter dungeon state.\n', '     */ \n', '    function addDungeonRewards(uint _id, uint _additinalRewards) external;\n', '    \n', '    /**\n', '     * @dev The external function to add another dungeon floor by its ID, \n', '     *  only contract owners can alter dungeon state.\n', '     */ \n', '    function addDungeonNewFloor(uint _id, uint _newRewards, uint _newFloorGenes) external;\n', '    \n', '}\n', '\n', '\n', 'contract HeroTokenInterface is ERC721, EDStructs {\n', '    \n', '    /**\n', '     * @dev Name of token.\n', '     */\n', '    string public constant name = "Hero";\n', '    \n', '    /**\n', '     * @dev Symbol of token.\n', '     */\n', '    string public constant symbol = "HERO";\n', '\n', '    /**\n', '     * @dev An array containing the Hero struct, which contains all the heroes in existance.\n', '     *  The ID for each hero is the index of this array.\n', '     */ \n', '    Hero[] public heroes;\n', '\n', '    /**\n', '     * @dev An external function that creates a new hero and stores it,\n', '     *  only contract owners can create new token.\n', '     *  method doesn&#39;t do any checking and should only be called when the\n', '     *  input data is known to be valid.\n', '     * @param _genes The gene of the new hero.\n', '     * @param _owner The inital owner of this hero.\n', '     * @return The hero ID of the new hero.\n', '     */\n', '    function createHero(uint _genes, address _owner) external returns (uint);\n', '    \n', '    /**\n', '     * @dev The external function to set the hero genes by its ID, \n', '     *  only contract owners can alter hero state.\n', '     */ \n', '    function setHeroGenes(uint _id, uint _newGenes) external;\n', '\n', '    /**\n', '     * @dev Set the cooldownStartTime for the given hero. Also increments the cooldownIndex.\n', '     */\n', '    function triggerCooldown(uint _id) external;\n', '    \n', '}\n', '\n', '\n', '/**\n', ' * SECRET\n', ' */\n', 'contract ChallengeFormulaInterface {\n', '    \n', '    /**\n', '     * @dev given genes of current floor and dungeon seed, return a genetic combination - may have a random factor.\n', '     * @param _floorGenes Genes of floor.\n', '     * @param _seedGenes Seed genes of dungeon.\n', '     * @return The resulting genes.\n', '     */\n', '    function calculateResult(uint _floorGenes, uint _seedGenes) external returns (uint);\n', '    \n', '}\n', '\n', '\n', '/**\n', ' * SECRET\n', ' */\n', 'contract TrainingFormulaInterface {\n', '    \n', '    /**\n', '     * @dev given genes of hero and current floor, return a genetic combination - may have a random factor.\n', '     * @param _heroGenes Genes of hero.\n', '     * @param _floorGenes Genes of current floor.\n', '     * @param _equipmentId Equipment index to train for, 0 is train all attributes.\n', '     * @return The resulting genes.\n', '     */\n', '    function calculateResult(uint _heroGenes, uint _floorGenes, uint _equipmentId) external returns (uint);\n', '    \n', '}\n', '\n', '\n', '/**\n', ' * @title EDBase\n', ' * @dev Base contract for Ether Dungeon. It implements all necessary sub-classes,\n', ' *  holds all the contracts, constants, game settings, storage variables, events, and some commonly used functions.\n', ' */\n', 'contract EDBase is EjectableOwnable, Pausable, PullPayment, EDStructs {\n', '    \n', '    /* ======== CONTRACTS ======== */\n', '    \n', '    /// @dev The address of the ERC721 token contract managing all Dungeon tokens.\n', '    DungeonTokenInterface public dungeonTokenContract;\n', '    \n', '    /// @dev The address of the ERC721 token contract managing all Hero tokens.\n', '    HeroTokenInterface public heroTokenContract;\n', '    \n', '    /// @dev The address of the ChallengeFormula contract that handles the floor generation mechanics after challenge success.\n', '    ChallengeFormulaInterface challengeFormulaContract;\n', '    \n', '    /// @dev The address of the TrainingFormula contract that handles the hero training mechanics.\n', '    TrainingFormulaInterface trainingFormulaContract;\n', '    \n', '    \n', '    /* ======== CONSTANTS / GAME SETTINGS (all variables are set to constant in order to save gas) ======== */\n', '    \n', '    // 1 finney = 0.001 ether\n', '    // 1 szabo = 0.001 finney\n', '    \n', '    /// @dev Super Hero (full set of same-themed Rare Equipments, there are 8 in total)\n', '    uint public constant SUPER_HERO_MULTIPLIER = 32;\n', '    \n', '    /// @dev Ultra Hero (full set of same-themed Epic Equipments, there are 4 in total)\n', '    uint public constant ULTRA_HERO_MULTIPLIER = 64;\n', '    \n', '    /**\n', '     * @dev Mega Hero (full set of same-themed Legendary Equipments, there are 2 in total)\n', '     *  There are also 2 Ultimate Hero/Demon, Pangu and Chaos, which will use the MEGA_HERO_MULTIPLIER.\n', '     */\n', '    uint public constant MEGA_HERO_MULTIPLIER = 96;\n', '    \n', '    /// @dev The fee for recruiting a hero. The payment is accumulated to the rewards of the origin dungeon.\n', '    uint public recruitHeroFee = 2 finney;\n', '    \n', '    /**\n', '     * @dev The actual fee contribution required to call transport() is calculated by this feeMultiplier,\n', '     *  times the dungeon difficulty of destination dungeon. The payment is accumulated to the rewards of the origin dungeon,\n', '     *  and a large proportion will be claimed by whoever successfully challenged the floor.\n', '     */\n', '    uint public transportationFeeMultiplier = 250 szabo;\n', '    \n', '    ///@dev All hero starts in the novice dungeon, also hero can only be recruited in novice dungoen.\n', '    uint public noviceDungeonId = 31; // < dungeon ID 31 = Abyss\n', '    \n', '    /// @dev Amount of faith required to claim a portion of the grandConsolationRewards.\n', '    uint public consolationRewardsRequiredFaith = 100;\n', '    \n', '    /// @dev The percentage for which when a player can get from the grandConsolationRewards when meeting the faith requirement.\n', '    uint public consolationRewardsClaimPercent = 50;\n', '    \n', '    /**\n', '     * @dev The actual fee contribution required to call challenge() is calculated by this feeMultiplier,\n', '     *  times the dungeon difficulty. The payment is accumulated to the dungeon rewards, \n', '     *  and a large proportion will be claimed by whoever successfully challenged the floor.\n', '     */\n', '    uint public constant challengeFeeMultiplier = 1 finney;\n', '    \n', '    /**\n', '     * @dev The percentage for which successful challenger be rewarded of the dungeons&#39; accumulated rewards.\n', '     *  The remaining rewards subtract dungeon master rewards and consolation rewards will be used as the base rewards for new floor.\n', '     */\n', '    uint public constant challengeRewardsPercent = 45;\n', '    \n', '    /**\n', '     * @dev The developer fee for dungeon master (owner of the dungeon token).\n', '     *  Note that when Ether Dungeon becomes truly decentralised, contract ownership will be ejected,\n', '     *  and the master rewards will be rewarded to the dungeon owner (Dungeon Masters).\n', '     */\n', '    uint public constant masterRewardsPercent = 8;\n', '    \n', '    /// @dev The percentage for which the challenge rewards is added to the grandConsolationRewards.\n', '    uint public consolationRewardsPercent = 2;\n', '    \n', '    /// @dev The preparation time period where a new dungeon is created, before it can be challenged.\n', '    uint public dungeonPreparationTime = 60 minutes;\n', '    \n', '    /// @dev The challenge rewards percentage used right after the preparation period.\n', '    uint public constant rushTimeChallengeRewardsPercent = 22;\n', '    \n', '    /// @dev The number of floor in which the rushTimeChallengeRewardsPercent be applied.\n', '    uint public constant rushTimeFloorCount = 30;\n', '    \n', '    /**\n', '     * @dev The actual fee contribution required to call trainX() is calculated by this feeMultiplier,\n', '     *  times the dungeon difficulty, times training times. The payment is accumulated to the dungeon rewards, \n', '     *  and a large proportion will be claimed by whoever successfully challenged the floor.\n', '     */\n', '    uint public trainingFeeMultiplier = 2 finney;\n', '    \n', '    /**\n', '     * @dev The actual fee contribution required to call trainEquipment() is calculated by this feeMultiplier,\n', '     *  times the dungeon difficulty. The payment is accumulated to the dungeon rewards.\n', '     *  (No preparation period discount on equipment training.)\n', '     */\n', '    uint public equipmentTrainingFeeMultiplier = 8 finney;\n', '    \n', '    /// @dev The discounted training fee multiplier to be used during preparation period.\n', '    uint public constant preparationPeriodTrainingFeeMultiplier = 1600 szabo;\n', '    \n', '    /// @dev The discounted equipment training fee multiplier to be used during preparation period.\n', '    uint public constant preparationPeriodEquipmentTrainingFeeMultiplier = 6400 szabo;\n', '    \n', '    \n', '    /* ======== STATE VARIABLES ======== */\n', '    \n', '    /**\n', '     * @dev After each successful training, do not update Hero immediately to avoid exploit.\n', '     *  The hero power will be auto updated during next challenge/training for any player.\n', '     *  Or calling the setTempHeroPower() public function directly.\n', '     */\n', '    mapping(address => uint) playerToLastActionBlockNumber;\n', '    uint tempSuccessTrainingHeroId;\n', '    uint tempSuccessTrainingNewHeroGenes = 1; // value 1 is used as no pending update\n', '    \n', '    /// @dev The total accumulated consolidation jackpot / rewards amount.\n', '    uint public grandConsolationRewards = 168203010964693559; // < migrated from previous contract\n', '    \n', '    /// @dev A mapping from token IDs to the address that owns them, the value can get by getPlayerDetails.\n', '    mapping(address => uint) playerToDungeonID;\n', '    \n', '    /// @dev A mapping from player address to the player&#39;s faith value, the value can get by getPlayerDetails.\n', '    mapping(address => uint) playerToFaith;\n', '\n', '    /**\n', '     * @dev A mapping from owner address to a boolean flag of whether the player recruited the first hero.\n', '     *  Note that transferring a hero from other address do not count, the value can get by getPlayerDetails.\n', '     */\n', '    mapping(address => bool) playerToFirstHeroRecruited;\n', '\n', '    /// @dev A mapping from owner address to count of tokens that address owns, the value can get by getDungeonDetails.\n', '    mapping(uint => uint) dungeonIdToPlayerCount;\n', '    \n', '    \n', '    /* ======== EVENTS ======== */\n', '    \n', '    /// @dev The PlayerTransported event is fired when user transported to another dungeon.\n', '    event PlayerTransported(uint timestamp, address indexed playerAddress, uint indexed originDungeonId, uint indexed destinationDungeonId);\n', '    \n', '    /// @dev The DungeonChallenged event is fired when user finished a dungeon challenge.\n', '    event DungeonChallenged(uint timestamp, address indexed playerAddress, uint indexed dungeonId, uint indexed heroId, uint heroGenes, uint floorNumber, uint floorGenes, bool success, uint newFloorGenes, uint successRewards, uint masterRewards);\n', '  \n', '    /// @dev The DungeonChallenged event is fired when user finished a dungeon challenge.\n', '    event ConsolationRewardsClaimed(uint timestamp, address indexed playerAddress, uint consolationRewards);\n', '  \n', '    /// @dev The HeroTrained event is fired when user finished a training.\n', '    event HeroTrained(uint timestamp, address indexed playerAddress, uint indexed dungeonId, uint indexed heroId, uint heroGenes, uint floorNumber, uint floorGenes, bool success, uint newHeroGenes);\n', '    \n', '    \n', '    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\n', '    \n', '    /**\n', '     * @dev Get the attributes (equipments + stats) of a hero from its gene.\n', '     */\n', '    function getHeroAttributes(uint _genes) public pure returns (uint[]) {\n', '        uint[] memory attributes = new uint[](12);\n', '        \n', '        for (uint i = 0; i < 12; i++) {\n', '            attributes[11 - i] = _genes % 32;\n', '            _genes /= 32 ** 4;\n', '        }\n', '        \n', '        return attributes;\n', '    }\n', '    \n', '    /**\n', '     * @dev Calculate the power of a hero from its gene,\n', '     *  it calculates the equipment power, stats power, and super hero boost.\n', '     */\n', '    function getHeroPower(uint _genes, uint _dungeonDifficulty) public pure returns (\n', '        uint totalPower, \n', '        uint equipmentPower, \n', '        uint statsPower, \n', '        bool isSuper, \n', '        uint superRank,\n', '        uint superBoost\n', '    ) {\n', '        // Individual power of each equipment.\n', '        // DUPLICATE CODE with _getDungeonPower: Constant array variable is not yet implemented,\n', '        // so need to put it here in order to save gas.\n', '        uint16[32] memory EQUIPMENT_POWERS = [\n', '            1, 2, 4, 5, 16, 17, 32, 33, // [Holy] Normal Equipments\n', '            8, 16, 16, 32, 32, 48, 64, 96, // [Myth] Normal Equipments\n', '            \n', '            4, 16, 32, 64, // [Holy] Rare Equipments\n', '            32, 48, 80, 128, // [Myth] Rare Equipments\n', '            \n', '            32, 96, // [Holy] Epic Equipments\n', '            80, 192, // [Myth] Epic Equipments\n', '            \n', '            192, // [Holy] Legendary Equipments\n', '            288, // [Myth] Legendary Equipments\n', '            \n', '            // Pangu / Chaos Legendary Equipments are reserved for far future use.\n', '            // Their existence is still a mystery.\n', '            384, // [Pangu] Legendary Equipments\n', '            512 // [Chaos] Legendary Equipments\n', '        ];\n', '        \n', '        uint[] memory attributes = getHeroAttributes(_genes);\n', '        \n', '        // Calculate total equipment power.\n', '        superRank = attributes[0];\n', '        \n', '        for (uint i = 0; i < 8; i++) {\n', '            uint equipment = attributes[i];\n', '            equipmentPower += EQUIPMENT_POWERS[equipment];\n', '            \n', '            // If any equipment is of difference index, set superRank to 0.\n', '            if (superRank != equipment) {\n', '                superRank = 0;\n', '            }\n', '        }\n', '        \n', '        // Calculate total stats power.\n', '        for (uint j = 8; j < 12; j++) {\n', '            // Stat power is gene number + 1.\n', '            statsPower += attributes[j] + 1;\n', '        }\n', '        \n', '        // Calculate Super/Ultra/Mega Power Boost.\n', '        isSuper = superRank >= 16;\n', '        \n', '        if (superRank >= 28) { // Mega Hero\n', '            superBoost = (_dungeonDifficulty - 1) * MEGA_HERO_MULTIPLIER;\n', '        } else if (superRank >= 24) { // Ultra Hero\n', '            superBoost = (_dungeonDifficulty - 1) * ULTRA_HERO_MULTIPLIER;\n', '        } else if (superRank >= 16) { // Super Hero\n', '            superBoost = (_dungeonDifficulty - 1) * SUPER_HERO_MULTIPLIER;\n', '        }\n', '        \n', '        totalPower = statsPower + equipmentPower + superBoost;\n', '    }\n', '    \n', '    /**\n', '     * @dev Calculate the power of a dungeon floor.\n', '     */\n', '    function getDungeonPower(uint _genes) public pure returns (uint) {\n', '        // Individual power of each equipment.\n', '        // DUPLICATE CODE with getHeroPower\n', '        uint16[32] memory EQUIPMENT_POWERS = [\n', '            1, 2, 4, 5, 16, 17, 32, 33, // [Holy] Normal Equipments\n', '            8, 16, 16, 32, 32, 48, 64, 96, // [Myth] Normal Equipments\n', '            \n', '            4, 16, 32, 64, // [Holy] Rare Equipments\n', '            32, 48, 80, 128, // [Myth] Rare Equipments\n', '            \n', '            32, 96, // [Holy] Epic Equipments\n', '            80, 192, // [Myth] Epic Equipments\n', '            \n', '            192, // [Holy] Legendary Equipments\n', '            288, // [Myth] Legendary Equipments\n', '            \n', '            // Pangu / Chaos Legendary Equipments are reserved for far future use.\n', '            // Their existence is still a mystery.\n', '            384, // [Pangu] Legendary Equipments\n', '            512 // [Chaos] Legendary Equipments\n', '        ];\n', '        \n', '        // Calculate total dungeon power.\n', '        uint dungeonPower;\n', '        \n', '        for (uint j = 0; j < 12; j++) {\n', '            dungeonPower += EQUIPMENT_POWERS[_genes % 32];\n', '            _genes /= 32 ** 4;\n', '        }\n', '        \n', '        return dungeonPower;\n', '    }\n', '    \n', '    /**\n', '     * @dev Calculate the sum of top 5 heroes power a player owns.\n', '     *  The gas usage increased with the number of heroes a player owned, roughly 500 x hero count.\n', '     *  This is used in transport function only to calculate the required tranport fee.\n', '     */\n', '    function calculateTop5HeroesPower(address _address, uint _dungeonId) public view returns (uint) {\n', '        uint heroCount = heroTokenContract.balanceOf(_address);\n', '        \n', '        if (heroCount == 0) {\n', '            return 0;\n', '        }\n', '        \n', '        // Get the dungeon difficulty to factor in the super power boost when calculating hero power.\n', '        uint difficulty;\n', '        (,, difficulty,,,,,,) = dungeonTokenContract.dungeons(_dungeonId);\n', '        \n', '        // Compute all hero powers for further calculation.\n', '        uint[] memory heroPowers = new uint[](heroCount);\n', '        \n', '        for (uint i = 0; i < heroCount; i++) {\n', '            uint heroId = heroTokenContract.ownerTokens(_address, i);\n', '            uint genes;\n', '            (,,, genes) = heroTokenContract.heroes(heroId);\n', '            (heroPowers[i],,,,,) = getHeroPower(genes, difficulty);\n', '        }\n', '        \n', '        // Calculate the top 5 heroes power.\n', '        uint result;\n', '        uint curMax;\n', '        uint curMaxIndex;\n', '        \n', '        for (uint j; j < 5; j++) {\n', '            for (uint k = 0; k < heroPowers.length; k++) {\n', '                if (heroPowers[k] > curMax) {\n', '                    curMax = heroPowers[k];\n', '                    curMaxIndex = k;\n', '                }\n', '            }\n', '            \n', '            result += curMax;\n', '            heroPowers[curMaxIndex] = 0;\n', '            curMax = 0;\n', '            curMaxIndex = 0;\n', '        }\n', '        \n', '        return result;\n', '    }\n', '    \n', '    /// @dev Set the previously temp stored upgraded hero genes. Can only be called by contract owner.\n', '    function setTempHeroPower() onlyOwner public {\n', '       _setTempHeroPower();\n', '    }\n', '    \n', '    \n', '    /* ======== SETTER FUNCTIONS ======== */\n', '    \n', '    /// @dev Set the address of the dungeon token contract.\n', '    function setDungeonTokenContract(address _newDungeonTokenContract) onlyOwner external {\n', '        dungeonTokenContract = DungeonTokenInterface(_newDungeonTokenContract);\n', '    }\n', '    \n', '    /// @dev Set the address of the hero token contract.\n', '    function setHeroTokenContract(address _newHeroTokenContract) onlyOwner external {\n', '        heroTokenContract = HeroTokenInterface(_newHeroTokenContract);\n', '    }\n', '    \n', '    /// @dev Set the address of the secret dungeon challenge formula contract.\n', '    function setChallengeFormulaContract(address _newChallengeFormulaAddress) onlyOwner external {\n', '        challengeFormulaContract = ChallengeFormulaInterface(_newChallengeFormulaAddress);\n', '    }\n', '    \n', '    /// @dev Set the address of the secret hero training formula contract.\n', '    function setTrainingFormulaContract(address _newTrainingFormulaAddress) onlyOwner external {\n', '        trainingFormulaContract = TrainingFormulaInterface(_newTrainingFormulaAddress);\n', '    }\n', '    \n', '    /// @dev Updates the fee for calling recruitHero().\n', '    function setRecruitHeroFee(uint _newRecruitHeroFee) onlyOwner external {\n', '        recruitHeroFee = _newRecruitHeroFee;\n', '    }\n', '    \n', '    /// @dev Updates the fee contribution multiplier required for calling transport().\n', '    function setTransportationFeeMultiplier(uint _newTransportationFeeMultiplier) onlyOwner external {\n', '        transportationFeeMultiplier = _newTransportationFeeMultiplier;\n', '    }\n', '    \n', '    /// @dev Updates the novice dungeon ID.\n', '    function setNoviceDungeonId(uint _newNoviceDungeonId) onlyOwner external {\n', '        noviceDungeonId = _newNoviceDungeonId;\n', '    }\n', '    \n', '    /// @dev Updates the required amount of faith to get a portion of the consolation rewards.\n', '    function setConsolationRewardsRequiredFaith(uint _newConsolationRewardsRequiredFaith) onlyOwner external {\n', '        consolationRewardsRequiredFaith = _newConsolationRewardsRequiredFaith;\n', '    }\n', '    \n', '    /// @dev Updates the percentage portion of consolation rewards a player get when meeting the faith requirement.\n', '    function setConsolationRewardsClaimPercent(uint _newConsolationRewardsClaimPercent) onlyOwner external {\n', '        consolationRewardsClaimPercent = _newConsolationRewardsClaimPercent;\n', '    }\n', '    \n', '    /// @dev Updates the consolation rewards percentage.\n', '    function setConsolationRewardsPercent(uint _newConsolationRewardsPercent) onlyOwner external {\n', '        consolationRewardsPercent = _newConsolationRewardsPercent;\n', '    }\n', '    \n', '    /// @dev Updates the challenge cooldown time.\n', '    function setDungeonPreparationTime(uint _newDungeonPreparationTime) onlyOwner external {\n', '        dungeonPreparationTime = _newDungeonPreparationTime;\n', '    }\n', '    \n', '    /// @dev Updates the fee contribution multiplier required for calling trainX().\n', '    function setTrainingFeeMultiplier(uint _newTrainingFeeMultiplier) onlyOwner external {\n', '        trainingFeeMultiplier = _newTrainingFeeMultiplier;\n', '    }\n', '\n', '    /// @dev Updates the fee contribution multiplier required for calling trainEquipment().\n', '    function setEquipmentTrainingFeeMultiplier(uint _newEquipmentTrainingFeeMultiplier) onlyOwner external {\n', '        equipmentTrainingFeeMultiplier = _newEquipmentTrainingFeeMultiplier;\n', '    }\n', '    \n', '    \n', '    /* ======== INTERNAL/PRIVATE FUNCTIONS ======== */\n', '    \n', '    /**\n', '     * @dev Internal function to set the previously temp stored upgraded hero genes. \n', '     * Every challenge/training will first call this function.\n', '     */\n', '    function _setTempHeroPower() internal {\n', '        // Genes of 1 is used as no pending update.\n', '        if (tempSuccessTrainingNewHeroGenes != 1) {\n', '            // ** STORAGE UPDATE **\n', '            heroTokenContract.setHeroGenes(tempSuccessTrainingHeroId, tempSuccessTrainingNewHeroGenes);\n', '            \n', '            // Reset the variables to indicate no pending update.\n', '            tempSuccessTrainingNewHeroGenes = 1;\n', '        }\n', '    }\n', '    \n', '    \n', '    /* ======== MODIFIERS ======== */\n', '    \n', '    /**\n', '     * @dev Throws if _dungeonId is not created yet.\n', '     */\n', '    modifier dungeonExists(uint _dungeonId) {\n', '        require(_dungeonId < dungeonTokenContract.totalSupply());\n', '        _;\n', '    }\n', '    \n', '}\n', '\n', '\n', 'contract EDTransportation is EDBase {\n', '\n', '    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\n', '    \n', '    /// @dev Recruit a new novice hero with no attributes (gene = 0).\n', '    function recruitHero() whenNotPaused external payable returns (uint) {\n', '        // Only allow recruiting hero in the novice dungeon, or first time recruiting hero.\n', '        require(playerToDungeonID[msg.sender] == noviceDungeonId || !playerToFirstHeroRecruited[msg.sender]);\n', '        \n', '        // Checks for payment, any exceeding funds will be transferred back to the player.\n', '        require(msg.value >= recruitHeroFee);\n', '        \n', '        // ** STORAGE UPDATE **\n', '        // Increment the accumulated rewards for the dungeon, \n', '        // since player can only recruit hero in the novice dungeon, rewards is added there.\n', '        dungeonTokenContract.addDungeonRewards(noviceDungeonId, recruitHeroFee);\n', '\n', '        // Calculate any excess funds and make it available to be withdrawed by the player.\n', '        asyncSend(msg.sender, msg.value - recruitHeroFee);\n', '        \n', '        // If it is the first time recruiting a hero, set the player&#39;s location to the novice dungeon.\n', '        if (!playerToFirstHeroRecruited[msg.sender]) {\n', '            // ** STORAGE UPDATE **\n', '            dungeonIdToPlayerCount[noviceDungeonId]++;\n', '            playerToDungeonID[msg.sender] = noviceDungeonId;\n', '            playerToFirstHeroRecruited[msg.sender] = true;\n', '        }\n', '        \n', '        return heroTokenContract.createHero(0, msg.sender);\n', '    }\n', '    \n', '    /**\n', '     * @dev The main external function to call when a player transport to another dungeon.\n', '     *  Will generate a PlayerTransported event.\n', '     *  Player must have at least one hero in order to perform\n', '     */\n', '    function transport(uint _destinationDungeonId) whenNotPaused dungeonCanTransport(_destinationDungeonId) playerAllowedToTransport() external payable {\n', '        uint originDungeonId = playerToDungeonID[msg.sender];\n', '        \n', '        // Disallow transport to the same dungeon.\n', '        require(_destinationDungeonId != originDungeonId);\n', '        \n', '        // Get the dungeon details from the token contract.\n', '        uint difficulty;\n', '        (,, difficulty,,,,,,) = dungeonTokenContract.dungeons(_destinationDungeonId);\n', '        \n', '        // Disallow weaker user to transport to "difficult" dungeon.\n', '        uint top5HeroesPower = calculateTop5HeroesPower(msg.sender, _destinationDungeonId);\n', '        require(top5HeroesPower >= difficulty * 12);\n', '        \n', '        // Checks for payment, any exceeding funds will be transferred back to the player.\n', '        // The transportation fee is calculated by a base fee from transportationFeeMultiplier,\n', '        // plus an additional fee increased with the total power of top 5 heroes owned.\n', '        uint baseFee = difficulty * transportationFeeMultiplier;\n', '        uint additionalFee = top5HeroesPower / 64 * transportationFeeMultiplier;\n', '        uint requiredFee = baseFee + additionalFee;\n', '        require(msg.value >= requiredFee);\n', '        \n', '        // ** STORAGE UPDATE **\n', '        // Increment the accumulated rewards for the dungeon.\n', '        dungeonTokenContract.addDungeonRewards(originDungeonId, requiredFee);\n', '\n', '        // Calculate any excess funds and make it available to be withdrawed by the player.\n', '        asyncSend(msg.sender, msg.value - requiredFee);\n', '\n', '        _transport(originDungeonId, _destinationDungeonId);\n', '    }\n', '    \n', '    \n', '    /* ======== INTERNAL/PRIVATE FUNCTIONS ======== */\n', '    \n', '    /// @dev Internal function to assigns location of a player.\n', '    function _transport(uint _originDungeonId, uint _destinationDungeonId) internal {\n', '        // ** STORAGE UPDATE **\n', '        // Update the dungeons&#39; player count.\n', '        // Normally the player count of original dungeon will already be > 0,\n', '        // perform checking to avoid unexpected overflow\n', '        if (dungeonIdToPlayerCount[_originDungeonId] > 0) {\n', '            dungeonIdToPlayerCount[_originDungeonId]--;\n', '        }\n', '        \n', '        dungeonIdToPlayerCount[_destinationDungeonId]++;\n', '        \n', '        // ** STORAGE UPDATE **\n', '        // Update player location.\n', '        playerToDungeonID[msg.sender] = _destinationDungeonId;\n', '            \n', '        // Emit the DungeonChallenged event.\n', '        PlayerTransported(now, msg.sender, _originDungeonId, _destinationDungeonId);\n', '    }\n', '    \n', '    \n', '    /* ======== MODIFIERS ======== */\n', '    \n', '    /**\n', '     * @dev Throws if dungeon status do not allow transportation, also check for dungeon existence.\n', '     *  Also check if the capacity of the destination dungeon is reached.\n', '     */\n', '    modifier dungeonCanTransport(uint _destinationDungeonId) {\n', '        require(_destinationDungeonId < dungeonTokenContract.totalSupply());\n', '        \n', '        uint status;\n', '        uint capacity;\n', '        (, status,, capacity,,,,,) = dungeonTokenContract.dungeons(_destinationDungeonId);\n', '        require(status == 0 || status == 1);\n', '        \n', '        // Check if the capacity of the destination dungeon is reached.\n', '        // Capacity 0 = Infinity\n', '        require(capacity == 0 || dungeonIdToPlayerCount[_destinationDungeonId] < capacity);\n', '        _;\n', '    }\n', '    \n', '    /// @dev Throws if player did recruit first hero yet.\n', '    modifier playerAllowedToTransport() {\n', '        // Note that we check playerToFirstHeroRecruited instead of heroTokenContract.balanceOf\n', '        // in order to prevent "capacity attack".\n', '        require(playerToFirstHeroRecruited[msg.sender]);\n', '        _;\n', '    }\n', '    \n', '}\n', '\n', '\n', 'contract EDChallenge is EDTransportation {\n', '    \n', '    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\n', '    \n', '    /**\n', '     * @dev The main external function to call when a player challenge a dungeon,\n', '     *  it determines whether if the player successfully challenged the current floor.\n', '     *  Will generate a DungeonChallenged event.\n', '     */\n', '    function challenge(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanChallenge(_dungeonId) heroAllowedToChallenge(_heroId) external payable {\n', '        // Set the last action block number, disallow player to perform another train or challenge in the same block.\n', '        playerToLastActionBlockNumber[msg.sender] = block.number;\n', '        \n', '        // Set the previously temp stored upgraded hero genes.\n', '        _setTempHeroPower();\n', '        \n', '        // Get the dungeon details from the token contract.\n', '        uint difficulty;\n', '        uint seedGenes;\n', '        (,, difficulty,,,,, seedGenes,) = dungeonTokenContract.dungeons(_dungeonId);\n', '        \n', '        // Checks for payment, any exceeding funds will be transferred back to the player.\n', '        uint requiredFee = difficulty * challengeFeeMultiplier;\n', '        require(msg.value >= requiredFee);\n', '        \n', '        // ** STORAGE UPDATE **\n', '        // Increment the accumulated rewards for the dungeon.\n', '        dungeonTokenContract.addDungeonRewards(_dungeonId, requiredFee);\n', '\n', '        // Calculate any excess funds and make it available to be withdrawed by the player.\n', '        asyncSend(msg.sender, msg.value - requiredFee);\n', '        \n', '        // Split the challenge function into multiple parts because of stack too deep error.\n', '        _challengePart2(_dungeonId, difficulty, _heroId);\n', '    }\n', '    \n', '    \n', '    /* ======== INTERNAL/PRIVATE FUNCTIONS ======== */\n', '    \n', '    /// @dev Compute the remaining time for which the hero can perform a challenge again.\n', '    function _computeCooldownRemainingTime(uint _heroId) internal view returns (uint) {\n', '        uint cooldownStartTime;\n', '        uint cooldownIndex;\n', '        (, cooldownStartTime, cooldownIndex,) = heroTokenContract.heroes(_heroId);\n', '        \n', '        // Cooldown period is FLOOR(challenge count / 2) ^ 2 minutes\n', '        uint cooldownPeriod = (cooldownIndex / 2) ** 2 * 1 minutes;\n', '        \n', '        if (cooldownPeriod > 100 minutes) {\n', '            cooldownPeriod = 100 minutes;\n', '        }\n', '        \n', '        uint cooldownEndTime = cooldownStartTime + cooldownPeriod;\n', '        \n', '        if (cooldownEndTime <= now) {\n', '            return 0;\n', '        } else {\n', '            return cooldownEndTime - now;\n', '        }\n', '    }\n', '    \n', '    /// @dev Split the challenge function into multiple parts because of stack too deep error.\n', '    function _challengePart2(uint _dungeonId, uint _dungeonDifficulty, uint _heroId) private {\n', '        uint floorNumber;\n', '        uint rewards;\n', '        uint floorGenes;\n', '        (,,,, floorNumber,, rewards,, floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\n', '        \n', '        // Get the hero gene.\n', '        uint heroGenes;\n', '        (,,, heroGenes) = heroTokenContract.heroes(_heroId);\n', '        \n', '        bool success = _getChallengeSuccess(heroGenes, _dungeonDifficulty, floorGenes);\n', '        \n', '        uint newFloorGenes;\n', '        uint masterRewards;\n', '        uint consolationRewards;\n', '        uint successRewards;\n', '        uint newRewards;\n', '        \n', '        // Whether a challenge is success or not is determined by a simple comparison between hero power and floor power.\n', '        if (success) {\n', '            newFloorGenes = _getNewFloorGene(_dungeonId);\n', '            \n', '            masterRewards = rewards * masterRewardsPercent / 100;\n', '            \n', '            consolationRewards = rewards * consolationRewardsPercent / 100;\n', '            \n', '            if (floorNumber < rushTimeFloorCount) { // rush time right after prepration period\n', '                successRewards = rewards * rushTimeChallengeRewardsPercent / 100;\n', '                \n', '                // The dungeon rewards for new floor as total rewards - challenge rewards - devleoper fee.\n', '                newRewards = rewards * (100 - rushTimeChallengeRewardsPercent - masterRewardsPercent - consolationRewardsPercent) / 100;\n', '            } else {\n', '                successRewards = rewards * challengeRewardsPercent / 100;\n', '                newRewards = rewards * (100 - challengeRewardsPercent - masterRewardsPercent - consolationRewardsPercent) / 100;\n', '            }\n', '            \n', '            // TRIPLE CONFIRM sanity check.\n', '            require(successRewards + masterRewards + consolationRewards + newRewards <= rewards);\n', '            \n', '            // ** STORAGE UPDATE **\n', '            // Add the consolation rewards to grandConsolationRewards.\n', '            grandConsolationRewards += consolationRewards;\n', '            \n', '            // Add new floor with the new floor genes and new rewards.\n', '            dungeonTokenContract.addDungeonNewFloor(_dungeonId, newRewards, newFloorGenes);\n', '            \n', '            // Mark the challenge rewards available to be withdrawed by the player.\n', '            asyncSend(msg.sender, successRewards);\n', '            \n', '            // Mark the master rewards available to be withdrawed by the dungeon master.\n', '            asyncSend(dungeonTokenContract.ownerOf(_dungeonId), masterRewards);\n', '        }\n', '        \n', '        // ** STORAGE UPDATE **\n', '        // Trigger the cooldown for the hero.\n', '        heroTokenContract.triggerCooldown(_heroId);\n', '            \n', '        // Emit the DungeonChallenged event.\n', '        DungeonChallenged(now, msg.sender, _dungeonId, _heroId, heroGenes, floorNumber, floorGenes, success, newFloorGenes, successRewards, masterRewards);\n', '    }\n', '    \n', '    /// @dev Split the challenge function into multiple parts because of stack too deep error.\n', '    function _getChallengeSuccess(uint _heroGenes, uint _dungeonDifficulty, uint _floorGenes) private pure returns (bool) {\n', '        // Determine if the player challenge successfuly the dungeon or not.\n', '        uint heroPower;\n', '        (heroPower,,,,,) = getHeroPower(_heroGenes, _dungeonDifficulty);\n', '        \n', '        uint floorPower = getDungeonPower(_floorGenes);\n', '        \n', '        return heroPower > floorPower;\n', '    }\n', '    \n', '    /// @dev Split the challenge function into multiple parts because of stack too deep error.\n', '    function _getNewFloorGene(uint _dungeonId) private returns (uint) {\n', '        uint seedGenes;\n', '        uint floorGenes;\n', '        (,,,,,, seedGenes, floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\n', '        \n', '        // Calculate the new floor gene.\n', '        uint floorPower = getDungeonPower(floorGenes);\n', '        \n', '        // Call the external closed source secret function that determines the resulting floor "genes".\n', '        uint newFloorGenes = challengeFormulaContract.calculateResult(floorGenes, seedGenes);\n', '        uint newFloorPower = getDungeonPower(newFloorGenes);\n', '        \n', '        // If the power decreased, rollback to the current floor genes.\n', '        if (newFloorPower < floorPower) {\n', '            newFloorGenes = floorGenes;\n', '        }\n', '        \n', '        return newFloorGenes;\n', '    }\n', '    \n', '    \n', '    /* ======== MODIFIERS ======== */\n', '    \n', '    /**\n', '     * @dev Throws if dungeon status do not allow challenge, also check for dungeon existence.\n', '     *  Also check if the user is in the dungeon.\n', '     *  Also check if the dungeon is not in preparation period.\n', '     */\n', '    modifier dungeonCanChallenge(uint _dungeonId) {\n', '        require(_dungeonId < dungeonTokenContract.totalSupply());\n', '        \n', '        uint creationTime;\n', '        uint status;\n', '        (creationTime, status,,,,,,,) = dungeonTokenContract.dungeons(_dungeonId);\n', '        require(status == 0 || status == 2);\n', '        \n', '        // Check if the user is in the dungeon.\n', '        require(playerToDungeonID[msg.sender] == _dungeonId);\n', '        \n', '        // Check if the dungeon is not in preparation period.\n', '        require(creationTime + dungeonPreparationTime <= now);\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Throws if player does not own the hero, or the hero is still in cooldown period,\n', '     *  and no pending power update.\n', '     */\n', '    modifier heroAllowedToChallenge(uint _heroId) {\n', '        // You can only challenge with your own hero.\n', '        require(heroTokenContract.ownerOf(_heroId) == msg.sender);\n', '        \n', '        // Hero must not be in cooldown period\n', '        uint cooldownRemainingTime = _computeCooldownRemainingTime(_heroId);\n', '        require(cooldownRemainingTime == 0);\n', '        \n', '        // Prevent player to perform training and challenge in the same block to avoid bot exploit.\n', '        require(block.number > playerToLastActionBlockNumber[msg.sender]);\n', '        _;\n', '    }\n', '    \n', '}\n', '\n', '\n', 'contract EDTraining is EDChallenge {\n', '    \n', '    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\n', '    \n', '    /**\n', '     * @dev The external function to call when a hero train with a dungeon,\n', '     *  it determines whether whether a training is successfully, and the resulting genes.\n', '     *  Will generate a DungeonChallenged event.\n', '     */\n', '    function train1(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanTrain(_dungeonId) heroAllowedToTrain(_heroId) external payable {\n', '        _train(_dungeonId, _heroId, 0, 1);\n', '    }\n', '    \n', '    function train2(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanTrain(_dungeonId) heroAllowedToTrain(_heroId) external payable {\n', '        _train(_dungeonId, _heroId, 0, 2);\n', '    }\n', '    \n', '    function train3(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanTrain(_dungeonId) heroAllowedToTrain(_heroId) external payable {\n', '        _train(_dungeonId, _heroId, 0, 3);\n', '    }\n', '    \n', '    /**\n', '     * @dev The external function to call when a hero train a particular equipment with a dungeon,\n', '     *  it determines whether whether a training is successfully, and the resulting genes.\n', '     *  Will generate a DungeonChallenged event.\n', '     *  _equipmentIndex is the index of equipment: 0 is train all attributes, including equipments and stats.\n', '     *  1: weapon | 2: shield | 3: armor | 4: shoe | 5: helmet | 6: gloves | 7: belt | 8: shawl\n', '     */\n', '    function trainEquipment(uint _dungeonId, uint _heroId, uint _equipmentIndex) whenNotPaused dungeonCanTrain(_dungeonId) heroAllowedToTrain(_heroId) external payable {\n', '        require(_equipmentIndex <= 8);\n', '        \n', '        _train(_dungeonId, _heroId, _equipmentIndex, 1);\n', '    }\n', '    \n', '    \n', '    /* ======== INTERNAL/PRIVATE FUNCTIONS ======== */\n', '    \n', '    /**\n', '     * @dev An internal function of a hero train with dungeon,\n', '     *  it determines whether whether a training is successfully, and the resulting genes.\n', '     *  Will generate a DungeonChallenged event.\n', '     */\n', '    function _train(uint _dungeonId, uint _heroId, uint _equipmentIndex, uint _trainingTimes) private {\n', '        // Set the last action block number, disallow player to perform another train or challenge in the same block.\n', '        playerToLastActionBlockNumber[msg.sender] = block.number;\n', '        \n', '        // Set the previously temp stored upgraded hero genes.\n', '        _setTempHeroPower();\n', '        \n', '        // Get the dungeon details from the token contract.\n', '        uint creationTime;\n', '        uint difficulty;\n', '        uint floorNumber;\n', '        uint rewards;\n', '        uint seedGenes;\n', '        uint floorGenes;\n', '        (creationTime,, difficulty,, floorNumber,, rewards, seedGenes, floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\n', '        \n', '        // Check for _trainingTimes abnormality, we probably won&#39;t have any feature that train a hero 10 times with a single call.\n', '        require(_trainingTimes < 10);\n', '        \n', '        // Checks for payment, any exceeding funds will be transferred back to the player.\n', '        uint requiredFee;\n', '        \n', '        // Calculate the required training fee.\n', '        if (now < creationTime + dungeonPreparationTime) {\n', '            // Apply preparation period discount. \n', '            if (_equipmentIndex > 0) { // train specific equipments\n', '                requiredFee = difficulty * preparationPeriodEquipmentTrainingFeeMultiplier * _trainingTimes;\n', '            } else { // train all attributes\n', '                requiredFee = difficulty * preparationPeriodTrainingFeeMultiplier * _trainingTimes;\n', '            }\n', '        } else {\n', '            if (_equipmentIndex > 0) { // train specific equipments\n', '                requiredFee = difficulty * equipmentTrainingFeeMultiplier * _trainingTimes;\n', '            } else { // train all attributes\n', '                requiredFee = difficulty * trainingFeeMultiplier * _trainingTimes;\n', '            }\n', '        }\n', '        \n', '        require(msg.value >= requiredFee);\n', '        \n', '        // Get the hero gene.\n', '        uint heroGenes;\n', '        (,,, heroGenes) = heroTokenContract.heroes(_heroId);\n', '        \n', '        // ** STORAGE UPDATE **\n', '        // Increment the accumulated rewards for the dungeon.\n', '        dungeonTokenContract.addDungeonRewards(_dungeonId, requiredFee);\n', '\n', '        // Calculate any excess funds and make it available to be withdrawed by the player.\n', '        asyncSend(msg.sender, msg.value - requiredFee);\n', '        \n', '        // Split the _train function into multiple parts because of stack too deep error.\n', '        _trainPart2(_dungeonId, _heroId, _equipmentIndex, _trainingTimes, difficulty, floorNumber, floorGenes, heroGenes);\n', '    }\n', '    \n', '    /// @dev Split the _train function into multiple parts because of Stack Too Deep error.\n', '    function _trainPart2(\n', '        uint _dungeonId,\n', '        uint _heroId,\n', '        uint _equipmentIndex,\n', '        uint _trainingTimes,\n', '        uint _dungeonDifficulty,\n', '        uint _floorNumber,\n', '        uint _floorGenes,\n', '        uint _heroGenes\n', '    ) private {\n', '        // Determine if the hero training is successful or not, and the resulting genes.\n', '        uint heroPower;\n', '        bool isSuper;\n', '        (heroPower,,, isSuper,,) = getHeroPower(_heroGenes, _dungeonDifficulty);\n', '        \n', '        uint newHeroGenes;\n', '        uint newHeroPower;\n', '        (newHeroGenes, newHeroPower) = _calculateNewHeroPower(_dungeonDifficulty, _heroGenes, _equipmentIndex, _trainingTimes, heroPower, isSuper, _floorGenes);\n', '\n', '        // Set the new hero genes if updated (sometimes there is no power increase during equipment forging).\n', '        if (newHeroGenes != _heroGenes) {\n', '            if (newHeroPower >= 256) {\n', '                // Do not update immediately to prevent deterministic training exploit.\n', '                tempSuccessTrainingHeroId = _heroId;\n', '                tempSuccessTrainingNewHeroGenes = newHeroGenes;\n', '            } else {\n', '                // Immediately update the genes for small power hero.\n', '                // ** STORAGE UPDATE **\n', '                heroTokenContract.setHeroGenes(_heroId, newHeroGenes);\n', '            }\n', '        }\n', '        \n', '        // Training is successful only when power increase, changing another equipment with same power is considered failure\n', '        // and faith will be given accordingly.\n', '        bool success = newHeroPower > heroPower;\n', '        \n', '        if (!success) {\n', '            // Handle training failure - consolation rewards mechanics.\n', '            _handleTrainingFailure(_equipmentIndex, _trainingTimes, _dungeonDifficulty);\n', '        }\n', '        \n', '        // Emit the HeroTrained event.\n', '        HeroTrained(now, msg.sender, _dungeonId, _heroId, _heroGenes, _floorNumber, _floorGenes, success, newHeroGenes);\n', '    }\n', '    \n', '    /// @dev Determine if the hero training is successful or not, and the resulting genes and power.\n', '    function _calculateNewHeroPower(\n', '        uint _dungeonDifficulty, \n', '        uint _heroGenes, \n', '        uint _equipmentIndex, \n', '        uint _trainingTimes, \n', '        uint _heroPower, \n', '        bool _isSuper, \n', '        uint _floorGenes\n', '    ) private returns (uint newHeroGenes, uint newHeroPower) {\n', '        newHeroGenes = _heroGenes;\n', '        newHeroPower = _heroPower;\n', '        bool newIsSuper = _isSuper;\n', '        \n', '        // Train the hero multiple times according to _trainingTimes, \n', '        // each time if the resulting power is larger, update new hero power.\n', '        for (uint i = 0; i < _trainingTimes; i++) {\n', '            // Call the external closed source secret function that determines the resulting hero "genes".\n', '            uint tmpHeroGenes = trainingFormulaContract.calculateResult(newHeroGenes, _floorGenes, _equipmentIndex);\n', '            \n', '            uint tmpHeroPower;\n', '            bool tmpIsSuper;\n', '            (tmpHeroPower,,, tmpIsSuper,,) = getHeroPower(tmpHeroGenes, _dungeonDifficulty);\n', '            \n', '            if (tmpHeroPower > newHeroPower) {\n', '                // Prevent Super Hero downgrade.\n', '                if (!(newIsSuper && !tmpIsSuper)) {\n', '                    newHeroGenes = tmpHeroGenes;\n', '                    newHeroPower = tmpHeroPower;\n', '                }\n', '            } else if (_equipmentIndex > 0 && tmpHeroPower == newHeroPower && tmpHeroGenes != newHeroGenes) {\n', '                // Allow Equipment Forging to replace current requipemnt with a same power equipment.\n', '                // The training is considered failed (faith will be given, but the equipment will change).\n', '                newHeroGenes = tmpHeroGenes;\n', '                newHeroPower = tmpHeroPower;\n', '            }\n', '        }\n', '    }\n', '    \n', '    /// @dev Calculate and assign the appropriate faith value to the player.\n', '    function _handleTrainingFailure(uint _equipmentIndex, uint _trainingTimes, uint _dungeonDifficulty) private {\n', '        // Failed training in a dungeon will add to player&#39;s faith value.\n', '        uint faith = playerToFaith[msg.sender];\n', '        uint faithEarned;\n', '        \n', '        if (_equipmentIndex == 0) { // Hero Training\n', '            // The faith earned is proportional to the training fee, i.e. _difficulty * _trainingTimes.\n', '            faithEarned = _dungeonDifficulty * _trainingTimes;\n', '        } else { // Equipment Forging\n', '            // Equipment Forging faith earned is only 2 times normal training, not proportional to forging fee.\n', '            faithEarned = _dungeonDifficulty * _trainingTimes * 2;\n', '        }\n', '        \n', '        uint newFaith = faith + faithEarned;\n', '        \n', '        // Hitting the required amount in faith will get a proportion of grandConsolationRewards\n', '        if (newFaith >= consolationRewardsRequiredFaith) {\n', '            uint consolationRewards = grandConsolationRewards * consolationRewardsClaimPercent / 100;\n', '            \n', '            // ** STORAGE UPDATE **\n', '            grandConsolationRewards -= consolationRewards;\n', '            \n', '            // Mark the consolation rewards available to be withdrawed by the player.\n', '            asyncSend(msg.sender, consolationRewards);\n', '            \n', '            // Reset the faith value.\n', '            newFaith -= consolationRewardsRequiredFaith;\n', '            \n', '            ConsolationRewardsClaimed(now, msg.sender, consolationRewards);\n', '        }\n', '        \n', '        // ** STORAGE UPDATE **\n', '        playerToFaith[msg.sender] = newFaith;\n', '    }\n', '    \n', '    \n', '    /* ======== MODIFIERS ======== */\n', '    \n', '    /**\n', '     * @dev Throws if dungeon status do not allow training, also check for dungeon existence.\n', '     *  Also check if the user is in the dungeon.\n', '     */\n', '    modifier dungeonCanTrain(uint _dungeonId) {\n', '        require(_dungeonId < dungeonTokenContract.totalSupply());\n', '        uint status;\n', '        (,status,,,,,,,) = dungeonTokenContract.dungeons(_dungeonId);\n', '        require(status == 0 || status == 3);\n', '        \n', '        // Also check if the user is in the dungeon.\n', '        require(playerToDungeonID[msg.sender] == _dungeonId);\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Throws if player does not own the hero, and no pending power update.\n', '     */\n', '    modifier heroAllowedToTrain(uint _heroId) {\n', '        require(heroTokenContract.ownerOf(_heroId) == msg.sender);\n', '        \n', '        // Prevent player to perform training and challenge in the same block to avoid bot exploit.\n', '        require(block.number > playerToLastActionBlockNumber[msg.sender]);\n', '        _;\n', '    }\n', '    \n', '}\n', '\n', '\n', '/**\n', ' * @title EDCoreVersion1\n', ' * @dev Core Contract of Ether Dungeon.\n', ' *  When Version 2 launches, EDCoreVersion2 contract will be deployed and EDCoreVersion1 will be destroyed.\n', ' *  Since all dungeons and heroes are stored as tokens in external contracts, they remains immutable.\n', ' */\n', 'contract EDCoreVersion1 is Destructible, EDTraining {\n', '    \n', '    /**\n', '     * Initialize the EDCore contract with all the required contract addresses.\n', '     */\n', '    function EDCoreVersion1(\n', '        address _dungeonTokenAddress,\n', '        address _heroTokenAddress,\n', '        address _challengeFormulaAddress, \n', '        address _trainingFormulaAddress\n', '    ) public payable {\n', '        dungeonTokenContract = DungeonTokenInterface(_dungeonTokenAddress);\n', '        heroTokenContract = HeroTokenInterface(_heroTokenAddress);\n', '        challengeFormulaContract = ChallengeFormulaInterface(_challengeFormulaAddress);\n', '        trainingFormulaContract = TrainingFormulaInterface(_trainingFormulaAddress);\n', '    }\n', '\n', '    \n', '    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\n', '    \n', '    /// @dev The external function to get all the game settings in one call.\n', '    function getGameSettings() external view returns (\n', '        uint _recruitHeroFee,\n', '        uint _transportationFeeMultiplier,\n', '        uint _noviceDungeonId,\n', '        uint _consolationRewardsRequiredFaith,\n', '        uint _challengeFeeMultiplier,\n', '        uint _dungeonPreparationTime,\n', '        uint _trainingFeeMultiplier,\n', '        uint _equipmentTrainingFeeMultiplier,\n', '        uint _preparationPeriodTrainingFeeMultiplier,\n', '        uint _preparationPeriodEquipmentTrainingFeeMultiplier\n', '    ) {\n', '        _recruitHeroFee = recruitHeroFee;\n', '        _transportationFeeMultiplier = transportationFeeMultiplier;\n', '        _noviceDungeonId = noviceDungeonId;\n', '        _consolationRewardsRequiredFaith = consolationRewardsRequiredFaith;\n', '        _challengeFeeMultiplier = challengeFeeMultiplier;\n', '        _dungeonPreparationTime = dungeonPreparationTime;\n', '        _trainingFeeMultiplier = trainingFeeMultiplier;\n', '        _equipmentTrainingFeeMultiplier = equipmentTrainingFeeMultiplier;\n', '        _preparationPeriodTrainingFeeMultiplier = preparationPeriodTrainingFeeMultiplier;\n', '        _preparationPeriodEquipmentTrainingFeeMultiplier = preparationPeriodEquipmentTrainingFeeMultiplier;\n', '    }\n', '    \n', '    /**\n', '     * @dev The external function to get all the relevant information about a specific player by its address.\n', '     * @param _address The address of the player.\n', '     */\n', '    function getPlayerDetails(address _address) external view returns (\n', '        uint dungeonId, \n', '        uint payment, \n', '        uint dungeonCount, \n', '        uint heroCount, \n', '        uint faith,\n', '        bool firstHeroRecruited\n', '    ) {\n', '        payment = payments[_address];\n', '        dungeonCount = dungeonTokenContract.balanceOf(_address);\n', '        heroCount = heroTokenContract.balanceOf(_address);\n', '        faith = playerToFaith[_address];\n', '        firstHeroRecruited = playerToFirstHeroRecruited[_address];\n', '        \n', '        // If a player didn&#39;t recruit any hero yet, consider the player is in novice dungeon\n', '        if (firstHeroRecruited) {\n', '            dungeonId = playerToDungeonID[_address];\n', '        } else {\n', '            dungeonId = noviceDungeonId;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev The external function to get all the relevant information about a specific dungeon by its ID.\n', '     * @param _id The ID of the dungeon.\n', '     */\n', '    function getDungeonDetails(uint _id) external view returns (\n', '        uint creationTime, \n', '        uint status, \n', '        uint difficulty, \n', '        uint capacity, \n', '        address owner, \n', '        bool isReady, \n', '        uint playerCount\n', '    ) {\n', '        require(_id < dungeonTokenContract.totalSupply());\n', '        \n', '        // Didn&#39;t get the "floorCreationTime" because of Stack Too Deep error.\n', '        (creationTime, status, difficulty, capacity,,,,,) = dungeonTokenContract.dungeons(_id);\n', '        \n', '        // Dungeon is ready to be challenged (not in preparation mode).\n', '        owner = dungeonTokenContract.ownerOf(_id);\n', '        isReady = creationTime + dungeonPreparationTime <= now;\n', '        playerCount = dungeonIdToPlayerCount[_id];\n', '    }\n', '    \n', '    /**\n', '     * @dev Split floor related details out of getDungeonDetails, just to avoid Stack Too Deep error.\n', '     * @param _id The ID of the dungeon.\n', '     */\n', '    function getDungeonFloorDetails(uint _id) external view returns (\n', '        uint floorNumber, \n', '        uint floorCreationTime, \n', '        uint rewards, \n', '        uint seedGenes, \n', '        uint floorGenes\n', '    ) {\n', '        require(_id < dungeonTokenContract.totalSupply());\n', '        \n', '        // Didn&#39;t get the "floorCreationTime" because of Stack Too Deep error.\n', '        (,,,, floorNumber, floorCreationTime, rewards, seedGenes, floorGenes) = dungeonTokenContract.dungeons(_id);\n', '    }\n', '\n', '    /**\n', '     * @dev The external function to get all the relevant information about a specific hero by its ID.\n', '     * @param _id The ID of the hero.\n', '     */\n', '    function getHeroDetails(uint _id) external view returns (\n', '        uint creationTime, \n', '        uint cooldownStartTime, \n', '        uint cooldownIndex, \n', '        uint genes, \n', '        address owner, \n', '        bool isReady, \n', '        uint cooldownRemainingTime\n', '    ) {\n', '        require(_id < heroTokenContract.totalSupply());\n', '\n', '        (creationTime, cooldownStartTime, cooldownIndex, genes) = heroTokenContract.heroes(_id);\n', '        \n', '        // Hero is ready to challenge (not in cooldown mode).\n', '        owner = heroTokenContract.ownerOf(_id);\n', '        cooldownRemainingTime = _computeCooldownRemainingTime(_id);\n', '        isReady = cooldownRemainingTime == 0;\n', '    }\n', '    \n', '    \n', '    /* ======== MIGRATION FUNCTIONS ======== */\n', '    \n', '    /**\n', '     * @dev Since the DungeonToken contract is re-deployed due to optimization.\n', '     *  We need to migrate all dungeons from Beta token contract to Version 1.\n', '     */\n', '    function migrateDungeon(uint _id, uint _playerCount) external {\n', '        // Migration will be finished before maintenance period ends, tx.origin is used within a short period only.\n', '        require(now < 1520694000 && tx.origin == 0x47169f78750Be1e6ec2DEb2974458ac4F8751714);\n', '        \n', '        dungeonIdToPlayerCount[_id] = _playerCount;\n', '    }\n', '    \n', '    /**\n', '     * @dev We need to migrate all player location from Beta token contract to Version 1.\n', '     */\n', '    function migratePlayer(address _address, uint _ownerDungeonId, uint _payment, uint _faith) external {\n', '        // Migration will be finished before maintenance period ends, tx.origin is used within a short period only.\n', '        require(now < 1520694000 && tx.origin == 0x47169f78750Be1e6ec2DEb2974458ac4F8751714);\n', '        \n', '        playerToDungeonID[_address] = _ownerDungeonId;\n', '        \n', '        if (_payment > 0) {\n', '            asyncSend(_address, _payment);\n', '        }\n', '        \n', '        if (_faith > 0) {\n', '            playerToFaith[_address] = _faith;\n', '        }\n', '        \n', '        playerToFirstHeroRecruited[_address] = true;\n', '    }\n', '    \n', '}']