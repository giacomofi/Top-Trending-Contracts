['pragma solidity ^0.4.23;\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 {\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 _tokenId\n', '  );\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _approved,\n', '    uint256 _tokenId\n', '  );\n', '  event ApprovalForAll(\n', '    address indexed _owner,\n', '    address indexed _operator,\n', '    bool _approved\n', '  );\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId)\n', '    public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator)\n', '    public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n', '    public;\n', '\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public;\n', '}\n', 'contract ERC721Receiver {\n', '  /**\n', '   * @dev Magic value to be returned upon successful reception of an NFT\n', '   *  Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`,\n', '   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '   */\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  /**\n', '   * @notice Handle the receipt of an NFT\n', '   * @dev The ERC721 smart contract calls this function on the recipient\n', '   *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '   *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '   *  than the magic value MUST result in the transaction being reverted.\n', '   *  Note: the contract address is always the message sender.\n', '   * @param _from The sending address\n', '   * @param _tokenId The NFT identifier which is being transfered\n', '   * @param _data Additional data with no specified format\n', '   * @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '   */\n', '  function onERC721Received(\n', '    address _from,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public\n', '    returns(bytes4);\n', '}\n', '\n', 'contract etherdoodleToken is ERC721 {\n', '\n', '    using AddressUtils for address;\n', '    //@dev ERC-721 compliance\n', '    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '\n', '//EVENTS\n', '// @dev fired when a pixel&#39;s colour is changed\n', '    event ColourChanged(uint pixelId, uint8 colourR, uint8 colourG, uint8 colourB);\n', '\n', '// @dev fired when a pixel&#39;s price is changed\n', '    event PriceChanged(uint pixelId, uint oldPrice, uint newPrice);\n', '\n', '// @dev fired when a pixel&#39;s text is changed\n', '    event TextChanged(uint pixelId, string textChanged);\n', '\n', '//@dev name for ERC-721\n', '    string constant public name = "etherdoodle";\n', '\n', '//@dev symbol for ERC-721\n', '    string constant public symbol = "etherdoodle";\n', '\n', '//@dev Starting pixel price\n', '    uint constant public startingPrice = 0.001 ether;\n', '\n', '\n', '//@dev Switch from 3x to 1.5x per transaction\n', '    uint private constant stepAt = 0.09944 ether;\n', '\n', '//@dev The addresses of the accounts \n', '    address public ceoAddress;\n', '\n', '\n', '//DATA STRUCTURES\n', '//@dev struct representation of a pixel\n', '    struct Pixel {\n', '        uint32 id;\n', '        uint8 colourR;\n', '        uint8 colourG;\n', '        uint8 colourB;\n', '        string pixelText;\n', '    }\n', '\n', '//@dev array holding all pixels\n', '    Pixel[1000000] public pixels;\n', '\n', '//MAPPINGS\n', '//@dev mapping from a pixel to its owner\n', '    mapping (uint => address) private pixelToOwner;\n', '\n', '//@dev mapping from owner to all of their pixels;\n', '    mapping (address => uint[]) private ownerToPixel;\n', '\n', '//@dev mapping from an address to the count of pixels\n', '    mapping (address => uint) private ownerPixelCount;\n', '\n', '//@dev mapping from a pixelId to the price of that pixel\n', '    mapping (uint => uint ) private pixelToPrice;\n', '\n', '//@dev mapping from a pixel to an approved account for transfer\n', '    mapping(uint => address) public pixelToApproved;\n', '\n', '//@dev mapping from an address to another mapping that determines if an operator is approved\n', '    mapping(address => mapping(address=>bool)) internal operatorApprovals;\n', '\n', '//MODIFIERS\n', '//@dev access modifiers for ceo\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '//@dev used to verify ownership\n', '    modifier onlyOwnerOf(uint _pixelId) {\n', '        require(msg.sender == ownerOf(_pixelId));\n', '        _;\n', '    }\n', '\n', '//@dev used to allow operators to transfer and to manage the pixels\n', '    modifier canManageAndTransfer(uint _pixelId) {\n', '        require(isApprovedOrOwner(msg.sender, _pixelId));\n', '        _;\n', '    }\n', '\n', '//@dev make sure that the recipient address is notNull\n', '    modifier notNull(address _to) {\n', '        require(_to != address(0));\n', '        _;\n', '    }\n', '\n', '//Constructor\n', '    constructor () public {\n', '        ceoAddress = msg.sender;\n', '    }\n', '///////\n', '// External functions\n', '/////\n', '//@dev function to assign a new CEO\n', '    function assignCEO(address _newCEO) external onlyCEO {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '//@Update All a selected pixels details, can be done by the operator, or the owner\n', '    function updateAllPixelDetails(uint _pixelId, uint8 _colourR, uint8 _colourG, uint8 _colourB,uint _price,string _text) \n', '    external canManageAndTransfer(_pixelId) {\n', '        require(_price <= pixelToPrice[_pixelId]);\n', '        require(_price >= 0.0001 ether);\n', '        require(bytes(_text).length < 101);\n', '        bool colourChangedBool = false;\n', '        if(pixelToPrice[_pixelId] != _price){\n', '            pixelToPrice[_pixelId] = _price;\n', '            emit PriceChanged(_pixelId,pixelToPrice[_pixelId],_price);\n', '        }\n', '        if(pixels[_pixelId].colourR != _colourR){\n', '            pixels[_pixelId].colourR = _colourR;\n', '            colourChangedBool = true;\n', '        }\n', '        if(pixels[_pixelId].colourG != _colourG){\n', '            pixels[_pixelId].colourG = _colourG;\n', '            colourChangedBool = true;\n', '        }\n', '        if(pixels[_pixelId].colourB != _colourB){\n', '            pixels[_pixelId].colourB = _colourB;\n', '            colourChangedBool = true;\n', '        }\n', '        if (colourChangedBool){\n', '            emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n', '        }\n', '        \n', '        if(keccak256(getPixelText(_pixelId)) != keccak256(_text) ){\n', '            pixels[_pixelId].pixelText = _text;\n', '            emit TextChanged(_pixelId,_text);\n', '        }\n', '    }\n', '\n', '//@dev add an address to a pixel&#39;s approved list\n', '    function approve(address _to, uint _pixelId) public  {\n', '        address owner = ownerOf(_pixelId);\n', '        require(_to != owner);\n', '        require(msg.sender == owner || isApprovedForAll(owner,msg.sender));\n', '        if(getApproved(_pixelId) != address(0) || _to != address(0)) {\n', '            pixelToApproved[_pixelId] = _to;\n', '            emit Approval(msg.sender, _to, _pixelId);\n', '        }\n', '        \n', '    }\n', '\n', '//@dev returns approved Addresses\n', '    function getApproved(uint _pixelId) public view returns(address){\n', '        return pixelToApproved[_pixelId];\n', '    }\n', '\n', '//@dev approve all an owner&#39;s pixels to be managed by an address\n', '    function setApprovalForAll(address _to,bool _approved) public{\n', '        require(_to != msg.sender);\n', '        operatorApprovals[msg.sender][_to] = _approved;\n', '        emit ApprovalForAll(msg.sender, _to, _approved);\n', '    }\n', ' \n', '\n', '///////////////////\n', '///Public functions\n', '///////////////////\n', '\n', '//@dev returns if a pixel has already been purchased\n', '    function exists(uint256 _pixelId) public view returns (bool) {\n', '        address owner = pixelToOwner[_pixelId];\n', '        return owner != address(0);\n', '    }\n', '\n', '//@dev returns if an address is approved to manage all another address&#39; pixels\n', '    function isApprovedForAll(address _owner, address _operator) public view returns(bool) {\n', '        return operatorApprovals[_owner][_operator];\n', '    }\n', '\n', '//@dev returns the number of pixels an address owns\n', '    function balanceOf(address _owner) public view returns (uint) {\n', '        return ownerPixelCount[_owner];\n', '    }\n', '\n', '\n', '//@dev returns the owner of a pixel\n', '    function ownerOf(uint _pixelId)  public view returns (address) {\n', '        address owner = pixelToOwner[_pixelId];\n', '        return owner;\n', '    }\n', '\n', '//@dev internal function to determine if its approved or an owner\n', '    function isApprovedOrOwner(address _spender, uint _pixelId)internal view returns (bool) {\n', '        address owner = ownerOf(_pixelId);\n', '        return(_spender == owner || getApproved(_pixelId) == _spender || isApprovedForAll(owner,_spender));\n', '    }\n', '\n', '//@dev internal function to remove approval on a pixel\n', '    function clearApproval(address _owner, uint256 _pixelId) internal {\n', '        require(ownerOf(_pixelId) == _owner);\n', '        if(pixelToApproved[_pixelId] != address(0)) {\n', '            pixelToApproved[_pixelId] = address(0);\n', '            emit Approval(_owner,address(0),_pixelId);\n', '        }\n', '    }\n', '\n', '//@dev returns the total number of pixels generated\n', '    function totalSupply() public view returns (uint) {\n', '        return pixels.length;\n', '    }\n', '\n', '//@dev ERC 721 transfer from\n', '    function transferFrom(address _from, address _to, uint _pixelId) public \n', '    canManageAndTransfer(_pixelId) {\n', '        require(_from != address(0));\n', '        require(_to != address(0));\n', '        clearApproval(_from,_pixelId);\n', '        _transfer(_from, _to, _pixelId);\n', '    }\n', '//@dev ERC 721 safeTransfer from functions\n', '    function safeTransferFrom(address _from, address _to, uint _pixelId) public canManageAndTransfer(_pixelId){\n', '        safeTransferFrom(_from,_to,_pixelId,"");\n', '    }\n', '\n', '//@dev ERC 721 safeTransferFrom functions\n', '    function safeTransferFrom(address _from, address _to, uint _pixelId,bytes _data) public canManageAndTransfer(_pixelId){\n', '        transferFrom(_from,_to,_pixelId);\n', '        require(checkAndCallSafeTransfer(_from,_to,_pixelId,_data));\n', '    }\n', '\n', '//@dev TRANSFER\n', '    function transfer(address _to, uint _pixelId) public canManageAndTransfer(_pixelId) notNull(_to) {\n', '        _transfer(msg.sender, _to, _pixelId);\n', '    }\n', '\n', '//@dev returns all pixel&#39;s data\n', '    function getPixelData(uint _pixelId) public view returns \n', '    (uint32 _id, address _owner, uint8 _colourR, uint8 _colourG, uint8 _colourB, uint _price,string _text) {\n', '        Pixel storage pixel = pixels[_pixelId];\n', '        _id = pixel.id;\n', '        _price = getPixelPrice(_pixelId);\n', '        _owner = pixelToOwner[_pixelId];\n', '        _colourR = pixel.colourR;\n', '        _colourG = pixel.colourG;\n', '        _colourB = pixel.colourB;\n', '        _text = pixel.pixelText;\n', '    }\n', '\n', '//@dev Returns only Text\n', '    function getPixelText(uint _pixelId)public view returns(string) {\n', '        return pixels[_pixelId].pixelText;\n', '    }\n', '\n', '//@dev Returns the priceof a pixel\n', '    function getPixelPrice(uint _pixelId) public view returns(uint) {\n', '        uint price = pixelToPrice[_pixelId];\n', '        if (price != 0) {\n', '            return price;\n', '        } else {\n', '            return startingPrice;\n', '            }\n', '        \n', '    } \n', '\n', '    //@dev return the pixels owned by an address\n', '    function getPixelsOwned(address _owner) public view returns(uint[]) {\n', '        return ownerToPixel[_owner];\n', '    }\n', '\n', '    //@dev return number of pixels owned by an address\n', '    function getOwnerPixelCount(address _owner) public view returns(uint) {\n', '        return ownerPixelCount[_owner];\n', '    }\n', '\n', '    //@dev  return colour\n', '    function getPixelColour(uint _pixelId) public view returns (uint _colourR, uint _colourG, uint _colourB) {\n', '        _colourR = pixels[_pixelId].colourR;\n', '        _colourG = pixels[_pixelId].colourG;\n', '        _colourB = pixels[_pixelId].colourB;\n', '    }\n', '\n', '    //@dev payout function to dev\n', '    function payout(address _to) public onlyCEO {\n', '        if (_to == address(0)) {\n', '            ceoAddress.transfer(address(this).balance);\n', '        } else {\n', '            _to.transfer(address(this).balance);\n', '        }  \n', '    }\n', '\n', '    //@dev purchase multiple pixels at the same time\n', '    function multiPurchase(uint32[] _Id, uint8[] _R,uint8[] _G,uint8[] _B,string _text) public payable {\n', '        require(_Id.length == _R.length && _Id.length == _G.length && _Id.length == _B.length);\n', '        require(bytes(_text).length < 101);\n', '        address newOwner = msg.sender;\n', '        uint totalPrice = 0;\n', '        uint excessValue = msg.value;\n', '        \n', '        for(uint i = 0; i < _Id.length; i++){\n', '            address oldOwner = ownerOf(_Id[i]);\n', '            require(ownerOf(_Id[i]) != newOwner);\n', '            require(!isInvulnerableByArea(_Id[i]));\n', '            \n', '            uint tempPrice = getPixelPrice(_Id[i]);\n', '            totalPrice = SafeMath.add(totalPrice,tempPrice);\n', '            excessValue = processMultiPurchase(_Id[i],_R[i],_G[i],_B[i],_text,oldOwner,newOwner,excessValue);\n', '           \n', '            if(i == _Id.length-1) {\n', '                require(msg.value >= totalPrice);\n', '                msg.sender.transfer(excessValue);\n', '            }   \n', '        }\n', '        \n', '    } \n', '\n', '    //@dev helper function for processing multiple purchases\n', '    function processMultiPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text, // solium-disable-line\n', '        address _oldOwner,address _newOwner,uint value) private returns (uint excess) {\n', '        uint payment; // payment to previous owner\n', '        uint purchaseExcess; // excess purchase value\n', '        uint sellingPrice = getPixelPrice(_pixelId);\n', '        if(_oldOwner == address(0)) {\n', '            purchaseExcess = uint(SafeMath.sub(value,startingPrice));\n', '            _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\n', '        } else {\n', '            payment = uint(SafeMath.div(SafeMath.mul(sellingPrice,95), 100));\n', '            purchaseExcess = SafeMath.sub(value,sellingPrice);\n', '            if(pixels[_pixelId].colourR != _colourR || pixels[_pixelId].colourG != _colourG || pixels[_pixelId].colourB != _colourB)\n', '                _changeColour(_pixelId,_colourR,_colourG,_colourB);\n', '            if(keccak256(getPixelText(_pixelId)) != keccak256(_text))\n', '                _changeText(_pixelId,_text);\n', '            clearApproval(_oldOwner,_pixelId);\n', '        }\n', '        if(sellingPrice < stepAt) {\n', '            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,300),95);\n', '        } else {\n', '            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,150),95);\n', '        }\n', '        _transfer(_oldOwner, _newOwner,_pixelId);\n', '     \n', '        if(_oldOwner != address(this)) {\n', '            _oldOwner.transfer(payment); \n', '        }\n', '        return purchaseExcess;\n', '    }\n', '    \n', '    function _changeColour(uint _pixelId,uint8 _colourR,uint8 _colourG, uint8 _colourB) private {\n', '        pixels[_pixelId].colourR = _colourR;\n', '        pixels[_pixelId].colourG = _colourG;\n', '        pixels[_pixelId].colourB = _colourB;\n', '        emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n', '    }\n', '    function _changeText(uint _pixelId, string _text) private{\n', '        require(bytes(_text).length < 101);\n', '        pixels[_pixelId].pixelText = _text;\n', '        emit TextChanged(_pixelId,_text);\n', '    }\n', '    \n', '\n', '//@dev Invulnerability logic check \n', '    function isInvulnerableByArea(uint _pixelId) public view returns (bool) {\n', '        require(_pixelId >= 0 && _pixelId <= 999999);\n', '        if (ownerOf(_pixelId) == address(0)) {\n', '            return false;\n', '        }\n', '        uint256 counter = 0;\n', ' \n', '        if (_pixelId == 0 || _pixelId == 999 || _pixelId == 999000 || _pixelId == 999999) {\n', '            return false;\n', '        }\n', '\n', '        if (_pixelId < 1000) {\n', '            if (_checkPixelRight(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelLeft(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelUnder(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelUnderRight(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1); \n', '            }\n', '            if (_checkPixelUnderLeft(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '        }\n', '\n', '        if (_pixelId > 999000) {\n', '            if (_checkPixelRight(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelLeft(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelAbove(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelAboveRight(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelAboveLeft(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '        }\n', '\n', '        if (_pixelId > 999 && _pixelId < 999000) {\n', '            if (_pixelId%1000 == 0 || _pixelId%1000 == 999) {\n', '                if (_pixelId%1000 == 0) {\n', '                    if (_checkPixelAbove(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelAboveRight(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelRight(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelUnder(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelUnderRight(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                } else {\n', '                    if (_checkPixelAbove(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelAboveLeft(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelLeft(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelUnder(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelUnderLeft(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                }\n', '            } else {\n', '                if (_checkPixelAbove(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelAboveLeft(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelAboveRight(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelUnder(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelUnderRight(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelUnderLeft(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelRight(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelLeft(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '            }\n', '        }\n', '        return counter >= 5;\n', '    }\n', '\n', '   \n', '\n', '   \n', '\n', '////////////////////\n', '///Private functions\n', '////////////////////\n', '//@dev create a pixel\n', '    function _createPixel (uint32 _id, uint8 _colourR, uint8 _colourG, uint8 _colourB, string _pixelText) private returns(uint) {\n', '        pixels[_id] = Pixel(_id, _colourR, _colourG, _colourB, _pixelText);\n', '        pixelToPrice[_id] = startingPrice;\n', '        emit ColourChanged(_id, _colourR, _colourG, _colourB);\n', '        return _id;\n', '    }\n', '\n', '//@dev private function to transfer a pixel from an old address to a new one\n', '    function _transfer(address _from, address _to, uint _pixelId) private {\n', '  //increment new owner pixel count and decrement old owner count and add a pixel to the owners array\n', '        ownerPixelCount[_to] = SafeMath.add(ownerPixelCount[_to], 1);\n', '        ownerToPixel[_to].push(_pixelId);\n', '        if (_from != address(0)) {\n', '            for (uint i = 0; i < ownerToPixel[_from].length; i++) {\n', '                if (ownerToPixel[_from][i] == _pixelId) {\n', '                    ownerToPixel[_from][i] = ownerToPixel[_from][ownerToPixel[_from].length-1];\n', '                    delete ownerToPixel[_from][ownerToPixel[_from].length-1];\n', '                }\n', '            }\n', '            ownerPixelCount[_from] = SafeMath.sub(ownerPixelCount[_from], 1);\n', '        }\n', '        pixelToOwner[_pixelId] = _to;\n', '        emit Transfer(_from, _to, _pixelId);\n', '    }\n', '\n', '//@dev helper functions to check for if a pixel purchase is valid\n', '    function _checkPixelAbove(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId-1000)) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function _checkPixelUnder(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId+1000)) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _checkPixelRight(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId+1)) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _checkPixelLeft(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId-1)) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _checkPixelAboveLeft(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId-1001)) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _checkPixelUnderLeft(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId+999)) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _checkPixelAboveRight(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId-999)) {\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function _checkPixelUnderRight(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId+1001)) {\n', '            return true;\n', '        } else {  \n', '            return false; \n', '        }\n', '    }\n', '\n', '//@dev ERC721 compliance to check what address it is being sent to\n', '    function checkAndCallSafeTransfer(address _from, address _to, uint256 _pixelId, bytes _data)\n', '    internal\n', '    returns (bool)\n', '    {\n', '        if (!_to.isContract()) {\n', '            return true;\n', '        }\n', '        bytes4 retval = ERC721Receiver(_to).onERC721Received(\n', '        _from, _pixelId, _data);\n', '        return (retval == ERC721_RECEIVED);\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 {\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 _tokenId\n', '  );\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _approved,\n', '    uint256 _tokenId\n', '  );\n', '  event ApprovalForAll(\n', '    address indexed _owner,\n', '    address indexed _operator,\n', '    bool _approved\n', '  );\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId)\n', '    public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator)\n', '    public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n', '    public;\n', '\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public;\n', '}\n', 'contract ERC721Receiver {\n', '  /**\n', '   * @dev Magic value to be returned upon successful reception of an NFT\n', '   *  Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`,\n', '   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '   */\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  /**\n', '   * @notice Handle the receipt of an NFT\n', '   * @dev The ERC721 smart contract calls this function on the recipient\n', '   *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '   *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '   *  than the magic value MUST result in the transaction being reverted.\n', '   *  Note: the contract address is always the message sender.\n', '   * @param _from The sending address\n', '   * @param _tokenId The NFT identifier which is being transfered\n', '   * @param _data Additional data with no specified format\n', '   * @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '   */\n', '  function onERC721Received(\n', '    address _from,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public\n', '    returns(bytes4);\n', '}\n', '\n', 'contract etherdoodleToken is ERC721 {\n', '\n', '    using AddressUtils for address;\n', '    //@dev ERC-721 compliance\n', '    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '\n', '//EVENTS\n', "// @dev fired when a pixel's colour is changed\n", '    event ColourChanged(uint pixelId, uint8 colourR, uint8 colourG, uint8 colourB);\n', '\n', "// @dev fired when a pixel's price is changed\n", '    event PriceChanged(uint pixelId, uint oldPrice, uint newPrice);\n', '\n', "// @dev fired when a pixel's text is changed\n", '    event TextChanged(uint pixelId, string textChanged);\n', '\n', '//@dev name for ERC-721\n', '    string constant public name = "etherdoodle";\n', '\n', '//@dev symbol for ERC-721\n', '    string constant public symbol = "etherdoodle";\n', '\n', '//@dev Starting pixel price\n', '    uint constant public startingPrice = 0.001 ether;\n', '\n', '\n', '//@dev Switch from 3x to 1.5x per transaction\n', '    uint private constant stepAt = 0.09944 ether;\n', '\n', '//@dev The addresses of the accounts \n', '    address public ceoAddress;\n', '\n', '\n', '//DATA STRUCTURES\n', '//@dev struct representation of a pixel\n', '    struct Pixel {\n', '        uint32 id;\n', '        uint8 colourR;\n', '        uint8 colourG;\n', '        uint8 colourB;\n', '        string pixelText;\n', '    }\n', '\n', '//@dev array holding all pixels\n', '    Pixel[1000000] public pixels;\n', '\n', '//MAPPINGS\n', '//@dev mapping from a pixel to its owner\n', '    mapping (uint => address) private pixelToOwner;\n', '\n', '//@dev mapping from owner to all of their pixels;\n', '    mapping (address => uint[]) private ownerToPixel;\n', '\n', '//@dev mapping from an address to the count of pixels\n', '    mapping (address => uint) private ownerPixelCount;\n', '\n', '//@dev mapping from a pixelId to the price of that pixel\n', '    mapping (uint => uint ) private pixelToPrice;\n', '\n', '//@dev mapping from a pixel to an approved account for transfer\n', '    mapping(uint => address) public pixelToApproved;\n', '\n', '//@dev mapping from an address to another mapping that determines if an operator is approved\n', '    mapping(address => mapping(address=>bool)) internal operatorApprovals;\n', '\n', '//MODIFIERS\n', '//@dev access modifiers for ceo\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '//@dev used to verify ownership\n', '    modifier onlyOwnerOf(uint _pixelId) {\n', '        require(msg.sender == ownerOf(_pixelId));\n', '        _;\n', '    }\n', '\n', '//@dev used to allow operators to transfer and to manage the pixels\n', '    modifier canManageAndTransfer(uint _pixelId) {\n', '        require(isApprovedOrOwner(msg.sender, _pixelId));\n', '        _;\n', '    }\n', '\n', '//@dev make sure that the recipient address is notNull\n', '    modifier notNull(address _to) {\n', '        require(_to != address(0));\n', '        _;\n', '    }\n', '\n', '//Constructor\n', '    constructor () public {\n', '        ceoAddress = msg.sender;\n', '    }\n', '///////\n', '// External functions\n', '/////\n', '//@dev function to assign a new CEO\n', '    function assignCEO(address _newCEO) external onlyCEO {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '//@Update All a selected pixels details, can be done by the operator, or the owner\n', '    function updateAllPixelDetails(uint _pixelId, uint8 _colourR, uint8 _colourG, uint8 _colourB,uint _price,string _text) \n', '    external canManageAndTransfer(_pixelId) {\n', '        require(_price <= pixelToPrice[_pixelId]);\n', '        require(_price >= 0.0001 ether);\n', '        require(bytes(_text).length < 101);\n', '        bool colourChangedBool = false;\n', '        if(pixelToPrice[_pixelId] != _price){\n', '            pixelToPrice[_pixelId] = _price;\n', '            emit PriceChanged(_pixelId,pixelToPrice[_pixelId],_price);\n', '        }\n', '        if(pixels[_pixelId].colourR != _colourR){\n', '            pixels[_pixelId].colourR = _colourR;\n', '            colourChangedBool = true;\n', '        }\n', '        if(pixels[_pixelId].colourG != _colourG){\n', '            pixels[_pixelId].colourG = _colourG;\n', '            colourChangedBool = true;\n', '        }\n', '        if(pixels[_pixelId].colourB != _colourB){\n', '            pixels[_pixelId].colourB = _colourB;\n', '            colourChangedBool = true;\n', '        }\n', '        if (colourChangedBool){\n', '            emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n', '        }\n', '        \n', '        if(keccak256(getPixelText(_pixelId)) != keccak256(_text) ){\n', '            pixels[_pixelId].pixelText = _text;\n', '            emit TextChanged(_pixelId,_text);\n', '        }\n', '    }\n', '\n', "//@dev add an address to a pixel's approved list\n", '    function approve(address _to, uint _pixelId) public  {\n', '        address owner = ownerOf(_pixelId);\n', '        require(_to != owner);\n', '        require(msg.sender == owner || isApprovedForAll(owner,msg.sender));\n', '        if(getApproved(_pixelId) != address(0) || _to != address(0)) {\n', '            pixelToApproved[_pixelId] = _to;\n', '            emit Approval(msg.sender, _to, _pixelId);\n', '        }\n', '        \n', '    }\n', '\n', '//@dev returns approved Addresses\n', '    function getApproved(uint _pixelId) public view returns(address){\n', '        return pixelToApproved[_pixelId];\n', '    }\n', '\n', "//@dev approve all an owner's pixels to be managed by an address\n", '    function setApprovalForAll(address _to,bool _approved) public{\n', '        require(_to != msg.sender);\n', '        operatorApprovals[msg.sender][_to] = _approved;\n', '        emit ApprovalForAll(msg.sender, _to, _approved);\n', '    }\n', ' \n', '\n', '///////////////////\n', '///Public functions\n', '///////////////////\n', '\n', '//@dev returns if a pixel has already been purchased\n', '    function exists(uint256 _pixelId) public view returns (bool) {\n', '        address owner = pixelToOwner[_pixelId];\n', '        return owner != address(0);\n', '    }\n', '\n', "//@dev returns if an address is approved to manage all another address' pixels\n", '    function isApprovedForAll(address _owner, address _operator) public view returns(bool) {\n', '        return operatorApprovals[_owner][_operator];\n', '    }\n', '\n', '//@dev returns the number of pixels an address owns\n', '    function balanceOf(address _owner) public view returns (uint) {\n', '        return ownerPixelCount[_owner];\n', '    }\n', '\n', '\n', '//@dev returns the owner of a pixel\n', '    function ownerOf(uint _pixelId)  public view returns (address) {\n', '        address owner = pixelToOwner[_pixelId];\n', '        return owner;\n', '    }\n', '\n', '//@dev internal function to determine if its approved or an owner\n', '    function isApprovedOrOwner(address _spender, uint _pixelId)internal view returns (bool) {\n', '        address owner = ownerOf(_pixelId);\n', '        return(_spender == owner || getApproved(_pixelId) == _spender || isApprovedForAll(owner,_spender));\n', '    }\n', '\n', '//@dev internal function to remove approval on a pixel\n', '    function clearApproval(address _owner, uint256 _pixelId) internal {\n', '        require(ownerOf(_pixelId) == _owner);\n', '        if(pixelToApproved[_pixelId] != address(0)) {\n', '            pixelToApproved[_pixelId] = address(0);\n', '            emit Approval(_owner,address(0),_pixelId);\n', '        }\n', '    }\n', '\n', '//@dev returns the total number of pixels generated\n', '    function totalSupply() public view returns (uint) {\n', '        return pixels.length;\n', '    }\n', '\n', '//@dev ERC 721 transfer from\n', '    function transferFrom(address _from, address _to, uint _pixelId) public \n', '    canManageAndTransfer(_pixelId) {\n', '        require(_from != address(0));\n', '        require(_to != address(0));\n', '        clearApproval(_from,_pixelId);\n', '        _transfer(_from, _to, _pixelId);\n', '    }\n', '//@dev ERC 721 safeTransfer from functions\n', '    function safeTransferFrom(address _from, address _to, uint _pixelId) public canManageAndTransfer(_pixelId){\n', '        safeTransferFrom(_from,_to,_pixelId,"");\n', '    }\n', '\n', '//@dev ERC 721 safeTransferFrom functions\n', '    function safeTransferFrom(address _from, address _to, uint _pixelId,bytes _data) public canManageAndTransfer(_pixelId){\n', '        transferFrom(_from,_to,_pixelId);\n', '        require(checkAndCallSafeTransfer(_from,_to,_pixelId,_data));\n', '    }\n', '\n', '//@dev TRANSFER\n', '    function transfer(address _to, uint _pixelId) public canManageAndTransfer(_pixelId) notNull(_to) {\n', '        _transfer(msg.sender, _to, _pixelId);\n', '    }\n', '\n', "//@dev returns all pixel's data\n", '    function getPixelData(uint _pixelId) public view returns \n', '    (uint32 _id, address _owner, uint8 _colourR, uint8 _colourG, uint8 _colourB, uint _price,string _text) {\n', '        Pixel storage pixel = pixels[_pixelId];\n', '        _id = pixel.id;\n', '        _price = getPixelPrice(_pixelId);\n', '        _owner = pixelToOwner[_pixelId];\n', '        _colourR = pixel.colourR;\n', '        _colourG = pixel.colourG;\n', '        _colourB = pixel.colourB;\n', '        _text = pixel.pixelText;\n', '    }\n', '\n', '//@dev Returns only Text\n', '    function getPixelText(uint _pixelId)public view returns(string) {\n', '        return pixels[_pixelId].pixelText;\n', '    }\n', '\n', '//@dev Returns the priceof a pixel\n', '    function getPixelPrice(uint _pixelId) public view returns(uint) {\n', '        uint price = pixelToPrice[_pixelId];\n', '        if (price != 0) {\n', '            return price;\n', '        } else {\n', '            return startingPrice;\n', '            }\n', '        \n', '    } \n', '\n', '    //@dev return the pixels owned by an address\n', '    function getPixelsOwned(address _owner) public view returns(uint[]) {\n', '        return ownerToPixel[_owner];\n', '    }\n', '\n', '    //@dev return number of pixels owned by an address\n', '    function getOwnerPixelCount(address _owner) public view returns(uint) {\n', '        return ownerPixelCount[_owner];\n', '    }\n', '\n', '    //@dev  return colour\n', '    function getPixelColour(uint _pixelId) public view returns (uint _colourR, uint _colourG, uint _colourB) {\n', '        _colourR = pixels[_pixelId].colourR;\n', '        _colourG = pixels[_pixelId].colourG;\n', '        _colourB = pixels[_pixelId].colourB;\n', '    }\n', '\n', '    //@dev payout function to dev\n', '    function payout(address _to) public onlyCEO {\n', '        if (_to == address(0)) {\n', '            ceoAddress.transfer(address(this).balance);\n', '        } else {\n', '            _to.transfer(address(this).balance);\n', '        }  \n', '    }\n', '\n', '    //@dev purchase multiple pixels at the same time\n', '    function multiPurchase(uint32[] _Id, uint8[] _R,uint8[] _G,uint8[] _B,string _text) public payable {\n', '        require(_Id.length == _R.length && _Id.length == _G.length && _Id.length == _B.length);\n', '        require(bytes(_text).length < 101);\n', '        address newOwner = msg.sender;\n', '        uint totalPrice = 0;\n', '        uint excessValue = msg.value;\n', '        \n', '        for(uint i = 0; i < _Id.length; i++){\n', '            address oldOwner = ownerOf(_Id[i]);\n', '            require(ownerOf(_Id[i]) != newOwner);\n', '            require(!isInvulnerableByArea(_Id[i]));\n', '            \n', '            uint tempPrice = getPixelPrice(_Id[i]);\n', '            totalPrice = SafeMath.add(totalPrice,tempPrice);\n', '            excessValue = processMultiPurchase(_Id[i],_R[i],_G[i],_B[i],_text,oldOwner,newOwner,excessValue);\n', '           \n', '            if(i == _Id.length-1) {\n', '                require(msg.value >= totalPrice);\n', '                msg.sender.transfer(excessValue);\n', '            }   \n', '        }\n', '        \n', '    } \n', '\n', '    //@dev helper function for processing multiple purchases\n', '    function processMultiPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text, // solium-disable-line\n', '        address _oldOwner,address _newOwner,uint value) private returns (uint excess) {\n', '        uint payment; // payment to previous owner\n', '        uint purchaseExcess; // excess purchase value\n', '        uint sellingPrice = getPixelPrice(_pixelId);\n', '        if(_oldOwner == address(0)) {\n', '            purchaseExcess = uint(SafeMath.sub(value,startingPrice));\n', '            _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\n', '        } else {\n', '            payment = uint(SafeMath.div(SafeMath.mul(sellingPrice,95), 100));\n', '            purchaseExcess = SafeMath.sub(value,sellingPrice);\n', '            if(pixels[_pixelId].colourR != _colourR || pixels[_pixelId].colourG != _colourG || pixels[_pixelId].colourB != _colourB)\n', '                _changeColour(_pixelId,_colourR,_colourG,_colourB);\n', '            if(keccak256(getPixelText(_pixelId)) != keccak256(_text))\n', '                _changeText(_pixelId,_text);\n', '            clearApproval(_oldOwner,_pixelId);\n', '        }\n', '        if(sellingPrice < stepAt) {\n', '            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,300),95);\n', '        } else {\n', '            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,150),95);\n', '        }\n', '        _transfer(_oldOwner, _newOwner,_pixelId);\n', '     \n', '        if(_oldOwner != address(this)) {\n', '            _oldOwner.transfer(payment); \n', '        }\n', '        return purchaseExcess;\n', '    }\n', '    \n', '    function _changeColour(uint _pixelId,uint8 _colourR,uint8 _colourG, uint8 _colourB) private {\n', '        pixels[_pixelId].colourR = _colourR;\n', '        pixels[_pixelId].colourG = _colourG;\n', '        pixels[_pixelId].colourB = _colourB;\n', '        emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n', '    }\n', '    function _changeText(uint _pixelId, string _text) private{\n', '        require(bytes(_text).length < 101);\n', '        pixels[_pixelId].pixelText = _text;\n', '        emit TextChanged(_pixelId,_text);\n', '    }\n', '    \n', '\n', '//@dev Invulnerability logic check \n', '    function isInvulnerableByArea(uint _pixelId) public view returns (bool) {\n', '        require(_pixelId >= 0 && _pixelId <= 999999);\n', '        if (ownerOf(_pixelId) == address(0)) {\n', '            return false;\n', '        }\n', '        uint256 counter = 0;\n', ' \n', '        if (_pixelId == 0 || _pixelId == 999 || _pixelId == 999000 || _pixelId == 999999) {\n', '            return false;\n', '        }\n', '\n', '        if (_pixelId < 1000) {\n', '            if (_checkPixelRight(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelLeft(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelUnder(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelUnderRight(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1); \n', '            }\n', '            if (_checkPixelUnderLeft(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '        }\n', '\n', '        if (_pixelId > 999000) {\n', '            if (_checkPixelRight(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelLeft(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelAbove(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelAboveRight(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '            if (_checkPixelAboveLeft(_pixelId)) {\n', '                counter = SafeMath.add(counter, 1);\n', '            }\n', '        }\n', '\n', '        if (_pixelId > 999 && _pixelId < 999000) {\n', '            if (_pixelId%1000 == 0 || _pixelId%1000 == 999) {\n', '                if (_pixelId%1000 == 0) {\n', '                    if (_checkPixelAbove(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelAboveRight(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelRight(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelUnder(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelUnderRight(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                } else {\n', '                    if (_checkPixelAbove(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelAboveLeft(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelLeft(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelUnder(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                    if (_checkPixelUnderLeft(_pixelId)) {\n', '                        counter = SafeMath.add(counter, 1);\n', '                    }\n', '                }\n', '            } else {\n', '                if (_checkPixelAbove(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelAboveLeft(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelAboveRight(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelUnder(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelUnderRight(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelUnderLeft(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelRight(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '                if (_checkPixelLeft(_pixelId)) {\n', '                    counter = SafeMath.add(counter, 1);\n', '                }\n', '            }\n', '        }\n', '        return counter >= 5;\n', '    }\n', '\n', '   \n', '\n', '   \n', '\n', '////////////////////\n', '///Private functions\n', '////////////////////\n', '//@dev create a pixel\n', '    function _createPixel (uint32 _id, uint8 _colourR, uint8 _colourG, uint8 _colourB, string _pixelText) private returns(uint) {\n', '        pixels[_id] = Pixel(_id, _colourR, _colourG, _colourB, _pixelText);\n', '        pixelToPrice[_id] = startingPrice;\n', '        emit ColourChanged(_id, _colourR, _colourG, _colourB);\n', '        return _id;\n', '    }\n', '\n', '//@dev private function to transfer a pixel from an old address to a new one\n', '    function _transfer(address _from, address _to, uint _pixelId) private {\n', '  //increment new owner pixel count and decrement old owner count and add a pixel to the owners array\n', '        ownerPixelCount[_to] = SafeMath.add(ownerPixelCount[_to], 1);\n', '        ownerToPixel[_to].push(_pixelId);\n', '        if (_from != address(0)) {\n', '            for (uint i = 0; i < ownerToPixel[_from].length; i++) {\n', '                if (ownerToPixel[_from][i] == _pixelId) {\n', '                    ownerToPixel[_from][i] = ownerToPixel[_from][ownerToPixel[_from].length-1];\n', '                    delete ownerToPixel[_from][ownerToPixel[_from].length-1];\n', '                }\n', '            }\n', '            ownerPixelCount[_from] = SafeMath.sub(ownerPixelCount[_from], 1);\n', '        }\n', '        pixelToOwner[_pixelId] = _to;\n', '        emit Transfer(_from, _to, _pixelId);\n', '    }\n', '\n', '//@dev helper functions to check for if a pixel purchase is valid\n', '    function _checkPixelAbove(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId-1000)) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function _checkPixelUnder(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId+1000)) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _checkPixelRight(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId+1)) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _checkPixelLeft(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId-1)) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _checkPixelAboveLeft(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId-1001)) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _checkPixelUnderLeft(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId+999)) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _checkPixelAboveRight(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId-999)) {\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function _checkPixelUnderRight(uint _pixelId) private view returns (bool) {\n', '        if (ownerOf(_pixelId) == ownerOf(_pixelId+1001)) {\n', '            return true;\n', '        } else {  \n', '            return false; \n', '        }\n', '    }\n', '\n', '//@dev ERC721 compliance to check what address it is being sent to\n', '    function checkAndCallSafeTransfer(address _from, address _to, uint256 _pixelId, bytes _data)\n', '    internal\n', '    returns (bool)\n', '    {\n', '        if (!_to.isContract()) {\n', '            return true;\n', '        }\n', '        bytes4 retval = ERC721Receiver(_to).onERC721Received(\n', '        _from, _pixelId, _data);\n', '        return (retval == ERC721_RECEIVED);\n', '    }\n', '}']
