['pragma solidity ^0.4.18;\n', '\n', '\n', 'contract GroupBuyContract {\n', '  /*** CONSTANTS ***/\n', '  uint256 public constant MAX_CONTRIBUTION_SLOTS = 20;\n', '  uint256 private firstStepLimit =  0.053613 ether;\n', '  uint256 private secondStepLimit = 0.564957 ether;\n', '\n', '  /*** DATATYPES ***/\n', '  // @dev A Group is created for all the contributors who want to contribute\n', '  //  to the purchase of a particular token.\n', '  struct Group {\n', '    // Array of addresses of contributors in group\n', '    address[] contributorArr;\n', "    // Maps address to an address's position (+ 1) in the contributorArr;\n", '    // 1 is added to the position because zero is the default value in the mapping\n', '    mapping(address => uint256) addressToContributorArrIndex;\n', '    mapping(address => uint256) addressToContribution; // user address to amount contributed\n', '    bool exists; // For tracking whether a group has been initialized or not\n', '    uint256 contributedBalance; // Total amount contributed\n', '    uint256 purchasePrice; // Price of purchased token\n', '  }\n', '\n', '  // @dev A Contributor record is created for each user participating in\n', '  //  this group buy contract. It stores the group ids the user contributed to\n', '  //  and a record of their sale proceeds.\n', '  struct Contributor {\n', "    // Maps tokenId to an tokenId's position (+ 1) in the groupArr;\n", '    // 1 is added to the position because zero is the default value in the mapping\n', '    mapping(uint256 => uint) tokenIdToGroupArrIndex;\n', '    // Array of tokenIds contributed to by a contributor\n', '    uint256[] groupArr;\n', '    bool exists;\n', '    // Ledger for withdrawable balance for this user.\n', '    //  Funds can come from excess paid into a groupBuy,\n', '    //  or from withdrawing from a group, or from\n', '    //  sale proceeds from a token.\n', '    uint256 withdrawableBalance;\n', '  }\n', '\n', '  /*** EVENTS ***/\n', '  /// Admin Events\n', '  // @dev Event noting commission paid to contract\n', '  event Commission(uint256 _tokenId, uint256 amount);\n', '\n', '  /// Contract Events\n', '  // @dev Event signifiying that contract received funds via fallback fn\n', '  event FundsReceived(address _from, uint256 amount);\n', '\n', '  /// User Events\n', "  // @dev Event marking funds deposited into user _to's account\n", '  event FundsDeposited(address _to, uint256 amount);\n', '\n', '  // @dev Event marking a withdrawal of amount by user _to\n', '  event FundsWithdrawn(address _to, uint256 amount);\n', '\n', '  // @dev Event noting an interest distribution for user _to for token _tokenId.\n', '  //  Token Group will not be disbanded\n', '  event InterestDeposited(uint256 _tokenId, address _to, uint256 amount);\n', '\n', '  // @dev Event for when a contributor joins a token group _tokenId\n', '  event JoinGroup(\n', '    uint256 _tokenId,\n', '    address contributor,\n', '    uint256 groupBalance,\n', '    uint256 contributionAdded\n', '  );\n', '\n', '  // @dev Event for when a contributor leaves a token group\n', '  event LeaveGroup(\n', '    uint256 _tokenId,\n', '    address contributor,\n', '    uint256 groupBalance,\n', '    uint256 contributionSubtracted\n', '  );\n', '\n', '  // @dev Event noting sales proceeds distribution for user _to from sale of token _tokenId\n', '  event ProceedsDeposited(uint256 _tokenId, address _to, uint256 amount);\n', '\n', '  // @dev Event for when a token group purchases a token\n', '  event TokenPurchased(uint256 _tokenId, uint256 balance);\n', '\n', '  /*** STORAGE ***/\n', '  // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '  address public ceoAddress;\n', '  address public cfoAddress;\n', '  address public cooAddress1;\n', '  address public cooAddress2;\n', '  address public cooAddress3;\n', '\n', '  // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '  bool public paused = false;\n', '  bool public forking = false;\n', '\n', '  uint256 public activeGroups;\n', '  uint256 public commissionBalance;\n', '  uint256 private distributionNumerator;\n', '  uint256 private distributionDenominator;\n', '\n', '  CelebrityToken public linkedContract;\n', '\n', '  /// @dev A mapping from token IDs to the group associated with that token.\n', '  mapping(uint256 => Group) private tokenIndexToGroup;\n', '\n', '  // @dev A mapping from owner address to available balance not held by a Group.\n', '  mapping(address => Contributor) private userAddressToContributor;\n', '\n', '  /*** ACCESS MODIFIERS ***/\n', '  /// @dev Access modifier for CEO-only functionality\n', '  modifier onlyCEO() {\n', '    require(msg.sender == ceoAddress);\n', '    _;\n', '  }\n', '\n', '  /// @dev Access modifier for CFO-only functionality\n', '  modifier onlyCFO() {\n', '    require(msg.sender == cfoAddress);\n', '    _;\n', '  }\n', '\n', '  /// @dev Access modifier for COO-only functionality\n', '  modifier onlyCOO() {\n', '    require(\n', '      msg.sender == cooAddress1 ||\n', '      msg.sender == cooAddress2 ||\n', '      msg.sender == cooAddress3\n', '    );\n', '    _;\n', '  }\n', '\n', '  /// @dev Access modifier for contract managers only functionality\n', '  modifier onlyCLevel() {\n', '    require(\n', '      msg.sender == ceoAddress ||\n', '      msg.sender == cooAddress1 ||\n', '      msg.sender == cooAddress2 ||\n', '      msg.sender == cooAddress3 ||\n', '      msg.sender == cfoAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /// @dev Modifier to allow actions only when the contract IS paused\n', '  modifier whenPaused {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /// @dev Modifier to allow actions only when the contract IS NOT in forking mode\n', '  modifier whenNotForking() {\n', '    require(!forking);\n', '    _;\n', '  }\n', '\n', '  /// @dev Modifier to allow actions only when the contract IS in forking mode\n', '  modifier whenForking {\n', '    require(forking);\n', '    _;\n', '  }\n', '\n', '  /*** CONSTRUCTOR ***/\n', '  function GroupBuyContract(address contractAddress, uint256 numerator, uint256 denominator) public {\n', '    ceoAddress = msg.sender;\n', '    cooAddress1 = msg.sender;\n', '    cooAddress2 = msg.sender;\n', '    cooAddress3 = msg.sender;\n', '    cfoAddress = msg.sender;\n', '    distributionNumerator = numerator;\n', '    distributionDenominator = denominator;\n', '    linkedContract = CelebrityToken(contractAddress);\n', '  }\n', '\n', '  /*** PUBLIC FUNCTIONS ***/\n', '  /// @notice Fallback fn for receiving ether\n', '  function() external payable {\n', '    FundsReceived(msg.sender, msg.value);\n', '  }\n', '\n', '  /** Action Fns **/\n', '  /// @notice Backup function for activating token purchase\n', '  ///  requires sender to be a member of the group or CLevel\n', '  /// @param _tokenId The ID of the Token group\n', '  function activatePurchase(uint256 _tokenId) external whenNotPaused {\n', '    var group = tokenIndexToGroup[_tokenId];\n', '    require(group.addressToContribution[msg.sender] > 0 ||\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cooAddress1 ||\n', '            msg.sender == cooAddress2 ||\n', '            msg.sender == cooAddress3 ||\n', '            msg.sender == cfoAddress);\n', '\n', '    // Safety check that enough money has been contributed to group\n', '    var price = linkedContract.priceOf(_tokenId);\n', '    require(group.contributedBalance >= price);\n', '\n', '    // Safety check that token had not be purchased yet\n', '    require(group.purchasePrice == 0);\n', '\n', '    _purchase(_tokenId, price);\n', '  }\n', '\n', '  /// @notice Allow user to contribute to _tokenId token group\n', '  /// @param _tokenId The ID of the token group to be joined\n', '  function contributeToTokenGroup(uint256 _tokenId)\n', '  external payable whenNotForking whenNotPaused {\n', '    address userAdd = msg.sender;\n', '    // Safety check to prevent against an un  expected 0x0 default.\n', '    require(_addressNotNull(userAdd));\n', '\n', '    /// Safety check to make sure contributor has not already joined this group\n', '    var group = tokenIndexToGroup[_tokenId];\n', '    var contributor = userAddressToContributor[userAdd];\n', '    if (!group.exists) { // Create group if not exists\n', '      group.exists = true;\n', '      activeGroups += 1;\n', '    } else {\n', '      require(group.addressToContributorArrIndex[userAdd] == 0);\n', '    }\n', '\n', '    if (!contributor.exists) { // Create contributor if not exists\n', '      userAddressToContributor[userAdd].exists = true;\n', '    } else {\n', '      require(contributor.tokenIdToGroupArrIndex[_tokenId] == 0);\n', '    }\n', '\n', "    // Safety check to make sure group isn't currently holding onto token\n", '    //  or has a group record stored (for sales proceeds distribution)\n', '    require(group.purchasePrice == 0);\n', '\n', '    /// Safety check to ensure amount contributed is higher than min required percentage\n', '    ///  of purchase price\n', '    uint256 tokenPrice = linkedContract.priceOf(_tokenId);\n', '    require(msg.value >= uint256(SafeMath.div(tokenPrice, MAX_CONTRIBUTION_SLOTS)));\n', '\n', "    // Index saved is 1 + the array's index, b/c 0 is the default value in a mapping,\n", '    //  so as stored on the mapping, array index will begin at 1\n', '    uint256 cIndex = tokenIndexToGroup[_tokenId].contributorArr.push(userAdd);\n', '    tokenIndexToGroup[_tokenId].addressToContributorArrIndex[userAdd] = cIndex;\n', '\n', '    uint256 amountNeeded = SafeMath.sub(tokenPrice, group.contributedBalance);\n', '    if (msg.value > amountNeeded) {\n', '      tokenIndexToGroup[_tokenId].addressToContribution[userAdd] = amountNeeded;\n', '      tokenIndexToGroup[_tokenId].contributedBalance += amountNeeded;\n', '      // refund excess paid\n', '      userAddressToContributor[userAdd].withdrawableBalance += SafeMath.sub(msg.value, amountNeeded);\n', '      FundsDeposited(userAdd, SafeMath.sub(msg.value, amountNeeded));\n', '    } else {\n', '      tokenIndexToGroup[_tokenId].addressToContribution[userAdd] = msg.value;\n', '      tokenIndexToGroup[_tokenId].contributedBalance += msg.value;\n', '    }\n', '\n', "    // Index saved is 1 + the array's index, b/c 0 is the default value in a mapping,\n", '    //  so as stored on the mapping, array index will begin at 1\n', '    uint256 gIndex = userAddressToContributor[userAdd].groupArr.push(_tokenId);\n', '    userAddressToContributor[userAdd].tokenIdToGroupArrIndex[_tokenId] = gIndex;\n', '\n', '    JoinGroup(\n', '      _tokenId,\n', '      userAdd,\n', '      tokenIndexToGroup[_tokenId].contributedBalance,\n', '      tokenIndexToGroup[_tokenId].addressToContribution[userAdd]\n', '    );\n', '\n', '    // Purchase token if enough funds contributed\n', '    if (tokenIndexToGroup[_tokenId].contributedBalance >= tokenPrice) {\n', '      _purchase(_tokenId, tokenPrice);\n', '    }\n', '  }\n', '\n', '  /// @notice Allow user to leave purchase group; note that their contribution\n', '  ///  will be added to their withdrawable balance, and not directly refunded.\n', '  ///  User can call withdrawBalance to retrieve funds.\n', '  /// @param _tokenId The ID of the Token purchase group to be left\n', '  function leaveTokenGroup(uint256 _tokenId) external whenNotPaused {\n', '    address userAdd = msg.sender;\n', '\n', '    var group = tokenIndexToGroup[_tokenId];\n', '    var contributor = userAddressToContributor[userAdd];\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(userAdd));\n', '\n', '    // Safety check to make sure group exists;\n', '    require(group.exists);\n', '\n', "    // Safety check to make sure group hasn't purchased token already\n", '    require(group.purchasePrice == 0);\n', '\n', '    // Safety checks to ensure contributor has contributed to group\n', '    require(group.addressToContributorArrIndex[userAdd] > 0);\n', '    require(contributor.tokenIdToGroupArrIndex[_tokenId] > 0);\n', '\n', '    uint refundBalance = _clearContributorRecordInGroup(_tokenId, userAdd);\n', '    _clearGroupRecordInContributor(_tokenId, userAdd);\n', '\n', '    userAddressToContributor[userAdd].withdrawableBalance += refundBalance;\n', '    FundsDeposited(userAdd, refundBalance);\n', '\n', '    LeaveGroup(\n', '      _tokenId,\n', '      userAdd,\n', '      tokenIndexToGroup[_tokenId].contributedBalance,\n', '      refundBalance\n', '    );\n', '  }\n', '\n', '  /// @notice Allow user to leave purchase group; note that their contribution\n', '  ///  and any funds they have in their withdrawableBalance will transfered to them.\n', '  /// @param _tokenId The ID of the Token purchase group to be left\n', '  function leaveTokenGroupAndWithdrawBalance(uint256 _tokenId) external whenNotPaused {\n', '    address userAdd = msg.sender;\n', '\n', '    var group = tokenIndexToGroup[_tokenId];\n', '    var contributor = userAddressToContributor[userAdd];\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(userAdd));\n', '\n', '    // Safety check to make sure group exists;\n', '    require(group.exists);\n', '\n', "    // Safety check to make sure group hasn't purchased token already\n", '    require(group.purchasePrice == 0);\n', '\n', '    // Safety checks to ensure contributor has contributed to group\n', '    require(group.addressToContributorArrIndex[userAdd] > 0);\n', '    require(contributor.tokenIdToGroupArrIndex[_tokenId] > 0);\n', '\n', '    uint refundBalance = _clearContributorRecordInGroup(_tokenId, userAdd);\n', '    _clearGroupRecordInContributor(_tokenId, userAdd);\n', '\n', '    userAddressToContributor[userAdd].withdrawableBalance += refundBalance;\n', '    FundsDeposited(userAdd, refundBalance);\n', '\n', '    _withdrawUserFunds(userAdd);\n', '\n', '    LeaveGroup(\n', '      _tokenId,\n', '      userAdd,\n', '      tokenIndexToGroup[_tokenId].contributedBalance,\n', '      refundBalance\n', '    );\n', '  }\n', '\n', '  /// @dev Withdraw balance from own account\n', '  function withdrawBalance() external whenNotPaused {\n', '    require(_addressNotNull(msg.sender));\n', '    require(userAddressToContributor[msg.sender].exists);\n', '\n', '    _withdrawUserFunds(msg.sender);\n', '  }\n', '\n', '  /** Admin Fns **/\n', '  /// @notice Fn for adjusting commission rate\n', '  /// @param numerator Numerator for calculating funds distributed\n', '  /// @param denominator Denominator for calculating funds distributed\n', '  function adjustCommission(uint256 numerator, uint256 denominator) external onlyCLevel {\n', '    require(numerator <= denominator);\n', '    distributionNumerator = numerator;\n', '    distributionDenominator = denominator;\n', '  }\n', '\n', '  /// @dev In the event of needing a fork, this function moves all\n', "  ///  of a group's contributors' contributions into their withdrawable balance.\n", '  /// @notice Group is dissolved after fn call\n', '  /// @param _tokenId The ID of the Token purchase group\n', '  function dissolveTokenGroup(uint256 _tokenId) external onlyCOO whenForking {\n', '    var group = tokenIndexToGroup[_tokenId];\n', '\n', '    // Safety check to make sure group exists and had not purchased a token\n', '    require(group.exists);\n', '    require(group.purchasePrice == 0);\n', '\n', '    for (uint i = 0; i < tokenIndexToGroup[_tokenId].contributorArr.length; i++) {\n', '      address userAdd = tokenIndexToGroup[_tokenId].contributorArr[i];\n', '\n', '      var userContribution = group.addressToContribution[userAdd];\n', '\n', '      _clearGroupRecordInContributor(_tokenId, userAdd);\n', '\n', '      // clear contributor record on group\n', '      tokenIndexToGroup[_tokenId].addressToContribution[userAdd] = 0;\n', '      tokenIndexToGroup[_tokenId].addressToContributorArrIndex[userAdd] = 0;\n', '\n', "      // move contributor's contribution to their withdrawable balance\n", '      userAddressToContributor[userAdd].withdrawableBalance += userContribution;\n', '      ProceedsDeposited(_tokenId, userAdd, userContribution);\n', '    }\n', '    activeGroups -= 1;\n', '    tokenIndexToGroup[_tokenId].exists = false;\n', '  }\n', '\n', '  /// @dev Backup fn to allow distribution of funds after sale,\n', '  ///  for the special scenario where an alternate sale platform is used;\n', '  /// @notice Group is dissolved after fn call\n', '  /// @param _tokenId The ID of the Token purchase group\n', '  /// @param _amount Funds to be distributed\n', '  function distributeCustomSaleProceeds(uint256 _tokenId, uint256 _amount) external onlyCOO {\n', '    var group = tokenIndexToGroup[_tokenId];\n', '\n', '    // Safety check to make sure group exists and had purchased the token\n', '    require(group.exists);\n', '    require(group.purchasePrice > 0);\n', '    require(_amount > 0);\n', '\n', '    _distributeProceeds(_tokenId, _amount);\n', '  }\n', '\n', '  /* /// @dev Allow distribution of interest payment,\n', '  ///  Group is intact after fn call\n', '  /// @param _tokenId The ID of the Token purchase group\n', '  function distributeInterest(uint256 _tokenId) external onlyCOO payable {\n', '    var group = tokenIndexToGroup[_tokenId];\n', '    var amount = msg.value;\n', '    var excess = amount;\n', '\n', '    // Safety check to make sure group exists and had purchased the token\n', '    require(group.exists);\n', '    require(group.purchasePrice > 0);\n', '    require(amount > 0);\n', '\n', '    for (uint i = 0; i < tokenIndexToGroup[_tokenId].contributorArr.length; i++) {\n', '      address userAdd = tokenIndexToGroup[_tokenId].contributorArr[i];\n', '\n', "      // calculate contributor's interest proceeds and add to their withdrawable balance\n", '      uint256 userProceeds = uint256(SafeMath.div(SafeMath.mul(amount,\n', '        tokenIndexToGroup[_tokenId].addressToContribution[userAdd]),\n', '        tokenIndexToGroup[_tokenId].contributedBalance));\n', '      userAddressToContributor[userAdd].withdrawableBalance += userProceeds;\n', '\n', '      excess -= userProceeds;\n', '\n', '      InterestDeposited(_tokenId, userAdd, userProceeds);\n', '    }\n', '    commissionBalance += excess;\n', '    Commission(_tokenId, excess);\n', '  } */\n', '\n', '  /// @dev Distribute funds after a token is sold.\n', '  ///  Group is dissolved after fn call\n', '  /// @param _tokenId The ID of the Token purchase group\n', '  function distributeSaleProceeds(uint256 _tokenId) external onlyCOO {\n', '    var group = tokenIndexToGroup[_tokenId];\n', '\n', '    // Safety check to make sure group exists and had purchased the token\n', '    require(group.exists);\n', '    require(group.purchasePrice > 0);\n', '\n', '    // Safety check to make sure token had been sold\n', '    uint256 currPrice = linkedContract.priceOf(_tokenId);\n', '    uint256 soldPrice = _newPrice(group.purchasePrice);\n', '    require(currPrice > soldPrice);\n', '\n', '    uint256 paymentIntoContract = uint256(SafeMath.div(SafeMath.mul(soldPrice, 94), 100));\n', '    _distributeProceeds(_tokenId, paymentIntoContract);\n', '  }\n', '\n', '  /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '  ///  a bug or exploit is detected and we need to limit damage.\n', '  function pause() external onlyCLevel whenNotPaused {\n', '    paused = true;\n', '  }\n', '\n', '  /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '  ///  one reason we may pause the contract is when CFO or COO accounts are\n', '  ///  compromised.\n', '  function unpause() external onlyCEO whenPaused {\n', "    // can't unpause if contract was upgraded\n", '    paused = false;\n', '  }\n', '\n', '  /// @dev Called by any "C-level" role to set the contract to . Used only when\n', '  ///  a bug or exploit is detected and we need to limit damage.\n', '  function setToForking() external onlyCLevel whenNotForking {\n', '    forking = true;\n', '  }\n', '\n', '  /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '  ///  one reason we may pause the contract is when CFO or COO accounts are\n', '  ///  compromised.\n', '  function setToNotForking() external onlyCEO whenForking {\n', "    // can't unpause if contract was upgraded\n", '    forking = false;\n', '  }\n', '\n', '  /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '  /// @param _newCEO The address of the new CEO\n', '  function setCEO(address _newCEO) external onlyCEO {\n', '    require(_newCEO != address(0));\n', '\n', '    ceoAddress = _newCEO;\n', '  }\n', '\n', '  /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n', '  /// @param _newCFO The address of the new CFO\n', '  function setCFO(address _newCFO) external onlyCEO {\n', '    require(_newCFO != address(0));\n', '\n', '    cfoAddress = _newCFO;\n', '  }\n', '\n', '  /// @dev Assigns a new address to act as the COO1. Only available to the current CEO.\n', '  /// @param _newCOO1 The address of the new COO1\n', '  function setCOO1(address _newCOO1) external onlyCEO {\n', '    require(_newCOO1 != address(0));\n', '\n', '    cooAddress1 = _newCOO1;\n', '  }\n', '\n', '  /// @dev Assigns a new address to act as the COO2. Only available to the current CEO.\n', '  /// @param _newCOO2 The address of the new COO2\n', '  function setCOO2(address _newCOO2) external onlyCEO {\n', '    require(_newCOO2 != address(0));\n', '\n', '    cooAddress2 = _newCOO2;\n', '  }\n', '\n', '  /// @dev Assigns a new address to act as the COO3. Only available to the current CEO.\n', '  /// @param _newCOO3 The address of the new COO3\n', '  function setCOO3(address _newCOO3) external onlyCEO {\n', '    require(_newCOO3 != address(0));\n', '\n', '    cooAddress3 = _newCOO3;\n', '  }\n', '\n', '  /// @dev Backup fn to allow transfer of token out of\n', '  ///  contract, for use where a purchase group wants to use an alternate\n', '  ///  selling platform\n', '  /// @param _tokenId The ID of the Token purchase group\n', '  /// @param _to Address to transfer token to\n', '  function transferToken(uint256 _tokenId, address _to) external onlyCOO {\n', '    var group = tokenIndexToGroup[_tokenId];\n', '\n', '    // Safety check to make sure group exists and had purchased the token\n', '    require(group.exists);\n', '    require(group.purchasePrice > 0);\n', '\n', '    linkedContract.transfer(_to, _tokenId);\n', '  }\n', '\n', '  /// @dev Withdraws sale commission, CFO-only functionality\n', '  /// @param _to Address for commission to be sent to\n', '  function withdrawCommission(address _to) external onlyCFO {\n', '    uint256 balance = commissionBalance;\n', '    address transferee = (_to == address(0)) ? cfoAddress : _to;\n', '    commissionBalance = 0;\n', '    if (balance > 0) {\n', '      transferee.transfer(balance);\n', '    }\n', '    FundsWithdrawn(transferee, balance);\n', '  }\n', '\n', '  /** Information Query Fns **/\n', '  /// @dev Get contributed balance in _tokenId token group for user\n', '  /// @param _tokenId The ID of the token to be queried\n', '  function getContributionBalanceForTokenGroup(uint256 _tokenId, address userAdd) external view returns (uint balance) {\n', '    var group = tokenIndexToGroup[_tokenId];\n', '    require(group.exists);\n', '    balance = group.addressToContribution[userAdd];\n', '  }\n', '\n', '  /// @dev Get contributed balance in _tokenId token group for user\n', '  /// @param _tokenId The ID of the token to be queried\n', '  function getSelfContributionBalanceForTokenGroup(uint256 _tokenId) external view returns (uint balance) {\n', '    var group = tokenIndexToGroup[_tokenId];\n', '    require(group.exists);\n', '    balance = group.addressToContribution[msg.sender];\n', '  }\n', '\n', "  /// @dev Get array of contributors' addresses in _tokenId token group\n", '  /// @param _tokenId The ID of the token to be queried\n', '  function getContributorsInTokenGroup(uint256 _tokenId) external view returns (address[] contribAddr) {\n', '    var group = tokenIndexToGroup[_tokenId];\n', '    require(group.exists);\n', '    contribAddr = group.contributorArr;\n', '  }\n', '\n', '  /// @dev Get no. of contributors in _tokenId token group\n', '  /// @param _tokenId The ID of the token to be queried\n', '  function getContributorsInTokenGroupCount(uint256 _tokenId) external view returns (uint count) {\n', '    var group = tokenIndexToGroup[_tokenId];\n', '    require(group.exists);\n', '    count = group.contributorArr.length;\n', '  }\n', '\n', '  /// @dev Get list of tokenIds of token groups a user contributed to\n', '  function getGroupsContributedTo(address userAdd) external view returns (uint256[] groupIds) {\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(userAdd));\n', '\n', '    var contributor = userAddressToContributor[userAdd];\n', '    require(contributor.exists);\n', '\n', '    groupIds = contributor.groupArr;\n', '  }\n', '\n', '  /// @dev Get list of tokenIds of token groups the user contributed to\n', '  function getSelfGroupsContributedTo() external view returns (uint256[] groupIds) {\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(msg.sender));\n', '\n', '    var contributor = userAddressToContributor[msg.sender];\n', '    require(contributor.exists);\n', '\n', '    groupIds = contributor.groupArr;\n', '  }\n', '\n', '  /// @dev Get price at which token group purchased _tokenId token\n', '  function getGroupPurchasedPrice(uint256 _tokenId) external view returns (uint256 price) {\n', '    var group = tokenIndexToGroup[_tokenId];\n', '    require(group.exists);\n', '    require(group.purchasePrice > 0);\n', '    price = group.purchasePrice;\n', '  }\n', '\n', '  /// @dev Get withdrawable balance from sale proceeds for a user\n', '  function getWithdrawableBalance() external view returns (uint256 balance) {\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(msg.sender));\n', '\n', '    var contributor = userAddressToContributor[msg.sender];\n', '    require(contributor.exists);\n', '\n', '    balance = contributor.withdrawableBalance;\n', '  }\n', '\n', '  /// @dev Get total contributed balance in _tokenId token group\n', '  /// @param _tokenId The ID of the token group to be queried\n', '  function getTokenGroupTotalBalance(uint256 _tokenId) external view returns (uint balance) {\n', '    var group = tokenIndexToGroup[_tokenId];\n', '    require(group.exists);\n', '    balance = group.contributedBalance;\n', '  }\n', '\n', '  /*** PRIVATE FUNCTIONS ***/\n', '  /// @dev Safety check on _to address to prevent against an unexpected 0x0 default.\n', '  /// @param _to Address to be checked\n', '  function _addressNotNull(address _to) private pure returns (bool) {\n', '    return _to != address(0);\n', '  }\n', '\n', "  /// @dev Clears record of a Contributor from a Group's record\n", '  /// @param _tokenId Token ID of Group to be cleared\n', '  /// @param _userAdd Address of Contributor\n', '  function _clearContributorRecordInGroup(uint256 _tokenId, address _userAdd) private returns (uint256 refundBalance) {\n', '    var group = tokenIndexToGroup[_tokenId];\n', '\n', "    // Index was saved is 1 + the array's index, b/c 0 is the default value\n", '    //  in a mapping.\n', '    uint cIndex = group.addressToContributorArrIndex[_userAdd] - 1;\n', '    uint lastCIndex = group.contributorArr.length - 1;\n', '    refundBalance = group.addressToContribution[_userAdd];\n', '\n', '    // clear contribution record in group\n', '    tokenIndexToGroup[_tokenId].addressToContributorArrIndex[_userAdd] = 0;\n', '    tokenIndexToGroup[_tokenId].addressToContribution[_userAdd] = 0;\n', '\n', "    // move address in last position to deleted contributor's spot\n", '    if (lastCIndex > 0) {\n', '      tokenIndexToGroup[_tokenId].addressToContributorArrIndex[group.contributorArr[lastCIndex]] = cIndex;\n', '      tokenIndexToGroup[_tokenId].contributorArr[cIndex] = group.contributorArr[lastCIndex];\n', '    }\n', '\n', '    tokenIndexToGroup[_tokenId].contributorArr.length -= 1;\n', '    tokenIndexToGroup[_tokenId].contributedBalance -= refundBalance;\n', '  }\n', '\n', "  /// @dev Clears record of a Group from a Contributor's record\n", '  /// @param _tokenId Token ID of Group to be cleared\n', '  /// @param _userAdd Address of Contributor\n', '  function _clearGroupRecordInContributor(uint256 _tokenId, address _userAdd) private {\n', "    // Index saved is 1 + the array's index, b/c 0 is the default value\n", '    //  in a mapping.\n', '    uint gIndex = userAddressToContributor[_userAdd].tokenIdToGroupArrIndex[_tokenId] - 1;\n', '    uint lastGIndex = userAddressToContributor[_userAdd].groupArr.length - 1;\n', '\n', '    // clear Group record in Contributor\n', '    userAddressToContributor[_userAdd].tokenIdToGroupArrIndex[_tokenId] = 0;\n', '\n', "    // move tokenId from end of array to deleted Group record's spot\n", '    if (lastGIndex > 0) {\n', '      userAddressToContributor[_userAdd].tokenIdToGroupArrIndex[userAddressToContributor[_userAdd].groupArr[lastGIndex]] = gIndex;\n', '      userAddressToContributor[_userAdd].groupArr[gIndex] = userAddressToContributor[_userAdd].groupArr[lastGIndex];\n', '    }\n', '\n', '    userAddressToContributor[_userAdd].groupArr.length -= 1;\n', '  }\n', '\n', '  /// @dev Redistribute proceeds from token purchase\n', '  /// @param _tokenId Token ID of token to be purchased\n', '  /// @param _amount Amount paid into contract for token\n', '  function _distributeProceeds(uint256 _tokenId, uint256 _amount) private {\n', '    uint256 fundsForDistribution = uint256(SafeMath.div(SafeMath.mul(_amount,\n', '      distributionNumerator), distributionDenominator));\n', '    uint256 commission = _amount;\n', '\n', '    for (uint i = 0; i < tokenIndexToGroup[_tokenId].contributorArr.length; i++) {\n', '      address userAdd = tokenIndexToGroup[_tokenId].contributorArr[i];\n', '\n', "      // calculate contributor's sale proceeds and add to their withdrawable balance\n", '      uint256 userProceeds = uint256(SafeMath.div(SafeMath.mul(fundsForDistribution,\n', '        tokenIndexToGroup[_tokenId].addressToContribution[userAdd]),\n', '        tokenIndexToGroup[_tokenId].contributedBalance));\n', '\n', '      _clearGroupRecordInContributor(_tokenId, userAdd);\n', '\n', '      // clear contributor record on group\n', '      tokenIndexToGroup[_tokenId].addressToContribution[userAdd] = 0;\n', '      tokenIndexToGroup[_tokenId].addressToContributorArrIndex[userAdd] = 0;\n', '\n', '      commission -= userProceeds;\n', '      userAddressToContributor[userAdd].withdrawableBalance += userProceeds;\n', '      ProceedsDeposited(_tokenId, userAdd, userProceeds);\n', '    }\n', '\n', '    commissionBalance += commission;\n', '    Commission(_tokenId, commission);\n', '\n', '    activeGroups -= 1;\n', '    tokenIndexToGroup[_tokenId].exists = false;\n', '    tokenIndexToGroup[_tokenId].contributorArr.length = 0;\n', '    tokenIndexToGroup[_tokenId].contributedBalance = 0;\n', '    tokenIndexToGroup[_tokenId].purchasePrice = 0;\n', '  }\n', '\n', '  /// @dev Calculates next price of celebrity token\n', '  /// @param _oldPrice Previous price\n', '  function _newPrice(uint256 _oldPrice) private view returns (uint256 newPrice) {\n', '    if (_oldPrice < firstStepLimit) {\n', '      // first stage\n', '      newPrice = SafeMath.div(SafeMath.mul(_oldPrice, 200), 94);\n', '    } else if (_oldPrice < secondStepLimit) {\n', '      // second stage\n', '      newPrice = SafeMath.div(SafeMath.mul(_oldPrice, 120), 94);\n', '    } else {\n', '      // third stage\n', '      newPrice = SafeMath.div(SafeMath.mul(_oldPrice, 115), 94);\n', '    }\n', '  }\n', '\n', '  /// @dev Calls CelebrityToken purchase fn and updates records\n', '  /// @param _tokenId Token ID of token to be purchased\n', '  /// @param _amount Amount to be paid to CelebrityToken\n', '  function _purchase(uint256 _tokenId, uint256 _amount) private {\n', '    tokenIndexToGroup[_tokenId].purchasePrice = _amount;\n', '    linkedContract.purchase.value(_amount)(_tokenId);\n', '    TokenPurchased(_tokenId, _amount);\n', '  }\n', '\n', '  function _withdrawUserFunds(address userAdd) private {\n', '    uint256 balance = userAddressToContributor[userAdd].withdrawableBalance;\n', '    userAddressToContributor[userAdd].withdrawableBalance = 0;\n', '\n', '    if (balance > 0) {\n', '      FundsWithdrawn(userAdd, balance);\n', '      userAdd.transfer(balance);\n', '    }\n', '  }\n', '}\n', '\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\n', 'contract ERC721 {\n', '  // Required methods\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '  function implementsERC721() public pure returns (bool);\n', '  function ownerOf(uint256 _tokenId) public view returns (address addr);\n', '  function takeOwnership(uint256 _tokenId) public;\n', '  function totalSupply() public view returns (uint256 total);\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function transfer(address _to, uint256 _tokenId) public;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 tokenId);\n', '  event Approval(address indexed owner, address indexed approved, uint256 tokenId);\n', '\n', '  // Optional\n', '  // function name() public view returns (string name);\n', '  // function symbol() public view returns (string symbol);\n', '  // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n', '  // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n', '}\n', '\n', '\n', 'contract CelebrityToken is ERC721 {\n', '\n', '  /*** EVENTS ***/\n', '\n', '  /// @dev The Birth event is fired whenever a new person comes into existence.\n', '  event Birth(uint256 tokenId, string name, address owner);\n', '\n', '  /// @dev The TokenSold event is fired whenever a token is sold.\n', '  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name);\n', '\n', '  /// @dev Transfer event as defined in current draft of ERC721.\n', '  ///  ownership is assigned, including births.\n', '  event Transfer(address from, address to, uint256 tokenId);\n', '\n', '  /*** CONSTANTS ***/\n', '\n', '  /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '  string public constant NAME = "CryptoCelebrities"; // solhint-disable-line\n', '  string public constant SYMBOL = "CelebrityToken"; // solhint-disable-line\n', '\n', '  address public ceoAddress;\n', '  address public cooAddress;\n', '\n', '  uint256 public promoCreatedCount;\n', '\n', '  /*** DATATYPES ***/\n', '  struct Person {\n', '    string name;\n', '  }\n', '\n', '  /*** CONSTRUCTOR ***/\n', '  function CelebrityToken() public {\n', '    ceoAddress = msg.sender;\n', '    cooAddress = msg.sender;\n', '  }\n', '\n', '  /*** PUBLIC FUNCTIONS ***/\n', '  /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().\n', '  /// @param _to The address to be granted transfer approval. Pass address(0) to\n', '  ///  clear all approvals.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function approve(\n', '    address _to,\n', '    uint256 _tokenId\n', '  ) public;\n', '\n', '  /// For querying balance of a particular account\n', '  /// @param _owner The address for balance query\n', '  /// @dev Required for ERC-721 compliance.\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '  /// @dev Creates a new promo Person with the given name, with given _price and assignes it to an address.\n', '  function createPromoPerson(address _owner, string _name, uint256 _price) public;\n', '\n', '  /// @dev Creates a new Person with the given name.\n', '  function createContractPerson(string _name) public;\n', '\n', '  /// @notice Returns all the relevant information about a specific person.\n', '  /// @param _tokenId The tokenId of the person of interest.\n', '  function getPerson(uint256 _tokenId) public view returns (\n', '    string personName,\n', '    uint256 sellingPrice,\n', '    address owner\n', '  );\n', '\n', '  function implementsERC721() public pure returns (bool);\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function name() public pure returns (string);\n', '\n', '  /// For querying owner of token\n', '  /// @param _tokenId The tokenID for owner inquiry\n', '  /// @dev Required for ERC-721 compliance.\n', '  function ownerOf(uint256 _tokenId)\n', '    public\n', '    view\n', '    returns (address owner);\n', '    \n', '  function payout(address _to) public;\n', '\n', '  // Allows someone to send ether and obtain the token\n', '  function purchase(uint256 _tokenId) public payable;\n', '\n', '  function priceOf(uint256 _tokenId) public view returns (uint256 price);\n', '  /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '  /// @param _newCEO The address of the new CEO\n', '  function setCEO(address _newCEO) public;\n', '\n', '  /// @dev Assigns a new address to act as the COO. Only available to the current COO.\n', '  /// @param _newCOO The address of the new COO\n', '  function setCOO(address _newCOO) public;\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function symbol() public pure returns (string);\n', '  /// @notice Allow pre-approved user to take ownership of a token\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function takeOwnership(uint256 _tokenId) public;\n', '\n', '  /// @param _owner The owner whose celebrity tokens we are interested in.\n', "  /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\n", '  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\n', '  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '  ///  not contract-to-contract calls.\n', '  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens);\n', '\n', '  /// For querying totalSupply of token\n', '  /// @dev Required for ERC-721 compliance.\n', '  function totalSupply() public view returns (uint256 total);\n', '\n', '  /// Owner initates the transfer of the token to another account\n', '  /// @param _to The address for the token to be transferred to.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function transfer(\n', '    address _to,\n', '    uint256 _tokenId\n', '  ) public;\n', '\n', '  /// Third-party initiates transfer of token from address _from to address _to\n', '  /// @param _from The address for the token to be transferred from.\n', '  /// @param _to The address for the token to be transferred to.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  ) public;\n', '\n', '  /*** PRIVATE FUNCTIONS ***/\n', '  /// Safety check on _to address to prevent against an unexpected 0x0 default.\n', '  function _addressNotNull(address _to) private pure returns (bool);\n', '\n', '  /// For checking approval of transfer for address _to\n', '  function _approved(address _to, uint256 _tokenId) private view returns (bool);\n', '\n', '  /// For creating Person\n', '  function _createPerson(string _name, address _owner, uint256 _price) private;\n', '\n', '  /// Check for token ownership\n', '  function _owns(address claimant, uint256 _tokenId) private view returns (bool);\n', '\n', '  /// For paying out balance on contract\n', '  function _payout(address _to) private;\n', '\n', '  /// @dev Assigns ownership of a specific Person to an address.\n', '  function _transfer(address _from, address _to, uint256 _tokenId) private;\n', '}\n', '\n', '\n', 'library SafeMath {\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']