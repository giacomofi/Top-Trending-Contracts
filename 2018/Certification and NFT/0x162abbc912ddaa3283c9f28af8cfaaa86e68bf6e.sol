['pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract IStorage {\n', '  function processPreSaleBonus(uint minTotalUsdAmountInCents, uint bonusPercent, uint _start, uint _limit) external returns(uint);\n', '  function checkNeedProcessPreSaleBonus(uint minTotalUsdAmountInCents) external view returns(bool);\n', '  function getCountNeedProcessPreSaleBonus(uint minTotalUsdAmountInCents, uint start, uint limit) external view returns(uint);\n', '  function reCountUserPreSaleBonus(uint uId, uint minTotalUsdAmountInCents, uint bonusPercent, uint maxPayTime) external returns(uint, uint);\n', '  function getContributorIndexes(uint index) external view returns(uint);\n', '  function checkNeedSendSHPC(bool proc) external view returns(bool);\n', '  function getCountNeedSendSHPC(uint start, uint limit) external view returns(uint);\n', '  function checkETHRefund(bool proc) external view returns(bool);\n', '  function getCountETHRefund(uint start, uint limit) external view returns(uint);\n', '  function addPayment(address _addr, string pType, uint _value, uint usdAmount, uint currencyUSD, uint tokenWithoutBonus, uint tokenBonus, uint bonusPercent, uint payId) public returns(bool);\n', '  function addPayment(uint uId, string pType, uint _value, uint usdAmount, uint currencyUSD, uint tokenWithoutBonus, uint tokenBonus, uint bonusPercent, uint payId) public returns(bool);\n', '  function checkUserIdExists(uint uId) public view returns(bool);\n', '  function getContributorAddressById(uint uId) public view returns(address);\n', '  function editPaymentByUserId(uint uId, uint payId, uint _payValue, uint _usdAmount, uint _currencyUSD, uint _totalToken, uint _tokenWithoutBonus, uint _tokenBonus, uint _bonusPercent) public returns(bool);\n', '  function getUserPaymentById(uint uId, uint payId) public view returns(uint time, bytes32 pType, uint currencyUSD, uint bonusPercent, uint payValue, uint totalToken, uint tokenBonus, uint tokenWithoutBonus, uint usdAbsRaisedInCents, bool refund);\n', '  function checkWalletExists(address addr) public view returns(bool result);\n', '  function checkReceivedCoins(address addr) public view returns(bool);\n', '  function getContributorId(address addr) public view returns(uint);\n', '  function getTotalCoin(address addr) public view returns(uint);\n', '  function setReceivedCoin(uint uId) public returns(bool);\n', '  function checkPreSaleReceivedBonus(address addr) public view returns(bool);\n', '  function checkRefund(address addr) public view returns(bool);\n', '  function setRefund(uint uId) public returns(bool);\n', '  function getEthPaymentContributor(address addr) public view returns(uint);\n', '  function refundPaymentByUserId(uint uId, uint payId) public returns(bool);\n', '  function changeSupportChangeMainWallet(bool support) public returns(bool);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title String\n', ' * @dev ConcatenationString, uintToString, stringsEqual, stringToBytes32, bytes32ToString\n', ' */\n', 'contract String {\n', '\n', '  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string memory) {\n', '    bytes memory _ba = bytes(_a);\n', '    bytes memory _bb = bytes(_b);\n', '    bytes memory _bc = bytes(_c);\n', '    bytes memory _bd = bytes(_d);\n', '    bytes memory _be = bytes(_e);\n', '    bytes memory abcde = bytes(new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length));\n', '    uint k = 0;\n', '    uint i;\n', '    for (i = 0; i < _ba.length; i++) {\n', '      abcde[k++] = _ba[i];\n', '    }\n', '    for (i = 0; i < _bb.length; i++) {\n', '      abcde[k++] = _bb[i];\n', '    }\n', '    for (i = 0; i < _bc.length; i++) {\n', '      abcde[k++] = _bc[i];\n', '    }\n', '    for (i = 0; i < _bd.length; i++) {\n', '      abcde[k++] = _bd[i];\n', '    }\n', '    for (i = 0; i < _be.length; i++) {\n', '      abcde[k++] = _be[i];\n', '    }\n', '    return string(abcde);\n', '  }\n', '\n', '  function strConcat(string _a, string _b, string _c, string _d) internal pure returns(string) {\n', '    return strConcat(_a, _b, _c, _d, "");\n', '  }\n', '\n', '  function strConcat(string _a, string _b, string _c) internal pure returns(string) {\n', '    return strConcat(_a, _b, _c, "", "");\n', '  }\n', '\n', '  function strConcat(string _a, string _b) internal pure returns(string) {\n', '    return strConcat(_a, _b, "", "", "");\n', '  }\n', '\n', '  function uint2str(uint i) internal pure returns(string) {\n', '    if (i == 0) {\n', '      return "0";\n', '    }\n', '    uint j = i;\n', '    uint length;\n', '    while (j != 0) {\n', '      length++;\n', '      j /= 10;\n', '    }\n', '    bytes memory bstr = new bytes(length);\n', '    uint k = length - 1;\n', '    while (i != 0) {\n', '      bstr[k--] = byte(uint8(48 + i % 10));\n', '      i /= 10;\n', '    }\n', '    return string(bstr);\n', '  }\n', '\n', '  function stringsEqual(string memory _a, string memory _b) internal pure returns(bool) {\n', '    bytes memory a = bytes(_a);\n', '    bytes memory b = bytes(_b);\n', '\n', '    if (a.length != b.length)\n', '      return false;\n', '\n', '    for (uint i = 0; i < a.length; i++) {\n', '      if (a[i] != b[i]) {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  function stringToBytes32(string memory source) internal pure returns(bytes32 result) {\n', '    bytes memory _tmp = bytes(source);\n', '    if (_tmp.length == 0) {\n', '      return 0x0;\n', '    }\n', '    assembly {\n', '      result := mload(add(source, 32))\n', '    }\n', '  }\n', '\n', '  function bytes32ToString(bytes32 x) internal pure returns (string) {\n', '    bytes memory bytesString = new bytes(32);\n', '    uint charCount = 0;\n', '    uint j;\n', '    for (j = 0; j < 32; j++) {\n', '      byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '      if (char != 0) {\n', '        bytesString[charCount] = char;\n', '        charCount++;\n', '      }\n', '    }\n', '    bytes memory bytesStringTrimmed = new bytes(charCount);\n', '    for (j = 0; j < charCount; j++) {\n', '      bytesStringTrimmed[j] = bytesString[j];\n', '    }\n', '    return string(bytesStringTrimmed);\n', '  }\n', '\n', '  function inArray(string[] _array, string _value) internal pure returns(bool result) {\n', '    if (_array.length == 0 || bytes(_value).length == 0) {\n', '      return false;\n', '    }\n', '    result = false;\n', '    for (uint i = 0; i < _array.length; i++) {\n', '      if (stringsEqual(_array[i],_value)) {\n', '        result = true;\n', '        return true;\n', '      }\n', '    }\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor () public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title MultiOwnable\n', ' * @dev The MultiOwnable contract has an owner address[], and provides basic authorization control\n', ' */\n', 'contract MultiOwnable is Ownable {\n', '\n', '  struct Types {\n', '    mapping (address => bool) access;\n', '  }\n', '  mapping (uint => Types) private multiOwnersTypes;\n', '\n', '  event AddOwner(uint _type, address addr);\n', '  event AddOwner(uint[] types, address addr);\n', '  event RemoveOwner(uint _type, address addr);\n', '\n', '  modifier onlyMultiOwnersType(uint _type) {\n', '    require(multiOwnersTypes[_type].access[msg.sender] || msg.sender == owner, "403");\n', '    _;\n', '  }\n', '\n', '  function onlyMultiOwnerType(uint _type, address _sender) public view returns(bool) {\n', '    if (multiOwnersTypes[_type].access[_sender] || _sender == owner) {\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function addMultiOwnerType(uint _type, address _owner) public onlyOwner returns(bool) {\n', '    require(_owner != address(0));\n', '    multiOwnersTypes[_type].access[_owner] = true;\n', '    emit AddOwner(_type, _owner);\n', '    return true;\n', '  }\n', '  \n', '  function addMultiOwnerTypes(uint[] types, address _owner) public onlyOwner returns(bool) {\n', '    require(_owner != address(0));\n', '    require(types.length > 0);\n', '    for (uint i = 0; i < types.length; i++) {\n', '      multiOwnersTypes[types[i]].access[_owner] = true;\n', '    }\n', '    emit AddOwner(types, _owner);\n', '    return true;\n', '  }\n', '\n', '  function removeMultiOwnerType(uint types, address _owner) public onlyOwner returns(bool) {\n', '    require(_owner != address(0));\n', '    multiOwnersTypes[types].access[_owner] = false;\n', '    emit RemoveOwner(types, _owner);\n', '    return true;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Whitelist\n', ' * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n', ' * @dev This simplifies the implementation of "user permissions".\n', ' */\n', 'contract ShipCoinStorage is IStorage, MultiOwnable, String {\n', '  using SafeMath for uint256;\n', '\n', '  /* Events */\n', '  event WhitelistAddressAdded(address addr);\n', '  event WhitelistAddressRemoved(address addr);\n', '  event AddPayment(address addr);\n', '  event GotPreSaleBonus(address addr);\n', '  event EditUserPayments(address addr, uint payId);\n', '  event RefundPayment(address addr, uint payId);\n', '  event ReceivedCoin(address addr);\n', '  event Refund(address addr);\n', '  event ChangeMainWallet(address addr);\n', '\n', '  struct PaymentData {\n', '    uint time;\n', '    bytes32 pType;\n', '    uint currencyUSD;\n', '    uint payValue;\n', '    uint totalToken;\n', '    uint tokenWithoutBonus;\n', '    uint tokenBonus;\n', '    uint bonusPercent;\n', '    uint usdAbsRaisedInCents;\n', '  }\n', '\n', '  struct StorageData {\n', '    bool active;\n', '    mapping(bytes32 => uint) payInCurrency;\n', '    uint totalToken;\n', '    uint tokenWithoutBonus;\n', '    uint tokenBonus;\n', '    uint usdAbsRaisedInCents;\n', '    mapping(uint => PaymentData) paymentInfo;\n', '    address mainWallet;\n', '    address[] wallet;\n', '  }\n', '  // uId = { }\n', '  mapping(uint => StorageData) private contributorList;\n', '  // wallet = uId\n', '  mapping(address => uint) private contributorIds;\n', '  // i++ = uId\n', '  mapping(uint => uint) private contributorIndexes;\n', '  //uId = payIds\n', '  mapping(uint => uint[]) private contributorPayIds;\n', '  uint public nextContributorIndex;\n', '\n', '  bytes32[] private currencyTicker;\n', '  // uId\n', '  mapping(uint => uint) private receivedPreSaleBonus;\n', '  // uId\n', '  mapping(uint => bool) private receivedCoin;\n', '  //payIds\n', '  mapping(uint => bool) private payIds;\n', '  //payIds\n', '  mapping(uint => bool) private refundPayIds;\n', '  //uId\n', '  mapping(uint => bool) private refundUserIds;\n', '\n', '  uint private startGenId = 100000;\n', '\n', '  bool public supportChangeMainWallet = true;\n', '\n', '  /**\n', '   * @dev Calculate contributors appoint presale bonus\n', '   */\n', '  function processPreSaleBonus(uint minTotalUsdAmountInCents, uint bonusPercent, uint _start, uint _limit) external onlyMultiOwnersType(12) returns(uint) {\n', '    require(minTotalUsdAmountInCents > 10000);\n', '    require(bonusPercent > 20 && bonusPercent < 50);\n', '    require(_limit >= 10);\n', '\n', '    uint start = _start;\n', '    uint limit = _limit;\n', '    uint bonusTokenAll = 0;\n', '    for (uint i = start; i < limit; i++) {\n', '      uint uId = contributorIndexes[i];\n', '      if (contributorList[uId].active && !checkPreSaleReceivedBonus(uId) && contributorList[uId].usdAbsRaisedInCents >= minTotalUsdAmountInCents) {\n', '        uint bonusToken = contributorList[uId].tokenWithoutBonus.mul(bonusPercent).div(100);\n', '\n', '        contributorList[uId].totalToken += bonusToken;\n', '        contributorList[uId].tokenBonus = bonusToken;\n', '        receivedPreSaleBonus[uId] = bonusToken;\n', '        bonusTokenAll += bonusToken;\n', '        emit GotPreSaleBonus(contributorList[uId].mainWallet);\n', '      }\n', '    }\n', '\n', '    return bonusTokenAll;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks contributors who have not received their presale bonuses\n', '   */\n', '  function checkNeedProcessPreSaleBonus(uint minTotalUsdAmountInCents) external view returns(bool) {\n', '    require(minTotalUsdAmountInCents > 10000);\n', '    bool processed = false;\n', '    for (uint i = 0; i < nextContributorIndex; i++) {\n', '      if (processed) {\n', '        break;\n', '      }\n', '      uint uId = contributorIndexes[i];\n', '      if (contributorList[uId].active && !refundUserIds[uId] && !checkPreSaleReceivedBonus(uId) && contributorList[uId].usdAbsRaisedInCents >= minTotalUsdAmountInCents) {\n', '        processed = true;\n', '      }\n', '    }\n', '    return processed;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number of contributors who have not received their presale bonuses\n', '   */\n', '  function getCountNeedProcessPreSaleBonus(uint minTotalUsdAmountInCents, uint start, uint limit) external view returns(uint) {\n', '    require(minTotalUsdAmountInCents > 10000);\n', '    require(start >= 0 && limit >= 10);\n', '    uint processed = 0;\n', '    for (uint i = start; i < (limit > nextContributorIndex ? nextContributorIndex : limit); i++) {\n', '      uint uId = contributorIndexes[i];\n', '      if (contributorList[uId].active && !refundUserIds[uId] && !checkPreSaleReceivedBonus(uId) && contributorList[uId].usdAbsRaisedInCents >= minTotalUsdAmountInCents) {\n', '        processed++;\n', '      }\n', '    }\n', '    return processed;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks contributors who have not received their SHPC\n', '   */\n', '  function checkNeedSendSHPC(bool proc) external view returns(bool) {\n', '    bool processed = false;\n', '    if (proc) {\n', '      for (uint i = 0; i < nextContributorIndex; i++) {\n', '        if (processed) {\n', '          break;\n', '        }\n', '        uint uId = contributorIndexes[i];\n', '        if (contributorList[uId].active && !refundUserIds[uId] && !checkReceivedCoins(uId) && contributorList[uId].totalToken > 0) {\n', '          processed = true;\n', '        }\n', '      }\n', '    }\n', '    return processed;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number of contributors who have not received their SHPC\n', '   */\n', '  function getCountNeedSendSHPC(uint start, uint limit) external view returns(uint) {\n', '    require(start >= 0 && limit >= 10);\n', '    uint processed = 0;\n', '    for (uint i = start; i < (limit > nextContributorIndex ? nextContributorIndex : limit); i++) {\n', '      uint uId = contributorIndexes[i];\n', '      if (contributorList[uId].active && !refundUserIds[uId] && !checkReceivedCoins(uId) && contributorList[uId].totalToken > 0) {\n', '        processed++;\n', '      }\n', '    }\n', '    return processed;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks contributors who have not received their ETH when refund\n', '   */\n', '  function checkETHRefund(bool proc) external view returns(bool) {\n', '    bool processed = false;\n', '    if (proc) {\n', '      for (uint i = 0; i < nextContributorIndex; i++) {\n', '        if (processed) {\n', '          break;\n', '        }\n', '        uint uId = contributorIndexes[i];\n', '        if (contributorList[uId].active && !refundUserIds[uId] && getEthPaymentContributor(uId) > 0) {\n', '          processed = true;\n', '        }\n', '      }\n', '    }\n', '    return processed;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number of contributors who have not received their ETH when refund\n', '   */\n', '  function getCountETHRefund(uint start, uint limit) external view returns(uint) {\n', '    require(start >= 0 && limit >= 10);\n', '    uint processed = 0;\n', '    for (uint i = start; i < (limit > nextContributorIndex ? nextContributorIndex : limit); i++) {\n', '      uint uId = contributorIndexes[i];\n', '      if (contributorList[uId].active && !refundUserIds[uId] && getEthPaymentContributor(uId) > 0) {\n', '        processed++;\n', '      }\n', '    }\n', '    return processed;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns uId by index;\n', '   */\n', '  function getContributorIndexes(uint index) external onlyMultiOwnersType(7) view returns(uint) {\n', '    return contributorIndexes[index];\n', '  }\n', '\n', '  /**\n', '   * @dev Recalculation contributors presale bonus\n', '   */\n', '  function reCountUserPreSaleBonus(uint _uId, uint minTotalUsdAmountInCents, uint bonusPercent, uint maxPayTime) external onlyMultiOwnersType(13) returns(uint, uint) {\n', '    require(_uId > 0);\n', '    require(contributorList[_uId].active);\n', '    require(!refundUserIds[_uId]);\n', '    require(minTotalUsdAmountInCents > 10000);\n', '    require(bonusPercent > 20 && bonusPercent < 50);\n', '    uint bonusToken = 0;\n', '    uint uId = _uId;\n', '    uint beforeBonusToken = receivedPreSaleBonus[uId];\n', '\n', '    if (beforeBonusToken > 0) {\n', '      contributorList[uId].totalToken -= beforeBonusToken;\n', '      contributorList[uId].tokenBonus -= beforeBonusToken;\n', '      receivedPreSaleBonus[uId] = 0;\n', '    }\n', '\n', '    if (contributorList[uId].usdAbsRaisedInCents >= minTotalUsdAmountInCents) {\n', '      if (maxPayTime > 0) {\n', '        for (uint i = 0; i < contributorPayIds[uId].length; i++) {\n', '          PaymentData memory _payment = contributorList[uId].paymentInfo[contributorPayIds[uId][i]];\n', '          if (!refundPayIds[contributorPayIds[uId][i]] && _payment.bonusPercent == 0 && _payment.time < maxPayTime) {\n', '            bonusToken += _payment.tokenWithoutBonus.mul(bonusPercent).div(100);\n', '          }\n', '        }\n', '      } else {\n', '        bonusToken = contributorList[uId].tokenWithoutBonus.mul(bonusPercent).div(100);\n', '      }\n', '\n', '      if (bonusToken > 0) {\n', '        contributorList[uId].totalToken += bonusToken;\n', '        contributorList[uId].tokenBonus += bonusToken;\n', '        receivedPreSaleBonus[uId] = bonusToken;\n', '        emit GotPreSaleBonus(contributorList[uId].mainWallet);\n', '      }\n', '    }\n', '    return (beforeBonusToken, bonusToken);\n', '  }\n', '\n', '  /**\n', '   * @dev add user and wallet to whitelist\n', '   */\n', '  function addWhiteList(uint uId, address addr) public onlyMultiOwnersType(1) returns(bool success) {\n', '    require(addr != address(0), "1");\n', '    require(uId > 0, "2");\n', '    require(!refundUserIds[uId]);\n', '\n', '    if (contributorIds[addr] > 0 && contributorIds[addr] != uId) {\n', '      success = false;\n', '      revert("3");\n', '    }\n', '\n', '    if (contributorList[uId].active != true) {\n', '      contributorList[uId].active = true;\n', '      contributorIndexes[nextContributorIndex] = uId;\n', '      nextContributorIndex++;\n', '      contributorList[uId].mainWallet = addr;\n', '    }\n', '\n', '    if (inArray(contributorList[uId].wallet, addr) != true && contributorList[uId].wallet.length < 3) {\n', '      contributorList[uId].wallet.push(addr);\n', '      contributorIds[addr] = uId;\n', '      emit WhitelistAddressAdded(addr);\n', '      success = true;\n', '    } else {\n', '      success = false;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove user wallet from whitelist\n', '   */\n', '  function removeWhiteList(uint uId, address addr) public onlyMultiOwnersType(2) returns(bool success) {\n', '    require(contributorList[uId].active, "1");\n', '    require(addr != address(0), "2");\n', '    require(uId > 0, "3");\n', '    require(inArray(contributorList[uId].wallet, addr));\n', '\n', '    if (contributorPayIds[uId].length > 0 || contributorList[uId].mainWallet == addr) {\n', '      success = false;\n', '      revert("5");\n', '    }\n', '\n', '\n', '    contributorList[uId].wallet = removeValueFromArray(contributorList[uId].wallet, addr);\n', '    delete contributorIds[addr];\n', '\n', '    emit WhitelistAddressRemoved(addr);\n', '    success = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Change contributor mainWallet\n', '   */\n', '  function changeMainWallet(uint uId, address addr) public onlyMultiOwnersType(3) returns(bool) {\n', '    require(supportChangeMainWallet);\n', '    require(addr != address(0));\n', '    require(uId > 0);\n', '    require(contributorList[uId].active);\n', '    require(!refundUserIds[uId]);\n', '    require(inArray(contributorList[uId].wallet, addr));\n', '\n', '    contributorList[uId].mainWallet = addr;\n', '    emit ChangeMainWallet(addr);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Change the right to change mainWallet\n', '   */\n', '  function changeSupportChangeMainWallet(bool support) public onlyMultiOwnersType(21) returns(bool) {\n', '    supportChangeMainWallet = support;\n', '    return supportChangeMainWallet;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns all contributor info by uId\n', '   */\n', '  function getContributionInfoById(uint _uId) public onlyMultiOwnersType(4) view returns(\n', '      bool active,\n', '      string payInCurrency,\n', '      uint totalToken,\n', '      uint tokenWithoutBonus,\n', '      uint tokenBonus,\n', '      uint usdAbsRaisedInCents,\n', '      uint[] paymentInfoIds,\n', '      address mainWallet,\n', '      address[] wallet,\n', '      uint preSaleReceivedBonus,\n', '      bool receivedCoins,\n', '      bool refund\n', '    )\n', '  {\n', '    uint uId = _uId;\n', '    return getContributionInfo(contributorList[uId].mainWallet);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns all contributor info by address\n', '   */\n', '  function getContributionInfo(address _addr)\n', '    public\n', '    view\n', '    returns(\n', '      bool active,\n', '      string payInCurrency,\n', '      uint totalToken,\n', '      uint tokenWithoutBonus,\n', '      uint tokenBonus,\n', '      uint usdAbsRaisedInCents,\n', '      uint[] paymentInfoIds,\n', '      address mainWallet,\n', '      address[] wallet,\n', '      uint preSaleReceivedBonus,\n', '      bool receivedCoins,\n', '      bool refund\n', '    )\n', '  {\n', '\n', '    address addr = _addr;\n', '    StorageData memory storData = contributorList[contributorIds[addr]];\n', '\n', '    (preSaleReceivedBonus, receivedCoins, refund) = getInfoAdditionl(addr);\n', '\n', '    return(\n', '    storData.active,\n', '    (contributorPayIds[contributorIds[addr]].length > 0 ? getContributorPayInCurrency(contributorIds[addr]) : "[]"),\n', '    storData.totalToken,\n', '    storData.tokenWithoutBonus,\n', '    storData.tokenBonus,\n', '    storData.usdAbsRaisedInCents,\n', '    contributorPayIds[contributorIds[addr]],\n', '    storData.mainWallet,\n', '    storData.wallet,\n', '    preSaleReceivedBonus,\n', '    receivedCoins,\n', '    refund\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Returns contributor id by address\n', '   */\n', '  function getContributorId(address addr) public onlyMultiOwnersType(5) view returns(uint) {\n', '    return contributorIds[addr];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns contributors address by uId\n', '   */\n', '  function getContributorAddressById(uint uId) public onlyMultiOwnersType(6) view returns(address) {\n', '    require(uId > 0);\n', '    require(contributorList[uId].active);\n', '    return contributorList[uId].mainWallet;\n', '  }\n', '\n', '  /**\n', '   * @dev Check wallet exists by address\n', '   */\n', '  function checkWalletExists(address addr) public view returns(bool result) {\n', '    result = false;\n', '    if (contributorList[contributorIds[addr]].wallet.length > 0) {\n', '      result = inArray(contributorList[contributorIds[addr]].wallet, addr);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Check userId is exists\n', '   */\n', '  function checkUserIdExists(uint uId) public onlyMultiOwnersType(8) view returns(bool) {\n', '    return contributorList[uId].active;\n', '  }\n', '\n', '  /**\n', '   * @dev Add payment by address\n', '   */\n', '  function addPayment(\n', '    address _addr,\n', '    string pType,\n', '    uint _value,\n', '    uint usdAmount,\n', '    uint currencyUSD,\n', '    uint tokenWithoutBonus,\n', '    uint tokenBonus,\n', '    uint bonusPercent,\n', '    uint payId\n', '  )\n', '  public\n', '  onlyMultiOwnersType(9)\n', '  returns(bool)\n', '  {\n', '    require(_value > 0);\n', '    require(usdAmount > 0);\n', '    require(tokenWithoutBonus > 0);\n', '    require(bytes(pType).length > 0);\n', '    assert((payId == 0 && stringsEqual(pType, "ETH")) || (payId > 0 && !payIds[payId]));\n', '\n', '    address addr = _addr;\n', '    uint uId = contributorIds[addr];\n', '\n', '    assert(addr != address(0));\n', '    assert(checkWalletExists(addr));\n', '    assert(uId > 0);\n', '    assert(contributorList[uId].active);\n', '    assert(!refundUserIds[uId]);\n', '    assert(!receivedCoin[uId]);\n', '\n', '    if (payId == 0) {\n', '      payId = genId(addr, _value, 0);\n', '    }\n', '\n', '    bytes32 _pType = stringToBytes32(pType);\n', '    PaymentData memory userPayment;\n', '    uint totalToken = tokenWithoutBonus.add(tokenBonus);\n', '\n', '    //userPayment.payId = payId;\n', '    userPayment.time = block.timestamp;\n', '    userPayment.pType = _pType;\n', '    userPayment.currencyUSD = currencyUSD;\n', '    userPayment.payValue = _value;\n', '    userPayment.totalToken = totalToken;\n', '    userPayment.tokenWithoutBonus = tokenWithoutBonus;\n', '    userPayment.tokenBonus = tokenBonus;\n', '    userPayment.bonusPercent = bonusPercent;\n', '    userPayment.usdAbsRaisedInCents = usdAmount;\n', '\n', '    if (!inArray(currencyTicker, _pType)) {\n', '      currencyTicker.push(_pType);\n', '    }\n', '    if (payId > 0) {\n', '      payIds[payId] = true;\n', '    }\n', '\n', '    contributorList[uId].usdAbsRaisedInCents += usdAmount;\n', '    contributorList[uId].totalToken += totalToken;\n', '    contributorList[uId].tokenWithoutBonus += tokenWithoutBonus;\n', '    contributorList[uId].tokenBonus += tokenBonus;\n', '\n', '    contributorList[uId].payInCurrency[_pType] += _value;\n', '    contributorList[uId].paymentInfo[payId] = userPayment;\n', '    contributorPayIds[uId].push(payId);\n', '\n', '    emit AddPayment(addr);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Add payment by uId\n', '   */\n', '  function addPayment(\n', '    uint uId,\n', '    string pType,\n', '    uint _value,\n', '    uint usdAmount,\n', '    uint currencyUSD,\n', '    uint tokenWithoutBonus,\n', '    uint tokenBonus,\n', '    uint bonusPercent,\n', '    uint payId\n', '  )\n', '  public\n', '  returns(bool)\n', '  {\n', '    require(contributorList[uId].active);\n', '    require(contributorList[uId].mainWallet != address(0));\n', '    return addPayment(contributorList[uId].mainWallet, pType, _value, usdAmount, currencyUSD, tokenWithoutBonus, tokenBonus, bonusPercent, payId);\n', '  }\n', '\n', '  /**\n', '   * @dev Edit user payment info\n', '   */\n', '  function editPaymentByUserId(\n', '    uint uId,\n', '    uint payId,\n', '    uint _payValue,\n', '    uint _usdAmount,\n', '    uint _currencyUSD,\n', '    uint _totalToken,\n', '    uint _tokenWithoutBonus,\n', '    uint _tokenBonus,\n', '    uint _bonusPercent\n', '  )\n', '  public\n', '  onlyMultiOwnersType(10)\n', '  returns(bool)\n', '  {\n', '    require(contributorList[uId].active);\n', '    require(inArray(contributorPayIds[uId], payId));\n', '    require(!refundPayIds[payId]);\n', '    require(!refundUserIds[uId]);\n', '    require(!receivedCoin[uId]);\n', '\n', '    PaymentData memory oldPayment = contributorList[uId].paymentInfo[payId];\n', '\n', '    contributorList[uId].usdAbsRaisedInCents -= oldPayment.usdAbsRaisedInCents;\n', '    contributorList[uId].totalToken -= oldPayment.totalToken;\n', '    contributorList[uId].tokenWithoutBonus -= oldPayment.tokenWithoutBonus;\n', '    contributorList[uId].tokenBonus -= oldPayment.tokenBonus;\n', '    contributorList[uId].payInCurrency[oldPayment.pType] -= oldPayment.payValue;\n', '\n', '    contributorList[uId].paymentInfo[payId] = PaymentData(\n', '      oldPayment.time,\n', '      oldPayment.pType,\n', '      _currencyUSD,\n', '      _payValue,\n', '      _totalToken,\n', '      _tokenWithoutBonus,\n', '      _tokenBonus,\n', '      _bonusPercent,\n', '      _usdAmount\n', '    );\n', '\n', '    contributorList[uId].usdAbsRaisedInCents += _usdAmount;\n', '    contributorList[uId].totalToken += _totalToken;\n', '    contributorList[uId].tokenWithoutBonus += _tokenWithoutBonus;\n', '    contributorList[uId].tokenBonus += _tokenBonus;\n', '    contributorList[uId].payInCurrency[oldPayment.pType] += _payValue;\n', '\n', '    emit EditUserPayments(contributorList[uId].mainWallet, payId);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Refund user payment\n', '   */\n', '  function refundPaymentByUserId(uint uId, uint payId) public onlyMultiOwnersType(20) returns(bool) {\n', '    require(contributorList[uId].active);\n', '    require(inArray(contributorPayIds[uId], payId));\n', '    require(!refundPayIds[payId]);\n', '    require(!refundUserIds[uId]);\n', '    require(!receivedCoin[uId]);\n', '\n', '    PaymentData memory oldPayment = contributorList[uId].paymentInfo[payId];\n', '\n', '    assert(oldPayment.pType != stringToBytes32("ETH"));\n', '\n', '    contributorList[uId].usdAbsRaisedInCents -= oldPayment.usdAbsRaisedInCents;\n', '    contributorList[uId].totalToken -= oldPayment.totalToken;\n', '    contributorList[uId].tokenWithoutBonus -= oldPayment.tokenWithoutBonus;\n', '    contributorList[uId].tokenBonus -= oldPayment.tokenBonus;\n', '    contributorList[uId].payInCurrency[oldPayment.pType] -= oldPayment.payValue;\n', '\n', '    refundPayIds[payId] = true;\n', '\n', '    emit RefundPayment(contributorList[uId].mainWallet, payId);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Reutrns user payment info by uId and paymentId\n', '   */\n', '  function getUserPaymentById(uint _uId, uint _payId) public onlyMultiOwnersType(11) view returns(\n', '    uint time,\n', '    bytes32 pType,\n', '    uint currencyUSD,\n', '    uint bonusPercent,\n', '    uint payValue,\n', '    uint totalToken,\n', '    uint tokenBonus,\n', '    uint tokenWithoutBonus,\n', '    uint usdAbsRaisedInCents,\n', '    bool refund\n', '  )\n', '  {\n', '    uint uId = _uId;\n', '    uint payId = _payId;\n', '    require(contributorList[uId].active);\n', '    require(inArray(contributorPayIds[uId], payId));\n', '\n', '    PaymentData memory payment = contributorList[uId].paymentInfo[payId];\n', '\n', '    return (\n', '      payment.time,\n', '      payment.pType,\n', '      payment.currencyUSD,\n', '      payment.bonusPercent,\n', '      payment.payValue,\n', '      payment.totalToken,\n', '      payment.tokenBonus,\n', '      payment.tokenWithoutBonus,\n', '      payment.usdAbsRaisedInCents,\n', '      refundPayIds[payId] ? true : false\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Reutrns user payment info by address and payment id\n', '   */\n', '  function getUserPayment(address addr, uint _payId) public view returns(\n', '    uint time,\n', '    string pType,\n', '    uint currencyUSD,\n', '    uint bonusPercent,\n', '    uint payValue,\n', '    uint totalToken,\n', '    uint tokenBonus,\n', '    uint tokenWithoutBonus,\n', '    uint usdAbsRaisedInCents,\n', '    bool refund\n', '  )\n', '  {\n', '    address _addr = addr;\n', '    require(contributorList[contributorIds[_addr]].active);\n', '    require(inArray(contributorPayIds[contributorIds[_addr]], _payId));\n', '\n', '    uint payId = _payId;\n', '\n', '    PaymentData memory payment = contributorList[contributorIds[_addr]].paymentInfo[payId];\n', '\n', '    return (\n', '      payment.time,\n', '      bytes32ToString(payment.pType),\n', '      payment.currencyUSD,\n', '      payment.bonusPercent,\n', '      payment.payValue,\n', '      payment.totalToken,\n', '      payment.tokenBonus,\n', '      payment.tokenWithoutBonus,\n', '      payment.usdAbsRaisedInCents,\n', '      refundPayIds[payId] ? true : false\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Returns payment in ETH from address\n', '   */\n', '  function getEthPaymentContributor(address addr) public view returns(uint) {\n', '    return contributorList[contributorIds[addr]].payInCurrency[stringToBytes32("ETH")];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns SHPC from address\n', '   */\n', '  function getTotalCoin(address addr) public view returns(uint) {\n', '    return contributorList[contributorIds[addr]].totalToken;\n', '  }\n', '\n', '  /**\n', '   * @dev Check user get pre sale bonus by address\n', '   */\n', '  function checkPreSaleReceivedBonus(address addr) public view returns(bool) {\n', '    return receivedPreSaleBonus[contributorIds[addr]] > 0 ? true : false;\n', '  }\n', '\n', '  /**\n', '   * @dev Check payment refund by payment id\n', '   */\n', '  function checkPaymentRefund(uint payId) public view returns(bool) {\n', '    return refundPayIds[payId];\n', '  }\n', '\n', '  /**\n', '   * @dev Check user refund by address\n', '   */\n', '  function checkRefund(address addr) public view returns(bool) {\n', '    return refundUserIds[contributorIds[addr]];\n', '  }\n', '\n', '  /**\n', '   * @dev Set start number generate payment id when user pay in eth\n', '   */\n', '  function setStartGenId(uint startId) public onlyMultiOwnersType(14) {\n', '    require(startId > 0);\n', '    startGenId = startId;\n', '  }\n', '\n', '  /**\n', '   * @dev Set contributer got SHPC\n', '   */\n', '  function setReceivedCoin(uint uId) public onlyMultiOwnersType(15) returns(bool) {\n', '    require(contributorList[uId].active);\n', '    require(!refundUserIds[uId]);\n', '    require(!receivedCoin[uId]);\n', '    receivedCoin[uId] = true;\n', '    emit ReceivedCoin(contributorList[uId].mainWallet);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Set contributer got refund ETH\n', '   */\n', '  function setRefund(uint uId) public onlyMultiOwnersType(16) returns(bool) {\n', '    require(contributorList[uId].active);\n', '    require(!refundUserIds[uId]);\n', '    require(!receivedCoin[uId]);\n', '    refundUserIds[uId] = true;\n', '    emit Refund(contributorList[uId].mainWallet);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Check contributor got SHPC\n', '   */\n', '  function checkReceivedCoins(address addr) public view returns(bool) {\n', '    return receivedCoin[contributorIds[addr]];\n', '  }\n', '\n', '  /**\n', '   * @dev Check contributor got ETH\n', '   */\n', '  function checkReceivedEth(address addr) public view returns(bool) {\n', '    return refundUserIds[contributorIds[addr]];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns all contributor currency amount in json\n', '   */\n', '  function getContributorPayInCurrency(uint uId) private view returns(string) {\n', '    require(uId > 0);\n', '    require(contributorList[uId].active);\n', '    string memory payInCurrency = "{";\n', '    for (uint i = 0; i < currencyTicker.length; i++) {\n', '      payInCurrency = strConcat(payInCurrency, strConcat("\\"", bytes32ToString(currencyTicker[i]), "\\":\\""), uint2str(contributorList[uId].payInCurrency[currencyTicker[i]]), (i+1 < currencyTicker.length) ? "\\"," : "\\"}");\n', '    }\n', '    return payInCurrency;\n', '  }\n', '\n', '  /**\n', '   * @dev Check receives presale bonud by uId\n', '   */\n', '  function checkPreSaleReceivedBonus(uint uId) private view returns(bool) {\n', '    return receivedPreSaleBonus[uId] > 0 ? true : false;\n', '  }\n', '\n', '  /**\n', '   * @dev Check refund by uId\n', '   */\n', '  function checkRefund(uint uId) private view returns(bool) {\n', '    return refundUserIds[uId];\n', '  }\n', '\n', '  /**\n', '   * @dev  Check received SHPC by uI\n', '   */\n', '  function checkReceivedCoins(uint id) private view returns(bool) {\n', '    return receivedCoin[id];\n', '  }\n', '\n', '  /**\n', '   * @dev Check received eth by uId\n', '   */\n', '  function checkReceivedEth(uint id) private view returns(bool) {\n', '    return refundUserIds[id];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns new uniq payment id\n', '   */\n', '  function genId(address addr, uint ammount, uint rand) private view returns(uint) {\n', '    uint id = startGenId + uint8(keccak256(abi.encodePacked(addr, blockhash(block.number), ammount, rand))) + contributorPayIds[contributorIds[addr]].length;\n', '    if (!payIds[id]) {\n', '      return id;\n', '    } else {\n', '      return genId(addr, ammount, id);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Returns payment in ETH from uid\n', '   */\n', '  function getEthPaymentContributor(uint uId) private view returns(uint) {\n', '    return contributorList[uId].payInCurrency[stringToBytes32("ETH")];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns adittional info by contributor address\n', '   */\n', '  function getInfoAdditionl(address addr) private view returns(uint, bool, bool) {\n', '    return(receivedPreSaleBonus[contributorIds[addr]], receivedCoin[contributorIds[addr]], refundUserIds[contributorIds[addr]]);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns payments info by userId in json\n', '   */\n', '  function getArrayjsonPaymentInfo(uint uId) private view returns (string) {\n', '    string memory _array = "{";\n', '    for (uint i = 0; i < contributorPayIds[uId].length; i++) {\n', '      _array = strConcat(_array, getJsonPaymentInfo(contributorList[uId].paymentInfo[contributorPayIds[uId][i]], contributorPayIds[uId][i]), (i+1 == contributorPayIds[uId].length) ? "}" : ",");\n', '    }\n', '    return _array;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns payment info by payment data in json\n', '   */\n', '  function getJsonPaymentInfo(PaymentData memory _obj, uint payId) private view returns (string) {\n', '    return strConcat(\n', '      strConcat("\\"", uint2str(payId), "\\":{", strConcat("\\"", "time", "\\":"), uint2str(_obj.time)),\n', '      strConcat(",\\"pType\\":\\"", bytes32ToString(_obj.pType), "\\",\\"currencyUSD\\":", uint2str(_obj.currencyUSD), ",\\"payValue\\":\\""),\n', '      strConcat(uint2str(_obj.payValue), "\\",\\"totalToken\\":\\"", uint2str(_obj.totalToken), "\\",\\"tokenWithoutBonus\\":\\"", uint2str(_obj.tokenWithoutBonus)),\n', '      strConcat("\\",\\"tokenBonus\\":\\"", uint2str(_obj.tokenBonus), "\\",\\"bonusPercent\\":", uint2str(_obj.bonusPercent)),\n', '      strConcat(",\\"usdAbsRaisedInCents\\":\\"", uint2str(_obj.usdAbsRaisedInCents), "\\",\\"refund\\":\\"", (refundPayIds[payId] ? "1" : "0"), "\\"}")\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Check if value contains array\n', '   */\n', '  function inArray(address[] _array, address _value) private pure returns(bool result) {\n', '    if (_array.length == 0 || _value == address(0)) {\n', '      return false;\n', '    }\n', '    result = false;\n', '    for (uint i = 0; i < _array.length; i++) {\n', '      if (_array[i] == _value) {\n', '        result = true;\n', '        return true;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Check if value contains array\n', '   */\n', '  function inArray(uint[] _array, uint _value) private pure returns(bool result) {\n', '    if (_array.length == 0 || _value == 0) {\n', '      return false;\n', '    }\n', '    result = false;\n', '    for (uint i = 0; i < _array.length; i++) {\n', '      if (_array[i] == _value) {\n', '        result = true;\n', '        return true;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Check if value contains array\n', '   */\n', '  function inArray(bytes32[] _array, bytes32 _value) private pure returns(bool result) {\n', '    if (_array.length == 0 || _value.length == 0) {\n', '      return false;\n', '    }\n', '    result = false;\n', '    for (uint i = 0; i < _array.length; i++) {\n', '      if (_array[i] == _value) {\n', '        result = true;\n', '        return true;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Remove value from arary\n', '   */\n', '  function removeValueFromArray(address[] _array, address _value) private pure returns(address[]) {\n', '    address[] memory arrayNew = new address[](_array.length-1);\n', '    if (arrayNew.length == 0) {\n', '      return arrayNew;\n', '    }\n', '    uint i1 = 0;\n', '    for (uint i = 0; i < _array.length; i++) {\n', '      if (_array[i] != _value) {\n', '        arrayNew[i1++] = _array[i];\n', '      }\n', '    }\n', '    return arrayNew;\n', '  }\n', '\n', '}']