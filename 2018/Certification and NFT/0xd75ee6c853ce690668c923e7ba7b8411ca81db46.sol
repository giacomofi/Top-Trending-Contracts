['pragma solidity 0.4.21;\n', '\n', '/**\n', '* @title SafeMath by OpenZeppelin (commit: 5daaf60)\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) \n', '            return 0;\n', '\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface Token {\n', '    function transfer(address to, uint256 value) external returns (bool success);\n', '    function burn(uint256 amount) external;\n', '    function balanceOf(address owner) external returns (uint256 balance);\n', '}\n', '\n', 'contract Crowdsale {\n', '    address public owner;                       // Address of the contract owner\n', '    address public fundRaiser;                  // Address which can withraw funds raised\n', '    uint256 public amountRaisedInWei;           // Total amount of ether raised in wei\n', '    uint256 public tokensSold;                  // Total number of tokens sold\n', '    uint256 public tokensClaimed;               // Total Number of tokens claimed by participants\n', '    uint256 public icoDeadline;                 // Duration this ICO will end\n', '    uint256 public tokensClaimableAfter;        // Duration after tokens will be claimable\n', '    uint256 public tokensPerWei;                // How many token units a buyer gets per wei \n', '    Token public tokenReward;                   // Token contract being distributed \n', '\n', '    // Map of crowdsale participants, address as key and Participant structure as value\n', '    mapping(address => Participant) public participants;    \n', '\n', '    // This is a type for a single Participant\n', '    struct Participant {\n', '        bool whitelisted;\n', '        uint256 tokens;\n', '        bool tokensClaimed;\n', '    }\n', '\n', '    event FundTransfer(address to, uint amount);\n', '\n', '    modifier afterIcoDeadline() { if (now >= icoDeadline) _; }\n', '    modifier afterTokensClaimableDeadline() { if (now >= tokensClaimableAfter) _; }\n', '    modifier onlyOwner() { require(msg.sender == owner); _; }\n', '\n', '    /**\n', '     * Constructor function\n', '     */\n', '    function Crowdsale(\n', '        address fundRaiserAccount,\n', '        uint256 durationOfIcoInDays,\n', '        uint256 durationTokensClaimableAfterInDays,\n', '        uint256 tokensForOneWei,\n', '        address addressOfToken\n', '    ) \n', '        public \n', '    {\n', '        owner = msg.sender;\n', '        fundRaiser = fundRaiserAccount;\n', '        icoDeadline = now + durationOfIcoInDays * 1 days;\n', '        tokensClaimableAfter = now + durationTokensClaimableAfterInDays * 1 days;\n', '        tokensPerWei = tokensForOneWei;\n', '        tokenReward = Token(addressOfToken);\n', '    }\n', '\n', '    /**\n', '     * Fallback function: Buy token\n', '     * The function without name is the default function that is called whenever anyone sends funds to a contract.\n', '     * Reserves a number tokens per participant by multiplying tokensPerWei and sent ether in wei.\n', '     * This function is able to buy token in four cases:\n', '     *      - Before deadline\n', '     *      - Payer is whitelisted\n', '     *      - Sent ether is equal or bigger than minimum transaction (0.01 ether) \n', '     *      - There are enough tokens to sell in contract (Tokens in contract minus tokensSold)\n', '     */\n', '    function() payable public {\n', '        require(now < icoDeadline);\n', '        require(participants[msg.sender].whitelisted);             \n', '        require(msg.value >= 0.01 ether); \n', '        uint256 tokensToBuy = SafeMath.mul(msg.value, tokensPerWei);\n', '        require(tokensToBuy <= SafeMath.sub(tokenReward.balanceOf(this), tokensSold));\n', '        participants[msg.sender].tokens = SafeMath.add(participants[msg.sender].tokens, tokensToBuy);      \n', '        amountRaisedInWei = SafeMath.add(amountRaisedInWei, msg.value);\n', '        tokensSold = SafeMath.add(tokensSold, tokensToBuy);\n', '    }\n', '    \n', '    /**\n', '    * Add single address into the whitelist. \n', '    * Note: Use this function for a single address save transaction fee\n', '    */ \n', '    function addToWhitelist(address addr) onlyOwner public {\n', '        participants[addr].whitelisted = true;   \n', '    }\n', '\n', '    /**\n', '    * Remove single address into the whitelist. \n', '    * Note: Use this function for a single address save transaction fee\n', '    */ \n', '    function removeFromWhitelist(address addr) onlyOwner public {\n', '        participants[addr].whitelisted = false;   \n', '    }\n', '\n', '    /**\n', '    * Remove single address into the whitelist. \n', '    * Note-1: Use addToWhitelist for a single address to save transaction fee\n', '    * Note-2: Use this function for more than one address to save transaction fee\n', '    */ \n', '    function addAddressesToWhitelist(address[] addresses) onlyOwner public {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            participants[addresses[i]].whitelisted = true;   \n', '        }\n', '    }\n', '\n', '    /**\n', '    * Add single address into the whitelist\n', '    * Note-1: Use addToWhitelist for a single address to save transaction fee\n', '    * Note-2: Use this function for more than one address to save transaction fee\n', '    */ \n', '    function removeAddressesFromWhitelist(address[] addresses) onlyOwner public {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            participants[addresses[i]].whitelisted = false;   \n', '        }\n', '    }\n', '\n', '    // ----------- After ICO Deadline ------------\n', '\n', '    /**\n', '    * Fundraiser address claims the raised funds after ICO deadline\n', '    */ \n', '    function withdrawFunds() afterIcoDeadline public {\n', '        require(fundRaiser == msg.sender);\n', '        fundRaiser.transfer(address(this).balance);\n', '        emit FundTransfer(fundRaiser, address(this).balance);        \n', '    }\n', '\n', '    /**\n', '    * Burn unsold tokens after ICO deadline\n', '    * This function is designed to be used after Final-ICO ends to burn unsold tokens\n', '    */ \n', '    function burnUnsoldTokens()  onlyOwner afterIcoDeadline public {  \n', '        uint256 tokensUnclaimed = SafeMath.sub(tokensSold, tokensClaimed);\n', '        uint256 unsoldTokens = SafeMath.sub(tokenReward.balanceOf(this), tokensUnclaimed);\n', '        tokenReward.burn(unsoldTokens);\n', '    }    \n', '\n', '    /**\n', '    * Transfer unsold tokens after ico deadline\n', '    * This function is designed to be used after Pre-ICO ends to transfer unsold tokens into Final-ICO contract.\n', '    */ \n', '    function transferUnsoldTokens(address toAddress) onlyOwner afterIcoDeadline public {\n', '        uint256 tokensUnclaimed = SafeMath.sub(tokensSold, tokensClaimed);\n', '        uint256 unsoldTokens = SafeMath.sub(tokenReward.balanceOf(this), tokensUnclaimed);\n', '        tokenReward.transfer(toAddress, unsoldTokens);\n', '    }\n', '\n', '    // ----------- After Tokens Claimable Duration ------------\n', '\n', '    /**\n', '    * Each participant will be able to claim his tokens after duration tokensClaimableAfter\n', '    */ \n', '    function withdrawTokens() afterTokensClaimableDeadline public {\n', '        require(participants[msg.sender].whitelisted);                \n', '        require(!participants[msg.sender].tokensClaimed);        \n', '        participants[msg.sender].tokensClaimed = true;\n', '        uint256 tokens = participants[msg.sender].tokens;\n', '        tokenReward.transfer(msg.sender, tokens); \n', '        tokensClaimed = SafeMath.add(tokensClaimed, tokens);\n', '    }\n', '}']
['pragma solidity 0.4.21;\n', '\n', '/**\n', '* @title SafeMath by OpenZeppelin (commit: 5daaf60)\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) \n', '            return 0;\n', '\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface Token {\n', '    function transfer(address to, uint256 value) external returns (bool success);\n', '    function burn(uint256 amount) external;\n', '    function balanceOf(address owner) external returns (uint256 balance);\n', '}\n', '\n', 'contract Crowdsale {\n', '    address public owner;                       // Address of the contract owner\n', '    address public fundRaiser;                  // Address which can withraw funds raised\n', '    uint256 public amountRaisedInWei;           // Total amount of ether raised in wei\n', '    uint256 public tokensSold;                  // Total number of tokens sold\n', '    uint256 public tokensClaimed;               // Total Number of tokens claimed by participants\n', '    uint256 public icoDeadline;                 // Duration this ICO will end\n', '    uint256 public tokensClaimableAfter;        // Duration after tokens will be claimable\n', '    uint256 public tokensPerWei;                // How many token units a buyer gets per wei \n', '    Token public tokenReward;                   // Token contract being distributed \n', '\n', '    // Map of crowdsale participants, address as key and Participant structure as value\n', '    mapping(address => Participant) public participants;    \n', '\n', '    // This is a type for a single Participant\n', '    struct Participant {\n', '        bool whitelisted;\n', '        uint256 tokens;\n', '        bool tokensClaimed;\n', '    }\n', '\n', '    event FundTransfer(address to, uint amount);\n', '\n', '    modifier afterIcoDeadline() { if (now >= icoDeadline) _; }\n', '    modifier afterTokensClaimableDeadline() { if (now >= tokensClaimableAfter) _; }\n', '    modifier onlyOwner() { require(msg.sender == owner); _; }\n', '\n', '    /**\n', '     * Constructor function\n', '     */\n', '    function Crowdsale(\n', '        address fundRaiserAccount,\n', '        uint256 durationOfIcoInDays,\n', '        uint256 durationTokensClaimableAfterInDays,\n', '        uint256 tokensForOneWei,\n', '        address addressOfToken\n', '    ) \n', '        public \n', '    {\n', '        owner = msg.sender;\n', '        fundRaiser = fundRaiserAccount;\n', '        icoDeadline = now + durationOfIcoInDays * 1 days;\n', '        tokensClaimableAfter = now + durationTokensClaimableAfterInDays * 1 days;\n', '        tokensPerWei = tokensForOneWei;\n', '        tokenReward = Token(addressOfToken);\n', '    }\n', '\n', '    /**\n', '     * Fallback function: Buy token\n', '     * The function without name is the default function that is called whenever anyone sends funds to a contract.\n', '     * Reserves a number tokens per participant by multiplying tokensPerWei and sent ether in wei.\n', '     * This function is able to buy token in four cases:\n', '     *      - Before deadline\n', '     *      - Payer is whitelisted\n', '     *      - Sent ether is equal or bigger than minimum transaction (0.01 ether) \n', '     *      - There are enough tokens to sell in contract (Tokens in contract minus tokensSold)\n', '     */\n', '    function() payable public {\n', '        require(now < icoDeadline);\n', '        require(participants[msg.sender].whitelisted);             \n', '        require(msg.value >= 0.01 ether); \n', '        uint256 tokensToBuy = SafeMath.mul(msg.value, tokensPerWei);\n', '        require(tokensToBuy <= SafeMath.sub(tokenReward.balanceOf(this), tokensSold));\n', '        participants[msg.sender].tokens = SafeMath.add(participants[msg.sender].tokens, tokensToBuy);      \n', '        amountRaisedInWei = SafeMath.add(amountRaisedInWei, msg.value);\n', '        tokensSold = SafeMath.add(tokensSold, tokensToBuy);\n', '    }\n', '    \n', '    /**\n', '    * Add single address into the whitelist. \n', '    * Note: Use this function for a single address save transaction fee\n', '    */ \n', '    function addToWhitelist(address addr) onlyOwner public {\n', '        participants[addr].whitelisted = true;   \n', '    }\n', '\n', '    /**\n', '    * Remove single address into the whitelist. \n', '    * Note: Use this function for a single address save transaction fee\n', '    */ \n', '    function removeFromWhitelist(address addr) onlyOwner public {\n', '        participants[addr].whitelisted = false;   \n', '    }\n', '\n', '    /**\n', '    * Remove single address into the whitelist. \n', '    * Note-1: Use addToWhitelist for a single address to save transaction fee\n', '    * Note-2: Use this function for more than one address to save transaction fee\n', '    */ \n', '    function addAddressesToWhitelist(address[] addresses) onlyOwner public {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            participants[addresses[i]].whitelisted = true;   \n', '        }\n', '    }\n', '\n', '    /**\n', '    * Add single address into the whitelist\n', '    * Note-1: Use addToWhitelist for a single address to save transaction fee\n', '    * Note-2: Use this function for more than one address to save transaction fee\n', '    */ \n', '    function removeAddressesFromWhitelist(address[] addresses) onlyOwner public {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            participants[addresses[i]].whitelisted = false;   \n', '        }\n', '    }\n', '\n', '    // ----------- After ICO Deadline ------------\n', '\n', '    /**\n', '    * Fundraiser address claims the raised funds after ICO deadline\n', '    */ \n', '    function withdrawFunds() afterIcoDeadline public {\n', '        require(fundRaiser == msg.sender);\n', '        fundRaiser.transfer(address(this).balance);\n', '        emit FundTransfer(fundRaiser, address(this).balance);        \n', '    }\n', '\n', '    /**\n', '    * Burn unsold tokens after ICO deadline\n', '    * This function is designed to be used after Final-ICO ends to burn unsold tokens\n', '    */ \n', '    function burnUnsoldTokens()  onlyOwner afterIcoDeadline public {  \n', '        uint256 tokensUnclaimed = SafeMath.sub(tokensSold, tokensClaimed);\n', '        uint256 unsoldTokens = SafeMath.sub(tokenReward.balanceOf(this), tokensUnclaimed);\n', '        tokenReward.burn(unsoldTokens);\n', '    }    \n', '\n', '    /**\n', '    * Transfer unsold tokens after ico deadline\n', '    * This function is designed to be used after Pre-ICO ends to transfer unsold tokens into Final-ICO contract.\n', '    */ \n', '    function transferUnsoldTokens(address toAddress) onlyOwner afterIcoDeadline public {\n', '        uint256 tokensUnclaimed = SafeMath.sub(tokensSold, tokensClaimed);\n', '        uint256 unsoldTokens = SafeMath.sub(tokenReward.balanceOf(this), tokensUnclaimed);\n', '        tokenReward.transfer(toAddress, unsoldTokens);\n', '    }\n', '\n', '    // ----------- After Tokens Claimable Duration ------------\n', '\n', '    /**\n', '    * Each participant will be able to claim his tokens after duration tokensClaimableAfter\n', '    */ \n', '    function withdrawTokens() afterTokensClaimableDeadline public {\n', '        require(participants[msg.sender].whitelisted);                \n', '        require(!participants[msg.sender].tokensClaimed);        \n', '        participants[msg.sender].tokensClaimed = true;\n', '        uint256 tokens = participants[msg.sender].tokens;\n', '        tokenReward.transfer(msg.sender, tokens); \n', '        tokensClaimed = SafeMath.add(tokensClaimed, tokens);\n', '    }\n', '}']
