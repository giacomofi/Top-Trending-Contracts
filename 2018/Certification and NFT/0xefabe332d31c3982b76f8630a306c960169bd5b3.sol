['pragma solidity ^0.4.15;\n', '\n', '/*\n', '  https://cryptogs.io\n', '  --Austin Thomas Griffith for ETHDenver\n', '  ( PS this gas guzzling beast is still unaudited )\n', '*/\n', '\n', '\n', '//adapted from https://github.com/ethereum/EIPs/issues/721\n', '// thanks to Dieter Shirley && http://axiomzen.co\n', '\n', 'contract NFT {\n', '\n', '  function NFT() public { }\n', '\n', '  mapping (uint256 => address) public tokenIndexToOwner;\n', '  mapping (address => uint256) ownershipTokenCount;\n', '  mapping (uint256 => address) public tokenIndexToApproved;\n', '\n', '  function transfer(address _to,uint256 _tokenId) public {\n', '      require(_to != address(0));\n', '      require(_to != address(this));\n', '      require(_owns(msg.sender, _tokenId));\n', '      _transfer(msg.sender, _to, _tokenId);\n', '  }\n', '  function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '      ownershipTokenCount[_to]++;\n', '      tokenIndexToOwner[_tokenId] = _to;\n', '      if (_from != address(0)) {\n', '          ownershipTokenCount[_from]--;\n', '          delete tokenIndexToApproved[_tokenId];\n', '      }\n', '      Transfer(_from, _to, _tokenId);\n', '  }\n', '  event Transfer(address from, address to, uint256 tokenId);\n', '\n', '  function transferFrom(address _from,address _to,uint256 _tokenId) external {\n', '      require(_to != address(0));\n', '      require(_to != address(this));\n', '      require(_approvedFor(msg.sender, _tokenId));\n', '      require(_owns(_from, _tokenId));\n', '      _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '      return tokenIndexToOwner[_tokenId] == _claimant;\n', '  }\n', '  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '      return tokenIndexToApproved[_tokenId] == _claimant;\n', '  }\n', '  function _approve(uint256 _tokenId, address _approved) internal {\n', '      tokenIndexToApproved[_tokenId] = _approved;\n', '  }\n', '\n', '  function approve(address _to,uint256 _tokenId) public returns (bool) {\n', '      require(_owns(msg.sender, _tokenId));\n', '      _approve(_tokenId, _to);\n', '      Approval(msg.sender, _to, _tokenId);\n', '      return true;\n', '  }\n', '  event Approval(address owner, address approved, uint256 tokenId);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 count) {\n', '      return ownershipTokenCount[_owner];\n', '  }\n', '\n', '  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n', '      owner = tokenIndexToOwner[_tokenId];\n', '      require(owner != address(0));\n', '  }\n', '\n', '  function allowance(address _claimant, uint256 _tokenId) public view returns (bool) {\n', '      return _approvedFor(_claimant,_tokenId);\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Cryptogs is NFT, Ownable {\n', '\n', '    string public constant name = "Cryptogs";\n', '    string public constant symbol = "POGS";\n', '\n', '    string public constant purpose = "ETHDenver";\n', '    string public constant contact = "https://cryptogs.io";\n', '    string public constant author = "Austin Thomas Griffith";\n', '\n', '    uint8 public constant FLIPPINESS = 64;\n', '    uint8 public constant FLIPPINESSROUNDBONUS = 16;\n', '    uint8 public constant TIMEOUTBLOCKS = 180;\n', '    uint8 public constant BLOCKSUNTILCLEANUPSTACK=1;\n', '\n', '    string public ipfs;\n', '    function setIpfs(string _ipfs) public onlyOwner returns (bool){\n', '      ipfs=_ipfs;\n', '      IPFS(ipfs);\n', '      return true;\n', '    }\n', '    event IPFS(string ipfs);\n', '\n', '    function Cryptogs() public {\n', '      //0 index should be a blank item owned by no one\n', '      Item memory _item = Item({\n', '        image: ""\n', '      });\n', '      items.push(_item);\n', '    }\n', '\n', '    address public slammerTime;\n', '    function setSlammerTime(address _slammerTime) public onlyOwner returns (bool){\n', '      //in order to trust that this contract isn&#39;t sending a player&#39;s tokens\n', '      // to a different contract, the slammertime contract is set once and\n', '      // only once -- at deploy\n', '      require(slammerTime==address(0));\n', '      slammerTime=_slammerTime;\n', '      return true;\n', '    }\n', '\n', '    struct Item{\n', '      bytes32 image;\n', '      //perhaps some are harder to flip over?\n', '      //perhaps some have magical metadata?\n', '      //I don&#39;t know, it&#39;s late and I&#39;m weird\n', '    }\n', '\n', '    Item[] private items;\n', '\n', '    function mint(bytes32 _image,address _owner) public onlyOwner returns (uint){\n', '      uint256 newId = _mint(_image);\n', '      _transfer(0, _owner, newId);\n', '      Mint(items[newId].image,tokenIndexToOwner[newId],newId);\n', '      return newId;\n', '    }\n', '    event Mint(bytes32 _image,address _owner,uint256 _id);\n', '\n', '    function mintBatch(bytes32 _image1,bytes32 _image2,bytes32 _image3,bytes32 _image4,bytes32 _image5,address _owner) public onlyOwner returns (bool){\n', '      uint256 newId = _mint(_image1);\n', '      _transfer(0, _owner, newId);\n', '      Mint(_image1,tokenIndexToOwner[newId],newId);\n', '      newId=_mint(_image2);\n', '      _transfer(0, _owner, newId);\n', '      Mint(_image2,tokenIndexToOwner[newId],newId);\n', '      newId=_mint(_image3);\n', '      _transfer(0, _owner, newId);\n', '      Mint(_image3,tokenIndexToOwner[newId],newId);\n', '      newId=_mint(_image4);\n', '      _transfer(0, _owner, newId);\n', '      Mint(_image4,tokenIndexToOwner[newId],newId);\n', '      newId=_mint(_image5);\n', '      _transfer(0, _owner, newId);\n', '      Mint(_image5,tokenIndexToOwner[newId],newId);\n', '      return true;\n', '    }\n', '\n', '    function _mint(bytes32 _image) internal returns (uint){\n', '      Item memory _item = Item({\n', '        image: _image\n', '      });\n', '      uint256 newId = items.push(_item) - 1;\n', '      tokensOfImage[items[newId].image]++;\n', '      return newId;\n', '    }\n', '\n', '    Pack[] private packs;\n', '    struct Pack{\n', '      uint256[10] tokens;\n', '      uint256 price;\n', '    }\n', '    function mintPack(uint256 _price,bytes32 _image1,bytes32 _image2,bytes32 _image3,bytes32 _image4,bytes32 _image5,bytes32 _image6,bytes32 _image7,bytes32 _image8,bytes32 _image9,bytes32 _image10) public onlyOwner returns (bool){\n', '      uint256[10] memory tokens;\n', '      tokens[0] = _mint(_image1);\n', '      tokens[1] = _mint(_image2);\n', '      tokens[2] = _mint(_image3);\n', '      tokens[3] = _mint(_image4);\n', '      tokens[4] = _mint(_image5);\n', '      tokens[5] = _mint(_image6);\n', '      tokens[6] = _mint(_image7);\n', '      tokens[7] = _mint(_image8);\n', '      tokens[8] = _mint(_image9);\n', '      tokens[9] = _mint(_image10);\n', '      Pack memory _pack = Pack({\n', '        tokens: tokens,\n', '        price: _price\n', '      });\n', '      MintPack(packs.push(_pack) - 1, _price,tokens[0],tokens[1],tokens[2],tokens[3],tokens[4],tokens[5],tokens[6],tokens[7],tokens[8],tokens[9]);\n', '      return true;\n', '    }\n', '    event MintPack(uint256 packId,uint256 price,uint256 token1,uint256 token2,uint256 token3,uint256 token4,uint256 token5,uint256 token6,uint256 token7,uint256 token8,uint256 token9,uint256 token10);\n', '\n', '    function buyPack(uint256 packId) public payable returns (bool) {\n', '      //make sure pack is for sale\n', '      require( packs[packId].price > 0 );\n', '      //make sure they sent in enough value\n', '      require( msg.value >= packs[packId].price );\n', '      //right away set price to 0 to avoid some sort of reentrance\n', '      packs[packId].price=0;\n', '      //give tokens to owner\n', '      for(uint8 i=0;i<10;i++){\n', '        tokenIndexToOwner[packs[packId].tokens[i]]=msg.sender;\n', '        _transfer(0, msg.sender, packs[packId].tokens[i]);\n', '      }\n', '      //clear the price so it is no longer for sale\n', '      delete packs[packId];\n', '      BuyPack(msg.sender,packId,msg.value);\n', '    }\n', '    event BuyPack(address sender, uint256 packId, uint256 price);\n', '\n', '    //lets keep a count of how many of a specific image is created too\n', '    //that will allow us to calculate rarity on-chain if we want\n', '    mapping (bytes32 => uint256) public tokensOfImage;\n', '\n', '    function getToken(uint256 _id) public view returns (address owner,bytes32 image,uint256 copies) {\n', '      image = items[_id].image;\n', '      copies = tokensOfImage[image];\n', '      return (\n', '        tokenIndexToOwner[_id],\n', '        image,\n', '        copies\n', '      );\n', '    }\n', '\n', '    uint256 nonce = 0;\n', '\n', '    struct Stack{\n', '      //this will be an array of ids but for now just doing one for simplicity\n', '      uint256[5] ids;\n', '      address owner;\n', '      uint32 block;\n', '\n', '    }\n', '\n', '    mapping (bytes32 => Stack) public stacks;\n', '    mapping (bytes32 => bytes32) public stackCounter;\n', '\n', '    function stackOwner(bytes32 _stack) public constant returns (address owner) {\n', '      return stacks[_stack].owner;\n', '    }\n', '\n', '    function getStack(bytes32 _stack) public constant returns (address owner,uint32 block,uint256 token1,uint256 token2,uint256 token3,uint256 token4,uint256 token5) {\n', '      return (stacks[_stack].owner,stacks[_stack].block,stacks[_stack].ids[0],stacks[_stack].ids[1],stacks[_stack].ids[2],stacks[_stack].ids[3],stacks[_stack].ids[4]);\n', '    }\n', '\n', '    //tx 1: of a game, player one approves the SlammerTime contract to take their tokens\n', '    //this triggers an event to broadcast to other players that there is an open challenge\n', '    function submitStack(uint256 _id,uint256 _id2,uint256 _id3,uint256 _id4,uint256 _id5, bool _public) public returns (bool) {\n', '      //make sure slammerTime was set at deploy\n', '      require(slammerTime!=address(0));\n', '      //the sender must own the token\n', '      require(tokenIndexToOwner[_id]==msg.sender);\n', '      require(tokenIndexToOwner[_id2]==msg.sender);\n', '      require(tokenIndexToOwner[_id3]==msg.sender);\n', '      require(tokenIndexToOwner[_id4]==msg.sender);\n', '      require(tokenIndexToOwner[_id5]==msg.sender);\n', '      //they approve the slammertime contract to take the token away from them\n', '      require(approve(slammerTime,_id));\n', '      require(approve(slammerTime,_id2));\n', '      require(approve(slammerTime,_id3));\n', '      require(approve(slammerTime,_id4));\n', '      require(approve(slammerTime,_id5));\n', '\n', '      bytes32 stack = keccak256(nonce++,msg.sender);\n', '      uint256[5] memory ids = [_id,_id2,_id3,_id4,_id5];\n', '      stacks[stack] = Stack(ids,msg.sender,uint32(block.number));\n', '\n', '      //the event is triggered to the frontend to display the stack\n', '      //the frontend will check if they want it public or not\n', '      SubmitStack(msg.sender,now,stack,_id,_id2,_id3,_id4,_id5,_public);\n', '    }\n', '    event SubmitStack(address indexed _sender,uint256 indexed timestamp,bytes32 indexed _stack,uint256 _token1,uint256 _token2,uint256 _token3,uint256 _token4,uint256 _token5,bool _public);\n', '\n', '    //tx 2: of a game, player two approves the SlammerTime contract to take their tokens\n', '    //this triggers an event to broadcast to player one that this player wants to rumble\n', '    function submitCounterStack(bytes32 _stack, uint256 _id, uint256 _id2, uint256 _id3, uint256 _id4, uint256 _id5) public returns (bool) {\n', '      //make sure slammerTime was set at deploy\n', '      require(slammerTime!=address(0));\n', '      //the sender must own the token\n', '      require(tokenIndexToOwner[_id]==msg.sender);\n', '      require(tokenIndexToOwner[_id2]==msg.sender);\n', '      require(tokenIndexToOwner[_id3]==msg.sender);\n', '      require(tokenIndexToOwner[_id4]==msg.sender);\n', '      require(tokenIndexToOwner[_id5]==msg.sender);\n', '      //they approve the slammertime contract to take the token away from them\n', '      require(approve(slammerTime,_id));\n', '      require(approve(slammerTime,_id2));\n', '      require(approve(slammerTime,_id3));\n', '      require(approve(slammerTime,_id4));\n', '      require(approve(slammerTime,_id5));\n', '      //stop playing with yourself\n', '      require(msg.sender!=stacks[_stack].owner);\n', '\n', '      bytes32 counterstack = keccak256(nonce++,msg.sender,_id);\n', '      uint256[5] memory ids = [_id,_id2,_id3,_id4,_id5];\n', '      stacks[counterstack] = Stack(ids,msg.sender,uint32(block.number));\n', '      stackCounter[counterstack] = _stack;\n', '\n', '      //the event is triggered to the frontend to display the stack\n', '      //the frontend will check if they want it public or not\n', '      CounterStack(msg.sender,now,_stack,counterstack,_id,_id2,_id3,_id4,_id5);\n', '    }\n', '    event CounterStack(address indexed _sender,uint256 indexed timestamp,bytes32 indexed _stack, bytes32 _counterStack, uint256 _token1, uint256 _token2, uint256 _token3, uint256 _token4, uint256 _token5);\n', '\n', '    // if someone creates a stack they should be able to clean it up\n', '    // its not really that big of a deal because we will have a timeout\n', '    // in the frontent, but still...\n', '    function cancelStack(bytes32 _stack) public returns (bool) {\n', '      //it must be your stack\n', '      require(msg.sender==stacks[_stack].owner);\n', '      //make sure there is no mode set yet\n', '      require(mode[_stack]==0);\n', '      //make sure they aren&#39;t trying to cancel a counterstack using this function\n', '      require(stackCounter[_stack]==0x00000000000000000000000000000000);\n', '\n', '      delete stacks[_stack];\n', '\n', '      CancelStack(msg.sender,now,_stack);\n', '    }\n', '    event CancelStack(address indexed _sender,uint256 indexed timestamp,bytes32 indexed _stack);\n', '\n', '    function cancelCounterStack(bytes32 _stack,bytes32 _counterstack) public returns (bool) {\n', '      //it must be your stack\n', '      require(msg.sender==stacks[_counterstack].owner);\n', '      //the counter must be a counter of stack 1\n', '      require(stackCounter[_counterstack]==_stack);\n', '      //make sure there is no mode set yet\n', '      require(mode[_stack]==0);\n', '\n', '      delete stacks[_counterstack];\n', '      delete stackCounter[_counterstack];\n', '\n', '      CancelCounterStack(msg.sender,now,_stack,_counterstack);\n', '    }\n', '    event CancelCounterStack(address indexed _sender,uint256 indexed timestamp,bytes32 indexed _stack,bytes32 _counterstack);\n', '\n', '    mapping (bytes32 => bytes32) public counterOfStack;\n', '    mapping (bytes32 => uint8) public mode;\n', '    mapping (bytes32 => uint8) public round;\n', '    mapping (bytes32 => uint32) public lastBlock;\n', '    mapping (bytes32 => uint32) public commitBlock;\n', '    mapping (bytes32 => address) public lastActor;\n', '    mapping (bytes32 => uint256[10]) public mixedStack;\n', '\n', '    //tx 3: of a game, player one approves counter stack and transfers everything in\n', '    function acceptCounterStack(bytes32 _stack, bytes32 _counterStack) public returns (bool) {\n', '      //sender must be owner of stack 1\n', '      require(msg.sender==stacks[_stack].owner);\n', '      //the counter must be a counter of stack 1\n', '      require(stackCounter[_counterStack]==_stack);\n', '      //make sure there is no mode set yet\n', '      require(mode[_stack]==0);\n', '\n', '      //do the transfer\n', '      SlammerTime slammerTimeContract = SlammerTime(slammerTime);\n', '      require( slammerTimeContract.startSlammerTime(msg.sender,stacks[_stack].ids,stacks[_counterStack].owner,stacks[_counterStack].ids) );\n', '\n', '      //save the block for a timeout\n', '      lastBlock[_stack]=uint32(block.number);\n', '      lastActor[_stack]=stacks[_counterStack].owner;\n', '      mode[_stack]=1;\n', '      counterOfStack[_stack]=_counterStack;\n', '\n', '      //// LOL @\n', '      mixedStack[_stack][0] = stacks[_stack].ids[0];\n', '      mixedStack[_stack][1] = stacks[_counterStack].ids[0];\n', '      mixedStack[_stack][2] = stacks[_stack].ids[1];\n', '      mixedStack[_stack][3] = stacks[_counterStack].ids[1];\n', '      mixedStack[_stack][4] = stacks[_stack].ids[2];\n', '      mixedStack[_stack][5] = stacks[_counterStack].ids[2];\n', '      mixedStack[_stack][6] = stacks[_stack].ids[3];\n', '      mixedStack[_stack][7] = stacks[_counterStack].ids[3];\n', '      mixedStack[_stack][8] = stacks[_stack].ids[4];\n', '      mixedStack[_stack][9] = stacks[_counterStack].ids[4];\n', '\n', '      //let the front end know that the transfer is good and we are ready for the coin flip\n', '      AcceptCounterStack(msg.sender,_stack,_counterStack);\n', '    }\n', '    event AcceptCounterStack(address indexed _sender,bytes32 indexed _stack, bytes32 indexed _counterStack);\n', '\n', '    mapping (bytes32 => bytes32) public commit;\n', '\n', '    function getMixedStack(bytes32 _stack) external view returns(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256){\n', '      uint256[10] thisStack = mixedStack[_stack];\n', '      return (thisStack[0],thisStack[1],thisStack[2],thisStack[3],thisStack[4],thisStack[5],thisStack[6],thisStack[7],thisStack[8],thisStack[9]);\n', '    }\n', '\n', '    //tx 4: player one commits and flips coin up\n', '    //at this point, the timeout goes into effect and if any transaction including\n', '    //the coin flip don&#39;t come back in time, we need to allow the other party\n', '    //to withdraw all tokens... this keeps either player from refusing to\n', '    //reveal their commit. (every tx from here on out needs to update the lastBlock and lastActor)\n', '    //and in the withdraw function you check currentblock-lastBlock > timeout = refund to lastActor\n', '    //and by refund I mean let them withdraw if they want\n', '    //we could even have a little timer on the front end that tells you how long your opponnet has\n', '    //before they will forfet\n', '    function startCoinFlip(bytes32 _stack, bytes32 _counterStack, bytes32 _commit) public returns (bool) {\n', '      //make sure it&#39;s the owner of the first stack (player one) doing the flip\n', '      require(stacks[_stack].owner==msg.sender);\n', '      //the counter must be a counter of stack 1\n', '      require(stackCounter[_counterStack]==_stack);\n', '      require(counterOfStack[_stack]==_counterStack);\n', '      //make sure that we are in mode 1\n', '      require(mode[_stack]==1);\n', '      //store the commit for the next tx\n', '      commit[_stack]=_commit;\n', '      commitBlock[_stack]=uint32(block.number);\n', '      //inc the mode to 2\n', '      mode[_stack]=2;\n', '      StartCoinFlip(_stack,_commit);\n', '    }\n', '    event StartCoinFlip(bytes32 stack, bytes32 commit);\n', '\n', '    //tx5: player one ends coin flip with reveal\n', '    function endCoinFlip(bytes32 _stack, bytes32 _counterStack, bytes32 _reveal) public returns (bool) {\n', '      //make sure it&#39;s the owner of the first stack (player one) doing the flip\n', '      require(stacks[_stack].owner==msg.sender);\n', '      //the counter must be a counter of stack 1\n', '      require(stackCounter[_counterStack]==_stack);\n', '      require(counterOfStack[_stack]==_counterStack);\n', '      //make sure that we are in mode 2\n', '      require(mode[_stack]==2);\n', '\n', '      //make sure that we are on a later block than the commit block\n', '      require(uint32(block.number)>commitBlock[_stack]);\n', '\n', '      //make sure hash of reveal == commit\n', '      if(keccak256(_reveal)!=commit[_stack]){\n', '        //commit/reveal failed.. this can happen if they\n', '        //reload, so don&#39;t punish, just go back to the\n', '        //start of the coin flip stage\n', '        mode[_stack]=1;\n', '        CoinFlipFail(_stack);\n', '        return false;\n', '      }else{\n', '        //successful coin flip, ready to get random\n', '        mode[_stack]=3;\n', '        round[_stack]=1;\n', '        bytes32 pseudoRandomHash = keccak256(_reveal,block.blockhash(commitBlock[_stack]));\n', '        if(uint256(pseudoRandomHash)%2==0){\n', '          //player1 goes first\n', '          lastBlock[_stack]=uint32(block.number);\n', '          lastActor[_stack]=stacks[_counterStack].owner;\n', '          CoinFlipSuccess(_stack,stacks[_stack].owner,true);\n', '        }else{\n', '          //player2 goes first\n', '          lastBlock[_stack]=uint32(block.number);\n', '          lastActor[_stack]=stacks[_stack].owner;\n', '          CoinFlipSuccess(_stack,stacks[_counterStack].owner,false);\n', '        }\n', '        return true;\n', '      }\n', '\n', '    }\n', '    event CoinFlipSuccess(bytes32 indexed stack,address whosTurn,bool heads);\n', '    event CoinFlipFail(bytes32 stack);\n', '\n', '\n', '    //tx6 next player raises slammer\n', '    function raiseSlammer(bytes32 _stack, bytes32 _counterStack, bytes32 _commit) public returns (bool) {\n', '      if(lastActor[_stack]==stacks[_stack].owner){\n', '        //it is player2&#39;s turn\n', '        require(stacks[_counterStack].owner==msg.sender);\n', '      }else{\n', '        //it is player1&#39;s turn\n', '        require(stacks[_stack].owner==msg.sender);\n', '      }\n', '      //the counter must be a counter of stack 1\n', '      require(stackCounter[_counterStack]==_stack);\n', '      require(counterOfStack[_stack]==_counterStack);\n', '      //make sure that we are in mode 3\n', '      require(mode[_stack]==3);\n', '      //store the commit for the next tx\n', '      commit[_stack]=_commit;\n', '      commitBlock[_stack]=uint32(block.number);\n', '      //inc the mode to 2\n', '      mode[_stack]=4;\n', '      RaiseSlammer(_stack,_commit);\n', '    }\n', '    event RaiseSlammer(bytes32 stack, bytes32 commit);\n', '\n', '\n', '    //tx7 player throws slammer\n', '    function throwSlammer(bytes32 _stack, bytes32 _counterStack, bytes32 _reveal) public returns (bool) {\n', '      if(lastActor[_stack]==stacks[_stack].owner){\n', '        //it is player2&#39;s turn\n', '        require(stacks[_counterStack].owner==msg.sender);\n', '      }else{\n', '        //it is player1&#39;s turn\n', '        require(stacks[_stack].owner==msg.sender);\n', '      }\n', '      //the counter must be a counter of stack 1\n', '      require(stackCounter[_counterStack]==_stack);\n', '      require(counterOfStack[_stack]==_counterStack);\n', '      //make sure that we are in mode 4\n', '      require(mode[_stack]==4);\n', '\n', '      //make sure that we are on a later block than the commit block\n', '      require(uint32(block.number)>commitBlock[_stack]);\n', '\n', '      uint256[10] memory flipped;\n', '      if(keccak256(_reveal)!=commit[_stack]){\n', '        //commit/reveal failed.. this can happen if they\n', '        //reload, so don&#39;t punish, just go back to the\n', '        //start of the slammer raise\n', '        mode[_stack]=3;\n', '        throwSlammerEvent(_stack,msg.sender,address(0),flipped);\n', '        return false;\n', '      }else{\n', '        //successful slam!!!!!!!!!!!! At this point I have officially been awake for 24 hours !!!!!!!!!!\n', '        mode[_stack]=3;\n', '\n', '        address previousLastActor = lastActor[_stack];\n', '\n', '        bytes32 pseudoRandomHash = keccak256(_reveal,block.blockhash(commitBlock[_stack]));\n', '        //Debug(_reveal,block.blockhash(block.number-1),pseudoRandomHash);\n', '        if(lastActor[_stack]==stacks[_stack].owner){\n', '          //player1 goes next\n', '          lastBlock[_stack]=uint32(block.number);\n', '          lastActor[_stack]=stacks[_counterStack].owner;\n', '        }else{\n', '          //player2 goes next\n', '          lastBlock[_stack]=uint32(block.number);\n', '          lastActor[_stack]=stacks[_stack].owner;\n', '        }\n', '\n', '        //look through the stack of remaining pogs and compare to byte to see if less than FLIPPINESS and transfer back to correct owner\n', '        // oh man, that smells like reentrance --  I think the mode would actually break that right?\n', '        bool done=true;\n', '        uint8 randIndex = 0;\n', '        for(uint8 i=0;i<10;i++){\n', '          if(mixedStack[_stack][i]>0){\n', '            //there is still a pog here, check for flip\n', '            uint8 thisFlipper = uint8(pseudoRandomHash[randIndex++]);\n', '            //DebugFlip(pseudoRandomHash,i,randIndex,thisFlipper,FLIPPINESS);\n', '            if(thisFlipper<(FLIPPINESS+round[_stack]*FLIPPINESSROUNDBONUS)){\n', '              //ITS A FLIP!\n', '               uint256 tempId = mixedStack[_stack][i];\n', '               flipped[i]=tempId;\n', '               mixedStack[_stack][i]=0;\n', '               SlammerTime slammerTimeContract = SlammerTime(slammerTime);\n', '               //require( slammerTimeContract.transferBack(msg.sender,tempId) );\n', '               slammerTimeContract.transferBack(msg.sender,tempId);\n', '            }else{\n', '              done=false;\n', '            }\n', '          }\n', '        }\n', '\n', '        throwSlammerEvent(_stack,msg.sender,previousLastActor,flipped);\n', '\n', '        if(done){\n', '          FinishGame(_stack);\n', '          mode[_stack]=9;\n', '          delete mixedStack[_stack];\n', '          delete stacks[_stack];\n', '          delete stackCounter[_counterStack];\n', '          delete stacks[_counterStack];\n', '          delete lastBlock[_stack];\n', '          delete lastActor[_stack];\n', '          delete counterOfStack[_stack];\n', '          delete round[_stack];\n', '          delete commitBlock[_stack];\n', '          delete commit[_stack];\n', '        }else{\n', '          round[_stack]++;\n', '        }\n', '\n', '        return true;\n', '      }\n', '    }\n', '    event ThrowSlammer(bytes32 indexed stack, address indexed whoDoneIt, address indexed otherPlayer, uint256 token1Flipped, uint256 token2Flipped, uint256 token3Flipped, uint256 token4Flipped, uint256 token5Flipped, uint256 token6Flipped, uint256 token7Flipped, uint256 token8Flipped, uint256 token9Flipped, uint256 token10Flipped);\n', '    event FinishGame(bytes32 stack);\n', '\n', '    function throwSlammerEvent(bytes32 stack,address whoDoneIt,address otherAccount, uint256[10] flipArray) internal {\n', '      ThrowSlammer(stack,whoDoneIt,otherAccount,flipArray[0],flipArray[1],flipArray[2],flipArray[3],flipArray[4],flipArray[5],flipArray[6],flipArray[7],flipArray[8],flipArray[9]);\n', '    }\n', '\n', '\n', '    function drainStack(bytes32 _stack, bytes32 _counterStack) public returns (bool) {\n', '      //this function is for the case of a timeout in the commit / reveal\n', '      // if a player realizes they are going to lose, they can refuse to reveal\n', '      // therefore we must have a timeout of TIMEOUTBLOCKS and if that time is reached\n', '      // the other player can get in and drain the remaining tokens from the game\n', '      require( stacks[_stack].owner==msg.sender || stacks[_counterStack].owner==msg.sender );\n', '      //the counter must be a counter of stack 1\n', '      require( stackCounter[_counterStack]==_stack );\n', '      require( counterOfStack[_stack]==_counterStack );\n', '      //the bad guy shouldn&#39;t be able to drain\n', '      require( lastActor[_stack]==msg.sender );\n', '      //must be after timeout period\n', '      require( block.number - lastBlock[_stack] >= TIMEOUTBLOCKS);\n', '      //game must still be going\n', '      require( mode[_stack]<9 );\n', '\n', '      for(uint8 i=0;i<10;i++){\n', '        if(mixedStack[_stack][i]>0){\n', '          uint256 tempId = mixedStack[_stack][i];\n', '          mixedStack[_stack][i]=0;\n', '          SlammerTime slammerTimeContract = SlammerTime(slammerTime);\n', '          slammerTimeContract.transferBack(msg.sender,tempId);\n', '        }\n', '      }\n', '\n', '      FinishGame(_stack);\n', '      mode[_stack]=9;\n', '\n', '      delete mixedStack[_stack];\n', '      delete stacks[_stack];\n', '      delete stackCounter[_counterStack];\n', '      delete stacks[_counterStack];\n', '      delete lastBlock[_stack];\n', '      delete lastActor[_stack];\n', '      delete counterOfStack[_stack];\n', '      delete round[_stack];\n', '      delete commitBlock[_stack];\n', '      delete commit[_stack];\n', '\n', '      DrainStack(_stack,_counterStack,msg.sender);\n', '    }\n', '    event DrainStack(bytes32 stack,bytes32 counterStack,address sender);\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return items.length - 1;\n', '    }\n', '\n', '    function tokensOfOwner(address _owner) external view returns(uint256[]) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '        if (tokenCount == 0) {\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            uint256 total = totalSupply();\n', '            uint256 resultIndex = 0;\n', '            uint256 id;\n', '            for (id = 1; id <= total; id++) {\n', '                if (tokenIndexToOwner[id] == _owner) {\n', '                    result[resultIndex] = id;\n', '                    resultIndex++;\n', '                }\n', '            }\n', '            return result;\n', '        }\n', '    }\n', '\n', '    function withdraw(uint256 _amount) public onlyOwner returns (bool) {\n', '      require(this.balance >= _amount);\n', '      assert(owner.send(_amount));\n', '      return true;\n', '    }\n', '\n', '    function withdrawToken(address _token,uint256 _amount) public onlyOwner returns (bool) {\n', '      StandardToken token = StandardToken(_token);\n', '      token.transfer(msg.sender,_amount);\n', '      return true;\n', '    }\n', '\n', '\n', '    //adapted from ERC-677 from my dude Steve Ellis - thanks man!\n', '    function transferStackAndCall(address _to, uint _token1, uint _token2, uint _token3, uint _token4, uint _token5, bytes32 _data) public returns (bool) {\n', '      transfer(_to, _token1);\n', '      transfer(_to, _token2);\n', '      transfer(_to, _token3);\n', '      transfer(_to, _token4);\n', '      transfer(_to, _token5);\n', '\n', '      if (isContract(_to)) {\n', '        contractFallback(_to,_token1,_token2,_token3,_token4,_token5,_data);\n', '      }\n', '      return true;\n', '    }\n', '\n', '    function contractFallback(address _to, uint _token1, uint _token2, uint _token3, uint _token4, uint _token5, bytes32 _data) private {\n', '      StackReceiver receiver = StackReceiver(_to);\n', '      receiver.onTransferStack(msg.sender,_token1,_token2,_token3,_token4,_token5,_data);\n', '    }\n', '\n', '    function isContract(address _addr) private returns (bool hasCode) {\n', '      uint length;\n', '      assembly { length := extcodesize(_addr) }\n', '      return length > 0;\n', '    }\n', '\n', '}\n', '\n', 'contract StackReceiver {\n', '  function onTransferStack(address _sender, uint _token1, uint _token2, uint _token3, uint _token4, uint _token5, bytes32 _data);\n', '}\n', '\n', 'contract StandardToken {\n', '  function transfer(address _to, uint256 _value) public returns (bool) { }\n', '}\n', '\n', 'contract SlammerTime {\n', '  function startSlammerTime(address _player1,uint256[5] _id1,address _player2,uint256[5] _id2) public returns (bool) { }\n', '  function transferBack(address _toWhom, uint256 _id) public returns (bool) { }\n', '}']
['pragma solidity ^0.4.15;\n', '\n', '/*\n', '  https://cryptogs.io\n', '  --Austin Thomas Griffith for ETHDenver\n', '  ( PS this gas guzzling beast is still unaudited )\n', '*/\n', '\n', '\n', '//adapted from https://github.com/ethereum/EIPs/issues/721\n', '// thanks to Dieter Shirley && http://axiomzen.co\n', '\n', 'contract NFT {\n', '\n', '  function NFT() public { }\n', '\n', '  mapping (uint256 => address) public tokenIndexToOwner;\n', '  mapping (address => uint256) ownershipTokenCount;\n', '  mapping (uint256 => address) public tokenIndexToApproved;\n', '\n', '  function transfer(address _to,uint256 _tokenId) public {\n', '      require(_to != address(0));\n', '      require(_to != address(this));\n', '      require(_owns(msg.sender, _tokenId));\n', '      _transfer(msg.sender, _to, _tokenId);\n', '  }\n', '  function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '      ownershipTokenCount[_to]++;\n', '      tokenIndexToOwner[_tokenId] = _to;\n', '      if (_from != address(0)) {\n', '          ownershipTokenCount[_from]--;\n', '          delete tokenIndexToApproved[_tokenId];\n', '      }\n', '      Transfer(_from, _to, _tokenId);\n', '  }\n', '  event Transfer(address from, address to, uint256 tokenId);\n', '\n', '  function transferFrom(address _from,address _to,uint256 _tokenId) external {\n', '      require(_to != address(0));\n', '      require(_to != address(this));\n', '      require(_approvedFor(msg.sender, _tokenId));\n', '      require(_owns(_from, _tokenId));\n', '      _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '      return tokenIndexToOwner[_tokenId] == _claimant;\n', '  }\n', '  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '      return tokenIndexToApproved[_tokenId] == _claimant;\n', '  }\n', '  function _approve(uint256 _tokenId, address _approved) internal {\n', '      tokenIndexToApproved[_tokenId] = _approved;\n', '  }\n', '\n', '  function approve(address _to,uint256 _tokenId) public returns (bool) {\n', '      require(_owns(msg.sender, _tokenId));\n', '      _approve(_tokenId, _to);\n', '      Approval(msg.sender, _to, _tokenId);\n', '      return true;\n', '  }\n', '  event Approval(address owner, address approved, uint256 tokenId);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 count) {\n', '      return ownershipTokenCount[_owner];\n', '  }\n', '\n', '  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n', '      owner = tokenIndexToOwner[_tokenId];\n', '      require(owner != address(0));\n', '  }\n', '\n', '  function allowance(address _claimant, uint256 _tokenId) public view returns (bool) {\n', '      return _approvedFor(_claimant,_tokenId);\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Cryptogs is NFT, Ownable {\n', '\n', '    string public constant name = "Cryptogs";\n', '    string public constant symbol = "POGS";\n', '\n', '    string public constant purpose = "ETHDenver";\n', '    string public constant contact = "https://cryptogs.io";\n', '    string public constant author = "Austin Thomas Griffith";\n', '\n', '    uint8 public constant FLIPPINESS = 64;\n', '    uint8 public constant FLIPPINESSROUNDBONUS = 16;\n', '    uint8 public constant TIMEOUTBLOCKS = 180;\n', '    uint8 public constant BLOCKSUNTILCLEANUPSTACK=1;\n', '\n', '    string public ipfs;\n', '    function setIpfs(string _ipfs) public onlyOwner returns (bool){\n', '      ipfs=_ipfs;\n', '      IPFS(ipfs);\n', '      return true;\n', '    }\n', '    event IPFS(string ipfs);\n', '\n', '    function Cryptogs() public {\n', '      //0 index should be a blank item owned by no one\n', '      Item memory _item = Item({\n', '        image: ""\n', '      });\n', '      items.push(_item);\n', '    }\n', '\n', '    address public slammerTime;\n', '    function setSlammerTime(address _slammerTime) public onlyOwner returns (bool){\n', "      //in order to trust that this contract isn't sending a player's tokens\n", '      // to a different contract, the slammertime contract is set once and\n', '      // only once -- at deploy\n', '      require(slammerTime==address(0));\n', '      slammerTime=_slammerTime;\n', '      return true;\n', '    }\n', '\n', '    struct Item{\n', '      bytes32 image;\n', '      //perhaps some are harder to flip over?\n', '      //perhaps some have magical metadata?\n', "      //I don't know, it's late and I'm weird\n", '    }\n', '\n', '    Item[] private items;\n', '\n', '    function mint(bytes32 _image,address _owner) public onlyOwner returns (uint){\n', '      uint256 newId = _mint(_image);\n', '      _transfer(0, _owner, newId);\n', '      Mint(items[newId].image,tokenIndexToOwner[newId],newId);\n', '      return newId;\n', '    }\n', '    event Mint(bytes32 _image,address _owner,uint256 _id);\n', '\n', '    function mintBatch(bytes32 _image1,bytes32 _image2,bytes32 _image3,bytes32 _image4,bytes32 _image5,address _owner) public onlyOwner returns (bool){\n', '      uint256 newId = _mint(_image1);\n', '      _transfer(0, _owner, newId);\n', '      Mint(_image1,tokenIndexToOwner[newId],newId);\n', '      newId=_mint(_image2);\n', '      _transfer(0, _owner, newId);\n', '      Mint(_image2,tokenIndexToOwner[newId],newId);\n', '      newId=_mint(_image3);\n', '      _transfer(0, _owner, newId);\n', '      Mint(_image3,tokenIndexToOwner[newId],newId);\n', '      newId=_mint(_image4);\n', '      _transfer(0, _owner, newId);\n', '      Mint(_image4,tokenIndexToOwner[newId],newId);\n', '      newId=_mint(_image5);\n', '      _transfer(0, _owner, newId);\n', '      Mint(_image5,tokenIndexToOwner[newId],newId);\n', '      return true;\n', '    }\n', '\n', '    function _mint(bytes32 _image) internal returns (uint){\n', '      Item memory _item = Item({\n', '        image: _image\n', '      });\n', '      uint256 newId = items.push(_item) - 1;\n', '      tokensOfImage[items[newId].image]++;\n', '      return newId;\n', '    }\n', '\n', '    Pack[] private packs;\n', '    struct Pack{\n', '      uint256[10] tokens;\n', '      uint256 price;\n', '    }\n', '    function mintPack(uint256 _price,bytes32 _image1,bytes32 _image2,bytes32 _image3,bytes32 _image4,bytes32 _image5,bytes32 _image6,bytes32 _image7,bytes32 _image8,bytes32 _image9,bytes32 _image10) public onlyOwner returns (bool){\n', '      uint256[10] memory tokens;\n', '      tokens[0] = _mint(_image1);\n', '      tokens[1] = _mint(_image2);\n', '      tokens[2] = _mint(_image3);\n', '      tokens[3] = _mint(_image4);\n', '      tokens[4] = _mint(_image5);\n', '      tokens[5] = _mint(_image6);\n', '      tokens[6] = _mint(_image7);\n', '      tokens[7] = _mint(_image8);\n', '      tokens[8] = _mint(_image9);\n', '      tokens[9] = _mint(_image10);\n', '      Pack memory _pack = Pack({\n', '        tokens: tokens,\n', '        price: _price\n', '      });\n', '      MintPack(packs.push(_pack) - 1, _price,tokens[0],tokens[1],tokens[2],tokens[3],tokens[4],tokens[5],tokens[6],tokens[7],tokens[8],tokens[9]);\n', '      return true;\n', '    }\n', '    event MintPack(uint256 packId,uint256 price,uint256 token1,uint256 token2,uint256 token3,uint256 token4,uint256 token5,uint256 token6,uint256 token7,uint256 token8,uint256 token9,uint256 token10);\n', '\n', '    function buyPack(uint256 packId) public payable returns (bool) {\n', '      //make sure pack is for sale\n', '      require( packs[packId].price > 0 );\n', '      //make sure they sent in enough value\n', '      require( msg.value >= packs[packId].price );\n', '      //right away set price to 0 to avoid some sort of reentrance\n', '      packs[packId].price=0;\n', '      //give tokens to owner\n', '      for(uint8 i=0;i<10;i++){\n', '        tokenIndexToOwner[packs[packId].tokens[i]]=msg.sender;\n', '        _transfer(0, msg.sender, packs[packId].tokens[i]);\n', '      }\n', '      //clear the price so it is no longer for sale\n', '      delete packs[packId];\n', '      BuyPack(msg.sender,packId,msg.value);\n', '    }\n', '    event BuyPack(address sender, uint256 packId, uint256 price);\n', '\n', '    //lets keep a count of how many of a specific image is created too\n', '    //that will allow us to calculate rarity on-chain if we want\n', '    mapping (bytes32 => uint256) public tokensOfImage;\n', '\n', '    function getToken(uint256 _id) public view returns (address owner,bytes32 image,uint256 copies) {\n', '      image = items[_id].image;\n', '      copies = tokensOfImage[image];\n', '      return (\n', '        tokenIndexToOwner[_id],\n', '        image,\n', '        copies\n', '      );\n', '    }\n', '\n', '    uint256 nonce = 0;\n', '\n', '    struct Stack{\n', '      //this will be an array of ids but for now just doing one for simplicity\n', '      uint256[5] ids;\n', '      address owner;\n', '      uint32 block;\n', '\n', '    }\n', '\n', '    mapping (bytes32 => Stack) public stacks;\n', '    mapping (bytes32 => bytes32) public stackCounter;\n', '\n', '    function stackOwner(bytes32 _stack) public constant returns (address owner) {\n', '      return stacks[_stack].owner;\n', '    }\n', '\n', '    function getStack(bytes32 _stack) public constant returns (address owner,uint32 block,uint256 token1,uint256 token2,uint256 token3,uint256 token4,uint256 token5) {\n', '      return (stacks[_stack].owner,stacks[_stack].block,stacks[_stack].ids[0],stacks[_stack].ids[1],stacks[_stack].ids[2],stacks[_stack].ids[3],stacks[_stack].ids[4]);\n', '    }\n', '\n', '    //tx 1: of a game, player one approves the SlammerTime contract to take their tokens\n', '    //this triggers an event to broadcast to other players that there is an open challenge\n', '    function submitStack(uint256 _id,uint256 _id2,uint256 _id3,uint256 _id4,uint256 _id5, bool _public) public returns (bool) {\n', '      //make sure slammerTime was set at deploy\n', '      require(slammerTime!=address(0));\n', '      //the sender must own the token\n', '      require(tokenIndexToOwner[_id]==msg.sender);\n', '      require(tokenIndexToOwner[_id2]==msg.sender);\n', '      require(tokenIndexToOwner[_id3]==msg.sender);\n', '      require(tokenIndexToOwner[_id4]==msg.sender);\n', '      require(tokenIndexToOwner[_id5]==msg.sender);\n', '      //they approve the slammertime contract to take the token away from them\n', '      require(approve(slammerTime,_id));\n', '      require(approve(slammerTime,_id2));\n', '      require(approve(slammerTime,_id3));\n', '      require(approve(slammerTime,_id4));\n', '      require(approve(slammerTime,_id5));\n', '\n', '      bytes32 stack = keccak256(nonce++,msg.sender);\n', '      uint256[5] memory ids = [_id,_id2,_id3,_id4,_id5];\n', '      stacks[stack] = Stack(ids,msg.sender,uint32(block.number));\n', '\n', '      //the event is triggered to the frontend to display the stack\n', '      //the frontend will check if they want it public or not\n', '      SubmitStack(msg.sender,now,stack,_id,_id2,_id3,_id4,_id5,_public);\n', '    }\n', '    event SubmitStack(address indexed _sender,uint256 indexed timestamp,bytes32 indexed _stack,uint256 _token1,uint256 _token2,uint256 _token3,uint256 _token4,uint256 _token5,bool _public);\n', '\n', '    //tx 2: of a game, player two approves the SlammerTime contract to take their tokens\n', '    //this triggers an event to broadcast to player one that this player wants to rumble\n', '    function submitCounterStack(bytes32 _stack, uint256 _id, uint256 _id2, uint256 _id3, uint256 _id4, uint256 _id5) public returns (bool) {\n', '      //make sure slammerTime was set at deploy\n', '      require(slammerTime!=address(0));\n', '      //the sender must own the token\n', '      require(tokenIndexToOwner[_id]==msg.sender);\n', '      require(tokenIndexToOwner[_id2]==msg.sender);\n', '      require(tokenIndexToOwner[_id3]==msg.sender);\n', '      require(tokenIndexToOwner[_id4]==msg.sender);\n', '      require(tokenIndexToOwner[_id5]==msg.sender);\n', '      //they approve the slammertime contract to take the token away from them\n', '      require(approve(slammerTime,_id));\n', '      require(approve(slammerTime,_id2));\n', '      require(approve(slammerTime,_id3));\n', '      require(approve(slammerTime,_id4));\n', '      require(approve(slammerTime,_id5));\n', '      //stop playing with yourself\n', '      require(msg.sender!=stacks[_stack].owner);\n', '\n', '      bytes32 counterstack = keccak256(nonce++,msg.sender,_id);\n', '      uint256[5] memory ids = [_id,_id2,_id3,_id4,_id5];\n', '      stacks[counterstack] = Stack(ids,msg.sender,uint32(block.number));\n', '      stackCounter[counterstack] = _stack;\n', '\n', '      //the event is triggered to the frontend to display the stack\n', '      //the frontend will check if they want it public or not\n', '      CounterStack(msg.sender,now,_stack,counterstack,_id,_id2,_id3,_id4,_id5);\n', '    }\n', '    event CounterStack(address indexed _sender,uint256 indexed timestamp,bytes32 indexed _stack, bytes32 _counterStack, uint256 _token1, uint256 _token2, uint256 _token3, uint256 _token4, uint256 _token5);\n', '\n', '    // if someone creates a stack they should be able to clean it up\n', '    // its not really that big of a deal because we will have a timeout\n', '    // in the frontent, but still...\n', '    function cancelStack(bytes32 _stack) public returns (bool) {\n', '      //it must be your stack\n', '      require(msg.sender==stacks[_stack].owner);\n', '      //make sure there is no mode set yet\n', '      require(mode[_stack]==0);\n', "      //make sure they aren't trying to cancel a counterstack using this function\n", '      require(stackCounter[_stack]==0x00000000000000000000000000000000);\n', '\n', '      delete stacks[_stack];\n', '\n', '      CancelStack(msg.sender,now,_stack);\n', '    }\n', '    event CancelStack(address indexed _sender,uint256 indexed timestamp,bytes32 indexed _stack);\n', '\n', '    function cancelCounterStack(bytes32 _stack,bytes32 _counterstack) public returns (bool) {\n', '      //it must be your stack\n', '      require(msg.sender==stacks[_counterstack].owner);\n', '      //the counter must be a counter of stack 1\n', '      require(stackCounter[_counterstack]==_stack);\n', '      //make sure there is no mode set yet\n', '      require(mode[_stack]==0);\n', '\n', '      delete stacks[_counterstack];\n', '      delete stackCounter[_counterstack];\n', '\n', '      CancelCounterStack(msg.sender,now,_stack,_counterstack);\n', '    }\n', '    event CancelCounterStack(address indexed _sender,uint256 indexed timestamp,bytes32 indexed _stack,bytes32 _counterstack);\n', '\n', '    mapping (bytes32 => bytes32) public counterOfStack;\n', '    mapping (bytes32 => uint8) public mode;\n', '    mapping (bytes32 => uint8) public round;\n', '    mapping (bytes32 => uint32) public lastBlock;\n', '    mapping (bytes32 => uint32) public commitBlock;\n', '    mapping (bytes32 => address) public lastActor;\n', '    mapping (bytes32 => uint256[10]) public mixedStack;\n', '\n', '    //tx 3: of a game, player one approves counter stack and transfers everything in\n', '    function acceptCounterStack(bytes32 _stack, bytes32 _counterStack) public returns (bool) {\n', '      //sender must be owner of stack 1\n', '      require(msg.sender==stacks[_stack].owner);\n', '      //the counter must be a counter of stack 1\n', '      require(stackCounter[_counterStack]==_stack);\n', '      //make sure there is no mode set yet\n', '      require(mode[_stack]==0);\n', '\n', '      //do the transfer\n', '      SlammerTime slammerTimeContract = SlammerTime(slammerTime);\n', '      require( slammerTimeContract.startSlammerTime(msg.sender,stacks[_stack].ids,stacks[_counterStack].owner,stacks[_counterStack].ids) );\n', '\n', '      //save the block for a timeout\n', '      lastBlock[_stack]=uint32(block.number);\n', '      lastActor[_stack]=stacks[_counterStack].owner;\n', '      mode[_stack]=1;\n', '      counterOfStack[_stack]=_counterStack;\n', '\n', '      //// LOL @\n', '      mixedStack[_stack][0] = stacks[_stack].ids[0];\n', '      mixedStack[_stack][1] = stacks[_counterStack].ids[0];\n', '      mixedStack[_stack][2] = stacks[_stack].ids[1];\n', '      mixedStack[_stack][3] = stacks[_counterStack].ids[1];\n', '      mixedStack[_stack][4] = stacks[_stack].ids[2];\n', '      mixedStack[_stack][5] = stacks[_counterStack].ids[2];\n', '      mixedStack[_stack][6] = stacks[_stack].ids[3];\n', '      mixedStack[_stack][7] = stacks[_counterStack].ids[3];\n', '      mixedStack[_stack][8] = stacks[_stack].ids[4];\n', '      mixedStack[_stack][9] = stacks[_counterStack].ids[4];\n', '\n', '      //let the front end know that the transfer is good and we are ready for the coin flip\n', '      AcceptCounterStack(msg.sender,_stack,_counterStack);\n', '    }\n', '    event AcceptCounterStack(address indexed _sender,bytes32 indexed _stack, bytes32 indexed _counterStack);\n', '\n', '    mapping (bytes32 => bytes32) public commit;\n', '\n', '    function getMixedStack(bytes32 _stack) external view returns(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256){\n', '      uint256[10] thisStack = mixedStack[_stack];\n', '      return (thisStack[0],thisStack[1],thisStack[2],thisStack[3],thisStack[4],thisStack[5],thisStack[6],thisStack[7],thisStack[8],thisStack[9]);\n', '    }\n', '\n', '    //tx 4: player one commits and flips coin up\n', '    //at this point, the timeout goes into effect and if any transaction including\n', "    //the coin flip don't come back in time, we need to allow the other party\n", '    //to withdraw all tokens... this keeps either player from refusing to\n', '    //reveal their commit. (every tx from here on out needs to update the lastBlock and lastActor)\n', '    //and in the withdraw function you check currentblock-lastBlock > timeout = refund to lastActor\n', '    //and by refund I mean let them withdraw if they want\n', '    //we could even have a little timer on the front end that tells you how long your opponnet has\n', '    //before they will forfet\n', '    function startCoinFlip(bytes32 _stack, bytes32 _counterStack, bytes32 _commit) public returns (bool) {\n', "      //make sure it's the owner of the first stack (player one) doing the flip\n", '      require(stacks[_stack].owner==msg.sender);\n', '      //the counter must be a counter of stack 1\n', '      require(stackCounter[_counterStack]==_stack);\n', '      require(counterOfStack[_stack]==_counterStack);\n', '      //make sure that we are in mode 1\n', '      require(mode[_stack]==1);\n', '      //store the commit for the next tx\n', '      commit[_stack]=_commit;\n', '      commitBlock[_stack]=uint32(block.number);\n', '      //inc the mode to 2\n', '      mode[_stack]=2;\n', '      StartCoinFlip(_stack,_commit);\n', '    }\n', '    event StartCoinFlip(bytes32 stack, bytes32 commit);\n', '\n', '    //tx5: player one ends coin flip with reveal\n', '    function endCoinFlip(bytes32 _stack, bytes32 _counterStack, bytes32 _reveal) public returns (bool) {\n', "      //make sure it's the owner of the first stack (player one) doing the flip\n", '      require(stacks[_stack].owner==msg.sender);\n', '      //the counter must be a counter of stack 1\n', '      require(stackCounter[_counterStack]==_stack);\n', '      require(counterOfStack[_stack]==_counterStack);\n', '      //make sure that we are in mode 2\n', '      require(mode[_stack]==2);\n', '\n', '      //make sure that we are on a later block than the commit block\n', '      require(uint32(block.number)>commitBlock[_stack]);\n', '\n', '      //make sure hash of reveal == commit\n', '      if(keccak256(_reveal)!=commit[_stack]){\n', '        //commit/reveal failed.. this can happen if they\n', "        //reload, so don't punish, just go back to the\n", '        //start of the coin flip stage\n', '        mode[_stack]=1;\n', '        CoinFlipFail(_stack);\n', '        return false;\n', '      }else{\n', '        //successful coin flip, ready to get random\n', '        mode[_stack]=3;\n', '        round[_stack]=1;\n', '        bytes32 pseudoRandomHash = keccak256(_reveal,block.blockhash(commitBlock[_stack]));\n', '        if(uint256(pseudoRandomHash)%2==0){\n', '          //player1 goes first\n', '          lastBlock[_stack]=uint32(block.number);\n', '          lastActor[_stack]=stacks[_counterStack].owner;\n', '          CoinFlipSuccess(_stack,stacks[_stack].owner,true);\n', '        }else{\n', '          //player2 goes first\n', '          lastBlock[_stack]=uint32(block.number);\n', '          lastActor[_stack]=stacks[_stack].owner;\n', '          CoinFlipSuccess(_stack,stacks[_counterStack].owner,false);\n', '        }\n', '        return true;\n', '      }\n', '\n', '    }\n', '    event CoinFlipSuccess(bytes32 indexed stack,address whosTurn,bool heads);\n', '    event CoinFlipFail(bytes32 stack);\n', '\n', '\n', '    //tx6 next player raises slammer\n', '    function raiseSlammer(bytes32 _stack, bytes32 _counterStack, bytes32 _commit) public returns (bool) {\n', '      if(lastActor[_stack]==stacks[_stack].owner){\n', "        //it is player2's turn\n", '        require(stacks[_counterStack].owner==msg.sender);\n', '      }else{\n', "        //it is player1's turn\n", '        require(stacks[_stack].owner==msg.sender);\n', '      }\n', '      //the counter must be a counter of stack 1\n', '      require(stackCounter[_counterStack]==_stack);\n', '      require(counterOfStack[_stack]==_counterStack);\n', '      //make sure that we are in mode 3\n', '      require(mode[_stack]==3);\n', '      //store the commit for the next tx\n', '      commit[_stack]=_commit;\n', '      commitBlock[_stack]=uint32(block.number);\n', '      //inc the mode to 2\n', '      mode[_stack]=4;\n', '      RaiseSlammer(_stack,_commit);\n', '    }\n', '    event RaiseSlammer(bytes32 stack, bytes32 commit);\n', '\n', '\n', '    //tx7 player throws slammer\n', '    function throwSlammer(bytes32 _stack, bytes32 _counterStack, bytes32 _reveal) public returns (bool) {\n', '      if(lastActor[_stack]==stacks[_stack].owner){\n', "        //it is player2's turn\n", '        require(stacks[_counterStack].owner==msg.sender);\n', '      }else{\n', "        //it is player1's turn\n", '        require(stacks[_stack].owner==msg.sender);\n', '      }\n', '      //the counter must be a counter of stack 1\n', '      require(stackCounter[_counterStack]==_stack);\n', '      require(counterOfStack[_stack]==_counterStack);\n', '      //make sure that we are in mode 4\n', '      require(mode[_stack]==4);\n', '\n', '      //make sure that we are on a later block than the commit block\n', '      require(uint32(block.number)>commitBlock[_stack]);\n', '\n', '      uint256[10] memory flipped;\n', '      if(keccak256(_reveal)!=commit[_stack]){\n', '        //commit/reveal failed.. this can happen if they\n', "        //reload, so don't punish, just go back to the\n", '        //start of the slammer raise\n', '        mode[_stack]=3;\n', '        throwSlammerEvent(_stack,msg.sender,address(0),flipped);\n', '        return false;\n', '      }else{\n', '        //successful slam!!!!!!!!!!!! At this point I have officially been awake for 24 hours !!!!!!!!!!\n', '        mode[_stack]=3;\n', '\n', '        address previousLastActor = lastActor[_stack];\n', '\n', '        bytes32 pseudoRandomHash = keccak256(_reveal,block.blockhash(commitBlock[_stack]));\n', '        //Debug(_reveal,block.blockhash(block.number-1),pseudoRandomHash);\n', '        if(lastActor[_stack]==stacks[_stack].owner){\n', '          //player1 goes next\n', '          lastBlock[_stack]=uint32(block.number);\n', '          lastActor[_stack]=stacks[_counterStack].owner;\n', '        }else{\n', '          //player2 goes next\n', '          lastBlock[_stack]=uint32(block.number);\n', '          lastActor[_stack]=stacks[_stack].owner;\n', '        }\n', '\n', '        //look through the stack of remaining pogs and compare to byte to see if less than FLIPPINESS and transfer back to correct owner\n', '        // oh man, that smells like reentrance --  I think the mode would actually break that right?\n', '        bool done=true;\n', '        uint8 randIndex = 0;\n', '        for(uint8 i=0;i<10;i++){\n', '          if(mixedStack[_stack][i]>0){\n', '            //there is still a pog here, check for flip\n', '            uint8 thisFlipper = uint8(pseudoRandomHash[randIndex++]);\n', '            //DebugFlip(pseudoRandomHash,i,randIndex,thisFlipper,FLIPPINESS);\n', '            if(thisFlipper<(FLIPPINESS+round[_stack]*FLIPPINESSROUNDBONUS)){\n', '              //ITS A FLIP!\n', '               uint256 tempId = mixedStack[_stack][i];\n', '               flipped[i]=tempId;\n', '               mixedStack[_stack][i]=0;\n', '               SlammerTime slammerTimeContract = SlammerTime(slammerTime);\n', '               //require( slammerTimeContract.transferBack(msg.sender,tempId) );\n', '               slammerTimeContract.transferBack(msg.sender,tempId);\n', '            }else{\n', '              done=false;\n', '            }\n', '          }\n', '        }\n', '\n', '        throwSlammerEvent(_stack,msg.sender,previousLastActor,flipped);\n', '\n', '        if(done){\n', '          FinishGame(_stack);\n', '          mode[_stack]=9;\n', '          delete mixedStack[_stack];\n', '          delete stacks[_stack];\n', '          delete stackCounter[_counterStack];\n', '          delete stacks[_counterStack];\n', '          delete lastBlock[_stack];\n', '          delete lastActor[_stack];\n', '          delete counterOfStack[_stack];\n', '          delete round[_stack];\n', '          delete commitBlock[_stack];\n', '          delete commit[_stack];\n', '        }else{\n', '          round[_stack]++;\n', '        }\n', '\n', '        return true;\n', '      }\n', '    }\n', '    event ThrowSlammer(bytes32 indexed stack, address indexed whoDoneIt, address indexed otherPlayer, uint256 token1Flipped, uint256 token2Flipped, uint256 token3Flipped, uint256 token4Flipped, uint256 token5Flipped, uint256 token6Flipped, uint256 token7Flipped, uint256 token8Flipped, uint256 token9Flipped, uint256 token10Flipped);\n', '    event FinishGame(bytes32 stack);\n', '\n', '    function throwSlammerEvent(bytes32 stack,address whoDoneIt,address otherAccount, uint256[10] flipArray) internal {\n', '      ThrowSlammer(stack,whoDoneIt,otherAccount,flipArray[0],flipArray[1],flipArray[2],flipArray[3],flipArray[4],flipArray[5],flipArray[6],flipArray[7],flipArray[8],flipArray[9]);\n', '    }\n', '\n', '\n', '    function drainStack(bytes32 _stack, bytes32 _counterStack) public returns (bool) {\n', '      //this function is for the case of a timeout in the commit / reveal\n', '      // if a player realizes they are going to lose, they can refuse to reveal\n', '      // therefore we must have a timeout of TIMEOUTBLOCKS and if that time is reached\n', '      // the other player can get in and drain the remaining tokens from the game\n', '      require( stacks[_stack].owner==msg.sender || stacks[_counterStack].owner==msg.sender );\n', '      //the counter must be a counter of stack 1\n', '      require( stackCounter[_counterStack]==_stack );\n', '      require( counterOfStack[_stack]==_counterStack );\n', "      //the bad guy shouldn't be able to drain\n", '      require( lastActor[_stack]==msg.sender );\n', '      //must be after timeout period\n', '      require( block.number - lastBlock[_stack] >= TIMEOUTBLOCKS);\n', '      //game must still be going\n', '      require( mode[_stack]<9 );\n', '\n', '      for(uint8 i=0;i<10;i++){\n', '        if(mixedStack[_stack][i]>0){\n', '          uint256 tempId = mixedStack[_stack][i];\n', '          mixedStack[_stack][i]=0;\n', '          SlammerTime slammerTimeContract = SlammerTime(slammerTime);\n', '          slammerTimeContract.transferBack(msg.sender,tempId);\n', '        }\n', '      }\n', '\n', '      FinishGame(_stack);\n', '      mode[_stack]=9;\n', '\n', '      delete mixedStack[_stack];\n', '      delete stacks[_stack];\n', '      delete stackCounter[_counterStack];\n', '      delete stacks[_counterStack];\n', '      delete lastBlock[_stack];\n', '      delete lastActor[_stack];\n', '      delete counterOfStack[_stack];\n', '      delete round[_stack];\n', '      delete commitBlock[_stack];\n', '      delete commit[_stack];\n', '\n', '      DrainStack(_stack,_counterStack,msg.sender);\n', '    }\n', '    event DrainStack(bytes32 stack,bytes32 counterStack,address sender);\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return items.length - 1;\n', '    }\n', '\n', '    function tokensOfOwner(address _owner) external view returns(uint256[]) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '        if (tokenCount == 0) {\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            uint256 total = totalSupply();\n', '            uint256 resultIndex = 0;\n', '            uint256 id;\n', '            for (id = 1; id <= total; id++) {\n', '                if (tokenIndexToOwner[id] == _owner) {\n', '                    result[resultIndex] = id;\n', '                    resultIndex++;\n', '                }\n', '            }\n', '            return result;\n', '        }\n', '    }\n', '\n', '    function withdraw(uint256 _amount) public onlyOwner returns (bool) {\n', '      require(this.balance >= _amount);\n', '      assert(owner.send(_amount));\n', '      return true;\n', '    }\n', '\n', '    function withdrawToken(address _token,uint256 _amount) public onlyOwner returns (bool) {\n', '      StandardToken token = StandardToken(_token);\n', '      token.transfer(msg.sender,_amount);\n', '      return true;\n', '    }\n', '\n', '\n', '    //adapted from ERC-677 from my dude Steve Ellis - thanks man!\n', '    function transferStackAndCall(address _to, uint _token1, uint _token2, uint _token3, uint _token4, uint _token5, bytes32 _data) public returns (bool) {\n', '      transfer(_to, _token1);\n', '      transfer(_to, _token2);\n', '      transfer(_to, _token3);\n', '      transfer(_to, _token4);\n', '      transfer(_to, _token5);\n', '\n', '      if (isContract(_to)) {\n', '        contractFallback(_to,_token1,_token2,_token3,_token4,_token5,_data);\n', '      }\n', '      return true;\n', '    }\n', '\n', '    function contractFallback(address _to, uint _token1, uint _token2, uint _token3, uint _token4, uint _token5, bytes32 _data) private {\n', '      StackReceiver receiver = StackReceiver(_to);\n', '      receiver.onTransferStack(msg.sender,_token1,_token2,_token3,_token4,_token5,_data);\n', '    }\n', '\n', '    function isContract(address _addr) private returns (bool hasCode) {\n', '      uint length;\n', '      assembly { length := extcodesize(_addr) }\n', '      return length > 0;\n', '    }\n', '\n', '}\n', '\n', 'contract StackReceiver {\n', '  function onTransferStack(address _sender, uint _token1, uint _token2, uint _token3, uint _token4, uint _token5, bytes32 _data);\n', '}\n', '\n', 'contract StandardToken {\n', '  function transfer(address _to, uint256 _value) public returns (bool) { }\n', '}\n', '\n', 'contract SlammerTime {\n', '  function startSlammerTime(address _player1,uint256[5] _id1,address _player2,uint256[5] _id2) public returns (bool) { }\n', '  function transferBack(address _toWhom, uint256 _id) public returns (bool) { }\n', '}']
