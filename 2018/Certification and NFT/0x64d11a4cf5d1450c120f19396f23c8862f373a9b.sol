['pragma solidity ^0.4.25;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, reverts on overflow.\n', '     */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '        return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', '        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, reverts on overflow.\n', '     */\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address _newOwner) internal {\n', '        require(_newOwner != address(0));\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Currency exchange rate contract\n', ' */\n', 'contract CurrencyExchangeRate is Ownable {\n', '\n', '    struct Currency {\n', '        uint256 exRateToEther; // Exchange rate: currency to Ether\n', '        uint8 exRateDecimals;  // Exchange rate decimals\n', '    }\n', '\n', '    Currency[] public currencies;\n', '\n', '    event CurrencyExchangeRateAdded(\n', '        address indexed setter, uint256 index, uint256 rate, uint256 decimals\n', '    );\n', '\n', '    event CurrencyExchangeRateSet(\n', '        address indexed setter, uint256 index, uint256 rate, uint256 decimals\n', '    );\n', '\n', '    constructor() public {\n', '        // Add Ether to index 0\n', '        currencies.push(\n', '            Currency ({\n', '                exRateToEther: 1,\n', '                exRateDecimals: 0\n', '            })\n', '        );\n', '        // Add USD to index 1\n', '        currencies.push(\n', '            Currency ({\n', '                exRateToEther: 30000,\n', '                exRateDecimals: 2\n', '            })\n', '        );\n', '    }\n', '\n', '    function addCurrencyExchangeRate(\n', '        uint256 _exRateToEther, \n', '        uint8 _exRateDecimals\n', '    ) external onlyOwner {\n', '        emit CurrencyExchangeRateAdded(\n', '            msg.sender, currencies.length, _exRateToEther, _exRateDecimals);\n', '        currencies.push(\n', '            Currency ({\n', '                exRateToEther: _exRateToEther,\n', '                exRateDecimals: _exRateDecimals\n', '            })\n', '        );\n', '    }\n', '\n', '    function setCurrencyExchangeRate(\n', '        uint256 _currencyIndex,\n', '        uint256 _exRateToEther, \n', '        uint8 _exRateDecimals\n', '    ) external onlyOwner {\n', '        emit CurrencyExchangeRateSet(\n', '            msg.sender, _currencyIndex, _exRateToEther, _exRateDecimals);\n', '        currencies[_currencyIndex].exRateToEther = _exRateToEther;\n', '        currencies[_currencyIndex].exRateDecimals = _exRateDecimals;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title KYC contract interface\n', ' */\n', 'contract KYC {\n', '    \n', '    /**\n', '     * Get KYC expiration timestamp in second.\n', '     *\n', '     * @param _who Account address\n', '     * @return KYC expiration timestamp in second\n', '     */\n', '    function expireOf(address _who) external view returns (uint256);\n', '\n', '    /**\n', '     * Get KYC level.\n', '     * Level is ranging from 0 (lowest, no KYC) to 255 (highest, toughest).\n', '     *\n', '     * @param _who Account address\n', '     * @return KYC level\n', '     */\n', '    function kycLevelOf(address _who) external view returns (uint8);\n', '\n', '    /**\n', '     * Get encoded nationalities (country list).\n', '     * The uint256 is represented by 256 bits (0 or 1).\n', '     * Every bit can represent a country.\n', '     * For each listed country, set the corresponding bit to 1.\n', '     * To do so, up to 256 countries can be encoded in an uint256 variable.\n', '     * Further, if country blacklist of an ICO was encoded by the same way,\n', '     * it is able to use bitwise AND to check whether the investor can invest\n', '     * the ICO by the crowdsale.\n', '     *\n', '     * @param _who Account address\n', '     * @return Encoded nationalities\n', '     */\n', '    function nationalitiesOf(address _who) external view returns (uint256);\n', '\n', '    /**\n', '     * Set KYC status to specific account address.\n', '     *\n', '     * @param _who Account address\n', '     * @param _expiresAt Expire timestamp in seconds\n', '     * @param _level KYC level\n', '     * @param _nationalities Encoded nationalities\n', '     */\n', '    function setKYC(\n', '        address _who, uint256 _expiresAt, uint8 _level, uint256 _nationalities) \n', '        external;\n', '\n', '    event KYCSet (\n', '        address indexed _setter,\n', '        address indexed _who,\n', '        uint256 _expiresAt,\n', '        uint8 _level,\n', '        uint256 _nationalities\n', '    );\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    function balanceOf(address _who) public view returns (uint256);\n', '\n', '    function allowance(address _owner, address _spender)\n', '        public view returns (uint256);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '    function approve(address _spender, uint256 _value)\n', '        public returns (bool);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public returns (bool);\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', '\n', 'contract EtherVault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    enum State { Active, Refunding, Closed }\n', '\n', '    address public wallet;\n', '    State public state;\n', '\n', '    event Closed(address indexed commissionWallet, uint256 commission);\n', '    event RefundsEnabled();\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '    constructor(address _wallet) public {\n', '        require(\n', '            _wallet != address(0),\n', '            "Failed to create Ether vault due to wallet address is 0x0."\n', '        );\n', '        wallet = _wallet;\n', '        state = State.Active;\n', '    }\n', '\n', '    function deposit() public onlyOwner payable {\n', '        require(\n', '            state == State.Active,\n', '            "Failed to deposit Ether due to state is not Active."\n', '        );\n', '    }\n', '\n', '    function close(address _commissionWallet, uint256 _commission) public onlyOwner {\n', '        require(\n', '            state == State.Active,\n', '            "Failed to close due to state is not Active."\n', '        );\n', '        state = State.Closed;\n', '        emit Closed(_commissionWallet, _commission);\n', '        _commissionWallet.transfer(address(this).balance.mul(_commission).div(100));\n', '        wallet.transfer(address(this).balance);\n', '    }\n', '\n', '    function enableRefunds() public onlyOwner {\n', '        require(\n', '            state == State.Active,\n', '            "Failed to enable refunds due to state is not Active."\n', '        );\n', '        emit RefundsEnabled();\n', '        state = State.Refunding;        \n', '    }\n', '\n', '    function refund(address investor, uint256 depositedValue) public onlyOwner {\n', '        require(\n', '            state == State.Refunding,\n', '            "Failed to refund due to state is not Refunding."\n', '        );\n', '        emit Refunded(investor, depositedValue);\n', '        investor.transfer(depositedValue);        \n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ICO Rocket Fuel contract for FirstMile/LastMile service.\n', ' */\n', 'contract IcoRocketFuel is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    // Crowdsale current state\n', '    enum States {Ready, Active, Paused, Refunding, Closed}\n', '    States public state = States.Ready;\n', '\n', '    // Token for crowdsale (Token contract).\n', '    // Replace 0x0 by deployed ERC20 token address.\n', '    ERC20 public token = ERC20(0x0e27b0ca1f890d37737dd5cde9de22431255f524);\n', '\n', '    // Crowdsale owner (ICO team).\n', '    // Replace 0x0 by wallet address of ICO team.\n', '    address public crowdsaleOwner = 0xf75589cac3b23f24de65fe5a3cd07966728071a3;\n', '\n', '    // When crowdsale is closed, commissions will transfer to this wallet.\n', '    // Replace 0x0 by commission wallet address of platform.\n', '    address public commissionWallet = 0xf75589cac3b23f24de65fe5a3cd07966728071a3;\n', '\n', '    // Base exchange rate (1 invested currency = N tokens) and its decimals.\n', '    // Ex. to present base exchange rate = 0.01 (= 1 / (10^2))\n', '    //     baseExRate = 1; baseExRateDecimals = 2 \n', '    //     (1 / (10^2)) equal to (baseExRate / (10^baseExRateDecimals))\n', '    uint256 public baseExRate = 20;    \n', '    uint8 public baseExRateDecimals = 0;\n', '\n', '    // External exchange rate contract and currency index.\n', '    // Use exRate.currencies(currency) to get tuple.\n', '    // tuple = (Exchange rate to Ether, Exchange rate decimal)\n', '    // Replace 0x0 by address of deployed CurrencyExchangeRate contract.\n', '    CurrencyExchangeRate public exRate = CurrencyExchangeRate(0x44802e3d6fb67bd8ee7b24033ee04b1290692fd9);\n', '    // Supported currency\n', '    // 0: Ether\n', '    // 1: USD\n', '    uint256 public currency = 1;\n', '\n', '    // Total raised in specified currency.\n', '    uint256 public raised = 0;\n', '    // Hard cap in specified currency.\n', '    uint256 public cap = 25000000 * (10**18);\n', '    // Soft cap in specified currency.\n', '    uint256 public goal = 0;\n', '    // Minimum investment in specified currency.\n', '    uint256 public minInvest = 50000 * (10**18);\n', '    \n', '    // Crowdsale closing time in second.\n', '    uint256 public closingTime = 1548979200;\n', '    // Whether allow early closure\n', '    bool public earlyClosure = true;\n', '\n', '    // Commission percentage. Set to 10 means 10% \n', '    uint8 public commission = 10;\n', '\n', '    // When KYC is required, check KYC result with this contract.\n', '    // The value is initiated by constructor.\n', '    // The value is not allowed to change after contract deployment.\n', '    // Replace 0x0 by address of deployed KYC contract.\n', '    KYC public kyc = KYC(0x8df3064451f840285993e2a4cfc0ec56b267d288);\n', '\n', '    // Get encoded country blacklist.\n', '    // The uint256 is represented by 256 bits (0 or 1).\n', '    // Every bit can represent a country.\n', '    // For the country listed in the blacklist, set the corresponding bit to 1.\n', '    // To do so, up to 256 countries can be encoded in an uint256 variable.\n', '    // Further, if nationalities of an investor were encoded by the same way,\n', '    // it is able to use bitwise AND to check whether the investor can invest\n', '    // the ICO by the crowdsale.\n', '    // Keypasco: Natural persons from Singapore and United States cannot invest.\n', '    uint256 public countryBlacklist = 27606985387965724171868518586879082855975017189942647717541493312847872;\n', '\n', '    // Get required KYC level of the crowdsale.\n', '    // KYC level = 0 (default): Crowdsale does not require KYC.\n', '    // KYC level > 0: Crowdsale requires centain level of KYC.\n', '    // KYC level ranges from 0 (no KYC) to 255 (toughest).\n', '    uint8 public kycLevel = 100;\n', '\n', '    // Whether legal person can skip country check.\n', '    // True: can skip; False: cannot skip.  \n', '    bool public legalPersonSkipsCountryCheck = true;\n', '\n', '    // Use deposits[buyer] to get deposited Wei for buying the token.\n', '    // The buyer is the buyer address.\n', '    mapping(address => uint256) public deposits;\n', '    // Ether vault entrusts invested Wei.\n', '    EtherVault public vault;\n', '    \n', '    // Investment in specified currency.\n', '    // Use invests[buyer] to get current investments.\n', '    mapping(address => uint256) public invests;\n', '    // Token units can be claimed by buyer.\n', '    // Use tokenUnits[buyer] to get current bought token units.\n', '    mapping(address => uint256) public tokenUnits;\n', '    // Total token units for performing the deal.\n', '    // Sum of all buyers&#39; bought token units will equal to this value.\n', '    uint256 public totalTokenUnits = 0;\n', '\n', '    // Bonus tiers which will be initiated in constructor.\n', '    struct BonusTier {\n', '        uint256 investSize; // Invest in specified currency\n', '        uint256 bonus;      // Bonus in percentage\n', '    }\n', '    // Bonus levels initiated by constructor.\n', '    BonusTier[] public bonusTiers;\n', '\n', '    event StateSet(\n', '        address indexed setter, \n', '        States oldState, \n', '        States newState\n', '    );\n', '\n', '    event CrowdsaleStarted(\n', '        address indexed icoTeam\n', '    );\n', '\n', '    event TokenBought(\n', '        address indexed buyer, \n', '        uint256 valueWei, \n', '        uint256 valueCurrency\n', '    );\n', '\n', '    event TokensRefunded(\n', '        address indexed beneficiary,\n', '        uint256 valueTokenUnit\n', '    );\n', '\n', '    event Finalized(\n', '        address indexed icoTeam\n', '    );\n', '\n', '    event SurplusTokensRefunded(\n', '        address indexed beneficiary,\n', '        uint256 valueTokenUnit\n', '    );\n', '\n', '    event CrowdsaleStopped(\n', '        address indexed owner\n', '    );\n', '\n', '    event TokenClaimed(\n', '        address indexed beneficiary,\n', '        uint256 valueTokenUnit\n', '    );\n', '\n', '    event RefundClaimed(\n', '        address indexed beneficiary,\n', '        uint256 valueWei\n', '    );\n', '\n', '    modifier onlyCrowdsaleOwner() {\n', '        require(\n', '            msg.sender == crowdsaleOwner,\n', '            "Failed to call function due to permission denied."\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier inState(States _state) {\n', '        require(\n', '            state == _state,\n', '            "Failed to call function due to crowdsale is not in right state."\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        // Must push higher bonus first.\n', '        bonusTiers.push(\n', '            BonusTier({\n', '                investSize: 400000 * (10**18),\n', '                bonus: 50\n', '            })\n', '        );\n', '        bonusTiers.push(\n', '            BonusTier({\n', '                investSize: 200000 * (10**18),\n', '                bonus: 40\n', '            })\n', '        );\n', '        bonusTiers.push(\n', '            BonusTier({\n', '                investSize: 100000 * (10**18),\n', '                bonus: 30\n', '            })\n', '        );\n', '        bonusTiers.push(\n', '            BonusTier({\n', '                investSize: 50000 * (10**18),\n', '                bonus: 20\n', '            })\n', '        );\n', '    }\n', '\n', '    function setAddress(\n', '        address _token,\n', '        address _crowdsaleOwner,\n', '        address _commissionWallet,\n', '        address _exRate,\n', '        address _kyc\n', '    ) external onlyOwner inState(States.Ready){\n', '        token = ERC20(_token);\n', '        crowdsaleOwner = _crowdsaleOwner;\n', '        commissionWallet = _commissionWallet;\n', '        exRate = CurrencyExchangeRate(_exRate);\n', '        kyc = KYC(_kyc);\n', '    }\n', '\n', '    function setSpecialOffer(\n', '        uint256 _currency,\n', '        uint256 _cap,\n', '        uint256 _goal,\n', '        uint256 _minInvest,\n', '        uint256 _closingTime\n', '    ) external onlyOwner inState(States.Ready) {\n', '        currency = _currency;\n', '        cap = _cap;\n', '        goal = _goal;\n', '        minInvest = _minInvest;\n', '        closingTime = _closingTime;\n', '    }\n', '\n', '    function setInvestRestriction(\n', '        uint256 _countryBlacklist,\n', '        uint8 _kycLevel,\n', '        bool _legalPersonSkipsCountryCheck\n', '    ) external onlyOwner inState(States.Ready) {\n', '        countryBlacklist = _countryBlacklist;\n', '        kycLevel = _kycLevel;\n', '        legalPersonSkipsCountryCheck = _legalPersonSkipsCountryCheck;\n', '    }\n', '\n', '    function setState(uint256 _state) external onlyOwner {\n', '        require(\n', '            uint256(state) < uint256(States.Refunding),\n', '            "Failed to set state due to crowdsale was finalized."\n', '        );\n', '        require(\n', '            // Only allow switch state between Active and Paused.\n', '            uint256(States.Active) == _state || uint256(States.Paused) == _state,\n', '            "Failed to set state due to invalid index."\n', '        );\n', '        emit StateSet(msg.sender, state, States(_state));\n', '        state = States(_state);\n', '    }\n', '\n', '    /**\n', '     * Get bonus in token units.\n', '     * @param _investSize Total investment size in specified currency\n', '     * @param _tokenUnits Token units for the investment (without bonus)\n', '     * @return Bonus in token units\n', '     */\n', '    function _getBonus(uint256 _investSize, uint256 _tokenUnits) \n', '        private view returns (uint256) \n', '    {\n', '        for (uint256 _i = 0; _i < bonusTiers.length; _i++) {\n', '            if (_investSize >= bonusTiers[_i].investSize) {\n', '                return _tokenUnits.mul(bonusTiers[_i].bonus).div(100);\n', '            }\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * Start crowdsale.\n', '     */\n', '    function startCrowdsale()\n', '        external\n', '        onlyCrowdsaleOwner\n', '        inState(States.Ready)\n', '    {\n', '        emit CrowdsaleStarted(msg.sender);\n', '        vault = new EtherVault(msg.sender);\n', '        state = States.Active;\n', '    }\n', '\n', '    /**\n', '     * Buy token.\n', '     */\n', '    function buyToken()\n', '        external\n', '        inState(States.Active)\n', '        payable\n', '    {\n', '        // KYC level = 0 means no KYC can invest.\n', '        // KYC level > 0 means certain level of KYC is required.\n', '        if (kycLevel > 0) {\n', '            require(\n', '                // solium-disable-next-line security/no-block-members\n', '                block.timestamp < kyc.expireOf(msg.sender),\n', '                "Failed to buy token due to KYC was expired."\n', '            );\n', '        }\n', '\n', '        require(\n', '            kycLevel <= kyc.kycLevelOf(msg.sender),\n', '            "Failed to buy token due to require higher KYC level."\n', '        );\n', '\n', '        require(\n', '            countryBlacklist & kyc.nationalitiesOf(msg.sender) == 0 || (\n', '                kyc.kycLevelOf(msg.sender) >= 200 && legalPersonSkipsCountryCheck\n', '            ),\n', '            "Failed to buy token due to country investment restriction."\n', '        );\n', '\n', '        // Get exchange rate of specified currency.\n', '        (uint256 _exRate, uint8 _exRateDecimals) = exRate.currencies(currency);\n', '\n', '        // Convert from Ether to base currency.\n', '        uint256 _investSize = (msg.value)\n', '            .mul(_exRate).div(10**uint256(_exRateDecimals));\n', '\n', '        require(\n', '            _investSize >= minInvest,\n', '            "Failed to buy token due to less than minimum investment."\n', '        );\n', '\n', '        require(\n', '            raised.add(_investSize) <= cap,\n', '            "Failed to buy token due to exceed cap."\n', '        );\n', '\n', '        require(\n', '            // solium-disable-next-line security/no-block-members\n', '            block.timestamp < closingTime,\n', '            "Failed to buy token due to crowdsale is closed."\n', '        );\n', '\n', '        // Update total invested in specified currency.\n', '        invests[msg.sender] = invests[msg.sender].add(_investSize);\n', '        // Update total invested wei.\n', '        deposits[msg.sender] = deposits[msg.sender].add(msg.value);\n', '        // Update total raised in specified currency.    \n', '        raised = raised.add(_investSize);\n', '\n', '        // Log previous token units.\n', '        uint256 _previousTokenUnits = tokenUnits[msg.sender];\n', '\n', '        // Calculate token units by base exchange rate.\n', '        uint256 _tokenUnits = invests[msg.sender]\n', '            .mul(baseExRate)\n', '            .div(10**uint256(baseExRateDecimals));\n', '\n', '        // Calculate bought token units (take bonus into account).\n', '        uint256 _tokenUnitsWithBonus = _tokenUnits.add(\n', '            _getBonus(invests[msg.sender], _tokenUnits));\n', '\n', '        // Update total bought token units.\n', '        tokenUnits[msg.sender] = _tokenUnitsWithBonus;\n', '\n', '        // Update total token units to be issued.\n', '        totalTokenUnits = totalTokenUnits\n', '            .sub(_previousTokenUnits)\n', '            .add(_tokenUnitsWithBonus);\n', '\n', '        emit TokenBought(msg.sender, msg.value, _investSize);\n', '\n', '        // Entrust wei to vault.\n', '        vault.deposit.value(msg.value)();\n', '    }\n', '\n', '    /**\n', '     * Refund token units to wallet address of crowdsale owner.\n', '     */\n', '    function _refundTokens()\n', '        private\n', '        inState(States.Refunding)\n', '    {\n', '        uint256 _value = token.balanceOf(address(this));\n', '        emit TokensRefunded(crowdsaleOwner, _value);\n', '        if (_value > 0) {         \n', '            // Refund all tokens for crowdsale to refund wallet.\n', '            token.transfer(crowdsaleOwner, _value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Finalize this crowdsale.\n', '     */\n', '    function finalize()\n', '        external\n', '        inState(States.Active)        \n', '        onlyCrowdsaleOwner\n', '    {\n', '        require(\n', '            // solium-disable-next-line security/no-block-members                \n', '            earlyClosure || block.timestamp >= closingTime,                   \n', '            "Failed to finalize due to crowdsale is opening."\n', '        );\n', '\n', '        emit Finalized(msg.sender);\n', '\n', '        if (raised >= goal && token.balanceOf(address(this)) >= totalTokenUnits) {\n', '            // Set state to Closed whiling preventing reentry.\n', '            state = States.Closed;\n', '\n', '            // Refund surplus tokens.\n', '            uint256 _balance = token.balanceOf(address(this));\n', '            uint256 _surplus = _balance.sub(totalTokenUnits);\n', '            emit SurplusTokensRefunded(crowdsaleOwner, _surplus);\n', '            if (_surplus > 0) {\n', '                // Refund surplus tokens to refund wallet.\n', '                token.transfer(crowdsaleOwner, _surplus);\n', '            }\n', '            // Close vault, and transfer commission and raised ether.\n', '            vault.close(commissionWallet, commission);\n', '        } else {\n', '            state = States.Refunding;\n', '            _refundTokens();\n', '            vault.enableRefunds();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Stop this crowdsale.\n', '     * Only stop suspecious projects.\n', '     */\n', '    function stopCrowdsale()  \n', '        external\n', '        onlyOwner\n', '        inState(States.Paused)\n', '    {\n', '        emit CrowdsaleStopped(msg.sender);\n', '        state = States.Refunding;\n', '        _refundTokens();\n', '        vault.enableRefunds();\n', '    }\n', '\n', '    /**\n', '     * Investors claim bought token units.\n', '     */\n', '    function claimToken()\n', '        external \n', '        inState(States.Closed)\n', '    {\n', '        require(\n', '            tokenUnits[msg.sender] > 0,\n', '            "Failed to claim token due to token unit is 0."\n', '        );\n', '        uint256 _value = tokenUnits[msg.sender];\n', '        tokenUnits[msg.sender] = 0;\n', '        emit TokenClaimed(msg.sender, _value);\n', '        token.transfer(msg.sender, _value);\n', '    }\n', '\n', '    /**\n', '     * Investors claim invested Ether refunds.\n', '     */\n', '    function claimRefund()\n', '        external\n', '        inState(States.Refunding)\n', '    {\n', '        require(\n', '            deposits[msg.sender] > 0,\n', '            "Failed to claim refund due to deposit is 0."\n', '        );\n', '\n', '        uint256 _value = deposits[msg.sender];\n', '        deposits[msg.sender] = 0;\n', '        emit RefundClaimed(msg.sender, _value);\n', '        vault.refund(msg.sender, _value);\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, reverts on overflow.\n', '     */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '        return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', "        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, reverts on overflow.\n', '     */\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address _newOwner) internal {\n', '        require(_newOwner != address(0));\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Currency exchange rate contract\n', ' */\n', 'contract CurrencyExchangeRate is Ownable {\n', '\n', '    struct Currency {\n', '        uint256 exRateToEther; // Exchange rate: currency to Ether\n', '        uint8 exRateDecimals;  // Exchange rate decimals\n', '    }\n', '\n', '    Currency[] public currencies;\n', '\n', '    event CurrencyExchangeRateAdded(\n', '        address indexed setter, uint256 index, uint256 rate, uint256 decimals\n', '    );\n', '\n', '    event CurrencyExchangeRateSet(\n', '        address indexed setter, uint256 index, uint256 rate, uint256 decimals\n', '    );\n', '\n', '    constructor() public {\n', '        // Add Ether to index 0\n', '        currencies.push(\n', '            Currency ({\n', '                exRateToEther: 1,\n', '                exRateDecimals: 0\n', '            })\n', '        );\n', '        // Add USD to index 1\n', '        currencies.push(\n', '            Currency ({\n', '                exRateToEther: 30000,\n', '                exRateDecimals: 2\n', '            })\n', '        );\n', '    }\n', '\n', '    function addCurrencyExchangeRate(\n', '        uint256 _exRateToEther, \n', '        uint8 _exRateDecimals\n', '    ) external onlyOwner {\n', '        emit CurrencyExchangeRateAdded(\n', '            msg.sender, currencies.length, _exRateToEther, _exRateDecimals);\n', '        currencies.push(\n', '            Currency ({\n', '                exRateToEther: _exRateToEther,\n', '                exRateDecimals: _exRateDecimals\n', '            })\n', '        );\n', '    }\n', '\n', '    function setCurrencyExchangeRate(\n', '        uint256 _currencyIndex,\n', '        uint256 _exRateToEther, \n', '        uint8 _exRateDecimals\n', '    ) external onlyOwner {\n', '        emit CurrencyExchangeRateSet(\n', '            msg.sender, _currencyIndex, _exRateToEther, _exRateDecimals);\n', '        currencies[_currencyIndex].exRateToEther = _exRateToEther;\n', '        currencies[_currencyIndex].exRateDecimals = _exRateDecimals;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title KYC contract interface\n', ' */\n', 'contract KYC {\n', '    \n', '    /**\n', '     * Get KYC expiration timestamp in second.\n', '     *\n', '     * @param _who Account address\n', '     * @return KYC expiration timestamp in second\n', '     */\n', '    function expireOf(address _who) external view returns (uint256);\n', '\n', '    /**\n', '     * Get KYC level.\n', '     * Level is ranging from 0 (lowest, no KYC) to 255 (highest, toughest).\n', '     *\n', '     * @param _who Account address\n', '     * @return KYC level\n', '     */\n', '    function kycLevelOf(address _who) external view returns (uint8);\n', '\n', '    /**\n', '     * Get encoded nationalities (country list).\n', '     * The uint256 is represented by 256 bits (0 or 1).\n', '     * Every bit can represent a country.\n', '     * For each listed country, set the corresponding bit to 1.\n', '     * To do so, up to 256 countries can be encoded in an uint256 variable.\n', '     * Further, if country blacklist of an ICO was encoded by the same way,\n', '     * it is able to use bitwise AND to check whether the investor can invest\n', '     * the ICO by the crowdsale.\n', '     *\n', '     * @param _who Account address\n', '     * @return Encoded nationalities\n', '     */\n', '    function nationalitiesOf(address _who) external view returns (uint256);\n', '\n', '    /**\n', '     * Set KYC status to specific account address.\n', '     *\n', '     * @param _who Account address\n', '     * @param _expiresAt Expire timestamp in seconds\n', '     * @param _level KYC level\n', '     * @param _nationalities Encoded nationalities\n', '     */\n', '    function setKYC(\n', '        address _who, uint256 _expiresAt, uint8 _level, uint256 _nationalities) \n', '        external;\n', '\n', '    event KYCSet (\n', '        address indexed _setter,\n', '        address indexed _who,\n', '        uint256 _expiresAt,\n', '        uint8 _level,\n', '        uint256 _nationalities\n', '    );\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    function balanceOf(address _who) public view returns (uint256);\n', '\n', '    function allowance(address _owner, address _spender)\n', '        public view returns (uint256);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '    function approve(address _spender, uint256 _value)\n', '        public returns (bool);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public returns (bool);\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', '\n', 'contract EtherVault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    enum State { Active, Refunding, Closed }\n', '\n', '    address public wallet;\n', '    State public state;\n', '\n', '    event Closed(address indexed commissionWallet, uint256 commission);\n', '    event RefundsEnabled();\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '    constructor(address _wallet) public {\n', '        require(\n', '            _wallet != address(0),\n', '            "Failed to create Ether vault due to wallet address is 0x0."\n', '        );\n', '        wallet = _wallet;\n', '        state = State.Active;\n', '    }\n', '\n', '    function deposit() public onlyOwner payable {\n', '        require(\n', '            state == State.Active,\n', '            "Failed to deposit Ether due to state is not Active."\n', '        );\n', '    }\n', '\n', '    function close(address _commissionWallet, uint256 _commission) public onlyOwner {\n', '        require(\n', '            state == State.Active,\n', '            "Failed to close due to state is not Active."\n', '        );\n', '        state = State.Closed;\n', '        emit Closed(_commissionWallet, _commission);\n', '        _commissionWallet.transfer(address(this).balance.mul(_commission).div(100));\n', '        wallet.transfer(address(this).balance);\n', '    }\n', '\n', '    function enableRefunds() public onlyOwner {\n', '        require(\n', '            state == State.Active,\n', '            "Failed to enable refunds due to state is not Active."\n', '        );\n', '        emit RefundsEnabled();\n', '        state = State.Refunding;        \n', '    }\n', '\n', '    function refund(address investor, uint256 depositedValue) public onlyOwner {\n', '        require(\n', '            state == State.Refunding,\n', '            "Failed to refund due to state is not Refunding."\n', '        );\n', '        emit Refunded(investor, depositedValue);\n', '        investor.transfer(depositedValue);        \n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ICO Rocket Fuel contract for FirstMile/LastMile service.\n', ' */\n', 'contract IcoRocketFuel is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    // Crowdsale current state\n', '    enum States {Ready, Active, Paused, Refunding, Closed}\n', '    States public state = States.Ready;\n', '\n', '    // Token for crowdsale (Token contract).\n', '    // Replace 0x0 by deployed ERC20 token address.\n', '    ERC20 public token = ERC20(0x0e27b0ca1f890d37737dd5cde9de22431255f524);\n', '\n', '    // Crowdsale owner (ICO team).\n', '    // Replace 0x0 by wallet address of ICO team.\n', '    address public crowdsaleOwner = 0xf75589cac3b23f24de65fe5a3cd07966728071a3;\n', '\n', '    // When crowdsale is closed, commissions will transfer to this wallet.\n', '    // Replace 0x0 by commission wallet address of platform.\n', '    address public commissionWallet = 0xf75589cac3b23f24de65fe5a3cd07966728071a3;\n', '\n', '    // Base exchange rate (1 invested currency = N tokens) and its decimals.\n', '    // Ex. to present base exchange rate = 0.01 (= 1 / (10^2))\n', '    //     baseExRate = 1; baseExRateDecimals = 2 \n', '    //     (1 / (10^2)) equal to (baseExRate / (10^baseExRateDecimals))\n', '    uint256 public baseExRate = 20;    \n', '    uint8 public baseExRateDecimals = 0;\n', '\n', '    // External exchange rate contract and currency index.\n', '    // Use exRate.currencies(currency) to get tuple.\n', '    // tuple = (Exchange rate to Ether, Exchange rate decimal)\n', '    // Replace 0x0 by address of deployed CurrencyExchangeRate contract.\n', '    CurrencyExchangeRate public exRate = CurrencyExchangeRate(0x44802e3d6fb67bd8ee7b24033ee04b1290692fd9);\n', '    // Supported currency\n', '    // 0: Ether\n', '    // 1: USD\n', '    uint256 public currency = 1;\n', '\n', '    // Total raised in specified currency.\n', '    uint256 public raised = 0;\n', '    // Hard cap in specified currency.\n', '    uint256 public cap = 25000000 * (10**18);\n', '    // Soft cap in specified currency.\n', '    uint256 public goal = 0;\n', '    // Minimum investment in specified currency.\n', '    uint256 public minInvest = 50000 * (10**18);\n', '    \n', '    // Crowdsale closing time in second.\n', '    uint256 public closingTime = 1548979200;\n', '    // Whether allow early closure\n', '    bool public earlyClosure = true;\n', '\n', '    // Commission percentage. Set to 10 means 10% \n', '    uint8 public commission = 10;\n', '\n', '    // When KYC is required, check KYC result with this contract.\n', '    // The value is initiated by constructor.\n', '    // The value is not allowed to change after contract deployment.\n', '    // Replace 0x0 by address of deployed KYC contract.\n', '    KYC public kyc = KYC(0x8df3064451f840285993e2a4cfc0ec56b267d288);\n', '\n', '    // Get encoded country blacklist.\n', '    // The uint256 is represented by 256 bits (0 or 1).\n', '    // Every bit can represent a country.\n', '    // For the country listed in the blacklist, set the corresponding bit to 1.\n', '    // To do so, up to 256 countries can be encoded in an uint256 variable.\n', '    // Further, if nationalities of an investor were encoded by the same way,\n', '    // it is able to use bitwise AND to check whether the investor can invest\n', '    // the ICO by the crowdsale.\n', '    // Keypasco: Natural persons from Singapore and United States cannot invest.\n', '    uint256 public countryBlacklist = 27606985387965724171868518586879082855975017189942647717541493312847872;\n', '\n', '    // Get required KYC level of the crowdsale.\n', '    // KYC level = 0 (default): Crowdsale does not require KYC.\n', '    // KYC level > 0: Crowdsale requires centain level of KYC.\n', '    // KYC level ranges from 0 (no KYC) to 255 (toughest).\n', '    uint8 public kycLevel = 100;\n', '\n', '    // Whether legal person can skip country check.\n', '    // True: can skip; False: cannot skip.  \n', '    bool public legalPersonSkipsCountryCheck = true;\n', '\n', '    // Use deposits[buyer] to get deposited Wei for buying the token.\n', '    // The buyer is the buyer address.\n', '    mapping(address => uint256) public deposits;\n', '    // Ether vault entrusts invested Wei.\n', '    EtherVault public vault;\n', '    \n', '    // Investment in specified currency.\n', '    // Use invests[buyer] to get current investments.\n', '    mapping(address => uint256) public invests;\n', '    // Token units can be claimed by buyer.\n', '    // Use tokenUnits[buyer] to get current bought token units.\n', '    mapping(address => uint256) public tokenUnits;\n', '    // Total token units for performing the deal.\n', "    // Sum of all buyers' bought token units will equal to this value.\n", '    uint256 public totalTokenUnits = 0;\n', '\n', '    // Bonus tiers which will be initiated in constructor.\n', '    struct BonusTier {\n', '        uint256 investSize; // Invest in specified currency\n', '        uint256 bonus;      // Bonus in percentage\n', '    }\n', '    // Bonus levels initiated by constructor.\n', '    BonusTier[] public bonusTiers;\n', '\n', '    event StateSet(\n', '        address indexed setter, \n', '        States oldState, \n', '        States newState\n', '    );\n', '\n', '    event CrowdsaleStarted(\n', '        address indexed icoTeam\n', '    );\n', '\n', '    event TokenBought(\n', '        address indexed buyer, \n', '        uint256 valueWei, \n', '        uint256 valueCurrency\n', '    );\n', '\n', '    event TokensRefunded(\n', '        address indexed beneficiary,\n', '        uint256 valueTokenUnit\n', '    );\n', '\n', '    event Finalized(\n', '        address indexed icoTeam\n', '    );\n', '\n', '    event SurplusTokensRefunded(\n', '        address indexed beneficiary,\n', '        uint256 valueTokenUnit\n', '    );\n', '\n', '    event CrowdsaleStopped(\n', '        address indexed owner\n', '    );\n', '\n', '    event TokenClaimed(\n', '        address indexed beneficiary,\n', '        uint256 valueTokenUnit\n', '    );\n', '\n', '    event RefundClaimed(\n', '        address indexed beneficiary,\n', '        uint256 valueWei\n', '    );\n', '\n', '    modifier onlyCrowdsaleOwner() {\n', '        require(\n', '            msg.sender == crowdsaleOwner,\n', '            "Failed to call function due to permission denied."\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier inState(States _state) {\n', '        require(\n', '            state == _state,\n', '            "Failed to call function due to crowdsale is not in right state."\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        // Must push higher bonus first.\n', '        bonusTiers.push(\n', '            BonusTier({\n', '                investSize: 400000 * (10**18),\n', '                bonus: 50\n', '            })\n', '        );\n', '        bonusTiers.push(\n', '            BonusTier({\n', '                investSize: 200000 * (10**18),\n', '                bonus: 40\n', '            })\n', '        );\n', '        bonusTiers.push(\n', '            BonusTier({\n', '                investSize: 100000 * (10**18),\n', '                bonus: 30\n', '            })\n', '        );\n', '        bonusTiers.push(\n', '            BonusTier({\n', '                investSize: 50000 * (10**18),\n', '                bonus: 20\n', '            })\n', '        );\n', '    }\n', '\n', '    function setAddress(\n', '        address _token,\n', '        address _crowdsaleOwner,\n', '        address _commissionWallet,\n', '        address _exRate,\n', '        address _kyc\n', '    ) external onlyOwner inState(States.Ready){\n', '        token = ERC20(_token);\n', '        crowdsaleOwner = _crowdsaleOwner;\n', '        commissionWallet = _commissionWallet;\n', '        exRate = CurrencyExchangeRate(_exRate);\n', '        kyc = KYC(_kyc);\n', '    }\n', '\n', '    function setSpecialOffer(\n', '        uint256 _currency,\n', '        uint256 _cap,\n', '        uint256 _goal,\n', '        uint256 _minInvest,\n', '        uint256 _closingTime\n', '    ) external onlyOwner inState(States.Ready) {\n', '        currency = _currency;\n', '        cap = _cap;\n', '        goal = _goal;\n', '        minInvest = _minInvest;\n', '        closingTime = _closingTime;\n', '    }\n', '\n', '    function setInvestRestriction(\n', '        uint256 _countryBlacklist,\n', '        uint8 _kycLevel,\n', '        bool _legalPersonSkipsCountryCheck\n', '    ) external onlyOwner inState(States.Ready) {\n', '        countryBlacklist = _countryBlacklist;\n', '        kycLevel = _kycLevel;\n', '        legalPersonSkipsCountryCheck = _legalPersonSkipsCountryCheck;\n', '    }\n', '\n', '    function setState(uint256 _state) external onlyOwner {\n', '        require(\n', '            uint256(state) < uint256(States.Refunding),\n', '            "Failed to set state due to crowdsale was finalized."\n', '        );\n', '        require(\n', '            // Only allow switch state between Active and Paused.\n', '            uint256(States.Active) == _state || uint256(States.Paused) == _state,\n', '            "Failed to set state due to invalid index."\n', '        );\n', '        emit StateSet(msg.sender, state, States(_state));\n', '        state = States(_state);\n', '    }\n', '\n', '    /**\n', '     * Get bonus in token units.\n', '     * @param _investSize Total investment size in specified currency\n', '     * @param _tokenUnits Token units for the investment (without bonus)\n', '     * @return Bonus in token units\n', '     */\n', '    function _getBonus(uint256 _investSize, uint256 _tokenUnits) \n', '        private view returns (uint256) \n', '    {\n', '        for (uint256 _i = 0; _i < bonusTiers.length; _i++) {\n', '            if (_investSize >= bonusTiers[_i].investSize) {\n', '                return _tokenUnits.mul(bonusTiers[_i].bonus).div(100);\n', '            }\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * Start crowdsale.\n', '     */\n', '    function startCrowdsale()\n', '        external\n', '        onlyCrowdsaleOwner\n', '        inState(States.Ready)\n', '    {\n', '        emit CrowdsaleStarted(msg.sender);\n', '        vault = new EtherVault(msg.sender);\n', '        state = States.Active;\n', '    }\n', '\n', '    /**\n', '     * Buy token.\n', '     */\n', '    function buyToken()\n', '        external\n', '        inState(States.Active)\n', '        payable\n', '    {\n', '        // KYC level = 0 means no KYC can invest.\n', '        // KYC level > 0 means certain level of KYC is required.\n', '        if (kycLevel > 0) {\n', '            require(\n', '                // solium-disable-next-line security/no-block-members\n', '                block.timestamp < kyc.expireOf(msg.sender),\n', '                "Failed to buy token due to KYC was expired."\n', '            );\n', '        }\n', '\n', '        require(\n', '            kycLevel <= kyc.kycLevelOf(msg.sender),\n', '            "Failed to buy token due to require higher KYC level."\n', '        );\n', '\n', '        require(\n', '            countryBlacklist & kyc.nationalitiesOf(msg.sender) == 0 || (\n', '                kyc.kycLevelOf(msg.sender) >= 200 && legalPersonSkipsCountryCheck\n', '            ),\n', '            "Failed to buy token due to country investment restriction."\n', '        );\n', '\n', '        // Get exchange rate of specified currency.\n', '        (uint256 _exRate, uint8 _exRateDecimals) = exRate.currencies(currency);\n', '\n', '        // Convert from Ether to base currency.\n', '        uint256 _investSize = (msg.value)\n', '            .mul(_exRate).div(10**uint256(_exRateDecimals));\n', '\n', '        require(\n', '            _investSize >= minInvest,\n', '            "Failed to buy token due to less than minimum investment."\n', '        );\n', '\n', '        require(\n', '            raised.add(_investSize) <= cap,\n', '            "Failed to buy token due to exceed cap."\n', '        );\n', '\n', '        require(\n', '            // solium-disable-next-line security/no-block-members\n', '            block.timestamp < closingTime,\n', '            "Failed to buy token due to crowdsale is closed."\n', '        );\n', '\n', '        // Update total invested in specified currency.\n', '        invests[msg.sender] = invests[msg.sender].add(_investSize);\n', '        // Update total invested wei.\n', '        deposits[msg.sender] = deposits[msg.sender].add(msg.value);\n', '        // Update total raised in specified currency.    \n', '        raised = raised.add(_investSize);\n', '\n', '        // Log previous token units.\n', '        uint256 _previousTokenUnits = tokenUnits[msg.sender];\n', '\n', '        // Calculate token units by base exchange rate.\n', '        uint256 _tokenUnits = invests[msg.sender]\n', '            .mul(baseExRate)\n', '            .div(10**uint256(baseExRateDecimals));\n', '\n', '        // Calculate bought token units (take bonus into account).\n', '        uint256 _tokenUnitsWithBonus = _tokenUnits.add(\n', '            _getBonus(invests[msg.sender], _tokenUnits));\n', '\n', '        // Update total bought token units.\n', '        tokenUnits[msg.sender] = _tokenUnitsWithBonus;\n', '\n', '        // Update total token units to be issued.\n', '        totalTokenUnits = totalTokenUnits\n', '            .sub(_previousTokenUnits)\n', '            .add(_tokenUnitsWithBonus);\n', '\n', '        emit TokenBought(msg.sender, msg.value, _investSize);\n', '\n', '        // Entrust wei to vault.\n', '        vault.deposit.value(msg.value)();\n', '    }\n', '\n', '    /**\n', '     * Refund token units to wallet address of crowdsale owner.\n', '     */\n', '    function _refundTokens()\n', '        private\n', '        inState(States.Refunding)\n', '    {\n', '        uint256 _value = token.balanceOf(address(this));\n', '        emit TokensRefunded(crowdsaleOwner, _value);\n', '        if (_value > 0) {         \n', '            // Refund all tokens for crowdsale to refund wallet.\n', '            token.transfer(crowdsaleOwner, _value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Finalize this crowdsale.\n', '     */\n', '    function finalize()\n', '        external\n', '        inState(States.Active)        \n', '        onlyCrowdsaleOwner\n', '    {\n', '        require(\n', '            // solium-disable-next-line security/no-block-members                \n', '            earlyClosure || block.timestamp >= closingTime,                   \n', '            "Failed to finalize due to crowdsale is opening."\n', '        );\n', '\n', '        emit Finalized(msg.sender);\n', '\n', '        if (raised >= goal && token.balanceOf(address(this)) >= totalTokenUnits) {\n', '            // Set state to Closed whiling preventing reentry.\n', '            state = States.Closed;\n', '\n', '            // Refund surplus tokens.\n', '            uint256 _balance = token.balanceOf(address(this));\n', '            uint256 _surplus = _balance.sub(totalTokenUnits);\n', '            emit SurplusTokensRefunded(crowdsaleOwner, _surplus);\n', '            if (_surplus > 0) {\n', '                // Refund surplus tokens to refund wallet.\n', '                token.transfer(crowdsaleOwner, _surplus);\n', '            }\n', '            // Close vault, and transfer commission and raised ether.\n', '            vault.close(commissionWallet, commission);\n', '        } else {\n', '            state = States.Refunding;\n', '            _refundTokens();\n', '            vault.enableRefunds();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Stop this crowdsale.\n', '     * Only stop suspecious projects.\n', '     */\n', '    function stopCrowdsale()  \n', '        external\n', '        onlyOwner\n', '        inState(States.Paused)\n', '    {\n', '        emit CrowdsaleStopped(msg.sender);\n', '        state = States.Refunding;\n', '        _refundTokens();\n', '        vault.enableRefunds();\n', '    }\n', '\n', '    /**\n', '     * Investors claim bought token units.\n', '     */\n', '    function claimToken()\n', '        external \n', '        inState(States.Closed)\n', '    {\n', '        require(\n', '            tokenUnits[msg.sender] > 0,\n', '            "Failed to claim token due to token unit is 0."\n', '        );\n', '        uint256 _value = tokenUnits[msg.sender];\n', '        tokenUnits[msg.sender] = 0;\n', '        emit TokenClaimed(msg.sender, _value);\n', '        token.transfer(msg.sender, _value);\n', '    }\n', '\n', '    /**\n', '     * Investors claim invested Ether refunds.\n', '     */\n', '    function claimRefund()\n', '        external\n', '        inState(States.Refunding)\n', '    {\n', '        require(\n', '            deposits[msg.sender] > 0,\n', '            "Failed to claim refund due to deposit is 0."\n', '        );\n', '\n', '        uint256 _value = deposits[msg.sender];\n', '        deposits[msg.sender] = 0;\n', '        emit RefundClaimed(msg.sender, _value);\n', '        vault.refund(msg.sender, _value);\n', '    }\n', '}']
