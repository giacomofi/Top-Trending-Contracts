['pragma solidity 0.4.19;\n', '\n', '\n', 'contract Ownable {\n', '    \n', '    address public owner;\n', '\n', '    /**\n', '     * The address whcih deploys this contrcat is automatically assgined ownership.\n', '     * */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Functions with this modifier can only be executed by the owner of the contract. \n', '     * */\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '\n', '    /**\n', '    * Transfers ownership to new Ethereum address. This function can only be called by the \n', '    * owner.\n', '    * @param _newOwner the address to be granted ownership.\n', '    **/\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != 0x0);\n', '        OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', 'library SafeMath {\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure  returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure  returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract ERC20TransferInterface {\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function balanceOf(address who) constant public returns (uint256);\n', '}\n', '\n', '\n', '\n', 'contract ICO is Ownable {\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    event TokenAddressSet(address indexed tokenAddress);\n', '    event FirstPreIcoActivated(uint256 startTime, uint256 endTime, uint256 bonus);\n', '    event SecondPreIcoActivated(uint256 startTime, uint256 endTime, uint256 bonus);\n', '    event MainIcoActivated(uint256 startTime, uint256 endTime, uint256 bonus);\n', '    event TokenPriceChanged(uint256 newTokenPrice, uint256 newExchangeRate);\n', '    event ExchangeRateChanged(uint256 newExchangeRate, uint256 newTokenPrice);\n', '    event BonuseChanged(uint256 newBonus);\n', '    event OffchainPurchaseMade(address indexed recipient, uint256 tokensPurchased);\n', '    event TokensPurchased(address indexed recipient, uint256 tokensPurchased, uint256 weiSent);\n', '    event UnsoldTokensWithdrawn(uint256 tokensWithdrawn);\n', '    event ICOPaused(uint256 timeOfPause);\n', '    event ICOUnpaused(uint256 timeOfUnpause);\n', '    event IcoDeadlineExtended(State currentState, uint256 newDeadline);\n', '    event IcoDeadlineShortened(State currentState, uint256 newDeadline);\n', '    event IcoTerminated(uint256 terminationTime);\n', '    event AirdropInvoked();\n', '\n', '    uint256 public endTime;\n', '    uint256 private pausedTime;\n', '    bool public IcoPaused;\n', '    uint256 public tokenPrice;\n', '    uint256 public rate;\n', '    uint256 public bonus;\n', '    uint256 public minInvestment;\n', '    ERC20TransferInterface public MSTCOIN;\n', '    address public multiSigWallet;\n', '    uint256 public tokensSold;\n', '\n', '    mapping (address => uint256) public investmentOf;\n', '\n', '    enum State {FIRST_PRE_ICO, SECOND_PRE_ICO, MAIN_ICO, TERMINATED}\n', '    State public icoState;\n', '\n', '    uint256[4] public mainIcoBonusStages;\n', '\n', '    function ICO() public {\n', '        endTime = now.add(7 days);\n', '        pausedTime = 0;\n', '        IcoPaused = false;\n', '        tokenPrice = 89e12; // tokenPrice is rate / 1e18\n', '        rate = 11235;  // rate is 1e18 / tokenPrice\n', '        bonus = 100;\n', '        minInvestment = 1e17;\n', '        multiSigWallet = 0xE1377e465121776d8810007576034c7E0798CD46;\n', '        tokensSold = 0;\n', '        icoState = State.FIRST_PRE_ICO;\n', '        FirstPreIcoActivated(now, endTime, bonus);\n', '    }\n', '\n', '    /**\n', '    * Sets the address of the token. This function can only be executed by the \n', '    * owner of the contract.\n', '    **/\n', '    function setTokenAddress(address _tokenAddress) public onlyOwner {\n', '        require(_tokenAddress != 0x0);\n', '        MSTCOIN = ERC20TransferInterface(_tokenAddress);\n', '        TokenAddressSet(_tokenAddress);\n', '    }\n', '\n', '    /**\n', '    * Returns the address of the token. \n', '    **/\n', '    function getTokenAddress() public view returns(address) {\n', '        return address(MSTCOIN);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to activate the second pre ICO. This function can only be \n', '    * executed once the first pre ICO has finished. \n', '    **/\n', '    function activateSecondPreIco() public onlyOwner {\n', '        require(now >= endTime && icoState == State.FIRST_PRE_ICO);\n', '        icoState = State.SECOND_PRE_ICO;\n', '        endTime = now.add(4 days);\n', '        bonus = 50;\n', '        SecondPreIcoActivated(now, endTime, bonus);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to activate the main public ICO stage. This function can only be \n', '    * executed once the second pre ICO has finished. \n', '    **/\n', '    function activateMainIco() public onlyOwner {\n', '        require(now >= endTime && icoState == State.SECOND_PRE_ICO);\n', '        icoState = State.MAIN_ICO;\n', '        mainIcoBonusStages[0] = now.add(7 days);\n', '        mainIcoBonusStages[1] = now.add(14 days);\n', '        mainIcoBonusStages[2] = now.add(21 days);\n', '        mainIcoBonusStages[3] = now.add(31 days);\n', '        endTime = now.add(31 days);\n', '        bonus = 35;\n', '        MainIcoActivated(now, endTime, bonus);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to change the price of the token. \n', '    *\n', '    * @param _newTokenPrice The new price per token. \n', '    **/\n', '    function changeTokenPrice(uint256 _newTokenPrice) public onlyOwner {\n', '        require(tokenPrice != _newTokenPrice && _newTokenPrice > 0);\n', '        tokenPrice = _newTokenPrice;\n', '        uint256 eth = 1e18;\n', '        rate = eth.div(tokenPrice);\n', '        TokenPriceChanged(tokenPrice, rate);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to change the exchange rate of the token.\n', '    *\n', '    * @param _newRate The new exchange rate\n', '    **/\n', '    function changeRate(uint256 _newRate) public onlyOwner {\n', '        require(rate != _newRate && _newRate > 0);\n', '        rate = _newRate;\n', '        uint256 x = 1e12;\n', '        tokenPrice = x.div(rate);\n', '        ExchangeRateChanged(rate, tokenPrice);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to change the bonus of the current ICO stage. \n', '    *\n', '    * @param _newBonus The new bonus percentage investors will receive.\n', '    **/\n', '    function changeBonus(uint256 _newBonus) public onlyOwner {\n', '        require(bonus != _newBonus && _newBonus > 0);\n', '        bonus = _newBonus;\n', '        BonuseChanged(bonus);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to sell tokens with other forms of payment including fiat and all other\n', '    * cryptos. \n', '    *\n', '    * @param _recipient The address to send tokens to.\n', '    * @param _value The amount of tokens to be sent.\n', '    **/\n', '    function processOffchainTokenPurchase(address _recipient, uint256 _value) public onlyOwner {\n', '        require(MSTCOIN.balanceOf(address(this)) >= _value);\n', '        require(_recipient != 0x0 && _value > 0);\n', '        MSTCOIN.transfer(_recipient, _value);\n', '        tokensSold = tokensSold.add(_value);\n', '        OffchainPurchaseMade(_recipient, _value);\n', '    }\n', '\n', '    /**\n', '    * Fallback function calls the buyTokens function automatically when an investment is made.\n', '    **/\n', '    function() public payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * Allows investors to send their ETH and automatically receive tokens in return.\n', '    *\n', '    * @param _recipient The addrewss which will receive tokens\n', '    **/\n', '    function buyTokens(address _recipient) public payable {\n', '        uint256 msgVal = msg.value.div(1e12); //because token has 6 decimals\n', '        require(MSTCOIN.balanceOf(address(this)) >= msgVal.mul(rate.mul(getBonus()).div(100)).add(rate) ) ;\n', '        require(msg.value >= minInvestment && withinPeriod());\n', '        require(_recipient != 0x0);\n', '        uint256 toTransfer = msgVal.mul(rate.mul(getBonus()).div(100).add(rate));\n', '        MSTCOIN.transfer(_recipient, toTransfer);\n', '        tokensSold = tokensSold.add(toTransfer);\n', '        investmentOf[msg.sender] = investmentOf[msg.sender].add(msg.value);\n', '        TokensPurchased(_recipient, toTransfer, msg.value);\n', '        forwardFunds();\n', '    }\n', '\n', '    /**\n', '    * This function is internally called by the buyTokens function to automatically forward\n', '    * all investments made to the multi signature wallet. \n', '    **/\n', '    function forwardFunds() internal {\n', '        multiSigWallet.transfer(msg.value);\n', '    }\n', '\n', '    /**\n', '    * This function is internally called by the buyTokens function to ensure that investments\n', '    * are made during times when the ICO is not paused and when the duration of the current \n', '    * phase has not finished.\n', '    **/\n', '    function withinPeriod() internal view returns(bool) {\n', '        return IcoPaused == false && now < endTime && icoState != State.TERMINATED;\n', '    }\n', '\n', '    /**\n', '    * Calculates and returns the bonus of the current ICO stage. During the main public ICO, the\n', '    * first ICO the bonus stages are set as such:\n', '    *\n', '    * week 1: bonus = 35%\n', '    * week 2: bonus = 25%\n', '    * week 3: bonus = 15%\n', '    * week 4: bonus = 5%\n', '    **/\n', '    function getBonus() public view returns(uint256 _bonus) {\n', '        _bonus = bonus;\n', '        if(icoState == State.MAIN_ICO) {\n', '            if(now > mainIcoBonusStages[3]) {\n', '                _bonus = 0;\n', '            } else {\n', '                uint256 timeStamp = now;\n', '                for(uint i = 0; i < mainIcoBonusStages.length; i++) {\n', '                    if(timeStamp <= mainIcoBonusStages[i]) {\n', '                        break;\n', '                    } else {\n', '                        if(_bonus >= 15) {\n', '                            _bonus = _bonus.sub(10);\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        return _bonus;\n', '    }\n', '\n', '    /**\n', '    * Allows the owner of the contract to withdraw all unsold tokens. This function can \n', '    * only be executed once the ICO contract has been terminated after the main public \n', '    * ICO has finished. \n', '    *\n', '    * @param _recipient The address to withdraw all unsold tokens to. If this field is \n', '    * left empty, then the tokens will just be sent to the owner of the contract. \n', '    **/\n', '    function withdrawUnsoldTokens(address _recipient) public onlyOwner {\n', '        require(icoState == State.TERMINATED);\n', '        require(now >= endTime && MSTCOIN.balanceOf(address(this)) > 0);\n', '        if(_recipient == 0x0) { \n', '            _recipient = owner; \n', '        }\n', '        UnsoldTokensWithdrawn(MSTCOIN.balanceOf(address(this)));\n', '        MSTCOIN.transfer(_recipient, MSTCOIN.balanceOf(address(this)));\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to pause the ICO contract. While the ICO is paused investments cannot\n', '    * be made. \n', '    **/\n', '    function pauseICO() public onlyOwner {\n', '        require(!IcoPaused);\n', '        IcoPaused = true;\n', '        pausedTime = now;\n', '        ICOPaused(now);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to unpause the ICO only when the ICO contract has been paused. Once\n', '    * invoked, the deadline will automatically be extended by the duration the ICO was \n', '    * paused for. \n', '    **/\n', '    function unpauseICO() public onlyOwner {\n', '        require(IcoPaused);\n', '        IcoPaused = false;\n', '        endTime = endTime.add(now.sub(pausedTime));\n', '        ICOUnpaused(now);\n', '    }\n', '\n', '\n', '    /**\n', '    * Allows the owner of the ICO to extend the deadline of the current ICO stage. This\n', '    * function can only be executed if the ICO contract has not been terminated. \n', '    *\n', '    * @param _days The number of days to increase the duration of the ICO by. \n', '    **/\n', '    function extendDeadline(uint256 _days) public onlyOwner {\n', '        require(icoState != State.TERMINATED);\n', '        endTime = endTime.add(_days.mul(1 days));\n', '        if(icoState == State.MAIN_ICO) {\n', '            uint256 blocks = 0;\n', '            uint256 stage = 0;\n', '            for(uint i = 0; i < mainIcoBonusStages.length; i++) {\n', '                if(now < mainIcoBonusStages[i]) {\n', '                    stage = i;\n', '                }\n', '            }\n', '            blocks = (_days.mul(1 days)).div(mainIcoBonusStages.length.sub(stage));\n', '            for(uint x = stage; x < mainIcoBonusStages.length; x++) {\n', '                mainIcoBonusStages[x] = mainIcoBonusStages[x].add(blocks);\n', '            }\n', '        }\n', '        IcoDeadlineExtended(icoState, endTime);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner of the contract to shorten the deadline of the current ICO stage.\n', '    *\n', '    * @param _days The number of days to reduce the druation of the ICO by. \n', '    **/\n', '    function shortenDeadline(uint256 _days) public onlyOwner {\n', '        if(now.add(_days.mul(1 days)) >= endTime) {\n', '            revert();\n', '        } else {\n', '            endTime = endTime.sub(_days.mul(1 days));\n', '            if(icoState == State.MAIN_ICO) {\n', '                uint256 blocks = 0;\n', '                uint256 stage = 0;\n', '                for(uint i = 0; i < mainIcoBonusStages.length; i++) {\n', '                    if(now < mainIcoBonusStages[i]) {\n', '                        stage = i;\n', '                    }\n', '                }\n', '                blocks = (_days.mul(1 days)).div(mainIcoBonusStages.length.sub(stage));\n', '                for(uint x = stage; x < mainIcoBonusStages.length; x++) {\n', '                    mainIcoBonusStages[x] = mainIcoBonusStages[x].sub(blocks);\n', '                }\n', '            }\n', '        }\n', '        IcoDeadlineShortened(icoState, endTime);\n', '    }\n', '\n', '    /**\n', '    * Terminates the ICO early permanently. This function can only be called by the\n', '    * owner of the contract during the main public ICO. \n', '    **/\n', '    function terminateIco() public onlyOwner {\n', '        require(icoState == State.MAIN_ICO);\n', '        require(now < endTime);\n', '        endTime = now;\n', '        icoState = State.TERMINATED;\n', '        IcoTerminated(now);\n', '    }\n', '\n', '    /**\n', '    * Returns the amount of tokens that have been sold.\n', '    **/\n', '    function getTokensSold() public view returns(uint256) {\n', '        return tokensSold;\n', '    }\n', '\n', '    /**\n', '    * Airdrops tokens to up to 100 ETH addresses. \n', '    *\n', '    * @param _addrs The list of addresses to send tokens to\n', '    * @param _values The list of amounts of tokens to send to each corresponding address.\n', '    **/\n', '    function airdrop(address[] _addrs, uint256[] _values) public onlyOwner returns(bool) {\n', '        require(_addrs.length == _values.length && _addrs.length <= 100);\n', '        require(MSTCOIN.balanceOf(address(this)) >= getSumOfValues(_values));\n', '        for (uint i = 0; i < _addrs.length; i++) {\n', '            if (_addrs[i] != 0x0 && _values[i] > 0) {\n', '                MSTCOIN.transfer(_addrs[i], _values[i]);\n', '            }\n', '        }\n', '        AirdropInvoked();\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Called internally by the airdrop function to ensure the contract holds enough tokens\n', '    * to succesfully execute the airdrop.\n', '    *\n', '    * @param _values The list of values representing the amount of tokens which will be airdroped.\n', '    **/\n', '    function getSumOfValues(uint256[] _values) internal pure returns(uint256) {\n', '        uint256 sum = 0;\n', '        for(uint i=0; i < _values.length; i++) {\n', '            sum = sum.add(_values[i]);\n', '        }\n', '        return sum;\n', '    } \n', '}']
['pragma solidity 0.4.19;\n', '\n', '\n', 'contract Ownable {\n', '    \n', '    address public owner;\n', '\n', '    /**\n', '     * The address whcih deploys this contrcat is automatically assgined ownership.\n', '     * */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Functions with this modifier can only be executed by the owner of the contract. \n', '     * */\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '\n', '    /**\n', '    * Transfers ownership to new Ethereum address. This function can only be called by the \n', '    * owner.\n', '    * @param _newOwner the address to be granted ownership.\n', '    **/\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != 0x0);\n', '        OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', 'library SafeMath {\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure  returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure  returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract ERC20TransferInterface {\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function balanceOf(address who) constant public returns (uint256);\n', '}\n', '\n', '\n', '\n', 'contract ICO is Ownable {\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    event TokenAddressSet(address indexed tokenAddress);\n', '    event FirstPreIcoActivated(uint256 startTime, uint256 endTime, uint256 bonus);\n', '    event SecondPreIcoActivated(uint256 startTime, uint256 endTime, uint256 bonus);\n', '    event MainIcoActivated(uint256 startTime, uint256 endTime, uint256 bonus);\n', '    event TokenPriceChanged(uint256 newTokenPrice, uint256 newExchangeRate);\n', '    event ExchangeRateChanged(uint256 newExchangeRate, uint256 newTokenPrice);\n', '    event BonuseChanged(uint256 newBonus);\n', '    event OffchainPurchaseMade(address indexed recipient, uint256 tokensPurchased);\n', '    event TokensPurchased(address indexed recipient, uint256 tokensPurchased, uint256 weiSent);\n', '    event UnsoldTokensWithdrawn(uint256 tokensWithdrawn);\n', '    event ICOPaused(uint256 timeOfPause);\n', '    event ICOUnpaused(uint256 timeOfUnpause);\n', '    event IcoDeadlineExtended(State currentState, uint256 newDeadline);\n', '    event IcoDeadlineShortened(State currentState, uint256 newDeadline);\n', '    event IcoTerminated(uint256 terminationTime);\n', '    event AirdropInvoked();\n', '\n', '    uint256 public endTime;\n', '    uint256 private pausedTime;\n', '    bool public IcoPaused;\n', '    uint256 public tokenPrice;\n', '    uint256 public rate;\n', '    uint256 public bonus;\n', '    uint256 public minInvestment;\n', '    ERC20TransferInterface public MSTCOIN;\n', '    address public multiSigWallet;\n', '    uint256 public tokensSold;\n', '\n', '    mapping (address => uint256) public investmentOf;\n', '\n', '    enum State {FIRST_PRE_ICO, SECOND_PRE_ICO, MAIN_ICO, TERMINATED}\n', '    State public icoState;\n', '\n', '    uint256[4] public mainIcoBonusStages;\n', '\n', '    function ICO() public {\n', '        endTime = now.add(7 days);\n', '        pausedTime = 0;\n', '        IcoPaused = false;\n', '        tokenPrice = 89e12; // tokenPrice is rate / 1e18\n', '        rate = 11235;  // rate is 1e18 / tokenPrice\n', '        bonus = 100;\n', '        minInvestment = 1e17;\n', '        multiSigWallet = 0xE1377e465121776d8810007576034c7E0798CD46;\n', '        tokensSold = 0;\n', '        icoState = State.FIRST_PRE_ICO;\n', '        FirstPreIcoActivated(now, endTime, bonus);\n', '    }\n', '\n', '    /**\n', '    * Sets the address of the token. This function can only be executed by the \n', '    * owner of the contract.\n', '    **/\n', '    function setTokenAddress(address _tokenAddress) public onlyOwner {\n', '        require(_tokenAddress != 0x0);\n', '        MSTCOIN = ERC20TransferInterface(_tokenAddress);\n', '        TokenAddressSet(_tokenAddress);\n', '    }\n', '\n', '    /**\n', '    * Returns the address of the token. \n', '    **/\n', '    function getTokenAddress() public view returns(address) {\n', '        return address(MSTCOIN);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to activate the second pre ICO. This function can only be \n', '    * executed once the first pre ICO has finished. \n', '    **/\n', '    function activateSecondPreIco() public onlyOwner {\n', '        require(now >= endTime && icoState == State.FIRST_PRE_ICO);\n', '        icoState = State.SECOND_PRE_ICO;\n', '        endTime = now.add(4 days);\n', '        bonus = 50;\n', '        SecondPreIcoActivated(now, endTime, bonus);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to activate the main public ICO stage. This function can only be \n', '    * executed once the second pre ICO has finished. \n', '    **/\n', '    function activateMainIco() public onlyOwner {\n', '        require(now >= endTime && icoState == State.SECOND_PRE_ICO);\n', '        icoState = State.MAIN_ICO;\n', '        mainIcoBonusStages[0] = now.add(7 days);\n', '        mainIcoBonusStages[1] = now.add(14 days);\n', '        mainIcoBonusStages[2] = now.add(21 days);\n', '        mainIcoBonusStages[3] = now.add(31 days);\n', '        endTime = now.add(31 days);\n', '        bonus = 35;\n', '        MainIcoActivated(now, endTime, bonus);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to change the price of the token. \n', '    *\n', '    * @param _newTokenPrice The new price per token. \n', '    **/\n', '    function changeTokenPrice(uint256 _newTokenPrice) public onlyOwner {\n', '        require(tokenPrice != _newTokenPrice && _newTokenPrice > 0);\n', '        tokenPrice = _newTokenPrice;\n', '        uint256 eth = 1e18;\n', '        rate = eth.div(tokenPrice);\n', '        TokenPriceChanged(tokenPrice, rate);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to change the exchange rate of the token.\n', '    *\n', '    * @param _newRate The new exchange rate\n', '    **/\n', '    function changeRate(uint256 _newRate) public onlyOwner {\n', '        require(rate != _newRate && _newRate > 0);\n', '        rate = _newRate;\n', '        uint256 x = 1e12;\n', '        tokenPrice = x.div(rate);\n', '        ExchangeRateChanged(rate, tokenPrice);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to change the bonus of the current ICO stage. \n', '    *\n', '    * @param _newBonus The new bonus percentage investors will receive.\n', '    **/\n', '    function changeBonus(uint256 _newBonus) public onlyOwner {\n', '        require(bonus != _newBonus && _newBonus > 0);\n', '        bonus = _newBonus;\n', '        BonuseChanged(bonus);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to sell tokens with other forms of payment including fiat and all other\n', '    * cryptos. \n', '    *\n', '    * @param _recipient The address to send tokens to.\n', '    * @param _value The amount of tokens to be sent.\n', '    **/\n', '    function processOffchainTokenPurchase(address _recipient, uint256 _value) public onlyOwner {\n', '        require(MSTCOIN.balanceOf(address(this)) >= _value);\n', '        require(_recipient != 0x0 && _value > 0);\n', '        MSTCOIN.transfer(_recipient, _value);\n', '        tokensSold = tokensSold.add(_value);\n', '        OffchainPurchaseMade(_recipient, _value);\n', '    }\n', '\n', '    /**\n', '    * Fallback function calls the buyTokens function automatically when an investment is made.\n', '    **/\n', '    function() public payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * Allows investors to send their ETH and automatically receive tokens in return.\n', '    *\n', '    * @param _recipient The addrewss which will receive tokens\n', '    **/\n', '    function buyTokens(address _recipient) public payable {\n', '        uint256 msgVal = msg.value.div(1e12); //because token has 6 decimals\n', '        require(MSTCOIN.balanceOf(address(this)) >= msgVal.mul(rate.mul(getBonus()).div(100)).add(rate) ) ;\n', '        require(msg.value >= minInvestment && withinPeriod());\n', '        require(_recipient != 0x0);\n', '        uint256 toTransfer = msgVal.mul(rate.mul(getBonus()).div(100).add(rate));\n', '        MSTCOIN.transfer(_recipient, toTransfer);\n', '        tokensSold = tokensSold.add(toTransfer);\n', '        investmentOf[msg.sender] = investmentOf[msg.sender].add(msg.value);\n', '        TokensPurchased(_recipient, toTransfer, msg.value);\n', '        forwardFunds();\n', '    }\n', '\n', '    /**\n', '    * This function is internally called by the buyTokens function to automatically forward\n', '    * all investments made to the multi signature wallet. \n', '    **/\n', '    function forwardFunds() internal {\n', '        multiSigWallet.transfer(msg.value);\n', '    }\n', '\n', '    /**\n', '    * This function is internally called by the buyTokens function to ensure that investments\n', '    * are made during times when the ICO is not paused and when the duration of the current \n', '    * phase has not finished.\n', '    **/\n', '    function withinPeriod() internal view returns(bool) {\n', '        return IcoPaused == false && now < endTime && icoState != State.TERMINATED;\n', '    }\n', '\n', '    /**\n', '    * Calculates and returns the bonus of the current ICO stage. During the main public ICO, the\n', '    * first ICO the bonus stages are set as such:\n', '    *\n', '    * week 1: bonus = 35%\n', '    * week 2: bonus = 25%\n', '    * week 3: bonus = 15%\n', '    * week 4: bonus = 5%\n', '    **/\n', '    function getBonus() public view returns(uint256 _bonus) {\n', '        _bonus = bonus;\n', '        if(icoState == State.MAIN_ICO) {\n', '            if(now > mainIcoBonusStages[3]) {\n', '                _bonus = 0;\n', '            } else {\n', '                uint256 timeStamp = now;\n', '                for(uint i = 0; i < mainIcoBonusStages.length; i++) {\n', '                    if(timeStamp <= mainIcoBonusStages[i]) {\n', '                        break;\n', '                    } else {\n', '                        if(_bonus >= 15) {\n', '                            _bonus = _bonus.sub(10);\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        return _bonus;\n', '    }\n', '\n', '    /**\n', '    * Allows the owner of the contract to withdraw all unsold tokens. This function can \n', '    * only be executed once the ICO contract has been terminated after the main public \n', '    * ICO has finished. \n', '    *\n', '    * @param _recipient The address to withdraw all unsold tokens to. If this field is \n', '    * left empty, then the tokens will just be sent to the owner of the contract. \n', '    **/\n', '    function withdrawUnsoldTokens(address _recipient) public onlyOwner {\n', '        require(icoState == State.TERMINATED);\n', '        require(now >= endTime && MSTCOIN.balanceOf(address(this)) > 0);\n', '        if(_recipient == 0x0) { \n', '            _recipient = owner; \n', '        }\n', '        UnsoldTokensWithdrawn(MSTCOIN.balanceOf(address(this)));\n', '        MSTCOIN.transfer(_recipient, MSTCOIN.balanceOf(address(this)));\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to pause the ICO contract. While the ICO is paused investments cannot\n', '    * be made. \n', '    **/\n', '    function pauseICO() public onlyOwner {\n', '        require(!IcoPaused);\n', '        IcoPaused = true;\n', '        pausedTime = now;\n', '        ICOPaused(now);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner to unpause the ICO only when the ICO contract has been paused. Once\n', '    * invoked, the deadline will automatically be extended by the duration the ICO was \n', '    * paused for. \n', '    **/\n', '    function unpauseICO() public onlyOwner {\n', '        require(IcoPaused);\n', '        IcoPaused = false;\n', '        endTime = endTime.add(now.sub(pausedTime));\n', '        ICOUnpaused(now);\n', '    }\n', '\n', '\n', '    /**\n', '    * Allows the owner of the ICO to extend the deadline of the current ICO stage. This\n', '    * function can only be executed if the ICO contract has not been terminated. \n', '    *\n', '    * @param _days The number of days to increase the duration of the ICO by. \n', '    **/\n', '    function extendDeadline(uint256 _days) public onlyOwner {\n', '        require(icoState != State.TERMINATED);\n', '        endTime = endTime.add(_days.mul(1 days));\n', '        if(icoState == State.MAIN_ICO) {\n', '            uint256 blocks = 0;\n', '            uint256 stage = 0;\n', '            for(uint i = 0; i < mainIcoBonusStages.length; i++) {\n', '                if(now < mainIcoBonusStages[i]) {\n', '                    stage = i;\n', '                }\n', '            }\n', '            blocks = (_days.mul(1 days)).div(mainIcoBonusStages.length.sub(stage));\n', '            for(uint x = stage; x < mainIcoBonusStages.length; x++) {\n', '                mainIcoBonusStages[x] = mainIcoBonusStages[x].add(blocks);\n', '            }\n', '        }\n', '        IcoDeadlineExtended(icoState, endTime);\n', '    }\n', '\n', '    /**\n', '    * Allows the owner of the contract to shorten the deadline of the current ICO stage.\n', '    *\n', '    * @param _days The number of days to reduce the druation of the ICO by. \n', '    **/\n', '    function shortenDeadline(uint256 _days) public onlyOwner {\n', '        if(now.add(_days.mul(1 days)) >= endTime) {\n', '            revert();\n', '        } else {\n', '            endTime = endTime.sub(_days.mul(1 days));\n', '            if(icoState == State.MAIN_ICO) {\n', '                uint256 blocks = 0;\n', '                uint256 stage = 0;\n', '                for(uint i = 0; i < mainIcoBonusStages.length; i++) {\n', '                    if(now < mainIcoBonusStages[i]) {\n', '                        stage = i;\n', '                    }\n', '                }\n', '                blocks = (_days.mul(1 days)).div(mainIcoBonusStages.length.sub(stage));\n', '                for(uint x = stage; x < mainIcoBonusStages.length; x++) {\n', '                    mainIcoBonusStages[x] = mainIcoBonusStages[x].sub(blocks);\n', '                }\n', '            }\n', '        }\n', '        IcoDeadlineShortened(icoState, endTime);\n', '    }\n', '\n', '    /**\n', '    * Terminates the ICO early permanently. This function can only be called by the\n', '    * owner of the contract during the main public ICO. \n', '    **/\n', '    function terminateIco() public onlyOwner {\n', '        require(icoState == State.MAIN_ICO);\n', '        require(now < endTime);\n', '        endTime = now;\n', '        icoState = State.TERMINATED;\n', '        IcoTerminated(now);\n', '    }\n', '\n', '    /**\n', '    * Returns the amount of tokens that have been sold.\n', '    **/\n', '    function getTokensSold() public view returns(uint256) {\n', '        return tokensSold;\n', '    }\n', '\n', '    /**\n', '    * Airdrops tokens to up to 100 ETH addresses. \n', '    *\n', '    * @param _addrs The list of addresses to send tokens to\n', '    * @param _values The list of amounts of tokens to send to each corresponding address.\n', '    **/\n', '    function airdrop(address[] _addrs, uint256[] _values) public onlyOwner returns(bool) {\n', '        require(_addrs.length == _values.length && _addrs.length <= 100);\n', '        require(MSTCOIN.balanceOf(address(this)) >= getSumOfValues(_values));\n', '        for (uint i = 0; i < _addrs.length; i++) {\n', '            if (_addrs[i] != 0x0 && _values[i] > 0) {\n', '                MSTCOIN.transfer(_addrs[i], _values[i]);\n', '            }\n', '        }\n', '        AirdropInvoked();\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Called internally by the airdrop function to ensure the contract holds enough tokens\n', '    * to succesfully execute the airdrop.\n', '    *\n', '    * @param _values The list of values representing the amount of tokens which will be airdroped.\n', '    **/\n', '    function getSumOfValues(uint256[] _values) internal pure returns(uint256) {\n', '        uint256 sum = 0;\n', '        for(uint i=0; i < _values.length; i++) {\n', '            sum = sum.add(_values[i]);\n', '        }\n', '        return sum;\n', '    } \n', '}']
