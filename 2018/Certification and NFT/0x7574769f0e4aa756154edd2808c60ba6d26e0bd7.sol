['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract MultiOwnable {\n', '\n', '    mapping(address => bool) public isOwner;\n', '    address[] public ownerHistory;\n', '    uint8 public ownerCount;\n', '\n', '    event OwnerAddedEvent(address indexed _newOwner);\n', '    event OwnerRemovedEvent(address indexed _oldOwner);\n', '\n', '    function MultiOwnable() public {\n', '        // Add default owner\n', '        address owner = msg.sender;\n', '        ownerHistory.push(owner);\n', '        isOwner[owner] = true;\n', '        ownerCount++;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function ownerHistoryCount() public view returns (uint) {\n', '        return ownerHistory.length;\n', '    }\n', '\n', '    /** Add extra owner. */\n', '    function addOwner(address owner) onlyOwner public {\n', '        require(owner != address(0));\n', '        require(!isOwner[owner]);\n', '        ownerHistory.push(owner);\n', '        isOwner[owner] = true;\n', '        ownerCount++;\n', '        OwnerAddedEvent(owner);\n', '    }\n', '\n', '    /** Remove extra owner. */\n', '    function removeOwner(address owner) onlyOwner public {\n', '\n', '        // This check is neccessary to prevent a situation where all owners \n', '        // are accidentally removed, because we do not want an ownable contract \n', '        // to become an orphan.\n', '        require(ownerCount > 1);\n', '\n', '        require(isOwner[owner]);\n', '        isOwner[owner] = false;\n', '        ownerCount--;\n', '        OwnerRemovedEvent(owner);\n', '    }\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '\n', '    bool public paused;\n', '\n', '    modifier ifNotPaused {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier ifPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    // Called by the owner on emergency, triggers paused state\n', '    function pause() external onlyOwner ifNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    // Called by the owner on end of emergency, returns to normal state\n', '    function resume() external onlyOwner ifPaused {\n', '        paused = false;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract StandardToken is ERC20 {\n', '\n', '    using SafeMath for uint;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Returns number of allowed tokens for given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract CommonToken is StandardToken, MultiOwnable {\n', '\n', '    string public constant name = &#39;White Rabbit Token&#39;;\n', '    string public constant symbol = &#39;WRT&#39;;\n', '    uint8 public constant decimals = 18;\n', '\n', '    // The main account that holds all tokens from the time token created and during all tokensales.\n', '    address public seller;\n', '\n', '    // saleLimit (e18) Maximum amount of tokens for sale across all tokensales.\n', '    // Reserved tokens formula: 16% Team + 6% Partners + 5% Advisory Board + 15% WR reserve 1 = 42%\n', '    // For sale formula: 40% for sale + 1.5% Bounty + 16.5% WR reserve 2 = 58%\n', '    uint256 public constant saleLimit = 110200000 ether;\n', '\n', '    // Next fields are for stats:\n', '    uint256 public tokensSold; // (e18) Number of tokens sold through all tiers or tokensales.\n', '    uint256 public totalSales; // Total number of sales (including external sales) made through all tiers or tokensales.\n', '\n', '    // Lock the transfer functions during tokensales to prevent price speculations.\n', '    bool public locked = true;\n', '\n', '    event SellEvent(address indexed _seller, address indexed _buyer, uint256 _value);\n', '    event ChangeSellerEvent(address indexed _oldSeller, address indexed _newSeller);\n', '    event Burn(address indexed _burner, uint256 _value);\n', '    event Unlock();\n', '\n', '    function CommonToken(\n', '        address _seller\n', '    ) MultiOwnable() public {\n', '\n', '        require(_seller != 0);\n', '        seller = _seller;\n', '\n', '        totalSupply = 190000000 ether;\n', '        balances[seller] = totalSupply;\n', '        Transfer(0x0, seller, totalSupply);\n', '    }\n', '\n', '    modifier ifUnlocked() {\n', '        require(isOwner[msg.sender] || !locked);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * An address can become a new seller only in case it has no tokens.\n', '     * This is required to prevent stealing of tokens  from newSeller via \n', '     * 2 calls of this function.\n', '     */\n', '    function changeSeller(address newSeller) onlyOwner public returns (bool) {\n', '        require(newSeller != address(0));\n', '        require(seller != newSeller);\n', '\n', '        // To prevent stealing of tokens from newSeller via 2 calls of changeSeller:\n', '        require(balances[newSeller] == 0);\n', '\n', '        address oldSeller = seller;\n', '        uint256 unsoldTokens = balances[oldSeller];\n', '        balances[oldSeller] = 0;\n', '        balances[newSeller] = unsoldTokens;\n', '        Transfer(oldSeller, newSeller, unsoldTokens);\n', '\n', '        seller = newSeller;\n', '        ChangeSellerEvent(oldSeller, newSeller);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * User-friendly alternative to sell() function.\n', '     */\n', '    function sellNoDecimals(address _to, uint256 _value) public returns (bool) {\n', '        return sell(_to, _value * 1e18);\n', '    }\n', '\n', '    function sell(address _to, uint256 _value) onlyOwner public returns (bool) {\n', '\n', '        // Check that we are not out of limit and still can sell tokens:\n', '        if (saleLimit > 0) require(tokensSold.add(_value) <= saleLimit);\n', '\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '        require(_value <= balances[seller]);\n', '\n', '        balances[seller] = balances[seller].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(seller, _to, _value);\n', '\n', '        totalSales++;\n', '        tokensSold = tokensSold.add(_value);\n', '        SellEvent(seller, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) ifUnlocked public returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) ifUnlocked public returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool) {\n', '        require(_value > 0);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Transfer(msg.sender, 0x0, _value);\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    /** Can be called once by super owner. */\n', '    function unlock() onlyOwner public {\n', '        require(locked);\n', '        locked = false;\n', '        Unlock();\n', '    }\n', '}\n', '\n', 'contract CommonWhitelist is MultiOwnable {\n', '\n', '    mapping(address => bool) public isAllowed;\n', '\n', '    // Historical array of wallet that have bben added to whitelist,\n', '    // even if some addresses have been removed later such wallet still remaining\n', '    // in the history. This is Solidity optimization for work with large arrays.\n', '    address[] public history;\n', '\n', '    event AddedEvent(address indexed wallet);\n', '    event RemovedEvent(address indexed wallet);\n', '\n', '    function CommonWhitelist() MultiOwnable() public {}\n', '\n', '    function historyCount() public view returns (uint) {\n', '        return history.length;\n', '    }\n', '\n', '    function add(address _wallet) internal {\n', '        require(_wallet != address(0));\n', '        require(!isAllowed[_wallet]);\n', '\n', '        history.push(_wallet);\n', '        isAllowed[_wallet] = true;\n', '        AddedEvent(_wallet);\n', '    }\n', '\n', '    function addMany(address[] _wallets) public onlyOwner {\n', '        for (uint i = 0; i < _wallets.length; i++) {\n', '            add(_wallets[i]);\n', '        }\n', '    }\n', '\n', '    function remove(address _wallet) internal {\n', '        require(isAllowed[_wallet]);\n', '\n', '        isAllowed[_wallet] = false;\n', '        RemovedEvent(_wallet);\n', '    }\n', '\n', '    function removeMany(address[] _wallets) public onlyOwner {\n', '        for (uint i = 0; i < _wallets.length; i++) {\n', '            remove(_wallets[i]);\n', '        }\n', '    }\n', '}\n', '\n', '//---------------------------------------------------------------\n', '// Wings contracts: Start\n', '// DO NOT CHANGE the next contracts. They were copied from Wings \n', '// and left unformated.\n', '\n', 'contract HasManager {\n', '    address public manager;\n', '\n', '    modifier onlyManager {\n', '        require(msg.sender == manager);\n', '        _;\n', '    }\n', '\n', '    function transferManager(address _newManager) public onlyManager() {\n', '        require(_newManager != address(0));\n', '        manager = _newManager;\n', '    }\n', '}\n', '\n', '// Crowdsale contracts interface\n', 'contract ICrowdsaleProcessor is Ownable, HasManager {\n', '    modifier whenCrowdsaleAlive() {\n', '        require(isActive());\n', '        _;\n', '    }\n', '\n', '    modifier whenCrowdsaleFailed() {\n', '        require(isFailed());\n', '        _;\n', '    }\n', '\n', '    modifier whenCrowdsaleSuccessful() {\n', '        require(isSuccessful());\n', '        _;\n', '    }\n', '\n', '    modifier hasntStopped() {\n', '        require(!stopped);\n', '        _;\n', '    }\n', '\n', '    modifier hasBeenStopped() {\n', '        require(stopped);\n', '        _;\n', '    }\n', '\n', '    modifier hasntStarted() {\n', '        require(!started);\n', '        _;\n', '    }\n', '\n', '    modifier hasBeenStarted() {\n', '        require(started);\n', '        _;\n', '    }\n', '\n', '    // Minimal acceptable hard cap\n', '    uint256 constant public MIN_HARD_CAP = 1 ether;\n', '\n', '    // Minimal acceptable duration of crowdsale\n', '    uint256 constant public MIN_CROWDSALE_TIME = 3 days;\n', '\n', '    // Maximal acceptable duration of crowdsale\n', '    uint256 constant public MAX_CROWDSALE_TIME = 50 days;\n', '\n', '    // Becomes true when timeframe is assigned\n', '    bool public started;\n', '\n', '    // Becomes true if cancelled by owner\n', '    bool public stopped;\n', '\n', '    // Total collected Ethereum: must be updated every time tokens has been sold\n', '    uint256 public totalCollected;\n', '\n', '    // Total amount of project&#39;s token sold: must be updated every time tokens has been sold\n', '    uint256 public totalSold;\n', '\n', '    // Crowdsale minimal goal, must be greater or equal to Forecasting min amount\n', '    uint256 public minimalGoal;\n', '\n', '    // Crowdsale hard cap, must be less or equal to Forecasting max amount\n', '    uint256 public hardCap;\n', '\n', '    // Crowdsale duration in seconds.\n', '    // Accepted range is MIN_CROWDSALE_TIME..MAX_CROWDSALE_TIME.\n', '    uint256 public duration;\n', '\n', '    // Start timestamp of crowdsale, absolute UTC time\n', '    uint256 public startTimestamp;\n', '\n', '    // End timestamp of crowdsale, absolute UTC time\n', '    uint256 public endTimestamp;\n', '\n', '    // Allows to transfer some ETH into the contract without selling tokens\n', '    function deposit() public payable {}\n', '\n', '    // Returns address of crowdsale token, must be ERC20 compilant\n', '    function getToken() public returns (address);\n', '\n', '    // Transfers ETH rewards amount (if ETH rewards is configured) to Forecasting contract\n', '    function mintETHRewards(address _contract, uint256 _amount) public onlyManager();\n', '\n', '    // Mints token Rewards to Forecasting contract\n', '    function mintTokenRewards(address _contract, uint256 _amount) public onlyManager();\n', '\n', '    // Releases tokens (transfers crowdsale token from mintable to transferrable state)\n', '    function releaseTokens() public onlyManager() hasntStopped() whenCrowdsaleSuccessful();\n', '\n', '    // Stops crowdsale. Called by CrowdsaleController, the latter is called by owner.\n', '    // Crowdsale may be stopped any time before it finishes.\n', '    function stop() public onlyManager() hasntStopped();\n', '\n', '    // Validates parameters and starts crowdsale\n', '    function start(uint256 _startTimestamp, uint256 _endTimestamp, address _fundingAddress)\n', '    public onlyManager() hasntStarted() hasntStopped();\n', '\n', '    // Is crowdsale failed (completed, but minimal goal wasn&#39;t reached)\n', '    function isFailed() public constant returns (bool);\n', '\n', '    // Is crowdsale active (i.e. the token can be sold)\n', '    function isActive() public constant returns (bool);\n', '\n', '    // Is crowdsale completed successfully\n', '    function isSuccessful() public constant returns (bool);\n', '}\n', '\n', '// Basic crowdsale implementation both for regualt and 3rdparty Crowdsale contracts\n', 'contract BasicCrowdsale is ICrowdsaleProcessor {\n', '    event CROWDSALE_START(uint256 startTimestamp, uint256 endTimestamp, address fundingAddress);\n', '\n', '    // Where to transfer collected ETH\n', '    address public fundingAddress;\n', '\n', '    // Ctor.\n', '    function BasicCrowdsale(\n', '        address _owner,\n', '        address _manager\n', '    )\n', '    public\n', '    {\n', '        owner = _owner;\n', '        manager = _manager;\n', '    }\n', '\n', '    // called by CrowdsaleController to transfer reward part of ETH\n', '    // collected by successful crowdsale to Forecasting contract.\n', '    // This call is made upon closing successful crowdfunding process\n', '    // iff agreed ETH reward part is not zero\n', '    function mintETHRewards(\n', '        address _contract, // Forecasting contract\n', '        uint256 _amount     // agreed part of totalCollected which is intended for rewards\n', '    )\n', '    public\n', '    onlyManager() // manager is CrowdsaleController instance\n', '    {\n', '        require(_contract.call.value(_amount)());\n', '    }\n', '\n', '    // cancels crowdsale\n', '    function stop() public onlyManager() hasntStopped() {\n', '        // we can stop only not started and not completed crowdsale\n', '        if (started) {\n', '            require(!isFailed());\n', '            require(!isSuccessful());\n', '        }\n', '        stopped = true;\n', '    }\n', '\n', '    // called by CrowdsaleController to setup start and end time of crowdfunding process\n', '    // as well as funding address (where to transfer ETH upon successful crowdsale)\n', '    function start(\n', '        uint256 _startTimestamp,\n', '        uint256 _endTimestamp,\n', '        address _fundingAddress\n', '    )\n', '    public\n', '    onlyManager() // manager is CrowdsaleController instance\n', '    hasntStarted() // not yet started\n', '    hasntStopped() // crowdsale wasn&#39;t cancelled\n', '    {\n', '        require(_fundingAddress != address(0));\n', '\n', '        // start time must not be earlier than current time\n', '        require(_startTimestamp >= block.timestamp);\n', '\n', '        // range must be sane\n', '        require(_endTimestamp > _startTimestamp);\n', '        duration = _endTimestamp - _startTimestamp;\n', '\n', '        // duration must fit constraints\n', '        require(duration >= MIN_CROWDSALE_TIME && duration <= MAX_CROWDSALE_TIME);\n', '\n', '        startTimestamp = _startTimestamp;\n', '        endTimestamp = _endTimestamp;\n', '        fundingAddress = _fundingAddress;\n', '\n', '        // now crowdsale is considered started, even if the current time is before startTimestamp\n', '        started = true;\n', '\n', '        CROWDSALE_START(_startTimestamp, _endTimestamp, _fundingAddress);\n', '    }\n', '\n', '    // must return true if crowdsale is over, but it failed\n', '    function isFailed()\n', '    public\n', '    constant\n', '    returns (bool)\n', '    {\n', '        return (\n', '        // it was started\n', '        started &&\n', '\n', '        // crowdsale period has finished\n', '        block.timestamp >= endTimestamp &&\n', '\n', '        // but collected ETH is below the required minimum\n', '        totalCollected < minimalGoal\n', '        );\n', '    }\n', '\n', '    // must return true if crowdsale is active (i.e. the token can be bought)\n', '    function isActive()\n', '    public\n', '    constant\n', '    returns (bool)\n', '    {\n', '        return (\n', '        // it was started\n', '        started &&\n', '\n', '        // hard cap wasn&#39;t reached yet\n', '        totalCollected < hardCap &&\n', '\n', '        // and current time is within the crowdfunding period\n', '        block.timestamp >= startTimestamp &&\n', '        block.timestamp < endTimestamp\n', '        );\n', '    }\n', '\n', '    // must return true if crowdsale completed successfully\n', '    function isSuccessful()\n', '    public\n', '    constant\n', '    returns (bool)\n', '    {\n', '        return (\n', '        // either the hard cap is collected\n', '        totalCollected >= hardCap ||\n', '\n', '        // ...or the crowdfunding period is over, but the minimum has been reached\n', '        (block.timestamp >= endTimestamp && totalCollected >= minimalGoal)\n', '        );\n', '    }\n', '}\n', '\n', '// Minimal crowdsale token for custom contracts\n', 'contract IWingsController {\n', '    uint256 public ethRewardPart;\n', '    uint256 public tokenRewardPart;\n', '}\n', '\n', '/*\n', '  Implements custom crowdsale as bridge\n', '*/\n', 'contract Bridge is BasicCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    modifier onlyCrowdsale() {\n', '        require(msg.sender == crowdsaleAddress);\n', '        _;\n', '    }\n', '\n', '    // Crowdsale token\n', '    StandardToken token;\n', '\n', '    // Address of crowdsale\n', '    address public crowdsaleAddress;\n', '\n', '    // is crowdsale completed\n', '    bool public completed;\n', '\n', '    // Ctor. In this example, minimalGoal, hardCap, and price are not changeable.\n', '    // In more complex cases, those parameters may be changed until start() is called.\n', '    function Bridge(\n', '        uint256 _minimalGoal,\n', '        uint256 _hardCap,\n', '        address _token,\n', '        address _crowdsaleAddress\n', '    )\n', '    public\n', '        // simplest case where manager==owner. See onlyOwner() and onlyManager() modifiers\n', '        // before functions to figure out the cases in which those addresses should differ\n', '    BasicCrowdsale(msg.sender, msg.sender)\n', '    {\n', '        // just setup them once...\n', '        minimalGoal = _minimalGoal;\n', '        hardCap = _hardCap;\n', '        crowdsaleAddress = _crowdsaleAddress;\n', '        token = StandardToken(_token);\n', '    }\n', '\n', '    // Here goes ICrowdsaleProcessor implementation\n', '\n', '    // returns address of crowdsale token. The token must be ERC20-compliant\n', '    function getToken()\n', '    public\n', '    returns (address)\n', '    {\n', '        return address(token);\n', '    }\n', '\n', '    // called by CrowdsaleController to transfer reward part of\n', '    // tokens sold by successful crowdsale to Forecasting contract.\n', '    // This call is made upon closing successful crowdfunding process.\n', '    function mintTokenRewards(\n', '        address _contract, // Forecasting contract\n', '        uint256 _amount     // agreed part of totalSold which is intended for rewards\n', '    )\n', '    public\n', '    onlyManager() // manager is CrowdsaleController instance\n', '    {\n', '        // crowdsale token is mintable in this example, tokens are created here\n', '        token.transfer(_contract, _amount);\n', '    }\n', '\n', '    // transfers crowdsale token from mintable to transferrable state\n', '    function releaseTokens()\n', '    public\n', '    onlyManager() // manager is CrowdsaleController instance\n', '    hasntStopped() // crowdsale wasn&#39;t cancelled\n', '    whenCrowdsaleSuccessful() // crowdsale was successful\n', '    {\n', '        // empty for bridge\n', '    }\n', '\n', '    // Here go crowdsale process itself and token manipulations\n', '\n', '    // default function allows for ETH transfers to the contract\n', '    function() payable public {\n', '    }\n', '\n', '    function notifySale(uint256 _ethAmount, uint256 _tokensAmount) public\n', '    hasBeenStarted() // crowdsale started\n', '    hasntStopped() // wasn&#39;t cancelled by owner\n', '    whenCrowdsaleAlive() // in active state\n', '    onlyCrowdsale() // can do only crowdsale\n', '    {\n', '        totalCollected = totalCollected.add(_ethAmount);\n', '        totalSold = totalSold.add(_tokensAmount);\n', '    }\n', '\n', '    // finish collecting data\n', '    function finish() public\n', '    hasntStopped()\n', '    hasBeenStarted()\n', '    whenCrowdsaleAlive()\n', '    onlyCrowdsale()\n', '    {\n', '        completed = true;\n', '    }\n', '\n', '    // project&#39;s owner withdraws ETH funds to the funding address upon successful crowdsale\n', '    function withdraw(\n', '        uint256 _amount // can be done partially\n', '    )\n', '    public\n', '    onlyOwner() // project&#39;s owner\n', '    hasntStopped() // crowdsale wasn&#39;t cancelled\n', '    whenCrowdsaleSuccessful() // crowdsale completed successfully\n', '    {\n', '        // nothing to withdraw\n', '    }\n', '\n', '    // backers refund their ETH if the crowdsale was cancelled or has failed\n', '    function refund()\n', '    public\n', '    {\n', '        // nothing to refund\n', '    }\n', '\n', '    // called by CrowdsaleController to setup start and end time of crowdfunding process\n', '    // as well as funding address (where to transfer ETH upon successful crowdsale)\n', '    function start(\n', '        uint256 _startTimestamp,\n', '        uint256 _endTimestamp,\n', '        address _fundingAddress\n', '    )\n', '    public\n', '    onlyManager() // manager is CrowdsaleController instance\n', '    hasntStarted() // not yet started\n', '    hasntStopped() // crowdsale wasn&#39;t cancelled\n', '    {\n', '        // just start crowdsale\n', '        started = true;\n', '\n', '        CROWDSALE_START(_startTimestamp, _endTimestamp, _fundingAddress);\n', '    }\n', '\n', '    // must return true if crowdsale is over, but it failed\n', '    function isFailed()\n', '    public\n', '    constant\n', '    returns (bool)\n', '    {\n', '        return (\n', '        false\n', '        );\n', '    }\n', '\n', '    // must return true if crowdsale is active (i.e. the token can be bought)\n', '    function isActive()\n', '    public\n', '    constant\n', '    returns (bool)\n', '    {\n', '        return (\n', '        // we remove timelines\n', '        started && !completed\n', '        );\n', '    }\n', '\n', '    // must return true if crowdsale completed successfully\n', '    function isSuccessful()\n', '    public\n', '    constant\n', '    returns (bool)\n', '    {\n', '        return (\n', '        completed\n', '        );\n', '    }\n', '\n', '    function calculateRewards() public view returns (uint256, uint256) {\n', '        uint256 tokenRewardPart = IWingsController(manager).tokenRewardPart();\n', '        uint256 ethRewardPart = IWingsController(manager).ethRewardPart();\n', '\n', '        uint256 tokenReward = totalSold.mul(tokenRewardPart) / 1000000;\n', '        bool hasEthReward = (ethRewardPart != 0);\n', '\n', '        uint256 ethReward = 0;\n', '        if (hasEthReward) {\n', '            ethReward = totalCollected.mul(ethRewardPart) / 1000000;\n', '        }\n', '\n', '        return (ethReward, tokenReward);\n', '    }\n', '}\n', '\n', 'contract Connector is Ownable {\n', '    modifier bridgeInitialized() {\n', '        require(address(bridge) != address(0x0));\n', '        _;\n', '    }\n', '\n', '    Bridge public bridge;\n', '\n', '    function changeBridge(address _bridge) public onlyOwner {\n', '        require(_bridge != address(0x0));\n', '        bridge = Bridge(_bridge);\n', '    }\n', '\n', '    function notifySale(uint256 _ethAmount, uint256 _tokenAmount) internal bridgeInitialized {\n', '        bridge.notifySale(_ethAmount, _tokenAmount);\n', '    }\n', '\n', '    function closeBridge() internal bridgeInitialized {\n', '        bridge.finish();\n', '    }\n', '}\n', '\n', '// Wings contracts: End\n', '//---------------------------------------------------------------\n', '\n', 'contract CommonTokensale is Connector, Pausable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    CommonToken public token;         // Token contract reference.\n', '    CommonWhitelist public whitelist; // Whitelist contract reference.\n', '\n', '    address public beneficiary;       // Address that will receive ETH raised during this tokensale.\n', '    address public bsWallet = 0x8D5bd2aBa04A07Bfa0cc976C73eD45B23cC6D6a2;\n', '\n', '    bool public whitelistEnabled = true;\n', '\n', '    uint public constant preSaleMinPaymentWei = 5 ether;    // Hint: Set to lower amount (ex. 0.001 ETH) for tests.\n', '    uint public constant mainSaleMinPaymentWei = 0.05 ether; // Hint: Set to lower amount (ex. 0.001 ETH) for tests.\n', '\n', '    uint public defaultTokensPerWei = 4750; // TODO To be determined based on ETH to USD price at the date of sale.\n', '    uint public tokensPerWei5;\n', '    uint public tokensPerWei7;\n', '    uint public tokensPerWei10;\n', '    uint public tokensPerWei15;\n', '    uint public tokensPerWei20;\n', '\n', '    uint public minCapWei = 3200 ether;  // TODO  2m USD. Recalculate based on ETH to USD price at the date of tokensale.\n', '    uint public maxCapWei = 16000 ether; // TODO 10m USD. Recalculate based on ETH to USD price at the date of tokensale.\n', '\n', '    uint public constant startTime = 1525701600; // May 7, 2018 2:00:00 PM\n', '    uint public constant preSaleEndTime = 1526306400; // May 14, 2018 2:00:00 PM\n', '    uint public constant mainSaleStartTime = 1526392800; // May 15, 2018 2:00:00 PM\n', '    uint public constant endTime = 1528639200; // June 10, 2018 2:00:00 PM\n', '\n', '    // At main sale bonuses will be available only during the first 48 hours.\n', '    uint public mainSaleBonusEndTime;\n', '\n', '    // In case min (soft) cap is not reached, token buyers will be able to \n', '    // refund their contributions during one month after sale is finished.\n', '    uint public refundDeadlineTime;\n', '\n', '    // Stats for current tokensale:\n', '\n', '    uint public totalTokensSold;  // Total amount of tokens sold during this tokensale.\n', '    uint public totalWeiReceived; // Total amount of wei received during this tokensale.\n', '    uint public totalWeiRefunded; // Total amount of wei refunded if min (soft) cap is not reached.\n', '\n', '    // This mapping stores info on how many ETH (wei) have been sent to this tokensale from specific address.\n', '    mapping(address => uint256) public buyerToSentWei;\n', '\n', '    mapping(bytes32 => bool) public calledOnce;\n', '\n', '    event ChangeBeneficiaryEvent(address indexed _oldAddress, address indexed _newAddress);\n', '    event ChangeWhitelistEvent(address indexed _oldAddress, address indexed _newAddress);\n', '    event ReceiveEthEvent(address indexed _buyer, uint256 _amountWei);\n', '    event RefundEthEvent(address indexed _buyer, uint256 _amountWei);\n', '\n', '    function CommonTokensale(\n', '        address _token,\n', '        address _whitelist,\n', '        address _beneficiary\n', '    ) public Connector() {\n', '        require(_token != 0);\n', '        require(_whitelist != 0);\n', '        require(_beneficiary != 0);\n', '\n', '        token = CommonToken(_token);\n', '        whitelist = CommonWhitelist(_whitelist);\n', '        beneficiary = _beneficiary;\n', '\n', '        mainSaleBonusEndTime = mainSaleStartTime + 48 hours;\n', '        refundDeadlineTime = endTime + 30 days;\n', '\n', '        recalcBonuses();\n', '    }\n', '\n', '    modifier canBeCalledOnce(bytes32 _flag) {\n', '        require(!calledOnce[_flag]);\n', '        calledOnce[_flag] = true;\n', '        _;\n', '    }\n', '\n', '    function updateMinCapEthOnce(uint _amountInEth) public onlyOwner canBeCalledOnce("updateMinCapEth") {\n', '        minCapWei = _amountInEth * 1e18;\n', '        // Convert ETH to Wei and update a min cap.\n', '    }\n', '\n', '    function updateMaxCapEthOnce(uint _amountInEth) public onlyOwner canBeCalledOnce("updateMaxCapEth") {\n', '        maxCapWei = _amountInEth * 1e18;\n', '        // Convert ETH to Wei and update a max cap.\n', '    }\n', '\n', '    function updateTokensPerEthOnce(uint _amountInEth) public onlyOwner canBeCalledOnce("updateTokensPerEth") {\n', '        defaultTokensPerWei = _amountInEth;\n', '        recalcBonuses();\n', '    }\n', '\n', '    function setBeneficiary(address _beneficiary) public onlyOwner {\n', '        require(_beneficiary != 0);\n', '        ChangeBeneficiaryEvent(beneficiary, _beneficiary);\n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '    function setWhitelist(address _whitelist) public onlyOwner {\n', '        require(_whitelist != 0);\n', '        ChangeWhitelistEvent(whitelist, _whitelist);\n', '        whitelist = CommonWhitelist(_whitelist);\n', '    }\n', '\n', '    function setWhitelistEnabled(bool _enabled) public onlyOwner {\n', '        whitelistEnabled = _enabled;\n', '    }\n', '\n', '    /** The fallback function corresponds to a donation in ETH. */\n', '    function() public payable {\n', '        sellTokensForEth(msg.sender, msg.value);\n', '    }\n', '\n', '    function sellTokensForEth(\n', '        address _buyer,\n', '        uint256 _amountWei\n', '    ) ifNotPaused internal {\n', '\n', '        // Check that buyer is in whitelist onlist if whitelist check is enabled.\n', '        if (whitelistEnabled) require(whitelist.isAllowed(_buyer));\n', '\n', '        require(canAcceptPayment(_amountWei));\n', '        require(totalWeiReceived < maxCapWei);\n', '\n', '        uint256 newTotalReceived = totalWeiReceived.add(_amountWei);\n', '\n', '        // Don&#39;t sell anything above the hard cap\n', '        if (newTotalReceived > maxCapWei) {\n', '            uint refundWei = newTotalReceived.sub(maxCapWei);\n', '            _amountWei = _amountWei.sub(refundWei);\n', '\n', '            // We need to check payment amount once more such as we updated \n', '            // (reduced) it in this if-clause.\n', '            require(canAcceptPayment(_amountWei));\n', '\n', '            // Send the ETH part which exceeds the hard cap back to the buyer:\n', '            _buyer.transfer(refundWei);\n', '        }\n', '\n', '        uint tokensE18 = weiToTokens(_amountWei);\n', '        // Transfer tokens to buyer.\n', '        token.sell(_buyer, tokensE18);\n', '\n', '        // 0.75% of sold tokens go to BS account:\n', '        uint bsTokens = tokensE18.mul(75).div(10000);\n', '        token.sell(bsWallet, bsTokens);\n', '\n', '        // Update total stats:\n', '        totalTokensSold = totalTokensSold.add(tokensE18).add(bsTokens);\n', '        totalWeiReceived = totalWeiReceived.add(_amountWei);\n', '        buyerToSentWei[_buyer] = buyerToSentWei[_buyer].add(_amountWei);\n', '        ReceiveEthEvent(_buyer, _amountWei);\n', '\n', '        // Notify Wings about successful sale of tokens:\n', '        notifySale(_amountWei, tokensE18.add(bsTokens));\n', '    }\n', '\n', '    function recalcBonuses() internal {\n', '        tokensPerWei5 = tokensPerWeiPlusBonus(5);\n', '        tokensPerWei7 = tokensPerWeiPlusBonus(7);\n', '        tokensPerWei10 = tokensPerWeiPlusBonus(10);\n', '        tokensPerWei15 = tokensPerWeiPlusBonus(15);\n', '        tokensPerWei20 = tokensPerWeiPlusBonus(20);\n', '    }\n', '\n', '    function tokensPerWeiPlusBonus(uint _per) public view returns (uint) {\n', '        return defaultTokensPerWei.add(\n', '            amountPercentage(defaultTokensPerWei, _per)\n', '        );\n', '    }\n', '\n', '    function amountPercentage(uint _amount, uint _per) public pure returns (uint) {\n', '        return _amount.mul(_per).div(100);\n', '    }\n', '\n', '    /** Calc how much tokens you can buy at current time. */\n', '    function weiToTokens(uint _amountWei) public view returns (uint) {\n', '        return _amountWei.mul(tokensPerWei(_amountWei));\n', '    }\n', '\n', '    function tokensPerWei(uint _amountWei) public view returns (uint256) {\n', '        // Presale bonuses:\n', '        if (isPreSaleTime()) {\n', '            if (5 ether <= _amountWei && _amountWei < 10 ether) return tokensPerWei10;\n', '            if (_amountWei < 20 ether) return tokensPerWei15;\n', '            if (20 ether <= _amountWei) return tokensPerWei20;\n', '        }\n', '        // Main sale bonues:\n', '        if (isMainSaleBonusTime()) {\n', '            if (0.05 ether <= _amountWei && _amountWei < 10 ether) return tokensPerWei5;\n', '            if (_amountWei < 20 ether) return tokensPerWei7;\n', '            if (20 ether <= _amountWei) return tokensPerWei10;\n', '        }\n', '        return defaultTokensPerWei;\n', '    }\n', '\n', '    function canAcceptPayment(uint _amountWei) public view returns (bool) {\n', '        if (isPreSaleTime()) return _amountWei >= preSaleMinPaymentWei;\n', '        if (isMainSaleTime()) return _amountWei >= mainSaleMinPaymentWei;\n', '        return false;\n', '    }\n', '\n', '    function isPreSaleTime() public view returns (bool) {\n', '        return startTime <= now && now <= preSaleEndTime;\n', '    }\n', '\n', '    function isMainSaleBonusTime() public view returns (bool) {\n', '        return mainSaleStartTime <= now && now <= mainSaleBonusEndTime;\n', '    }\n', '\n', '    function isMainSaleTime() public view returns (bool) {\n', '        return mainSaleStartTime <= now && now <= endTime;\n', '    }\n', '\n', '    function isFinishedSuccessfully() public view returns (bool) {\n', '        return totalWeiReceived >= minCapWei && now > endTime;\n', '    }\n', '\n', '    /** \n', '     * During tokensale it will be possible to withdraw only in two cases:\n', '     * min cap reached OR refund period expired.\n', '     */\n', '    function canWithdraw() public view returns (bool) {\n', '        return totalWeiReceived >= minCapWei || now > refundDeadlineTime;\n', '    }\n', '\n', '    /** \n', '     * This method allows to withdraw to any arbitrary ETH address. \n', '     * This approach gives more flexibility.\n', '     */\n', '    function withdraw(address _to, uint256 _amount) public {\n', '        require(canWithdraw());\n', '        require(msg.sender == beneficiary);\n', '        require(_amount <= this.balance);\n', '\n', '        _to.transfer(_amount);\n', '    }\n', '\n', '    function withdraw(address _to) public {\n', '        withdraw(_to, this.balance);\n', '    }\n', '\n', '    /** \n', '     * It will be possible to refund only if min (soft) cap is not reached and \n', '     * refund requested during 30 days after tokensale finished.\n', '     */\n', '    function canRefund() public view returns (bool) {\n', '        return totalWeiReceived < minCapWei && endTime < now && now <= refundDeadlineTime;\n', '    }\n', '\n', '    function refund() public {\n', '        require(canRefund());\n', '\n', '        address buyer = msg.sender;\n', '        uint amount = buyerToSentWei[buyer];\n', '        require(amount > 0);\n', '\n', '        RefundEthEvent(buyer, amount);\n', '        buyerToSentWei[buyer] = 0;\n', '        totalWeiRefunded = totalWeiRefunded.add(amount);\n', '        buyer.transfer(amount);\n', '    }\n', '\n', '    /**\n', '     * If there is ETH rewards and all ETH already withdrawn but contract \n', '     * needs to pay for transfering transactions. \n', '     */\n', '    function deposit() public payable {\n', '        require(isFinishedSuccessfully());\n', '    }\n', '\n', '    /** \n', '     * This function should be called only once only after \n', '     * successfully finished tokensale. Once - because Wings bridge \n', '     * will be closed at the end of this function call.\n', '     */\n', '    function sendWingsRewardsOnce() public onlyOwner canBeCalledOnce("sendWingsRewards") {\n', '        require(isFinishedSuccessfully());\n', '\n', '        uint256 ethReward = 0;\n', '        uint256 tokenReward = 0;\n', '\n', '        (ethReward, tokenReward) = bridge.calculateRewards();\n', '\n', '        if (ethReward > 0) {\n', '            bridge.transfer(ethReward);\n', '        }\n', '\n', '        if (tokenReward > 0) {\n', '            token.sell(bridge, tokenReward);\n', '        }\n', '\n', '        // Close Wings bridge\n', '        closeBridge();\n', '    }\n', '}\n', '\n', '\n', '// >> Start:\n', '// >> EXAMPLE: How to deploy Token, Whitelist and Tokensale.\n', '\n', '// token = new CommonToken(\n', '//     0x123 // TODO Set seller address\n', '// );\n', '// whitelist = new CommonWhitelist();\n', '// tokensale = new Tokensale(\n', '//     token,\n', '//     whitelist,\n', '//     0x123 // TODO Set beneficiary address\n', '// );\n', '// token.addOwner(tokensale);\n', '\n', '// << EXAMPLE: How to deploy Token, Whitelist and Tokensale.\n', '// << End\n', '\n', '\n', '// TODO After Tokensale deployed, call token.addOwner(address_of_deployed_tokensale)\n', 'contract ProdTokensale is CommonTokensale {\n', '    function ProdTokensale() CommonTokensale(\n', '        0x123, // TODO Set token address\n', '        0x123, // TODO Set whitelist address\n', '        0x123  // TODO Set beneficiary address\n', '    ) public {}\n', '}']