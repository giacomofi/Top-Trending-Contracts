['/*\n', '\n', '  Copyright 2017 ZeroEx Intl.\n', '  Modifications Copyright 2018 bZeroX, LLC\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract TokenRegistry is Ownable {\n', '\n', '    event LogAddToken(\n', '        address indexed token,\n', '        string name,\n', '        string symbol,\n', '        uint8 decimals,\n', '        string url\n', '    );\n', '\n', '    event LogRemoveToken(\n', '        address indexed token,\n', '        string name,\n', '        string symbol,\n', '        uint8 decimals,\n', '        string url\n', '    );\n', '\n', '    event LogTokenNameChange(address indexed token, string oldName, string newName);\n', '    event LogTokenSymbolChange(address indexed token, string oldSymbol, string newSymbol);\n', '    event LogTokenURLChange(address indexed token, string oldURL, string newURL);\n', '\n', '    mapping (address => TokenMetadata) public tokens;\n', '    mapping (string => address) internal tokenBySymbol;\n', '    mapping (string => address) internal tokenByName;\n', '\n', '    address[] public tokenAddresses;\n', '\n', '    struct TokenMetadata {\n', '        address token;\n', '        string name;\n', '        string symbol;\n', '        uint8 decimals;\n', '        string url;\n', '    }\n', '\n', '    modifier tokenExists(address _token) {\n', '        require(tokens[_token].token != address(0), "TokenRegistry::token doesn&#39;t exist");\n', '        _;\n', '    }\n', '\n', '    modifier tokenDoesNotExist(address _token) {\n', '        require(tokens[_token].token == address(0), "TokenRegistry::token exists");\n', '        _;\n', '    }\n', '\n', '    modifier nameDoesNotExist(string _name) {\n', '        require(tokenByName[_name] == address(0), "TokenRegistry::name exists");\n', '        _;\n', '    }\n', '\n', '    modifier symbolDoesNotExist(string _symbol) {\n', '        require(tokenBySymbol[_symbol] == address(0), "TokenRegistry::symbol exists");\n', '        _;\n', '    }\n', '\n', '    modifier addressNotNull(address _address) {\n', '        require(_address != address(0), "TokenRegistry::address is null");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows owner to add a new token to the registry.\n', '    /// @param _token Address of new token.\n', '    /// @param _name Name of new token.\n', '    /// @param _symbol Symbol for new token.\n', '    /// @param _decimals Number of decimals, divisibility of new token.\n', '    /// @param _url URL of token icon.\n', '    function addToken(\n', '        address _token,\n', '        string _name,\n', '        string _symbol,\n', '        uint8 _decimals,\n', '        string _url)\n', '        public\n', '        onlyOwner\n', '        tokenDoesNotExist(_token)\n', '        addressNotNull(_token)\n', '        symbolDoesNotExist(_symbol)\n', '        nameDoesNotExist(_name)\n', '    {\n', '        tokens[_token] = TokenMetadata({\n', '            token: _token,\n', '            name: _name,\n', '            symbol: _symbol,\n', '            decimals: _decimals,\n', '            url: _url\n', '        });\n', '        tokenAddresses.push(_token);\n', '        tokenBySymbol[_symbol] = _token;\n', '        tokenByName[_name] = _token;\n', '        emit LogAddToken(\n', '            _token,\n', '            _name,\n', '            _symbol,\n', '            _decimals,\n', '            _url\n', '        );\n', '    }\n', '\n', '    /// @dev Allows owner to remove an existing token from the registry.\n', '    /// @param _token Address of existing token.\n', '    function removeToken(address _token, uint _index)\n', '        public\n', '        onlyOwner\n', '        tokenExists(_token)\n', '    {\n', '        require(tokenAddresses[_index] == _token, "TokenRegistry::invalid index");\n', '\n', '        tokenAddresses[_index] = tokenAddresses[tokenAddresses.length - 1];\n', '        tokenAddresses.length -= 1;\n', '\n', '        TokenMetadata storage token = tokens[_token];\n', '        emit LogRemoveToken(\n', '            token.token,\n', '            token.name,\n', '            token.symbol,\n', '            token.decimals,\n', '            token.url\n', '        );\n', '        delete tokenBySymbol[token.symbol];\n', '        delete tokenByName[token.name];\n', '        delete tokens[_token];\n', '    }\n', '\n', '    /// @dev Allows owner to modify an existing token&#39;s name.\n', '    /// @param _token Address of existing token.\n', '    /// @param _name New name.\n', '    function setTokenName(address _token, string _name)\n', '        public\n', '        onlyOwner\n', '        tokenExists(_token)\n', '        nameDoesNotExist(_name)\n', '    {\n', '        TokenMetadata storage token = tokens[_token];\n', '        emit LogTokenNameChange(_token, token.name, _name);\n', '        delete tokenByName[token.name];\n', '        tokenByName[_name] = _token;\n', '        token.name = _name;\n', '    }\n', '\n', '    /// @dev Allows owner to modify an existing token&#39;s symbol.\n', '    /// @param _token Address of existing token.\n', '    /// @param _symbol New symbol.\n', '    function setTokenSymbol(address _token, string _symbol)\n', '        public\n', '        onlyOwner\n', '        tokenExists(_token)\n', '        symbolDoesNotExist(_symbol)\n', '    {\n', '        TokenMetadata storage token = tokens[_token];\n', '        emit LogTokenSymbolChange(_token, token.symbol, _symbol);\n', '        delete tokenBySymbol[token.symbol];\n', '        tokenBySymbol[_symbol] = _token;\n', '        token.symbol = _symbol;\n', '    }\n', '\n', '    /// @dev Allows owner to modify an existing token&#39;s icon URL.\n', '    /// @param _token URL of token token.\n', '    /// @param _url New URL to token icon.\n', '    function setTokenURL(address _token, string _url)\n', '        public\n', '        onlyOwner\n', '        tokenExists(_token)\n', '    {\n', '        TokenMetadata storage token = tokens[_token];\n', '        emit LogTokenURLChange(_token, token.url, _url);\n', '        token.url = _url;\n', '    }\n', '\n', '    /*\n', '     * View functions\n', '     */\n', '    /// @dev Provides a registered token&#39;s address when given the token symbol.\n', '    /// @param _symbol Symbol of registered token.\n', '    /// @return Token&#39;s address.\n', '    function getTokenAddressBySymbol(string _symbol) \n', '        public\n', '        view \n', '        returns (address)\n', '    {\n', '        return tokenBySymbol[_symbol];\n', '    }\n', '\n', '    /// @dev Provides a registered token&#39;s address when given the token name.\n', '    /// @param _name Name of registered token.\n', '    /// @return Token&#39;s address.\n', '    function getTokenAddressByName(string _name) \n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return tokenByName[_name];\n', '    }\n', '\n', '    /// @dev Provides a registered token&#39;s metadata, looked up by address.\n', '    /// @param _token Address of registered token.\n', '    /// @return Token metadata.\n', '    function getTokenMetaData(address _token)\n', '        public\n', '        view\n', '        returns (\n', '            address,  //tokenAddress\n', '            string,   //name\n', '            string,   //symbol\n', '            uint8,    //decimals\n', '            string    //url\n', '        )\n', '    {\n', '        TokenMetadata memory token = tokens[_token];\n', '        return (\n', '            token.token,\n', '            token.name,\n', '            token.symbol,\n', '            token.decimals,\n', '            token.url\n', '        );\n', '    }\n', '\n', '    /// @dev Provides a registered token&#39;s metadata, looked up by name.\n', '    /// @param _name Name of registered token.\n', '    /// @return Token metadata.\n', '    function getTokenByName(string _name)\n', '        public\n', '        view\n', '        returns (\n', '            address,  //tokenAddress\n', '            string,   //name\n', '            string,   //symbol\n', '            uint8,    //decimals\n', '            string    //url\n', '        )\n', '    {\n', '        address _token = tokenByName[_name];\n', '        return getTokenMetaData(_token);\n', '    }\n', '\n', '    /// @dev Provides a registered token&#39;s metadata, looked up by symbol.\n', '    /// @param _symbol Symbol of registered token.\n', '    /// @return Token metadata.\n', '    function getTokenBySymbol(string _symbol)\n', '        public\n', '        view\n', '        returns (\n', '            address,  //tokenAddress\n', '            string,   //name\n', '            string,   //symbol\n', '            uint8,    //decimals\n', '            string    //url\n', '        )\n', '    {\n', '        address _token = tokenBySymbol[_symbol];\n', '        return getTokenMetaData(_token);\n', '    }\n', '\n', '    /// @dev Returns an array containing all token addresses.\n', '    /// @return Array of token addresses.\n', '    function getTokenAddresses()\n', '        public\n', '        view\n', '        returns (address[])\n', '    {\n', '        return tokenAddresses;\n', '    }\n', '}']
['/*\n', '\n', '  Copyright 2017 ZeroEx Intl.\n', '  Modifications Copyright 2018 bZeroX, LLC\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract TokenRegistry is Ownable {\n', '\n', '    event LogAddToken(\n', '        address indexed token,\n', '        string name,\n', '        string symbol,\n', '        uint8 decimals,\n', '        string url\n', '    );\n', '\n', '    event LogRemoveToken(\n', '        address indexed token,\n', '        string name,\n', '        string symbol,\n', '        uint8 decimals,\n', '        string url\n', '    );\n', '\n', '    event LogTokenNameChange(address indexed token, string oldName, string newName);\n', '    event LogTokenSymbolChange(address indexed token, string oldSymbol, string newSymbol);\n', '    event LogTokenURLChange(address indexed token, string oldURL, string newURL);\n', '\n', '    mapping (address => TokenMetadata) public tokens;\n', '    mapping (string => address) internal tokenBySymbol;\n', '    mapping (string => address) internal tokenByName;\n', '\n', '    address[] public tokenAddresses;\n', '\n', '    struct TokenMetadata {\n', '        address token;\n', '        string name;\n', '        string symbol;\n', '        uint8 decimals;\n', '        string url;\n', '    }\n', '\n', '    modifier tokenExists(address _token) {\n', '        require(tokens[_token].token != address(0), "TokenRegistry::token doesn\'t exist");\n', '        _;\n', '    }\n', '\n', '    modifier tokenDoesNotExist(address _token) {\n', '        require(tokens[_token].token == address(0), "TokenRegistry::token exists");\n', '        _;\n', '    }\n', '\n', '    modifier nameDoesNotExist(string _name) {\n', '        require(tokenByName[_name] == address(0), "TokenRegistry::name exists");\n', '        _;\n', '    }\n', '\n', '    modifier symbolDoesNotExist(string _symbol) {\n', '        require(tokenBySymbol[_symbol] == address(0), "TokenRegistry::symbol exists");\n', '        _;\n', '    }\n', '\n', '    modifier addressNotNull(address _address) {\n', '        require(_address != address(0), "TokenRegistry::address is null");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows owner to add a new token to the registry.\n', '    /// @param _token Address of new token.\n', '    /// @param _name Name of new token.\n', '    /// @param _symbol Symbol for new token.\n', '    /// @param _decimals Number of decimals, divisibility of new token.\n', '    /// @param _url URL of token icon.\n', '    function addToken(\n', '        address _token,\n', '        string _name,\n', '        string _symbol,\n', '        uint8 _decimals,\n', '        string _url)\n', '        public\n', '        onlyOwner\n', '        tokenDoesNotExist(_token)\n', '        addressNotNull(_token)\n', '        symbolDoesNotExist(_symbol)\n', '        nameDoesNotExist(_name)\n', '    {\n', '        tokens[_token] = TokenMetadata({\n', '            token: _token,\n', '            name: _name,\n', '            symbol: _symbol,\n', '            decimals: _decimals,\n', '            url: _url\n', '        });\n', '        tokenAddresses.push(_token);\n', '        tokenBySymbol[_symbol] = _token;\n', '        tokenByName[_name] = _token;\n', '        emit LogAddToken(\n', '            _token,\n', '            _name,\n', '            _symbol,\n', '            _decimals,\n', '            _url\n', '        );\n', '    }\n', '\n', '    /// @dev Allows owner to remove an existing token from the registry.\n', '    /// @param _token Address of existing token.\n', '    function removeToken(address _token, uint _index)\n', '        public\n', '        onlyOwner\n', '        tokenExists(_token)\n', '    {\n', '        require(tokenAddresses[_index] == _token, "TokenRegistry::invalid index");\n', '\n', '        tokenAddresses[_index] = tokenAddresses[tokenAddresses.length - 1];\n', '        tokenAddresses.length -= 1;\n', '\n', '        TokenMetadata storage token = tokens[_token];\n', '        emit LogRemoveToken(\n', '            token.token,\n', '            token.name,\n', '            token.symbol,\n', '            token.decimals,\n', '            token.url\n', '        );\n', '        delete tokenBySymbol[token.symbol];\n', '        delete tokenByName[token.name];\n', '        delete tokens[_token];\n', '    }\n', '\n', "    /// @dev Allows owner to modify an existing token's name.\n", '    /// @param _token Address of existing token.\n', '    /// @param _name New name.\n', '    function setTokenName(address _token, string _name)\n', '        public\n', '        onlyOwner\n', '        tokenExists(_token)\n', '        nameDoesNotExist(_name)\n', '    {\n', '        TokenMetadata storage token = tokens[_token];\n', '        emit LogTokenNameChange(_token, token.name, _name);\n', '        delete tokenByName[token.name];\n', '        tokenByName[_name] = _token;\n', '        token.name = _name;\n', '    }\n', '\n', "    /// @dev Allows owner to modify an existing token's symbol.\n", '    /// @param _token Address of existing token.\n', '    /// @param _symbol New symbol.\n', '    function setTokenSymbol(address _token, string _symbol)\n', '        public\n', '        onlyOwner\n', '        tokenExists(_token)\n', '        symbolDoesNotExist(_symbol)\n', '    {\n', '        TokenMetadata storage token = tokens[_token];\n', '        emit LogTokenSymbolChange(_token, token.symbol, _symbol);\n', '        delete tokenBySymbol[token.symbol];\n', '        tokenBySymbol[_symbol] = _token;\n', '        token.symbol = _symbol;\n', '    }\n', '\n', "    /// @dev Allows owner to modify an existing token's icon URL.\n", '    /// @param _token URL of token token.\n', '    /// @param _url New URL to token icon.\n', '    function setTokenURL(address _token, string _url)\n', '        public\n', '        onlyOwner\n', '        tokenExists(_token)\n', '    {\n', '        TokenMetadata storage token = tokens[_token];\n', '        emit LogTokenURLChange(_token, token.url, _url);\n', '        token.url = _url;\n', '    }\n', '\n', '    /*\n', '     * View functions\n', '     */\n', "    /// @dev Provides a registered token's address when given the token symbol.\n", '    /// @param _symbol Symbol of registered token.\n', "    /// @return Token's address.\n", '    function getTokenAddressBySymbol(string _symbol) \n', '        public\n', '        view \n', '        returns (address)\n', '    {\n', '        return tokenBySymbol[_symbol];\n', '    }\n', '\n', "    /// @dev Provides a registered token's address when given the token name.\n", '    /// @param _name Name of registered token.\n', "    /// @return Token's address.\n", '    function getTokenAddressByName(string _name) \n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return tokenByName[_name];\n', '    }\n', '\n', "    /// @dev Provides a registered token's metadata, looked up by address.\n", '    /// @param _token Address of registered token.\n', '    /// @return Token metadata.\n', '    function getTokenMetaData(address _token)\n', '        public\n', '        view\n', '        returns (\n', '            address,  //tokenAddress\n', '            string,   //name\n', '            string,   //symbol\n', '            uint8,    //decimals\n', '            string    //url\n', '        )\n', '    {\n', '        TokenMetadata memory token = tokens[_token];\n', '        return (\n', '            token.token,\n', '            token.name,\n', '            token.symbol,\n', '            token.decimals,\n', '            token.url\n', '        );\n', '    }\n', '\n', "    /// @dev Provides a registered token's metadata, looked up by name.\n", '    /// @param _name Name of registered token.\n', '    /// @return Token metadata.\n', '    function getTokenByName(string _name)\n', '        public\n', '        view\n', '        returns (\n', '            address,  //tokenAddress\n', '            string,   //name\n', '            string,   //symbol\n', '            uint8,    //decimals\n', '            string    //url\n', '        )\n', '    {\n', '        address _token = tokenByName[_name];\n', '        return getTokenMetaData(_token);\n', '    }\n', '\n', "    /// @dev Provides a registered token's metadata, looked up by symbol.\n", '    /// @param _symbol Symbol of registered token.\n', '    /// @return Token metadata.\n', '    function getTokenBySymbol(string _symbol)\n', '        public\n', '        view\n', '        returns (\n', '            address,  //tokenAddress\n', '            string,   //name\n', '            string,   //symbol\n', '            uint8,    //decimals\n', '            string    //url\n', '        )\n', '    {\n', '        address _token = tokenBySymbol[_symbol];\n', '        return getTokenMetaData(_token);\n', '    }\n', '\n', '    /// @dev Returns an array containing all token addresses.\n', '    /// @return Array of token addresses.\n', '    function getTokenAddresses()\n', '        public\n', '        view\n', '        returns (address[])\n', '    {\n', '        return tokenAddresses;\n', '    }\n', '}']
