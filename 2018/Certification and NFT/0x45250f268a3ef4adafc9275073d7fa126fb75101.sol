['pragma solidity 0.4.24;\n', '\n', 'library BPackedUtils {\n', '\n', '    // the uint16 ending at 128 bits should be 0s\n', '    uint256 constant sbMask        = 0xffffffffffffffffffffffffffff0000ffffffffffffffffffffffffffffffff;\n', '    uint256 constant startTimeMask = 0xffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff;\n', '    uint256 constant endTimeMask   = 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000;\n', '\n', '    function packedToSubmissionBits(uint256 packed) internal pure returns (uint16) {\n', '        return uint16(packed >> 128);\n', '    }\n', '\n', '    function packedToStartTime(uint256 packed) internal pure returns (uint64) {\n', '        return uint64(packed >> 64);\n', '    }\n', '\n', '    function packedToEndTime(uint256 packed) internal pure returns (uint64) {\n', '        return uint64(packed);\n', '    }\n', '\n', '    function unpackAll(uint256 packed) internal pure returns (uint16 submissionBits, uint64 startTime, uint64 endTime) {\n', '        submissionBits = uint16(packed >> 128);\n', '        startTime = uint64(packed >> 64);\n', '        endTime = uint64(packed);\n', '    }\n', '\n', '    function pack(uint16 sb, uint64 st, uint64 et) internal pure returns (uint256 packed) {\n', '        return uint256(sb) << 128 | uint256(st) << 64 | uint256(et);\n', '    }\n', '\n', '    function setSB(uint256 packed, uint16 newSB) internal pure returns (uint256) {\n', '        return (packed & sbMask) | uint256(newSB) << 128;\n', '    }\n', '\n', '    // function setStartTime(uint256 packed, uint64 startTime) internal pure returns (uint256) {\n', '    //     return (packed & startTimeMask) | uint256(startTime) << 64;\n', '    // }\n', '\n', '    // function setEndTime(uint256 packed, uint64 endTime) internal pure returns (uint256) {\n', '    //     return (packed & endTimeMask) | uint256(endTime);\n', '    // }\n', '}\n', '\n', 'contract safeSend {\n', '    bool private txMutex3847834;\n', '\n', '    // we want to be able to call outside contracts (e.g. the admin proxy contract)\n', '    // but reentrency is bad, so here&#39;s a mutex.\n', '    function doSafeSend(address toAddr, uint amount) internal {\n', '        doSafeSendWData(toAddr, "", amount);\n', '    }\n', '\n', '    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\n', '        require(txMutex3847834 == false, "ss-guard");\n', '        txMutex3847834 = true;\n', '        // we need to use address.call.value(v)() because we want\n', '        // to be able to send to other contracts, even with no data,\n', '        // which might use more than 2300 gas in their fallback function.\n', '        require(toAddr.call.value(amount)(data), "ss-failed");\n', '        txMutex3847834 = false;\n', '    }\n', '}\n', '\n', 'contract payoutAllC is safeSend {\n', '    address private _payTo;\n', '\n', '    event PayoutAll(address payTo, uint value);\n', '\n', '    constructor(address initPayTo) public {\n', '        // DEV NOTE: you can overwrite _getPayTo if you want to reuse other storage vars\n', '        assert(initPayTo != address(0));\n', '        _payTo = initPayTo;\n', '    }\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return _payTo;\n', '    }\n', '\n', '    function _setPayTo(address newPayTo) internal {\n', '        _payTo = newPayTo;\n', '    }\n', '\n', '    function payoutAll() external {\n', '        address a = _getPayTo();\n', '        uint bal = address(this).balance;\n', '        doSafeSend(a, bal);\n', '        emit PayoutAll(a, bal);\n', '    }\n', '}\n', '\n', 'contract payoutAllCSettable is payoutAllC {\n', '    constructor (address initPayTo) payoutAllC(initPayTo) public {\n', '    }\n', '\n', '    function setPayTo(address) external;\n', '    function getPayTo() external view returns (address) {\n', '        return _getPayTo();\n', '    }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address newOwner);\n', '\n', '    modifier only_owner() {\n', '        require(msg.sender == owner, "only_owner: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier owner_or(address addr) {\n', '        require(msg.sender == addr || msg.sender == owner, "!owner-or");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address newOwner) only_owner() external {\n', '        owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '}\n', '\n', 'contract controlledIface {\n', '    function controller() external view returns (address);\n', '}\n', '\n', 'contract hasAdmins is owned {\n', '    mapping (uint => mapping (address => bool)) admins;\n', '    uint public currAdminEpoch = 0;\n', '    bool public adminsDisabledForever = false;\n', '    address[] adminLog;\n', '\n', '    event AdminAdded(address indexed newAdmin);\n', '    event AdminRemoved(address indexed oldAdmin);\n', '    event AdminEpochInc();\n', '    event AdminDisabledForever();\n', '\n', '    modifier only_admin() {\n', '        require(adminsDisabledForever == false, "admins must not be disabled");\n', '        require(isAdmin(msg.sender), "only_admin: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        _setAdmin(msg.sender, true);\n', '    }\n', '\n', '    function isAdmin(address a) view public returns (bool) {\n', '        return admins[currAdminEpoch][a];\n', '    }\n', '\n', '    function getAdminLogN() view external returns (uint) {\n', '        return adminLog.length;\n', '    }\n', '\n', '    function getAdminLog(uint n) view external returns (address) {\n', '        return adminLog[n];\n', '    }\n', '\n', '    function upgradeMeAdmin(address newAdmin) only_admin() external {\n', '        // note: already checked msg.sender has admin with `only_admin` modifier\n', '        require(msg.sender != owner, "owner cannot upgrade self");\n', '        _setAdmin(msg.sender, false);\n', '        _setAdmin(newAdmin, true);\n', '    }\n', '\n', '    function setAdmin(address a, bool _givePerms) only_admin() external {\n', '        require(a != msg.sender && a != owner, "cannot change your own (or owner&#39;s) permissions");\n', '        _setAdmin(a, _givePerms);\n', '    }\n', '\n', '    function _setAdmin(address a, bool _givePerms) internal {\n', '        admins[currAdminEpoch][a] = _givePerms;\n', '        if (_givePerms) {\n', '            emit AdminAdded(a);\n', '            adminLog.push(a);\n', '        } else {\n', '            emit AdminRemoved(a);\n', '        }\n', '    }\n', '\n', '    // safety feature if admins go bad or something\n', '    function incAdminEpoch() only_owner() external {\n', '        currAdminEpoch++;\n', '        admins[currAdminEpoch][msg.sender] = true;\n', '        emit AdminEpochInc();\n', '    }\n', '\n', '    // this is internal so contracts can all it, but not exposed anywhere in this\n', '    // contract.\n', '    function disableAdminForever() internal {\n', '        currAdminEpoch++;\n', '        adminsDisabledForever = true;\n', '        emit AdminDisabledForever();\n', '    }\n', '}\n', '\n', 'contract permissioned is owned, hasAdmins {\n', '    mapping (address => bool) editAllowed;\n', '    bool public adminLockdown = false;\n', '\n', '    event PermissionError(address editAddr);\n', '    event PermissionGranted(address editAddr);\n', '    event PermissionRevoked(address editAddr);\n', '    event PermissionsUpgraded(address oldSC, address newSC);\n', '    event SelfUpgrade(address oldSC, address newSC);\n', '    event AdminLockdown();\n', '\n', '    modifier only_editors() {\n', '        require(editAllowed[msg.sender], "only_editors: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier no_lockdown() {\n', '        require(adminLockdown == false, "no_lockdown: check failed");\n', '        _;\n', '    }\n', '\n', '\n', '    constructor() owned() hasAdmins() public {\n', '    }\n', '\n', '\n', '    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\n', '        editAllowed[e] = _editPerms;\n', '        if (_editPerms)\n', '            emit PermissionGranted(e);\n', '        else\n', '            emit PermissionRevoked(e);\n', '    }\n', '\n', '    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\n', '        editAllowed[oldSC] = false;\n', '        editAllowed[newSC] = true;\n', '        emit PermissionsUpgraded(oldSC, newSC);\n', '    }\n', '\n', '    // always allow SCs to upgrade themselves, even after lockdown\n', '    function upgradeMe(address newSC) only_editors() external {\n', '        editAllowed[msg.sender] = false;\n', '        editAllowed[newSC] = true;\n', '        emit SelfUpgrade(msg.sender, newSC);\n', '    }\n', '\n', '    function hasPermissions(address a) public view returns (bool) {\n', '        return editAllowed[a];\n', '    }\n', '\n', '    function doLockdown() external only_owner() no_lockdown() {\n', '        disableAdminForever();\n', '        adminLockdown = true;\n', '        emit AdminLockdown();\n', '    }\n', '}\n', '\n', 'contract upgradePtr {\n', '    address ptr = address(0);\n', '\n', '    modifier not_upgraded() {\n', '        require(ptr == address(0), "upgrade pointer is non-zero");\n', '        _;\n', '    }\n', '\n', '    function getUpgradePointer() view external returns (address) {\n', '        return ptr;\n', '    }\n', '\n', '    function doUpgradeInternal(address nextSC) internal {\n', '        ptr = nextSC;\n', '    }\n', '}\n', '\n', 'interface ERC20Interface {\n', '    // Get the total token supply\n', '    function totalSupply() constant external returns (uint256 _totalSupply);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract ixBackendEvents {\n', '    event NewDemoc(bytes32 democHash);\n', '    event ManuallyAddedDemoc(bytes32 democHash, address erc20);\n', '    event NewBallot(bytes32 indexed democHash, uint ballotN);\n', '    event DemocOwnerSet(bytes32 indexed democHash, address owner);\n', '    event DemocEditorSet(bytes32 indexed democHash, address editor, bool canEdit);\n', '    event DemocEditorsWiped(bytes32 indexed democHash);\n', '    event DemocErc20Set(bytes32 indexed democHash, address erc20);\n', '    event DemocDataSet(bytes32 indexed democHash, bytes32 keyHash);\n', '    event DemocCatAdded(bytes32 indexed democHash, uint catId);\n', '    event DemocCatDeprecated(bytes32 indexed democHash, uint catId);\n', '    event DemocCommunityBallotsEnabled(bytes32 indexed democHash, bool enabled);\n', '    event DemocErc20OwnerClaimDisabled(bytes32 indexed democHash);\n', '    event DemocClaimed(bytes32 indexed democHash);\n', '    event EmergencyDemocOwner(bytes32 indexed democHash, address newOwner);\n', '}\n', '\n', 'interface hasVersion {\n', '    function getVersion() external pure returns (uint);\n', '}\n', '\n', 'contract IxBackendIface is hasVersion, ixBackendEvents, permissioned, payoutAllC {\n', '    /* global getters */\n', '    function getGDemocsN() external view returns (uint);\n', '    function getGDemoc(uint id) external view returns (bytes32);\n', '    function getGErc20ToDemocs(address erc20) external view returns (bytes32[] democHashes);\n', '\n', '    /* owner functions */\n', '    function dAdd(bytes32 democHash, address erc20, bool disableErc20OwnerClaim) external;\n', '    function emergencySetDOwner(bytes32 democHash, address newOwner) external;\n', '\n', '    /* democ admin */\n', '    function dInit(address defaultErc20, address initOwner, bool disableErc20OwnerClaim) external returns (bytes32 democHash);\n', '    function setDOwner(bytes32 democHash, address newOwner) external;\n', '    function setDOwnerFromClaim(bytes32 democHash, address newOwner) external;\n', '    function setDEditor(bytes32 democHash, address editor, bool canEdit) external;\n', '    function setDNoEditors(bytes32 democHash) external;\n', '    function setDErc20(bytes32 democHash, address newErc20) external;\n', '    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external;\n', '    function dSetEditorArbitraryData(bytes32 democHash, bytes key, bytes value) external;\n', '    function dAddCategory(bytes32 democHash, bytes32 categoryName, bool hasParent, uint parent) external;\n', '    function dDeprecateCategory(bytes32 democHash, uint catId) external;\n', '    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) external;\n', '    function dDisableErc20OwnerClaim(bytes32 democHash) external;\n', '\n', '    /* actually add a ballot */\n', '    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) external;\n', '\n', '    /* global democ getters */\n', '    function getDOwner(bytes32 democHash) external view returns (address);\n', '    function isDEditor(bytes32 democHash, address editor) external view returns (bool);\n', '    function getDHash(bytes13 prefix) external view returns (bytes32);\n', '    function getDInfo(bytes32 democHash) external view returns (address erc20, address owner, uint256 nBallots);\n', '    function getDErc20(bytes32 democHash) external view returns (address);\n', '    function getDArbitraryData(bytes32 democHash, bytes key) external view returns (bytes value);\n', '    function getDEditorArbitraryData(bytes32 democHash, bytes key) external view returns (bytes value);\n', '    function getDBallotsN(bytes32 democHash) external view returns (uint256);\n', '    function getDBallotID(bytes32 democHash, uint n) external view returns (uint ballotId);\n', '    function getDCountedBasicBallotsN(bytes32 democHash) external view returns (uint256);\n', '    function getDCountedBasicBallotID(bytes32 democHash, uint256 n) external view returns (uint256);\n', '    function getDCategoriesN(bytes32 democHash) external view returns (uint);\n', '    function getDCategory(bytes32 democHash, uint catId) external view returns (bool deprecated, bytes32 name, bool hasParent, uint parent);\n', '    function getDCommBallotsEnabled(bytes32 democHash) external view returns (bool);\n', '    function getDErc20OwnerClaimEnabled(bytes32 democHash) external view returns (bool);\n', '}\n', '\n', 'contract SVIndexBackend is IxBackendIface {\n', '    uint constant VERSION = 2;\n', '\n', '    struct Democ {\n', '        address erc20;\n', '        address owner;\n', '        bool communityBallotsDisabled;\n', '        bool erc20OwnerClaimDisabled;\n', '        uint editorEpoch;\n', '        mapping (uint => mapping (address => bool)) editors;\n', '        uint256[] allBallots;\n', '        uint256[] includedBasicBallots;  // the IDs of official ballots\n', '\n', '    }\n', '\n', '    struct BallotRef {\n', '        bytes32 democHash;\n', '        uint ballotId;\n', '    }\n', '\n', '    struct Category {\n', '        bool deprecated;\n', '        bytes32 name;\n', '        bool hasParent;\n', '        uint parent;\n', '    }\n', '\n', '    struct CategoriesIx {\n', '        uint nCategories;\n', '        mapping(uint => Category) categories;\n', '    }\n', '\n', '    mapping (bytes32 => Democ) democs;\n', '    mapping (bytes32 => CategoriesIx) democCategories;\n', '    mapping (bytes13 => bytes32) democPrefixToHash;\n', '    mapping (address => bytes32[]) erc20ToDemocs;\n', '    bytes32[] democList;\n', '\n', '    // allows democ admins to store arbitrary data\n', '    // this lets us (for example) set particular keys to signal cerain\n', '    // things to client apps s.t. the admin can turn them on and off.\n', '    // arbitraryData[democHash][key]\n', '    mapping (bytes32 => mapping (bytes32 => bytes)) arbitraryData;\n', '\n', '    /* constructor */\n', '\n', '    constructor() payoutAllC(msg.sender) public {\n', '        // do nothing\n', '    }\n', '\n', '    /* base contract overloads */\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return owner;\n', '    }\n', '\n', '    function getVersion() external pure returns (uint) {\n', '        return VERSION;\n', '    }\n', '\n', '    /* GLOBAL INFO */\n', '\n', '    function getGDemocsN() external view returns (uint) {\n', '        return democList.length;\n', '    }\n', '\n', '    function getGDemoc(uint id) external view returns (bytes32) {\n', '        return democList[id];\n', '    }\n', '\n', '    function getGErc20ToDemocs(address erc20) external view returns (bytes32[] democHashes) {\n', '        return erc20ToDemocs[erc20];\n', '    }\n', '\n', '    /* DEMOCRACY ADMIN FUNCTIONS */\n', '\n', '    function _addDemoc(bytes32 democHash, address erc20, address initOwner, bool disableErc20OwnerClaim) internal {\n', '        democList.push(democHash);\n', '        Democ storage d = democs[democHash];\n', '        d.erc20 = erc20;\n', '        if (disableErc20OwnerClaim) {\n', '            d.erc20OwnerClaimDisabled = true;\n', '        }\n', '        // this should never trigger if we have a good security model - entropy for 13 bytes ~ 2^(8*13) ~ 10^31\n', '        assert(democPrefixToHash[bytes13(democHash)] == bytes32(0));\n', '        democPrefixToHash[bytes13(democHash)] = democHash;\n', '        erc20ToDemocs[erc20].push(democHash);\n', '        _setDOwner(democHash, initOwner);\n', '        emit NewDemoc(democHash);\n', '    }\n', '\n', '    /* owner democ admin functions */\n', '\n', '    function dAdd(bytes32 democHash, address erc20, bool disableErc20OwnerClaim) only_owner() external {\n', '        _addDemoc(democHash, erc20, msg.sender, disableErc20OwnerClaim);\n', '        emit ManuallyAddedDemoc(democHash, erc20);\n', '    }\n', '\n', '    /* Preferably for emergencies only */\n', '\n', '    function emergencySetDOwner(bytes32 democHash, address newOwner) only_owner() external {\n', '        _setDOwner(democHash, newOwner);\n', '        emit EmergencyDemocOwner(democHash, newOwner);\n', '    }\n', '\n', '    /* user democ admin functions */\n', '\n', '    function dInit(address defaultErc20, address initOwner, bool disableErc20OwnerClaim) only_editors() external returns (bytes32 democHash) {\n', '        // generating the democHash in this way guarentees it&#39;ll be unique/hard-to-brute-force\n', '        // (particularly because prevBlockHash and now are part of the hash)\n', '        democHash = keccak256(abi.encodePacked(democList.length, blockhash(block.number-1), defaultErc20, now));\n', '        _addDemoc(democHash, defaultErc20, initOwner, disableErc20OwnerClaim);\n', '    }\n', '\n', '    function _setDOwner(bytes32 democHash, address newOwner) internal {\n', '        Democ storage d = democs[democHash];\n', '        uint epoch = d.editorEpoch;\n', '        d.owner = newOwner;\n', '        // unset prev owner as editor - does little if one was not set\n', '        d.editors[epoch][d.owner] = false;\n', '        // make new owner an editor too\n', '        d.editors[epoch][newOwner] = true;\n', '        emit DemocOwnerSet(democHash, newOwner);\n', '    }\n', '\n', '    function setDOwner(bytes32 democHash, address newOwner) only_editors() external {\n', '        _setDOwner(democHash, newOwner);\n', '    }\n', '\n', '    function setDOwnerFromClaim(bytes32 democHash, address newOwner) only_editors() external {\n', '        Democ storage d = democs[democHash];\n', '        // make sure that the owner claim is enabled (i.e. the disabled flag is false)\n', '        require(d.erc20OwnerClaimDisabled == false, "!erc20-claim");\n', '        // set owner and editor\n', '        d.owner = newOwner;\n', '        d.editors[d.editorEpoch][newOwner] = true;\n', '        // disable the ability to claim now that it&#39;s done\n', '        d.erc20OwnerClaimDisabled = true;\n', '        emit DemocOwnerSet(democHash, newOwner);\n', '        emit DemocClaimed(democHash);\n', '    }\n', '\n', '    function setDEditor(bytes32 democHash, address editor, bool canEdit) only_editors() external {\n', '        Democ storage d = democs[democHash];\n', '        d.editors[d.editorEpoch][editor] = canEdit;\n', '        emit DemocEditorSet(democHash, editor, canEdit);\n', '    }\n', '\n', '    function setDNoEditors(bytes32 democHash) only_editors() external {\n', '        democs[democHash].editorEpoch += 1;\n', '        emit DemocEditorsWiped(democHash);\n', '    }\n', '\n', '    function setDErc20(bytes32 democHash, address newErc20) only_editors() external {\n', '        democs[democHash].erc20 = newErc20;\n', '        erc20ToDemocs[newErc20].push(democHash);\n', '        emit DemocErc20Set(democHash, newErc20);\n', '    }\n', '\n', '    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) only_editors() external {\n', '        bytes32 k = keccak256(key);\n', '        arbitraryData[democHash][k] = value;\n', '        emit DemocDataSet(democHash, k);\n', '    }\n', '\n', '    function dSetEditorArbitraryData(bytes32 democHash, bytes key, bytes value) only_editors() external {\n', '        bytes32 k = keccak256(_calcEditorKey(key));\n', '        arbitraryData[democHash][k] = value;\n', '        emit DemocDataSet(democHash, k);\n', '    }\n', '\n', '    function dAddCategory(bytes32 democHash, bytes32 name, bool hasParent, uint parent) only_editors() external {\n', '        uint catId = democCategories[democHash].nCategories;\n', '        democCategories[democHash].categories[catId].name = name;\n', '        if (hasParent) {\n', '            democCategories[democHash].categories[catId].hasParent = true;\n', '            democCategories[democHash].categories[catId].parent = parent;\n', '        }\n', '        democCategories[democHash].nCategories += 1;\n', '        emit DemocCatAdded(democHash, catId);\n', '    }\n', '\n', '    function dDeprecateCategory(bytes32 democHash, uint catId) only_editors() external {\n', '        democCategories[democHash].categories[catId].deprecated = true;\n', '        emit DemocCatDeprecated(democHash, catId);\n', '    }\n', '\n', '    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) only_editors() external {\n', '        democs[democHash].communityBallotsDisabled = !enabled;\n', '        emit DemocCommunityBallotsEnabled(democHash, enabled);\n', '    }\n', '\n', '    function dDisableErc20OwnerClaim(bytes32 democHash) only_editors() external {\n', '        democs[democHash].erc20OwnerClaimDisabled = true;\n', '        emit DemocErc20OwnerClaimDisabled(democHash);\n', '    }\n', '\n', '    //* ADD BALLOT TO RECORD */\n', '\n', '    function _commitBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) internal {\n', '        uint16 subBits;\n', '        subBits = BPackedUtils.packedToSubmissionBits(packed);\n', '\n', '        uint localBallotId = democs[democHash].allBallots.length;\n', '        democs[democHash].allBallots.push(ballotId);\n', '\n', '        // do this for anything that doesn&#39;t qualify as a community ballot\n', '        if (countTowardsLimit) {\n', '            democs[democHash].includedBasicBallots.push(ballotId);\n', '        }\n', '\n', '        emit NewBallot(democHash, localBallotId);\n', '    }\n', '\n', '    // what SVIndex uses to add a ballot\n', '    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) only_editors() external {\n', '        _commitBallot(democHash, ballotId, packed, countTowardsLimit);\n', '    }\n', '\n', '    /* democ getters */\n', '\n', '    function getDOwner(bytes32 democHash) external view returns (address) {\n', '        return democs[democHash].owner;\n', '    }\n', '\n', '    function isDEditor(bytes32 democHash, address editor) external view returns (bool) {\n', '        Democ storage d = democs[democHash];\n', '        // allow either an editor or always the owner\n', '        return d.editors[d.editorEpoch][editor] || editor == d.owner;\n', '    }\n', '\n', '    function getDHash(bytes13 prefix) external view returns (bytes32) {\n', '        return democPrefixToHash[prefix];\n', '    }\n', '\n', '    function getDInfo(bytes32 democHash) external view returns (address erc20, address owner, uint256 nBallots) {\n', '        return (democs[democHash].erc20, democs[democHash].owner, democs[democHash].allBallots.length);\n', '    }\n', '\n', '    function getDErc20(bytes32 democHash) external view returns (address) {\n', '        return democs[democHash].erc20;\n', '    }\n', '\n', '    function getDArbitraryData(bytes32 democHash, bytes key) external view returns (bytes) {\n', '        return arbitraryData[democHash][keccak256(key)];\n', '    }\n', '\n', '    function getDEditorArbitraryData(bytes32 democHash, bytes key) external view returns (bytes) {\n', '        return arbitraryData[democHash][keccak256(_calcEditorKey(key))];\n', '    }\n', '\n', '    function getDBallotsN(bytes32 democHash) external view returns (uint256) {\n', '        return democs[democHash].allBallots.length;\n', '    }\n', '\n', '    function getDBallotID(bytes32 democHash, uint256 n) external view returns (uint ballotId) {\n', '        return democs[democHash].allBallots[n];\n', '    }\n', '\n', '    function getDCountedBasicBallotsN(bytes32 democHash) external view returns (uint256) {\n', '        return democs[democHash].includedBasicBallots.length;\n', '    }\n', '\n', '    function getDCountedBasicBallotID(bytes32 democHash, uint256 n) external view returns (uint256) {\n', '        return democs[democHash].includedBasicBallots[n];\n', '    }\n', '\n', '    function getDCategoriesN(bytes32 democHash) external view returns (uint) {\n', '        return democCategories[democHash].nCategories;\n', '    }\n', '\n', '    function getDCategory(bytes32 democHash, uint catId) external view returns (bool deprecated, bytes32 name, bool hasParent, uint256 parent) {\n', '        deprecated = democCategories[democHash].categories[catId].deprecated;\n', '        name = democCategories[democHash].categories[catId].name;\n', '        hasParent = democCategories[democHash].categories[catId].hasParent;\n', '        parent = democCategories[democHash].categories[catId].parent;\n', '    }\n', '\n', '    function getDCommBallotsEnabled(bytes32 democHash) external view returns (bool) {\n', '        return !democs[democHash].communityBallotsDisabled;\n', '    }\n', '\n', '    function getDErc20OwnerClaimEnabled(bytes32 democHash) external view returns (bool) {\n', '        return !democs[democHash].erc20OwnerClaimDisabled;\n', '    }\n', '\n', '    /* util for calculating editor key */\n', '\n', '    function _calcEditorKey(bytes key) internal pure returns (bytes) {\n', '        return abi.encodePacked("editor.", key);\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'library BPackedUtils {\n', '\n', '    // the uint16 ending at 128 bits should be 0s\n', '    uint256 constant sbMask        = 0xffffffffffffffffffffffffffff0000ffffffffffffffffffffffffffffffff;\n', '    uint256 constant startTimeMask = 0xffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff;\n', '    uint256 constant endTimeMask   = 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000;\n', '\n', '    function packedToSubmissionBits(uint256 packed) internal pure returns (uint16) {\n', '        return uint16(packed >> 128);\n', '    }\n', '\n', '    function packedToStartTime(uint256 packed) internal pure returns (uint64) {\n', '        return uint64(packed >> 64);\n', '    }\n', '\n', '    function packedToEndTime(uint256 packed) internal pure returns (uint64) {\n', '        return uint64(packed);\n', '    }\n', '\n', '    function unpackAll(uint256 packed) internal pure returns (uint16 submissionBits, uint64 startTime, uint64 endTime) {\n', '        submissionBits = uint16(packed >> 128);\n', '        startTime = uint64(packed >> 64);\n', '        endTime = uint64(packed);\n', '    }\n', '\n', '    function pack(uint16 sb, uint64 st, uint64 et) internal pure returns (uint256 packed) {\n', '        return uint256(sb) << 128 | uint256(st) << 64 | uint256(et);\n', '    }\n', '\n', '    function setSB(uint256 packed, uint16 newSB) internal pure returns (uint256) {\n', '        return (packed & sbMask) | uint256(newSB) << 128;\n', '    }\n', '\n', '    // function setStartTime(uint256 packed, uint64 startTime) internal pure returns (uint256) {\n', '    //     return (packed & startTimeMask) | uint256(startTime) << 64;\n', '    // }\n', '\n', '    // function setEndTime(uint256 packed, uint64 endTime) internal pure returns (uint256) {\n', '    //     return (packed & endTimeMask) | uint256(endTime);\n', '    // }\n', '}\n', '\n', 'contract safeSend {\n', '    bool private txMutex3847834;\n', '\n', '    // we want to be able to call outside contracts (e.g. the admin proxy contract)\n', "    // but reentrency is bad, so here's a mutex.\n", '    function doSafeSend(address toAddr, uint amount) internal {\n', '        doSafeSendWData(toAddr, "", amount);\n', '    }\n', '\n', '    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\n', '        require(txMutex3847834 == false, "ss-guard");\n', '        txMutex3847834 = true;\n', '        // we need to use address.call.value(v)() because we want\n', '        // to be able to send to other contracts, even with no data,\n', '        // which might use more than 2300 gas in their fallback function.\n', '        require(toAddr.call.value(amount)(data), "ss-failed");\n', '        txMutex3847834 = false;\n', '    }\n', '}\n', '\n', 'contract payoutAllC is safeSend {\n', '    address private _payTo;\n', '\n', '    event PayoutAll(address payTo, uint value);\n', '\n', '    constructor(address initPayTo) public {\n', '        // DEV NOTE: you can overwrite _getPayTo if you want to reuse other storage vars\n', '        assert(initPayTo != address(0));\n', '        _payTo = initPayTo;\n', '    }\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return _payTo;\n', '    }\n', '\n', '    function _setPayTo(address newPayTo) internal {\n', '        _payTo = newPayTo;\n', '    }\n', '\n', '    function payoutAll() external {\n', '        address a = _getPayTo();\n', '        uint bal = address(this).balance;\n', '        doSafeSend(a, bal);\n', '        emit PayoutAll(a, bal);\n', '    }\n', '}\n', '\n', 'contract payoutAllCSettable is payoutAllC {\n', '    constructor (address initPayTo) payoutAllC(initPayTo) public {\n', '    }\n', '\n', '    function setPayTo(address) external;\n', '    function getPayTo() external view returns (address) {\n', '        return _getPayTo();\n', '    }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address newOwner);\n', '\n', '    modifier only_owner() {\n', '        require(msg.sender == owner, "only_owner: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier owner_or(address addr) {\n', '        require(msg.sender == addr || msg.sender == owner, "!owner-or");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address newOwner) only_owner() external {\n', '        owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '}\n', '\n', 'contract controlledIface {\n', '    function controller() external view returns (address);\n', '}\n', '\n', 'contract hasAdmins is owned {\n', '    mapping (uint => mapping (address => bool)) admins;\n', '    uint public currAdminEpoch = 0;\n', '    bool public adminsDisabledForever = false;\n', '    address[] adminLog;\n', '\n', '    event AdminAdded(address indexed newAdmin);\n', '    event AdminRemoved(address indexed oldAdmin);\n', '    event AdminEpochInc();\n', '    event AdminDisabledForever();\n', '\n', '    modifier only_admin() {\n', '        require(adminsDisabledForever == false, "admins must not be disabled");\n', '        require(isAdmin(msg.sender), "only_admin: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        _setAdmin(msg.sender, true);\n', '    }\n', '\n', '    function isAdmin(address a) view public returns (bool) {\n', '        return admins[currAdminEpoch][a];\n', '    }\n', '\n', '    function getAdminLogN() view external returns (uint) {\n', '        return adminLog.length;\n', '    }\n', '\n', '    function getAdminLog(uint n) view external returns (address) {\n', '        return adminLog[n];\n', '    }\n', '\n', '    function upgradeMeAdmin(address newAdmin) only_admin() external {\n', '        // note: already checked msg.sender has admin with `only_admin` modifier\n', '        require(msg.sender != owner, "owner cannot upgrade self");\n', '        _setAdmin(msg.sender, false);\n', '        _setAdmin(newAdmin, true);\n', '    }\n', '\n', '    function setAdmin(address a, bool _givePerms) only_admin() external {\n', '        require(a != msg.sender && a != owner, "cannot change your own (or owner\'s) permissions");\n', '        _setAdmin(a, _givePerms);\n', '    }\n', '\n', '    function _setAdmin(address a, bool _givePerms) internal {\n', '        admins[currAdminEpoch][a] = _givePerms;\n', '        if (_givePerms) {\n', '            emit AdminAdded(a);\n', '            adminLog.push(a);\n', '        } else {\n', '            emit AdminRemoved(a);\n', '        }\n', '    }\n', '\n', '    // safety feature if admins go bad or something\n', '    function incAdminEpoch() only_owner() external {\n', '        currAdminEpoch++;\n', '        admins[currAdminEpoch][msg.sender] = true;\n', '        emit AdminEpochInc();\n', '    }\n', '\n', '    // this is internal so contracts can all it, but not exposed anywhere in this\n', '    // contract.\n', '    function disableAdminForever() internal {\n', '        currAdminEpoch++;\n', '        adminsDisabledForever = true;\n', '        emit AdminDisabledForever();\n', '    }\n', '}\n', '\n', 'contract permissioned is owned, hasAdmins {\n', '    mapping (address => bool) editAllowed;\n', '    bool public adminLockdown = false;\n', '\n', '    event PermissionError(address editAddr);\n', '    event PermissionGranted(address editAddr);\n', '    event PermissionRevoked(address editAddr);\n', '    event PermissionsUpgraded(address oldSC, address newSC);\n', '    event SelfUpgrade(address oldSC, address newSC);\n', '    event AdminLockdown();\n', '\n', '    modifier only_editors() {\n', '        require(editAllowed[msg.sender], "only_editors: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier no_lockdown() {\n', '        require(adminLockdown == false, "no_lockdown: check failed");\n', '        _;\n', '    }\n', '\n', '\n', '    constructor() owned() hasAdmins() public {\n', '    }\n', '\n', '\n', '    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\n', '        editAllowed[e] = _editPerms;\n', '        if (_editPerms)\n', '            emit PermissionGranted(e);\n', '        else\n', '            emit PermissionRevoked(e);\n', '    }\n', '\n', '    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\n', '        editAllowed[oldSC] = false;\n', '        editAllowed[newSC] = true;\n', '        emit PermissionsUpgraded(oldSC, newSC);\n', '    }\n', '\n', '    // always allow SCs to upgrade themselves, even after lockdown\n', '    function upgradeMe(address newSC) only_editors() external {\n', '        editAllowed[msg.sender] = false;\n', '        editAllowed[newSC] = true;\n', '        emit SelfUpgrade(msg.sender, newSC);\n', '    }\n', '\n', '    function hasPermissions(address a) public view returns (bool) {\n', '        return editAllowed[a];\n', '    }\n', '\n', '    function doLockdown() external only_owner() no_lockdown() {\n', '        disableAdminForever();\n', '        adminLockdown = true;\n', '        emit AdminLockdown();\n', '    }\n', '}\n', '\n', 'contract upgradePtr {\n', '    address ptr = address(0);\n', '\n', '    modifier not_upgraded() {\n', '        require(ptr == address(0), "upgrade pointer is non-zero");\n', '        _;\n', '    }\n', '\n', '    function getUpgradePointer() view external returns (address) {\n', '        return ptr;\n', '    }\n', '\n', '    function doUpgradeInternal(address nextSC) internal {\n', '        ptr = nextSC;\n', '    }\n', '}\n', '\n', 'interface ERC20Interface {\n', '    // Get the total token supply\n', '    function totalSupply() constant external returns (uint256 _totalSupply);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract ixBackendEvents {\n', '    event NewDemoc(bytes32 democHash);\n', '    event ManuallyAddedDemoc(bytes32 democHash, address erc20);\n', '    event NewBallot(bytes32 indexed democHash, uint ballotN);\n', '    event DemocOwnerSet(bytes32 indexed democHash, address owner);\n', '    event DemocEditorSet(bytes32 indexed democHash, address editor, bool canEdit);\n', '    event DemocEditorsWiped(bytes32 indexed democHash);\n', '    event DemocErc20Set(bytes32 indexed democHash, address erc20);\n', '    event DemocDataSet(bytes32 indexed democHash, bytes32 keyHash);\n', '    event DemocCatAdded(bytes32 indexed democHash, uint catId);\n', '    event DemocCatDeprecated(bytes32 indexed democHash, uint catId);\n', '    event DemocCommunityBallotsEnabled(bytes32 indexed democHash, bool enabled);\n', '    event DemocErc20OwnerClaimDisabled(bytes32 indexed democHash);\n', '    event DemocClaimed(bytes32 indexed democHash);\n', '    event EmergencyDemocOwner(bytes32 indexed democHash, address newOwner);\n', '}\n', '\n', 'interface hasVersion {\n', '    function getVersion() external pure returns (uint);\n', '}\n', '\n', 'contract IxBackendIface is hasVersion, ixBackendEvents, permissioned, payoutAllC {\n', '    /* global getters */\n', '    function getGDemocsN() external view returns (uint);\n', '    function getGDemoc(uint id) external view returns (bytes32);\n', '    function getGErc20ToDemocs(address erc20) external view returns (bytes32[] democHashes);\n', '\n', '    /* owner functions */\n', '    function dAdd(bytes32 democHash, address erc20, bool disableErc20OwnerClaim) external;\n', '    function emergencySetDOwner(bytes32 democHash, address newOwner) external;\n', '\n', '    /* democ admin */\n', '    function dInit(address defaultErc20, address initOwner, bool disableErc20OwnerClaim) external returns (bytes32 democHash);\n', '    function setDOwner(bytes32 democHash, address newOwner) external;\n', '    function setDOwnerFromClaim(bytes32 democHash, address newOwner) external;\n', '    function setDEditor(bytes32 democHash, address editor, bool canEdit) external;\n', '    function setDNoEditors(bytes32 democHash) external;\n', '    function setDErc20(bytes32 democHash, address newErc20) external;\n', '    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external;\n', '    function dSetEditorArbitraryData(bytes32 democHash, bytes key, bytes value) external;\n', '    function dAddCategory(bytes32 democHash, bytes32 categoryName, bool hasParent, uint parent) external;\n', '    function dDeprecateCategory(bytes32 democHash, uint catId) external;\n', '    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) external;\n', '    function dDisableErc20OwnerClaim(bytes32 democHash) external;\n', '\n', '    /* actually add a ballot */\n', '    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) external;\n', '\n', '    /* global democ getters */\n', '    function getDOwner(bytes32 democHash) external view returns (address);\n', '    function isDEditor(bytes32 democHash, address editor) external view returns (bool);\n', '    function getDHash(bytes13 prefix) external view returns (bytes32);\n', '    function getDInfo(bytes32 democHash) external view returns (address erc20, address owner, uint256 nBallots);\n', '    function getDErc20(bytes32 democHash) external view returns (address);\n', '    function getDArbitraryData(bytes32 democHash, bytes key) external view returns (bytes value);\n', '    function getDEditorArbitraryData(bytes32 democHash, bytes key) external view returns (bytes value);\n', '    function getDBallotsN(bytes32 democHash) external view returns (uint256);\n', '    function getDBallotID(bytes32 democHash, uint n) external view returns (uint ballotId);\n', '    function getDCountedBasicBallotsN(bytes32 democHash) external view returns (uint256);\n', '    function getDCountedBasicBallotID(bytes32 democHash, uint256 n) external view returns (uint256);\n', '    function getDCategoriesN(bytes32 democHash) external view returns (uint);\n', '    function getDCategory(bytes32 democHash, uint catId) external view returns (bool deprecated, bytes32 name, bool hasParent, uint parent);\n', '    function getDCommBallotsEnabled(bytes32 democHash) external view returns (bool);\n', '    function getDErc20OwnerClaimEnabled(bytes32 democHash) external view returns (bool);\n', '}\n', '\n', 'contract SVIndexBackend is IxBackendIface {\n', '    uint constant VERSION = 2;\n', '\n', '    struct Democ {\n', '        address erc20;\n', '        address owner;\n', '        bool communityBallotsDisabled;\n', '        bool erc20OwnerClaimDisabled;\n', '        uint editorEpoch;\n', '        mapping (uint => mapping (address => bool)) editors;\n', '        uint256[] allBallots;\n', '        uint256[] includedBasicBallots;  // the IDs of official ballots\n', '\n', '    }\n', '\n', '    struct BallotRef {\n', '        bytes32 democHash;\n', '        uint ballotId;\n', '    }\n', '\n', '    struct Category {\n', '        bool deprecated;\n', '        bytes32 name;\n', '        bool hasParent;\n', '        uint parent;\n', '    }\n', '\n', '    struct CategoriesIx {\n', '        uint nCategories;\n', '        mapping(uint => Category) categories;\n', '    }\n', '\n', '    mapping (bytes32 => Democ) democs;\n', '    mapping (bytes32 => CategoriesIx) democCategories;\n', '    mapping (bytes13 => bytes32) democPrefixToHash;\n', '    mapping (address => bytes32[]) erc20ToDemocs;\n', '    bytes32[] democList;\n', '\n', '    // allows democ admins to store arbitrary data\n', '    // this lets us (for example) set particular keys to signal cerain\n', '    // things to client apps s.t. the admin can turn them on and off.\n', '    // arbitraryData[democHash][key]\n', '    mapping (bytes32 => mapping (bytes32 => bytes)) arbitraryData;\n', '\n', '    /* constructor */\n', '\n', '    constructor() payoutAllC(msg.sender) public {\n', '        // do nothing\n', '    }\n', '\n', '    /* base contract overloads */\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return owner;\n', '    }\n', '\n', '    function getVersion() external pure returns (uint) {\n', '        return VERSION;\n', '    }\n', '\n', '    /* GLOBAL INFO */\n', '\n', '    function getGDemocsN() external view returns (uint) {\n', '        return democList.length;\n', '    }\n', '\n', '    function getGDemoc(uint id) external view returns (bytes32) {\n', '        return democList[id];\n', '    }\n', '\n', '    function getGErc20ToDemocs(address erc20) external view returns (bytes32[] democHashes) {\n', '        return erc20ToDemocs[erc20];\n', '    }\n', '\n', '    /* DEMOCRACY ADMIN FUNCTIONS */\n', '\n', '    function _addDemoc(bytes32 democHash, address erc20, address initOwner, bool disableErc20OwnerClaim) internal {\n', '        democList.push(democHash);\n', '        Democ storage d = democs[democHash];\n', '        d.erc20 = erc20;\n', '        if (disableErc20OwnerClaim) {\n', '            d.erc20OwnerClaimDisabled = true;\n', '        }\n', '        // this should never trigger if we have a good security model - entropy for 13 bytes ~ 2^(8*13) ~ 10^31\n', '        assert(democPrefixToHash[bytes13(democHash)] == bytes32(0));\n', '        democPrefixToHash[bytes13(democHash)] = democHash;\n', '        erc20ToDemocs[erc20].push(democHash);\n', '        _setDOwner(democHash, initOwner);\n', '        emit NewDemoc(democHash);\n', '    }\n', '\n', '    /* owner democ admin functions */\n', '\n', '    function dAdd(bytes32 democHash, address erc20, bool disableErc20OwnerClaim) only_owner() external {\n', '        _addDemoc(democHash, erc20, msg.sender, disableErc20OwnerClaim);\n', '        emit ManuallyAddedDemoc(democHash, erc20);\n', '    }\n', '\n', '    /* Preferably for emergencies only */\n', '\n', '    function emergencySetDOwner(bytes32 democHash, address newOwner) only_owner() external {\n', '        _setDOwner(democHash, newOwner);\n', '        emit EmergencyDemocOwner(democHash, newOwner);\n', '    }\n', '\n', '    /* user democ admin functions */\n', '\n', '    function dInit(address defaultErc20, address initOwner, bool disableErc20OwnerClaim) only_editors() external returns (bytes32 democHash) {\n', "        // generating the democHash in this way guarentees it'll be unique/hard-to-brute-force\n", '        // (particularly because prevBlockHash and now are part of the hash)\n', '        democHash = keccak256(abi.encodePacked(democList.length, blockhash(block.number-1), defaultErc20, now));\n', '        _addDemoc(democHash, defaultErc20, initOwner, disableErc20OwnerClaim);\n', '    }\n', '\n', '    function _setDOwner(bytes32 democHash, address newOwner) internal {\n', '        Democ storage d = democs[democHash];\n', '        uint epoch = d.editorEpoch;\n', '        d.owner = newOwner;\n', '        // unset prev owner as editor - does little if one was not set\n', '        d.editors[epoch][d.owner] = false;\n', '        // make new owner an editor too\n', '        d.editors[epoch][newOwner] = true;\n', '        emit DemocOwnerSet(democHash, newOwner);\n', '    }\n', '\n', '    function setDOwner(bytes32 democHash, address newOwner) only_editors() external {\n', '        _setDOwner(democHash, newOwner);\n', '    }\n', '\n', '    function setDOwnerFromClaim(bytes32 democHash, address newOwner) only_editors() external {\n', '        Democ storage d = democs[democHash];\n', '        // make sure that the owner claim is enabled (i.e. the disabled flag is false)\n', '        require(d.erc20OwnerClaimDisabled == false, "!erc20-claim");\n', '        // set owner and editor\n', '        d.owner = newOwner;\n', '        d.editors[d.editorEpoch][newOwner] = true;\n', "        // disable the ability to claim now that it's done\n", '        d.erc20OwnerClaimDisabled = true;\n', '        emit DemocOwnerSet(democHash, newOwner);\n', '        emit DemocClaimed(democHash);\n', '    }\n', '\n', '    function setDEditor(bytes32 democHash, address editor, bool canEdit) only_editors() external {\n', '        Democ storage d = democs[democHash];\n', '        d.editors[d.editorEpoch][editor] = canEdit;\n', '        emit DemocEditorSet(democHash, editor, canEdit);\n', '    }\n', '\n', '    function setDNoEditors(bytes32 democHash) only_editors() external {\n', '        democs[democHash].editorEpoch += 1;\n', '        emit DemocEditorsWiped(democHash);\n', '    }\n', '\n', '    function setDErc20(bytes32 democHash, address newErc20) only_editors() external {\n', '        democs[democHash].erc20 = newErc20;\n', '        erc20ToDemocs[newErc20].push(democHash);\n', '        emit DemocErc20Set(democHash, newErc20);\n', '    }\n', '\n', '    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) only_editors() external {\n', '        bytes32 k = keccak256(key);\n', '        arbitraryData[democHash][k] = value;\n', '        emit DemocDataSet(democHash, k);\n', '    }\n', '\n', '    function dSetEditorArbitraryData(bytes32 democHash, bytes key, bytes value) only_editors() external {\n', '        bytes32 k = keccak256(_calcEditorKey(key));\n', '        arbitraryData[democHash][k] = value;\n', '        emit DemocDataSet(democHash, k);\n', '    }\n', '\n', '    function dAddCategory(bytes32 democHash, bytes32 name, bool hasParent, uint parent) only_editors() external {\n', '        uint catId = democCategories[democHash].nCategories;\n', '        democCategories[democHash].categories[catId].name = name;\n', '        if (hasParent) {\n', '            democCategories[democHash].categories[catId].hasParent = true;\n', '            democCategories[democHash].categories[catId].parent = parent;\n', '        }\n', '        democCategories[democHash].nCategories += 1;\n', '        emit DemocCatAdded(democHash, catId);\n', '    }\n', '\n', '    function dDeprecateCategory(bytes32 democHash, uint catId) only_editors() external {\n', '        democCategories[democHash].categories[catId].deprecated = true;\n', '        emit DemocCatDeprecated(democHash, catId);\n', '    }\n', '\n', '    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) only_editors() external {\n', '        democs[democHash].communityBallotsDisabled = !enabled;\n', '        emit DemocCommunityBallotsEnabled(democHash, enabled);\n', '    }\n', '\n', '    function dDisableErc20OwnerClaim(bytes32 democHash) only_editors() external {\n', '        democs[democHash].erc20OwnerClaimDisabled = true;\n', '        emit DemocErc20OwnerClaimDisabled(democHash);\n', '    }\n', '\n', '    //* ADD BALLOT TO RECORD */\n', '\n', '    function _commitBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) internal {\n', '        uint16 subBits;\n', '        subBits = BPackedUtils.packedToSubmissionBits(packed);\n', '\n', '        uint localBallotId = democs[democHash].allBallots.length;\n', '        democs[democHash].allBallots.push(ballotId);\n', '\n', "        // do this for anything that doesn't qualify as a community ballot\n", '        if (countTowardsLimit) {\n', '            democs[democHash].includedBasicBallots.push(ballotId);\n', '        }\n', '\n', '        emit NewBallot(democHash, localBallotId);\n', '    }\n', '\n', '    // what SVIndex uses to add a ballot\n', '    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) only_editors() external {\n', '        _commitBallot(democHash, ballotId, packed, countTowardsLimit);\n', '    }\n', '\n', '    /* democ getters */\n', '\n', '    function getDOwner(bytes32 democHash) external view returns (address) {\n', '        return democs[democHash].owner;\n', '    }\n', '\n', '    function isDEditor(bytes32 democHash, address editor) external view returns (bool) {\n', '        Democ storage d = democs[democHash];\n', '        // allow either an editor or always the owner\n', '        return d.editors[d.editorEpoch][editor] || editor == d.owner;\n', '    }\n', '\n', '    function getDHash(bytes13 prefix) external view returns (bytes32) {\n', '        return democPrefixToHash[prefix];\n', '    }\n', '\n', '    function getDInfo(bytes32 democHash) external view returns (address erc20, address owner, uint256 nBallots) {\n', '        return (democs[democHash].erc20, democs[democHash].owner, democs[democHash].allBallots.length);\n', '    }\n', '\n', '    function getDErc20(bytes32 democHash) external view returns (address) {\n', '        return democs[democHash].erc20;\n', '    }\n', '\n', '    function getDArbitraryData(bytes32 democHash, bytes key) external view returns (bytes) {\n', '        return arbitraryData[democHash][keccak256(key)];\n', '    }\n', '\n', '    function getDEditorArbitraryData(bytes32 democHash, bytes key) external view returns (bytes) {\n', '        return arbitraryData[democHash][keccak256(_calcEditorKey(key))];\n', '    }\n', '\n', '    function getDBallotsN(bytes32 democHash) external view returns (uint256) {\n', '        return democs[democHash].allBallots.length;\n', '    }\n', '\n', '    function getDBallotID(bytes32 democHash, uint256 n) external view returns (uint ballotId) {\n', '        return democs[democHash].allBallots[n];\n', '    }\n', '\n', '    function getDCountedBasicBallotsN(bytes32 democHash) external view returns (uint256) {\n', '        return democs[democHash].includedBasicBallots.length;\n', '    }\n', '\n', '    function getDCountedBasicBallotID(bytes32 democHash, uint256 n) external view returns (uint256) {\n', '        return democs[democHash].includedBasicBallots[n];\n', '    }\n', '\n', '    function getDCategoriesN(bytes32 democHash) external view returns (uint) {\n', '        return democCategories[democHash].nCategories;\n', '    }\n', '\n', '    function getDCategory(bytes32 democHash, uint catId) external view returns (bool deprecated, bytes32 name, bool hasParent, uint256 parent) {\n', '        deprecated = democCategories[democHash].categories[catId].deprecated;\n', '        name = democCategories[democHash].categories[catId].name;\n', '        hasParent = democCategories[democHash].categories[catId].hasParent;\n', '        parent = democCategories[democHash].categories[catId].parent;\n', '    }\n', '\n', '    function getDCommBallotsEnabled(bytes32 democHash) external view returns (bool) {\n', '        return !democs[democHash].communityBallotsDisabled;\n', '    }\n', '\n', '    function getDErc20OwnerClaimEnabled(bytes32 democHash) external view returns (bool) {\n', '        return !democs[democHash].erc20OwnerClaimDisabled;\n', '    }\n', '\n', '    /* util for calculating editor key */\n', '\n', '    function _calcEditorKey(bytes key) internal pure returns (bytes) {\n', '        return abi.encodePacked("editor.", key);\n', '    }\n', '}']
