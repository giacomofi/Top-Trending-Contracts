['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract Queue {\n', '    using SafeMath for uint256;\n', '    address[] users;\n', '    mapping(address => bool) usersExist;\n', '    mapping(address => address) users2users;\n', '    mapping(address => uint256) collectBalances;\n', '    mapping(address => uint256) balances;\n', '    mapping(address => uint256) balancesTotal;\n', '    uint256 nextForwardUserId = 0;\n', '    uint256 nextBackUserId = 0;\n', '    uint256 cyles = 50;\n', '    uint256 interes = 10 finney;\n', '    uint256 reminder=0;\n', '    uint256 price = 20 finney;\n', '    uint256 referalBonus = 5 finney;\n', '    uint256 queueInteres = 100 szabo;\n', '    address to;\n', '    uint256 collect = 30 finney;\n', '    \n', '    event QueueStart(address indexed user, address indexed parentUser, uint256 indexed timeshtamp);\n', '    event BalanceUp(address indexed user, uint256 amount, uint256 indexed timeshtamp);\n', '    event GetMyMoney(address indexed user, uint256 amount, uint256 indexed timeshtamp);\n', '    \n', '    function () payable public {\n', '        msg.sender.transfer(msg.value);\n', '    }\n', '    \n', '    function startQueue(address parentUser) payable public {\n', '        require(msg.value == price);\n', '        require(msg.sender != address(0));\n', '        require(parentUser != address(0));\n', '        require(!usersExist[msg.sender]);\n', '        _queue(msg.sender, parentUser);\n', '    }\n', '    \n', '    function serchIndexByAddress(address a) public view returns (uint256 index) {\n', '        for(index=0; index<users.length; index++) {\n', '            if(a == users[index]){\n', '                return index;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function _removeIndex(uint256 indexToRemove) internal {\n', '        if (indexToRemove >= users.length) return;\n', '\n', '        for (uint i = indexToRemove; i<users.length-1; i++){\n', '            users[i] = users[i+1];\n', '        }\n', '        delete users[users.length-1];\n', '        users.length--;\n', '    }\n', '    \n', '    function _queue(address user, address parentUser) internal {\n', '        if (user != address(0x9a965e5e9c3A0F062C80a7f3d1B0972201b2F19f) ) {\n', '            require(parentUser!=user);\n', '            require(usersExist[parentUser]);\n', '        }\n', '        users.push(user);\n', '        usersExist[user]=true;\n', '        users2users[user]=parentUser;\n', '        emit QueueStart(user, parentUser, now);\n', '        \n', '        if (collectBalances[parentUser].add(referalBonus) >= collect){\n', '            reminder = collectBalances[parentUser].add(referalBonus) - collect;\n', '            balancesTotal[parentUser] = balancesTotal[parentUser].add(interes);\n', '            balances[parentUser] = balances[parentUser].add(interes);\n', '            emit BalanceUp(parentUser, interes, now);\n', '            collectBalances[parentUser] = reminder;\n', '            to = parentUser;\n', '            _removeIndex(serchIndexByAddress(parentUser));\n', '            _queue(to, users2users[to]);\n', '        }else{\n', '            collectBalances[parentUser] = collectBalances[parentUser].add(referalBonus);\n', '        }\n', '        \n', '        if (collectBalances[users2users[parentUser]].add(referalBonus) >= collect){\n', '            reminder = collectBalances[users2users[parentUser]].add(referalBonus) - collect;\n', '            balancesTotal[users2users[parentUser]] = balancesTotal[users2users[parentUser]].add(interes);\n', '            balances[users2users[parentUser]] = balances[users2users[parentUser]].add(interes);\n', '            emit BalanceUp(users2users[parentUser], interes, now);\n', '            collectBalances[users2users[parentUser]] = reminder;\n', '            to = users2users[parentUser];\n', '            _removeIndex(serchIndexByAddress(users2users[parentUser]));\n', '            _queue(to, users2users[to]);\n', '        }else{\n', '            collectBalances[users2users[parentUser]] = collectBalances[users2users[parentUser]].add(referalBonus);\n', '        }\n', '        \n', '        uint256 length = users.length;\n', '        uint256 existLastIndex = length.sub(1);\n', '        uint256 firstHalfEnd = 0;\n', '        uint256 secondHalfStart = 0;\n', '        \n', '        if (length == 1 ){\n', '            collectBalances[users[0]] = collectBalances[users[0]].add(queueInteres.mul(cyles.mul(2)));\n', '        }else{\n', '            if (length % 2 != 0) {\n', '                firstHalfEnd  = length.div(2);\n', '                secondHalfStart  = length.div(2);\n', '            }else{\n', '                firstHalfEnd  = length.div(2).sub(1);\n', '                secondHalfStart  = length.div(2);\n', '            }\n', '            \n', '            for (uint i = 1; i <= cyles; i++) {\n', '                if(collectBalances[users[nextForwardUserId]].add(queueInteres) >= collect){\n', '                    reminder = collectBalances[users[nextForwardUserId]].add(queueInteres) - collect;\n', '                    balancesTotal[users[nextForwardUserId]] = balancesTotal[users[nextForwardUserId]].add(interes);\n', '                    balances[users[nextForwardUserId]] = balances[users[nextForwardUserId]].add(interes);\n', '                    collectBalances[users[nextForwardUserId]] = reminder;\n', '                    emit BalanceUp(users[nextForwardUserId], interes, now);\n', '                    to = users[nextForwardUserId];\n', '                    _removeIndex(serchIndexByAddress(users[nextForwardUserId]));\n', '                    _queue(to, users2users[to]);\n', '                    if (nextForwardUserId == 0){\n', '                        nextForwardUserId = firstHalfEnd;\n', '                    }else{\n', '                        nextForwardUserId = nextForwardUserId.sub(1);\n', '                    }\n', '                }else{\n', '                    collectBalances[users[nextForwardUserId]] = collectBalances[users[nextForwardUserId]].add(queueInteres);\n', '                }\n', '                if(collectBalances[users[nextBackUserId]].add(queueInteres) == collect){\n', '                    reminder = collectBalances[users[nextBackUserId]].add(queueInteres) - collect;\n', '                    balancesTotal[users[nextBackUserId]] = balancesTotal[users[nextBackUserId]].add(interes);\n', '                    balances[users[nextBackUserId]] = balances[users[nextBackUserId]].add(interes);\n', '                    collectBalances[users[nextBackUserId]] = reminder;\n', '                    emit BalanceUp(users[nextBackUserId], interes, now);\n', '                    to = users[nextBackUserId];\n', '                    _removeIndex(serchIndexByAddress(users[nextBackUserId]));\n', '                    _queue(to, users2users[to]);\n', '                    if (nextBackUserId == existLastIndex){\n', '                        nextBackUserId = secondHalfStart;\n', '                    }else{\n', '                        nextBackUserId = nextBackUserId.add(1);\n', '                    }\n', '                }else{\n', '                    collectBalances[users[nextBackUserId]] = collectBalances[users[nextBackUserId]].add(queueInteres);\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getMyMoney() public {\n', '        require(balances[msg.sender]>0);\n', '        msg.sender.transfer(balances[msg.sender]);\n', '        emit GetMyMoney(msg.sender, balances[msg.sender], now);\n', '        balances[msg.sender]=0;\n', '    }\n', '    \n', '    function balanceOf(address who) public view returns (uint256 balance) {\n', '        return balances[who];\n', '    }\n', '    \n', '    function balanceTotalOf(address who) public view returns (uint256 balanceTotal) {\n', '        return balancesTotal[who];\n', '    }\n', '    \n', '    function getNextForwardUserId() public view returns (uint256) {\n', '        return nextForwardUserId;\n', '    }\n', '    \n', '    function getNextBackUserId() public view returns (uint256) {\n', '        return nextBackUserId;\n', '    }\n', '    \n', '    function getLastIndex() public view returns (uint256) {\n', '        uint256 length = users.length;\n', '        return length.sub(1);\n', '    }\n', '    \n', '    function getUserAddressById(uint256 id) public view returns (address userAddress) {\n', '        return users[id];\n', '    }\n', '    \n', '    function checkExistAddress(address user) public view returns (bool) {\n', '        return usersExist[user];\n', '    }\n', '    \n', '    function getParentUser(address user) public view returns (address) {\n', '        return users2users[user];\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract Queue {\n', '    using SafeMath for uint256;\n', '    address[] users;\n', '    mapping(address => bool) usersExist;\n', '    mapping(address => address) users2users;\n', '    mapping(address => uint256) collectBalances;\n', '    mapping(address => uint256) balances;\n', '    mapping(address => uint256) balancesTotal;\n', '    uint256 nextForwardUserId = 0;\n', '    uint256 nextBackUserId = 0;\n', '    uint256 cyles = 50;\n', '    uint256 interes = 10 finney;\n', '    uint256 reminder=0;\n', '    uint256 price = 20 finney;\n', '    uint256 referalBonus = 5 finney;\n', '    uint256 queueInteres = 100 szabo;\n', '    address to;\n', '    uint256 collect = 30 finney;\n', '    \n', '    event QueueStart(address indexed user, address indexed parentUser, uint256 indexed timeshtamp);\n', '    event BalanceUp(address indexed user, uint256 amount, uint256 indexed timeshtamp);\n', '    event GetMyMoney(address indexed user, uint256 amount, uint256 indexed timeshtamp);\n', '    \n', '    function () payable public {\n', '        msg.sender.transfer(msg.value);\n', '    }\n', '    \n', '    function startQueue(address parentUser) payable public {\n', '        require(msg.value == price);\n', '        require(msg.sender != address(0));\n', '        require(parentUser != address(0));\n', '        require(!usersExist[msg.sender]);\n', '        _queue(msg.sender, parentUser);\n', '    }\n', '    \n', '    function serchIndexByAddress(address a) public view returns (uint256 index) {\n', '        for(index=0; index<users.length; index++) {\n', '            if(a == users[index]){\n', '                return index;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function _removeIndex(uint256 indexToRemove) internal {\n', '        if (indexToRemove >= users.length) return;\n', '\n', '        for (uint i = indexToRemove; i<users.length-1; i++){\n', '            users[i] = users[i+1];\n', '        }\n', '        delete users[users.length-1];\n', '        users.length--;\n', '    }\n', '    \n', '    function _queue(address user, address parentUser) internal {\n', '        if (user != address(0x9a965e5e9c3A0F062C80a7f3d1B0972201b2F19f) ) {\n', '            require(parentUser!=user);\n', '            require(usersExist[parentUser]);\n', '        }\n', '        users.push(user);\n', '        usersExist[user]=true;\n', '        users2users[user]=parentUser;\n', '        emit QueueStart(user, parentUser, now);\n', '        \n', '        if (collectBalances[parentUser].add(referalBonus) >= collect){\n', '            reminder = collectBalances[parentUser].add(referalBonus) - collect;\n', '            balancesTotal[parentUser] = balancesTotal[parentUser].add(interes);\n', '            balances[parentUser] = balances[parentUser].add(interes);\n', '            emit BalanceUp(parentUser, interes, now);\n', '            collectBalances[parentUser] = reminder;\n', '            to = parentUser;\n', '            _removeIndex(serchIndexByAddress(parentUser));\n', '            _queue(to, users2users[to]);\n', '        }else{\n', '            collectBalances[parentUser] = collectBalances[parentUser].add(referalBonus);\n', '        }\n', '        \n', '        if (collectBalances[users2users[parentUser]].add(referalBonus) >= collect){\n', '            reminder = collectBalances[users2users[parentUser]].add(referalBonus) - collect;\n', '            balancesTotal[users2users[parentUser]] = balancesTotal[users2users[parentUser]].add(interes);\n', '            balances[users2users[parentUser]] = balances[users2users[parentUser]].add(interes);\n', '            emit BalanceUp(users2users[parentUser], interes, now);\n', '            collectBalances[users2users[parentUser]] = reminder;\n', '            to = users2users[parentUser];\n', '            _removeIndex(serchIndexByAddress(users2users[parentUser]));\n', '            _queue(to, users2users[to]);\n', '        }else{\n', '            collectBalances[users2users[parentUser]] = collectBalances[users2users[parentUser]].add(referalBonus);\n', '        }\n', '        \n', '        uint256 length = users.length;\n', '        uint256 existLastIndex = length.sub(1);\n', '        uint256 firstHalfEnd = 0;\n', '        uint256 secondHalfStart = 0;\n', '        \n', '        if (length == 1 ){\n', '            collectBalances[users[0]] = collectBalances[users[0]].add(queueInteres.mul(cyles.mul(2)));\n', '        }else{\n', '            if (length % 2 != 0) {\n', '                firstHalfEnd  = length.div(2);\n', '                secondHalfStart  = length.div(2);\n', '            }else{\n', '                firstHalfEnd  = length.div(2).sub(1);\n', '                secondHalfStart  = length.div(2);\n', '            }\n', '            \n', '            for (uint i = 1; i <= cyles; i++) {\n', '                if(collectBalances[users[nextForwardUserId]].add(queueInteres) >= collect){\n', '                    reminder = collectBalances[users[nextForwardUserId]].add(queueInteres) - collect;\n', '                    balancesTotal[users[nextForwardUserId]] = balancesTotal[users[nextForwardUserId]].add(interes);\n', '                    balances[users[nextForwardUserId]] = balances[users[nextForwardUserId]].add(interes);\n', '                    collectBalances[users[nextForwardUserId]] = reminder;\n', '                    emit BalanceUp(users[nextForwardUserId], interes, now);\n', '                    to = users[nextForwardUserId];\n', '                    _removeIndex(serchIndexByAddress(users[nextForwardUserId]));\n', '                    _queue(to, users2users[to]);\n', '                    if (nextForwardUserId == 0){\n', '                        nextForwardUserId = firstHalfEnd;\n', '                    }else{\n', '                        nextForwardUserId = nextForwardUserId.sub(1);\n', '                    }\n', '                }else{\n', '                    collectBalances[users[nextForwardUserId]] = collectBalances[users[nextForwardUserId]].add(queueInteres);\n', '                }\n', '                if(collectBalances[users[nextBackUserId]].add(queueInteres) == collect){\n', '                    reminder = collectBalances[users[nextBackUserId]].add(queueInteres) - collect;\n', '                    balancesTotal[users[nextBackUserId]] = balancesTotal[users[nextBackUserId]].add(interes);\n', '                    balances[users[nextBackUserId]] = balances[users[nextBackUserId]].add(interes);\n', '                    collectBalances[users[nextBackUserId]] = reminder;\n', '                    emit BalanceUp(users[nextBackUserId], interes, now);\n', '                    to = users[nextBackUserId];\n', '                    _removeIndex(serchIndexByAddress(users[nextBackUserId]));\n', '                    _queue(to, users2users[to]);\n', '                    if (nextBackUserId == existLastIndex){\n', '                        nextBackUserId = secondHalfStart;\n', '                    }else{\n', '                        nextBackUserId = nextBackUserId.add(1);\n', '                    }\n', '                }else{\n', '                    collectBalances[users[nextBackUserId]] = collectBalances[users[nextBackUserId]].add(queueInteres);\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getMyMoney() public {\n', '        require(balances[msg.sender]>0);\n', '        msg.sender.transfer(balances[msg.sender]);\n', '        emit GetMyMoney(msg.sender, balances[msg.sender], now);\n', '        balances[msg.sender]=0;\n', '    }\n', '    \n', '    function balanceOf(address who) public view returns (uint256 balance) {\n', '        return balances[who];\n', '    }\n', '    \n', '    function balanceTotalOf(address who) public view returns (uint256 balanceTotal) {\n', '        return balancesTotal[who];\n', '    }\n', '    \n', '    function getNextForwardUserId() public view returns (uint256) {\n', '        return nextForwardUserId;\n', '    }\n', '    \n', '    function getNextBackUserId() public view returns (uint256) {\n', '        return nextBackUserId;\n', '    }\n', '    \n', '    function getLastIndex() public view returns (uint256) {\n', '        uint256 length = users.length;\n', '        return length.sub(1);\n', '    }\n', '    \n', '    function getUserAddressById(uint256 id) public view returns (address userAddress) {\n', '        return users[id];\n', '    }\n', '    \n', '    function checkExistAddress(address user) public view returns (bool) {\n', '        return usersExist[user];\n', '    }\n', '    \n', '    function getParentUser(address user) public view returns (address) {\n', '        return users2users[user];\n', '    }\n', '}']
