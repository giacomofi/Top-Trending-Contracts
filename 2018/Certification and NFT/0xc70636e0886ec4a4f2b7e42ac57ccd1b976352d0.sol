['pragma solidity 0.4.18;\n', '\n', '/// @title Math operations with safety checks\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // require(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // require(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function toPower2(uint256 a) internal pure returns (uint256) {\n', '        return mul(a, a);\n', '    }\n', '\n', '    function sqrt(uint256 a) internal pure returns (uint256) {\n', '        uint256 c = (a + 1) / 2;\n', '        uint256 b = a;\n', '        while (c < b) {\n', '            b = c;\n', '            c = (a / c + c) / 2;\n', '        }\n', '        return b;\n', '    }\n', '}\n', '\n', '/// @title ERC223Receiver Interface\n', '/// @dev Based on the specs form: https://github.com/ethereum/EIPs/issues/223\n', 'contract ERC223Receiver {\n', '    function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok);\n', '}\n', '\n', '\n', '\n', '/// @title Market Maker Interface.\n', '/// @author Tal Beja.\n', 'contract MarketMaker is ERC223Receiver {\n', '\n', '  function getCurrentPrice() public constant returns (uint _price);\n', '  function change(address _fromToken, uint _amount, address _toToken) public returns (uint _returnAmount);\n', '  function change(address _fromToken, uint _amount, address _toToken, uint _minReturn) public returns (uint _returnAmount);\n', '  function change(address _toToken) public returns (uint _returnAmount);\n', '  function change(address _toToken, uint _minReturn) public returns (uint _returnAmount);\n', '  function quote(address _fromToken, uint _amount, address _toToken) public constant returns (uint _returnAmount);\n', '  function openForPublicTrade() public returns (bool success);\n', '  function isOpenForPublic() public returns (bool success);\n', '\n', '  event Change(address indexed fromToken, uint inAmount, address indexed toToken, uint returnAmount, address indexed account);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/// @title Ellipse Market Maker Interfase\n', '/// @author Tal Beja\n', 'contract IEllipseMarketMaker is MarketMaker {\n', '\n', '    // precision for price representation (as in ether or tokens).\n', '    uint256 public constant PRECISION = 10 ** 18;\n', '\n', '    // The tokens pair.\n', '    ERC20 public token1;\n', '    ERC20 public token2;\n', '\n', '    // The tokens reserves.\n', '    uint256 public R1;\n', '    uint256 public R2;\n', '\n', '    // The tokens full suplly.\n', '    uint256 public S1;\n', '    uint256 public S2;\n', '\n', '    // State flags.\n', '    bool public operational;\n', '    bool public openForPublic;\n', '\n', '    // Library contract address.\n', '    address public mmLib;\n', '\n', '    function supportsToken(address token) public constant returns (bool);\n', '\n', '    function calcReserve(uint256 _R1, uint256 _S1, uint256 _S2) public pure returns (uint256);\n', '\n', '    function validateReserves() public view returns (bool);\n', '\n', '    function withdrawExcessReserves() public returns (uint256);\n', '\n', '    function initializeAfterTransfer() public returns (bool);\n', '\n', '    function initializeOnTransfer() public returns (bool);\n', '\n', '    function getPrice(uint256 _R1, uint256 _R2, uint256 _S1, uint256 _S2) public constant returns (uint256);\n', '}\n', '\n', '\n', '/// @title ERC Token Standard #20 Interface (https://github.com/ethereum/EIPs/issues/20)\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address _owner) constant public returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic authorization control functions,\n', '/// this simplifies the implementation of "user permissions".\n', "/// @dev Based on OpenZeppelin's Ownable.\n", '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwnerCandidate;\n', '\n', '    event OwnershipRequested(address indexed _by, address indexed _to);\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    /// @dev Constructor sets the original `owner` of the contract to the sender account.\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Reverts if called by any account other than the owner.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerCandidate() {\n', '        require(msg.sender == newOwnerCandidate);\n', '        _;\n', '    }\n', '\n', '    /// @dev Proposes to transfer control of the contract to a newOwnerCandidate.\n', '    /// @param _newOwnerCandidate address The address to transfer ownership to.\n', '    function requestOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\n', '        require(_newOwnerCandidate != address(0));\n', '\n', '        newOwnerCandidate = _newOwnerCandidate;\n', '\n', '        OwnershipRequested(msg.sender, newOwnerCandidate);\n', '    }\n', '\n', '    /// @dev Accept ownership transfer. This method needs to be called by the perviously proposed owner.\n', '    function acceptOwnership() external onlyOwnerCandidate {\n', '        address previousOwner = owner;\n', '\n', '        owner = newOwnerCandidate;\n', '        newOwnerCandidate = address(0);\n', '\n', '        OwnershipTransferred(previousOwner, owner);\n', '    }\n', '}\n', '\n', '\n', '\n', ' /// @title Standard ERC223 Token Receiver implementing tokenFallback function and tokenPayable modifier\n', '\n', 'contract Standard223Receiver is ERC223Receiver {\n', '  Tkn tkn;\n', '\n', '  struct Tkn {\n', '    address addr;\n', '    address sender; // the transaction caller\n', '    uint256 value;\n', '  }\n', '\n', '  bool __isTokenFallback;\n', '\n', '  modifier tokenPayable {\n', '    require(__isTokenFallback);\n', '    _;\n', '  }\n', '\n', '  /// @dev Called when the receiver of transfer is contract\n', '  /// @param _sender address the address of tokens sender\n', '  /// @param _value uint256 the amount of tokens to be transferred.\n', '  /// @param _data bytes data that can be attached to the token transation\n', '  function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok) {\n', '    if (!supportsToken(msg.sender)) {\n', '      return false;\n', '    }\n', '\n', '    // Problem: This will do a sstore which is expensive gas wise. Find a way to keep it in memory.\n', '    // Solution: Remove the the data\n', '    tkn = Tkn(msg.sender, _sender, _value);\n', '    __isTokenFallback = true;\n', '    if (!address(this).delegatecall(_data)) {\n', '      __isTokenFallback = false;\n', '      return false;\n', '    }\n', '    // avoid doing an overwrite to .token, which would be more expensive\n', '    // makes accessing .tkn values outside tokenPayable functions unsafe\n', '    __isTokenFallback = false;\n', '\n', '    return true;\n', '  }\n', '\n', '  function supportsToken(address token) public constant returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/// @title TokenOwnable\n', '/// @dev The TokenOwnable contract adds a onlyTokenOwner modifier as a tokenReceiver with ownable addaptation\n', '\n', 'contract TokenOwnable is Standard223Receiver, Ownable {\n', '    /// @dev Reverts if called by any account other than the owner for token sending.\n', '    modifier onlyTokenOwner() {\n', '        require(tkn.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Ellipse Market Maker Library.\n', '/// @dev market maker, using ellipse equation.\n', '/// @dev for more information read the appendix of the CLN white paper: https://cln.network/pdf/cln_whitepaper.pdf\n', '/// @author Tal Beja.\n', 'contract EllipseMarketMakerLib is TokenOwnable, IEllipseMarketMaker {\n', '  using SafeMath for uint256;\n', '\n', '  // temp reserves\n', '  uint256 private l_R1;\n', '  uint256 private l_R2;\n', '\n', '  modifier notConstructed() {\n', '    require(mmLib == address(0));\n', '    _;\n', '  }\n', '\n', '  /// @dev Reverts if not operational\n', '  modifier isOperational() {\n', '    require(operational);\n', '    _;\n', '  }\n', '\n', '  /// @dev Reverts if operational\n', '  modifier notOperational() {\n', '    require(!operational);\n', '    _;\n', '  }\n', '\n', "  /// @dev Reverts if msg.sender can't trade\n", '  modifier canTrade() {\n', '    require(openForPublic || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', "  /// @dev Reverts if tkn.sender can't trade\n", '  modifier canTrade223() {\n', '    require (openForPublic || tkn.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /// @dev The Market Maker constructor\n', '  /// @param _mmLib address address of the market making lib contract\n', '  /// @param _token1 address contract of the first token for marker making (CLN)\n', '  /// @param _token2 address contract of the second token for marker making (CC)\n', '  function constructor(address _mmLib, address _token1, address _token2) public onlyOwner notConstructed returns (bool) {\n', '    require(_mmLib != address(0));\n', '    require(_token1 != address(0));\n', '    require(_token2 != address(0));\n', '    require(_token1 != _token2);\n', '\n', '    mmLib = _mmLib;\n', '    token1 = ERC20(_token1);\n', '    token2 = ERC20(_token2);\n', '    R1 = 0;\n', '    R2 = 0;\n', '    S1 = token1.totalSupply();\n', '    S2 = token2.totalSupply();\n', '\n', '    operational = false;\n', '    openForPublic = false;\n', '\n', '    return true;\n', '  }\n', '\n', '  /// @dev open the Market Maker for public trade.\n', '  function openForPublicTrade() public onlyOwner isOperational returns (bool) {\n', '    openForPublic = true;\n', '    return true;\n', '  }\n', '\n', '  /// @dev returns true iff the contract is open for public trade.\n', '  function isOpenForPublic() public onlyOwner returns (bool) {\n', '    return (openForPublic && operational);\n', '  }\n', '\n', '  /// @dev returns true iff token is supperted by this contract (for erc223/677 tokens calls)\n', '  /// @param _token address adress of the contract to check\n', '  function supportsToken(address _token) public constant returns (bool) {\n', '      return (token1 == _token || token2 == _token);\n', '  }\n', '\n', '  /// @dev initialize the contract after transfering all of the tokens form the pair\n', '  function initializeAfterTransfer() public notOperational onlyOwner returns (bool) {\n', '    require(initialize());\n', '    return true;\n', '  }\n', '\n', '  /// @dev initialize the contract during erc223/erc677 transfer of all of the tokens form the pair\n', '  function initializeOnTransfer() public notOperational onlyTokenOwner tokenPayable returns (bool) {\n', '    require(initialize());\n', '    return true;\n', '  }\n', '\n', '  /// @dev initialize the contract.\n', '  function initialize() private returns (bool success) {\n', '    R1 = token1.balanceOf(this);\n', '    R2 = token2.balanceOf(this);\n', '    // one reserve should be full and the second should be empty\n', '    success = ((R1 == 0 && R2 == S2) || (R2 == 0 && R1 == S1));\n', '    if (success) {\n', '      operational = true;\n', '    }\n', '  }\n', '\n', '  /// @dev the price of token1 in terms of token2, represented in 18 decimals.\n', '  function getCurrentPrice() public constant isOperational returns (uint256) {\n', '    return getPrice(R1, R2, S1, S2);\n', '  }\n', '\n', '  /// @dev the price of token1 in terms of token2, represented in 18 decimals.\n', '  /// price = (S1 - R1) / (S2 - R2) * (S2 / S1)^2\n', '  /// @param _R1 uint256 reserve of the first token\n', '  /// @param _R2 uint256 reserve of the second token\n', '  /// @param _S1 uint256 total supply of the first token\n', '  /// @param _S2 uint256 total supply of the second token\n', '  function getPrice(uint256 _R1, uint256 _R2, uint256 _S1, uint256 _S2) public constant returns (uint256 price) {\n', '    price = PRECISION;\n', '    price = price.mul(_S1.sub(_R1));\n', '    price = price.div(_S2.sub(_R2));\n', '    price = price.mul(_S2);\n', '    price = price.div(_S1);\n', '    price = price.mul(_S2);\n', '    price = price.div(_S1);\n', '  }\n', '\n', '  /// @dev get a quote for exchanging and update temporary reserves.\n', '  /// @param _fromToken the token to sell from\n', '  /// @param _inAmount the amount to sell\n', '  /// @param _toToken the token to buy\n', '  /// @return the return amount of the buying token\n', '  function quoteAndReserves(address _fromToken, uint256 _inAmount, address _toToken) private isOperational returns (uint256 returnAmount) {\n', '    // if buying token2 from token1\n', '    if (token1 == _fromToken && token2 == _toToken) {\n', '      // add buying amount to the temp reserve\n', '      l_R1 = R1.add(_inAmount);\n', '      // calculate the other reserve\n', '      l_R2 = calcReserve(l_R1, S1, S2);\n', '      if (l_R2 > R2) {\n', '        return 0;\n', '      }\n', '      // the returnAmount is the other reserve difference\n', '      returnAmount = R2.sub(l_R2);\n', '    }\n', '    // if buying token1 from token2\n', '    else if (token2 == _fromToken && token1 == _toToken) {\n', '      // add buying amount to the temp reserve\n', '      l_R2 = R2.add(_inAmount);\n', '      // calculate the other reserve\n', '      l_R1 = calcReserve(l_R2, S2, S1);\n', '      if (l_R1 > R1) {\n', '        return 0;\n', '      }\n', '      // the returnAmount is the other reserve difference\n', '      returnAmount = R1.sub(l_R1);\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  /// @dev get a quote for exchanging.\n', '  /// @param _fromToken the token to sell from\n', '  /// @param _inAmount the amount to sell\n', '  /// @param _toToken the token to buy\n', '  /// @return the return amount of the buying token\n', '  function quote(address _fromToken, uint256 _inAmount, address _toToken) public constant isOperational returns (uint256 returnAmount) {\n', '    uint256 _R1;\n', '    uint256 _R2;\n', '    // if buying token2 from token1\n', '    if (token1 == _fromToken && token2 == _toToken) {\n', '      // add buying amount to the temp reserve\n', '      _R1 = R1.add(_inAmount);\n', '      // calculate the other reserve\n', '      _R2 = calcReserve(_R1, S1, S2);\n', '      if (_R2 > R2) {\n', '        return 0;\n', '      }\n', '      // the returnAmount is the other reserve difference\n', '      returnAmount = R2.sub(_R2);\n', '    }\n', '    // if buying token1 from token2\n', '    else if (token2 == _fromToken && token1 == _toToken) {\n', '      // add buying amount to the temp reserve\n', '      _R2 = R2.add(_inAmount);\n', '      // calculate the other reserve\n', '      _R1 = calcReserve(_R2, S2, S1);\n', '      if (_R1 > R1) {\n', '        return 0;\n', '      }\n', '      // the returnAmount is the other reserve difference\n', '      returnAmount = R1.sub(_R1);\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  /// @dev calculate second reserve from the first reserve and the supllies.\n', '  /// @dev formula: R2 = S2 * (S1 - sqrt(R1 * S1 * 2  - R1 ^ 2)) / S1\n', '  /// @dev the equation is simetric, so by replacing _S1 and _S2 and _R1 with _R2 we can calculate the first reserve from the second reserve\n', '  /// @param _R1 the first reserve\n', '  /// @param _S1 the first total supply\n', '  /// @param _S2 the second total supply\n', '  /// @return _R2 the second reserve\n', '  function calcReserve(uint256 _R1, uint256 _S1, uint256 _S2) public pure returns (uint256 _R2) {\n', '    _R2 = _S2\n', '      .mul(\n', '        _S1\n', '        .sub(\n', '          _R1\n', '          .mul(_S1)\n', '          .mul(2)\n', '          .sub(\n', '            _R1\n', '            .toPower2()\n', '          )\n', '          .sqrt()\n', '        )\n', '      )\n', '      .div(_S1);\n', '  }\n', '\n', '  /// @dev change tokens.\n', '  /// @param _fromToken the token to sell from\n', '  /// @param _inAmount the amount to sell\n', '  /// @param _toToken the token to buy\n', '  /// @return the return amount of the buying token\n', '  function change(address _fromToken, uint256 _inAmount, address _toToken) public canTrade returns (uint256 returnAmount) {\n', '    return change(_fromToken, _inAmount, _toToken, 0);\n', '  }\n', '\n', '  /// @dev change tokens.\n', '  /// @param _fromToken the token to sell from\n', '  /// @param _inAmount the amount to sell\n', '  /// @param _toToken the token to buy\n', '  /// @param _minReturn the munimum token to buy\n', '  /// @return the return amount of the buying token\n', '  function change(address _fromToken, uint256 _inAmount, address _toToken, uint256 _minReturn) public canTrade returns (uint256 returnAmount) {\n', '    // pull transfer the selling token\n', '    require(ERC20(_fromToken).transferFrom(msg.sender, this, _inAmount));\n', '    // exchange the token\n', '    returnAmount = exchange(_fromToken, _inAmount, _toToken, _minReturn);\n', '    if (returnAmount == 0) {\n', '      // if no return value revert\n', '      revert();\n', '    }\n', '    // transfer the buying token\n', '    ERC20(_toToken).transfer(msg.sender, returnAmount);\n', '    // validate the reserves\n', '    require(validateReserves());\n', '    Change(_fromToken, _inAmount, _toToken, returnAmount, msg.sender);\n', '  }\n', '\n', '  /// @dev change tokens using erc223\\erc677 transfer.\n', '  /// @param _toToken the token to buy\n', '  /// @return the return amount of the buying token\n', '  function change(address _toToken) public canTrade223 tokenPayable returns (uint256 returnAmount) {\n', '    return change(_toToken, 0);\n', '  }\n', '\n', '  /// @dev change tokens using erc223\\erc677 transfer.\n', '  /// @param _toToken the token to buy\n', '  /// @param _minReturn the munimum token to buy\n', '  /// @return the return amount of the buying token\n', '  function change(address _toToken, uint256 _minReturn) public canTrade223 tokenPayable returns (uint256 returnAmount) {\n', '    // get from token and in amount from the tkn object\n', '    address fromToken = tkn.addr;\n', '    uint256 inAmount = tkn.value;\n', '    // exchange the token\n', '    returnAmount = exchange(fromToken, inAmount, _toToken, _minReturn);\n', '    if (returnAmount == 0) {\n', '      // if no return value revert\n', '      revert();\n', '    }\n', '    // transfer the buying token\n', '    ERC20(_toToken).transfer(tkn.sender, returnAmount);\n', '    // validate the reserves\n', '    require(validateReserves());\n', '    Change(fromToken, inAmount, _toToken, returnAmount, tkn.sender);\n', '  }\n', '\n', '  /// @dev exchange tokens.\n', '  /// @param _fromToken the token to sell from\n', '  /// @param _inAmount the amount to sell\n', '  /// @param _toToken the token to buy\n', '  /// @param _minReturn the munimum token to buy\n', '  /// @return the return amount of the buying token\n', '  function exchange(address _fromToken, uint256 _inAmount, address _toToken, uint256 _minReturn) private returns (uint256 returnAmount) {\n', '    // get quote and update temp reserves\n', '    returnAmount = quoteAndReserves(_fromToken, _inAmount, _toToken);\n', "    // if the return amount is lower than minimum return, don't buy\n", '    if (returnAmount == 0 || returnAmount < _minReturn) {\n', '      return 0;\n', '    }\n', '\n', '    // update reserves from temp values\n', '    updateReserve();\n', '  }\n', '\n', '  /// @dev update token reserves from temp values\n', '  function updateReserve() private {\n', '    R1 = l_R1;\n', '    R2 = l_R2;\n', '  }\n', '\n', "  /// @dev validate that the tokens balances don't goes below reserves\n", '  function validateReserves() public view returns (bool) {\n', '    return (token1.balanceOf(this) >= R1 && token2.balanceOf(this) >= R2);\n', '  }\n', '\n', '  /// @dev allow admin to withraw excess tokens accumulated due to precision\n', '  function withdrawExcessReserves() public onlyOwner returns (uint256 returnAmount) {\n', '    // if there is excess of token 1, transfer it to the owner\n', '    if (token1.balanceOf(this) > R1) {\n', '      returnAmount = returnAmount.add(token1.balanceOf(this).sub(R1));\n', '      token1.transfer(msg.sender, token1.balanceOf(this).sub(R1));\n', '    }\n', '    // if there is excess of token 2, transfer it to the owner\n', '    if (token2.balanceOf(this) > R2) {\n', '      returnAmount = returnAmount.add(token2.balanceOf(this).sub(R2));\n', '      token2.transfer(msg.sender, token2.balanceOf(this).sub(R2));\n', '    }\n', '  }\n', '}']