['pragma solidity ^0.4.21;\n', '\n', '// File: contracts/ERC165.sol\n', '\n', 'interface ERC165 {\n', '  /// @notice Query if a contract implements an interface\n', '  /// @param interfaceID The interface identifier, as specified in ERC-165\n', '  /// @dev Interface identification is specified in ERC-165. This function\n', '  ///  uses less than 30,000 gas.\n', '  /// @return `true` if the contract implements `interfaceID` and\n', '  ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '  function supportsInterface(bytes4 interfaceID) external pure returns (bool);\n', '}\n', '\n', '// File: contracts/ERC721Basic.sol\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Basic {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public;\n', '}\n', '\n', '// File: contracts/ERC721.sol\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Enumerable is ERC721Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\n', '  function tokenByIndex(uint256 _index) public view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Metadata is ERC721Basic {\n', '  function name() public view returns (string _name);\n', '  function symbol() public view returns (string _symbol);\n', '  function tokenURI(uint256 _tokenId) public view returns (string);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n', '}\n', '\n', '// File: contracts/ERC721Receiver.sol\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' *  from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver {\n', '  /**\n', '   * @dev Magic value to be returned upon successful reception of an NFT\n', '   *  Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`,\n', '   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '   */\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  /**\n', '   * @notice Handle the receipt of an NFT\n', '   * @dev The ERC721 smart contract calls this function on the recipient\n', '   *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '   *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '   *  than the magic value MUST result in the transaction being reverted.\n', '   *  Note: the contract address is always the message sender.\n', '   * @param _from The sending address\n', '   * @param _tokenId The NFT identifier which is being transfered\n', '   * @param _data Additional data with no specified format\n', '   * @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '   */\n', '  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether there is code in the target address\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address address to check\n', '   * @return whether there is code in the target address\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/ERC721BasicToken.sol\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic implementation\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721BasicToken is ERC721Basic {\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  // Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  // Mapping from token ID to owner\n', '  mapping (uint256 => address) internal tokenOwner;\n', '\n', '  // Mapping from token ID to approved address\n', '  mapping (uint256 => address) internal tokenApprovals;\n', '\n', '  // Mapping from owner to number of owned token\n', '  mapping (address => uint256) internal ownedTokensCount;\n', '\n', '  // Mapping from owner to operator approvals\n', '  mapping (address => mapping (address => bool)) internal operatorApprovals;\n', '\n', '  /**\n', '  * @dev Guarantees msg.sender is owner of the given token\n', '  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n', '  */\n', '  modifier onlyOwnerOf(uint256 _tokenId) {\n', '    require(ownerOf(_tokenId) == msg.sender);\n', '    _;\n', '  }\n', '\n', '  /**\n', '  * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\n', '  * @param _tokenId uint256 ID of the token to validate\n', '  */\n', '  modifier canTransfer(uint256 _tokenId) {\n', '    require(isApprovedOrOwner(msg.sender, _tokenId));\n', '    _;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address\n', '  * @param _owner address to query the balance of\n', '  * @return uint256 representing the amount owned by the passed address\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    require(_owner != address(0));\n', '    return ownedTokensCount[_owner];\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the owner of the specified token ID\n', '  * @param _tokenId uint256 ID of the token to query the owner of\n', '  * @return owner address currently marked as the owner of the given token ID\n', '  */\n', '  function ownerOf(uint256 _tokenId) public view returns (address) {\n', '    address owner = tokenOwner[_tokenId];\n', '    require(owner != address(0));\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '  * @dev Returns whether the specified token exists\n', '  * @param _tokenId uint256 ID of the token to query the existance of\n', '  * @return whether the token exists\n', '  */\n', '  function exists(uint256 _tokenId) public view returns (bool) {\n', '    address owner = tokenOwner[_tokenId];\n', '    return owner != address(0);\n', '  }\n', '\n', '  /**\n', '  * @dev Approves another address to transfer the given token ID\n', '  * @dev The zero address indicates there is no approved address.\n', '  * @dev There can only be one approved address per token at a given time.\n', '  * @dev Can only be called by the token owner or an approved operator.\n', '  * @param _to address to be approved for the given token ID\n', '  * @param _tokenId uint256 ID of the token to be approved\n', '  */\n', '  function approve(address _to, uint256 _tokenId) public {\n', '    address owner = ownerOf(_tokenId);\n', '    require(_to != owner);\n', '    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '\n', '    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n', '      tokenApprovals[_tokenId] = _to;\n', '      Approval(owner, _to, _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the approved address for a token ID, or zero if no address set\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return address currently approved for a the given token ID\n', '   */\n', '  function getApproved(uint256 _tokenId) public view returns (address) {\n', '    return tokenApprovals[_tokenId];\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev Sets or unsets the approval of a given operator\n', '  * @dev An operator is allowed to transfer all tokens of the sender on their behalf\n', '  * @param _to operator address to set the approval\n', '  * @param _approved representing the status of the approval to be set\n', '  */\n', '  function setApprovalForAll(address _to, bool _approved) public {\n', '    require(_to != msg.sender);\n', '    operatorApprovals[msg.sender][_to] = _approved;\n', '    ApprovalForAll(msg.sender, _to, _approved);\n', '  }\n', '\n', '  /**\n', '   * @dev Tells whether an operator is approved by a given owner\n', '   * @param _owner owner address which you want to query the approval of\n', '   * @param _operator operator address which you want to query the approval of\n', '   * @return bool whether the given operator is approved by the given owner\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n', '    return operatorApprovals[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '  * @dev Transfers the ownership of a given token ID to another address\n', '  * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '  * @dev Requires the msg sender to be the owner, approved, or operator\n', '  * @param _from current owner of the token\n', '  * @param _to address to receive the ownership of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\n', '    require(_from != address(0));\n', '    require(_to != address(0));\n', '\n', '    clearApproval(_from, _tokenId);\n', '    removeTokenFrom(_from, _tokenId);\n', '    addTokenTo(_to, _tokenId);\n', '\n', '    Transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @dev Safely transfers the ownership of a given token ID to another address\n', '  * @dev If the target address is a contract, it must implement `onERC721Received`,\n', '  *  which is called upon a safe transfer, and return the magic value\n', '  *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise,\n', '  *  the transfer is reverted.\n', '  * @dev Requires the msg sender to be the owner, approved, or operator\n', '  * @param _from current owner of the token\n', '  * @param _to address to receive the ownership of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\n', '    safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '  * @dev Safely transfers the ownership of a given token ID to another address\n', '  * @dev If the target address is a contract, it must implement `onERC721Received`,\n', '  *  which is called upon a safe transfer, and return the magic value\n', '  *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise,\n', '  *  the transfer is reverted.\n', '  * @dev Requires the msg sender to be the owner, approved, or operator\n', '  * @param _from current owner of the token\n', '  * @param _to address to receive the ownership of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  * @param _data bytes data to send along with a safe transfer check\n', '  */\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public canTransfer(_tokenId) {\n', '    transferFrom(_from, _to, _tokenId);\n', '    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n', '  }\n', '\n', '  /**\n', '   * @dev Returns whether the given spender can transfer a given token ID\n', '   * @param _spender address of the spender to query\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @return bool whether the msg.sender is approved for the given token ID,\n', '   *  is an operator of the owner, or is the owner of the token\n', '   */\n', '  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\n', '    address owner = ownerOf(_tokenId);\n', '    return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to mint a new token\n', '  * @dev Reverts if the given token ID already exists\n', '  * @param _to The address that will own the minted token\n', '  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '  */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0));\n', '    addTokenTo(_to, _tokenId);\n', '    Transfer(address(0), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to burn a specific token\n', '  * @dev Reverts if the token does not exist\n', '  * @param _tokenId uint256 ID of the token being burned by the msg.sender\n', '  */\n', '  function _burn(address _owner, uint256 _tokenId) internal {\n', '    clearApproval(_owner, _tokenId);\n', '    removeTokenFrom(_owner, _tokenId);\n', '    Transfer(_owner, address(0), _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to clear current approval of a given token ID\n', '  * @dev Reverts if the given address is not indeed the owner of the token\n', '  * @param _owner owner of the token\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function clearApproval(address _owner, uint256 _tokenId) internal {\n', '    require(ownerOf(_tokenId) == _owner);\n', '    if (tokenApprovals[_tokenId] != address(0)) {\n', '      tokenApprovals[_tokenId] = address(0);\n', '      Approval(_owner, address(0), _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to add a token ID to the list of a given address\n', '  * @param _to address representing the new owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '  */\n', '  function addTokenTo(address _to, uint256 _tokenId) internal {\n', '    require(tokenOwner[_tokenId] == address(0));\n', '    tokenOwner[_tokenId] = _to;\n', '    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to remove a token ID from the list of a given address\n', '  * @param _from address representing the previous owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '  */\n', '  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n', '    require(ownerOf(_tokenId) == _from);\n', '    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n', '    tokenOwner[_tokenId] = address(0);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to invoke `onERC721Received` on a target address\n', '  * @dev The call is not executed if the target address is not a contract\n', '  * @param _from address representing the previous owner of the given token ID\n', '  * @param _to target address that will receive the tokens\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  * @param _data bytes optional data to send along with the call\n', '  * @return whether the call correctly returned the expected magic value\n', '  */\n', '  function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes _data) internal returns (bool) {\n', '    if (!_to.isContract()) {\n', '      return true;\n', '    }\n', '    bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\n', '    return (retval == ERC721_RECEIVED);\n', '  }\n', '}\n', '\n', '// File: contracts/ERC721Token.sol\n', '\n', '/**\n', ' * @title Full ERC721 Token\n', ' * This implementation includes all the required and some optional functionality of the ERC721 standard\n', ' * Moreover, it includes approve all functionality using operator terminology\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Token is ERC721, ERC721BasicToken {\n', '  // Token name\n', '  string internal name_;\n', '\n', '  // Token symbol\n', '  string internal symbol_;\n', '\n', '  // Mapping from owner to list of owned token IDs\n', '  mapping (address => uint256[]) internal ownedTokens;\n', '\n', '  // Mapping from token ID to index of the owner tokens list\n', '  mapping(uint256 => uint256) internal ownedTokensIndex;\n', '\n', '  // Array with all token ids, used for enumeration\n', '  uint256[] internal allTokens;\n', '\n', '  // Mapping from token id to position in the allTokens array\n', '  mapping(uint256 => uint256) internal allTokensIndex;\n', '\n', '  // Optional mapping for token URIs\n', '  mapping(uint256 => string) internal tokenURIs;\n', '\n', '  /**\n', '  * @dev Constructor function\n', '  */\n', '  function ERC721Token(string _name, string _symbol) public {\n', '    name_ = _name;\n', '    symbol_ = _symbol;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the token name\n', '  * @return string representing the token name\n', '  */\n', '  function name() public view returns (string) {\n', '    return name_;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the token symbol\n', '  * @return string representing the token symbol\n', '  */\n', '  function symbol() public view returns (string) {\n', '    return symbol_;\n', '  }\n', '\n', '  /**\n', '  * @dev Returns an URI for a given token ID\n', '  * @dev Throws if the token ID does not exist. May return an empty string.\n', '  * @param _tokenId uint256 ID of the token to query\n', '  */\n', '  function tokenURI(uint256 _tokenId) public view returns (string) {\n', '    require(exists(_tokenId));\n', '    return tokenURIs[_tokenId];\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to set the token URI for a given token\n', '  * @dev Reverts if the token ID does not exist\n', '  * @param _tokenId uint256 ID of the token to set its URI\n', '  * @param _uri string URI to assign\n', '  */\n', '  function _setTokenURI(uint256 _tokenId, string _uri) internal {\n', '    require(exists(_tokenId));\n', '    tokenURIs[_tokenId] = _uri;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the token ID at a given index of the tokens list of the requested owner\n', '  * @param _owner address owning the tokens list to be accessed\n', '  * @param _index uint256 representing the index to be accessed of the requested tokens list\n', '  * @return uint256 token ID at the given index of the tokens list owned by the requested address\n', '  */\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\n', '    require(_index < balanceOf(_owner));\n', '    return ownedTokens[_owner][_index];\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the total amount of tokens stored by the contract\n', '  * @return uint256 representing the total amount of tokens\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return allTokens.length;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the token ID at a given index of all the tokens in this contract\n', '  * @dev Reverts if the index is greater or equal to the total number of tokens\n', '  * @param _index uint256 representing the index to be accessed of the tokens list\n', '  * @return uint256 token ID at the given index of the tokens list\n', '  */\n', '  function tokenByIndex(uint256 _index) public view returns (uint256) {\n', '    require(_index < totalSupply());\n', '    return allTokens[_index];\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to add a token ID to the list of a given address\n', '  * @param _to address representing the new owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '  */\n', '  function addTokenTo(address _to, uint256 _tokenId) internal {\n', '    super.addTokenTo(_to, _tokenId);\n', '    uint256 length = ownedTokens[_to].length;\n', '    ownedTokens[_to].push(_tokenId);\n', '    ownedTokensIndex[_tokenId] = length;\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to remove a token ID from the list of a given address\n', '  * @param _from address representing the previous owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '  */\n', '  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n', '    super.removeTokenFrom(_from, _tokenId);\n', '\n', '    uint256 tokenIndex = ownedTokensIndex[_tokenId];\n', '    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n', '    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n', '\n', '    ownedTokens[_from][tokenIndex] = lastToken;\n', '    ownedTokens[_from][lastTokenIndex] = 0;\n', '    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n', '    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n', '    // the lastToken to the first position, and then dropping the element placed in the last position of the list\n', '\n', '    ownedTokens[_from].length--;\n', '    ownedTokensIndex[_tokenId] = 0;\n', '    ownedTokensIndex[lastToken] = tokenIndex;\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to mint a new token\n', '  * @dev Reverts if the given token ID already exists\n', '  * @param _to address the beneficiary that will own the minted token\n', '  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '  */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    super._mint(_to, _tokenId);\n', '\n', '    allTokensIndex[_tokenId] = allTokens.length;\n', '    allTokens.push(_tokenId);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to burn a specific token\n', '  * @dev Reverts if the token does not exist\n', '  * @param _owner owner of the token to burn\n', '  * @param _tokenId uint256 ID of the token being burned by the msg.sender\n', '  */\n', '  function _burn(address _owner, uint256 _tokenId) internal {\n', '    super._burn(_owner, _tokenId);\n', '\n', '    // Clear metadata (if any)\n', '    if (bytes(tokenURIs[_tokenId]).length != 0) {\n', '      delete tokenURIs[_tokenId];\n', '    }\n', '\n', '    // Reorg all tokens array\n', '    uint256 tokenIndex = allTokensIndex[_tokenId];\n', '    uint256 lastTokenIndex = allTokens.length.sub(1);\n', '    uint256 lastToken = allTokens[lastTokenIndex];\n', '\n', '    allTokens[tokenIndex] = lastToken;\n', '    allTokens[lastTokenIndex] = 0;\n', '\n', '    allTokens.length--;\n', '    allTokensIndex[_tokenId] = 0;\n', '    allTokensIndex[lastToken] = tokenIndex;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/Strings.sol\n', '\n', 'library Strings {\n', '  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n', '  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n', '    bytes memory _ba = bytes(_a);\n', '    bytes memory _bb = bytes(_b);\n', '    bytes memory _bc = bytes(_c);\n', '    bytes memory _bd = bytes(_d);\n', '    bytes memory _be = bytes(_e);\n', '    string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '    bytes memory babcde = bytes(abcde);\n', '    uint k = 0;\n', '    for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '    for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '    for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '    for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '    for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '    return string(babcde);\n', '  }\n', '\n', '  function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n', '    return strConcat(_a, _b, _c, _d, "");\n', '  }\n', '\n', '  function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n', '    return strConcat(_a, _b, _c, "", "");\n', '  }\n', '\n', '  function strConcat(string _a, string _b) internal pure returns (string) {\n', '    return strConcat(_a, _b, "", "", "");\n', '  }\n', '\n', '  function bytes16ToStr(bytes16 _bytes16, uint8 _start, uint8 _end) internal pure returns (string) {\n', '    bytes memory bytesArray = new bytes(_end - _start);\n', '    uint8 pos = 0;\n', '    for (uint8 i = _start; i < _end; i++) {\n', '      bytesArray[pos] = _bytes16[i];\n', '      pos++;\n', '    }\n', '    return string(bytesArray);\n', '  }\n', '}\n', '\n', '// File: contracts/KnownOriginDigitalAsset.sol\n', '\n', '/**\n', '* @title KnownOriginDigitalAsset\n', '*\n', '* http://www.knownorigin.io/\n', '*\n', '* ERC721 compliant digital assets for real-world artwork.\n', '* BE ORIGINAL. BUY ORIGINAL.\n', '*\n', '*/\n', 'contract KnownOriginDigitalAsset is ERC721Token, ERC165 {\n', '  using SafeMath for uint256;\n', '\n', '  bytes4 constant InterfaceSignature_ERC165 = 0x01ffc9a7;\n', '    /*\n', '    bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));\n', '    */\n', '\n', '  bytes4 constant InterfaceSignature_ERC721Enumerable = 0x780e9d63;\n', '    /*\n', '    bytes4(keccak256(&#39;totalSupply()&#39;)) ^\n', '    bytes4(keccak256(&#39;tokenOfOwnerByIndex(address,uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;tokenByIndex(uint256)&#39;));\n', '    */\n', '\n', '  bytes4 constant InterfaceSignature_ERC721Metadata = 0x5b5e139f;\n', '    /*\n', '    bytes4(keccak256(&#39;name()&#39;)) ^\n', '    bytes4(keccak256(&#39;symbol()&#39;)) ^\n', '    bytes4(keccak256(&#39;tokenURI(uint256)&#39;));\n', '    */\n', '\n', '  bytes4 constant InterfaceSignature_ERC721 = 0x80ac58cd;\n', '    /*\n', '    bytes4(keccak256(&#39;balanceOf(address)&#39;)) ^\n', '    bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;approve(address,uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;getApproved(uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;setApprovalForAll(address,bool)&#39;)) ^\n', '    bytes4(keccak256(&#39;isApprovedForAll(address,address)&#39;)) ^\n', '    bytes4(keccak256(&#39;transferFrom(address,address,uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;safeTransferFrom(address,address,uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;safeTransferFrom(address,address,uint256,bytes)&#39;));\n', '    */\n', '\n', '  bytes4 public constant InterfaceSignature_ERC721Optional =- 0x4f558e79;\n', '    /*\n', '    bytes4(keccak256(&#39;exists(uint256)&#39;));\n', '    */\n', '\n', '  /**\n', '   * @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n', '   * @dev Returns true for any standardized interfaces implemented by this contract.\n', '   * @param _interfaceID bytes4 the interface to check for\n', '   * @return true for any standardized interfaces implemented by this contract.\n', '   */\n', '  function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\n', '    return ((_interfaceID == InterfaceSignature_ERC165)\n', '    || (_interfaceID == InterfaceSignature_ERC721)\n', '    || (_interfaceID == InterfaceSignature_ERC721Optional)\n', '    || (_interfaceID == InterfaceSignature_ERC721Enumerable)\n', '    || (_interfaceID == InterfaceSignature_ERC721Metadata));\n', '  }\n', '\n', '  struct CommissionStructure {\n', '    uint8 curator;\n', '    uint8 developer;\n', '  }\n', '\n', '  string internal tokenBaseURI = "https://ipfs.infura.io/ipfs/";\n', '\n', '  // creates and owns the original assets all primary purchases transferred to this account\n', '  address public curatorAccount;\n', '\n', '  // the person who is responsible for designing and building the contract\n', '  address public developerAccount;\n', '\n', '  // total wei been processed through the contract\n', '  uint256 public totalPurchaseValueInWei;\n', '\n', '  // number of assets sold of any type\n', '  uint256 public totalNumberOfPurchases;\n', '\n', '  // A pointer to the next token to be minted, zero indexed\n', '  uint256 public tokenIdPointer = 0;\n', '\n', '  enum PurchaseState {Unsold, EtherPurchase, FiatPurchase}\n', '\n', '  mapping(string => CommissionStructure) internal editionTypeToCommission;\n', '  mapping(uint256 => PurchaseState) internal tokenIdToPurchased;\n', '\n', '  mapping(uint256 => bytes16) internal tokenIdToEdition;\n', '  mapping(uint256 => uint256) internal tokenIdToPriceInWei;\n', '  mapping(uint256 => uint32) internal tokenIdToPurchaseFromTime;\n', '\n', '  mapping(bytes16 => uint256) internal editionToEditionNumber;\n', '  mapping(bytes16 => address) internal editionToArtistAccount;\n', '\n', '  event PurchasedWithEther(uint256 indexed _tokenId, address indexed _buyer);\n', '\n', '  event PurchasedWithFiat(uint256 indexed _tokenId);\n', '\n', '  event PurchasedWithFiatReversed(uint256 indexed _tokenId);\n', '\n', '  modifier onlyCurator() {\n', '    require(msg.sender == curatorAccount);\n', '    _;\n', '  }\n', '\n', '  modifier onlyUnsold(uint256 _tokenId) {\n', '    require(tokenIdToPurchased[_tokenId] == PurchaseState.Unsold);\n', '    _;\n', '  }\n', '\n', '  modifier onlyFiatPurchased(uint256 _tokenId) {\n', '    require(tokenIdToPurchased[_tokenId] == PurchaseState.FiatPurchase);\n', '    _;\n', '  }\n', '\n', '  modifier onlyKnownOriginOwnedToken(uint256 _tokenId) {\n', '    require(tokenOwner[_tokenId] == curatorAccount || tokenOwner[_tokenId] == developerAccount);\n', '    _;\n', '  }\n', '\n', '  modifier onlyKnownOrigin() {\n', '    require(msg.sender == curatorAccount || msg.sender == developerAccount);\n', '    _;\n', '  }\n', '\n', '  modifier onlyAfterPurchaseFromTime(uint256 _tokenId) {\n', '    require(tokenIdToPurchaseFromTime[_tokenId] <= block.timestamp);\n', '    _;\n', '  }\n', '\n', '  function KnownOriginDigitalAsset(address _curatorAccount) public ERC721Token("KnownOriginDigitalAsset", "KODA") {\n', '    developerAccount = msg.sender;\n', '    curatorAccount = _curatorAccount;\n', '  }\n', '\n', '  // don&#39;t accept payment directly to contract\n', '  function() public payable {\n', '    revert();\n', '  }\n', '\n', '  /**\n', '   * @dev Mint a new KODA token\n', '   * @dev Reverts if not called by management\n', '   * @param _tokenURI the IPFS or equivalent hash\n', '   * @param _edition the identifier of the edition - leading 3 bytes are the artist code, trailing 3 bytes are the asset type\n', '   * @param _priceInWei the price of the KODA token\n', '   * @param _auctionStartDate the date when the token is available for sale\n', '   */\n', '  function mint(string _tokenURI, bytes16 _edition, uint256 _priceInWei, uint32 _auctionStartDate, address _artistAccount) external onlyKnownOrigin {\n', '    require(_artistAccount != address(0));\n', '\n', '    uint256 _tokenId = tokenIdPointer;\n', '\n', '    super._mint(msg.sender, _tokenId);\n', '    super._setTokenURI(_tokenId, _tokenURI);\n', '\n', '    editionToArtistAccount[_edition] = _artistAccount;\n', '\n', '    _populateTokenData(_tokenId, _edition, _priceInWei, _auctionStartDate);\n', '\n', '    tokenIdPointer = tokenIdPointer.add(1);\n', '  }\n', '\n', '  function _populateTokenData(uint _tokenId, bytes16 _edition, uint256 _priceInWei, uint32 _purchaseFromTime) internal {\n', '    tokenIdToEdition[_tokenId] = _edition;\n', '    editionToEditionNumber[_edition] = editionToEditionNumber[_edition].add(1);\n', '    tokenIdToPriceInWei[_tokenId] = _priceInWei;\n', '    tokenIdToPurchaseFromTime[_tokenId] = _purchaseFromTime;\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a KODA token\n', '   * @dev Reverts if token is not unsold or not owned by management\n', '   * @param _tokenId the KODA token ID\n', '   */\n', '  function burn(uint256 _tokenId) public onlyKnownOrigin onlyUnsold(_tokenId) onlyKnownOriginOwnedToken(_tokenId) {\n', '    require(exists(_tokenId));\n', '    super._burn(ownerOf(_tokenId), _tokenId);\n', '\n', '    bytes16 edition = tokenIdToEdition[_tokenId];\n', '\n', '    delete tokenIdToEdition[_tokenId];\n', '    delete tokenIdToPriceInWei[_tokenId];\n', '    delete tokenIdToPurchaseFromTime[_tokenId];\n', '\n', '    editionToEditionNumber[edition] = editionToEditionNumber[edition].sub(1);\n', '  }\n', '\n', '  /**\n', '   * @dev Utility function for updating a KODA assets token URI\n', '   * @dev Reverts if not called by management\n', '   * @param _tokenId the KODA token ID\n', '   * @param _uri the token URI, will be concatenated with baseUri\n', '   */\n', '  function setTokenURI(uint256 _tokenId, string _uri) external onlyKnownOrigin {\n', '    require(exists(_tokenId));\n', '    _setTokenURI(_tokenId, _uri);\n', '  }\n', '\n', '  /**\n', '   * @dev Utility function for updating a KODA assets price\n', '   * @dev Reverts if token is not unsold or not called by management\n', '   * @param _tokenId the KODA token ID\n', '   * @param _priceInWei the price in wei\n', '   */\n', '  function setPriceInWei(uint _tokenId, uint256 _priceInWei) external onlyKnownOrigin onlyUnsold(_tokenId) {\n', '    require(exists(_tokenId));\n', '    tokenIdToPriceInWei[_tokenId] = _priceInWei;\n', '  }\n', '\n', '  /**\n', '   * @dev Used to pre-approve a purchaser in order for internal purchase methods\n', '   * to succeed without calling approve() directly\n', '   * @param _tokenId the KODA token ID\n', '   * @return address currently approved for a the given token ID\n', '   */\n', '  function _approvePurchaser(address _to, uint256 _tokenId) internal {\n', '    address owner = ownerOf(_tokenId);\n', '    require(_to != address(0));\n', '\n', '    tokenApprovals[_tokenId] = _to;\n', '    Approval(owner, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Updates the commission structure for the given _type\n', '   * @dev Reverts if not called by management\n', '   * @param _type the asset type\n', '   * @param _curator the curators commission\n', '   * @param _developer the developers commission\n', '   */\n', '  function updateCommission(string _type, uint8 _curator, uint8 _developer) external onlyKnownOrigin {\n', '    require(_curator > 0);\n', '    require(_developer > 0);\n', '    require((_curator + _developer) < 100);\n', '\n', '    editionTypeToCommission[_type] = CommissionStructure({curator : _curator, developer : _developer});\n', '  }\n', '\n', '  /**\n', '   * @dev Utility function for retrieving the commission structure for the provided _type\n', '   * @param _type the asset type\n', '   * @return the commission structure or zero for both values when not found\n', '   */\n', '  function getCommissionForType(string _type) public view returns (uint8 _curator, uint8 _developer) {\n', '    CommissionStructure storage commission = editionTypeToCommission[_type];\n', '    return (commission.curator, commission.developer);\n', '  }\n', '\n', '  /**\n', '   * @dev Purchase the provide token in Ether\n', '   * @dev Reverts if token not unsold and not available to be purchased\n', '   * msg.sender will become the owner of the token\n', '   * msg.value needs to be >= to the token priceInWei\n', '   * @param _tokenId the KODA token ID\n', '   * @return true/false depending on success\n', '   */\n', '  function purchaseWithEther(uint256 _tokenId) public payable onlyUnsold(_tokenId) onlyKnownOriginOwnedToken(_tokenId) onlyAfterPurchaseFromTime(_tokenId) {\n', '    require(exists(_tokenId));\n', '\n', '    uint256 priceInWei = tokenIdToPriceInWei[_tokenId];\n', '    require(msg.value >= priceInWei);\n', '\n', '    // approve sender as they have paid the required amount\n', '    _approvePurchaser(msg.sender, _tokenId);\n', '\n', '    // transfer assets from contract creator (curator) to new owner\n', '    safeTransferFrom(ownerOf(_tokenId), msg.sender, _tokenId);\n', '\n', '    // now purchased - don&#39;t allow re-purchase!\n', '    tokenIdToPurchased[_tokenId] = PurchaseState.EtherPurchase;\n', '\n', '    totalPurchaseValueInWei = totalPurchaseValueInWei.add(msg.value);\n', '    totalNumberOfPurchases = totalNumberOfPurchases.add(1);\n', '\n', '    // Only apply commission if the art work has value\n', '    if (priceInWei > 0) {\n', '      _applyCommission(_tokenId);\n', '    }\n', '\n', '    PurchasedWithEther(_tokenId, msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Purchase the provide token in FIAT, management command only for taking fiat payments during KODA physical exhibitions\n', '   * Equivalent to taking the KODA token off the market and marking as sold\n', '   * @dev Reverts if token not unsold and not available to be purchased and not called by management\n', '   * @param _tokenId the KODA token ID\n', '   */\n', '  function purchaseWithFiat(uint256 _tokenId) public onlyKnownOrigin onlyUnsold(_tokenId) onlyAfterPurchaseFromTime(_tokenId) {\n', '    require(exists(_tokenId));\n', '\n', '    // now purchased - don&#39;t allow re-purchase!\n', '    tokenIdToPurchased[_tokenId] = PurchaseState.FiatPurchase;\n', '\n', '    totalNumberOfPurchases = totalNumberOfPurchases.add(1);\n', '\n', '    PurchasedWithFiat(_tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Reverse a fiat purchase made by calling purchaseWithFiat()\n', '   * @dev Reverts if token not purchased with fiat and not available to be purchased and not called by management\n', '   * @param _tokenId the KODA token ID\n', '   */\n', '  function reverseFiatPurchase(uint256 _tokenId) public onlyKnownOrigin onlyFiatPurchased(_tokenId) onlyAfterPurchaseFromTime(_tokenId) {\n', '    require(exists(_tokenId));\n', '\n', '    // reset to Unsold\n', '    tokenIdToPurchased[_tokenId] = PurchaseState.Unsold;\n', '\n', '    totalNumberOfPurchases = totalNumberOfPurchases.sub(1);\n', '\n', '    PurchasedWithFiatReversed(_tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function for apply commission on purchase\n', '   */\n', '  function _applyCommission(uint256 _tokenId) internal {\n', '    bytes16 edition = tokenIdToEdition[_tokenId];\n', '\n', '    string memory typeCode = getTypeFromEdition(edition);\n', '\n', '    CommissionStructure memory commission = editionTypeToCommission[typeCode];\n', '\n', '    // split & transfer fee for curator\n', '    uint curatorAccountFee = msg.value / 100 * commission.curator;\n', '    curatorAccount.transfer(curatorAccountFee);\n', '\n', '    // split & transfer fee for developer\n', '    uint developerAccountFee = msg.value / 100 * commission.developer;\n', '    developerAccount.transfer(developerAccountFee);\n', '\n', '    // final payment to commission would be the remaining value\n', '    uint finalCommissionTotal = msg.value - (curatorAccountFee + developerAccountFee);\n', '\n', '    // send ether\n', '    address artistAccount = editionToArtistAccount[edition];\n', '    artistAccount.transfer(finalCommissionTotal);\n', '  }\n', '\n', '  /**\n', '   * @dev Retrieve all asset information for the provided token\n', '   * @param _tokenId the KODA token ID\n', '   * @return tokenId, owner, purchaseState, priceInWei, purchaseFromDateTime\n', '   */\n', '  function assetInfo(uint _tokenId) public view returns (\n', '    uint256 _tokId,\n', '    address _owner,\n', '    PurchaseState _purchaseState,\n', '    uint256 _priceInWei,\n', '    uint32 _purchaseFromTime\n', '  ) {\n', '    return (\n', '      _tokenId,\n', '      tokenOwner[_tokenId],\n', '      tokenIdToPurchased[_tokenId],\n', '      tokenIdToPriceInWei[_tokenId],\n', '      tokenIdToPurchaseFromTime[_tokenId]\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Retrieve all edition information for the provided token\n', '   * @param _tokenId the KODA token ID\n', '   * @return tokenId, edition, editionNumber, tokenUri\n', '   */\n', '  function editionInfo(uint256 _tokenId) public view returns (\n', '    uint256 _tokId,\n', '    bytes16 _edition,\n', '    uint256 _editionNumber,\n', '    string _tokenURI,\n', '    address _artistAccount\n', '  ) {\n', '    bytes16 edition = tokenIdToEdition[_tokenId];\n', '    return (\n', '      _tokenId,\n', '      edition,\n', '      editionToEditionNumber[edition],\n', '      tokenURI(_tokenId),\n', '      editionToArtistAccount[edition]\n', '    );\n', '  }\n', '\n', '  function tokensOf(address _owner) public view returns (uint256[] _tokenIds) {\n', '    return ownedTokens[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Return the total number of assets in an edition\n', '   * @param _edition the edition identifier\n', '   */\n', '  function numberOf(bytes16 _edition) public view returns (uint256) {\n', '    return editionToEditionNumber[_edition];\n', '  }\n', '\n', '  /**\n', '   * @dev Get the token purchase state for the given token\n', '   * @param _tokenId the KODA token ID\n', '   * @return the purchase sate, either 0, 1, 2, reverts if token not found\n', '   */\n', '  function isPurchased(uint256 _tokenId) public view returns (PurchaseState _purchased) {\n', '    require(exists(_tokenId));\n', '    return tokenIdToPurchased[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Get the edition identifier for the given token\n', '   * @param _tokenId the KODA token ID\n', '   * @return the edition is found, reverts if token not found\n', '   */\n', '  function editionOf(uint256 _tokenId) public view returns (bytes16 _edition) {\n', '    require(exists(_tokenId));\n', '    return tokenIdToEdition[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Get the purchase from time for the given token\n', '   * @param _tokenId the KODA token ID\n', '   * @return the purchased from time, reverts if token not found\n', '   */\n', '  function purchaseFromTime(uint256 _tokenId) public view returns (uint32 _purchaseFromTime) {\n', '    require(exists(_tokenId));\n', '    return tokenIdToPurchaseFromTime[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Get the price in wei for the given token\n', '   * @param _tokenId the KODA token ID\n', '   * @return the price in wei, reverts if token not found\n', '   */\n', '  function priceInWei(uint256 _tokenId) public view returns (uint256 _priceInWei) {\n', '    require(exists(_tokenId));\n', '    return tokenIdToPriceInWei[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Get the type for the provided edition, useful for testing purposes\n', '   * @param _edition the edition identifier\n', '   * @return the type or blank string\n', '   */\n', '  function getTypeFromEdition(bytes16 _edition) public pure returns (string) {\n', '    // return last 3 chars that represent the edition type\n', '    return Strings.bytes16ToStr(_edition, 13, 16);\n', '  }\n', '\n', '  /**\n', '   * @dev Get token URI fro the given token, useful for testing purposes\n', '   * @param _tokenId the KODA token ID\n', '   * @return the token ID or only the base URI if not found\n', '   */\n', '  function tokenURI(uint256 _tokenId) public view returns (string) {\n', '    return Strings.strConcat(tokenBaseURI, tokenURIs[_tokenId]);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows management to update the base tokenURI path\n', '   * @dev Reverts if not called by management\n', '   * @param _newBaseURI the new base URI to set\n', '   */\n', '  function setTokenBaseURI(string _newBaseURI) external onlyKnownOrigin {\n', '    tokenBaseURI = _newBaseURI;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows management to update the artist account (where commission is sent)\n', '   * @dev Reverts if not called by management\n', '   * @param _edition edition to adjust\n', '    * @param _artistAccount address of artist on blockchain\n', '   */\n', '  function setArtistAccount(bytes16 _edition, address _artistAccount) external onlyKnownOrigin {\n', '    require(_artistAccount != address(0));\n', '\n', '    editionToArtistAccount[_edition] = _artistAccount;\n', '  }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '// File: contracts/ERC165.sol\n', '\n', 'interface ERC165 {\n', '  /// @notice Query if a contract implements an interface\n', '  /// @param interfaceID The interface identifier, as specified in ERC-165\n', '  /// @dev Interface identification is specified in ERC-165. This function\n', '  ///  uses less than 30,000 gas.\n', '  /// @return `true` if the contract implements `interfaceID` and\n', '  ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '  function supportsInterface(bytes4 interfaceID) external pure returns (bool);\n', '}\n', '\n', '// File: contracts/ERC721Basic.sol\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Basic {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public;\n', '}\n', '\n', '// File: contracts/ERC721.sol\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Enumerable is ERC721Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\n', '  function tokenByIndex(uint256 _index) public view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Metadata is ERC721Basic {\n', '  function name() public view returns (string _name);\n', '  function symbol() public view returns (string _symbol);\n', '  function tokenURI(uint256 _tokenId) public view returns (string);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n', '}\n', '\n', '// File: contracts/ERC721Receiver.sol\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' *  from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver {\n', '  /**\n', '   * @dev Magic value to be returned upon successful reception of an NFT\n', '   *  Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`,\n', '   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '   */\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  /**\n', '   * @notice Handle the receipt of an NFT\n', '   * @dev The ERC721 smart contract calls this function on the recipient\n', '   *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '   *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '   *  than the magic value MUST result in the transaction being reverted.\n', '   *  Note: the contract address is always the message sender.\n', '   * @param _from The sending address\n', '   * @param _tokenId The NFT identifier which is being transfered\n', '   * @param _data Additional data with no specified format\n', '   * @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '   */\n', '  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether there is code in the target address\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address address to check\n', '   * @return whether there is code in the target address\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/ERC721BasicToken.sol\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic implementation\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721BasicToken is ERC721Basic {\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  // Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  // Mapping from token ID to owner\n', '  mapping (uint256 => address) internal tokenOwner;\n', '\n', '  // Mapping from token ID to approved address\n', '  mapping (uint256 => address) internal tokenApprovals;\n', '\n', '  // Mapping from owner to number of owned token\n', '  mapping (address => uint256) internal ownedTokensCount;\n', '\n', '  // Mapping from owner to operator approvals\n', '  mapping (address => mapping (address => bool)) internal operatorApprovals;\n', '\n', '  /**\n', '  * @dev Guarantees msg.sender is owner of the given token\n', '  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n', '  */\n', '  modifier onlyOwnerOf(uint256 _tokenId) {\n', '    require(ownerOf(_tokenId) == msg.sender);\n', '    _;\n', '  }\n', '\n', '  /**\n', '  * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\n', '  * @param _tokenId uint256 ID of the token to validate\n', '  */\n', '  modifier canTransfer(uint256 _tokenId) {\n', '    require(isApprovedOrOwner(msg.sender, _tokenId));\n', '    _;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address\n', '  * @param _owner address to query the balance of\n', '  * @return uint256 representing the amount owned by the passed address\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    require(_owner != address(0));\n', '    return ownedTokensCount[_owner];\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the owner of the specified token ID\n', '  * @param _tokenId uint256 ID of the token to query the owner of\n', '  * @return owner address currently marked as the owner of the given token ID\n', '  */\n', '  function ownerOf(uint256 _tokenId) public view returns (address) {\n', '    address owner = tokenOwner[_tokenId];\n', '    require(owner != address(0));\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '  * @dev Returns whether the specified token exists\n', '  * @param _tokenId uint256 ID of the token to query the existance of\n', '  * @return whether the token exists\n', '  */\n', '  function exists(uint256 _tokenId) public view returns (bool) {\n', '    address owner = tokenOwner[_tokenId];\n', '    return owner != address(0);\n', '  }\n', '\n', '  /**\n', '  * @dev Approves another address to transfer the given token ID\n', '  * @dev The zero address indicates there is no approved address.\n', '  * @dev There can only be one approved address per token at a given time.\n', '  * @dev Can only be called by the token owner or an approved operator.\n', '  * @param _to address to be approved for the given token ID\n', '  * @param _tokenId uint256 ID of the token to be approved\n', '  */\n', '  function approve(address _to, uint256 _tokenId) public {\n', '    address owner = ownerOf(_tokenId);\n', '    require(_to != owner);\n', '    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '\n', '    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n', '      tokenApprovals[_tokenId] = _to;\n', '      Approval(owner, _to, _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the approved address for a token ID, or zero if no address set\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return address currently approved for a the given token ID\n', '   */\n', '  function getApproved(uint256 _tokenId) public view returns (address) {\n', '    return tokenApprovals[_tokenId];\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev Sets or unsets the approval of a given operator\n', '  * @dev An operator is allowed to transfer all tokens of the sender on their behalf\n', '  * @param _to operator address to set the approval\n', '  * @param _approved representing the status of the approval to be set\n', '  */\n', '  function setApprovalForAll(address _to, bool _approved) public {\n', '    require(_to != msg.sender);\n', '    operatorApprovals[msg.sender][_to] = _approved;\n', '    ApprovalForAll(msg.sender, _to, _approved);\n', '  }\n', '\n', '  /**\n', '   * @dev Tells whether an operator is approved by a given owner\n', '   * @param _owner owner address which you want to query the approval of\n', '   * @param _operator operator address which you want to query the approval of\n', '   * @return bool whether the given operator is approved by the given owner\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n', '    return operatorApprovals[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '  * @dev Transfers the ownership of a given token ID to another address\n', '  * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '  * @dev Requires the msg sender to be the owner, approved, or operator\n', '  * @param _from current owner of the token\n', '  * @param _to address to receive the ownership of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\n', '    require(_from != address(0));\n', '    require(_to != address(0));\n', '\n', '    clearApproval(_from, _tokenId);\n', '    removeTokenFrom(_from, _tokenId);\n', '    addTokenTo(_to, _tokenId);\n', '\n', '    Transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @dev Safely transfers the ownership of a given token ID to another address\n', '  * @dev If the target address is a contract, it must implement `onERC721Received`,\n', '  *  which is called upon a safe transfer, and return the magic value\n', '  *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise,\n', '  *  the transfer is reverted.\n', '  * @dev Requires the msg sender to be the owner, approved, or operator\n', '  * @param _from current owner of the token\n', '  * @param _to address to receive the ownership of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\n', '    safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '  * @dev Safely transfers the ownership of a given token ID to another address\n', '  * @dev If the target address is a contract, it must implement `onERC721Received`,\n', '  *  which is called upon a safe transfer, and return the magic value\n', '  *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise,\n', '  *  the transfer is reverted.\n', '  * @dev Requires the msg sender to be the owner, approved, or operator\n', '  * @param _from current owner of the token\n', '  * @param _to address to receive the ownership of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  * @param _data bytes data to send along with a safe transfer check\n', '  */\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public canTransfer(_tokenId) {\n', '    transferFrom(_from, _to, _tokenId);\n', '    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n', '  }\n', '\n', '  /**\n', '   * @dev Returns whether the given spender can transfer a given token ID\n', '   * @param _spender address of the spender to query\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @return bool whether the msg.sender is approved for the given token ID,\n', '   *  is an operator of the owner, or is the owner of the token\n', '   */\n', '  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\n', '    address owner = ownerOf(_tokenId);\n', '    return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to mint a new token\n', '  * @dev Reverts if the given token ID already exists\n', '  * @param _to The address that will own the minted token\n', '  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '  */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0));\n', '    addTokenTo(_to, _tokenId);\n', '    Transfer(address(0), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to burn a specific token\n', '  * @dev Reverts if the token does not exist\n', '  * @param _tokenId uint256 ID of the token being burned by the msg.sender\n', '  */\n', '  function _burn(address _owner, uint256 _tokenId) internal {\n', '    clearApproval(_owner, _tokenId);\n', '    removeTokenFrom(_owner, _tokenId);\n', '    Transfer(_owner, address(0), _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to clear current approval of a given token ID\n', '  * @dev Reverts if the given address is not indeed the owner of the token\n', '  * @param _owner owner of the token\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function clearApproval(address _owner, uint256 _tokenId) internal {\n', '    require(ownerOf(_tokenId) == _owner);\n', '    if (tokenApprovals[_tokenId] != address(0)) {\n', '      tokenApprovals[_tokenId] = address(0);\n', '      Approval(_owner, address(0), _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to add a token ID to the list of a given address\n', '  * @param _to address representing the new owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '  */\n', '  function addTokenTo(address _to, uint256 _tokenId) internal {\n', '    require(tokenOwner[_tokenId] == address(0));\n', '    tokenOwner[_tokenId] = _to;\n', '    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to remove a token ID from the list of a given address\n', '  * @param _from address representing the previous owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '  */\n', '  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n', '    require(ownerOf(_tokenId) == _from);\n', '    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n', '    tokenOwner[_tokenId] = address(0);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to invoke `onERC721Received` on a target address\n', '  * @dev The call is not executed if the target address is not a contract\n', '  * @param _from address representing the previous owner of the given token ID\n', '  * @param _to target address that will receive the tokens\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  * @param _data bytes optional data to send along with the call\n', '  * @return whether the call correctly returned the expected magic value\n', '  */\n', '  function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes _data) internal returns (bool) {\n', '    if (!_to.isContract()) {\n', '      return true;\n', '    }\n', '    bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\n', '    return (retval == ERC721_RECEIVED);\n', '  }\n', '}\n', '\n', '// File: contracts/ERC721Token.sol\n', '\n', '/**\n', ' * @title Full ERC721 Token\n', ' * This implementation includes all the required and some optional functionality of the ERC721 standard\n', ' * Moreover, it includes approve all functionality using operator terminology\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Token is ERC721, ERC721BasicToken {\n', '  // Token name\n', '  string internal name_;\n', '\n', '  // Token symbol\n', '  string internal symbol_;\n', '\n', '  // Mapping from owner to list of owned token IDs\n', '  mapping (address => uint256[]) internal ownedTokens;\n', '\n', '  // Mapping from token ID to index of the owner tokens list\n', '  mapping(uint256 => uint256) internal ownedTokensIndex;\n', '\n', '  // Array with all token ids, used for enumeration\n', '  uint256[] internal allTokens;\n', '\n', '  // Mapping from token id to position in the allTokens array\n', '  mapping(uint256 => uint256) internal allTokensIndex;\n', '\n', '  // Optional mapping for token URIs\n', '  mapping(uint256 => string) internal tokenURIs;\n', '\n', '  /**\n', '  * @dev Constructor function\n', '  */\n', '  function ERC721Token(string _name, string _symbol) public {\n', '    name_ = _name;\n', '    symbol_ = _symbol;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the token name\n', '  * @return string representing the token name\n', '  */\n', '  function name() public view returns (string) {\n', '    return name_;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the token symbol\n', '  * @return string representing the token symbol\n', '  */\n', '  function symbol() public view returns (string) {\n', '    return symbol_;\n', '  }\n', '\n', '  /**\n', '  * @dev Returns an URI for a given token ID\n', '  * @dev Throws if the token ID does not exist. May return an empty string.\n', '  * @param _tokenId uint256 ID of the token to query\n', '  */\n', '  function tokenURI(uint256 _tokenId) public view returns (string) {\n', '    require(exists(_tokenId));\n', '    return tokenURIs[_tokenId];\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to set the token URI for a given token\n', '  * @dev Reverts if the token ID does not exist\n', '  * @param _tokenId uint256 ID of the token to set its URI\n', '  * @param _uri string URI to assign\n', '  */\n', '  function _setTokenURI(uint256 _tokenId, string _uri) internal {\n', '    require(exists(_tokenId));\n', '    tokenURIs[_tokenId] = _uri;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the token ID at a given index of the tokens list of the requested owner\n', '  * @param _owner address owning the tokens list to be accessed\n', '  * @param _index uint256 representing the index to be accessed of the requested tokens list\n', '  * @return uint256 token ID at the given index of the tokens list owned by the requested address\n', '  */\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\n', '    require(_index < balanceOf(_owner));\n', '    return ownedTokens[_owner][_index];\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the total amount of tokens stored by the contract\n', '  * @return uint256 representing the total amount of tokens\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return allTokens.length;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the token ID at a given index of all the tokens in this contract\n', '  * @dev Reverts if the index is greater or equal to the total number of tokens\n', '  * @param _index uint256 representing the index to be accessed of the tokens list\n', '  * @return uint256 token ID at the given index of the tokens list\n', '  */\n', '  function tokenByIndex(uint256 _index) public view returns (uint256) {\n', '    require(_index < totalSupply());\n', '    return allTokens[_index];\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to add a token ID to the list of a given address\n', '  * @param _to address representing the new owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '  */\n', '  function addTokenTo(address _to, uint256 _tokenId) internal {\n', '    super.addTokenTo(_to, _tokenId);\n', '    uint256 length = ownedTokens[_to].length;\n', '    ownedTokens[_to].push(_tokenId);\n', '    ownedTokensIndex[_tokenId] = length;\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to remove a token ID from the list of a given address\n', '  * @param _from address representing the previous owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '  */\n', '  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n', '    super.removeTokenFrom(_from, _tokenId);\n', '\n', '    uint256 tokenIndex = ownedTokensIndex[_tokenId];\n', '    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n', '    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n', '\n', '    ownedTokens[_from][tokenIndex] = lastToken;\n', '    ownedTokens[_from][lastTokenIndex] = 0;\n', '    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n', '    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n', '    // the lastToken to the first position, and then dropping the element placed in the last position of the list\n', '\n', '    ownedTokens[_from].length--;\n', '    ownedTokensIndex[_tokenId] = 0;\n', '    ownedTokensIndex[lastToken] = tokenIndex;\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to mint a new token\n', '  * @dev Reverts if the given token ID already exists\n', '  * @param _to address the beneficiary that will own the minted token\n', '  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '  */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    super._mint(_to, _tokenId);\n', '\n', '    allTokensIndex[_tokenId] = allTokens.length;\n', '    allTokens.push(_tokenId);\n', '  }\n', '\n', '  /**\n', '  * @dev Internal function to burn a specific token\n', '  * @dev Reverts if the token does not exist\n', '  * @param _owner owner of the token to burn\n', '  * @param _tokenId uint256 ID of the token being burned by the msg.sender\n', '  */\n', '  function _burn(address _owner, uint256 _tokenId) internal {\n', '    super._burn(_owner, _tokenId);\n', '\n', '    // Clear metadata (if any)\n', '    if (bytes(tokenURIs[_tokenId]).length != 0) {\n', '      delete tokenURIs[_tokenId];\n', '    }\n', '\n', '    // Reorg all tokens array\n', '    uint256 tokenIndex = allTokensIndex[_tokenId];\n', '    uint256 lastTokenIndex = allTokens.length.sub(1);\n', '    uint256 lastToken = allTokens[lastTokenIndex];\n', '\n', '    allTokens[tokenIndex] = lastToken;\n', '    allTokens[lastTokenIndex] = 0;\n', '\n', '    allTokens.length--;\n', '    allTokensIndex[_tokenId] = 0;\n', '    allTokensIndex[lastToken] = tokenIndex;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/Strings.sol\n', '\n', 'library Strings {\n', '  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n', '  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n', '    bytes memory _ba = bytes(_a);\n', '    bytes memory _bb = bytes(_b);\n', '    bytes memory _bc = bytes(_c);\n', '    bytes memory _bd = bytes(_d);\n', '    bytes memory _be = bytes(_e);\n', '    string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '    bytes memory babcde = bytes(abcde);\n', '    uint k = 0;\n', '    for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '    for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '    for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '    for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '    for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '    return string(babcde);\n', '  }\n', '\n', '  function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n', '    return strConcat(_a, _b, _c, _d, "");\n', '  }\n', '\n', '  function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n', '    return strConcat(_a, _b, _c, "", "");\n', '  }\n', '\n', '  function strConcat(string _a, string _b) internal pure returns (string) {\n', '    return strConcat(_a, _b, "", "", "");\n', '  }\n', '\n', '  function bytes16ToStr(bytes16 _bytes16, uint8 _start, uint8 _end) internal pure returns (string) {\n', '    bytes memory bytesArray = new bytes(_end - _start);\n', '    uint8 pos = 0;\n', '    for (uint8 i = _start; i < _end; i++) {\n', '      bytesArray[pos] = _bytes16[i];\n', '      pos++;\n', '    }\n', '    return string(bytesArray);\n', '  }\n', '}\n', '\n', '// File: contracts/KnownOriginDigitalAsset.sol\n', '\n', '/**\n', '* @title KnownOriginDigitalAsset\n', '*\n', '* http://www.knownorigin.io/\n', '*\n', '* ERC721 compliant digital assets for real-world artwork.\n', '* BE ORIGINAL. BUY ORIGINAL.\n', '*\n', '*/\n', 'contract KnownOriginDigitalAsset is ERC721Token, ERC165 {\n', '  using SafeMath for uint256;\n', '\n', '  bytes4 constant InterfaceSignature_ERC165 = 0x01ffc9a7;\n', '    /*\n', "    bytes4(keccak256('supportsInterface(bytes4)'));\n", '    */\n', '\n', '  bytes4 constant InterfaceSignature_ERC721Enumerable = 0x780e9d63;\n', '    /*\n', "    bytes4(keccak256('totalSupply()')) ^\n", "    bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n", "    bytes4(keccak256('tokenByIndex(uint256)'));\n", '    */\n', '\n', '  bytes4 constant InterfaceSignature_ERC721Metadata = 0x5b5e139f;\n', '    /*\n', "    bytes4(keccak256('name()')) ^\n", "    bytes4(keccak256('symbol()')) ^\n", "    bytes4(keccak256('tokenURI(uint256)'));\n", '    */\n', '\n', '  bytes4 constant InterfaceSignature_ERC721 = 0x80ac58cd;\n', '    /*\n', "    bytes4(keccak256('balanceOf(address)')) ^\n", "    bytes4(keccak256('ownerOf(uint256)')) ^\n", "    bytes4(keccak256('approve(address,uint256)')) ^\n", "    bytes4(keccak256('getApproved(uint256)')) ^\n", "    bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n", "    bytes4(keccak256('isApprovedForAll(address,address)')) ^\n", "    bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n", "    bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n", "    bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'));\n", '    */\n', '\n', '  bytes4 public constant InterfaceSignature_ERC721Optional =- 0x4f558e79;\n', '    /*\n', "    bytes4(keccak256('exists(uint256)'));\n", '    */\n', '\n', '  /**\n', '   * @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n', '   * @dev Returns true for any standardized interfaces implemented by this contract.\n', '   * @param _interfaceID bytes4 the interface to check for\n', '   * @return true for any standardized interfaces implemented by this contract.\n', '   */\n', '  function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\n', '    return ((_interfaceID == InterfaceSignature_ERC165)\n', '    || (_interfaceID == InterfaceSignature_ERC721)\n', '    || (_interfaceID == InterfaceSignature_ERC721Optional)\n', '    || (_interfaceID == InterfaceSignature_ERC721Enumerable)\n', '    || (_interfaceID == InterfaceSignature_ERC721Metadata));\n', '  }\n', '\n', '  struct CommissionStructure {\n', '    uint8 curator;\n', '    uint8 developer;\n', '  }\n', '\n', '  string internal tokenBaseURI = "https://ipfs.infura.io/ipfs/";\n', '\n', '  // creates and owns the original assets all primary purchases transferred to this account\n', '  address public curatorAccount;\n', '\n', '  // the person who is responsible for designing and building the contract\n', '  address public developerAccount;\n', '\n', '  // total wei been processed through the contract\n', '  uint256 public totalPurchaseValueInWei;\n', '\n', '  // number of assets sold of any type\n', '  uint256 public totalNumberOfPurchases;\n', '\n', '  // A pointer to the next token to be minted, zero indexed\n', '  uint256 public tokenIdPointer = 0;\n', '\n', '  enum PurchaseState {Unsold, EtherPurchase, FiatPurchase}\n', '\n', '  mapping(string => CommissionStructure) internal editionTypeToCommission;\n', '  mapping(uint256 => PurchaseState) internal tokenIdToPurchased;\n', '\n', '  mapping(uint256 => bytes16) internal tokenIdToEdition;\n', '  mapping(uint256 => uint256) internal tokenIdToPriceInWei;\n', '  mapping(uint256 => uint32) internal tokenIdToPurchaseFromTime;\n', '\n', '  mapping(bytes16 => uint256) internal editionToEditionNumber;\n', '  mapping(bytes16 => address) internal editionToArtistAccount;\n', '\n', '  event PurchasedWithEther(uint256 indexed _tokenId, address indexed _buyer);\n', '\n', '  event PurchasedWithFiat(uint256 indexed _tokenId);\n', '\n', '  event PurchasedWithFiatReversed(uint256 indexed _tokenId);\n', '\n', '  modifier onlyCurator() {\n', '    require(msg.sender == curatorAccount);\n', '    _;\n', '  }\n', '\n', '  modifier onlyUnsold(uint256 _tokenId) {\n', '    require(tokenIdToPurchased[_tokenId] == PurchaseState.Unsold);\n', '    _;\n', '  }\n', '\n', '  modifier onlyFiatPurchased(uint256 _tokenId) {\n', '    require(tokenIdToPurchased[_tokenId] == PurchaseState.FiatPurchase);\n', '    _;\n', '  }\n', '\n', '  modifier onlyKnownOriginOwnedToken(uint256 _tokenId) {\n', '    require(tokenOwner[_tokenId] == curatorAccount || tokenOwner[_tokenId] == developerAccount);\n', '    _;\n', '  }\n', '\n', '  modifier onlyKnownOrigin() {\n', '    require(msg.sender == curatorAccount || msg.sender == developerAccount);\n', '    _;\n', '  }\n', '\n', '  modifier onlyAfterPurchaseFromTime(uint256 _tokenId) {\n', '    require(tokenIdToPurchaseFromTime[_tokenId] <= block.timestamp);\n', '    _;\n', '  }\n', '\n', '  function KnownOriginDigitalAsset(address _curatorAccount) public ERC721Token("KnownOriginDigitalAsset", "KODA") {\n', '    developerAccount = msg.sender;\n', '    curatorAccount = _curatorAccount;\n', '  }\n', '\n', "  // don't accept payment directly to contract\n", '  function() public payable {\n', '    revert();\n', '  }\n', '\n', '  /**\n', '   * @dev Mint a new KODA token\n', '   * @dev Reverts if not called by management\n', '   * @param _tokenURI the IPFS or equivalent hash\n', '   * @param _edition the identifier of the edition - leading 3 bytes are the artist code, trailing 3 bytes are the asset type\n', '   * @param _priceInWei the price of the KODA token\n', '   * @param _auctionStartDate the date when the token is available for sale\n', '   */\n', '  function mint(string _tokenURI, bytes16 _edition, uint256 _priceInWei, uint32 _auctionStartDate, address _artistAccount) external onlyKnownOrigin {\n', '    require(_artistAccount != address(0));\n', '\n', '    uint256 _tokenId = tokenIdPointer;\n', '\n', '    super._mint(msg.sender, _tokenId);\n', '    super._setTokenURI(_tokenId, _tokenURI);\n', '\n', '    editionToArtistAccount[_edition] = _artistAccount;\n', '\n', '    _populateTokenData(_tokenId, _edition, _priceInWei, _auctionStartDate);\n', '\n', '    tokenIdPointer = tokenIdPointer.add(1);\n', '  }\n', '\n', '  function _populateTokenData(uint _tokenId, bytes16 _edition, uint256 _priceInWei, uint32 _purchaseFromTime) internal {\n', '    tokenIdToEdition[_tokenId] = _edition;\n', '    editionToEditionNumber[_edition] = editionToEditionNumber[_edition].add(1);\n', '    tokenIdToPriceInWei[_tokenId] = _priceInWei;\n', '    tokenIdToPurchaseFromTime[_tokenId] = _purchaseFromTime;\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a KODA token\n', '   * @dev Reverts if token is not unsold or not owned by management\n', '   * @param _tokenId the KODA token ID\n', '   */\n', '  function burn(uint256 _tokenId) public onlyKnownOrigin onlyUnsold(_tokenId) onlyKnownOriginOwnedToken(_tokenId) {\n', '    require(exists(_tokenId));\n', '    super._burn(ownerOf(_tokenId), _tokenId);\n', '\n', '    bytes16 edition = tokenIdToEdition[_tokenId];\n', '\n', '    delete tokenIdToEdition[_tokenId];\n', '    delete tokenIdToPriceInWei[_tokenId];\n', '    delete tokenIdToPurchaseFromTime[_tokenId];\n', '\n', '    editionToEditionNumber[edition] = editionToEditionNumber[edition].sub(1);\n', '  }\n', '\n', '  /**\n', '   * @dev Utility function for updating a KODA assets token URI\n', '   * @dev Reverts if not called by management\n', '   * @param _tokenId the KODA token ID\n', '   * @param _uri the token URI, will be concatenated with baseUri\n', '   */\n', '  function setTokenURI(uint256 _tokenId, string _uri) external onlyKnownOrigin {\n', '    require(exists(_tokenId));\n', '    _setTokenURI(_tokenId, _uri);\n', '  }\n', '\n', '  /**\n', '   * @dev Utility function for updating a KODA assets price\n', '   * @dev Reverts if token is not unsold or not called by management\n', '   * @param _tokenId the KODA token ID\n', '   * @param _priceInWei the price in wei\n', '   */\n', '  function setPriceInWei(uint _tokenId, uint256 _priceInWei) external onlyKnownOrigin onlyUnsold(_tokenId) {\n', '    require(exists(_tokenId));\n', '    tokenIdToPriceInWei[_tokenId] = _priceInWei;\n', '  }\n', '\n', '  /**\n', '   * @dev Used to pre-approve a purchaser in order for internal purchase methods\n', '   * to succeed without calling approve() directly\n', '   * @param _tokenId the KODA token ID\n', '   * @return address currently approved for a the given token ID\n', '   */\n', '  function _approvePurchaser(address _to, uint256 _tokenId) internal {\n', '    address owner = ownerOf(_tokenId);\n', '    require(_to != address(0));\n', '\n', '    tokenApprovals[_tokenId] = _to;\n', '    Approval(owner, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Updates the commission structure for the given _type\n', '   * @dev Reverts if not called by management\n', '   * @param _type the asset type\n', '   * @param _curator the curators commission\n', '   * @param _developer the developers commission\n', '   */\n', '  function updateCommission(string _type, uint8 _curator, uint8 _developer) external onlyKnownOrigin {\n', '    require(_curator > 0);\n', '    require(_developer > 0);\n', '    require((_curator + _developer) < 100);\n', '\n', '    editionTypeToCommission[_type] = CommissionStructure({curator : _curator, developer : _developer});\n', '  }\n', '\n', '  /**\n', '   * @dev Utility function for retrieving the commission structure for the provided _type\n', '   * @param _type the asset type\n', '   * @return the commission structure or zero for both values when not found\n', '   */\n', '  function getCommissionForType(string _type) public view returns (uint8 _curator, uint8 _developer) {\n', '    CommissionStructure storage commission = editionTypeToCommission[_type];\n', '    return (commission.curator, commission.developer);\n', '  }\n', '\n', '  /**\n', '   * @dev Purchase the provide token in Ether\n', '   * @dev Reverts if token not unsold and not available to be purchased\n', '   * msg.sender will become the owner of the token\n', '   * msg.value needs to be >= to the token priceInWei\n', '   * @param _tokenId the KODA token ID\n', '   * @return true/false depending on success\n', '   */\n', '  function purchaseWithEther(uint256 _tokenId) public payable onlyUnsold(_tokenId) onlyKnownOriginOwnedToken(_tokenId) onlyAfterPurchaseFromTime(_tokenId) {\n', '    require(exists(_tokenId));\n', '\n', '    uint256 priceInWei = tokenIdToPriceInWei[_tokenId];\n', '    require(msg.value >= priceInWei);\n', '\n', '    // approve sender as they have paid the required amount\n', '    _approvePurchaser(msg.sender, _tokenId);\n', '\n', '    // transfer assets from contract creator (curator) to new owner\n', '    safeTransferFrom(ownerOf(_tokenId), msg.sender, _tokenId);\n', '\n', "    // now purchased - don't allow re-purchase!\n", '    tokenIdToPurchased[_tokenId] = PurchaseState.EtherPurchase;\n', '\n', '    totalPurchaseValueInWei = totalPurchaseValueInWei.add(msg.value);\n', '    totalNumberOfPurchases = totalNumberOfPurchases.add(1);\n', '\n', '    // Only apply commission if the art work has value\n', '    if (priceInWei > 0) {\n', '      _applyCommission(_tokenId);\n', '    }\n', '\n', '    PurchasedWithEther(_tokenId, msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Purchase the provide token in FIAT, management command only for taking fiat payments during KODA physical exhibitions\n', '   * Equivalent to taking the KODA token off the market and marking as sold\n', '   * @dev Reverts if token not unsold and not available to be purchased and not called by management\n', '   * @param _tokenId the KODA token ID\n', '   */\n', '  function purchaseWithFiat(uint256 _tokenId) public onlyKnownOrigin onlyUnsold(_tokenId) onlyAfterPurchaseFromTime(_tokenId) {\n', '    require(exists(_tokenId));\n', '\n', "    // now purchased - don't allow re-purchase!\n", '    tokenIdToPurchased[_tokenId] = PurchaseState.FiatPurchase;\n', '\n', '    totalNumberOfPurchases = totalNumberOfPurchases.add(1);\n', '\n', '    PurchasedWithFiat(_tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Reverse a fiat purchase made by calling purchaseWithFiat()\n', '   * @dev Reverts if token not purchased with fiat and not available to be purchased and not called by management\n', '   * @param _tokenId the KODA token ID\n', '   */\n', '  function reverseFiatPurchase(uint256 _tokenId) public onlyKnownOrigin onlyFiatPurchased(_tokenId) onlyAfterPurchaseFromTime(_tokenId) {\n', '    require(exists(_tokenId));\n', '\n', '    // reset to Unsold\n', '    tokenIdToPurchased[_tokenId] = PurchaseState.Unsold;\n', '\n', '    totalNumberOfPurchases = totalNumberOfPurchases.sub(1);\n', '\n', '    PurchasedWithFiatReversed(_tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function for apply commission on purchase\n', '   */\n', '  function _applyCommission(uint256 _tokenId) internal {\n', '    bytes16 edition = tokenIdToEdition[_tokenId];\n', '\n', '    string memory typeCode = getTypeFromEdition(edition);\n', '\n', '    CommissionStructure memory commission = editionTypeToCommission[typeCode];\n', '\n', '    // split & transfer fee for curator\n', '    uint curatorAccountFee = msg.value / 100 * commission.curator;\n', '    curatorAccount.transfer(curatorAccountFee);\n', '\n', '    // split & transfer fee for developer\n', '    uint developerAccountFee = msg.value / 100 * commission.developer;\n', '    developerAccount.transfer(developerAccountFee);\n', '\n', '    // final payment to commission would be the remaining value\n', '    uint finalCommissionTotal = msg.value - (curatorAccountFee + developerAccountFee);\n', '\n', '    // send ether\n', '    address artistAccount = editionToArtistAccount[edition];\n', '    artistAccount.transfer(finalCommissionTotal);\n', '  }\n', '\n', '  /**\n', '   * @dev Retrieve all asset information for the provided token\n', '   * @param _tokenId the KODA token ID\n', '   * @return tokenId, owner, purchaseState, priceInWei, purchaseFromDateTime\n', '   */\n', '  function assetInfo(uint _tokenId) public view returns (\n', '    uint256 _tokId,\n', '    address _owner,\n', '    PurchaseState _purchaseState,\n', '    uint256 _priceInWei,\n', '    uint32 _purchaseFromTime\n', '  ) {\n', '    return (\n', '      _tokenId,\n', '      tokenOwner[_tokenId],\n', '      tokenIdToPurchased[_tokenId],\n', '      tokenIdToPriceInWei[_tokenId],\n', '      tokenIdToPurchaseFromTime[_tokenId]\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Retrieve all edition information for the provided token\n', '   * @param _tokenId the KODA token ID\n', '   * @return tokenId, edition, editionNumber, tokenUri\n', '   */\n', '  function editionInfo(uint256 _tokenId) public view returns (\n', '    uint256 _tokId,\n', '    bytes16 _edition,\n', '    uint256 _editionNumber,\n', '    string _tokenURI,\n', '    address _artistAccount\n', '  ) {\n', '    bytes16 edition = tokenIdToEdition[_tokenId];\n', '    return (\n', '      _tokenId,\n', '      edition,\n', '      editionToEditionNumber[edition],\n', '      tokenURI(_tokenId),\n', '      editionToArtistAccount[edition]\n', '    );\n', '  }\n', '\n', '  function tokensOf(address _owner) public view returns (uint256[] _tokenIds) {\n', '    return ownedTokens[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Return the total number of assets in an edition\n', '   * @param _edition the edition identifier\n', '   */\n', '  function numberOf(bytes16 _edition) public view returns (uint256) {\n', '    return editionToEditionNumber[_edition];\n', '  }\n', '\n', '  /**\n', '   * @dev Get the token purchase state for the given token\n', '   * @param _tokenId the KODA token ID\n', '   * @return the purchase sate, either 0, 1, 2, reverts if token not found\n', '   */\n', '  function isPurchased(uint256 _tokenId) public view returns (PurchaseState _purchased) {\n', '    require(exists(_tokenId));\n', '    return tokenIdToPurchased[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Get the edition identifier for the given token\n', '   * @param _tokenId the KODA token ID\n', '   * @return the edition is found, reverts if token not found\n', '   */\n', '  function editionOf(uint256 _tokenId) public view returns (bytes16 _edition) {\n', '    require(exists(_tokenId));\n', '    return tokenIdToEdition[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Get the purchase from time for the given token\n', '   * @param _tokenId the KODA token ID\n', '   * @return the purchased from time, reverts if token not found\n', '   */\n', '  function purchaseFromTime(uint256 _tokenId) public view returns (uint32 _purchaseFromTime) {\n', '    require(exists(_tokenId));\n', '    return tokenIdToPurchaseFromTime[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Get the price in wei for the given token\n', '   * @param _tokenId the KODA token ID\n', '   * @return the price in wei, reverts if token not found\n', '   */\n', '  function priceInWei(uint256 _tokenId) public view returns (uint256 _priceInWei) {\n', '    require(exists(_tokenId));\n', '    return tokenIdToPriceInWei[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Get the type for the provided edition, useful for testing purposes\n', '   * @param _edition the edition identifier\n', '   * @return the type or blank string\n', '   */\n', '  function getTypeFromEdition(bytes16 _edition) public pure returns (string) {\n', '    // return last 3 chars that represent the edition type\n', '    return Strings.bytes16ToStr(_edition, 13, 16);\n', '  }\n', '\n', '  /**\n', '   * @dev Get token URI fro the given token, useful for testing purposes\n', '   * @param _tokenId the KODA token ID\n', '   * @return the token ID or only the base URI if not found\n', '   */\n', '  function tokenURI(uint256 _tokenId) public view returns (string) {\n', '    return Strings.strConcat(tokenBaseURI, tokenURIs[_tokenId]);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows management to update the base tokenURI path\n', '   * @dev Reverts if not called by management\n', '   * @param _newBaseURI the new base URI to set\n', '   */\n', '  function setTokenBaseURI(string _newBaseURI) external onlyKnownOrigin {\n', '    tokenBaseURI = _newBaseURI;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows management to update the artist account (where commission is sent)\n', '   * @dev Reverts if not called by management\n', '   * @param _edition edition to adjust\n', '    * @param _artistAccount address of artist on blockchain\n', '   */\n', '  function setArtistAccount(bytes16 _edition, address _artistAccount) external onlyKnownOrigin {\n', '    require(_artistAccount != address(0));\n', '\n', '    editionToArtistAccount[_edition] = _artistAccount;\n', '  }\n', '}']
