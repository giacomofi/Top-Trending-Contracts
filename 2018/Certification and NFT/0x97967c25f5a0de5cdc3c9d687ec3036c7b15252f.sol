['pragma solidity ^0.4.23;\n', '\n', '// https://www.pennyether.com\n', '\n', '/******* USING Registry **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .addressOf(bytes32): returns current address mapped to the name.\n', '    [modifier] .fromOwner(): requires the sender is owner.\n', '\n', '*************************************************/\n', '// Returned by .getRegistry()\n', 'interface IRegistry {\n', '    function owner() external view returns (address _addr);\n', '    function addressOf(bytes32 _name) external view returns (address _addr);\n', '}\n', '\n', 'contract UsingRegistry {\n', '    IRegistry private registry;\n', '\n', '    modifier fromOwner(){\n', '        require(msg.sender == getOwner());\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry)\n', '        public\n', '    {\n', '        require(_registry != 0);\n', '        registry = IRegistry(_registry);\n', '    }\n', '\n', '    function addressOf(bytes32 _name)\n', '        internal\n', '        view\n', '        returns(address _addr)\n', '    {\n', '        return registry.addressOf(_name);\n', '    }\n', '\n', '    function getOwner()\n', '        public\n', '        view\n', '        returns (address _addr)\n', '    {\n', '        return registry.owner();\n', '    }\n', '\n', '    function getRegistry()\n', '        public\n', '        view\n', '        returns (IRegistry _addr)\n', '    {\n', '        return registry;\n', '    }\n', '}\n', '\n', '\n', '/******* USING ADMIN ***********************\n', '\n', 'Gives the inherting contract access to:\n', '    .getAdmin(): returns the current address of the admin\n', '    [modifier] .fromAdmin: requires the sender is the admin\n', '\n', '*************************************************/\n', 'contract UsingAdmin is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromAdmin(){\n', '        require(msg.sender == getAdmin());\n', '        _;\n', '    }\n', '    \n', '    function getAdmin()\n', '        public\n', '        constant\n', '        returns (address _addr)\n', '    {\n', '        return addressOf("ADMIN");\n', '    }\n', '}\n', '\n', '/******* USING TREASURY **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .getTreasury(): returns current ITreasury instance\n', '    [modifier] .fromTreasury(): requires the sender is current Treasury\n', '\n', '*************************************************/\n', '// Returned by .getTreasury()\n', 'interface ITreasury {\n', '    function issueDividend() external returns (uint _profits);\n', '    function profitsSendable() external view returns (uint _profits);\n', '}\n', '\n', 'contract UsingTreasury is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromTreasury(){\n', '        require(msg.sender == address(getTreasury()));\n', '        _;\n', '    }\n', '    \n', '    function getTreasury()\n', '        public\n', '        view\n', '        returns (ITreasury)\n', '    {\n', '        return ITreasury(addressOf("TREASURY"));\n', '    }\n', '}\n', '\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    address => uint amounts. Address balances can be added to \n', '    or removed from via add() and subtract(). All balances can\n', '    be obtain by calling balances(). If an address has a 0 amount,\n', '    it is removed from the Ledger.\n', '\n', '    Note: THIS DOES NOT TEST FOR OVERFLOWS, but it&#39;s safe to\n', '          use to track Ether balances.\n', '\n', '    Public methods:\n', '      - [fromOwner] add()\n', '      - [fromOwner] subtract()\n', '    Public views:\n', '      - total()\n', '      - size()\n', '      - balanceOf()\n', '      - balances()\n', '      - entries() [to manually iterate]\n', '*/\n', 'contract Ledger {\n', '    uint public total;      // Total amount in Ledger\n', '\n', '    struct Entry {          // Doubly linked list tracks amount per address\n', '        uint balance;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        // If new entry, replace first entry with this one.\n', '        if (entry.balance == 0) {\n', '            entry.next = entries[0x0].next;\n', '            entries[entries[0x0].next].prev = _address;\n', '            entries[0x0].next = _address;\n', '        }\n', '        // Update stats.\n', '        total += _amt;\n', '        entry.balance += _amt;\n', '    }\n', '\n', '    function subtract(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '        returns (uint _amtRemoved)\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        uint _maxAmt = entry.balance;\n', '        if (_maxAmt == 0) return;\n', '        \n', '        if (_amt >= _maxAmt) {\n', '            // Subtract the max amount, and delete entry.\n', '            total -= _maxAmt;\n', '            entries[entry.prev].next = entry.next;\n', '            entries[entry.next].prev = entry.prev;\n', '            delete entries[_address];\n', '            return _maxAmt;\n', '        } else {\n', '            // Subtract the amount from entry.\n', '            total -= _amt;\n', '            entry.balance -= _amt;\n', '            return _amt;\n', '        }\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function balanceOf(address _address)\n', '        public\n', '        view\n', '        returns (uint _balance)\n', '    {\n', '        return entries[_address].balance;\n', '    }\n', '\n', '    function balances()\n', '        public\n', '        view\n', '        returns (address[] _addresses, uint[] _balances)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        _balances = new uint[](_size);\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _balances[_i] = entries[_curEntry.next].balance;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return (_addresses, _balances);\n', '    }\n', '}\n', '\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    addresses it has seen. Addresses can be added and removed\n', '    from the set, and a full list of addresses can be obtained.\n', '\n', '    Methods:\n', '     - [fromOwner] .add()\n', '     - [fromOwner] .remove()\n', '    Views:\n', '     - .size()\n', '     - .has()\n', '     - .addresses()\n', '*/\n', 'contract AddressSet {\n', '    \n', '    struct Entry {  // Doubly linked list\n', '        bool exists;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner.\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didCreate)\n', '    {\n', '        // Do not allow the adding of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', '        // If already exists, do nothing. Otherwise set it.\n', '        if (entry.exists) return;\n', '        else entry.exists = true;\n', '\n', '        // Replace first entry with this one.\n', '        // Before: HEAD <-> X <-> Y\n', '        // After: HEAD <-> THIS <-> X <-> Y\n', '        // do: THIS.NEXT = [0].next; [0].next.prev = THIS; [0].next = THIS; THIS.prev = 0;\n', '        Entry storage HEAD = entries[0x0];\n', '        entry.next = HEAD.next;\n', '        entries[HEAD.next].prev = _address;\n', '        HEAD.next = _address;\n', '        return true;\n', '    }\n', '\n', '    function remove(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didExist)\n', '    {\n', '        // Do not allow the removal of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', '        // If it doesn&#39;t exist already, there is nothing to do.\n', '        if (!entry.exists) return;\n', '\n', '        // Stitch together next and prev, delete entry.\n', '        // Before: X <-> THIS <-> Y\n', '        // After: X <-> Y\n', '        // do: THIS.next.prev = this.prev; THIS.prev.next = THIS.next;\n', '        entries[entry.prev].next = entry.next;\n', '        entries[entry.next].prev = entry.prev;\n', '        delete entries[_address];\n', '        return true;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function has(address _address)\n', '        public\n', '        view\n', '        returns (bool _exists)\n', '    {\n', '        return entries[_address].exists;\n', '    }\n', '\n', '    function addresses()\n', '        public\n', '        view\n', '        returns (address[] _addresses)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        // Iterate forward through all entries until the end.\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return _addresses;\n', '    }\n', '}\n', '\n', '/**\n', '  A simple class that manages bankroll, and maintains collateral.\n', '  This class only ever sends profits the Treasury. No exceptions.\n', '\n', '  - Anybody can add funding (according to whitelist)\n', '  - Anybody can tell profits (balance - (funding + collateral)) to go to Treasury.\n', '  - Anyone can remove their funding, so long as balance >= collateral.\n', '  - Whitelist is managed by getWhitelistOwner() -- typically Admin.\n', '\n', '  Exposes the following:\n', '    Public Methods\n', '     - addBankroll\n', '     - removeBankroll\n', '     - sendProfits\n', '    Public Views\n', '     - getCollateral\n', '     - profits\n', '     - profitsSent\n', '     - profitsTotal\n', '     - bankroll\n', '     - bankrollAvailable\n', '     - bankrolledBy\n', '     - bankrollerTable\n', '*/\n', 'contract Bankrollable is\n', '    UsingTreasury\n', '{   \n', '    // How much profits have been sent. \n', '    uint public profitsSent;\n', '    // Ledger keeps track of who has bankrolled us, and for how much\n', '    Ledger public ledger;\n', '    // This is a copy of ledger.total(), to save gas in .bankrollAvailable()\n', '    uint public bankroll;\n', '    // This is the whitelist of who can call .addBankroll()\n', '    AddressSet public whitelist;\n', '\n', '    modifier fromWhitelistOwner(){\n', '        require(msg.sender == getWhitelistOwner());\n', '        _;\n', '    }\n', '\n', '    event BankrollAdded(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event BankrollRemoved(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event ProfitsSent(uint time, address indexed treasury, uint amount);\n', '    event AddedToWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '    event RemovedFromWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '\n', '    // Constructor creates the ledger and whitelist, with self as owner.\n', '    constructor(address _registry)\n', '        UsingTreasury(_registry)\n', '        public\n', '    {\n', '        ledger = new Ledger(this);\n', '        whitelist = new AddressSet(this);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** WHITELIST MGMT ***********************/\n', '    /*****************************************************/    \n', '\n', '    function addToWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didAdd = whitelist.add(_addr);\n', '        if (_didAdd) emit AddedToWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    function removeFromWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didRemove = whitelist.remove(_addr);\n', '        if (_didRemove) emit RemovedFromWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC FUNCTIONS *********************/\n', '    /*****************************************************/\n', '\n', '    // Bankrollable contracts should be payable (to receive revenue)\n', '    function () public payable {}\n', '\n', '    // Increase funding by whatever value is sent\n', '    function addBankroll()\n', '        public\n', '        payable \n', '    {\n', '        require(whitelist.size()==0 || whitelist.has(msg.sender));\n', '        ledger.add(msg.sender, msg.value);\n', '        bankroll = ledger.total();\n', '        emit BankrollAdded(now, msg.sender, msg.value, bankroll);\n', '    }\n', '\n', '    // Removes up to _amount from Ledger, and sends it to msg.sender._callbackFn\n', '    function removeBankroll(uint _amount, string _callbackFn)\n', '        public\n', '        returns (uint _recalled)\n', '    {\n', '        // cap amount at the balance minus collateral, or nothing at all.\n', '        address _bankroller = msg.sender;\n', '        uint _collateral = getCollateral();\n', '        uint _balance = address(this).balance;\n', '        uint _available = _balance > _collateral ? _balance - _collateral : 0;\n', '        if (_amount > _available) _amount = _available;\n', '\n', '        // Try to remove _amount from ledger, get actual _amount removed.\n', '        _amount = ledger.subtract(_bankroller, _amount);\n', '        bankroll = ledger.total();\n', '        if (_amount == 0) return;\n', '\n', '        bytes4 _sig = bytes4(keccak256(_callbackFn));\n', '        require(_bankroller.call.value(_amount)(_sig));\n', '        emit BankrollRemoved(now, _bankroller, _amount, bankroll);\n', '        return _amount;\n', '    }\n', '\n', '    // Send any excess profits to treasury.\n', '    function sendProfits()\n', '        public\n', '        returns (uint _profits)\n', '    {\n', '        int _p = profits();\n', '        if (_p <= 0) return;\n', '        _profits = uint(_p);\n', '        profitsSent += _profits;\n', '        // Send profits to Treasury\n', '        address _tr = getTreasury();\n', '        require(_tr.call.value(_profits)());\n', '        emit ProfitsSent(now, _tr, _profits);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC VIEWS *************************/\n', '    /*****************************************************/\n', '\n', '    // Function must be overridden by inheritors to ensure collateral is kept.\n', '    function getCollateral()\n', '        public\n', '        view\n', '        returns (uint _amount);\n', '\n', '    // Function must be overridden by inheritors to enable whitelist control.\n', '    function getWhitelistOwner()\n', '        public\n', '        view\n', '        returns (address _addr);\n', '\n', '    // Profits are the difference between balance and threshold\n', '    function profits()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        int _balance = int(address(this).balance);\n', '        int _threshold = int(bankroll + getCollateral());\n', '        return _balance - _threshold;\n', '    }\n', '\n', '    // How profitable this contract is, overall\n', '    function profitsTotal()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        return int(profitsSent) + profits();\n', '    }\n', '\n', '    // Returns the amount that can currently be bankrolled.\n', '    //   - 0 if balance < collateral\n', '    //   - If profits: full bankroll\n', '    //   - If no profits: remaning bankroll: balance - collateral\n', '    function bankrollAvailable()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        uint _balance = address(this).balance;\n', '        uint _bankroll = bankroll;\n', '        uint _collat = getCollateral();\n', '        // Balance is below collateral!\n', '        if (_balance <= _collat) return 0;\n', '        // No profits, but we have a balance over collateral.\n', '        else if (_balance < _collat + _bankroll) return _balance - _collat;\n', '        // Profits. Return only _bankroll\n', '        else return _bankroll;\n', '    }\n', '\n', '    function bankrolledBy(address _addr)\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return ledger.balanceOf(_addr);\n', '    }\n', '\n', '    function bankrollerTable()\n', '        public\n', '        view\n', '        returns (address[], uint[])\n', '    {\n', '        return ledger.balances();\n', '    }\n', '}\n', '\n', 'contract VideoPokerUtils {\n', '    uint constant HAND_UNDEFINED = 0;\n', '    uint constant HAND_RF = 1;\n', '    uint constant HAND_SF = 2;\n', '    uint constant HAND_FK = 3;\n', '    uint constant HAND_FH = 4;\n', '    uint constant HAND_FL = 5;\n', '    uint constant HAND_ST = 6;\n', '    uint constant HAND_TK = 7;\n', '    uint constant HAND_TP = 8;\n', '    uint constant HAND_JB = 9;\n', '    uint constant HAND_HC = 10;\n', '    uint constant HAND_NOT_COMPUTABLE = 11;\n', '\n', '    /*****************************************************/\n', '    /********** PUBLIC PURE FUNCTIONS ********************/\n', '    /*****************************************************/\n', '\n', '    // Gets a new 5-card hand, stored in uint32\n', '    // Gas Cost: 3k\n', '    function getHand(uint256 _hash)\n', '        public\n', '        pure\n', '        returns (uint32)\n', '    {\n', '        // Return the cards as a hand.\n', '        return uint32(getCardsFromHash(_hash, 5, 0));\n', '    }\n', '\n', '    // Both _hand and _draws store the first card in the\n', '    //   rightmost position. _hand uses chunks of 6 bits.\n', '    //\n', '    // In the below example, hand is [9,18,35,12,32], and\n', '    // the cards 18 and 35 will be replaced.\n', '    //\n', '    // _hand:                                [9,18,35,12,32]  \n', '    //    encoding:    XX 100000 001100 100011 010010 001001\n', '    //      chunks:           32     12     35     18      9\n', '    //       order:        card5, card4, card3, card2, card1\n', '    //     decimal:                                540161161\n', '    //\n', '    // _draws:                               card2 and card4\n', '    //    encoding:   XXX      0      0      1      1      0\n', '    //       order:        card5, card4, card3, card2, card1 \n', '    //     decimal:                                        6\n', '    // \n', '    // Gas Cost: Fixed 6k gas. \n', '    function drawToHand(uint256 _hash, uint32 _hand, uint _draws)\n', '        public\n', '        pure\n', '        returns (uint32)\n', '    {\n', '        // Draws must be valid. If no hand, must draw all 5 cards.\n', '        assert(_draws <= 31);\n', '        assert(_hand != 0 || _draws == 31);\n', '        // Shortcuts. Return _hand on no draws, or 5 cards on full draw.\n', '        if (_draws == 0) return _hand;\n', '        if (_draws == 31) return uint32(getCardsFromHash(_hash, 5, handToBitmap(_hand)));\n', '\n', '        // Create a mask of 1&#39;s where new cards should go.\n', '        uint _newMask;\n', '        for (uint _i=0; _i<5; _i++) {\n', '            if (_draws & 2**_i == 0) continue;\n', '            _newMask |= 63 * (2**(6*_i));\n', '        }\n', '        // Create a mask of 0&#39;s where new cards should go.\n', '        // Be sure to use only first 30 bits (5 cards x 6 bits)\n', '        uint _discardMask = ~_newMask & (2**31-1);\n', '\n', '        // Select from _newHand, discard from _hand, and combine.\n', '        uint _newHand = getCardsFromHash(_hash, 5, handToBitmap(_hand));\n', '        _newHand &= _newMask;\n', '        _newHand |= _hand & _discardMask;\n', '        return uint32(_newHand);\n', '    }\n', '\n', '    // Looks at a hand of 5-cards, determines strictly the HandRank.\n', '    // Gas Cost: up to 7k depending on hand.\n', '    function getHandRank(uint32 _hand)\n', '        public\n', '        pure\n', '        returns (uint)\n', '    {\n', '        if (_hand == 0) return HAND_NOT_COMPUTABLE;\n', '\n', '        uint _card;\n', '        uint[] memory _valCounts = new uint[](13);\n', '        uint[] memory _suitCounts = new uint[](5);\n', '        uint _pairVal;\n', '        uint _minNonAce = 100;\n', '        uint _maxNonAce = 0;\n', '        uint _numPairs;\n', '        uint _maxSet;\n', '        bool _hasFlush;\n', '        bool _hasAce;\n', '\n', '        // Set all the values above.\n', '        // Note:\n', '        //   _hasTwoPair will be true even if one pair is Trips.\n', '        //   Likewise, _hasTrips will be true even if there are Quads.\n', '        uint _i;\n', '        uint _val;\n', '        for (_i=0; _i<5; _i++) {\n', '            _card = readFromCards(_hand, _i);\n', '            if (_card > 51) return HAND_NOT_COMPUTABLE;\n', '            \n', '            // update val and suit counts, and if it&#39;s a flush\n', '            _val = _card % 13;\n', '            _valCounts[_val]++;\n', '            _suitCounts[_card/13]++;\n', '            if (_suitCounts[_card/13] == 5) _hasFlush = true;\n', '            \n', '            // update _hasAce, and min/max value\n', '            if (_val == 0) {\n', '                _hasAce = true;\n', '            } else {\n', '                if (_val < _minNonAce) _minNonAce = _val;\n', '                if (_val > _maxNonAce) _maxNonAce = _val;\n', '            }\n', '\n', '            // update _pairVal, _numPairs, _maxSet\n', '            if (_valCounts[_val] == 2) {\n', '                if (_numPairs==0) _pairVal = _val;\n', '                _numPairs++;\n', '            } else if (_valCounts[_val] == 3) {\n', '                _maxSet = 3;\n', '            } else if (_valCounts[_val] == 4) {\n', '                _maxSet = 4;\n', '            }\n', '        }\n', '\n', '        if (_numPairs > 0){\n', '            // If they have quads, they can&#39;t have royal flush, so we can return.\n', '            if (_maxSet==4) return HAND_FK;\n', '            // One of the two pairs was the trips, so it&#39;s a full house.\n', '            if (_maxSet==3 && _numPairs==2) return HAND_FH;\n', '            // Trips is their best hand (no straight or flush possible)\n', '            if (_maxSet==3) return HAND_TK;\n', '            // Two pair is their best hand (no straight or flush possible)\n', '            if (_numPairs==2) return HAND_TP;\n', '            // One pair is their best hand (no straight or flush possible)\n', '            if (_numPairs == 1 && (_pairVal >= 10 || _pairVal==0)) return HAND_JB;\n', '            // They have a low pair (no straight or flush possible)\n', '            return HAND_HC;\n', '        }\n', '\n', '        // They have no pair. Do they have a straight?\n', '        bool _hasStraight = _hasAce\n', '            // Check for: A,1,2,3,4 or 9,10,11,12,A\n', '            ? _maxNonAce == 4 || _minNonAce == 9\n', '            // Check for X,X+1,X+2,X+3,X+4\n', '            : _maxNonAce - _minNonAce == 4;\n', '        \n', '        // Check for hands in order of rank.\n', '        if (_hasStraight && _hasFlush && _minNonAce==9) return HAND_RF;\n', '        if (_hasStraight && _hasFlush) return HAND_SF;\n', '        if (_hasFlush) return HAND_FL;\n', '        if (_hasStraight) return HAND_ST;\n', '        return HAND_HC;\n', '    }\n', '\n', '    // Not used anywhere, but added for convenience\n', '    function handToCards(uint32 _hand)\n', '        public\n', '        pure\n', '        returns (uint8[5] _cards)\n', '    {\n', '        uint32 _mask;\n', '        for (uint _i=0; _i<5; _i++){\n', '            _mask = uint32(63 * 2**(6*_i));\n', '            _cards[_i] = uint8((_hand & _mask) / (2**(6*_i)));\n', '        }\n', '    }\n', '\n', '\n', '\n', '    /*****************************************************/\n', '    /********** PRIVATE INTERNAL FUNCTIONS ***************/\n', '    /*****************************************************/\n', '\n', '    function readFromCards(uint _cards, uint _index)\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        uint _offset = 2**(6*_index);\n', '        uint _oneBits = 2**6 - 1;\n', '        return (_cards & (_oneBits * _offset)) / _offset;\n', '    }\n', '\n', '    // Returns a bitmap to represent the set of cards in _hand.\n', '    function handToBitmap(uint32 _hand)\n', '        internal\n', '        pure\n', '        returns (uint _bitmap)\n', '    {\n', '        if (_hand == 0) return 0;\n', '        uint _mask;\n', '        uint _card;\n', '        for (uint _i=0; _i<5; _i++){\n', '            _mask = 63 * 2**(6*_i);\n', '            _card = (_hand & _mask) / (2**(6*_i));\n', '            _bitmap |= 2**_card;\n', '        }\n', '    }\n', '\n', '    // Returns numCards from a uint256 (eg, keccak256) seed hash.\n', '    // Returns cards as one uint, with each card being 6 bits.\n', '    function getCardsFromHash(uint256 _hash, uint _numCards, uint _usedBitmap)\n', '        internal\n', '        pure\n', '        returns (uint _cards)\n', '    {\n', '        // Return early if we don&#39;t need to pick any cards.\n', '        if (_numCards == 0) return;\n', '\n', '        uint _cardIdx = 0;                // index of currentCard\n', '        uint _card;                       // current chosen card\n', '        uint _usedMask;                   // mask of current card\n', '\n', '        while (true) {\n', '            _card = _hash % 52;           // Generate card from hash\n', '            _usedMask = 2**_card;         // Create mask for the card\n', '\n', '            // If card is not used, add it to _cards and _usedBitmap\n', '            // Return if we have enough cards.\n', '            if (_usedBitmap & _usedMask == 0) {\n', '                _cards |= (_card * 2**(_cardIdx*6));\n', '                _usedBitmap |= _usedMask;\n', '                _cardIdx++;\n', '                if (_cardIdx == _numCards) return _cards;\n', '            }\n', '\n', '            // Generate hash used to pick next card.\n', '            _hash = uint256(keccak256(_hash));\n', '        }\n', '    }\n', '}\n', '\n', 'contract VideoPoker is\n', '    VideoPokerUtils,\n', '    Bankrollable,\n', '    UsingAdmin\n', '{\n', '    // All the data needed for each game.\n', '    struct Game {\n', '        // [1st 256-bit block]\n', '        uint32 userId;\n', '        uint64 bet;         // max of 18 Ether (set on bet)\n', '        uint16 payTableId;  // the PayTable used (set on bet)\n', '        uint32 iBlock;      // initial hand block (set on bet)\n', '        uint32 iHand;       // initial hand (set on draw/finalize)\n', '        uint8 draws;        // bitmap of which cards to draw (set on draw/finalize)\n', '        uint32 dBlock;      // block of the dHand (set on draw/finalize)\n', '        uint32 dHand;       // hand after draws (set on finalize)\n', '        uint8 handRank;     // result of the hand (set on finalize)\n', '    }\n', '\n', '    // These variables change on each bet and finalization.\n', '    // We put them in a struct with the hopes that optimizer\n', '    //   will do one write if any/all of them change.\n', '    struct Vars {\n', '        // [1st 256-bit block]\n', '        uint32 curId;               // (changes on bet)\n', '        uint64 totalWageredGwei;    // (changes on bet)\n', '        uint32 curUserId;           // (changes on bet, maybe)\n', '        uint128 empty1;             // intentionally left empty, so the below\n', '                                    //   updates occur in the same update\n', '        // [2nd 256-bit block]\n', '        uint64 totalWonGwei;        // (changes on finalization win)\n', '        uint88 totalCredits;        // (changes on finalization win)\n', '        uint8 empty2;               // set to true to normalize gas cost\n', '    }\n', '\n', '    struct Settings {\n', '        uint64 minBet;\n', '        uint64 maxBet;\n', '        uint16 curPayTableId;\n', '        uint16 numPayTables;\n', '        uint32 lastDayAdded;\n', '    }\n', '\n', '    Settings settings;\n', '    Vars vars;\n', '\n', '    // A Mapping of all games\n', '    mapping(uint32 => Game) public games;\n', '    \n', '    // Credits we owe the user\n', '    mapping(address => uint) public credits;\n', '\n', '    // Store a two-way mapping of address <=> userId\n', '    // If we&#39;ve seen a user before, betting will be just 1 write\n', '    //  per Game struct vs 2 writes.\n', '    // The trade-off is 3 writes for new users. Seems fair.\n', '    mapping (address => uint32) public userIds;\n', '    mapping (uint32 => address) public userAddresses;\n', '\n', '    // Note: Pay tables cannot be changed once added.\n', '    // However, admin can change the current PayTable\n', '    mapping(uint16=>uint16[12]) payTables;\n', '\n', '    // version of the game\n', '    uint8 public constant version = 2;\n', '    uint8 constant WARN_IHAND_TIMEOUT = 1; // "Initial hand not available. Drawing 5 new cards."\n', '    uint8 constant WARN_DHAND_TIMEOUT = 2; // "Draw cards not available. Using initial hand."\n', '    uint8 constant WARN_BOTH_TIMEOUT = 3;  // "Draw cards not available, and no initial hand."\n', '    \n', '    // Admin Events\n', '    event Created(uint time);\n', '    event PayTableAdded(uint time, address admin, uint payTableId);\n', '    event SettingsChanged(uint time, address admin);\n', '    // Game Events\n', '    event BetSuccess(uint time, address indexed user, uint32 indexed id, uint bet, uint payTableId);\n', '    event BetFailure(uint time, address indexed user, uint bet, string msg);\n', '    event DrawSuccess(uint time, address indexed user, uint32 indexed id, uint32 iHand, uint8 draws, uint8 warnCode);\n', '    event DrawFailure(uint time, address indexed user, uint32 indexed id, uint8 draws, string msg);\n', '    event FinalizeSuccess(uint time, address indexed user, uint32 indexed id, uint32 dHand, uint8 handRank, uint payout, uint8 warnCode);\n', '    event FinalizeFailure(uint time, address indexed user, uint32 indexed id, string msg);\n', '    // Credits\n', '    event CreditsAdded(uint time, address indexed user, uint32 indexed id, uint amount);\n', '    event CreditsUsed(uint time, address indexed user, uint32 indexed id, uint amount);\n', '    event CreditsCashedout(uint time, address indexed user, uint amount);\n', '        \n', '    constructor(address _registry)\n', '        Bankrollable(_registry)\n', '        UsingAdmin(_registry)\n', '        public\n', '    {\n', '        // Add the default PayTable.\n', '        _addPayTable(800, 50, 25, 9, 6, 4, 3, 2, 1);\n', '        // write to vars, to lower gas-cost for the first game.\n', '        // vars.empty1 = 1;\n', '        // vars.empty2 = 1;\n', '        // initialze stats to last settings\n', '        vars.curId = 293;\n', '        vars.totalWageredGwei =2864600000;\n', '        vars.curUserId = 38;\n', '        vars.totalWonGwei = 2450400000;\n', '\n', '        // initialize settings\n', '        settings.minBet = .001 ether;\n', '        settings.maxBet = .375 ether;\n', '        emit Created(now);\n', '    }\n', '    \n', '    \n', '    /************************************************************/\n', '    /******************** ADMIN FUNCTIONS ***********************/\n', '    /************************************************************/\n', '    \n', '    // Allows admin to change minBet, maxBet, and curPayTableId\n', '    function changeSettings(uint64 _minBet, uint64 _maxBet, uint8 _payTableId)\n', '        public\n', '        fromAdmin\n', '    {\n', '        require(_maxBet <= .375 ether);\n', '        require(_payTableId < settings.numPayTables);\n', '        settings.minBet = _minBet;\n', '        settings.maxBet = _maxBet;\n', '        settings.curPayTableId = _payTableId;\n', '        emit SettingsChanged(now, msg.sender);\n', '    }\n', '    \n', '    // Allows admin to permanently add a PayTable (once per day)\n', '    function addPayTable(\n', '        uint16 _rf, uint16 _sf, uint16 _fk, uint16 _fh,\n', '        uint16 _fl, uint16 _st, uint16 _tk, uint16 _tp, uint16 _jb\n', '    )\n', '        public\n', '        fromAdmin\n', '    {\n', '        uint32 _today = uint32(block.timestamp / 1 days);\n', '        require(settings.lastDayAdded < _today);\n', '        settings.lastDayAdded = _today;\n', '        _addPayTable(_rf, _sf, _fk, _fh, _fl, _st, _tk, _tp, _jb);\n', '        emit PayTableAdded(now, msg.sender, settings.numPayTables-1);\n', '    }\n', '    \n', '\n', '    /************************************************************/\n', '    /****************** PUBLIC FUNCTIONS ************************/\n', '    /************************************************************/\n', '\n', '    // Allows a user to add credits to their account.\n', '    function addCredits()\n', '        public\n', '        payable\n', '    {\n', '        _creditUser(msg.sender, msg.value, 0);\n', '    }\n', '\n', '    // Allows the user to cashout an amt (or their whole balance)\n', '    function cashOut(uint _amt)\n', '        public\n', '    {\n', '        _uncreditUser(msg.sender, _amt);\n', '    }\n', '\n', '    // Allows a user to create a game from Ether sent.\n', '    //\n', '    // Gas Cost: 55k (prev player), 95k (new player)\n', '    //   - 22k: tx overhead\n', '    //   - 26k, 66k: see _createNewGame()\n', '    //   -  3k: event\n', '    //   -  2k: curMaxBet()\n', '    //   -  2k: SLOAD, execution\n', '    function bet()\n', '        public\n', '        payable\n', '    {\n', '        uint _bet = msg.value;\n', '        if (_bet > settings.maxBet)\n', '            return _betFailure("Bet too large.", _bet, true);\n', '        if (_bet < settings.minBet)\n', '            return _betFailure("Bet too small.", _bet, true);\n', '        if (_bet > curMaxBet())\n', '            return _betFailure("The bankroll is too low.", _bet, true);\n', '\n', '        // no uint64 overflow: _bet < maxBet < .625 ETH < 2e64\n', '        uint32 _id = _createNewGame(uint64(_bet));\n', '        emit BetSuccess(now, msg.sender, _id, _bet, settings.curPayTableId);\n', '    }\n', '\n', '    // Allows a user to create a game from Credits.\n', '    //\n', '    // Gas Cost: 61k\n', '    //   - 22k: tx overhead\n', '    //   - 26k: see _createNewGame()\n', '    //   -  3k: event\n', '    //   -  2k: curMaxBet()\n', '    //   -  2k: 1 event: CreditsUsed\n', '    //   -  5k: update credits[user]\n', '    //   -  1k: SLOAD, execution\n', '    function betWithCredits(uint64 _bet)\n', '        public\n', '    {\n', '        if (_bet > settings.maxBet)\n', '            return _betFailure("Bet too large.", _bet, false);\n', '        if (_bet < settings.minBet)\n', '            return _betFailure("Bet too small.", _bet, false);\n', '        if (_bet > curMaxBet())\n', '            return _betFailure("The bankroll is too low.", _bet, false);\n', '        if (_bet > credits[msg.sender])\n', '            return _betFailure("Insufficient credits", _bet, false);\n', '\n', '        uint32 _id = _createNewGame(uint64(_bet));\n', '        vars.totalCredits -= uint88(_bet);\n', '        credits[msg.sender] -= _bet;\n', '        emit CreditsUsed(now, msg.sender, _id, _bet);\n', '        emit BetSuccess(now, msg.sender, _id, _bet, settings.curPayTableId);\n', '    }\n', '\n', '    function betFromGame(uint32 _id, bytes32 _hashCheck)\n', '        public\n', '    {\n', '        bool _didFinalize = finalize(_id, _hashCheck);\n', '        uint64 _bet = games[_id].bet;\n', '        if (!_didFinalize)\n', '            return _betFailure("Failed to finalize prior game.", _bet, false);\n', '        betWithCredits(_bet);\n', '    }\n', '\n', '        // Logs an error, and optionally refunds user the _bet\n', '        function _betFailure(string _msg, uint _bet, bool _doRefund)\n', '            private\n', '        {\n', '            if (_doRefund) require(msg.sender.call.value(_bet)());\n', '            emit BetFailure(now, msg.sender, _bet, _msg);\n', '        }\n', '        \n', '\n', '    // Resolves the initial hand (if possible) and sets the users draws.\n', '    // Users cannot draw 0 cards. They should instead use finalize().\n', '    //\n', '    // Notes:\n', '    //  - If user unable to resolve initial hand, sets draws to 5\n', '    //  - This always sets game.dBlock\n', '    //\n', '    // Gas Cost: ~38k\n', '    //   - 23k: tx\n', '    //   - 13k: see _draw()\n', '    //   -  2k: SLOADs, execution\n', '    function draw(uint32 _id, uint8 _draws, bytes32 _hashCheck)\n', '        public\n', '    {\n', '        Game storage _game = games[_id];\n', '        address _user = userAddresses[_game.userId];\n', '        if (_game.iBlock == 0)\n', '            return _drawFailure(_id, _draws, "Invalid game Id.");\n', '        if (_user != msg.sender)\n', '            return _drawFailure(_id, _draws, "This is not your game.");\n', '        if (_game.iBlock == block.number)\n', '            return _drawFailure(_id, _draws, "Initial cards not available.");\n', '        if (_game.dBlock != 0)\n', '            return _drawFailure(_id, _draws, "Cards already drawn.");\n', '        if (_draws > 31)\n', '            return _drawFailure(_id, _draws, "Invalid draws.");\n', '        if (_draws == 0)\n', '            return _drawFailure(_id, _draws, "Cannot draw 0 cards. Use finalize instead.");\n', '        if (_game.handRank != HAND_UNDEFINED)\n', '            return _drawFailure(_id, _draws, "Game already finalized.");\n', '        \n', '        _draw(_game, _id, _draws, _hashCheck);\n', '    }\n', '        function _drawFailure(uint32 _id, uint8 _draws, string _msg)\n', '            private\n', '        {\n', '            emit DrawFailure(now, msg.sender, _id, _draws, _msg);\n', '        }\n', '      \n', '\n', '    // Callable any time after the initial hand. Will assume\n', '    // no draws if called directly after new hand.\n', '    //\n', '    // Gas Cost: 44k (loss), 59k (win, has credits), 72k (win, no credits)\n', '    //   - 22k: tx overhead\n', '    //   - 21k, 36k, 49k: see _finalize()\n', '    //   -  1k: SLOADs, execution\n', '    function finalize(uint32 _id, bytes32 _hashCheck)\n', '        public\n', '        returns (bool _didFinalize)\n', '    {\n', '        Game storage _game = games[_id];\n', '        address _user = userAddresses[_game.userId];\n', '        if (_game.iBlock == 0)\n', '            return _finalizeFailure(_id, "Invalid game Id.");\n', '        if (_user != msg.sender)\n', '            return _finalizeFailure(_id, "This is not your game.");\n', '        if (_game.iBlock == block.number)\n', '            return _finalizeFailure(_id, "Initial hand not avaiable.");\n', '        if (_game.dBlock == block.number)\n', '            return _finalizeFailure(_id, "Drawn cards not available.");\n', '        if (_game.handRank != HAND_UNDEFINED)\n', '            return _finalizeFailure(_id, "Game already finalized.");\n', '\n', '        _finalize(_game, _id, _hashCheck);\n', '        return true;\n', '    }\n', '        function _finalizeFailure(uint32 _id, string _msg)\n', '            private\n', '            returns (bool)\n', '        {\n', '            emit FinalizeFailure(now, msg.sender, _id, _msg);\n', '            return false;\n', '        }\n', '\n', '\n', '    /************************************************************/\n', '    /****************** PRIVATE FUNCTIONS ***********************/\n', '    /************************************************************/\n', '\n', '    // Appends a PayTable to the mapping.\n', '    // It ensures sane values. (Double the defaults)\n', '    function _addPayTable(\n', '        uint16 _rf, uint16 _sf, uint16 _fk, uint16 _fh,\n', '        uint16 _fl, uint16 _st, uint16 _tk, uint16 _tp, uint16 _jb\n', '    )\n', '        private\n', '    {\n', '        require(_rf<=1600 && _sf<=100 && _fk<=50 && _fh<=18 && _fl<=12 \n', '                 && _st<=8 && _tk<=6 && _tp<=4 && _jb<=2);\n', '\n', '        uint16[12] memory _pt;\n', '        _pt[HAND_UNDEFINED] = 0;\n', '        _pt[HAND_RF] = _rf;\n', '        _pt[HAND_SF] = _sf;\n', '        _pt[HAND_FK] = _fk;\n', '        _pt[HAND_FH] = _fh;\n', '        _pt[HAND_FL] = _fl;\n', '        _pt[HAND_ST] = _st;\n', '        _pt[HAND_TK] = _tk;\n', '        _pt[HAND_TP] = _tp;\n', '        _pt[HAND_JB] = _jb;\n', '        _pt[HAND_HC] = 0;\n', '        _pt[HAND_NOT_COMPUTABLE] = 0;\n', '        payTables[settings.numPayTables] = _pt;\n', '        settings.numPayTables++;\n', '    }\n', '\n', '    // Increases totalCredits and credits[user]\n', '    // Optionally increases totalWonGwei stat.\n', '    function _creditUser(address _user, uint _amt, uint32 _gameId)\n', '        private\n', '    {\n', '        if (_amt == 0) return;\n', '        uint64 _incr = _gameId == 0 ? 0 : uint64(_amt / 1e9);\n', '        uint88 _totalCredits = vars.totalCredits + uint88(_amt);\n', '        uint64 _totalWonGwei = vars.totalWonGwei + _incr;\n', '        vars.totalCredits = _totalCredits;\n', '        vars.totalWonGwei = _totalWonGwei;\n', '        credits[_user] += _amt;\n', '        emit CreditsAdded(now, _user, _gameId, _amt);\n', '    }\n', '\n', '    // Lowers totalCredits and credits[user].\n', '    // Sends to user, using unlimited gas.\n', '    function _uncreditUser(address _user, uint _amt)\n', '        private\n', '    {\n', '        if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];\n', '        if (_amt == 0) return;\n', '        vars.totalCredits -= uint88(_amt);\n', '        credits[_user] -= _amt;\n', '        require(_user.call.value(_amt)());\n', '        emit CreditsCashedout(now, _user, _amt);\n', '    }\n', '\n', '    // Creates a new game with the specified bet and current PayTable.\n', '    // Does no validation of the _bet size.\n', '    //\n', '    // Gas Cost: 26k, 66k\n', '    //   Overhead:\n', '    //     - 20k: 1 writes: Game\n', '    //     -  5k: 1 update: vars\n', '    //     -  1k: SLOAD, execution\n', '    //   New User:\n', '    //     - 40k: 2 writes: userIds, userAddresses\n', '    //   Repeat User:\n', '    //     -  0k: nothing extra\n', '    function _createNewGame(uint64 _bet)\n', '        private\n', '        returns (uint32 _curId)\n', '    {\n', '        // get or create user id\n', '        uint32 _curUserId = vars.curUserId;\n', '        uint32 _userId = userIds[msg.sender];\n', '        if (_userId == 0) {\n', '            _curUserId++;\n', '            userIds[msg.sender] = _curUserId;\n', '            userAddresses[_curUserId] = msg.sender;\n', '            _userId = _curUserId;\n', '        }\n', '\n', '        // increment vars\n', '        _curId =  vars.curId + 1;\n', '        uint64 _totalWagered = vars.totalWageredGwei + _bet / 1e9;\n', '        vars.curId = _curId;\n', '        vars.totalWageredGwei = _totalWagered;\n', '        vars.curUserId = _curUserId;\n', '\n', '        // save game\n', '        uint16 _payTableId = settings.curPayTableId;\n', '        Game storage _game = games[_curId];\n', '        _game.userId = _userId;\n', '        _game.bet = _bet;\n', '        _game.payTableId = _payTableId;\n', '        _game.iBlock = uint32(block.number);\n', '        return _curId;\n', '    }\n', '\n', '    // Gets initialHand, and stores .draws and .dBlock.\n', '    // Gas Cost: 13k\n', '    //   - 3k: getHand()\n', '    //   - 5k: 1 update: iHand, draws, dBlock\n', '    //   - 3k: event: DrawSuccess\n', '    //   - 2k: SLOADs, other\n', '    function _draw(Game storage _game, uint32 _id, uint8 _draws, bytes32 _hashCheck)\n', '        private\n', '    {\n', '        // assert hand is not already drawn\n', '        assert(_game.dBlock == 0);\n', '\n', '        // Deal the initial hand, or set draws to 5.\n', '        uint32 _iHand;\n', '        bytes32 _iBlockHash = blockhash(_game.iBlock);\n', '        uint8 _warnCode;\n', '        if (_iBlockHash != 0) {\n', '            // Ensure they are drawing against expected hand\n', '            if (_iBlockHash != _hashCheck) {\n', '                return _drawFailure(_id, _draws, "HashCheck Failed. Try refreshing game.");\n', '            }\n', '            _iHand = getHand(uint(keccak256(_iBlockHash, _id)));\n', '        } else {\n', '            _warnCode = WARN_IHAND_TIMEOUT;\n', '            _draws = 31;\n', '        }\n', '\n', '        // update game\n', '        _game.iHand = _iHand;\n', '        _game.draws = _draws;\n', '        _game.dBlock = uint32(block.number);\n', '\n', '        emit DrawSuccess(now, msg.sender, _id, _game.iHand, _draws, _warnCode);\n', '    }\n', '\n', '    // Resolves game based on .iHand and .draws, crediting user on a win.\n', '    // This always sets game.dHand and game.handRank.\n', '    //\n', '    // There are four possible scenarios:\n', '    //   User draws N cads, and dBlock is fresh:\n', '    //     - draw N cards into iHand, this is dHand\n', '    //   User draws N cards, and dBlock is too old:\n', '    //     - set dHand to iHand (note: iHand may be empty)\n', '    //   User draws 0 cards, and iBlock is fresh:\n', '    //     - draw 5 cards into iHand, set dHand to iHand\n', '    //   User draws 0 cards, and iBlock is too old:\n', '    //     - fail: set draws to 5, return. (user should call finalize again)\n', '    //\n', '    // Gas Cost: 21k loss, 36k win, 49k new win\n', '    //   - 6k: if draws > 0: drawToHand()\n', '    //   - 7k: getHandRank()\n', '    //   - 5k: 1 update: Game\n', '    //   - 2k: FinalizeSuccess\n', '    //   - 1k: SLOADs, execution\n', '    //   On Win: +13k, or +28k\n', '    //   - 5k: 1 updates: totalCredits, totalWon\n', '    //   - 5k or 20k: 1 update/write to credits[user]\n', '    //   - 2k: event: AccountCredited\n', '    //   - 1k: SLOADs, execution\n', '    function _finalize(Game storage _game, uint32 _id, bytes32 _hashCheck)\n', '        private\n', '    {\n', '        // Require game is not already finalized\n', '        assert(_game.handRank == HAND_UNDEFINED);\n', '\n', '        // Compute _dHand\n', '        address _user = userAddresses[_game.userId];\n', '        bytes32 _blockhash;\n', '        uint32 _dHand;\n', '        uint32 _iHand;  // set if draws are 0, and iBlock is fresh\n', '        uint8 _warnCode;\n', '        if (_game.draws != 0) {\n', '            _blockhash = blockhash(_game.dBlock);\n', '            if (_blockhash != 0) {\n', '                // draw cards to iHand, use as dHand\n', '                _dHand = drawToHand(uint(keccak256(_blockhash, _id)), _game.iHand, _game.draws);\n', '            } else {\n', '                // cannot draw any cards. use iHand.\n', '                if (_game.iHand != 0){\n', '                    _dHand = _game.iHand;\n', '                    _warnCode = WARN_DHAND_TIMEOUT;\n', '                } else {\n', '                    _dHand = 0;\n', '                    _warnCode = WARN_BOTH_TIMEOUT;\n', '                }\n', '            }\n', '        } else {\n', '            _blockhash = blockhash(_game.iBlock);\n', '            if (_blockhash != 0) {\n', '                // ensure they are drawing against expected hand\n', '                if (_blockhash != _hashCheck) {\n', '                    _finalizeFailure(_id, "HashCheck Failed. Try refreshing game.");\n', '                    return;\n', '                }\n', '                // draw 5 cards into iHand, use as dHand\n', '                _iHand = getHand(uint(keccak256(_blockhash, _id)));\n', '                _dHand = _iHand;\n', '            } else {\n', '                // can&#39;t finalize with iHand. Draw 5 cards.\n', '                _finalizeFailure(_id, "Initial hand not available. Drawing 5 new cards.");\n', '                _game.draws = 31;\n', '                _game.dBlock = uint32(block.number);\n', '                emit DrawSuccess(now, _user, _id, 0, 31, WARN_IHAND_TIMEOUT);\n', '                return;\n', '            }\n', '        }\n', '\n', '        // Compute _handRank. be sure dHand is not empty\n', '        uint8 _handRank = _dHand == 0\n', '            ? uint8(HAND_NOT_COMPUTABLE)\n', '            : uint8(getHandRank(_dHand));\n', '\n', '        // This only happens if draws==0, and iHand was drawable.\n', '        if (_iHand > 0) _game.iHand = _iHand;\n', '        // Always set dHand and handRank\n', '        _game.dHand = _dHand;\n', '        _game.handRank = _handRank;\n', '\n', '        // Compute _payout, credit user, emit event.\n', '        uint _payout = payTables[_game.payTableId][_handRank] * uint(_game.bet);\n', '        if (_payout > 0) _creditUser(_user, _payout, _id);\n', '        emit FinalizeSuccess(now, _user, _id, _game.dHand, _game.handRank, _payout, _warnCode);\n', '    }\n', '\n', '\n', '\n', '    /************************************************************/\n', '    /******************** PUBLIC VIEWS **************************/\n', '    /************************************************************/\n', '\n', '    // IMPLEMENTS: Bankrollable.getProfits()\n', '    // Ensures contract always has at least bankroll + totalCredits.\n', '    function getCollateral() public view returns (uint _amount) {\n', '        return vars.totalCredits;\n', '    }\n', '\n', '    // IMPLEMENTS: Bankrollable.getWhitelistOwner()\n', '    // Ensures contract always has at least bankroll + totalCredits.\n', '    function getWhitelistOwner() public view returns (address _wlOwner) {\n', '        return getAdmin();\n', '    }\n', '\n', '    // Returns the largest bet such that we could pay out two RoyalFlushes.\n', '    // The likelihood that two RoyalFlushes (with max bet size) are \n', '    //  won within a 255 block period is extremely low.\n', '    function curMaxBet() public view returns (uint) {\n', '        // Return largest bet such that RF*2*bet = bankrollable\n', '        uint _maxPayout = payTables[settings.curPayTableId][HAND_RF] * 2;\n', '        return bankrollAvailable() / _maxPayout;\n', '    }\n', '\n', '    // Return the less of settings.maxBet and curMaxBet()\n', '    function effectiveMaxBet() public view returns (uint _amount) {\n', '        uint _curMax = curMaxBet();\n', '        return _curMax > settings.maxBet ? settings.maxBet : _curMax;\n', '    }\n', '\n', '    function getPayTable(uint16 _payTableId)\n', '        public\n', '        view\n', '        returns (uint16[12])\n', '    {\n', '        require(_payTableId < settings.numPayTables);\n', '        return payTables[_payTableId];\n', '    }\n', '\n', '    function getCurPayTable()\n', '        public\n', '        view\n', '        returns (uint16[12])\n', '    {\n', '        return getPayTable(settings.curPayTableId);\n', '    }\n', '\n', '    // Gets the initial hand of a game.\n', '    function getIHand(uint32 _id)\n', '        public\n', '        view\n', '        returns (uint32)\n', '    {\n', '        Game memory _game = games[_id];\n', '        if (_game.iHand != 0) return _game.iHand;\n', '        if (_game.iBlock == 0) return;\n', '        \n', '        bytes32 _iBlockHash = blockhash(_game.iBlock);\n', '        if (_iBlockHash == 0) return;\n', '        return getHand(uint(keccak256(_iBlockHash, _id)));\n', '    }\n', '\n', '    // Get the final hand of a game.\n', '    // This will return iHand if there are no draws yet.\n', '    function getDHand(uint32 _id)\n', '        public\n', '        view\n', '        returns (uint32)\n', '    {\n', '        Game memory _game = games[_id];\n', '        if (_game.dHand != 0) return _game.dHand;\n', '        if (_game.draws == 0) return _game.iHand;\n', '        if (_game.dBlock == 0) return;\n', '\n', '        bytes32 _dBlockHash = blockhash(_game.dBlock);\n', '        if (_dBlockHash == 0) return _game.iHand;\n', '        return drawToHand(uint(keccak256(_dBlockHash, _id)), _game.iHand, _game.draws);\n', '    }\n', '\n', '    // Returns the hand rank and payout of a Game.\n', '    function getDHandRank(uint32 _id)\n', '        public\n', '        view\n', '        returns (uint8)\n', '    {\n', '        uint32 _dHand = getDHand(_id);\n', '        return _dHand == 0\n', '            ? uint8(HAND_NOT_COMPUTABLE)\n', '            : uint8(getHandRank(_dHand));\n', '    }\n', '\n', '    // Expose Vars //////////////////////////////////////\n', '    function curId() public view returns (uint32) {\n', '        return vars.curId;\n', '    }\n', '    function totalWagered() public view returns (uint) {\n', '        return uint(vars.totalWageredGwei) * 1e9;\n', '    }\n', '    function curUserId() public view returns (uint) {\n', '        return uint(vars.curUserId);\n', '    }\n', '    function totalWon() public view returns (uint) {\n', '        return uint(vars.totalWonGwei) * 1e9;\n', '    }\n', '    function totalCredits() public view returns (uint) {\n', '        return vars.totalCredits;\n', '    }\n', '    /////////////////////////////////////////////////////\n', '\n', '    // Expose Settings //////////////////////////////////\n', '    function minBet() public view returns (uint) {\n', '        return settings.minBet;\n', '    }\n', '    function maxBet() public view returns (uint) {\n', '        return settings.maxBet;\n', '    }\n', '    function curPayTableId() public view returns (uint) {\n', '        return settings.curPayTableId;\n', '    }\n', '    function numPayTables() public view returns (uint) {\n', '        return settings.numPayTables;\n', '    }\n', '    /////////////////////////////////////////////////////\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// https://www.pennyether.com\n', '\n', '/******* USING Registry **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .addressOf(bytes32): returns current address mapped to the name.\n', '    [modifier] .fromOwner(): requires the sender is owner.\n', '\n', '*************************************************/\n', '// Returned by .getRegistry()\n', 'interface IRegistry {\n', '    function owner() external view returns (address _addr);\n', '    function addressOf(bytes32 _name) external view returns (address _addr);\n', '}\n', '\n', 'contract UsingRegistry {\n', '    IRegistry private registry;\n', '\n', '    modifier fromOwner(){\n', '        require(msg.sender == getOwner());\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry)\n', '        public\n', '    {\n', '        require(_registry != 0);\n', '        registry = IRegistry(_registry);\n', '    }\n', '\n', '    function addressOf(bytes32 _name)\n', '        internal\n', '        view\n', '        returns(address _addr)\n', '    {\n', '        return registry.addressOf(_name);\n', '    }\n', '\n', '    function getOwner()\n', '        public\n', '        view\n', '        returns (address _addr)\n', '    {\n', '        return registry.owner();\n', '    }\n', '\n', '    function getRegistry()\n', '        public\n', '        view\n', '        returns (IRegistry _addr)\n', '    {\n', '        return registry;\n', '    }\n', '}\n', '\n', '\n', '/******* USING ADMIN ***********************\n', '\n', 'Gives the inherting contract access to:\n', '    .getAdmin(): returns the current address of the admin\n', '    [modifier] .fromAdmin: requires the sender is the admin\n', '\n', '*************************************************/\n', 'contract UsingAdmin is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromAdmin(){\n', '        require(msg.sender == getAdmin());\n', '        _;\n', '    }\n', '    \n', '    function getAdmin()\n', '        public\n', '        constant\n', '        returns (address _addr)\n', '    {\n', '        return addressOf("ADMIN");\n', '    }\n', '}\n', '\n', '/******* USING TREASURY **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .getTreasury(): returns current ITreasury instance\n', '    [modifier] .fromTreasury(): requires the sender is current Treasury\n', '\n', '*************************************************/\n', '// Returned by .getTreasury()\n', 'interface ITreasury {\n', '    function issueDividend() external returns (uint _profits);\n', '    function profitsSendable() external view returns (uint _profits);\n', '}\n', '\n', 'contract UsingTreasury is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromTreasury(){\n', '        require(msg.sender == address(getTreasury()));\n', '        _;\n', '    }\n', '    \n', '    function getTreasury()\n', '        public\n', '        view\n', '        returns (ITreasury)\n', '    {\n', '        return ITreasury(addressOf("TREASURY"));\n', '    }\n', '}\n', '\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    address => uint amounts. Address balances can be added to \n', '    or removed from via add() and subtract(). All balances can\n', '    be obtain by calling balances(). If an address has a 0 amount,\n', '    it is removed from the Ledger.\n', '\n', "    Note: THIS DOES NOT TEST FOR OVERFLOWS, but it's safe to\n", '          use to track Ether balances.\n', '\n', '    Public methods:\n', '      - [fromOwner] add()\n', '      - [fromOwner] subtract()\n', '    Public views:\n', '      - total()\n', '      - size()\n', '      - balanceOf()\n', '      - balances()\n', '      - entries() [to manually iterate]\n', '*/\n', 'contract Ledger {\n', '    uint public total;      // Total amount in Ledger\n', '\n', '    struct Entry {          // Doubly linked list tracks amount per address\n', '        uint balance;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        // If new entry, replace first entry with this one.\n', '        if (entry.balance == 0) {\n', '            entry.next = entries[0x0].next;\n', '            entries[entries[0x0].next].prev = _address;\n', '            entries[0x0].next = _address;\n', '        }\n', '        // Update stats.\n', '        total += _amt;\n', '        entry.balance += _amt;\n', '    }\n', '\n', '    function subtract(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '        returns (uint _amtRemoved)\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        uint _maxAmt = entry.balance;\n', '        if (_maxAmt == 0) return;\n', '        \n', '        if (_amt >= _maxAmt) {\n', '            // Subtract the max amount, and delete entry.\n', '            total -= _maxAmt;\n', '            entries[entry.prev].next = entry.next;\n', '            entries[entry.next].prev = entry.prev;\n', '            delete entries[_address];\n', '            return _maxAmt;\n', '        } else {\n', '            // Subtract the amount from entry.\n', '            total -= _amt;\n', '            entry.balance -= _amt;\n', '            return _amt;\n', '        }\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function balanceOf(address _address)\n', '        public\n', '        view\n', '        returns (uint _balance)\n', '    {\n', '        return entries[_address].balance;\n', '    }\n', '\n', '    function balances()\n', '        public\n', '        view\n', '        returns (address[] _addresses, uint[] _balances)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        _balances = new uint[](_size);\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _balances[_i] = entries[_curEntry.next].balance;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return (_addresses, _balances);\n', '    }\n', '}\n', '\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    addresses it has seen. Addresses can be added and removed\n', '    from the set, and a full list of addresses can be obtained.\n', '\n', '    Methods:\n', '     - [fromOwner] .add()\n', '     - [fromOwner] .remove()\n', '    Views:\n', '     - .size()\n', '     - .has()\n', '     - .addresses()\n', '*/\n', 'contract AddressSet {\n', '    \n', '    struct Entry {  // Doubly linked list\n', '        bool exists;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner.\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didCreate)\n', '    {\n', '        // Do not allow the adding of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', '        // If already exists, do nothing. Otherwise set it.\n', '        if (entry.exists) return;\n', '        else entry.exists = true;\n', '\n', '        // Replace first entry with this one.\n', '        // Before: HEAD <-> X <-> Y\n', '        // After: HEAD <-> THIS <-> X <-> Y\n', '        // do: THIS.NEXT = [0].next; [0].next.prev = THIS; [0].next = THIS; THIS.prev = 0;\n', '        Entry storage HEAD = entries[0x0];\n', '        entry.next = HEAD.next;\n', '        entries[HEAD.next].prev = _address;\n', '        HEAD.next = _address;\n', '        return true;\n', '    }\n', '\n', '    function remove(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didExist)\n', '    {\n', '        // Do not allow the removal of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', "        // If it doesn't exist already, there is nothing to do.\n", '        if (!entry.exists) return;\n', '\n', '        // Stitch together next and prev, delete entry.\n', '        // Before: X <-> THIS <-> Y\n', '        // After: X <-> Y\n', '        // do: THIS.next.prev = this.prev; THIS.prev.next = THIS.next;\n', '        entries[entry.prev].next = entry.next;\n', '        entries[entry.next].prev = entry.prev;\n', '        delete entries[_address];\n', '        return true;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function has(address _address)\n', '        public\n', '        view\n', '        returns (bool _exists)\n', '    {\n', '        return entries[_address].exists;\n', '    }\n', '\n', '    function addresses()\n', '        public\n', '        view\n', '        returns (address[] _addresses)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        // Iterate forward through all entries until the end.\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return _addresses;\n', '    }\n', '}\n', '\n', '/**\n', '  A simple class that manages bankroll, and maintains collateral.\n', '  This class only ever sends profits the Treasury. No exceptions.\n', '\n', '  - Anybody can add funding (according to whitelist)\n', '  - Anybody can tell profits (balance - (funding + collateral)) to go to Treasury.\n', '  - Anyone can remove their funding, so long as balance >= collateral.\n', '  - Whitelist is managed by getWhitelistOwner() -- typically Admin.\n', '\n', '  Exposes the following:\n', '    Public Methods\n', '     - addBankroll\n', '     - removeBankroll\n', '     - sendProfits\n', '    Public Views\n', '     - getCollateral\n', '     - profits\n', '     - profitsSent\n', '     - profitsTotal\n', '     - bankroll\n', '     - bankrollAvailable\n', '     - bankrolledBy\n', '     - bankrollerTable\n', '*/\n', 'contract Bankrollable is\n', '    UsingTreasury\n', '{   \n', '    // How much profits have been sent. \n', '    uint public profitsSent;\n', '    // Ledger keeps track of who has bankrolled us, and for how much\n', '    Ledger public ledger;\n', '    // This is a copy of ledger.total(), to save gas in .bankrollAvailable()\n', '    uint public bankroll;\n', '    // This is the whitelist of who can call .addBankroll()\n', '    AddressSet public whitelist;\n', '\n', '    modifier fromWhitelistOwner(){\n', '        require(msg.sender == getWhitelistOwner());\n', '        _;\n', '    }\n', '\n', '    event BankrollAdded(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event BankrollRemoved(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event ProfitsSent(uint time, address indexed treasury, uint amount);\n', '    event AddedToWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '    event RemovedFromWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '\n', '    // Constructor creates the ledger and whitelist, with self as owner.\n', '    constructor(address _registry)\n', '        UsingTreasury(_registry)\n', '        public\n', '    {\n', '        ledger = new Ledger(this);\n', '        whitelist = new AddressSet(this);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** WHITELIST MGMT ***********************/\n', '    /*****************************************************/    \n', '\n', '    function addToWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didAdd = whitelist.add(_addr);\n', '        if (_didAdd) emit AddedToWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    function removeFromWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didRemove = whitelist.remove(_addr);\n', '        if (_didRemove) emit RemovedFromWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC FUNCTIONS *********************/\n', '    /*****************************************************/\n', '\n', '    // Bankrollable contracts should be payable (to receive revenue)\n', '    function () public payable {}\n', '\n', '    // Increase funding by whatever value is sent\n', '    function addBankroll()\n', '        public\n', '        payable \n', '    {\n', '        require(whitelist.size()==0 || whitelist.has(msg.sender));\n', '        ledger.add(msg.sender, msg.value);\n', '        bankroll = ledger.total();\n', '        emit BankrollAdded(now, msg.sender, msg.value, bankroll);\n', '    }\n', '\n', '    // Removes up to _amount from Ledger, and sends it to msg.sender._callbackFn\n', '    function removeBankroll(uint _amount, string _callbackFn)\n', '        public\n', '        returns (uint _recalled)\n', '    {\n', '        // cap amount at the balance minus collateral, or nothing at all.\n', '        address _bankroller = msg.sender;\n', '        uint _collateral = getCollateral();\n', '        uint _balance = address(this).balance;\n', '        uint _available = _balance > _collateral ? _balance - _collateral : 0;\n', '        if (_amount > _available) _amount = _available;\n', '\n', '        // Try to remove _amount from ledger, get actual _amount removed.\n', '        _amount = ledger.subtract(_bankroller, _amount);\n', '        bankroll = ledger.total();\n', '        if (_amount == 0) return;\n', '\n', '        bytes4 _sig = bytes4(keccak256(_callbackFn));\n', '        require(_bankroller.call.value(_amount)(_sig));\n', '        emit BankrollRemoved(now, _bankroller, _amount, bankroll);\n', '        return _amount;\n', '    }\n', '\n', '    // Send any excess profits to treasury.\n', '    function sendProfits()\n', '        public\n', '        returns (uint _profits)\n', '    {\n', '        int _p = profits();\n', '        if (_p <= 0) return;\n', '        _profits = uint(_p);\n', '        profitsSent += _profits;\n', '        // Send profits to Treasury\n', '        address _tr = getTreasury();\n', '        require(_tr.call.value(_profits)());\n', '        emit ProfitsSent(now, _tr, _profits);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC VIEWS *************************/\n', '    /*****************************************************/\n', '\n', '    // Function must be overridden by inheritors to ensure collateral is kept.\n', '    function getCollateral()\n', '        public\n', '        view\n', '        returns (uint _amount);\n', '\n', '    // Function must be overridden by inheritors to enable whitelist control.\n', '    function getWhitelistOwner()\n', '        public\n', '        view\n', '        returns (address _addr);\n', '\n', '    // Profits are the difference between balance and threshold\n', '    function profits()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        int _balance = int(address(this).balance);\n', '        int _threshold = int(bankroll + getCollateral());\n', '        return _balance - _threshold;\n', '    }\n', '\n', '    // How profitable this contract is, overall\n', '    function profitsTotal()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        return int(profitsSent) + profits();\n', '    }\n', '\n', '    // Returns the amount that can currently be bankrolled.\n', '    //   - 0 if balance < collateral\n', '    //   - If profits: full bankroll\n', '    //   - If no profits: remaning bankroll: balance - collateral\n', '    function bankrollAvailable()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        uint _balance = address(this).balance;\n', '        uint _bankroll = bankroll;\n', '        uint _collat = getCollateral();\n', '        // Balance is below collateral!\n', '        if (_balance <= _collat) return 0;\n', '        // No profits, but we have a balance over collateral.\n', '        else if (_balance < _collat + _bankroll) return _balance - _collat;\n', '        // Profits. Return only _bankroll\n', '        else return _bankroll;\n', '    }\n', '\n', '    function bankrolledBy(address _addr)\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return ledger.balanceOf(_addr);\n', '    }\n', '\n', '    function bankrollerTable()\n', '        public\n', '        view\n', '        returns (address[], uint[])\n', '    {\n', '        return ledger.balances();\n', '    }\n', '}\n', '\n', 'contract VideoPokerUtils {\n', '    uint constant HAND_UNDEFINED = 0;\n', '    uint constant HAND_RF = 1;\n', '    uint constant HAND_SF = 2;\n', '    uint constant HAND_FK = 3;\n', '    uint constant HAND_FH = 4;\n', '    uint constant HAND_FL = 5;\n', '    uint constant HAND_ST = 6;\n', '    uint constant HAND_TK = 7;\n', '    uint constant HAND_TP = 8;\n', '    uint constant HAND_JB = 9;\n', '    uint constant HAND_HC = 10;\n', '    uint constant HAND_NOT_COMPUTABLE = 11;\n', '\n', '    /*****************************************************/\n', '    /********** PUBLIC PURE FUNCTIONS ********************/\n', '    /*****************************************************/\n', '\n', '    // Gets a new 5-card hand, stored in uint32\n', '    // Gas Cost: 3k\n', '    function getHand(uint256 _hash)\n', '        public\n', '        pure\n', '        returns (uint32)\n', '    {\n', '        // Return the cards as a hand.\n', '        return uint32(getCardsFromHash(_hash, 5, 0));\n', '    }\n', '\n', '    // Both _hand and _draws store the first card in the\n', '    //   rightmost position. _hand uses chunks of 6 bits.\n', '    //\n', '    // In the below example, hand is [9,18,35,12,32], and\n', '    // the cards 18 and 35 will be replaced.\n', '    //\n', '    // _hand:                                [9,18,35,12,32]  \n', '    //    encoding:    XX 100000 001100 100011 010010 001001\n', '    //      chunks:           32     12     35     18      9\n', '    //       order:        card5, card4, card3, card2, card1\n', '    //     decimal:                                540161161\n', '    //\n', '    // _draws:                               card2 and card4\n', '    //    encoding:   XXX      0      0      1      1      0\n', '    //       order:        card5, card4, card3, card2, card1 \n', '    //     decimal:                                        6\n', '    // \n', '    // Gas Cost: Fixed 6k gas. \n', '    function drawToHand(uint256 _hash, uint32 _hand, uint _draws)\n', '        public\n', '        pure\n', '        returns (uint32)\n', '    {\n', '        // Draws must be valid. If no hand, must draw all 5 cards.\n', '        assert(_draws <= 31);\n', '        assert(_hand != 0 || _draws == 31);\n', '        // Shortcuts. Return _hand on no draws, or 5 cards on full draw.\n', '        if (_draws == 0) return _hand;\n', '        if (_draws == 31) return uint32(getCardsFromHash(_hash, 5, handToBitmap(_hand)));\n', '\n', "        // Create a mask of 1's where new cards should go.\n", '        uint _newMask;\n', '        for (uint _i=0; _i<5; _i++) {\n', '            if (_draws & 2**_i == 0) continue;\n', '            _newMask |= 63 * (2**(6*_i));\n', '        }\n', "        // Create a mask of 0's where new cards should go.\n", '        // Be sure to use only first 30 bits (5 cards x 6 bits)\n', '        uint _discardMask = ~_newMask & (2**31-1);\n', '\n', '        // Select from _newHand, discard from _hand, and combine.\n', '        uint _newHand = getCardsFromHash(_hash, 5, handToBitmap(_hand));\n', '        _newHand &= _newMask;\n', '        _newHand |= _hand & _discardMask;\n', '        return uint32(_newHand);\n', '    }\n', '\n', '    // Looks at a hand of 5-cards, determines strictly the HandRank.\n', '    // Gas Cost: up to 7k depending on hand.\n', '    function getHandRank(uint32 _hand)\n', '        public\n', '        pure\n', '        returns (uint)\n', '    {\n', '        if (_hand == 0) return HAND_NOT_COMPUTABLE;\n', '\n', '        uint _card;\n', '        uint[] memory _valCounts = new uint[](13);\n', '        uint[] memory _suitCounts = new uint[](5);\n', '        uint _pairVal;\n', '        uint _minNonAce = 100;\n', '        uint _maxNonAce = 0;\n', '        uint _numPairs;\n', '        uint _maxSet;\n', '        bool _hasFlush;\n', '        bool _hasAce;\n', '\n', '        // Set all the values above.\n', '        // Note:\n', '        //   _hasTwoPair will be true even if one pair is Trips.\n', '        //   Likewise, _hasTrips will be true even if there are Quads.\n', '        uint _i;\n', '        uint _val;\n', '        for (_i=0; _i<5; _i++) {\n', '            _card = readFromCards(_hand, _i);\n', '            if (_card > 51) return HAND_NOT_COMPUTABLE;\n', '            \n', "            // update val and suit counts, and if it's a flush\n", '            _val = _card % 13;\n', '            _valCounts[_val]++;\n', '            _suitCounts[_card/13]++;\n', '            if (_suitCounts[_card/13] == 5) _hasFlush = true;\n', '            \n', '            // update _hasAce, and min/max value\n', '            if (_val == 0) {\n', '                _hasAce = true;\n', '            } else {\n', '                if (_val < _minNonAce) _minNonAce = _val;\n', '                if (_val > _maxNonAce) _maxNonAce = _val;\n', '            }\n', '\n', '            // update _pairVal, _numPairs, _maxSet\n', '            if (_valCounts[_val] == 2) {\n', '                if (_numPairs==0) _pairVal = _val;\n', '                _numPairs++;\n', '            } else if (_valCounts[_val] == 3) {\n', '                _maxSet = 3;\n', '            } else if (_valCounts[_val] == 4) {\n', '                _maxSet = 4;\n', '            }\n', '        }\n', '\n', '        if (_numPairs > 0){\n', "            // If they have quads, they can't have royal flush, so we can return.\n", '            if (_maxSet==4) return HAND_FK;\n', "            // One of the two pairs was the trips, so it's a full house.\n", '            if (_maxSet==3 && _numPairs==2) return HAND_FH;\n', '            // Trips is their best hand (no straight or flush possible)\n', '            if (_maxSet==3) return HAND_TK;\n', '            // Two pair is their best hand (no straight or flush possible)\n', '            if (_numPairs==2) return HAND_TP;\n', '            // One pair is their best hand (no straight or flush possible)\n', '            if (_numPairs == 1 && (_pairVal >= 10 || _pairVal==0)) return HAND_JB;\n', '            // They have a low pair (no straight or flush possible)\n', '            return HAND_HC;\n', '        }\n', '\n', '        // They have no pair. Do they have a straight?\n', '        bool _hasStraight = _hasAce\n', '            // Check for: A,1,2,3,4 or 9,10,11,12,A\n', '            ? _maxNonAce == 4 || _minNonAce == 9\n', '            // Check for X,X+1,X+2,X+3,X+4\n', '            : _maxNonAce - _minNonAce == 4;\n', '        \n', '        // Check for hands in order of rank.\n', '        if (_hasStraight && _hasFlush && _minNonAce==9) return HAND_RF;\n', '        if (_hasStraight && _hasFlush) return HAND_SF;\n', '        if (_hasFlush) return HAND_FL;\n', '        if (_hasStraight) return HAND_ST;\n', '        return HAND_HC;\n', '    }\n', '\n', '    // Not used anywhere, but added for convenience\n', '    function handToCards(uint32 _hand)\n', '        public\n', '        pure\n', '        returns (uint8[5] _cards)\n', '    {\n', '        uint32 _mask;\n', '        for (uint _i=0; _i<5; _i++){\n', '            _mask = uint32(63 * 2**(6*_i));\n', '            _cards[_i] = uint8((_hand & _mask) / (2**(6*_i)));\n', '        }\n', '    }\n', '\n', '\n', '\n', '    /*****************************************************/\n', '    /********** PRIVATE INTERNAL FUNCTIONS ***************/\n', '    /*****************************************************/\n', '\n', '    function readFromCards(uint _cards, uint _index)\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        uint _offset = 2**(6*_index);\n', '        uint _oneBits = 2**6 - 1;\n', '        return (_cards & (_oneBits * _offset)) / _offset;\n', '    }\n', '\n', '    // Returns a bitmap to represent the set of cards in _hand.\n', '    function handToBitmap(uint32 _hand)\n', '        internal\n', '        pure\n', '        returns (uint _bitmap)\n', '    {\n', '        if (_hand == 0) return 0;\n', '        uint _mask;\n', '        uint _card;\n', '        for (uint _i=0; _i<5; _i++){\n', '            _mask = 63 * 2**(6*_i);\n', '            _card = (_hand & _mask) / (2**(6*_i));\n', '            _bitmap |= 2**_card;\n', '        }\n', '    }\n', '\n', '    // Returns numCards from a uint256 (eg, keccak256) seed hash.\n', '    // Returns cards as one uint, with each card being 6 bits.\n', '    function getCardsFromHash(uint256 _hash, uint _numCards, uint _usedBitmap)\n', '        internal\n', '        pure\n', '        returns (uint _cards)\n', '    {\n', "        // Return early if we don't need to pick any cards.\n", '        if (_numCards == 0) return;\n', '\n', '        uint _cardIdx = 0;                // index of currentCard\n', '        uint _card;                       // current chosen card\n', '        uint _usedMask;                   // mask of current card\n', '\n', '        while (true) {\n', '            _card = _hash % 52;           // Generate card from hash\n', '            _usedMask = 2**_card;         // Create mask for the card\n', '\n', '            // If card is not used, add it to _cards and _usedBitmap\n', '            // Return if we have enough cards.\n', '            if (_usedBitmap & _usedMask == 0) {\n', '                _cards |= (_card * 2**(_cardIdx*6));\n', '                _usedBitmap |= _usedMask;\n', '                _cardIdx++;\n', '                if (_cardIdx == _numCards) return _cards;\n', '            }\n', '\n', '            // Generate hash used to pick next card.\n', '            _hash = uint256(keccak256(_hash));\n', '        }\n', '    }\n', '}\n', '\n', 'contract VideoPoker is\n', '    VideoPokerUtils,\n', '    Bankrollable,\n', '    UsingAdmin\n', '{\n', '    // All the data needed for each game.\n', '    struct Game {\n', '        // [1st 256-bit block]\n', '        uint32 userId;\n', '        uint64 bet;         // max of 18 Ether (set on bet)\n', '        uint16 payTableId;  // the PayTable used (set on bet)\n', '        uint32 iBlock;      // initial hand block (set on bet)\n', '        uint32 iHand;       // initial hand (set on draw/finalize)\n', '        uint8 draws;        // bitmap of which cards to draw (set on draw/finalize)\n', '        uint32 dBlock;      // block of the dHand (set on draw/finalize)\n', '        uint32 dHand;       // hand after draws (set on finalize)\n', '        uint8 handRank;     // result of the hand (set on finalize)\n', '    }\n', '\n', '    // These variables change on each bet and finalization.\n', '    // We put them in a struct with the hopes that optimizer\n', '    //   will do one write if any/all of them change.\n', '    struct Vars {\n', '        // [1st 256-bit block]\n', '        uint32 curId;               // (changes on bet)\n', '        uint64 totalWageredGwei;    // (changes on bet)\n', '        uint32 curUserId;           // (changes on bet, maybe)\n', '        uint128 empty1;             // intentionally left empty, so the below\n', '                                    //   updates occur in the same update\n', '        // [2nd 256-bit block]\n', '        uint64 totalWonGwei;        // (changes on finalization win)\n', '        uint88 totalCredits;        // (changes on finalization win)\n', '        uint8 empty2;               // set to true to normalize gas cost\n', '    }\n', '\n', '    struct Settings {\n', '        uint64 minBet;\n', '        uint64 maxBet;\n', '        uint16 curPayTableId;\n', '        uint16 numPayTables;\n', '        uint32 lastDayAdded;\n', '    }\n', '\n', '    Settings settings;\n', '    Vars vars;\n', '\n', '    // A Mapping of all games\n', '    mapping(uint32 => Game) public games;\n', '    \n', '    // Credits we owe the user\n', '    mapping(address => uint) public credits;\n', '\n', '    // Store a two-way mapping of address <=> userId\n', "    // If we've seen a user before, betting will be just 1 write\n", '    //  per Game struct vs 2 writes.\n', '    // The trade-off is 3 writes for new users. Seems fair.\n', '    mapping (address => uint32) public userIds;\n', '    mapping (uint32 => address) public userAddresses;\n', '\n', '    // Note: Pay tables cannot be changed once added.\n', '    // However, admin can change the current PayTable\n', '    mapping(uint16=>uint16[12]) payTables;\n', '\n', '    // version of the game\n', '    uint8 public constant version = 2;\n', '    uint8 constant WARN_IHAND_TIMEOUT = 1; // "Initial hand not available. Drawing 5 new cards."\n', '    uint8 constant WARN_DHAND_TIMEOUT = 2; // "Draw cards not available. Using initial hand."\n', '    uint8 constant WARN_BOTH_TIMEOUT = 3;  // "Draw cards not available, and no initial hand."\n', '    \n', '    // Admin Events\n', '    event Created(uint time);\n', '    event PayTableAdded(uint time, address admin, uint payTableId);\n', '    event SettingsChanged(uint time, address admin);\n', '    // Game Events\n', '    event BetSuccess(uint time, address indexed user, uint32 indexed id, uint bet, uint payTableId);\n', '    event BetFailure(uint time, address indexed user, uint bet, string msg);\n', '    event DrawSuccess(uint time, address indexed user, uint32 indexed id, uint32 iHand, uint8 draws, uint8 warnCode);\n', '    event DrawFailure(uint time, address indexed user, uint32 indexed id, uint8 draws, string msg);\n', '    event FinalizeSuccess(uint time, address indexed user, uint32 indexed id, uint32 dHand, uint8 handRank, uint payout, uint8 warnCode);\n', '    event FinalizeFailure(uint time, address indexed user, uint32 indexed id, string msg);\n', '    // Credits\n', '    event CreditsAdded(uint time, address indexed user, uint32 indexed id, uint amount);\n', '    event CreditsUsed(uint time, address indexed user, uint32 indexed id, uint amount);\n', '    event CreditsCashedout(uint time, address indexed user, uint amount);\n', '        \n', '    constructor(address _registry)\n', '        Bankrollable(_registry)\n', '        UsingAdmin(_registry)\n', '        public\n', '    {\n', '        // Add the default PayTable.\n', '        _addPayTable(800, 50, 25, 9, 6, 4, 3, 2, 1);\n', '        // write to vars, to lower gas-cost for the first game.\n', '        // vars.empty1 = 1;\n', '        // vars.empty2 = 1;\n', '        // initialze stats to last settings\n', '        vars.curId = 293;\n', '        vars.totalWageredGwei =2864600000;\n', '        vars.curUserId = 38;\n', '        vars.totalWonGwei = 2450400000;\n', '\n', '        // initialize settings\n', '        settings.minBet = .001 ether;\n', '        settings.maxBet = .375 ether;\n', '        emit Created(now);\n', '    }\n', '    \n', '    \n', '    /************************************************************/\n', '    /******************** ADMIN FUNCTIONS ***********************/\n', '    /************************************************************/\n', '    \n', '    // Allows admin to change minBet, maxBet, and curPayTableId\n', '    function changeSettings(uint64 _minBet, uint64 _maxBet, uint8 _payTableId)\n', '        public\n', '        fromAdmin\n', '    {\n', '        require(_maxBet <= .375 ether);\n', '        require(_payTableId < settings.numPayTables);\n', '        settings.minBet = _minBet;\n', '        settings.maxBet = _maxBet;\n', '        settings.curPayTableId = _payTableId;\n', '        emit SettingsChanged(now, msg.sender);\n', '    }\n', '    \n', '    // Allows admin to permanently add a PayTable (once per day)\n', '    function addPayTable(\n', '        uint16 _rf, uint16 _sf, uint16 _fk, uint16 _fh,\n', '        uint16 _fl, uint16 _st, uint16 _tk, uint16 _tp, uint16 _jb\n', '    )\n', '        public\n', '        fromAdmin\n', '    {\n', '        uint32 _today = uint32(block.timestamp / 1 days);\n', '        require(settings.lastDayAdded < _today);\n', '        settings.lastDayAdded = _today;\n', '        _addPayTable(_rf, _sf, _fk, _fh, _fl, _st, _tk, _tp, _jb);\n', '        emit PayTableAdded(now, msg.sender, settings.numPayTables-1);\n', '    }\n', '    \n', '\n', '    /************************************************************/\n', '    /****************** PUBLIC FUNCTIONS ************************/\n', '    /************************************************************/\n', '\n', '    // Allows a user to add credits to their account.\n', '    function addCredits()\n', '        public\n', '        payable\n', '    {\n', '        _creditUser(msg.sender, msg.value, 0);\n', '    }\n', '\n', '    // Allows the user to cashout an amt (or their whole balance)\n', '    function cashOut(uint _amt)\n', '        public\n', '    {\n', '        _uncreditUser(msg.sender, _amt);\n', '    }\n', '\n', '    // Allows a user to create a game from Ether sent.\n', '    //\n', '    // Gas Cost: 55k (prev player), 95k (new player)\n', '    //   - 22k: tx overhead\n', '    //   - 26k, 66k: see _createNewGame()\n', '    //   -  3k: event\n', '    //   -  2k: curMaxBet()\n', '    //   -  2k: SLOAD, execution\n', '    function bet()\n', '        public\n', '        payable\n', '    {\n', '        uint _bet = msg.value;\n', '        if (_bet > settings.maxBet)\n', '            return _betFailure("Bet too large.", _bet, true);\n', '        if (_bet < settings.minBet)\n', '            return _betFailure("Bet too small.", _bet, true);\n', '        if (_bet > curMaxBet())\n', '            return _betFailure("The bankroll is too low.", _bet, true);\n', '\n', '        // no uint64 overflow: _bet < maxBet < .625 ETH < 2e64\n', '        uint32 _id = _createNewGame(uint64(_bet));\n', '        emit BetSuccess(now, msg.sender, _id, _bet, settings.curPayTableId);\n', '    }\n', '\n', '    // Allows a user to create a game from Credits.\n', '    //\n', '    // Gas Cost: 61k\n', '    //   - 22k: tx overhead\n', '    //   - 26k: see _createNewGame()\n', '    //   -  3k: event\n', '    //   -  2k: curMaxBet()\n', '    //   -  2k: 1 event: CreditsUsed\n', '    //   -  5k: update credits[user]\n', '    //   -  1k: SLOAD, execution\n', '    function betWithCredits(uint64 _bet)\n', '        public\n', '    {\n', '        if (_bet > settings.maxBet)\n', '            return _betFailure("Bet too large.", _bet, false);\n', '        if (_bet < settings.minBet)\n', '            return _betFailure("Bet too small.", _bet, false);\n', '        if (_bet > curMaxBet())\n', '            return _betFailure("The bankroll is too low.", _bet, false);\n', '        if (_bet > credits[msg.sender])\n', '            return _betFailure("Insufficient credits", _bet, false);\n', '\n', '        uint32 _id = _createNewGame(uint64(_bet));\n', '        vars.totalCredits -= uint88(_bet);\n', '        credits[msg.sender] -= _bet;\n', '        emit CreditsUsed(now, msg.sender, _id, _bet);\n', '        emit BetSuccess(now, msg.sender, _id, _bet, settings.curPayTableId);\n', '    }\n', '\n', '    function betFromGame(uint32 _id, bytes32 _hashCheck)\n', '        public\n', '    {\n', '        bool _didFinalize = finalize(_id, _hashCheck);\n', '        uint64 _bet = games[_id].bet;\n', '        if (!_didFinalize)\n', '            return _betFailure("Failed to finalize prior game.", _bet, false);\n', '        betWithCredits(_bet);\n', '    }\n', '\n', '        // Logs an error, and optionally refunds user the _bet\n', '        function _betFailure(string _msg, uint _bet, bool _doRefund)\n', '            private\n', '        {\n', '            if (_doRefund) require(msg.sender.call.value(_bet)());\n', '            emit BetFailure(now, msg.sender, _bet, _msg);\n', '        }\n', '        \n', '\n', '    // Resolves the initial hand (if possible) and sets the users draws.\n', '    // Users cannot draw 0 cards. They should instead use finalize().\n', '    //\n', '    // Notes:\n', '    //  - If user unable to resolve initial hand, sets draws to 5\n', '    //  - This always sets game.dBlock\n', '    //\n', '    // Gas Cost: ~38k\n', '    //   - 23k: tx\n', '    //   - 13k: see _draw()\n', '    //   -  2k: SLOADs, execution\n', '    function draw(uint32 _id, uint8 _draws, bytes32 _hashCheck)\n', '        public\n', '    {\n', '        Game storage _game = games[_id];\n', '        address _user = userAddresses[_game.userId];\n', '        if (_game.iBlock == 0)\n', '            return _drawFailure(_id, _draws, "Invalid game Id.");\n', '        if (_user != msg.sender)\n', '            return _drawFailure(_id, _draws, "This is not your game.");\n', '        if (_game.iBlock == block.number)\n', '            return _drawFailure(_id, _draws, "Initial cards not available.");\n', '        if (_game.dBlock != 0)\n', '            return _drawFailure(_id, _draws, "Cards already drawn.");\n', '        if (_draws > 31)\n', '            return _drawFailure(_id, _draws, "Invalid draws.");\n', '        if (_draws == 0)\n', '            return _drawFailure(_id, _draws, "Cannot draw 0 cards. Use finalize instead.");\n', '        if (_game.handRank != HAND_UNDEFINED)\n', '            return _drawFailure(_id, _draws, "Game already finalized.");\n', '        \n', '        _draw(_game, _id, _draws, _hashCheck);\n', '    }\n', '        function _drawFailure(uint32 _id, uint8 _draws, string _msg)\n', '            private\n', '        {\n', '            emit DrawFailure(now, msg.sender, _id, _draws, _msg);\n', '        }\n', '      \n', '\n', '    // Callable any time after the initial hand. Will assume\n', '    // no draws if called directly after new hand.\n', '    //\n', '    // Gas Cost: 44k (loss), 59k (win, has credits), 72k (win, no credits)\n', '    //   - 22k: tx overhead\n', '    //   - 21k, 36k, 49k: see _finalize()\n', '    //   -  1k: SLOADs, execution\n', '    function finalize(uint32 _id, bytes32 _hashCheck)\n', '        public\n', '        returns (bool _didFinalize)\n', '    {\n', '        Game storage _game = games[_id];\n', '        address _user = userAddresses[_game.userId];\n', '        if (_game.iBlock == 0)\n', '            return _finalizeFailure(_id, "Invalid game Id.");\n', '        if (_user != msg.sender)\n', '            return _finalizeFailure(_id, "This is not your game.");\n', '        if (_game.iBlock == block.number)\n', '            return _finalizeFailure(_id, "Initial hand not avaiable.");\n', '        if (_game.dBlock == block.number)\n', '            return _finalizeFailure(_id, "Drawn cards not available.");\n', '        if (_game.handRank != HAND_UNDEFINED)\n', '            return _finalizeFailure(_id, "Game already finalized.");\n', '\n', '        _finalize(_game, _id, _hashCheck);\n', '        return true;\n', '    }\n', '        function _finalizeFailure(uint32 _id, string _msg)\n', '            private\n', '            returns (bool)\n', '        {\n', '            emit FinalizeFailure(now, msg.sender, _id, _msg);\n', '            return false;\n', '        }\n', '\n', '\n', '    /************************************************************/\n', '    /****************** PRIVATE FUNCTIONS ***********************/\n', '    /************************************************************/\n', '\n', '    // Appends a PayTable to the mapping.\n', '    // It ensures sane values. (Double the defaults)\n', '    function _addPayTable(\n', '        uint16 _rf, uint16 _sf, uint16 _fk, uint16 _fh,\n', '        uint16 _fl, uint16 _st, uint16 _tk, uint16 _tp, uint16 _jb\n', '    )\n', '        private\n', '    {\n', '        require(_rf<=1600 && _sf<=100 && _fk<=50 && _fh<=18 && _fl<=12 \n', '                 && _st<=8 && _tk<=6 && _tp<=4 && _jb<=2);\n', '\n', '        uint16[12] memory _pt;\n', '        _pt[HAND_UNDEFINED] = 0;\n', '        _pt[HAND_RF] = _rf;\n', '        _pt[HAND_SF] = _sf;\n', '        _pt[HAND_FK] = _fk;\n', '        _pt[HAND_FH] = _fh;\n', '        _pt[HAND_FL] = _fl;\n', '        _pt[HAND_ST] = _st;\n', '        _pt[HAND_TK] = _tk;\n', '        _pt[HAND_TP] = _tp;\n', '        _pt[HAND_JB] = _jb;\n', '        _pt[HAND_HC] = 0;\n', '        _pt[HAND_NOT_COMPUTABLE] = 0;\n', '        payTables[settings.numPayTables] = _pt;\n', '        settings.numPayTables++;\n', '    }\n', '\n', '    // Increases totalCredits and credits[user]\n', '    // Optionally increases totalWonGwei stat.\n', '    function _creditUser(address _user, uint _amt, uint32 _gameId)\n', '        private\n', '    {\n', '        if (_amt == 0) return;\n', '        uint64 _incr = _gameId == 0 ? 0 : uint64(_amt / 1e9);\n', '        uint88 _totalCredits = vars.totalCredits + uint88(_amt);\n', '        uint64 _totalWonGwei = vars.totalWonGwei + _incr;\n', '        vars.totalCredits = _totalCredits;\n', '        vars.totalWonGwei = _totalWonGwei;\n', '        credits[_user] += _amt;\n', '        emit CreditsAdded(now, _user, _gameId, _amt);\n', '    }\n', '\n', '    // Lowers totalCredits and credits[user].\n', '    // Sends to user, using unlimited gas.\n', '    function _uncreditUser(address _user, uint _amt)\n', '        private\n', '    {\n', '        if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];\n', '        if (_amt == 0) return;\n', '        vars.totalCredits -= uint88(_amt);\n', '        credits[_user] -= _amt;\n', '        require(_user.call.value(_amt)());\n', '        emit CreditsCashedout(now, _user, _amt);\n', '    }\n', '\n', '    // Creates a new game with the specified bet and current PayTable.\n', '    // Does no validation of the _bet size.\n', '    //\n', '    // Gas Cost: 26k, 66k\n', '    //   Overhead:\n', '    //     - 20k: 1 writes: Game\n', '    //     -  5k: 1 update: vars\n', '    //     -  1k: SLOAD, execution\n', '    //   New User:\n', '    //     - 40k: 2 writes: userIds, userAddresses\n', '    //   Repeat User:\n', '    //     -  0k: nothing extra\n', '    function _createNewGame(uint64 _bet)\n', '        private\n', '        returns (uint32 _curId)\n', '    {\n', '        // get or create user id\n', '        uint32 _curUserId = vars.curUserId;\n', '        uint32 _userId = userIds[msg.sender];\n', '        if (_userId == 0) {\n', '            _curUserId++;\n', '            userIds[msg.sender] = _curUserId;\n', '            userAddresses[_curUserId] = msg.sender;\n', '            _userId = _curUserId;\n', '        }\n', '\n', '        // increment vars\n', '        _curId =  vars.curId + 1;\n', '        uint64 _totalWagered = vars.totalWageredGwei + _bet / 1e9;\n', '        vars.curId = _curId;\n', '        vars.totalWageredGwei = _totalWagered;\n', '        vars.curUserId = _curUserId;\n', '\n', '        // save game\n', '        uint16 _payTableId = settings.curPayTableId;\n', '        Game storage _game = games[_curId];\n', '        _game.userId = _userId;\n', '        _game.bet = _bet;\n', '        _game.payTableId = _payTableId;\n', '        _game.iBlock = uint32(block.number);\n', '        return _curId;\n', '    }\n', '\n', '    // Gets initialHand, and stores .draws and .dBlock.\n', '    // Gas Cost: 13k\n', '    //   - 3k: getHand()\n', '    //   - 5k: 1 update: iHand, draws, dBlock\n', '    //   - 3k: event: DrawSuccess\n', '    //   - 2k: SLOADs, other\n', '    function _draw(Game storage _game, uint32 _id, uint8 _draws, bytes32 _hashCheck)\n', '        private\n', '    {\n', '        // assert hand is not already drawn\n', '        assert(_game.dBlock == 0);\n', '\n', '        // Deal the initial hand, or set draws to 5.\n', '        uint32 _iHand;\n', '        bytes32 _iBlockHash = blockhash(_game.iBlock);\n', '        uint8 _warnCode;\n', '        if (_iBlockHash != 0) {\n', '            // Ensure they are drawing against expected hand\n', '            if (_iBlockHash != _hashCheck) {\n', '                return _drawFailure(_id, _draws, "HashCheck Failed. Try refreshing game.");\n', '            }\n', '            _iHand = getHand(uint(keccak256(_iBlockHash, _id)));\n', '        } else {\n', '            _warnCode = WARN_IHAND_TIMEOUT;\n', '            _draws = 31;\n', '        }\n', '\n', '        // update game\n', '        _game.iHand = _iHand;\n', '        _game.draws = _draws;\n', '        _game.dBlock = uint32(block.number);\n', '\n', '        emit DrawSuccess(now, msg.sender, _id, _game.iHand, _draws, _warnCode);\n', '    }\n', '\n', '    // Resolves game based on .iHand and .draws, crediting user on a win.\n', '    // This always sets game.dHand and game.handRank.\n', '    //\n', '    // There are four possible scenarios:\n', '    //   User draws N cads, and dBlock is fresh:\n', '    //     - draw N cards into iHand, this is dHand\n', '    //   User draws N cards, and dBlock is too old:\n', '    //     - set dHand to iHand (note: iHand may be empty)\n', '    //   User draws 0 cards, and iBlock is fresh:\n', '    //     - draw 5 cards into iHand, set dHand to iHand\n', '    //   User draws 0 cards, and iBlock is too old:\n', '    //     - fail: set draws to 5, return. (user should call finalize again)\n', '    //\n', '    // Gas Cost: 21k loss, 36k win, 49k new win\n', '    //   - 6k: if draws > 0: drawToHand()\n', '    //   - 7k: getHandRank()\n', '    //   - 5k: 1 update: Game\n', '    //   - 2k: FinalizeSuccess\n', '    //   - 1k: SLOADs, execution\n', '    //   On Win: +13k, or +28k\n', '    //   - 5k: 1 updates: totalCredits, totalWon\n', '    //   - 5k or 20k: 1 update/write to credits[user]\n', '    //   - 2k: event: AccountCredited\n', '    //   - 1k: SLOADs, execution\n', '    function _finalize(Game storage _game, uint32 _id, bytes32 _hashCheck)\n', '        private\n', '    {\n', '        // Require game is not already finalized\n', '        assert(_game.handRank == HAND_UNDEFINED);\n', '\n', '        // Compute _dHand\n', '        address _user = userAddresses[_game.userId];\n', '        bytes32 _blockhash;\n', '        uint32 _dHand;\n', '        uint32 _iHand;  // set if draws are 0, and iBlock is fresh\n', '        uint8 _warnCode;\n', '        if (_game.draws != 0) {\n', '            _blockhash = blockhash(_game.dBlock);\n', '            if (_blockhash != 0) {\n', '                // draw cards to iHand, use as dHand\n', '                _dHand = drawToHand(uint(keccak256(_blockhash, _id)), _game.iHand, _game.draws);\n', '            } else {\n', '                // cannot draw any cards. use iHand.\n', '                if (_game.iHand != 0){\n', '                    _dHand = _game.iHand;\n', '                    _warnCode = WARN_DHAND_TIMEOUT;\n', '                } else {\n', '                    _dHand = 0;\n', '                    _warnCode = WARN_BOTH_TIMEOUT;\n', '                }\n', '            }\n', '        } else {\n', '            _blockhash = blockhash(_game.iBlock);\n', '            if (_blockhash != 0) {\n', '                // ensure they are drawing against expected hand\n', '                if (_blockhash != _hashCheck) {\n', '                    _finalizeFailure(_id, "HashCheck Failed. Try refreshing game.");\n', '                    return;\n', '                }\n', '                // draw 5 cards into iHand, use as dHand\n', '                _iHand = getHand(uint(keccak256(_blockhash, _id)));\n', '                _dHand = _iHand;\n', '            } else {\n', "                // can't finalize with iHand. Draw 5 cards.\n", '                _finalizeFailure(_id, "Initial hand not available. Drawing 5 new cards.");\n', '                _game.draws = 31;\n', '                _game.dBlock = uint32(block.number);\n', '                emit DrawSuccess(now, _user, _id, 0, 31, WARN_IHAND_TIMEOUT);\n', '                return;\n', '            }\n', '        }\n', '\n', '        // Compute _handRank. be sure dHand is not empty\n', '        uint8 _handRank = _dHand == 0\n', '            ? uint8(HAND_NOT_COMPUTABLE)\n', '            : uint8(getHandRank(_dHand));\n', '\n', '        // This only happens if draws==0, and iHand was drawable.\n', '        if (_iHand > 0) _game.iHand = _iHand;\n', '        // Always set dHand and handRank\n', '        _game.dHand = _dHand;\n', '        _game.handRank = _handRank;\n', '\n', '        // Compute _payout, credit user, emit event.\n', '        uint _payout = payTables[_game.payTableId][_handRank] * uint(_game.bet);\n', '        if (_payout > 0) _creditUser(_user, _payout, _id);\n', '        emit FinalizeSuccess(now, _user, _id, _game.dHand, _game.handRank, _payout, _warnCode);\n', '    }\n', '\n', '\n', '\n', '    /************************************************************/\n', '    /******************** PUBLIC VIEWS **************************/\n', '    /************************************************************/\n', '\n', '    // IMPLEMENTS: Bankrollable.getProfits()\n', '    // Ensures contract always has at least bankroll + totalCredits.\n', '    function getCollateral() public view returns (uint _amount) {\n', '        return vars.totalCredits;\n', '    }\n', '\n', '    // IMPLEMENTS: Bankrollable.getWhitelistOwner()\n', '    // Ensures contract always has at least bankroll + totalCredits.\n', '    function getWhitelistOwner() public view returns (address _wlOwner) {\n', '        return getAdmin();\n', '    }\n', '\n', '    // Returns the largest bet such that we could pay out two RoyalFlushes.\n', '    // The likelihood that two RoyalFlushes (with max bet size) are \n', '    //  won within a 255 block period is extremely low.\n', '    function curMaxBet() public view returns (uint) {\n', '        // Return largest bet such that RF*2*bet = bankrollable\n', '        uint _maxPayout = payTables[settings.curPayTableId][HAND_RF] * 2;\n', '        return bankrollAvailable() / _maxPayout;\n', '    }\n', '\n', '    // Return the less of settings.maxBet and curMaxBet()\n', '    function effectiveMaxBet() public view returns (uint _amount) {\n', '        uint _curMax = curMaxBet();\n', '        return _curMax > settings.maxBet ? settings.maxBet : _curMax;\n', '    }\n', '\n', '    function getPayTable(uint16 _payTableId)\n', '        public\n', '        view\n', '        returns (uint16[12])\n', '    {\n', '        require(_payTableId < settings.numPayTables);\n', '        return payTables[_payTableId];\n', '    }\n', '\n', '    function getCurPayTable()\n', '        public\n', '        view\n', '        returns (uint16[12])\n', '    {\n', '        return getPayTable(settings.curPayTableId);\n', '    }\n', '\n', '    // Gets the initial hand of a game.\n', '    function getIHand(uint32 _id)\n', '        public\n', '        view\n', '        returns (uint32)\n', '    {\n', '        Game memory _game = games[_id];\n', '        if (_game.iHand != 0) return _game.iHand;\n', '        if (_game.iBlock == 0) return;\n', '        \n', '        bytes32 _iBlockHash = blockhash(_game.iBlock);\n', '        if (_iBlockHash == 0) return;\n', '        return getHand(uint(keccak256(_iBlockHash, _id)));\n', '    }\n', '\n', '    // Get the final hand of a game.\n', '    // This will return iHand if there are no draws yet.\n', '    function getDHand(uint32 _id)\n', '        public\n', '        view\n', '        returns (uint32)\n', '    {\n', '        Game memory _game = games[_id];\n', '        if (_game.dHand != 0) return _game.dHand;\n', '        if (_game.draws == 0) return _game.iHand;\n', '        if (_game.dBlock == 0) return;\n', '\n', '        bytes32 _dBlockHash = blockhash(_game.dBlock);\n', '        if (_dBlockHash == 0) return _game.iHand;\n', '        return drawToHand(uint(keccak256(_dBlockHash, _id)), _game.iHand, _game.draws);\n', '    }\n', '\n', '    // Returns the hand rank and payout of a Game.\n', '    function getDHandRank(uint32 _id)\n', '        public\n', '        view\n', '        returns (uint8)\n', '    {\n', '        uint32 _dHand = getDHand(_id);\n', '        return _dHand == 0\n', '            ? uint8(HAND_NOT_COMPUTABLE)\n', '            : uint8(getHandRank(_dHand));\n', '    }\n', '\n', '    // Expose Vars //////////////////////////////////////\n', '    function curId() public view returns (uint32) {\n', '        return vars.curId;\n', '    }\n', '    function totalWagered() public view returns (uint) {\n', '        return uint(vars.totalWageredGwei) * 1e9;\n', '    }\n', '    function curUserId() public view returns (uint) {\n', '        return uint(vars.curUserId);\n', '    }\n', '    function totalWon() public view returns (uint) {\n', '        return uint(vars.totalWonGwei) * 1e9;\n', '    }\n', '    function totalCredits() public view returns (uint) {\n', '        return vars.totalCredits;\n', '    }\n', '    /////////////////////////////////////////////////////\n', '\n', '    // Expose Settings //////////////////////////////////\n', '    function minBet() public view returns (uint) {\n', '        return settings.minBet;\n', '    }\n', '    function maxBet() public view returns (uint) {\n', '        return settings.maxBet;\n', '    }\n', '    function curPayTableId() public view returns (uint) {\n', '        return settings.curPayTableId;\n', '    }\n', '    function numPayTables() public view returns (uint) {\n', '        return settings.numPayTables;\n', '    }\n', '    /////////////////////////////////////////////////////\n', '}']
