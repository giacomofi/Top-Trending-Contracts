['pragma solidity ^0.4.23;\n', '\n', '/*****************************************************\n', '************* PENNYETHER REGISTRY ********************\n', '******************************************************\n', '\n', 'Registry allows a permanent owner to map names to addresses.\n', 'Anyone can find a mapped address by calling .addressOf(),\n', 'which throws if the name is not registered to an address.\n', '\n', 'Registry uses a doubly linked list to maintain an iterable\n', 'list of name => address mappings. When a name is mapped to\n', 'the address 0, it is removed from the list.\n', '\n', 'Methods:\n', '    - [onlyOwner] register(name, address)\n', '    - [onlyOnwer] unregiser(name)\n', 'Public Views:\n', '    - size()\n', '    - addressOf(name)\n', '    - nameOf(address)\n', '    - mappings()\n', '\n', '*/\n', 'contract Registry {\n', '    // Doubly Linked List of NameEntries\n', '    struct Entry {\n', '        address addr;\n', '        bytes32 next;\n', '        bytes32 prev;\n', '    }\n', '    mapping (bytes32 => Entry) public entries;\n', '\n', '    // Used to determine if an entry is empty or not.\n', '    address constant NO_ADDRESS = address(0);\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    event Created(uint time);\n', '    event Registered(uint time, bytes32 name, address addr);\n', '    event Unregistered(uint time, bytes32 name);\n', '\n', '    // Constructor sets the owner\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '        emit Created(now);\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function register(bytes32 _name, address _addr)\n', '        fromOwner\n', '        public\n', '    {\n', '        require(_name != 0 && _addr != 0);\n', '        Entry storage entry = entries[_name];\n', '\n', '        // If new entry, replace first one with this one.\n', '        if (entry.addr == NO_ADDRESS) {\n', '            entry.next = entries[0x0].next;\n', '            entries[entries[0x0].next].prev = _name;\n', '            entries[0x0].next = _name;\n', '        }\n', '        // Update the address\n', '        entry.addr = _addr;\n', '        emit Registered(now, _name, _addr);\n', '    }\n', '\n', '    function unregister(bytes32 _name)\n', '        fromOwner\n', '        public\n', '    {\n', '        require(_name != 0);\n', '        Entry storage entry = entries[_name];\n', '        if (entry.addr == NO_ADDRESS) return;\n', '\n', '        // Remove entry by stitching together prev and next\n', '        entries[entry.prev].next = entry.next;\n', '        entries[entry.next].prev = entry.prev;\n', '        delete entries[_name];\n', '        emit Unregistered(now, _name);\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    // Retrieves the address for the name of _name.\n', '    function addressOf(bytes32 _name)\n', '        public\n', '        view\n', '        returns (address _addr)\n', '    {\n', '        _addr = entries[_name].addr;\n', '        require(_addr != address(0));\n', '        return _addr;\n', '    }\n', '\n', '    // Retrieves a associated with an _address.\n', '    function nameOf(address _address)\n', '        public\n', '        view\n', '        returns (bytes32 _name)\n', '    {\n', '        Entry memory _curEntry = entries[0x0];\n', '        Entry memory _nextEntry;\n', '        while (_curEntry.next > 0) {\n', '            _nextEntry = entries[_curEntry.next];\n', '            if (_nextEntry.addr == _address){\n', '                return _curEntry.next;\n', '            }\n', '            _curEntry = _nextEntry;\n', '        }\n', '    }\n', '\n', '    // Retrieves the name of _addr, if any\n', '    function mappings()\n', '        public\n', '        view\n', '        returns (bytes32[] _names, address[] _addresses)\n', '    {\n', '        uint _size = size();\n', '\n', '        // Populate names and addresses\n', '        _names = new bytes32[](_size);\n', '        _addresses = new address[](_size);\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        Entry memory _nextEntry;\n', '        while (_curEntry.next > 0) {\n', '            _nextEntry = entries[_curEntry.next];\n', '            _names[_i] = _curEntry.next;\n', '            _addresses[_i] = _nextEntry.addr;\n', '            _curEntry = _nextEntry;\n', '            _i++;\n', '        }\n', '        return (_names, _addresses);\n', '    }\n', '}']