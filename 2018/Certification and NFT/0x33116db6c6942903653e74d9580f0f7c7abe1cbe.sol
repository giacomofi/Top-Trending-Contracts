['pragma solidity ^0.4.0;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract VanityLib {\n', '    uint constant m = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f;\n', '\n', '    function lengthOfCommonPrefix(bytes a, bytes b) public pure returns(uint) {\n', '        uint len = (a.length <= b.length) ? a.length : b.length;\n', '        for (uint i = 0; i < len; i++) {\n', '            if (a[i] != b[i]) {\n', '                return i;\n', '            }\n', '        }\n', '        return len;\n', '    }\n', '    \n', '    function lengthOfCommonPrefix32(bytes32 a, bytes b) public pure returns(uint) {\n', '        for (uint i = 0; i < b.length; i++) {\n', '            if (a[i] != b[i]) {\n', '                return i;\n', '            }\n', '        }\n', '        return b.length;\n', '    }\n', '\n', '    function lengthOfCommonPrefix3232(bytes32 a, bytes32 b) public pure returns(uint) {\n', '        for (uint i = 0; i < 32; i++) {\n', '            if (a[i] != b[i] || a[i] == 0) {\n', '                return i;\n', '            }\n', '        }\n', '        return 0;\n', '    }\n', '    \n', '    function equalBytesToBytes(bytes a, bytes b) public pure returns (bool) {\n', '        if (a.length != b.length) {\n', '            return false;\n', '        }\n', '        for (uint i = 0; i < a.length; i++) {\n', '            if (a[i] != b[i]) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function equalBytes32ToBytes(bytes32 a, bytes b) public pure returns (bool) {\n', '        for (uint i = 0; i < b.length; i++) {\n', '            if (a[i] != b[i]) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function bytesToBytes32(bytes source) public pure returns(bytes32 result) {\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '\n', '    /* Converts given number to base58, limited by 32 symbols */\n', '    function toBase58Checked(uint256 _value, byte appCode) public pure returns(bytes32) {\n', '        string memory letters = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";\n', '        bytes memory alphabet = bytes(letters);\n', '        uint8 base = 58;\n', '        uint8 len = 0;\n', '        uint256 remainder = 0;\n', '        bool needBreak = false;\n', '        bytes memory bytesReversed = bytes(new string(32));\n', '        \n', '        for (uint8 i = 0; true; i++) {\n', '            if (_value < base) {\n', '                needBreak = true;\n', '            }\n', '            remainder = _value % base;\n', '            _value = uint256(_value / base);\n', '            if (len == 32) {\n', '                for (uint j = 0; j < len - 1; j++) {\n', '                    bytesReversed[j] = bytesReversed[j + 1];\n', '                }\n', '                len--;\n', '            }\n', '            bytesReversed[len] = alphabet[remainder];\n', '            len++;\n', '            if (needBreak) {\n', '                break;\n', '            }\n', '        }\n', '        \n', '        // Reverse\n', '        bytes memory result = bytes(new string(32));\n', '        result[0] = appCode;\n', '        for (i = 0; i < 31; i++) {\n', '            result[i + 1] = bytesReversed[len - 1 - i];\n', '        }\n', '        \n', '        return bytesToBytes32(result);\n', '    }\n', '\n', '    // Create BTC Address: https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses#How_to_create_Bitcoin_Address\n', '    function createBtcAddressHex(uint256 publicXPoint, uint256 publicYPoint) public pure returns(uint256) {\n', '        bytes20 publicKeyPart = ripemd160(sha256(byte(0x04), publicXPoint, publicYPoint));\n', '        bytes32 publicKeyCheckCode = sha256(sha256(byte(0x00), publicKeyPart));\n', '        \n', '        bytes memory publicKey = new bytes(32);\n', '        for (uint i = 0; i < 7; i++) {\n', '            publicKey[i] = 0x00;\n', '        }\n', '        publicKey[7] = 0x00; // Main Network\n', '        for (uint j = 0; j < 20; j++) {\n', '            publicKey[j + 8] = publicKeyPart[j];\n', '        }\n', '        publicKey[28] = publicKeyCheckCode[0];\n', '        publicKey[29] = publicKeyCheckCode[1];\n', '        publicKey[30] = publicKeyCheckCode[2];\n', '        publicKey[31] = publicKeyCheckCode[3];\n', '        \n', '        return uint256(bytesToBytes32(publicKey));\n', '    }\n', '    \n', '    function createBtcAddress(uint256 publicXPoint, uint256 publicYPoint) public pure returns(bytes32) {\n', '        return toBase58Checked(createBtcAddressHex(publicXPoint, publicYPoint), "1");\n', '    }\n', '\n', '    // https://github.com/stonecoldpat/anonymousvoting/blob/master/LocalCrypto.sol\n', '    function invmod(uint256 a, uint256 p) public pure returns (uint256) {\n', '        int t1 = 0;\n', '        int t2 = 1;\n', '        uint r1 = p;\n', '        uint r2 = a;\n', '        uint q;\n', '        while (r2 != 0) {\n', '            q = r1 / r2;\n', '            (t1, t2, r1, r2) = (t2, t1 - int(q) * t2, r2, r1 - q * r2);\n', '        }\n', '\n', '        return t1 < 0 ? p - uint(-t1) : uint(t1);\n', '    }\n', '    \n', '    // https://github.com/stonecoldpat/anonymousvoting/blob/master/LocalCrypto.sol\n', '    function submod(uint a, uint b, uint p) public pure returns (uint) {\n', '        return addmod(a, p - b, p);\n', '    }\n', '\n', '    // https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Point_addition\n', '    // https://github.com/bellaj/Blockchain/blob/6bffb47afae6a2a70903a26d215484cf8ff03859/ecdsa_bitcoin.pdf\n', '    // https://math.stackexchange.com/questions/2198139/elliptic-curve-formulas-for-point-addition\n', '    function addXY(uint x1, uint y1, uint x2, uint y2) public pure returns(uint x3, uint y3) {\n', '        uint anti = invmod(submod(x1, x2, m), m);\n', '        uint alpha = mulmod(submod(y1, y2, m), anti, m);\n', '        x3 = submod(submod(mulmod(alpha, alpha, m), x1, m), x2, m);\n', '        y3 = submod(mulmod(alpha, submod(x2, x3, m), m), y2, m);\n', '        \n', '        // x3 = bytes32(mul_mod(uint(x3), uint(y3), m)); == 1!!!!\n', '        \n', '        // https://github.com/jbaylina/ecsol/blob/master/ec.sol\n', '        // x3 = addmod(mulmod(y2, x1, m), mulmod(x2, y1, m), m);\n', '        // y3 = mulmod(y1, y2, m);\n', '    }\n', '\n', '    function doubleXY(uint x1, uint y1) public pure returns(uint x2, uint y2) {\n', '        uint anti = invmod(addmod(y1, y1, m), m);\n', '        uint alpha = mulmod(addmod(addmod(mulmod(x1, x1, m), mulmod(x1, x1, m), m), mulmod(x1, x1, m), m), anti, m);\n', '        x2 = submod(mulmod(alpha, alpha, m), addmod(x1, x1, m), m);\n', '        y2 = submod(mulmod(alpha, submod(x1, x2, m), m), y1, m);\n', '    }\n', '\n', '    function mulXY(uint x1, uint y1, uint privateKey) public pure returns(uint x2, uint y2) {\n', '        bool addition = false;\n', '        for (uint i = 0; i < 256; i++) {\n', '            if (((privateKey >> i) & 1) == 1) {\n', '                if (addition) {\n', '                    (x2, y2) = addXY(x1, y1, x2, y2);\n', '                } else {\n', '                    (x2, y2) = (x1, y1);\n', '                    addition = true;\n', '                }\n', '            }\n', '            (x1,y1) = doubleXY(x1, y1);\n', '        }\n', '    }\n', '\n', '    function bitcoinPublicKey(uint256 privateKey) public pure returns(uint, uint) {\n', '        uint256 gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798;\n', '        uint256 gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8;\n', '        return mulXY(gx, gy, privateKey);\n', '    }\n', '\n', '    function complexityForBtcAddressPrefix(bytes prefix) public pure returns(uint) {\n', '        return complexityForBtcAddressPrefixWithLength(prefix, prefix.length);\n', '    }\n', '\n', '    // https://bitcoin.stackexchange.com/questions/48586\n', '    function complexityForBtcAddressPrefixWithLength(bytes prefix, uint length) public pure returns(uint) {\n', '        require(prefix.length >= length);\n', '        \n', '        uint8[128] memory unbase58 = [\n', '            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, \n', '            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n', '            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, \n', '            255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 255, 255, 255, 255, 255, 255, \n', '            255, 9, 10, 11, 12, 13, 14, 15, 16, 255, 17, 18, 19, 20, 21, 255, \n', '            22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 255, 255, 255, 255, 255,\n', '            255, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 255, 44, 45, 46,\n', '            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 255, 255, 255, 255, 255\n', '        ];\n', '\n', '        uint leadingOnes = countBtcAddressLeadingOnes(prefix, length);\n', '\n', '        uint256 prefixValue = 0;\n', '        uint256 prefix1 = 1;\n', '        for (uint i = 0; i < length; i++) {\n', '            uint index = uint(prefix[i]);\n', '            require(index != 255);\n', '            prefixValue = prefixValue * 58 + unbase58[index];\n', '            prefix1 *= 58;\n', '        }\n', '\n', '        uint256 top = (uint256(1) << (200 - 8*leadingOnes));\n', '        uint256 total = 0;\n', '        uint256 prefixMin = prefixValue;\n', '        uint256 diff = 0;\n', '        for (uint digits = 1; prefix1/58 < (1 << 192); digits++) {\n', '            prefix1 *= 58;\n', '            prefixMin *= 58;\n', '            prefixValue = prefixValue * 58 + 57;\n', '\n', '            diff = 0;\n', '            if (prefixValue >= top) {\n', '                diff += prefixValue - top;\n', '            }\n', '            if (prefixMin < (top >> 8)) {\n', '                diff += (top >> 8) - prefixMin;\n', '            }\n', '            \n', '            if ((58 ** digits) >= diff) {\n', '                total += (58 ** digits) - diff;\n', '            }\n', '        }\n', '\n', '        if (prefixMin == 0) { // if prefix is contains only ones: 111111\n', '            total = (58 ** (digits - 1)) - diff;\n', '        }\n', '\n', '        return (1 << 192) / total;\n', '    }\n', '\n', '    function countBtcAddressLeadingOnes(bytes prefix, uint length) public pure returns(uint) {\n', '        uint leadingOnes = 1;\n', '        for (uint j = 0; j < length && prefix[j] == 49; j++) {\n', '            leadingOnes = j + 1;\n', '        }\n', '        return leadingOnes;\n', '    }\n', '\n', '    function isValidBicoinAddressPrefix(bytes prefixArg) public pure returns(bool) {\n', '        if (prefixArg.length < 5) {\n', '            return false;\n', '        }\n', '        if (prefixArg[0] != "1" && prefixArg[0] != "3") {\n', '            return false;\n', '        }\n', '        \n', '        for (uint i = 0; i < prefixArg.length; i++) {\n', '            byte ch = prefixArg[i];\n', '            if (ch == "0" || ch == "O" || ch == "I" || ch == "l") {\n', '                return false;\n', '            }\n', '            if (!((ch >= "1" && ch <= "9") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z"))) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function isValidPublicKey(uint256 x, uint256 y) public pure returns(bool) {\n', '        return (mulmod(y, y, m) == addmod(mulmod(x, mulmod(x, x, m), m), 7, m));\n', '    }\n', '\n', '}\n', '\n', 'contract IUpgradable {\n', '\n', '    function startUpgrade() public;\n', '    function endUpgrade() public;\n', '\n', '}\n', '\n', 'contract Upgradable is Ownable {\n', '\n', '    struct UpgradableState {\n', '        bool isUpgrading;\n', '        address prevVersion;\n', '        address nextVersion;\n', '    }\n', '\n', '    UpgradableState public upgradableState;\n', '\n', '    event Initialized(address indexed prevVersion);\n', '    event Upgrading(address indexed nextVersion);\n', '    event Upgraded(address indexed nextVersion);\n', '\n', '    modifier isLastestVersion {\n', '        require(!upgradableState.isUpgrading);\n', '        require(upgradableState.nextVersion == address(0));\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrigin {\n', '        require(tx.origin == owner);\n', '        _;\n', '    }\n', '\n', '    function Upgradable(address _prevVersion) public {\n', '        if (_prevVersion != address(0)) {\n', '            require(msg.sender == Ownable(_prevVersion).owner());\n', '            upgradableState.isUpgrading = true;\n', '            upgradableState.prevVersion = _prevVersion;\n', '            IUpgradable(_prevVersion).startUpgrade();\n', '        } else {\n', '            Initialized(_prevVersion);\n', '        }\n', '    }\n', '\n', '    function startUpgrade() public onlyOwnerOrigin {\n', '        require(msg.sender != owner);\n', '        require(!upgradableState.isUpgrading);\n', '        require(upgradableState.nextVersion == 0);\n', '        upgradableState.isUpgrading = true;\n', '        upgradableState.nextVersion = msg.sender;\n', '        Upgrading(msg.sender);\n', '    }\n', '\n', '    //function upgrade(uint index, uint size) public onlyOwner {}\n', '\n', '    function endUpgrade() public onlyOwnerOrigin {\n', '        require(upgradableState.isUpgrading);\n', '        upgradableState.isUpgrading = false;\n', '        if (msg.sender != owner) {\n', '            require(upgradableState.nextVersion == msg.sender);\n', '            Upgraded(upgradableState.nextVersion);\n', '        } \n', '        else  {\n', '            if (upgradableState.prevVersion != address(0)) {\n', '                Upgradable(upgradableState.prevVersion).endUpgrade();\n', '            }\n', '            Initialized(upgradableState.prevVersion);\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract IEC {\n', '\n', '    function _inverse(uint256 a) public constant \n', '        returns(uint256 invA);\n', '\n', '    function _ecAdd(uint256 x1,uint256 y1,uint256 z1,\n', '                    uint256 x2,uint256 y2,uint256 z2) public constant\n', '        returns(uint256 x3,uint256 y3,uint256 z3);\n', '\n', '    function _ecDouble(uint256 x1,uint256 y1,uint256 z1) public constant\n', '        returns(uint256 x3,uint256 y3,uint256 z3);\n', '\n', '    function _ecMul(uint256 d, uint256 x1,uint256 y1,uint256 z1) public constant\n', '        returns(uint256 x3,uint256 y3,uint256 z3);\n', '\n', '    function publicKey(uint256 privKey) public constant\n', '        returns(uint256 qx, uint256 qy);\n', '\n', '    function deriveKey(uint256 privKey, uint256 pubX, uint256 pubY) public constant\n', '        returns(uint256 qx, uint256 qy);\n', '\n', '}\n', '\n', 'contract TaskRegister is Upgradable, VanityLib {\n', '\n', '    enum TaskType {\n', '        BITCOIN_ADDRESS_PREFIX\n', '    }\n', '\n', '    struct Task {\n', '        TaskType taskType;\n', '        uint256 taskId;\n', '        address creator;\n', '        uint256 reward;\n', '        bytes32 data;\n', '        uint256 dataLength;\n', '        uint256 requestPublicXPoint;\n', '        uint256 requestPublicYPoint;\n', '        uint256 answerPrivateKey;\n', '    }\n', '\n', '    IEC public ec;\n', '    ERC20 public token;\n', '    uint256 public nextTaskId = 1;\n', '    uint256 public totalReward;\n', '    \n', '    Task[] public tasks;\n', '    Task[] public completedTasks;\n', '    mapping(uint256 => uint) public indexOfTaskId; // Starting from 1\n', '    event TaskCreated(uint256 indexed taskId);\n', '    event TaskSolved(uint256 indexed taskId);\n', '    event TaskPayed(uint256 indexed taskId);\n', '\n', '    function TaskRegister(address _ec, address _token, address _prevVersion) public Upgradable(_prevVersion) {\n', '        ec = IEC(_ec);\n', '        token = ERC20(_token);\n', '    }\n', '\n', '    function upgrade(uint size) public onlyOwner {\n', '        require(upgradableState.isUpgrading);\n', '        require(upgradableState.prevVersion != 0);\n', '\n', '        // Migrate some vars\n', '        nextTaskId = TaskRegister(upgradableState.prevVersion).nextTaskId();\n', '        totalReward = TaskRegister(upgradableState.prevVersion).totalReward();\n', '\n', '        uint index = tasks.length;\n', '        uint tasksCount = TaskRegister(upgradableState.prevVersion).tasksCount();\n', '\n', '        // Migrate tasks\n', '\n', '        for (uint i = index; i < index + size && i < tasksCount; i++) {\n', '            tasks.push(Task(TaskType.BITCOIN_ADDRESS_PREFIX,0,0,0,bytes32(0),0,0,0,0));\n', '        }\n', '\n', '        for (uint j = index; j < index + size && j < tasksCount; j++) {\n', '            (\n', '                tasks[j].taskType,\n', '                tasks[j].taskId,\n', '                tasks[j].creator,\n', '                tasks[j].reward,\n', '                tasks[j].data,\n', '                ,//tasks[j].dataLength, \n', '                ,//tasks[j].requestPublicXPoint, \n', '                ,//tasks[j].requestPublicYPoint,\n', '                 //tasks[j].answerPrivateKey\n', '            ) = TaskRegister(upgradableState.prevVersion).tasks(j);\n', '            indexOfTaskId[tasks[j].taskId] = j + 1;\n', '        }\n', '\n', '        for (uint k = index; k < index + size && k < tasksCount; k++) {\n', '            (\n', '                ,//tasks[k].taskType,\n', '                ,//tasks[k].taskId,\n', '                ,//tasks[k].creator,\n', '                ,//tasks[k].reward,\n', '                ,//tasks[k].data,\n', '                tasks[k].dataLength, \n', '                tasks[k].requestPublicXPoint, \n', '                tasks[k].requestPublicYPoint,\n', '                tasks[k].answerPrivateKey\n', '            ) = TaskRegister(upgradableState.prevVersion).tasks(k);\n', '        }\n', '    }\n', '    \n', '    function endUpgrade() public {\n', '        super.endUpgrade();\n', '        \n', '        if (upgradableState.nextVersion != 0) {\n', '            token.transfer(upgradableState.nextVersion, token.balanceOf(this));\n', '        }\n', '    }\n', '\n', '    function tasksCount() public constant returns(uint) {\n', '        return tasks.length;\n', '    }\n', '\n', '    function completedTasksCount() public constant returns(uint) {\n', '        return completedTasks.length;\n', '    }\n', '\n', '    function payForTask(uint256 taskId, uint256 reward) public isLastestVersion {\n', '        require(reward > 0);\n', '        uint index = safeIndexOfTaskId(taskId);\n', '        token.transferFrom(tx.origin, this, reward);\n', '        tasks[index].reward += reward;\n', '        totalReward += reward;\n', '        TaskPayed(taskId);\n', '    }\n', '\n', '    function safeIndexOfTaskId(uint taskId) public constant returns(uint) {\n', '        uint index = indexOfTaskId[taskId];\n', '        require(index > 0);\n', '        return index - 1;\n', '    }\n', '    \n', '    function createBitcoinAddressPrefixTask(bytes prefix, uint256 reward, uint256 requestPublicXPoint, uint256 requestPublicYPoint) public isLastestVersion {\n', '        require(prefix.length > 5);\n', '        require(prefix[0] == "1");\n', '        require(prefix[1] != "1"); // Do not support multiple 1s yet\n', '        require(isValidBicoinAddressPrefix(prefix));\n', '        require(isValidPublicKey(requestPublicXPoint, requestPublicYPoint));\n', '        if (reward > 0) {\n', '            token.transferFrom(tx.origin, this, reward);\n', '        }\n', '\n', '        bytes32 data;\n', '        assembly {\n', '            data := mload(add(prefix, 32))\n', '        }\n', '        \n', '        Task memory task = Task({\n', '            taskType: TaskType.BITCOIN_ADDRESS_PREFIX,\n', '            taskId: nextTaskId,\n', '            creator: tx.origin,\n', '            reward: reward,\n', '            data: data,\n', '            dataLength: prefix.length,\n', '            requestPublicXPoint: requestPublicXPoint,\n', '            requestPublicYPoint: requestPublicYPoint,\n', '            answerPrivateKey: 0\n', '        });\n', '        tasks.push(task);\n', '        indexOfTaskId[nextTaskId] = tasks.length; // incremented to avoid 0 index\n', '        TaskCreated(nextTaskId);\n', '        nextTaskId++;\n', '    }\n', '    \n', '    function solveTask(uint taskId, uint256 answerPrivateKey) public isLastestVersion {\n', '        uint taskIndex = safeIndexOfTaskId(taskId);\n', '        Task storage task = tasks[taskIndex];\n', '\n', '        // Require private key to be part of address to prevent front-running attack\n', '        bytes32 answerPrivateKeyBytes = bytes32(answerPrivateKey);\n', '        bytes32 senderAddressBytes = bytes32(uint256(msg.sender) << 96);\n', '        for (uint i = 0; i < 16; i++) {\n', '            require(answerPrivateKeyBytes[i] == senderAddressBytes[i]);\n', '        }\n', '\n', '        if (task.taskType == TaskType.BITCOIN_ADDRESS_PREFIX) {\n', '            uint256 answerPublicXPoint;\n', '            uint256 answerPublicYPoint;\n', '            uint256 publicXPoint;\n', '            uint256 publicYPoint;\n', '            uint256 z;\n', '            (answerPublicXPoint, answerPublicYPoint) = ec.publicKey(answerPrivateKey);\n', '            (publicXPoint, publicYPoint, z) = ec._ecAdd(\n', '                task.requestPublicXPoint,\n', '                task.requestPublicYPoint,\n', '                1,\n', '                answerPublicXPoint,\n', '                answerPublicYPoint,\n', '                1\n', '            );\n', '\n', '            uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n', '            z = ec._inverse(z);\n', '            publicXPoint = mulmod(publicXPoint, z, m);\n', '            publicYPoint = mulmod(publicYPoint, z, m);\n', '            require(isValidPublicKey(publicXPoint, publicYPoint));\n', '            \n', '            bytes32 btcAddress = createBtcAddress(publicXPoint, publicYPoint);\n', '            uint prefixLength = lengthOfCommonPrefix3232(btcAddress, task.data);\n', '            require(prefixLength == task.dataLength);\n', '            \n', '            task.answerPrivateKey = answerPrivateKey;\n', '        }\n', '\n', '        token.transfer(msg.sender, task.reward);\n', '        totalReward -= task.reward;\n', '\n', '        completeTask(taskId, taskIndex);\n', '        TaskSolved(taskId);\n', '    }\n', '\n', '    function completeTask(uint taskId, uint index) internal {\n', '        completedTasks.push(tasks[index]);\n', '        if (index < tasks.length - 1) { // if not latest\n', '            tasks[index] = tasks[tasks.length - 1];\n', '            indexOfTaskId[tasks[index].taskId] = index + 1;\n', '        }\n', '        tasks.length -= 1;\n', '        delete indexOfTaskId[taskId];\n', '    }\n', '\n', '    function recoverLost(ERC20Basic _token, address loser) public onlyOwner {\n', '        uint256 amount = _token.balanceOf(this);\n', '        if (_token == token) {\n', '            amount -= totalReward;\n', '        }\n', '        _token.transfer(loser, _token.balanceOf(this));\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.0;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract VanityLib {\n', '    uint constant m = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f;\n', '\n', '    function lengthOfCommonPrefix(bytes a, bytes b) public pure returns(uint) {\n', '        uint len = (a.length <= b.length) ? a.length : b.length;\n', '        for (uint i = 0; i < len; i++) {\n', '            if (a[i] != b[i]) {\n', '                return i;\n', '            }\n', '        }\n', '        return len;\n', '    }\n', '    \n', '    function lengthOfCommonPrefix32(bytes32 a, bytes b) public pure returns(uint) {\n', '        for (uint i = 0; i < b.length; i++) {\n', '            if (a[i] != b[i]) {\n', '                return i;\n', '            }\n', '        }\n', '        return b.length;\n', '    }\n', '\n', '    function lengthOfCommonPrefix3232(bytes32 a, bytes32 b) public pure returns(uint) {\n', '        for (uint i = 0; i < 32; i++) {\n', '            if (a[i] != b[i] || a[i] == 0) {\n', '                return i;\n', '            }\n', '        }\n', '        return 0;\n', '    }\n', '    \n', '    function equalBytesToBytes(bytes a, bytes b) public pure returns (bool) {\n', '        if (a.length != b.length) {\n', '            return false;\n', '        }\n', '        for (uint i = 0; i < a.length; i++) {\n', '            if (a[i] != b[i]) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function equalBytes32ToBytes(bytes32 a, bytes b) public pure returns (bool) {\n', '        for (uint i = 0; i < b.length; i++) {\n', '            if (a[i] != b[i]) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function bytesToBytes32(bytes source) public pure returns(bytes32 result) {\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '\n', '    /* Converts given number to base58, limited by 32 symbols */\n', '    function toBase58Checked(uint256 _value, byte appCode) public pure returns(bytes32) {\n', '        string memory letters = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";\n', '        bytes memory alphabet = bytes(letters);\n', '        uint8 base = 58;\n', '        uint8 len = 0;\n', '        uint256 remainder = 0;\n', '        bool needBreak = false;\n', '        bytes memory bytesReversed = bytes(new string(32));\n', '        \n', '        for (uint8 i = 0; true; i++) {\n', '            if (_value < base) {\n', '                needBreak = true;\n', '            }\n', '            remainder = _value % base;\n', '            _value = uint256(_value / base);\n', '            if (len == 32) {\n', '                for (uint j = 0; j < len - 1; j++) {\n', '                    bytesReversed[j] = bytesReversed[j + 1];\n', '                }\n', '                len--;\n', '            }\n', '            bytesReversed[len] = alphabet[remainder];\n', '            len++;\n', '            if (needBreak) {\n', '                break;\n', '            }\n', '        }\n', '        \n', '        // Reverse\n', '        bytes memory result = bytes(new string(32));\n', '        result[0] = appCode;\n', '        for (i = 0; i < 31; i++) {\n', '            result[i + 1] = bytesReversed[len - 1 - i];\n', '        }\n', '        \n', '        return bytesToBytes32(result);\n', '    }\n', '\n', '    // Create BTC Address: https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses#How_to_create_Bitcoin_Address\n', '    function createBtcAddressHex(uint256 publicXPoint, uint256 publicYPoint) public pure returns(uint256) {\n', '        bytes20 publicKeyPart = ripemd160(sha256(byte(0x04), publicXPoint, publicYPoint));\n', '        bytes32 publicKeyCheckCode = sha256(sha256(byte(0x00), publicKeyPart));\n', '        \n', '        bytes memory publicKey = new bytes(32);\n', '        for (uint i = 0; i < 7; i++) {\n', '            publicKey[i] = 0x00;\n', '        }\n', '        publicKey[7] = 0x00; // Main Network\n', '        for (uint j = 0; j < 20; j++) {\n', '            publicKey[j + 8] = publicKeyPart[j];\n', '        }\n', '        publicKey[28] = publicKeyCheckCode[0];\n', '        publicKey[29] = publicKeyCheckCode[1];\n', '        publicKey[30] = publicKeyCheckCode[2];\n', '        publicKey[31] = publicKeyCheckCode[3];\n', '        \n', '        return uint256(bytesToBytes32(publicKey));\n', '    }\n', '    \n', '    function createBtcAddress(uint256 publicXPoint, uint256 publicYPoint) public pure returns(bytes32) {\n', '        return toBase58Checked(createBtcAddressHex(publicXPoint, publicYPoint), "1");\n', '    }\n', '\n', '    // https://github.com/stonecoldpat/anonymousvoting/blob/master/LocalCrypto.sol\n', '    function invmod(uint256 a, uint256 p) public pure returns (uint256) {\n', '        int t1 = 0;\n', '        int t2 = 1;\n', '        uint r1 = p;\n', '        uint r2 = a;\n', '        uint q;\n', '        while (r2 != 0) {\n', '            q = r1 / r2;\n', '            (t1, t2, r1, r2) = (t2, t1 - int(q) * t2, r2, r1 - q * r2);\n', '        }\n', '\n', '        return t1 < 0 ? p - uint(-t1) : uint(t1);\n', '    }\n', '    \n', '    // https://github.com/stonecoldpat/anonymousvoting/blob/master/LocalCrypto.sol\n', '    function submod(uint a, uint b, uint p) public pure returns (uint) {\n', '        return addmod(a, p - b, p);\n', '    }\n', '\n', '    // https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Point_addition\n', '    // https://github.com/bellaj/Blockchain/blob/6bffb47afae6a2a70903a26d215484cf8ff03859/ecdsa_bitcoin.pdf\n', '    // https://math.stackexchange.com/questions/2198139/elliptic-curve-formulas-for-point-addition\n', '    function addXY(uint x1, uint y1, uint x2, uint y2) public pure returns(uint x3, uint y3) {\n', '        uint anti = invmod(submod(x1, x2, m), m);\n', '        uint alpha = mulmod(submod(y1, y2, m), anti, m);\n', '        x3 = submod(submod(mulmod(alpha, alpha, m), x1, m), x2, m);\n', '        y3 = submod(mulmod(alpha, submod(x2, x3, m), m), y2, m);\n', '        \n', '        // x3 = bytes32(mul_mod(uint(x3), uint(y3), m)); == 1!!!!\n', '        \n', '        // https://github.com/jbaylina/ecsol/blob/master/ec.sol\n', '        // x3 = addmod(mulmod(y2, x1, m), mulmod(x2, y1, m), m);\n', '        // y3 = mulmod(y1, y2, m);\n', '    }\n', '\n', '    function doubleXY(uint x1, uint y1) public pure returns(uint x2, uint y2) {\n', '        uint anti = invmod(addmod(y1, y1, m), m);\n', '        uint alpha = mulmod(addmod(addmod(mulmod(x1, x1, m), mulmod(x1, x1, m), m), mulmod(x1, x1, m), m), anti, m);\n', '        x2 = submod(mulmod(alpha, alpha, m), addmod(x1, x1, m), m);\n', '        y2 = submod(mulmod(alpha, submod(x1, x2, m), m), y1, m);\n', '    }\n', '\n', '    function mulXY(uint x1, uint y1, uint privateKey) public pure returns(uint x2, uint y2) {\n', '        bool addition = false;\n', '        for (uint i = 0; i < 256; i++) {\n', '            if (((privateKey >> i) & 1) == 1) {\n', '                if (addition) {\n', '                    (x2, y2) = addXY(x1, y1, x2, y2);\n', '                } else {\n', '                    (x2, y2) = (x1, y1);\n', '                    addition = true;\n', '                }\n', '            }\n', '            (x1,y1) = doubleXY(x1, y1);\n', '        }\n', '    }\n', '\n', '    function bitcoinPublicKey(uint256 privateKey) public pure returns(uint, uint) {\n', '        uint256 gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798;\n', '        uint256 gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8;\n', '        return mulXY(gx, gy, privateKey);\n', '    }\n', '\n', '    function complexityForBtcAddressPrefix(bytes prefix) public pure returns(uint) {\n', '        return complexityForBtcAddressPrefixWithLength(prefix, prefix.length);\n', '    }\n', '\n', '    // https://bitcoin.stackexchange.com/questions/48586\n', '    function complexityForBtcAddressPrefixWithLength(bytes prefix, uint length) public pure returns(uint) {\n', '        require(prefix.length >= length);\n', '        \n', '        uint8[128] memory unbase58 = [\n', '            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, \n', '            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n', '            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, \n', '            255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 255, 255, 255, 255, 255, 255, \n', '            255, 9, 10, 11, 12, 13, 14, 15, 16, 255, 17, 18, 19, 20, 21, 255, \n', '            22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 255, 255, 255, 255, 255,\n', '            255, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 255, 44, 45, 46,\n', '            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 255, 255, 255, 255, 255\n', '        ];\n', '\n', '        uint leadingOnes = countBtcAddressLeadingOnes(prefix, length);\n', '\n', '        uint256 prefixValue = 0;\n', '        uint256 prefix1 = 1;\n', '        for (uint i = 0; i < length; i++) {\n', '            uint index = uint(prefix[i]);\n', '            require(index != 255);\n', '            prefixValue = prefixValue * 58 + unbase58[index];\n', '            prefix1 *= 58;\n', '        }\n', '\n', '        uint256 top = (uint256(1) << (200 - 8*leadingOnes));\n', '        uint256 total = 0;\n', '        uint256 prefixMin = prefixValue;\n', '        uint256 diff = 0;\n', '        for (uint digits = 1; prefix1/58 < (1 << 192); digits++) {\n', '            prefix1 *= 58;\n', '            prefixMin *= 58;\n', '            prefixValue = prefixValue * 58 + 57;\n', '\n', '            diff = 0;\n', '            if (prefixValue >= top) {\n', '                diff += prefixValue - top;\n', '            }\n', '            if (prefixMin < (top >> 8)) {\n', '                diff += (top >> 8) - prefixMin;\n', '            }\n', '            \n', '            if ((58 ** digits) >= diff) {\n', '                total += (58 ** digits) - diff;\n', '            }\n', '        }\n', '\n', '        if (prefixMin == 0) { // if prefix is contains only ones: 111111\n', '            total = (58 ** (digits - 1)) - diff;\n', '        }\n', '\n', '        return (1 << 192) / total;\n', '    }\n', '\n', '    function countBtcAddressLeadingOnes(bytes prefix, uint length) public pure returns(uint) {\n', '        uint leadingOnes = 1;\n', '        for (uint j = 0; j < length && prefix[j] == 49; j++) {\n', '            leadingOnes = j + 1;\n', '        }\n', '        return leadingOnes;\n', '    }\n', '\n', '    function isValidBicoinAddressPrefix(bytes prefixArg) public pure returns(bool) {\n', '        if (prefixArg.length < 5) {\n', '            return false;\n', '        }\n', '        if (prefixArg[0] != "1" && prefixArg[0] != "3") {\n', '            return false;\n', '        }\n', '        \n', '        for (uint i = 0; i < prefixArg.length; i++) {\n', '            byte ch = prefixArg[i];\n', '            if (ch == "0" || ch == "O" || ch == "I" || ch == "l") {\n', '                return false;\n', '            }\n', '            if (!((ch >= "1" && ch <= "9") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z"))) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function isValidPublicKey(uint256 x, uint256 y) public pure returns(bool) {\n', '        return (mulmod(y, y, m) == addmod(mulmod(x, mulmod(x, x, m), m), 7, m));\n', '    }\n', '\n', '}\n', '\n', 'contract IUpgradable {\n', '\n', '    function startUpgrade() public;\n', '    function endUpgrade() public;\n', '\n', '}\n', '\n', 'contract Upgradable is Ownable {\n', '\n', '    struct UpgradableState {\n', '        bool isUpgrading;\n', '        address prevVersion;\n', '        address nextVersion;\n', '    }\n', '\n', '    UpgradableState public upgradableState;\n', '\n', '    event Initialized(address indexed prevVersion);\n', '    event Upgrading(address indexed nextVersion);\n', '    event Upgraded(address indexed nextVersion);\n', '\n', '    modifier isLastestVersion {\n', '        require(!upgradableState.isUpgrading);\n', '        require(upgradableState.nextVersion == address(0));\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrigin {\n', '        require(tx.origin == owner);\n', '        _;\n', '    }\n', '\n', '    function Upgradable(address _prevVersion) public {\n', '        if (_prevVersion != address(0)) {\n', '            require(msg.sender == Ownable(_prevVersion).owner());\n', '            upgradableState.isUpgrading = true;\n', '            upgradableState.prevVersion = _prevVersion;\n', '            IUpgradable(_prevVersion).startUpgrade();\n', '        } else {\n', '            Initialized(_prevVersion);\n', '        }\n', '    }\n', '\n', '    function startUpgrade() public onlyOwnerOrigin {\n', '        require(msg.sender != owner);\n', '        require(!upgradableState.isUpgrading);\n', '        require(upgradableState.nextVersion == 0);\n', '        upgradableState.isUpgrading = true;\n', '        upgradableState.nextVersion = msg.sender;\n', '        Upgrading(msg.sender);\n', '    }\n', '\n', '    //function upgrade(uint index, uint size) public onlyOwner {}\n', '\n', '    function endUpgrade() public onlyOwnerOrigin {\n', '        require(upgradableState.isUpgrading);\n', '        upgradableState.isUpgrading = false;\n', '        if (msg.sender != owner) {\n', '            require(upgradableState.nextVersion == msg.sender);\n', '            Upgraded(upgradableState.nextVersion);\n', '        } \n', '        else  {\n', '            if (upgradableState.prevVersion != address(0)) {\n', '                Upgradable(upgradableState.prevVersion).endUpgrade();\n', '            }\n', '            Initialized(upgradableState.prevVersion);\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract IEC {\n', '\n', '    function _inverse(uint256 a) public constant \n', '        returns(uint256 invA);\n', '\n', '    function _ecAdd(uint256 x1,uint256 y1,uint256 z1,\n', '                    uint256 x2,uint256 y2,uint256 z2) public constant\n', '        returns(uint256 x3,uint256 y3,uint256 z3);\n', '\n', '    function _ecDouble(uint256 x1,uint256 y1,uint256 z1) public constant\n', '        returns(uint256 x3,uint256 y3,uint256 z3);\n', '\n', '    function _ecMul(uint256 d, uint256 x1,uint256 y1,uint256 z1) public constant\n', '        returns(uint256 x3,uint256 y3,uint256 z3);\n', '\n', '    function publicKey(uint256 privKey) public constant\n', '        returns(uint256 qx, uint256 qy);\n', '\n', '    function deriveKey(uint256 privKey, uint256 pubX, uint256 pubY) public constant\n', '        returns(uint256 qx, uint256 qy);\n', '\n', '}\n', '\n', 'contract TaskRegister is Upgradable, VanityLib {\n', '\n', '    enum TaskType {\n', '        BITCOIN_ADDRESS_PREFIX\n', '    }\n', '\n', '    struct Task {\n', '        TaskType taskType;\n', '        uint256 taskId;\n', '        address creator;\n', '        uint256 reward;\n', '        bytes32 data;\n', '        uint256 dataLength;\n', '        uint256 requestPublicXPoint;\n', '        uint256 requestPublicYPoint;\n', '        uint256 answerPrivateKey;\n', '    }\n', '\n', '    IEC public ec;\n', '    ERC20 public token;\n', '    uint256 public nextTaskId = 1;\n', '    uint256 public totalReward;\n', '    \n', '    Task[] public tasks;\n', '    Task[] public completedTasks;\n', '    mapping(uint256 => uint) public indexOfTaskId; // Starting from 1\n', '    event TaskCreated(uint256 indexed taskId);\n', '    event TaskSolved(uint256 indexed taskId);\n', '    event TaskPayed(uint256 indexed taskId);\n', '\n', '    function TaskRegister(address _ec, address _token, address _prevVersion) public Upgradable(_prevVersion) {\n', '        ec = IEC(_ec);\n', '        token = ERC20(_token);\n', '    }\n', '\n', '    function upgrade(uint size) public onlyOwner {\n', '        require(upgradableState.isUpgrading);\n', '        require(upgradableState.prevVersion != 0);\n', '\n', '        // Migrate some vars\n', '        nextTaskId = TaskRegister(upgradableState.prevVersion).nextTaskId();\n', '        totalReward = TaskRegister(upgradableState.prevVersion).totalReward();\n', '\n', '        uint index = tasks.length;\n', '        uint tasksCount = TaskRegister(upgradableState.prevVersion).tasksCount();\n', '\n', '        // Migrate tasks\n', '\n', '        for (uint i = index; i < index + size && i < tasksCount; i++) {\n', '            tasks.push(Task(TaskType.BITCOIN_ADDRESS_PREFIX,0,0,0,bytes32(0),0,0,0,0));\n', '        }\n', '\n', '        for (uint j = index; j < index + size && j < tasksCount; j++) {\n', '            (\n', '                tasks[j].taskType,\n', '                tasks[j].taskId,\n', '                tasks[j].creator,\n', '                tasks[j].reward,\n', '                tasks[j].data,\n', '                ,//tasks[j].dataLength, \n', '                ,//tasks[j].requestPublicXPoint, \n', '                ,//tasks[j].requestPublicYPoint,\n', '                 //tasks[j].answerPrivateKey\n', '            ) = TaskRegister(upgradableState.prevVersion).tasks(j);\n', '            indexOfTaskId[tasks[j].taskId] = j + 1;\n', '        }\n', '\n', '        for (uint k = index; k < index + size && k < tasksCount; k++) {\n', '            (\n', '                ,//tasks[k].taskType,\n', '                ,//tasks[k].taskId,\n', '                ,//tasks[k].creator,\n', '                ,//tasks[k].reward,\n', '                ,//tasks[k].data,\n', '                tasks[k].dataLength, \n', '                tasks[k].requestPublicXPoint, \n', '                tasks[k].requestPublicYPoint,\n', '                tasks[k].answerPrivateKey\n', '            ) = TaskRegister(upgradableState.prevVersion).tasks(k);\n', '        }\n', '    }\n', '    \n', '    function endUpgrade() public {\n', '        super.endUpgrade();\n', '        \n', '        if (upgradableState.nextVersion != 0) {\n', '            token.transfer(upgradableState.nextVersion, token.balanceOf(this));\n', '        }\n', '    }\n', '\n', '    function tasksCount() public constant returns(uint) {\n', '        return tasks.length;\n', '    }\n', '\n', '    function completedTasksCount() public constant returns(uint) {\n', '        return completedTasks.length;\n', '    }\n', '\n', '    function payForTask(uint256 taskId, uint256 reward) public isLastestVersion {\n', '        require(reward > 0);\n', '        uint index = safeIndexOfTaskId(taskId);\n', '        token.transferFrom(tx.origin, this, reward);\n', '        tasks[index].reward += reward;\n', '        totalReward += reward;\n', '        TaskPayed(taskId);\n', '    }\n', '\n', '    function safeIndexOfTaskId(uint taskId) public constant returns(uint) {\n', '        uint index = indexOfTaskId[taskId];\n', '        require(index > 0);\n', '        return index - 1;\n', '    }\n', '    \n', '    function createBitcoinAddressPrefixTask(bytes prefix, uint256 reward, uint256 requestPublicXPoint, uint256 requestPublicYPoint) public isLastestVersion {\n', '        require(prefix.length > 5);\n', '        require(prefix[0] == "1");\n', '        require(prefix[1] != "1"); // Do not support multiple 1s yet\n', '        require(isValidBicoinAddressPrefix(prefix));\n', '        require(isValidPublicKey(requestPublicXPoint, requestPublicYPoint));\n', '        if (reward > 0) {\n', '            token.transferFrom(tx.origin, this, reward);\n', '        }\n', '\n', '        bytes32 data;\n', '        assembly {\n', '            data := mload(add(prefix, 32))\n', '        }\n', '        \n', '        Task memory task = Task({\n', '            taskType: TaskType.BITCOIN_ADDRESS_PREFIX,\n', '            taskId: nextTaskId,\n', '            creator: tx.origin,\n', '            reward: reward,\n', '            data: data,\n', '            dataLength: prefix.length,\n', '            requestPublicXPoint: requestPublicXPoint,\n', '            requestPublicYPoint: requestPublicYPoint,\n', '            answerPrivateKey: 0\n', '        });\n', '        tasks.push(task);\n', '        indexOfTaskId[nextTaskId] = tasks.length; // incremented to avoid 0 index\n', '        TaskCreated(nextTaskId);\n', '        nextTaskId++;\n', '    }\n', '    \n', '    function solveTask(uint taskId, uint256 answerPrivateKey) public isLastestVersion {\n', '        uint taskIndex = safeIndexOfTaskId(taskId);\n', '        Task storage task = tasks[taskIndex];\n', '\n', '        // Require private key to be part of address to prevent front-running attack\n', '        bytes32 answerPrivateKeyBytes = bytes32(answerPrivateKey);\n', '        bytes32 senderAddressBytes = bytes32(uint256(msg.sender) << 96);\n', '        for (uint i = 0; i < 16; i++) {\n', '            require(answerPrivateKeyBytes[i] == senderAddressBytes[i]);\n', '        }\n', '\n', '        if (task.taskType == TaskType.BITCOIN_ADDRESS_PREFIX) {\n', '            uint256 answerPublicXPoint;\n', '            uint256 answerPublicYPoint;\n', '            uint256 publicXPoint;\n', '            uint256 publicYPoint;\n', '            uint256 z;\n', '            (answerPublicXPoint, answerPublicYPoint) = ec.publicKey(answerPrivateKey);\n', '            (publicXPoint, publicYPoint, z) = ec._ecAdd(\n', '                task.requestPublicXPoint,\n', '                task.requestPublicYPoint,\n', '                1,\n', '                answerPublicXPoint,\n', '                answerPublicYPoint,\n', '                1\n', '            );\n', '\n', '            uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n', '            z = ec._inverse(z);\n', '            publicXPoint = mulmod(publicXPoint, z, m);\n', '            publicYPoint = mulmod(publicYPoint, z, m);\n', '            require(isValidPublicKey(publicXPoint, publicYPoint));\n', '            \n', '            bytes32 btcAddress = createBtcAddress(publicXPoint, publicYPoint);\n', '            uint prefixLength = lengthOfCommonPrefix3232(btcAddress, task.data);\n', '            require(prefixLength == task.dataLength);\n', '            \n', '            task.answerPrivateKey = answerPrivateKey;\n', '        }\n', '\n', '        token.transfer(msg.sender, task.reward);\n', '        totalReward -= task.reward;\n', '\n', '        completeTask(taskId, taskIndex);\n', '        TaskSolved(taskId);\n', '    }\n', '\n', '    function completeTask(uint taskId, uint index) internal {\n', '        completedTasks.push(tasks[index]);\n', '        if (index < tasks.length - 1) { // if not latest\n', '            tasks[index] = tasks[tasks.length - 1];\n', '            indexOfTaskId[tasks[index].taskId] = index + 1;\n', '        }\n', '        tasks.length -= 1;\n', '        delete indexOfTaskId[taskId];\n', '    }\n', '\n', '    function recoverLost(ERC20Basic _token, address loser) public onlyOwner {\n', '        uint256 amount = _token.balanceOf(this);\n', '        if (_token == token) {\n', '            amount -= totalReward;\n', '        }\n', '        _token.transfer(loser, _token.balanceOf(this));\n', '    }\n', '\n', '}']
