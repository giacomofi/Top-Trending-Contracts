['pragma solidity ^0.4.21;\n', '\n', '\n', 'library SafeMath {\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\tassert(a <= c);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(a >= b);\n', '\t\treturn a - b;\n', '\t}\n', '}\n', '\n', '\n', 'contract AuctusToken {\n', '\tfunction transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', '\n', 'contract AuctusPreSale {\n', '\tfunction getTokenAmount(address who) constant returns (uint256);\n', '}\n', '\n', '\n', 'contract ContractReceiver {\n', '\tfunction tokenFallback(address from, uint256 value, bytes data) public;\n', '}\n', '\n', '\n', 'contract AuctusPreSaleDistribution is ContractReceiver {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public auctusTokenAddress = 0xc12d099be31567add4e4e4d0D45691C3F58f5663;\n', '\taddress public auctusPreSaleAddress = 0x84D45E60f7036F0DE7dF8ed68E1Ee50471B963BA;\n', '\tuint256 public escrowedTokens;\n', '\taddress public owner;\n', '\tmapping(address => bool) public redeemed;\n', '\n', '\tevent Escrow(address indexed from, uint256 value);\n', '\tevent Redeem(address indexed to, uint256 value);\n', '\n', '\tfunction AuctusPreSaleDistribution() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(owner == msg.sender);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) onlyOwner public {\n', '\t\trequire(newOwner != address(0));\n', '\t\towner = newOwner;\n', '\t}\n', '\n', '\tfunction tokenFallback(address from, uint256 value, bytes) public {\n', '\t\trequire(msg.sender == auctusTokenAddress);\n', '\t\tescrowedTokens = escrowedTokens.add(value);\n', '\t\temit Escrow(from, value);\n', '\t}\n', '\n', '\tfunction redeemMany(address[] _addresses) onlyOwner public {\n', '\t\tfor (uint256 i = 0; i < _addresses.length; i++) {\n', '\t\t\tredeemPreSale(_addresses[i]);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction redeemPreSale(address _address) public returns (bool) {\n', '\t\tif (!redeemed[_address]) {\n', '\t\t\tuint256 value = AuctusPreSale(auctusPreSaleAddress).getTokenAmount(_address);\n', '\t\t\tif (value > 0) {\n', '\t\t\t\tredeemed[_address] = true;\n', '\t\t\t\tescrowedTokens = escrowedTokens.sub(value);\n', '\t\t\t\tassert(AuctusToken(auctusTokenAddress).transfer(_address, value));\n', '\t\t\t\temit Redeem(_address, value);\n', '\t\t\t\treturn true;\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn false;\n', '\t}\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '\n', 'library SafeMath {\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\tassert(a <= c);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(a >= b);\n', '\t\treturn a - b;\n', '\t}\n', '}\n', '\n', '\n', 'contract AuctusToken {\n', '\tfunction transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', '\n', 'contract AuctusPreSale {\n', '\tfunction getTokenAmount(address who) constant returns (uint256);\n', '}\n', '\n', '\n', 'contract ContractReceiver {\n', '\tfunction tokenFallback(address from, uint256 value, bytes data) public;\n', '}\n', '\n', '\n', 'contract AuctusPreSaleDistribution is ContractReceiver {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public auctusTokenAddress = 0xc12d099be31567add4e4e4d0D45691C3F58f5663;\n', '\taddress public auctusPreSaleAddress = 0x84D45E60f7036F0DE7dF8ed68E1Ee50471B963BA;\n', '\tuint256 public escrowedTokens;\n', '\taddress public owner;\n', '\tmapping(address => bool) public redeemed;\n', '\n', '\tevent Escrow(address indexed from, uint256 value);\n', '\tevent Redeem(address indexed to, uint256 value);\n', '\n', '\tfunction AuctusPreSaleDistribution() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(owner == msg.sender);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) onlyOwner public {\n', '\t\trequire(newOwner != address(0));\n', '\t\towner = newOwner;\n', '\t}\n', '\n', '\tfunction tokenFallback(address from, uint256 value, bytes) public {\n', '\t\trequire(msg.sender == auctusTokenAddress);\n', '\t\tescrowedTokens = escrowedTokens.add(value);\n', '\t\temit Escrow(from, value);\n', '\t}\n', '\n', '\tfunction redeemMany(address[] _addresses) onlyOwner public {\n', '\t\tfor (uint256 i = 0; i < _addresses.length; i++) {\n', '\t\t\tredeemPreSale(_addresses[i]);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction redeemPreSale(address _address) public returns (bool) {\n', '\t\tif (!redeemed[_address]) {\n', '\t\t\tuint256 value = AuctusPreSale(auctusPreSaleAddress).getTokenAmount(_address);\n', '\t\t\tif (value > 0) {\n', '\t\t\t\tredeemed[_address] = true;\n', '\t\t\t\tescrowedTokens = escrowedTokens.sub(value);\n', '\t\t\t\tassert(AuctusToken(auctusTokenAddress).transfer(_address, value));\n', '\t\t\t\temit Redeem(_address, value);\n', '\t\t\t\treturn true;\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn false;\n', '\t}\n', '}']
