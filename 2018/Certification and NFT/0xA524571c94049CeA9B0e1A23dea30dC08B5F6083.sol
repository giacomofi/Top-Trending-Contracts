['pragma solidity ^0.4.13;\n', '\n', 'contract OracleInterface {\n', '    struct PriceData {\n', '        uint ARTTokenPrice;\n', '        uint blockHeight;\n', '    }\n', '\n', '    mapping(uint => PriceData) public historicPricing;\n', '    uint public index;\n', '    address public owner;\n', '    uint8 public decimals;\n', '\n', '    function setPrice(uint price) public returns (uint _index) {}\n', '\n', '    function getPrice() public view returns (uint price, uint _index, uint blockHeight) {}\n', '\n', '    function getHistoricalPrice(uint _index) public view returns (uint price, uint blockHeight) {}\n', '\n', '    event Updated(uint indexed price, uint indexed index);\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20Interface is ERC20Basic {\n', '    uint8 public decimals;\n', '}\n', '\n', 'contract HasNoTokens {\n', '\n', ' /**\n', '  * @dev Reject all ERC223 compatible tokens\n', '  * @param from_ address The address that is transferring the tokens\n', '  * @param value_ uint256 the amount of the specified token\n', '  * @param data_ Bytes The data passed from the caller.\n', '  */\n', '  function tokenFallback(address from_, uint256 value_, bytes data_) external {\n', '    from_;\n', '    value_;\n', '    data_;\n', '    revert();\n', '  }\n', '\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  constructor() public payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    owner.transfer(address(this).balance);\n', '  }\n', '}\n', '\n', 'contract DutchAuction is Ownable, HasNoEther, HasNoTokens {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /// @notice Auction Data\n', '    uint public min_shares_to_sell;\n', '    uint public max_shares_to_sell;\n', '    uint public min_share_price;\n', '    uint public available_shares;\n', '\n', '    bool private fundraise_defined;\n', '    uint public fundraise_max;\n', '\n', '    /// @notice Auction status\n', '    state public status = state.pending;\n', '    enum state { pending, active, ended, decrypted, success, failure }\n', '\n', '    /// @notice Events\n', '    event Started(uint block_number);\n', '    event BidAdded(uint index);\n', '    event Ended(uint block_number);\n', '    event BidDecrypted(uint index, bool it_will_process);\n', '    event FundraiseDefined(uint min_share_price, uint max);\n', '    event BidBurned(uint index);\n', '    event Decrypted(uint blocknumber, uint bids_decrypted, uint bids_burned);\n', '    event Computed(uint index, uint share_price, uint shares_count);\n', '    event Assigned(uint index, uint shares, uint executed_amout, uint refunded);\n', '    event Refunded(uint index, uint refunded);\n', '    event Success(uint raised, uint share_price, uint delivered_shares);\n', '    event Failure(uint raised, uint share_price);\n', '\n', '    event Execution(address destination,uint value,bytes data);\n', '    event ExecutionFailure(address destination,uint value,bytes data);\n', '\n', '    /// @notice Token assignment data\n', '    uint public final_share_price;\n', '    uint public computed_fundraise;\n', '    uint public final_fundraise;\n', '    uint public computed_shares_sold;\n', '    uint public final_shares_sold;\n', '    uint public winner_bids;\n', '    uint public assigned_bids;\n', '    uint public assigned_shares;\n', '\n', '    /// @notice Bidding data\n', '    struct BidData {\n', '        uint origin_index;\n', '        uint bid_id;\n', '        address investor_address;\n', '        uint share_price;\n', '        uint shares_count;\n', '        uint transfer_valuation;\n', '        uint transfer_token;\n', '        uint asigned_shares_count;\n', '        uint executed_amount;\n', '        bool closed;\n', '    }\n', '    uint public bids_sorted_count;\n', '    uint public bids_sorted_refunded;\n', '    mapping (uint => BidData) public bids_sorted; //Is sorted\n', '\n', '    uint public bids_burned_count;\n', '    mapping (uint => uint) public bids_burned;\n', '\n', '    uint public bids_ignored_count;\n', '    uint public bids_ignored_refunded;\n', '    mapping (uint => BidData) public bids_ignored;\n', '\n', '\n', '    uint public bids_decrypted_count;\n', '    mapping (uint => uint) public bids_decrypted;\n', '    uint private bids_reset_count;\n', '\n', '    struct Bid {\n', '        // https://ethereum.stackexchange.com/questions/3184/what-is-the-cheapest-hash-function-available-in-solidity#3200\n', '        bytes32 bid_hash;\n', '        uint art_price;\n', '        uint art_price_index;\n', '        bool exist;\n', '        bool is_decrypted;\n', '        bool is_burned;\n', '        bool will_compute;\n', '    }\n', '    uint public bids_count;\n', '    mapping (uint => Bid) public bids;\n', '\n', '    uint public bids_computed_cursor;\n', '\n', '    uint public shares_holders_count;\n', '    mapping (uint => address) public shares_holders;\n', '    mapping (address => uint) public shares_holders_balance;\n', '\n', '    /// @notice External dependencies\n', '\n', '    OracleInterface oracle;\n', '    uint public oracle_price_decimals_factor;\n', '    ERC20Interface art_token_contract;\n', '    uint public decimal_precission_difference_factor;\n', '\n', '    /// @notice Set up the dutch auction\n', '    /// @param _min_shares_to_sell The minimum amount of asset shares to be sold\n', '    /// @param _max_shares_to_sell The maximum amount of asset shares to be sold\n', '    /// @param _available_shares The total share amount the asset will be divided into\n', '    /// @param _oracle Address of the ART/USD price oracle contract\n', '    /// @param _art_token_contract Address of the ART token contract\n', '    constructor(\n', '        uint _min_shares_to_sell,\n', '        uint _max_shares_to_sell,\n', '        uint _available_shares,\n', '        address _oracle,\n', '        address _art_token_contract\n', '    ) public {\n', '        require(_max_shares_to_sell > 0);\n', '        require(_max_shares_to_sell >= _min_shares_to_sell);\n', '        require(_available_shares >= _max_shares_to_sell);\n', '        require(_oracle != address(0x0));\n', '        owner = msg.sender;\n', '        min_shares_to_sell = _min_shares_to_sell;\n', '        max_shares_to_sell = _max_shares_to_sell;\n', '        available_shares = _available_shares;\n', '        oracle = OracleInterface(_oracle);\n', '        uint256 oracle_decimals = uint256(oracle.decimals());\n', '        oracle_price_decimals_factor = 10**oracle_decimals;\n', '        art_token_contract = ERC20Interface(_art_token_contract);\n', '        uint256 art_token_decimals = uint256(art_token_contract.decimals());\n', '        decimal_precission_difference_factor = 10**(art_token_decimals.sub(oracle_decimals));\n', '    }\n', '\n', '    /// @notice Allows configuration of the final parameters needed for\n', '    /// auction end state calculation. This is only allowed once the auction\n', '    /// has closed and no more bids can enter\n', '    /// @param _min_share_price Minimum price accepted for individual asset shares\n', '    /// @param _fundraise_max Maximum cap for fundraised capital\n', '    function setFundraiseLimits(uint _min_share_price, uint _fundraise_max) public onlyOwner{\n', '        require(!fundraise_defined);\n', '        require(_min_share_price > 0);\n', '        require(_fundraise_max > 0);\n', '        require(status == state.ended);\n', '        fundraise_max = _fundraise_max;\n', '        min_share_price = _min_share_price;\n', '        emit FundraiseDefined(min_share_price,fundraise_max);\n', '        fundraise_defined = true;\n', '    }\n', '\n', '    /// @notice Starts the auction\n', '    function startAuction() public onlyOwner{\n', '        require(status == state.pending);\n', '        status = state.active;\n', '        emit Started(block.number);\n', '    }\n', '\n', '    /// @notice Ends the auction, preventing new bids from entering\n', '    function endAuction() public onlyOwner{\n', '        require(status == state.active);\n', '        status = state.ended;\n', '        emit Ended(block.number);\n', '    }\n', '\n', '    /// @notice Append an encrypted bid to the auction. This allows the contract\n', '    /// to keep a count on how many bids it has, while staying ignorant of the \n', '    /// bid contents.\n', '    function appendEncryptedBid(bytes32 _bid_hash, uint price_index) public onlyOwner returns (uint index){\n', '        require(status == state.active);\n', '        uint art_price;\n', '        uint art_price_blockHeight;\n', '        (art_price, art_price_blockHeight) = oracle.getHistoricalPrice(price_index);\n', '        bids[bids_count] = Bid(_bid_hash, art_price, price_index, true, false, false, false);\n', '        index = bids_count;\n', '        emit BidAdded(bids_count++);\n', '    }\n', '\n', '    /// @notice Helper function for calculating a bid&#39;s hash.\n', '    function getBidHash(uint nonce, uint bid_id, address investor_address, uint share_price, uint shares_count) public pure returns(bytes32) {\n', '        return keccak256(abi.encodePacked(nonce, bid_id, investor_address, share_price, shares_count));\n', '    }\n', '\n', '    /// @notice Allows the "burning" of a bid, for cases in which a bid was corrupted and can&#39;t be decrypted.\n', '    /// "Burnt" bids do not participate in the final calculations for auction participants\n', '    /// @param _index Indicates the index of the bid to be burnt\n', '    function burnBid(uint _index) public onlyOwner {\n', '        require(status == state.ended);\n', '        require(bids_sorted_count == 0);\n', '        require(bids[_index].exist == true);\n', '        require(bids[_index].is_decrypted == false);\n', '        require(bids[_index].is_burned == false);\n', '        \n', '        bids_burned[bids_burned_count] = _index;\n', '        bids_burned_count++;\n', '        \n', '        bids_decrypted[bids_decrypted_count] = _index;\n', '        bids_decrypted_count++;\n', '\n', '        bids[_index].is_burned = true;\n', '        emit BidBurned(_index);\n', '    }\n', '\n', '    /// @notice Appends the bid&#39;s data to the contract, for use in the final calculations\n', '    /// Once all bids are appended, the auction is locked and changes its state to "decrypted"\n', '    /// @dev Bids MUST be appended in order of asset valuation,\n', '    /// since the contract relies on off-chain sorting and checks if the order is correct\n', '    /// @param _nonce Bid parameter\n', '    /// @param _index Bid&#39;s index inside the contract\n', '    /// @param _bid_id Bid parameter\n', '    /// @param _investor_address Bid parameter - address of the bid&#39;s originator\n', '    /// @param _share_price Bid parameter - estimated value of the asset&#39;s share price\n', '    /// @param _shares_count Bid parameter - amount of shares bid for\n', '    /// @param _transfered_token Bid parameter - amount of ART tokens sent with the bid\n', '    function appendDecryptedBid(uint _nonce, uint _index, uint _bid_id, address _investor_address, uint _share_price, uint _shares_count, uint _transfered_token) onlyOwner public {\n', '        require(status == state.ended);\n', '        require(fundraise_defined);\n', '        require(bids[_index].exist == true);\n', '        require(bids[_index].is_decrypted == false);\n', '        require(bids[_index].is_burned == false);\n', '        require(_share_price > 0);\n', '        require(_shares_count > 0);\n', '        require(_transfered_token >= convert_valuation_to_art(_shares_count.mul(_share_price),bids[_index].art_price));\n', '        \n', '        if (bids_sorted_count > 0){\n', '            BidData memory previous_bid_data = bids_sorted[bids_sorted_count-1];\n', '            require(_share_price <= previous_bid_data.share_price);\n', '            if (_share_price == previous_bid_data.share_price){\n', '                require(_index > previous_bid_data.origin_index);\n', '            }\n', '        }\n', '        \n', '        require(\n', '            getBidHash(_nonce, _bid_id,_investor_address,_share_price,_shares_count) == bids[_index].bid_hash\n', '        );\n', '        \n', '        uint _transfer_amount = _share_price.mul(_shares_count);\n', '        \n', '        BidData memory bid_data = BidData(_index, _bid_id, _investor_address, _share_price, _shares_count, _transfer_amount, _transfered_token, 0, 0, false);\n', '        bids[_index].is_decrypted = true;\n', '        \n', '        if (_share_price >= min_share_price){\n', '            bids[_index].will_compute = true;\n', '            bids_sorted[bids_sorted_count] = bid_data;\n', '            bids_sorted_count++;\n', '            emit BidDecrypted(_index,true);\n', '        }else{\n', '            bids[_index].will_compute = false;\n', '            bids_ignored[bids_ignored_count] = bid_data;\n', '            bids_ignored_count++;\n', '            emit BidDecrypted(_index,false);\n', '        }\n', '        bids_decrypted[bids_decrypted_count] = _index;\n', '        bids_decrypted_count++;\n', '        if(bids_decrypted_count == bids_count){\n', '            emit Decrypted(block.number, bids_decrypted_count.sub(bids_burned_count), bids_burned_count);\n', '            status = state.decrypted;\n', '        }\n', '    }\n', '\n', '    /// @notice Allows appending multiple decrypted bids (in order) at once.\n', '    /// @dev Parameters are the same as appendDecryptedBid but in array format.\n', '    function appendDecryptedBids(uint[] _nonce, uint[] _index, uint[] _bid_id, address[] _investor_address, uint[] _share_price, uint[] _shares_count, uint[] _transfered_token) public onlyOwner {\n', '        require(_nonce.length == _index.length);\n', '        require(_index.length == _bid_id.length);\n', '        require(_bid_id.length == _investor_address.length);\n', '        require(_investor_address.length == _share_price.length);\n', '        require(_share_price.length == _shares_count.length);\n', '        require(_shares_count.length == _transfered_token.length);\n', '        require(bids_count.sub(bids_decrypted_count) > 0);\n', '        for (uint i = 0; i < _index.length; i++){\n', '            appendDecryptedBid(_nonce[i], _index[i], _bid_id[i], _investor_address[i], _share_price[i], _shares_count[i], _transfered_token[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice Allows resetting the entire bid decryption/appending process\n', '    /// in case a mistake was made and it is not possible to continue appending further bids.\n', '    function resetAppendDecryptedBids(uint _count) public onlyOwner{\n', '        require(status == state.ended);\n', '        require(bids_decrypted_count > 0);\n', '        require(_count > 0);\n', '        if (bids_reset_count == 0){\n', '            bids_reset_count = bids_decrypted_count;\n', '        }\n', '        uint count = _count;\n', '        if(bids_reset_count < count){\n', '            count = bids_reset_count;\n', '        }\n', '\n', '        do {\n', '            bids_reset_count--;\n', '            bids[bids_decrypted[bids_reset_count]].is_decrypted = false;\n', '            bids[bids_decrypted[bids_reset_count]].is_burned = false;\n', '            bids[bids_decrypted[bids_reset_count]].will_compute = false;\n', '            count--;\n', '        } while(count > 0);\n', '        \n', '        if (bids_reset_count == 0){\n', '            bids_sorted_count = 0;\n', '            bids_ignored_count = 0;\n', '            bids_decrypted_count = 0;\n', '            bids_burned_count = 0;\n', '        }\n', '    }\n', '\n', '    /// @notice Performs the computation of auction winners and losers.\n', '    /// Also, determines if the auction is successful or failed.\n', '    /// Bids which place the asset valuation below the minimum fundraise cap\n', '    /// as well as bids below the final valuation are marked as ignored or "loser" respectively\n', '    /// and do not count towards the process.\n', '    /// @dev Since this function is resource intensive, computation is done in batches\n', '    /// of `_count` bids, so as to not encounter an OutOfGas exception in the middle\n', '    /// of the process.\n', '    /// @param _count Amount of bids to be processed in this run.\n', '    function computeBids(uint _count) public onlyOwner{\n', '        require(status == state.decrypted);\n', '        require(_count > 0);\n', '        uint count = _count;\n', '        // No bids\n', '        if (bids_sorted_count == 0){\n', '            status = state.failure;\n', '            emit Failure(0, 0);\n', '            return;\n', '        }\n', '        //bids_computed_cursor: How many bid already processed\n', '        //bids_sorted_count: How many bids can compunte\n', '        require(bids_computed_cursor < bids_sorted_count);\n', '        \n', '        //bid: Auxiliary variable\n', '        BidData memory bid;\n', '\n', '        do{\n', '            //bid: Current bid to compute\n', '            bid = bids_sorted[bids_computed_cursor];\n', '            //if only one share of current bid leave us out of fundraise limitis, ignore the bid\n', '            //computed_shares_sold: Sumarize shares sold\n', '            if (bid.share_price.mul(computed_shares_sold).add(bid.share_price) > fundraise_max){\n', '                if(bids_computed_cursor > 0){\n', '                    bids_computed_cursor--;\n', '                }\n', '                bid = bids_sorted[bids_computed_cursor];\n', '                break;\n', '            }\n', '            //computed_shares_sold: Sumarize cumpued shares\n', '            computed_shares_sold = computed_shares_sold.add(bid.shares_count);\n', '            //computed_fundraise: Sumarize fundraise\n', '            computed_fundraise = bid.share_price.mul(computed_shares_sold);\n', '            emit Computed(bid.origin_index, bid.share_price, bid.shares_count);\n', '            //Next bid\n', '            bids_computed_cursor++;\n', '            count--;\n', '        }while(\n', '            count > 0 && //We have limite to compute\n', '            bids_computed_cursor < bids_sorted_count && //We have more bids to compute \n', '            (\n', '                computed_fundraise < fundraise_max && //Fundraise is more or equal to max\n', '                computed_shares_sold < max_shares_to_sell //Assigned shares are more or equal to max\n', '            )\n', '        );\n', '\n', '        if (\n', '            bids_computed_cursor == bids_sorted_count ||  //All bids computed\n', '            computed_fundraise >= fundraise_max ||//Fundraise is more or equal to max\n', '            computed_shares_sold >= max_shares_to_sell//Max shares raised\n', '        ){\n', '            \n', '            final_share_price = bid.share_price;\n', '            \n', '            //More than max shares\n', '            if(computed_shares_sold >= max_shares_to_sell){\n', '                computed_shares_sold = max_shares_to_sell;//Limit shares\n', '                computed_fundraise = final_share_price.mul(computed_shares_sold);\n', '                winner_bids = bids_computed_cursor;\n', '                status = state.success;\n', '                emit Success(computed_fundraise, final_share_price, computed_shares_sold);\n', '                return;            \n', '            }\n', '\n', '            //Max fundraise is raised\n', '            if(computed_fundraise.add(final_share_price.mul(1)) >= fundraise_max){//More than max fundraise\n', '                computed_fundraise = fundraise_max;//Limit fundraise\n', '                winner_bids = bids_computed_cursor;\n', '                status = state.success;\n', '                emit Success(computed_fundraise, final_share_price, computed_shares_sold);\n', '                return;\n', '            }\n', '            \n', '            //All bids computed\n', '            if (bids_computed_cursor == bids_sorted_count){\n', '                if (computed_shares_sold >= min_shares_to_sell){\n', '                    winner_bids = bids_computed_cursor;\n', '                    status = state.success;\n', '                    emit Success(computed_fundraise, final_share_price, computed_shares_sold);\n', '                    return;\n', '                }else{\n', '                    status = state.failure;\n', '                    emit Failure(computed_fundraise, final_share_price);\n', '                    return;\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Helper function that calculates the valuation of the asset\n', '    /// in terms of an ART token quantity.\n', '    function convert_valuation_to_art(uint _valuation, uint _art_price) view public returns(uint amount){\n', '        amount = ((\n', '                _valuation.mul(oracle_price_decimals_factor)\n', '            ).div(\n', '                _art_price\n', '            )).mul(decimal_precission_difference_factor);\n', '    }\n', '\n', '    /// @notice Performs the refund of the ignored bids ART tokens\n', '    /// @dev Since this function is resource intensive, computation is done in batches\n', '    /// of `_count` bids, so as to not encounter an OutOfGas exception in the middle\n', '    /// of the process.\n', '    /// @param _count Amount of bids to be processed in this run.\n', '    function refundIgnoredBids(uint _count) public onlyOwner{\n', '        require(status == state.success || status == state.failure);\n', '        uint count = _count;\n', '        if(bids_ignored_count < bids_ignored_refunded.add(count)){\n', '            count = bids_ignored_count.sub(bids_ignored_refunded);\n', '        }\n', '        require(count > 0);\n', '        uint cursor = bids_ignored_refunded;\n', '        bids_ignored_refunded = bids_ignored_refunded.add(count);\n', '        BidData storage bid;\n', '        while (count > 0) {\n', '            bid = bids_ignored[cursor];\n', '            if(bid.closed){\n', '                continue;\n', '            }\n', '            bid.closed = true;\n', '            art_token_contract.transfer(bid.investor_address, bid.transfer_token);\n', '            emit Refunded(bid.origin_index, bid.transfer_token);\n', '            cursor ++;\n', '            count --;\n', '        }\n', '    }\n', '\n', '    /// @notice Performs the refund of the "loser" bids ART tokens\n', '    /// @dev Since this function is resource intensive, computation is done in batches\n', '    /// of `_count` bids, so as to not encounter an OutOfGas exception in the middle\n', '    /// of the process.\n', '    /// @param _count Amount of bids to be processed in this run.\n', '    function refundLosersBids(uint _count) public onlyOwner{\n', '        require(status == state.success || status == state.failure);\n', '        uint count = _count;\n', '        if(bids_sorted_count.sub(winner_bids) < bids_sorted_refunded.add(count)){\n', '            count = bids_sorted_count.sub(winner_bids).sub(bids_sorted_refunded);\n', '        }\n', '        require(count > 0);\n', '        uint cursor = bids_sorted_refunded.add(winner_bids);\n', '        bids_sorted_refunded = bids_sorted_refunded.add(count);\n', '        BidData memory bid;\n', '        while (count > 0) {\n', '            bid = bids_sorted[cursor];\n', '            if(bid.closed){\n', '                continue;\n', '            }\n', '            bids_sorted[cursor].closed = true;\n', '            art_token_contract.transfer(bid.investor_address, bid.transfer_token);\n', '            emit Refunded(bid.origin_index, bid.transfer_token);\n', '            cursor ++;\n', '            count --;\n', '        }\n', '    }\n', '\n', '    /// @notice Calculates how many shares are assigned to a bid.\n', '    /// @param _shares_count Amount of shares bid for.\n', '    /// @param _transfer_valuation Unused parameter\n', '    /// @param _final_share_price Final share price calculated from all winning bids\n', '    /// @param _art_price Price of the ART token\n', '    /// @param transfer_token Amount of ART tokens transferred with the bid\n', '    function calculate_shares_and_return(uint _shares_count, uint _share_price, uint _transfer_valuation, uint _final_share_price, uint _art_price, uint transfer_token) view public \n', '        returns(\n', '            uint _shares_to_assign,\n', '            uint _executed_amount_valuation,\n', '            uint _return_amount\n', '        ){\n', '        if(assigned_shares.add(_shares_count) > max_shares_to_sell){\n', '            _shares_to_assign = max_shares_to_sell.sub(assigned_shares);\n', '        }else{\n', '            _shares_to_assign = _shares_count;\n', '        }\n', '        _executed_amount_valuation = _shares_to_assign.mul(_final_share_price);\n', '        if (final_fundraise.add(_executed_amount_valuation) > fundraise_max){\n', '            _executed_amount_valuation = fundraise_max.sub(final_fundraise);\n', '            _shares_to_assign = _executed_amount_valuation.div(_final_share_price);\n', '            _executed_amount_valuation = _shares_to_assign.mul(_final_share_price);\n', '        }\n', '        uint _executed_amount = convert_valuation_to_art(_executed_amount_valuation, _art_price);\n', '        _return_amount = transfer_token.sub(_executed_amount);\n', '    }\n', '\n', '\n', '    /// @notice Assign the asset share tokens to winner bid&#39;s authors\n', '    /// @dev Since this function is resource intensive, computation is done in batches\n', '    /// of `_count` bids, so as to not encounter an OutOfGas exception in the middle\n', '    /// of the process.\n', '    /// @param _count Amount of bids to be processed in this run.\n', '    function assignShareTokens(uint _count) public onlyOwner{\n', '        require(status == state.success);\n', '        uint count = _count;\n', '        if(winner_bids < assigned_bids.add(count)){\n', '            count = winner_bids.sub(assigned_bids);\n', '        }\n', '        require(count > 0);\n', '        uint cursor = assigned_bids;\n', '        assigned_bids = assigned_bids.add(count);\n', '        BidData storage bid;\n', '\n', '        while (count > 0) {\n', '            bid = bids_sorted[cursor];\n', '            uint _shares_to_assign;\n', '            uint _executed_amount_valuation;\n', '            uint _return_amount;\n', '            (_shares_to_assign, _executed_amount_valuation, _return_amount) = calculate_shares_and_return(\n', '                bid.shares_count,\n', '                bid.share_price,\n', '                bid.transfer_valuation,\n', '                final_share_price,\n', '                bids[bid.origin_index].art_price,\n', '                bid.transfer_token\n', '            );\n', '            bid.executed_amount = _executed_amount_valuation;\n', '            bid.asigned_shares_count = _shares_to_assign;\n', '            assigned_shares = assigned_shares.add(_shares_to_assign);\n', '            final_fundraise = final_fundraise.add(_executed_amount_valuation);\n', '            final_shares_sold = final_shares_sold.add(_shares_to_assign);\n', '            if(_return_amount > 0){\n', '                art_token_contract.transfer(bid.investor_address, _return_amount);\n', '            }\n', '            bid.closed = true;\n', '            if (shares_holders_balance[bid.investor_address] == 0){\n', '                shares_holders[shares_holders_count++] = bid.investor_address;\n', '            }\n', '            emit Assigned(bid.origin_index,_shares_to_assign, _executed_amount_valuation, _return_amount);\n', '            shares_holders_balance[bid.investor_address] = shares_holders_balance[bid.investor_address].add(_shares_to_assign);\n', '            cursor ++;\n', '            count --;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Return share balance of sender\n', '    * @return uint256 share_balance\n', '    */\n', '    function getShareBalance() view public returns (uint256 share_balance){\n', '        require(status == state.success);\n', '        require(winner_bids == assigned_bids);\n', '        share_balance = shares_holders_balance[msg.sender];\n', '    }\n', '\n', '    /**\n', '    * @dev Reclaim all (Except ART) ERC20Basic compatible tokens\n', '    * @param token ERC20Basic The address of the token contract\n', '    */\n', '    function reclaimToken(ERC20Basic token) external onlyOwner {\n', '        require(token != art_token_contract);\n', '        uint256 balance = token.balanceOf(this);\n', '        token.transfer(owner, balance);\n', '    }\n', '\n', '    function reclaim_art_token() external onlyOwner {\n', '        require(status == state.success || status == state.failure);\n', '        require(winner_bids == assigned_bids);\n', '        uint256 balance = art_token_contract.balanceOf(this);\n', '        art_token_contract.transfer(owner, balance); \n', '    }\n', '\n', '    /// @notice Proxy function which allows sending of transactions\n', '    /// in behalf of the contract\n', '    function executeTransaction(\n', '        address destination,\n', '        uint value,\n', '        bytes data\n', '    )\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (destination.call.value(value)(data))\n', '            emit Execution(destination,value,data);\n', '        else\n', '            emit ExecutionFailure(destination,value,data);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']