['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title Owned contract with safe ownership pass.\n', ' *\n', ' * Note: all the non constant functions return false instead of throwing in case if state change\n', ' * didn&#39;t happen yet.\n', ' */\n', 'contract Owned {\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public contractOwner;\n', '\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public pendingContractOwner;\n', '\n', '    function Owned() {\n', '        contractOwner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner check modifier\n', '    */\n', '    modifier onlyContractOwner() {\n', '        if (contractOwner == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Destroy contract and scrub a data\n', '     * @notice Only owner can call it\n', '     */\n', '    function destroy() onlyContractOwner {\n', '        suicide(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Prepares ownership pass.\n', '     *\n', '     * Can only be called by current owner.\n', '     *\n', '     * @param _to address of the next owner. 0x0 is not allowed.\n', '     *\n', '     * @return success.\n', '     */\n', '    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\n', '        if (_to  == 0x0) {\n', '            return false;\n', '        }\n', '\n', '        pendingContractOwner = _to;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Finalize ownership pass.\n', '     *\n', '     * Can only be called by pending owner.\n', '     *\n', '     * @return success.\n', '     */\n', '    function claimContractOwnership() returns(bool) {\n', '        if (pendingContractOwner != msg.sender) {\n', '            return false;\n', '        }\n', '\n', '        contractOwner = pendingContractOwner;\n', '        delete pendingContractOwner;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '    string public symbol;\n', '\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', '\n', '\n', 'contract ATxProxy is ERC20 {\n', '    \n', '    bytes32 public smbl;\n', '    address public platform;\n', '\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __approve(address _spender, uint _value, address _sender) public returns (bool);\n', '    function getLatestVersion() public returns (address);\n', '    function init(address _bmcPlatform, string _symbol, string _name) public;\n', '    function proposeUpgrade(address _newVersion) public;\n', '}\n', '\n', '/// @title Provides possibility manage holders? country limits and limits for holders.\n', 'contract DataControllerInterface {\n', '\n', '    /// @notice Checks user is holder.\n', '    /// @param _address - checking address.\n', '    /// @return `true` if _address is registered holder, `false` otherwise.\n', '    function isHolderAddress(address _address) public view returns (bool);\n', '\n', '    function allowance(address _user) public view returns (uint);\n', '\n', '    function changeAllowance(address _holder, uint _value) public returns (uint);\n', '}\n', '/// @title ServiceController\n', '///\n', '/// Base implementation\n', '/// Serves for managing service instances\n', 'contract ServiceControllerInterface {\n', '\n', '    /// @notice Check target address is service\n', '    /// @param _address target address\n', '    /// @return `true` when an address is a service, `false` otherwise\n', '    function isService(address _address) public view returns (bool);\n', '}\n', '\n', '\n', '\n', 'contract ATxAssetInterface {\n', '\n', '    DataControllerInterface public dataController;\n', '    ServiceControllerInterface public serviceController;\n', '\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __approve(address _spender, uint _value, address _sender) public returns (bool);\n', '    function __process(bytes /*_data*/, address /*_sender*/) payable public {\n', '        revert();\n', '    }\n', '}\n', '\n', 'contract AssetProxy is ERC20 {\n', '    \n', '    bytes32 public smbl;\n', '    address public platform;\n', '\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __approve(address _spender, uint _value, address _sender) public returns (bool);\n', '    function getLatestVersion() public returns (address);\n', '    function init(address _bmcPlatform, string _symbol, string _name) public;\n', '    function proposeUpgrade(address _newVersion) public;\n', '}\n', '\n', '\n', 'contract BasicAsset is ATxAssetInterface {\n', '\n', '    // Assigned asset proxy contract, immutable.\n', '    address public proxy;\n', '\n', '    /**\n', '     * Only assigned proxy is allowed to call.\n', '     */\n', '    modifier onlyProxy() {\n', '        if (proxy == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Sets asset proxy address.\n', '     *\n', '     * Can be set only once.\n', '     *\n', '     * @param _proxy asset proxy contract address.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function init(address _proxy) public returns (bool) {\n', '        if (address(proxy) != 0x0) {\n', '            return false;\n', '        }\n', '        proxy = _proxy;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Passes execution into virtual function.\n', '     *\n', '     * Can only be called by assigned asset proxy.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public onlyProxy returns (bool) {\n', '        return _transferWithReference(_to, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Passes execution into virtual function.\n', '     *\n', '     * Can only be called by assigned asset proxy.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public onlyProxy returns (bool) {\n', '        return _transferFromWithReference(_from, _to, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Passes execution into virtual function.\n', '     *\n', '     * Can only be called by assigned asset proxy.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function __approve(address _spender, uint _value, address _sender) public onlyProxy returns (bool) {\n', '        return _approve(_spender, _value, _sender);\n', '    }\n', '\n', '    /**\n', '     * Calls back without modifications.\n', '     *\n', '     * @return success.\n', '     * @dev function is virtual, and meant to be overridden.\n', '     */\n', '    function _transferWithReference(address _to, uint _value, string _reference, address _sender) internal returns (bool) {\n', '        return AssetProxy(proxy).__transferWithReference(_to, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Calls back without modifications.\n', '     *\n', '     * @return success.\n', '     * @dev function is virtual, and meant to be overridden.\n', '     */\n', '    function _transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) internal returns (bool) {\n', '        return AssetProxy(proxy).__transferFromWithReference(_from, _to, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Calls back without modifications.\n', '     *\n', '     * @return success.\n', '     * @dev function is virtual, and meant to be overridden.\n', '     */\n', '    function _approve(address _spender, uint _value, address _sender) internal returns (bool) {\n', '        return AssetProxy(proxy).__approve(_spender, _value, _sender);\n', '    }\n', '}\n', '\n', '\n', '/// @title ServiceAllowance.\n', '///\n', '/// Provides a way to delegate operation allowance decision to a service contract\n', 'contract ServiceAllowance {\n', '    function isTransferAllowed(address _from, address _to, address _sender, address _token, uint _value) public view returns (bool);\n', '}\n', '\n', 'contract ERC20Interface {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '    string public symbol;\n', '\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', '\n', '/**\n', ' * @title Generic owned destroyable contract\n', ' */\n', 'contract Object is Owned {\n', '    /**\n', '    *  Common result code. Means everything is fine.\n', '    */\n', '    uint constant OK = 1;\n', '    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\n', '\n', '    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\n', '        for(uint i=0;i<tokens.length;i++) {\n', '            address token = tokens[i];\n', '            uint balance = ERC20Interface(token).balanceOf(this);\n', '            if(balance != 0)\n', '                ERC20Interface(token).transfer(_to,balance);\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    function checkOnlyContractOwner() internal constant returns(uint) {\n', '        if (contractOwner == msg.sender) {\n', '            return OK;\n', '        }\n', '\n', '        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\n', '    }\n', '}\n', '\n', 'contract GroupsAccessManagerEmitter {\n', '\n', '    event UserCreated(address user);\n', '    event UserDeleted(address user);\n', '    event GroupCreated(bytes32 groupName);\n', '    event GroupActivated(bytes32 groupName);\n', '    event GroupDeactivated(bytes32 groupName);\n', '    event UserToGroupAdded(address user, bytes32 groupName);\n', '    event UserFromGroupRemoved(address user, bytes32 groupName);\n', '}\n', '\n', '\n', '/// @title Group Access Manager\n', '///\n', '/// Base implementation\n', '/// This contract serves as group manager\n', 'contract GroupsAccessManager is Object, GroupsAccessManagerEmitter {\n', '\n', '    uint constant USER_MANAGER_SCOPE = 111000;\n', '    uint constant USER_MANAGER_MEMBER_ALREADY_EXIST = USER_MANAGER_SCOPE + 1;\n', '    uint constant USER_MANAGER_GROUP_ALREADY_EXIST = USER_MANAGER_SCOPE + 2;\n', '    uint constant USER_MANAGER_OBJECT_ALREADY_SECURED = USER_MANAGER_SCOPE + 3;\n', '    uint constant USER_MANAGER_CONFIRMATION_HAS_COMPLETED = USER_MANAGER_SCOPE + 4;\n', '    uint constant USER_MANAGER_USER_HAS_CONFIRMED = USER_MANAGER_SCOPE + 5;\n', '    uint constant USER_MANAGER_NOT_ENOUGH_GAS = USER_MANAGER_SCOPE + 6;\n', '    uint constant USER_MANAGER_INVALID_INVOCATION = USER_MANAGER_SCOPE + 7;\n', '    uint constant USER_MANAGER_DONE = USER_MANAGER_SCOPE + 11;\n', '    uint constant USER_MANAGER_CANCELLED = USER_MANAGER_SCOPE + 12;\n', '\n', '    using SafeMath for uint;\n', '\n', '    struct Member {\n', '        address addr;\n', '        uint groupsCount;\n', '        mapping(bytes32 => uint) groupName2index;\n', '        mapping(uint => uint) index2globalIndex;\n', '    }\n', '\n', '    struct Group {\n', '        bytes32 name;\n', '        uint priority;\n', '        uint membersCount;\n', '        mapping(address => uint) memberAddress2index;\n', '        mapping(uint => uint) index2globalIndex;\n', '    }\n', '\n', '    uint public membersCount;\n', '    mapping(uint => address) index2memberAddress;\n', '    mapping(address => uint) memberAddress2index;\n', '    mapping(address => Member) address2member;\n', '\n', '    uint public groupsCount;\n', '    mapping(uint => bytes32) index2groupName;\n', '    mapping(bytes32 => uint) groupName2index;\n', '    mapping(bytes32 => Group) groupName2group;\n', '    mapping(bytes32 => bool) public groupsBlocked; // if groupName => true, then couldn&#39;t be used for confirmation\n', '\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    /// @notice Register user\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _user user address\n', '    ///\n', '    /// @return code\n', '    function registerUser(address _user) external onlyContractOwner returns (uint) {\n', '        require(_user != 0x0);\n', '\n', '        if (isRegisteredUser(_user)) {\n', '            return USER_MANAGER_MEMBER_ALREADY_EXIST;\n', '        }\n', '\n', '        uint _membersCount = membersCount.add(1);\n', '        membersCount = _membersCount;\n', '        memberAddress2index[_user] = _membersCount;\n', '        index2memberAddress[_membersCount] = _user;\n', '        address2member[_user] = Member(_user, 0);\n', '\n', '        UserCreated(_user);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Discard user registration\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _user user address\n', '    ///\n', '    /// @return code\n', '    function unregisterUser(address _user) external onlyContractOwner returns (uint) {\n', '        require(_user != 0x0);\n', '\n', '        uint _memberIndex = memberAddress2index[_user];\n', '        if (_memberIndex == 0 || address2member[_user].groupsCount != 0) {\n', '            return USER_MANAGER_INVALID_INVOCATION;\n', '        }\n', '\n', '        uint _membersCount = membersCount;\n', '        delete memberAddress2index[_user];\n', '        if (_memberIndex != _membersCount) {\n', '            address _lastUser = index2memberAddress[_membersCount];\n', '            index2memberAddress[_memberIndex] = _lastUser;\n', '            memberAddress2index[_lastUser] = _memberIndex;\n', '        }\n', '        delete address2member[_user];\n', '        delete index2memberAddress[_membersCount];\n', '        delete memberAddress2index[_user];\n', '        membersCount = _membersCount.sub(1);\n', '\n', '        UserDeleted(_user);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Create group\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _groupName group name\n', '    /// @param _priority group priority\n', '    ///\n', '    /// @return code\n', '    function createGroup(bytes32 _groupName, uint _priority) external onlyContractOwner returns (uint) {\n', '        require(_groupName != bytes32(0));\n', '\n', '        if (isGroupExists(_groupName)) {\n', '            return USER_MANAGER_GROUP_ALREADY_EXIST;\n', '        }\n', '\n', '        uint _groupsCount = groupsCount.add(1);\n', '        groupName2index[_groupName] = _groupsCount;\n', '        index2groupName[_groupsCount] = _groupName;\n', '        groupName2group[_groupName] = Group(_groupName, _priority, 0);\n', '        groupsCount = _groupsCount;\n', '\n', '        GroupCreated(_groupName);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Change group status\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _groupName group name\n', '    /// @param _blocked block status\n', '    ///\n', '    /// @return code\n', '    function changeGroupActiveStatus(bytes32 _groupName, bool _blocked) external onlyContractOwner returns (uint) {\n', '        require(isGroupExists(_groupName));\n', '        groupsBlocked[_groupName] = _blocked;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Add users in group\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _groupName group name\n', '    /// @param _users user array\n', '    ///\n', '    /// @return code\n', '    function addUsersToGroup(bytes32 _groupName, address[] _users) external onlyContractOwner returns (uint) {\n', '        require(isGroupExists(_groupName));\n', '\n', '        Group storage _group = groupName2group[_groupName];\n', '        uint _groupMembersCount = _group.membersCount;\n', '\n', '        for (uint _userIdx = 0; _userIdx < _users.length; ++_userIdx) {\n', '            address _user = _users[_userIdx];\n', '            uint _memberIndex = memberAddress2index[_user];\n', '            require(_memberIndex != 0);\n', '\n', '            if (_group.memberAddress2index[_user] != 0) {\n', '                continue;\n', '            }\n', '\n', '            _groupMembersCount = _groupMembersCount.add(1);\n', '            _group.memberAddress2index[_user] = _groupMembersCount;\n', '            _group.index2globalIndex[_groupMembersCount] = _memberIndex;\n', '\n', '            _addGroupToMember(_user, _groupName);\n', '\n', '            UserToGroupAdded(_user, _groupName);\n', '        }\n', '        _group.membersCount = _groupMembersCount;\n', '\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Remove users in group\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _groupName group name\n', '    /// @param _users user array\n', '    ///\n', '    /// @return code\n', '    function removeUsersFromGroup(bytes32 _groupName, address[] _users) external onlyContractOwner returns (uint) {\n', '        require(isGroupExists(_groupName));\n', '\n', '        Group storage _group = groupName2group[_groupName];\n', '        uint _groupMembersCount = _group.membersCount;\n', '\n', '        for (uint _userIdx = 0; _userIdx < _users.length; ++_userIdx) {\n', '            address _user = _users[_userIdx];\n', '            uint _memberIndex = memberAddress2index[_user];\n', '            uint _groupMemberIndex = _group.memberAddress2index[_user];\n', '\n', '            if (_memberIndex == 0 || _groupMemberIndex == 0) {\n', '                continue;\n', '            }\n', '\n', '            if (_groupMemberIndex != _groupMembersCount) {\n', '                uint _lastUserGlobalIndex = _group.index2globalIndex[_groupMembersCount];\n', '                address _lastUser = index2memberAddress[_lastUserGlobalIndex];\n', '                _group.index2globalIndex[_groupMemberIndex] = _lastUserGlobalIndex;\n', '                _group.memberAddress2index[_lastUser] = _groupMemberIndex;\n', '            }\n', '            delete _group.memberAddress2index[_user];\n', '            delete _group.index2globalIndex[_groupMembersCount];\n', '            _groupMembersCount = _groupMembersCount.sub(1);\n', '\n', '            _removeGroupFromMember(_user, _groupName);\n', '\n', '            UserFromGroupRemoved(_user, _groupName);\n', '        }\n', '        _group.membersCount = _groupMembersCount;\n', '\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Check is user registered\n', '    ///\n', '    /// @param _user user address\n', '    ///\n', '    /// @return status\n', '    function isRegisteredUser(address _user) public view returns (bool) {\n', '        return memberAddress2index[_user] != 0;\n', '    }\n', '\n', '    /// @notice Check is user in group\n', '    ///\n', '    /// @param _groupName user array\n', '    /// @param _user user array\n', '    ///\n', '    /// @return status\n', '    function isUserInGroup(bytes32 _groupName, address _user) public view returns (bool) {\n', '        return isRegisteredUser(_user) && address2member[_user].groupName2index[_groupName] != 0;\n', '    }\n', '\n', '    /// @notice Check is group exist\n', '    ///\n', '    /// @param _groupName group name\n', '    ///\n', '    /// @return status\n', '    function isGroupExists(bytes32 _groupName) public view returns (bool) {\n', '        return groupName2index[_groupName] != 0;\n', '    }\n', '\n', '    /// @notice Get current group names\n', '    ///\n', '    /// @return group names\n', '    function getGroups() public view returns (bytes32[] _groups) {\n', '        uint _groupsCount = groupsCount;\n', '        _groups = new bytes32[](_groupsCount);\n', '        for (uint _groupIdx = 0; _groupIdx < _groupsCount; ++_groupIdx) {\n', '            _groups[_groupIdx] = index2groupName[_groupIdx + 1];\n', '        }\n', '    }\n', '\n', '    // PRIVATE\n', '\n', '    function _removeGroupFromMember(address _user, bytes32 _groupName) private {\n', '        Member storage _member = address2member[_user];\n', '        uint _memberGroupsCount = _member.groupsCount;\n', '        uint _memberGroupIndex = _member.groupName2index[_groupName];\n', '        if (_memberGroupIndex != _memberGroupsCount) {\n', '            uint _lastGroupGlobalIndex = _member.index2globalIndex[_memberGroupsCount];\n', '            bytes32 _lastGroupName = index2groupName[_lastGroupGlobalIndex];\n', '            _member.index2globalIndex[_memberGroupIndex] = _lastGroupGlobalIndex;\n', '            _member.groupName2index[_lastGroupName] = _memberGroupIndex;\n', '        }\n', '        delete _member.groupName2index[_groupName];\n', '        delete _member.index2globalIndex[_memberGroupsCount];\n', '        _member.groupsCount = _memberGroupsCount.sub(1);\n', '    }\n', '\n', '    function _addGroupToMember(address _user, bytes32 _groupName) private {\n', '        Member storage _member = address2member[_user];\n', '        uint _memberGroupsCount = _member.groupsCount.add(1);\n', '        _member.groupName2index[_groupName] = _memberGroupsCount;\n', '        _member.index2globalIndex[_memberGroupsCount] = groupName2index[_groupName];\n', '        _member.groupsCount = _memberGroupsCount;\n', '    }\n', '}\n', '\n', 'contract PendingManagerEmitter {\n', '\n', '    event PolicyRuleAdded(bytes4 sig, address contractAddress, bytes32 key, bytes32 groupName, uint acceptLimit, uint declinesLimit);\n', '    event PolicyRuleRemoved(bytes4 sig, address contractAddress, bytes32 key, bytes32 groupName);\n', '\n', '    event ProtectionTxAdded(bytes32 key, bytes32 sig, uint blockNumber);\n', '    event ProtectionTxAccepted(bytes32 key, address indexed sender, bytes32 groupNameVoted);\n', '    event ProtectionTxDone(bytes32 key);\n', '    event ProtectionTxDeclined(bytes32 key, address indexed sender, bytes32 groupNameVoted);\n', '    event ProtectionTxCancelled(bytes32 key);\n', '    event ProtectionTxVoteRevoked(bytes32 key, address indexed sender, bytes32 groupNameVoted);\n', '    event TxDeleted(bytes32 key);\n', '\n', '    event Error(uint errorCode);\n', '\n', '    function _emitError(uint _errorCode) internal returns (uint) {\n', '        Error(_errorCode);\n', '        return _errorCode;\n', '    }\n', '}\n', '\n', 'contract PendingManagerInterface {\n', '\n', '    function signIn(address _contract) external returns (uint);\n', '    function signOut(address _contract) external returns (uint);\n', '\n', '    function addPolicyRule(\n', '        bytes4 _sig, \n', '        address _contract, \n', '        bytes32 _groupName, \n', '        uint _acceptLimit, \n', '        uint _declineLimit \n', '        ) \n', '        external returns (uint);\n', '        \n', '    function removePolicyRule(\n', '        bytes4 _sig, \n', '        address _contract, \n', '        bytes32 _groupName\n', '        ) \n', '        external returns (uint);\n', '\n', '    function addTx(bytes32 _key, bytes4 _sig, address _contract) external returns (uint);\n', '    function deleteTx(bytes32 _key) external returns (uint);\n', '\n', '    function accept(bytes32 _key, bytes32 _votingGroupName) external returns (uint);\n', '    function decline(bytes32 _key, bytes32 _votingGroupName) external returns (uint);\n', '    function revoke(bytes32 _key) external returns (uint);\n', '\n', '    function hasConfirmedRecord(bytes32 _key) public view returns (uint);\n', '    function getPolicyDetails(bytes4 _sig, address _contract) public view returns (\n', '        bytes32[] _groupNames,\n', '        uint[] _acceptLimits,\n', '        uint[] _declineLimits,\n', '        uint _totalAcceptedLimit,\n', '        uint _totalDeclinedLimit\n', '        );\n', '}\n', '\n', '/// @title PendingManager\n', '///\n', '/// Base implementation\n', '/// This contract serves as pending manager for transaction status\n', 'contract PendingManager is Object, PendingManagerEmitter, PendingManagerInterface {\n', '\n', '    uint constant NO_RECORDS_WERE_FOUND = 4;\n', '    uint constant PENDING_MANAGER_SCOPE = 4000;\n', '    uint constant PENDING_MANAGER_INVALID_INVOCATION = PENDING_MANAGER_SCOPE + 1;\n', '    uint constant PENDING_MANAGER_HASNT_VOTED = PENDING_MANAGER_SCOPE + 2;\n', '    uint constant PENDING_DUPLICATE_TX = PENDING_MANAGER_SCOPE + 3;\n', '    uint constant PENDING_MANAGER_CONFIRMED = PENDING_MANAGER_SCOPE + 4;\n', '    uint constant PENDING_MANAGER_REJECTED = PENDING_MANAGER_SCOPE + 5;\n', '    uint constant PENDING_MANAGER_IN_PROCESS = PENDING_MANAGER_SCOPE + 6;\n', '    uint constant PENDING_MANAGER_TX_DOESNT_EXIST = PENDING_MANAGER_SCOPE + 7;\n', '    uint constant PENDING_MANAGER_TX_WAS_DECLINED = PENDING_MANAGER_SCOPE + 8;\n', '    uint constant PENDING_MANAGER_TX_WAS_NOT_CONFIRMED = PENDING_MANAGER_SCOPE + 9;\n', '    uint constant PENDING_MANAGER_INSUFFICIENT_GAS = PENDING_MANAGER_SCOPE + 10;\n', '    uint constant PENDING_MANAGER_POLICY_NOT_FOUND = PENDING_MANAGER_SCOPE + 11;\n', '\n', '    using SafeMath for uint;\n', '\n', '    enum GuardState {\n', '        Decline, Confirmed, InProcess\n', '    }\n', '\n', '    struct Requirements {\n', '        bytes32 groupName;\n', '        uint acceptLimit;\n', '        uint declineLimit;\n', '    }\n', '\n', '    struct Policy {\n', '        uint groupsCount;\n', '        mapping(uint => Requirements) participatedGroups; // index => globalGroupIndex\n', '        mapping(bytes32 => uint) groupName2index; // groupName => localIndex\n', '        \n', '        uint totalAcceptedLimit;\n', '        uint totalDeclinedLimit;\n', '\n', '        uint securesCount;\n', '        mapping(uint => uint) index2txIndex;\n', '        mapping(uint => uint) txIndex2index;\n', '    }\n', '\n', '    struct Vote {\n', '        bytes32 groupName;\n', '        bool accepted;\n', '    }\n', '\n', '    struct Guard {\n', '        GuardState state;\n', '        uint basePolicyIndex;\n', '\n', '        uint alreadyAccepted;\n', '        uint alreadyDeclined;\n', '        \n', '        mapping(address => Vote) votes; // member address => vote\n', '        mapping(bytes32 => uint) acceptedCount; // groupName => how many from group has already accepted\n', '        mapping(bytes32 => uint) declinedCount; // groupName => how many from group has already declined\n', '    }\n', '\n', '    address public accessManager;\n', '\n', '    mapping(address => bool) public authorized;\n', '\n', '    uint public policiesCount;\n', '    mapping(uint => bytes32) index2PolicyId; // index => policy hash\n', '    mapping(bytes32 => uint) policyId2Index; // policy hash => index\n', '    mapping(bytes32 => Policy) policyId2policy; // policy hash => policy struct\n', '\n', '    uint public txCount;\n', '    mapping(uint => bytes32) index2txKey;\n', '    mapping(bytes32 => uint) txKey2index; // tx key => index\n', '    mapping(bytes32 => Guard) txKey2guard;\n', '\n', '    /// @dev Execution is allowed only by authorized contract\n', '    modifier onlyAuthorized {\n', '        if (authorized[msg.sender] || address(this) == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /// @dev Pending Manager&#39;s constructor\n', '    ///\n', '    /// @param _accessManager access manager&#39;s address\n', '    function PendingManager(address _accessManager) public {\n', '        require(_accessManager != 0x0);\n', '        accessManager = _accessManager;\n', '    }\n', '\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    /// @notice Update access manager address\n', '    ///\n', '    /// @param _accessManager access manager&#39;s address\n', '    function setAccessManager(address _accessManager) external onlyContractOwner returns (uint) {\n', '        require(_accessManager != 0x0);\n', '        accessManager = _accessManager;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Sign in contract\n', '    ///\n', '    /// @param _contract contract&#39;s address\n', '    function signIn(address _contract) external onlyContractOwner returns (uint) {\n', '        require(_contract != 0x0);\n', '        authorized[_contract] = true;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Sign out contract\n', '    ///\n', '    /// @param _contract contract&#39;s address\n', '    function signOut(address _contract) external onlyContractOwner returns (uint) {\n', '        require(_contract != 0x0);\n', '        delete authorized[_contract];\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Register new policy rule\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _sig target method signature\n', '    /// @param _contract target contract address\n', '    /// @param _groupName group&#39;s name\n', '    /// @param _acceptLimit accepted vote limit\n', '    /// @param _declineLimit decline vote limit\n', '    ///\n', '    /// @return code\n', '    function addPolicyRule(\n', '        bytes4 _sig,\n', '        address _contract,\n', '        bytes32 _groupName,\n', '        uint _acceptLimit,\n', '        uint _declineLimit\n', '    )\n', '    onlyContractOwner\n', '    external\n', '    returns (uint)\n', '    {\n', '        require(_sig != 0x0);\n', '        require(_contract != 0x0);\n', '        require(GroupsAccessManager(accessManager).isGroupExists(_groupName));\n', '        require(_acceptLimit != 0);\n', '        require(_declineLimit != 0);\n', '\n', '        bytes32 _policyHash = keccak256(_sig, _contract);\n', '        \n', '        if (policyId2Index[_policyHash] == 0) {\n', '            uint _policiesCount = policiesCount.add(1);\n', '            index2PolicyId[_policiesCount] = _policyHash;\n', '            policyId2Index[_policyHash] = _policiesCount;\n', '            policiesCount = _policiesCount;\n', '        }\n', '\n', '        Policy storage _policy = policyId2policy[_policyHash];\n', '        uint _policyGroupsCount = _policy.groupsCount;\n', '\n', '        if (_policy.groupName2index[_groupName] == 0) {\n', '            _policyGroupsCount += 1;\n', '            _policy.groupName2index[_groupName] = _policyGroupsCount;\n', '            _policy.participatedGroups[_policyGroupsCount].groupName = _groupName;\n', '            _policy.groupsCount = _policyGroupsCount;\n', '        }\n', '\n', '        uint _previousAcceptLimit = _policy.participatedGroups[_policyGroupsCount].acceptLimit;\n', '        uint _previousDeclineLimit = _policy.participatedGroups[_policyGroupsCount].declineLimit;\n', '        _policy.participatedGroups[_policyGroupsCount].acceptLimit = _acceptLimit;\n', '        _policy.participatedGroups[_policyGroupsCount].declineLimit = _declineLimit;\n', '        _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_previousAcceptLimit).add(_acceptLimit);\n', '        _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_previousDeclineLimit).add(_declineLimit);\n', '\n', '        PolicyRuleAdded(_sig, _contract, _policyHash, _groupName, _acceptLimit, _declineLimit);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Remove policy rule\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _groupName group&#39;s name\n', '    ///\n', '    /// @return code\n', '    function removePolicyRule(\n', '        bytes4 _sig,\n', '        address _contract,\n', '        bytes32 _groupName\n', '    ) \n', '    onlyContractOwner \n', '    external \n', '    returns (uint) \n', '    {\n', '        require(_sig != bytes4(0));\n', '        require(_contract != 0x0);\n', '        require(GroupsAccessManager(accessManager).isGroupExists(_groupName));\n', '\n', '        bytes32 _policyHash = keccak256(_sig, _contract);\n', '        Policy storage _policy = policyId2policy[_policyHash];\n', '        uint _policyGroupNameIndex = _policy.groupName2index[_groupName];\n', '\n', '        if (_policyGroupNameIndex == 0) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        uint _policyGroupsCount = _policy.groupsCount;\n', '        if (_policyGroupNameIndex != _policyGroupsCount) {\n', '            Requirements storage _requirements = _policy.participatedGroups[_policyGroupsCount];\n', '            _policy.participatedGroups[_policyGroupNameIndex] = _requirements;\n', '            _policy.groupName2index[_requirements.groupName] = _policyGroupNameIndex;\n', '        }\n', '\n', '        _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_policy.participatedGroups[_policyGroupsCount].acceptLimit);\n', '        _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_policy.participatedGroups[_policyGroupsCount].declineLimit);\n', '\n', '        delete _policy.groupName2index[_groupName];\n', '        delete _policy.participatedGroups[_policyGroupsCount];\n', '        _policy.groupsCount = _policyGroupsCount.sub(1);\n', '\n', '        PolicyRuleRemoved(_sig, _contract, _policyHash, _groupName);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Add transaction\n', '    ///\n', '    /// @param _key transaction id\n', '    ///\n', '    /// @return code\n', '    function addTx(bytes32 _key, bytes4 _sig, address _contract) external onlyAuthorized returns (uint) {\n', '        require(_key != bytes32(0));\n', '        require(_sig != bytes4(0));\n', '        require(_contract != 0x0);\n', '\n', '        bytes32 _policyHash = keccak256(_sig, _contract);\n', '        require(isPolicyExist(_policyHash));\n', '\n', '        if (isTxExist(_key)) {\n', '            return _emitError(PENDING_DUPLICATE_TX);\n', '        }\n', '\n', '        if (_policyHash == bytes32(0)) {\n', '            return _emitError(PENDING_MANAGER_POLICY_NOT_FOUND);\n', '        }\n', '\n', '        uint _index = txCount.add(1);\n', '        txCount = _index;\n', '        index2txKey[_index] = _key;\n', '        txKey2index[_key] = _index;\n', '\n', '        Guard storage _guard = txKey2guard[_key];\n', '        _guard.basePolicyIndex = policyId2Index[_policyHash];\n', '        _guard.state = GuardState.InProcess;\n', '\n', '        Policy storage _policy = policyId2policy[_policyHash];\n', '        uint _counter = _policy.securesCount.add(1);\n', '        _policy.securesCount = _counter;\n', '        _policy.index2txIndex[_counter] = _index;\n', '        _policy.txIndex2index[_index] = _counter;\n', '\n', '        ProtectionTxAdded(_key, _policyHash, block.number);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Delete transaction\n', '    /// @param _key transaction id\n', '    /// @return code\n', '    function deleteTx(bytes32 _key) external onlyContractOwner returns (uint) {\n', '        require(_key != bytes32(0));\n', '\n', '        if (!isTxExist(_key)) {\n', '            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n', '        }\n', '\n', '        uint _txsCount = txCount;\n', '        uint _txIndex = txKey2index[_key];\n', '        if (_txIndex != _txsCount) {\n', '            bytes32 _last = index2txKey[txCount];\n', '            index2txKey[_txIndex] = _last;\n', '            txKey2index[_last] = _txIndex;\n', '        }\n', '\n', '        delete txKey2index[_key];\n', '        delete index2txKey[_txsCount];\n', '        txCount = _txsCount.sub(1);\n', '\n', '        uint _basePolicyIndex = txKey2guard[_key].basePolicyIndex;\n', '        Policy storage _policy = policyId2policy[index2PolicyId[_basePolicyIndex]];\n', '        uint _counter = _policy.securesCount;\n', '        uint _policyTxIndex = _policy.txIndex2index[_txIndex];\n', '        if (_policyTxIndex != _counter) {\n', '            uint _movedTxIndex = _policy.index2txIndex[_counter];\n', '            _policy.index2txIndex[_policyTxIndex] = _movedTxIndex;\n', '            _policy.txIndex2index[_movedTxIndex] = _policyTxIndex;\n', '        }\n', '\n', '        delete _policy.index2txIndex[_counter];\n', '        delete _policy.txIndex2index[_txIndex];\n', '        _policy.securesCount = _counter.sub(1);\n', '\n', '        TxDeleted(_key);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Accept transaction\n', '    /// Can be called only by registered user in GroupsAccessManager\n', '    ///\n', '    /// @param _key transaction id\n', '    ///\n', '    /// @return code\n', '    function accept(bytes32 _key, bytes32 _votingGroupName) external returns (uint) {\n', '        if (!isTxExist(_key)) {\n', '            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n', '        }\n', '\n', '        if (!GroupsAccessManager(accessManager).isUserInGroup(_votingGroupName, msg.sender)) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        Guard storage _guard = txKey2guard[_key];\n', '        if (_guard.state != GuardState.InProcess) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        if (_guard.votes[msg.sender].groupName != bytes32(0) && _guard.votes[msg.sender].accepted) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        Policy storage _policy = policyId2policy[index2PolicyId[_guard.basePolicyIndex]];\n', '        uint _policyGroupIndex = _policy.groupName2index[_votingGroupName];\n', '        uint _groupAcceptedVotesCount = _guard.acceptedCount[_votingGroupName];\n', '        if (_groupAcceptedVotesCount == _policy.participatedGroups[_policyGroupIndex].acceptLimit) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        _guard.votes[msg.sender] = Vote(_votingGroupName, true);\n', '        _guard.acceptedCount[_votingGroupName] = _groupAcceptedVotesCount + 1;\n', '        uint _alreadyAcceptedCount = _guard.alreadyAccepted + 1;\n', '        _guard.alreadyAccepted = _alreadyAcceptedCount;\n', '\n', '        ProtectionTxAccepted(_key, msg.sender, _votingGroupName);\n', '\n', '        if (_alreadyAcceptedCount == _policy.totalAcceptedLimit) {\n', '            _guard.state = GuardState.Confirmed;\n', '            ProtectionTxDone(_key);\n', '        }\n', '\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Decline transaction\n', '    /// Can be called only by registered user in GroupsAccessManager\n', '    ///\n', '    /// @param _key transaction id\n', '    ///\n', '    /// @return code\n', '    function decline(bytes32 _key, bytes32 _votingGroupName) external returns (uint) {\n', '        if (!isTxExist(_key)) {\n', '            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n', '        }\n', '\n', '        if (!GroupsAccessManager(accessManager).isUserInGroup(_votingGroupName, msg.sender)) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        Guard storage _guard = txKey2guard[_key];\n', '        if (_guard.state != GuardState.InProcess) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        if (_guard.votes[msg.sender].groupName != bytes32(0) && !_guard.votes[msg.sender].accepted) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        Policy storage _policy = policyId2policy[index2PolicyId[_guard.basePolicyIndex]];\n', '        uint _policyGroupIndex = _policy.groupName2index[_votingGroupName];\n', '        uint _groupDeclinedVotesCount = _guard.declinedCount[_votingGroupName];\n', '        if (_groupDeclinedVotesCount == _policy.participatedGroups[_policyGroupIndex].declineLimit) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        _guard.votes[msg.sender] = Vote(_votingGroupName, false);\n', '        _guard.declinedCount[_votingGroupName] = _groupDeclinedVotesCount + 1;\n', '        uint _alreadyDeclinedCount = _guard.alreadyDeclined + 1;\n', '        _guard.alreadyDeclined = _alreadyDeclinedCount;\n', '\n', '\n', '        ProtectionTxDeclined(_key, msg.sender, _votingGroupName);\n', '\n', '        if (_alreadyDeclinedCount == _policy.totalDeclinedLimit) {\n', '            _guard.state = GuardState.Decline;\n', '            ProtectionTxCancelled(_key);\n', '        }\n', '\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Revoke user votes for transaction\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _key transaction id\n', '    /// @param _user target user address\n', '    ///\n', '    /// @return code\n', '    function forceRejectVotes(bytes32 _key, address _user) external onlyContractOwner returns (uint) {\n', '        return _revoke(_key, _user);\n', '    }\n', '\n', '    /// @notice Revoke vote for transaction\n', '    /// Can be called only by authorized user\n', '    /// @param _key transaction id\n', '    /// @return code\n', '    function revoke(bytes32 _key) external returns (uint) {\n', '        return _revoke(_key, msg.sender);\n', '    }\n', '\n', '    /// @notice Check transaction status\n', '    /// @param _key transaction id\n', '    /// @return code\n', '    function hasConfirmedRecord(bytes32 _key) public view returns (uint) {\n', '        require(_key != bytes32(0));\n', '\n', '        if (!isTxExist(_key)) {\n', '            return NO_RECORDS_WERE_FOUND;\n', '        }\n', '\n', '        Guard storage _guard = txKey2guard[_key];\n', '        return _guard.state == GuardState.InProcess\n', '        ? PENDING_MANAGER_IN_PROCESS\n', '        : _guard.state == GuardState.Confirmed\n', '        ? OK\n', '        : PENDING_MANAGER_REJECTED;\n', '    }\n', '\n', '\n', '    /// @notice Check policy details\n', '    ///\n', '    /// @return _groupNames group names included in policies\n', '    /// @return _acceptLimits accept limit for group\n', '    /// @return _declineLimits decline limit for group\n', '    function getPolicyDetails(bytes4 _sig, address _contract)\n', '    public\n', '    view\n', '    returns (\n', '        bytes32[] _groupNames,\n', '        uint[] _acceptLimits,\n', '        uint[] _declineLimits,\n', '        uint _totalAcceptedLimit,\n', '        uint _totalDeclinedLimit\n', '    ) {\n', '        require(_sig != bytes4(0));\n', '        require(_contract != 0x0);\n', '        \n', '        bytes32 _policyHash = keccak256(_sig, _contract);\n', '        uint _policyIdx = policyId2Index[_policyHash];\n', '        if (_policyIdx == 0) {\n', '            return;\n', '        }\n', '\n', '        Policy storage _policy = policyId2policy[_policyHash];\n', '        uint _policyGroupsCount = _policy.groupsCount;\n', '        _groupNames = new bytes32[](_policyGroupsCount);\n', '        _acceptLimits = new uint[](_policyGroupsCount);\n', '        _declineLimits = new uint[](_policyGroupsCount);\n', '\n', '        for (uint _idx = 0; _idx < _policyGroupsCount; ++_idx) {\n', '            Requirements storage _requirements = _policy.participatedGroups[_idx + 1];\n', '            _groupNames[_idx] = _requirements.groupName;\n', '            _acceptLimits[_idx] = _requirements.acceptLimit;\n', '            _declineLimits[_idx] = _requirements.declineLimit;\n', '        }\n', '\n', '        (_totalAcceptedLimit, _totalDeclinedLimit) = (_policy.totalAcceptedLimit, _policy.totalDeclinedLimit);\n', '    }\n', '\n', '    /// @notice Check policy include target group\n', '    /// @param _policyHash policy hash (sig, contract address)\n', '    /// @param _groupName group id\n', '    /// @return bool\n', '    function isGroupInPolicy(bytes32 _policyHash, bytes32 _groupName) public view returns (bool) {\n', '        Policy storage _policy = policyId2policy[_policyHash];\n', '        return _policy.groupName2index[_groupName] != 0;\n', '    }\n', '\n', '    /// @notice Check is policy exist\n', '    /// @param _policyHash policy hash (sig, contract address)\n', '    /// @return bool\n', '    function isPolicyExist(bytes32 _policyHash) public view returns (bool) {\n', '        return policyId2Index[_policyHash] != 0;\n', '    }\n', '\n', '    /// @notice Check is transaction exist\n', '    /// @param _key transaction id\n', '    /// @return bool\n', '    function isTxExist(bytes32 _key) public view returns (bool){\n', '        return txKey2index[_key] != 0;\n', '    }\n', '\n', '    function _updateTxState(Policy storage _policy, Guard storage _guard, uint confirmedAmount, uint declineAmount) private {\n', '        if (declineAmount != 0 && _guard.state != GuardState.Decline) {\n', '            _guard.state = GuardState.Decline;\n', '        } else if (confirmedAmount >= _policy.groupsCount && _guard.state != GuardState.Confirmed) {\n', '            _guard.state = GuardState.Confirmed;\n', '        } else if (_guard.state != GuardState.InProcess) {\n', '            _guard.state = GuardState.InProcess;\n', '        }\n', '    }\n', '\n', '    function _revoke(bytes32 _key, address _user) private returns (uint) {\n', '        require(_key != bytes32(0));\n', '        require(_user != 0x0);\n', '\n', '        if (!isTxExist(_key)) {\n', '            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n', '        }\n', '\n', '        Guard storage _guard = txKey2guard[_key];\n', '        if (_guard.state != GuardState.InProcess) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        bytes32 _votedGroupName = _guard.votes[_user].groupName;\n', '        if (_votedGroupName == bytes32(0)) {\n', '            return _emitError(PENDING_MANAGER_HASNT_VOTED);\n', '        }\n', '\n', '        bool isAcceptedVote = _guard.votes[_user].accepted;\n', '        if (isAcceptedVote) {\n', '            _guard.acceptedCount[_votedGroupName] = _guard.acceptedCount[_votedGroupName].sub(1);\n', '            _guard.alreadyAccepted = _guard.alreadyAccepted.sub(1);\n', '        } else {\n', '            _guard.declinedCount[_votedGroupName] = _guard.declinedCount[_votedGroupName].sub(1);\n', '            _guard.alreadyDeclined = _guard.alreadyDeclined.sub(1);\n', '\n', '        }\n', '\n', '        delete _guard.votes[_user];\n', '\n', '        ProtectionTxVoteRevoked(_key, _user, _votedGroupName);\n', '        return OK;\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title MultiSigAdapter\n', '///\n', '/// Abstract implementation\n', '/// This contract serves as transaction signer\n', 'contract MultiSigAdapter is Object {\n', '\n', '    uint constant MULTISIG_ADDED = 3;\n', '    uint constant NO_RECORDS_WERE_FOUND = 4;\n', '\n', '    modifier isAuthorized {\n', '        if (msg.sender == contractOwner || msg.sender == getPendingManager()) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /// @notice Get pending address\n', '    /// @dev abstract. Needs child implementation\n', '    ///\n', '    /// @return pending address\n', '    function getPendingManager() public view returns (address);\n', '\n', '    /// @notice Sign current transaction and add it to transaction pending queue\n', '    ///\n', '    /// @return code\n', '    function _multisig(bytes32 _args, uint _block) internal returns (uint _code) {\n', '        bytes32 _txHash = _getKey(_args, _block);\n', '        address _manager = getPendingManager();\n', '\n', '        _code = PendingManager(_manager).hasConfirmedRecord(_txHash);\n', '        if (_code != NO_RECORDS_WERE_FOUND) {\n', '            return _code;\n', '        }\n', '\n', '        if (OK != PendingManager(_manager).addTx(_txHash, msg.sig, address(this))) {\n', '            revert();\n', '        }\n', '\n', '        return MULTISIG_ADDED;\n', '    }\n', '\n', '    function _isTxExistWithArgs(bytes32 _args, uint _block) internal view returns (bool) {\n', '        bytes32 _txHash = _getKey(_args, _block);\n', '        address _manager = getPendingManager();\n', '        return PendingManager(_manager).isTxExist(_txHash);\n', '    }\n', '\n', '    function _getKey(bytes32 _args, uint _block) private view returns (bytes32 _txHash) {\n', '        _block = _block != 0 ? _block : block.number;\n', '        _txHash = keccak256(msg.sig, _args, _block);\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title ServiceController\n', '///\n', '/// Base implementation\n', '/// Serves for managing service instances\n', 'contract ServiceController is MultiSigAdapter {\n', '\n', '    uint constant SERVICE_CONTROLLER = 350000;\n', '    uint constant SERVICE_CONTROLLER_EMISSION_EXIST = SERVICE_CONTROLLER + 1;\n', '    uint constant SERVICE_CONTROLLER_BURNING_MAN_EXIST = SERVICE_CONTROLLER + 2;\n', '    uint constant SERVICE_CONTROLLER_ALREADY_INITIALIZED = SERVICE_CONTROLLER + 3;\n', '    uint constant SERVICE_CONTROLLER_SERVICE_EXIST = SERVICE_CONTROLLER + 4;\n', '\n', '    address public profiterole;\n', '    address public treasury;\n', '    address public pendingManager;\n', '    address public proxy;\n', '\n', '    mapping(address => bool) public sideServices;\n', '    mapping(address => bool) emissionProviders;\n', '    mapping(address => bool) burningMans;\n', '\n', '    /// @notice Default ServiceController&#39;s constructor\n', '    ///\n', '    /// @param _pendingManager pending manager address\n', '    /// @param _proxy ERC20 proxy address\n', '    /// @param _profiterole profiterole address\n', '    /// @param _treasury treasury address\n', '    function ServiceController(address _pendingManager, address _proxy, address _profiterole, address _treasury) public {\n', '        require(_pendingManager != 0x0);\n', '        require(_proxy != 0x0);\n', '        require(_profiterole != 0x0);\n', '        require(_treasury != 0x0);\n', '        pendingManager = _pendingManager;\n', '        proxy = _proxy;\n', '        profiterole = _profiterole;\n', '        treasury = _treasury;\n', '    }\n', '\n', '    /// @notice Return pending manager address\n', '    ///\n', '    /// @return code\n', '    function getPendingManager() public view returns (address) {\n', '        return pendingManager;\n', '    }\n', '\n', '    /// @notice Add emission provider\n', '    ///\n', '    /// @param _provider emission provider address\n', '    ///\n', '    /// @return code\n', '    function addEmissionProvider(address _provider, uint _block) public returns (uint _code) {\n', '        if (emissionProviders[_provider]) {\n', '            return SERVICE_CONTROLLER_EMISSION_EXIST;\n', '        }\n', '        _code = _multisig(keccak256(_provider), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        emissionProviders[_provider] = true;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Remove emission provider\n', '    ///\n', '    /// @param _provider emission provider address\n', '    ///\n', '    /// @return code\n', '    function removeEmissionProvider(address _provider, uint _block) public returns (uint _code) {\n', '        _code = _multisig(keccak256(_provider), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        delete emissionProviders[_provider];\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Add burning man\n', '    ///\n', '    /// @param _burningMan burning man address\n', '    ///\n', '    /// @return code\n', '    function addBurningMan(address _burningMan, uint _block) public returns (uint _code) {\n', '        if (burningMans[_burningMan]) {\n', '            return SERVICE_CONTROLLER_BURNING_MAN_EXIST;\n', '        }\n', '\n', '        _code = _multisig(keccak256(_burningMan), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        burningMans[_burningMan] = true;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Remove burning man\n', '    ///\n', '    /// @param _burningMan burning man address\n', '    ///\n', '    /// @return code\n', '    function removeBurningMan(address _burningMan, uint _block) public returns (uint _code) {\n', '        _code = _multisig(keccak256(_burningMan), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        delete burningMans[_burningMan];\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Update a profiterole address\n', '    ///\n', '    /// @param _profiterole profiterole address\n', '    ///\n', '    /// @return result code of an operation\n', '    function updateProfiterole(address _profiterole, uint _block) public returns (uint _code) {\n', '        _code = _multisig(keccak256(_profiterole), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        profiterole = _profiterole;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Update a treasury address\n', '    ///\n', '    /// @param _treasury treasury address\n', '    ///\n', '    /// @return result code of an operation\n', '    function updateTreasury(address _treasury, uint _block) public returns (uint _code) {\n', '        _code = _multisig(keccak256(_treasury), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        treasury = _treasury;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Update pending manager address\n', '    ///\n', '    /// @param _pendingManager pending manager address\n', '    ///\n', '    /// @return result code of an operation\n', '    function updatePendingManager(address _pendingManager, uint _block) public returns (uint _code) {\n', '        _code = _multisig(keccak256(_pendingManager), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        pendingManager = _pendingManager;\n', '        return OK;\n', '    }\n', '\n', '    function addSideService(address _service, uint _block) public returns (uint _code) {\n', '        if (sideServices[_service]) {\n', '            return SERVICE_CONTROLLER_SERVICE_EXIST;\n', '        }\n', '        _code = _multisig(keccak256(_service), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        sideServices[_service] = true;\n', '        return OK;\n', '    }\n', '\n', '    function removeSideService(address _service, uint _block) public returns (uint _code) {\n', '        _code = _multisig(keccak256(_service), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        delete sideServices[_service];\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Check target address is service\n', '    ///\n', '    /// @param _address target address\n', '    ///\n', '    /// @return `true` when an address is a service, `false` otherwise\n', '    function isService(address _address) public view returns (bool check) {\n', '        return _address == profiterole ||\n', '            _address == treasury || \n', '            _address == proxy || \n', '            _address == pendingManager || \n', '            emissionProviders[_address] || \n', '            burningMans[_address] ||\n', '            sideServices[_address];\n', '    }\n', '}\n', '\n', 'contract OracleMethodAdapter is Object {\n', '\n', '    event OracleAdded(bytes4 _sig, address _oracle);\n', '    event OracleRemoved(bytes4 _sig, address _oracle);\n', '\n', '    mapping(bytes4 => mapping(address => bool)) public oracles;\n', '\n', '    /// @dev Allow access only for oracle\n', '    modifier onlyOracle {\n', '        if (oracles[msg.sig][msg.sender]) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    modifier onlyOracleOrOwner {\n', '        if (oracles[msg.sig][msg.sender] || msg.sender == contractOwner) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    function addOracles(bytes4[] _signatures, address[] _oracles) onlyContractOwner external returns (uint) {\n', '        require(_signatures.length == _oracles.length);\n', '        bytes4 _sig;\n', '        address _oracle;\n', '        for (uint _idx = 0; _idx < _signatures.length; ++_idx) {\n', '            (_sig, _oracle) = (_signatures[_idx], _oracles[_idx]);\n', '            if (!oracles[_sig][_oracle]) {\n', '                oracles[_sig][_oracle] = true;\n', '                _emitOracleAdded(_sig, _oracle);\n', '            }\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    function removeOracles(bytes4[] _signatures, address[] _oracles) onlyContractOwner external returns (uint) {\n', '        require(_signatures.length == _oracles.length);\n', '        bytes4 _sig;\n', '        address _oracle;\n', '        for (uint _idx = 0; _idx < _signatures.length; ++_idx) {\n', '            (_sig, _oracle) = (_signatures[_idx], _oracles[_idx]);\n', '            if (oracles[_sig][_oracle]) {\n', '                delete oracles[_sig][_oracle];\n', '                _emitOracleRemoved(_sig, _oracle);\n', '            }\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    function _emitOracleAdded(bytes4 _sig, address _oracle) internal {\n', '        OracleAdded(_sig, _oracle);\n', '    }\n', '\n', '    function _emitOracleRemoved(bytes4 _sig, address _oracle) internal {\n', '        OracleRemoved(_sig, _oracle);\n', '    }\n', '\n', '}\n', '\n', 'contract Platform {\n', '    mapping(bytes32 => address) public proxies;\n', '    function name(bytes32 _symbol) public view returns (string);\n', '    function setProxy(address _address, bytes32 _symbol) public returns (uint errorCode);\n', '    function isOwner(address _owner, bytes32 _symbol) public view returns (bool);\n', '    function totalSupply(bytes32 _symbol) public view returns (uint);\n', '    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint);\n', '    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint);\n', '    function baseUnit(bytes32 _symbol) public view returns (uint8);\n', '    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n', '    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n', '    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public returns (uint errorCode);\n', '    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);\n', '    function reissueAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n', '    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n', '    function isReissuable(bytes32 _symbol) public view returns (bool);\n', '    function changeOwnership(bytes32 _symbol, address _newOwner) public returns (uint errorCode);\n', '}\n', '\n', '\n', 'contract ATxAssetProxy is ERC20, Object, ServiceAllowance {\n', '\n', '    // Timespan for users to review the new implementation and make decision.\n', '    uint constant UPGRADE_FREEZE_TIME = 3 days;\n', '\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '     * Indicates an upgrade freeze-time start, and the next asset implementation contract.\n', '     */\n', '    event UpgradeProposal(address newVersion);\n', '\n', '    // Current asset implementation contract address.\n', '    address latestVersion;\n', '\n', '    // Proposed next asset implementation contract address.\n', '    address pendingVersion;\n', '\n', '    // Upgrade freeze-time start.\n', '    uint pendingVersionTimestamp;\n', '\n', '    // Assigned platform, immutable.\n', '    Platform public platform;\n', '\n', '    // Assigned symbol, immutable.\n', '    bytes32 public smbl;\n', '\n', '    // Assigned name, immutable.\n', '    string public name;\n', '\n', '    /**\n', '     * Only platform is allowed to call.\n', '     */\n', '    modifier onlyPlatform() {\n', '        if (msg.sender == address(platform)) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Only current asset owner is allowed to call.\n', '     */\n', '    modifier onlyAssetOwner() {\n', '        if (platform.isOwner(msg.sender, smbl)) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Only asset implementation contract assigned to sender is allowed to call.\n', '     */\n', '    modifier onlyAccess(address _sender) {\n', '        if (getLatestVersion() == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Resolves asset implementation contract for the caller and forwards there transaction data,\n', '     * along with the value. This allows for proxy interface growth.\n', '     */\n', '    function() public payable {\n', '        _getAsset().__process.value(msg.value)(msg.data, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Sets platform address, assigns symbol and name.\n', '     *\n', '     * Can be set only once.\n', '     *\n', '     * @param _platform platform contract address.\n', '     * @param _symbol assigned symbol.\n', '     * @param _name assigned name.\n', '     *\n', '     * @return success.\n', '     */\n', '    function init(Platform _platform, string _symbol, string _name) public returns (bool) {\n', '        if (address(platform) != 0x0) {\n', '            return false;\n', '        }\n', '        platform = _platform;\n', '        symbol = _symbol;\n', '        smbl = stringToBytes32(_symbol);\n', '        name = _name;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns asset total supply.\n', '     *\n', '     * @return asset total supply.\n', '     */\n', '    function totalSupply() public view returns (uint) {\n', '        return platform.totalSupply(smbl);\n', '    }\n', '\n', '    /**\n', '     * Returns asset balance for a particular holder.\n', '     *\n', '     * @param _owner holder address.\n', '     *\n', '     * @return holder balance.\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint) {\n', '        return platform.balanceOf(_owner, smbl);\n', '    }\n', '\n', '    /**\n', '     * Returns asset allowance from one holder to another.\n', '     *\n', '     * @param _from holder that allowed spending.\n', '     * @param _spender holder that is allowed to spend.\n', '     *\n', '     * @return holder to spender allowance.\n', '     */\n', '    function allowance(address _from, address _spender) public view returns (uint) {\n', '        return platform.allowance(_from, _spender, smbl);\n', '    }\n', '\n', '    /**\n', '     * Returns asset decimals.\n', '     *\n', '     * @return asset decimals.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return platform.baseUnit(smbl);\n', '    }\n', '\n', '    /**\n', '     * Transfers asset balance from the caller to specified receiver.\n', '     *\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     *\n', '     * @return success.\n', '     */\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        if (_to != 0x0) {\n', '            return _transferWithReference(_to, _value, "");\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfers asset balance from the caller to specified receiver adding specified comment.\n', '     *\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     * @param _reference transfer comment to be included in a platform&#39;s Transfer event.\n', '     *\n', '     * @return success.\n', '     */\n', '    function transferWithReference(address _to, uint _value, string _reference) public returns (bool) {\n', '        if (_to != 0x0) {\n', '            return _transferWithReference(_to, _value, _reference);\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Performs transfer call on the platform by the name of specified sender.\n', '     *\n', '     * Can only be called by asset implementation contract assigned to sender.\n', '     *\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     * @param _reference transfer comment to be included in a platform&#39;s Transfer event.\n', '     * @param _sender initial caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\n', '        return platform.proxyTransferWithReference(_to, _value, smbl, _reference, _sender) == OK;\n', '    }\n', '\n', '    /**\n', '     * Prforms allowance transfer of asset balance between holders.\n', '     *\n', '     * @param _from holder address to take from.\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     *\n', '     * @return success.\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        if (_to != 0x0) {\n', '            return _getAsset().__transferFromWithReference(_from, _to, _value, "", msg.sender);\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Performs allowance transfer call on the platform by the name of specified sender.\n', '     *\n', '     * Can only be called by asset implementation contract assigned to sender.\n', '     *\n', '     * @param _from holder address to take from.\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     * @param _reference transfer comment to be included in a platform&#39;s Transfer event.\n', '     * @param _sender initial caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\n', '        return platform.proxyTransferFromWithReference(_from, _to, _value, smbl, _reference, _sender) == OK;\n', '    }\n', '\n', '    /**\n', '     * Sets asset spending allowance for a specified spender.\n', '     *\n', '     * @param _spender holder address to set allowance to.\n', '     * @param _value amount to allow.\n', '     *\n', '     * @return success.\n', '     */\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        if (_spender != 0x0) {\n', '            return _getAsset().__approve(_spender, _value, msg.sender);\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Performs allowance setting call on the platform by the name of specified sender.\n', '     *\n', '     * Can only be called by asset implementation contract assigned to sender.\n', '     *\n', '     * @param _spender holder address to set allowance to.\n', '     * @param _value amount to allow.\n', '     * @param _sender initial caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function __approve(address _spender, uint _value, address _sender) public onlyAccess(_sender) returns (bool) {\n', '        return platform.proxyApprove(_spender, _value, smbl, _sender) == OK;\n', '    }\n', '\n', '    /**\n', '     * Emits ERC20 Transfer event on this contract.\n', '     *\n', '     * Can only be, and, called by assigned platform when asset transfer happens.\n', '     */\n', '    function emitTransfer(address _from, address _to, uint _value) public onlyPlatform() {\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Emits ERC20 Approval event on this contract.\n', '     *\n', '     * Can only be, and, called by assigned platform when asset allowance set happens.\n', '     */\n', '    function emitApprove(address _from, address _spender, uint _value) public onlyPlatform() {\n', '        Approval(_from, _spender, _value);\n', '    }\n', '\n', '    /**\n', '     * Returns current asset implementation contract address.\n', '     *\n', '     * @return asset implementation contract address.\n', '     */\n', '    function getLatestVersion() public view returns (address) {\n', '        return latestVersion;\n', '    }\n', '\n', '    /**\n', '     * Returns proposed next asset implementation contract address.\n', '     *\n', '     * @return asset implementation contract address.\n', '     */\n', '    function getPendingVersion() public view returns (address) {\n', '        return pendingVersion;\n', '    }\n', '\n', '    /**\n', '     * Returns upgrade freeze-time start.\n', '     *\n', '     * @return freeze-time start.\n', '     */\n', '    function getPendingVersionTimestamp() public view returns (uint) {\n', '        return pendingVersionTimestamp;\n', '    }\n', '\n', '    /**\n', '     * Propose next asset implementation contract address.\n', '     *\n', '     * Can only be called by current asset owner.\n', '     *\n', '     * Note: freeze-time should not be applied for the initial setup.\n', '     *\n', '     * @param _newVersion asset implementation contract address.\n', '     *\n', '     * @return success.\n', '     */\n', '    function proposeUpgrade(address _newVersion) public onlyAssetOwner returns (bool) {\n', '        // Should not already be in the upgrading process.\n', '        if (pendingVersion != 0x0) {\n', '            return false;\n', '        }\n', '        // New version address should be other than 0x0.\n', '        if (_newVersion == 0x0) {\n', '            return false;\n', '        }\n', '        // Don&#39;t apply freeze-time for the initial setup.\n', '        if (latestVersion == 0x0) {\n', '            latestVersion = _newVersion;\n', '            return true;\n', '        }\n', '        pendingVersion = _newVersion;\n', '        pendingVersionTimestamp = now;\n', '        UpgradeProposal(_newVersion);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Cancel the pending upgrade process.\n', '     *\n', '     * Can only be called by current asset owner.\n', '     *\n', '     * @return success.\n', '     */\n', '    function purgeUpgrade() public onlyAssetOwner returns (bool) {\n', '        if (pendingVersion == 0x0) {\n', '            return false;\n', '        }\n', '        delete pendingVersion;\n', '        delete pendingVersionTimestamp;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Finalize an upgrade process setting new asset implementation contract address.\n', '     *\n', '     * Can only be called after an upgrade freeze-time.\n', '     *\n', '     * @return success.\n', '     */\n', '    function commitUpgrade() public returns (bool) {\n', '        if (pendingVersion == 0x0) {\n', '            return false;\n', '        }\n', '        if (pendingVersionTimestamp.add(UPGRADE_FREEZE_TIME) > now) {\n', '            return false;\n', '        }\n', '        latestVersion = pendingVersion;\n', '        delete pendingVersion;\n', '        delete pendingVersionTimestamp;\n', '        return true;\n', '    }\n', '\n', '    function isTransferAllowed(address, address, address, address, uint) public view returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns asset implementation contract for current caller.\n', '     *\n', '     * @return asset implementation contract.\n', '     */\n', '    function _getAsset() internal view returns (ATxAssetInterface) {\n', '        return ATxAssetInterface(getLatestVersion());\n', '    }\n', '\n', '    /**\n', '     * Resolves asset implementation contract for the caller and forwards there arguments along with\n', '     * the caller address.\n', '     *\n', '     * @return success.\n', '     */\n', '    function _transferWithReference(address _to, uint _value, string _reference) internal returns (bool) {\n', '        return _getAsset().__transferWithReference(_to, _value, _reference, msg.sender);\n', '    }\n', '\n', '    function stringToBytes32(string memory source) private pure returns (bytes32 result) {\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '}\n', '\n', 'contract DataControllerEmitter {\n', '\n', '    event CountryCodeAdded(uint _countryCode, uint _countryId, uint _maxHolderCount);\n', '    event CountryCodeChanged(uint _countryCode, uint _countryId, uint _maxHolderCount);\n', '\n', '    event HolderRegistered(bytes32 _externalHolderId, uint _accessIndex, uint _countryCode);\n', '    event HolderAddressAdded(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex);\n', '    event HolderAddressRemoved(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex);\n', '    event HolderOperationalChanged(bytes32 _externalHolderId, bool _operational);\n', '\n', '    event DayLimitChanged(bytes32 _externalHolderId, uint _from, uint _to);\n', '    event MonthLimitChanged(bytes32 _externalHolderId, uint _from, uint _to);\n', '\n', '    event Error(uint _errorCode);\n', '\n', '    function _emitHolderAddressAdded(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex) internal {\n', '        HolderAddressAdded(_externalHolderId, _holderPrototype, _accessIndex);\n', '    }\n', '\n', '    function _emitHolderAddressRemoved(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex) internal {\n', '        HolderAddressRemoved(_externalHolderId, _holderPrototype, _accessIndex);\n', '    }\n', '\n', '    function _emitHolderRegistered(bytes32 _externalHolderId, uint _accessIndex, uint _countryCode) internal {\n', '        HolderRegistered(_externalHolderId, _accessIndex, _countryCode);\n', '    }\n', '\n', '    function _emitHolderOperationalChanged(bytes32 _externalHolderId, bool _operational) internal {\n', '        HolderOperationalChanged(_externalHolderId, _operational);\n', '    }\n', '\n', '    function _emitCountryCodeAdded(uint _countryCode, uint _countryId, uint _maxHolderCount) internal {\n', '        CountryCodeAdded(_countryCode, _countryId, _maxHolderCount);\n', '    }\n', '\n', '    function _emitCountryCodeChanged(uint _countryCode, uint _countryId, uint _maxHolderCount) internal {\n', '        CountryCodeChanged(_countryCode, _countryId, _maxHolderCount);\n', '    }\n', '\n', '    function _emitDayLimitChanged(bytes32 _externalHolderId, uint _from, uint _to) internal {\n', '        DayLimitChanged(_externalHolderId, _from, _to);\n', '    }\n', '\n', '    function _emitMonthLimitChanged(bytes32 _externalHolderId, uint _from, uint _to) internal {\n', '        MonthLimitChanged(_externalHolderId, _from, _to);\n', '    }\n', '\n', '    function _emitError(uint _errorCode) internal returns (uint) {\n', '        Error(_errorCode);\n', '        return _errorCode;\n', '    }\n', '}\n', '\n', '\n', '/// @title Provides possibility manage holders? country limits and limits for holders.\n', 'contract DataController is OracleMethodAdapter, DataControllerEmitter {\n', '\n', '    /* CONSTANTS */\n', '\n', '    uint constant DATA_CONTROLLER = 109000;\n', '    uint constant DATA_CONTROLLER_ERROR = DATA_CONTROLLER + 1;\n', '    uint constant DATA_CONTROLLER_CURRENT_WRONG_LIMIT = DATA_CONTROLLER + 2;\n', '    uint constant DATA_CONTROLLER_WRONG_ALLOWANCE = DATA_CONTROLLER + 3;\n', '    uint constant DATA_CONTROLLER_COUNTRY_CODE_ALREADY_EXISTS = DATA_CONTROLLER + 4;\n', '\n', '    uint constant MAX_TOKEN_HOLDER_NUMBER = 2 ** 256 - 1;\n', '\n', '    using SafeMath for uint;\n', '\n', '    /* STRUCTS */\n', '\n', '    /// @title HoldersData couldn&#39;t be public because of internal structures, so needed to provide getters for different parts of _holderData\n', '    struct HoldersData {\n', '        uint countryCode;\n', '        uint sendLimPerDay;\n', '        uint sendLimPerMonth;\n', '        bool operational;\n', '        bytes text;\n', '        uint holderAddressCount;\n', '        mapping(uint => address) index2Address;\n', '        mapping(address => uint) address2Index;\n', '    }\n', '\n', '    struct CountryLimits {\n', '        uint countryCode;\n', '        uint maxTokenHolderNumber;\n', '        uint currentTokenHolderNumber;\n', '    }\n', '\n', '    /* FIELDS */\n', '\n', '    address public withdrawal;\n', '    address assetAddress;\n', '    address public serviceController;\n', '\n', '    mapping(address => uint) public allowance;\n', '\n', '    // Iterable mapping pattern is used for holders.\n', '    /// @dev This is an access address mapping. Many addresses may have access to a single holder.\n', '    uint public holdersCount;\n', '    mapping(uint => HoldersData) holders;\n', '    mapping(address => bytes32) holderAddress2Id;\n', '    mapping(bytes32 => uint) public holderIndex;\n', '\n', '    // This is an access address mapping. Many addresses may have access to a single holder.\n', '    uint public countriesCount;\n', '    mapping(uint => CountryLimits) countryLimitsList;\n', '    mapping(uint => uint) countryIndex;\n', '\n', '    /* MODIFIERS */\n', '\n', '    modifier onlyWithdrawal {\n', '        if (msg.sender != withdrawal) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier onlyAsset {\n', '        if (msg.sender == assetAddress) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    modifier onlyContractOwner {\n', '        if (msg.sender == contractOwner) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /// @notice Constructor for _holderData controller.\n', '    /// @param _serviceController service controller\n', '    function DataController(address _serviceController, address _asset) public {\n', '        require(_serviceController != 0x0);\n', '        require(_asset != 0x0);\n', '\n', '        serviceController = _serviceController;\n', '        assetAddress = _asset;\n', '    }\n', '\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    function setWithdraw(address _withdrawal) onlyContractOwner external returns (uint) {\n', '        require(_withdrawal != 0x0);\n', '        withdrawal = _withdrawal;\n', '        return OK;\n', '    }\n', '\n', '\n', '    function getPendingManager() public view returns (address) {\n', '        return ServiceController(serviceController).getPendingManager();\n', '    }\n', '\n', '    function getHolderInfo(bytes32 _externalHolderId) public view returns (\n', '        uint _countryCode,\n', '        uint _limPerDay,\n', '        uint _limPerMonth,\n', '        bool _operational,\n', '        bytes _text\n', '    ) {\n', '        HoldersData storage _data = holders[holderIndex[_externalHolderId]];\n', '        return (_data.countryCode, _data.sendLimPerDay, _data.sendLimPerMonth, _data.operational, _data.text);\n', '    }\n', '\n', '    function getHolderAddresses(bytes32 _externalHolderId) public view returns (address[] _addresses) {\n', '        HoldersData storage _holderData = holders[holderIndex[_externalHolderId]];\n', '        uint _addressesCount = _holderData.holderAddressCount;\n', '        _addresses = new address[](_addressesCount);\n', '        for (uint _holderAddressIdx = 0; _holderAddressIdx < _addressesCount; ++_holderAddressIdx) {\n', '            _addresses[_holderAddressIdx] = _holderData.index2Address[_holderAddressIdx + 1];\n', '        }\n', '    }\n', '\n', '    function getHolderCountryCode(bytes32 _externalHolderId) public view returns (uint) {\n', '        return holders[holderIndex[_externalHolderId]].countryCode;\n', '    }\n', '\n', '    function getHolderExternalIdByAddress(address _address) public view returns (bytes32) {\n', '        return holderAddress2Id[_address];\n', '    }\n', '\n', '    /// @notice Checks user is holder.\n', '    /// @param _address checking address.\n', '    /// @return `true` if _address is registered holder, `false` otherwise.\n', '    function isRegisteredAddress(address _address) public view returns (bool) {\n', '        return holderIndex[holderAddress2Id[_address]] != 0;\n', '    }\n', '\n', '    function isHolderOwnAddress(bytes32 _externalHolderId, address _address) public view returns (bool) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        if (_holderIndex == 0) {\n', '            return false;\n', '        }\n', '        return holders[_holderIndex].address2Index[_address] != 0;\n', '    }\n', '\n', '    function getCountryInfo(uint _countryCode) public view returns (uint _maxHolderNumber, uint _currentHolderCount) {\n', '        CountryLimits storage _data = countryLimitsList[countryIndex[_countryCode]];\n', '        return (_data.maxTokenHolderNumber, _data.currentTokenHolderNumber);\n', '    }\n', '\n', '    function getCountryLimit(uint _countryCode) public view returns (uint limit) {\n', '        uint _index = countryIndex[_countryCode];\n', '        require(_index != 0);\n', '        return countryLimitsList[_index].maxTokenHolderNumber;\n', '    }\n', '\n', '    function addCountryCode(uint _countryCode) onlyContractOwner public returns (uint) {\n', '        var (,_created) = _createCountryId(_countryCode);\n', '        if (!_created) {\n', '            return _emitError(DATA_CONTROLLER_COUNTRY_CODE_ALREADY_EXISTS);\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Returns holder id for the specified address, creates it if needed.\n', '    /// @param _externalHolderId holder address.\n', '    /// @param _countryCode country code.\n', '    /// @return error code.\n', '    function registerHolder(bytes32 _externalHolderId, address _holderAddress, uint _countryCode) onlyOracleOrOwner external returns (uint) {\n', '        require(_holderAddress != 0x0);\n', '        uint _holderIndex = holderIndex[holderAddress2Id[_holderAddress]];\n', '        require(_holderIndex == 0);\n', '\n', '        _createCountryId(_countryCode);\n', '        _holderIndex = holdersCount.add(1);\n', '        holdersCount = _holderIndex;\n', '\n', '        HoldersData storage _holderData = holders[_holderIndex];\n', '        _holderData.countryCode = _countryCode;\n', '        _holderData.operational = true;\n', '        _holderData.sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER;\n', '        _holderData.sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER;\n', '        uint _firstAddressIndex = 1;\n', '        _holderData.holderAddressCount = _firstAddressIndex;\n', '        _holderData.address2Index[_holderAddress] = _firstAddressIndex;\n', '        _holderData.index2Address[_firstAddressIndex] = _holderAddress;\n', '        holderIndex[_externalHolderId] = _holderIndex;\n', '        holderAddress2Id[_holderAddress] = _externalHolderId;\n', '\n', '        _emitHolderRegistered(_externalHolderId, _holderIndex, _countryCode);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Adds new address equivalent to holder.\n', '    /// @param _externalHolderId external holder identifier.\n', '    /// @param _newAddress adding address.\n', '    /// @return error code.\n', '    function addHolderAddress(bytes32 _externalHolderId, address _newAddress) onlyOracleOrOwner external returns (uint) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        require(_holderIndex != 0);\n', '\n', '        uint _newAddressId = holderIndex[holderAddress2Id[_newAddress]];\n', '        require(_newAddressId == 0);\n', '\n', '        HoldersData storage _holderData = holders[_holderIndex];\n', '\n', '        if (_holderData.address2Index[_newAddress] == 0) {\n', '            _holderData.holderAddressCount = _holderData.holderAddressCount.add(1);\n', '            _holderData.address2Index[_newAddress] = _holderData.holderAddressCount;\n', '            _holderData.index2Address[_holderData.holderAddressCount] = _newAddress;\n', '        }\n', '\n', '        holderAddress2Id[_newAddress] = _externalHolderId;\n', '\n', '        _emitHolderAddressAdded(_externalHolderId, _newAddress, _holderIndex);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Remove an address owned by a holder.\n', '    /// @param _externalHolderId external holder identifier.\n', '    /// @param _address removing address.\n', '    /// @return error code.\n', '    function removeHolderAddress(bytes32 _externalHolderId, address _address) onlyOracleOrOwner external returns (uint) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        require(_holderIndex != 0);\n', '\n', '        HoldersData storage _holderData = holders[_holderIndex];\n', '\n', '        uint _tempIndex = _holderData.address2Index[_address];\n', '        require(_tempIndex != 0);\n', '\n', '        address _lastAddress = _holderData.index2Address[_holderData.holderAddressCount];\n', '        _holderData.address2Index[_lastAddress] = _tempIndex;\n', '        _holderData.index2Address[_tempIndex] = _lastAddress;\n', '        delete _holderData.address2Index[_address];\n', '        _holderData.holderAddressCount = _holderData.holderAddressCount.sub(1);\n', '\n', '        delete holderAddress2Id[_address];\n', '\n', '        _emitHolderAddressRemoved(_externalHolderId, _address, _holderIndex);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Change operational status for holder.\n', '    /// Can be accessed by contract owner or oracle only.\n', '    ///\n', '    /// @param _externalHolderId external holder identifier.\n', '    /// @param _operational operational status.\n', '    ///\n', '    /// @return result code.\n', '    function changeOperational(bytes32 _externalHolderId, bool _operational) onlyOracleOrOwner external returns (uint) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        require(_holderIndex != 0);\n', '\n', '        holders[_holderIndex].operational = _operational;\n', '\n', '        _emitHolderOperationalChanged(_externalHolderId, _operational);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Changes text for holder.\n', '    /// Can be accessed by contract owner or oracle only.\n', '    ///\n', '    /// @param _externalHolderId external holder identifier.\n', '    /// @param _text changing text.\n', '    ///\n', '    /// @return result code.\n', '    function updateTextForHolder(bytes32 _externalHolderId, bytes _text) onlyOracleOrOwner external returns (uint) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        require(_holderIndex != 0);\n', '\n', '        holders[_holderIndex].text = _text;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Updates limit per day for holder.\n', '    ///\n', '    /// Can be accessed by contract owner only.\n', '    ///\n', '    /// @param _externalHolderId external holder identifier.\n', '    /// @param _limit limit value.\n', '    ///\n', '    /// @return result code.\n', '    function updateLimitPerDay(bytes32 _externalHolderId, uint _limit) onlyOracleOrOwner external returns (uint) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        require(_holderIndex != 0);\n', '\n', '        uint _currentLimit = holders[_holderIndex].sendLimPerDay;\n', '        holders[_holderIndex].sendLimPerDay = _limit;\n', '\n', '        _emitDayLimitChanged(_externalHolderId, _currentLimit, _limit);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Updates limit per month for holder.\n', '    /// Can be accessed by contract owner or oracle only.\n', '    ///\n', '    /// @param _externalHolderId external holder identifier.\n', '    /// @param _limit limit value.\n', '    ///\n', '    /// @return result code.\n', '    function updateLimitPerMonth(bytes32 _externalHolderId, uint _limit) onlyOracleOrOwner external returns (uint) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        require(_holderIndex != 0);\n', '\n', '        uint _currentLimit = holders[_holderIndex].sendLimPerDay;\n', '        holders[_holderIndex].sendLimPerMonth = _limit;\n', '\n', '        _emitMonthLimitChanged(_externalHolderId, _currentLimit, _limit);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Change country limits.\n', '    /// Can be accessed by contract owner or oracle only.\n', '    ///\n', '    /// @param _countryCode country code.\n', '    /// @param _limit limit value.\n', '    ///\n', '    /// @return result code.\n', '    function changeCountryLimit(uint _countryCode, uint _limit) onlyOracleOrOwner external returns (uint) {\n', '        uint _countryIndex = countryIndex[_countryCode];\n', '        require(_countryIndex != 0);\n', '\n', '        uint _currentTokenHolderNumber = countryLimitsList[_countryIndex].currentTokenHolderNumber;\n', '        if (_currentTokenHolderNumber > _limit) {\n', '            return DATA_CONTROLLER_CURRENT_WRONG_LIMIT;\n', '        }\n', '\n', '        countryLimitsList[_countryIndex].maxTokenHolderNumber = _limit;\n', '        \n', '        _emitCountryCodeChanged(_countryIndex, _countryCode, _limit);\n', '        return OK;\n', '    }\n', '\n', '    function withdrawFrom(address _holderAddress, uint _value) public onlyAsset returns (uint) {\n', '        bytes32 _externalHolderId = holderAddress2Id[_holderAddress];\n', '        HoldersData storage _holderData = holders[holderIndex[_externalHolderId]];\n', '        _holderData.sendLimPerDay = _holderData.sendLimPerDay.sub(_value);\n', '        _holderData.sendLimPerMonth = _holderData.sendLimPerMonth.sub(_value);\n', '        return OK;\n', '    }\n', '\n', '    function depositTo(address _holderAddress, uint _value) public onlyAsset returns (uint) {\n', '        bytes32 _externalHolderId = holderAddress2Id[_holderAddress];\n', '        HoldersData storage _holderData = holders[holderIndex[_externalHolderId]];\n', '        _holderData.sendLimPerDay = _holderData.sendLimPerDay.add(_value);\n', '        _holderData.sendLimPerMonth = _holderData.sendLimPerMonth.add(_value);\n', '        return OK;\n', '    }\n', '\n', '    function updateCountryHoldersCount(uint _countryCode, uint _updatedHolderCount) public onlyAsset returns (uint) {\n', '        CountryLimits storage _data = countryLimitsList[countryIndex[_countryCode]];\n', '        assert(_data.maxTokenHolderNumber >= _updatedHolderCount);\n', '        _data.currentTokenHolderNumber = _updatedHolderCount;\n', '        return OK;\n', '    }\n', '\n', '    function changeAllowance(address _from, uint _value) public onlyWithdrawal returns (uint) {\n', '        ServiceController _serviceController = ServiceController(serviceController);\n', '        ATxAssetProxy token = ATxAssetProxy(_serviceController.proxy());\n', '        if (token.balanceOf(_from) < _value) {\n', '            return DATA_CONTROLLER_WRONG_ALLOWANCE;\n', '        }\n', '        allowance[_from] = _value;\n', '        return OK;\n', '    }\n', '\n', '    function _createCountryId(uint _countryCode) internal returns (uint, bool _created) {\n', '        uint countryId = countryIndex[_countryCode];\n', '        if (countryId == 0) {\n', '            uint _countriesCount = countriesCount;\n', '            countryId = _countriesCount.add(1);\n', '            countriesCount = countryId;\n', '            CountryLimits storage limits = countryLimitsList[countryId];\n', '            limits.countryCode = _countryCode;\n', '            limits.maxTokenHolderNumber = MAX_TOKEN_HOLDER_NUMBER;\n', '\n', '            countryIndex[_countryCode] = countryId;\n', '            _emitCountryCodeAdded(countryIndex[_countryCode], _countryCode, MAX_TOKEN_HOLDER_NUMBER);\n', '\n', '            _created = true;\n', '        }\n', '\n', '        return (countryId, _created);\n', '    }\n', '}\n', '\n', '/// @title Contract that will work with ERC223 tokens.\n', 'interface ERC223ReceivingInterface {\n', '\n', '\t/// @notice Standard ERC223 function that will handle incoming token transfers.\n', '\t/// @param _from  Token sender address.\n', '\t/// @param _value Amount of tokens.\n', '\t/// @param _data  Transaction metadata.\n', '    function tokenFallback(address _from, uint _value, bytes _data) external;\n', '}\n', '\n', '/// @title ATx Asset implementation contract.\n', '///\n', '/// Basic asset implementation contract, without any additional logic.\n', '/// Every other asset implementation contracts should derive from this one.\n', '/// Receives calls from the proxy, and calls back immediately without arguments modification.\n', '///\n', '/// Note: all the non constant functions return false instead of throwing in case if state change\n', '/// didn&#39;t happen yet.\n', 'contract ATxAsset is BasicAsset, Owned {\n', '\n', '    uint public constant OK = 1;\n', '\n', '    using SafeMath for uint;\n', '\n', '    enum Roles {\n', '        Holder,\n', '        Service,\n', '        Other\n', '    }\n', '\n', '    ServiceController public serviceController;\n', '    DataController public dataController;\n', '    uint public lockupDate;\n', '\n', '    /// @notice Default constructor for ATxAsset.\n', '    function ATxAsset() public {\n', '    }\n', '\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    /// @notice Init function for ATxAsset.\n', '    ///\n', '    /// @param _proxy - atx asset proxy.\n', '    /// @param _serviceController - service controoler.\n', '    /// @param _dataController - data controller.\n', '    /// @param _lockupDate - th lockup date.\n', '    function initAtx(\n', '        address _proxy, \n', '        address _serviceController, \n', '        address _dataController, \n', '        uint _lockupDate\n', '    ) \n', '    onlyContractOwner \n', '    public \n', '    returns (bool) \n', '    {\n', '        require(_serviceController != 0x0);\n', '        require(_dataController != 0x0);\n', '        require(_proxy != 0x0);\n', '        require(_lockupDate > now || _lockupDate == 0);\n', '\n', '        if (!super.init(ATxProxy(_proxy))) {\n', '            return false;\n', '        }\n', '\n', '        serviceController = ServiceController(_serviceController);\n', '        dataController = DataController(_dataController);\n', '        lockupDate = _lockupDate;\n', '        return true;\n', '    }\n', '\n', '    /// @notice Performs transfer call on the platform by the name of specified sender.\n', '    ///\n', '    /// @dev Can only be called by proxy asset.\n', '    ///\n', '    /// @param _to holder address to give to.\n', '    /// @param _value amount to transfer.\n', '    /// @param _reference transfer comment to be included in a platform&#39;s Transfer event.\n', '    /// @param _sender initial caller.\n', '    ///\n', '    /// @return success.\n', '    function __transferWithReference(\n', '        address _to, \n', '        uint _value, \n', '        string _reference, \n', '        address _sender\n', '    ) \n', '    onlyProxy \n', '    public \n', '    returns (bool) \n', '    {\n', '        var (_fromRole, _toRole) = _getParticipantRoles(_sender, _to);\n', '\n', '        if (!_checkTransferAllowance(_to, _toRole, _value, _sender, _fromRole)) {\n', '            return false;\n', '        }\n', '\n', '        if (!_isValidCountryLimits(_to, _toRole, _value, _sender, _fromRole)) {\n', '            return false;\n', '        }\n', '\n', '        if (!super.__transferWithReference(_to, _value, _reference, _sender)) {\n', '            return false;\n', '        }\n', '\n', '        _updateTransferLimits(_to, _toRole, _value, _sender, _fromRole);\n', '        _contractFallbackERC223(_sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Performs allowance transfer call on the platform by the name of specified sender.\n', '    ///\n', '    /// @dev Can only be called by proxy asset.\n', '    ///\n', '    /// @param _from holder address to take from.\n', '    /// @param _to holder address to give to.\n', '    /// @param _value amount to transfer.\n', '    /// @param _reference transfer comment to be included in a platform&#39;s Transfer event.\n', '    /// @param _sender initial caller.\n', '    ///\n', '    /// @return success.\n', '    function __transferFromWithReference(\n', '        address _from, \n', '        address _to, \n', '        uint _value, \n', '        string _reference, \n', '        address _sender\n', '    ) \n', '    public \n', '    onlyProxy \n', '    returns (bool) \n', '    {\n', '        var (_fromRole, _toRole) = _getParticipantRoles(_from, _to);\n', '\n', '        // @note Special check for operational withdraw.\n', '        bool _isTransferFromHolderToContractOwner = (_fromRole == Roles.Holder) && \n', '            (contractOwner == _to) && \n', '            (dataController.allowance(_from) >= _value) && \n', '            super.__transferFromWithReference(_from, _to, _value, _reference, _sender);\n', '        if (_isTransferFromHolderToContractOwner) {\n', '            return true;\n', '        }\n', '\n', '        if (!_checkTransferAllowanceFrom(_to, _toRole, _value, _from, _fromRole, _sender)) {\n', '            return false;\n', '        }\n', '\n', '        if (!_isValidCountryLimits(_to, _toRole, _value, _from, _fromRole)) {\n', '            return false;\n', '        }\n', '\n', '        if (!super.__transferFromWithReference(_from, _to, _value, _reference, _sender)) {\n', '            return false;\n', '        }\n', '\n', '        _updateTransferLimits(_to, _toRole, _value, _from, _fromRole);\n', '        _contractFallbackERC223(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* INTERNAL */\n', '\n', '    function _contractFallbackERC223(address _from, address _to, uint _value) internal {\n', '        uint _codeLength;\n', '        assembly {\n', '            _codeLength := extcodesize(_to)\n', '        }\n', '\n', '        if (_codeLength > 0) {\n', '            ERC223ReceivingInterface _receiver = ERC223ReceivingInterface(_to);\n', '            bytes memory _empty;\n', '            _receiver.tokenFallback(_from, _value, _empty);\n', '        }\n', '    }\n', '\n', '    function _isTokenActive() internal view returns (bool) {\n', '        return now > lockupDate;\n', '    }\n', '\n', '    function _checkTransferAllowance(address _to, Roles _toRole, uint _value, address _from, Roles _fromRole) internal view returns (bool) {\n', '        if (_to == proxy) {\n', '            return false;\n', '        }\n', '\n', '        bool _canTransferFromService = _fromRole == Roles.Service && ServiceAllowance(_from).isTransferAllowed(_from, _to, _from, proxy, _value);\n', '        bool _canTransferToService = _toRole == Roles.Service && ServiceAllowance(_to).isTransferAllowed(_from, _to, _from, proxy, _value);\n', '        bool _canTransferToHolder = _toRole == Roles.Holder && _couldDepositToHolder(_to, _value);\n', '\n', '        bool _canTransferFromHolder;\n', '\n', '        if (_isTokenActive()) {\n', '            _canTransferFromHolder = _fromRole == Roles.Holder && _couldWithdrawFromHolder(_from, _value);\n', '        } else {\n', '            _canTransferFromHolder = _fromRole == Roles.Holder && _couldWithdrawFromHolder(_from, _value) && _from == contractOwner;\n', '        }\n', '\n', '        return (_canTransferFromHolder || _canTransferFromService) && (_canTransferToHolder || _canTransferToService);\n', '    }\n', '\n', '    function _checkTransferAllowanceFrom(\n', '        address _to, \n', '        Roles _toRole, \n', '        uint _value, \n', '        address _from, \n', '        Roles _fromRole, \n', '        address\n', '    ) \n', '    internal \n', '    view \n', '    returns (bool) \n', '    {\n', '        return _checkTransferAllowance(_to, _toRole, _value, _from, _fromRole);\n', '    }\n', '\n', '    function _isValidWithdrawLimits(uint _sendLimPerDay, uint _sendLimPerMonth, uint _value) internal pure returns (bool) {\n', '        return !(_value > _sendLimPerDay || _value > _sendLimPerMonth);\n', '    }\n', '\n', '    function _isValidDepositCountry(\n', '        uint _value,\n', '        uint _withdrawCountryCode,\n', '        uint _withdrawBalance,\n', '        uint _countryCode,\n', '        uint _balance,\n', '        uint _currentHolderCount,\n', '        uint _maxHolderNumber\n', '    )\n', '    internal\n', '    pure\n', '    returns (bool)\n', '    {\n', '        return _isNoNeedInCountryLimitChange(_value, _withdrawCountryCode, _withdrawBalance, _countryCode, _balance, _currentHolderCount, _maxHolderNumber)\n', '        ? true\n', '        : _isValidDepositCountry(_balance, _currentHolderCount, _maxHolderNumber);\n', '    }\n', '\n', '    function _isNoNeedInCountryLimitChange(\n', '        uint _value,\n', '        uint _withdrawCountryCode,\n', '        uint _withdrawBalance,\n', '        uint _countryCode,\n', '        uint _balance,\n', '        uint _currentHolderCount,\n', '        uint _maxHolderNumber\n', '    )\n', '    internal\n', '    pure\n', '    returns (bool)\n', '    {\n', '        bool _needToIncrementCountryHolderCount = _balance == 0;\n', '        bool _needToDecrementCountryHolderCount = _withdrawBalance == _value;\n', '        bool _shouldOverflowCountryHolderCount = _currentHolderCount == _maxHolderNumber;\n', '\n', '        return _withdrawCountryCode == _countryCode && _needToDecrementCountryHolderCount && _needToIncrementCountryHolderCount && _shouldOverflowCountryHolderCount;\n', '    }\n', '\n', '    function _updateCountries(\n', '        uint _value,\n', '        uint _withdrawCountryCode,\n', '        uint _withdrawBalance,\n', '        uint _withdrawCurrentHolderCount,\n', '        uint _countryCode,\n', '        uint _balance,\n', '        uint _currentHolderCount,\n', '        uint _maxHolderNumber\n', '    )\n', '    internal\n', '    {\n', '        if (_isNoNeedInCountryLimitChange(_value, _withdrawCountryCode, _withdrawBalance, _countryCode, _balance, _currentHolderCount, _maxHolderNumber)) {\n', '            return;\n', '        }\n', '\n', '        _updateWithdrawCountry(_value, _withdrawCountryCode, _withdrawBalance, _withdrawCurrentHolderCount);\n', '        _updateDepositCountry(_countryCode, _balance, _currentHolderCount);\n', '    }\n', '\n', '    function _updateWithdrawCountry(\n', '        uint _value,\n', '        uint _countryCode,\n', '        uint _balance,\n', '        uint _currentHolderCount\n', '    )\n', '    internal\n', '    {\n', '        if (_value == _balance && OK != dataController.updateCountryHoldersCount(_countryCode, _currentHolderCount.sub(1))) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function _updateDepositCountry(\n', '        uint _countryCode,\n', '        uint _balance,\n', '        uint _currentHolderCount\n', '    )\n', '    internal\n', '    {\n', '        if (_balance == 0 && OK != dataController.updateCountryHoldersCount(_countryCode, _currentHolderCount.add(1))) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function _getParticipantRoles(address _from, address _to) private view returns (Roles _fromRole, Roles _toRole) {\n', '        _fromRole = dataController.isRegisteredAddress(_from) ? Roles.Holder : (serviceController.isService(_from) ? Roles.Service : Roles.Other);\n', '        _toRole = dataController.isRegisteredAddress(_to) ? Roles.Holder : (serviceController.isService(_to) ? Roles.Service : Roles.Other);\n', '    }\n', '\n', '    function _couldWithdrawFromHolder(address _holder, uint _value) private view returns (bool) {\n', '        bytes32 _holderId = dataController.getHolderExternalIdByAddress(_holder);\n', '        var (, _limPerDay, _limPerMonth, _operational,) = dataController.getHolderInfo(_holderId);\n', '        return _operational ? _isValidWithdrawLimits(_limPerDay, _limPerMonth, _value) : false;\n', '    }\n', '\n', '    function _couldDepositToHolder(address _holder, uint) private view returns (bool) {\n', '        bytes32 _holderId = dataController.getHolderExternalIdByAddress(_holder);\n', '        var (,,, _operational,) = dataController.getHolderInfo(_holderId);\n', '        return _operational;\n', '    }\n', '\n', '    //TODO need additional check: not clear check of country limit:\n', '    function _isValidDepositCountry(uint _balance, uint _currentHolderCount, uint _maxHolderNumber) private pure returns (bool) {\n', '        return !(_balance == 0 && _currentHolderCount == _maxHolderNumber);\n', '    }\n', '\n', '    function _getHoldersInfo(address _to, Roles _toRole, uint, address _from, Roles _fromRole)\n', '    private\n', '    view\n', '    returns (\n', '        uint _fromCountryCode,\n', '        uint _fromBalance,\n', '        uint _toCountryCode,\n', '        uint _toCountryCurrentHolderCount,\n', '        uint _toCountryMaxHolderNumber,\n', '        uint _toBalance\n', '    ) {\n', '        bytes32 _holderId;\n', '        if (_toRole == Roles.Holder) {\n', '            _holderId = dataController.getHolderExternalIdByAddress(_to);\n', '            _toCountryCode = dataController.getHolderCountryCode(_holderId);\n', '            (_toCountryCurrentHolderCount, _toCountryMaxHolderNumber) = dataController.getCountryInfo(_toCountryCode);\n', '            _toBalance = ERC20Interface(proxy).balanceOf(_to);\n', '        }\n', '\n', '        if (_fromRole == Roles.Holder) {\n', '            _holderId = dataController.getHolderExternalIdByAddress(_from);\n', '            _fromCountryCode = dataController.getHolderCountryCode(_holderId);\n', '            _fromBalance = ERC20Interface(proxy).balanceOf(_from);\n', '        }\n', '    }\n', '\n', '    function _isValidCountryLimits(address _to, Roles _toRole, uint _value, address _from, Roles _fromRole) private view returns (bool) {\n', '        var (\n', '        _fromCountryCode,\n', '        _fromBalance,\n', '        _toCountryCode,\n', '        _toCountryCurrentHolderCount,\n', '        _toCountryMaxHolderNumber,\n', '        _toBalance\n', '        ) = _getHoldersInfo(_to, _toRole, _value, _from, _fromRole);\n', '\n', '        //TODO not clear for which case this check\n', '        bool _isValidLimitFromHolder = _fromRole == _toRole && _fromRole == Roles.Holder && !_isValidDepositCountry(_value, _fromCountryCode, _fromBalance, _toCountryCode, _toBalance, _toCountryCurrentHolderCount, _toCountryMaxHolderNumber);\n', '        bool _isValidLimitsToHolder = _toRole == Roles.Holder && !_isValidDepositCountry(_toBalance, _toCountryCurrentHolderCount, _toCountryMaxHolderNumber);\n', '\n', '        return !(_isValidLimitFromHolder || _isValidLimitsToHolder);\n', '    }\n', '\n', '    function _updateTransferLimits(address _to, Roles _toRole, uint _value, address _from, Roles _fromRole) private {\n', '        var (\n', '        _fromCountryCode,\n', '        _fromBalance,\n', '        _toCountryCode,\n', '        _toCountryCurrentHolderCount,\n', '        _toCountryMaxHolderNumber,\n', '        _toBalance\n', '        ) = _getHoldersInfo(_to, _toRole, _value, _from, _fromRole);\n', '\n', '        if (_fromRole == Roles.Holder && OK != dataController.withdrawFrom(_from, _value)) {\n', '            revert();\n', '        }\n', '\n', '        if (_toRole == Roles.Holder && OK != dataController.depositTo(_from, _value)) {\n', '            revert();\n', '        }\n', '\n', '        uint _fromCountryCurrentHolderCount;\n', '        if (_fromRole == Roles.Holder && _fromRole == _toRole) {\n', '            (_fromCountryCurrentHolderCount,) = dataController.getCountryInfo(_fromCountryCode);\n', '            _updateCountries(\n', '                _value,\n', '                _fromCountryCode,\n', '                _fromBalance,\n', '                _fromCountryCurrentHolderCount,\n', '                _toCountryCode,\n', '                _toBalance,\n', '                _toCountryCurrentHolderCount,\n', '                _toCountryMaxHolderNumber\n', '            );\n', '        } else if (_fromRole == Roles.Holder) {\n', '            (_fromCountryCurrentHolderCount,) = dataController.getCountryInfo(_fromCountryCode);\n', '            _updateWithdrawCountry(_value, _fromCountryCode, _fromBalance, _fromCountryCurrentHolderCount);\n', '        } else if (_toRole == Roles.Holder) {\n', '            _updateDepositCountry(_toCountryCode, _toBalance, _toCountryCurrentHolderCount);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title ATx Asset implementation contract.\n', '///\n', '/// Basic asset implementation contract, without any additional logic.\n', '/// Every other asset implementation contracts should derive from this one.\n', '/// Receives calls from the proxy, and calls back immediately without arguments modification.\n', '///\n', '/// Note: all the non constant functions return false instead of throwing in case if state change\n', '/// didn&#39;t happen yet.\n', 'contract EEMAsset is ATxAsset {\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title Owned contract with safe ownership pass.\n', ' *\n', ' * Note: all the non constant functions return false instead of throwing in case if state change\n', " * didn't happen yet.\n", ' */\n', 'contract Owned {\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public contractOwner;\n', '\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public pendingContractOwner;\n', '\n', '    function Owned() {\n', '        contractOwner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner check modifier\n', '    */\n', '    modifier onlyContractOwner() {\n', '        if (contractOwner == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Destroy contract and scrub a data\n', '     * @notice Only owner can call it\n', '     */\n', '    function destroy() onlyContractOwner {\n', '        suicide(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Prepares ownership pass.\n', '     *\n', '     * Can only be called by current owner.\n', '     *\n', '     * @param _to address of the next owner. 0x0 is not allowed.\n', '     *\n', '     * @return success.\n', '     */\n', '    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\n', '        if (_to  == 0x0) {\n', '            return false;\n', '        }\n', '\n', '        pendingContractOwner = _to;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Finalize ownership pass.\n', '     *\n', '     * Can only be called by pending owner.\n', '     *\n', '     * @return success.\n', '     */\n', '    function claimContractOwnership() returns(bool) {\n', '        if (pendingContractOwner != msg.sender) {\n', '            return false;\n', '        }\n', '\n', '        contractOwner = pendingContractOwner;\n', '        delete pendingContractOwner;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '    string public symbol;\n', '\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', '\n', '\n', 'contract ATxProxy is ERC20 {\n', '    \n', '    bytes32 public smbl;\n', '    address public platform;\n', '\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __approve(address _spender, uint _value, address _sender) public returns (bool);\n', '    function getLatestVersion() public returns (address);\n', '    function init(address _bmcPlatform, string _symbol, string _name) public;\n', '    function proposeUpgrade(address _newVersion) public;\n', '}\n', '\n', '/// @title Provides possibility manage holders? country limits and limits for holders.\n', 'contract DataControllerInterface {\n', '\n', '    /// @notice Checks user is holder.\n', '    /// @param _address - checking address.\n', '    /// @return `true` if _address is registered holder, `false` otherwise.\n', '    function isHolderAddress(address _address) public view returns (bool);\n', '\n', '    function allowance(address _user) public view returns (uint);\n', '\n', '    function changeAllowance(address _holder, uint _value) public returns (uint);\n', '}\n', '/// @title ServiceController\n', '///\n', '/// Base implementation\n', '/// Serves for managing service instances\n', 'contract ServiceControllerInterface {\n', '\n', '    /// @notice Check target address is service\n', '    /// @param _address target address\n', '    /// @return `true` when an address is a service, `false` otherwise\n', '    function isService(address _address) public view returns (bool);\n', '}\n', '\n', '\n', '\n', 'contract ATxAssetInterface {\n', '\n', '    DataControllerInterface public dataController;\n', '    ServiceControllerInterface public serviceController;\n', '\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __approve(address _spender, uint _value, address _sender) public returns (bool);\n', '    function __process(bytes /*_data*/, address /*_sender*/) payable public {\n', '        revert();\n', '    }\n', '}\n', '\n', 'contract AssetProxy is ERC20 {\n', '    \n', '    bytes32 public smbl;\n', '    address public platform;\n', '\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __approve(address _spender, uint _value, address _sender) public returns (bool);\n', '    function getLatestVersion() public returns (address);\n', '    function init(address _bmcPlatform, string _symbol, string _name) public;\n', '    function proposeUpgrade(address _newVersion) public;\n', '}\n', '\n', '\n', 'contract BasicAsset is ATxAssetInterface {\n', '\n', '    // Assigned asset proxy contract, immutable.\n', '    address public proxy;\n', '\n', '    /**\n', '     * Only assigned proxy is allowed to call.\n', '     */\n', '    modifier onlyProxy() {\n', '        if (proxy == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Sets asset proxy address.\n', '     *\n', '     * Can be set only once.\n', '     *\n', '     * @param _proxy asset proxy contract address.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function init(address _proxy) public returns (bool) {\n', '        if (address(proxy) != 0x0) {\n', '            return false;\n', '        }\n', '        proxy = _proxy;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Passes execution into virtual function.\n', '     *\n', '     * Can only be called by assigned asset proxy.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public onlyProxy returns (bool) {\n', '        return _transferWithReference(_to, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Passes execution into virtual function.\n', '     *\n', '     * Can only be called by assigned asset proxy.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public onlyProxy returns (bool) {\n', '        return _transferFromWithReference(_from, _to, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Passes execution into virtual function.\n', '     *\n', '     * Can only be called by assigned asset proxy.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function __approve(address _spender, uint _value, address _sender) public onlyProxy returns (bool) {\n', '        return _approve(_spender, _value, _sender);\n', '    }\n', '\n', '    /**\n', '     * Calls back without modifications.\n', '     *\n', '     * @return success.\n', '     * @dev function is virtual, and meant to be overridden.\n', '     */\n', '    function _transferWithReference(address _to, uint _value, string _reference, address _sender) internal returns (bool) {\n', '        return AssetProxy(proxy).__transferWithReference(_to, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Calls back without modifications.\n', '     *\n', '     * @return success.\n', '     * @dev function is virtual, and meant to be overridden.\n', '     */\n', '    function _transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) internal returns (bool) {\n', '        return AssetProxy(proxy).__transferFromWithReference(_from, _to, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Calls back without modifications.\n', '     *\n', '     * @return success.\n', '     * @dev function is virtual, and meant to be overridden.\n', '     */\n', '    function _approve(address _spender, uint _value, address _sender) internal returns (bool) {\n', '        return AssetProxy(proxy).__approve(_spender, _value, _sender);\n', '    }\n', '}\n', '\n', '\n', '/// @title ServiceAllowance.\n', '///\n', '/// Provides a way to delegate operation allowance decision to a service contract\n', 'contract ServiceAllowance {\n', '    function isTransferAllowed(address _from, address _to, address _sender, address _token, uint _value) public view returns (bool);\n', '}\n', '\n', 'contract ERC20Interface {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '    string public symbol;\n', '\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', '\n', '/**\n', ' * @title Generic owned destroyable contract\n', ' */\n', 'contract Object is Owned {\n', '    /**\n', '    *  Common result code. Means everything is fine.\n', '    */\n', '    uint constant OK = 1;\n', '    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\n', '\n', '    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\n', '        for(uint i=0;i<tokens.length;i++) {\n', '            address token = tokens[i];\n', '            uint balance = ERC20Interface(token).balanceOf(this);\n', '            if(balance != 0)\n', '                ERC20Interface(token).transfer(_to,balance);\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    function checkOnlyContractOwner() internal constant returns(uint) {\n', '        if (contractOwner == msg.sender) {\n', '            return OK;\n', '        }\n', '\n', '        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\n', '    }\n', '}\n', '\n', 'contract GroupsAccessManagerEmitter {\n', '\n', '    event UserCreated(address user);\n', '    event UserDeleted(address user);\n', '    event GroupCreated(bytes32 groupName);\n', '    event GroupActivated(bytes32 groupName);\n', '    event GroupDeactivated(bytes32 groupName);\n', '    event UserToGroupAdded(address user, bytes32 groupName);\n', '    event UserFromGroupRemoved(address user, bytes32 groupName);\n', '}\n', '\n', '\n', '/// @title Group Access Manager\n', '///\n', '/// Base implementation\n', '/// This contract serves as group manager\n', 'contract GroupsAccessManager is Object, GroupsAccessManagerEmitter {\n', '\n', '    uint constant USER_MANAGER_SCOPE = 111000;\n', '    uint constant USER_MANAGER_MEMBER_ALREADY_EXIST = USER_MANAGER_SCOPE + 1;\n', '    uint constant USER_MANAGER_GROUP_ALREADY_EXIST = USER_MANAGER_SCOPE + 2;\n', '    uint constant USER_MANAGER_OBJECT_ALREADY_SECURED = USER_MANAGER_SCOPE + 3;\n', '    uint constant USER_MANAGER_CONFIRMATION_HAS_COMPLETED = USER_MANAGER_SCOPE + 4;\n', '    uint constant USER_MANAGER_USER_HAS_CONFIRMED = USER_MANAGER_SCOPE + 5;\n', '    uint constant USER_MANAGER_NOT_ENOUGH_GAS = USER_MANAGER_SCOPE + 6;\n', '    uint constant USER_MANAGER_INVALID_INVOCATION = USER_MANAGER_SCOPE + 7;\n', '    uint constant USER_MANAGER_DONE = USER_MANAGER_SCOPE + 11;\n', '    uint constant USER_MANAGER_CANCELLED = USER_MANAGER_SCOPE + 12;\n', '\n', '    using SafeMath for uint;\n', '\n', '    struct Member {\n', '        address addr;\n', '        uint groupsCount;\n', '        mapping(bytes32 => uint) groupName2index;\n', '        mapping(uint => uint) index2globalIndex;\n', '    }\n', '\n', '    struct Group {\n', '        bytes32 name;\n', '        uint priority;\n', '        uint membersCount;\n', '        mapping(address => uint) memberAddress2index;\n', '        mapping(uint => uint) index2globalIndex;\n', '    }\n', '\n', '    uint public membersCount;\n', '    mapping(uint => address) index2memberAddress;\n', '    mapping(address => uint) memberAddress2index;\n', '    mapping(address => Member) address2member;\n', '\n', '    uint public groupsCount;\n', '    mapping(uint => bytes32) index2groupName;\n', '    mapping(bytes32 => uint) groupName2index;\n', '    mapping(bytes32 => Group) groupName2group;\n', "    mapping(bytes32 => bool) public groupsBlocked; // if groupName => true, then couldn't be used for confirmation\n", '\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    /// @notice Register user\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _user user address\n', '    ///\n', '    /// @return code\n', '    function registerUser(address _user) external onlyContractOwner returns (uint) {\n', '        require(_user != 0x0);\n', '\n', '        if (isRegisteredUser(_user)) {\n', '            return USER_MANAGER_MEMBER_ALREADY_EXIST;\n', '        }\n', '\n', '        uint _membersCount = membersCount.add(1);\n', '        membersCount = _membersCount;\n', '        memberAddress2index[_user] = _membersCount;\n', '        index2memberAddress[_membersCount] = _user;\n', '        address2member[_user] = Member(_user, 0);\n', '\n', '        UserCreated(_user);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Discard user registration\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _user user address\n', '    ///\n', '    /// @return code\n', '    function unregisterUser(address _user) external onlyContractOwner returns (uint) {\n', '        require(_user != 0x0);\n', '\n', '        uint _memberIndex = memberAddress2index[_user];\n', '        if (_memberIndex == 0 || address2member[_user].groupsCount != 0) {\n', '            return USER_MANAGER_INVALID_INVOCATION;\n', '        }\n', '\n', '        uint _membersCount = membersCount;\n', '        delete memberAddress2index[_user];\n', '        if (_memberIndex != _membersCount) {\n', '            address _lastUser = index2memberAddress[_membersCount];\n', '            index2memberAddress[_memberIndex] = _lastUser;\n', '            memberAddress2index[_lastUser] = _memberIndex;\n', '        }\n', '        delete address2member[_user];\n', '        delete index2memberAddress[_membersCount];\n', '        delete memberAddress2index[_user];\n', '        membersCount = _membersCount.sub(1);\n', '\n', '        UserDeleted(_user);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Create group\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _groupName group name\n', '    /// @param _priority group priority\n', '    ///\n', '    /// @return code\n', '    function createGroup(bytes32 _groupName, uint _priority) external onlyContractOwner returns (uint) {\n', '        require(_groupName != bytes32(0));\n', '\n', '        if (isGroupExists(_groupName)) {\n', '            return USER_MANAGER_GROUP_ALREADY_EXIST;\n', '        }\n', '\n', '        uint _groupsCount = groupsCount.add(1);\n', '        groupName2index[_groupName] = _groupsCount;\n', '        index2groupName[_groupsCount] = _groupName;\n', '        groupName2group[_groupName] = Group(_groupName, _priority, 0);\n', '        groupsCount = _groupsCount;\n', '\n', '        GroupCreated(_groupName);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Change group status\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _groupName group name\n', '    /// @param _blocked block status\n', '    ///\n', '    /// @return code\n', '    function changeGroupActiveStatus(bytes32 _groupName, bool _blocked) external onlyContractOwner returns (uint) {\n', '        require(isGroupExists(_groupName));\n', '        groupsBlocked[_groupName] = _blocked;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Add users in group\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _groupName group name\n', '    /// @param _users user array\n', '    ///\n', '    /// @return code\n', '    function addUsersToGroup(bytes32 _groupName, address[] _users) external onlyContractOwner returns (uint) {\n', '        require(isGroupExists(_groupName));\n', '\n', '        Group storage _group = groupName2group[_groupName];\n', '        uint _groupMembersCount = _group.membersCount;\n', '\n', '        for (uint _userIdx = 0; _userIdx < _users.length; ++_userIdx) {\n', '            address _user = _users[_userIdx];\n', '            uint _memberIndex = memberAddress2index[_user];\n', '            require(_memberIndex != 0);\n', '\n', '            if (_group.memberAddress2index[_user] != 0) {\n', '                continue;\n', '            }\n', '\n', '            _groupMembersCount = _groupMembersCount.add(1);\n', '            _group.memberAddress2index[_user] = _groupMembersCount;\n', '            _group.index2globalIndex[_groupMembersCount] = _memberIndex;\n', '\n', '            _addGroupToMember(_user, _groupName);\n', '\n', '            UserToGroupAdded(_user, _groupName);\n', '        }\n', '        _group.membersCount = _groupMembersCount;\n', '\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Remove users in group\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _groupName group name\n', '    /// @param _users user array\n', '    ///\n', '    /// @return code\n', '    function removeUsersFromGroup(bytes32 _groupName, address[] _users) external onlyContractOwner returns (uint) {\n', '        require(isGroupExists(_groupName));\n', '\n', '        Group storage _group = groupName2group[_groupName];\n', '        uint _groupMembersCount = _group.membersCount;\n', '\n', '        for (uint _userIdx = 0; _userIdx < _users.length; ++_userIdx) {\n', '            address _user = _users[_userIdx];\n', '            uint _memberIndex = memberAddress2index[_user];\n', '            uint _groupMemberIndex = _group.memberAddress2index[_user];\n', '\n', '            if (_memberIndex == 0 || _groupMemberIndex == 0) {\n', '                continue;\n', '            }\n', '\n', '            if (_groupMemberIndex != _groupMembersCount) {\n', '                uint _lastUserGlobalIndex = _group.index2globalIndex[_groupMembersCount];\n', '                address _lastUser = index2memberAddress[_lastUserGlobalIndex];\n', '                _group.index2globalIndex[_groupMemberIndex] = _lastUserGlobalIndex;\n', '                _group.memberAddress2index[_lastUser] = _groupMemberIndex;\n', '            }\n', '            delete _group.memberAddress2index[_user];\n', '            delete _group.index2globalIndex[_groupMembersCount];\n', '            _groupMembersCount = _groupMembersCount.sub(1);\n', '\n', '            _removeGroupFromMember(_user, _groupName);\n', '\n', '            UserFromGroupRemoved(_user, _groupName);\n', '        }\n', '        _group.membersCount = _groupMembersCount;\n', '\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Check is user registered\n', '    ///\n', '    /// @param _user user address\n', '    ///\n', '    /// @return status\n', '    function isRegisteredUser(address _user) public view returns (bool) {\n', '        return memberAddress2index[_user] != 0;\n', '    }\n', '\n', '    /// @notice Check is user in group\n', '    ///\n', '    /// @param _groupName user array\n', '    /// @param _user user array\n', '    ///\n', '    /// @return status\n', '    function isUserInGroup(bytes32 _groupName, address _user) public view returns (bool) {\n', '        return isRegisteredUser(_user) && address2member[_user].groupName2index[_groupName] != 0;\n', '    }\n', '\n', '    /// @notice Check is group exist\n', '    ///\n', '    /// @param _groupName group name\n', '    ///\n', '    /// @return status\n', '    function isGroupExists(bytes32 _groupName) public view returns (bool) {\n', '        return groupName2index[_groupName] != 0;\n', '    }\n', '\n', '    /// @notice Get current group names\n', '    ///\n', '    /// @return group names\n', '    function getGroups() public view returns (bytes32[] _groups) {\n', '        uint _groupsCount = groupsCount;\n', '        _groups = new bytes32[](_groupsCount);\n', '        for (uint _groupIdx = 0; _groupIdx < _groupsCount; ++_groupIdx) {\n', '            _groups[_groupIdx] = index2groupName[_groupIdx + 1];\n', '        }\n', '    }\n', '\n', '    // PRIVATE\n', '\n', '    function _removeGroupFromMember(address _user, bytes32 _groupName) private {\n', '        Member storage _member = address2member[_user];\n', '        uint _memberGroupsCount = _member.groupsCount;\n', '        uint _memberGroupIndex = _member.groupName2index[_groupName];\n', '        if (_memberGroupIndex != _memberGroupsCount) {\n', '            uint _lastGroupGlobalIndex = _member.index2globalIndex[_memberGroupsCount];\n', '            bytes32 _lastGroupName = index2groupName[_lastGroupGlobalIndex];\n', '            _member.index2globalIndex[_memberGroupIndex] = _lastGroupGlobalIndex;\n', '            _member.groupName2index[_lastGroupName] = _memberGroupIndex;\n', '        }\n', '        delete _member.groupName2index[_groupName];\n', '        delete _member.index2globalIndex[_memberGroupsCount];\n', '        _member.groupsCount = _memberGroupsCount.sub(1);\n', '    }\n', '\n', '    function _addGroupToMember(address _user, bytes32 _groupName) private {\n', '        Member storage _member = address2member[_user];\n', '        uint _memberGroupsCount = _member.groupsCount.add(1);\n', '        _member.groupName2index[_groupName] = _memberGroupsCount;\n', '        _member.index2globalIndex[_memberGroupsCount] = groupName2index[_groupName];\n', '        _member.groupsCount = _memberGroupsCount;\n', '    }\n', '}\n', '\n', 'contract PendingManagerEmitter {\n', '\n', '    event PolicyRuleAdded(bytes4 sig, address contractAddress, bytes32 key, bytes32 groupName, uint acceptLimit, uint declinesLimit);\n', '    event PolicyRuleRemoved(bytes4 sig, address contractAddress, bytes32 key, bytes32 groupName);\n', '\n', '    event ProtectionTxAdded(bytes32 key, bytes32 sig, uint blockNumber);\n', '    event ProtectionTxAccepted(bytes32 key, address indexed sender, bytes32 groupNameVoted);\n', '    event ProtectionTxDone(bytes32 key);\n', '    event ProtectionTxDeclined(bytes32 key, address indexed sender, bytes32 groupNameVoted);\n', '    event ProtectionTxCancelled(bytes32 key);\n', '    event ProtectionTxVoteRevoked(bytes32 key, address indexed sender, bytes32 groupNameVoted);\n', '    event TxDeleted(bytes32 key);\n', '\n', '    event Error(uint errorCode);\n', '\n', '    function _emitError(uint _errorCode) internal returns (uint) {\n', '        Error(_errorCode);\n', '        return _errorCode;\n', '    }\n', '}\n', '\n', 'contract PendingManagerInterface {\n', '\n', '    function signIn(address _contract) external returns (uint);\n', '    function signOut(address _contract) external returns (uint);\n', '\n', '    function addPolicyRule(\n', '        bytes4 _sig, \n', '        address _contract, \n', '        bytes32 _groupName, \n', '        uint _acceptLimit, \n', '        uint _declineLimit \n', '        ) \n', '        external returns (uint);\n', '        \n', '    function removePolicyRule(\n', '        bytes4 _sig, \n', '        address _contract, \n', '        bytes32 _groupName\n', '        ) \n', '        external returns (uint);\n', '\n', '    function addTx(bytes32 _key, bytes4 _sig, address _contract) external returns (uint);\n', '    function deleteTx(bytes32 _key) external returns (uint);\n', '\n', '    function accept(bytes32 _key, bytes32 _votingGroupName) external returns (uint);\n', '    function decline(bytes32 _key, bytes32 _votingGroupName) external returns (uint);\n', '    function revoke(bytes32 _key) external returns (uint);\n', '\n', '    function hasConfirmedRecord(bytes32 _key) public view returns (uint);\n', '    function getPolicyDetails(bytes4 _sig, address _contract) public view returns (\n', '        bytes32[] _groupNames,\n', '        uint[] _acceptLimits,\n', '        uint[] _declineLimits,\n', '        uint _totalAcceptedLimit,\n', '        uint _totalDeclinedLimit\n', '        );\n', '}\n', '\n', '/// @title PendingManager\n', '///\n', '/// Base implementation\n', '/// This contract serves as pending manager for transaction status\n', 'contract PendingManager is Object, PendingManagerEmitter, PendingManagerInterface {\n', '\n', '    uint constant NO_RECORDS_WERE_FOUND = 4;\n', '    uint constant PENDING_MANAGER_SCOPE = 4000;\n', '    uint constant PENDING_MANAGER_INVALID_INVOCATION = PENDING_MANAGER_SCOPE + 1;\n', '    uint constant PENDING_MANAGER_HASNT_VOTED = PENDING_MANAGER_SCOPE + 2;\n', '    uint constant PENDING_DUPLICATE_TX = PENDING_MANAGER_SCOPE + 3;\n', '    uint constant PENDING_MANAGER_CONFIRMED = PENDING_MANAGER_SCOPE + 4;\n', '    uint constant PENDING_MANAGER_REJECTED = PENDING_MANAGER_SCOPE + 5;\n', '    uint constant PENDING_MANAGER_IN_PROCESS = PENDING_MANAGER_SCOPE + 6;\n', '    uint constant PENDING_MANAGER_TX_DOESNT_EXIST = PENDING_MANAGER_SCOPE + 7;\n', '    uint constant PENDING_MANAGER_TX_WAS_DECLINED = PENDING_MANAGER_SCOPE + 8;\n', '    uint constant PENDING_MANAGER_TX_WAS_NOT_CONFIRMED = PENDING_MANAGER_SCOPE + 9;\n', '    uint constant PENDING_MANAGER_INSUFFICIENT_GAS = PENDING_MANAGER_SCOPE + 10;\n', '    uint constant PENDING_MANAGER_POLICY_NOT_FOUND = PENDING_MANAGER_SCOPE + 11;\n', '\n', '    using SafeMath for uint;\n', '\n', '    enum GuardState {\n', '        Decline, Confirmed, InProcess\n', '    }\n', '\n', '    struct Requirements {\n', '        bytes32 groupName;\n', '        uint acceptLimit;\n', '        uint declineLimit;\n', '    }\n', '\n', '    struct Policy {\n', '        uint groupsCount;\n', '        mapping(uint => Requirements) participatedGroups; // index => globalGroupIndex\n', '        mapping(bytes32 => uint) groupName2index; // groupName => localIndex\n', '        \n', '        uint totalAcceptedLimit;\n', '        uint totalDeclinedLimit;\n', '\n', '        uint securesCount;\n', '        mapping(uint => uint) index2txIndex;\n', '        mapping(uint => uint) txIndex2index;\n', '    }\n', '\n', '    struct Vote {\n', '        bytes32 groupName;\n', '        bool accepted;\n', '    }\n', '\n', '    struct Guard {\n', '        GuardState state;\n', '        uint basePolicyIndex;\n', '\n', '        uint alreadyAccepted;\n', '        uint alreadyDeclined;\n', '        \n', '        mapping(address => Vote) votes; // member address => vote\n', '        mapping(bytes32 => uint) acceptedCount; // groupName => how many from group has already accepted\n', '        mapping(bytes32 => uint) declinedCount; // groupName => how many from group has already declined\n', '    }\n', '\n', '    address public accessManager;\n', '\n', '    mapping(address => bool) public authorized;\n', '\n', '    uint public policiesCount;\n', '    mapping(uint => bytes32) index2PolicyId; // index => policy hash\n', '    mapping(bytes32 => uint) policyId2Index; // policy hash => index\n', '    mapping(bytes32 => Policy) policyId2policy; // policy hash => policy struct\n', '\n', '    uint public txCount;\n', '    mapping(uint => bytes32) index2txKey;\n', '    mapping(bytes32 => uint) txKey2index; // tx key => index\n', '    mapping(bytes32 => Guard) txKey2guard;\n', '\n', '    /// @dev Execution is allowed only by authorized contract\n', '    modifier onlyAuthorized {\n', '        if (authorized[msg.sender] || address(this) == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', "    /// @dev Pending Manager's constructor\n", '    ///\n', "    /// @param _accessManager access manager's address\n", '    function PendingManager(address _accessManager) public {\n', '        require(_accessManager != 0x0);\n', '        accessManager = _accessManager;\n', '    }\n', '\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    /// @notice Update access manager address\n', '    ///\n', "    /// @param _accessManager access manager's address\n", '    function setAccessManager(address _accessManager) external onlyContractOwner returns (uint) {\n', '        require(_accessManager != 0x0);\n', '        accessManager = _accessManager;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Sign in contract\n', '    ///\n', "    /// @param _contract contract's address\n", '    function signIn(address _contract) external onlyContractOwner returns (uint) {\n', '        require(_contract != 0x0);\n', '        authorized[_contract] = true;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Sign out contract\n', '    ///\n', "    /// @param _contract contract's address\n", '    function signOut(address _contract) external onlyContractOwner returns (uint) {\n', '        require(_contract != 0x0);\n', '        delete authorized[_contract];\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Register new policy rule\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _sig target method signature\n', '    /// @param _contract target contract address\n', "    /// @param _groupName group's name\n", '    /// @param _acceptLimit accepted vote limit\n', '    /// @param _declineLimit decline vote limit\n', '    ///\n', '    /// @return code\n', '    function addPolicyRule(\n', '        bytes4 _sig,\n', '        address _contract,\n', '        bytes32 _groupName,\n', '        uint _acceptLimit,\n', '        uint _declineLimit\n', '    )\n', '    onlyContractOwner\n', '    external\n', '    returns (uint)\n', '    {\n', '        require(_sig != 0x0);\n', '        require(_contract != 0x0);\n', '        require(GroupsAccessManager(accessManager).isGroupExists(_groupName));\n', '        require(_acceptLimit != 0);\n', '        require(_declineLimit != 0);\n', '\n', '        bytes32 _policyHash = keccak256(_sig, _contract);\n', '        \n', '        if (policyId2Index[_policyHash] == 0) {\n', '            uint _policiesCount = policiesCount.add(1);\n', '            index2PolicyId[_policiesCount] = _policyHash;\n', '            policyId2Index[_policyHash] = _policiesCount;\n', '            policiesCount = _policiesCount;\n', '        }\n', '\n', '        Policy storage _policy = policyId2policy[_policyHash];\n', '        uint _policyGroupsCount = _policy.groupsCount;\n', '\n', '        if (_policy.groupName2index[_groupName] == 0) {\n', '            _policyGroupsCount += 1;\n', '            _policy.groupName2index[_groupName] = _policyGroupsCount;\n', '            _policy.participatedGroups[_policyGroupsCount].groupName = _groupName;\n', '            _policy.groupsCount = _policyGroupsCount;\n', '        }\n', '\n', '        uint _previousAcceptLimit = _policy.participatedGroups[_policyGroupsCount].acceptLimit;\n', '        uint _previousDeclineLimit = _policy.participatedGroups[_policyGroupsCount].declineLimit;\n', '        _policy.participatedGroups[_policyGroupsCount].acceptLimit = _acceptLimit;\n', '        _policy.participatedGroups[_policyGroupsCount].declineLimit = _declineLimit;\n', '        _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_previousAcceptLimit).add(_acceptLimit);\n', '        _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_previousDeclineLimit).add(_declineLimit);\n', '\n', '        PolicyRuleAdded(_sig, _contract, _policyHash, _groupName, _acceptLimit, _declineLimit);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Remove policy rule\n', '    /// Can be called only by contract owner\n', '    ///\n', "    /// @param _groupName group's name\n", '    ///\n', '    /// @return code\n', '    function removePolicyRule(\n', '        bytes4 _sig,\n', '        address _contract,\n', '        bytes32 _groupName\n', '    ) \n', '    onlyContractOwner \n', '    external \n', '    returns (uint) \n', '    {\n', '        require(_sig != bytes4(0));\n', '        require(_contract != 0x0);\n', '        require(GroupsAccessManager(accessManager).isGroupExists(_groupName));\n', '\n', '        bytes32 _policyHash = keccak256(_sig, _contract);\n', '        Policy storage _policy = policyId2policy[_policyHash];\n', '        uint _policyGroupNameIndex = _policy.groupName2index[_groupName];\n', '\n', '        if (_policyGroupNameIndex == 0) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        uint _policyGroupsCount = _policy.groupsCount;\n', '        if (_policyGroupNameIndex != _policyGroupsCount) {\n', '            Requirements storage _requirements = _policy.participatedGroups[_policyGroupsCount];\n', '            _policy.participatedGroups[_policyGroupNameIndex] = _requirements;\n', '            _policy.groupName2index[_requirements.groupName] = _policyGroupNameIndex;\n', '        }\n', '\n', '        _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_policy.participatedGroups[_policyGroupsCount].acceptLimit);\n', '        _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_policy.participatedGroups[_policyGroupsCount].declineLimit);\n', '\n', '        delete _policy.groupName2index[_groupName];\n', '        delete _policy.participatedGroups[_policyGroupsCount];\n', '        _policy.groupsCount = _policyGroupsCount.sub(1);\n', '\n', '        PolicyRuleRemoved(_sig, _contract, _policyHash, _groupName);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Add transaction\n', '    ///\n', '    /// @param _key transaction id\n', '    ///\n', '    /// @return code\n', '    function addTx(bytes32 _key, bytes4 _sig, address _contract) external onlyAuthorized returns (uint) {\n', '        require(_key != bytes32(0));\n', '        require(_sig != bytes4(0));\n', '        require(_contract != 0x0);\n', '\n', '        bytes32 _policyHash = keccak256(_sig, _contract);\n', '        require(isPolicyExist(_policyHash));\n', '\n', '        if (isTxExist(_key)) {\n', '            return _emitError(PENDING_DUPLICATE_TX);\n', '        }\n', '\n', '        if (_policyHash == bytes32(0)) {\n', '            return _emitError(PENDING_MANAGER_POLICY_NOT_FOUND);\n', '        }\n', '\n', '        uint _index = txCount.add(1);\n', '        txCount = _index;\n', '        index2txKey[_index] = _key;\n', '        txKey2index[_key] = _index;\n', '\n', '        Guard storage _guard = txKey2guard[_key];\n', '        _guard.basePolicyIndex = policyId2Index[_policyHash];\n', '        _guard.state = GuardState.InProcess;\n', '\n', '        Policy storage _policy = policyId2policy[_policyHash];\n', '        uint _counter = _policy.securesCount.add(1);\n', '        _policy.securesCount = _counter;\n', '        _policy.index2txIndex[_counter] = _index;\n', '        _policy.txIndex2index[_index] = _counter;\n', '\n', '        ProtectionTxAdded(_key, _policyHash, block.number);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Delete transaction\n', '    /// @param _key transaction id\n', '    /// @return code\n', '    function deleteTx(bytes32 _key) external onlyContractOwner returns (uint) {\n', '        require(_key != bytes32(0));\n', '\n', '        if (!isTxExist(_key)) {\n', '            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n', '        }\n', '\n', '        uint _txsCount = txCount;\n', '        uint _txIndex = txKey2index[_key];\n', '        if (_txIndex != _txsCount) {\n', '            bytes32 _last = index2txKey[txCount];\n', '            index2txKey[_txIndex] = _last;\n', '            txKey2index[_last] = _txIndex;\n', '        }\n', '\n', '        delete txKey2index[_key];\n', '        delete index2txKey[_txsCount];\n', '        txCount = _txsCount.sub(1);\n', '\n', '        uint _basePolicyIndex = txKey2guard[_key].basePolicyIndex;\n', '        Policy storage _policy = policyId2policy[index2PolicyId[_basePolicyIndex]];\n', '        uint _counter = _policy.securesCount;\n', '        uint _policyTxIndex = _policy.txIndex2index[_txIndex];\n', '        if (_policyTxIndex != _counter) {\n', '            uint _movedTxIndex = _policy.index2txIndex[_counter];\n', '            _policy.index2txIndex[_policyTxIndex] = _movedTxIndex;\n', '            _policy.txIndex2index[_movedTxIndex] = _policyTxIndex;\n', '        }\n', '\n', '        delete _policy.index2txIndex[_counter];\n', '        delete _policy.txIndex2index[_txIndex];\n', '        _policy.securesCount = _counter.sub(1);\n', '\n', '        TxDeleted(_key);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Accept transaction\n', '    /// Can be called only by registered user in GroupsAccessManager\n', '    ///\n', '    /// @param _key transaction id\n', '    ///\n', '    /// @return code\n', '    function accept(bytes32 _key, bytes32 _votingGroupName) external returns (uint) {\n', '        if (!isTxExist(_key)) {\n', '            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n', '        }\n', '\n', '        if (!GroupsAccessManager(accessManager).isUserInGroup(_votingGroupName, msg.sender)) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        Guard storage _guard = txKey2guard[_key];\n', '        if (_guard.state != GuardState.InProcess) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        if (_guard.votes[msg.sender].groupName != bytes32(0) && _guard.votes[msg.sender].accepted) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        Policy storage _policy = policyId2policy[index2PolicyId[_guard.basePolicyIndex]];\n', '        uint _policyGroupIndex = _policy.groupName2index[_votingGroupName];\n', '        uint _groupAcceptedVotesCount = _guard.acceptedCount[_votingGroupName];\n', '        if (_groupAcceptedVotesCount == _policy.participatedGroups[_policyGroupIndex].acceptLimit) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        _guard.votes[msg.sender] = Vote(_votingGroupName, true);\n', '        _guard.acceptedCount[_votingGroupName] = _groupAcceptedVotesCount + 1;\n', '        uint _alreadyAcceptedCount = _guard.alreadyAccepted + 1;\n', '        _guard.alreadyAccepted = _alreadyAcceptedCount;\n', '\n', '        ProtectionTxAccepted(_key, msg.sender, _votingGroupName);\n', '\n', '        if (_alreadyAcceptedCount == _policy.totalAcceptedLimit) {\n', '            _guard.state = GuardState.Confirmed;\n', '            ProtectionTxDone(_key);\n', '        }\n', '\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Decline transaction\n', '    /// Can be called only by registered user in GroupsAccessManager\n', '    ///\n', '    /// @param _key transaction id\n', '    ///\n', '    /// @return code\n', '    function decline(bytes32 _key, bytes32 _votingGroupName) external returns (uint) {\n', '        if (!isTxExist(_key)) {\n', '            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n', '        }\n', '\n', '        if (!GroupsAccessManager(accessManager).isUserInGroup(_votingGroupName, msg.sender)) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        Guard storage _guard = txKey2guard[_key];\n', '        if (_guard.state != GuardState.InProcess) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        if (_guard.votes[msg.sender].groupName != bytes32(0) && !_guard.votes[msg.sender].accepted) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        Policy storage _policy = policyId2policy[index2PolicyId[_guard.basePolicyIndex]];\n', '        uint _policyGroupIndex = _policy.groupName2index[_votingGroupName];\n', '        uint _groupDeclinedVotesCount = _guard.declinedCount[_votingGroupName];\n', '        if (_groupDeclinedVotesCount == _policy.participatedGroups[_policyGroupIndex].declineLimit) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        _guard.votes[msg.sender] = Vote(_votingGroupName, false);\n', '        _guard.declinedCount[_votingGroupName] = _groupDeclinedVotesCount + 1;\n', '        uint _alreadyDeclinedCount = _guard.alreadyDeclined + 1;\n', '        _guard.alreadyDeclined = _alreadyDeclinedCount;\n', '\n', '\n', '        ProtectionTxDeclined(_key, msg.sender, _votingGroupName);\n', '\n', '        if (_alreadyDeclinedCount == _policy.totalDeclinedLimit) {\n', '            _guard.state = GuardState.Decline;\n', '            ProtectionTxCancelled(_key);\n', '        }\n', '\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Revoke user votes for transaction\n', '    /// Can be called only by contract owner\n', '    ///\n', '    /// @param _key transaction id\n', '    /// @param _user target user address\n', '    ///\n', '    /// @return code\n', '    function forceRejectVotes(bytes32 _key, address _user) external onlyContractOwner returns (uint) {\n', '        return _revoke(_key, _user);\n', '    }\n', '\n', '    /// @notice Revoke vote for transaction\n', '    /// Can be called only by authorized user\n', '    /// @param _key transaction id\n', '    /// @return code\n', '    function revoke(bytes32 _key) external returns (uint) {\n', '        return _revoke(_key, msg.sender);\n', '    }\n', '\n', '    /// @notice Check transaction status\n', '    /// @param _key transaction id\n', '    /// @return code\n', '    function hasConfirmedRecord(bytes32 _key) public view returns (uint) {\n', '        require(_key != bytes32(0));\n', '\n', '        if (!isTxExist(_key)) {\n', '            return NO_RECORDS_WERE_FOUND;\n', '        }\n', '\n', '        Guard storage _guard = txKey2guard[_key];\n', '        return _guard.state == GuardState.InProcess\n', '        ? PENDING_MANAGER_IN_PROCESS\n', '        : _guard.state == GuardState.Confirmed\n', '        ? OK\n', '        : PENDING_MANAGER_REJECTED;\n', '    }\n', '\n', '\n', '    /// @notice Check policy details\n', '    ///\n', '    /// @return _groupNames group names included in policies\n', '    /// @return _acceptLimits accept limit for group\n', '    /// @return _declineLimits decline limit for group\n', '    function getPolicyDetails(bytes4 _sig, address _contract)\n', '    public\n', '    view\n', '    returns (\n', '        bytes32[] _groupNames,\n', '        uint[] _acceptLimits,\n', '        uint[] _declineLimits,\n', '        uint _totalAcceptedLimit,\n', '        uint _totalDeclinedLimit\n', '    ) {\n', '        require(_sig != bytes4(0));\n', '        require(_contract != 0x0);\n', '        \n', '        bytes32 _policyHash = keccak256(_sig, _contract);\n', '        uint _policyIdx = policyId2Index[_policyHash];\n', '        if (_policyIdx == 0) {\n', '            return;\n', '        }\n', '\n', '        Policy storage _policy = policyId2policy[_policyHash];\n', '        uint _policyGroupsCount = _policy.groupsCount;\n', '        _groupNames = new bytes32[](_policyGroupsCount);\n', '        _acceptLimits = new uint[](_policyGroupsCount);\n', '        _declineLimits = new uint[](_policyGroupsCount);\n', '\n', '        for (uint _idx = 0; _idx < _policyGroupsCount; ++_idx) {\n', '            Requirements storage _requirements = _policy.participatedGroups[_idx + 1];\n', '            _groupNames[_idx] = _requirements.groupName;\n', '            _acceptLimits[_idx] = _requirements.acceptLimit;\n', '            _declineLimits[_idx] = _requirements.declineLimit;\n', '        }\n', '\n', '        (_totalAcceptedLimit, _totalDeclinedLimit) = (_policy.totalAcceptedLimit, _policy.totalDeclinedLimit);\n', '    }\n', '\n', '    /// @notice Check policy include target group\n', '    /// @param _policyHash policy hash (sig, contract address)\n', '    /// @param _groupName group id\n', '    /// @return bool\n', '    function isGroupInPolicy(bytes32 _policyHash, bytes32 _groupName) public view returns (bool) {\n', '        Policy storage _policy = policyId2policy[_policyHash];\n', '        return _policy.groupName2index[_groupName] != 0;\n', '    }\n', '\n', '    /// @notice Check is policy exist\n', '    /// @param _policyHash policy hash (sig, contract address)\n', '    /// @return bool\n', '    function isPolicyExist(bytes32 _policyHash) public view returns (bool) {\n', '        return policyId2Index[_policyHash] != 0;\n', '    }\n', '\n', '    /// @notice Check is transaction exist\n', '    /// @param _key transaction id\n', '    /// @return bool\n', '    function isTxExist(bytes32 _key) public view returns (bool){\n', '        return txKey2index[_key] != 0;\n', '    }\n', '\n', '    function _updateTxState(Policy storage _policy, Guard storage _guard, uint confirmedAmount, uint declineAmount) private {\n', '        if (declineAmount != 0 && _guard.state != GuardState.Decline) {\n', '            _guard.state = GuardState.Decline;\n', '        } else if (confirmedAmount >= _policy.groupsCount && _guard.state != GuardState.Confirmed) {\n', '            _guard.state = GuardState.Confirmed;\n', '        } else if (_guard.state != GuardState.InProcess) {\n', '            _guard.state = GuardState.InProcess;\n', '        }\n', '    }\n', '\n', '    function _revoke(bytes32 _key, address _user) private returns (uint) {\n', '        require(_key != bytes32(0));\n', '        require(_user != 0x0);\n', '\n', '        if (!isTxExist(_key)) {\n', '            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n', '        }\n', '\n', '        Guard storage _guard = txKey2guard[_key];\n', '        if (_guard.state != GuardState.InProcess) {\n', '            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n', '        }\n', '\n', '        bytes32 _votedGroupName = _guard.votes[_user].groupName;\n', '        if (_votedGroupName == bytes32(0)) {\n', '            return _emitError(PENDING_MANAGER_HASNT_VOTED);\n', '        }\n', '\n', '        bool isAcceptedVote = _guard.votes[_user].accepted;\n', '        if (isAcceptedVote) {\n', '            _guard.acceptedCount[_votedGroupName] = _guard.acceptedCount[_votedGroupName].sub(1);\n', '            _guard.alreadyAccepted = _guard.alreadyAccepted.sub(1);\n', '        } else {\n', '            _guard.declinedCount[_votedGroupName] = _guard.declinedCount[_votedGroupName].sub(1);\n', '            _guard.alreadyDeclined = _guard.alreadyDeclined.sub(1);\n', '\n', '        }\n', '\n', '        delete _guard.votes[_user];\n', '\n', '        ProtectionTxVoteRevoked(_key, _user, _votedGroupName);\n', '        return OK;\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title MultiSigAdapter\n', '///\n', '/// Abstract implementation\n', '/// This contract serves as transaction signer\n', 'contract MultiSigAdapter is Object {\n', '\n', '    uint constant MULTISIG_ADDED = 3;\n', '    uint constant NO_RECORDS_WERE_FOUND = 4;\n', '\n', '    modifier isAuthorized {\n', '        if (msg.sender == contractOwner || msg.sender == getPendingManager()) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /// @notice Get pending address\n', '    /// @dev abstract. Needs child implementation\n', '    ///\n', '    /// @return pending address\n', '    function getPendingManager() public view returns (address);\n', '\n', '    /// @notice Sign current transaction and add it to transaction pending queue\n', '    ///\n', '    /// @return code\n', '    function _multisig(bytes32 _args, uint _block) internal returns (uint _code) {\n', '        bytes32 _txHash = _getKey(_args, _block);\n', '        address _manager = getPendingManager();\n', '\n', '        _code = PendingManager(_manager).hasConfirmedRecord(_txHash);\n', '        if (_code != NO_RECORDS_WERE_FOUND) {\n', '            return _code;\n', '        }\n', '\n', '        if (OK != PendingManager(_manager).addTx(_txHash, msg.sig, address(this))) {\n', '            revert();\n', '        }\n', '\n', '        return MULTISIG_ADDED;\n', '    }\n', '\n', '    function _isTxExistWithArgs(bytes32 _args, uint _block) internal view returns (bool) {\n', '        bytes32 _txHash = _getKey(_args, _block);\n', '        address _manager = getPendingManager();\n', '        return PendingManager(_manager).isTxExist(_txHash);\n', '    }\n', '\n', '    function _getKey(bytes32 _args, uint _block) private view returns (bytes32 _txHash) {\n', '        _block = _block != 0 ? _block : block.number;\n', '        _txHash = keccak256(msg.sig, _args, _block);\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title ServiceController\n', '///\n', '/// Base implementation\n', '/// Serves for managing service instances\n', 'contract ServiceController is MultiSigAdapter {\n', '\n', '    uint constant SERVICE_CONTROLLER = 350000;\n', '    uint constant SERVICE_CONTROLLER_EMISSION_EXIST = SERVICE_CONTROLLER + 1;\n', '    uint constant SERVICE_CONTROLLER_BURNING_MAN_EXIST = SERVICE_CONTROLLER + 2;\n', '    uint constant SERVICE_CONTROLLER_ALREADY_INITIALIZED = SERVICE_CONTROLLER + 3;\n', '    uint constant SERVICE_CONTROLLER_SERVICE_EXIST = SERVICE_CONTROLLER + 4;\n', '\n', '    address public profiterole;\n', '    address public treasury;\n', '    address public pendingManager;\n', '    address public proxy;\n', '\n', '    mapping(address => bool) public sideServices;\n', '    mapping(address => bool) emissionProviders;\n', '    mapping(address => bool) burningMans;\n', '\n', "    /// @notice Default ServiceController's constructor\n", '    ///\n', '    /// @param _pendingManager pending manager address\n', '    /// @param _proxy ERC20 proxy address\n', '    /// @param _profiterole profiterole address\n', '    /// @param _treasury treasury address\n', '    function ServiceController(address _pendingManager, address _proxy, address _profiterole, address _treasury) public {\n', '        require(_pendingManager != 0x0);\n', '        require(_proxy != 0x0);\n', '        require(_profiterole != 0x0);\n', '        require(_treasury != 0x0);\n', '        pendingManager = _pendingManager;\n', '        proxy = _proxy;\n', '        profiterole = _profiterole;\n', '        treasury = _treasury;\n', '    }\n', '\n', '    /// @notice Return pending manager address\n', '    ///\n', '    /// @return code\n', '    function getPendingManager() public view returns (address) {\n', '        return pendingManager;\n', '    }\n', '\n', '    /// @notice Add emission provider\n', '    ///\n', '    /// @param _provider emission provider address\n', '    ///\n', '    /// @return code\n', '    function addEmissionProvider(address _provider, uint _block) public returns (uint _code) {\n', '        if (emissionProviders[_provider]) {\n', '            return SERVICE_CONTROLLER_EMISSION_EXIST;\n', '        }\n', '        _code = _multisig(keccak256(_provider), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        emissionProviders[_provider] = true;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Remove emission provider\n', '    ///\n', '    /// @param _provider emission provider address\n', '    ///\n', '    /// @return code\n', '    function removeEmissionProvider(address _provider, uint _block) public returns (uint _code) {\n', '        _code = _multisig(keccak256(_provider), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        delete emissionProviders[_provider];\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Add burning man\n', '    ///\n', '    /// @param _burningMan burning man address\n', '    ///\n', '    /// @return code\n', '    function addBurningMan(address _burningMan, uint _block) public returns (uint _code) {\n', '        if (burningMans[_burningMan]) {\n', '            return SERVICE_CONTROLLER_BURNING_MAN_EXIST;\n', '        }\n', '\n', '        _code = _multisig(keccak256(_burningMan), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        burningMans[_burningMan] = true;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Remove burning man\n', '    ///\n', '    /// @param _burningMan burning man address\n', '    ///\n', '    /// @return code\n', '    function removeBurningMan(address _burningMan, uint _block) public returns (uint _code) {\n', '        _code = _multisig(keccak256(_burningMan), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        delete burningMans[_burningMan];\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Update a profiterole address\n', '    ///\n', '    /// @param _profiterole profiterole address\n', '    ///\n', '    /// @return result code of an operation\n', '    function updateProfiterole(address _profiterole, uint _block) public returns (uint _code) {\n', '        _code = _multisig(keccak256(_profiterole), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        profiterole = _profiterole;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Update a treasury address\n', '    ///\n', '    /// @param _treasury treasury address\n', '    ///\n', '    /// @return result code of an operation\n', '    function updateTreasury(address _treasury, uint _block) public returns (uint _code) {\n', '        _code = _multisig(keccak256(_treasury), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        treasury = _treasury;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Update pending manager address\n', '    ///\n', '    /// @param _pendingManager pending manager address\n', '    ///\n', '    /// @return result code of an operation\n', '    function updatePendingManager(address _pendingManager, uint _block) public returns (uint _code) {\n', '        _code = _multisig(keccak256(_pendingManager), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        pendingManager = _pendingManager;\n', '        return OK;\n', '    }\n', '\n', '    function addSideService(address _service, uint _block) public returns (uint _code) {\n', '        if (sideServices[_service]) {\n', '            return SERVICE_CONTROLLER_SERVICE_EXIST;\n', '        }\n', '        _code = _multisig(keccak256(_service), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        sideServices[_service] = true;\n', '        return OK;\n', '    }\n', '\n', '    function removeSideService(address _service, uint _block) public returns (uint _code) {\n', '        _code = _multisig(keccak256(_service), _block);\n', '        if (OK != _code) {\n', '            return _code;\n', '        }\n', '\n', '        delete sideServices[_service];\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Check target address is service\n', '    ///\n', '    /// @param _address target address\n', '    ///\n', '    /// @return `true` when an address is a service, `false` otherwise\n', '    function isService(address _address) public view returns (bool check) {\n', '        return _address == profiterole ||\n', '            _address == treasury || \n', '            _address == proxy || \n', '            _address == pendingManager || \n', '            emissionProviders[_address] || \n', '            burningMans[_address] ||\n', '            sideServices[_address];\n', '    }\n', '}\n', '\n', 'contract OracleMethodAdapter is Object {\n', '\n', '    event OracleAdded(bytes4 _sig, address _oracle);\n', '    event OracleRemoved(bytes4 _sig, address _oracle);\n', '\n', '    mapping(bytes4 => mapping(address => bool)) public oracles;\n', '\n', '    /// @dev Allow access only for oracle\n', '    modifier onlyOracle {\n', '        if (oracles[msg.sig][msg.sender]) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    modifier onlyOracleOrOwner {\n', '        if (oracles[msg.sig][msg.sender] || msg.sender == contractOwner) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    function addOracles(bytes4[] _signatures, address[] _oracles) onlyContractOwner external returns (uint) {\n', '        require(_signatures.length == _oracles.length);\n', '        bytes4 _sig;\n', '        address _oracle;\n', '        for (uint _idx = 0; _idx < _signatures.length; ++_idx) {\n', '            (_sig, _oracle) = (_signatures[_idx], _oracles[_idx]);\n', '            if (!oracles[_sig][_oracle]) {\n', '                oracles[_sig][_oracle] = true;\n', '                _emitOracleAdded(_sig, _oracle);\n', '            }\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    function removeOracles(bytes4[] _signatures, address[] _oracles) onlyContractOwner external returns (uint) {\n', '        require(_signatures.length == _oracles.length);\n', '        bytes4 _sig;\n', '        address _oracle;\n', '        for (uint _idx = 0; _idx < _signatures.length; ++_idx) {\n', '            (_sig, _oracle) = (_signatures[_idx], _oracles[_idx]);\n', '            if (oracles[_sig][_oracle]) {\n', '                delete oracles[_sig][_oracle];\n', '                _emitOracleRemoved(_sig, _oracle);\n', '            }\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    function _emitOracleAdded(bytes4 _sig, address _oracle) internal {\n', '        OracleAdded(_sig, _oracle);\n', '    }\n', '\n', '    function _emitOracleRemoved(bytes4 _sig, address _oracle) internal {\n', '        OracleRemoved(_sig, _oracle);\n', '    }\n', '\n', '}\n', '\n', 'contract Platform {\n', '    mapping(bytes32 => address) public proxies;\n', '    function name(bytes32 _symbol) public view returns (string);\n', '    function setProxy(address _address, bytes32 _symbol) public returns (uint errorCode);\n', '    function isOwner(address _owner, bytes32 _symbol) public view returns (bool);\n', '    function totalSupply(bytes32 _symbol) public view returns (uint);\n', '    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint);\n', '    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint);\n', '    function baseUnit(bytes32 _symbol) public view returns (uint8);\n', '    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n', '    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n', '    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public returns (uint errorCode);\n', '    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);\n', '    function reissueAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n', '    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n', '    function isReissuable(bytes32 _symbol) public view returns (bool);\n', '    function changeOwnership(bytes32 _symbol, address _newOwner) public returns (uint errorCode);\n', '}\n', '\n', '\n', 'contract ATxAssetProxy is ERC20, Object, ServiceAllowance {\n', '\n', '    // Timespan for users to review the new implementation and make decision.\n', '    uint constant UPGRADE_FREEZE_TIME = 3 days;\n', '\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '     * Indicates an upgrade freeze-time start, and the next asset implementation contract.\n', '     */\n', '    event UpgradeProposal(address newVersion);\n', '\n', '    // Current asset implementation contract address.\n', '    address latestVersion;\n', '\n', '    // Proposed next asset implementation contract address.\n', '    address pendingVersion;\n', '\n', '    // Upgrade freeze-time start.\n', '    uint pendingVersionTimestamp;\n', '\n', '    // Assigned platform, immutable.\n', '    Platform public platform;\n', '\n', '    // Assigned symbol, immutable.\n', '    bytes32 public smbl;\n', '\n', '    // Assigned name, immutable.\n', '    string public name;\n', '\n', '    /**\n', '     * Only platform is allowed to call.\n', '     */\n', '    modifier onlyPlatform() {\n', '        if (msg.sender == address(platform)) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Only current asset owner is allowed to call.\n', '     */\n', '    modifier onlyAssetOwner() {\n', '        if (platform.isOwner(msg.sender, smbl)) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Only asset implementation contract assigned to sender is allowed to call.\n', '     */\n', '    modifier onlyAccess(address _sender) {\n', '        if (getLatestVersion() == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Resolves asset implementation contract for the caller and forwards there transaction data,\n', '     * along with the value. This allows for proxy interface growth.\n', '     */\n', '    function() public payable {\n', '        _getAsset().__process.value(msg.value)(msg.data, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Sets platform address, assigns symbol and name.\n', '     *\n', '     * Can be set only once.\n', '     *\n', '     * @param _platform platform contract address.\n', '     * @param _symbol assigned symbol.\n', '     * @param _name assigned name.\n', '     *\n', '     * @return success.\n', '     */\n', '    function init(Platform _platform, string _symbol, string _name) public returns (bool) {\n', '        if (address(platform) != 0x0) {\n', '            return false;\n', '        }\n', '        platform = _platform;\n', '        symbol = _symbol;\n', '        smbl = stringToBytes32(_symbol);\n', '        name = _name;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns asset total supply.\n', '     *\n', '     * @return asset total supply.\n', '     */\n', '    function totalSupply() public view returns (uint) {\n', '        return platform.totalSupply(smbl);\n', '    }\n', '\n', '    /**\n', '     * Returns asset balance for a particular holder.\n', '     *\n', '     * @param _owner holder address.\n', '     *\n', '     * @return holder balance.\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint) {\n', '        return platform.balanceOf(_owner, smbl);\n', '    }\n', '\n', '    /**\n', '     * Returns asset allowance from one holder to another.\n', '     *\n', '     * @param _from holder that allowed spending.\n', '     * @param _spender holder that is allowed to spend.\n', '     *\n', '     * @return holder to spender allowance.\n', '     */\n', '    function allowance(address _from, address _spender) public view returns (uint) {\n', '        return platform.allowance(_from, _spender, smbl);\n', '    }\n', '\n', '    /**\n', '     * Returns asset decimals.\n', '     *\n', '     * @return asset decimals.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return platform.baseUnit(smbl);\n', '    }\n', '\n', '    /**\n', '     * Transfers asset balance from the caller to specified receiver.\n', '     *\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     *\n', '     * @return success.\n', '     */\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        if (_to != 0x0) {\n', '            return _transferWithReference(_to, _value, "");\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfers asset balance from the caller to specified receiver adding specified comment.\n', '     *\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', "     * @param _reference transfer comment to be included in a platform's Transfer event.\n", '     *\n', '     * @return success.\n', '     */\n', '    function transferWithReference(address _to, uint _value, string _reference) public returns (bool) {\n', '        if (_to != 0x0) {\n', '            return _transferWithReference(_to, _value, _reference);\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Performs transfer call on the platform by the name of specified sender.\n', '     *\n', '     * Can only be called by asset implementation contract assigned to sender.\n', '     *\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', "     * @param _reference transfer comment to be included in a platform's Transfer event.\n", '     * @param _sender initial caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\n', '        return platform.proxyTransferWithReference(_to, _value, smbl, _reference, _sender) == OK;\n', '    }\n', '\n', '    /**\n', '     * Prforms allowance transfer of asset balance between holders.\n', '     *\n', '     * @param _from holder address to take from.\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     *\n', '     * @return success.\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        if (_to != 0x0) {\n', '            return _getAsset().__transferFromWithReference(_from, _to, _value, "", msg.sender);\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Performs allowance transfer call on the platform by the name of specified sender.\n', '     *\n', '     * Can only be called by asset implementation contract assigned to sender.\n', '     *\n', '     * @param _from holder address to take from.\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', "     * @param _reference transfer comment to be included in a platform's Transfer event.\n", '     * @param _sender initial caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\n', '        return platform.proxyTransferFromWithReference(_from, _to, _value, smbl, _reference, _sender) == OK;\n', '    }\n', '\n', '    /**\n', '     * Sets asset spending allowance for a specified spender.\n', '     *\n', '     * @param _spender holder address to set allowance to.\n', '     * @param _value amount to allow.\n', '     *\n', '     * @return success.\n', '     */\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        if (_spender != 0x0) {\n', '            return _getAsset().__approve(_spender, _value, msg.sender);\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Performs allowance setting call on the platform by the name of specified sender.\n', '     *\n', '     * Can only be called by asset implementation contract assigned to sender.\n', '     *\n', '     * @param _spender holder address to set allowance to.\n', '     * @param _value amount to allow.\n', '     * @param _sender initial caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function __approve(address _spender, uint _value, address _sender) public onlyAccess(_sender) returns (bool) {\n', '        return platform.proxyApprove(_spender, _value, smbl, _sender) == OK;\n', '    }\n', '\n', '    /**\n', '     * Emits ERC20 Transfer event on this contract.\n', '     *\n', '     * Can only be, and, called by assigned platform when asset transfer happens.\n', '     */\n', '    function emitTransfer(address _from, address _to, uint _value) public onlyPlatform() {\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Emits ERC20 Approval event on this contract.\n', '     *\n', '     * Can only be, and, called by assigned platform when asset allowance set happens.\n', '     */\n', '    function emitApprove(address _from, address _spender, uint _value) public onlyPlatform() {\n', '        Approval(_from, _spender, _value);\n', '    }\n', '\n', '    /**\n', '     * Returns current asset implementation contract address.\n', '     *\n', '     * @return asset implementation contract address.\n', '     */\n', '    function getLatestVersion() public view returns (address) {\n', '        return latestVersion;\n', '    }\n', '\n', '    /**\n', '     * Returns proposed next asset implementation contract address.\n', '     *\n', '     * @return asset implementation contract address.\n', '     */\n', '    function getPendingVersion() public view returns (address) {\n', '        return pendingVersion;\n', '    }\n', '\n', '    /**\n', '     * Returns upgrade freeze-time start.\n', '     *\n', '     * @return freeze-time start.\n', '     */\n', '    function getPendingVersionTimestamp() public view returns (uint) {\n', '        return pendingVersionTimestamp;\n', '    }\n', '\n', '    /**\n', '     * Propose next asset implementation contract address.\n', '     *\n', '     * Can only be called by current asset owner.\n', '     *\n', '     * Note: freeze-time should not be applied for the initial setup.\n', '     *\n', '     * @param _newVersion asset implementation contract address.\n', '     *\n', '     * @return success.\n', '     */\n', '    function proposeUpgrade(address _newVersion) public onlyAssetOwner returns (bool) {\n', '        // Should not already be in the upgrading process.\n', '        if (pendingVersion != 0x0) {\n', '            return false;\n', '        }\n', '        // New version address should be other than 0x0.\n', '        if (_newVersion == 0x0) {\n', '            return false;\n', '        }\n', "        // Don't apply freeze-time for the initial setup.\n", '        if (latestVersion == 0x0) {\n', '            latestVersion = _newVersion;\n', '            return true;\n', '        }\n', '        pendingVersion = _newVersion;\n', '        pendingVersionTimestamp = now;\n', '        UpgradeProposal(_newVersion);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Cancel the pending upgrade process.\n', '     *\n', '     * Can only be called by current asset owner.\n', '     *\n', '     * @return success.\n', '     */\n', '    function purgeUpgrade() public onlyAssetOwner returns (bool) {\n', '        if (pendingVersion == 0x0) {\n', '            return false;\n', '        }\n', '        delete pendingVersion;\n', '        delete pendingVersionTimestamp;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Finalize an upgrade process setting new asset implementation contract address.\n', '     *\n', '     * Can only be called after an upgrade freeze-time.\n', '     *\n', '     * @return success.\n', '     */\n', '    function commitUpgrade() public returns (bool) {\n', '        if (pendingVersion == 0x0) {\n', '            return false;\n', '        }\n', '        if (pendingVersionTimestamp.add(UPGRADE_FREEZE_TIME) > now) {\n', '            return false;\n', '        }\n', '        latestVersion = pendingVersion;\n', '        delete pendingVersion;\n', '        delete pendingVersionTimestamp;\n', '        return true;\n', '    }\n', '\n', '    function isTransferAllowed(address, address, address, address, uint) public view returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns asset implementation contract for current caller.\n', '     *\n', '     * @return asset implementation contract.\n', '     */\n', '    function _getAsset() internal view returns (ATxAssetInterface) {\n', '        return ATxAssetInterface(getLatestVersion());\n', '    }\n', '\n', '    /**\n', '     * Resolves asset implementation contract for the caller and forwards there arguments along with\n', '     * the caller address.\n', '     *\n', '     * @return success.\n', '     */\n', '    function _transferWithReference(address _to, uint _value, string _reference) internal returns (bool) {\n', '        return _getAsset().__transferWithReference(_to, _value, _reference, msg.sender);\n', '    }\n', '\n', '    function stringToBytes32(string memory source) private pure returns (bytes32 result) {\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '}\n', '\n', 'contract DataControllerEmitter {\n', '\n', '    event CountryCodeAdded(uint _countryCode, uint _countryId, uint _maxHolderCount);\n', '    event CountryCodeChanged(uint _countryCode, uint _countryId, uint _maxHolderCount);\n', '\n', '    event HolderRegistered(bytes32 _externalHolderId, uint _accessIndex, uint _countryCode);\n', '    event HolderAddressAdded(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex);\n', '    event HolderAddressRemoved(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex);\n', '    event HolderOperationalChanged(bytes32 _externalHolderId, bool _operational);\n', '\n', '    event DayLimitChanged(bytes32 _externalHolderId, uint _from, uint _to);\n', '    event MonthLimitChanged(bytes32 _externalHolderId, uint _from, uint _to);\n', '\n', '    event Error(uint _errorCode);\n', '\n', '    function _emitHolderAddressAdded(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex) internal {\n', '        HolderAddressAdded(_externalHolderId, _holderPrototype, _accessIndex);\n', '    }\n', '\n', '    function _emitHolderAddressRemoved(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex) internal {\n', '        HolderAddressRemoved(_externalHolderId, _holderPrototype, _accessIndex);\n', '    }\n', '\n', '    function _emitHolderRegistered(bytes32 _externalHolderId, uint _accessIndex, uint _countryCode) internal {\n', '        HolderRegistered(_externalHolderId, _accessIndex, _countryCode);\n', '    }\n', '\n', '    function _emitHolderOperationalChanged(bytes32 _externalHolderId, bool _operational) internal {\n', '        HolderOperationalChanged(_externalHolderId, _operational);\n', '    }\n', '\n', '    function _emitCountryCodeAdded(uint _countryCode, uint _countryId, uint _maxHolderCount) internal {\n', '        CountryCodeAdded(_countryCode, _countryId, _maxHolderCount);\n', '    }\n', '\n', '    function _emitCountryCodeChanged(uint _countryCode, uint _countryId, uint _maxHolderCount) internal {\n', '        CountryCodeChanged(_countryCode, _countryId, _maxHolderCount);\n', '    }\n', '\n', '    function _emitDayLimitChanged(bytes32 _externalHolderId, uint _from, uint _to) internal {\n', '        DayLimitChanged(_externalHolderId, _from, _to);\n', '    }\n', '\n', '    function _emitMonthLimitChanged(bytes32 _externalHolderId, uint _from, uint _to) internal {\n', '        MonthLimitChanged(_externalHolderId, _from, _to);\n', '    }\n', '\n', '    function _emitError(uint _errorCode) internal returns (uint) {\n', '        Error(_errorCode);\n', '        return _errorCode;\n', '    }\n', '}\n', '\n', '\n', '/// @title Provides possibility manage holders? country limits and limits for holders.\n', 'contract DataController is OracleMethodAdapter, DataControllerEmitter {\n', '\n', '    /* CONSTANTS */\n', '\n', '    uint constant DATA_CONTROLLER = 109000;\n', '    uint constant DATA_CONTROLLER_ERROR = DATA_CONTROLLER + 1;\n', '    uint constant DATA_CONTROLLER_CURRENT_WRONG_LIMIT = DATA_CONTROLLER + 2;\n', '    uint constant DATA_CONTROLLER_WRONG_ALLOWANCE = DATA_CONTROLLER + 3;\n', '    uint constant DATA_CONTROLLER_COUNTRY_CODE_ALREADY_EXISTS = DATA_CONTROLLER + 4;\n', '\n', '    uint constant MAX_TOKEN_HOLDER_NUMBER = 2 ** 256 - 1;\n', '\n', '    using SafeMath for uint;\n', '\n', '    /* STRUCTS */\n', '\n', "    /// @title HoldersData couldn't be public because of internal structures, so needed to provide getters for different parts of _holderData\n", '    struct HoldersData {\n', '        uint countryCode;\n', '        uint sendLimPerDay;\n', '        uint sendLimPerMonth;\n', '        bool operational;\n', '        bytes text;\n', '        uint holderAddressCount;\n', '        mapping(uint => address) index2Address;\n', '        mapping(address => uint) address2Index;\n', '    }\n', '\n', '    struct CountryLimits {\n', '        uint countryCode;\n', '        uint maxTokenHolderNumber;\n', '        uint currentTokenHolderNumber;\n', '    }\n', '\n', '    /* FIELDS */\n', '\n', '    address public withdrawal;\n', '    address assetAddress;\n', '    address public serviceController;\n', '\n', '    mapping(address => uint) public allowance;\n', '\n', '    // Iterable mapping pattern is used for holders.\n', '    /// @dev This is an access address mapping. Many addresses may have access to a single holder.\n', '    uint public holdersCount;\n', '    mapping(uint => HoldersData) holders;\n', '    mapping(address => bytes32) holderAddress2Id;\n', '    mapping(bytes32 => uint) public holderIndex;\n', '\n', '    // This is an access address mapping. Many addresses may have access to a single holder.\n', '    uint public countriesCount;\n', '    mapping(uint => CountryLimits) countryLimitsList;\n', '    mapping(uint => uint) countryIndex;\n', '\n', '    /* MODIFIERS */\n', '\n', '    modifier onlyWithdrawal {\n', '        if (msg.sender != withdrawal) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier onlyAsset {\n', '        if (msg.sender == assetAddress) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    modifier onlyContractOwner {\n', '        if (msg.sender == contractOwner) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /// @notice Constructor for _holderData controller.\n', '    /// @param _serviceController service controller\n', '    function DataController(address _serviceController, address _asset) public {\n', '        require(_serviceController != 0x0);\n', '        require(_asset != 0x0);\n', '\n', '        serviceController = _serviceController;\n', '        assetAddress = _asset;\n', '    }\n', '\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    function setWithdraw(address _withdrawal) onlyContractOwner external returns (uint) {\n', '        require(_withdrawal != 0x0);\n', '        withdrawal = _withdrawal;\n', '        return OK;\n', '    }\n', '\n', '\n', '    function getPendingManager() public view returns (address) {\n', '        return ServiceController(serviceController).getPendingManager();\n', '    }\n', '\n', '    function getHolderInfo(bytes32 _externalHolderId) public view returns (\n', '        uint _countryCode,\n', '        uint _limPerDay,\n', '        uint _limPerMonth,\n', '        bool _operational,\n', '        bytes _text\n', '    ) {\n', '        HoldersData storage _data = holders[holderIndex[_externalHolderId]];\n', '        return (_data.countryCode, _data.sendLimPerDay, _data.sendLimPerMonth, _data.operational, _data.text);\n', '    }\n', '\n', '    function getHolderAddresses(bytes32 _externalHolderId) public view returns (address[] _addresses) {\n', '        HoldersData storage _holderData = holders[holderIndex[_externalHolderId]];\n', '        uint _addressesCount = _holderData.holderAddressCount;\n', '        _addresses = new address[](_addressesCount);\n', '        for (uint _holderAddressIdx = 0; _holderAddressIdx < _addressesCount; ++_holderAddressIdx) {\n', '            _addresses[_holderAddressIdx] = _holderData.index2Address[_holderAddressIdx + 1];\n', '        }\n', '    }\n', '\n', '    function getHolderCountryCode(bytes32 _externalHolderId) public view returns (uint) {\n', '        return holders[holderIndex[_externalHolderId]].countryCode;\n', '    }\n', '\n', '    function getHolderExternalIdByAddress(address _address) public view returns (bytes32) {\n', '        return holderAddress2Id[_address];\n', '    }\n', '\n', '    /// @notice Checks user is holder.\n', '    /// @param _address checking address.\n', '    /// @return `true` if _address is registered holder, `false` otherwise.\n', '    function isRegisteredAddress(address _address) public view returns (bool) {\n', '        return holderIndex[holderAddress2Id[_address]] != 0;\n', '    }\n', '\n', '    function isHolderOwnAddress(bytes32 _externalHolderId, address _address) public view returns (bool) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        if (_holderIndex == 0) {\n', '            return false;\n', '        }\n', '        return holders[_holderIndex].address2Index[_address] != 0;\n', '    }\n', '\n', '    function getCountryInfo(uint _countryCode) public view returns (uint _maxHolderNumber, uint _currentHolderCount) {\n', '        CountryLimits storage _data = countryLimitsList[countryIndex[_countryCode]];\n', '        return (_data.maxTokenHolderNumber, _data.currentTokenHolderNumber);\n', '    }\n', '\n', '    function getCountryLimit(uint _countryCode) public view returns (uint limit) {\n', '        uint _index = countryIndex[_countryCode];\n', '        require(_index != 0);\n', '        return countryLimitsList[_index].maxTokenHolderNumber;\n', '    }\n', '\n', '    function addCountryCode(uint _countryCode) onlyContractOwner public returns (uint) {\n', '        var (,_created) = _createCountryId(_countryCode);\n', '        if (!_created) {\n', '            return _emitError(DATA_CONTROLLER_COUNTRY_CODE_ALREADY_EXISTS);\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Returns holder id for the specified address, creates it if needed.\n', '    /// @param _externalHolderId holder address.\n', '    /// @param _countryCode country code.\n', '    /// @return error code.\n', '    function registerHolder(bytes32 _externalHolderId, address _holderAddress, uint _countryCode) onlyOracleOrOwner external returns (uint) {\n', '        require(_holderAddress != 0x0);\n', '        uint _holderIndex = holderIndex[holderAddress2Id[_holderAddress]];\n', '        require(_holderIndex == 0);\n', '\n', '        _createCountryId(_countryCode);\n', '        _holderIndex = holdersCount.add(1);\n', '        holdersCount = _holderIndex;\n', '\n', '        HoldersData storage _holderData = holders[_holderIndex];\n', '        _holderData.countryCode = _countryCode;\n', '        _holderData.operational = true;\n', '        _holderData.sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER;\n', '        _holderData.sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER;\n', '        uint _firstAddressIndex = 1;\n', '        _holderData.holderAddressCount = _firstAddressIndex;\n', '        _holderData.address2Index[_holderAddress] = _firstAddressIndex;\n', '        _holderData.index2Address[_firstAddressIndex] = _holderAddress;\n', '        holderIndex[_externalHolderId] = _holderIndex;\n', '        holderAddress2Id[_holderAddress] = _externalHolderId;\n', '\n', '        _emitHolderRegistered(_externalHolderId, _holderIndex, _countryCode);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Adds new address equivalent to holder.\n', '    /// @param _externalHolderId external holder identifier.\n', '    /// @param _newAddress adding address.\n', '    /// @return error code.\n', '    function addHolderAddress(bytes32 _externalHolderId, address _newAddress) onlyOracleOrOwner external returns (uint) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        require(_holderIndex != 0);\n', '\n', '        uint _newAddressId = holderIndex[holderAddress2Id[_newAddress]];\n', '        require(_newAddressId == 0);\n', '\n', '        HoldersData storage _holderData = holders[_holderIndex];\n', '\n', '        if (_holderData.address2Index[_newAddress] == 0) {\n', '            _holderData.holderAddressCount = _holderData.holderAddressCount.add(1);\n', '            _holderData.address2Index[_newAddress] = _holderData.holderAddressCount;\n', '            _holderData.index2Address[_holderData.holderAddressCount] = _newAddress;\n', '        }\n', '\n', '        holderAddress2Id[_newAddress] = _externalHolderId;\n', '\n', '        _emitHolderAddressAdded(_externalHolderId, _newAddress, _holderIndex);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Remove an address owned by a holder.\n', '    /// @param _externalHolderId external holder identifier.\n', '    /// @param _address removing address.\n', '    /// @return error code.\n', '    function removeHolderAddress(bytes32 _externalHolderId, address _address) onlyOracleOrOwner external returns (uint) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        require(_holderIndex != 0);\n', '\n', '        HoldersData storage _holderData = holders[_holderIndex];\n', '\n', '        uint _tempIndex = _holderData.address2Index[_address];\n', '        require(_tempIndex != 0);\n', '\n', '        address _lastAddress = _holderData.index2Address[_holderData.holderAddressCount];\n', '        _holderData.address2Index[_lastAddress] = _tempIndex;\n', '        _holderData.index2Address[_tempIndex] = _lastAddress;\n', '        delete _holderData.address2Index[_address];\n', '        _holderData.holderAddressCount = _holderData.holderAddressCount.sub(1);\n', '\n', '        delete holderAddress2Id[_address];\n', '\n', '        _emitHolderAddressRemoved(_externalHolderId, _address, _holderIndex);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Change operational status for holder.\n', '    /// Can be accessed by contract owner or oracle only.\n', '    ///\n', '    /// @param _externalHolderId external holder identifier.\n', '    /// @param _operational operational status.\n', '    ///\n', '    /// @return result code.\n', '    function changeOperational(bytes32 _externalHolderId, bool _operational) onlyOracleOrOwner external returns (uint) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        require(_holderIndex != 0);\n', '\n', '        holders[_holderIndex].operational = _operational;\n', '\n', '        _emitHolderOperationalChanged(_externalHolderId, _operational);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Changes text for holder.\n', '    /// Can be accessed by contract owner or oracle only.\n', '    ///\n', '    /// @param _externalHolderId external holder identifier.\n', '    /// @param _text changing text.\n', '    ///\n', '    /// @return result code.\n', '    function updateTextForHolder(bytes32 _externalHolderId, bytes _text) onlyOracleOrOwner external returns (uint) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        require(_holderIndex != 0);\n', '\n', '        holders[_holderIndex].text = _text;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Updates limit per day for holder.\n', '    ///\n', '    /// Can be accessed by contract owner only.\n', '    ///\n', '    /// @param _externalHolderId external holder identifier.\n', '    /// @param _limit limit value.\n', '    ///\n', '    /// @return result code.\n', '    function updateLimitPerDay(bytes32 _externalHolderId, uint _limit) onlyOracleOrOwner external returns (uint) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        require(_holderIndex != 0);\n', '\n', '        uint _currentLimit = holders[_holderIndex].sendLimPerDay;\n', '        holders[_holderIndex].sendLimPerDay = _limit;\n', '\n', '        _emitDayLimitChanged(_externalHolderId, _currentLimit, _limit);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Updates limit per month for holder.\n', '    /// Can be accessed by contract owner or oracle only.\n', '    ///\n', '    /// @param _externalHolderId external holder identifier.\n', '    /// @param _limit limit value.\n', '    ///\n', '    /// @return result code.\n', '    function updateLimitPerMonth(bytes32 _externalHolderId, uint _limit) onlyOracleOrOwner external returns (uint) {\n', '        uint _holderIndex = holderIndex[_externalHolderId];\n', '        require(_holderIndex != 0);\n', '\n', '        uint _currentLimit = holders[_holderIndex].sendLimPerDay;\n', '        holders[_holderIndex].sendLimPerMonth = _limit;\n', '\n', '        _emitMonthLimitChanged(_externalHolderId, _currentLimit, _limit);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Change country limits.\n', '    /// Can be accessed by contract owner or oracle only.\n', '    ///\n', '    /// @param _countryCode country code.\n', '    /// @param _limit limit value.\n', '    ///\n', '    /// @return result code.\n', '    function changeCountryLimit(uint _countryCode, uint _limit) onlyOracleOrOwner external returns (uint) {\n', '        uint _countryIndex = countryIndex[_countryCode];\n', '        require(_countryIndex != 0);\n', '\n', '        uint _currentTokenHolderNumber = countryLimitsList[_countryIndex].currentTokenHolderNumber;\n', '        if (_currentTokenHolderNumber > _limit) {\n', '            return DATA_CONTROLLER_CURRENT_WRONG_LIMIT;\n', '        }\n', '\n', '        countryLimitsList[_countryIndex].maxTokenHolderNumber = _limit;\n', '        \n', '        _emitCountryCodeChanged(_countryIndex, _countryCode, _limit);\n', '        return OK;\n', '    }\n', '\n', '    function withdrawFrom(address _holderAddress, uint _value) public onlyAsset returns (uint) {\n', '        bytes32 _externalHolderId = holderAddress2Id[_holderAddress];\n', '        HoldersData storage _holderData = holders[holderIndex[_externalHolderId]];\n', '        _holderData.sendLimPerDay = _holderData.sendLimPerDay.sub(_value);\n', '        _holderData.sendLimPerMonth = _holderData.sendLimPerMonth.sub(_value);\n', '        return OK;\n', '    }\n', '\n', '    function depositTo(address _holderAddress, uint _value) public onlyAsset returns (uint) {\n', '        bytes32 _externalHolderId = holderAddress2Id[_holderAddress];\n', '        HoldersData storage _holderData = holders[holderIndex[_externalHolderId]];\n', '        _holderData.sendLimPerDay = _holderData.sendLimPerDay.add(_value);\n', '        _holderData.sendLimPerMonth = _holderData.sendLimPerMonth.add(_value);\n', '        return OK;\n', '    }\n', '\n', '    function updateCountryHoldersCount(uint _countryCode, uint _updatedHolderCount) public onlyAsset returns (uint) {\n', '        CountryLimits storage _data = countryLimitsList[countryIndex[_countryCode]];\n', '        assert(_data.maxTokenHolderNumber >= _updatedHolderCount);\n', '        _data.currentTokenHolderNumber = _updatedHolderCount;\n', '        return OK;\n', '    }\n', '\n', '    function changeAllowance(address _from, uint _value) public onlyWithdrawal returns (uint) {\n', '        ServiceController _serviceController = ServiceController(serviceController);\n', '        ATxAssetProxy token = ATxAssetProxy(_serviceController.proxy());\n', '        if (token.balanceOf(_from) < _value) {\n', '            return DATA_CONTROLLER_WRONG_ALLOWANCE;\n', '        }\n', '        allowance[_from] = _value;\n', '        return OK;\n', '    }\n', '\n', '    function _createCountryId(uint _countryCode) internal returns (uint, bool _created) {\n', '        uint countryId = countryIndex[_countryCode];\n', '        if (countryId == 0) {\n', '            uint _countriesCount = countriesCount;\n', '            countryId = _countriesCount.add(1);\n', '            countriesCount = countryId;\n', '            CountryLimits storage limits = countryLimitsList[countryId];\n', '            limits.countryCode = _countryCode;\n', '            limits.maxTokenHolderNumber = MAX_TOKEN_HOLDER_NUMBER;\n', '\n', '            countryIndex[_countryCode] = countryId;\n', '            _emitCountryCodeAdded(countryIndex[_countryCode], _countryCode, MAX_TOKEN_HOLDER_NUMBER);\n', '\n', '            _created = true;\n', '        }\n', '\n', '        return (countryId, _created);\n', '    }\n', '}\n', '\n', '/// @title Contract that will work with ERC223 tokens.\n', 'interface ERC223ReceivingInterface {\n', '\n', '\t/// @notice Standard ERC223 function that will handle incoming token transfers.\n', '\t/// @param _from  Token sender address.\n', '\t/// @param _value Amount of tokens.\n', '\t/// @param _data  Transaction metadata.\n', '    function tokenFallback(address _from, uint _value, bytes _data) external;\n', '}\n', '\n', '/// @title ATx Asset implementation contract.\n', '///\n', '/// Basic asset implementation contract, without any additional logic.\n', '/// Every other asset implementation contracts should derive from this one.\n', '/// Receives calls from the proxy, and calls back immediately without arguments modification.\n', '///\n', '/// Note: all the non constant functions return false instead of throwing in case if state change\n', "/// didn't happen yet.\n", 'contract ATxAsset is BasicAsset, Owned {\n', '\n', '    uint public constant OK = 1;\n', '\n', '    using SafeMath for uint;\n', '\n', '    enum Roles {\n', '        Holder,\n', '        Service,\n', '        Other\n', '    }\n', '\n', '    ServiceController public serviceController;\n', '    DataController public dataController;\n', '    uint public lockupDate;\n', '\n', '    /// @notice Default constructor for ATxAsset.\n', '    function ATxAsset() public {\n', '    }\n', '\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    /// @notice Init function for ATxAsset.\n', '    ///\n', '    /// @param _proxy - atx asset proxy.\n', '    /// @param _serviceController - service controoler.\n', '    /// @param _dataController - data controller.\n', '    /// @param _lockupDate - th lockup date.\n', '    function initAtx(\n', '        address _proxy, \n', '        address _serviceController, \n', '        address _dataController, \n', '        uint _lockupDate\n', '    ) \n', '    onlyContractOwner \n', '    public \n', '    returns (bool) \n', '    {\n', '        require(_serviceController != 0x0);\n', '        require(_dataController != 0x0);\n', '        require(_proxy != 0x0);\n', '        require(_lockupDate > now || _lockupDate == 0);\n', '\n', '        if (!super.init(ATxProxy(_proxy))) {\n', '            return false;\n', '        }\n', '\n', '        serviceController = ServiceController(_serviceController);\n', '        dataController = DataController(_dataController);\n', '        lockupDate = _lockupDate;\n', '        return true;\n', '    }\n', '\n', '    /// @notice Performs transfer call on the platform by the name of specified sender.\n', '    ///\n', '    /// @dev Can only be called by proxy asset.\n', '    ///\n', '    /// @param _to holder address to give to.\n', '    /// @param _value amount to transfer.\n', "    /// @param _reference transfer comment to be included in a platform's Transfer event.\n", '    /// @param _sender initial caller.\n', '    ///\n', '    /// @return success.\n', '    function __transferWithReference(\n', '        address _to, \n', '        uint _value, \n', '        string _reference, \n', '        address _sender\n', '    ) \n', '    onlyProxy \n', '    public \n', '    returns (bool) \n', '    {\n', '        var (_fromRole, _toRole) = _getParticipantRoles(_sender, _to);\n', '\n', '        if (!_checkTransferAllowance(_to, _toRole, _value, _sender, _fromRole)) {\n', '            return false;\n', '        }\n', '\n', '        if (!_isValidCountryLimits(_to, _toRole, _value, _sender, _fromRole)) {\n', '            return false;\n', '        }\n', '\n', '        if (!super.__transferWithReference(_to, _value, _reference, _sender)) {\n', '            return false;\n', '        }\n', '\n', '        _updateTransferLimits(_to, _toRole, _value, _sender, _fromRole);\n', '        _contractFallbackERC223(_sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Performs allowance transfer call on the platform by the name of specified sender.\n', '    ///\n', '    /// @dev Can only be called by proxy asset.\n', '    ///\n', '    /// @param _from holder address to take from.\n', '    /// @param _to holder address to give to.\n', '    /// @param _value amount to transfer.\n', "    /// @param _reference transfer comment to be included in a platform's Transfer event.\n", '    /// @param _sender initial caller.\n', '    ///\n', '    /// @return success.\n', '    function __transferFromWithReference(\n', '        address _from, \n', '        address _to, \n', '        uint _value, \n', '        string _reference, \n', '        address _sender\n', '    ) \n', '    public \n', '    onlyProxy \n', '    returns (bool) \n', '    {\n', '        var (_fromRole, _toRole) = _getParticipantRoles(_from, _to);\n', '\n', '        // @note Special check for operational withdraw.\n', '        bool _isTransferFromHolderToContractOwner = (_fromRole == Roles.Holder) && \n', '            (contractOwner == _to) && \n', '            (dataController.allowance(_from) >= _value) && \n', '            super.__transferFromWithReference(_from, _to, _value, _reference, _sender);\n', '        if (_isTransferFromHolderToContractOwner) {\n', '            return true;\n', '        }\n', '\n', '        if (!_checkTransferAllowanceFrom(_to, _toRole, _value, _from, _fromRole, _sender)) {\n', '            return false;\n', '        }\n', '\n', '        if (!_isValidCountryLimits(_to, _toRole, _value, _from, _fromRole)) {\n', '            return false;\n', '        }\n', '\n', '        if (!super.__transferFromWithReference(_from, _to, _value, _reference, _sender)) {\n', '            return false;\n', '        }\n', '\n', '        _updateTransferLimits(_to, _toRole, _value, _from, _fromRole);\n', '        _contractFallbackERC223(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* INTERNAL */\n', '\n', '    function _contractFallbackERC223(address _from, address _to, uint _value) internal {\n', '        uint _codeLength;\n', '        assembly {\n', '            _codeLength := extcodesize(_to)\n', '        }\n', '\n', '        if (_codeLength > 0) {\n', '            ERC223ReceivingInterface _receiver = ERC223ReceivingInterface(_to);\n', '            bytes memory _empty;\n', '            _receiver.tokenFallback(_from, _value, _empty);\n', '        }\n', '    }\n', '\n', '    function _isTokenActive() internal view returns (bool) {\n', '        return now > lockupDate;\n', '    }\n', '\n', '    function _checkTransferAllowance(address _to, Roles _toRole, uint _value, address _from, Roles _fromRole) internal view returns (bool) {\n', '        if (_to == proxy) {\n', '            return false;\n', '        }\n', '\n', '        bool _canTransferFromService = _fromRole == Roles.Service && ServiceAllowance(_from).isTransferAllowed(_from, _to, _from, proxy, _value);\n', '        bool _canTransferToService = _toRole == Roles.Service && ServiceAllowance(_to).isTransferAllowed(_from, _to, _from, proxy, _value);\n', '        bool _canTransferToHolder = _toRole == Roles.Holder && _couldDepositToHolder(_to, _value);\n', '\n', '        bool _canTransferFromHolder;\n', '\n', '        if (_isTokenActive()) {\n', '            _canTransferFromHolder = _fromRole == Roles.Holder && _couldWithdrawFromHolder(_from, _value);\n', '        } else {\n', '            _canTransferFromHolder = _fromRole == Roles.Holder && _couldWithdrawFromHolder(_from, _value) && _from == contractOwner;\n', '        }\n', '\n', '        return (_canTransferFromHolder || _canTransferFromService) && (_canTransferToHolder || _canTransferToService);\n', '    }\n', '\n', '    function _checkTransferAllowanceFrom(\n', '        address _to, \n', '        Roles _toRole, \n', '        uint _value, \n', '        address _from, \n', '        Roles _fromRole, \n', '        address\n', '    ) \n', '    internal \n', '    view \n', '    returns (bool) \n', '    {\n', '        return _checkTransferAllowance(_to, _toRole, _value, _from, _fromRole);\n', '    }\n', '\n', '    function _isValidWithdrawLimits(uint _sendLimPerDay, uint _sendLimPerMonth, uint _value) internal pure returns (bool) {\n', '        return !(_value > _sendLimPerDay || _value > _sendLimPerMonth);\n', '    }\n', '\n', '    function _isValidDepositCountry(\n', '        uint _value,\n', '        uint _withdrawCountryCode,\n', '        uint _withdrawBalance,\n', '        uint _countryCode,\n', '        uint _balance,\n', '        uint _currentHolderCount,\n', '        uint _maxHolderNumber\n', '    )\n', '    internal\n', '    pure\n', '    returns (bool)\n', '    {\n', '        return _isNoNeedInCountryLimitChange(_value, _withdrawCountryCode, _withdrawBalance, _countryCode, _balance, _currentHolderCount, _maxHolderNumber)\n', '        ? true\n', '        : _isValidDepositCountry(_balance, _currentHolderCount, _maxHolderNumber);\n', '    }\n', '\n', '    function _isNoNeedInCountryLimitChange(\n', '        uint _value,\n', '        uint _withdrawCountryCode,\n', '        uint _withdrawBalance,\n', '        uint _countryCode,\n', '        uint _balance,\n', '        uint _currentHolderCount,\n', '        uint _maxHolderNumber\n', '    )\n', '    internal\n', '    pure\n', '    returns (bool)\n', '    {\n', '        bool _needToIncrementCountryHolderCount = _balance == 0;\n', '        bool _needToDecrementCountryHolderCount = _withdrawBalance == _value;\n', '        bool _shouldOverflowCountryHolderCount = _currentHolderCount == _maxHolderNumber;\n', '\n', '        return _withdrawCountryCode == _countryCode && _needToDecrementCountryHolderCount && _needToIncrementCountryHolderCount && _shouldOverflowCountryHolderCount;\n', '    }\n', '\n', '    function _updateCountries(\n', '        uint _value,\n', '        uint _withdrawCountryCode,\n', '        uint _withdrawBalance,\n', '        uint _withdrawCurrentHolderCount,\n', '        uint _countryCode,\n', '        uint _balance,\n', '        uint _currentHolderCount,\n', '        uint _maxHolderNumber\n', '    )\n', '    internal\n', '    {\n', '        if (_isNoNeedInCountryLimitChange(_value, _withdrawCountryCode, _withdrawBalance, _countryCode, _balance, _currentHolderCount, _maxHolderNumber)) {\n', '            return;\n', '        }\n', '\n', '        _updateWithdrawCountry(_value, _withdrawCountryCode, _withdrawBalance, _withdrawCurrentHolderCount);\n', '        _updateDepositCountry(_countryCode, _balance, _currentHolderCount);\n', '    }\n', '\n', '    function _updateWithdrawCountry(\n', '        uint _value,\n', '        uint _countryCode,\n', '        uint _balance,\n', '        uint _currentHolderCount\n', '    )\n', '    internal\n', '    {\n', '        if (_value == _balance && OK != dataController.updateCountryHoldersCount(_countryCode, _currentHolderCount.sub(1))) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function _updateDepositCountry(\n', '        uint _countryCode,\n', '        uint _balance,\n', '        uint _currentHolderCount\n', '    )\n', '    internal\n', '    {\n', '        if (_balance == 0 && OK != dataController.updateCountryHoldersCount(_countryCode, _currentHolderCount.add(1))) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function _getParticipantRoles(address _from, address _to) private view returns (Roles _fromRole, Roles _toRole) {\n', '        _fromRole = dataController.isRegisteredAddress(_from) ? Roles.Holder : (serviceController.isService(_from) ? Roles.Service : Roles.Other);\n', '        _toRole = dataController.isRegisteredAddress(_to) ? Roles.Holder : (serviceController.isService(_to) ? Roles.Service : Roles.Other);\n', '    }\n', '\n', '    function _couldWithdrawFromHolder(address _holder, uint _value) private view returns (bool) {\n', '        bytes32 _holderId = dataController.getHolderExternalIdByAddress(_holder);\n', '        var (, _limPerDay, _limPerMonth, _operational,) = dataController.getHolderInfo(_holderId);\n', '        return _operational ? _isValidWithdrawLimits(_limPerDay, _limPerMonth, _value) : false;\n', '    }\n', '\n', '    function _couldDepositToHolder(address _holder, uint) private view returns (bool) {\n', '        bytes32 _holderId = dataController.getHolderExternalIdByAddress(_holder);\n', '        var (,,, _operational,) = dataController.getHolderInfo(_holderId);\n', '        return _operational;\n', '    }\n', '\n', '    //TODO need additional check: not clear check of country limit:\n', '    function _isValidDepositCountry(uint _balance, uint _currentHolderCount, uint _maxHolderNumber) private pure returns (bool) {\n', '        return !(_balance == 0 && _currentHolderCount == _maxHolderNumber);\n', '    }\n', '\n', '    function _getHoldersInfo(address _to, Roles _toRole, uint, address _from, Roles _fromRole)\n', '    private\n', '    view\n', '    returns (\n', '        uint _fromCountryCode,\n', '        uint _fromBalance,\n', '        uint _toCountryCode,\n', '        uint _toCountryCurrentHolderCount,\n', '        uint _toCountryMaxHolderNumber,\n', '        uint _toBalance\n', '    ) {\n', '        bytes32 _holderId;\n', '        if (_toRole == Roles.Holder) {\n', '            _holderId = dataController.getHolderExternalIdByAddress(_to);\n', '            _toCountryCode = dataController.getHolderCountryCode(_holderId);\n', '            (_toCountryCurrentHolderCount, _toCountryMaxHolderNumber) = dataController.getCountryInfo(_toCountryCode);\n', '            _toBalance = ERC20Interface(proxy).balanceOf(_to);\n', '        }\n', '\n', '        if (_fromRole == Roles.Holder) {\n', '            _holderId = dataController.getHolderExternalIdByAddress(_from);\n', '            _fromCountryCode = dataController.getHolderCountryCode(_holderId);\n', '            _fromBalance = ERC20Interface(proxy).balanceOf(_from);\n', '        }\n', '    }\n', '\n', '    function _isValidCountryLimits(address _to, Roles _toRole, uint _value, address _from, Roles _fromRole) private view returns (bool) {\n', '        var (\n', '        _fromCountryCode,\n', '        _fromBalance,\n', '        _toCountryCode,\n', '        _toCountryCurrentHolderCount,\n', '        _toCountryMaxHolderNumber,\n', '        _toBalance\n', '        ) = _getHoldersInfo(_to, _toRole, _value, _from, _fromRole);\n', '\n', '        //TODO not clear for which case this check\n', '        bool _isValidLimitFromHolder = _fromRole == _toRole && _fromRole == Roles.Holder && !_isValidDepositCountry(_value, _fromCountryCode, _fromBalance, _toCountryCode, _toBalance, _toCountryCurrentHolderCount, _toCountryMaxHolderNumber);\n', '        bool _isValidLimitsToHolder = _toRole == Roles.Holder && !_isValidDepositCountry(_toBalance, _toCountryCurrentHolderCount, _toCountryMaxHolderNumber);\n', '\n', '        return !(_isValidLimitFromHolder || _isValidLimitsToHolder);\n', '    }\n', '\n', '    function _updateTransferLimits(address _to, Roles _toRole, uint _value, address _from, Roles _fromRole) private {\n', '        var (\n', '        _fromCountryCode,\n', '        _fromBalance,\n', '        _toCountryCode,\n', '        _toCountryCurrentHolderCount,\n', '        _toCountryMaxHolderNumber,\n', '        _toBalance\n', '        ) = _getHoldersInfo(_to, _toRole, _value, _from, _fromRole);\n', '\n', '        if (_fromRole == Roles.Holder && OK != dataController.withdrawFrom(_from, _value)) {\n', '            revert();\n', '        }\n', '\n', '        if (_toRole == Roles.Holder && OK != dataController.depositTo(_from, _value)) {\n', '            revert();\n', '        }\n', '\n', '        uint _fromCountryCurrentHolderCount;\n', '        if (_fromRole == Roles.Holder && _fromRole == _toRole) {\n', '            (_fromCountryCurrentHolderCount,) = dataController.getCountryInfo(_fromCountryCode);\n', '            _updateCountries(\n', '                _value,\n', '                _fromCountryCode,\n', '                _fromBalance,\n', '                _fromCountryCurrentHolderCount,\n', '                _toCountryCode,\n', '                _toBalance,\n', '                _toCountryCurrentHolderCount,\n', '                _toCountryMaxHolderNumber\n', '            );\n', '        } else if (_fromRole == Roles.Holder) {\n', '            (_fromCountryCurrentHolderCount,) = dataController.getCountryInfo(_fromCountryCode);\n', '            _updateWithdrawCountry(_value, _fromCountryCode, _fromBalance, _fromCountryCurrentHolderCount);\n', '        } else if (_toRole == Roles.Holder) {\n', '            _updateDepositCountry(_toCountryCode, _toBalance, _toCountryCurrentHolderCount);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title ATx Asset implementation contract.\n', '///\n', '/// Basic asset implementation contract, without any additional logic.\n', '/// Every other asset implementation contracts should derive from this one.\n', '/// Receives calls from the proxy, and calls back immediately without arguments modification.\n', '///\n', '/// Note: all the non constant functions return false instead of throwing in case if state change\n', "/// didn't happen yet.\n", 'contract EEMAsset is ATxAsset {\n', '}']
