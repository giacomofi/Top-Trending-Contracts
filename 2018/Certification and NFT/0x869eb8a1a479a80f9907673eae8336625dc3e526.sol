['pragma solidity ^0.4.25;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMath {\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow.\n', '    */\n', '    function safeSub(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        assert(y <= x);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function safeAdd(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x + y;\n', '        assert(z >= x);\n', '        return z;\n', '    }\n', '\t\n', '\t/**\n', '    * @dev Integer division of two numbers, reverts on division by zero.\n', '    */\n', '    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x / y;\n', '        return z;\n', '    }\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\t\n', '    function safeMul(uint256 x, uint256 y) internal pure returns (uint256) {    \n', '        if (x == 0) {\n', '            return 0;\n', '        }\n', '    \n', '        uint256 z = x * y;\n', '        assert(z / x == y);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the integer percentage of the number.\n', '    */\n', '    function safePerc(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        if (x == 0) {\n', '            return 0;\n', '        }\n', '        \n', '        uint256 z = x * y;\n', '        assert(z / x == y);    \n', '        z = z / 10000; // percent to hundredths\n', '        return z;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the minimum value of two numbers.\n', '    */\t\n', '    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x <= y ? x : y;\n', '        return z;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the maximum value of two numbers.\n', '    */\n', '    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x >= y ? x : y;\n', '        return z;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable contract - base contract with an owner\n', ' */\n', 'contract Ownable {\n', '  \n', '  address public owner;\n', '  address public newOwner;\n', '\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '  \n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    assert(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    assert(_newOwner != address(0));      \n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Accept transferOwnership.\n', '   */\n', '  function acceptOwnership() public {\n', '    if (msg.sender == newOwner) {\n', '      emit OwnershipTransferred(owner, newOwner);\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Agent contract - base contract with an agent\n', ' */\n', 'contract Agent is Ownable {\n', '\n', '  address public defAgent;\n', '\n', '  mapping(address => bool) public Agents;  \n', '\n', '  event UpdatedAgent(address _agent, bool _status);\n', '\n', '  constructor() public {\n', '    defAgent = msg.sender;\n', '    Agents[msg.sender] = true;\n', '  }\n', '  \n', '  modifier onlyAgent() {\n', '    assert(Agents[msg.sender]);\n', '    _;\n', '  }\n', '  \n', '  function updateAgent(address _agent, bool _status) public onlyOwner {\n', '    assert(_agent != address(0));\n', '    Agents[_agent] = _status;\n', '\n', '    emit UpdatedAgent(_agent, _status);\n', '  }  \n', '}\n', '\n', '\n', '/**\n', ' * @title CryptoDuel game\n', ' */\n', 'contract CryptoDuel is Agent, SafeMath {\n', '\n', '    uint public fee = 100;            //  1% from bet\n', '    uint public refGroupFee = 5000;   // 50% from profit\n', '    uint public refLevel1Fee = 1000;  // 10% from profit\n', '    uint public refLevel2Fee = 500;   //  5% from profit\n', '    uint public min = 1000000000000000;       // 0.001 ETH\n', '    uint public max = 1000000000000000000000;  // 1000 ETH\n', '\n', '    uint256 public start = 0;         // Must be equal to the date of issue tokens\n', '    uint256 public period = 30 days;  // By default, the dividend accrual period is 30 days\n', '\n', '    /** State\n', '     *\n', '     * - New: 0\n', '     * - Deleted: 1\n', '     * - OnGoing: 2\n', '     * - Closed: 3\n', '     */\n', '    enum State{New, Deleted, OnGoing, Closed}\n', '\n', '    struct _duel {\n', '        address creator;\n', '        address responder;\n', '        uint bet;\n', '        uint blocknumber;\n', '        int refID;\n', '        State state;\n', '    }\n', '\n', '    _duel[] public Duels;\n', '    mapping(int => address) public RefGroup;                 // RefGroup[id group] = address referrer\n', '    mapping(address => address) public RefAddr;              // RefAddr[address referal] = address referrer\n', '\n', '    mapping(uint => uint) public reward;                     // reward[period] = amount\n', '    mapping(address => uint) public rewardGroup;             // rewardGroup[address] = amount\n', '    mapping(address => uint) public rewardAddr;              // rewardAddr[address] = amount\n', '\n', '    mapping(uint => bool) public AlreadyReward;              // AlreadyReward[period] = true/false\n', '\n', '    event newDuel(uint duel, address indexed creator, address indexed responder, uint bet, int refID);\n', '    event deleteDuel(uint duel);\n', '    event respondDuel(uint duel, address indexed responder);\n', '\n', '    event refundDuel(uint duel);\n', '    event resultDuel(uint duel, address indexed winner, uint sum);\n', '\n', '    event changeMin(uint min);\n', '    event changeMax(uint max);\n', '    \n', '    event changeRefGroup(int ID, address referrer);\n', '    event changeRefAddr(address referal, address referrer);\n', '\n', '    event changeFee(uint fee);\n', '    event changeRefGroupFee(uint refGroupFee);\n', '    event changeRefLevel1Fee(uint refLevel1Fee);\n', '    event changeRefLevel2Fee(uint refLevel2Fee);    \n', '    \n', '    event withdrawProfit(uint fee, address RefGroup);\n', '\n', '    event UpdatedPeriod(uint _period);\n', '\n', '    constructor() public {\n', '        RefGroup[0] = msg.sender;\n', '        emit changeRefGroup(0, msg.sender);\n', '    }\n', '\n', '    function CreateDuel(address _responder) payable external {\n', '\n', '        require(msg.value >= min && msg.value <= max);        \n', '\n', '        Duels.push(_duel({\n', '            creator : msg.sender,\n', '            responder : _responder,\n', '            bet : msg.value,\n', '            blocknumber : 0,\n', '            state : State.New,\n', '            refID : 0\n', '            }));\n', '\n', '        emit newDuel(Duels.length - 1, msg.sender, _responder, msg.value, 0);\n', '    }\n', '\n', '    function CreateDuel(address _responder, int _refID) payable external {\n', '\n', '        require(msg.value >= min && msg.value <= max);\n', '        require(RefGroup[_refID] != address(0));\n', '\n', '        Duels.push(_duel({\n', '            creator : msg.sender,\n', '            responder : _responder,\n', '            bet : msg.value,\n', '            blocknumber : 0,\n', '            state : State.New,\n', '            refID : _refID\n', '            }));\n', '\n', '        emit newDuel(Duels.length - 1, msg.sender, _responder, msg.value, _refID);\n', '    }\n', '\n', '    function RespondDuel(uint _duelID) payable external {\n', '\n', '        _duel storage duel = Duels[_duelID];\n', '\n', '        require(duel.state == State.New);\n', '        require(duel.bet == msg.value);\n', '        require(duel.responder == msg.sender || duel.responder == address(0));\n', '\n', '        duel.state = State.OnGoing;\n', '        duel.responder = msg.sender;\n', '        duel.blocknumber = block.number;\n', '\n', '        emit respondDuel(_duelID, msg.sender);\n', '    }\n', '\n', '\n', '    function DeleteDuel(uint _duelID) external {\n', '\n', '        _duel storage duel = Duels[_duelID];\n', '\n', '        require(duel.creator == msg.sender);\n', '        require(duel.state == State.New);\n', '\n', '        duel.state = State.Deleted;\n', '\n', '        uint duel_fee = safePerc(duel.bet, fee);\n', '\n', '        uint256 N = 1;\n', '        if (block.timestamp > start) {\n', '            N = (block.timestamp - start) / period + 1;\n', '        }\n', '\n', '        reward[N] = safeAdd(reward[N], duel_fee);\n', '\n', '        duel.creator.transfer(safeSub(duel.bet, duel_fee));\n', '\n', '        emit deleteDuel(_duelID);\n', '    }\n', '\n', '\n', '    function GetWin(uint _duelID) external {\n', '\n', '        _duel storage duel = Duels[_duelID];\n', '\n', '        require(duel.state == State.OnGoing);\n', '        require(duel.creator == msg.sender || duel.responder == msg.sender);\n', '        require(block.number > duel.blocknumber + 1);\n', '\n', '        duel.state = State.Closed;\n', '        uint duel_fee = 0;\n', '\n', '        uint256 N = 1;\n', '        if (block.timestamp > start) {\n', '            N = (block.timestamp - start) / period + 1;\n', '        }\n', '\n', '        if (blockhash(duel.blocknumber) == 0 || (block.number - duel.blocknumber) > 256) {\n', '\n', '            duel_fee = safePerc(duel.bet, fee);\n', '\n', '            duel.creator.transfer(safeSub(duel.bet, duel_fee));\n', '            duel.responder.transfer(safeSub(duel.bet, duel_fee));\n', '\n', '            reward[N] = safeAdd(reward[N], safeMul(2, duel_fee));\n', '\n', '            emit refundDuel(_duelID);\n', '\n', '        } else {\n', '\n', '            uint hash = uint(keccak256(abi.encodePacked(blockhash(duel.blocknumber + 1), duel.creator, duel.responder, duel.bet)));\n', '\n', '            uint duel_bet_common = safeMul(2, duel.bet);\n', '            duel_fee = safePerc(duel_bet_common, fee);\n', '\n', '            uint refFee = 0;\n', '            uint sum = safeSub(duel_bet_common, duel_fee);\n', '\n', '            address winner;\n', '\n', '            if (hash % 2 == 0) {\n', '                duel.creator.transfer(sum);\n', '                winner = duel.creator;\n', '                emit resultDuel(_duelID, duel.creator, sum);\n', '\n', '            } else {                \n', '                duel.responder.transfer(sum);\n', '                winner = duel.responder;\n', '                emit resultDuel(_duelID, duel.responder, sum);\n', '            }\n', '\n', '            // ref level 1\n', '            if (RefAddr[winner] != address(0)) {                \n', '                refFee = refLevel1Fee;\n', '                rewardAddr[RefAddr[winner]] = safeAdd(rewardAddr[RefAddr[winner]], safePerc(duel_fee, refLevel1Fee));\n', '\n', '                // ref level 2\n', '                if (RefAddr[RefAddr[winner]] != address(0)) {\n', '                    refFee = safeAdd(refFee, refLevel2Fee);\n', '                    rewardAddr[RefAddr[RefAddr[winner]]] = safeAdd(rewardAddr[RefAddr[RefAddr[winner]]], safePerc(duel_fee, refLevel2Fee));\n', '                }\n', '            }\n', '            \n', '            // ref group\n', '            if (duel.refID != 0) {\n', '                refFee = safeSub(refGroupFee, refFee);\n', '                rewardGroup[RefGroup[duel.refID]] = safeAdd(rewardGroup[RefGroup[duel.refID]], safePerc(duel_fee, refFee));\n', '                reward[N] = safeAdd(reward[N], safeSub(duel_fee, safePerc(duel_fee, refGroupFee)));\n', '            } else {\n', '                reward[N] = safeAdd(reward[N], safeSub(duel_fee, safePerc(duel_fee, refFee)));\n', '            }            \n', '        }\n', '    }\n', '\n', '    function setMin(uint _min) external onlyOwner {\n', '        min = _min;\n', '        emit changeMin(_min);\n', '    }\n', '\n', '    function setMax(uint _max) external onlyOwner {\n', '        max = _max;\n', '        emit changeMax(_max);\n', '    }\n', '\n', '    function setFee(uint _fee) external onlyOwner {\n', '        fee = _fee;\n', '        emit changeFee(_fee);\n', '    }\n', '\n', '    function setRefGroupFee(uint _refGroupFee) external onlyOwner {\n', '        refGroupFee = _refGroupFee;        \n', '        emit changeRefGroupFee(_refGroupFee);\n', '    }\n', '    \n', '    function setRefLevel1Fee(uint _refLevel1Fee) external onlyOwner {\n', '        refLevel1Fee = _refLevel1Fee;\n', '        emit changeRefLevel1Fee(_refLevel1Fee);\n', '    }\n', '\n', '    function setRefLevel2Fee(uint _refLevel2Fee) external onlyOwner {\n', '        refLevel2Fee = _refLevel2Fee;\n', '        emit changeRefLevel2Fee(_refLevel2Fee);\n', '    }\n', '    \n', '    function setRefGroup(int _ID, address _referrer) external onlyAgent {\n', '        RefGroup[_ID] = _referrer;\n', '        emit changeRefGroup(_ID, _referrer);\n', '    }\n', '    \n', '    function setRefAddr(address _referral, address _referrer) external onlyAgent {\n', '        RefAddr[_referral] = _referrer;\n', '        emit changeRefAddr(_referral, _referrer);\n', '    }\n', '\n', '    function withdraw() external onlyOwner returns (bool success) {        \n', '        uint256 N = 1;\n', '        if (block.timestamp > start) {\n', '            N = (block.timestamp - start) / period;\n', '        }\n', '\n', '        if (!AlreadyReward[N]) {\n', '            uint amount = reward[N];\n', '            AlreadyReward[N] = true;\n', '            msg.sender.transfer(amount);\n', '            emit withdrawProfit(amount, msg.sender);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function withdrawRefGroup() external returns (bool success) {\n', '        require(rewardGroup[msg.sender] > 0);\n', '        uint amount = rewardGroup[msg.sender];\n', '        rewardGroup[msg.sender] = 0;\n', '        msg.sender.transfer(amount);\n', '        emit withdrawProfit(amount, msg.sender);\n', '        return true;\n', '    }\n', '\n', '    function withdrawRefAddr() external returns (bool success) {\n', '        require(rewardAddr[msg.sender] > 0);\n', '        uint amount = rewardAddr[msg.sender];\n', '        rewardAddr[msg.sender] = 0;\n', '        msg.sender.transfer(amount);\n', '        emit withdrawProfit(amount, msg.sender);\n', '        return true;\n', '    }\n', '\n', '    function withdrawRefBoth() external returns (bool success) {\n', '        require(rewardAddr[msg.sender] > 0 || rewardGroup[msg.sender] > 0);\n', '        uint amount = safeAdd(rewardAddr[msg.sender], rewardGroup[msg.sender]);\n', '        rewardAddr[msg.sender] = 0;\n', '        rewardGroup[msg.sender] = 0;\n', '        msg.sender.transfer(amount);\n', '        emit withdrawProfit(amount, msg.sender);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Owner can change period\n', '    */\n', '    function setPeriod(uint _period) external onlyOwner {\n', '        period = _period;\n', '        emit UpdatedPeriod(_period);\n', '    }\n', '\n', '    /**\n', '    * Owner can change start\n', '    */\n', '    function setStart(uint _start) external onlyOwner {        \n', '        start = _start;\n', '    }\n', '}']