['pragma solidity ^0.4.24;\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(\n', '    ERC20Basic _token,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.transfer(_to, _value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 _token,\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.transferFrom(_from, _to, _value));\n', '  }\n', '\n', '  function safeApprove(\n', '    ERC20 _token,\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.approve(_spender, _value));\n', '  }\n', '}\n', '\n', '// File: contracts/crowdsale/Crowdsale.sol\n', '\n', '/**\n', ' * @title Crowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale,\n', ' * allowing investors to purchase tokens with ether. This contract implements\n', ' * such functionality in its most fundamental form and can be extended to provide additional\n', ' * functionality and/or custom behavior.\n', ' * The external interface represents the basic interface for purchasing tokens, and conform\n', ' * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\n', ' * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\n', " * the methods to add functionality. Consider using 'super' where appropriate to concatenate\n", ' * behavior.\n', ' */\n', 'contract Crowdsale {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '\n', '    // The token being sold\n', '    ERC20 public token;\n', '\n', '    // Address where funds are collected\n', '    address public wallet;\n', '\n', '    // How many token units a buyer gets per wei.\n', '    // The rate is the conversion between wei and the smallest and indivisible token unit.\n', '    // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK\n', '    // 1 wei will give you 1 unit, or 0.001 TOK.\n', '    uint256 public rate;\n', '\n', '    // Amount of wei raised\n', '    uint256 public weiRaised;\n', '\n', '    // Amount tokens Sold\n', '    uint256 public tokensSold;\n', '    \n', '    /**\n', '    * Event for token purchase logging\n', '    * @param purchaser who paid for the tokens\n', '    * @param beneficiary who got the tokens\n', '    * @param value weis paid for purchase\n', '    * @param amount amount of tokens purchased\n', '    */\n', '    event TokenPurchase(\n', '        address indexed purchaser,\n', '        address indexed beneficiary,\n', '        uint256 value,\n', '        uint256 amount\n', '    );\n', '\n', '    /**\n', '    * @param _rate Number of token units a buyer gets per wei\n', '    * @param _wallet Address where collected funds will be forwarded to\n', '    * @param _token Address of the token being sold\n', '    */\n', '    constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n', '        require(_rate > 0);\n', '        require(_wallet != address(0));\n', '        require(_token != address(0));\n', '\n', '        rate = _rate;\n', '        wallet = _wallet;\n', '        token = _token;\n', '    }\n', '\n', '    // -----------------------------------------\n', '    // Crowdsale external interface\n', '    // -----------------------------------------\n', '\n', '    /**\n', '    * @dev fallback function ***DO NOT OVERRIDE***\n', '    */\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @dev low level token purchase ***DO NOT OVERRIDE***\n', '    * @param _beneficiary Address performing the token purchase\n', '    */\n', '    function buyTokens(address _beneficiary) public payable {\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // calculate token amount to be created\n', '        uint256 tokens = _getTokenAmount(weiAmount);\n', '\n', '        _preValidatePurchase(_beneficiary, weiAmount, tokens);\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        tokensSold = tokensSold.add(tokens);\n', '\n', '        _processPurchase(_beneficiary, tokens);\n', '        emit TokenPurchase(\n', '            msg.sender,\n', '            _beneficiary,\n', '            weiAmount,\n', '            tokens\n', '        );\n', '\n', '        _updatePurchasingState(_beneficiary, weiAmount, tokens);\n', '\n', '        _forwardFunds();\n', '        _postValidatePurchase(_beneficiary, weiAmount, tokens);\n', '    }\n', '\n', '    // -----------------------------------------\n', '    // Internal interface (extensible)\n', '    // -----------------------------------------\n', '\n', '    /**\n', '    * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\n', "    * Example from CappedCrowdsale.sol's _preValidatePurchase method: \n", '    *   super._preValidatePurchase(_beneficiary, _weiAmount);\n', '    *   require(weiRaised.add(_weiAmount) <= cap);\n', '    * @param _beneficiary Address performing the token purchase\n', '    * @param _weiAmount Value in wei involved in the purchase\n', '    * @param _tokenAmount Value in token involved in the purchase\n', '    */\n', '    function _preValidatePurchase(\n', '        address _beneficiary,\n', '        uint256 _weiAmount,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        require(_beneficiary != address(0));\n', '        require(_weiAmount != 0);\n', '    }\n', '\n', '    /**\n', '    * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\n', '    * @param _beneficiary Address performing the token purchase\n', '    * @param _weiAmount Value in wei involved in the purchase\n', '    * @param _tokenAmount Value in token involved in the purchase\n', '    */\n', '    function _postValidatePurchase(\n', '        address _beneficiary,\n', '        uint256 _weiAmount,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        // optional override\n', '    }\n', '\n', '    /**\n', '    * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n', '    * @param _beneficiary Address performing the token purchase\n', '    * @param _tokenAmount Number of tokens to be emitted\n', '    */\n', '    function _deliverTokens(\n', '        address _beneficiary,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        token.safeTransfer(_beneficiary, _tokenAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n', '    * @param _beneficiary Address receiving the tokens\n', '    * @param _tokenAmount Number of tokens to be purchased\n', '    */\n', '    function _processPurchase(\n', '        address _beneficiary,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        _deliverTokens(_beneficiary, _tokenAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\n', '    * @param _beneficiary Address receiving the tokens\n', '    * @param _weiAmount Value in wei involved in the purchase\n', '    * @param _tokenAmount Value in token involved in the purchase\n', '    */\n', '    function _updatePurchasingState(\n', '        address _beneficiary,\n', '        uint256 _weiAmount,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        // optional override\n', '    }\n', '\n', '    /**\n', '    * @dev Override to extend the way in which ether is converted to tokens.\n', '    * @param _weiAmount Value in wei to be converted into tokens\n', '    * @return Number of tokens that can be purchased with the specified _weiAmount\n', '    */\n', '    function _getTokenAmount(uint256 _weiAmount)\n', '        internal view returns (uint256)\n', '    {\n', '        return _weiAmount.mul(rate);\n', '    }\n', '\n', '    /**\n', '    * @dev Determines how ETH is stored/forwarded on purchases.\n', '    */\n', '    function _forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '}\n', '\n', '// File: contracts/crowdsale/validation/TimedCrowdsale.sol\n', '\n', '/**\n', ' * @title TimedCrowdsale\n', ' * @dev Crowdsale accepting contributions only within a time frame.\n', ' */\n', 'contract TimedCrowdsale is Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public openingTime;\n', '    uint256 public closingTime;\n', '\n', '    /**\n', '    * @dev Reverts if not in crowdsale time range.\n', '    */\n', '    modifier onlyWhileOpen {\n', '        // solium-disable-next-line security/no-block-members\n', '        require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Constructor, takes crowdsale opening and closing times.\n', '    * @param _openingTime Crowdsale opening time\n', '    * @param _closingTime Crowdsale closing time\n', '    */\n', '    constructor(uint256 _openingTime, uint256 _closingTime) public {\n', '        // solium-disable-next-line security/no-block-members\n', '        require(_openingTime >= block.timestamp);\n', '        require(_closingTime > _openingTime);\n', '\n', '        openingTime = _openingTime;\n', '        closingTime = _closingTime;\n', '    }\n', '\n', '    /**\n', '    * @dev Checks whether the period in which the crowdsale is open has already elapsed.\n', '    * @return Whether crowdsale period has elapsed\n', '    */\n', '    function hasClosed() public view returns (bool) {\n', '        // solium-disable-next-line security/no-block-members\n', '        return block.timestamp > closingTime;\n', '    }\n', '\n', '    /**\n', '    * @dev Extend parent behavior requiring to be within contributing period\n', '    * @param _beneficiary Token purchaser\n', '    * @param _weiAmount Amount of wei contributed\n', '    * @param _tokenAmount Amount of token purchased\n', '    */\n', '    function _preValidatePurchase(\n', '        address _beneficiary,\n', '        uint256 _weiAmount,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '        onlyWhileOpen\n', '    {\n', '        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/crowdsale/validation/MilestoneCrowdsale.sol\n', '\n', '/**\n', ' * @title MilestoneCrowdsale\n', ' * @dev Crowdsale with multiple milestones separated by time and cap\n', ' * @author Nikola Wyatt <nikola.wyatt@foodnation.io>\n', ' */\n', 'contract MilestoneCrowdsale is TimedCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public constant MAX_MILESTONE = 10;\n', '\n', '    /**\n', '    * Define pricing schedule using milestones.\n', '    */\n', '    struct Milestone {\n', '\n', '        // Milestone index in array\n', '        uint256 index;\n', '\n', '        // UNIX timestamp when this milestone starts\n', '        uint256 startTime;\n', '\n', '        // Amount of tokens sold in milestone\n', '        uint256 tokensSold;\n', '\n', '        // Maximum amount of Tokens accepted in the current Milestone.\n', '        uint256 cap;\n', '\n', '        // How many tokens per wei you will get after this milestone has been passed\n', '        uint256 rate;\n', '\n', '    }\n', '\n', '    /**\n', '    * Store milestones in a fixed array, so that it can be seen in a blockchain explorer\n', '    * Milestone 0 is always (0, 0)\n', '    * (TODO: change this when we confirm dynamic arrays are explorable)\n', '    */\n', '    Milestone[10] public milestones;\n', '\n', '    // How many active milestones have been created\n', '    uint256 public milestoneCount = 0;\n', '\n', '\n', '    bool public milestoningFinished = false;\n', '\n', '    constructor(        \n', '        uint256 _openingTime,\n', '        uint256 _closingTime\n', '        ) \n', '        TimedCrowdsale(_openingTime, _closingTime)\n', '        public \n', '        {\n', '        }\n', '\n', '    /**\n', '    * @dev Contruction, setting a list of milestones\n', '    * @param _milestoneStartTime uint[] milestones start time \n', '    * @param _milestoneCap uint[] milestones cap \n', '    * @param _milestoneRate uint[] milestones price \n', '    */\n', '    function setMilestonesList(uint256[] _milestoneStartTime, uint256[] _milestoneCap, uint256[] _milestoneRate) public {\n', '        // Need to have tuples, length check\n', '        require(!milestoningFinished);\n', '        require(_milestoneStartTime.length > 0);\n', '        require(_milestoneStartTime.length == _milestoneCap.length && _milestoneCap.length == _milestoneRate.length);\n', '        require(_milestoneStartTime[0] == openingTime);\n', '        require(_milestoneStartTime[_milestoneStartTime.length-1] < closingTime);\n', '\n', '        for (uint iterator = 0; iterator < _milestoneStartTime.length; iterator++) {\n', '            if (iterator > 0) {\n', '                assert(_milestoneStartTime[iterator] > milestones[iterator-1].startTime);\n', '            }\n', '            milestones[iterator] = Milestone({\n', '                index: iterator,\n', '                startTime: _milestoneStartTime[iterator],\n', '                tokensSold: 0,\n', '                cap: _milestoneCap[iterator],\n', '                rate: _milestoneRate[iterator]\n', '            });\n', '            milestoneCount++;\n', '        }\n', '        milestoningFinished = true;\n', '    }\n', '\n', '    /**\n', '    * @dev Iterate through milestones. You reach end of milestones when rate = 0\n', '    * @return tuple (time, rate)\n', '    */\n', '    function getMilestoneTimeAndRate(uint256 n) public view returns (uint256, uint256) {\n', '        return (milestones[n].startTime, milestones[n].rate);\n', '    }\n', '\n', '    /**\n', '    * @dev Checks whether the cap of a milestone has been reached.\n', '    * @return Whether the cap was reached\n', '    */\n', '    function capReached(uint256 n) public view returns (bool) {\n', '        return milestones[n].tokensSold >= milestones[n].cap;\n', '    }\n', '\n', '    /**\n', '    * @dev Checks amount of tokens sold in milestone.\n', '    * @return Amount of tokens sold in milestone\n', '    */\n', '    function getTokensSold(uint256 n) public view returns (uint256) {\n', '        return milestones[n].tokensSold;\n', '    }\n', '\n', '    function getFirstMilestone() private view returns (Milestone) {\n', '        return milestones[0];\n', '    }\n', '\n', '    function getLastMilestone() private view returns (Milestone) {\n', '        return milestones[milestoneCount-1];\n', '    }\n', '\n', '    function getFirstMilestoneStartsAt() public view returns (uint256) {\n', '        return getFirstMilestone().startTime;\n', '    }\n', '\n', '    function getLastMilestoneStartsAt() public view returns (uint256) {\n', '        return getLastMilestone().startTime;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the current milestone or bail out if we are not in the milestone periods.\n', '    * @return {[type]} [description]\n', '    */\n', '    function getCurrentMilestoneIndex() internal view onlyWhileOpen returns  (uint256) {\n', '        uint256 index;\n', '\n', '        // Found the current milestone by evaluating time. \n', '        // If (now < next start) the current milestone is the previous\n', '        // Stops loop if finds current\n', '        for(uint i = 0; i < milestoneCount; i++) {\n', '            index = i;\n', '            // solium-disable-next-line security/no-block-members\n', '            if(block.timestamp < milestones[i].startTime) {\n', '                index = i - 1;\n', '                break;\n', '            }\n', '        }\n', '\n', '        // For the next code, you may ask why not assert if last milestone surpass cap...\n', '        // Because if its last and it is capped we would like to finish not sell any more tokens \n', "        // Check if the current milestone has reached it's cap\n", '        if (milestones[index].tokensSold > milestones[index].cap) {\n', '            index = index + 1;\n', '        }\n', '\n', '        return index;\n', '    }\n', '\n', '    /**\n', '    * @dev Extend parent behavior requiring purchase to respect the funding cap from the currentMilestone.\n', '    * @param _beneficiary Token purchaser\n', '    * @param _weiAmount Amount of wei contributed\n', '    * @param _tokenAmount Amount of token purchased\n', '    \n', '    */\n', '    function _preValidatePurchase(\n', '        address _beneficiary,\n', '        uint256 _weiAmount,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\n', '        require(milestones[getCurrentMilestoneIndex()].tokensSold.add(_tokenAmount) <= milestones[getCurrentMilestoneIndex()].cap);\n', '    }\n', '\n', '    /**\n', '    * @dev Extend parent behavior to update current milestone state and index\n', '    * @param _beneficiary Token purchaser\n', '    * @param _weiAmount Amount of wei contributed\n', '    * @param _tokenAmount Amount of token purchased\n', '    */\n', '    function _updatePurchasingState(\n', '        address _beneficiary,\n', '        uint256 _weiAmount,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        super._updatePurchasingState(_beneficiary, _weiAmount, _tokenAmount);\n', '        milestones[getCurrentMilestoneIndex()].tokensSold = milestones[getCurrentMilestoneIndex()].tokensSold.add(_tokenAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Get the current price.\n', '    * @return The current price or 0 if we are outside milestone period\n', '    */\n', '    function getCurrentRate() internal view returns (uint result) {\n', '        return milestones[getCurrentMilestoneIndex()].rate;\n', '    }\n', '\n', '    /**\n', '    * @dev Override to extend the way in which ether is converted to tokens.\n', '    * @param _weiAmount Value in wei to be converted into tokens\n', '    * @return Number of tokens that can be purchased with the specified _weiAmount\n', '    */\n', '    function _getTokenAmount(uint256 _weiAmount)\n', '        internal view returns (uint256)\n', '    {\n', '        return _weiAmount.mul(getCurrentRate());\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/price/USDPrice.sol\n', '\n', '/**\n', '* @title USDPrice\n', '* @dev Contract that calculates the price of tokens in USD cents.\n', '* Note that this contracts needs to be updated\n', '*/\n', 'contract USDPrice is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // PRICE of 1 ETHER in USD in cents\n', '    // So, if price is: $271.90, the value in variable will be: 27190\n', '    uint256 public ETHUSD;\n', '\n', '    // Time of Last Updated Price\n', '    uint256 public updatedTime;\n', '\n', '    // Historic price of ETH in USD in cents\n', '    mapping (uint256 => uint256) public priceHistory;\n', '\n', '    event PriceUpdated(uint256 price);\n', '\n', '    constructor() public {\n', '    }\n', '\n', '    function getHistoricPrice(uint256 time) public view returns (uint256) {\n', '        return priceHistory[time];\n', '    } \n', '\n', '    function updatePrice(uint256 price) public onlyOwner {\n', '        require(price > 0);\n', '\n', '        priceHistory[updatedTime] = ETHUSD;\n', '\n', '        ETHUSD = price;\n', '        // solium-disable-next-line security/no-block-members\n', '        updatedTime = block.timestamp;\n', '\n', '        emit PriceUpdated(ETHUSD);\n', '    }\n', '\n', '    /**\n', '    * @dev Override to extend the way in which ether is converted to USD.\n', '    * @param _weiAmount Value in wei to be converted into tokens\n', '    * @return The value of wei amount in USD cents\n', '    */\n', '    function getPrice(uint256 _weiAmount)\n', '        public view returns (uint256)\n', '    {\n', '        return _weiAmount.mul(ETHUSD);\n', '    }\n', '    \n', '}\n', '\n', '// File: contracts/Sale.sol\n', '\n', 'interface MintableERC20 {\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '}\n', '/**\n', ' * @title PreSale\n', ' * @dev Crowdsale accepting contributions only within a time frame, \n', ' * having milestones defined, the price is defined in USD\n', ' * having a mechanism to refund sales if soft cap not capReached();\n', ' */\n', 'contract PreSale is Ownable, Crowdsale, MilestoneCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    /// Max amount of tokens to be contributed\n', '    uint256 public cap;\n', '\n', '    /// Minimum amount of wei per contribution\n', '    uint256 public minimumContribution;\n', '    \n', '    bool public isFinalized = false;\n', '\n', '    USDPrice private usdPrice; \n', '\n', '    event Finalized();\n', '\n', '    constructor(\n', '        uint256 _rate,\n', '        address _wallet,\n', '        ERC20 _token,\n', '        uint256 _openingTime,\n', '        uint256 _closingTime,\n', '        uint256 _cap,\n', '        uint256 _minimumContribution,\n', '        USDPrice _usdPrice\n', '    )\n', '        Crowdsale(_rate, _wallet, _token)\n', '        MilestoneCrowdsale(_openingTime, _closingTime)\n', '        public\n', '    {  \n', '        require(_cap > 0);\n', '        require(_minimumContribution > 0);\n', '        \n', '        cap = _cap;\n', '        minimumContribution = _minimumContribution;\n', '\n', '        usdPrice = _usdPrice;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Checks whether the cap has been reached.\n', '    * @return Whether the cap was reached\n', '    */\n', '    function capReached() public view returns (bool) {\n', '        return tokensSold >= cap;\n', '    }\n', '\n', '    /**\n', '    * @dev Must be called after crowdsale ends, to do some extra finalization\n', "    * work. Calls the contract's finalization function.\n", '    */\n', '    function finalize() public onlyOwner {\n', '        require(!isFinalized);\n', '        require(hasClosed());\n', '\n', '        emit Finalized();\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '    /**\n', '    * @dev Override to extend the way in which ether is converted to tokens.\n', '    * @param _weiAmount Value in wei to be converted into tokens\n', '    * @return Number of tokens that can be purchased with the specified _weiAmount\n', '    */\n', '    function _getTokenAmount(uint256 _weiAmount)\n', '        internal view returns (uint256)\n', '    {\n', '        return usdPrice.getPrice(_weiAmount).div(getCurrentRate());\n', '    }\n', '\n', '    /**\n', '    * @dev Extend parent behavior sending heartbeat to token.\n', '    * @param _beneficiary Address receiving the tokens\n', '    * @param _weiAmount Value in wei involved in the purchase\n', '    * @param _tokenAmount Value in token involved in the purchase\n', '    */\n', '    function _updatePurchasingState(\n', '        address _beneficiary,\n', '        uint256 _weiAmount,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        super._updatePurchasingState(_beneficiary, _weiAmount, _tokenAmount);\n', '    }\n', '    \n', '    /**\n', '    * @dev Overrides delivery by minting tokens upon purchase. - MINTED Crowdsale\n', '    * @param _beneficiary Token purchaser\n', '    * @param _tokenAmount Number of tokens to be minted\n', '    */\n', '    function _deliverTokens(\n', '        address _beneficiary,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        // Potentially dangerous assumption about the type of the token.\n', '        require(MintableERC20(address(token)).mint(_beneficiary, _tokenAmount));\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Extend parent behavior requiring purchase to respect the funding cap.\n', '    * @param _beneficiary Token purchaser\n', '    * @param _weiAmount Amount of wei contributed\n', '    * @param _tokenAmount Amount of token purchased\n', '    */\n', '    function _preValidatePurchase(\n', '        address _beneficiary,\n', '        uint256 _weiAmount,\n', '        uint256 _tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\n', '        require(_weiAmount >= minimumContribution);\n', '        require(tokensSold.add(_tokenAmount) <= cap);\n', '    }\n', '\n', '}']