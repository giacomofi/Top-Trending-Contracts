['pragma solidity 0.4.24;\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/v2/auctions/ArtistAcceptingBids.sol\n', '\n', '/**\n', '* Auction interface definition - event and method definitions\n', '*\n', '* https://www.knownorigin.io/\n', '*/\n', 'interface IAuction {\n', '\n', '  event BidPlaced(\n', '    address indexed _bidder,\n', '    uint256 indexed _editionNumber,\n', '    uint256 indexed _amount\n', '  );\n', '\n', '  event BidIncreased(\n', '    address indexed _bidder,\n', '    uint256 indexed _editionNumber,\n', '    uint256 indexed _amount\n', '  );\n', '\n', '  event BidWithdrawn(\n', '    address indexed _bidder,\n', '    uint256 indexed _editionNumber\n', '  );\n', '\n', '  event BidAccepted(\n', '    address indexed _bidder,\n', '    uint256 indexed _editionNumber,\n', '    uint256 indexed _tokenId,\n', '    uint256 _amount\n', '  );\n', '\n', '  event BidderRefunded(\n', '    uint256 indexed _editionNumber,\n', '    address indexed _bidder,\n', '    uint256 indexed _amount\n', '  );\n', '\n', '  event AuctionCancelled(\n', '    uint256 indexed _editionNumber\n', '  );\n', '\n', '  function placeBid(uint256 _editionNumber) public payable returns (bool success);\n', '\n', '  function increaseBid(uint256 _editionNumber) public payable returns (bool success);\n', '\n', '  function withdrawBid(uint256 _editionNumber) public returns (bool success);\n', '\n', '  function acceptBid(uint256 _editionNumber) public returns (uint256 tokenId);\n', '\n', '  function cancelAuction(uint256 _editionNumber) public returns (bool success);\n', '}\n', '\n', '/**\n', '* Minimal interface definition for KODA V2 contract calls\n', '*\n', '* https://www.knownorigin.io/\n', '*/\n', 'interface IKODAV2 {\n', '  function mint(address _to, uint256 _editionNumber) external returns (uint256);\n', '\n', '  function editionExists(uint256 _editionNumber) external returns (bool);\n', '\n', '  function totalRemaining(uint256 _editionNumber) external view returns (uint256);\n', '\n', '  function artistCommission(uint256 _editionNumber) external view returns (address _artistAccount, uint256 _artistCommission);\n', '}\n', '\n', '/**\n', '* @title Artists accepting bidding contract for KnownOrigin (KODA)\n', '*\n', '* Rules:\n', '* Can only bid for an edition which is enabled\n', '* Can only add new bids higher than previous highest bid plus minimum bid amount\n', '* Can increase your bid, only if you are the top current bidder\n', '* Once outbid, original bidder has ETH returned\n', '* Cannot double bid once you are already the highest bidder, can only call increaseBid()\n', '* Only the defined controller address can accept the bid\n', '* If a bid is revoked, the auction remains open however no highest bid exists\n', '* If the contract is Paused, no public actions can happen e.g. bids, increases, withdrawals\n', '* Managers of contract have full control over it act as a fallback in-case funds go missing or errors are found\n', '* On accepting of any bid, funds are split to KO and Artists - optional 3rd party split not currently supported\n', '* If an edition is sold out, the auction is stopped, manual refund required by bidder or owner\n', '* Upon cancelling a bid which is in flight, funds are returned and contract stops further bids on the edition\n', '* Artists commissions and address are pulled from the KODA contract and are not based on the controller address\n', '*\n', '* Scenario:\n', '* 1) Config artist (Dave) & edition (1000)\n', '* 2) Bob places a bid on edition 1000 for 1 ETH\n', '* 3) Alice places a higher bid of 1.5ETH, overriding Bobs position as the leader, sends Bobs 1 ETH back and taking 1st place\n', "* 4) Dave accepts Alice's bid\n", '* 5) KODA token generated and transferred to Alice, funds are split between KO and Artist\n', '*\n', '* https://www.knownorigin.io/\n', '*\n', '* BE ORIGINAL. BUY ORIGINAL.\n', '*/\n', 'contract ArtistAcceptingBids is Ownable, Pausable, IAuction {\n', '  using SafeMath for uint256;\n', '\n', '  // A mapping of the controller address to the edition number\n', '  mapping(uint256 => address) internal editionNumberToArtistControlAddress;\n', '\n', '  // Enabled/disable the auction for the edition number\n', '  mapping(uint256 => bool) internal enabledEditions;\n', '\n', '  // Edition to current highest bidders address\n', '  mapping(uint256 => address) internal editionHighestBid;\n', '\n', '  // Mapping for edition -> bidder -> bid amount\n', '  mapping(uint256 => mapping(address => uint256)) internal editionBids;\n', '\n', '  // Min increase in bid amount\n', '  uint256 public minBidAmount = 0.01 ether;\n', '\n', '  // Interface into the KODA world\n', '  IKODAV2 public kodaAddress;\n', '\n', '  // KO account which can receive commission\n', '  address public koCommissionAccount;\n', '\n', '  ///////////////\n', '  // Modifiers //\n', '  ///////////////\n', '\n', '  // Checks the auction is enabled\n', '  modifier whenAuctionEnabled(uint256 _editionNumber) {\n', '    require(enabledEditions[_editionNumber], "Edition is not enabled for auctions");\n', '    _;\n', '  }\n', '\n', '  // Checks the msg.sender is the artists control address or the auction owner\n', '  modifier whenCallerIsController(uint256 _editionNumber) {\n', '    require(editionNumberToArtistControlAddress[_editionNumber] == msg.sender || msg.sender == owner, "Edition not managed by calling address");\n', '    _;\n', '  }\n', '\n', '  // Checks the bid is higher than the current amount + min bid\n', '  modifier whenPlacedBidIsAboveMinAmount(uint256 _editionNumber) {\n', '    address currentHighestBidder = editionHighestBid[_editionNumber];\n', '    uint256 currentHighestBidderAmount = editionBids[_editionNumber][currentHighestBidder];\n', '    require(currentHighestBidderAmount.add(minBidAmount) <= msg.value, "Bids must be higher than previous bids plus minimum bid");\n', '    _;\n', '  }\n', '\n', '  // Checks the bid is higher than the min bid\n', '  modifier whenBidIncreaseIsAboveMinAmount() {\n', '    require(minBidAmount <= msg.value, "Bids must be higher than minimum bid amount");\n', '    _;\n', '  }\n', '\n', '  // Check the caller in not already the highest bidder\n', '  modifier whenCallerNotAlreadyTheHighestBidder(uint256 _editionNumber) {\n', '    address currentHighestBidder = editionHighestBid[_editionNumber];\n', '    require(currentHighestBidder != msg.sender, "Cant bid anymore, you are already the current highest");\n', '    _;\n', '  }\n', '\n', '  // Checks msg.sender is the highest bidder\n', '  modifier whenCallerIsHighestBidder(uint256 _editionNumber) {\n', '    require(editionHighestBid[_editionNumber] == msg.sender, "Can only withdraw a bid if you are the highest bidder");\n', '    _;\n', '  }\n', '\n', '  // Only when editions are not sold out in KODA\n', '  modifier whenEditionNotSoldOut(uint256 _editionNumber) {\n', '    uint256 totalRemaining = kodaAddress.totalRemaining(_editionNumber);\n', '    require(totalRemaining > 0, "Unable to accept any more bids, edition is sold out");\n', '    _;\n', '  }\n', '\n', '  // Only when edition exists in KODA\n', '  modifier whenEditionExists(uint256 _editionNumber) {\n', '    bool editionExists = kodaAddress.editionExists(_editionNumber);\n', '    require(editionExists, "Edition does not exist");\n', '    _;\n', '  }\n', '\n', '  /////////////////\n', '  // Constructor //\n', '  /////////////////\n', '\n', '  // Set the caller as the default KO account\n', '  constructor(IKODAV2 _kodaAddress) public {\n', '    kodaAddress = _kodaAddress;\n', '    koCommissionAccount = msg.sender;\n', '  }\n', '\n', '  //////////////////////////\n', '  // Core Auction Methods //\n', '  //////////////////////////\n', '\n', '  /**\n', '   * @dev Public method for placing a bid, reverts if:\n', '   * - Contract is Paused\n', '   * - Edition provided is not valid\n', '   * - Edition provided is not configured for auctions\n', '   * - Edition provided is sold out\n', '   * - msg.sender is already the highest bidder\n', '   * - msg.value is not greater than highest bid + minimum amount\n', '   * @dev refunds the previous bidders ether if the bid is overwritten\n', '   * @return true on success\n', '   */\n', '  function placeBid(uint256 _editionNumber)\n', '  public\n', '  payable\n', '  whenNotPaused\n', '  whenEditionExists(_editionNumber)\n', '  whenAuctionEnabled(_editionNumber)\n', '  whenPlacedBidIsAboveMinAmount(_editionNumber)\n', '  whenCallerNotAlreadyTheHighestBidder(_editionNumber)\n', '  whenEditionNotSoldOut(_editionNumber)\n', '  returns (bool success)\n', '  {\n', '    // Grab the previous holders bid so we can refund it\n', '    _refundHighestBidder(_editionNumber);\n', '\n', '    // Keep a record of the current users bid (previous bidder has been refunded)\n', '    editionBids[_editionNumber][msg.sender] = msg.value;\n', '\n', '    // Update the highest bid to be the latest bidder\n', '    editionHighestBid[_editionNumber] = msg.sender;\n', '\n', '    // Emit event\n', '    emit BidPlaced(msg.sender, _editionNumber, msg.value);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Public method for increasing your bid, reverts if:\n', '   * - Contract is Paused\n', '   * - Edition provided is not valid\n', '   * - Edition provided is not configured for auctions\n', '   * - Edition provided is sold out\n', '   * - msg.sender is not the current highest bidder\n', '   * @return true on success\n', '   */\n', '  function increaseBid(uint256 _editionNumber)\n', '  public\n', '  payable\n', '  whenNotPaused\n', '  whenBidIncreaseIsAboveMinAmount\n', '  whenEditionExists(_editionNumber)\n', '  whenAuctionEnabled(_editionNumber)\n', '  whenEditionNotSoldOut(_editionNumber)\n', '  whenCallerIsHighestBidder(_editionNumber)\n', '  returns (bool success)\n', '  {\n', '    // Bump the current highest bid by provided amount\n', '    editionBids[_editionNumber][msg.sender] = editionBids[_editionNumber][msg.sender].add(msg.value);\n', '\n', '    // Emit event\n', '    emit BidIncreased(msg.sender, _editionNumber, editionBids[_editionNumber][msg.sender]);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Public method for withdrawing your bid, reverts if:\n', '   * - Contract is Paused\n', '   * - msg.sender is not the current highest bidder\n', '   * @dev removes current highest bid so there is no current highest bidder\n', '   * @return true on success\n', '   */\n', '  function withdrawBid(uint256 _editionNumber)\n', '  public\n', '  whenNotPaused\n', '  whenEditionExists(_editionNumber)\n', '  whenCallerIsHighestBidder(_editionNumber)\n', '  returns (bool success)\n', '  {\n', '    // get current highest bid and refund it\n', '    _refundHighestBidder(_editionNumber);\n', '\n', '    // Fire event\n', '    emit BidWithdrawn(msg.sender, _editionNumber);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Method for cancelling an auction, only called from contract owner\n', '   * @dev refunds previous highest bidders bid\n', '   * @dev removes current highest bid so there is no current highest bidder\n', '   * @return true on success\n', '   */\n', '  function cancelAuction(uint256 _editionNumber)\n', '  public\n', '  onlyOwner\n', '  whenEditionExists(_editionNumber)\n', '  returns (bool success)\n', '  {\n', '    // get current highest bid and refund it\n', '    _refundHighestBidder(_editionNumber);\n', '\n', '    // Disable the auction\n', '    enabledEditions[_editionNumber] = false;\n', '\n', '    // Fire event\n', '    emit AuctionCancelled(_editionNumber);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Method for accepting the highest bid, only called by edition creator, reverts if:\n', '   * - Contract is Paused\n', '   * - msg.sender is not the edition controller\n', '   * - Edition provided is not valid\n', '   * @dev Mints a new token in KODA contract\n', '   * @dev Splits bid amount to KO and Artist, based on KODA contract defined values\n', '   * @dev Removes current highest bid so there is no current highest bidder\n', '   * @dev If no more editions are available the auction is stopped\n', '   * @return the generated tokenId on success\n', '   */\n', '  function acceptBid(uint256 _editionNumber)\n', '  public\n', '  whenNotPaused\n', '  whenCallerIsController(_editionNumber) // Checks only the controller can call this\n', '  whenAuctionEnabled(_editionNumber) // Checks auction is still enabled\n', '  returns (uint256 tokenId)\n', '  {\n', '    // Get total remaining here so we can use it below\n', '    uint256 totalRemaining = kodaAddress.totalRemaining(_editionNumber);\n', '    require(totalRemaining > 0, "Unable to accept bid, edition is sold out");\n', '\n', '    // Get the winner of the bidding action\n', '    address winningAccount = editionHighestBid[_editionNumber];\n', '    require(winningAccount != address(0), "Cannot win an auction when there is no highest bidder");\n', '\n', '    uint256 winningBidAmount = editionBids[_editionNumber][winningAccount];\n', '    require(winningBidAmount >= 0, "Cannot win an auction when no bid amount set");\n', '\n', '    // Mint a new token to the winner\n', '    uint256 _tokenId = kodaAddress.mint(winningAccount, _editionNumber);\n', '    require(_tokenId != 0, "Failed to mint new token");\n', '\n', '    // Get the commission and split bid amount accordingly\n', '    address artistAccount;\n', '    uint256 artistCommission;\n', '    (artistAccount, artistCommission) = kodaAddress.artistCommission(_editionNumber);\n', '\n', '    // Extract the artists commission and send it\n', '    uint256 artistPayment = winningBidAmount.div(100).mul(artistCommission);\n', '    if (artistPayment > 0) {\n', '      artistAccount.transfer(artistPayment);\n', '    }\n', '\n', '    // Send KO remaining amount\n', '    uint256 remainingCommission = winningBidAmount.sub(artistPayment);\n', '    if (remainingCommission > 0) {\n', '      koCommissionAccount.transfer(remainingCommission);\n', '    }\n', '\n', '    // Clear out highest bidder for this auction\n', '    delete editionHighestBid[_editionNumber];\n', '\n', '    // If the edition is sold out, disable the auction\n', '    if (totalRemaining.sub(1) == 0) {\n', '      enabledEditions[_editionNumber] = false;\n', '    }\n', '\n', '    // Fire event\n', '    emit BidAccepted(winningAccount, _editionNumber, _tokenId, winningBidAmount);\n', '\n', '    return _tokenId;\n', '  }\n', '\n', '  /**\n', '   * Returns funds of the previous highest bidder back to them if present\n', '   */\n', '  function _refundHighestBidder(uint256 _editionNumber) internal {\n', '    // Get current highest bidder\n', '    address currentHighestBidder = editionHighestBid[_editionNumber];\n', '\n', '    // Get current highest bid amount\n', '    uint256 currentHighestBiddersAmount = editionBids[_editionNumber][currentHighestBidder];\n', '\n', '    if (currentHighestBidder != address(0) && currentHighestBiddersAmount > 0) {\n', '\n', '      // Clear out highest bidder as there is no long one\n', '      delete editionHighestBid[_editionNumber];\n', '\n', '      // Refund it\n', '      currentHighestBidder.transfer(currentHighestBiddersAmount);\n', '\n', '      // Emit event\n', '      emit BidderRefunded(_editionNumber, currentHighestBidder, currentHighestBiddersAmount);\n', '    }\n', '  }\n', '\n', '  ///////////////////////////////\n', '  // Public management methods //\n', '  ///////////////////////////////\n', '\n', '  /**\n', '   * @dev Enables the edition for auctions\n', '   * @dev Only callable from owner\n', '   */\n', '  function enableEdition(uint256 _editionNumber) onlyOwner public returns (bool) {\n', '    enabledEditions[_editionNumber] = true;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Disables the edition for auctions\n', '   * @dev Only callable from owner\n', '   */\n', '  function disableEdition(uint256 _editionNumber) onlyOwner public returns (bool) {\n', '    enabledEditions[_editionNumber] = false;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the edition artist control address\n', '   * @dev Only callable from owner\n', '   */\n', '  function setArtistsControlAddress(uint256 _editionNumber, address _address) onlyOwner public returns (bool) {\n', '    editionNumberToArtistControlAddress[_editionNumber] = _address;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the edition artist control address and enables the edition for auction\n', '   * @dev Only callable from owner\n', '   */\n', '  function setArtistsControlAddressAndEnabledEdition(uint256 _editionNumber, address _address) onlyOwner public returns (bool) {\n', '    enabledEditions[_editionNumber] = true;\n', '    editionNumberToArtistControlAddress[_editionNumber] = _address;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the minimum bid amount\n', '   * @dev Only callable from owner\n', '   */\n', '  function setMinBidAmount(uint256 _minBidAmount) onlyOwner public {\n', '    minBidAmount = _minBidAmount;\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the KODA address\n', '   * @dev Only callable from owner\n', '   */\n', '  function setKodavV2(IKODAV2 _kodaAddress) onlyOwner public {\n', '    kodaAddress = _kodaAddress;\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the KODA address\n', '   * @dev Only callable from owner\n', '   */\n', '  function setKoCommissionAccount(address _koCommissionAccount) public onlyOwner {\n', '    require(_koCommissionAccount != address(0), "Invalid address");\n', '    koCommissionAccount = _koCommissionAccount;\n', '  }\n', '\n', '  /////////////////////////////\n', '  // Manual Override methods //\n', '  /////////////////////////////\n', '\n', '  /**\n', '   * @dev Allows for the ability to extract ether so we can distribute to the correct bidders accordingly\n', '   * @dev Only callable from owner\n', '   */\n', '  function withdrawStuckEther(address _withdrawalAccount) onlyOwner public {\n', '    require(_withdrawalAccount != address(0), "Invalid address provided");\n', '    require(address(this).balance != 0, "No more ether to withdraw");\n', '    _withdrawalAccount.transfer(address(this).balance);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows for the ability to extract specific ether amounts so we can distribute to the correct bidders accordingly\n', '   * @dev Only callable from owner\n', '   */\n', '  function withdrawStuckEtherOfAmount(address _withdrawalAccount, uint256 _amount) onlyOwner public {\n', '    require(_withdrawalAccount != address(0), "Invalid address provided");\n', '    require(_amount != 0, "Invalid amount to withdraw");\n', '    require(address(this).balance >= _amount, "No more ether to withdraw");\n', '    _withdrawalAccount.transfer(_amount);\n', '  }\n', '\n', '  /**\n', '   * @dev Manual override method for setting edition highest bid & the highest bidder to the provided address\n', '   * @dev Only callable from owner\n', '   */\n', '  function manualOverrideEditionHighestBidAndBidder(uint256 _editionNumber, address _bidder, uint256 _amount) onlyOwner public returns (bool) {\n', '    editionBids[_editionNumber][_bidder] = _amount;\n', '    editionHighestBid[_editionNumber] = _bidder;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Manual override method removing bidding values\n', '   * @dev Only callable from owner\n', '   */\n', '  function manualDeleteEditionBids(uint256 _editionNumber, address _bidder) onlyOwner public returns (bool) {\n', '    delete editionHighestBid[_editionNumber];\n', '    delete editionBids[_editionNumber][_bidder];\n', '    return true;\n', '  }\n', '\n', '  //////////////////////////\n', '  // Public query methods //\n', '  //////////////////////////\n', '\n', '  /**\n', '   * @dev Look up all the known data about the latest edition bidding round\n', '   * @dev Returns zeros for all values when not valid\n', '   */\n', '  function auctionDetails(uint256 _editionNumber) public view returns (bool _enabled, address _bidder, uint256 _value, address _controller) {\n', '    address highestBidder = editionHighestBid[_editionNumber];\n', '    uint256 bidValue = editionBids[_editionNumber][highestBidder];\n', '    address controlAddress = editionNumberToArtistControlAddress[_editionNumber];\n', '    return (\n', '    enabledEditions[_editionNumber],\n', '    highestBidder,\n', '    bidValue,\n', '    controlAddress\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Look up all the current highest bidder for the latest edition\n', '   * @dev Returns zeros for all values when not valid\n', '   */\n', '  function highestBidForEdition(uint256 _editionNumber) public view returns (address _bidder, uint256 _value) {\n', '    address highestBidder = editionHighestBid[_editionNumber];\n', '    uint256 bidValue = editionBids[_editionNumber][highestBidder];\n', '    return (highestBidder, bidValue);\n', '  }\n', '\n', '  /**\n', '   * @dev Check an edition is enabled for auction\n', '   */\n', '  function isEditionEnabled(uint256 _editionNumber) public view returns (bool) {\n', '    return enabledEditions[_editionNumber];\n', '  }\n', '\n', '  /**\n', '   * @dev Check which address can action a bid for the given edition\n', '   */\n', '  function editionController(uint256 _editionNumber) public view returns (address) {\n', '    return editionNumberToArtistControlAddress[_editionNumber];\n', '  }\n', '\n', '}']