['pragma solidity ^0.4.19;\n', '\n', '// File: zeppelin/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '// File: zeppelin/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin/contracts/ownership/HasNoEther.sol\n', '\n', '/**\n', ' * @title Contracts that should not own Ether\n', ' * @author Remco Bloemen <<span class="__cf_email__" data-cfemail="b8caddd5dbd7f88a">[email&#160;protected]</span>π.com>\n', ' * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\n', ' * in the contract, it will allow the owner to reclaim this ether.\n', ' * @notice Ether can still be send to this contract by:\n', ' * calling functions labeled `payable`\n', ' * `selfdestruct(contract_address)`\n', ' * mining directly to the contract address\n', '*/\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  function HasNoEther() payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    assert(owner.send(this.balance));\n', '  }\n', '}\n', '\n', '// File: contracts/presale/AxiePresale.sol\n', '\n', 'contract AxiePresale is HasNoEther, Pausable {\n', '  using SafeMath for uint256;\n', '\n', '  // No Axies can be adopted after this end date: Friday, March 16, 2018 11:59:59 PM GMT.\n', '  uint256 constant public PRESALE_END_TIMESTAMP = 1521244799;\n', '\n', '  uint8 constant public CLASS_BEAST = 0;\n', '  uint8 constant public CLASS_AQUATIC = 2;\n', '  uint8 constant public CLASS_PLANT = 4;\n', '\n', '  uint256 constant public INITIAL_PRICE_INCREMENT = 1600 szabo; // 0.0016 Ether\n', '  uint256 constant public INITIAL_PRICE = INITIAL_PRICE_INCREMENT;\n', '  uint256 constant public REF_CREDITS_PER_AXIE = 5;\n', '\n', '  mapping (uint8 => uint256) public currentPrices;\n', '  mapping (uint8 => uint256) public priceIncrements;\n', '\n', '  mapping (uint8 => uint256) public totalAxiesAdopted;\n', '  mapping (address => mapping (uint8 => uint256)) public axiesAdopted;\n', '\n', '  mapping (address => uint256) public referralCredits;\n', '  mapping (address => uint256) public axiesRewarded;\n', '  uint256 public totalAxiesRewarded;\n', '\n', '  event AxiesAdopted(\n', '    address indexed adopter,\n', '    uint8 indexed clazz,\n', '    uint256 quantity,\n', '    address indexed referrer\n', '  );\n', '\n', '  event AxiesRewarded(address indexed receiver, uint256 quantity);\n', '\n', '  event AdoptedAxiesRedeemed(address indexed receiver, uint8 indexed clazz, uint256 quantity);\n', '  event RewardedAxiesRedeemed(address indexed receiver, uint256 quantity);\n', '\n', '  function AxiePresale() public {\n', '    priceIncrements[CLASS_BEAST] = priceIncrements[CLASS_AQUATIC] = //\n', '      priceIncrements[CLASS_PLANT] = INITIAL_PRICE_INCREMENT;\n', '\n', '    currentPrices[CLASS_BEAST] = currentPrices[CLASS_AQUATIC] = //\n', '      currentPrices[CLASS_PLANT] = INITIAL_PRICE;\n', '  }\n', '\n', '  function axiesPrice(\n', '    uint256 beastQuantity,\n', '    uint256 aquaticQuantity,\n', '    uint256 plantQuantity\n', '  )\n', '    public\n', '    view\n', '    returns (uint256 totalPrice)\n', '  {\n', '    uint256 price;\n', '\n', '    (price,,) = _axiesPrice(CLASS_BEAST, beastQuantity);\n', '    totalPrice = totalPrice.add(price);\n', '\n', '    (price,,) = _axiesPrice(CLASS_AQUATIC, aquaticQuantity);\n', '    totalPrice = totalPrice.add(price);\n', '\n', '    (price,,) = _axiesPrice(CLASS_PLANT, plantQuantity);\n', '    totalPrice = totalPrice.add(price);\n', '  }\n', '\n', '  function adoptAxies(\n', '    uint256 beastQuantity,\n', '    uint256 aquaticQuantity,\n', '    uint256 plantQuantity,\n', '    address referrer\n', '  )\n', '    public\n', '    payable\n', '    whenNotPaused\n', '  {\n', '    require(now <= PRESALE_END_TIMESTAMP);\n', '\n', '    require(beastQuantity <= 3);\n', '    require(aquaticQuantity <= 3);\n', '    require(plantQuantity <= 3);\n', '\n', '    address adopter = msg.sender;\n', '    address actualReferrer = 0x0;\n', '\n', '    // An adopter cannot be his/her own referrer.\n', '    if (referrer != adopter) {\n', '      actualReferrer = referrer;\n', '    }\n', '\n', '    uint256 value = msg.value;\n', '    uint256 price;\n', '\n', '    if (beastQuantity > 0) {\n', '      price = _adoptAxies(\n', '        adopter,\n', '        CLASS_BEAST,\n', '        beastQuantity,\n', '        actualReferrer\n', '      );\n', '\n', '      require(value >= price);\n', '      value -= price;\n', '    }\n', '\n', '    if (aquaticQuantity > 0) {\n', '      price = _adoptAxies(\n', '        adopter,\n', '        CLASS_AQUATIC,\n', '        aquaticQuantity,\n', '        actualReferrer\n', '      );\n', '\n', '      require(value >= price);\n', '      value -= price;\n', '    }\n', '\n', '    if (plantQuantity > 0) {\n', '      price = _adoptAxies(\n', '        adopter,\n', '        CLASS_PLANT,\n', '        plantQuantity,\n', '        actualReferrer\n', '      );\n', '\n', '      require(value >= price);\n', '      value -= price;\n', '    }\n', '\n', '    msg.sender.transfer(value);\n', '\n', '    // The current referral is ignored if the referrer&#39;s address is 0x0.\n', '    if (actualReferrer != 0x0) {\n', '      uint256 numCredit = referralCredits[actualReferrer]\n', '        .add(beastQuantity)\n', '        .add(aquaticQuantity)\n', '        .add(plantQuantity);\n', '\n', '      uint256 numReward = numCredit / REF_CREDITS_PER_AXIE;\n', '\n', '      if (numReward > 0) {\n', '        referralCredits[actualReferrer] = numCredit % REF_CREDITS_PER_AXIE;\n', '        axiesRewarded[actualReferrer] = axiesRewarded[actualReferrer].add(numReward);\n', '        totalAxiesRewarded = totalAxiesRewarded.add(numReward);\n', '        AxiesRewarded(actualReferrer, numReward);\n', '      } else {\n', '        referralCredits[actualReferrer] = numCredit;\n', '      }\n', '    }\n', '  }\n', '\n', '  function redeemAdoptedAxies(\n', '    address receiver,\n', '    uint256 beastQuantity,\n', '    uint256 aquaticQuantity,\n', '    uint256 plantQuantity\n', '  )\n', '    public\n', '    onlyOwner\n', '    returns (\n', '      uint256 /* remainingBeastQuantity */,\n', '      uint256 /* remainingAquaticQuantity */,\n', '      uint256 /* remainingPlantQuantity */\n', '    )\n', '  {\n', '    return (\n', '      _redeemAdoptedAxies(receiver, CLASS_BEAST, beastQuantity),\n', '      _redeemAdoptedAxies(receiver, CLASS_AQUATIC, aquaticQuantity),\n', '      _redeemAdoptedAxies(receiver, CLASS_PLANT, plantQuantity)\n', '    );\n', '  }\n', '\n', '  function redeemRewardedAxies(\n', '    address receiver,\n', '    uint256 quantity\n', '  )\n', '    public\n', '    onlyOwner\n', '    returns (uint256 remainingQuantity)\n', '  {\n', '    remainingQuantity = axiesRewarded[receiver] = axiesRewarded[receiver].sub(quantity);\n', '\n', '    if (quantity > 0) {\n', '      // This requires that rewarded Axies are always included in the total\n', '      // to make sure overflow won&#39;t happen.\n', '      totalAxiesRewarded -= quantity;\n', '\n', '      RewardedAxiesRedeemed(receiver, quantity);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Calculate price of Axies from the same class.\n', '   * @param clazz The class of Axies.\n', '   * @param quantity Number of Axies to be calculated.\n', '   */\n', '  function _axiesPrice(\n', '    uint8 clazz,\n', '    uint256 quantity\n', '  )\n', '    private\n', '    view\n', '    returns (uint256 totalPrice, uint256 priceIncrement, uint256 currentPrice)\n', '  {\n', '    priceIncrement = priceIncrements[clazz];\n', '    currentPrice = currentPrices[clazz];\n', '\n', '    uint256 nextPrice;\n', '\n', '    for (uint256 i = 0; i < quantity; i++) {\n', '      totalPrice = totalPrice.add(currentPrice);\n', '      nextPrice = currentPrice.add(priceIncrement);\n', '\n', '      if (nextPrice / 100 finney != currentPrice / 100 finney) {\n', '        priceIncrement >>= 1;\n', '      }\n', '\n', '      currentPrice = nextPrice;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Adopt some Axies from the same class.\n', '   * @param adopter Address of the adopter.\n', '   * @param clazz The class of adopted Axies.\n', '   * @param quantity Number of Axies to be adopted, this should be positive.\n', '   * @param referrer Address of the referrer.\n', '   */\n', '  function _adoptAxies(\n', '    address adopter,\n', '    uint8 clazz,\n', '    uint256 quantity,\n', '    address referrer\n', '  )\n', '    private\n', '    returns (uint256 totalPrice)\n', '  {\n', '    (totalPrice, priceIncrements[clazz], currentPrices[clazz]) = _axiesPrice(clazz, quantity);\n', '\n', '    axiesAdopted[adopter][clazz] = axiesAdopted[adopter][clazz].add(quantity);\n', '    totalAxiesAdopted[clazz] = totalAxiesAdopted[clazz].add(quantity);\n', '\n', '    AxiesAdopted(\n', '      adopter,\n', '      clazz,\n', '      quantity,\n', '      referrer\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Redeem adopted Axies from the same class.\n', '   * @param receiver Address of the receiver.\n', '   * @param clazz The class of adopted Axies.\n', '   * @param quantity Number of adopted Axies to be redeemed.\n', '   */\n', '  function _redeemAdoptedAxies(\n', '    address receiver,\n', '    uint8 clazz,\n', '    uint256 quantity\n', '  )\n', '    private\n', '    returns (uint256 remainingQuantity)\n', '  {\n', '    remainingQuantity = axiesAdopted[receiver][clazz] = axiesAdopted[receiver][clazz].sub(quantity);\n', '\n', '    if (quantity > 0) {\n', '      // This requires that adopted Axies are always included in the total\n', '      // to make sure overflow won&#39;t happen.\n', '      totalAxiesAdopted[clazz] -= quantity;\n', '\n', '      AdoptedAxiesRedeemed(receiver, clazz, quantity);\n', '    }\n', '  }\n', '}\n', '\n', '// File: zeppelin/contracts/ownership/HasNoContracts.sol\n', '\n', '/**\n', ' * @title Contracts that should not own Contracts\n', ' * @author Remco Bloemen <<span class="__cf_email__" data-cfemail="80f2e5ede3efc0b2">[email&#160;protected]</span>π.com>\n', ' * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\n', ' * of this contract to reclaim ownership of the contracts.\n', ' */\n', 'contract HasNoContracts is Ownable {\n', '\n', '  /**\n', '   * @dev Reclaim ownership of Ownable contracts\n', '   * @param contractAddr The address of the Ownable to be reclaimed.\n', '   */\n', '  function reclaimContract(address contractAddr) external onlyOwner {\n', '    Ownable contractInst = Ownable(contractAddr);\n', '    contractInst.transferOwnership(owner);\n', '  }\n', '}\n', '\n', '// File: contracts/presale/AxiePresaleExtended.sol\n', '\n', 'contract AxiePresaleExtended is HasNoContracts, Pausable {\n', '  using SafeMath for uint256;\n', '\n', '  // No Axies can be adopted after this end date: Monday, April 16, 2018 11:59:59 PM GMT.\n', '  uint256 constant public PRESALE_END_TIMESTAMP = 1523923199;\n', '\n', '  // The total number of adopted Axies will be capped at 5250,\n', '  // so the number of Axies which have Mystic parts will be capped roughly at 2000.\n', '  uint256 constant public MAX_TOTAL_ADOPTED_AXIES = 5250;\n', '\n', '  uint8 constant public CLASS_BEAST = 0;\n', '  uint8 constant public CLASS_AQUATIC = 2;\n', '  uint8 constant public CLASS_PLANT = 4;\n', '\n', '  // The initial price increment and the initial price are for reference only\n', '  uint256 constant public INITIAL_PRICE_INCREMENT = 1600 szabo; // 0.0016 Ether\n', '  uint256 constant public INITIAL_PRICE = INITIAL_PRICE_INCREMENT;\n', '\n', '  uint256 constant public REF_CREDITS_PER_AXIE = 5;\n', '\n', '  AxiePresale public presaleContract;\n', '  address public redemptionAddress;\n', '\n', '  mapping (uint8 => uint256) public currentPrice;\n', '  mapping (uint8 => uint256) public priceIncrement;\n', '\n', '  mapping (uint8 => uint256) private _totalAdoptedAxies;\n', '  mapping (uint8 => uint256) private _totalDeductedAdoptedAxies;\n', '  mapping (address => mapping (uint8 => uint256)) private _numAdoptedAxies;\n', '  mapping (address => mapping (uint8 => uint256)) private _numDeductedAdoptedAxies;\n', '\n', '  mapping (address => uint256) private _numRefCredits;\n', '  mapping (address => uint256) private _numDeductedRefCredits;\n', '  uint256 public numBountyCredits;\n', '\n', '  uint256 private _totalRewardedAxies;\n', '  uint256 private _totalDeductedRewardedAxies;\n', '  mapping (address => uint256) private _numRewardedAxies;\n', '  mapping (address => uint256) private _numDeductedRewardedAxies;\n', '\n', '  event AxiesAdopted(\n', '    address indexed _adopter,\n', '    uint8 indexed _class,\n', '    uint256 _quantity,\n', '    address indexed _referrer\n', '  );\n', '\n', '  event AxiesRewarded(address indexed _receiver, uint256 _quantity);\n', '\n', '  event AdoptedAxiesRedeemed(address indexed _receiver, uint8 indexed _class, uint256 _quantity);\n', '  event RewardedAxiesRedeemed(address indexed _receiver, uint256 _quantity);\n', '\n', '  event RefCreditsMinted(address indexed _receiver, uint256 _numMintedCredits);\n', '\n', '  function AxiePresaleExtended() public payable {\n', '    require(msg.value == 0);\n', '    paused = true;\n', '    numBountyCredits = 300;\n', '  }\n', '\n', '  function () external payable {\n', '    require(msg.sender == address(presaleContract));\n', '  }\n', '\n', '  modifier whenNotInitialized {\n', '    require(presaleContract == address(0));\n', '    _;\n', '  }\n', '\n', '  modifier whenInitialized {\n', '    require(presaleContract != address(0));\n', '    _;\n', '  }\n', '\n', '  modifier onlyRedemptionAddress {\n', '    require(msg.sender == redemptionAddress);\n', '    _;\n', '  }\n', '\n', '  function reclaimEther() external onlyOwner whenInitialized {\n', '    presaleContract.reclaimEther();\n', '    owner.transfer(this.balance);\n', '  }\n', '\n', '  /**\n', '   * @dev This must be called only once after the owner of the presale contract\n', '   *  has been updated to this contract.\n', '   */\n', '  function initialize(address _presaleAddress) external onlyOwner whenNotInitialized {\n', '    // Set the presale address.\n', '    presaleContract = AxiePresale(_presaleAddress);\n', '\n', '    presaleContract.pause();\n', '\n', '    // Restore price increments from the old contract.\n', '    priceIncrement[CLASS_BEAST] = presaleContract.priceIncrements(CLASS_BEAST);\n', '    priceIncrement[CLASS_AQUATIC] = presaleContract.priceIncrements(CLASS_AQUATIC);\n', '    priceIncrement[CLASS_PLANT] = presaleContract.priceIncrements(CLASS_PLANT);\n', '\n', '    // Restore current prices from the old contract.\n', '    currentPrice[CLASS_BEAST] = presaleContract.currentPrices(CLASS_BEAST);\n', '    currentPrice[CLASS_AQUATIC] = presaleContract.currentPrices(CLASS_AQUATIC);\n', '    currentPrice[CLASS_PLANT] = presaleContract.currentPrices(CLASS_PLANT);\n', '\n', '    paused = false;\n', '  }\n', '\n', '  function setRedemptionAddress(address _redemptionAddress) external onlyOwner whenInitialized {\n', '    redemptionAddress = _redemptionAddress;\n', '  }\n', '\n', '  function totalAdoptedAxies(\n', '    uint8 _class,\n', '    bool _deduction\n', '  )\n', '    external\n', '    view\n', '    whenInitialized\n', '    returns (uint256 _number)\n', '  {\n', '    _number = _totalAdoptedAxies[_class]\n', '      .add(presaleContract.totalAxiesAdopted(_class));\n', '\n', '    if (_deduction) {\n', '      _number = _number.sub(_totalDeductedAdoptedAxies[_class]);\n', '    }\n', '  }\n', '\n', '  function numAdoptedAxies(\n', '    address _owner,\n', '    uint8 _class,\n', '    bool _deduction\n', '  )\n', '    external\n', '    view\n', '    whenInitialized\n', '    returns (uint256 _number)\n', '  {\n', '    _number = _numAdoptedAxies[_owner][_class]\n', '      .add(presaleContract.axiesAdopted(_owner, _class));\n', '\n', '    if (_deduction) {\n', '      _number = _number.sub(_numDeductedAdoptedAxies[_owner][_class]);\n', '    }\n', '  }\n', '\n', '  function numRefCredits(\n', '    address _owner,\n', '    bool _deduction\n', '  )\n', '    external\n', '    view\n', '    whenInitialized\n', '    returns (uint256 _number)\n', '  {\n', '    _number = _numRefCredits[_owner]\n', '      .add(presaleContract.referralCredits(_owner));\n', '\n', '    if (_deduction) {\n', '      _number = _number.sub(_numDeductedRefCredits[_owner]);\n', '    }\n', '  }\n', '\n', '  function totalRewardedAxies(\n', '    bool _deduction\n', '  )\n', '    external\n', '    view\n', '    whenInitialized\n', '    returns (uint256 _number)\n', '  {\n', '    _number = _totalRewardedAxies\n', '      .add(presaleContract.totalAxiesRewarded());\n', '\n', '    if (_deduction) {\n', '      _number = _number.sub(_totalDeductedRewardedAxies);\n', '    }\n', '  }\n', '\n', '  function numRewardedAxies(\n', '    address _owner,\n', '    bool _deduction\n', '  )\n', '    external\n', '    view\n', '    whenInitialized\n', '    returns (uint256 _number)\n', '  {\n', '    _number = _numRewardedAxies[_owner]\n', '      .add(presaleContract.axiesRewarded(_owner));\n', '\n', '    if (_deduction) {\n', '      _number = _number.sub(_numDeductedRewardedAxies[_owner]);\n', '    }\n', '  }\n', '\n', '  function axiesPrice(\n', '    uint256 _beastQuantity,\n', '    uint256 _aquaticQuantity,\n', '    uint256 _plantQuantity\n', '  )\n', '    external\n', '    view\n', '    whenInitialized\n', '    returns (uint256 _totalPrice)\n', '  {\n', '    uint256 price;\n', '\n', '    (price,,) = _sameClassAxiesPrice(CLASS_BEAST, _beastQuantity);\n', '    _totalPrice = _totalPrice.add(price);\n', '\n', '    (price,,) = _sameClassAxiesPrice(CLASS_AQUATIC, _aquaticQuantity);\n', '    _totalPrice = _totalPrice.add(price);\n', '\n', '    (price,,) = _sameClassAxiesPrice(CLASS_PLANT, _plantQuantity);\n', '    _totalPrice = _totalPrice.add(price);\n', '  }\n', '\n', '  function adoptAxies(\n', '    uint256 _beastQuantity,\n', '    uint256 _aquaticQuantity,\n', '    uint256 _plantQuantity,\n', '    address _referrer\n', '  )\n', '    external\n', '    payable\n', '    whenInitialized\n', '    whenNotPaused\n', '  {\n', '    require(now <= PRESALE_END_TIMESTAMP);\n', '    require(_beastQuantity <= 3 && _aquaticQuantity <= 3 && _plantQuantity <= 3);\n', '\n', '    uint256 _totalAdopted = this.totalAdoptedAxies(CLASS_BEAST, false)\n', '      .add(this.totalAdoptedAxies(CLASS_AQUATIC, false))\n', '      .add(this.totalAdoptedAxies(CLASS_PLANT, false))\n', '      .add(_beastQuantity)\n', '      .add(_aquaticQuantity)\n', '      .add(_plantQuantity);\n', '\n', '    require(_totalAdopted <= MAX_TOTAL_ADOPTED_AXIES);\n', '\n', '    address _adopter = msg.sender;\n', '    address _actualReferrer = 0x0;\n', '\n', '    // An adopter cannot be his/her own referrer.\n', '    if (_referrer != _adopter) {\n', '      _actualReferrer = _referrer;\n', '    }\n', '\n', '    uint256 _value = msg.value;\n', '    uint256 _price;\n', '\n', '    if (_beastQuantity > 0) {\n', '      _price = _adoptSameClassAxies(\n', '        _adopter,\n', '        CLASS_BEAST,\n', '        _beastQuantity,\n', '        _actualReferrer\n', '      );\n', '\n', '      require(_value >= _price);\n', '      _value -= _price;\n', '    }\n', '\n', '    if (_aquaticQuantity > 0) {\n', '      _price = _adoptSameClassAxies(\n', '        _adopter,\n', '        CLASS_AQUATIC,\n', '        _aquaticQuantity,\n', '        _actualReferrer\n', '      );\n', '\n', '      require(_value >= _price);\n', '      _value -= _price;\n', '    }\n', '\n', '    if (_plantQuantity > 0) {\n', '      _price = _adoptSameClassAxies(\n', '        _adopter,\n', '        CLASS_PLANT,\n', '        _plantQuantity,\n', '        _actualReferrer\n', '      );\n', '\n', '      require(_value >= _price);\n', '      _value -= _price;\n', '    }\n', '\n', '    msg.sender.transfer(_value);\n', '\n', '    // The current referral is ignored if the referrer&#39;s address is 0x0.\n', '    if (_actualReferrer != 0x0) {\n', '      _applyRefCredits(\n', '        _actualReferrer,\n', '        _beastQuantity.add(_aquaticQuantity).add(_plantQuantity)\n', '      );\n', '    }\n', '  }\n', '\n', '  function mintRefCredits(\n', '    address _receiver,\n', '    uint256 _numMintedCredits\n', '  )\n', '    external\n', '    onlyOwner\n', '    whenInitialized\n', '    returns (uint256)\n', '  {\n', '    require(_receiver != address(0));\n', '    numBountyCredits = numBountyCredits.sub(_numMintedCredits);\n', '    _applyRefCredits(_receiver, _numMintedCredits);\n', '    RefCreditsMinted(_receiver, _numMintedCredits);\n', '    return numBountyCredits;\n', '  }\n', '\n', '  function redeemAdoptedAxies(\n', '    address _receiver,\n', '    uint256 _beastQuantity,\n', '    uint256 _aquaticQuantity,\n', '    uint256 _plantQuantity\n', '  )\n', '    external\n', '    onlyRedemptionAddress\n', '    whenInitialized\n', '    returns (\n', '      uint256 /* remainingBeastQuantity */,\n', '      uint256 /* remainingAquaticQuantity */,\n', '      uint256 /* remainingPlantQuantity */\n', '    )\n', '  {\n', '    return (\n', '      _redeemSameClassAdoptedAxies(_receiver, CLASS_BEAST, _beastQuantity),\n', '      _redeemSameClassAdoptedAxies(_receiver, CLASS_AQUATIC, _aquaticQuantity),\n', '      _redeemSameClassAdoptedAxies(_receiver, CLASS_PLANT, _plantQuantity)\n', '    );\n', '  }\n', '\n', '  function redeemRewardedAxies(\n', '    address _receiver,\n', '    uint256 _quantity\n', '  )\n', '    external\n', '    onlyRedemptionAddress\n', '    whenInitialized\n', '    returns (uint256 _remainingQuantity)\n', '  {\n', '    _remainingQuantity = this.numRewardedAxies(_receiver, true).sub(_quantity);\n', '\n', '    if (_quantity > 0) {\n', '      _numDeductedRewardedAxies[_receiver] = _numDeductedRewardedAxies[_receiver].add(_quantity);\n', '      _totalDeductedRewardedAxies = _totalDeductedRewardedAxies.add(_quantity);\n', '\n', '      RewardedAxiesRedeemed(_receiver, _quantity);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Calculate price of Axies from the same class.\n', '   * @param _class The class of Axies.\n', '   * @param _quantity Number of Axies to be calculated.\n', '   */\n', '  function _sameClassAxiesPrice(\n', '    uint8 _class,\n', '    uint256 _quantity\n', '  )\n', '    private\n', '    view\n', '    returns (\n', '      uint256 _totalPrice,\n', '      uint256 /* should be _subsequentIncrement */ _currentIncrement,\n', '      uint256 /* should be _subsequentPrice */ _currentPrice\n', '    )\n', '  {\n', '    _currentIncrement = priceIncrement[_class];\n', '    _currentPrice = currentPrice[_class];\n', '\n', '    uint256 _nextPrice;\n', '\n', '    for (uint256 i = 0; i < _quantity; i++) {\n', '      _totalPrice = _totalPrice.add(_currentPrice);\n', '      _nextPrice = _currentPrice.add(_currentIncrement);\n', '\n', '      if (_nextPrice / 100 finney != _currentPrice / 100 finney) {\n', '        _currentIncrement >>= 1;\n', '      }\n', '\n', '      _currentPrice = _nextPrice;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Adopt some Axies from the same class.\n', '   * @dev The quantity MUST be positive.\n', '   * @param _adopter Address of the adopter.\n', '   * @param _class The class of adopted Axies.\n', '   * @param _quantity Number of Axies to be adopted.\n', '   * @param _referrer Address of the referrer.\n', '   */\n', '  function _adoptSameClassAxies(\n', '    address _adopter,\n', '    uint8 _class,\n', '    uint256 _quantity,\n', '    address _referrer\n', '  )\n', '    private\n', '    returns (uint256 _totalPrice)\n', '  {\n', '    (_totalPrice, priceIncrement[_class], currentPrice[_class]) = _sameClassAxiesPrice(_class, _quantity);\n', '\n', '    _numAdoptedAxies[_adopter][_class] = _numAdoptedAxies[_adopter][_class].add(_quantity);\n', '    _totalAdoptedAxies[_class] = _totalAdoptedAxies[_class].add(_quantity);\n', '\n', '    AxiesAdopted(\n', '      _adopter,\n', '      _class,\n', '      _quantity,\n', '      _referrer\n', '    );\n', '  }\n', '\n', '  function _applyRefCredits(address _receiver, uint256 _numAppliedCredits) private {\n', '    _numRefCredits[_receiver] = _numRefCredits[_receiver].add(_numAppliedCredits);\n', '\n', '    uint256 _numCredits = this.numRefCredits(_receiver, true);\n', '    uint256 _numRewards = _numCredits / REF_CREDITS_PER_AXIE;\n', '\n', '    if (_numRewards > 0) {\n', '      _numDeductedRefCredits[_receiver] = _numDeductedRefCredits[_receiver]\n', '        .add(_numRewards.mul(REF_CREDITS_PER_AXIE));\n', '\n', '      _numRewardedAxies[_receiver] = _numRewardedAxies[_receiver].add(_numRewards);\n', '      _totalRewardedAxies = _totalRewardedAxies.add(_numRewards);\n', '\n', '      AxiesRewarded(_receiver, _numRewards);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Redeem adopted Axies from the same class.\n', '   * @dev Emit the `AdoptedAxiesRedeemed` event if the quantity is positive.\n', '   * @param _receiver The address of the receiver.\n', '   * @param _class The class of adopted Axies.\n', '   * @param _quantity The number of adopted Axies to be redeemed.\n', '   */\n', '  function _redeemSameClassAdoptedAxies(\n', '    address _receiver,\n', '    uint8 _class,\n', '    uint256 _quantity\n', '  )\n', '    private\n', '    returns (uint256 _remainingQuantity)\n', '  {\n', '    _remainingQuantity = this.numAdoptedAxies(_receiver, _class, true).sub(_quantity);\n', '\n', '    if (_quantity > 0) {\n', '      _numDeductedAdoptedAxies[_receiver][_class] = _numDeductedAdoptedAxies[_receiver][_class].add(_quantity);\n', '      _totalDeductedAdoptedAxies[_class] = _totalDeductedAdoptedAxies[_class].add(_quantity);\n', '\n', '      AdoptedAxiesRedeemed(_receiver, _class, _quantity);\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '// File: zeppelin/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '// File: zeppelin/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin/contracts/ownership/HasNoEther.sol\n', '\n', '/**\n', ' * @title Contracts that should not own Ether\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\n', ' * in the contract, it will allow the owner to reclaim this ether.\n', ' * @notice Ether can still be send to this contract by:\n', ' * calling functions labeled `payable`\n', ' * `selfdestruct(contract_address)`\n', ' * mining directly to the contract address\n', '*/\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  function HasNoEther() payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    assert(owner.send(this.balance));\n', '  }\n', '}\n', '\n', '// File: contracts/presale/AxiePresale.sol\n', '\n', 'contract AxiePresale is HasNoEther, Pausable {\n', '  using SafeMath for uint256;\n', '\n', '  // No Axies can be adopted after this end date: Friday, March 16, 2018 11:59:59 PM GMT.\n', '  uint256 constant public PRESALE_END_TIMESTAMP = 1521244799;\n', '\n', '  uint8 constant public CLASS_BEAST = 0;\n', '  uint8 constant public CLASS_AQUATIC = 2;\n', '  uint8 constant public CLASS_PLANT = 4;\n', '\n', '  uint256 constant public INITIAL_PRICE_INCREMENT = 1600 szabo; // 0.0016 Ether\n', '  uint256 constant public INITIAL_PRICE = INITIAL_PRICE_INCREMENT;\n', '  uint256 constant public REF_CREDITS_PER_AXIE = 5;\n', '\n', '  mapping (uint8 => uint256) public currentPrices;\n', '  mapping (uint8 => uint256) public priceIncrements;\n', '\n', '  mapping (uint8 => uint256) public totalAxiesAdopted;\n', '  mapping (address => mapping (uint8 => uint256)) public axiesAdopted;\n', '\n', '  mapping (address => uint256) public referralCredits;\n', '  mapping (address => uint256) public axiesRewarded;\n', '  uint256 public totalAxiesRewarded;\n', '\n', '  event AxiesAdopted(\n', '    address indexed adopter,\n', '    uint8 indexed clazz,\n', '    uint256 quantity,\n', '    address indexed referrer\n', '  );\n', '\n', '  event AxiesRewarded(address indexed receiver, uint256 quantity);\n', '\n', '  event AdoptedAxiesRedeemed(address indexed receiver, uint8 indexed clazz, uint256 quantity);\n', '  event RewardedAxiesRedeemed(address indexed receiver, uint256 quantity);\n', '\n', '  function AxiePresale() public {\n', '    priceIncrements[CLASS_BEAST] = priceIncrements[CLASS_AQUATIC] = //\n', '      priceIncrements[CLASS_PLANT] = INITIAL_PRICE_INCREMENT;\n', '\n', '    currentPrices[CLASS_BEAST] = currentPrices[CLASS_AQUATIC] = //\n', '      currentPrices[CLASS_PLANT] = INITIAL_PRICE;\n', '  }\n', '\n', '  function axiesPrice(\n', '    uint256 beastQuantity,\n', '    uint256 aquaticQuantity,\n', '    uint256 plantQuantity\n', '  )\n', '    public\n', '    view\n', '    returns (uint256 totalPrice)\n', '  {\n', '    uint256 price;\n', '\n', '    (price,,) = _axiesPrice(CLASS_BEAST, beastQuantity);\n', '    totalPrice = totalPrice.add(price);\n', '\n', '    (price,,) = _axiesPrice(CLASS_AQUATIC, aquaticQuantity);\n', '    totalPrice = totalPrice.add(price);\n', '\n', '    (price,,) = _axiesPrice(CLASS_PLANT, plantQuantity);\n', '    totalPrice = totalPrice.add(price);\n', '  }\n', '\n', '  function adoptAxies(\n', '    uint256 beastQuantity,\n', '    uint256 aquaticQuantity,\n', '    uint256 plantQuantity,\n', '    address referrer\n', '  )\n', '    public\n', '    payable\n', '    whenNotPaused\n', '  {\n', '    require(now <= PRESALE_END_TIMESTAMP);\n', '\n', '    require(beastQuantity <= 3);\n', '    require(aquaticQuantity <= 3);\n', '    require(plantQuantity <= 3);\n', '\n', '    address adopter = msg.sender;\n', '    address actualReferrer = 0x0;\n', '\n', '    // An adopter cannot be his/her own referrer.\n', '    if (referrer != adopter) {\n', '      actualReferrer = referrer;\n', '    }\n', '\n', '    uint256 value = msg.value;\n', '    uint256 price;\n', '\n', '    if (beastQuantity > 0) {\n', '      price = _adoptAxies(\n', '        adopter,\n', '        CLASS_BEAST,\n', '        beastQuantity,\n', '        actualReferrer\n', '      );\n', '\n', '      require(value >= price);\n', '      value -= price;\n', '    }\n', '\n', '    if (aquaticQuantity > 0) {\n', '      price = _adoptAxies(\n', '        adopter,\n', '        CLASS_AQUATIC,\n', '        aquaticQuantity,\n', '        actualReferrer\n', '      );\n', '\n', '      require(value >= price);\n', '      value -= price;\n', '    }\n', '\n', '    if (plantQuantity > 0) {\n', '      price = _adoptAxies(\n', '        adopter,\n', '        CLASS_PLANT,\n', '        plantQuantity,\n', '        actualReferrer\n', '      );\n', '\n', '      require(value >= price);\n', '      value -= price;\n', '    }\n', '\n', '    msg.sender.transfer(value);\n', '\n', "    // The current referral is ignored if the referrer's address is 0x0.\n", '    if (actualReferrer != 0x0) {\n', '      uint256 numCredit = referralCredits[actualReferrer]\n', '        .add(beastQuantity)\n', '        .add(aquaticQuantity)\n', '        .add(plantQuantity);\n', '\n', '      uint256 numReward = numCredit / REF_CREDITS_PER_AXIE;\n', '\n', '      if (numReward > 0) {\n', '        referralCredits[actualReferrer] = numCredit % REF_CREDITS_PER_AXIE;\n', '        axiesRewarded[actualReferrer] = axiesRewarded[actualReferrer].add(numReward);\n', '        totalAxiesRewarded = totalAxiesRewarded.add(numReward);\n', '        AxiesRewarded(actualReferrer, numReward);\n', '      } else {\n', '        referralCredits[actualReferrer] = numCredit;\n', '      }\n', '    }\n', '  }\n', '\n', '  function redeemAdoptedAxies(\n', '    address receiver,\n', '    uint256 beastQuantity,\n', '    uint256 aquaticQuantity,\n', '    uint256 plantQuantity\n', '  )\n', '    public\n', '    onlyOwner\n', '    returns (\n', '      uint256 /* remainingBeastQuantity */,\n', '      uint256 /* remainingAquaticQuantity */,\n', '      uint256 /* remainingPlantQuantity */\n', '    )\n', '  {\n', '    return (\n', '      _redeemAdoptedAxies(receiver, CLASS_BEAST, beastQuantity),\n', '      _redeemAdoptedAxies(receiver, CLASS_AQUATIC, aquaticQuantity),\n', '      _redeemAdoptedAxies(receiver, CLASS_PLANT, plantQuantity)\n', '    );\n', '  }\n', '\n', '  function redeemRewardedAxies(\n', '    address receiver,\n', '    uint256 quantity\n', '  )\n', '    public\n', '    onlyOwner\n', '    returns (uint256 remainingQuantity)\n', '  {\n', '    remainingQuantity = axiesRewarded[receiver] = axiesRewarded[receiver].sub(quantity);\n', '\n', '    if (quantity > 0) {\n', '      // This requires that rewarded Axies are always included in the total\n', "      // to make sure overflow won't happen.\n", '      totalAxiesRewarded -= quantity;\n', '\n', '      RewardedAxiesRedeemed(receiver, quantity);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Calculate price of Axies from the same class.\n', '   * @param clazz The class of Axies.\n', '   * @param quantity Number of Axies to be calculated.\n', '   */\n', '  function _axiesPrice(\n', '    uint8 clazz,\n', '    uint256 quantity\n', '  )\n', '    private\n', '    view\n', '    returns (uint256 totalPrice, uint256 priceIncrement, uint256 currentPrice)\n', '  {\n', '    priceIncrement = priceIncrements[clazz];\n', '    currentPrice = currentPrices[clazz];\n', '\n', '    uint256 nextPrice;\n', '\n', '    for (uint256 i = 0; i < quantity; i++) {\n', '      totalPrice = totalPrice.add(currentPrice);\n', '      nextPrice = currentPrice.add(priceIncrement);\n', '\n', '      if (nextPrice / 100 finney != currentPrice / 100 finney) {\n', '        priceIncrement >>= 1;\n', '      }\n', '\n', '      currentPrice = nextPrice;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Adopt some Axies from the same class.\n', '   * @param adopter Address of the adopter.\n', '   * @param clazz The class of adopted Axies.\n', '   * @param quantity Number of Axies to be adopted, this should be positive.\n', '   * @param referrer Address of the referrer.\n', '   */\n', '  function _adoptAxies(\n', '    address adopter,\n', '    uint8 clazz,\n', '    uint256 quantity,\n', '    address referrer\n', '  )\n', '    private\n', '    returns (uint256 totalPrice)\n', '  {\n', '    (totalPrice, priceIncrements[clazz], currentPrices[clazz]) = _axiesPrice(clazz, quantity);\n', '\n', '    axiesAdopted[adopter][clazz] = axiesAdopted[adopter][clazz].add(quantity);\n', '    totalAxiesAdopted[clazz] = totalAxiesAdopted[clazz].add(quantity);\n', '\n', '    AxiesAdopted(\n', '      adopter,\n', '      clazz,\n', '      quantity,\n', '      referrer\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Redeem adopted Axies from the same class.\n', '   * @param receiver Address of the receiver.\n', '   * @param clazz The class of adopted Axies.\n', '   * @param quantity Number of adopted Axies to be redeemed.\n', '   */\n', '  function _redeemAdoptedAxies(\n', '    address receiver,\n', '    uint8 clazz,\n', '    uint256 quantity\n', '  )\n', '    private\n', '    returns (uint256 remainingQuantity)\n', '  {\n', '    remainingQuantity = axiesAdopted[receiver][clazz] = axiesAdopted[receiver][clazz].sub(quantity);\n', '\n', '    if (quantity > 0) {\n', '      // This requires that adopted Axies are always included in the total\n', "      // to make sure overflow won't happen.\n", '      totalAxiesAdopted[clazz] -= quantity;\n', '\n', '      AdoptedAxiesRedeemed(receiver, clazz, quantity);\n', '    }\n', '  }\n', '}\n', '\n', '// File: zeppelin/contracts/ownership/HasNoContracts.sol\n', '\n', '/**\n', ' * @title Contracts that should not own Contracts\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\n', ' * of this contract to reclaim ownership of the contracts.\n', ' */\n', 'contract HasNoContracts is Ownable {\n', '\n', '  /**\n', '   * @dev Reclaim ownership of Ownable contracts\n', '   * @param contractAddr The address of the Ownable to be reclaimed.\n', '   */\n', '  function reclaimContract(address contractAddr) external onlyOwner {\n', '    Ownable contractInst = Ownable(contractAddr);\n', '    contractInst.transferOwnership(owner);\n', '  }\n', '}\n', '\n', '// File: contracts/presale/AxiePresaleExtended.sol\n', '\n', 'contract AxiePresaleExtended is HasNoContracts, Pausable {\n', '  using SafeMath for uint256;\n', '\n', '  // No Axies can be adopted after this end date: Monday, April 16, 2018 11:59:59 PM GMT.\n', '  uint256 constant public PRESALE_END_TIMESTAMP = 1523923199;\n', '\n', '  // The total number of adopted Axies will be capped at 5250,\n', '  // so the number of Axies which have Mystic parts will be capped roughly at 2000.\n', '  uint256 constant public MAX_TOTAL_ADOPTED_AXIES = 5250;\n', '\n', '  uint8 constant public CLASS_BEAST = 0;\n', '  uint8 constant public CLASS_AQUATIC = 2;\n', '  uint8 constant public CLASS_PLANT = 4;\n', '\n', '  // The initial price increment and the initial price are for reference only\n', '  uint256 constant public INITIAL_PRICE_INCREMENT = 1600 szabo; // 0.0016 Ether\n', '  uint256 constant public INITIAL_PRICE = INITIAL_PRICE_INCREMENT;\n', '\n', '  uint256 constant public REF_CREDITS_PER_AXIE = 5;\n', '\n', '  AxiePresale public presaleContract;\n', '  address public redemptionAddress;\n', '\n', '  mapping (uint8 => uint256) public currentPrice;\n', '  mapping (uint8 => uint256) public priceIncrement;\n', '\n', '  mapping (uint8 => uint256) private _totalAdoptedAxies;\n', '  mapping (uint8 => uint256) private _totalDeductedAdoptedAxies;\n', '  mapping (address => mapping (uint8 => uint256)) private _numAdoptedAxies;\n', '  mapping (address => mapping (uint8 => uint256)) private _numDeductedAdoptedAxies;\n', '\n', '  mapping (address => uint256) private _numRefCredits;\n', '  mapping (address => uint256) private _numDeductedRefCredits;\n', '  uint256 public numBountyCredits;\n', '\n', '  uint256 private _totalRewardedAxies;\n', '  uint256 private _totalDeductedRewardedAxies;\n', '  mapping (address => uint256) private _numRewardedAxies;\n', '  mapping (address => uint256) private _numDeductedRewardedAxies;\n', '\n', '  event AxiesAdopted(\n', '    address indexed _adopter,\n', '    uint8 indexed _class,\n', '    uint256 _quantity,\n', '    address indexed _referrer\n', '  );\n', '\n', '  event AxiesRewarded(address indexed _receiver, uint256 _quantity);\n', '\n', '  event AdoptedAxiesRedeemed(address indexed _receiver, uint8 indexed _class, uint256 _quantity);\n', '  event RewardedAxiesRedeemed(address indexed _receiver, uint256 _quantity);\n', '\n', '  event RefCreditsMinted(address indexed _receiver, uint256 _numMintedCredits);\n', '\n', '  function AxiePresaleExtended() public payable {\n', '    require(msg.value == 0);\n', '    paused = true;\n', '    numBountyCredits = 300;\n', '  }\n', '\n', '  function () external payable {\n', '    require(msg.sender == address(presaleContract));\n', '  }\n', '\n', '  modifier whenNotInitialized {\n', '    require(presaleContract == address(0));\n', '    _;\n', '  }\n', '\n', '  modifier whenInitialized {\n', '    require(presaleContract != address(0));\n', '    _;\n', '  }\n', '\n', '  modifier onlyRedemptionAddress {\n', '    require(msg.sender == redemptionAddress);\n', '    _;\n', '  }\n', '\n', '  function reclaimEther() external onlyOwner whenInitialized {\n', '    presaleContract.reclaimEther();\n', '    owner.transfer(this.balance);\n', '  }\n', '\n', '  /**\n', '   * @dev This must be called only once after the owner of the presale contract\n', '   *  has been updated to this contract.\n', '   */\n', '  function initialize(address _presaleAddress) external onlyOwner whenNotInitialized {\n', '    // Set the presale address.\n', '    presaleContract = AxiePresale(_presaleAddress);\n', '\n', '    presaleContract.pause();\n', '\n', '    // Restore price increments from the old contract.\n', '    priceIncrement[CLASS_BEAST] = presaleContract.priceIncrements(CLASS_BEAST);\n', '    priceIncrement[CLASS_AQUATIC] = presaleContract.priceIncrements(CLASS_AQUATIC);\n', '    priceIncrement[CLASS_PLANT] = presaleContract.priceIncrements(CLASS_PLANT);\n', '\n', '    // Restore current prices from the old contract.\n', '    currentPrice[CLASS_BEAST] = presaleContract.currentPrices(CLASS_BEAST);\n', '    currentPrice[CLASS_AQUATIC] = presaleContract.currentPrices(CLASS_AQUATIC);\n', '    currentPrice[CLASS_PLANT] = presaleContract.currentPrices(CLASS_PLANT);\n', '\n', '    paused = false;\n', '  }\n', '\n', '  function setRedemptionAddress(address _redemptionAddress) external onlyOwner whenInitialized {\n', '    redemptionAddress = _redemptionAddress;\n', '  }\n', '\n', '  function totalAdoptedAxies(\n', '    uint8 _class,\n', '    bool _deduction\n', '  )\n', '    external\n', '    view\n', '    whenInitialized\n', '    returns (uint256 _number)\n', '  {\n', '    _number = _totalAdoptedAxies[_class]\n', '      .add(presaleContract.totalAxiesAdopted(_class));\n', '\n', '    if (_deduction) {\n', '      _number = _number.sub(_totalDeductedAdoptedAxies[_class]);\n', '    }\n', '  }\n', '\n', '  function numAdoptedAxies(\n', '    address _owner,\n', '    uint8 _class,\n', '    bool _deduction\n', '  )\n', '    external\n', '    view\n', '    whenInitialized\n', '    returns (uint256 _number)\n', '  {\n', '    _number = _numAdoptedAxies[_owner][_class]\n', '      .add(presaleContract.axiesAdopted(_owner, _class));\n', '\n', '    if (_deduction) {\n', '      _number = _number.sub(_numDeductedAdoptedAxies[_owner][_class]);\n', '    }\n', '  }\n', '\n', '  function numRefCredits(\n', '    address _owner,\n', '    bool _deduction\n', '  )\n', '    external\n', '    view\n', '    whenInitialized\n', '    returns (uint256 _number)\n', '  {\n', '    _number = _numRefCredits[_owner]\n', '      .add(presaleContract.referralCredits(_owner));\n', '\n', '    if (_deduction) {\n', '      _number = _number.sub(_numDeductedRefCredits[_owner]);\n', '    }\n', '  }\n', '\n', '  function totalRewardedAxies(\n', '    bool _deduction\n', '  )\n', '    external\n', '    view\n', '    whenInitialized\n', '    returns (uint256 _number)\n', '  {\n', '    _number = _totalRewardedAxies\n', '      .add(presaleContract.totalAxiesRewarded());\n', '\n', '    if (_deduction) {\n', '      _number = _number.sub(_totalDeductedRewardedAxies);\n', '    }\n', '  }\n', '\n', '  function numRewardedAxies(\n', '    address _owner,\n', '    bool _deduction\n', '  )\n', '    external\n', '    view\n', '    whenInitialized\n', '    returns (uint256 _number)\n', '  {\n', '    _number = _numRewardedAxies[_owner]\n', '      .add(presaleContract.axiesRewarded(_owner));\n', '\n', '    if (_deduction) {\n', '      _number = _number.sub(_numDeductedRewardedAxies[_owner]);\n', '    }\n', '  }\n', '\n', '  function axiesPrice(\n', '    uint256 _beastQuantity,\n', '    uint256 _aquaticQuantity,\n', '    uint256 _plantQuantity\n', '  )\n', '    external\n', '    view\n', '    whenInitialized\n', '    returns (uint256 _totalPrice)\n', '  {\n', '    uint256 price;\n', '\n', '    (price,,) = _sameClassAxiesPrice(CLASS_BEAST, _beastQuantity);\n', '    _totalPrice = _totalPrice.add(price);\n', '\n', '    (price,,) = _sameClassAxiesPrice(CLASS_AQUATIC, _aquaticQuantity);\n', '    _totalPrice = _totalPrice.add(price);\n', '\n', '    (price,,) = _sameClassAxiesPrice(CLASS_PLANT, _plantQuantity);\n', '    _totalPrice = _totalPrice.add(price);\n', '  }\n', '\n', '  function adoptAxies(\n', '    uint256 _beastQuantity,\n', '    uint256 _aquaticQuantity,\n', '    uint256 _plantQuantity,\n', '    address _referrer\n', '  )\n', '    external\n', '    payable\n', '    whenInitialized\n', '    whenNotPaused\n', '  {\n', '    require(now <= PRESALE_END_TIMESTAMP);\n', '    require(_beastQuantity <= 3 && _aquaticQuantity <= 3 && _plantQuantity <= 3);\n', '\n', '    uint256 _totalAdopted = this.totalAdoptedAxies(CLASS_BEAST, false)\n', '      .add(this.totalAdoptedAxies(CLASS_AQUATIC, false))\n', '      .add(this.totalAdoptedAxies(CLASS_PLANT, false))\n', '      .add(_beastQuantity)\n', '      .add(_aquaticQuantity)\n', '      .add(_plantQuantity);\n', '\n', '    require(_totalAdopted <= MAX_TOTAL_ADOPTED_AXIES);\n', '\n', '    address _adopter = msg.sender;\n', '    address _actualReferrer = 0x0;\n', '\n', '    // An adopter cannot be his/her own referrer.\n', '    if (_referrer != _adopter) {\n', '      _actualReferrer = _referrer;\n', '    }\n', '\n', '    uint256 _value = msg.value;\n', '    uint256 _price;\n', '\n', '    if (_beastQuantity > 0) {\n', '      _price = _adoptSameClassAxies(\n', '        _adopter,\n', '        CLASS_BEAST,\n', '        _beastQuantity,\n', '        _actualReferrer\n', '      );\n', '\n', '      require(_value >= _price);\n', '      _value -= _price;\n', '    }\n', '\n', '    if (_aquaticQuantity > 0) {\n', '      _price = _adoptSameClassAxies(\n', '        _adopter,\n', '        CLASS_AQUATIC,\n', '        _aquaticQuantity,\n', '        _actualReferrer\n', '      );\n', '\n', '      require(_value >= _price);\n', '      _value -= _price;\n', '    }\n', '\n', '    if (_plantQuantity > 0) {\n', '      _price = _adoptSameClassAxies(\n', '        _adopter,\n', '        CLASS_PLANT,\n', '        _plantQuantity,\n', '        _actualReferrer\n', '      );\n', '\n', '      require(_value >= _price);\n', '      _value -= _price;\n', '    }\n', '\n', '    msg.sender.transfer(_value);\n', '\n', "    // The current referral is ignored if the referrer's address is 0x0.\n", '    if (_actualReferrer != 0x0) {\n', '      _applyRefCredits(\n', '        _actualReferrer,\n', '        _beastQuantity.add(_aquaticQuantity).add(_plantQuantity)\n', '      );\n', '    }\n', '  }\n', '\n', '  function mintRefCredits(\n', '    address _receiver,\n', '    uint256 _numMintedCredits\n', '  )\n', '    external\n', '    onlyOwner\n', '    whenInitialized\n', '    returns (uint256)\n', '  {\n', '    require(_receiver != address(0));\n', '    numBountyCredits = numBountyCredits.sub(_numMintedCredits);\n', '    _applyRefCredits(_receiver, _numMintedCredits);\n', '    RefCreditsMinted(_receiver, _numMintedCredits);\n', '    return numBountyCredits;\n', '  }\n', '\n', '  function redeemAdoptedAxies(\n', '    address _receiver,\n', '    uint256 _beastQuantity,\n', '    uint256 _aquaticQuantity,\n', '    uint256 _plantQuantity\n', '  )\n', '    external\n', '    onlyRedemptionAddress\n', '    whenInitialized\n', '    returns (\n', '      uint256 /* remainingBeastQuantity */,\n', '      uint256 /* remainingAquaticQuantity */,\n', '      uint256 /* remainingPlantQuantity */\n', '    )\n', '  {\n', '    return (\n', '      _redeemSameClassAdoptedAxies(_receiver, CLASS_BEAST, _beastQuantity),\n', '      _redeemSameClassAdoptedAxies(_receiver, CLASS_AQUATIC, _aquaticQuantity),\n', '      _redeemSameClassAdoptedAxies(_receiver, CLASS_PLANT, _plantQuantity)\n', '    );\n', '  }\n', '\n', '  function redeemRewardedAxies(\n', '    address _receiver,\n', '    uint256 _quantity\n', '  )\n', '    external\n', '    onlyRedemptionAddress\n', '    whenInitialized\n', '    returns (uint256 _remainingQuantity)\n', '  {\n', '    _remainingQuantity = this.numRewardedAxies(_receiver, true).sub(_quantity);\n', '\n', '    if (_quantity > 0) {\n', '      _numDeductedRewardedAxies[_receiver] = _numDeductedRewardedAxies[_receiver].add(_quantity);\n', '      _totalDeductedRewardedAxies = _totalDeductedRewardedAxies.add(_quantity);\n', '\n', '      RewardedAxiesRedeemed(_receiver, _quantity);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Calculate price of Axies from the same class.\n', '   * @param _class The class of Axies.\n', '   * @param _quantity Number of Axies to be calculated.\n', '   */\n', '  function _sameClassAxiesPrice(\n', '    uint8 _class,\n', '    uint256 _quantity\n', '  )\n', '    private\n', '    view\n', '    returns (\n', '      uint256 _totalPrice,\n', '      uint256 /* should be _subsequentIncrement */ _currentIncrement,\n', '      uint256 /* should be _subsequentPrice */ _currentPrice\n', '    )\n', '  {\n', '    _currentIncrement = priceIncrement[_class];\n', '    _currentPrice = currentPrice[_class];\n', '\n', '    uint256 _nextPrice;\n', '\n', '    for (uint256 i = 0; i < _quantity; i++) {\n', '      _totalPrice = _totalPrice.add(_currentPrice);\n', '      _nextPrice = _currentPrice.add(_currentIncrement);\n', '\n', '      if (_nextPrice / 100 finney != _currentPrice / 100 finney) {\n', '        _currentIncrement >>= 1;\n', '      }\n', '\n', '      _currentPrice = _nextPrice;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Adopt some Axies from the same class.\n', '   * @dev The quantity MUST be positive.\n', '   * @param _adopter Address of the adopter.\n', '   * @param _class The class of adopted Axies.\n', '   * @param _quantity Number of Axies to be adopted.\n', '   * @param _referrer Address of the referrer.\n', '   */\n', '  function _adoptSameClassAxies(\n', '    address _adopter,\n', '    uint8 _class,\n', '    uint256 _quantity,\n', '    address _referrer\n', '  )\n', '    private\n', '    returns (uint256 _totalPrice)\n', '  {\n', '    (_totalPrice, priceIncrement[_class], currentPrice[_class]) = _sameClassAxiesPrice(_class, _quantity);\n', '\n', '    _numAdoptedAxies[_adopter][_class] = _numAdoptedAxies[_adopter][_class].add(_quantity);\n', '    _totalAdoptedAxies[_class] = _totalAdoptedAxies[_class].add(_quantity);\n', '\n', '    AxiesAdopted(\n', '      _adopter,\n', '      _class,\n', '      _quantity,\n', '      _referrer\n', '    );\n', '  }\n', '\n', '  function _applyRefCredits(address _receiver, uint256 _numAppliedCredits) private {\n', '    _numRefCredits[_receiver] = _numRefCredits[_receiver].add(_numAppliedCredits);\n', '\n', '    uint256 _numCredits = this.numRefCredits(_receiver, true);\n', '    uint256 _numRewards = _numCredits / REF_CREDITS_PER_AXIE;\n', '\n', '    if (_numRewards > 0) {\n', '      _numDeductedRefCredits[_receiver] = _numDeductedRefCredits[_receiver]\n', '        .add(_numRewards.mul(REF_CREDITS_PER_AXIE));\n', '\n', '      _numRewardedAxies[_receiver] = _numRewardedAxies[_receiver].add(_numRewards);\n', '      _totalRewardedAxies = _totalRewardedAxies.add(_numRewards);\n', '\n', '      AxiesRewarded(_receiver, _numRewards);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Redeem adopted Axies from the same class.\n', '   * @dev Emit the `AdoptedAxiesRedeemed` event if the quantity is positive.\n', '   * @param _receiver The address of the receiver.\n', '   * @param _class The class of adopted Axies.\n', '   * @param _quantity The number of adopted Axies to be redeemed.\n', '   */\n', '  function _redeemSameClassAdoptedAxies(\n', '    address _receiver,\n', '    uint8 _class,\n', '    uint256 _quantity\n', '  )\n', '    private\n', '    returns (uint256 _remainingQuantity)\n', '  {\n', '    _remainingQuantity = this.numAdoptedAxies(_receiver, _class, true).sub(_quantity);\n', '\n', '    if (_quantity > 0) {\n', '      _numDeductedAdoptedAxies[_receiver][_class] = _numDeductedAdoptedAxies[_receiver][_class].add(_quantity);\n', '      _totalDeductedAdoptedAxies[_class] = _totalDeductedAdoptedAxies[_class].add(_quantity);\n', '\n', '      AdoptedAxiesRedeemed(_receiver, _class, _quantity);\n', '    }\n', '  }\n', '}']
