['pragma solidity ^0.4.23;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '\tfunction add(uint a, uint b) internal pure returns (uint c) {\n', '\t\tc = a + b; require(c >= a);\n', '\t}\n', '\tfunction sub(uint a, uint b) internal pure returns (uint c) {\n', '\t\trequire(b <= a); c = a - b;\n', '\t}\n', '\tfunction mul(uint a, uint b) internal pure returns (uint c) {\n', '\t\tc = a * b; require(a == 0 || c / a == b);\n', '\t}\n', '\tfunction div(uint a, uint b) internal pure returns (uint c) {\n', '\t\trequire(b > 0); c = a / b;\n', '\t}\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '\tfunction totalSupply() public constant returns (uint);\n', '\tfunction balanceOf(address tokenOwner) public constant returns (uint balance);\n', '\tfunction allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '\tfunction transfer(address to, uint tokens) public returns (bool success);\n', '\tfunction approve(address spender, uint tokens) public returns (bool success);\n', '\tfunction transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\tevent Transfer(address indexed from, address indexed to, uint tokens);\n', '\tevent Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '\taddress public owner;\n', '\taddress public parityOwner;\n', '\taddress public newOwner;\n', '\taddress public newParityOwner;\n', '\tevent OwnershipTransferred(address indexed _from, address indexed _to);\n', '\tevent ParityOwnershipTransferred(address indexed _from, address indexed _to);\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t\tparityOwner = 0xC1eb7d6d44457A33582Ed7541CEd9CDb03A7A3a9;\n', '\t}\n', '\tmodifier onlyOwner {\n', '\t\tbool isOwner = (msg.sender == owner);\n', '\t\trequire(isOwner);\n', '\t\t_;\n', '\t}\n', '\tmodifier onlyOwners {\n', '\t\tbool isOwner = (msg.sender == owner);\n', '\t\tbool isParityOwner = (msg.sender == parityOwner);\n', '\t\trequire(owner != parityOwner);\n', '\t\trequire(isOwner || isParityOwner);\n', '\t\t_;\n', '\t}\n', '\tfunction transferOwnership(address _newOwner) public onlyOwner {\n', '\t\trequire(_newOwner != parityOwner);\n', '\t\trequire(_newOwner != newParityOwner);\n', '\t\tnewOwner = _newOwner;\n', '\t}\n', '\tfunction acceptOwnership() public {\n', '\t\trequire(msg.sender == newOwner);\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t\tnewOwner = address(0);\n', '\t}\n', '\tfunction transferParityOwnership(address _newParityOwner) public onlyOwner {\n', '\t\trequire(_newParityOwner != owner);\n', '\t\trequire(_newParityOwner != newOwner);\n', '\t\tnewParityOwner = _newParityOwner;\n', '\t}\n', '\tfunction acceptParityOwnership() public {\n', '\t\trequire(msg.sender == newParityOwner);\n', '\t\temit ParityOwnershipTransferred(parityOwner, newParityOwner);\n', '\t\tparityOwner = newParityOwner;\n', '\t\tnewParityOwner = address(0);\n', '\t}\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// NZO (Release Candidate)\n', '// ----------------------------------------------------------------------------\n', 'contract NZO is ERC20Interface, Owned {\n', '\tusing SafeMath for uint;\n', '\n', '\tstring public symbol;\n', '\tstring public  name;\n', '\tuint8  public decimals;\n', '\tuint   public _totalSupply;\n', '\tuint   public releasedSupply;\n', '\tuint   public crowdSaleBalance;\n', '\tuint   public crowdSaleAmountRaised;\n', '\tbool   public crowdSaleOngoing;\n', '\tuint   public crowdSalesCompleted;\n', '\tbool   public supplyLocked;\n', '\tbool   public supplyLockedA;\n', '\tbool   public supplyLockedB;\n', '\tuint   public weiCostOfToken;\n', '\n', '\tmapping(address => uint) balances;\n', '\tmapping(address => mapping(address => uint)) allowed;\n', '\tmapping(address => mapping(address => uint)) owed;\n', '\tmapping(address => uint) crowdSaleAllowed;\n', '\n', '\tevent SupplyLocked(bool isLocked);\n', '\tevent AddOwed(address indexed from, address indexed to, uint tokens);\n', '\tevent CrowdSaleLocked(bool status, uint indexed completed, uint amountRaised);\n', '\tevent CrowdSaleOpened(bool status);\n', '\tevent CrowdSaleApproval(address approver, address indexed buyer, uint tokens);\n', '\tevent CrowdSalePurchaseCompleted(address indexed buyer, uint ethAmount, uint tokens);\n', '\tevent ChangedWeiCostOfToken(uint newCost);\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Constructor\n', '\t// 900,000,000 total.\n', '\t// 540,000,000 for crowd sale.\n', '\t// 360,000,000 for normal.\n', '\t// Starting cost: 0.10 USD for 1 token.\n', '\t// ------------------------------------------------------------------------\n', '\tconstructor() public {\n', '\t\tsymbol                = "NZO";\n', '\t\tname                  = "Non-Zero";\n', '\t\tdecimals              = 18;\n', '\t\t_totalSupply          = 900000000 * 10**uint(decimals);\n', '\t\treleasedSupply        = 0;\n', '\t\tcrowdSaleBalance      = 540000000 * 10**uint(decimals);\n', '\t\tcrowdSaleAmountRaised = 0;\n', '\t\tcrowdSaleOngoing      = true;\n', '\t\tcrowdSalesCompleted   = 0;\n', '\t\tsupplyLocked          = false;\n', '\t\tsupplyLockedA         = false;\n', '\t\tsupplyLockedB         = false;\n', '\t\tweiCostOfToken        = 168000000000000 * 1 wei;\n', '\t\tbalances[owner]       = _totalSupply - crowdSaleBalance;\n', '\t\temit Transfer(address(0), owner, _totalSupply);\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Getters\n', '\t// ------------------------------------------------------------------------\n', '\tfunction totalSupply() public constant returns (uint) {\n', '\t\treturn _totalSupply  - balances[address(0)];\n', '\t}\n', '\tfunction balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '\t\treturn balances[tokenOwner];\n', '\t}\n', '\tfunction allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '\t\treturn allowed[tokenOwner][spender];\n', '\t}\n', '\tfunction getOwed(address from, address to) public constant returns (uint tokens) {\n', '\t\treturn owed[from][to];\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Lock token supply. CAUTION: IRREVERSIBLE\n', '\t// ------------------------------------------------------------------------\n', '\tfunction lockSupply() public onlyOwners returns (bool isSupplyLocked) {\n', '\t\trequire(!supplyLocked);\n', '\t\tif (msg.sender == owner) {\n', '\t\t\tsupplyLockedA = true;\n', '\t\t} else if (msg.sender == parityOwner) {\n', '\t\t\tsupplyLockedB = true;\n', '\t\t}\n', '\t\tsupplyLocked = (supplyLockedA && supplyLockedB);\n', '\t\temit SupplyLocked(true);\n', '\t\treturn supplyLocked;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Increase total supply ("issue" new tokens)\n', '\t// ------------------------------------------------------------------------\n', '\tfunction increaseTotalSupply(uint tokens) public onlyOwner returns (bool success) {\n', '\t\trequire(!supplyLocked);\n', '\t\t_totalSupply = _totalSupply.add(tokens);\n', '\t\tbalances[owner] = balances[owner].add(tokens);\n', '\t\temit Transfer(address(0), owner, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// End crowd sale. Increments crowdSalesCompleted counter.\n', '\t// Returns remaining crowdSaleBalance to owner.\n', '\t// ------------------------------------------------------------------------\n', '\tfunction lockCrowdSale() public onlyOwner returns (bool success) {\n', '\t\trequire(crowdSaleOngoing);\n', '\t\tcrowdSaleOngoing = false;\n', '\t\tcrowdSalesCompleted = crowdSalesCompleted.add(1);\n', '\t\tbalances[owner] = balances[owner].add(crowdSaleBalance);\n', '\t\tcrowdSaleBalance = 0;\n', '\t\temit CrowdSaleLocked(!crowdSaleOngoing, crowdSalesCompleted, crowdSaleAmountRaised);\n', '\t\treturn !crowdSaleOngoing;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Open a new crowd sale.\n', '\t// ------------------------------------------------------------------------\n', '\tfunction openCrowdSale(uint supply) public onlyOwner returns (bool success) {\n', '\t\trequire(!crowdSaleOngoing);\n', '\t\trequire(supply <= balances[owner]);\n', '\t\tbalances[owner] = balances[owner].sub(supply);\n', '\t\tcrowdSaleBalance = supply;\n', '\t\tcrowdSaleOngoing = true;\n', '\t\temit CrowdSaleOpened(crowdSaleOngoing);\n', '\t\treturn crowdSaleOngoing;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Add amount owed (usually from broker to user)\n', '\t// Amount can only be increased, and can only be decreased by paying.\n', '\t// ------------------------------------------------------------------------\n', '\tfunction addOwed(address to, uint tokens) public returns (uint newOwed) {\n', '\t\trequire((msg.sender == owner) || (crowdSalesCompleted > 0));\n', '\t\towed[msg.sender][to] = owed[msg.sender][to].add(tokens);\n', '\t\temit AddOwed(msg.sender, to, tokens);\n', '\t\treturn owed[msg.sender][to];\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Token owner can approve for `spender` to transferFrom(...) `tokens`\n', '\t// from the token owner&#39;s account\n', '\t//\n', '\t// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '\t// recommends that there are no checks for the approval double-spend attack\n', '\t// as this should be implemented in user interfaces \n', '\t// ------------------------------------------------------------------------\n', '\tfunction approve(address spender, uint tokens) public returns (bool success) {\n', '\t\trequire((msg.sender == owner) || (crowdSalesCompleted > 0));\n', '\t\tallowed[msg.sender][spender] = tokens;\n', '\t\temit Approval(msg.sender, spender, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Allow an address to participate in the crowd sale up to some limit\n', '\t// ------------------------------------------------------------------------\n', '\tfunction crowdSaleApprove(address buyer, uint tokens) public onlyOwner returns (bool success) {\n', '\t\trequire(tokens <= crowdSaleBalance);\n', '\t\tcrowdSaleAllowed[buyer] = tokens;\n', '\t\temit CrowdSaleApproval(msg.sender, buyer, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Transfer the balance from token owner&#39;s account to `to` account\n', '\t// - Owner&#39;s account must have sufficient balance to transfer\n', '\t// - 0 value transfers are allowed\n', '\t// ------------------------------------------------------------------------\n', '\tfunction transfer(address to, uint tokens) public returns (bool success) {\n', '\t\trequire((msg.sender == owner) || (crowdSalesCompleted > 0));\n', '\t\trequire(msg.sender != to);\n', '\t\trequire(to != owner);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(tokens);\n', '\t\tbalances[to] = balances[to].add(tokens);\n', '\t\tif (owed[msg.sender][to] >= tokens) {\n', '\t\t\towed[msg.sender][to].sub(tokens);\n', '\t\t} else if (owed[msg.sender][to] < tokens) {\n', '\t\t\towed[msg.sender][to] = uint(0);\n', '\t\t}\n', '\t\tif (msg.sender == owner) {\n', '\t\t\treleasedSupply.add(tokens);\n', '\t\t}\n', '\t\temit Transfer(msg.sender, to, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Transfer `tokens` from the `from` account to the `to` account\n', '\t// \n', '\t// The calling account must already have sufficient tokens approve(...)-d\n', '\t// for spending from the `from` account and\n', '\t// - From account must have sufficient balance to transfer\n', '\t// - Spender must have sufficient allowance to transfer\n', '\t// - 0 value transfers are allowed\n', '\t// ------------------------------------------------------------------------\n', '\tfunction transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '\t\trequire((from == owner) || (crowdSalesCompleted > 0));\n', '\t\trequire(from != to);\n', '\t\trequire(to != owner);\n', '\t\tbalances[from] = balances[from].sub(tokens);\n', '\t\tallowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '\t\tbalances[to] = balances[to].add(tokens);\n', '\t\tif (owed[from][to] >= tokens) {\n', '\t\t\towed[from][to].sub(tokens);\n', '\t\t} else if (owed[from][to] < tokens) {\n', '\t\t\towed[from][to] = uint(0);\n', '\t\t}\n', '\t\tif (from == owner) {\n', '\t\t\treleasedSupply.add(tokens);\n', '\t\t}\n', '\t\temit Transfer(from, to, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Change ETH cost of token (goal is to keep it pegged to 0.10 USD)\n', '\t// Cost must be specified in Wei\n', '\t// ------------------------------------------------------------------------\n', '\tfunction changeWeiCostOfToken(uint newCost) public onlyOwners returns (uint changedCost) {\n', '\t\trequire(crowdSaleOngoing);\n', '\t\trequire(newCost > 0);\n', '\t\tweiCostOfToken = newCost * 1 wei;\n', '\t\temit ChangedWeiCostOfToken(newCost);\n', '\t\treturn weiCostOfToken;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Only accept ETH during crowd sale period\n', '\t// Crowdsale purchaser must be KYCed and added to allowed map\n', '\t// ------------------------------------------------------------------------\n', '\tfunction () public payable {\n', '\t\trequire(msg.value > 0);\n', '\t\trequire(crowdSaleOngoing);\n', '\t\trequire(now > 1531267200);\n', '\t\tuint tokens = (msg.value * (10**uint(decimals))) / weiCostOfToken;\n', '\t\tuint remainder = msg.value % weiCostOfToken;\n', '\t\tif (now < 1533081600) { tokens = (125 * tokens) / 100; }\n', '\t\telse if (now < 1535932800) { tokens = (110 * tokens) / 100; }\n', '\n', '\t\tcrowdSaleAllowed[msg.sender] = crowdSaleAllowed[msg.sender].sub(tokens);\n', '\t\tcrowdSaleBalance = crowdSaleBalance.sub(tokens);\n', '\t\tbalances[msg.sender] = balances[msg.sender].add(tokens);\n', '\t\tcrowdSaleAmountRaised = crowdSaleAmountRaised.add(msg.value);\n', '\t\towner.transfer(msg.value - remainder);\n', '\t\temit Transfer(owner, msg.sender, tokens);\n', '\t\temit CrowdSalePurchaseCompleted(msg.sender, msg.value, tokens);\n', '\t\t\n', '\t\tif (crowdSaleBalance == 0) {\n', '\t\t\tcrowdSaleOngoing = false;\n', '\t\t\tcrowdSalesCompleted = crowdSalesCompleted.add(1);\n', '\t\t\temit CrowdSaleLocked(!crowdSaleOngoing, crowdSalesCompleted, crowdSaleAmountRaised);\n', '\t\t}\n', '\t\tif (remainder > 0) {\n', '\t\t\tmsg.sender.transfer(remainder);\n', '\t\t}\n', '\t}\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '\tfunction add(uint a, uint b) internal pure returns (uint c) {\n', '\t\tc = a + b; require(c >= a);\n', '\t}\n', '\tfunction sub(uint a, uint b) internal pure returns (uint c) {\n', '\t\trequire(b <= a); c = a - b;\n', '\t}\n', '\tfunction mul(uint a, uint b) internal pure returns (uint c) {\n', '\t\tc = a * b; require(a == 0 || c / a == b);\n', '\t}\n', '\tfunction div(uint a, uint b) internal pure returns (uint c) {\n', '\t\trequire(b > 0); c = a / b;\n', '\t}\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '\tfunction totalSupply() public constant returns (uint);\n', '\tfunction balanceOf(address tokenOwner) public constant returns (uint balance);\n', '\tfunction allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '\tfunction transfer(address to, uint tokens) public returns (bool success);\n', '\tfunction approve(address spender, uint tokens) public returns (bool success);\n', '\tfunction transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\tevent Transfer(address indexed from, address indexed to, uint tokens);\n', '\tevent Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '\taddress public owner;\n', '\taddress public parityOwner;\n', '\taddress public newOwner;\n', '\taddress public newParityOwner;\n', '\tevent OwnershipTransferred(address indexed _from, address indexed _to);\n', '\tevent ParityOwnershipTransferred(address indexed _from, address indexed _to);\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t\tparityOwner = 0xC1eb7d6d44457A33582Ed7541CEd9CDb03A7A3a9;\n', '\t}\n', '\tmodifier onlyOwner {\n', '\t\tbool isOwner = (msg.sender == owner);\n', '\t\trequire(isOwner);\n', '\t\t_;\n', '\t}\n', '\tmodifier onlyOwners {\n', '\t\tbool isOwner = (msg.sender == owner);\n', '\t\tbool isParityOwner = (msg.sender == parityOwner);\n', '\t\trequire(owner != parityOwner);\n', '\t\trequire(isOwner || isParityOwner);\n', '\t\t_;\n', '\t}\n', '\tfunction transferOwnership(address _newOwner) public onlyOwner {\n', '\t\trequire(_newOwner != parityOwner);\n', '\t\trequire(_newOwner != newParityOwner);\n', '\t\tnewOwner = _newOwner;\n', '\t}\n', '\tfunction acceptOwnership() public {\n', '\t\trequire(msg.sender == newOwner);\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t\tnewOwner = address(0);\n', '\t}\n', '\tfunction transferParityOwnership(address _newParityOwner) public onlyOwner {\n', '\t\trequire(_newParityOwner != owner);\n', '\t\trequire(_newParityOwner != newOwner);\n', '\t\tnewParityOwner = _newParityOwner;\n', '\t}\n', '\tfunction acceptParityOwnership() public {\n', '\t\trequire(msg.sender == newParityOwner);\n', '\t\temit ParityOwnershipTransferred(parityOwner, newParityOwner);\n', '\t\tparityOwner = newParityOwner;\n', '\t\tnewParityOwner = address(0);\n', '\t}\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// NZO (Release Candidate)\n', '// ----------------------------------------------------------------------------\n', 'contract NZO is ERC20Interface, Owned {\n', '\tusing SafeMath for uint;\n', '\n', '\tstring public symbol;\n', '\tstring public  name;\n', '\tuint8  public decimals;\n', '\tuint   public _totalSupply;\n', '\tuint   public releasedSupply;\n', '\tuint   public crowdSaleBalance;\n', '\tuint   public crowdSaleAmountRaised;\n', '\tbool   public crowdSaleOngoing;\n', '\tuint   public crowdSalesCompleted;\n', '\tbool   public supplyLocked;\n', '\tbool   public supplyLockedA;\n', '\tbool   public supplyLockedB;\n', '\tuint   public weiCostOfToken;\n', '\n', '\tmapping(address => uint) balances;\n', '\tmapping(address => mapping(address => uint)) allowed;\n', '\tmapping(address => mapping(address => uint)) owed;\n', '\tmapping(address => uint) crowdSaleAllowed;\n', '\n', '\tevent SupplyLocked(bool isLocked);\n', '\tevent AddOwed(address indexed from, address indexed to, uint tokens);\n', '\tevent CrowdSaleLocked(bool status, uint indexed completed, uint amountRaised);\n', '\tevent CrowdSaleOpened(bool status);\n', '\tevent CrowdSaleApproval(address approver, address indexed buyer, uint tokens);\n', '\tevent CrowdSalePurchaseCompleted(address indexed buyer, uint ethAmount, uint tokens);\n', '\tevent ChangedWeiCostOfToken(uint newCost);\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Constructor\n', '\t// 900,000,000 total.\n', '\t// 540,000,000 for crowd sale.\n', '\t// 360,000,000 for normal.\n', '\t// Starting cost: 0.10 USD for 1 token.\n', '\t// ------------------------------------------------------------------------\n', '\tconstructor() public {\n', '\t\tsymbol                = "NZO";\n', '\t\tname                  = "Non-Zero";\n', '\t\tdecimals              = 18;\n', '\t\t_totalSupply          = 900000000 * 10**uint(decimals);\n', '\t\treleasedSupply        = 0;\n', '\t\tcrowdSaleBalance      = 540000000 * 10**uint(decimals);\n', '\t\tcrowdSaleAmountRaised = 0;\n', '\t\tcrowdSaleOngoing      = true;\n', '\t\tcrowdSalesCompleted   = 0;\n', '\t\tsupplyLocked          = false;\n', '\t\tsupplyLockedA         = false;\n', '\t\tsupplyLockedB         = false;\n', '\t\tweiCostOfToken        = 168000000000000 * 1 wei;\n', '\t\tbalances[owner]       = _totalSupply - crowdSaleBalance;\n', '\t\temit Transfer(address(0), owner, _totalSupply);\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Getters\n', '\t// ------------------------------------------------------------------------\n', '\tfunction totalSupply() public constant returns (uint) {\n', '\t\treturn _totalSupply  - balances[address(0)];\n', '\t}\n', '\tfunction balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '\t\treturn balances[tokenOwner];\n', '\t}\n', '\tfunction allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '\t\treturn allowed[tokenOwner][spender];\n', '\t}\n', '\tfunction getOwed(address from, address to) public constant returns (uint tokens) {\n', '\t\treturn owed[from][to];\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Lock token supply. CAUTION: IRREVERSIBLE\n', '\t// ------------------------------------------------------------------------\n', '\tfunction lockSupply() public onlyOwners returns (bool isSupplyLocked) {\n', '\t\trequire(!supplyLocked);\n', '\t\tif (msg.sender == owner) {\n', '\t\t\tsupplyLockedA = true;\n', '\t\t} else if (msg.sender == parityOwner) {\n', '\t\t\tsupplyLockedB = true;\n', '\t\t}\n', '\t\tsupplyLocked = (supplyLockedA && supplyLockedB);\n', '\t\temit SupplyLocked(true);\n', '\t\treturn supplyLocked;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Increase total supply ("issue" new tokens)\n', '\t// ------------------------------------------------------------------------\n', '\tfunction increaseTotalSupply(uint tokens) public onlyOwner returns (bool success) {\n', '\t\trequire(!supplyLocked);\n', '\t\t_totalSupply = _totalSupply.add(tokens);\n', '\t\tbalances[owner] = balances[owner].add(tokens);\n', '\t\temit Transfer(address(0), owner, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// End crowd sale. Increments crowdSalesCompleted counter.\n', '\t// Returns remaining crowdSaleBalance to owner.\n', '\t// ------------------------------------------------------------------------\n', '\tfunction lockCrowdSale() public onlyOwner returns (bool success) {\n', '\t\trequire(crowdSaleOngoing);\n', '\t\tcrowdSaleOngoing = false;\n', '\t\tcrowdSalesCompleted = crowdSalesCompleted.add(1);\n', '\t\tbalances[owner] = balances[owner].add(crowdSaleBalance);\n', '\t\tcrowdSaleBalance = 0;\n', '\t\temit CrowdSaleLocked(!crowdSaleOngoing, crowdSalesCompleted, crowdSaleAmountRaised);\n', '\t\treturn !crowdSaleOngoing;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Open a new crowd sale.\n', '\t// ------------------------------------------------------------------------\n', '\tfunction openCrowdSale(uint supply) public onlyOwner returns (bool success) {\n', '\t\trequire(!crowdSaleOngoing);\n', '\t\trequire(supply <= balances[owner]);\n', '\t\tbalances[owner] = balances[owner].sub(supply);\n', '\t\tcrowdSaleBalance = supply;\n', '\t\tcrowdSaleOngoing = true;\n', '\t\temit CrowdSaleOpened(crowdSaleOngoing);\n', '\t\treturn crowdSaleOngoing;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Add amount owed (usually from broker to user)\n', '\t// Amount can only be increased, and can only be decreased by paying.\n', '\t// ------------------------------------------------------------------------\n', '\tfunction addOwed(address to, uint tokens) public returns (uint newOwed) {\n', '\t\trequire((msg.sender == owner) || (crowdSalesCompleted > 0));\n', '\t\towed[msg.sender][to] = owed[msg.sender][to].add(tokens);\n', '\t\temit AddOwed(msg.sender, to, tokens);\n', '\t\treturn owed[msg.sender][to];\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "\t// from the token owner's account\n", '\t//\n', '\t// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '\t// recommends that there are no checks for the approval double-spend attack\n', '\t// as this should be implemented in user interfaces \n', '\t// ------------------------------------------------------------------------\n', '\tfunction approve(address spender, uint tokens) public returns (bool success) {\n', '\t\trequire((msg.sender == owner) || (crowdSalesCompleted > 0));\n', '\t\tallowed[msg.sender][spender] = tokens;\n', '\t\temit Approval(msg.sender, spender, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Allow an address to participate in the crowd sale up to some limit\n', '\t// ------------------------------------------------------------------------\n', '\tfunction crowdSaleApprove(address buyer, uint tokens) public onlyOwner returns (bool success) {\n', '\t\trequire(tokens <= crowdSaleBalance);\n', '\t\tcrowdSaleAllowed[buyer] = tokens;\n', '\t\temit CrowdSaleApproval(msg.sender, buyer, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', "\t// Transfer the balance from token owner's account to `to` account\n", "\t// - Owner's account must have sufficient balance to transfer\n", '\t// - 0 value transfers are allowed\n', '\t// ------------------------------------------------------------------------\n', '\tfunction transfer(address to, uint tokens) public returns (bool success) {\n', '\t\trequire((msg.sender == owner) || (crowdSalesCompleted > 0));\n', '\t\trequire(msg.sender != to);\n', '\t\trequire(to != owner);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(tokens);\n', '\t\tbalances[to] = balances[to].add(tokens);\n', '\t\tif (owed[msg.sender][to] >= tokens) {\n', '\t\t\towed[msg.sender][to].sub(tokens);\n', '\t\t} else if (owed[msg.sender][to] < tokens) {\n', '\t\t\towed[msg.sender][to] = uint(0);\n', '\t\t}\n', '\t\tif (msg.sender == owner) {\n', '\t\t\treleasedSupply.add(tokens);\n', '\t\t}\n', '\t\temit Transfer(msg.sender, to, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Transfer `tokens` from the `from` account to the `to` account\n', '\t// \n', '\t// The calling account must already have sufficient tokens approve(...)-d\n', '\t// for spending from the `from` account and\n', '\t// - From account must have sufficient balance to transfer\n', '\t// - Spender must have sufficient allowance to transfer\n', '\t// - 0 value transfers are allowed\n', '\t// ------------------------------------------------------------------------\n', '\tfunction transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '\t\trequire((from == owner) || (crowdSalesCompleted > 0));\n', '\t\trequire(from != to);\n', '\t\trequire(to != owner);\n', '\t\tbalances[from] = balances[from].sub(tokens);\n', '\t\tallowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '\t\tbalances[to] = balances[to].add(tokens);\n', '\t\tif (owed[from][to] >= tokens) {\n', '\t\t\towed[from][to].sub(tokens);\n', '\t\t} else if (owed[from][to] < tokens) {\n', '\t\t\towed[from][to] = uint(0);\n', '\t\t}\n', '\t\tif (from == owner) {\n', '\t\t\treleasedSupply.add(tokens);\n', '\t\t}\n', '\t\temit Transfer(from, to, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Change ETH cost of token (goal is to keep it pegged to 0.10 USD)\n', '\t// Cost must be specified in Wei\n', '\t// ------------------------------------------------------------------------\n', '\tfunction changeWeiCostOfToken(uint newCost) public onlyOwners returns (uint changedCost) {\n', '\t\trequire(crowdSaleOngoing);\n', '\t\trequire(newCost > 0);\n', '\t\tweiCostOfToken = newCost * 1 wei;\n', '\t\temit ChangedWeiCostOfToken(newCost);\n', '\t\treturn weiCostOfToken;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Only accept ETH during crowd sale period\n', '\t// Crowdsale purchaser must be KYCed and added to allowed map\n', '\t// ------------------------------------------------------------------------\n', '\tfunction () public payable {\n', '\t\trequire(msg.value > 0);\n', '\t\trequire(crowdSaleOngoing);\n', '\t\trequire(now > 1531267200);\n', '\t\tuint tokens = (msg.value * (10**uint(decimals))) / weiCostOfToken;\n', '\t\tuint remainder = msg.value % weiCostOfToken;\n', '\t\tif (now < 1533081600) { tokens = (125 * tokens) / 100; }\n', '\t\telse if (now < 1535932800) { tokens = (110 * tokens) / 100; }\n', '\n', '\t\tcrowdSaleAllowed[msg.sender] = crowdSaleAllowed[msg.sender].sub(tokens);\n', '\t\tcrowdSaleBalance = crowdSaleBalance.sub(tokens);\n', '\t\tbalances[msg.sender] = balances[msg.sender].add(tokens);\n', '\t\tcrowdSaleAmountRaised = crowdSaleAmountRaised.add(msg.value);\n', '\t\towner.transfer(msg.value - remainder);\n', '\t\temit Transfer(owner, msg.sender, tokens);\n', '\t\temit CrowdSalePurchaseCompleted(msg.sender, msg.value, tokens);\n', '\t\t\n', '\t\tif (crowdSaleBalance == 0) {\n', '\t\t\tcrowdSaleOngoing = false;\n', '\t\t\tcrowdSalesCompleted = crowdSalesCompleted.add(1);\n', '\t\t\temit CrowdSaleLocked(!crowdSaleOngoing, crowdSalesCompleted, crowdSaleAmountRaised);\n', '\t\t}\n', '\t\tif (remainder > 0) {\n', '\t\t\tmsg.sender.transfer(remainder);\n', '\t\t}\n', '\t}\n', '}']
