['pragma solidity ^0.4.24;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/pricing/CvcPricingInterface.sol\n', '\n', '/**\n', ' * @title CvcPricingInterface\n', ' * @dev This contract defines the pricing service interface.\n', ' */\n', 'contract CvcPricingInterface {\n', '\n', '    struct CredentialItemPrice {\n', '        bytes32 id;\n', '        uint256 price;\n', '        address idv;\n', '        string credentialItemType;\n', '        string credentialItemName;\n', '        string credentialItemVersion;\n', '        bool deprecated;\n', '    }\n', '\n', '    /**\n', '     * @dev The CredentialItemPriceSet event is emitted when Identity Validator sets new price for specific credential item.\n', '     *\n', '     * @param id Price record identifier.\n', '     * @param price Credential Item price in CVC.\n', '     * @param idv The address of Identity Validator who offers Credential Item for sale.\n', '     * @param credentialItemType Credential Item Type.\n', '     * @param credentialItemName Credential Item Name.\n', '     * @param credentialItemVersion Credential Item Version.\n', '     * @param credentialItemId Credential Item ID.\n', '     */\n', '    event CredentialItemPriceSet(\n', '        bytes32 indexed id,\n', '        uint256 price,\n', '        address indexed idv,\n', '        string credentialItemType,\n', '        string credentialItemName,\n', '        string credentialItemVersion,\n', '        bytes32 indexed credentialItemId\n', '    );\n', '\n', '    /**\n', '     * @dev The CredentialItemPriceDeleted event is emitted when Identity Validator deletes the price for specific credential item.\n', '     *\n', '     * @param id Price record identifier.\n', '     * @param idv The address of Identity Validator who offers Credential Item for sale\n', '     * @param credentialItemType Credential Item Type.\n', '     * @param credentialItemName Credential Item Name.\n', '     * @param credentialItemVersion Credential Item Version.\n', '     * @param credentialItemId Credential Item ID.\n', '     */\n', '    event CredentialItemPriceDeleted(\n', '        bytes32 indexed id,\n', '        address indexed idv,\n', '        string credentialItemType,\n', '        string credentialItemName,\n', '        string credentialItemVersion,\n', '        bytes32 indexed credentialItemId\n', '    );\n', '\n', '    /**\n', '    * @dev Sets the price for Credential Item of specific type, name and version.\n', '    * The price is associated with IDV address (sender).\n', '    * @param _credentialItemType Credential Item type.\n', '    * @param _credentialItemName Credential Item name.\n', '    * @param _credentialItemVersion Credential Item version.\n', '    * @param _price Credential Item price.\n', '    */\n', '    function setPrice(\n', '        string _credentialItemType,\n', '        string _credentialItemName,\n', '        string _credentialItemVersion,\n', '        uint256 _price\n', '        ) external;\n', '\n', '    /**\n', '    * @dev Deletes the price for Credential Item of specific type, name and version.\n', '    * @param _credentialItemType Credential Item type.\n', '    * @param _credentialItemName Credential Item name.\n', '    * @param _credentialItemVersion Credential Item version.\n', '    */\n', '    function deletePrice(\n', '        string _credentialItemType,\n', '        string _credentialItemName,\n', '        string _credentialItemVersion\n', '        ) external;\n', '\n', '    /**\n', '    * @dev Returns the price set by IDV for Credential Item of specific type, name and version.\n', '    * @param _idv IDV address.\n', '    * @param _credentialItemType Credential Item type.\n', '    * @param _credentialItemName Credential Item name.\n', '    * @param _credentialItemVersion Credential Item version.\n', '    * @return bytes32 Price ID.\n', '    * @return uint256 Price value.\n', '    * @return address IDV address.\n', '    * @return string Credential Item type.\n', '    * @return string Credential Item name.\n', '    * @return string Credential Item version.\n', '    */\n', '    function getPrice(\n', '        address _idv,\n', '        string _credentialItemType,\n', '        string _credentialItemName,\n', '        string _credentialItemVersion\n', '        ) external view returns (\n', '            bytes32 id,\n', '            uint256 price,\n', '            address idv,\n', '            string credentialItemType,\n', '            string credentialItemName,\n', '            string credentialItemVersion,\n', '            bool deprecated\n', '        );\n', '\n', '    /**\n', '    * @dev Returns the price by Credential Item ID.\n', '    * @param _idv IDV address.\n', '    * @param _credentialItemId Credential Item ID.\n', '    * @return bytes32 Price ID.\n', '    * @return uint256 Price value.\n', '    * @return address IDV address.\n', '    * @return string Credential Item type.\n', '    * @return string Credential Item name.\n', '    * @return string Credential Item version.\n', '    */\n', '    function getPriceByCredentialItemId(\n', '        address _idv,\n', '        bytes32 _credentialItemId\n', '        ) external view returns (\n', '            bytes32 id,\n', '            uint256 price,\n', '            address idv,\n', '            string credentialItemType,\n', '            string credentialItemName,\n', '            string credentialItemVersion,\n', '            bool deprecated\n', '        );\n', '\n', '    /**\n', '    * @dev Returns all Credential Item prices.\n', '    * @return CredentialItemPrice[]\n', '    */\n', '    function getAllPrices() external view returns (CredentialItemPrice[]);\n', '\n', '    /**\n', '     * @dev Returns all IDs of registered Credential Item prices.\n', '     * @return bytes32[]\n', '     */\n', '    function getAllIds() external view returns (bytes32[]);\n', '\n', '    /**\n', '    * @dev Returns the price by ID.\n', '    * @param _id Price ID\n', '    * @return bytes32 Price ID.\n', '    * @return uint256 Price value.\n', '    * @return address IDV address.\n', '    * @return string Credential Item type.\n', '    * @return string Credential Item name.\n', '    * @return string Credential Item version.\n', '    */\n', '    function getPriceById(\n', '        bytes32 _id\n', '        ) public view returns (\n', '            bytes32 id,\n', '            uint256 price,\n', '            address idv,\n', '            string credentialItemType,\n', '            string credentialItemName,\n', '            string credentialItemVersion,\n', '            bool deprecated\n', '        );\n', '}\n', '\n', '// File: contracts/idv/CvcValidatorRegistryInterface.sol\n', '\n', '/**\n', ' * @title CvcValidatorRegistryInterface\n', ' * @dev This contract defines Validator Registry interface.\n', ' */\n', 'contract CvcValidatorRegistryInterface {\n', '\n', '    /**\n', '    * @dev Adds a new Validator record or updates the existing one.\n', '    * @param _name Validator name.\n', '    * @param _description Validator description.\n', '    */\n', '    function set(address _idv, string _name, string _description) external;\n', '\n', '    /**\n', '    * @dev Returns Validator entry.\n', '    * @param _idv Validator address.\n', '    * @return name Validator name.\n', '    * @return description Validator description.\n', '    */\n', '    function get(address _idv) external view returns (string name, string description);\n', '\n', '    /**\n', '    * @dev Verifies whether Validator is registered.\n', '    * @param _idv Validator address.\n', '    * @return bool\n', '    */\n', '    function exists(address _idv) external view returns (bool);\n', '}\n', '\n', '// File: contracts/ontology/CvcOntologyInterface.sol\n', '\n', '/**\n', ' * @title CvcOntologyInterface\n', ' * @dev This contract defines marketplace ontology registry interface.\n', ' */\n', 'contract CvcOntologyInterface {\n', '\n', '    struct CredentialItem {\n', '        bytes32 id;\n', '        string recordType;\n', '        string recordName;\n', '        string recordVersion;\n', '        string reference;\n', '        string referenceType;\n', '        bytes32 referenceHash;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds new Credential Item to the registry.\n', '     * @param _recordType Credential Item type\n', '     * @param _recordName Credential Item name\n', '     * @param _recordVersion Credential Item version\n', '     * @param _reference Credential Item reference URL\n', '     * @param _referenceType Credential Item reference type\n', '     * @param _referenceHash Credential Item reference hash\n', '     */\n', '    function add(\n', '        string _recordType,\n', '        string _recordName,\n', '        string _recordVersion,\n', '        string _reference,\n', '        string _referenceType,\n', '        bytes32 _referenceHash\n', '        ) external;\n', '\n', '    /**\n', '    * @dev Deprecates single Credential Item by external ID (type, name and version).\n', '    * @param _type Record type to deprecate\n', '    * @param _name Record name to deprecate\n', '    * @param _version Record version to deprecate\n', '    */\n', '    function deprecate(string _type, string _name, string _version) public;\n', '\n', '    /**\n', '    * @dev Deprecates single Credential Item by ID.\n', '    * @param _id Record ID to deprecate\n', '    */\n', '    function deprecateById(bytes32 _id) public;\n', '\n', '    /**\n', '     * @dev Returns single Credential Item data up by ontology record ID.\n', '     * @param _id Ontology record ID to search by\n', '     * @return id Ontology record ID\n', '     * @return recordType Credential Item type\n', '     * @return recordName Credential Item name\n', '     * @return recordVersion Credential Item version\n', '     * @return reference Credential Item reference URL\n', '     * @return referenceType Credential Item reference type\n', '     * @return referenceHash Credential Item reference hash\n', '     * @return deprecated Credential Item type deprecation flag\n', '     */\n', '    function getById(bytes32 _id) public view returns (\n', '        bytes32 id,\n', '        string recordType,\n', '        string recordName,\n', '        string recordVersion,\n', '        string reference,\n', '        string referenceType,\n', '        bytes32 referenceHash,\n', '        bool deprecated\n', '        );\n', '\n', '    /**\n', '     * @dev Returns single Credential Item of specific type, name and version.\n', '     * @param _type Credential Item type\n', '     * @param _name Credential Item name\n', '     * @param _version Credential Item version\n', '     * @return id Ontology record ID\n', '     * @return recordType Credential Item type\n', '     * @return recordName Credential Item name\n', '     * @return recordVersion Credential Item version\n', '     * @return reference Credential Item reference URL\n', '     * @return referenceType Credential Item reference type\n', '     * @return referenceHash Credential Item reference hash\n', '     * @return deprecated Credential Item type deprecation flag\n', '     */\n', '    function getByTypeNameVersion(\n', '        string _type,\n', '        string _name,\n', '        string _version\n', '        ) public view returns (\n', '            bytes32 id,\n', '            string recordType,\n', '            string recordName,\n', '            string recordVersion,\n', '            string reference,\n', '            string referenceType,\n', '            bytes32 referenceHash,\n', '            bool deprecated\n', '        );\n', '\n', '    /**\n', '     * @dev Returns all IDs of registered Credential Items.\n', '     * @return bytes32[]\n', '     */\n', '    function getAllIds() public view returns (bytes32[]);\n', '\n', '    /**\n', '     * @dev Returns all registered Credential Items.\n', '     * @return bytes32[]\n', '     */\n', '    function getAll() public view returns (CredentialItem[]);\n', '}\n', '\n', '// File: contracts/upgradeability/EternalStorage.sol\n', '\n', '/**\n', ' * @title EternalStorage\n', ' * @dev This contract defines the generic storage structure\n', ' * so that it could be re-used to implement any domain specific storage functionality\n', ' */\n', 'contract EternalStorage {\n', '\n', '    mapping(bytes32 => uint256) internal uintStorage;\n', '    mapping(bytes32 => string) internal stringStorage;\n', '    mapping(bytes32 => address) internal addressStorage;\n', '    mapping(bytes32 => bytes) internal bytesStorage;\n', '    mapping(bytes32 => bool) internal boolStorage;\n', '    mapping(bytes32 => int256) internal intStorage;\n', '    mapping(bytes32 => bytes32) internal bytes32Storage;\n', '\n', '}\n', '\n', '// File: contracts/upgradeability/ImplementationStorage.sol\n', '\n', '/**\n', ' * @title ImplementationStorage\n', ' * @dev This contract stores proxy implementation address.\n', ' */\n', 'contract ImplementationStorage {\n', '\n', '    /**\n', '     * @dev Storage slot with the address of the current implementation.\n', '     * This is the keccak-256 hash of "cvc.proxy.implementation", and is validated in the constructor.\n', '     */\n', '    bytes32 internal constant IMPLEMENTATION_SLOT = 0xa490aab0d89837371982f93f57ffd20c47991f88066ef92475bc8233036969bb;\n', '\n', '    /**\n', '    * @dev Constructor\n', '    */\n', '    constructor() public {\n', '        assert(IMPLEMENTATION_SLOT == keccak256("cvc.proxy.implementation"));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current implementation.\n', '     * @return Address of the current implementation\n', '     */\n', '    function implementation() public view returns (address impl) {\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            impl := sload(slot)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/upgradeability/Initializable.sol\n', '\n', '/**\n', ' * @title Initializable\n', ' * @dev This contract provides basic initialization control\n', ' */\n', 'contract Initializable is EternalStorage, ImplementationStorage {\n', '\n', '    /**\n', '    Data structures and storage layout:\n', '    mapping(bytes32 => bool) initialized;\n', '    **/\n', '\n', '    /**\n', '     * @dev Throws if called before contract was initialized.\n', '     */\n', '    modifier onlyInitialized() {\n', '        // require(initialized[implementation()]);\n', '        require(boolStorage[keccak256(abi.encodePacked(implementation(), "initialized"))], "Contract is not initialized");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Controls the initialization state, allowing to call an initialization function only once.\n', '     */\n', '    modifier initializes() {\n', '        address impl = implementation();\n', '        // require(!initialized[implementation()]);\n', '        require(!boolStorage[keccak256(abi.encodePacked(impl, "initialized"))], "Contract is already initialized");\n', '        _;\n', '        // initialized[implementation()] = true;\n', '        boolStorage[keccak256(abi.encodePacked(impl, "initialized"))] = true;\n', '    }\n', '}\n', '\n', '// File: contracts/upgradeability/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev This contract has an owner address providing basic authorization control\n', ' */\n', 'contract Ownable is EternalStorage {\n', '\n', '    /**\n', '    Data structures and storage layout:\n', '    address owner;\n', '    **/\n', '\n', '    /**\n', '     * @dev Event to show ownership has been transferred\n', '     * @param previousOwner representing the address of the previous owner\n', '     * @param newOwner representing the address of the new owner\n', '     */\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner(), "Message sender must be contract admin");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Tells the address of the owner\n', '     * @return the address of the owner\n', '     */\n', '    function owner() public view returns (address) {\n', '        // return owner;\n', '        return addressStorage[keccak256("owner")];\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner the address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "Contract owner cannot be zero address");\n', '        setOwner(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets a new owner address\n', '     */\n', '    function setOwner(address newOwner) internal {\n', '        emit OwnershipTransferred(owner(), newOwner);\n', '        // owner = newOwner;\n', '        addressStorage[keccak256("owner")] = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/upgradeability/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable, ImplementationStorage {\n', '\n', '    /**\n', '    Data structures and storage layout:\n', '    mapping(bytes32 => bool) paused;\n', '    **/\n', '\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused(), "Contract is paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused(), "Contract must be paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() public onlyOwner whenNotPaused {\n', '        // paused[implementation()] = true;\n', '        boolStorage[keccak256(abi.encodePacked(implementation(), "paused"))] = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() public onlyOwner whenPaused {\n', '        // paused[implementation()] = false;\n', '        boolStorage[keccak256(abi.encodePacked(implementation(), "paused"))] = false;\n', '        emit Unpause();\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true when the contract is paused.\n', '     * @return bool\n', '     */\n', '    function paused() public view returns (bool) {\n', '        // return paused[implementation()];\n', '        return boolStorage[keccak256(abi.encodePacked(implementation(), "paused"))];\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/pricing/CvcPricing.sol\n', '\n', '/**\n', ' * @title CvcPricing\n', ' * @dev This contract stores actual prices for Credential Items available for sale.\n', ' * It allows registered Identity Validators to set or delete prices for specific Credential Items.\n', ' *\n', ' * The pricing contract depends on other marketplace contracts, such as:\n', ' * CvcOntology - to verify that Credential Item is available on the market and can be offered for sale.\n', ' * CvcValidatorRegistry - to ensure that only registered Identity Validators can use pricing services.\n', ' *                          Transactions from unknown accounts will be rejected.\n', ' */\n', 'contract CvcPricing is EternalStorage, Initializable, Pausable, CvcPricingInterface {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '    Data structures and storage layout:\n', '    struct Price {\n', '        uint256 value;\n', '        bytes32 credentialItemId;\n', '        address idv;\n', '    }\n', '\n', '    address cvcOntology;\n', '    address idvRegistry;\n', '    uint256 pricesCount;\n', '    bytes32[] pricesIds;\n', '    mapping(bytes32 => uint256) pricesIndices;\n', '    mapping(bytes32 => Price) prices;\n', '    **/\n', '\n', '\n', '    /// Total supply of CVC tokens.\n', '    uint256 constant private CVC_TOTAL_SUPPLY = 1e17;\n', '\n', '    /// The fallback price introduced to be returned when credential price is undefined.\n', '    /// The number is greater than CVC total supply, so it makes it impossible to transact with (e.g. place to escrow).\n', '    uint256 constant private FALLBACK_PRICE = CVC_TOTAL_SUPPLY + 1; // solium-disable-line zeppelin/no-arithmetic-operations\n', '\n', '    /// As zero price and undefined price are virtually indistinguishable,\n', '    /// a special value is introduced to represent zero price.\n', '    /// It equals to max unsigned integer which makes it impossible to transact with, hence should never be returned.\n', '    uint256 constant private ZERO_PRICE = ~uint256(0);\n', '\n', '    /**\n', '    * @dev Constructor\n', '    * @param _ontology CvcOntology contract address.\n', '    * @param _idvRegistry CvcValidatorRegistry contract address.\n', '    */\n', '    constructor(address _ontology, address _idvRegistry) public {\n', '        initialize(_ontology, _idvRegistry, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by unregistered IDV.\n', '     */\n', '    modifier onlyRegisteredValidator() {\n', '        require(idvRegistry().exists(msg.sender), "Identity Validator is not registered");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Sets the price for Credential Item of specific type, name and version.\n', '    * The price is associated with IDV address (sender).\n', '    * @param _credentialItemType Credential Item type.\n', '    * @param _credentialItemName Credential Item name.\n', '    * @param _credentialItemVersion Credential Item version.\n', '    * @param _price Credential Item price.\n', '    */\n', '    function setPrice(\n', '        string _credentialItemType,\n', '        string _credentialItemName,\n', '        string _credentialItemVersion,\n', '        uint256 _price\n', '    )\n', '        external\n', '        onlyRegisteredValidator\n', '        whenNotPaused\n', '    {\n', '        // Check price value upper bound.\n', '        require(_price <= CVC_TOTAL_SUPPLY, "Price value cannot be more than token total supply");\n', '\n', '        // Check Credential Item ID to verify existence.\n', '        bytes32 credentialItemId;\n', '        bool deprecated;\n', '        (credentialItemId, , , , , , , deprecated) = ontology().getByTypeNameVersion(\n', '            _credentialItemType,\n', '            _credentialItemName,\n', '            _credentialItemVersion\n', '        );\n', '        // Prevent setting price for unknown credential items.\n', '        require(credentialItemId != 0x0, "Cannot set price for unknown credential item");\n', '        require(deprecated == false, "Cannot set price for deprecated credential item");\n', '\n', '        // Calculate price ID.\n', '        bytes32 id = calculateId(msg.sender, credentialItemId);\n', '\n', '        // Register new record (when price record has no associated Credential Item ID).\n', '        if (getPriceCredentialItemId(id) == 0x0) {\n', '            registerNewRecord(id);\n', '        }\n', '\n', '        // Save the price.\n', '        setPriceIdv(id, msg.sender);\n', '        setPriceCredentialItemId(id, credentialItemId);\n', '        setPriceValue(id, _price);\n', '\n', '        emit CredentialItemPriceSet(\n', '            id,\n', '            _price,\n', '            msg.sender,\n', '            _credentialItemType,\n', '            _credentialItemName,\n', '            _credentialItemVersion,\n', '            credentialItemId\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Deletes the price for Credential Item of specific type, name and version.\n', '    * @param _credentialItemType Credential Item type.\n', '    * @param _credentialItemName Credential Item name.\n', '    * @param _credentialItemVersion Credential Item version.\n', '    */\n', '    function deletePrice(\n', '        string _credentialItemType,\n', '        string _credentialItemName,\n', '        string _credentialItemVersion\n', '    )\n', '        external\n', '        whenNotPaused\n', '    {\n', '        // Lookup Credential Item.\n', '        bytes32 credentialItemId;\n', '        (credentialItemId, , , , , , ,) = ontology().getByTypeNameVersion(\n', '            _credentialItemType,\n', '            _credentialItemName,\n', '            _credentialItemVersion\n', '        );\n', '\n', '        // Calculate Price ID to address individual data items.\n', '        bytes32 id = calculateId(msg.sender, credentialItemId);\n', '\n', '        // Ensure the price existence. Check whether Credential Item is associated.\n', '        credentialItemId = getPriceCredentialItemId(id);\n', '        require(credentialItemId != 0x0, "Cannot delete unknown price record");\n', '\n', '        // Delete the price data.\n', '        deletePriceIdv(id);\n', '        deletePriceCredentialItemId(id);\n', '        deletePriceValue(id);\n', '\n', '        unregisterRecord(id);\n', '\n', '        emit CredentialItemPriceDeleted(\n', '            id,\n', '            msg.sender,\n', '            _credentialItemType,\n', '            _credentialItemName,\n', '            _credentialItemVersion,\n', '            credentialItemId\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the price set by IDV for Credential Item of specific type, name and version.\n', '    * @param _idv IDV address.\n', '    * @param _credentialItemType Credential Item type.\n', '    * @param _credentialItemName Credential Item name.\n', '    * @param _credentialItemVersion Credential Item version.\n', '    * @return bytes32 Price ID.\n', '    * @return uint256 Price value.\n', '    * @return address IDV address.\n', '    * @return string Credential Item type.\n', '    * @return string Credential Item name.\n', '    * @return string Credential Item version.\n', '    */\n', '    function getPrice(\n', '        address _idv,\n', '        string _credentialItemType,\n', '        string _credentialItemName,\n', '        string _credentialItemVersion\n', '    )\n', '        external\n', '        view\n', '        onlyInitialized\n', '        returns (\n', '            bytes32 id,\n', '            uint256 price,\n', '            address idv,\n', '            string credentialItemType,\n', '            string credentialItemName,\n', '            string credentialItemVersion,\n', '            bool deprecated\n', '        )\n', '    {\n', '        // Lookup Credential Item.\n', '        bytes32 credentialItemId;\n', '        (credentialItemId, credentialItemType, credentialItemName, credentialItemVersion, , , , deprecated) = ontology().getByTypeNameVersion(\n', '            _credentialItemType,\n', '            _credentialItemName,\n', '            _credentialItemVersion\n', '        );\n', '        idv = _idv;\n', '        id = calculateId(idv, credentialItemId);\n', '        price = getPriceValue(id);\n', '        if (price == FALLBACK_PRICE) {\n', '            return (0x0, price, 0x0, "", "", "", false);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the price by Credential Item ID.\n', '    * @param _idv IDV address.\n', '    * @param _credentialItemId Credential Item ID.\n', '    * @return bytes32 Price ID.\n', '    * @return uint256 Price value.\n', '    * @return address IDV address.\n', '    * @return string Credential Item type.\n', '    * @return string Credential Item name.\n', '    * @return string Credential Item version.\n', '    */\n', '    function getPriceByCredentialItemId(address _idv, bytes32 _credentialItemId) external view returns (\n', '        bytes32 id,\n', '        uint256 price,\n', '        address idv,\n', '        string credentialItemType,\n', '        string credentialItemName,\n', '        string credentialItemVersion,\n', '        bool deprecated\n', '    ) {\n', '        return getPriceById(calculateId(_idv, _credentialItemId));\n', '    }\n', '\n', '    /**\n', '    * @dev Returns all Credential Item prices.\n', '    * @return CredentialItemPrice[]\n', '    */\n', '    function getAllPrices() external view onlyInitialized returns (CredentialItemPrice[]) {\n', '        uint256 count = getCount();\n', '        CredentialItemPrice[] memory prices = new CredentialItemPrice[](count);\n', '        for (uint256 i = 0; i < count; i++) {\n', '            bytes32 id = getRecordId(i);\n', '            bytes32 credentialItemId = getPriceCredentialItemId(id);\n', '            string memory credentialItemType;\n', '            string memory credentialItemName;\n', '            string memory credentialItemVersion;\n', '            bool deprecated;\n', '\n', '            (, credentialItemType, credentialItemName, credentialItemVersion, , , , deprecated) = ontology().getById(credentialItemId);\n', '\n', '            prices[i] = CredentialItemPrice(\n', '                id,\n', '                getPriceValue(id),\n', '                getPriceIdv(id),\n', '                credentialItemType,\n', '                credentialItemName,\n', '                credentialItemVersion,\n', '                deprecated\n', '            );\n', '        }\n', '\n', '        return prices;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns all IDs of registered Credential Item prices.\n', '     * @return bytes32[]\n', '     */\n', '    function getAllIds() external view onlyInitialized returns(bytes32[]) {\n', '        uint256 count = getCount();\n', '        bytes32[] memory ids = new bytes32[](count);\n', '        for (uint256 i = 0; i < count; i++) {\n', '            ids[i] = getRecordId(i);\n', '        }\n', '\n', '        return ids;\n', '    }\n', '\n', '    /**\n', '    * @dev Contract initialization method.\n', '    * @param _ontology CvcOntology contract address.\n', '    * @param _idvRegistry CvcValidatorRegistry contract address.\n', '    * @param _owner Owner address\n', '    */\n', '    function initialize(address _ontology, address _idvRegistry, address _owner) public initializes {\n', '        require(AddressUtils.isContract(_ontology), "Initialization error: no contract code at ontology contract address");\n', '        require(AddressUtils.isContract(_idvRegistry), "Initialization error: no contract code at IDV registry contract address");\n', '        // cvcOntology = _ontology;\n', '        addressStorage[keccak256("cvc.ontology")] = _ontology;\n', '        // idvRegistry = _idvRegistry;\n', '        addressStorage[keccak256("cvc.idv.registry")] = _idvRegistry;\n', '        // Initialize current implementation owner address.\n', '        setOwner(_owner);\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the price by ID.\n', '    * @param _id Price ID\n', '    * @return bytes32 Price ID.\n', '    * @return uint256 Price value.\n', '    * @return address IDV address.\n', '    * @return string Credential Item type.\n', '    * @return string Credential Item name.\n', '    * @return string Credential Item version.\n', '    */\n', '    function getPriceById(bytes32 _id) public view onlyInitialized returns (\n', '        bytes32 id,\n', '        uint256 price,\n', '        address idv,\n', '        string credentialItemType,\n', '        string credentialItemName,\n', '        string credentialItemVersion,\n', '        bool deprecated\n', '    ) {\n', '        // Always return price (could be a fallback price when not set).\n', '        price = getPriceValue(_id);\n', '        // Check whether Credential Item is associated. This is mandatory requirement for all existing prices.\n', '        bytes32 credentialItemId = getPriceCredentialItemId(_id);\n', '        if (credentialItemId != 0x0) {\n', '            // Return ID and IDV address for existing entry only.\n', '            id = _id;\n', '            idv = getPriceIdv(_id);\n', '\n', '            (, credentialItemType, credentialItemName, credentialItemVersion, , , , deprecated) = ontology().getById(credentialItemId);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Returns instance of CvcOntologyInterface.\n', '    * @return CvcOntologyInterface\n', '    */\n', '    function ontology() public view returns (CvcOntologyInterface) {\n', '        // return CvcOntologyInterface(cvcOntology);\n', '        return CvcOntologyInterface(addressStorage[keccak256("cvc.ontology")]);\n', '    }\n', '\n', '    /**\n', '    * @dev Returns instance of CvcValidatorRegistryInterface.\n', '    * @return CvcValidatorRegistryInterface\n', '    */\n', '    function idvRegistry() public view returns (CvcValidatorRegistryInterface) {\n', '        // return CvcValidatorRegistryInterface(idvRegistry);\n', '        return CvcValidatorRegistryInterface(addressStorage[keccak256("cvc.idv.registry")]);\n', '    }\n', '\n', '    /**\n', '    * @dev Returns price record count.\n', '    * @return uint256\n', '    */\n', '    function getCount() internal view returns (uint256) {\n', '        // return pricesCount;\n', '        return uintStorage[keccak256("prices.count")];\n', '    }\n', '\n', '    /**\n', '    * @dev Increments price record counter.\n', '    */\n', '    function incrementCount() internal {\n', '        // pricesCount = getCount().add(1);\n', '        uintStorage[keccak256("prices.count")] = getCount().add(1);\n', '    }\n', '\n', '    /**\n', '    * @dev Decrements price record counter.\n', '    */\n', '    function decrementCount() internal {\n', '        // pricesCount = getCount().sub(1);\n', '        uintStorage[keccak256("prices.count")] = getCount().sub(1);\n', '    }\n', '\n', '    /**\n', '    * @dev Returns price ID by index.\n', '    * @param _index Price record index.\n', '    * @return bytes32\n', '    */\n', '    function getRecordId(uint256 _index) internal view returns (bytes32) {\n', '        // return pricesIds[_index];\n', '        return bytes32Storage[keccak256(abi.encodePacked("prices.ids.", _index))];\n', '    }\n', '\n', '    /**\n', '    * @dev Index new price record.\n', '    * @param _id The price ID.\n', '    */\n', '    function registerNewRecord(bytes32 _id) internal {\n', '        bytes32 indexSlot = keccak256(abi.encodePacked("prices.indices.", _id));\n', '        // Prevent from registering same ID twice.\n', '        // require(pricesIndices[_id] == 0);\n', '        require(uintStorage[indexSlot] == 0, "Integrity error: price with the same ID is already registered");\n', '\n', '        uint256 index = getCount();\n', '        // Store record ID against index.\n', '        // pricesIds[index] = _id;\n', '        bytes32Storage[keccak256(abi.encodePacked("prices.ids.", index))] = _id;\n', '        // Maintain reversed index to ID mapping to ensure O(1) deletion.\n', '        // Store n+1 value and reserve zero value for not indexed records.\n', '        uintStorage[indexSlot] = index.add(1);\n', '        incrementCount();\n', '    }\n', '\n', '    /**\n', '    * @dev Deletes price record from index.\n', '    * @param _id The price ID.\n', '    */\n', '    function unregisterRecord(bytes32 _id) internal {\n', '        // Since the order of price records is not guaranteed, we can make deletion more efficient\n', '        // by replacing record we want to delete with the last record, hence avoid reindex.\n', '\n', '        // Calculate deletion record ID slot.\n', '        bytes32 deletionIndexSlot = keccak256(abi.encodePacked("prices.indices.", _id));\n', '        // uint256 deletionIndex = pricesIndices[_id].sub(1);\n', '        uint256 deletionIndex = uintStorage[deletionIndexSlot].sub(1);\n', '        bytes32 deletionIdSlot = keccak256(abi.encodePacked("prices.ids.", deletionIndex));\n', '\n', '        // Calculate last record ID slot.\n', '        uint256 lastIndex = getCount().sub(1);\n', '        bytes32 lastIdSlot = keccak256(abi.encodePacked("prices.ids.", lastIndex));\n', '\n', '        // Calculate last record index slot.\n', '        bytes32 lastIndexSlot = keccak256(abi.encodePacked("prices.indices.", bytes32Storage[lastIdSlot]));\n', '\n', '        // Copy last record ID into the empty slot.\n', '        // pricesIds[deletionIdSlot] = pricesIds[lastIdSlot];\n', '        bytes32Storage[deletionIdSlot] = bytes32Storage[lastIdSlot];\n', '        // Make moved ID index point to the the correct record.\n', '        // pricesIndices[lastIndexSlot] = pricesIndices[deletionIndexSlot];\n', '        uintStorage[lastIndexSlot] = uintStorage[deletionIndexSlot];\n', '        // Delete last record ID.\n', '        // delete pricesIds[lastIndex];\n', '        delete bytes32Storage[lastIdSlot];\n', '        // Delete reversed index.\n', '        // delete pricesIndices[_id];\n', '        delete uintStorage[deletionIndexSlot];\n', '        decrementCount();\n', '    }\n', '    /**\n', '    * @dev Returns price value.\n', '    * @param _id The price ID.\n', '    * @return uint256\n', '    */\n', '    function getPriceValue(bytes32 _id) internal view returns (uint256) {\n', '        // uint256 value = prices[_id].value;\n', '        uint256 value = uintStorage[keccak256(abi.encodePacked("prices.", _id, ".value"))];\n', '        // Return fallback price if price is not set for existing Credential Item.\n', '        // Since we use special (non-zero) value for zero price, actual &#39;0&#39; means the price was never set.\n', '        if (value == 0) {\n', '            return FALLBACK_PRICE;\n', '        }\n', '        // Convert from special zero representation value.\n', '        if (value == ZERO_PRICE) {\n', '            return 0;\n', '        }\n', '\n', '        return value;\n', '    }\n', '\n', '    /**\n', '    * @dev Saves price value.\n', '    * @param _id The price ID.\n', '    * @param _value The price value.\n', '    */\n', '    function setPriceValue(bytes32 _id, uint256 _value) internal {\n', '        // Save the price (convert to special zero representation value if necessary).\n', '        // prices[_id].value = (_value == 0) ? ZERO_PRICE : _value;\n', '        uintStorage[keccak256(abi.encodePacked("prices.", _id, ".value"))] = (_value == 0) ? ZERO_PRICE : _value;\n', '    }\n', '\n', '    /**\n', '    * @dev Deletes price value.\n', '    * @param _id The price ID.\n', '    */\n', '    function deletePriceValue(bytes32 _id) internal {\n', '        // delete prices[_id].value;\n', '        delete uintStorage[keccak256(abi.encodePacked("prices.", _id, ".value"))];\n', '    }\n', '\n', '    /**\n', '    * @dev Returns Credential Item ID the price is set for.\n', '    * @param _id The price ID.\n', '    * @return bytes32\n', '    */\n', '    function getPriceCredentialItemId(bytes32 _id) internal view returns (bytes32) {\n', '        // return prices[_id].credentialItemId;\n', '        return bytes32Storage[keccak256(abi.encodePacked("prices.", _id, ".credentialItemId"))];\n', '    }\n', '\n', '    /**\n', '    * @dev Saves price Credential Item ID\n', '    * @param _id The price ID.\n', '    * @param _credentialItemId Associated Credential Item ID.\n', '    */\n', '    function setPriceCredentialItemId(bytes32 _id, bytes32 _credentialItemId) internal {\n', '        // prices[_id].credentialItemId = _credentialItemId;\n', '        bytes32Storage[keccak256(abi.encodePacked("prices.", _id, ".credentialItemId"))] = _credentialItemId;\n', '    }\n', '\n', '    /**\n', '    * @dev Deletes price Credential Item ID.\n', '    * @param _id The price ID.\n', '    */\n', '    function deletePriceCredentialItemId(bytes32 _id) internal {\n', '        // delete prices[_id].credentialItemId;\n', '        delete bytes32Storage[keccak256(abi.encodePacked("prices.", _id, ".credentialItemId"))];\n', '    }\n', '\n', '    /**\n', '    * @dev Returns price IDV address.\n', '    * @param _id The price ID.\n', '    * @return address\n', '    */\n', '    function getPriceIdv(bytes32 _id) internal view returns (address) {\n', '        // return prices[_id].idv;\n', '        return addressStorage[keccak256(abi.encodePacked("prices.", _id, ".idv"))];\n', '    }\n', '\n', '    /**\n', '    * @dev Saves price IDV address.\n', '    * @param _id The price ID.\n', '    * @param _idv IDV address.\n', '    */\n', '    function setPriceIdv(bytes32 _id, address _idv) internal {\n', '        // prices[_id].idv = _idv;\n', '        addressStorage[keccak256(abi.encodePacked("prices.", _id, ".idv"))] = _idv;\n', '    }\n', '\n', '    /**\n', '    * @dev Deletes price IDV address.\n', '    * @param _id The price ID.\n', '    */\n', '    function deletePriceIdv(bytes32 _id) internal {\n', '        // delete prices[_id].idv;\n', '        delete addressStorage[keccak256(abi.encodePacked("prices.", _id, ".idv"))];\n', '    }\n', '\n', '    /**\n', '    * @dev Calculates price ID.\n', '    * @param _idv IDV address.\n', '    * @param _credentialItemId Credential Item ID.\n', '    * @return bytes32\n', '    */\n', '    function calculateId(address _idv, bytes32 _credentialItemId) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked(_idv, ".", _credentialItemId));\n', '    }\n', '}']