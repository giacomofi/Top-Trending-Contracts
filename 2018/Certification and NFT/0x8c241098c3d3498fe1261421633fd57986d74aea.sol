['//  conditional star release\n', '//  https://azimuth.network\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '//  Imports\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '// OpenZeppelin&#39;s Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// Azimuth&#39;s SafeMath8.sol\n', '\n', '/**\n', ' * @title SafeMath8\n', ' * @dev Math operations for uint8 with safety checks that throw on error\n', ' */\n', 'library SafeMath8 {\n', '  function mul(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    uint8 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint8 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    uint8 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// Azimuth&#39;s SafeMath16.sol\n', '\n', '/**\n', ' * @title SafeMath16\n', ' * @dev Math operations for uint16 with safety checks that throw on error\n', ' */\n', 'library SafeMath16 {\n', '  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint16 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// OpenZeppelin&#39;s SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// OpenZeppelin&#39;s ERC165.sol\n', '\n', '/**\n', ' * @title ERC165\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'interface ERC165 {\n', '\n', '  /**\n', '   * @notice Query if a contract implements an interface\n', '   * @param _interfaceId The interface identifier, as specified in ERC-165\n', '   * @dev Interface identification is specified in ERC-165. This function\n', '   * uses less than 30,000 gas.\n', '   */\n', '  function supportsInterface(bytes4 _interfaceId)\n', '    external\n', '    view\n', '    returns (bool);\n', '}\n', '\n', '// OpenZeppelin&#39;s SupportsInterfaceWithLookup.sol\n', '\n', '/**\n', ' * @title SupportsInterfaceWithLookup\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Implements ERC165 using a lookup table.\n', ' */\n', 'contract SupportsInterfaceWithLookup is ERC165 {\n', '\n', '  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\n', '  /**\n', '   * 0x01ffc9a7 ===\n', '   *   bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;))\n', '   */\n', '\n', '  /**\n', '   * @dev a mapping of interface id to whether or not it&#39;s supported\n', '   */\n', '  mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '  /**\n', '   * @dev A contract implementing SupportsInterfaceWithLookup\n', '   * implement ERC165 itself\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    _registerInterface(InterfaceId_ERC165);\n', '  }\n', '\n', '  /**\n', '   * @dev implement supportsInterface(bytes4) using a lookup table\n', '   */\n', '  function supportsInterface(bytes4 _interfaceId)\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    return supportedInterfaces[_interfaceId];\n', '  }\n', '\n', '  /**\n', '   * @dev private method for registering an interface\n', '   */\n', '  function _registerInterface(bytes4 _interfaceId)\n', '    internal\n', '  {\n', '    require(_interfaceId != 0xffffffff);\n', '    supportedInterfaces[_interfaceId] = true;\n', '  }\n', '}\n', '\n', '// OpenZeppelin&#39;s ERC721Basic.sol\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Basic is ERC165 {\n', '\n', '  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\n', '  /*\n', '   * 0x80ac58cd ===\n', '   *   bytes4(keccak256(&#39;balanceOf(address)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;approve(address,uint256)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;getApproved(uint256)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;setApprovalForAll(address,bool)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;isApprovedForAll(address,address)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;transferFrom(address,address,uint256)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;safeTransferFrom(address,address,uint256)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;safeTransferFrom(address,address,uint256,bytes)&#39;))\n', '   */\n', '\n', '  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\n', '  /*\n', '   * 0x4f558e79 ===\n', '   *   bytes4(keccak256(&#39;exists(uint256)&#39;))\n', '   */\n', '\n', '  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\n', '  /**\n', '   * 0x780e9d63 ===\n', '   *   bytes4(keccak256(&#39;totalSupply()&#39;)) ^\n', '   *   bytes4(keccak256(&#39;tokenOfOwnerByIndex(address,uint256)&#39;)) ^\n', '   *   bytes4(keccak256(&#39;tokenByIndex(uint256)&#39;))\n', '   */\n', '\n', '  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n', '  /**\n', '   * 0x5b5e139f ===\n', '   *   bytes4(keccak256(&#39;name()&#39;)) ^\n', '   *   bytes4(keccak256(&#39;symbol()&#39;)) ^\n', '   *   bytes4(keccak256(&#39;tokenURI(uint256)&#39;))\n', '   */\n', '\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 indexed _tokenId\n', '  );\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _approved,\n', '    uint256 indexed _tokenId\n', '  );\n', '  event ApprovalForAll(\n', '    address indexed _owner,\n', '    address indexed _operator,\n', '    bool _approved\n', '  );\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId)\n', '    public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator)\n', '    public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n', '    public;\n', '\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public;\n', '}\n', '\n', '// OpenZeppelin&#39;s ERC721.sol\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Enumerable is ERC721Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function tokenOfOwnerByIndex(\n', '    address _owner,\n', '    uint256 _index\n', '  )\n', '    public\n', '    view\n', '    returns (uint256 _tokenId);\n', '\n', '  function tokenByIndex(uint256 _index) public view returns (uint256);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Metadata is ERC721Basic {\n', '  function name() external view returns (string _name);\n', '  function symbol() external view returns (string _symbol);\n', '  function tokenURI(uint256 _tokenId) public view returns (string);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n', '}\n', '\n', '// OpenZeppelin&#39;s ERC721Receiver.sol\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver {\n', '  /**\n', '   * @dev Magic value to be returned upon successful reception of an NFT\n', '   *  Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`,\n', '   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '   */\n', '  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\n', '\n', '  /**\n', '   * @notice Handle the receipt of an NFT\n', '   * @dev The ERC721 smart contract calls this function on the recipient\n', '   * after a `safetransfer`. This function MAY throw to revert and reject the\n', '   * transfer. Return of other than the magic value MUST result in the\n', '   * transaction being reverted.\n', '   * Note: the contract address is always the message sender.\n', '   * @param _operator The address which called `safeTransferFrom` function\n', '   * @param _from The address which previously owned the token\n', '   * @param _tokenId The NFT identifier which is being transferred\n', '   * @param _data Additional data with no specified format\n', '   * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '   */\n', '  function onERC721Received(\n', '    address _operator,\n', '    address _from,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public\n', '    returns(bytes4);\n', '}\n', '\n', '// OpenZeppelin&#39;s AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   * as the code is not actually created until after the constructor finishes.\n', '   * @param _addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address _addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(_addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// Azimuth&#39;s Azimuth.sol\n', '\n', '//  Azimuth: point state data contract\n', '//\n', '//    This contract is used for storing all data related to Azimuth points\n', '//    and their ownership. Consider this contract the Azimuth ledger.\n', '//\n', '//    It also contains permissions data, which ties in to ERC721\n', '//    functionality. Operators of an address are allowed to transfer\n', '//    ownership of all points owned by their associated address\n', '//    (ERC721&#39;s approveAll()). A transfer proxy is allowed to transfer\n', '//    ownership of a single point (ERC721&#39;s approve()).\n', '//    Separate from ERC721 are managers, assigned per point. They are\n', '//    allowed to perform "low-impact" operations on the owner&#39;s points,\n', '//    like configuring public keys and making escape requests.\n', '//\n', '//    Since data stores are difficult to upgrade, this contract contains\n', '//    as little actual business logic as possible. Instead, the data stored\n', '//    herein can only be modified by this contract&#39;s owner, which can be\n', '//    changed and is thus upgradable/replaceable.\n', '//\n', '//    This contract will be owned by the Ecliptic contract.\n', '//\n', 'contract Azimuth is Ownable\n', '{\n', '//\n', '//  Events\n', '//\n', '\n', '  //  OwnerChanged: :point is now owned by :owner\n', '  //\n', '  event OwnerChanged(uint32 indexed point, address indexed owner);\n', '\n', '  //  Activated: :point is now active\n', '  //\n', '  event Activated(uint32 indexed point);\n', '\n', '  //  Spawned: :prefix has spawned :child\n', '  //\n', '  event Spawned(uint32 indexed prefix, uint32 indexed child);\n', '\n', '  //  EscapeRequested: :point has requested a new :sponsor\n', '  //\n', '  event EscapeRequested(uint32 indexed point, uint32 indexed sponsor);\n', '\n', '  //  EscapeCanceled: :point&#39;s :sponsor request was canceled or rejected\n', '  //\n', '  event EscapeCanceled(uint32 indexed point, uint32 indexed sponsor);\n', '\n', '  //  EscapeAccepted: :point confirmed with a new :sponsor\n', '  //\n', '  event EscapeAccepted(uint32 indexed point, uint32 indexed sponsor);\n', '\n', '  //  LostSponsor: :point&#39;s :sponsor is now refusing it service\n', '  //\n', '  event LostSponsor(uint32 indexed point, uint32 indexed sponsor);\n', '\n', '  //  ChangedKeys: :point has new network public keys\n', '  //\n', '  event ChangedKeys( uint32 indexed point,\n', '                     bytes32 encryptionKey,\n', '                     bytes32 authenticationKey,\n', '                     uint32 cryptoSuiteVersion,\n', '                     uint32 keyRevisionNumber );\n', '\n', '  //  BrokeContinuity: :point has a new continuity number, :number\n', '  //\n', '  event BrokeContinuity(uint32 indexed point, uint32 number);\n', '\n', '  //  ChangedSpawnProxy: :spawnProxy can now spawn using :point\n', '  //\n', '  event ChangedSpawnProxy(uint32 indexed point, address indexed spawnProxy);\n', '\n', '  //  ChangedTransferProxy: :transferProxy can now transfer ownership of :point\n', '  //\n', '  event ChangedTransferProxy( uint32 indexed point,\n', '                              address indexed transferProxy );\n', '\n', '  //  ChangedManagementProxy: :managementProxy can now manage :point\n', '  //\n', '  event ChangedManagementProxy( uint32 indexed point,\n', '                                address indexed managementProxy );\n', '\n', '  //  ChangedVotingProxy: :votingProxy can now vote using :point\n', '  //\n', '  event ChangedVotingProxy(uint32 indexed point, address indexed votingProxy);\n', '\n', '  //  ChangedDns: dnsDomains have been updated\n', '  //\n', '  event ChangedDns(string primary, string secondary, string tertiary);\n', '\n', '//\n', '//  Structures\n', '//\n', '\n', '  //  Size: kinds of points registered on-chain\n', '  //\n', '  //    NOTE: the order matters, because of Solidity enum numbering\n', '  //\n', '  enum Size\n', '  {\n', '    Galaxy, // = 0\n', '    Star,   // = 1\n', '    Planet  // = 2\n', '  }\n', '\n', '  //  Point: state of a point\n', '  //\n', '  //    While the ordering of the struct members is semantically chaotic,\n', '  //    they are ordered to tightly pack them into Ethereum&#39;s 32-byte storage\n', '  //    slots, which reduces gas costs for some function calls.\n', '  //    The comment ticks indicate assumed slot boundaries.\n', '  //\n', '  struct Point\n', '  {\n', '    //  encryptionKey: (curve25519) encryption public key, or 0 for none\n', '    //\n', '    bytes32 encryptionKey;\n', '  //\n', '    //  authenticationKey: (ed25519) authentication public key, or 0 for none\n', '    //\n', '    bytes32 authenticationKey;\n', '  //\n', '    //  spawned: for stars and galaxies, all :active children\n', '    //\n', '    uint32[] spawned;\n', '  //\n', '    //  hasSponsor: true if the sponsor still supports the point\n', '    //\n', '    bool hasSponsor;\n', '\n', '    //  active: whether point can be linked\n', '    //\n', '    //    false: point belongs to prefix, cannot be configured or linked\n', '    //    true: point no longer belongs to prefix, can be configured and linked\n', '    //\n', '    bool active;\n', '\n', '    //  escapeRequested: true if the point has requested to change sponsors\n', '    //\n', '    bool escapeRequested;\n', '\n', '    //  sponsor: the point that supports this one on the network, or,\n', '    //           if :hasSponsor is false, the last point that supported it.\n', '    //           (by default, the point&#39;s half-width prefix)\n', '    //\n', '    uint32 sponsor;\n', '\n', '    //  escapeRequestedTo: if :escapeRequested is true, new sponsor requested\n', '    //\n', '    uint32 escapeRequestedTo;\n', '\n', '    //  cryptoSuiteVersion: version of the crypto suite used for the pubkeys\n', '    //\n', '    uint32 cryptoSuiteVersion;\n', '\n', '    //  keyRevisionNumber: incremented every time the public keys change\n', '    //\n', '    uint32 keyRevisionNumber;\n', '\n', '    //  continuityNumber: incremented to indicate network-side state loss\n', '    //\n', '    uint32 continuityNumber;\n', '  }\n', '\n', '  //  Deed: permissions for a point\n', '  //\n', '  struct Deed\n', '  {\n', '    //  owner: address that owns this point\n', '    //\n', '    address owner;\n', '\n', '    //  managementProxy: 0, or another address with the right to perform\n', '    //                   low-impact, managerial operations on this point\n', '    //\n', '    address managementProxy;\n', '\n', '    //  spawnProxy: 0, or another address with the right to spawn children\n', '    //              of this point\n', '    //\n', '    address spawnProxy;\n', '\n', '    //  votingProxy: 0, or another address with the right to vote as this point\n', '    //\n', '    address votingProxy;\n', '\n', '    //  transferProxy: 0, or another address with the right to transfer\n', '    //                 ownership of this point\n', '    //\n', '    address transferProxy;\n', '  }\n', '\n', '//\n', '//  General state\n', '//\n', '\n', '  //  points: per point, general network-relevant point state\n', '  //\n', '  mapping(uint32 => Point) public points;\n', '\n', '  //  rights: per point, on-chain ownership and permissions\n', '  //\n', '  mapping(uint32 => Deed) public rights;\n', '\n', '  //  operators: per owner, per address, has the right to transfer ownership\n', '  //             of all the owner&#39;s points (ERC721)\n', '  //\n', '  mapping(address => mapping(address => bool)) public operators;\n', '\n', '  //  dnsDomains: base domains for contacting galaxies\n', '  //\n', '  //    dnsDomains[0] is primary, the others are used as fallbacks\n', '  //\n', '  string[3] public dnsDomains;\n', '\n', '//\n', '//  Lookups\n', '//\n', '\n', '  //  sponsoring: per point, the points they are sponsoring\n', '  //\n', '  mapping(uint32 => uint32[]) public sponsoring;\n', '\n', '  //  sponsoringIndexes: per point, per point, (index + 1) in\n', '  //                     the sponsoring array\n', '  //\n', '  mapping(uint32 => mapping(uint32 => uint256)) public sponsoringIndexes;\n', '\n', '  //  escapeRequests: per point, the points they have open escape requests from\n', '  //\n', '  mapping(uint32 => uint32[]) public escapeRequests;\n', '\n', '  //  escapeRequestsIndexes: per point, per point, (index + 1) in\n', '  //                         the escapeRequests array\n', '  //\n', '  mapping(uint32 => mapping(uint32 => uint256)) public escapeRequestsIndexes;\n', '\n', '  //  pointsOwnedBy: per address, the points they own\n', '  //\n', '  mapping(address => uint32[]) public pointsOwnedBy;\n', '\n', '  //  pointOwnerIndexes: per owner, per point, (index + 1) in\n', '  //                     the pointsOwnedBy array\n', '  //\n', '  //    We delete owners by moving the last entry in the array to the\n', '  //    newly emptied slot, which is (n - 1) where n is the value of\n', '  //    pointOwnerIndexes[owner][point].\n', '  //\n', '  mapping(address => mapping(uint32 => uint256)) public pointOwnerIndexes;\n', '\n', '  //  managerFor: per address, the points they are the management proxy for\n', '  //\n', '  mapping(address => uint32[]) public managerFor;\n', '\n', '  //  managerForIndexes: per address, per point, (index + 1) in\n', '  //                     the managerFor array\n', '  //\n', '  mapping(address => mapping(uint32 => uint256)) public managerForIndexes;\n', '\n', '  //  spawningFor: per address, the points they can spawn with\n', '  //\n', '  mapping(address => uint32[]) public spawningFor;\n', '\n', '  //  spawningForIndexes: per address, per point, (index + 1) in\n', '  //                      the spawningFor array\n', '  //\n', '  mapping(address => mapping(uint32 => uint256)) public spawningForIndexes;\n', '\n', '  //  votingFor: per address, the points they can vote with\n', '  //\n', '  mapping(address => uint32[]) public votingFor;\n', '\n', '  //  votingForIndexes: per address, per point, (index + 1) in\n', '  //                    the votingFor array\n', '  //\n', '  mapping(address => mapping(uint32 => uint256)) public votingForIndexes;\n', '\n', '  //  transferringFor: per address, the points they can transfer\n', '  //\n', '  mapping(address => uint32[]) public transferringFor;\n', '\n', '  //  transferringForIndexes: per address, per point, (index + 1) in\n', '  //                          the transferringFor array\n', '  //\n', '  mapping(address => mapping(uint32 => uint256)) public transferringForIndexes;\n', '\n', '//\n', '//  Logic\n', '//\n', '\n', '  //  constructor(): configure default dns domains\n', '  //\n', '  constructor()\n', '    public\n', '  {\n', '    setDnsDomains("example.com", "example.com", "example.com");\n', '  }\n', '\n', '  //  setDnsDomains(): set the base domains used for contacting galaxies\n', '  //\n', '  //    Note: since a string is really just a byte[], and Solidity can&#39;t\n', '  //    work with two-dimensional arrays yet, we pass in the three\n', '  //    domains as individual strings.\n', '  //\n', '  function setDnsDomains(string _primary, string _secondary, string _tertiary)\n', '    onlyOwner\n', '    public\n', '  {\n', '    dnsDomains[0] = _primary;\n', '    dnsDomains[1] = _secondary;\n', '    dnsDomains[2] = _tertiary;\n', '    emit ChangedDns(_primary, _secondary, _tertiary);\n', '  }\n', '\n', '  //\n', '  //  Point reading\n', '  //\n', '\n', '    //  isActive(): return true if _point is active\n', '    //\n', '    function isActive(uint32 _point)\n', '      view\n', '      external\n', '      returns (bool equals)\n', '    {\n', '      return points[_point].active;\n', '    }\n', '\n', '    //  getKeys(): returns the public keys and their details, as currently\n', '    //             registered for _point\n', '    //\n', '    function getKeys(uint32 _point)\n', '      view\n', '      external\n', '      returns (bytes32 crypt, bytes32 auth, uint32 suite, uint32 revision)\n', '    {\n', '      Point storage point = points[_point];\n', '      return (point.encryptionKey,\n', '              point.authenticationKey,\n', '              point.cryptoSuiteVersion,\n', '              point.keyRevisionNumber);\n', '    }\n', '\n', '    //  getKeyRevisionNumber(): gets the revision number of _point&#39;s current\n', '    //                          public keys\n', '    //\n', '    function getKeyRevisionNumber(uint32 _point)\n', '      view\n', '      external\n', '      returns (uint32 revision)\n', '    {\n', '      return points[_point].keyRevisionNumber;\n', '    }\n', '\n', '    //  hasBeenLinked(): returns true if the point has ever been assigned keys\n', '    //\n', '    function hasBeenLinked(uint32 _point)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return ( points[_point].keyRevisionNumber > 0 );\n', '    }\n', '\n', '    //  isLive(): returns true if _point currently has keys properly configured\n', '    //\n', '    function isLive(uint32 _point)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      Point storage point = points[_point];\n', '      return ( point.encryptionKey != 0 &&\n', '               point.authenticationKey != 0 &&\n', '               point.cryptoSuiteVersion != 0 );\n', '    }\n', '\n', '    //  getContinuityNumber(): returns _point&#39;s current continuity number\n', '    //\n', '    function getContinuityNumber(uint32 _point)\n', '      view\n', '      external\n', '      returns (uint32 continuityNumber)\n', '    {\n', '      return points[_point].continuityNumber;\n', '    }\n', '\n', '    //  getSpawnCount(): return the number of children spawned by _point\n', '    //\n', '    function getSpawnCount(uint32 _point)\n', '      view\n', '      external\n', '      returns (uint32 spawnCount)\n', '    {\n', '      uint256 len = points[_point].spawned.length;\n', '      assert(len < 2**32);\n', '      return uint32(len);\n', '    }\n', '\n', '    //  getSpawned(): return array of points created under _point\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getSpawned(uint32 _point)\n', '      view\n', '      external\n', '      returns (uint32[] spawned)\n', '    {\n', '      return points[_point].spawned;\n', '    }\n', '\n', '    //  hasSponsor(): returns true if _point&#39;s sponsor is providing it service\n', '    //\n', '    function hasSponsor(uint32 _point)\n', '      view\n', '      external\n', '      returns (bool has)\n', '    {\n', '      return points[_point].hasSponsor;\n', '    }\n', '\n', '    //  getSponsor(): returns _point&#39;s current (or most recent) sponsor\n', '    //\n', '    function getSponsor(uint32 _point)\n', '      view\n', '      external\n', '      returns (uint32 sponsor)\n', '    {\n', '      return points[_point].sponsor;\n', '    }\n', '\n', '    //  isSponsor(): returns true if _sponsor is currently providing service\n', '    //               to _point\n', '    //\n', '    function isSponsor(uint32 _point, uint32 _sponsor)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      Point storage point = points[_point];\n', '      return ( point.hasSponsor &&\n', '               (point.sponsor == _sponsor) );\n', '    }\n', '\n', '    //  getSponsoringCount(): returns the number of points _sponsor is\n', '    //                        providing service to\n', '    //\n', '    function getSponsoringCount(uint32 _sponsor)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return sponsoring[_sponsor].length;\n', '    }\n', '\n', '    //  getSponsoring(): returns a list of points _sponsor is providing\n', '    //                   service to\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getSponsoring(uint32 _sponsor)\n', '      view\n', '      external\n', '      returns (uint32[] sponsees)\n', '    {\n', '      return sponsoring[_sponsor];\n', '    }\n', '\n', '    //  escaping\n', '\n', '    //  isEscaping(): returns true if _point has an outstanding escape request\n', '    //\n', '    function isEscaping(uint32 _point)\n', '      view\n', '      external\n', '      returns (bool escaping)\n', '    {\n', '      return points[_point].escapeRequested;\n', '    }\n', '\n', '    //  getEscapeRequest(): returns _point&#39;s current escape request\n', '    //\n', '    //    the returned escape request is only valid as long as isEscaping()\n', '    //    returns true\n', '    //\n', '    function getEscapeRequest(uint32 _point)\n', '      view\n', '      external\n', '      returns (uint32 escape)\n', '    {\n', '      return points[_point].escapeRequestedTo;\n', '    }\n', '\n', '    //  isRequestingEscapeTo(): returns true if _point has an outstanding\n', '    //                          escape request targetting _sponsor\n', '    //\n', '    function isRequestingEscapeTo(uint32 _point, uint32 _sponsor)\n', '      view\n', '      public\n', '      returns (bool equals)\n', '    {\n', '      Point storage point = points[_point];\n', '      return (point.escapeRequested && (point.escapeRequestedTo == _sponsor));\n', '    }\n', '\n', '    //  getEscapeRequestsCount(): returns the number of points _sponsor\n', '    //                            is providing service to\n', '    //\n', '    function getEscapeRequestsCount(uint32 _sponsor)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return escapeRequests[_sponsor].length;\n', '    }\n', '\n', '    //  getEscapeRequests(): get the points _sponsor has received escape\n', '    //                       requests from\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getEscapeRequests(uint32 _sponsor)\n', '      view\n', '      external\n', '      returns (uint32[] requests)\n', '    {\n', '      return escapeRequests[_sponsor];\n', '    }\n', '\n', '  //\n', '  //  Point writing\n', '  //\n', '\n', '    //  activatePoint(): activate a point, register it as spawned by its prefix\n', '    //\n', '    function activatePoint(uint32 _point)\n', '      onlyOwner\n', '      external\n', '    {\n', '      //  make a point active, setting its sponsor to its prefix\n', '      //\n', '      Point storage point = points[_point];\n', '      require(!point.active);\n', '      point.active = true;\n', '      registerSponsor(_point, true, getPrefix(_point));\n', '      emit Activated(_point);\n', '    }\n', '\n', '    //  setKeys(): set network public keys of _point to _encryptionKey and\n', '    //            _authenticationKey, with the specified _cryptoSuiteVersion\n', '    //\n', '    function setKeys(uint32 _point,\n', '                     bytes32 _encryptionKey,\n', '                     bytes32 _authenticationKey,\n', '                     uint32 _cryptoSuiteVersion)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Point storage point = points[_point];\n', '      if ( point.encryptionKey == _encryptionKey &&\n', '           point.authenticationKey == _authenticationKey &&\n', '           point.cryptoSuiteVersion == _cryptoSuiteVersion )\n', '      {\n', '        return;\n', '      }\n', '\n', '      point.encryptionKey = _encryptionKey;\n', '      point.authenticationKey = _authenticationKey;\n', '      point.cryptoSuiteVersion = _cryptoSuiteVersion;\n', '      point.keyRevisionNumber++;\n', '\n', '      emit ChangedKeys(_point,\n', '                       _encryptionKey,\n', '                       _authenticationKey,\n', '                       _cryptoSuiteVersion,\n', '                       point.keyRevisionNumber);\n', '    }\n', '\n', '    //  incrementContinuityNumber(): break continuity for _point\n', '    //\n', '    function incrementContinuityNumber(uint32 _point)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Point storage point = points[_point];\n', '      point.continuityNumber++;\n', '      emit BrokeContinuity(_point, point.continuityNumber);\n', '    }\n', '\n', '    //  registerSpawn(): add a point to its prefix&#39;s list of spawned points\n', '    //\n', '    function registerSpawned(uint32 _point)\n', '      onlyOwner\n', '      external\n', '    {\n', '      //  if a point is its own prefix (a galaxy) then don&#39;t register it\n', '      //\n', '      uint32 prefix = getPrefix(_point);\n', '      if (prefix == _point)\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  register a new spawned point for the prefix\n', '      //\n', '      points[prefix].spawned.push(_point);\n', '      emit Spawned(prefix, _point);\n', '    }\n', '\n', '    //  loseSponsor(): indicates that _point&#39;s sponsor is no longer providing\n', '    //                 it service\n', '    //\n', '    function loseSponsor(uint32 _point)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Point storage point = points[_point];\n', '      if (!point.hasSponsor)\n', '      {\n', '        return;\n', '      }\n', '      registerSponsor(_point, false, point.sponsor);\n', '      emit LostSponsor(_point, point.sponsor);\n', '    }\n', '\n', '    //  setEscapeRequest(): for _point, start an escape request to _sponsor\n', '    //\n', '    function setEscapeRequest(uint32 _point, uint32 _sponsor)\n', '      onlyOwner\n', '      external\n', '    {\n', '      if (isRequestingEscapeTo(_point, _sponsor))\n', '      {\n', '        return;\n', '      }\n', '      registerEscapeRequest(_point, true, _sponsor);\n', '      emit EscapeRequested(_point, _sponsor);\n', '    }\n', '\n', '    //  cancelEscape(): for _point, stop the current escape request, if any\n', '    //\n', '    function cancelEscape(uint32 _point)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Point storage point = points[_point];\n', '      if (!point.escapeRequested)\n', '      {\n', '        return;\n', '      }\n', '      uint32 request = point.escapeRequestedTo;\n', '      registerEscapeRequest(_point, false, 0);\n', '      emit EscapeCanceled(_point, request);\n', '    }\n', '\n', '    //  doEscape(): perform the requested escape\n', '    //\n', '    function doEscape(uint32 _point)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Point storage point = points[_point];\n', '      require(point.escapeRequested);\n', '      registerSponsor(_point, true, point.escapeRequestedTo);\n', '      registerEscapeRequest(_point, false, 0);\n', '      emit EscapeAccepted(_point, point.sponsor);\n', '    }\n', '\n', '  //\n', '  //  Point utils\n', '  //\n', '\n', '    //  getPrefix(): compute prefix ("parent") of _point\n', '    //\n', '    function getPrefix(uint32 _point)\n', '      pure\n', '      public\n', '      returns (uint16 prefix)\n', '    {\n', '      if (_point < 0x10000)\n', '      {\n', '        return uint16(_point % 0x100);\n', '      }\n', '      return uint16(_point % 0x10000);\n', '    }\n', '\n', '    //  getPointSize(): return the size of _point\n', '    //\n', '    function getPointSize(uint32 _point)\n', '      external\n', '      pure\n', '      returns (Size _size)\n', '    {\n', '      if (_point < 0x100) return Size.Galaxy;\n', '      if (_point < 0x10000) return Size.Star;\n', '      return Size.Planet;\n', '    }\n', '\n', '    //  internal use\n', '\n', '    //  registerSponsor(): set the sponsorship state of _point and update the\n', '    //                     reverse lookup for sponsors\n', '    //\n', '    function registerSponsor(uint32 _point, bool _hasSponsor, uint32 _sponsor)\n', '      internal\n', '    {\n', '      Point storage point = points[_point];\n', '      bool had = point.hasSponsor;\n', '      uint32 prev = point.sponsor;\n', '\n', '      //  if we didn&#39;t have a sponsor, and won&#39;t get one,\n', '      //  or if we get the sponsor we already have,\n', '      //  nothing will change, so jump out early.\n', '      //\n', '      if ( (!had && !_hasSponsor) ||\n', '           (had && _hasSponsor && prev == _sponsor) )\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different sponsor, do some gymnastics\n', '      //  to keep the reverse lookup gapless.  delete the point from the old\n', '      //  sponsor&#39;s list, then fill that gap with the list tail.\n', '      //\n', '      if (had)\n', '      {\n', '        //  i: current index in previous sponsor&#39;s list of sponsored points\n', '        //\n', '        uint256 i = sponsoringIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :sponsoringIndexes reference\n', '        //\n', '        uint32[] storage prevSponsoring = sponsoring[prev];\n', '        uint256 last = prevSponsoring.length - 1;\n', '        uint32 moved = prevSponsoring[last];\n', '        prevSponsoring[i] = moved;\n', '        sponsoringIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(prevSponsoring[last]);\n', '        prevSponsoring.length = last;\n', '        sponsoringIndexes[prev][_point] = 0;\n', '      }\n', '\n', '      if (_hasSponsor)\n', '      {\n', '        uint32[] storage newSponsoring = sponsoring[_sponsor];\n', '        newSponsoring.push(_point);\n', '        sponsoringIndexes[_sponsor][_point] = newSponsoring.length;\n', '      }\n', '\n', '      point.sponsor = _sponsor;\n', '      point.hasSponsor = _hasSponsor;\n', '    }\n', '\n', '    //  registerEscapeRequest(): set the escape state of _point and update the\n', '    //                           reverse lookup for sponsors\n', '    //\n', '    function registerEscapeRequest( uint32 _point,\n', '                                    bool _isEscaping, uint32 _sponsor )\n', '      internal\n', '    {\n', '      Point storage point = points[_point];\n', '      bool was = point.escapeRequested;\n', '      uint32 prev = point.escapeRequestedTo;\n', '\n', '      //  if we weren&#39;t escaping, and won&#39;t be,\n', '      //  or if we were escaping, and the new target is the same,\n', '      //  nothing will change, so jump out early.\n', '      //\n', '      if ( (!was && !_isEscaping) ||\n', '           (was && _isEscaping && prev == _sponsor) )\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different request, do some gymnastics\n', '      //  to keep the reverse lookup gapless.  delete the point from the old\n', '      //  sponsor&#39;s list, then fill that gap with the list tail.\n', '      //\n', '      if (was)\n', '      {\n', '        //  i: current index in previous sponsor&#39;s list of sponsored points\n', '        //\n', '        uint256 i = escapeRequestsIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :escapeRequestsIndexes reference\n', '        //\n', '        uint32[] storage prevRequests = escapeRequests[prev];\n', '        uint256 last = prevRequests.length - 1;\n', '        uint32 moved = prevRequests[last];\n', '        prevRequests[i] = moved;\n', '        escapeRequestsIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(prevRequests[last]);\n', '        prevRequests.length = last;\n', '        escapeRequestsIndexes[prev][_point] = 0;\n', '      }\n', '\n', '      if (_isEscaping)\n', '      {\n', '        uint32[] storage newRequests = escapeRequests[_sponsor];\n', '        newRequests.push(_point);\n', '        escapeRequestsIndexes[_sponsor][_point] = newRequests.length;\n', '      }\n', '\n', '      point.escapeRequestedTo = _sponsor;\n', '      point.escapeRequested = _isEscaping;\n', '    }\n', '\n', '  //\n', '  //  Deed reading\n', '  //\n', '\n', '    //  owner\n', '\n', '    //  getOwner(): return owner of _point\n', '    //\n', '    function getOwner(uint32 _point)\n', '      view\n', '      external\n', '      returns (address owner)\n', '    {\n', '      return rights[_point].owner;\n', '    }\n', '\n', '    //  isOwner(): true if _point is owned by _address\n', '    //\n', '    function isOwner(uint32 _point, address _address)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return (rights[_point].owner == _address);\n', '    }\n', '\n', '    //  getOwnedPointCount(): return length of array of points that _whose owns\n', '    //\n', '    function getOwnedPointCount(address _whose)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return pointsOwnedBy[_whose].length;\n', '    }\n', '\n', '    //  getOwnedPoints(): return array of points that _whose owns\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getOwnedPoints(address _whose)\n', '      view\n', '      external\n', '      returns (uint32[] ownedPoints)\n', '    {\n', '      return pointsOwnedBy[_whose];\n', '    }\n', '\n', '    //  getOwnedPointAtIndex(): get point at _index from array of points that\n', '    //                         _whose owns\n', '    //\n', '    function getOwnedPointAtIndex(address _whose, uint256 _index)\n', '      view\n', '      external\n', '      returns (uint32 point)\n', '    {\n', '      uint32[] storage owned = pointsOwnedBy[_whose];\n', '      require(_index < owned.length);\n', '      return owned[_index];\n', '    }\n', '\n', '    //  management proxy\n', '\n', '    //  getManagementProxy(): returns _point&#39;s current management proxy\n', '    //\n', '    function getManagementProxy(uint32 _point)\n', '      view\n', '      external\n', '      returns (address manager)\n', '    {\n', '      return rights[_point].managementProxy;\n', '    }\n', '\n', '    //  isManagementProxy(): returns true if _proxy is _point&#39;s management proxy\n', '    //\n', '    function isManagementProxy(uint32 _point, address _proxy)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return (rights[_point].managementProxy == _proxy);\n', '    }\n', '\n', '    //  canManage(): true if _who is the owner or manager of _point\n', '    //\n', '    function canManage(uint32 _point, address _who)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      return ( (0x0 != _who) &&\n', '               ( (_who == deed.owner) ||\n', '                 (_who == deed.managementProxy) ) );\n', '    }\n', '\n', '    //  getManagerForCount(): returns the amount of points _proxy can manage\n', '    //\n', '    function getManagerForCount(address _proxy)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return managerFor[_proxy].length;\n', '    }\n', '\n', '    //  getManagerFor(): returns the points _proxy can manage\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getManagerFor(address _proxy)\n', '      view\n', '      external\n', '      returns (uint32[] mfor)\n', '    {\n', '      return managerFor[_proxy];\n', '    }\n', '\n', '    //  spawn proxy\n', '\n', '    //  getSpawnProxy(): returns _point&#39;s current spawn proxy\n', '    //\n', '    function getSpawnProxy(uint32 _point)\n', '      view\n', '      external\n', '      returns (address spawnProxy)\n', '    {\n', '      return rights[_point].spawnProxy;\n', '    }\n', '\n', '    //  isSpawnProxy(): returns true if _proxy is _point&#39;s spawn proxy\n', '    //\n', '    function isSpawnProxy(uint32 _point, address _proxy)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return (rights[_point].spawnProxy == _proxy);\n', '    }\n', '\n', '    //  canSpawnAs(): true if _who is the owner or spawn proxy of _point\n', '    //\n', '    function canSpawnAs(uint32 _point, address _who)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      return ( (0x0 != _who) &&\n', '               ( (_who == deed.owner) ||\n', '                 (_who == deed.spawnProxy) ) );\n', '    }\n', '\n', '    //  getSpawningForCount(): returns the amount of points _proxy\n', '    //                         can spawn with\n', '    //\n', '    function getSpawningForCount(address _proxy)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return spawningFor[_proxy].length;\n', '    }\n', '\n', '    //  getSpawningFor(): get the points _proxy can spawn with\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getSpawningFor(address _proxy)\n', '      view\n', '      external\n', '      returns (uint32[] sfor)\n', '    {\n', '      return spawningFor[_proxy];\n', '    }\n', '\n', '    //  voting proxy\n', '\n', '    //  getVotingProxy(): returns _point&#39;s current voting proxy\n', '    //\n', '    function getVotingProxy(uint32 _point)\n', '      view\n', '      external\n', '      returns (address voter)\n', '    {\n', '      return rights[_point].votingProxy;\n', '    }\n', '\n', '    //  isVotingProxy(): returns true if _proxy is _point&#39;s voting proxy\n', '    //\n', '    function isVotingProxy(uint32 _point, address _proxy)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return (rights[_point].votingProxy == _proxy);\n', '    }\n', '\n', '    //  canVoteAs(): true if _who is the owner of _point,\n', '    //               or the voting proxy of _point&#39;s owner\n', '    //\n', '    function canVoteAs(uint32 _point, address _who)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      return ( (0x0 != _who) &&\n', '               ( (_who == deed.owner) ||\n', '                 (_who == deed.votingProxy) ) );\n', '    }\n', '\n', '    //  getVotingForCount(): returns the amount of points _proxy can vote as\n', '    //\n', '    function getVotingForCount(address _proxy)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return votingFor[_proxy].length;\n', '    }\n', '\n', '    //  getVotingFor(): returns the points _proxy can vote as\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getVotingFor(address _proxy)\n', '      view\n', '      external\n', '      returns (uint32[] vfor)\n', '    {\n', '      return votingFor[_proxy];\n', '    }\n', '\n', '    //  transfer proxy\n', '\n', '    //  getTransferProxy(): returns _point&#39;s current transfer proxy\n', '    //\n', '    function getTransferProxy(uint32 _point)\n', '      view\n', '      external\n', '      returns (address transferProxy)\n', '    {\n', '      return rights[_point].transferProxy;\n', '    }\n', '\n', '    //  isTransferProxy(): returns true if _proxy is _point&#39;s transfer proxy\n', '    //\n', '    function isTransferProxy(uint32 _point, address _proxy)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return (rights[_point].transferProxy == _proxy);\n', '    }\n', '\n', '    //  canTransfer(): true if _who is the owner or transfer proxy of _point,\n', '    //                 or is an operator for _point&#39;s current owner\n', '    //\n', '    function canTransfer(uint32 _point, address _who)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      return ( (0x0 != _who) &&\n', '               ( (_who == deed.owner) ||\n', '                 (_who == deed.transferProxy) ||\n', '                 operators[deed.owner][_who] ) );\n', '    }\n', '\n', '    //  getTransferringForCount(): returns the amount of points _proxy\n', '    //                             can transfer\n', '    //\n', '    function getTransferringForCount(address _proxy)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return transferringFor[_proxy].length;\n', '    }\n', '\n', '    //  getTransferringFor(): get the points _proxy can transfer\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getTransferringFor(address _proxy)\n', '      view\n', '      external\n', '      returns (uint32[] tfor)\n', '    {\n', '      return transferringFor[_proxy];\n', '    }\n', '\n', '    //  isOperator(): returns true if _operator is allowed to transfer\n', '    //                ownership of _owner&#39;s points\n', '    //\n', '    function isOperator(address _owner, address _operator)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return operators[_owner][_operator];\n', '    }\n', '\n', '  //\n', '  //  Deed writing\n', '  //\n', '\n', '    //  setOwner(): set owner of _point to _owner\n', '    //\n', '    //    Note: setOwner() only implements the minimal data storage\n', '    //    logic for a transfer; the full transfer is implemented in\n', '    //    Ecliptic.\n', '    //\n', '    //    Note: _owner must not be the zero address.\n', '    //\n', '    function setOwner(uint32 _point, address _owner)\n', '      onlyOwner\n', '      external\n', '    {\n', '      //  prevent burning of points by making zero the owner\n', '      //\n', '      require(0x0 != _owner);\n', '\n', '      //  prev: previous owner, if any\n', '      //\n', '      address prev = rights[_point].owner;\n', '\n', '      if (prev == _owner)\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different owner, do some gymnastics to\n', '      //  keep the list of owned points gapless.  delete this point from the\n', '      //  list, then fill that gap with the list tail.\n', '      //\n', '      if (0x0 != prev)\n', '      {\n', '        //  i: current index in previous owner&#39;s list of owned points\n', '        //\n', '        uint256 i = pointOwnerIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :pointOwnerIndexes reference\n', '        //\n', '        uint32[] storage owner = pointsOwnedBy[prev];\n', '        uint256 last = owner.length - 1;\n', '        uint32 moved = owner[last];\n', '        owner[i] = moved;\n', '        pointOwnerIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(owner[last]);\n', '        owner.length = last;\n', '        pointOwnerIndexes[prev][_point] = 0;\n', '      }\n', '\n', '      //  update the owner list and the owner&#39;s index list\n', '      //\n', '      rights[_point].owner = _owner;\n', '      pointsOwnedBy[_owner].push(_point);\n', '      pointOwnerIndexes[_owner][_point] = pointsOwnedBy[_owner].length;\n', '      emit OwnerChanged(_point, _owner);\n', '    }\n', '\n', '    //  setManagementProxy(): makes _proxy _point&#39;s management proxy\n', '    //\n', '    function setManagementProxy(uint32 _point, address _proxy)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      address prev = deed.managementProxy;\n', '      if (prev == _proxy)\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different manager, do some gymnastics\n', '      //  to keep the reverse lookup gapless.  delete the point from the\n', '      //  old manager&#39;s list, then fill that gap with the list tail.\n', '      //\n', '      if (0x0 != prev)\n', '      {\n', '        //  i: current index in previous manager&#39;s list of managed points\n', '        //\n', '        uint256 i = managerForIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :managerForIndexes reference\n', '        //\n', '        uint32[] storage prevMfor = managerFor[prev];\n', '        uint256 last = prevMfor.length - 1;\n', '        uint32 moved = prevMfor[last];\n', '        prevMfor[i] = moved;\n', '        managerForIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(prevMfor[last]);\n', '        prevMfor.length = last;\n', '        managerForIndexes[prev][_point] = 0;\n', '      }\n', '\n', '      if (0x0 != _proxy)\n', '      {\n', '        uint32[] storage mfor = managerFor[_proxy];\n', '        mfor.push(_point);\n', '        managerForIndexes[_proxy][_point] = mfor.length;\n', '      }\n', '\n', '      deed.managementProxy = _proxy;\n', '      emit ChangedManagementProxy(_point, _proxy);\n', '    }\n', '\n', '    //  setSpawnProxy(): makes _proxy _point&#39;s spawn proxy\n', '    //\n', '    function setSpawnProxy(uint32 _point, address _proxy)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      address prev = deed.spawnProxy;\n', '      if (prev == _proxy)\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different spawn proxy, do some\n', '      //  gymnastics to keep the reverse lookup gapless.  delete the point\n', '      //  from the old proxy&#39;s list, then fill that gap with the list tail.\n', '      //\n', '      if (0x0 != prev)\n', '      {\n', '        //  i: current index in previous proxy&#39;s list of spawning points\n', '        //\n', '        uint256 i = spawningForIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :spawningForIndexes reference\n', '        //\n', '        uint32[] storage prevSfor = spawningFor[prev];\n', '        uint256 last = prevSfor.length - 1;\n', '        uint32 moved = prevSfor[last];\n', '        prevSfor[i] = moved;\n', '        spawningForIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(prevSfor[last]);\n', '        prevSfor.length = last;\n', '        spawningForIndexes[prev][_point] = 0;\n', '      }\n', '\n', '      if (0x0 != _proxy)\n', '      {\n', '        uint32[] storage sfor = spawningFor[_proxy];\n', '        sfor.push(_point);\n', '        spawningForIndexes[_proxy][_point] = sfor.length;\n', '      }\n', '\n', '      deed.spawnProxy = _proxy;\n', '      emit ChangedSpawnProxy(_point, _proxy);\n', '    }\n', '\n', '    //  setVotingProxy(): makes _proxy _point&#39;s voting proxy\n', '    //\n', '    function setVotingProxy(uint32 _point, address _proxy)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      address prev = deed.votingProxy;\n', '      if (prev == _proxy)\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different voter, do some gymnastics\n', '      //  to keep the reverse lookup gapless.  delete the point from the\n', '      //  old voter&#39;s list, then fill that gap with the list tail.\n', '      //\n', '      if (0x0 != prev)\n', '      {\n', '        //  i: current index in previous voter&#39;s list of points it was\n', '        //     voting for\n', '        //\n', '        uint256 i = votingForIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :votingForIndexes reference\n', '        //\n', '        uint32[] storage prevVfor = votingFor[prev];\n', '        uint256 last = prevVfor.length - 1;\n', '        uint32 moved = prevVfor[last];\n', '        prevVfor[i] = moved;\n', '        votingForIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(prevVfor[last]);\n', '        prevVfor.length = last;\n', '        votingForIndexes[prev][_point] = 0;\n', '      }\n', '\n', '      if (0x0 != _proxy)\n', '      {\n', '        uint32[] storage vfor = votingFor[_proxy];\n', '        vfor.push(_point);\n', '        votingForIndexes[_proxy][_point] = vfor.length;\n', '      }\n', '\n', '      deed.votingProxy = _proxy;\n', '      emit ChangedVotingProxy(_point, _proxy);\n', '    }\n', '\n', '    //  setManagementProxy(): makes _proxy _point&#39;s transfer proxy\n', '    //\n', '    function setTransferProxy(uint32 _point, address _proxy)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      address prev = deed.transferProxy;\n', '      if (prev == _proxy)\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different transfer proxy, do some\n', '      //  gymnastics to keep the reverse lookup gapless.  delete the point\n', '      //  from the old proxy&#39;s list, then fill that gap with the list tail.\n', '      //\n', '      if (0x0 != prev)\n', '      {\n', '        //  i: current index in previous proxy&#39;s list of transferable points\n', '        //\n', '        uint256 i = transferringForIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :transferringForIndexes reference\n', '        //\n', '        uint32[] storage prevTfor = transferringFor[prev];\n', '        uint256 last = prevTfor.length - 1;\n', '        uint32 moved = prevTfor[last];\n', '        prevTfor[i] = moved;\n', '        transferringForIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(prevTfor[last]);\n', '        prevTfor.length = last;\n', '        transferringForIndexes[prev][_point] = 0;\n', '      }\n', '\n', '      if (0x0 != _proxy)\n', '      {\n', '        uint32[] storage tfor = transferringFor[_proxy];\n', '        tfor.push(_point);\n', '        transferringForIndexes[_proxy][_point] = tfor.length;\n', '      }\n', '\n', '      deed.transferProxy = _proxy;\n', '      emit ChangedTransferProxy(_point, _proxy);\n', '    }\n', '\n', '    //  setOperator(): dis/allow _operator to transfer ownership of all points\n', '    //                 owned by _owner\n', '    //\n', '    //    operators are part of the ERC721 standard\n', '    //\n', '    function setOperator(address _owner, address _operator, bool _approved)\n', '      onlyOwner\n', '      external\n', '    {\n', '      operators[_owner][_operator] = _approved;\n', '    }\n', '}\n', '\n', '// Azimuth&#39;s ReadsAzimuth.sol\n', '\n', '//  ReadsAzimuth: referring to and testing against the Azimuth\n', '//                data contract\n', '//\n', '//    To avoid needless repetition, this contract provides common\n', '//    checks and operations using the Azimuth contract.\n', '//\n', 'contract ReadsAzimuth\n', '{\n', '  //  azimuth: points data storage contract.\n', '  //\n', '  Azimuth public azimuth;\n', '\n', '  //  constructor(): set the Azimuth data contract&#39;s address\n', '  //\n', '  constructor(Azimuth _azimuth)\n', '    public\n', '  {\n', '    azimuth = _azimuth;\n', '  }\n', '\n', '  //  activePointOwner(): require that :msg.sender is the owner of _point,\n', '  //                      and that _point is active\n', '  //\n', '  modifier activePointOwner(uint32 _point)\n', '  {\n', '    require( azimuth.isOwner(_point, msg.sender) &&\n', '             azimuth.isActive(_point) );\n', '    _;\n', '  }\n', '\n', '  //  activePointManager(): require that :msg.sender can manage _point,\n', '  //                        and that _point is active\n', '  //\n', '  modifier activePointManager(uint32 _point)\n', '  {\n', '    require( azimuth.canManage(_point, msg.sender) &&\n', '             azimuth.isActive(_point) );\n', '    _;\n', '  }\n', '}\n', '\n', '// Azimuth&#39;s Polls.sol\n', '\n', '//  Polls: proposals & votes data contract\n', '//\n', '//    This contract is used for storing all data related to the proposals\n', '//    of the senate (galaxy owners) and their votes on those proposals.\n', '//    It keeps track of votes and uses them to calculate whether a majority\n', '//    is in favor of a proposal.\n', '//\n', '//    Every galaxy can only vote on a proposal exactly once. Votes cannot\n', '//    be changed. If a proposal fails to achieve majority within its\n', '//    duration, it can be restarted after its cooldown period has passed.\n', '//\n', '//    The requirements for a proposal to achieve majority are as follows:\n', '//    - At least 1/4 of the currently active voters (rounded down) must have\n', '//      voted in favor of the proposal,\n', '//    - More than half of the votes cast must be in favor of the proposal,\n', '//      and this can no longer change, either because\n', '//      - the poll duration has passed, or\n', '//      - not enough voters remain to take away the in-favor majority.\n', '//    As soon as these conditions are met, no further interaction with\n', '//    the proposal is possible. Achieving majority is permanent.\n', '//\n', '//    Since data stores are difficult to upgrade, all of the logic unrelated\n', '//    to the voting itself (that is, determining who is eligible to vote)\n', '//    is expected to be implemented by this contract&#39;s owner.\n', '//\n', '//    This contract will be owned by the Ecliptic contract.\n', '//\n', 'contract Polls is Ownable\n', '{\n', '  using SafeMath for uint256;\n', '  using SafeMath16 for uint16;\n', '  using SafeMath8 for uint8;\n', '\n', '  //  UpgradePollStarted: a poll on :proposal has opened\n', '  //\n', '  event UpgradePollStarted(address proposal);\n', '\n', '  //  DocumentPollStarted: a poll on :proposal has opened\n', '  //\n', '  event DocumentPollStarted(bytes32 proposal);\n', '\n', '  //  UpgradeMajority: :proposal has achieved majority\n', '  //\n', '  event UpgradeMajority(address proposal);\n', '\n', '  //  DocumentMajority: :proposal has achieved majority\n', '  //\n', '  event DocumentMajority(bytes32 proposal);\n', '\n', '  //  Poll: full poll state\n', '  //\n', '  struct Poll\n', '  {\n', '    //  start: the timestamp at which the poll was started\n', '    //\n', '    uint256 start;\n', '\n', '    //  voted: per galaxy, whether they have voted on this poll\n', '    //\n', '    bool[256] voted;\n', '\n', '    //  yesVotes: amount of votes in favor of the proposal\n', '    //\n', '    uint16 yesVotes;\n', '\n', '    //  noVotes: amount of votes against the proposal\n', '    //\n', '    uint16 noVotes;\n', '\n', '    //  duration: amount of time during which the poll can be voted on\n', '    //\n', '    uint256 duration;\n', '\n', '    //  cooldown: amount of time before the (non-majority) poll can be reopened\n', '    //\n', '    uint256 cooldown;\n', '  }\n', '\n', '  //  pollDuration: duration set for new polls. see also Poll.duration above\n', '  //\n', '  uint256 public pollDuration;\n', '\n', '  //  pollCooldown: cooldown set for new polls. see also Poll.cooldown above\n', '  //\n', '  uint256 public pollCooldown;\n', '\n', '  //  totalVoters: amount of active galaxies\n', '  //\n', '  uint16 public totalVoters;\n', '\n', '  //  upgradeProposals: list of all upgrades ever proposed\n', '  //\n', '  //    this allows clients to discover the existence of polls.\n', '  //    from there, they can do liveness checks on the polls themselves.\n', '  //\n', '  address[] public upgradeProposals;\n', '\n', '  //  upgradePolls: per address, poll held to determine if that address\n', '  //                will become the new ecliptic\n', '  //\n', '  mapping(address => Poll) public upgradePolls;\n', '\n', '  //  upgradeHasAchievedMajority: per address, whether that address\n', '  //                              has ever achieved majority\n', '  //\n', '  //    If we did not store this, we would have to look at old poll data\n', '  //    to see whether or not a proposal has ever achieved majority.\n', '  //    Since the outcome of a poll is calculated based on :totalVoters,\n', '  //    which may not be consistent across time, we need to store outcomes\n', '  //    explicitly instead of re-calculating them. This allows us to always\n', '  //    tell with certainty whether or not a majority was achieved,\n', '  //    regardless of the current :totalVoters.\n', '  //\n', '  mapping(address => bool) public upgradeHasAchievedMajority;\n', '\n', '  //  documentProposals: list of all documents ever proposed\n', '  //\n', '  //    this allows clients to discover the existence of polls.\n', '  //    from there, they can do liveness checks on the polls themselves.\n', '  //\n', '  bytes32[] public documentProposals;\n', '\n', '  //  documentPolls: per hash, poll held to determine if the corresponding\n', '  //                 document is accepted by the galactic senate\n', '  //\n', '  mapping(bytes32 => Poll) public documentPolls;\n', '\n', '  //  documentHasAchievedMajority: per hash, whether that hash has ever\n', '  //                               achieved majority\n', '  //\n', '  //    the note for upgradeHasAchievedMajority above applies here as well\n', '  //\n', '  mapping(bytes32 => bool) public documentHasAchievedMajority;\n', '\n', '  //  documentMajorities: all hashes that have achieved majority\n', '  //\n', '  bytes32[] public documentMajorities;\n', '\n', '  //  constructor(): initial contract configuration\n', '  //\n', '  constructor(uint256 _pollDuration, uint256 _pollCooldown)\n', '    public\n', '  {\n', '    reconfigure(_pollDuration, _pollCooldown);\n', '  }\n', '\n', '  //  reconfigure(): change poll duration and cooldown\n', '  //\n', '  function reconfigure(uint256 _pollDuration, uint256 _pollCooldown)\n', '    public\n', '    onlyOwner\n', '  {\n', '    require( (5 days <= _pollDuration) && (_pollDuration <= 90 days) &&\n', '             (5 days <= _pollCooldown) && (_pollCooldown <= 90 days) );\n', '    pollDuration = _pollDuration;\n', '    pollCooldown = _pollCooldown;\n', '  }\n', '\n', '  //  incrementTotalVoters(): increase the amount of registered voters\n', '  //\n', '  function incrementTotalVoters()\n', '    external\n', '    onlyOwner\n', '  {\n', '    require(totalVoters < 256);\n', '    totalVoters = totalVoters.add(1);\n', '  }\n', '\n', '  //  getAllUpgradeProposals(): return array of all upgrade proposals ever made\n', '  //\n', '  //    Note: only useful for clients, as Solidity does not currently\n', '  //    support returning dynamic arrays.\n', '  //\n', '  function getUpgradeProposals()\n', '    external\n', '    view\n', '    returns (address[] proposals)\n', '  {\n', '    return upgradeProposals;\n', '  }\n', '\n', '  //  getUpgradeProposalCount(): get the number of unique proposed upgrades\n', '  //\n', '  function getUpgradeProposalCount()\n', '    external\n', '    view\n', '    returns (uint256 count)\n', '  {\n', '    return upgradeProposals.length;\n', '  }\n', '\n', '  //  getAllDocumentProposals(): return array of all upgrade proposals ever made\n', '  //\n', '  //    Note: only useful for clients, as Solidity does not currently\n', '  //    support returning dynamic arrays.\n', '  //\n', '  function getDocumentProposals()\n', '    external\n', '    view\n', '    returns (bytes32[] proposals)\n', '  {\n', '    return documentProposals;\n', '  }\n', '\n', '  //  getDocumentProposalCount(): get the number of unique proposed upgrades\n', '  //\n', '  function getDocumentProposalCount()\n', '    external\n', '    view\n', '    returns (uint256 count)\n', '  {\n', '    return documentProposals.length;\n', '  }\n', '\n', '  //  getDocumentMajorities(): return array of all document majorities\n', '  //\n', '  //    Note: only useful for clients, as Solidity does not currently\n', '  //    support returning dynamic arrays.\n', '  //\n', '  function getDocumentMajorities()\n', '    external\n', '    view\n', '    returns (bytes32[] majorities)\n', '  {\n', '    return documentMajorities;\n', '  }\n', '\n', '  //  hasVotedOnUpgradePoll(): returns true if _galaxy has voted\n', '  //                           on the _proposal\n', '  //\n', '  function hasVotedOnUpgradePoll(uint8 _galaxy, address _proposal)\n', '    external\n', '    view\n', '    returns (bool result)\n', '  {\n', '    return upgradePolls[_proposal].voted[_galaxy];\n', '  }\n', '\n', '  //  hasVotedOnDocumentPoll(): returns true if _galaxy has voted\n', '  //                            on the _proposal\n', '  //\n', '  function hasVotedOnDocumentPoll(uint8 _galaxy, bytes32 _proposal)\n', '    external\n', '    view\n', '    returns (bool result)\n', '  {\n', '    return documentPolls[_proposal].voted[_galaxy];\n', '  }\n', '\n', '  //  startUpgradePoll(): open a poll on making _proposal the new ecliptic\n', '  //\n', '  function startUpgradePoll(address _proposal)\n', '    external\n', '    onlyOwner\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!upgradeHasAchievedMajority[_proposal]);\n', '\n', '    Poll storage poll = upgradePolls[_proposal];\n', '\n', '    //  if the proposal is being made for the first time, register it.\n', '    //\n', '    if (0 == poll.start)\n', '    {\n', '      upgradeProposals.push(_proposal);\n', '    }\n', '\n', '    startPoll(poll);\n', '    emit UpgradePollStarted(_proposal);\n', '  }\n', '\n', '  //  startDocumentPoll(): open a poll on accepting the document\n', '  //                       whose hash is _proposal\n', '  //\n', '  function startDocumentPoll(bytes32 _proposal)\n', '    external\n', '    onlyOwner\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!documentHasAchievedMajority[_proposal]);\n', '\n', '    Poll storage poll = documentPolls[_proposal];\n', '\n', '    //  if the proposal is being made for the first time, register it.\n', '    //\n', '    if (0 == poll.start)\n', '    {\n', '      documentProposals.push(_proposal);\n', '    }\n', '\n', '    startPoll(poll);\n', '    emit DocumentPollStarted(_proposal);\n', '  }\n', '\n', '  //  startPoll(): open a new poll, or re-open an old one\n', '  //\n', '  function startPoll(Poll storage _poll)\n', '    internal\n', '  {\n', '    //  check that the poll has cooled down enough to be started again\n', '    //\n', '    //    for completely new polls, the values used will be zero\n', '    //\n', '    require( block.timestamp > ( _poll.start.add(\n', '                                 _poll.duration.add(\n', '                                 _poll.cooldown )) ) );\n', '\n', '    //  set started poll state\n', '    //\n', '    _poll.start = block.timestamp;\n', '    delete _poll.voted;\n', '    _poll.yesVotes = 0;\n', '    _poll.noVotes = 0;\n', '    _poll.duration = pollDuration;\n', '    _poll.cooldown = pollCooldown;\n', '  }\n', '\n', '  //  castUpgradeVote(): as galaxy _as, cast a vote on the _proposal\n', '  //\n', '  //    _vote is true when in favor of the proposal, false otherwise\n', '  //\n', '  function castUpgradeVote(uint8 _as, address _proposal, bool _vote)\n', '    external\n', '    onlyOwner\n', '    returns (bool majority)\n', '  {\n', '    Poll storage poll = upgradePolls[_proposal];\n', '    processVote(poll, _as, _vote);\n', '    return updateUpgradePoll(_proposal);\n', '  }\n', '\n', '  //  castDocumentVote(): as galaxy _as, cast a vote on the _proposal\n', '  //\n', '  //    _vote is true when in favor of the proposal, false otherwise\n', '  //\n', '  function castDocumentVote(uint8 _as, bytes32 _proposal, bool _vote)\n', '    external\n', '    onlyOwner\n', '    returns (bool majority)\n', '  {\n', '    Poll storage poll = documentPolls[_proposal];\n', '    processVote(poll, _as, _vote);\n', '    return updateDocumentPoll(_proposal);\n', '  }\n', '\n', '  //  processVote(): record a vote from _as on the _poll\n', '  //\n', '  function processVote(Poll storage _poll, uint8 _as, bool _vote)\n', '    internal\n', '  {\n', '    //  assist symbolic execution tools\n', '    //\n', '    assert(block.timestamp >= _poll.start);\n', '\n', '    require( //  may only vote once\n', '             //\n', '             !_poll.voted[_as] &&\n', '             //\n', '             //  may only vote when the poll is open\n', '             //\n', '             (block.timestamp < _poll.start.add(_poll.duration)) );\n', '\n', '    //  update poll state to account for the new vote\n', '    //\n', '    _poll.voted[_as] = true;\n', '    if (_vote)\n', '    {\n', '      _poll.yesVotes = _poll.yesVotes.add(1);\n', '    }\n', '    else\n', '    {\n', '      _poll.noVotes = _poll.noVotes.add(1);\n', '    }\n', '  }\n', '\n', '  //  updateUpgradePoll(): check whether the _proposal has achieved\n', '  //                            majority, updating state, sending an event,\n', '  //                            and returning true if it has\n', '  //\n', '  function updateUpgradePoll(address _proposal)\n', '    public\n', '    onlyOwner\n', '    returns (bool majority)\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!upgradeHasAchievedMajority[_proposal]);\n', '\n', '    //  check for majority in the poll\n', '    //\n', '    Poll storage poll = upgradePolls[_proposal];\n', '    majority = checkPollMajority(poll);\n', '\n', '    //  if majority was achieved, update the state and send an event\n', '    //\n', '    if (majority)\n', '    {\n', '      upgradeHasAchievedMajority[_proposal] = true;\n', '      emit UpgradeMajority(_proposal);\n', '    }\n', '    return majority;\n', '  }\n', '\n', '  //  updateDocumentPoll(): check whether the _proposal has achieved majority,\n', '  //                        updating the state and sending an event if it has\n', '  //\n', '  //    this can be called by anyone, because the ecliptic does not\n', '  //    need to be aware of the result\n', '  //\n', '  function updateDocumentPoll(bytes32 _proposal)\n', '    public\n', '    returns (bool majority)\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!documentHasAchievedMajority[_proposal]);\n', '\n', '    //  check for majority in the poll\n', '    //\n', '    Poll storage poll = documentPolls[_proposal];\n', '    majority = checkPollMajority(poll);\n', '\n', '    //  if majority was achieved, update state and send an event\n', '    //\n', '    if (majority)\n', '    {\n', '      documentHasAchievedMajority[_proposal] = true;\n', '      documentMajorities.push(_proposal);\n', '      emit DocumentMajority(_proposal);\n', '    }\n', '    return majority;\n', '  }\n', '\n', '  //  checkPollMajority(): returns true if the majority is in favor of\n', '  //                       the subject of the poll\n', '  //\n', '  function checkPollMajority(Poll _poll)\n', '    internal\n', '    view\n', '    returns (bool majority)\n', '  {\n', '    return ( //  poll must have at least the minimum required yes-votes\n', '             //\n', '             (_poll.yesVotes >= (totalVoters / 4)) &&\n', '             //\n', '             //  and have a majority...\n', '             //\n', '             (_poll.yesVotes > _poll.noVotes) &&\n', '             //\n', '             //  ...that is indisputable\n', '             //\n', '             ( //  either because the poll has ended\n', '               //\n', '               (block.timestamp > _poll.start.add(_poll.duration)) ||\n', '               //\n', '               //  or there are more yes votes than there can be no votes\n', '               //\n', '               ( _poll.yesVotes > totalVoters.sub(_poll.yesVotes) ) ) );\n', '  }\n', '}\n', '\n', '// Azimuth&#39;s Claims.sol\n', '\n', '//  Claims: simple identity management\n', '//\n', '//    This contract allows points to document claims about their owner.\n', '//    Most commonly, these are about identity, with a claim&#39;s protocol\n', '//    defining the context or platform of the claim, and its dossier\n', '//    containing proof of its validity.\n', '//    Points are limited to a maximum of 16 claims.\n', '//\n', '//    For existing claims, the dossier can be updated, or the claim can\n', '//    be removed entirely. It is recommended to remove any claims associated\n', '//    with a point when it is about to be transferred to a new owner.\n', '//    For convenience, the owner of the Azimuth contract (the Ecliptic)\n', '//    is allowed to clear claims for any point, allowing it to do this for\n', '//    you on-transfer.\n', '//\n', 'contract Claims is ReadsAzimuth\n', '{\n', '  //  ClaimAdded: a claim was added by :by\n', '  //\n', '  event ClaimAdded( uint32 indexed by,\n', '                    string _protocol,\n', '                    string _claim,\n', '                    bytes _dossier );\n', '\n', '  //  ClaimRemoved: a claim was removed by :by\n', '  //\n', '  event ClaimRemoved(uint32 indexed by, string _protocol, string _claim);\n', '\n', '  //  maxClaims: the amount of claims that can be registered per point\n', '  //\n', '  uint8 constant maxClaims = 16;\n', '\n', '  //  Claim: claim details\n', '  //\n', '  struct Claim\n', '  {\n', '    //  protocol: context of the claim\n', '    //\n', '    string protocol;\n', '\n', '    //  claim: the claim itself\n', '    //\n', '    string claim;\n', '\n', '    //  dossier: data relating to the claim, as proof\n', '    //\n', '    bytes dossier;\n', '  }\n', '\n', '  //  per point, list of claims\n', '  //\n', '  mapping(uint32 => Claim[maxClaims]) public claims;\n', '\n', '  //  constructor(): register the azimuth contract.\n', '  //\n', '  constructor(Azimuth _azimuth)\n', '    ReadsAzimuth(_azimuth)\n', '    public\n', '  {\n', '    //\n', '  }\n', '\n', '  //  addClaim(): register a claim as _point\n', '  //\n', '  function addClaim(uint32 _point,\n', '                    string _protocol,\n', '                    string _claim,\n', '                    bytes _dossier)\n', '    external\n', '    activePointManager(_point)\n', '  {\n', '    //  cur: index + 1 of the claim if it already exists, 0 otherwise\n', '    //\n', '    uint8 cur = findClaim(_point, _protocol, _claim);\n', '\n', '    //  if the claim doesn&#39;t yet exist, store it in state\n', '    //\n', '    if (cur == 0)\n', '    {\n', '      //  if there are no empty slots left, this throws\n', '      //\n', '      uint8 empty = findEmptySlot(_point);\n', '      claims[_point][empty] = Claim(_protocol, _claim, _dossier);\n', '    }\n', '    //\n', '    //  if the claim has been made before, update the version in state\n', '    //\n', '    else\n', '    {\n', '      claims[_point][cur-1] = Claim(_protocol, _claim, _dossier);\n', '    }\n', '    emit ClaimAdded(_point, _protocol, _claim, _dossier);\n', '  }\n', '\n', '  //  removeClaim(): unregister a claim as _point\n', '  //\n', '  function removeClaim(uint32 _point, string _protocol, string _claim)\n', '    external\n', '    activePointManager(_point)\n', '  {\n', '    //  i: current index + 1 in _point&#39;s list of claims\n', '    //\n', '    uint256 i = findClaim(_point, _protocol, _claim);\n', '\n', '    //  we store index + 1, because 0 is the eth default value\n', '    //  can only delete an existing claim\n', '    //\n', '    require(i > 0);\n', '    i--;\n', '\n', '    //  clear out the claim\n', '    //\n', '    delete claims[_point][i];\n', '\n', '    emit ClaimRemoved(_point, _protocol, _claim);\n', '  }\n', '\n', '  //  clearClaims(): unregister all of _point&#39;s claims\n', '  //\n', '  //    can also be called by the ecliptic during point transfer\n', '  //\n', '  function clearClaims(uint32 _point)\n', '    external\n', '  {\n', '    //  both point owner and ecliptic may do this\n', '    //\n', '    //    We do not necessarily need to check for _point&#39;s active flag here,\n', '    //    since inactive points cannot have claims set. Doing the check\n', '    //    anyway would make this function slightly harder to think about due\n', '    //    to its relation to Ecliptic&#39;s transferPoint().\n', '    //\n', '    require( azimuth.canManage(_point, msg.sender) ||\n', '             ( msg.sender == azimuth.owner() ) );\n', '\n', '    Claim[maxClaims] storage currClaims = claims[_point];\n', '\n', '    //  clear out all claims\n', '    //\n', '    for (uint8 i = 0; i < maxClaims; i++)\n', '    {\n', '      delete currClaims[i];\n', '    }\n', '  }\n', '\n', '  //  findClaim(): find the index of the specified claim\n', '  //\n', '  //    returns 0 if not found, index + 1 otherwise\n', '  //\n', '  function findClaim(uint32 _whose, string _protocol, string _claim)\n', '    public\n', '    view\n', '    returns (uint8 index)\n', '  {\n', '    //  we use hashes of the string because solidity can&#39;t do string\n', '    //  comparison yet\n', '    //\n', '    bytes32 protocolHash = keccak256(bytes(_protocol));\n', '    bytes32 claimHash = keccak256(bytes(_claim));\n', '    Claim[maxClaims] storage theirClaims = claims[_whose];\n', '    for (uint8 i = 0; i < maxClaims; i++)\n', '    {\n', '      Claim storage thisClaim = theirClaims[i];\n', '      if ( ( protocolHash == keccak256(bytes(thisClaim.protocol)) ) &&\n', '           ( claimHash == keccak256(bytes(thisClaim.claim)) ) )\n', '      {\n', '        return i+1;\n', '      }\n', '    }\n', '    return 0;\n', '  }\n', '\n', '  //  findEmptySlot(): find the index of the first empty claim slot\n', '  //\n', '  //    returns the index of the slot, throws if there are no empty slots\n', '  //\n', '  function findEmptySlot(uint32 _whose)\n', '    internal\n', '    view\n', '    returns (uint8 index)\n', '  {\n', '    Claim[maxClaims] storage theirClaims = claims[_whose];\n', '    for (uint8 i = 0; i < maxClaims; i++)\n', '    {\n', '      Claim storage thisClaim = theirClaims[i];\n', '      if ( (0 == bytes(thisClaim.protocol).length) &&\n', '           (0 == bytes(thisClaim.claim).length) )\n', '      {\n', '        return i;\n', '      }\n', '    }\n', '    revert();\n', '  }\n', '}\n', '\n', '// Azimuth&#39;s EclipticBase.sol\n', '\n', '//  EclipticBase: upgradable ecliptic\n', '//\n', '//    This contract implements the upgrade logic for the Ecliptic.\n', '//    Newer versions of the Ecliptic are expected to provide at least\n', '//    the onUpgrade() function. If they don&#39;t, upgrading to them will\n', '//    fail.\n', '//\n', '//    Note that even though this contract doesn&#39;t specify any required\n', '//    interface members aside from upgrade() and onUpgrade(), contracts\n', '//    and clients may still rely on the presence of certain functions\n', '//    provided by the Ecliptic proper. Keep this in mind when writing\n', '//    new versions of it.\n', '//\n', 'contract EclipticBase is Ownable, ReadsAzimuth\n', '{\n', '  //  Upgraded: _to is the new canonical Ecliptic\n', '  //\n', '  event Upgraded(address to);\n', '\n', '  //  polls: senate voting contract\n', '  //\n', '  Polls public polls;\n', '\n', '  //  previousEcliptic: address of the previous ecliptic this\n', '  //                    instance expects to upgrade from, stored and\n', '  //                    checked for to prevent unexpected upgrade paths\n', '  //\n', '  address public previousEcliptic;\n', '\n', '  constructor( address _previous,\n', '               Azimuth _azimuth,\n', '               Polls _polls )\n', '    ReadsAzimuth(_azimuth)\n', '    internal\n', '  {\n', '    previousEcliptic = _previous;\n', '    polls = _polls;\n', '  }\n', '\n', '  //  onUpgrade(): called by previous ecliptic when upgrading\n', '  //\n', '  //    in future ecliptics, this might perform more logic than\n', '  //    just simple checks and verifications.\n', '  //    when overriding this, make sure to call this original as well.\n', '  //\n', '  function onUpgrade()\n', '    external\n', '  {\n', '    //  make sure this is the expected upgrade path,\n', '    //  and that we have gotten the ownership we require\n', '    //\n', '    require( msg.sender == previousEcliptic &&\n', '             this == azimuth.owner() &&\n', '             this == polls.owner() );\n', '  }\n', '\n', '  //  upgrade(): transfer ownership of the ecliptic data to the new\n', '  //             ecliptic contract, notify it, then self-destruct.\n', '  //\n', '  //    Note: any eth that have somehow ended up in this contract\n', '  //          are also sent to the new ecliptic.\n', '  //\n', '  function upgrade(EclipticBase _new)\n', '    internal\n', '  {\n', '    //  transfer ownership of the data contracts\n', '    //\n', '    azimuth.transferOwnership(_new);\n', '    polls.transferOwnership(_new);\n', '\n', '    //  trigger upgrade logic on the target contract\n', '    //\n', '    _new.onUpgrade();\n', '\n', '    //  emit event and destroy this contract\n', '    //\n', '    emit Upgraded(_new);\n', '    selfdestruct(_new);\n', '  }\n', '}\n', '\n', '// Azimuth&#39;s Ecliptic.sol\n', '\n', '//  Ecliptic: logic for interacting with the Azimuth ledger\n', '//\n', '//    This contract is the point of entry for all operations on the Azimuth\n', '//    ledger as stored in the Azimuth data contract. The functions herein\n', '//    are responsible for performing all necessary business logic.\n', '//    Examples of such logic include verifying permissions of the caller\n', '//    and ensuring a requested change is actually valid.\n', '//    Point owners can always operate on their own points. Ethereum addresses\n', '//    can also perform specific operations if they&#39;ve been given the\n', '//    appropriate permissions. (For example, managers for general management,\n', '//    spawn proxies for spawning child points, etc.)\n', '//\n', '//    This contract uses external contracts (Azimuth, Polls) for data storage\n', '//    so that it itself can easily be replaced in case its logic needs to\n', '//    be changed. In other words, it can be upgraded. It does this by passing\n', '//    ownership of the data contracts to a new Ecliptic contract.\n', '//\n', '//    Because of this, it is advised for clients to not store this contract&#39;s\n', '//    address directly, but rather ask the Azimuth contract for its owner\n', '//    attribute to ensure transactions get sent to the latest Ecliptic.\n', '//    Alternatively, the ENS name ecliptic.eth will resolve to the latest\n', '//    Ecliptic as well.\n', '//\n', '//    Upgrading happens based on polls held by the senate (galaxy owners).\n', '//    Through this contract, the senate can submit proposals, opening polls\n', '//    for the senate to cast votes on. These proposals can be either hashes\n', '//    of documents or addresses of new Ecliptics.\n', '//    If an ecliptic proposal gains majority, this contract will transfer\n', '//    ownership of the data storage contracts to that address, so that it may\n', '//    operate on the data they contain. This contract will selfdestruct at\n', '//    the end of the upgrade process.\n', '//\n', '//    This contract implements the ERC721 interface for non-fungible tokens,\n', '//    allowing points to be managed using generic clients that support the\n', '//    standard. It also implements ERC165 to allow this to be discovered.\n', '//\n', 'contract Ecliptic is EclipticBase, SupportsInterfaceWithLookup, ERC721Metadata\n', '{\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  //  Transfer: This emits when ownership of any NFT changes by any mechanism.\n', '  //            This event emits when NFTs are created (`from` == 0) and\n', '  //            destroyed (`to` == 0). At the time of any transfer, the\n', '  //            approved address for that NFT (if any) is reset to none.\n', '  //\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '  //  Approval: This emits when the approved address for an NFT is changed or\n', '  //            reaffirmed. The zero address indicates there is no approved\n', '  //            address. When a Transfer event emits, this also indicates that\n', '  //            the approved address for that NFT (if any) is reset to none.\n', '  //\n', '  event Approval(address indexed _owner, address indexed _approved,\n', '                 uint256 _tokenId);\n', '\n', '  //  ApprovalForAll: This emits when an operator is enabled or disabled for an\n', '  //                  owner. The operator can manage all NFTs of the owner.\n', '  //\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator,\n', '                       bool _approved);\n', '\n', '  // erc721Received: equal to:\n', '  //        bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))\n', '  //                 which can be also obtained as:\n', '  //        ERC721Receiver(0).onERC721Received.selector`\n', '  bytes4 constant erc721Received = 0x150b7a02;\n', '\n', '  //  claims: contract reference, for clearing claims on-transfer\n', '  //\n', '  Claims public claims;\n', '\n', '  //  constructor(): set data contract addresses and signal interface support\n', '  //\n', '  //    Note: during first deploy, ownership of these data contracts must\n', '  //    be manually transferred to this contract.\n', '  //\n', '  constructor(address _previous,\n', '              Azimuth _azimuth,\n', '              Polls _polls,\n', '              Claims _claims)\n', '    EclipticBase(_previous, _azimuth, _polls)\n', '    public\n', '  {\n', '    claims = _claims;\n', '\n', '    //  register supported interfaces for ERC165\n', '    //\n', '    _registerInterface(0x80ac58cd); // ERC721\n', '    _registerInterface(0x5b5e139f); // ERC721Metadata\n', '    _registerInterface(0x7f5828d0); // ERC173 (ownership)\n', '  }\n', '\n', '  //\n', '  //  ERC721 interface\n', '  //\n', '\n', '    //  balanceOf(): get the amount of points owned by _owner\n', '    //\n', '    function balanceOf(address _owner)\n', '      public\n', '      view\n', '      returns (uint256 balance)\n', '    {\n', '      require(0x0 != _owner);\n', '      return azimuth.getOwnedPointCount(_owner);\n', '    }\n', '\n', '    //  ownerOf(): get the current owner of point _tokenId\n', '    //\n', '    function ownerOf(uint256 _tokenId)\n', '      public\n', '      view\n', '      validPointId(_tokenId)\n', '      returns (address owner)\n', '    {\n', '      uint32 id = uint32(_tokenId);\n', '\n', '      //  this will throw if the owner is the zero address,\n', '      //  active points always have a valid owner.\n', '      //\n', '      require(azimuth.isActive(id));\n', '\n', '      return azimuth.getOwner(id);\n', '    }\n', '\n', '    //  exists(): returns true if point _tokenId is active\n', '    //\n', '    function exists(uint256 _tokenId)\n', '      public\n', '      view\n', '      returns (bool doesExist)\n', '    {\n', '      return ( (_tokenId < 0x100000000) &&\n', '               azimuth.isActive(uint32(_tokenId)) );\n', '    }\n', '\n', '    //  safeTransferFrom(): transfer point _tokenId from _from to _to\n', '    //\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n', '      public\n', '    {\n', '      //  transfer with empty data\n', '      //\n', '      safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    //  safeTransferFrom(): transfer point _tokenId from _from to _to,\n', '    //                      and call recipient if it&#39;s a contract\n', '    //\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId,\n', '                              bytes _data)\n', '      public\n', '    {\n', '      //  perform raw transfer\n', '      //\n', '      transferFrom(_from, _to, _tokenId);\n', '\n', '      //  do the callback last to avoid re-entrancy\n', '      //\n', '      if (_to.isContract())\n', '      {\n', '        bytes4 retval = ERC721Receiver(_to)\n', '                        .onERC721Received(msg.sender, _from, _tokenId, _data);\n', '        //\n', '        //  standard return idiom to confirm contract semantics\n', '        //\n', '        require(retval == erc721Received);\n', '      }\n', '    }\n', '\n', '    //  transferFrom(): transfer point _tokenId from _from to _to,\n', '    //                  WITHOUT notifying recipient contract\n', '    //\n', '    function transferFrom(address _from, address _to, uint256 _tokenId)\n', '      public\n', '      validPointId(_tokenId)\n', '    {\n', '      uint32 id = uint32(_tokenId);\n', '      require(azimuth.isOwner(id, _from));\n', '\n', '      //  the ERC721 operator/approved address (if any) is\n', '      //  accounted for in transferPoint()\n', '      //\n', '      transferPoint(id, _to, true);\n', '    }\n', '\n', '    //  approve(): allow _approved to transfer ownership of point\n', '    //             _tokenId\n', '    //\n', '    function approve(address _approved, uint256 _tokenId)\n', '      public\n', '      validPointId(_tokenId)\n', '    {\n', '      setTransferProxy(uint32(_tokenId), _approved);\n', '    }\n', '\n', '    //  setApprovalForAll(): allow or disallow _operator to\n', '    //                       transfer ownership of ALL points\n', '    //                       owned by :msg.sender\n', '    //\n', '    function setApprovalForAll(address _operator, bool _approved)\n', '      public\n', '    {\n', '      require(0x0 != _operator);\n', '      azimuth.setOperator(msg.sender, _operator, _approved);\n', '      emit ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '\n', '    //  getApproved(): get the approved address for point _tokenId\n', '    //\n', '    function getApproved(uint256 _tokenId)\n', '      public\n', '      view\n', '      validPointId(_tokenId)\n', '      returns (address approved)\n', '    {\n', '      //NOTE  redundant, transfer proxy cannot be set for\n', '      //      inactive points\n', '      //\n', '      require(azimuth.isActive(uint32(_tokenId)));\n', '      return azimuth.getTransferProxy(uint32(_tokenId));\n', '    }\n', '\n', '    //  isApprovedForAll(): returns true if _operator is an\n', '    //                      operator for _owner\n', '    //\n', '    function isApprovedForAll(address _owner, address _operator)\n', '      public\n', '      view\n', '      returns (bool result)\n', '    {\n', '      return azimuth.isOperator(_owner, _operator);\n', '    }\n', '\n', '  //\n', '  //  ERC721Metadata interface\n', '  //\n', '\n', '    //  name(): returns the name of a collection of points\n', '    //\n', '    function name()\n', '      external\n', '      view\n', '      returns (string)\n', '    {\n', '      return "Azimuth Points";\n', '    }\n', '\n', '    //  symbol(): returns an abbreviates name for points\n', '    //\n', '    function symbol()\n', '      external\n', '      view\n', '      returns (string)\n', '    {\n', '      return "AZP";\n', '    }\n', '\n', '    //  tokenURI(): returns a URL to an ERC-721 standard JSON file\n', '    //\n', '    function tokenURI(uint256 _tokenId)\n', '      public\n', '      view\n', '      validPointId(_tokenId)\n', '      returns (string _tokenURI)\n', '    {\n', '      _tokenURI = "https://azimuth.network/erc721/0000000000.json";\n', '      bytes memory _tokenURIBytes = bytes(_tokenURI);\n', '      _tokenURIBytes[31] = byte(48+(_tokenId / 1000000000) % 10);\n', '      _tokenURIBytes[32] = byte(48+(_tokenId / 100000000) % 10);\n', '      _tokenURIBytes[33] = byte(48+(_tokenId / 10000000) % 10);\n', '      _tokenURIBytes[34] = byte(48+(_tokenId / 1000000) % 10);\n', '      _tokenURIBytes[35] = byte(48+(_tokenId / 100000) % 10);\n', '      _tokenURIBytes[36] = byte(48+(_tokenId / 10000) % 10);\n', '      _tokenURIBytes[37] = byte(48+(_tokenId / 1000) % 10);\n', '      _tokenURIBytes[38] = byte(48+(_tokenId / 100) % 10);\n', '      _tokenURIBytes[39] = byte(48+(_tokenId / 10) % 10);\n', '      _tokenURIBytes[40] = byte(48+(_tokenId / 1) % 10);\n', '    }\n', '\n', '  //\n', '  //  Points interface\n', '  //\n', '\n', '    //  configureKeys(): configure _point with network public keys\n', '    //                   _encryptionKey, _authenticationKey,\n', '    //                   and corresponding _cryptoSuiteVersion,\n', '    //                   incrementing the point&#39;s continuity number if needed\n', '    //\n', '    function configureKeys(uint32 _point,\n', '                           bytes32 _encryptionKey,\n', '                           bytes32 _authenticationKey,\n', '                           uint32 _cryptoSuiteVersion,\n', '                           bool _discontinuous)\n', '      external\n', '      activePointManager(_point)\n', '    {\n', '      if (_discontinuous)\n', '      {\n', '        azimuth.incrementContinuityNumber(_point);\n', '      }\n', '      azimuth.setKeys(_point,\n', '                      _encryptionKey,\n', '                      _authenticationKey,\n', '                      _cryptoSuiteVersion);\n', '    }\n', '\n', '    //  spawn(): spawn _point, then either give, or allow _target to take,\n', '    //           ownership of _point\n', '    //\n', '    //    if _target is the :msg.sender, _targets owns the _point right away.\n', '    //    otherwise, _target becomes the transfer proxy of _point.\n', '    //\n', '    //    Requirements:\n', '    //    - _point must not be active\n', '    //    - _point must not be a planet with a galaxy prefix\n', '    //    - _point&#39;s prefix must be linked and under its spawn limit\n', '    //    - :msg.sender must be either the owner of _point&#39;s prefix,\n', '    //      or an authorized spawn proxy for it\n', '    //\n', '    function spawn(uint32 _point, address _target)\n', '      external\n', '    {\n', '      //  only currently unowned (and thus also inactive) points can be spawned\n', '      //\n', '      require(azimuth.isOwner(_point, 0x0));\n', '\n', '      //  prefix: half-width prefix of _point\n', '      //\n', '      uint16 prefix = azimuth.getPrefix(_point);\n', '\n', '      //  only allow spawning of points of the size directly below the prefix\n', '      //\n', '      //    this is possible because of how the address space works,\n', '      //    but supporting it introduces complexity through broken assumptions.\n', '      //\n', '      //    example:\n', '      //    0x0000.0000 - galaxy zero\n', '      //    0x0000.0100 - the first star of galaxy zero\n', '      //    0x0001.0100 - the first planet of the first star\n', '      //    0x0001.0000 - the first planet of galaxy zero\n', '      //\n', '      require( (uint8(azimuth.getPointSize(prefix)) + 1) ==\n', '               uint8(azimuth.getPointSize(_point)) );\n', '\n', '      //  prefix point must be linked and able to spawn\n', '      //\n', '      require( (azimuth.hasBeenLinked(prefix)) &&\n', '               ( azimuth.getSpawnCount(prefix) <\n', '                 getSpawnLimit(prefix, block.timestamp) ) );\n', '\n', '      //  the owner of a prefix can always spawn its children;\n', '      //  other addresses need explicit permission (the role\n', '      //  of "spawnProxy" in the Azimuth contract)\n', '      //\n', '      require( azimuth.canSpawnAs(prefix, msg.sender) );\n', '\n', '      //  if the caller is spawning the point to themselves,\n', '      //  assume it knows what it&#39;s doing and resolve right away\n', '      //\n', '      if (msg.sender == _target)\n', '      {\n', '        doSpawn(_point, _target, true, 0x0);\n', '      }\n', '      //\n', '      //  when sending to a "foreign" address, enforce a withdraw pattern\n', '      //  making the _point prefix&#39;s owner the _point owner in the mean time\n', '      //\n', '      else\n', '      {\n', '        doSpawn(_point, _target, false, azimuth.getOwner(prefix));\n', '      }\n', '    }\n', '\n', '    //  doSpawn(): actual spawning logic, used in spawn(). creates _point,\n', '    //             making the _target its owner if _direct, or making the\n', '    //             _holder the owner and the _target the transfer proxy\n', '    //             if not _direct.\n', '    //\n', '    function doSpawn( uint32 _point,\n', '                      address _target,\n', '                      bool _direct,\n', '                      address _holder )\n', '      internal\n', '    {\n', '      //  register the spawn for _point&#39;s prefix, incrementing spawn count\n', '      //\n', '      azimuth.registerSpawned(_point);\n', '\n', '      //  if the spawn is _direct, assume _target knows what they&#39;re doing\n', '      //  and resolve right away\n', '      //\n', '      if (_direct)\n', '      {\n', '        //  make the point active and set its new owner\n', '        //\n', '        azimuth.activatePoint(_point);\n', '        azimuth.setOwner(_point, _target);\n', '\n', '        emit Transfer(0x0, _target, uint256(_point));\n', '      }\n', '      //\n', '      //  when spawning indirectly, enforce a withdraw pattern by approving\n', '      //  the _target for transfer of the _point instead.\n', '      //  we make the _holder the owner of this _point in the mean time,\n', '      //  so that it may cancel the transfer (un-approve) if _target flakes.\n', '      //  we don&#39;t make _point active yet, because it still doesn&#39;t really\n', '      //  belong to anyone.\n', '      //\n', '      else\n', '      {\n', '        //  have _holder hold on to the _point while _target gets to transfer\n', '        //  ownership of it\n', '        //\n', '        azimuth.setOwner(_point, _holder);\n', '        azimuth.setTransferProxy(_point, _target);\n', '\n', '        emit Transfer(0x0, _holder, uint256(_point));\n', '        emit Approval(_holder, _target, uint256(_point));\n', '      }\n', '    }\n', '\n', '    //  transferPoint(): transfer _point to _target, clearing all permissions\n', '    //                   data and keys if _reset is true\n', '    //\n', '    //    Note: the _reset flag is useful when transferring the point to\n', '    //    a recipient who doesn&#39;t trust the previous owner.\n', '    //\n', '    //    Requirements:\n', '    //    - :msg.sender must be either _point&#39;s current owner, authorized\n', '    //      to transfer _point, or authorized to transfer the current\n', '    //      owner&#39;s points (as in ERC721&#39;s operator)\n', '    //    - _target must not be the zero address\n', '    //\n', '    function transferPoint(uint32 _point, address _target, bool _reset)\n', '      public\n', '    {\n', '      //  transfer is legitimate if the caller is the current owner, or\n', '      //  an operator for the current owner, or the _point&#39;s transfer proxy\n', '      //\n', '      require(azimuth.canTransfer(_point, msg.sender));\n', '\n', '      //  if the point wasn&#39;t active yet, that means transferring it\n', '      //  is part of the "spawn" flow, so we need to activate it\n', '      //\n', '      if ( !azimuth.isActive(_point) )\n', '      {\n', '        azimuth.activatePoint(_point);\n', '      }\n', '\n', '      //  if the owner would actually change, change it\n', '      //\n', '      //    the only time this deliberately wouldn&#39;t be the case is when a\n', '      //    prefix owner wants to activate a spawned but untransferred child.\n', '      //\n', '      if ( !azimuth.isOwner(_point, _target) )\n', '      {\n', '        //  remember the previous owner, to be included in the Transfer event\n', '        //\n', '        address old = azimuth.getOwner(_point);\n', '\n', '        azimuth.setOwner(_point, _target);\n', '\n', '        //  according to ERC721, the approved address (here, transfer proxy)\n', '        //  gets cleared during every Transfer event\n', '        //\n', '        azimuth.setTransferProxy(_point, 0);\n', '\n', '        emit Transfer(old, _target, uint256(_point));\n', '      }\n', '\n', '      //  reset sensitive data\n', '      //  used when transferring the point to a new owner\n', '      //\n', '      if ( _reset )\n', '      {\n', '        //  clear the network public keys and break continuity,\n', '        //  but only if the point has already been linked\n', '        //\n', '        if ( azimuth.hasBeenLinked(_point) )\n', '        {\n', '          azimuth.incrementContinuityNumber(_point);\n', '          azimuth.setKeys(_point, 0, 0, 0);\n', '        }\n', '\n', '        //  clear management proxy\n', '        //\n', '        azimuth.setManagementProxy(_point, 0);\n', '\n', '        //  clear voting proxy\n', '        //\n', '        azimuth.setVotingProxy(_point, 0);\n', '\n', '        //  clear transfer proxy\n', '        //\n', '        //    in most cases this is done above, during the ownership transfer,\n', '        //    but we might not hit that and still be expected to reset the\n', '        //    transfer proxy.\n', '        //    doing it a second time is a no-op in Azimuth.\n', '        //\n', '        azimuth.setTransferProxy(_point, 0);\n', '\n', '        //  clear spawning proxy\n', '        //\n', '        azimuth.setSpawnProxy(_point, 0);\n', '\n', '        //  clear claims\n', '        //\n', '        claims.clearClaims(_point);\n', '      }\n', '    }\n', '\n', '    //  escape(): request escape as _point to _sponsor\n', '    //\n', '    //    if an escape request is already active, this overwrites\n', '    //    the existing request\n', '    //\n', '    //    Requirements:\n', '    //    - :msg.sender must be the owner or manager of _point,\n', '    //    - _point must be able to escape to _sponsor as per to canEscapeTo()\n', '    //\n', '    function escape(uint32 _point, uint32 _sponsor)\n', '      external\n', '      activePointManager(_point)\n', '    {\n', '      require(canEscapeTo(_point, _sponsor));\n', '      azimuth.setEscapeRequest(_point, _sponsor);\n', '    }\n', '\n', '    //  cancelEscape(): cancel the currently set escape for _point\n', '    //\n', '    function cancelEscape(uint32 _point)\n', '      external\n', '      activePointManager(_point)\n', '    {\n', '      azimuth.cancelEscape(_point);\n', '    }\n', '\n', '    //  adopt(): as the relevant sponsor, accept the _point\n', '    //\n', '    //    Requirements:\n', '    //    - :msg.sender must be the owner or management proxy\n', '    //      of _point&#39;s requested sponsor\n', '    //\n', '    function adopt(uint32 _point)\n', '      external\n', '    {\n', '      require( azimuth.isEscaping(_point) &&\n', '               azimuth.canManage( azimuth.getEscapeRequest(_point),\n', '                                  msg.sender ) );\n', '\n', '      //  _sponsor becomes _point&#39;s sponsor\n', '      //  its escape request is reset to "not escaping"\n', '      //\n', '      azimuth.doEscape(_point);\n', '    }\n', '\n', '    //  reject(): as the relevant sponsor, deny the _point&#39;s request\n', '    //\n', '    //    Requirements:\n', '    //    - :msg.sender must be the owner or management proxy\n', '    //      of _point&#39;s requested sponsor\n', '    //\n', '    function reject(uint32 _point)\n', '      external\n', '    {\n', '      require( azimuth.isEscaping(_point) &&\n', '               azimuth.canManage( azimuth.getEscapeRequest(_point),\n', '                                  msg.sender ) );\n', '\n', '      //  reset the _point&#39;s escape request to "not escaping"\n', '      //\n', '      azimuth.cancelEscape(_point);\n', '    }\n', '\n', '    //  detach(): as the _sponsor, stop sponsoring the _point\n', '    //\n', '    //    Requirements:\n', '    //    - :msg.sender must be the owner or management proxy\n', '    //      of _point&#39;s current sponsor\n', '    //\n', '    function detach(uint32 _point)\n', '      external\n', '    {\n', '      require( azimuth.hasSponsor(_point) &&\n', '               azimuth.canManage(azimuth.getSponsor(_point), msg.sender) );\n', '\n', '      //  signal that its sponsor no longer supports _point\n', '      //\n', '      azimuth.loseSponsor(_point);\n', '    }\n', '\n', '  //\n', '  //  Point rules\n', '  //\n', '\n', '    //  getSpawnLimit(): returns the total number of children the _point\n', '    //                   is allowed to spawn at _time.\n', '    //\n', '    function getSpawnLimit(uint32 _point, uint256 _time)\n', '      public\n', '      view\n', '      returns (uint32 limit)\n', '    {\n', '      Azimuth.Size size = azimuth.getPointSize(_point);\n', '\n', '      if ( size == Azimuth.Size.Galaxy )\n', '      {\n', '        return 255;\n', '      }\n', '      else if ( size == Azimuth.Size.Star )\n', '      {\n', '        //  in 2019, stars may spawn at most 1024 planets. this limit doubles\n', '        //  for every subsequent year.\n', '        //\n', '        //    Note: 1546300800 corresponds to 2019-01-01\n', '        //\n', '        uint256 yearsSince2019 = (_time - 1546300800) / 365 days;\n', '        if (yearsSince2019 < 6)\n', '        {\n', '          limit = uint32( 1024 * (2 ** yearsSince2019) );\n', '        }\n', '        else\n', '        {\n', '          limit = 65535;\n', '        }\n', '        return limit;\n', '      }\n', '      else  //  size == Azimuth.Size.Planet\n', '      {\n', '        //  planets can create moons, but moons aren&#39;t on the chain\n', '        //\n', '        return 0;\n', '      }\n', '    }\n', '\n', '    //  canEscapeTo(): true if _point could try to escape to _sponsor\n', '    //\n', '    function canEscapeTo(uint32 _point, uint32 _sponsor)\n', '      public\n', '      view\n', '      returns (bool canEscape)\n', '    {\n', '      //  can&#39;t escape to a sponsor that hasn&#39;t been linked\n', '      //\n', '      if ( !azimuth.hasBeenLinked(_sponsor) ) return false;\n', '\n', '      //  Can only escape to a point one size higher than ourselves,\n', '      //  except in the special case where the escaping point hasn&#39;t\n', '      //  been linked yet -- in that case we may escape to points of\n', '      //  the same size, to support lightweight invitation chains.\n', '      //\n', '      //  The use case for lightweight invitations is that a planet\n', '      //  owner should be able to invite their friends onto an\n', '      //  Azimuth network in a two-party transaction, without a new\n', '      //  star relationship.\n', '      //  The lightweight invitation process works by escaping your\n', '      //  own active (but never linked) point to one of your own\n', '      //  points, then transferring the point to your friend.\n', '      //\n', '      //  These planets can, in turn, sponsor other unlinked planets,\n', '      //  so the "planet sponsorship chain" can grow to arbitrary\n', '      //  length. Most users, especially deep down the chain, will\n', '      //  want to improve their performance by switching to direct\n', '      //  star sponsors eventually.\n', '      //\n', '      Azimuth.Size pointSize = azimuth.getPointSize(_point);\n', '      Azimuth.Size sponsorSize = azimuth.getPointSize(_sponsor);\n', '      return ( //  normal hierarchical escape structure\n', '               //\n', '               ( (uint8(sponsorSize) + 1) == uint8(pointSize) ) ||\n', '               //\n', '               //  special peer escape\n', '               //\n', '               ( (sponsorSize == pointSize) &&\n', '                 //\n', '                 //  peer escape is only for points that haven&#39;t been linked\n', '                 //  yet, because it&#39;s only for lightweight invitation chains\n', '                 //\n', '                 !azimuth.hasBeenLinked(_point) ) );\n', '    }\n', '\n', '  //\n', '  //  Permission management\n', '  //\n', '\n', '    //  setManagementProxy(): configure the management proxy for _point\n', '    //\n', '    //    The management proxy may perform "reversible" operations on\n', '    //    behalf of the owner. This includes public key configuration and\n', '    //    operations relating to sponsorship.\n', '    //\n', '    function setManagementProxy(uint32 _point, address _manager)\n', '      external\n', '      activePointOwner(_point)\n', '    {\n', '      azimuth.setManagementProxy(_point, _manager);\n', '    }\n', '\n', '    //  setSpawnProxy(): give _spawnProxy the right to spawn points\n', '    //                   with the prefix _prefix\n', '    //\n', '    function setSpawnProxy(uint16 _prefix, address _spawnProxy)\n', '      external\n', '      activePointOwner(_prefix)\n', '    {\n', '      azimuth.setSpawnProxy(_prefix, _spawnProxy);\n', '    }\n', '\n', '    //  setVotingProxy(): configure the voting proxy for _galaxy\n', '    //\n', '    //    the voting proxy is allowed to start polls and cast votes\n', '    //    on the point&#39;s behalf.\n', '    //\n', '    function setVotingProxy(uint8 _galaxy, address _voter)\n', '      external\n', '      activePointOwner(_galaxy)\n', '    {\n', '      azimuth.setVotingProxy(_galaxy, _voter);\n', '    }\n', '\n', '    //  setTransferProxy(): give _transferProxy the right to transfer _point\n', '    //\n', '    //    Requirements:\n', '    //    - :msg.sender must be either _point&#39;s current owner,\n', '    //      or be an operator for the current owner\n', '    //\n', '    function setTransferProxy(uint32 _point, address _transferProxy)\n', '      public\n', '    {\n', '      //  owner: owner of _point\n', '      //\n', '      address owner = azimuth.getOwner(_point);\n', '\n', '      //  caller must be :owner, or an operator designated by the owner.\n', '      //\n', '      require((owner == msg.sender) || azimuth.isOperator(owner, msg.sender));\n', '\n', '      //  set transfer proxy field in Azimuth contract\n', '      //\n', '      azimuth.setTransferProxy(_point, _transferProxy);\n', '\n', '      //  emit Approval event\n', '      //\n', '      emit Approval(owner, _transferProxy, uint256(_point));\n', '    }\n', '\n', '  //\n', '  //  Poll actions\n', '  //\n', '\n', '    //  startUpgradePoll(): as _galaxy, start a poll for the ecliptic\n', '    //                      upgrade _proposal\n', '    //\n', '    //    Requirements:\n', '    //    - :msg.sender must be the owner or voting proxy of _galaxy,\n', '    //    - the _proposal must expect to be upgraded from this specific\n', '    //      contract, as indicated by its previousEcliptic attribute\n', '    //\n', '    function startUpgradePoll(uint8 _galaxy, EclipticBase _proposal)\n', '      external\n', '      activePointVoter(_galaxy)\n', '    {\n', '      //  ensure that the upgrade target expects this contract as the source\n', '      //\n', '      require(_proposal.previousEcliptic() == address(this));\n', '      polls.startUpgradePoll(_proposal);\n', '    }\n', '\n', '    //  startDocumentPoll(): as _galaxy, start a poll for the _proposal\n', '    //\n', '    //    the _proposal argument is the keccak-256 hash of any arbitrary\n', '    //    document or string of text\n', '    //\n', '    function startDocumentPoll(uint8 _galaxy, bytes32 _proposal)\n', '      external\n', '      activePointVoter(_galaxy)\n', '    {\n', '      polls.startDocumentPoll(_proposal);\n', '    }\n', '\n', '    //  castUpgradeVote(): as _galaxy, cast a _vote on the ecliptic\n', '    //                     upgrade _proposal\n', '    //\n', '    //    _vote is true when in favor of the proposal, false otherwise\n', '    //\n', '    //    If this vote results in a majority for the _proposal, it will\n', '    //    be upgraded to immediately.\n', '    //\n', '    function castUpgradeVote(uint8 _galaxy,\n', '                              EclipticBase _proposal,\n', '                              bool _vote)\n', '      external\n', '      activePointVoter(_galaxy)\n', '    {\n', '      //  majority: true if the vote resulted in a majority, false otherwise\n', '      //\n', '      bool majority = polls.castUpgradeVote(_galaxy, _proposal, _vote);\n', '\n', '      //  if a majority is in favor of the upgrade, it happens as defined\n', '      //  in the ecliptic base contract\n', '      //\n', '      if (majority)\n', '      {\n', '        upgrade(_proposal);\n', '      }\n', '    }\n', '\n', '    //  castDocumentVote(): as _galaxy, cast a _vote on the _proposal\n', '    //\n', '    //    _vote is true when in favor of the proposal, false otherwise\n', '    //\n', '    function castDocumentVote(uint8 _galaxy, bytes32 _proposal, bool _vote)\n', '      external\n', '      activePointVoter(_galaxy)\n', '    {\n', '      polls.castDocumentVote(_galaxy, _proposal, _vote);\n', '    }\n', '\n', '    //  updateUpgradePoll(): check whether the _proposal has achieved\n', '    //                      majority, upgrading to it if it has\n', '    //\n', '    function updateUpgradePoll(EclipticBase _proposal)\n', '      external\n', '    {\n', '      //  majority: true if the poll ended in a majority, false otherwise\n', '      //\n', '      bool majority = polls.updateUpgradePoll(_proposal);\n', '\n', '      //  if a majority is in favor of the upgrade, it happens as defined\n', '      //  in the ecliptic base contract\n', '      //\n', '      if (majority)\n', '      {\n', '        upgrade(_proposal);\n', '      }\n', '    }\n', '\n', '    //  updateDocumentPoll(): check whether the _proposal has achieved majority\n', '    //\n', '    //    Note: the polls contract publicly exposes the function this calls,\n', '    //    but we offer it in the ecliptic interface as a convenience\n', '    //\n', '    function updateDocumentPoll(bytes32 _proposal)\n', '      external\n', '    {\n', '      polls.updateDocumentPoll(_proposal);\n', '    }\n', '\n', '  //\n', '  //  Contract owner operations\n', '  //\n', '\n', '    //  createGalaxy(): grant _target ownership of the _galaxy and register\n', '    //                  it for voting\n', '    //\n', '    function createGalaxy(uint8 _galaxy, address _target)\n', '      external\n', '      onlyOwner\n', '    {\n', '      //  only currently unowned (and thus also inactive) galaxies can be\n', '      //  created, and only to non-zero addresses\n', '      //\n', '      require( azimuth.isOwner(_galaxy, 0x0) &&\n', '               0x0 != _target );\n', '\n', '      //  new galaxy means a new registered voter\n', '      //\n', '      polls.incrementTotalVoters();\n', '\n', '      //  if the caller is sending the galaxy to themselves,\n', '      //  assume it knows what it&#39;s doing and resolve right away\n', '      //\n', '      if (msg.sender == _target)\n', '      {\n', '        doSpawn(_galaxy, _target, true, 0x0);\n', '      }\n', '      //\n', '      //  when sending to a "foreign" address, enforce a withdraw pattern,\n', '      //  making the caller the owner in the mean time\n', '      //\n', '      else\n', '      {\n', '        doSpawn(_galaxy, _target, false, msg.sender);\n', '      }\n', '    }\n', '\n', '    function setDnsDomains(string _primary, string _secondary, string _tertiary)\n', '      external\n', '      onlyOwner\n', '    {\n', '      azimuth.setDnsDomains(_primary, _secondary, _tertiary);\n', '    }\n', '\n', '  //\n', '  //  Function modifiers for this contract\n', '  //\n', '\n', '    //  validPointId(): require that _id is a valid point\n', '    //\n', '    modifier validPointId(uint256 _id)\n', '    {\n', '      require(_id < 0x100000000);\n', '      _;\n', '    }\n', '\n', '    //  activePointVoter(): require that :msg.sender can vote as _point,\n', '    //                      and that _point is active\n', '    //\n', '    modifier activePointVoter(uint32 _point)\n', '    {\n', '      require( azimuth.canVoteAs(_point, msg.sender) &&\n', '               azimuth.isActive(_point) );\n', '      _;\n', '    }\n', '}\n', '\n', '// Azimuth&#39;s TakesPoints.sol\n', '\n', 'contract TakesPoints is ReadsAzimuth\n', '{\n', '  constructor(Azimuth _azimuth)\n', '    ReadsAzimuth(_azimuth)\n', '    public\n', '  {\n', '    //\n', '  }\n', '\n', '  //  takePoint(): transfer _point to this contract. if _clean is true, require\n', '  //               that the point be unlinked.\n', '  //               returns true if this succeeds, false otherwise.\n', '  //\n', '  function takePoint(uint32 _point, bool _clean)\n', '    internal\n', '    returns (bool success)\n', '  {\n', '    Ecliptic ecliptic = Ecliptic(azimuth.owner());\n', '\n', '    //  There are two ways for a contract to get a point.\n', '    //  One way is for a prefix point to grant the contract permission to\n', '    //  spawn its points.\n', '    //  The contract will spawn the point directly to itself.\n', '    //\n', '    uint16 prefix = azimuth.getPrefix(_point);\n', '    if ( azimuth.isOwner(_point, 0x0) &&\n', '         azimuth.isOwner(prefix, msg.sender) &&\n', '         azimuth.isSpawnProxy(prefix, this) &&\n', '         (ecliptic.getSpawnLimit(prefix, now) > azimuth.getSpawnCount(prefix)) )\n', '    {\n', '      //  first model: spawn _point to :this contract\n', '      //\n', '      ecliptic.spawn(_point, this);\n', '      return true;\n', '    }\n', '\n', '    //  The second way is to accept existing points, optionally\n', '    //  requiring they be unlinked.\n', '    //  To deposit a point this way, the owner grants the contract\n', '    //  permission to transfer ownership of the point.\n', '    //  The contract will transfer the point to itself.\n', '    //\n', '    if ( (!_clean || !azimuth.hasBeenLinked(_point)) &&\n', '         azimuth.isOwner(_point, msg.sender) &&\n', '         azimuth.canTransfer(_point, this) )\n', '    {\n', '      //  second model: transfer active, unlinked _point to :this contract\n', '      //\n', '      ecliptic.transferPoint(_point, this, true);\n', '      return true;\n', '    }\n', '\n', '    //  point is not for us to take\n', '    //\n', '    return false;\n', '  }\n', '\n', '  //  givePoint(): transfer a _point we own to _to, optionally resetting.\n', '  //               returns true if this succeeds, false otherwise.\n', '  //\n', '  //    Note that _reset is unnecessary if the point was taken\n', '  //    using this contract&#39;s takePoint() function, which always\n', '  //    resets, and not touched since.\n', '  //\n', '  function givePoint(uint32 _point, address _to, bool _reset)\n', '    internal\n', '    returns (bool success)\n', '  {\n', '    //  only give points we&#39;ve taken, points we fully own\n', '    //\n', '    if (azimuth.isOwner(_point, this))\n', '    {\n', '      Ecliptic(azimuth.owner()).transferPoint(_point, _to, _reset);\n', '      return true;\n', '    }\n', '\n', '    //  point is not for us to give\n', '    //\n', '    return false;\n', '  }\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '//  ConditionalStarRelease\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '//  ConditionalStarRelease: star transfer over time, based on conditions\n', '//\n', '//    This contract allows its owner to transfer batches of stars to a\n', '//    recipient (also "participant") gradually over time, assuming\n', '//    the specified conditions are met.\n', '//\n', '//    This contract represents a single set of conditions and corresponding\n', '//    deadlines (up to eight) which get configured during contract creation.\n', '//    The conditions take the form of hashes, and they are checked for\n', '//    by looking at the Polls contract. A condition is met if it has\n', '//    achieved a majority in the Polls contract, or its deadline has\n', '//    passed.\n', '//    Completion timestamps are stored for each completed condition.\n', '//    They are equal to the time at which majority was observed, or\n', '//    the condition&#39;s deadline, whichever comes first.\n', '//\n', '//    An arbitrary number of participants (in the form of Ethereum\n', '//    addresses) can be registered with the contract.\n', '//    Per participant, the contract stores a commitment. This structure\n', '//    contains the details of the stars to be made available to the\n', '//    participant, configured during registration. This allows for\n', '//    per-participant configuration of the amount of stars they receive\n', '//    per condition, and at what rate these stars get released.\n', '//\n', '//    When a timestamp is set for a condition, the amount of stars in\n', '//    the batch corresponding to that condition is released to the\n', '//    participant at the rate specified in the commitment.\n', '//\n', '//    Stars deposited into the contracts for participants to (eventually)\n', '//    withdraw are treated on a last-in first-out basis.\n', '//\n', '//    If a condition&#39;s timestamp is equal to its deadline, participants\n', '//    have the option to forfeit the stars in the associated batch, only\n', '//    if they have not yet withdrawn from that batch. The participant will\n', '//    no longer be able to withdraw stars from the forfeited batch (they are\n', '//    to be collected by the contract owner), and the participant will settle\n', '//    compensation with the contract owner off-chain.\n', '//\n', '//    The contract owner can register commitments, deposit stars into\n', '//    them, and withdraw any stars that got forfeited.\n', '//    Participants can withdraw stars as they get released, and forfeit\n', '//    the remainder of their commitment if a deadline is missed.\n', '//    Anyone can check unsatisfied conditions for completion.\n', '//    If, after a specified date, any stars remain, the owner is able to\n', '//    withdraw them. This saves address space from being lost forever in case\n', '//    of key loss by participants.\n', '//\n', 'contract ConditionalStarRelease is Ownable, TakesPoints\n', '{\n', '  using SafeMath for uint256;\n', '  using SafeMath16 for uint16;\n', '\n', '  //  ConditionCompleted: :condition has either been met or missed\n', '  //\n', '  event ConditionCompleted(uint8 indexed condition, uint256 when);\n', '\n', '  //  Forfeit: :who has chosen to forfeit :batch, which contained\n', '  //           :stars number of stars\n', '  //\n', '  event Forfeit(address indexed who, uint8 batch, uint16 stars);\n', '\n', '  //  maxConditions: the max amount of conditions that can be configured\n', '  //\n', '  uint8 constant maxConditions = 8;\n', '\n', '  //  conditions: hashes for document proposals that must achieve majority\n', '  //              in the polls contract\n', '  //\n', '  //    a value of 0x0 is special-cased for azimuth initialization logic in\n', '  //    this implementation of the contract\n', '  //\n', '  bytes32[] public conditions;\n', '\n', '  //  livelines: dates before which the conditions cannot be registered as met.\n', '  //\n', '  uint256[] public livelines;\n', '\n', '  //  deadlines: deadlines by which conditions must have been met. if the\n', '  //             polls contract does not contain a majority vote for the\n', '  //             appropriate condition by the time its deadline is hit,\n', '  //             stars in a commitment can be forfeit and withdrawn by the\n', '  //             CSR contract owner.\n', '  //\n', '  uint256[] public deadlines;\n', '\n', '  //  timestamps: timestamps when conditions of the matching index were\n', '  //              hit; or 0 if not yet hit; or equal to the deadline if\n', '  //              the deadline was missed.\n', '  //\n', '  uint256[] public timestamps;\n', '\n', '  //  escapeHatchTime: date after which the contract owner can withdraw\n', '  //                   arbitrary stars\n', '  //\n', '  uint256 public escapeHatchDate;\n', '\n', '  //  Commitment: structure that mirrors a signed paper contract\n', '  //\n', '  //    While the ordering of the struct members is semantically chaotic,\n', '  //    they are ordered to tightly pack them into Ethereum&#39;s 32-byte storage\n', '  //    slots, which reduces gas costs for some function calls.\n', '  //    The comment ticks indicate assumed slot boundaries.\n', '  //\n', '  struct Commitment\n', '  {\n', '    //  stars: specific stars assigned to this commitment that have not yet\n', '    //         been withdrawn\n', '    //\n', '    uint16[] stars;\n', '  //\n', '    //  batches: number of stars to release per condition\n', '    //\n', '    uint16[] batches;\n', '  //\n', '    //  withdrawn: number of stars withdrawn per batch\n', '    //\n', '    uint16[] withdrawn;\n', '  //\n', '    //  forfeited: whether the stars in a batch have been forfeited\n', '    //             by the recipient\n', '    //\n', '    bool[] forfeited;\n', '  //\n', '    //  rateUnit: amount of time it takes for the next :rate stars to be\n', '    //            released\n', '    //\n', '    uint256 rateUnit;\n', '  //\n', '    //  approvedTransferTo: batch can be transferred to this address\n', '    //\n', '    address approvedTransferTo;\n', '\n', '    //  total: sum of stars in all batches\n', '    //\n', '    uint16 total;\n', '\n', '    //  rate: number of stars released per unlocked batch per :rateUnit\n', '    //\n', '    uint16 rate;\n', '  }\n', '\n', '  //  commitments: per participant, the registered purchase agreement\n', '  //\n', '  mapping(address => Commitment) public commitments;\n', '\n', '  //  constructor(): configure conditions and deadlines\n', '  //\n', '  constructor( Azimuth _azimuth,\n', '               bytes32[] _conditions,\n', '               uint256[] _livelines,\n', '               uint256[] _deadlines,\n', '               uint256 _escapeHatchDate )\n', '    TakesPoints(_azimuth)\n', '    public\n', '  {\n', '    //  sanity check: limited conditions, liveline and deadline per condition,\n', '    //  and fair escape hatch\n', '    //\n', '    require( _conditions.length > 0 &&\n', '             _conditions.length <= maxConditions &&\n', '             _livelines.length == _conditions.length &&\n', '             _deadlines.length == _conditions.length &&\n', '             _escapeHatchDate > _deadlines[_deadlines.length.sub(1)] );\n', '\n', '    //  install conditions and deadlines, and prepare timestamps array\n', '    //\n', '    conditions = _conditions;\n', '    livelines = _livelines;\n', '    deadlines = _deadlines;\n', '    timestamps.length = _conditions.length;\n', '    escapeHatchDate = _escapeHatchDate;\n', '\n', '    //  check if the first condition is met, it might get cleared immediately\n', '    //\n', '    analyzeCondition(0);\n', '  }\n', '\n', '  //\n', '  //  Functions for the contract owner\n', '  //\n', '\n', '    //  register(): register a new commitment\n', '    //\n', '    function register( //  _participant: address of the paper contract signer\n', '                       //  _batches: number of stars releasing per batch\n', '                       //  _rate: number of stars that unlock per _rateUnit\n', '                       //  _rateUnit: amount of time it takes for the next\n', '                       //             _rate stars to unlock\n', '                       //\n', '                       address _participant,\n', '                       uint16[] _batches,\n', '                       uint16 _rate,\n', '                       uint256 _rateUnit )\n', '      external\n', '      onlyOwner\n', '    {\n', '      Commitment storage com = commitments[_participant];\n', '\n', '      //  make sure this participant doesn&#39;t already have a commitment\n', '      //\n', '      require(0 == com.total);\n', '\n', '      //  for every condition/deadline, a batch release amount must be\n', '      //  specified, even if it&#39;s zero\n', '      //\n', '      require(_batches.length == conditions.length);\n', '\n', '      //  make sure a sane rate is submitted\n', '      //\n', '      require( (_rate > 0) &&\n', '               (_rateUnit > 0) );\n', '\n', '      //  make sure we&#39;re not promising more than we can possibly give\n', '      //\n', '      uint16 total = arraySum(_batches);\n', '      require( (total > 0) &&\n', '               (total <= 0xff00) );\n', '\n', '      //  register into state\n', '      //\n', '      com.batches = _batches;\n', '      com.total = total;\n', '      com.withdrawn.length = _batches.length;\n', '      com.forfeited.length = _batches.length;\n', '      com.rate = _rate;\n', '      com.rateUnit = _rateUnit;\n', '    }\n', '\n', '    //  deposit(): deposit a star into this contract for later withdrawal\n', '    //\n', '    function deposit(address _participant, uint16 _star)\n', '      external\n', '      onlyOwner\n', '    {\n', '      Commitment storage com = commitments[_participant];\n', '\n', '      //  ensure we can only deposit stars, and that we can&#39;t deposit\n', '      //  more stars than necessary\n', '      //\n', '      require( (_star > 0xff) &&\n', '               ( com.stars.length <\n', '                 com.total.sub( arraySum(com.withdrawn) ) ) );\n', '\n', '      //  have the contract take ownership of the star if possible,\n', '      //  reverting if that fails.\n', '      //\n', '      require( takePoint(_star, true) );\n', '\n', '      //  add _star to the participant&#39;s star balance\n', '      //\n', '      com.stars.push(_star);\n', '    }\n', '\n', '    //  withdrawForfeited(): withdraw one star, from _participant&#39;s forfeited\n', '    //                       _batch, to _to\n', '    //\n', '    function withdrawForfeited(address _participant, uint8 _batch, address _to)\n', '      external\n', '      onlyOwner\n', '    {\n', '      Commitment storage com = commitments[_participant];\n', '\n', '      //  withdraw is possible only if the participant has forfeited this batch,\n', '      //  and there&#39;s still stars there left to withdraw\n', '      //\n', '      require( com.forfeited[_batch] &&\n', '               (com.withdrawn[_batch] < com.batches[_batch]) &&\n', '               (0 < com.stars.length) );\n', '\n', '      //  update contract state\n', '      //\n', '      com.withdrawn[_batch] = com.withdrawn[_batch].add(1);\n', '\n', '      //  withdraw a star from the commitment (don&#39;t reset it because\n', '      //  no one whom we don&#39;t trust has ever had control of it)\n', '      //\n', '      performWithdraw(com, _to, false);\n', '    }\n', '\n', '    //  withdrawOverdue(): withdraw arbitrary star from the contract\n', '    //\n', '    //    this functions as an escape hatch in the case of key loss,\n', '    //    to prevent blocks of address space from being lost permanently.\n', '    //\n', '    //    we don&#39;t bother with specifying a batch or doing any kind of\n', '    //    book-keeping, because at this point in time we don&#39;t care about\n', '    //    that anymore.\n', '    //\n', '    function withdrawOverdue(address _participant, address _to)\n', '      external\n', '      onlyOwner\n', '    {\n', '      //  this can only be done after the :escapeHatchDate\n', '      //\n', '      require(block.timestamp > escapeHatchDate);\n', '\n', '      Commitment storage com = commitments[_participant];\n', '      require(0 < com.stars.length);\n', '\n', '      //  withdraw a star from the commitment (don&#39;t reset it because\n', '      //  no one whom we don&#39;t trust has ever had control of it)\n', '      //\n', '      performWithdraw(com, _to, false);\n', '    }\n', '\n', '  //\n', '  //  Functions for participants\n', '  //\n', '\n', '    //  approveCommitmentTransfer(): allow transfer of the commitment to/by _to\n', '    //\n', '    function approveCommitmentTransfer(address _to)\n', '      external\n', '    {\n', '      //  make sure the caller is a participant,\n', '      //  and that the target isn&#39;t\n', '      //\n', '      require( 0 != commitments[msg.sender].total &&\n', '               0 == commitments[_to].total );\n', '      commitments[msg.sender].approvedTransferTo = _to;\n', '    }\n', '\n', '    //  transferCommitment(): make an approved transfer of _from&#39;s commitment\n', '    //                        to the caller&#39;s address\n', '    //\n', '    function transferCommitment(address _from)\n', '      external\n', '    {\n', '      //  make sure the :msg.sender is authorized to make this transfer\n', '      //\n', '      require(commitments[_from].approvedTransferTo == msg.sender);\n', '\n', '      //  make sure the target isn&#39;t also a participant again,\n', '      //  this could have changed since approveCommitmentTransfer\n', '      //\n', '      require(0 == commitments[msg.sender].total);\n', '\n', '      //  copy the commitment to the :msg.sender and clear _from&#39;s\n', '      //\n', '      Commitment storage com = commitments[_from];\n', '      commitments[msg.sender] = com;\n', '      delete commitments[_from];\n', '    }\n', '\n', '    //  withdrawToSelf(): withdraw one star from the :msg.sender&#39;s commitment&#39;s\n', '    //                    _batch to :msg.sender\n', '    //\n', '    function withdrawToSelf(uint8 _batch)\n', '      external\n', '    {\n', '      withdraw(_batch, msg.sender);\n', '    }\n', '\n', '    //  withdraw(): withdraw one star from the :msg.sender&#39;s commitment&#39;s\n', '    //              _batch to _to\n', '    //\n', '    function withdraw(uint8 _batch, address _to)\n', '      public\n', '    {\n', '      Commitment storage com = commitments[msg.sender];\n', '\n', '      //  to withdraw, the participant must have a star balance,\n', '      //  be under their current withdrawal limit, and cannot\n', '      //  withdraw forfeited stars\n', '      //\n', '      require( (com.stars.length > 0) &&\n', '               (com.withdrawn[_batch] < withdrawLimit(msg.sender, _batch)) &&\n', '               !com.forfeited[_batch] );\n', '\n', '      //  update contract state\n', '      //\n', '      com.withdrawn[_batch] = com.withdrawn[_batch].add(1);\n', '\n', '      //  withdraw a star from the commitment\n', '      //\n', '      performWithdraw(com, _to, true);\n', '    }\n', '\n', '    //  forfeit(): forfeit all stars in the specified _batch, but only if\n', '    //             none have been withdrawn yet\n', '    //\n', '    function forfeit(uint8 _batch)\n', '      external\n', '    {\n', '      Commitment storage com = commitments[msg.sender];\n', '\n', '      //  ensure the commitment has actually been configured\n', '      //\n', '      require(0 < com.total);\n', '\n', '      //  the participant can forfeit if and only if the condition deadline\n', '      //  is missed (has passed without confirmation), no stars have\n', '      //  been withdrawn from the batch yet, and this batch has not yet\n', '      //  been forfeited\n', '      //\n', '      require( (deadlines[_batch] == timestamps[_batch]) &&\n', '               0 == com.withdrawn[_batch] &&\n', '               !com.forfeited[_batch] );\n', '\n', '      //  update commitment metadata\n', '      //\n', '      com.forfeited[_batch] = true;\n', '\n', '      //  emit event\n', '      //\n', '      emit Forfeit(msg.sender, _batch, com.batches[_batch]);\n', '    }\n', '\n', '  //\n', '  //  Internal functions\n', '  //\n', '\n', '    //  performWithdraw(): withdraw a star from _com to _to\n', '    //\n', '    function performWithdraw(Commitment storage _com, address _to, bool _reset)\n', '      internal\n', '    {\n', '      //  star: star to withdraw (from end of array)\n', '      //\n', '      uint16 star = _com.stars[_com.stars.length.sub(1)];\n', '\n', '      //  remove the star from the commitment\n', '      //\n', '      _com.stars.length = _com.stars.length.sub(1);\n', '\n', '      //  then transfer the star\n', '      //\n', '      require( givePoint(star, _to, _reset) );\n', '    }\n', '\n', '  //\n', '  //  Public operations and utilities\n', '  //\n', '\n', '    //  analyzeCondition(): analyze condition number _condition for completion;\n', '    //                    set :timestamps[_condition] if either the condition&#39;s\n', '    //                    deadline has passed, or its condition has been met\n', '    //\n', '    function analyzeCondition(uint8 _condition)\n', '      public\n', '    {\n', '      //  only analyze conditions that haven&#39;t been met yet\n', '      //\n', '      require(0 == timestamps[_condition]);\n', '\n', '      //  if the liveline hasn&#39;t been passed yet, the condition can&#39;t be met\n', '      //\n', '      require(block.timestamp > livelines[_condition]);\n', '\n', '      //  if the deadline has passed, the condition is missed, then the\n', '      //  deadline becomes the condition&#39;s timestamp\n', '      //\n', '      uint256 deadline = deadlines[_condition];\n', '      if (block.timestamp > deadline)\n', '      {\n', '        timestamps[_condition] = deadline;\n', '        emit ConditionCompleted(_condition, deadline);\n', '        return;\n', '      }\n', '\n', '      //  check if the condition has been met\n', '      //\n', '      bytes32 condition = conditions[_condition];\n', '      bool met = false;\n', '\n', '      //  if the condition is zero, it is our initialization case\n', '      //\n', '      if (bytes32(0) == condition)\n', '      {\n', '        //  condition is met if the Ecliptic has been upgraded\n', '        //  at least once\n', '        //\n', '        met = (0x0 != Ecliptic(azimuth.owner()).previousEcliptic());\n', '      }\n', '      //\n', '      //  a real condition is met when it has achieved a majority vote\n', '      //\n', '      else\n', '      {\n', '        //  we check using the polls contract from the current ecliptic\n', '        //\n', '        met = Ecliptic(azimuth.owner())\n', '              .polls()\n', '              .documentHasAchievedMajority(condition);\n', '      }\n', '\n', '      //  if the condition is met, set :timestamps[_condition] to the\n', '      //  timestamp of the current eth block\n', '      //\n', '      if (met)\n', '      {\n', '        timestamps[_condition] = block.timestamp;\n', '        emit ConditionCompleted(_condition, block.timestamp);\n', '      }\n', '    }\n', '\n', '    //  withdrawLimit(): return the number of stars _participant can withdraw\n', '    //                   from _batch at the current block timestamp\n', '    //\n', '    function withdrawLimit(address _participant, uint8 _batch)\n', '      public\n', '      view\n', '      returns (uint16 limit)\n', '    {\n', '      Commitment storage com = commitments[_participant];\n', '\n', '      //  if _participant has no commitment, they can&#39;t withdraw anything\n', '      //\n', '      if (0 == com.total)\n', '      {\n', '        return 0;\n', '      }\n', '\n', '      uint256 ts = timestamps[_batch];\n', '\n', '      //  if the condition hasn&#39;t completed yet, there is nothing to add.\n', '      //\n', '      if ( ts == 0 )\n', '      {\n', '        limit = 0;\n', '      }\n', '      else\n', '      {\n', '        //  a condition can&#39;t have been completed in the future\n', '        //\n', '        assert(ts <= block.timestamp);\n', '\n', '        //  calculate the amount of stars available from this batch by\n', '        //  multiplying the release rate (stars per :rateUnit) by the number\n', '        //  of :rateUnits that have passed since the condition completed\n', '        //\n', '        uint256 num = uint256(com.rate).mul(\n', '                      block.timestamp.sub(ts) / com.rateUnit );\n', '\n', '        //  bound the release amount by the batch amount\n', '        //\n', '        if ( num > com.batches[_batch] )\n', '        {\n', '          num = com.batches[_batch];\n', '        }\n', '\n', '        limit = uint16(num);\n', '      }\n', '\n', '      //  allow at least one star, from the first batch that has stars\n', '      //\n', '      if (limit < 1)\n', '      {\n', '        //  first: whether this _batch is the first sequential one to contain\n', '        //         any stars\n', '        //\n', '        bool first = false;\n', '\n', '        //  check to see if any batch up to this _batch has stars\n', '        //\n', '        for (uint8 i = 0; i <= _batch; i++)\n', '        {\n', '          //  if this batch has stars, that&#39;s the first batch we found\n', '          //\n', '          if (0 < com.batches[i])\n', '          {\n', '            //  maybe it&#39;s _batch, but in any case we stop searching here\n', '            //\n', '            first = (i == _batch);\n', '            break;\n', '          }\n', '        }\n', '\n', '        if (first)\n', '        {\n', '          return 1;\n', '        }\n', '      }\n', '\n', '      return limit;\n', '    }\n', '\n', '    //  arraySum(): return the sum of all numbers in _array\n', '    //\n', '    //    only supports sums that fit into a uint16, which is all\n', '    //    this contract needs\n', '    //\n', '    function arraySum(uint16[] _array)\n', '      internal\n', '      pure\n', '      returns (uint16 total)\n', '    {\n', '      for (uint256 i = 0; i < _array.length; i++)\n', '      {\n', '        total = total.add(_array[i]);\n', '      }\n', '      return total;\n', '    }\n', '\n', '    //  verifyBalance: check the balance of _participant\n', '    //\n', '    //    Note: for use by clients that have not forfeited,\n', '    //    to verify the contract owner has deposited the stars\n', '    //    they&#39;re entitled to.\n', '    //\n', '    function verifyBalance(address _participant)\n', '      external\n', '      view\n', '      returns (bool correct)\n', '    {\n', '      Commitment storage com = commitments[_participant];\n', '\n', '      //  return true if this contract holds as many stars as the participant\n', '      //  will ever be entitled to withdraw\n', '      //\n', '      return ( com.stars.length ==\n', '               com.total.sub( arraySum(com.withdrawn) ) );\n', '    }\n', '\n', '    //  getBatches(): get the configured batch sizes for a commitment\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getBatches(address _participant)\n', '      external\n', '      view\n', '      returns (uint16[] batches)\n', '    {\n', '      return commitments[_participant].batches;\n', '    }\n', '\n', '    //  getBatch(): get the configured size of _batch\n', '    //\n', '    function getBatch(address _participant, uint8 _batch)\n', '      external\n', '      view\n', '      returns (uint16 batch)\n', '    {\n', '      return commitments[_participant].batches[_batch];\n', '    }\n', '\n', '    //  getWithdrawn(): get the amounts of stars that have been withdrawn\n', '    //                  from each batch\n', '    //\n', '    function getWithdrawn(address _participant)\n', '      external\n', '      view\n', '      returns (uint16[] withdrawn)\n', '    {\n', '      return commitments[_participant].withdrawn;\n', '    }\n', '\n', '    //  getWithdrawnFromBatch(): get the amount of stars that have been\n', '    //                           withdrawn from _batch\n', '    //\n', '    function getWithdrawnFromBatch(address _participant, uint8 _batch)\n', '      external\n', '      view\n', '      returns (uint16 withdrawn)\n', '    {\n', '      return commitments[_participant].withdrawn[_batch];\n', '    }\n', '\n', '    //  getForfeited(): for all of _participant&#39;s batches, get the forfeit flag\n', '    //\n', '    function getForfeited(address _participant)\n', '      external\n', '      view\n', '      returns (bool[] forfeited)\n', '    {\n', '      return commitments[_participant].forfeited;\n', '    }\n', '\n', '    //  getForfeited(): for _participant&#39;s _batch, get the forfeit flag\n', '    //\n', '    function hasForfeitedBatch(address _participant, uint8 _batch)\n', '      external\n', '      view\n', '      returns (bool forfeited)\n', '    {\n', '      return commitments[_participant].forfeited[_batch];\n', '    }\n', '\n', '    //  getRemainingStars(): get the stars deposited into the commitment\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getRemainingStars(address _participant)\n', '      external\n', '      view\n', '      returns (uint16[] stars)\n', '    {\n', '      return commitments[_participant].stars;\n', '    }\n', '\n', '    //  getConditionsState(): get the condition configurations and state\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getConditionsState()\n', '      external\n', '      view\n', '      returns (bytes32[] conds,\n', '               uint256[] lives,\n', '               uint256[] deads,\n', '               uint256[] times)\n', '    {\n', '      return (conditions, livelines, deadlines, timestamps);\n', '    }\n', '}']
['//  conditional star release\n', '//  https://azimuth.network\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '//  Imports\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', "// OpenZeppelin's Ownable.sol\n", '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', "// Azimuth's SafeMath8.sol\n", '\n', '/**\n', ' * @title SafeMath8\n', ' * @dev Math operations for uint8 with safety checks that throw on error\n', ' */\n', 'library SafeMath8 {\n', '  function mul(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    uint8 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint8 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    uint8 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', "// Azimuth's SafeMath16.sol\n", '\n', '/**\n', ' * @title SafeMath16\n', ' * @dev Math operations for uint16 with safety checks that throw on error\n', ' */\n', 'library SafeMath16 {\n', '  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint16 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', "// OpenZeppelin's SafeMath.sol\n", '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', "// OpenZeppelin's ERC165.sol\n", '\n', '/**\n', ' * @title ERC165\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'interface ERC165 {\n', '\n', '  /**\n', '   * @notice Query if a contract implements an interface\n', '   * @param _interfaceId The interface identifier, as specified in ERC-165\n', '   * @dev Interface identification is specified in ERC-165. This function\n', '   * uses less than 30,000 gas.\n', '   */\n', '  function supportsInterface(bytes4 _interfaceId)\n', '    external\n', '    view\n', '    returns (bool);\n', '}\n', '\n', "// OpenZeppelin's SupportsInterfaceWithLookup.sol\n", '\n', '/**\n', ' * @title SupportsInterfaceWithLookup\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Implements ERC165 using a lookup table.\n', ' */\n', 'contract SupportsInterfaceWithLookup is ERC165 {\n', '\n', '  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\n', '  /**\n', '   * 0x01ffc9a7 ===\n', "   *   bytes4(keccak256('supportsInterface(bytes4)'))\n", '   */\n', '\n', '  /**\n', "   * @dev a mapping of interface id to whether or not it's supported\n", '   */\n', '  mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '  /**\n', '   * @dev A contract implementing SupportsInterfaceWithLookup\n', '   * implement ERC165 itself\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    _registerInterface(InterfaceId_ERC165);\n', '  }\n', '\n', '  /**\n', '   * @dev implement supportsInterface(bytes4) using a lookup table\n', '   */\n', '  function supportsInterface(bytes4 _interfaceId)\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    return supportedInterfaces[_interfaceId];\n', '  }\n', '\n', '  /**\n', '   * @dev private method for registering an interface\n', '   */\n', '  function _registerInterface(bytes4 _interfaceId)\n', '    internal\n', '  {\n', '    require(_interfaceId != 0xffffffff);\n', '    supportedInterfaces[_interfaceId] = true;\n', '  }\n', '}\n', '\n', "// OpenZeppelin's ERC721Basic.sol\n", '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Basic is ERC165 {\n', '\n', '  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\n', '  /*\n', '   * 0x80ac58cd ===\n', "   *   bytes4(keccak256('balanceOf(address)')) ^\n", "   *   bytes4(keccak256('ownerOf(uint256)')) ^\n", "   *   bytes4(keccak256('approve(address,uint256)')) ^\n", "   *   bytes4(keccak256('getApproved(uint256)')) ^\n", "   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n", "   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\n", "   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n", "   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n", "   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n", '   */\n', '\n', '  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\n', '  /*\n', '   * 0x4f558e79 ===\n', "   *   bytes4(keccak256('exists(uint256)'))\n", '   */\n', '\n', '  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\n', '  /**\n', '   * 0x780e9d63 ===\n', "   *   bytes4(keccak256('totalSupply()')) ^\n", "   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n", "   *   bytes4(keccak256('tokenByIndex(uint256)'))\n", '   */\n', '\n', '  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n', '  /**\n', '   * 0x5b5e139f ===\n', "   *   bytes4(keccak256('name()')) ^\n", "   *   bytes4(keccak256('symbol()')) ^\n", "   *   bytes4(keccak256('tokenURI(uint256)'))\n", '   */\n', '\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 indexed _tokenId\n', '  );\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _approved,\n', '    uint256 indexed _tokenId\n', '  );\n', '  event ApprovalForAll(\n', '    address indexed _owner,\n', '    address indexed _operator,\n', '    bool _approved\n', '  );\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId)\n', '    public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator)\n', '    public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n', '    public;\n', '\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public;\n', '}\n', '\n', "// OpenZeppelin's ERC721.sol\n", '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Enumerable is ERC721Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function tokenOfOwnerByIndex(\n', '    address _owner,\n', '    uint256 _index\n', '  )\n', '    public\n', '    view\n', '    returns (uint256 _tokenId);\n', '\n', '  function tokenByIndex(uint256 _index) public view returns (uint256);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Metadata is ERC721Basic {\n', '  function name() external view returns (string _name);\n', '  function symbol() external view returns (string _symbol);\n', '  function tokenURI(uint256 _tokenId) public view returns (string);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n', '}\n', '\n', "// OpenZeppelin's ERC721Receiver.sol\n", '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver {\n', '  /**\n', '   * @dev Magic value to be returned upon successful reception of an NFT\n', '   *  Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`,\n', '   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '   */\n', '  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\n', '\n', '  /**\n', '   * @notice Handle the receipt of an NFT\n', '   * @dev The ERC721 smart contract calls this function on the recipient\n', '   * after a `safetransfer`. This function MAY throw to revert and reject the\n', '   * transfer. Return of other than the magic value MUST result in the\n', '   * transaction being reverted.\n', '   * Note: the contract address is always the message sender.\n', '   * @param _operator The address which called `safeTransferFrom` function\n', '   * @param _from The address which previously owned the token\n', '   * @param _tokenId The NFT identifier which is being transferred\n', '   * @param _data Additional data with no specified format\n', '   * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '   */\n', '  function onERC721Received(\n', '    address _operator,\n', '    address _from,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public\n', '    returns(bytes4);\n', '}\n', '\n', "// OpenZeppelin's AddressUtils.sol\n", '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   * as the code is not actually created until after the constructor finishes.\n', '   * @param _addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address _addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(_addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', "// Azimuth's Azimuth.sol\n", '\n', '//  Azimuth: point state data contract\n', '//\n', '//    This contract is used for storing all data related to Azimuth points\n', '//    and their ownership. Consider this contract the Azimuth ledger.\n', '//\n', '//    It also contains permissions data, which ties in to ERC721\n', '//    functionality. Operators of an address are allowed to transfer\n', '//    ownership of all points owned by their associated address\n', "//    (ERC721's approveAll()). A transfer proxy is allowed to transfer\n", "//    ownership of a single point (ERC721's approve()).\n", '//    Separate from ERC721 are managers, assigned per point. They are\n', '//    allowed to perform "low-impact" operations on the owner\'s points,\n', '//    like configuring public keys and making escape requests.\n', '//\n', '//    Since data stores are difficult to upgrade, this contract contains\n', '//    as little actual business logic as possible. Instead, the data stored\n', "//    herein can only be modified by this contract's owner, which can be\n", '//    changed and is thus upgradable/replaceable.\n', '//\n', '//    This contract will be owned by the Ecliptic contract.\n', '//\n', 'contract Azimuth is Ownable\n', '{\n', '//\n', '//  Events\n', '//\n', '\n', '  //  OwnerChanged: :point is now owned by :owner\n', '  //\n', '  event OwnerChanged(uint32 indexed point, address indexed owner);\n', '\n', '  //  Activated: :point is now active\n', '  //\n', '  event Activated(uint32 indexed point);\n', '\n', '  //  Spawned: :prefix has spawned :child\n', '  //\n', '  event Spawned(uint32 indexed prefix, uint32 indexed child);\n', '\n', '  //  EscapeRequested: :point has requested a new :sponsor\n', '  //\n', '  event EscapeRequested(uint32 indexed point, uint32 indexed sponsor);\n', '\n', "  //  EscapeCanceled: :point's :sponsor request was canceled or rejected\n", '  //\n', '  event EscapeCanceled(uint32 indexed point, uint32 indexed sponsor);\n', '\n', '  //  EscapeAccepted: :point confirmed with a new :sponsor\n', '  //\n', '  event EscapeAccepted(uint32 indexed point, uint32 indexed sponsor);\n', '\n', "  //  LostSponsor: :point's :sponsor is now refusing it service\n", '  //\n', '  event LostSponsor(uint32 indexed point, uint32 indexed sponsor);\n', '\n', '  //  ChangedKeys: :point has new network public keys\n', '  //\n', '  event ChangedKeys( uint32 indexed point,\n', '                     bytes32 encryptionKey,\n', '                     bytes32 authenticationKey,\n', '                     uint32 cryptoSuiteVersion,\n', '                     uint32 keyRevisionNumber );\n', '\n', '  //  BrokeContinuity: :point has a new continuity number, :number\n', '  //\n', '  event BrokeContinuity(uint32 indexed point, uint32 number);\n', '\n', '  //  ChangedSpawnProxy: :spawnProxy can now spawn using :point\n', '  //\n', '  event ChangedSpawnProxy(uint32 indexed point, address indexed spawnProxy);\n', '\n', '  //  ChangedTransferProxy: :transferProxy can now transfer ownership of :point\n', '  //\n', '  event ChangedTransferProxy( uint32 indexed point,\n', '                              address indexed transferProxy );\n', '\n', '  //  ChangedManagementProxy: :managementProxy can now manage :point\n', '  //\n', '  event ChangedManagementProxy( uint32 indexed point,\n', '                                address indexed managementProxy );\n', '\n', '  //  ChangedVotingProxy: :votingProxy can now vote using :point\n', '  //\n', '  event ChangedVotingProxy(uint32 indexed point, address indexed votingProxy);\n', '\n', '  //  ChangedDns: dnsDomains have been updated\n', '  //\n', '  event ChangedDns(string primary, string secondary, string tertiary);\n', '\n', '//\n', '//  Structures\n', '//\n', '\n', '  //  Size: kinds of points registered on-chain\n', '  //\n', '  //    NOTE: the order matters, because of Solidity enum numbering\n', '  //\n', '  enum Size\n', '  {\n', '    Galaxy, // = 0\n', '    Star,   // = 1\n', '    Planet  // = 2\n', '  }\n', '\n', '  //  Point: state of a point\n', '  //\n', '  //    While the ordering of the struct members is semantically chaotic,\n', "  //    they are ordered to tightly pack them into Ethereum's 32-byte storage\n", '  //    slots, which reduces gas costs for some function calls.\n', '  //    The comment ticks indicate assumed slot boundaries.\n', '  //\n', '  struct Point\n', '  {\n', '    //  encryptionKey: (curve25519) encryption public key, or 0 for none\n', '    //\n', '    bytes32 encryptionKey;\n', '  //\n', '    //  authenticationKey: (ed25519) authentication public key, or 0 for none\n', '    //\n', '    bytes32 authenticationKey;\n', '  //\n', '    //  spawned: for stars and galaxies, all :active children\n', '    //\n', '    uint32[] spawned;\n', '  //\n', '    //  hasSponsor: true if the sponsor still supports the point\n', '    //\n', '    bool hasSponsor;\n', '\n', '    //  active: whether point can be linked\n', '    //\n', '    //    false: point belongs to prefix, cannot be configured or linked\n', '    //    true: point no longer belongs to prefix, can be configured and linked\n', '    //\n', '    bool active;\n', '\n', '    //  escapeRequested: true if the point has requested to change sponsors\n', '    //\n', '    bool escapeRequested;\n', '\n', '    //  sponsor: the point that supports this one on the network, or,\n', '    //           if :hasSponsor is false, the last point that supported it.\n', "    //           (by default, the point's half-width prefix)\n", '    //\n', '    uint32 sponsor;\n', '\n', '    //  escapeRequestedTo: if :escapeRequested is true, new sponsor requested\n', '    //\n', '    uint32 escapeRequestedTo;\n', '\n', '    //  cryptoSuiteVersion: version of the crypto suite used for the pubkeys\n', '    //\n', '    uint32 cryptoSuiteVersion;\n', '\n', '    //  keyRevisionNumber: incremented every time the public keys change\n', '    //\n', '    uint32 keyRevisionNumber;\n', '\n', '    //  continuityNumber: incremented to indicate network-side state loss\n', '    //\n', '    uint32 continuityNumber;\n', '  }\n', '\n', '  //  Deed: permissions for a point\n', '  //\n', '  struct Deed\n', '  {\n', '    //  owner: address that owns this point\n', '    //\n', '    address owner;\n', '\n', '    //  managementProxy: 0, or another address with the right to perform\n', '    //                   low-impact, managerial operations on this point\n', '    //\n', '    address managementProxy;\n', '\n', '    //  spawnProxy: 0, or another address with the right to spawn children\n', '    //              of this point\n', '    //\n', '    address spawnProxy;\n', '\n', '    //  votingProxy: 0, or another address with the right to vote as this point\n', '    //\n', '    address votingProxy;\n', '\n', '    //  transferProxy: 0, or another address with the right to transfer\n', '    //                 ownership of this point\n', '    //\n', '    address transferProxy;\n', '  }\n', '\n', '//\n', '//  General state\n', '//\n', '\n', '  //  points: per point, general network-relevant point state\n', '  //\n', '  mapping(uint32 => Point) public points;\n', '\n', '  //  rights: per point, on-chain ownership and permissions\n', '  //\n', '  mapping(uint32 => Deed) public rights;\n', '\n', '  //  operators: per owner, per address, has the right to transfer ownership\n', "  //             of all the owner's points (ERC721)\n", '  //\n', '  mapping(address => mapping(address => bool)) public operators;\n', '\n', '  //  dnsDomains: base domains for contacting galaxies\n', '  //\n', '  //    dnsDomains[0] is primary, the others are used as fallbacks\n', '  //\n', '  string[3] public dnsDomains;\n', '\n', '//\n', '//  Lookups\n', '//\n', '\n', '  //  sponsoring: per point, the points they are sponsoring\n', '  //\n', '  mapping(uint32 => uint32[]) public sponsoring;\n', '\n', '  //  sponsoringIndexes: per point, per point, (index + 1) in\n', '  //                     the sponsoring array\n', '  //\n', '  mapping(uint32 => mapping(uint32 => uint256)) public sponsoringIndexes;\n', '\n', '  //  escapeRequests: per point, the points they have open escape requests from\n', '  //\n', '  mapping(uint32 => uint32[]) public escapeRequests;\n', '\n', '  //  escapeRequestsIndexes: per point, per point, (index + 1) in\n', '  //                         the escapeRequests array\n', '  //\n', '  mapping(uint32 => mapping(uint32 => uint256)) public escapeRequestsIndexes;\n', '\n', '  //  pointsOwnedBy: per address, the points they own\n', '  //\n', '  mapping(address => uint32[]) public pointsOwnedBy;\n', '\n', '  //  pointOwnerIndexes: per owner, per point, (index + 1) in\n', '  //                     the pointsOwnedBy array\n', '  //\n', '  //    We delete owners by moving the last entry in the array to the\n', '  //    newly emptied slot, which is (n - 1) where n is the value of\n', '  //    pointOwnerIndexes[owner][point].\n', '  //\n', '  mapping(address => mapping(uint32 => uint256)) public pointOwnerIndexes;\n', '\n', '  //  managerFor: per address, the points they are the management proxy for\n', '  //\n', '  mapping(address => uint32[]) public managerFor;\n', '\n', '  //  managerForIndexes: per address, per point, (index + 1) in\n', '  //                     the managerFor array\n', '  //\n', '  mapping(address => mapping(uint32 => uint256)) public managerForIndexes;\n', '\n', '  //  spawningFor: per address, the points they can spawn with\n', '  //\n', '  mapping(address => uint32[]) public spawningFor;\n', '\n', '  //  spawningForIndexes: per address, per point, (index + 1) in\n', '  //                      the spawningFor array\n', '  //\n', '  mapping(address => mapping(uint32 => uint256)) public spawningForIndexes;\n', '\n', '  //  votingFor: per address, the points they can vote with\n', '  //\n', '  mapping(address => uint32[]) public votingFor;\n', '\n', '  //  votingForIndexes: per address, per point, (index + 1) in\n', '  //                    the votingFor array\n', '  //\n', '  mapping(address => mapping(uint32 => uint256)) public votingForIndexes;\n', '\n', '  //  transferringFor: per address, the points they can transfer\n', '  //\n', '  mapping(address => uint32[]) public transferringFor;\n', '\n', '  //  transferringForIndexes: per address, per point, (index + 1) in\n', '  //                          the transferringFor array\n', '  //\n', '  mapping(address => mapping(uint32 => uint256)) public transferringForIndexes;\n', '\n', '//\n', '//  Logic\n', '//\n', '\n', '  //  constructor(): configure default dns domains\n', '  //\n', '  constructor()\n', '    public\n', '  {\n', '    setDnsDomains("example.com", "example.com", "example.com");\n', '  }\n', '\n', '  //  setDnsDomains(): set the base domains used for contacting galaxies\n', '  //\n', "  //    Note: since a string is really just a byte[], and Solidity can't\n", '  //    work with two-dimensional arrays yet, we pass in the three\n', '  //    domains as individual strings.\n', '  //\n', '  function setDnsDomains(string _primary, string _secondary, string _tertiary)\n', '    onlyOwner\n', '    public\n', '  {\n', '    dnsDomains[0] = _primary;\n', '    dnsDomains[1] = _secondary;\n', '    dnsDomains[2] = _tertiary;\n', '    emit ChangedDns(_primary, _secondary, _tertiary);\n', '  }\n', '\n', '  //\n', '  //  Point reading\n', '  //\n', '\n', '    //  isActive(): return true if _point is active\n', '    //\n', '    function isActive(uint32 _point)\n', '      view\n', '      external\n', '      returns (bool equals)\n', '    {\n', '      return points[_point].active;\n', '    }\n', '\n', '    //  getKeys(): returns the public keys and their details, as currently\n', '    //             registered for _point\n', '    //\n', '    function getKeys(uint32 _point)\n', '      view\n', '      external\n', '      returns (bytes32 crypt, bytes32 auth, uint32 suite, uint32 revision)\n', '    {\n', '      Point storage point = points[_point];\n', '      return (point.encryptionKey,\n', '              point.authenticationKey,\n', '              point.cryptoSuiteVersion,\n', '              point.keyRevisionNumber);\n', '    }\n', '\n', "    //  getKeyRevisionNumber(): gets the revision number of _point's current\n", '    //                          public keys\n', '    //\n', '    function getKeyRevisionNumber(uint32 _point)\n', '      view\n', '      external\n', '      returns (uint32 revision)\n', '    {\n', '      return points[_point].keyRevisionNumber;\n', '    }\n', '\n', '    //  hasBeenLinked(): returns true if the point has ever been assigned keys\n', '    //\n', '    function hasBeenLinked(uint32 _point)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return ( points[_point].keyRevisionNumber > 0 );\n', '    }\n', '\n', '    //  isLive(): returns true if _point currently has keys properly configured\n', '    //\n', '    function isLive(uint32 _point)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      Point storage point = points[_point];\n', '      return ( point.encryptionKey != 0 &&\n', '               point.authenticationKey != 0 &&\n', '               point.cryptoSuiteVersion != 0 );\n', '    }\n', '\n', "    //  getContinuityNumber(): returns _point's current continuity number\n", '    //\n', '    function getContinuityNumber(uint32 _point)\n', '      view\n', '      external\n', '      returns (uint32 continuityNumber)\n', '    {\n', '      return points[_point].continuityNumber;\n', '    }\n', '\n', '    //  getSpawnCount(): return the number of children spawned by _point\n', '    //\n', '    function getSpawnCount(uint32 _point)\n', '      view\n', '      external\n', '      returns (uint32 spawnCount)\n', '    {\n', '      uint256 len = points[_point].spawned.length;\n', '      assert(len < 2**32);\n', '      return uint32(len);\n', '    }\n', '\n', '    //  getSpawned(): return array of points created under _point\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getSpawned(uint32 _point)\n', '      view\n', '      external\n', '      returns (uint32[] spawned)\n', '    {\n', '      return points[_point].spawned;\n', '    }\n', '\n', "    //  hasSponsor(): returns true if _point's sponsor is providing it service\n", '    //\n', '    function hasSponsor(uint32 _point)\n', '      view\n', '      external\n', '      returns (bool has)\n', '    {\n', '      return points[_point].hasSponsor;\n', '    }\n', '\n', "    //  getSponsor(): returns _point's current (or most recent) sponsor\n", '    //\n', '    function getSponsor(uint32 _point)\n', '      view\n', '      external\n', '      returns (uint32 sponsor)\n', '    {\n', '      return points[_point].sponsor;\n', '    }\n', '\n', '    //  isSponsor(): returns true if _sponsor is currently providing service\n', '    //               to _point\n', '    //\n', '    function isSponsor(uint32 _point, uint32 _sponsor)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      Point storage point = points[_point];\n', '      return ( point.hasSponsor &&\n', '               (point.sponsor == _sponsor) );\n', '    }\n', '\n', '    //  getSponsoringCount(): returns the number of points _sponsor is\n', '    //                        providing service to\n', '    //\n', '    function getSponsoringCount(uint32 _sponsor)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return sponsoring[_sponsor].length;\n', '    }\n', '\n', '    //  getSponsoring(): returns a list of points _sponsor is providing\n', '    //                   service to\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getSponsoring(uint32 _sponsor)\n', '      view\n', '      external\n', '      returns (uint32[] sponsees)\n', '    {\n', '      return sponsoring[_sponsor];\n', '    }\n', '\n', '    //  escaping\n', '\n', '    //  isEscaping(): returns true if _point has an outstanding escape request\n', '    //\n', '    function isEscaping(uint32 _point)\n', '      view\n', '      external\n', '      returns (bool escaping)\n', '    {\n', '      return points[_point].escapeRequested;\n', '    }\n', '\n', "    //  getEscapeRequest(): returns _point's current escape request\n", '    //\n', '    //    the returned escape request is only valid as long as isEscaping()\n', '    //    returns true\n', '    //\n', '    function getEscapeRequest(uint32 _point)\n', '      view\n', '      external\n', '      returns (uint32 escape)\n', '    {\n', '      return points[_point].escapeRequestedTo;\n', '    }\n', '\n', '    //  isRequestingEscapeTo(): returns true if _point has an outstanding\n', '    //                          escape request targetting _sponsor\n', '    //\n', '    function isRequestingEscapeTo(uint32 _point, uint32 _sponsor)\n', '      view\n', '      public\n', '      returns (bool equals)\n', '    {\n', '      Point storage point = points[_point];\n', '      return (point.escapeRequested && (point.escapeRequestedTo == _sponsor));\n', '    }\n', '\n', '    //  getEscapeRequestsCount(): returns the number of points _sponsor\n', '    //                            is providing service to\n', '    //\n', '    function getEscapeRequestsCount(uint32 _sponsor)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return escapeRequests[_sponsor].length;\n', '    }\n', '\n', '    //  getEscapeRequests(): get the points _sponsor has received escape\n', '    //                       requests from\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getEscapeRequests(uint32 _sponsor)\n', '      view\n', '      external\n', '      returns (uint32[] requests)\n', '    {\n', '      return escapeRequests[_sponsor];\n', '    }\n', '\n', '  //\n', '  //  Point writing\n', '  //\n', '\n', '    //  activatePoint(): activate a point, register it as spawned by its prefix\n', '    //\n', '    function activatePoint(uint32 _point)\n', '      onlyOwner\n', '      external\n', '    {\n', '      //  make a point active, setting its sponsor to its prefix\n', '      //\n', '      Point storage point = points[_point];\n', '      require(!point.active);\n', '      point.active = true;\n', '      registerSponsor(_point, true, getPrefix(_point));\n', '      emit Activated(_point);\n', '    }\n', '\n', '    //  setKeys(): set network public keys of _point to _encryptionKey and\n', '    //            _authenticationKey, with the specified _cryptoSuiteVersion\n', '    //\n', '    function setKeys(uint32 _point,\n', '                     bytes32 _encryptionKey,\n', '                     bytes32 _authenticationKey,\n', '                     uint32 _cryptoSuiteVersion)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Point storage point = points[_point];\n', '      if ( point.encryptionKey == _encryptionKey &&\n', '           point.authenticationKey == _authenticationKey &&\n', '           point.cryptoSuiteVersion == _cryptoSuiteVersion )\n', '      {\n', '        return;\n', '      }\n', '\n', '      point.encryptionKey = _encryptionKey;\n', '      point.authenticationKey = _authenticationKey;\n', '      point.cryptoSuiteVersion = _cryptoSuiteVersion;\n', '      point.keyRevisionNumber++;\n', '\n', '      emit ChangedKeys(_point,\n', '                       _encryptionKey,\n', '                       _authenticationKey,\n', '                       _cryptoSuiteVersion,\n', '                       point.keyRevisionNumber);\n', '    }\n', '\n', '    //  incrementContinuityNumber(): break continuity for _point\n', '    //\n', '    function incrementContinuityNumber(uint32 _point)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Point storage point = points[_point];\n', '      point.continuityNumber++;\n', '      emit BrokeContinuity(_point, point.continuityNumber);\n', '    }\n', '\n', "    //  registerSpawn(): add a point to its prefix's list of spawned points\n", '    //\n', '    function registerSpawned(uint32 _point)\n', '      onlyOwner\n', '      external\n', '    {\n', "      //  if a point is its own prefix (a galaxy) then don't register it\n", '      //\n', '      uint32 prefix = getPrefix(_point);\n', '      if (prefix == _point)\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  register a new spawned point for the prefix\n', '      //\n', '      points[prefix].spawned.push(_point);\n', '      emit Spawned(prefix, _point);\n', '    }\n', '\n', "    //  loseSponsor(): indicates that _point's sponsor is no longer providing\n", '    //                 it service\n', '    //\n', '    function loseSponsor(uint32 _point)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Point storage point = points[_point];\n', '      if (!point.hasSponsor)\n', '      {\n', '        return;\n', '      }\n', '      registerSponsor(_point, false, point.sponsor);\n', '      emit LostSponsor(_point, point.sponsor);\n', '    }\n', '\n', '    //  setEscapeRequest(): for _point, start an escape request to _sponsor\n', '    //\n', '    function setEscapeRequest(uint32 _point, uint32 _sponsor)\n', '      onlyOwner\n', '      external\n', '    {\n', '      if (isRequestingEscapeTo(_point, _sponsor))\n', '      {\n', '        return;\n', '      }\n', '      registerEscapeRequest(_point, true, _sponsor);\n', '      emit EscapeRequested(_point, _sponsor);\n', '    }\n', '\n', '    //  cancelEscape(): for _point, stop the current escape request, if any\n', '    //\n', '    function cancelEscape(uint32 _point)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Point storage point = points[_point];\n', '      if (!point.escapeRequested)\n', '      {\n', '        return;\n', '      }\n', '      uint32 request = point.escapeRequestedTo;\n', '      registerEscapeRequest(_point, false, 0);\n', '      emit EscapeCanceled(_point, request);\n', '    }\n', '\n', '    //  doEscape(): perform the requested escape\n', '    //\n', '    function doEscape(uint32 _point)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Point storage point = points[_point];\n', '      require(point.escapeRequested);\n', '      registerSponsor(_point, true, point.escapeRequestedTo);\n', '      registerEscapeRequest(_point, false, 0);\n', '      emit EscapeAccepted(_point, point.sponsor);\n', '    }\n', '\n', '  //\n', '  //  Point utils\n', '  //\n', '\n', '    //  getPrefix(): compute prefix ("parent") of _point\n', '    //\n', '    function getPrefix(uint32 _point)\n', '      pure\n', '      public\n', '      returns (uint16 prefix)\n', '    {\n', '      if (_point < 0x10000)\n', '      {\n', '        return uint16(_point % 0x100);\n', '      }\n', '      return uint16(_point % 0x10000);\n', '    }\n', '\n', '    //  getPointSize(): return the size of _point\n', '    //\n', '    function getPointSize(uint32 _point)\n', '      external\n', '      pure\n', '      returns (Size _size)\n', '    {\n', '      if (_point < 0x100) return Size.Galaxy;\n', '      if (_point < 0x10000) return Size.Star;\n', '      return Size.Planet;\n', '    }\n', '\n', '    //  internal use\n', '\n', '    //  registerSponsor(): set the sponsorship state of _point and update the\n', '    //                     reverse lookup for sponsors\n', '    //\n', '    function registerSponsor(uint32 _point, bool _hasSponsor, uint32 _sponsor)\n', '      internal\n', '    {\n', '      Point storage point = points[_point];\n', '      bool had = point.hasSponsor;\n', '      uint32 prev = point.sponsor;\n', '\n', "      //  if we didn't have a sponsor, and won't get one,\n", '      //  or if we get the sponsor we already have,\n', '      //  nothing will change, so jump out early.\n', '      //\n', '      if ( (!had && !_hasSponsor) ||\n', '           (had && _hasSponsor && prev == _sponsor) )\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different sponsor, do some gymnastics\n', '      //  to keep the reverse lookup gapless.  delete the point from the old\n', "      //  sponsor's list, then fill that gap with the list tail.\n", '      //\n', '      if (had)\n', '      {\n', "        //  i: current index in previous sponsor's list of sponsored points\n", '        //\n', '        uint256 i = sponsoringIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :sponsoringIndexes reference\n', '        //\n', '        uint32[] storage prevSponsoring = sponsoring[prev];\n', '        uint256 last = prevSponsoring.length - 1;\n', '        uint32 moved = prevSponsoring[last];\n', '        prevSponsoring[i] = moved;\n', '        sponsoringIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(prevSponsoring[last]);\n', '        prevSponsoring.length = last;\n', '        sponsoringIndexes[prev][_point] = 0;\n', '      }\n', '\n', '      if (_hasSponsor)\n', '      {\n', '        uint32[] storage newSponsoring = sponsoring[_sponsor];\n', '        newSponsoring.push(_point);\n', '        sponsoringIndexes[_sponsor][_point] = newSponsoring.length;\n', '      }\n', '\n', '      point.sponsor = _sponsor;\n', '      point.hasSponsor = _hasSponsor;\n', '    }\n', '\n', '    //  registerEscapeRequest(): set the escape state of _point and update the\n', '    //                           reverse lookup for sponsors\n', '    //\n', '    function registerEscapeRequest( uint32 _point,\n', '                                    bool _isEscaping, uint32 _sponsor )\n', '      internal\n', '    {\n', '      Point storage point = points[_point];\n', '      bool was = point.escapeRequested;\n', '      uint32 prev = point.escapeRequestedTo;\n', '\n', "      //  if we weren't escaping, and won't be,\n", '      //  or if we were escaping, and the new target is the same,\n', '      //  nothing will change, so jump out early.\n', '      //\n', '      if ( (!was && !_isEscaping) ||\n', '           (was && _isEscaping && prev == _sponsor) )\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different request, do some gymnastics\n', '      //  to keep the reverse lookup gapless.  delete the point from the old\n', "      //  sponsor's list, then fill that gap with the list tail.\n", '      //\n', '      if (was)\n', '      {\n', "        //  i: current index in previous sponsor's list of sponsored points\n", '        //\n', '        uint256 i = escapeRequestsIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :escapeRequestsIndexes reference\n', '        //\n', '        uint32[] storage prevRequests = escapeRequests[prev];\n', '        uint256 last = prevRequests.length - 1;\n', '        uint32 moved = prevRequests[last];\n', '        prevRequests[i] = moved;\n', '        escapeRequestsIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(prevRequests[last]);\n', '        prevRequests.length = last;\n', '        escapeRequestsIndexes[prev][_point] = 0;\n', '      }\n', '\n', '      if (_isEscaping)\n', '      {\n', '        uint32[] storage newRequests = escapeRequests[_sponsor];\n', '        newRequests.push(_point);\n', '        escapeRequestsIndexes[_sponsor][_point] = newRequests.length;\n', '      }\n', '\n', '      point.escapeRequestedTo = _sponsor;\n', '      point.escapeRequested = _isEscaping;\n', '    }\n', '\n', '  //\n', '  //  Deed reading\n', '  //\n', '\n', '    //  owner\n', '\n', '    //  getOwner(): return owner of _point\n', '    //\n', '    function getOwner(uint32 _point)\n', '      view\n', '      external\n', '      returns (address owner)\n', '    {\n', '      return rights[_point].owner;\n', '    }\n', '\n', '    //  isOwner(): true if _point is owned by _address\n', '    //\n', '    function isOwner(uint32 _point, address _address)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return (rights[_point].owner == _address);\n', '    }\n', '\n', '    //  getOwnedPointCount(): return length of array of points that _whose owns\n', '    //\n', '    function getOwnedPointCount(address _whose)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return pointsOwnedBy[_whose].length;\n', '    }\n', '\n', '    //  getOwnedPoints(): return array of points that _whose owns\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getOwnedPoints(address _whose)\n', '      view\n', '      external\n', '      returns (uint32[] ownedPoints)\n', '    {\n', '      return pointsOwnedBy[_whose];\n', '    }\n', '\n', '    //  getOwnedPointAtIndex(): get point at _index from array of points that\n', '    //                         _whose owns\n', '    //\n', '    function getOwnedPointAtIndex(address _whose, uint256 _index)\n', '      view\n', '      external\n', '      returns (uint32 point)\n', '    {\n', '      uint32[] storage owned = pointsOwnedBy[_whose];\n', '      require(_index < owned.length);\n', '      return owned[_index];\n', '    }\n', '\n', '    //  management proxy\n', '\n', "    //  getManagementProxy(): returns _point's current management proxy\n", '    //\n', '    function getManagementProxy(uint32 _point)\n', '      view\n', '      external\n', '      returns (address manager)\n', '    {\n', '      return rights[_point].managementProxy;\n', '    }\n', '\n', "    //  isManagementProxy(): returns true if _proxy is _point's management proxy\n", '    //\n', '    function isManagementProxy(uint32 _point, address _proxy)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return (rights[_point].managementProxy == _proxy);\n', '    }\n', '\n', '    //  canManage(): true if _who is the owner or manager of _point\n', '    //\n', '    function canManage(uint32 _point, address _who)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      return ( (0x0 != _who) &&\n', '               ( (_who == deed.owner) ||\n', '                 (_who == deed.managementProxy) ) );\n', '    }\n', '\n', '    //  getManagerForCount(): returns the amount of points _proxy can manage\n', '    //\n', '    function getManagerForCount(address _proxy)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return managerFor[_proxy].length;\n', '    }\n', '\n', '    //  getManagerFor(): returns the points _proxy can manage\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getManagerFor(address _proxy)\n', '      view\n', '      external\n', '      returns (uint32[] mfor)\n', '    {\n', '      return managerFor[_proxy];\n', '    }\n', '\n', '    //  spawn proxy\n', '\n', "    //  getSpawnProxy(): returns _point's current spawn proxy\n", '    //\n', '    function getSpawnProxy(uint32 _point)\n', '      view\n', '      external\n', '      returns (address spawnProxy)\n', '    {\n', '      return rights[_point].spawnProxy;\n', '    }\n', '\n', "    //  isSpawnProxy(): returns true if _proxy is _point's spawn proxy\n", '    //\n', '    function isSpawnProxy(uint32 _point, address _proxy)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return (rights[_point].spawnProxy == _proxy);\n', '    }\n', '\n', '    //  canSpawnAs(): true if _who is the owner or spawn proxy of _point\n', '    //\n', '    function canSpawnAs(uint32 _point, address _who)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      return ( (0x0 != _who) &&\n', '               ( (_who == deed.owner) ||\n', '                 (_who == deed.spawnProxy) ) );\n', '    }\n', '\n', '    //  getSpawningForCount(): returns the amount of points _proxy\n', '    //                         can spawn with\n', '    //\n', '    function getSpawningForCount(address _proxy)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return spawningFor[_proxy].length;\n', '    }\n', '\n', '    //  getSpawningFor(): get the points _proxy can spawn with\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getSpawningFor(address _proxy)\n', '      view\n', '      external\n', '      returns (uint32[] sfor)\n', '    {\n', '      return spawningFor[_proxy];\n', '    }\n', '\n', '    //  voting proxy\n', '\n', "    //  getVotingProxy(): returns _point's current voting proxy\n", '    //\n', '    function getVotingProxy(uint32 _point)\n', '      view\n', '      external\n', '      returns (address voter)\n', '    {\n', '      return rights[_point].votingProxy;\n', '    }\n', '\n', "    //  isVotingProxy(): returns true if _proxy is _point's voting proxy\n", '    //\n', '    function isVotingProxy(uint32 _point, address _proxy)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return (rights[_point].votingProxy == _proxy);\n', '    }\n', '\n', '    //  canVoteAs(): true if _who is the owner of _point,\n', "    //               or the voting proxy of _point's owner\n", '    //\n', '    function canVoteAs(uint32 _point, address _who)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      return ( (0x0 != _who) &&\n', '               ( (_who == deed.owner) ||\n', '                 (_who == deed.votingProxy) ) );\n', '    }\n', '\n', '    //  getVotingForCount(): returns the amount of points _proxy can vote as\n', '    //\n', '    function getVotingForCount(address _proxy)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return votingFor[_proxy].length;\n', '    }\n', '\n', '    //  getVotingFor(): returns the points _proxy can vote as\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getVotingFor(address _proxy)\n', '      view\n', '      external\n', '      returns (uint32[] vfor)\n', '    {\n', '      return votingFor[_proxy];\n', '    }\n', '\n', '    //  transfer proxy\n', '\n', "    //  getTransferProxy(): returns _point's current transfer proxy\n", '    //\n', '    function getTransferProxy(uint32 _point)\n', '      view\n', '      external\n', '      returns (address transferProxy)\n', '    {\n', '      return rights[_point].transferProxy;\n', '    }\n', '\n', "    //  isTransferProxy(): returns true if _proxy is _point's transfer proxy\n", '    //\n', '    function isTransferProxy(uint32 _point, address _proxy)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return (rights[_point].transferProxy == _proxy);\n', '    }\n', '\n', '    //  canTransfer(): true if _who is the owner or transfer proxy of _point,\n', "    //                 or is an operator for _point's current owner\n", '    //\n', '    function canTransfer(uint32 _point, address _who)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      return ( (0x0 != _who) &&\n', '               ( (_who == deed.owner) ||\n', '                 (_who == deed.transferProxy) ||\n', '                 operators[deed.owner][_who] ) );\n', '    }\n', '\n', '    //  getTransferringForCount(): returns the amount of points _proxy\n', '    //                             can transfer\n', '    //\n', '    function getTransferringForCount(address _proxy)\n', '      view\n', '      external\n', '      returns (uint256 count)\n', '    {\n', '      return transferringFor[_proxy].length;\n', '    }\n', '\n', '    //  getTransferringFor(): get the points _proxy can transfer\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getTransferringFor(address _proxy)\n', '      view\n', '      external\n', '      returns (uint32[] tfor)\n', '    {\n', '      return transferringFor[_proxy];\n', '    }\n', '\n', '    //  isOperator(): returns true if _operator is allowed to transfer\n', "    //                ownership of _owner's points\n", '    //\n', '    function isOperator(address _owner, address _operator)\n', '      view\n', '      external\n', '      returns (bool result)\n', '    {\n', '      return operators[_owner][_operator];\n', '    }\n', '\n', '  //\n', '  //  Deed writing\n', '  //\n', '\n', '    //  setOwner(): set owner of _point to _owner\n', '    //\n', '    //    Note: setOwner() only implements the minimal data storage\n', '    //    logic for a transfer; the full transfer is implemented in\n', '    //    Ecliptic.\n', '    //\n', '    //    Note: _owner must not be the zero address.\n', '    //\n', '    function setOwner(uint32 _point, address _owner)\n', '      onlyOwner\n', '      external\n', '    {\n', '      //  prevent burning of points by making zero the owner\n', '      //\n', '      require(0x0 != _owner);\n', '\n', '      //  prev: previous owner, if any\n', '      //\n', '      address prev = rights[_point].owner;\n', '\n', '      if (prev == _owner)\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different owner, do some gymnastics to\n', '      //  keep the list of owned points gapless.  delete this point from the\n', '      //  list, then fill that gap with the list tail.\n', '      //\n', '      if (0x0 != prev)\n', '      {\n', "        //  i: current index in previous owner's list of owned points\n", '        //\n', '        uint256 i = pointOwnerIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :pointOwnerIndexes reference\n', '        //\n', '        uint32[] storage owner = pointsOwnedBy[prev];\n', '        uint256 last = owner.length - 1;\n', '        uint32 moved = owner[last];\n', '        owner[i] = moved;\n', '        pointOwnerIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(owner[last]);\n', '        owner.length = last;\n', '        pointOwnerIndexes[prev][_point] = 0;\n', '      }\n', '\n', "      //  update the owner list and the owner's index list\n", '      //\n', '      rights[_point].owner = _owner;\n', '      pointsOwnedBy[_owner].push(_point);\n', '      pointOwnerIndexes[_owner][_point] = pointsOwnedBy[_owner].length;\n', '      emit OwnerChanged(_point, _owner);\n', '    }\n', '\n', "    //  setManagementProxy(): makes _proxy _point's management proxy\n", '    //\n', '    function setManagementProxy(uint32 _point, address _proxy)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      address prev = deed.managementProxy;\n', '      if (prev == _proxy)\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different manager, do some gymnastics\n', '      //  to keep the reverse lookup gapless.  delete the point from the\n', "      //  old manager's list, then fill that gap with the list tail.\n", '      //\n', '      if (0x0 != prev)\n', '      {\n', "        //  i: current index in previous manager's list of managed points\n", '        //\n', '        uint256 i = managerForIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :managerForIndexes reference\n', '        //\n', '        uint32[] storage prevMfor = managerFor[prev];\n', '        uint256 last = prevMfor.length - 1;\n', '        uint32 moved = prevMfor[last];\n', '        prevMfor[i] = moved;\n', '        managerForIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(prevMfor[last]);\n', '        prevMfor.length = last;\n', '        managerForIndexes[prev][_point] = 0;\n', '      }\n', '\n', '      if (0x0 != _proxy)\n', '      {\n', '        uint32[] storage mfor = managerFor[_proxy];\n', '        mfor.push(_point);\n', '        managerForIndexes[_proxy][_point] = mfor.length;\n', '      }\n', '\n', '      deed.managementProxy = _proxy;\n', '      emit ChangedManagementProxy(_point, _proxy);\n', '    }\n', '\n', "    //  setSpawnProxy(): makes _proxy _point's spawn proxy\n", '    //\n', '    function setSpawnProxy(uint32 _point, address _proxy)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      address prev = deed.spawnProxy;\n', '      if (prev == _proxy)\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different spawn proxy, do some\n', '      //  gymnastics to keep the reverse lookup gapless.  delete the point\n', "      //  from the old proxy's list, then fill that gap with the list tail.\n", '      //\n', '      if (0x0 != prev)\n', '      {\n', "        //  i: current index in previous proxy's list of spawning points\n", '        //\n', '        uint256 i = spawningForIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :spawningForIndexes reference\n', '        //\n', '        uint32[] storage prevSfor = spawningFor[prev];\n', '        uint256 last = prevSfor.length - 1;\n', '        uint32 moved = prevSfor[last];\n', '        prevSfor[i] = moved;\n', '        spawningForIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(prevSfor[last]);\n', '        prevSfor.length = last;\n', '        spawningForIndexes[prev][_point] = 0;\n', '      }\n', '\n', '      if (0x0 != _proxy)\n', '      {\n', '        uint32[] storage sfor = spawningFor[_proxy];\n', '        sfor.push(_point);\n', '        spawningForIndexes[_proxy][_point] = sfor.length;\n', '      }\n', '\n', '      deed.spawnProxy = _proxy;\n', '      emit ChangedSpawnProxy(_point, _proxy);\n', '    }\n', '\n', "    //  setVotingProxy(): makes _proxy _point's voting proxy\n", '    //\n', '    function setVotingProxy(uint32 _point, address _proxy)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      address prev = deed.votingProxy;\n', '      if (prev == _proxy)\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different voter, do some gymnastics\n', '      //  to keep the reverse lookup gapless.  delete the point from the\n', "      //  old voter's list, then fill that gap with the list tail.\n", '      //\n', '      if (0x0 != prev)\n', '      {\n', "        //  i: current index in previous voter's list of points it was\n", '        //     voting for\n', '        //\n', '        uint256 i = votingForIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :votingForIndexes reference\n', '        //\n', '        uint32[] storage prevVfor = votingFor[prev];\n', '        uint256 last = prevVfor.length - 1;\n', '        uint32 moved = prevVfor[last];\n', '        prevVfor[i] = moved;\n', '        votingForIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(prevVfor[last]);\n', '        prevVfor.length = last;\n', '        votingForIndexes[prev][_point] = 0;\n', '      }\n', '\n', '      if (0x0 != _proxy)\n', '      {\n', '        uint32[] storage vfor = votingFor[_proxy];\n', '        vfor.push(_point);\n', '        votingForIndexes[_proxy][_point] = vfor.length;\n', '      }\n', '\n', '      deed.votingProxy = _proxy;\n', '      emit ChangedVotingProxy(_point, _proxy);\n', '    }\n', '\n', "    //  setManagementProxy(): makes _proxy _point's transfer proxy\n", '    //\n', '    function setTransferProxy(uint32 _point, address _proxy)\n', '      onlyOwner\n', '      external\n', '    {\n', '      Deed storage deed = rights[_point];\n', '      address prev = deed.transferProxy;\n', '      if (prev == _proxy)\n', '      {\n', '        return;\n', '      }\n', '\n', '      //  if the point used to have a different transfer proxy, do some\n', '      //  gymnastics to keep the reverse lookup gapless.  delete the point\n', "      //  from the old proxy's list, then fill that gap with the list tail.\n", '      //\n', '      if (0x0 != prev)\n', '      {\n', "        //  i: current index in previous proxy's list of transferable points\n", '        //\n', '        uint256 i = transferringForIndexes[prev][_point];\n', '\n', '        //  we store index + 1, because 0 is the solidity default value\n', '        //\n', '        assert(i > 0);\n', '        i--;\n', '\n', '        //  copy the last item in the list into the now-unused slot,\n', '        //  making sure to update its :transferringForIndexes reference\n', '        //\n', '        uint32[] storage prevTfor = transferringFor[prev];\n', '        uint256 last = prevTfor.length - 1;\n', '        uint32 moved = prevTfor[last];\n', '        prevTfor[i] = moved;\n', '        transferringForIndexes[prev][moved] = i + 1;\n', '\n', '        //  delete the last item\n', '        //\n', '        delete(prevTfor[last]);\n', '        prevTfor.length = last;\n', '        transferringForIndexes[prev][_point] = 0;\n', '      }\n', '\n', '      if (0x0 != _proxy)\n', '      {\n', '        uint32[] storage tfor = transferringFor[_proxy];\n', '        tfor.push(_point);\n', '        transferringForIndexes[_proxy][_point] = tfor.length;\n', '      }\n', '\n', '      deed.transferProxy = _proxy;\n', '      emit ChangedTransferProxy(_point, _proxy);\n', '    }\n', '\n', '    //  setOperator(): dis/allow _operator to transfer ownership of all points\n', '    //                 owned by _owner\n', '    //\n', '    //    operators are part of the ERC721 standard\n', '    //\n', '    function setOperator(address _owner, address _operator, bool _approved)\n', '      onlyOwner\n', '      external\n', '    {\n', '      operators[_owner][_operator] = _approved;\n', '    }\n', '}\n', '\n', "// Azimuth's ReadsAzimuth.sol\n", '\n', '//  ReadsAzimuth: referring to and testing against the Azimuth\n', '//                data contract\n', '//\n', '//    To avoid needless repetition, this contract provides common\n', '//    checks and operations using the Azimuth contract.\n', '//\n', 'contract ReadsAzimuth\n', '{\n', '  //  azimuth: points data storage contract.\n', '  //\n', '  Azimuth public azimuth;\n', '\n', "  //  constructor(): set the Azimuth data contract's address\n", '  //\n', '  constructor(Azimuth _azimuth)\n', '    public\n', '  {\n', '    azimuth = _azimuth;\n', '  }\n', '\n', '  //  activePointOwner(): require that :msg.sender is the owner of _point,\n', '  //                      and that _point is active\n', '  //\n', '  modifier activePointOwner(uint32 _point)\n', '  {\n', '    require( azimuth.isOwner(_point, msg.sender) &&\n', '             azimuth.isActive(_point) );\n', '    _;\n', '  }\n', '\n', '  //  activePointManager(): require that :msg.sender can manage _point,\n', '  //                        and that _point is active\n', '  //\n', '  modifier activePointManager(uint32 _point)\n', '  {\n', '    require( azimuth.canManage(_point, msg.sender) &&\n', '             azimuth.isActive(_point) );\n', '    _;\n', '  }\n', '}\n', '\n', "// Azimuth's Polls.sol\n", '\n', '//  Polls: proposals & votes data contract\n', '//\n', '//    This contract is used for storing all data related to the proposals\n', '//    of the senate (galaxy owners) and their votes on those proposals.\n', '//    It keeps track of votes and uses them to calculate whether a majority\n', '//    is in favor of a proposal.\n', '//\n', '//    Every galaxy can only vote on a proposal exactly once. Votes cannot\n', '//    be changed. If a proposal fails to achieve majority within its\n', '//    duration, it can be restarted after its cooldown period has passed.\n', '//\n', '//    The requirements for a proposal to achieve majority are as follows:\n', '//    - At least 1/4 of the currently active voters (rounded down) must have\n', '//      voted in favor of the proposal,\n', '//    - More than half of the votes cast must be in favor of the proposal,\n', '//      and this can no longer change, either because\n', '//      - the poll duration has passed, or\n', '//      - not enough voters remain to take away the in-favor majority.\n', '//    As soon as these conditions are met, no further interaction with\n', '//    the proposal is possible. Achieving majority is permanent.\n', '//\n', '//    Since data stores are difficult to upgrade, all of the logic unrelated\n', '//    to the voting itself (that is, determining who is eligible to vote)\n', "//    is expected to be implemented by this contract's owner.\n", '//\n', '//    This contract will be owned by the Ecliptic contract.\n', '//\n', 'contract Polls is Ownable\n', '{\n', '  using SafeMath for uint256;\n', '  using SafeMath16 for uint16;\n', '  using SafeMath8 for uint8;\n', '\n', '  //  UpgradePollStarted: a poll on :proposal has opened\n', '  //\n', '  event UpgradePollStarted(address proposal);\n', '\n', '  //  DocumentPollStarted: a poll on :proposal has opened\n', '  //\n', '  event DocumentPollStarted(bytes32 proposal);\n', '\n', '  //  UpgradeMajority: :proposal has achieved majority\n', '  //\n', '  event UpgradeMajority(address proposal);\n', '\n', '  //  DocumentMajority: :proposal has achieved majority\n', '  //\n', '  event DocumentMajority(bytes32 proposal);\n', '\n', '  //  Poll: full poll state\n', '  //\n', '  struct Poll\n', '  {\n', '    //  start: the timestamp at which the poll was started\n', '    //\n', '    uint256 start;\n', '\n', '    //  voted: per galaxy, whether they have voted on this poll\n', '    //\n', '    bool[256] voted;\n', '\n', '    //  yesVotes: amount of votes in favor of the proposal\n', '    //\n', '    uint16 yesVotes;\n', '\n', '    //  noVotes: amount of votes against the proposal\n', '    //\n', '    uint16 noVotes;\n', '\n', '    //  duration: amount of time during which the poll can be voted on\n', '    //\n', '    uint256 duration;\n', '\n', '    //  cooldown: amount of time before the (non-majority) poll can be reopened\n', '    //\n', '    uint256 cooldown;\n', '  }\n', '\n', '  //  pollDuration: duration set for new polls. see also Poll.duration above\n', '  //\n', '  uint256 public pollDuration;\n', '\n', '  //  pollCooldown: cooldown set for new polls. see also Poll.cooldown above\n', '  //\n', '  uint256 public pollCooldown;\n', '\n', '  //  totalVoters: amount of active galaxies\n', '  //\n', '  uint16 public totalVoters;\n', '\n', '  //  upgradeProposals: list of all upgrades ever proposed\n', '  //\n', '  //    this allows clients to discover the existence of polls.\n', '  //    from there, they can do liveness checks on the polls themselves.\n', '  //\n', '  address[] public upgradeProposals;\n', '\n', '  //  upgradePolls: per address, poll held to determine if that address\n', '  //                will become the new ecliptic\n', '  //\n', '  mapping(address => Poll) public upgradePolls;\n', '\n', '  //  upgradeHasAchievedMajority: per address, whether that address\n', '  //                              has ever achieved majority\n', '  //\n', '  //    If we did not store this, we would have to look at old poll data\n', '  //    to see whether or not a proposal has ever achieved majority.\n', '  //    Since the outcome of a poll is calculated based on :totalVoters,\n', '  //    which may not be consistent across time, we need to store outcomes\n', '  //    explicitly instead of re-calculating them. This allows us to always\n', '  //    tell with certainty whether or not a majority was achieved,\n', '  //    regardless of the current :totalVoters.\n', '  //\n', '  mapping(address => bool) public upgradeHasAchievedMajority;\n', '\n', '  //  documentProposals: list of all documents ever proposed\n', '  //\n', '  //    this allows clients to discover the existence of polls.\n', '  //    from there, they can do liveness checks on the polls themselves.\n', '  //\n', '  bytes32[] public documentProposals;\n', '\n', '  //  documentPolls: per hash, poll held to determine if the corresponding\n', '  //                 document is accepted by the galactic senate\n', '  //\n', '  mapping(bytes32 => Poll) public documentPolls;\n', '\n', '  //  documentHasAchievedMajority: per hash, whether that hash has ever\n', '  //                               achieved majority\n', '  //\n', '  //    the note for upgradeHasAchievedMajority above applies here as well\n', '  //\n', '  mapping(bytes32 => bool) public documentHasAchievedMajority;\n', '\n', '  //  documentMajorities: all hashes that have achieved majority\n', '  //\n', '  bytes32[] public documentMajorities;\n', '\n', '  //  constructor(): initial contract configuration\n', '  //\n', '  constructor(uint256 _pollDuration, uint256 _pollCooldown)\n', '    public\n', '  {\n', '    reconfigure(_pollDuration, _pollCooldown);\n', '  }\n', '\n', '  //  reconfigure(): change poll duration and cooldown\n', '  //\n', '  function reconfigure(uint256 _pollDuration, uint256 _pollCooldown)\n', '    public\n', '    onlyOwner\n', '  {\n', '    require( (5 days <= _pollDuration) && (_pollDuration <= 90 days) &&\n', '             (5 days <= _pollCooldown) && (_pollCooldown <= 90 days) );\n', '    pollDuration = _pollDuration;\n', '    pollCooldown = _pollCooldown;\n', '  }\n', '\n', '  //  incrementTotalVoters(): increase the amount of registered voters\n', '  //\n', '  function incrementTotalVoters()\n', '    external\n', '    onlyOwner\n', '  {\n', '    require(totalVoters < 256);\n', '    totalVoters = totalVoters.add(1);\n', '  }\n', '\n', '  //  getAllUpgradeProposals(): return array of all upgrade proposals ever made\n', '  //\n', '  //    Note: only useful for clients, as Solidity does not currently\n', '  //    support returning dynamic arrays.\n', '  //\n', '  function getUpgradeProposals()\n', '    external\n', '    view\n', '    returns (address[] proposals)\n', '  {\n', '    return upgradeProposals;\n', '  }\n', '\n', '  //  getUpgradeProposalCount(): get the number of unique proposed upgrades\n', '  //\n', '  function getUpgradeProposalCount()\n', '    external\n', '    view\n', '    returns (uint256 count)\n', '  {\n', '    return upgradeProposals.length;\n', '  }\n', '\n', '  //  getAllDocumentProposals(): return array of all upgrade proposals ever made\n', '  //\n', '  //    Note: only useful for clients, as Solidity does not currently\n', '  //    support returning dynamic arrays.\n', '  //\n', '  function getDocumentProposals()\n', '    external\n', '    view\n', '    returns (bytes32[] proposals)\n', '  {\n', '    return documentProposals;\n', '  }\n', '\n', '  //  getDocumentProposalCount(): get the number of unique proposed upgrades\n', '  //\n', '  function getDocumentProposalCount()\n', '    external\n', '    view\n', '    returns (uint256 count)\n', '  {\n', '    return documentProposals.length;\n', '  }\n', '\n', '  //  getDocumentMajorities(): return array of all document majorities\n', '  //\n', '  //    Note: only useful for clients, as Solidity does not currently\n', '  //    support returning dynamic arrays.\n', '  //\n', '  function getDocumentMajorities()\n', '    external\n', '    view\n', '    returns (bytes32[] majorities)\n', '  {\n', '    return documentMajorities;\n', '  }\n', '\n', '  //  hasVotedOnUpgradePoll(): returns true if _galaxy has voted\n', '  //                           on the _proposal\n', '  //\n', '  function hasVotedOnUpgradePoll(uint8 _galaxy, address _proposal)\n', '    external\n', '    view\n', '    returns (bool result)\n', '  {\n', '    return upgradePolls[_proposal].voted[_galaxy];\n', '  }\n', '\n', '  //  hasVotedOnDocumentPoll(): returns true if _galaxy has voted\n', '  //                            on the _proposal\n', '  //\n', '  function hasVotedOnDocumentPoll(uint8 _galaxy, bytes32 _proposal)\n', '    external\n', '    view\n', '    returns (bool result)\n', '  {\n', '    return documentPolls[_proposal].voted[_galaxy];\n', '  }\n', '\n', '  //  startUpgradePoll(): open a poll on making _proposal the new ecliptic\n', '  //\n', '  function startUpgradePoll(address _proposal)\n', '    external\n', '    onlyOwner\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!upgradeHasAchievedMajority[_proposal]);\n', '\n', '    Poll storage poll = upgradePolls[_proposal];\n', '\n', '    //  if the proposal is being made for the first time, register it.\n', '    //\n', '    if (0 == poll.start)\n', '    {\n', '      upgradeProposals.push(_proposal);\n', '    }\n', '\n', '    startPoll(poll);\n', '    emit UpgradePollStarted(_proposal);\n', '  }\n', '\n', '  //  startDocumentPoll(): open a poll on accepting the document\n', '  //                       whose hash is _proposal\n', '  //\n', '  function startDocumentPoll(bytes32 _proposal)\n', '    external\n', '    onlyOwner\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!documentHasAchievedMajority[_proposal]);\n', '\n', '    Poll storage poll = documentPolls[_proposal];\n', '\n', '    //  if the proposal is being made for the first time, register it.\n', '    //\n', '    if (0 == poll.start)\n', '    {\n', '      documentProposals.push(_proposal);\n', '    }\n', '\n', '    startPoll(poll);\n', '    emit DocumentPollStarted(_proposal);\n', '  }\n', '\n', '  //  startPoll(): open a new poll, or re-open an old one\n', '  //\n', '  function startPoll(Poll storage _poll)\n', '    internal\n', '  {\n', '    //  check that the poll has cooled down enough to be started again\n', '    //\n', '    //    for completely new polls, the values used will be zero\n', '    //\n', '    require( block.timestamp > ( _poll.start.add(\n', '                                 _poll.duration.add(\n', '                                 _poll.cooldown )) ) );\n', '\n', '    //  set started poll state\n', '    //\n', '    _poll.start = block.timestamp;\n', '    delete _poll.voted;\n', '    _poll.yesVotes = 0;\n', '    _poll.noVotes = 0;\n', '    _poll.duration = pollDuration;\n', '    _poll.cooldown = pollCooldown;\n', '  }\n', '\n', '  //  castUpgradeVote(): as galaxy _as, cast a vote on the _proposal\n', '  //\n', '  //    _vote is true when in favor of the proposal, false otherwise\n', '  //\n', '  function castUpgradeVote(uint8 _as, address _proposal, bool _vote)\n', '    external\n', '    onlyOwner\n', '    returns (bool majority)\n', '  {\n', '    Poll storage poll = upgradePolls[_proposal];\n', '    processVote(poll, _as, _vote);\n', '    return updateUpgradePoll(_proposal);\n', '  }\n', '\n', '  //  castDocumentVote(): as galaxy _as, cast a vote on the _proposal\n', '  //\n', '  //    _vote is true when in favor of the proposal, false otherwise\n', '  //\n', '  function castDocumentVote(uint8 _as, bytes32 _proposal, bool _vote)\n', '    external\n', '    onlyOwner\n', '    returns (bool majority)\n', '  {\n', '    Poll storage poll = documentPolls[_proposal];\n', '    processVote(poll, _as, _vote);\n', '    return updateDocumentPoll(_proposal);\n', '  }\n', '\n', '  //  processVote(): record a vote from _as on the _poll\n', '  //\n', '  function processVote(Poll storage _poll, uint8 _as, bool _vote)\n', '    internal\n', '  {\n', '    //  assist symbolic execution tools\n', '    //\n', '    assert(block.timestamp >= _poll.start);\n', '\n', '    require( //  may only vote once\n', '             //\n', '             !_poll.voted[_as] &&\n', '             //\n', '             //  may only vote when the poll is open\n', '             //\n', '             (block.timestamp < _poll.start.add(_poll.duration)) );\n', '\n', '    //  update poll state to account for the new vote\n', '    //\n', '    _poll.voted[_as] = true;\n', '    if (_vote)\n', '    {\n', '      _poll.yesVotes = _poll.yesVotes.add(1);\n', '    }\n', '    else\n', '    {\n', '      _poll.noVotes = _poll.noVotes.add(1);\n', '    }\n', '  }\n', '\n', '  //  updateUpgradePoll(): check whether the _proposal has achieved\n', '  //                            majority, updating state, sending an event,\n', '  //                            and returning true if it has\n', '  //\n', '  function updateUpgradePoll(address _proposal)\n', '    public\n', '    onlyOwner\n', '    returns (bool majority)\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!upgradeHasAchievedMajority[_proposal]);\n', '\n', '    //  check for majority in the poll\n', '    //\n', '    Poll storage poll = upgradePolls[_proposal];\n', '    majority = checkPollMajority(poll);\n', '\n', '    //  if majority was achieved, update the state and send an event\n', '    //\n', '    if (majority)\n', '    {\n', '      upgradeHasAchievedMajority[_proposal] = true;\n', '      emit UpgradeMajority(_proposal);\n', '    }\n', '    return majority;\n', '  }\n', '\n', '  //  updateDocumentPoll(): check whether the _proposal has achieved majority,\n', '  //                        updating the state and sending an event if it has\n', '  //\n', '  //    this can be called by anyone, because the ecliptic does not\n', '  //    need to be aware of the result\n', '  //\n', '  function updateDocumentPoll(bytes32 _proposal)\n', '    public\n', '    returns (bool majority)\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!documentHasAchievedMajority[_proposal]);\n', '\n', '    //  check for majority in the poll\n', '    //\n', '    Poll storage poll = documentPolls[_proposal];\n', '    majority = checkPollMajority(poll);\n', '\n', '    //  if majority was achieved, update state and send an event\n', '    //\n', '    if (majority)\n', '    {\n', '      documentHasAchievedMajority[_proposal] = true;\n', '      documentMajorities.push(_proposal);\n', '      emit DocumentMajority(_proposal);\n', '    }\n', '    return majority;\n', '  }\n', '\n', '  //  checkPollMajority(): returns true if the majority is in favor of\n', '  //                       the subject of the poll\n', '  //\n', '  function checkPollMajority(Poll _poll)\n', '    internal\n', '    view\n', '    returns (bool majority)\n', '  {\n', '    return ( //  poll must have at least the minimum required yes-votes\n', '             //\n', '             (_poll.yesVotes >= (totalVoters / 4)) &&\n', '             //\n', '             //  and have a majority...\n', '             //\n', '             (_poll.yesVotes > _poll.noVotes) &&\n', '             //\n', '             //  ...that is indisputable\n', '             //\n', '             ( //  either because the poll has ended\n', '               //\n', '               (block.timestamp > _poll.start.add(_poll.duration)) ||\n', '               //\n', '               //  or there are more yes votes than there can be no votes\n', '               //\n', '               ( _poll.yesVotes > totalVoters.sub(_poll.yesVotes) ) ) );\n', '  }\n', '}\n', '\n', "// Azimuth's Claims.sol\n", '\n', '//  Claims: simple identity management\n', '//\n', '//    This contract allows points to document claims about their owner.\n', "//    Most commonly, these are about identity, with a claim's protocol\n", '//    defining the context or platform of the claim, and its dossier\n', '//    containing proof of its validity.\n', '//    Points are limited to a maximum of 16 claims.\n', '//\n', '//    For existing claims, the dossier can be updated, or the claim can\n', '//    be removed entirely. It is recommended to remove any claims associated\n', '//    with a point when it is about to be transferred to a new owner.\n', '//    For convenience, the owner of the Azimuth contract (the Ecliptic)\n', '//    is allowed to clear claims for any point, allowing it to do this for\n', '//    you on-transfer.\n', '//\n', 'contract Claims is ReadsAzimuth\n', '{\n', '  //  ClaimAdded: a claim was added by :by\n', '  //\n', '  event ClaimAdded( uint32 indexed by,\n', '                    string _protocol,\n', '                    string _claim,\n', '                    bytes _dossier );\n', '\n', '  //  ClaimRemoved: a claim was removed by :by\n', '  //\n', '  event ClaimRemoved(uint32 indexed by, string _protocol, string _claim);\n', '\n', '  //  maxClaims: the amount of claims that can be registered per point\n', '  //\n', '  uint8 constant maxClaims = 16;\n', '\n', '  //  Claim: claim details\n', '  //\n', '  struct Claim\n', '  {\n', '    //  protocol: context of the claim\n', '    //\n', '    string protocol;\n', '\n', '    //  claim: the claim itself\n', '    //\n', '    string claim;\n', '\n', '    //  dossier: data relating to the claim, as proof\n', '    //\n', '    bytes dossier;\n', '  }\n', '\n', '  //  per point, list of claims\n', '  //\n', '  mapping(uint32 => Claim[maxClaims]) public claims;\n', '\n', '  //  constructor(): register the azimuth contract.\n', '  //\n', '  constructor(Azimuth _azimuth)\n', '    ReadsAzimuth(_azimuth)\n', '    public\n', '  {\n', '    //\n', '  }\n', '\n', '  //  addClaim(): register a claim as _point\n', '  //\n', '  function addClaim(uint32 _point,\n', '                    string _protocol,\n', '                    string _claim,\n', '                    bytes _dossier)\n', '    external\n', '    activePointManager(_point)\n', '  {\n', '    //  cur: index + 1 of the claim if it already exists, 0 otherwise\n', '    //\n', '    uint8 cur = findClaim(_point, _protocol, _claim);\n', '\n', "    //  if the claim doesn't yet exist, store it in state\n", '    //\n', '    if (cur == 0)\n', '    {\n', '      //  if there are no empty slots left, this throws\n', '      //\n', '      uint8 empty = findEmptySlot(_point);\n', '      claims[_point][empty] = Claim(_protocol, _claim, _dossier);\n', '    }\n', '    //\n', '    //  if the claim has been made before, update the version in state\n', '    //\n', '    else\n', '    {\n', '      claims[_point][cur-1] = Claim(_protocol, _claim, _dossier);\n', '    }\n', '    emit ClaimAdded(_point, _protocol, _claim, _dossier);\n', '  }\n', '\n', '  //  removeClaim(): unregister a claim as _point\n', '  //\n', '  function removeClaim(uint32 _point, string _protocol, string _claim)\n', '    external\n', '    activePointManager(_point)\n', '  {\n', "    //  i: current index + 1 in _point's list of claims\n", '    //\n', '    uint256 i = findClaim(_point, _protocol, _claim);\n', '\n', '    //  we store index + 1, because 0 is the eth default value\n', '    //  can only delete an existing claim\n', '    //\n', '    require(i > 0);\n', '    i--;\n', '\n', '    //  clear out the claim\n', '    //\n', '    delete claims[_point][i];\n', '\n', '    emit ClaimRemoved(_point, _protocol, _claim);\n', '  }\n', '\n', "  //  clearClaims(): unregister all of _point's claims\n", '  //\n', '  //    can also be called by the ecliptic during point transfer\n', '  //\n', '  function clearClaims(uint32 _point)\n', '    external\n', '  {\n', '    //  both point owner and ecliptic may do this\n', '    //\n', "    //    We do not necessarily need to check for _point's active flag here,\n", '    //    since inactive points cannot have claims set. Doing the check\n', '    //    anyway would make this function slightly harder to think about due\n', "    //    to its relation to Ecliptic's transferPoint().\n", '    //\n', '    require( azimuth.canManage(_point, msg.sender) ||\n', '             ( msg.sender == azimuth.owner() ) );\n', '\n', '    Claim[maxClaims] storage currClaims = claims[_point];\n', '\n', '    //  clear out all claims\n', '    //\n', '    for (uint8 i = 0; i < maxClaims; i++)\n', '    {\n', '      delete currClaims[i];\n', '    }\n', '  }\n', '\n', '  //  findClaim(): find the index of the specified claim\n', '  //\n', '  //    returns 0 if not found, index + 1 otherwise\n', '  //\n', '  function findClaim(uint32 _whose, string _protocol, string _claim)\n', '    public\n', '    view\n', '    returns (uint8 index)\n', '  {\n', "    //  we use hashes of the string because solidity can't do string\n", '    //  comparison yet\n', '    //\n', '    bytes32 protocolHash = keccak256(bytes(_protocol));\n', '    bytes32 claimHash = keccak256(bytes(_claim));\n', '    Claim[maxClaims] storage theirClaims = claims[_whose];\n', '    for (uint8 i = 0; i < maxClaims; i++)\n', '    {\n', '      Claim storage thisClaim = theirClaims[i];\n', '      if ( ( protocolHash == keccak256(bytes(thisClaim.protocol)) ) &&\n', '           ( claimHash == keccak256(bytes(thisClaim.claim)) ) )\n', '      {\n', '        return i+1;\n', '      }\n', '    }\n', '    return 0;\n', '  }\n', '\n', '  //  findEmptySlot(): find the index of the first empty claim slot\n', '  //\n', '  //    returns the index of the slot, throws if there are no empty slots\n', '  //\n', '  function findEmptySlot(uint32 _whose)\n', '    internal\n', '    view\n', '    returns (uint8 index)\n', '  {\n', '    Claim[maxClaims] storage theirClaims = claims[_whose];\n', '    for (uint8 i = 0; i < maxClaims; i++)\n', '    {\n', '      Claim storage thisClaim = theirClaims[i];\n', '      if ( (0 == bytes(thisClaim.protocol).length) &&\n', '           (0 == bytes(thisClaim.claim).length) )\n', '      {\n', '        return i;\n', '      }\n', '    }\n', '    revert();\n', '  }\n', '}\n', '\n', "// Azimuth's EclipticBase.sol\n", '\n', '//  EclipticBase: upgradable ecliptic\n', '//\n', '//    This contract implements the upgrade logic for the Ecliptic.\n', '//    Newer versions of the Ecliptic are expected to provide at least\n', "//    the onUpgrade() function. If they don't, upgrading to them will\n", '//    fail.\n', '//\n', "//    Note that even though this contract doesn't specify any required\n", '//    interface members aside from upgrade() and onUpgrade(), contracts\n', '//    and clients may still rely on the presence of certain functions\n', '//    provided by the Ecliptic proper. Keep this in mind when writing\n', '//    new versions of it.\n', '//\n', 'contract EclipticBase is Ownable, ReadsAzimuth\n', '{\n', '  //  Upgraded: _to is the new canonical Ecliptic\n', '  //\n', '  event Upgraded(address to);\n', '\n', '  //  polls: senate voting contract\n', '  //\n', '  Polls public polls;\n', '\n', '  //  previousEcliptic: address of the previous ecliptic this\n', '  //                    instance expects to upgrade from, stored and\n', '  //                    checked for to prevent unexpected upgrade paths\n', '  //\n', '  address public previousEcliptic;\n', '\n', '  constructor( address _previous,\n', '               Azimuth _azimuth,\n', '               Polls _polls )\n', '    ReadsAzimuth(_azimuth)\n', '    internal\n', '  {\n', '    previousEcliptic = _previous;\n', '    polls = _polls;\n', '  }\n', '\n', '  //  onUpgrade(): called by previous ecliptic when upgrading\n', '  //\n', '  //    in future ecliptics, this might perform more logic than\n', '  //    just simple checks and verifications.\n', '  //    when overriding this, make sure to call this original as well.\n', '  //\n', '  function onUpgrade()\n', '    external\n', '  {\n', '    //  make sure this is the expected upgrade path,\n', '    //  and that we have gotten the ownership we require\n', '    //\n', '    require( msg.sender == previousEcliptic &&\n', '             this == azimuth.owner() &&\n', '             this == polls.owner() );\n', '  }\n', '\n', '  //  upgrade(): transfer ownership of the ecliptic data to the new\n', '  //             ecliptic contract, notify it, then self-destruct.\n', '  //\n', '  //    Note: any eth that have somehow ended up in this contract\n', '  //          are also sent to the new ecliptic.\n', '  //\n', '  function upgrade(EclipticBase _new)\n', '    internal\n', '  {\n', '    //  transfer ownership of the data contracts\n', '    //\n', '    azimuth.transferOwnership(_new);\n', '    polls.transferOwnership(_new);\n', '\n', '    //  trigger upgrade logic on the target contract\n', '    //\n', '    _new.onUpgrade();\n', '\n', '    //  emit event and destroy this contract\n', '    //\n', '    emit Upgraded(_new);\n', '    selfdestruct(_new);\n', '  }\n', '}\n', '\n', "// Azimuth's Ecliptic.sol\n", '\n', '//  Ecliptic: logic for interacting with the Azimuth ledger\n', '//\n', '//    This contract is the point of entry for all operations on the Azimuth\n', '//    ledger as stored in the Azimuth data contract. The functions herein\n', '//    are responsible for performing all necessary business logic.\n', '//    Examples of such logic include verifying permissions of the caller\n', '//    and ensuring a requested change is actually valid.\n', '//    Point owners can always operate on their own points. Ethereum addresses\n', "//    can also perform specific operations if they've been given the\n", '//    appropriate permissions. (For example, managers for general management,\n', '//    spawn proxies for spawning child points, etc.)\n', '//\n', '//    This contract uses external contracts (Azimuth, Polls) for data storage\n', '//    so that it itself can easily be replaced in case its logic needs to\n', '//    be changed. In other words, it can be upgraded. It does this by passing\n', '//    ownership of the data contracts to a new Ecliptic contract.\n', '//\n', "//    Because of this, it is advised for clients to not store this contract's\n", '//    address directly, but rather ask the Azimuth contract for its owner\n', '//    attribute to ensure transactions get sent to the latest Ecliptic.\n', '//    Alternatively, the ENS name ecliptic.eth will resolve to the latest\n', '//    Ecliptic as well.\n', '//\n', '//    Upgrading happens based on polls held by the senate (galaxy owners).\n', '//    Through this contract, the senate can submit proposals, opening polls\n', '//    for the senate to cast votes on. These proposals can be either hashes\n', '//    of documents or addresses of new Ecliptics.\n', '//    If an ecliptic proposal gains majority, this contract will transfer\n', '//    ownership of the data storage contracts to that address, so that it may\n', '//    operate on the data they contain. This contract will selfdestruct at\n', '//    the end of the upgrade process.\n', '//\n', '//    This contract implements the ERC721 interface for non-fungible tokens,\n', '//    allowing points to be managed using generic clients that support the\n', '//    standard. It also implements ERC165 to allow this to be discovered.\n', '//\n', 'contract Ecliptic is EclipticBase, SupportsInterfaceWithLookup, ERC721Metadata\n', '{\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  //  Transfer: This emits when ownership of any NFT changes by any mechanism.\n', '  //            This event emits when NFTs are created (`from` == 0) and\n', '  //            destroyed (`to` == 0). At the time of any transfer, the\n', '  //            approved address for that NFT (if any) is reset to none.\n', '  //\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '  //  Approval: This emits when the approved address for an NFT is changed or\n', '  //            reaffirmed. The zero address indicates there is no approved\n', '  //            address. When a Transfer event emits, this also indicates that\n', '  //            the approved address for that NFT (if any) is reset to none.\n', '  //\n', '  event Approval(address indexed _owner, address indexed _approved,\n', '                 uint256 _tokenId);\n', '\n', '  //  ApprovalForAll: This emits when an operator is enabled or disabled for an\n', '  //                  owner. The operator can manage all NFTs of the owner.\n', '  //\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator,\n', '                       bool _approved);\n', '\n', '  // erc721Received: equal to:\n', '  //        bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))\n', '  //                 which can be also obtained as:\n', '  //        ERC721Receiver(0).onERC721Received.selector`\n', '  bytes4 constant erc721Received = 0x150b7a02;\n', '\n', '  //  claims: contract reference, for clearing claims on-transfer\n', '  //\n', '  Claims public claims;\n', '\n', '  //  constructor(): set data contract addresses and signal interface support\n', '  //\n', '  //    Note: during first deploy, ownership of these data contracts must\n', '  //    be manually transferred to this contract.\n', '  //\n', '  constructor(address _previous,\n', '              Azimuth _azimuth,\n', '              Polls _polls,\n', '              Claims _claims)\n', '    EclipticBase(_previous, _azimuth, _polls)\n', '    public\n', '  {\n', '    claims = _claims;\n', '\n', '    //  register supported interfaces for ERC165\n', '    //\n', '    _registerInterface(0x80ac58cd); // ERC721\n', '    _registerInterface(0x5b5e139f); // ERC721Metadata\n', '    _registerInterface(0x7f5828d0); // ERC173 (ownership)\n', '  }\n', '\n', '  //\n', '  //  ERC721 interface\n', '  //\n', '\n', '    //  balanceOf(): get the amount of points owned by _owner\n', '    //\n', '    function balanceOf(address _owner)\n', '      public\n', '      view\n', '      returns (uint256 balance)\n', '    {\n', '      require(0x0 != _owner);\n', '      return azimuth.getOwnedPointCount(_owner);\n', '    }\n', '\n', '    //  ownerOf(): get the current owner of point _tokenId\n', '    //\n', '    function ownerOf(uint256 _tokenId)\n', '      public\n', '      view\n', '      validPointId(_tokenId)\n', '      returns (address owner)\n', '    {\n', '      uint32 id = uint32(_tokenId);\n', '\n', '      //  this will throw if the owner is the zero address,\n', '      //  active points always have a valid owner.\n', '      //\n', '      require(azimuth.isActive(id));\n', '\n', '      return azimuth.getOwner(id);\n', '    }\n', '\n', '    //  exists(): returns true if point _tokenId is active\n', '    //\n', '    function exists(uint256 _tokenId)\n', '      public\n', '      view\n', '      returns (bool doesExist)\n', '    {\n', '      return ( (_tokenId < 0x100000000) &&\n', '               azimuth.isActive(uint32(_tokenId)) );\n', '    }\n', '\n', '    //  safeTransferFrom(): transfer point _tokenId from _from to _to\n', '    //\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n', '      public\n', '    {\n', '      //  transfer with empty data\n', '      //\n', '      safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    //  safeTransferFrom(): transfer point _tokenId from _from to _to,\n', "    //                      and call recipient if it's a contract\n", '    //\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId,\n', '                              bytes _data)\n', '      public\n', '    {\n', '      //  perform raw transfer\n', '      //\n', '      transferFrom(_from, _to, _tokenId);\n', '\n', '      //  do the callback last to avoid re-entrancy\n', '      //\n', '      if (_to.isContract())\n', '      {\n', '        bytes4 retval = ERC721Receiver(_to)\n', '                        .onERC721Received(msg.sender, _from, _tokenId, _data);\n', '        //\n', '        //  standard return idiom to confirm contract semantics\n', '        //\n', '        require(retval == erc721Received);\n', '      }\n', '    }\n', '\n', '    //  transferFrom(): transfer point _tokenId from _from to _to,\n', '    //                  WITHOUT notifying recipient contract\n', '    //\n', '    function transferFrom(address _from, address _to, uint256 _tokenId)\n', '      public\n', '      validPointId(_tokenId)\n', '    {\n', '      uint32 id = uint32(_tokenId);\n', '      require(azimuth.isOwner(id, _from));\n', '\n', '      //  the ERC721 operator/approved address (if any) is\n', '      //  accounted for in transferPoint()\n', '      //\n', '      transferPoint(id, _to, true);\n', '    }\n', '\n', '    //  approve(): allow _approved to transfer ownership of point\n', '    //             _tokenId\n', '    //\n', '    function approve(address _approved, uint256 _tokenId)\n', '      public\n', '      validPointId(_tokenId)\n', '    {\n', '      setTransferProxy(uint32(_tokenId), _approved);\n', '    }\n', '\n', '    //  setApprovalForAll(): allow or disallow _operator to\n', '    //                       transfer ownership of ALL points\n', '    //                       owned by :msg.sender\n', '    //\n', '    function setApprovalForAll(address _operator, bool _approved)\n', '      public\n', '    {\n', '      require(0x0 != _operator);\n', '      azimuth.setOperator(msg.sender, _operator, _approved);\n', '      emit ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '\n', '    //  getApproved(): get the approved address for point _tokenId\n', '    //\n', '    function getApproved(uint256 _tokenId)\n', '      public\n', '      view\n', '      validPointId(_tokenId)\n', '      returns (address approved)\n', '    {\n', '      //NOTE  redundant, transfer proxy cannot be set for\n', '      //      inactive points\n', '      //\n', '      require(azimuth.isActive(uint32(_tokenId)));\n', '      return azimuth.getTransferProxy(uint32(_tokenId));\n', '    }\n', '\n', '    //  isApprovedForAll(): returns true if _operator is an\n', '    //                      operator for _owner\n', '    //\n', '    function isApprovedForAll(address _owner, address _operator)\n', '      public\n', '      view\n', '      returns (bool result)\n', '    {\n', '      return azimuth.isOperator(_owner, _operator);\n', '    }\n', '\n', '  //\n', '  //  ERC721Metadata interface\n', '  //\n', '\n', '    //  name(): returns the name of a collection of points\n', '    //\n', '    function name()\n', '      external\n', '      view\n', '      returns (string)\n', '    {\n', '      return "Azimuth Points";\n', '    }\n', '\n', '    //  symbol(): returns an abbreviates name for points\n', '    //\n', '    function symbol()\n', '      external\n', '      view\n', '      returns (string)\n', '    {\n', '      return "AZP";\n', '    }\n', '\n', '    //  tokenURI(): returns a URL to an ERC-721 standard JSON file\n', '    //\n', '    function tokenURI(uint256 _tokenId)\n', '      public\n', '      view\n', '      validPointId(_tokenId)\n', '      returns (string _tokenURI)\n', '    {\n', '      _tokenURI = "https://azimuth.network/erc721/0000000000.json";\n', '      bytes memory _tokenURIBytes = bytes(_tokenURI);\n', '      _tokenURIBytes[31] = byte(48+(_tokenId / 1000000000) % 10);\n', '      _tokenURIBytes[32] = byte(48+(_tokenId / 100000000) % 10);\n', '      _tokenURIBytes[33] = byte(48+(_tokenId / 10000000) % 10);\n', '      _tokenURIBytes[34] = byte(48+(_tokenId / 1000000) % 10);\n', '      _tokenURIBytes[35] = byte(48+(_tokenId / 100000) % 10);\n', '      _tokenURIBytes[36] = byte(48+(_tokenId / 10000) % 10);\n', '      _tokenURIBytes[37] = byte(48+(_tokenId / 1000) % 10);\n', '      _tokenURIBytes[38] = byte(48+(_tokenId / 100) % 10);\n', '      _tokenURIBytes[39] = byte(48+(_tokenId / 10) % 10);\n', '      _tokenURIBytes[40] = byte(48+(_tokenId / 1) % 10);\n', '    }\n', '\n', '  //\n', '  //  Points interface\n', '  //\n', '\n', '    //  configureKeys(): configure _point with network public keys\n', '    //                   _encryptionKey, _authenticationKey,\n', '    //                   and corresponding _cryptoSuiteVersion,\n', "    //                   incrementing the point's continuity number if needed\n", '    //\n', '    function configureKeys(uint32 _point,\n', '                           bytes32 _encryptionKey,\n', '                           bytes32 _authenticationKey,\n', '                           uint32 _cryptoSuiteVersion,\n', '                           bool _discontinuous)\n', '      external\n', '      activePointManager(_point)\n', '    {\n', '      if (_discontinuous)\n', '      {\n', '        azimuth.incrementContinuityNumber(_point);\n', '      }\n', '      azimuth.setKeys(_point,\n', '                      _encryptionKey,\n', '                      _authenticationKey,\n', '                      _cryptoSuiteVersion);\n', '    }\n', '\n', '    //  spawn(): spawn _point, then either give, or allow _target to take,\n', '    //           ownership of _point\n', '    //\n', '    //    if _target is the :msg.sender, _targets owns the _point right away.\n', '    //    otherwise, _target becomes the transfer proxy of _point.\n', '    //\n', '    //    Requirements:\n', '    //    - _point must not be active\n', '    //    - _point must not be a planet with a galaxy prefix\n', "    //    - _point's prefix must be linked and under its spawn limit\n", "    //    - :msg.sender must be either the owner of _point's prefix,\n", '    //      or an authorized spawn proxy for it\n', '    //\n', '    function spawn(uint32 _point, address _target)\n', '      external\n', '    {\n', '      //  only currently unowned (and thus also inactive) points can be spawned\n', '      //\n', '      require(azimuth.isOwner(_point, 0x0));\n', '\n', '      //  prefix: half-width prefix of _point\n', '      //\n', '      uint16 prefix = azimuth.getPrefix(_point);\n', '\n', '      //  only allow spawning of points of the size directly below the prefix\n', '      //\n', '      //    this is possible because of how the address space works,\n', '      //    but supporting it introduces complexity through broken assumptions.\n', '      //\n', '      //    example:\n', '      //    0x0000.0000 - galaxy zero\n', '      //    0x0000.0100 - the first star of galaxy zero\n', '      //    0x0001.0100 - the first planet of the first star\n', '      //    0x0001.0000 - the first planet of galaxy zero\n', '      //\n', '      require( (uint8(azimuth.getPointSize(prefix)) + 1) ==\n', '               uint8(azimuth.getPointSize(_point)) );\n', '\n', '      //  prefix point must be linked and able to spawn\n', '      //\n', '      require( (azimuth.hasBeenLinked(prefix)) &&\n', '               ( azimuth.getSpawnCount(prefix) <\n', '                 getSpawnLimit(prefix, block.timestamp) ) );\n', '\n', '      //  the owner of a prefix can always spawn its children;\n', '      //  other addresses need explicit permission (the role\n', '      //  of "spawnProxy" in the Azimuth contract)\n', '      //\n', '      require( azimuth.canSpawnAs(prefix, msg.sender) );\n', '\n', '      //  if the caller is spawning the point to themselves,\n', "      //  assume it knows what it's doing and resolve right away\n", '      //\n', '      if (msg.sender == _target)\n', '      {\n', '        doSpawn(_point, _target, true, 0x0);\n', '      }\n', '      //\n', '      //  when sending to a "foreign" address, enforce a withdraw pattern\n', "      //  making the _point prefix's owner the _point owner in the mean time\n", '      //\n', '      else\n', '      {\n', '        doSpawn(_point, _target, false, azimuth.getOwner(prefix));\n', '      }\n', '    }\n', '\n', '    //  doSpawn(): actual spawning logic, used in spawn(). creates _point,\n', '    //             making the _target its owner if _direct, or making the\n', '    //             _holder the owner and the _target the transfer proxy\n', '    //             if not _direct.\n', '    //\n', '    function doSpawn( uint32 _point,\n', '                      address _target,\n', '                      bool _direct,\n', '                      address _holder )\n', '      internal\n', '    {\n', "      //  register the spawn for _point's prefix, incrementing spawn count\n", '      //\n', '      azimuth.registerSpawned(_point);\n', '\n', "      //  if the spawn is _direct, assume _target knows what they're doing\n", '      //  and resolve right away\n', '      //\n', '      if (_direct)\n', '      {\n', '        //  make the point active and set its new owner\n', '        //\n', '        azimuth.activatePoint(_point);\n', '        azimuth.setOwner(_point, _target);\n', '\n', '        emit Transfer(0x0, _target, uint256(_point));\n', '      }\n', '      //\n', '      //  when spawning indirectly, enforce a withdraw pattern by approving\n', '      //  the _target for transfer of the _point instead.\n', '      //  we make the _holder the owner of this _point in the mean time,\n', '      //  so that it may cancel the transfer (un-approve) if _target flakes.\n', "      //  we don't make _point active yet, because it still doesn't really\n", '      //  belong to anyone.\n', '      //\n', '      else\n', '      {\n', '        //  have _holder hold on to the _point while _target gets to transfer\n', '        //  ownership of it\n', '        //\n', '        azimuth.setOwner(_point, _holder);\n', '        azimuth.setTransferProxy(_point, _target);\n', '\n', '        emit Transfer(0x0, _holder, uint256(_point));\n', '        emit Approval(_holder, _target, uint256(_point));\n', '      }\n', '    }\n', '\n', '    //  transferPoint(): transfer _point to _target, clearing all permissions\n', '    //                   data and keys if _reset is true\n', '    //\n', '    //    Note: the _reset flag is useful when transferring the point to\n', "    //    a recipient who doesn't trust the previous owner.\n", '    //\n', '    //    Requirements:\n', "    //    - :msg.sender must be either _point's current owner, authorized\n", '    //      to transfer _point, or authorized to transfer the current\n', "    //      owner's points (as in ERC721's operator)\n", '    //    - _target must not be the zero address\n', '    //\n', '    function transferPoint(uint32 _point, address _target, bool _reset)\n', '      public\n', '    {\n', '      //  transfer is legitimate if the caller is the current owner, or\n', "      //  an operator for the current owner, or the _point's transfer proxy\n", '      //\n', '      require(azimuth.canTransfer(_point, msg.sender));\n', '\n', "      //  if the point wasn't active yet, that means transferring it\n", '      //  is part of the "spawn" flow, so we need to activate it\n', '      //\n', '      if ( !azimuth.isActive(_point) )\n', '      {\n', '        azimuth.activatePoint(_point);\n', '      }\n', '\n', '      //  if the owner would actually change, change it\n', '      //\n', "      //    the only time this deliberately wouldn't be the case is when a\n", '      //    prefix owner wants to activate a spawned but untransferred child.\n', '      //\n', '      if ( !azimuth.isOwner(_point, _target) )\n', '      {\n', '        //  remember the previous owner, to be included in the Transfer event\n', '        //\n', '        address old = azimuth.getOwner(_point);\n', '\n', '        azimuth.setOwner(_point, _target);\n', '\n', '        //  according to ERC721, the approved address (here, transfer proxy)\n', '        //  gets cleared during every Transfer event\n', '        //\n', '        azimuth.setTransferProxy(_point, 0);\n', '\n', '        emit Transfer(old, _target, uint256(_point));\n', '      }\n', '\n', '      //  reset sensitive data\n', '      //  used when transferring the point to a new owner\n', '      //\n', '      if ( _reset )\n', '      {\n', '        //  clear the network public keys and break continuity,\n', '        //  but only if the point has already been linked\n', '        //\n', '        if ( azimuth.hasBeenLinked(_point) )\n', '        {\n', '          azimuth.incrementContinuityNumber(_point);\n', '          azimuth.setKeys(_point, 0, 0, 0);\n', '        }\n', '\n', '        //  clear management proxy\n', '        //\n', '        azimuth.setManagementProxy(_point, 0);\n', '\n', '        //  clear voting proxy\n', '        //\n', '        azimuth.setVotingProxy(_point, 0);\n', '\n', '        //  clear transfer proxy\n', '        //\n', '        //    in most cases this is done above, during the ownership transfer,\n', '        //    but we might not hit that and still be expected to reset the\n', '        //    transfer proxy.\n', '        //    doing it a second time is a no-op in Azimuth.\n', '        //\n', '        azimuth.setTransferProxy(_point, 0);\n', '\n', '        //  clear spawning proxy\n', '        //\n', '        azimuth.setSpawnProxy(_point, 0);\n', '\n', '        //  clear claims\n', '        //\n', '        claims.clearClaims(_point);\n', '      }\n', '    }\n', '\n', '    //  escape(): request escape as _point to _sponsor\n', '    //\n', '    //    if an escape request is already active, this overwrites\n', '    //    the existing request\n', '    //\n', '    //    Requirements:\n', '    //    - :msg.sender must be the owner or manager of _point,\n', '    //    - _point must be able to escape to _sponsor as per to canEscapeTo()\n', '    //\n', '    function escape(uint32 _point, uint32 _sponsor)\n', '      external\n', '      activePointManager(_point)\n', '    {\n', '      require(canEscapeTo(_point, _sponsor));\n', '      azimuth.setEscapeRequest(_point, _sponsor);\n', '    }\n', '\n', '    //  cancelEscape(): cancel the currently set escape for _point\n', '    //\n', '    function cancelEscape(uint32 _point)\n', '      external\n', '      activePointManager(_point)\n', '    {\n', '      azimuth.cancelEscape(_point);\n', '    }\n', '\n', '    //  adopt(): as the relevant sponsor, accept the _point\n', '    //\n', '    //    Requirements:\n', '    //    - :msg.sender must be the owner or management proxy\n', "    //      of _point's requested sponsor\n", '    //\n', '    function adopt(uint32 _point)\n', '      external\n', '    {\n', '      require( azimuth.isEscaping(_point) &&\n', '               azimuth.canManage( azimuth.getEscapeRequest(_point),\n', '                                  msg.sender ) );\n', '\n', "      //  _sponsor becomes _point's sponsor\n", '      //  its escape request is reset to "not escaping"\n', '      //\n', '      azimuth.doEscape(_point);\n', '    }\n', '\n', "    //  reject(): as the relevant sponsor, deny the _point's request\n", '    //\n', '    //    Requirements:\n', '    //    - :msg.sender must be the owner or management proxy\n', "    //      of _point's requested sponsor\n", '    //\n', '    function reject(uint32 _point)\n', '      external\n', '    {\n', '      require( azimuth.isEscaping(_point) &&\n', '               azimuth.canManage( azimuth.getEscapeRequest(_point),\n', '                                  msg.sender ) );\n', '\n', '      //  reset the _point\'s escape request to "not escaping"\n', '      //\n', '      azimuth.cancelEscape(_point);\n', '    }\n', '\n', '    //  detach(): as the _sponsor, stop sponsoring the _point\n', '    //\n', '    //    Requirements:\n', '    //    - :msg.sender must be the owner or management proxy\n', "    //      of _point's current sponsor\n", '    //\n', '    function detach(uint32 _point)\n', '      external\n', '    {\n', '      require( azimuth.hasSponsor(_point) &&\n', '               azimuth.canManage(azimuth.getSponsor(_point), msg.sender) );\n', '\n', '      //  signal that its sponsor no longer supports _point\n', '      //\n', '      azimuth.loseSponsor(_point);\n', '    }\n', '\n', '  //\n', '  //  Point rules\n', '  //\n', '\n', '    //  getSpawnLimit(): returns the total number of children the _point\n', '    //                   is allowed to spawn at _time.\n', '    //\n', '    function getSpawnLimit(uint32 _point, uint256 _time)\n', '      public\n', '      view\n', '      returns (uint32 limit)\n', '    {\n', '      Azimuth.Size size = azimuth.getPointSize(_point);\n', '\n', '      if ( size == Azimuth.Size.Galaxy )\n', '      {\n', '        return 255;\n', '      }\n', '      else if ( size == Azimuth.Size.Star )\n', '      {\n', '        //  in 2019, stars may spawn at most 1024 planets. this limit doubles\n', '        //  for every subsequent year.\n', '        //\n', '        //    Note: 1546300800 corresponds to 2019-01-01\n', '        //\n', '        uint256 yearsSince2019 = (_time - 1546300800) / 365 days;\n', '        if (yearsSince2019 < 6)\n', '        {\n', '          limit = uint32( 1024 * (2 ** yearsSince2019) );\n', '        }\n', '        else\n', '        {\n', '          limit = 65535;\n', '        }\n', '        return limit;\n', '      }\n', '      else  //  size == Azimuth.Size.Planet\n', '      {\n', "        //  planets can create moons, but moons aren't on the chain\n", '        //\n', '        return 0;\n', '      }\n', '    }\n', '\n', '    //  canEscapeTo(): true if _point could try to escape to _sponsor\n', '    //\n', '    function canEscapeTo(uint32 _point, uint32 _sponsor)\n', '      public\n', '      view\n', '      returns (bool canEscape)\n', '    {\n', "      //  can't escape to a sponsor that hasn't been linked\n", '      //\n', '      if ( !azimuth.hasBeenLinked(_sponsor) ) return false;\n', '\n', '      //  Can only escape to a point one size higher than ourselves,\n', "      //  except in the special case where the escaping point hasn't\n", '      //  been linked yet -- in that case we may escape to points of\n', '      //  the same size, to support lightweight invitation chains.\n', '      //\n', '      //  The use case for lightweight invitations is that a planet\n', '      //  owner should be able to invite their friends onto an\n', '      //  Azimuth network in a two-party transaction, without a new\n', '      //  star relationship.\n', '      //  The lightweight invitation process works by escaping your\n', '      //  own active (but never linked) point to one of your own\n', '      //  points, then transferring the point to your friend.\n', '      //\n', '      //  These planets can, in turn, sponsor other unlinked planets,\n', '      //  so the "planet sponsorship chain" can grow to arbitrary\n', '      //  length. Most users, especially deep down the chain, will\n', '      //  want to improve their performance by switching to direct\n', '      //  star sponsors eventually.\n', '      //\n', '      Azimuth.Size pointSize = azimuth.getPointSize(_point);\n', '      Azimuth.Size sponsorSize = azimuth.getPointSize(_sponsor);\n', '      return ( //  normal hierarchical escape structure\n', '               //\n', '               ( (uint8(sponsorSize) + 1) == uint8(pointSize) ) ||\n', '               //\n', '               //  special peer escape\n', '               //\n', '               ( (sponsorSize == pointSize) &&\n', '                 //\n', "                 //  peer escape is only for points that haven't been linked\n", "                 //  yet, because it's only for lightweight invitation chains\n", '                 //\n', '                 !azimuth.hasBeenLinked(_point) ) );\n', '    }\n', '\n', '  //\n', '  //  Permission management\n', '  //\n', '\n', '    //  setManagementProxy(): configure the management proxy for _point\n', '    //\n', '    //    The management proxy may perform "reversible" operations on\n', '    //    behalf of the owner. This includes public key configuration and\n', '    //    operations relating to sponsorship.\n', '    //\n', '    function setManagementProxy(uint32 _point, address _manager)\n', '      external\n', '      activePointOwner(_point)\n', '    {\n', '      azimuth.setManagementProxy(_point, _manager);\n', '    }\n', '\n', '    //  setSpawnProxy(): give _spawnProxy the right to spawn points\n', '    //                   with the prefix _prefix\n', '    //\n', '    function setSpawnProxy(uint16 _prefix, address _spawnProxy)\n', '      external\n', '      activePointOwner(_prefix)\n', '    {\n', '      azimuth.setSpawnProxy(_prefix, _spawnProxy);\n', '    }\n', '\n', '    //  setVotingProxy(): configure the voting proxy for _galaxy\n', '    //\n', '    //    the voting proxy is allowed to start polls and cast votes\n', "    //    on the point's behalf.\n", '    //\n', '    function setVotingProxy(uint8 _galaxy, address _voter)\n', '      external\n', '      activePointOwner(_galaxy)\n', '    {\n', '      azimuth.setVotingProxy(_galaxy, _voter);\n', '    }\n', '\n', '    //  setTransferProxy(): give _transferProxy the right to transfer _point\n', '    //\n', '    //    Requirements:\n', "    //    - :msg.sender must be either _point's current owner,\n", '    //      or be an operator for the current owner\n', '    //\n', '    function setTransferProxy(uint32 _point, address _transferProxy)\n', '      public\n', '    {\n', '      //  owner: owner of _point\n', '      //\n', '      address owner = azimuth.getOwner(_point);\n', '\n', '      //  caller must be :owner, or an operator designated by the owner.\n', '      //\n', '      require((owner == msg.sender) || azimuth.isOperator(owner, msg.sender));\n', '\n', '      //  set transfer proxy field in Azimuth contract\n', '      //\n', '      azimuth.setTransferProxy(_point, _transferProxy);\n', '\n', '      //  emit Approval event\n', '      //\n', '      emit Approval(owner, _transferProxy, uint256(_point));\n', '    }\n', '\n', '  //\n', '  //  Poll actions\n', '  //\n', '\n', '    //  startUpgradePoll(): as _galaxy, start a poll for the ecliptic\n', '    //                      upgrade _proposal\n', '    //\n', '    //    Requirements:\n', '    //    - :msg.sender must be the owner or voting proxy of _galaxy,\n', '    //    - the _proposal must expect to be upgraded from this specific\n', '    //      contract, as indicated by its previousEcliptic attribute\n', '    //\n', '    function startUpgradePoll(uint8 _galaxy, EclipticBase _proposal)\n', '      external\n', '      activePointVoter(_galaxy)\n', '    {\n', '      //  ensure that the upgrade target expects this contract as the source\n', '      //\n', '      require(_proposal.previousEcliptic() == address(this));\n', '      polls.startUpgradePoll(_proposal);\n', '    }\n', '\n', '    //  startDocumentPoll(): as _galaxy, start a poll for the _proposal\n', '    //\n', '    //    the _proposal argument is the keccak-256 hash of any arbitrary\n', '    //    document or string of text\n', '    //\n', '    function startDocumentPoll(uint8 _galaxy, bytes32 _proposal)\n', '      external\n', '      activePointVoter(_galaxy)\n', '    {\n', '      polls.startDocumentPoll(_proposal);\n', '    }\n', '\n', '    //  castUpgradeVote(): as _galaxy, cast a _vote on the ecliptic\n', '    //                     upgrade _proposal\n', '    //\n', '    //    _vote is true when in favor of the proposal, false otherwise\n', '    //\n', '    //    If this vote results in a majority for the _proposal, it will\n', '    //    be upgraded to immediately.\n', '    //\n', '    function castUpgradeVote(uint8 _galaxy,\n', '                              EclipticBase _proposal,\n', '                              bool _vote)\n', '      external\n', '      activePointVoter(_galaxy)\n', '    {\n', '      //  majority: true if the vote resulted in a majority, false otherwise\n', '      //\n', '      bool majority = polls.castUpgradeVote(_galaxy, _proposal, _vote);\n', '\n', '      //  if a majority is in favor of the upgrade, it happens as defined\n', '      //  in the ecliptic base contract\n', '      //\n', '      if (majority)\n', '      {\n', '        upgrade(_proposal);\n', '      }\n', '    }\n', '\n', '    //  castDocumentVote(): as _galaxy, cast a _vote on the _proposal\n', '    //\n', '    //    _vote is true when in favor of the proposal, false otherwise\n', '    //\n', '    function castDocumentVote(uint8 _galaxy, bytes32 _proposal, bool _vote)\n', '      external\n', '      activePointVoter(_galaxy)\n', '    {\n', '      polls.castDocumentVote(_galaxy, _proposal, _vote);\n', '    }\n', '\n', '    //  updateUpgradePoll(): check whether the _proposal has achieved\n', '    //                      majority, upgrading to it if it has\n', '    //\n', '    function updateUpgradePoll(EclipticBase _proposal)\n', '      external\n', '    {\n', '      //  majority: true if the poll ended in a majority, false otherwise\n', '      //\n', '      bool majority = polls.updateUpgradePoll(_proposal);\n', '\n', '      //  if a majority is in favor of the upgrade, it happens as defined\n', '      //  in the ecliptic base contract\n', '      //\n', '      if (majority)\n', '      {\n', '        upgrade(_proposal);\n', '      }\n', '    }\n', '\n', '    //  updateDocumentPoll(): check whether the _proposal has achieved majority\n', '    //\n', '    //    Note: the polls contract publicly exposes the function this calls,\n', '    //    but we offer it in the ecliptic interface as a convenience\n', '    //\n', '    function updateDocumentPoll(bytes32 _proposal)\n', '      external\n', '    {\n', '      polls.updateDocumentPoll(_proposal);\n', '    }\n', '\n', '  //\n', '  //  Contract owner operations\n', '  //\n', '\n', '    //  createGalaxy(): grant _target ownership of the _galaxy and register\n', '    //                  it for voting\n', '    //\n', '    function createGalaxy(uint8 _galaxy, address _target)\n', '      external\n', '      onlyOwner\n', '    {\n', '      //  only currently unowned (and thus also inactive) galaxies can be\n', '      //  created, and only to non-zero addresses\n', '      //\n', '      require( azimuth.isOwner(_galaxy, 0x0) &&\n', '               0x0 != _target );\n', '\n', '      //  new galaxy means a new registered voter\n', '      //\n', '      polls.incrementTotalVoters();\n', '\n', '      //  if the caller is sending the galaxy to themselves,\n', "      //  assume it knows what it's doing and resolve right away\n", '      //\n', '      if (msg.sender == _target)\n', '      {\n', '        doSpawn(_galaxy, _target, true, 0x0);\n', '      }\n', '      //\n', '      //  when sending to a "foreign" address, enforce a withdraw pattern,\n', '      //  making the caller the owner in the mean time\n', '      //\n', '      else\n', '      {\n', '        doSpawn(_galaxy, _target, false, msg.sender);\n', '      }\n', '    }\n', '\n', '    function setDnsDomains(string _primary, string _secondary, string _tertiary)\n', '      external\n', '      onlyOwner\n', '    {\n', '      azimuth.setDnsDomains(_primary, _secondary, _tertiary);\n', '    }\n', '\n', '  //\n', '  //  Function modifiers for this contract\n', '  //\n', '\n', '    //  validPointId(): require that _id is a valid point\n', '    //\n', '    modifier validPointId(uint256 _id)\n', '    {\n', '      require(_id < 0x100000000);\n', '      _;\n', '    }\n', '\n', '    //  activePointVoter(): require that :msg.sender can vote as _point,\n', '    //                      and that _point is active\n', '    //\n', '    modifier activePointVoter(uint32 _point)\n', '    {\n', '      require( azimuth.canVoteAs(_point, msg.sender) &&\n', '               azimuth.isActive(_point) );\n', '      _;\n', '    }\n', '}\n', '\n', "// Azimuth's TakesPoints.sol\n", '\n', 'contract TakesPoints is ReadsAzimuth\n', '{\n', '  constructor(Azimuth _azimuth)\n', '    ReadsAzimuth(_azimuth)\n', '    public\n', '  {\n', '    //\n', '  }\n', '\n', '  //  takePoint(): transfer _point to this contract. if _clean is true, require\n', '  //               that the point be unlinked.\n', '  //               returns true if this succeeds, false otherwise.\n', '  //\n', '  function takePoint(uint32 _point, bool _clean)\n', '    internal\n', '    returns (bool success)\n', '  {\n', '    Ecliptic ecliptic = Ecliptic(azimuth.owner());\n', '\n', '    //  There are two ways for a contract to get a point.\n', '    //  One way is for a prefix point to grant the contract permission to\n', '    //  spawn its points.\n', '    //  The contract will spawn the point directly to itself.\n', '    //\n', '    uint16 prefix = azimuth.getPrefix(_point);\n', '    if ( azimuth.isOwner(_point, 0x0) &&\n', '         azimuth.isOwner(prefix, msg.sender) &&\n', '         azimuth.isSpawnProxy(prefix, this) &&\n', '         (ecliptic.getSpawnLimit(prefix, now) > azimuth.getSpawnCount(prefix)) )\n', '    {\n', '      //  first model: spawn _point to :this contract\n', '      //\n', '      ecliptic.spawn(_point, this);\n', '      return true;\n', '    }\n', '\n', '    //  The second way is to accept existing points, optionally\n', '    //  requiring they be unlinked.\n', '    //  To deposit a point this way, the owner grants the contract\n', '    //  permission to transfer ownership of the point.\n', '    //  The contract will transfer the point to itself.\n', '    //\n', '    if ( (!_clean || !azimuth.hasBeenLinked(_point)) &&\n', '         azimuth.isOwner(_point, msg.sender) &&\n', '         azimuth.canTransfer(_point, this) )\n', '    {\n', '      //  second model: transfer active, unlinked _point to :this contract\n', '      //\n', '      ecliptic.transferPoint(_point, this, true);\n', '      return true;\n', '    }\n', '\n', '    //  point is not for us to take\n', '    //\n', '    return false;\n', '  }\n', '\n', '  //  givePoint(): transfer a _point we own to _to, optionally resetting.\n', '  //               returns true if this succeeds, false otherwise.\n', '  //\n', '  //    Note that _reset is unnecessary if the point was taken\n', "  //    using this contract's takePoint() function, which always\n", '  //    resets, and not touched since.\n', '  //\n', '  function givePoint(uint32 _point, address _to, bool _reset)\n', '    internal\n', '    returns (bool success)\n', '  {\n', "    //  only give points we've taken, points we fully own\n", '    //\n', '    if (azimuth.isOwner(_point, this))\n', '    {\n', '      Ecliptic(azimuth.owner()).transferPoint(_point, _to, _reset);\n', '      return true;\n', '    }\n', '\n', '    //  point is not for us to give\n', '    //\n', '    return false;\n', '  }\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '//  ConditionalStarRelease\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '//  ConditionalStarRelease: star transfer over time, based on conditions\n', '//\n', '//    This contract allows its owner to transfer batches of stars to a\n', '//    recipient (also "participant") gradually over time, assuming\n', '//    the specified conditions are met.\n', '//\n', '//    This contract represents a single set of conditions and corresponding\n', '//    deadlines (up to eight) which get configured during contract creation.\n', '//    The conditions take the form of hashes, and they are checked for\n', '//    by looking at the Polls contract. A condition is met if it has\n', '//    achieved a majority in the Polls contract, or its deadline has\n', '//    passed.\n', '//    Completion timestamps are stored for each completed condition.\n', '//    They are equal to the time at which majority was observed, or\n', "//    the condition's deadline, whichever comes first.\n", '//\n', '//    An arbitrary number of participants (in the form of Ethereum\n', '//    addresses) can be registered with the contract.\n', '//    Per participant, the contract stores a commitment. This structure\n', '//    contains the details of the stars to be made available to the\n', '//    participant, configured during registration. This allows for\n', '//    per-participant configuration of the amount of stars they receive\n', '//    per condition, and at what rate these stars get released.\n', '//\n', '//    When a timestamp is set for a condition, the amount of stars in\n', '//    the batch corresponding to that condition is released to the\n', '//    participant at the rate specified in the commitment.\n', '//\n', '//    Stars deposited into the contracts for participants to (eventually)\n', '//    withdraw are treated on a last-in first-out basis.\n', '//\n', "//    If a condition's timestamp is equal to its deadline, participants\n", '//    have the option to forfeit the stars in the associated batch, only\n', '//    if they have not yet withdrawn from that batch. The participant will\n', '//    no longer be able to withdraw stars from the forfeited batch (they are\n', '//    to be collected by the contract owner), and the participant will settle\n', '//    compensation with the contract owner off-chain.\n', '//\n', '//    The contract owner can register commitments, deposit stars into\n', '//    them, and withdraw any stars that got forfeited.\n', '//    Participants can withdraw stars as they get released, and forfeit\n', '//    the remainder of their commitment if a deadline is missed.\n', '//    Anyone can check unsatisfied conditions for completion.\n', '//    If, after a specified date, any stars remain, the owner is able to\n', '//    withdraw them. This saves address space from being lost forever in case\n', '//    of key loss by participants.\n', '//\n', 'contract ConditionalStarRelease is Ownable, TakesPoints\n', '{\n', '  using SafeMath for uint256;\n', '  using SafeMath16 for uint16;\n', '\n', '  //  ConditionCompleted: :condition has either been met or missed\n', '  //\n', '  event ConditionCompleted(uint8 indexed condition, uint256 when);\n', '\n', '  //  Forfeit: :who has chosen to forfeit :batch, which contained\n', '  //           :stars number of stars\n', '  //\n', '  event Forfeit(address indexed who, uint8 batch, uint16 stars);\n', '\n', '  //  maxConditions: the max amount of conditions that can be configured\n', '  //\n', '  uint8 constant maxConditions = 8;\n', '\n', '  //  conditions: hashes for document proposals that must achieve majority\n', '  //              in the polls contract\n', '  //\n', '  //    a value of 0x0 is special-cased for azimuth initialization logic in\n', '  //    this implementation of the contract\n', '  //\n', '  bytes32[] public conditions;\n', '\n', '  //  livelines: dates before which the conditions cannot be registered as met.\n', '  //\n', '  uint256[] public livelines;\n', '\n', '  //  deadlines: deadlines by which conditions must have been met. if the\n', '  //             polls contract does not contain a majority vote for the\n', '  //             appropriate condition by the time its deadline is hit,\n', '  //             stars in a commitment can be forfeit and withdrawn by the\n', '  //             CSR contract owner.\n', '  //\n', '  uint256[] public deadlines;\n', '\n', '  //  timestamps: timestamps when conditions of the matching index were\n', '  //              hit; or 0 if not yet hit; or equal to the deadline if\n', '  //              the deadline was missed.\n', '  //\n', '  uint256[] public timestamps;\n', '\n', '  //  escapeHatchTime: date after which the contract owner can withdraw\n', '  //                   arbitrary stars\n', '  //\n', '  uint256 public escapeHatchDate;\n', '\n', '  //  Commitment: structure that mirrors a signed paper contract\n', '  //\n', '  //    While the ordering of the struct members is semantically chaotic,\n', "  //    they are ordered to tightly pack them into Ethereum's 32-byte storage\n", '  //    slots, which reduces gas costs for some function calls.\n', '  //    The comment ticks indicate assumed slot boundaries.\n', '  //\n', '  struct Commitment\n', '  {\n', '    //  stars: specific stars assigned to this commitment that have not yet\n', '    //         been withdrawn\n', '    //\n', '    uint16[] stars;\n', '  //\n', '    //  batches: number of stars to release per condition\n', '    //\n', '    uint16[] batches;\n', '  //\n', '    //  withdrawn: number of stars withdrawn per batch\n', '    //\n', '    uint16[] withdrawn;\n', '  //\n', '    //  forfeited: whether the stars in a batch have been forfeited\n', '    //             by the recipient\n', '    //\n', '    bool[] forfeited;\n', '  //\n', '    //  rateUnit: amount of time it takes for the next :rate stars to be\n', '    //            released\n', '    //\n', '    uint256 rateUnit;\n', '  //\n', '    //  approvedTransferTo: batch can be transferred to this address\n', '    //\n', '    address approvedTransferTo;\n', '\n', '    //  total: sum of stars in all batches\n', '    //\n', '    uint16 total;\n', '\n', '    //  rate: number of stars released per unlocked batch per :rateUnit\n', '    //\n', '    uint16 rate;\n', '  }\n', '\n', '  //  commitments: per participant, the registered purchase agreement\n', '  //\n', '  mapping(address => Commitment) public commitments;\n', '\n', '  //  constructor(): configure conditions and deadlines\n', '  //\n', '  constructor( Azimuth _azimuth,\n', '               bytes32[] _conditions,\n', '               uint256[] _livelines,\n', '               uint256[] _deadlines,\n', '               uint256 _escapeHatchDate )\n', '    TakesPoints(_azimuth)\n', '    public\n', '  {\n', '    //  sanity check: limited conditions, liveline and deadline per condition,\n', '    //  and fair escape hatch\n', '    //\n', '    require( _conditions.length > 0 &&\n', '             _conditions.length <= maxConditions &&\n', '             _livelines.length == _conditions.length &&\n', '             _deadlines.length == _conditions.length &&\n', '             _escapeHatchDate > _deadlines[_deadlines.length.sub(1)] );\n', '\n', '    //  install conditions and deadlines, and prepare timestamps array\n', '    //\n', '    conditions = _conditions;\n', '    livelines = _livelines;\n', '    deadlines = _deadlines;\n', '    timestamps.length = _conditions.length;\n', '    escapeHatchDate = _escapeHatchDate;\n', '\n', '    //  check if the first condition is met, it might get cleared immediately\n', '    //\n', '    analyzeCondition(0);\n', '  }\n', '\n', '  //\n', '  //  Functions for the contract owner\n', '  //\n', '\n', '    //  register(): register a new commitment\n', '    //\n', '    function register( //  _participant: address of the paper contract signer\n', '                       //  _batches: number of stars releasing per batch\n', '                       //  _rate: number of stars that unlock per _rateUnit\n', '                       //  _rateUnit: amount of time it takes for the next\n', '                       //             _rate stars to unlock\n', '                       //\n', '                       address _participant,\n', '                       uint16[] _batches,\n', '                       uint16 _rate,\n', '                       uint256 _rateUnit )\n', '      external\n', '      onlyOwner\n', '    {\n', '      Commitment storage com = commitments[_participant];\n', '\n', "      //  make sure this participant doesn't already have a commitment\n", '      //\n', '      require(0 == com.total);\n', '\n', '      //  for every condition/deadline, a batch release amount must be\n', "      //  specified, even if it's zero\n", '      //\n', '      require(_batches.length == conditions.length);\n', '\n', '      //  make sure a sane rate is submitted\n', '      //\n', '      require( (_rate > 0) &&\n', '               (_rateUnit > 0) );\n', '\n', "      //  make sure we're not promising more than we can possibly give\n", '      //\n', '      uint16 total = arraySum(_batches);\n', '      require( (total > 0) &&\n', '               (total <= 0xff00) );\n', '\n', '      //  register into state\n', '      //\n', '      com.batches = _batches;\n', '      com.total = total;\n', '      com.withdrawn.length = _batches.length;\n', '      com.forfeited.length = _batches.length;\n', '      com.rate = _rate;\n', '      com.rateUnit = _rateUnit;\n', '    }\n', '\n', '    //  deposit(): deposit a star into this contract for later withdrawal\n', '    //\n', '    function deposit(address _participant, uint16 _star)\n', '      external\n', '      onlyOwner\n', '    {\n', '      Commitment storage com = commitments[_participant];\n', '\n', "      //  ensure we can only deposit stars, and that we can't deposit\n", '      //  more stars than necessary\n', '      //\n', '      require( (_star > 0xff) &&\n', '               ( com.stars.length <\n', '                 com.total.sub( arraySum(com.withdrawn) ) ) );\n', '\n', '      //  have the contract take ownership of the star if possible,\n', '      //  reverting if that fails.\n', '      //\n', '      require( takePoint(_star, true) );\n', '\n', "      //  add _star to the participant's star balance\n", '      //\n', '      com.stars.push(_star);\n', '    }\n', '\n', "    //  withdrawForfeited(): withdraw one star, from _participant's forfeited\n", '    //                       _batch, to _to\n', '    //\n', '    function withdrawForfeited(address _participant, uint8 _batch, address _to)\n', '      external\n', '      onlyOwner\n', '    {\n', '      Commitment storage com = commitments[_participant];\n', '\n', '      //  withdraw is possible only if the participant has forfeited this batch,\n', "      //  and there's still stars there left to withdraw\n", '      //\n', '      require( com.forfeited[_batch] &&\n', '               (com.withdrawn[_batch] < com.batches[_batch]) &&\n', '               (0 < com.stars.length) );\n', '\n', '      //  update contract state\n', '      //\n', '      com.withdrawn[_batch] = com.withdrawn[_batch].add(1);\n', '\n', "      //  withdraw a star from the commitment (don't reset it because\n", "      //  no one whom we don't trust has ever had control of it)\n", '      //\n', '      performWithdraw(com, _to, false);\n', '    }\n', '\n', '    //  withdrawOverdue(): withdraw arbitrary star from the contract\n', '    //\n', '    //    this functions as an escape hatch in the case of key loss,\n', '    //    to prevent blocks of address space from being lost permanently.\n', '    //\n', "    //    we don't bother with specifying a batch or doing any kind of\n", "    //    book-keeping, because at this point in time we don't care about\n", '    //    that anymore.\n', '    //\n', '    function withdrawOverdue(address _participant, address _to)\n', '      external\n', '      onlyOwner\n', '    {\n', '      //  this can only be done after the :escapeHatchDate\n', '      //\n', '      require(block.timestamp > escapeHatchDate);\n', '\n', '      Commitment storage com = commitments[_participant];\n', '      require(0 < com.stars.length);\n', '\n', "      //  withdraw a star from the commitment (don't reset it because\n", "      //  no one whom we don't trust has ever had control of it)\n", '      //\n', '      performWithdraw(com, _to, false);\n', '    }\n', '\n', '  //\n', '  //  Functions for participants\n', '  //\n', '\n', '    //  approveCommitmentTransfer(): allow transfer of the commitment to/by _to\n', '    //\n', '    function approveCommitmentTransfer(address _to)\n', '      external\n', '    {\n', '      //  make sure the caller is a participant,\n', "      //  and that the target isn't\n", '      //\n', '      require( 0 != commitments[msg.sender].total &&\n', '               0 == commitments[_to].total );\n', '      commitments[msg.sender].approvedTransferTo = _to;\n', '    }\n', '\n', "    //  transferCommitment(): make an approved transfer of _from's commitment\n", "    //                        to the caller's address\n", '    //\n', '    function transferCommitment(address _from)\n', '      external\n', '    {\n', '      //  make sure the :msg.sender is authorized to make this transfer\n', '      //\n', '      require(commitments[_from].approvedTransferTo == msg.sender);\n', '\n', "      //  make sure the target isn't also a participant again,\n", '      //  this could have changed since approveCommitmentTransfer\n', '      //\n', '      require(0 == commitments[msg.sender].total);\n', '\n', "      //  copy the commitment to the :msg.sender and clear _from's\n", '      //\n', '      Commitment storage com = commitments[_from];\n', '      commitments[msg.sender] = com;\n', '      delete commitments[_from];\n', '    }\n', '\n', "    //  withdrawToSelf(): withdraw one star from the :msg.sender's commitment's\n", '    //                    _batch to :msg.sender\n', '    //\n', '    function withdrawToSelf(uint8 _batch)\n', '      external\n', '    {\n', '      withdraw(_batch, msg.sender);\n', '    }\n', '\n', "    //  withdraw(): withdraw one star from the :msg.sender's commitment's\n", '    //              _batch to _to\n', '    //\n', '    function withdraw(uint8 _batch, address _to)\n', '      public\n', '    {\n', '      Commitment storage com = commitments[msg.sender];\n', '\n', '      //  to withdraw, the participant must have a star balance,\n', '      //  be under their current withdrawal limit, and cannot\n', '      //  withdraw forfeited stars\n', '      //\n', '      require( (com.stars.length > 0) &&\n', '               (com.withdrawn[_batch] < withdrawLimit(msg.sender, _batch)) &&\n', '               !com.forfeited[_batch] );\n', '\n', '      //  update contract state\n', '      //\n', '      com.withdrawn[_batch] = com.withdrawn[_batch].add(1);\n', '\n', '      //  withdraw a star from the commitment\n', '      //\n', '      performWithdraw(com, _to, true);\n', '    }\n', '\n', '    //  forfeit(): forfeit all stars in the specified _batch, but only if\n', '    //             none have been withdrawn yet\n', '    //\n', '    function forfeit(uint8 _batch)\n', '      external\n', '    {\n', '      Commitment storage com = commitments[msg.sender];\n', '\n', '      //  ensure the commitment has actually been configured\n', '      //\n', '      require(0 < com.total);\n', '\n', '      //  the participant can forfeit if and only if the condition deadline\n', '      //  is missed (has passed without confirmation), no stars have\n', '      //  been withdrawn from the batch yet, and this batch has not yet\n', '      //  been forfeited\n', '      //\n', '      require( (deadlines[_batch] == timestamps[_batch]) &&\n', '               0 == com.withdrawn[_batch] &&\n', '               !com.forfeited[_batch] );\n', '\n', '      //  update commitment metadata\n', '      //\n', '      com.forfeited[_batch] = true;\n', '\n', '      //  emit event\n', '      //\n', '      emit Forfeit(msg.sender, _batch, com.batches[_batch]);\n', '    }\n', '\n', '  //\n', '  //  Internal functions\n', '  //\n', '\n', '    //  performWithdraw(): withdraw a star from _com to _to\n', '    //\n', '    function performWithdraw(Commitment storage _com, address _to, bool _reset)\n', '      internal\n', '    {\n', '      //  star: star to withdraw (from end of array)\n', '      //\n', '      uint16 star = _com.stars[_com.stars.length.sub(1)];\n', '\n', '      //  remove the star from the commitment\n', '      //\n', '      _com.stars.length = _com.stars.length.sub(1);\n', '\n', '      //  then transfer the star\n', '      //\n', '      require( givePoint(star, _to, _reset) );\n', '    }\n', '\n', '  //\n', '  //  Public operations and utilities\n', '  //\n', '\n', '    //  analyzeCondition(): analyze condition number _condition for completion;\n', "    //                    set :timestamps[_condition] if either the condition's\n", '    //                    deadline has passed, or its condition has been met\n', '    //\n', '    function analyzeCondition(uint8 _condition)\n', '      public\n', '    {\n', "      //  only analyze conditions that haven't been met yet\n", '      //\n', '      require(0 == timestamps[_condition]);\n', '\n', "      //  if the liveline hasn't been passed yet, the condition can't be met\n", '      //\n', '      require(block.timestamp > livelines[_condition]);\n', '\n', '      //  if the deadline has passed, the condition is missed, then the\n', "      //  deadline becomes the condition's timestamp\n", '      //\n', '      uint256 deadline = deadlines[_condition];\n', '      if (block.timestamp > deadline)\n', '      {\n', '        timestamps[_condition] = deadline;\n', '        emit ConditionCompleted(_condition, deadline);\n', '        return;\n', '      }\n', '\n', '      //  check if the condition has been met\n', '      //\n', '      bytes32 condition = conditions[_condition];\n', '      bool met = false;\n', '\n', '      //  if the condition is zero, it is our initialization case\n', '      //\n', '      if (bytes32(0) == condition)\n', '      {\n', '        //  condition is met if the Ecliptic has been upgraded\n', '        //  at least once\n', '        //\n', '        met = (0x0 != Ecliptic(azimuth.owner()).previousEcliptic());\n', '      }\n', '      //\n', '      //  a real condition is met when it has achieved a majority vote\n', '      //\n', '      else\n', '      {\n', '        //  we check using the polls contract from the current ecliptic\n', '        //\n', '        met = Ecliptic(azimuth.owner())\n', '              .polls()\n', '              .documentHasAchievedMajority(condition);\n', '      }\n', '\n', '      //  if the condition is met, set :timestamps[_condition] to the\n', '      //  timestamp of the current eth block\n', '      //\n', '      if (met)\n', '      {\n', '        timestamps[_condition] = block.timestamp;\n', '        emit ConditionCompleted(_condition, block.timestamp);\n', '      }\n', '    }\n', '\n', '    //  withdrawLimit(): return the number of stars _participant can withdraw\n', '    //                   from _batch at the current block timestamp\n', '    //\n', '    function withdrawLimit(address _participant, uint8 _batch)\n', '      public\n', '      view\n', '      returns (uint16 limit)\n', '    {\n', '      Commitment storage com = commitments[_participant];\n', '\n', "      //  if _participant has no commitment, they can't withdraw anything\n", '      //\n', '      if (0 == com.total)\n', '      {\n', '        return 0;\n', '      }\n', '\n', '      uint256 ts = timestamps[_batch];\n', '\n', "      //  if the condition hasn't completed yet, there is nothing to add.\n", '      //\n', '      if ( ts == 0 )\n', '      {\n', '        limit = 0;\n', '      }\n', '      else\n', '      {\n', "        //  a condition can't have been completed in the future\n", '        //\n', '        assert(ts <= block.timestamp);\n', '\n', '        //  calculate the amount of stars available from this batch by\n', '        //  multiplying the release rate (stars per :rateUnit) by the number\n', '        //  of :rateUnits that have passed since the condition completed\n', '        //\n', '        uint256 num = uint256(com.rate).mul(\n', '                      block.timestamp.sub(ts) / com.rateUnit );\n', '\n', '        //  bound the release amount by the batch amount\n', '        //\n', '        if ( num > com.batches[_batch] )\n', '        {\n', '          num = com.batches[_batch];\n', '        }\n', '\n', '        limit = uint16(num);\n', '      }\n', '\n', '      //  allow at least one star, from the first batch that has stars\n', '      //\n', '      if (limit < 1)\n', '      {\n', '        //  first: whether this _batch is the first sequential one to contain\n', '        //         any stars\n', '        //\n', '        bool first = false;\n', '\n', '        //  check to see if any batch up to this _batch has stars\n', '        //\n', '        for (uint8 i = 0; i <= _batch; i++)\n', '        {\n', "          //  if this batch has stars, that's the first batch we found\n", '          //\n', '          if (0 < com.batches[i])\n', '          {\n', "            //  maybe it's _batch, but in any case we stop searching here\n", '            //\n', '            first = (i == _batch);\n', '            break;\n', '          }\n', '        }\n', '\n', '        if (first)\n', '        {\n', '          return 1;\n', '        }\n', '      }\n', '\n', '      return limit;\n', '    }\n', '\n', '    //  arraySum(): return the sum of all numbers in _array\n', '    //\n', '    //    only supports sums that fit into a uint16, which is all\n', '    //    this contract needs\n', '    //\n', '    function arraySum(uint16[] _array)\n', '      internal\n', '      pure\n', '      returns (uint16 total)\n', '    {\n', '      for (uint256 i = 0; i < _array.length; i++)\n', '      {\n', '        total = total.add(_array[i]);\n', '      }\n', '      return total;\n', '    }\n', '\n', '    //  verifyBalance: check the balance of _participant\n', '    //\n', '    //    Note: for use by clients that have not forfeited,\n', '    //    to verify the contract owner has deposited the stars\n', "    //    they're entitled to.\n", '    //\n', '    function verifyBalance(address _participant)\n', '      external\n', '      view\n', '      returns (bool correct)\n', '    {\n', '      Commitment storage com = commitments[_participant];\n', '\n', '      //  return true if this contract holds as many stars as the participant\n', '      //  will ever be entitled to withdraw\n', '      //\n', '      return ( com.stars.length ==\n', '               com.total.sub( arraySum(com.withdrawn) ) );\n', '    }\n', '\n', '    //  getBatches(): get the configured batch sizes for a commitment\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getBatches(address _participant)\n', '      external\n', '      view\n', '      returns (uint16[] batches)\n', '    {\n', '      return commitments[_participant].batches;\n', '    }\n', '\n', '    //  getBatch(): get the configured size of _batch\n', '    //\n', '    function getBatch(address _participant, uint8 _batch)\n', '      external\n', '      view\n', '      returns (uint16 batch)\n', '    {\n', '      return commitments[_participant].batches[_batch];\n', '    }\n', '\n', '    //  getWithdrawn(): get the amounts of stars that have been withdrawn\n', '    //                  from each batch\n', '    //\n', '    function getWithdrawn(address _participant)\n', '      external\n', '      view\n', '      returns (uint16[] withdrawn)\n', '    {\n', '      return commitments[_participant].withdrawn;\n', '    }\n', '\n', '    //  getWithdrawnFromBatch(): get the amount of stars that have been\n', '    //                           withdrawn from _batch\n', '    //\n', '    function getWithdrawnFromBatch(address _participant, uint8 _batch)\n', '      external\n', '      view\n', '      returns (uint16 withdrawn)\n', '    {\n', '      return commitments[_participant].withdrawn[_batch];\n', '    }\n', '\n', "    //  getForfeited(): for all of _participant's batches, get the forfeit flag\n", '    //\n', '    function getForfeited(address _participant)\n', '      external\n', '      view\n', '      returns (bool[] forfeited)\n', '    {\n', '      return commitments[_participant].forfeited;\n', '    }\n', '\n', "    //  getForfeited(): for _participant's _batch, get the forfeit flag\n", '    //\n', '    function hasForfeitedBatch(address _participant, uint8 _batch)\n', '      external\n', '      view\n', '      returns (bool forfeited)\n', '    {\n', '      return commitments[_participant].forfeited[_batch];\n', '    }\n', '\n', '    //  getRemainingStars(): get the stars deposited into the commitment\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getRemainingStars(address _participant)\n', '      external\n', '      view\n', '      returns (uint16[] stars)\n', '    {\n', '      return commitments[_participant].stars;\n', '    }\n', '\n', '    //  getConditionsState(): get the condition configurations and state\n', '    //\n', '    //    Note: only useful for clients, as Solidity does not currently\n', '    //    support returning dynamic arrays.\n', '    //\n', '    function getConditionsState()\n', '      external\n', '      view\n', '      returns (bytes32[] conds,\n', '               uint256[] lives,\n', '               uint256[] deads,\n', '               uint256[] times)\n', '    {\n', '      return (conditions, livelines, deadlines, timestamps);\n', '    }\n', '}']
