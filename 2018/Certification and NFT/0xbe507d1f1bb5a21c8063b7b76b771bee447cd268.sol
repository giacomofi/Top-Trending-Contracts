['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract OsherCrowdsale {\n', '    \n', '    function crowdSaleStartTime() returns (uint);\n', '    function preicostarted() returns (uint);\n', '    \n', '}\n', '\n', '\n', 'contract OsherCoinPricing is Ownable {\n', '    \n', '   \n', '    \n', '    OsherCoinCrowdsaleCore oshercoincrowdsalecore;\n', '    uint public preicostarted;\n', '    uint public icostarted;\n', '    uint public price;\n', '    address oshercrowdsaleaddress; \n', '    \n', '    \n', '    \n', '    function OsherCoinPricing() {\n', '        \n', '        \n', '        price =.00000000001 ether;\n', '        oshercrowdsaleaddress = 0x2Ef8DcDeCd124660C8CC8E55114f615C2e657da6;  // add crowdsale address\n', '        \n', '    }\n', '    \n', '    \n', '    \n', '    \n', '    function crowdsalepricing( address tokenholder, uint amount  )  returns ( uint , uint ) {\n', '        \n', '        uint award;\n', '        uint bonus;\n', '        \n', '        return ( OsherCoinAward ( amount ) , bonus );\n', '        \n', '    }\n', '    \n', '    \n', '    function precrowdsalepricing( address tokenholder, uint amount )   returns ( uint, uint )  {\n', '        \n', '       \n', '        uint award;\n', '        uint bonus;\n', '        \n', '        ( award, bonus ) = OsherCoinPresaleAward ( amount  );\n', '        \n', '        return ( award, bonus );\n', '        \n', '    }\n', '    \n', '    \n', '    function OsherCoinPresaleAward ( uint amount  ) public constant  returns ( uint, uint  ){\n', '        \n', '        \n', '        uint divisions = (amount / price) / 20;\n', '        uint bonus =   ( currentpreicobonus()/5 ) * divisions;\n', '        return ( (amount / price) , bonus );\n', '       \n', '    }\n', '    \n', '    \n', '    function currentpreicobonus() public constant returns ( uint) {\n', '        \n', '        uint bonus;\n', '        OsherCrowdsale oshercrowdsale =  OsherCrowdsale ( oshercrowdsaleaddress ); \n', '        \n', '        if ( now < ( oshercrowdsale.preicostarted() +   7 days ) ) bonus =   35; \n', '        if ( now > ( oshercrowdsale.preicostarted() +   7 days ) ) bonus =   30;\n', '        if ( now > ( oshercrowdsale.preicostarted() +  12 days ) ) bonus =   25;\n', '        if ( now > ( oshercrowdsale.preicostarted() +  17 days ) ) bonus =   20;\n', '        if ( now > ( oshercrowdsale.preicostarted() +  22 days ) ) bonus =   15;\n', '        if ( now > ( oshercrowdsale.preicostarted() +  27 days ) ) bonus =   10;\n', '        \n', '        return bonus;\n', '        \n', '    }\n', '    \n', '    function OsherCoinAward ( uint amount ) public constant returns ( uint ){\n', '        \n', '        return amount /  OsherCurrentICOPrice();\n', '       \n', '    }\n', '  \n', '  \n', '    function OsherCurrentICOPrice() public constant returns ( uint ){\n', '        \n', '        uint priceincrease;\n', '        OsherCrowdsale oshercrowdsale =  OsherCrowdsale ( oshercrowdsaleaddress ); \n', '        uint spotprice;\n', '        uint dayspassed = now - oshercrowdsale.crowdSaleStartTime();\n', '        uint todays = dayspassed/86400;\n', '        \n', '        if ( todays > 20 ) todays = 20;\n', '        \n', '        spotprice = (todays * .0000000000005 ether) + price;\n', '        \n', '        return spotprice;\n', '       \n', '    }  \n', '    \n', '    function setFirstRoundPricing ( uint _pricing ) onlyOwner {\n', '        \n', '        price = _pricing;\n', '        \n', '    }\n', '    \n', '    \n', '    \n', '}\n', '\n', 'contract OsherCoin {\n', '    function transfer(address receiver, uint amount)returns(bool ok);\n', '    function balanceOf( address _address )returns(uint256);\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract OsherCoinCrowdsaleCore is Ownable, OsherCoinPricing {\n', '    \n', '    using SafeMath for uint;\n', '    \n', '    address public beneficiary;\n', '    address public front;\n', '    uint public tokensSold;\n', '    uint public etherRaised;\n', '    uint public presold;\n', '    \n', '    \n', '    OsherCoin public tokenReward;\n', '    \n', '    \n', '    event ShowBool ( bool );\n', '    \n', '    \n', '    \n', '    \n', '    modifier onlyFront() {\n', '        if (msg.sender != front) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '\n', '    \n', '    \n', '    \n', '    function OsherCoinCrowdsaleCore(){\n', '        \n', '        tokenReward = OsherCoin(  0xa8a07e3fa28bd207e405c482ce8d02402cd60d92 ); // OsherCoin Address\n', '        owner = msg.sender;\n', '        beneficiary = msg.sender;\n', '        preicostarted = now;\n', '        front = 0x2Ef8DcDeCd124660C8CC8E55114f615C2e657da6; // front crowdsale address\n', '        \n', '       \n', '       \n', '    }\n', '    \n', '   \n', '    // runs during precrowdsale\n', '    function precrowdsale ( address tokenholder ) onlyFront payable {\n', '        \n', '        uint award;  // amount of oshercoins to credit to tokenholder\n', '        uint bonus;  // amount of oshercoins to credit to tokenholder\n', '        \n', '        OsherCoinPricing pricingstructure = new OsherCoinPricing();\n', '        ( award, bonus ) = pricingstructure.precrowdsalepricing( tokenholder , msg.value ); \n', '        \n', '       \n', '        presold = presold.add( award + bonus ); //add number of tokens sold in presale\n', '        tokenReward.transfer ( tokenholder , award + bonus ); // immediate transfer of oshercoins to token buyer\n', '        \n', '        beneficiary.transfer ( msg.value ); \n', '          \n', '        etherRaised = etherRaised.add( msg.value ); // tallies ether raised\n', '        tokensSold = tokensSold.add( award + bonus ); // tallies total osher sold\n', '        \n', '    }\n', '    \n', '    // runs when crowdsale is active\n', '    function crowdsale ( address tokenholder  ) onlyFront payable {\n', '        \n', '        uint award;  // amount of oshercoins to send to tokenholder\n', '        uint bonus;  // amount of oshercoin bonus\n', '     \n', '        OsherCoinPricing pricingstructure = new OsherCoinPricing();\n', '        ( award , bonus ) = pricingstructure.crowdsalepricing( tokenholder, msg.value ); \n', '    \n', '        tokenReward.transfer ( tokenholder , award ); // immediate transfer to token holders\n', '        beneficiary.transfer ( msg.value ); \n', '        \n', '        etherRaised = etherRaised.add( msg.value );  //etherRaised += msg.value; // tallies ether raised\n', '        tokensSold = tokensSold.add( award ); //tokensSold  += award; // tallies total osher sold\n', '       \n', '    }\n', '    \n', '    \n', '    // use this to set the crowdsale beneficiary address\n', '    function transferBeneficiary ( address _newbeneficiary ) onlyOwner {\n', '        \n', '        beneficiary = _newbeneficiary;\n', '        \n', '    }\n', '    \n', '    // use this to set the charity address\n', '    \n', '    // sets crowdsale address\n', '    function setFront ( address _front ) onlyOwner {\n', '        \n', '        front = _front;\n', '        \n', '    }\n', '    \n', '   \n', '        \n', '    //empty the crowdsale contract of Dragons and forward balance to beneficiary\n', '    function withdrawCrowdsaleOsherCoins() onlyOwner{\n', '        \n', '        uint256 balance = tokenReward.balanceOf( address( this ) );\n', '        tokenReward.transfer( beneficiary, balance );\n', '        \n', '        \n', '    }\n', '   \n', '   \n', '    \n', '    \n', '    \n', '}']