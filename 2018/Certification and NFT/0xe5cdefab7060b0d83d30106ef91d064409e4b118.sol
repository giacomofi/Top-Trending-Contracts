['/**\n', ' * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n', ' *\n', ' * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n', ' *\n', ' ** Code Modified by : TokenMagic\n', ' ** Change Log: \n', ' *** Solidity version upgraded from 0.4.8 to 0.4.23\n', ' */\n', ' \n', ' \n', 'pragma solidity ^0.4.23;\n', '\n', '/*\n', '* Ownable Contract\n', '* Added by : TokenMagic\n', '*/ \n', 'contract Ownable {\n', '  \n', '  address public owner;\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/*\n', '* Haltable Contract\n', '* Added by : TokenMagic\n', '*/\n', 'contract Haltable is Ownable {\n', '  bool public halted;\n', '\n', '  modifier stopInEmergency {\n', '    require(!halted);\n', '    _;\n', '  }\n', '\n', '  modifier stopNonOwnersInEmergency {\n', '    require(!halted && msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    require(halted);\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function halt() external onlyOwner {\n', '    halted = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function unhalt() external onlyOwner onlyInEmergency {\n', '    halted = false;\n', '  }\n', '\n', '}\n', '\n', '/*\n', '* SafeMathLib Library\n', '* Added by : TokenMagic\n', '*/\n', 'library SafeMathLib {\n', '\n', '  function times(uint a, uint b) public pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  \n', '}\n', '\n', '\n', '/*\n', '* Token Contract \n', '* Added by : TokenMagic\n', '*/\n', 'contract FractionalERC20 {\n', '\n', '  uint public decimals;\n', '\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/*\n', '* Crowdsale Contract\n', '* Added by : TokenMagic\n', '*/\n', 'contract HoardCrowdsale is Haltable {\n', '\n', '  using SafeMathLib for uint;\n', '\n', '  /* The token we are selling */\n', '  FractionalERC20 public token;\n', '\n', '  /* tokens will be transfered from this address */\n', '  address public multisigWallet;\n', '  \n', '  /* Founders team MultiSig Wallet address */\n', '  address public foundersTeamMultisig;\n', '  \n', '  /* if the funding goal is not reached, investors may withdraw their funds */\n', '  uint public minimumFundingGoal = 3265000000000000000000; // 3265 ETH in Wei\n', '\n', '  /* the UNIX timestamp start date of the crowdsale */\n', '  uint public startsAt;\n', '\n', '  /* the UNIX timestamp end date of the crowdsale */\n', '  uint public endsAt;\n', '\n', '  /* the number of tokens already sold through this contract*/\n', '  uint public tokensSold = 0;\n', '\n', '  /* the number of tokens already sold through this contract for presale*/\n', '  uint public presaleTokensSold = 0;\n', '\n', '  /* the number of tokens already sold before presale*/\n', '  uint public prePresaleTokensSold = 0;\n', '\n', '  /* Maximum number tokens that presale can assign*/ \n', '  uint public presaleTokenLimit = 80000000000000000000000000; //80,000,000 token\n', '\n', '  /* Maximum number tokens that crowdsale can assign*/ \n', '  uint public crowdsaleTokenLimit = 120000000000000000000000000; //120,000,000 token\n', '  \n', '  /** Total percent of tokens allocated to the founders team multiSig wallet at the end of the sale */\n', '  uint public percentageOfSoldTokensForFounders = 50; // 50% of solded token as bonus to founders team multiSig wallet\n', '  \n', '  /* How much bonus tokens we allocated */\n', '  uint public tokensForFoundingBoardWallet;\n', '  \n', "  /* The party who holds the full token pool and has approve()'ed tokens for this crowdsale */\n", '  address public beneficiary;\n', '  \n', '  /* How many wei of funding we have raised */\n', '  uint public weiRaised = 0;\n', '\n', '  /* Calculate incoming funds from presale contracts and addresses */\n', '  uint public presaleWeiRaised = 0;\n', '\n', '  /* How many distinct addresses have invested */\n', '  uint public investorCount = 0;\n', '\n', '  /* How much wei we have returned back to the contract after a failed crowdfund. */\n', '  uint public loadedRefund = 0;\n', '\n', '  /* How much wei we have given back to investors.*/\n', '  uint public weiRefunded = 0;\n', '\n', '  /* Has this crowdsale been finalized */\n', '  bool public finalized;\n', '\n', '  /** How much ETH each address has invested to this crowdsale */\n', '  mapping (address => uint256) public investedAmountOf;\n', '\n', '  /** How much tokens this crowdsale has credited for each investor address */\n', '  mapping (address => uint256) public tokenAmountOf;\n', '\n', '  /** Presale Addresses that are allowed to invest. */\n', '  mapping (address => bool) public presaleWhitelist;\n', '\n', '  /** Addresses that are allowed to invest. */\n', '  mapping (address => bool) public participantWhitelist;\n', '\n', '  /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */\n', '  uint public ownerTestValue;\n', '\n', '  uint public oneTokenInWei;\n', '\n', '  /** State machine\n', '   *\n', '   * - Preparing: All contract initialization calls and variables have not been set yet\n', '   * - Prefunding: We have not passed start time yet\n', '   * - Funding: Active crowdsale\n', '   * - Success: Minimum funding goal reached\n', '   * - Failure: Minimum funding goal not reached before ending time\n', '   * - Finalized: The finalized has been called and succesfully executed\n', '   * - Refunding: Refunds are loaded on the contract for reclaim.\n', '   */\n', '  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n', '\n', '  // A new investment was made\n', '  event Invested(address investor, uint weiAmount, uint tokenAmount);\n', '\n', '  // Refund was processed for a contributor\n', '  event Refund(address investor, uint weiAmount);\n', '\n', '  // Address participation whitelist status changed\n', '  event Whitelisted(address[] addr, bool status);\n', '\n', '  // Presale Address participation whitelist status changed\n', '  event PresaleWhitelisted(address addr, bool status);\n', '    \n', '  // Crowdsale start time has been changed\n', '  event StartsAtChanged(uint newStartsAt);\n', '      \n', '  // Crowdsale end time has been changed\n', '  event EndsAtChanged(uint newEndsAt);\n', '  \n', '  // Crowdsale token price has been changed\n', '  event TokenPriceChanged(uint tokenPrice);\n', '    \n', '  // Crowdsale multisig address has been changed    \n', '  event MultiSigChanged(address newAddr);\n', '  \n', '  // Crowdsale beneficiary address has been changed    \n', '  event BeneficiaryChanged(address newAddr);\n', '  \n', '  // Founders Team Wallet Address Changed \n', '  event FoundersWalletChanged(address newAddr);\n', '  \n', '  // Founders Team Token Allocation Percentage Changed \n', '  event FoundersTokenAllocationChanged(uint newValue);\n', '  \n', '  // Pre-Presale Tokens Value Changed\n', '  event PrePresaleTokensValueChanged(uint newValue);\n', '\n', '  constructor(address _token, uint _oneTokenInWei, address _multisigWallet, uint _start, uint _end, address _beneficiary, address _foundersTeamMultisig) public {\n', '\n', '    require(_multisigWallet != address(0) && _start != 0 && _end != 0 && _start <= _end);\n', '    owner = msg.sender;\n', '\n', '    token = FractionalERC20(_token);\n', '    oneTokenInWei = _oneTokenInWei;\n', '\n', '    multisigWallet = _multisigWallet;\n', '    startsAt = _start;\n', '    endsAt = _end;\n', '\n', '    beneficiary = _beneficiary;\n', '    foundersTeamMultisig = _foundersTeamMultisig;\n', '  }\n', '  \n', '  /**\n', '   * Just send in money and get tokens.\n', '   * Modified by : TokenMagic\n', '   */\n', '  function() payable public {\n', '    investInternal(msg.sender,0);\n', '  }\n', '  \n', '  /** \n', '  * Pre-sale contract call this function and get tokens \n', '  * Modified by : TokenMagic\n', '  */\n', '  function invest(address addr,uint tokenAmount) public payable {\n', '    investInternal(addr,tokenAmount);\n', '  }\n', '  \n', '  /**\n', '   * Make an investment.\n', '   *\n', '   * Crowdsale must be running for one to invest.\n', '   * We must have not pressed the emergency brake.\n', '   *\n', '   * @param receiver The Ethereum address who receives the tokens\n', '   *\n', '   * @return tokenAmount How mony tokens were bought\n', '   *\n', '   * Modified by : TokenMagic\n', '   */\n', '  function investInternal(address receiver, uint tokens) stopInEmergency internal returns(uint tokensBought) {\n', '\n', '    uint weiAmount = msg.value;\n', '    uint tokenAmount = tokens;\n', '    if(getState() == State.PreFunding || getState() == State.Funding) {\n', '      if(presaleWhitelist[msg.sender]){\n', '        // Allow presale particaipants\n', '        presaleWeiRaised = presaleWeiRaised.add(weiAmount);\n', '        presaleTokensSold = presaleTokensSold.add(tokenAmount);\n', '        require(presaleTokensSold <= presaleTokenLimit); \n', '      }\n', '      else if(participantWhitelist[receiver]){\n', '        uint multiplier = 10 ** token.decimals();\n', '        tokenAmount = weiAmount.times(multiplier) / oneTokenInWei;\n', '        // Allow whitelisted participants    \n', '      }\n', '      else {\n', '        revert();\n', '      }\n', '    } else {\n', '      // Unwanted state\n', '      revert();\n', '    }\n', '    \n', '    // Dust transaction\n', '    require(tokenAmount != 0);\n', '\n', '    if(investedAmountOf[receiver] == 0) {\n', '      // A new investor\n', '      investorCount++;\n', '    }\n', '\n', '    // Update investor\n', '    investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\n', '    tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\n', '\n', '    // Update totals\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    tokensSold = tokensSold.add(tokenAmount);\n', '    \n', '    require(tokensSold.sub(presaleTokensSold) <= crowdsaleTokenLimit);\n', '    \n', '    // Check that we did not bust the cap\n', '    require(!isBreakingCap(tokenAmount));\n', '    require(token.transferFrom(beneficiary, receiver, tokenAmount));\n', '\n', '    emit Invested(receiver, weiAmount, tokenAmount);\n', '    multisigWallet.transfer(weiAmount);\n', '    return tokenAmount;\n', '  }\n', '\n', '  /**\n', '   * Finalize a succcesful crowdsale.\n', '   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.\n', '   * Added by : TokenMagic\n', '   */\n', '  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n', '    require(!finalized); // Not already finalized\n', '    \n', '    // How many % of tokens the founders and others get\n', '    tokensForFoundingBoardWallet = tokensSold.times(percentageOfSoldTokensForFounders) / 100;\n', '    tokensForFoundingBoardWallet = tokensForFoundingBoardWallet.add(prePresaleTokensSold);\n', '    require(token.transferFrom(beneficiary, foundersTeamMultisig, tokensForFoundingBoardWallet));\n', '    \n', '    finalized = true;\n', '  }\n', '\n', '  /**\n', '   * Allow owner to change the percentage value of solded tokens to founders team wallet after finalize. Default value is 50.\n', '   * Added by : TokenMagic\n', '   */ \n', '  function setFoundersTokenAllocation(uint _percentageOfSoldTokensForFounders) public onlyOwner{\n', '    percentageOfSoldTokensForFounders = _percentageOfSoldTokensForFounders;\n', '    emit FoundersTokenAllocationChanged(percentageOfSoldTokensForFounders);\n', '  }\n', '\n', '  /**\n', '   * Allow crowdsale owner to close early or extend the crowdsale.\n', '   *\n', '   * This is useful e.g. for a manual soft cap implementation:\n', '   * - after X amount is reached determine manual closing\n', '   *\n', '   * This may put the crowdsale to an invalid state,\n', '   * but we trust owners know what they are doing.\n', '   *\n', '   */\n', '  function setEndsAt(uint time) onlyOwner public {\n', '    require(now < time && startsAt < time);\n', '    endsAt = time;\n', '    emit EndsAtChanged(endsAt);\n', '  }\n', '  \n', '  /**\n', '   * Allow owner to change crowdsale startsAt data.\n', '   * Added by : TokenMagic\n', '   **/ \n', '  function setStartsAt(uint time) onlyOwner public {\n', '    require(time < endsAt);\n', '    startsAt = time;\n', '    emit StartsAtChanged(startsAt);\n', '  }\n', '\n', '  /**\n', '   * Allow to change the team multisig address in the case of emergency.\n', '   *\n', '   * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun\n', '   * (we have done only few test transactions). After the crowdsale is going\n', '   * then multisig address stays locked for the safety reasons.\n', '   */\n', '  function setMultisig(address addr) public onlyOwner {\n', '    multisigWallet = addr;\n', '    emit MultiSigChanged(addr);\n', '  }\n', '\n', '  /**\n', '   * Allow load refunds back on the contract for the refunding.\n', '   *\n', '   * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\n', '   */\n', '  function loadRefund() public payable inState(State.Failure) {\n', '    require(msg.value > 0);\n', '    loadedRefund = loadedRefund.add(msg.value);\n', '  }\n', '\n', '  /**\n', '   * Investors can claim refund.\n', '   *\n', '   * Note that any refunds from proxy buyers should be handled separately,\n', '   * and not through this contract.\n', '   */\n', '  function refund() public inState(State.Refunding) {\n', '    // require(token.transferFrom(msg.sender,address(this),tokenAmountOf[msg.sender])); user should approve their token to this contract before this.\n', '    uint256 weiValue = investedAmountOf[msg.sender];\n', '    require(weiValue > 0);\n', '    investedAmountOf[msg.sender] = 0;\n', '    weiRefunded = weiRefunded.add(weiValue);\n', '    emit Refund(msg.sender, weiValue);\n', '    msg.sender.transfer(weiValue);\n', '  }\n', '\n', '  /**\n', '   * @return true if the crowdsale has raised enough money to be a successful.\n', '   */\n', '  function isMinimumGoalReached() public view  returns (bool reached) {\n', '    return weiRaised >= minimumFundingGoal;\n', '  }\n', '\n', '\n', '  /**\n', '   * Crowdfund state machine management.\n', '   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.\n', '   * Modified by : TokenMagic\n', '   */\n', '  function getState() public view returns (State) {\n', '    if(finalized) return State.Finalized;\n', '    else if (block.timestamp < startsAt) return State.PreFunding;\n', '    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n', '    else if (isMinimumGoalReached()) return State.Success;\n', '    else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\n', '    else return State.Failure;\n', '  }\n', '\n', '  /** This is for manual testing of multisig wallet interaction */\n', '  function setOwnerTestValue(uint val) onlyOwner public {\n', '    ownerTestValue = val;\n', '  }\n', '\n', '  /**\n', '  * Allow owner to change PrePresaleTokensSold value \n', '  * Added by : TokenMagic\n', '  **/\n', '  function setPrePresaleTokens(uint _value) onlyOwner public {\n', '    prePresaleTokensSold = _value;\n', '    emit PrePresaleTokensValueChanged(_value);\n', '  }\n', '\n', '  /**\n', '   * Allow addresses to do participation.\n', '   * Modified by : TokenMagic\n', '  */\n', '  function setParticipantWhitelist(address[] addr, bool status) onlyOwner public {\n', '    for(uint i = 0; i < addr.length; i++ ){\n', '      participantWhitelist[addr[i]] = status;\n', '    }\n', '    emit Whitelisted(addr, status);\n', '  }\n', '\n', '  /**\n', '   * Allow presale to do participation.\n', '   * Added by : TokenMagic\n', '  */\n', '  function setPresaleWhitelist(address addr, bool status) onlyOwner public {\n', '    presaleWhitelist[addr] = status;\n', '    emit PresaleWhitelisted(addr, status);\n', '  }\n', '  \n', '  /**\n', '   * Allow crowdsale owner to change the crowdsale token price.\n', '   * Added by : TokenMagic\n', '  */\n', '  function setPricing(uint _oneTokenInWei) onlyOwner public{\n', '    oneTokenInWei = _oneTokenInWei;\n', '    emit TokenPriceChanged(oneTokenInWei);\n', '  } \n', '  \n', '  /**\n', '   * Allow crowdsale owner to change the crowdsale beneficiary address.\n', '   * Added by : TokenMagic\n', '  */\n', '  function changeBeneficiary(address _beneficiary) onlyOwner public{\n', '    beneficiary = _beneficiary; \n', '    emit BeneficiaryChanged(beneficiary);\n', '  }\n', '  \n', '  /**\n', '   * Allow crowdsale owner to change the crowdsale founders team address.\n', '   * Added by : TokenMagic\n', '  */\n', '  function changeFoundersWallet(address _foundersTeamMultisig) onlyOwner public{\n', '    foundersTeamMultisig = _foundersTeamMultisig;\n', '    emit FoundersWalletChanged(foundersTeamMultisig);\n', '  } \n', '  \n', '  /** Interface marker. */\n', '  function isCrowdsale() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  //\n', '  // Modifiers\n', '  //\n', '\n', '  /** Modified allowing execution only if the crowdsale is currently running.  */\n', '  modifier inState(State state) {\n', '    require(getState() == state);\n', '    _;\n', '  }\n', '\n', ' /**\n', '   * Called from invest() to confirm if the curret investment does not break our cap rule.\n', '   */\n', '  function isBreakingCap(uint tokenAmount) public view returns (bool limitBroken)  {\n', '    if(tokenAmount > getTokensLeft()) {\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * We are sold out when our approve pool becomes empty.\n', '   */\n', '  function isCrowdsaleFull() public view returns (bool) {\n', '    return getTokensLeft() == 0;\n', '  }\n', '\n', '  /**\n', '   * Get the amount of unsold tokens allocated to this contract;\n', '   */\n', '  function getTokensLeft() public view returns (uint) {\n', '    return token.allowance(beneficiary, this);\n', '  }\n', '\n', '}']