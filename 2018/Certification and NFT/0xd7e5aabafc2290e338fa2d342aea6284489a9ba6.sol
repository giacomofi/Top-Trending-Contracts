['// solium-disable linebreak-style\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Whitelist\n', ' * @dev Whitelist contract has its own role whitelister and maintains index of whitelisted addresses.\n', ' */\n', 'contract Whitelist {\n', '\n', '    // who can whitelist\n', '    address public whitelister;\n', '\n', '    // Whitelist mapping\n', '    mapping (address => bool) whitelist;\n', '\n', '    /**\n', '      * @dev The Whitelist constructor sets the original `whitelister` of the contract to the sender\n', '      * account.\n', '      */\n', '    constructor() public {\n', '        whitelister = msg.sender;\n', '    }\n', '\n', '    /**\n', '      * @dev Throws if called by any account other than the whitelister.\n', '      */\n', '    modifier onlyWhitelister() {\n', '        require(msg.sender == whitelister);\n', '        _;\n', '    }\n', '\n', '    modifier addressNotZero(address _address) {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhitelisted(address _address) {\n', '        require(whitelist[_address]);\n', '        _;\n', '    }\n', '\n', '    /** \n', '    * @dev Only callable by the whitelister. Whitelists the specified address.\n', '    * @notice Only callable by the whitelister. Whitelists the specified address.\n', '    * @param _address Address to be whitelisted. \n', '    */\n', '    function addToWhitelist(address _address) public onlyWhitelister addressNotZero(_address) {\n', '        emit WhitelistAdd(whitelister, _address);\n', '        whitelist[_address] = true;\n', '    }\n', '    \n', '    /** \n', '    * @dev Only callable by the whitelister. Whitelists the specified addresses.\n', '    * @notice Only callable by the whitelister. Whitelists the specified addresses.\n', '    * @param _addresses Addresses to be whitelisted. \n', '    */\n', '    function addAddressesToWhitelist(address[] _addresses) public onlyWhitelister {\n', '        for(uint i = 0; i < _addresses.length; ++i)\n', '            addToWhitelist(_addresses[i]);\n', '    }\n', '\n', '    /**\n', '    * @dev Checks if the specified address is whitelisted.\n', '    * @notice Checks if the specified address is whitelisted. \n', '    * @param _address Address to be whitelisted.\n', '    */\n', '    function isWhitelisted(address _address) public view returns (bool) {\n', '        return whitelist[_address];\n', '    }\n', '\n', '    /**\n', '      * @dev Changes the current whitelister. Callable only by the whitelister.\n', '      * @notice Changes the current whitelister. Callable only by the whitelister.\n', '      * @param _newWhitelister Address of new whitelister.\n', '      */\n', '    function changeWhitelister(address _newWhitelister) public onlyWhitelister addressNotZero(_newWhitelister) {\n', '        emit WhitelisterChanged(whitelister, _newWhitelister);\n', '        whitelister = _newWhitelister;\n', '    }\n', '\n', '    /** \n', '    * Event for logging the whitelister change. \n', '    * @param previousWhitelister Old whitelister.\n', '    * @param newWhitelister New whitelister.\n', '    */\n', '    event WhitelisterChanged(address indexed previousWhitelister, address indexed newWhitelister);\n', '    \n', '    /** \n', '    * Event for logging when the user is whitelisted.\n', '    * @param whitelister Current whitelister.\n', '    * @param whitelistedAddress User added to whitelist.\n', '    */\n', '    event WhitelistAdd(address indexed whitelister, address indexed whitelistedAddress);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\n', '    // Owner&#39;s address\n', '    address public owner;\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != address(0));\n', '        emit OwnerChanged(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '\n', '    event OwnerChanged(address indexed previousOwner,address indexed newOwner);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  function balanceOf(address who) external view returns (uint256);\n', '\n', '  function allowance(address owner, address spender)\n', '    external view returns (uint256);\n', '\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '\n', '  function approve(address spender, uint256 value)\n', '    external returns (bool);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    external returns (bool);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '      // benefit is lost if &#39;b&#39; is also tested.\n', '      // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'contract AoraCrowdsale is Whitelist, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    // Token being sold\n', '    IERC20 public token;\n', '\n', '    // Start of presale timestamp in miliseconds\n', '    uint public startOfPresale;\n', '\n', '    // End of presale timestamp in miliseconds\n', '    uint public endOfPresale;\n', '\n', '    // Start of crowdsale timestamp in miliseconds\n', '    uint public startOfCrowdsale;\n', '\n', '    // End of crowdsale timestamp in miliseconds\n', '    uint public endOfCrowdsale;\n', '\n', '    // Maximum number of tokens that can be sold\n', '    uint public cap;\n', '\n', '    // Tokens sold so far\n', '    uint public tokensSold = 0;\n', '\n', '    // US Dollars raised so far in cents \n', '    uint public usdRaised = 0;\n', '\n', '    // Deployment block of the contract \n', '    uint public deploymentBlock;\n', '\n', '    // Tokens per US Dollar rate, fixed for this crowsale.\n', '    uint public tokensPerUsdRate = 5;\n', '\n', '    // Factor that we multiply with to get whole tokens from cents \n', '    uint constant public centsToWholeTokenFactor = 10 ** 16; \n', '\n', '    /**\n', '    * @param _startOfPresale start of presale timestamp\n', '    * @param _endOfPresale  end of presale timestamp\n', '    * @param _startOfCrowdsale start of crowdsale timestamp\n', '    * @param _endOfCrowdsale end of crowdsale timestamp\n', '    * @param _tokensPerUsdRate how many tokens per US Dollar contributed\n', '    * @param _cap total amount of sellable tokens \n', '    * @param _token address of the token contract \n', '    */\n', '    constructor(\n', '        uint _startOfPresale, \n', '        uint _endOfPresale, \n', '        uint _startOfCrowdsale, \n', '        uint _endOfCrowdsale, \n', '        uint _tokensPerUsdRate, \n', '        uint _cap,\n', '        IERC20 _token\n', '        ) public addressNotZero(_token) {\n', '        \n', '        startOfPresale = _startOfPresale;\n', '        endOfPresale = _endOfPresale;\n', '        startOfCrowdsale = _startOfCrowdsale;\n', '        endOfCrowdsale = _endOfCrowdsale;\n', '\n', '        tokensPerUsdRate = _tokensPerUsdRate; \n', '\n', '        cap = _cap;\n', '\n', '        token = _token;\n', '\n', '        deploymentBlock = block.number;\n', '    }\n', '\n', '    /**\n', '    * @dev Fallback function. Can&#39;t send ether to this contract. \n', '    */\n', '    function () external payable {\n', '        revert();\n', '    }\n', '\n', '    /**\n', '    * @dev signifies weather or not the argument has any value\n', '    * @param usdAmount amount of US Dollars in cents \n', '    */ \n', '    modifier hasValue(uint usdAmount) {\n', '        require(usdAmount > 0);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev signifies weather or not crowdsale is over\n', '    */\n', '    modifier crowdsaleNotOver() {\n', '        require(isCrowdsale()); \n', '        _;\n', '    }\n', '\n', '    /** \n', '    * @dev sets the start of presale\n', '    */\n', '    function setStartOfPresale(uint _startOfPresale) external onlyOwner {\n', '        emit OnStartOfPresaleSet(_startOfPresale, startOfPresale); \n', '        startOfPresale = _startOfPresale;\n', '    }\n', '\n', '    /**\n', '    * @dev sets the end of presale\n', '    * @param _endOfPresale new timestamp value  \n', '    */\n', '    function setEndOfPresale(uint _endOfPresale) external onlyOwner {\n', '        emit OnEndOfPresaleSet(_endOfPresale, endOfPresale); \n', '        endOfPresale = _endOfPresale;\n', '    }\n', '\n', '    /**\n', '    * @dev sets the start of crowdsale\n', '    * @param _startOfCrowdsale new timestamp value\n', '    */\n', '    function setStartOfCrowdsale(uint _startOfCrowdsale) external onlyOwner {\n', '        emit OnStartOfCrowdsaleSet(_startOfCrowdsale, startOfCrowdsale);\n', '        startOfCrowdsale = _startOfCrowdsale;\n', '    }\n', '\n', '    /**\n', '    * @dev sets the end of crowdsale\n', '    * @param _endOfCrowdsale new timestamp value\n', '    */\n', '    function setEndOfCrowdsale(uint _endOfCrowdsale) external onlyOwner {\n', '        emit OnEndOfCrowdsaleSet(_endOfCrowdsale, endOfCrowdsale);\n', '        endOfCrowdsale = _endOfCrowdsale;\n', '    }\n', '\n', '    /** \n', '    * @dev sets the cap\n', '    * @param _cap new cap value\n', '    */\n', '    function setCap(uint _cap) external onlyOwner { \n', '        emit OnCapSet(_cap, cap);\n', '        cap = _cap;\n', '    }\n', '\n', '    /**\n', '    * @dev sets the tokensPerUsdRate\n', '    * @param _tokensPerUsdRate new tokens per US Dollar rate\n', '    */\n', '    function setTokensPerUsdRate(uint _tokensPerUsdRate) external onlyOwner {\n', '        emit OnTokensPerUsdRateSet(_tokensPerUsdRate, tokensPerUsdRate);\n', '        tokensPerUsdRate = _tokensPerUsdRate;\n', '    }\n', '\n', '    /**\n', '    * @dev returns weather or not the presale is over\n', '    */\n', '    function isPresale() public view returns(bool) {\n', '        return now < endOfPresale;\n', '    }\n', '\n', '    /** \n', '    * @dev returns weather or not the crowdsale is over\n', '    */\n', '    function isCrowdsale() public view returns(bool) {\n', '        return now < endOfCrowdsale;\n', '    }\n', '\n', '    /**\n', '    * @dev Creates a contribution for the specified beneficiary.\n', '    *   Callable only by the owner, while the crowdsale is not over. \n', '    *   Whitelists the beneficiary as well, to optimize gas cost.\n', '    * @param beneficiary address of the beneficiary\n', '    * @param usdAmount contribution value in cents\n', '    */\n', '    function createContribution(address beneficiary, uint usdAmount) public \n', '    onlyOwner \n', '    addressNotZero(beneficiary) \n', '    hasValue(usdAmount)\n', '    crowdsaleNotOver\n', '    {        \n', '        usdRaised = usdRaised.add(usdAmount); // USD amount in cents \n', '\n', '        uint aoraTgeAmount = usdAmount.mul(tokensPerUsdRate).mul(centsToWholeTokenFactor); \n', '\n', '        if(isPresale())\n', '            aoraTgeAmount = aoraTgeAmount.mul(11).div(10); // 10% presale bonus, paid out from crowdsale pool\n', '\n', '        uint newTokensSoldAmount = tokensSold.add(aoraTgeAmount);\n', '\n', '        require(newTokensSoldAmount <= cap);\n', '\n', '        tokensSold = newTokensSoldAmount;\n', '\n', '        token.transfer(beneficiary, aoraTgeAmount);\n', '\n', '        addToWhitelist(beneficiary);\n', '\n', '        emit OnContributionCreated(beneficiary, usdAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Create contributions in bulk, to optimize gas cost.\n', '    * @param beneficiaries addresses of beneficiaries \n', '    * @param usdAmounts USDollar value of the each contribution in cents.\n', '    */\n', '    function createBulkContributions(address[] beneficiaries, uint[] usdAmounts) external onlyOwner {\n', '        require(beneficiaries.length == usdAmounts.length);\n', '        for (uint i = 0; i < beneficiaries.length; ++i)\n', '            createContribution(beneficiaries[i], usdAmounts[i]);\n', '    }\n', '\n', '    /**\n', '    * @dev This method can be used by the owner to extract mistakenly sent tokens\n', '    * or Ether sent to this contract.\n', '    * @param _token address The address of the token contract that you want to\n', '    * recover set to 0 in case you want to extract ether. It can&#39;t be ElpisToken.\n', '    */\n', '    function claimTokens(address _token) public onlyOwner {\n', '        require(_token != address(token));\n', '\n', '        if (_token == address(0)) {\n', '            owner.transfer(address(this).balance);\n', '            return;\n', '        }\n', '\n', '        IERC20 tokenReference = IERC20(_token);\n', '        uint balance = tokenReference.balanceOf(address(this));\n', '        tokenReference.transfer(owner, balance);\n', '        emit OnClaimTokens(_token, owner, balance);\n', '    }\n', '\n', '    /**\n', '    * @param oldValue old value of the field\n', '    * @param newValue new value of the field\n', '    */\n', '    event OnTokensPerUsdRateSet(uint256 oldValue, uint256 newValue);\n', '\n', '    /**\n', '    * @param oldValue old value of the field\n', '    * @param newValue new value of the field\n', '    */\n', '    event OnCapSet(uint256 oldValue, uint256 newValue);\n', '\n', '    /**\n', '    * @param oldValue old value of the field\n', '    * @param newValue new value of the field\n', '    */\n', '    event OnStartOfPresaleSet(uint256 oldValue, uint256 newValue);\n', '\n', '    /**\n', '    * @param oldValue old value of the field\n', '    * @param newValue new value of the field\n', '    */\n', '    event OnEndOfPresaleSet(uint256 oldValue, uint256 newValue);\n', '\n', '    /**\n', '    * @param oldValue old value of the field\n', '    * @param newValue new value of the field\n', '    */\n', '    event OnStartOfCrowdsaleSet(uint256 oldValue, uint256 newValue);\n', '\n', '    /**\n', '    * @param oldValue old value of the field\n', '    * @param newValue new value of the field\n', '    */\n', '    event OnEndOfCrowdsaleSet(uint256 oldValue, uint256 newValue);\n', '\n', '    /**\n', '    * @param token claimed token\n', '    * @param owner who owns the contract\n', '    * @param amount amount of the claimed token\n', '    */\n', '    event OnClaimTokens(address indexed token, address indexed owner, uint256 amount);\n', '\n', '    /**\n', '    * @param beneficiary who is the recipient of tokens from the contribution\n', '    * @param weiAmount Amount of wei contributed \n', '    */\n', '    event OnContributionCreated(address indexed beneficiary, uint256 weiAmount);\n', '}']