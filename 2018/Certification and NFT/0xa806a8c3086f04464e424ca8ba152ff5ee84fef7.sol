['pragma solidity ^0.4.18;\n', '\n', '\n', '//>> Reference to https://github.com/OpenZeppelin/zeppelin-solidity\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '//<< Reference to https://github.com/OpenZeppelin/zeppelin-solidity\n', '\n', '\n', '\n', '\n', 'contract Coin {\n', '    function sell(address _to, uint256 _value, string _note) public returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @title MultiOwnable\n', ' */\n', 'contract MultiOwnable {\n', '    address public root;\n', '    mapping (address => address) public owners; // owner => parent of owner\n', '    \n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function MultiOwnable() public {\n', '        root= msg.sender;\n', '        owners[root]= root;\n', '    }\n', '    \n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(owners[msg.sender] != 0);\n', '        _;\n', '    }\n', '    \n', '    /**\n', '    * @dev Adding new owners\n', '    */\n', '    function newOwner(address _owner) onlyOwner public returns (bool) {\n', '        require(_owner != 0);\n', '        owners[_owner]= msg.sender;\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Deleting owners\n', '     */\n', '    function deleteOwner(address _owner) onlyOwner public returns (bool) {\n', '        require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));\n', '        owners[_owner]= 0;\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title KStarCoinSale\n', ' * @author Tae Kim\n', ' * @notice This contract is for crowdfunding of KStarCoin.\n', ' */\n', 'contract KStarCoinSale is MultiOwnable {\n', '    using SafeMath for uint256;\n', '    \n', '    eICOLevel public level;\n', '    uint256 public rate;\n', '    uint256 public minWei;\n', '\n', '    function checkValidLevel(eICOLevel _level) public pure returns (bool) {\n', '        return (_level == eICOLevel.C_ICO_PRESALE || _level == eICOLevel.C_ICO_ONSALE || _level == eICOLevel.C_ICO_END);\n', '    }\n', '\n', '    modifier onSale() {\n', '        require(level != eICOLevel.C_ICO_END);\n', '        _;\n', '    }\n', '    \n', '    enum eICOLevel { C_ICO_PRESALE, C_ICO_ONSALE, C_ICO_END }\n', '    \n', '    Coin public coin;\n', '    address public wallet;\n', '\n', '    // Constructure\n', '    function KStarCoinSale(Coin _coin, address _wallet) public {\n', '        require(_coin != address(0));\n', '        require(_wallet != address(0));\n', '        \n', '        coin= _coin;\n', '        wallet= _wallet;\n', '\n', '        updateICOVars(  eICOLevel.C_ICO_PRESALE,\n', '                        3750,       // 3000 is default, +750 is pre-sale bonus\n', '                        1e5 szabo); // = 0.1 ether\n', '    }\n', '    \n', '    // Update variables related to crowdfunding\n', '    function updateICOVars(eICOLevel _level, uint256 _rate, uint256 _minWei) onlyOwner public returns (bool) {\n', '        require(checkValidLevel(_level));\n', '        require(_rate != 0);\n', '        require(_minWei >= 1 szabo);\n', '        \n', '        level= _level;\n', '        rate= _rate;\n', '        minWei= _minWei;\n', '        \n', '        ICOVarsChange(level, rate, minWei);\n', '        return true;\n', '    }\n', '    \n', '    function () external payable {\n', '        buyCoin(msg.sender);\n', '    }\n', '    \n', '    function buyCoin(address beneficiary) onSale public payable {\n', '        require(beneficiary != address(0));\n', '        require(msg.value >= minWei);\n', '\n', '        // calculate token amount to be created\n', '        uint256 coins= getCoinAmount(msg.value);\n', '        \n', '        // update state \n', '        coin.sell(beneficiary, coins, "");\n', '        \n', '        forwardFunds();\n', '    }\n', '\n', '    function getCoinAmount(uint256 weiAmount) internal view returns(uint256) {\n', '        return weiAmount.mul(rate);\n', '    }\n', '  \n', '    // send ether to the fund collection wallet\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '    \n', '    event ICOVarsChange(eICOLevel level, uint256 rate, uint256 minWei);\n', '}']