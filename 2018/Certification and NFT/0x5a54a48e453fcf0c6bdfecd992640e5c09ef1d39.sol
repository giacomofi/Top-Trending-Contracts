['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'contract ERC20Extended is ERC20 {\n', '    uint256 public decimals;\n', '    string public name;\n', '    string public symbol;\n', '\n', '}\n', '\n', 'contract ComponentInterface {\n', '    string public name;\n', '    string public description;\n', '    string public category;\n', '    string public version;\n', '}\n', '\n', 'contract ExchangeInterface is ComponentInterface {\n', '    /*\n', '     * @dev Checks if a trading pair is available\n', '     * For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n', '     * @param address _sourceAddress The token to sell for the destAddress.\n', '     * @param address _destAddress The token to buy with the source token.\n', '     * @param bytes32 _exchangeId The exchangeId to choose. If it&#39;s an empty string, then the exchange will be chosen automatically.\n', '     * @return boolean whether or not the trading pair is supported by this exchange provider\n', '     */\n', '    function supportsTradingPair(address _srcAddress, address _destAddress, bytes32 _exchangeId)\n', '        external view returns(bool supported);\n', '\n', '    /*\n', '     * @dev Buy a single token with ETH.\n', '     * @param ERC20Extended _token The token to buy, should be an ERC20Extended address.\n', '     * @param uint _amount Amount of ETH used to buy this token. Make sure the value sent to this function is the same as the _amount.\n', '     * @param uint _minimumRate The minimum amount of tokens to receive for 1 ETH.\n', '     * @param address _depositAddress The address to send the bought tokens to.\n', '     * @param bytes32 _exchangeId The exchangeId to choose. If it&#39;s an empty string, then the exchange will be chosen automatically.\n', '     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here.\n', '     * @return boolean whether or not the trade succeeded.\n', '     */\n', '    function buyToken\n', '        (\n', '        ERC20Extended _token, uint _amount, uint _minimumRate,\n', '        address _depositAddress, bytes32 _exchangeId, address _partnerId\n', '        ) external payable returns(bool success);\n', '\n', '    /*\n', '     * @dev Sell a single token for ETH. Make sure the token is approved beforehand.\n', '     * @param ERC20Extended _token The token to sell, should be an ERC20Extended address.\n', '     * @param uint _amount Amount of tokens to sell.\n', '     * @param uint _minimumRate The minimum amount of ETH to receive for 1 ERC20Extended token.\n', '     * @param address _depositAddress The address to send the bought tokens to.\n', '     * @param bytes32 _exchangeId The exchangeId to choose. If it&#39;s an empty string, then the exchange will be chosen automatically.\n', '     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here\n', '     * @return boolean boolean whether or not the trade succeeded.\n', '     */\n', '    function sellToken\n', '        (\n', '        ERC20Extended _token, uint _amount, uint _minimumRate,\n', '        address _depositAddress, bytes32 _exchangeId, address _partnerId\n', '        ) external returns(bool success);\n', '}\n', '\n', 'contract KyberNetworkInterface {\n', '\n', '    function getExpectedRate(ERC20Extended src, ERC20Extended dest, uint srcQty)\n', '        external view returns (uint expectedRate, uint slippageRate);\n', '\n', '    function trade(\n', '        ERC20Extended source,\n', '        uint srcAmount,\n', '        ERC20Extended dest,\n', '        address destAddress,\n', '        uint maxDestAmount,\n', '        uint minConversionRate,\n', '        address walletId)\n', '        external payable returns(uint);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract OlympusExchangeAdapterInterface is Ownable {\n', '\n', '    function supportsTradingPair(address _srcAddress, address _destAddress)\n', '        external view returns(bool supported);\n', '\n', '    function getPrice(ERC20Extended _sourceAddress, ERC20Extended _destAddress, uint _amount)\n', '        external view returns(uint expectedRate, uint slippageRate);\n', '\n', '    function sellToken\n', '        (\n', '        ERC20Extended _token, uint _amount, uint _minimumRate,\n', '        address _depositAddress\n', '        ) external returns(bool success);\n', '\n', '    function buyToken\n', '        (\n', '        ERC20Extended _token, uint _amount, uint _minimumRate,\n', '        address _depositAddress\n', '        ) external payable returns(bool success);\n', '\n', '    function enable() external returns(bool);\n', '    function disable() external returns(bool);\n', '    function isEnabled() external view returns (bool success);\n', '\n', '    function setExchangeDetails(bytes32 _id, bytes32 _name) external returns(bool success);\n', '    function getExchangeDetails() external view returns(bytes32 _name, bool _enabled);\n', '\n', '}\n', '\n', 'contract OlympusExchangeAdapterManagerInterface is Ownable {\n', '    function pickExchange(ERC20Extended _token, uint _amount, uint _rate, bool _isBuying) public view returns (bytes32 exchangeId);\n', '    function supportsTradingPair(address _srcAddress, address _destAddress, bytes32 _exchangeId) external view returns(bool supported);\n', '    function getExchangeAdapter(bytes32 _exchangeId) external view returns(address);\n', '    function isValidAdapter(address _adapter) external view returns(bool);\n', '    function getPrice(ERC20Extended _sourceAddress, ERC20Extended _destAddress, uint _amount, bytes32 _exchangeId)\n', '        external view returns(uint expectedRate, uint slippageRate);\n', '}\n', '\n', 'contract ExchangeAdapterManager is OlympusExchangeAdapterManagerInterface {\n', '\n', '    mapping(bytes32 => OlympusExchangeAdapterInterface) public exchangeAdapters;\n', '    bytes32[] public exchanges;\n', '    uint private genExchangeId = 1000;\n', '    mapping(address=>uint) private adapters;\n', '    ERC20Extended private constant ETH_TOKEN_ADDRESS = ERC20Extended(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '\n', '\n', '    event AddedExchange(bytes32 id);\n', '\n', '    function addExchange(bytes32 _name, address _adapter)\n', '    external onlyOwner returns(bool) {\n', '        require(_adapter != 0x0);\n', '        bytes32 id = keccak256(abi.encodePacked(_adapter, genExchangeId++));\n', '        require(OlympusExchangeAdapterInterface(_adapter).setExchangeDetails(id, _name));\n', '        exchanges.push(id);\n', '        exchangeAdapters[id] = OlympusExchangeAdapterInterface(_adapter);\n', '        adapters[_adapter]++;\n', '\n', '        emit AddedExchange(id);\n', '        return true;\n', '    }\n', '\n', '    function getExchanges() external view returns(bytes32[]) {\n', '        return exchanges;\n', '    }\n', '\n', '    function getExchangeInfo(bytes32 _id)\n', '    external view returns(bytes32 name, bool status) {\n', '        OlympusExchangeAdapterInterface adapter = exchangeAdapters[_id];\n', '        require(address(adapter) != 0x0);\n', '\n', '        return adapter.getExchangeDetails();\n', '    }\n', '\n', '    function getExchangeAdapter(bytes32 _id)\n', '    external view returns(address)\n', '    {\n', '        return address(exchangeAdapters[_id]);\n', '    }\n', '\n', '    function getPrice(ERC20Extended _sourceAddress, ERC20Extended _destAddress, uint _amount, bytes32 _exchangeId)\n', '        external view returns(uint expectedRate, uint slippageRate) {\n', '\n', '        if(_exchangeId != 0x0) {\n', '            return exchangeAdapters[_exchangeId].getPrice(_sourceAddress, _destAddress, _amount);\n', '        }\n', '        bytes32 exchangeId = _sourceAddress == ETH_TOKEN_ADDRESS ?\n', '        pickExchange(_destAddress, _amount, 0, true) :\n', '        pickExchange(_sourceAddress, _amount, 0, false);\n', '        if(exchangeId != 0x0) {\n', '            OlympusExchangeAdapterInterface adapter = exchangeAdapters[exchangeId];\n', '            return adapter.getPrice(_sourceAddress, _destAddress, _amount);\n', '        }\n', '        return(0, 0);\n', '    }\n', '\n', '    /// >0  : found exchangeId\n', '    /// ==0 : not found\n', '    function pickExchange(ERC20Extended _token, uint _amount, uint _rate, bool _isBuying) public view returns (bytes32 exchangeId) {\n', '\n', '        int maxRate = -1;\n', '        for (uint i = 0; i < exchanges.length; i++) {\n', '\n', '            bytes32 id = exchanges[i];\n', '            OlympusExchangeAdapterInterface adapter = exchangeAdapters[id];\n', '            if (!adapter.isEnabled()) {\n', '                continue;\n', '            }\n', '            uint adapterResultRate;\n', '            uint adapterResultSlippage;\n', '            if (_isBuying){\n', '                (adapterResultRate,adapterResultSlippage) = adapter.getPrice(ETH_TOKEN_ADDRESS, _token, _amount);\n', '            } else {\n', '                (adapterResultRate,adapterResultSlippage) = adapter.getPrice(_token, ETH_TOKEN_ADDRESS, _amount);\n', '            }\n', '            int resultRate = int(adapterResultSlippage);\n', '\n', '\n', '            if (adapterResultRate == 0) { // not support\n', '                continue;\n', '            }\n', '\n', '            if (resultRate < int(_rate)) {\n', '                continue;\n', '            }\n', '\n', '            if (resultRate >= maxRate) {\n', '                maxRate = resultRate;\n', '                return id;\n', '            }\n', '        }\n', '        return 0x0;\n', '    }\n', '\n', '    function supportsTradingPair(address _srcAddress, address _destAddress, bytes32 _exchangeId) external view returns (bool) {\n', '        OlympusExchangeAdapterInterface adapter;\n', '        if(_exchangeId != ""){\n', '            adapter = exchangeAdapters[id];\n', '            if(!adapter.isEnabled()){\n', '                return false;\n', '            }\n', '            if (adapter.supportsTradingPair(_srcAddress, _destAddress)) {\n', '                return true;\n', '            }\n', '            return false;\n', '        }\n', '        for (uint i = 0; i < exchanges.length; i++) {\n', '            bytes32 id = exchanges[i];\n', '            adapter = exchangeAdapters[id];\n', '            if (!adapter.isEnabled()) {\n', '                continue;\n', '            }\n', '            if (adapter.supportsTradingPair(_srcAddress, _destAddress)) {\n', '                return true;\n', '            }\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function isValidAdapter(address _adapter) external view returns (bool) {\n', '        return adapters[_adapter] > 0;\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'contract ERC20Extended is ERC20 {\n', '    uint256 public decimals;\n', '    string public name;\n', '    string public symbol;\n', '\n', '}\n', '\n', 'contract ComponentInterface {\n', '    string public name;\n', '    string public description;\n', '    string public category;\n', '    string public version;\n', '}\n', '\n', 'contract ExchangeInterface is ComponentInterface {\n', '    /*\n', '     * @dev Checks if a trading pair is available\n', '     * For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n', '     * @param address _sourceAddress The token to sell for the destAddress.\n', '     * @param address _destAddress The token to buy with the source token.\n', "     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\n", '     * @return boolean whether or not the trading pair is supported by this exchange provider\n', '     */\n', '    function supportsTradingPair(address _srcAddress, address _destAddress, bytes32 _exchangeId)\n', '        external view returns(bool supported);\n', '\n', '    /*\n', '     * @dev Buy a single token with ETH.\n', '     * @param ERC20Extended _token The token to buy, should be an ERC20Extended address.\n', '     * @param uint _amount Amount of ETH used to buy this token. Make sure the value sent to this function is the same as the _amount.\n', '     * @param uint _minimumRate The minimum amount of tokens to receive for 1 ETH.\n', '     * @param address _depositAddress The address to send the bought tokens to.\n', "     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\n", '     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here.\n', '     * @return boolean whether or not the trade succeeded.\n', '     */\n', '    function buyToken\n', '        (\n', '        ERC20Extended _token, uint _amount, uint _minimumRate,\n', '        address _depositAddress, bytes32 _exchangeId, address _partnerId\n', '        ) external payable returns(bool success);\n', '\n', '    /*\n', '     * @dev Sell a single token for ETH. Make sure the token is approved beforehand.\n', '     * @param ERC20Extended _token The token to sell, should be an ERC20Extended address.\n', '     * @param uint _amount Amount of tokens to sell.\n', '     * @param uint _minimumRate The minimum amount of ETH to receive for 1 ERC20Extended token.\n', '     * @param address _depositAddress The address to send the bought tokens to.\n', "     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\n", '     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here\n', '     * @return boolean boolean whether or not the trade succeeded.\n', '     */\n', '    function sellToken\n', '        (\n', '        ERC20Extended _token, uint _amount, uint _minimumRate,\n', '        address _depositAddress, bytes32 _exchangeId, address _partnerId\n', '        ) external returns(bool success);\n', '}\n', '\n', 'contract KyberNetworkInterface {\n', '\n', '    function getExpectedRate(ERC20Extended src, ERC20Extended dest, uint srcQty)\n', '        external view returns (uint expectedRate, uint slippageRate);\n', '\n', '    function trade(\n', '        ERC20Extended source,\n', '        uint srcAmount,\n', '        ERC20Extended dest,\n', '        address destAddress,\n', '        uint maxDestAmount,\n', '        uint minConversionRate,\n', '        address walletId)\n', '        external payable returns(uint);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract OlympusExchangeAdapterInterface is Ownable {\n', '\n', '    function supportsTradingPair(address _srcAddress, address _destAddress)\n', '        external view returns(bool supported);\n', '\n', '    function getPrice(ERC20Extended _sourceAddress, ERC20Extended _destAddress, uint _amount)\n', '        external view returns(uint expectedRate, uint slippageRate);\n', '\n', '    function sellToken\n', '        (\n', '        ERC20Extended _token, uint _amount, uint _minimumRate,\n', '        address _depositAddress\n', '        ) external returns(bool success);\n', '\n', '    function buyToken\n', '        (\n', '        ERC20Extended _token, uint _amount, uint _minimumRate,\n', '        address _depositAddress\n', '        ) external payable returns(bool success);\n', '\n', '    function enable() external returns(bool);\n', '    function disable() external returns(bool);\n', '    function isEnabled() external view returns (bool success);\n', '\n', '    function setExchangeDetails(bytes32 _id, bytes32 _name) external returns(bool success);\n', '    function getExchangeDetails() external view returns(bytes32 _name, bool _enabled);\n', '\n', '}\n', '\n', 'contract OlympusExchangeAdapterManagerInterface is Ownable {\n', '    function pickExchange(ERC20Extended _token, uint _amount, uint _rate, bool _isBuying) public view returns (bytes32 exchangeId);\n', '    function supportsTradingPair(address _srcAddress, address _destAddress, bytes32 _exchangeId) external view returns(bool supported);\n', '    function getExchangeAdapter(bytes32 _exchangeId) external view returns(address);\n', '    function isValidAdapter(address _adapter) external view returns(bool);\n', '    function getPrice(ERC20Extended _sourceAddress, ERC20Extended _destAddress, uint _amount, bytes32 _exchangeId)\n', '        external view returns(uint expectedRate, uint slippageRate);\n', '}\n', '\n', 'contract ExchangeAdapterManager is OlympusExchangeAdapterManagerInterface {\n', '\n', '    mapping(bytes32 => OlympusExchangeAdapterInterface) public exchangeAdapters;\n', '    bytes32[] public exchanges;\n', '    uint private genExchangeId = 1000;\n', '    mapping(address=>uint) private adapters;\n', '    ERC20Extended private constant ETH_TOKEN_ADDRESS = ERC20Extended(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '\n', '\n', '    event AddedExchange(bytes32 id);\n', '\n', '    function addExchange(bytes32 _name, address _adapter)\n', '    external onlyOwner returns(bool) {\n', '        require(_adapter != 0x0);\n', '        bytes32 id = keccak256(abi.encodePacked(_adapter, genExchangeId++));\n', '        require(OlympusExchangeAdapterInterface(_adapter).setExchangeDetails(id, _name));\n', '        exchanges.push(id);\n', '        exchangeAdapters[id] = OlympusExchangeAdapterInterface(_adapter);\n', '        adapters[_adapter]++;\n', '\n', '        emit AddedExchange(id);\n', '        return true;\n', '    }\n', '\n', '    function getExchanges() external view returns(bytes32[]) {\n', '        return exchanges;\n', '    }\n', '\n', '    function getExchangeInfo(bytes32 _id)\n', '    external view returns(bytes32 name, bool status) {\n', '        OlympusExchangeAdapterInterface adapter = exchangeAdapters[_id];\n', '        require(address(adapter) != 0x0);\n', '\n', '        return adapter.getExchangeDetails();\n', '    }\n', '\n', '    function getExchangeAdapter(bytes32 _id)\n', '    external view returns(address)\n', '    {\n', '        return address(exchangeAdapters[_id]);\n', '    }\n', '\n', '    function getPrice(ERC20Extended _sourceAddress, ERC20Extended _destAddress, uint _amount, bytes32 _exchangeId)\n', '        external view returns(uint expectedRate, uint slippageRate) {\n', '\n', '        if(_exchangeId != 0x0) {\n', '            return exchangeAdapters[_exchangeId].getPrice(_sourceAddress, _destAddress, _amount);\n', '        }\n', '        bytes32 exchangeId = _sourceAddress == ETH_TOKEN_ADDRESS ?\n', '        pickExchange(_destAddress, _amount, 0, true) :\n', '        pickExchange(_sourceAddress, _amount, 0, false);\n', '        if(exchangeId != 0x0) {\n', '            OlympusExchangeAdapterInterface adapter = exchangeAdapters[exchangeId];\n', '            return adapter.getPrice(_sourceAddress, _destAddress, _amount);\n', '        }\n', '        return(0, 0);\n', '    }\n', '\n', '    /// >0  : found exchangeId\n', '    /// ==0 : not found\n', '    function pickExchange(ERC20Extended _token, uint _amount, uint _rate, bool _isBuying) public view returns (bytes32 exchangeId) {\n', '\n', '        int maxRate = -1;\n', '        for (uint i = 0; i < exchanges.length; i++) {\n', '\n', '            bytes32 id = exchanges[i];\n', '            OlympusExchangeAdapterInterface adapter = exchangeAdapters[id];\n', '            if (!adapter.isEnabled()) {\n', '                continue;\n', '            }\n', '            uint adapterResultRate;\n', '            uint adapterResultSlippage;\n', '            if (_isBuying){\n', '                (adapterResultRate,adapterResultSlippage) = adapter.getPrice(ETH_TOKEN_ADDRESS, _token, _amount);\n', '            } else {\n', '                (adapterResultRate,adapterResultSlippage) = adapter.getPrice(_token, ETH_TOKEN_ADDRESS, _amount);\n', '            }\n', '            int resultRate = int(adapterResultSlippage);\n', '\n', '\n', '            if (adapterResultRate == 0) { // not support\n', '                continue;\n', '            }\n', '\n', '            if (resultRate < int(_rate)) {\n', '                continue;\n', '            }\n', '\n', '            if (resultRate >= maxRate) {\n', '                maxRate = resultRate;\n', '                return id;\n', '            }\n', '        }\n', '        return 0x0;\n', '    }\n', '\n', '    function supportsTradingPair(address _srcAddress, address _destAddress, bytes32 _exchangeId) external view returns (bool) {\n', '        OlympusExchangeAdapterInterface adapter;\n', '        if(_exchangeId != ""){\n', '            adapter = exchangeAdapters[id];\n', '            if(!adapter.isEnabled()){\n', '                return false;\n', '            }\n', '            if (adapter.supportsTradingPair(_srcAddress, _destAddress)) {\n', '                return true;\n', '            }\n', '            return false;\n', '        }\n', '        for (uint i = 0; i < exchanges.length; i++) {\n', '            bytes32 id = exchanges[i];\n', '            adapter = exchangeAdapters[id];\n', '            if (!adapter.isEnabled()) {\n', '                continue;\n', '            }\n', '            if (adapter.supportsTradingPair(_srcAddress, _destAddress)) {\n', '                return true;\n', '            }\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function isValidAdapter(address _adapter) external view returns (bool) {\n', '        return adapters[_adapter] > 0;\n', '    }\n', '}']
