['pragma solidity ^0.4.24;\n', '\n', 'contract Fog {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed owner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  event Winner(address indexed to, uint indexed value);\n', '  event CupCake(address indexed to, uint indexed value);\n', '  event Looser(address indexed from, uint indexed value);\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function move(uint256 direction) public payable {\n', '    require(tx.origin == msg.sender);\n', '\n', '    uint doubleValue = mul(msg.value, 2);\n', '    uint minValue = 10000000000000000; // 0.01 Ether\n', '\n', '    // Check for minValue and make sure we have enough balance\n', '    require(msg.value >= minValue && doubleValue <= address(this).balance);\n', '\n', '    // Roll biased towards direction\n', '    uint dice = uint(keccak256(abi.encodePacked(now + uint(msg.sender) + direction))) % 3;\n', '\n', '    // Winner\n', '    if (dice == 2) {\n', '      msg.sender.transfer(doubleValue);\n', '      emit Winner(msg.sender, doubleValue);\n', '\n', '    // Looser\n', '    } else {\n', '      // Coin biased towards direction\n', '      uint coin = uint(keccak256(abi.encodePacked(now + uint(msg.sender) + direction))) % 2;\n', '\n', '      // CupCake\n', '      if (coin == 1) {\n', '        // Woa! Refund 80%\n', '        uint eightyPercent = div(mul(msg.value, 80), 100);\n', '\n', '        msg.sender.transfer(eightyPercent);\n', '        emit CupCake(msg.sender, eightyPercent);\n', '\n', '      // Looser\n', '      } else {\n', '        emit Looser(msg.sender, msg.value);\n', '      }\n', '    }\n', '  }\n', '\n', '  function drain(uint value) public onlyOwner {\n', '    require(value > 0 && value < address(this).balance);\n', '    owner.transfer(value);\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function() public payable { }\n', '\n', '  /**\n', '   * @dev Multiplies two numbers, reverts on overflow.\n', '   */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '   */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '}']