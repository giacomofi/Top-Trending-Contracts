['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Whitelist\n', ' * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n', ' * @dev This simplifies the implementation of "user permissions".\n', ' */\n', 'contract Whitelist is Ownable {\n', '  mapping(address => bool) public whitelist;\n', '\n', '  event WhitelistedAddressAdded(address addr);\n', '  event WhitelistedAddressRemoved(address addr);\n', '\n', '  /**\n', '   * @dev Throws if called by any account that&#39;s not whitelisted.\n', '   */\n', '  modifier onlyWhitelisted() {\n', '    require(whitelist[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param addr address\n', '   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '   */\n', '  function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n', '    if (!whitelist[addr]) {\n', '      whitelist[addr] = true;\n', '      emit WhitelistedAddressAdded(addr);\n', '      success = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev add addresses to the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was added to the whitelist,\n', '   * false if all addresses were already in the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      if (addAddressToWhitelist(addrs[i])) {\n', '        success = true;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param addr address\n', '   * @return true if the address was removed from the whitelist,\n', '   * false if the address wasn&#39;t in the whitelist in the first place\n', '   */\n', '  function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n', '    if (whitelist[addr]) {\n', '      whitelist[addr] = false;\n', '      emit WhitelistedAddressRemoved(addr);\n', '      success = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove addresses from the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was removed from the whitelist,\n', '   * false if all addresses weren&#39;t in the whitelist in the first place\n', '   */\n', '  function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      if (removeAddressFromWhitelist(addrs[i])) {\n', '        success = true;\n', '      }\n', '    }\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract TTTToken is ERC20, Ownable {\n', '\tusing SafeMath for uint;\n', '\n', '\tstring public constant name = "The Tip Token";\n', '\tstring public constant symbol = "TTT";\n', '\n', '\tuint8 public decimals = 18;\n', '\n', '\tmapping(address=>uint256) balances;\n', '\tmapping(address=>mapping(address=>uint256)) allowed;\n', '\n', '\t// Supply variables\n', '\tuint256 public totalSupply_;\n', '\tuint256 public presaleSupply;\n', '\tuint256 public crowdsaleSupply;\n', '\tuint256 public privatesaleSupply;\n', '\tuint256 public airdropSupply;\n', '\tuint256 public teamSupply;\n', '\tuint256 public ecoSupply;\n', '\n', '\t// Vest variables\n', '\tuint256 public firstVestStartsAt;\n', '\tuint256 public secondVestStartsAt;\n', '\tuint256 public firstVestAmount;\n', '\tuint256 public secondVestAmount;\n', '\tuint256 public currentVestedAmount;\n', '\n', '\tuint256 public crowdsaleBurnAmount;\n', '\n', '\t// Token sale addresses\n', '\taddress public privatesaleAddress;\n', '\taddress public presaleAddress;\n', '\taddress public crowdsaleAddress;\n', '\taddress public teamSupplyAddress;\n', '\taddress public ecoSupplyAddress;\n', '\taddress public crowdsaleAirdropAddress;\n', '\taddress public crowdsaleBurnAddress;\n', '\taddress public tokenSaleAddress;\n', '\n', '\t// Token sale state variables\n', '\tbool public privatesaleFinalized;\n', '\tbool public presaleFinalized;\n', '\tbool public crowdsaleFinalized;\n', '\n', '\tevent PrivatesaleFinalized(uint tokensRemaining);\n', '\tevent PresaleFinalized(uint tokensRemaining);\n', '\tevent CrowdsaleFinalized(uint tokensRemaining);\n', '\tevent Burn(address indexed burner, uint256 value);\n', '\tevent TokensaleAddressSet(address tSeller, address from);\n', '\n', '\tmodifier onlyTokenSale() {\n', '\t\trequire(msg.sender == tokenSaleAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier canItoSend() {\n', '\t\trequire(crowdsaleFinalized == true || (crowdsaleFinalized == false && msg.sender == ecoSupplyAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction TTTToken() {\n', '\t\t// 600 million total supply divided into\n', '\t\t//\t\t90 million to privatesale address\n', '\t\t//\t\t120 million to presale address\n', '\t\t//\t\t180 million to crowdsale address\n', '\t\t//\t\t90 million to eco supply address\n', '\t\t//\t\t120 million to team supply address\n', '\t\ttotalSupply_ = 600000000 * 10**uint(decimals);\n', '\t\tprivatesaleSupply = 90000000 * 10**uint(decimals);\n', '\t\tpresaleSupply = 120000000 * 10**uint(decimals);\n', '\t\tcrowdsaleSupply = 180000000 * 10**uint(decimals);\n', '\t\tecoSupply = 90000000 * 10**uint(decimals);\n', '\t\tteamSupply = 120000000 * 10**uint(decimals);\n', '\n', '\t\tfirstVestAmount = teamSupply.div(2);\n', '\t\tsecondVestAmount = firstVestAmount;\n', '\t\tcurrentVestedAmount = 0;\n', '\n', '\t\tprivatesaleAddress = 0xE67EE1935bf160B48BA331074bb743630ee8aAea;\n', '\t\tpresaleAddress = 0x4A41D67748D16aEB12708E88270d342751223870;\n', '\t\tcrowdsaleAddress = 0x2eDf855e5A90DF003a5c1039bEcf4a721C9c3f9b;\n', '\t\tteamSupplyAddress = 0xc4146EcE2645038fbccf79784a6DcbE3C6586c03;\n', '\t\tecoSupplyAddress = 0xdBA99B92a18930dA39d1e4B52177f84a0C27C8eE;\n', '\t\tcrowdsaleAirdropAddress = 0x6BCb947a8e8E895d1258C1b2fc84A5d22632E6Fa;\n', '\t\tcrowdsaleBurnAddress = 0xDF1CAf03FA89AfccdAbDd55bAF5C9C4b9b1ceBaB;\n', '\n', '\t\taddToBalance(privatesaleAddress, privatesaleSupply);\n', '\t\taddToBalance(presaleAddress, presaleSupply);\n', '\t\taddToBalance(crowdsaleAddress, crowdsaleSupply);\n', '\t\taddToBalance(teamSupplyAddress, teamSupply);\n', '\t\taddToBalance(ecoSupplyAddress, ecoSupply);\n', '\n', '\t\t// 12/01/2018 @ 12:00am (UTC)\n', '\t\tfirstVestStartsAt = 1543622400;\n', '\t\t// 06/01/2019 @ 12:00am (UTC)\n', '\t\tsecondVestStartsAt = 1559347200;\n', '\t}\n', '\n', '\t// Transfer\n', '\tfunction transfer(address _to, uint256 _amount) public canItoSend returns (bool success) {\n', '\t\trequire(balanceOf(msg.sender) >= _amount);\n', '\t\taddToBalance(_to, _amount);\n', '\t\tdecrementBalance(msg.sender, _amount);\n', '\t\tTransfer(msg.sender, _to, _amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Transfer from one address to another\n', '\tfunction transferFrom(address _from, address _to, uint256 _amount) public canItoSend returns (bool success) {\n', '\t\trequire(allowance(_from, msg.sender) >= _amount);\n', '\t\tdecrementBalance(_from, _amount);\n', '\t\taddToBalance(_to, _amount);\n', '\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '\t\tTransfer(_from, _to, _amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Function for token sell contract to call on transfers\n', '\tfunction transferFromTokenSell(address _to, address _from, uint256 _amount) external onlyTokenSale returns (bool success) {\n', '\t\trequire(_amount > 0);\n', '\t\trequire(_to != 0x0);\n', '\t\trequire(balanceOf(_from) >= _amount);\n', '\t\tdecrementBalance(_from, _amount);\n', '\t\taddToBalance(_to, _amount);\n', '\t\tTransfer(_from, _to, _amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Approve another address a certain amount of TTT\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\n', '\t\trequire((_value == 0) || (allowance(msg.sender, _spender) == 0));\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\tApproval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Get an address&#39;s TTT allowance\n', '\tfunction allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '\t// Get TTT balance of an address\n', '\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '\n', '\t// Return total supply\n', '\tfunction totalSupply() public view returns (uint256 totalSupply) {\n', '\t\treturn totalSupply_;\n', '\t}\n', '\n', '\t// Set the tokenSell contract address, can only be set once\n', '\tfunction setTokenSaleAddress(address _tokenSaleAddress) external onlyOwner {\n', '\t\trequire(tokenSaleAddress == 0x0);\n', '\t\ttokenSaleAddress = _tokenSaleAddress;\n', '\t\tTokensaleAddressSet(tokenSaleAddress, msg.sender);\n', '\t}\n', '\n', '\t// Finalize private. If there are leftover TTT, overflow to presale\n', '\tfunction finalizePrivatesale() external onlyTokenSale returns (bool success) {\n', '\t\trequire(privatesaleFinalized == false);\n', '\t\tuint256 amount = balanceOf(privatesaleAddress);\n', '\t\tif (amount != 0) {\n', '\t\t\taddToBalance(presaleAddress, amount);\n', '\t\t\tdecrementBalance(privatesaleAddress, amount);\n', '\t\t}\n', '\t\tprivatesaleFinalized = true;\n', '\t\tPrivatesaleFinalized(amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Finalize presale. If there are leftover TTT, overflow to crowdsale\n', '\tfunction finalizePresale() external onlyTokenSale returns (bool success) {\n', '\t\trequire(presaleFinalized == false && privatesaleFinalized == true);\n', '\t\tuint256 amount = balanceOf(presaleAddress);\n', '\t\tif (amount != 0) {\n', '\t\t\taddToBalance(crowdsaleAddress, amount);\n', '\t\t\tdecrementBalance(presaleAddress, amount);\n', '\t\t}\n', '\t\tpresaleFinalized = true;\n', '\t\tPresaleFinalized(amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Finalize crowdsale. If there are leftover TTT, add 10% to airdrop, 20% to ecosupply, burn 70% at a later date\n', '\tfunction finalizeCrowdsale(uint256 _burnAmount, uint256 _ecoAmount, uint256 _airdropAmount) external onlyTokenSale returns(bool success) {\n', '\t\trequire(presaleFinalized == true && crowdsaleFinalized == false);\n', '\t\tuint256 amount = balanceOf(crowdsaleAddress);\n', '\t\tassert((_burnAmount.add(_ecoAmount).add(_airdropAmount)) == amount);\n', '\t\tif (amount > 0) {\n', '\t\t\tcrowdsaleBurnAmount = _burnAmount;\n', '\t\t\taddToBalance(ecoSupplyAddress, _ecoAmount);\n', '\t\t\taddToBalance(crowdsaleBurnAddress, crowdsaleBurnAmount);\n', '\t\t\taddToBalance(crowdsaleAirdropAddress, _airdropAmount);\n', '\t\t\tdecrementBalance(crowdsaleAddress, amount);\n', '\t\t\tassert(balanceOf(crowdsaleAddress) == 0);\n', '\t\t}\n', '\t\tcrowdsaleFinalized = true;\n', '\t\tCrowdsaleFinalized(amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Burns a specific amount of tokens. * added onlyOwner, as this will only happen from owner, if there are crowdsale leftovers\n', '\t* @param _value The amount of token to be burned.\n', '\t* @dev imported from https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/BurnableToken.sol\n', '\t*/\n', '\tfunction burn(uint256 _value) public onlyOwner {\n', '\t\trequire(_value <= balances[msg.sender]);\n', '\t\trequire(crowdsaleFinalized == true);\n', '\t\t// no need to require value <= totalSupply, since that would imply the\n', '\t\t// sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '\t\taddress burner = msg.sender;\n', '\t\tbalances[burner] = balances[burner].sub(_value);\n', '\t\ttotalSupply_ = totalSupply_.sub(_value);\n', '\t\tBurn(burner, _value);\n', '\t\tTransfer(burner, address(0), _value);\n', '\t}\n', '\n', '\t// Transfer tokens from the vested address. 50% available 12/01/2018, the rest available 06/01/2019\n', '\tfunction transferFromVest(uint256 _amount) public onlyOwner {\n', '\t\trequire(block.timestamp > firstVestStartsAt);\n', '\t\trequire(crowdsaleFinalized == true);\n', '\t\trequire(_amount > 0);\n', '\t\tif(block.timestamp > secondVestStartsAt) {\n', '\t\t\t// all tokens available for vest withdrawl\n', '\t\t\trequire(_amount <= teamSupply);\n', '\t\t\trequire(_amount <= balanceOf(teamSupplyAddress));\n', '\t\t} else {\n', '\t\t\t// only first vest available\n', '\t\t\trequire(_amount <= (firstVestAmount - currentVestedAmount));\n', '\t\t\trequire(_amount <= balanceOf(teamSupplyAddress));\n', '\t\t}\n', '\t\tcurrentVestedAmount = currentVestedAmount.add(_amount);\n', '\t\taddToBalance(msg.sender, _amount);\n', '\t\tdecrementBalance(teamSupplyAddress, _amount);\n', '\t\tTransfer(teamSupplyAddress, msg.sender, _amount);\n', '\t}\n', '\n', '\t// Add to balance\n', '\tfunction addToBalance(address _address, uint _amount) internal {\n', '\t\tbalances[_address] = balances[_address].add(_amount);\n', '\t}\n', '\n', '\t// Remove from balance\n', '\tfunction decrementBalance(address _address, uint _amount) internal {\n', '\t\tbalances[_address] = balances[_address].sub(_amount);\n', '\t}\n', '\n', '}\n', '\n', 'contract TTTTokenSell is Whitelist, Pausable {\n', '\tusing SafeMath for uint;\n', '\n', '\tuint public decimals = 18;\n', '\n', '\t// TTTToken contract address\n', '\taddress public tokenAddress;\n', '\taddress public wallet;\n', '\t// Wallets for each phase - hardcap of each is balanceOf\n', '\taddress public privatesaleAddress;\n', '\taddress public presaleAddress;\n', '\taddress public crowdsaleAddress;\n', '\n', '\t// Amount of wei currently raised\n', '\tuint256 public weiRaised;\n', '\n', '\t// Variables for phase start/end\n', '\tuint256 public startsAt;\n', '\tuint256 public endsAt;\n', '\n', '\t// minimum and maximum\n', '\tuint256 public ethMin;\n', '\tuint256 public ethMax;\n', '\n', '\tenum CurrentPhase { Privatesale, Presale, Crowdsale, None }\n', '\n', '\tCurrentPhase public currentPhase;\n', '\tuint public currentPhaseRate;\n', '\taddress public currentPhaseAddress;\n', '\n', '\tTTTToken public token;\n', '\n', '\tevent AmountRaised(address beneficiary, uint amountRaised);\n', '\tevent TokenPurchased(address indexed purchaser, uint256 value, uint256 wieAmount);\n', '\tevent TokenPhaseStarted(CurrentPhase phase, uint256 startsAt, uint256 endsAt);\n', '\tevent TokenPhaseEnded(CurrentPhase phase);\n', '\n', '\tmodifier tokenPhaseIsActive() {\n', '\t\tassert(now >= startsAt && now <= endsAt);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction TTTTokenSell() {\n', '\t\twallet = 0xE6CB27F5fA75e0B75422c9B8A8da8697C9631cC6;\n', '\n', '\t\tprivatesaleAddress = 0xE67EE1935bf160B48BA331074bb743630ee8aAea;\n', '\t\tpresaleAddress = 0x4A41D67748D16aEB12708E88270d342751223870;\n', '\t\tcrowdsaleAddress = 0x2eDf855e5A90DF003a5c1039bEcf4a721C9c3f9b;\n', '\n', '\t\tcurrentPhase = CurrentPhase.None;\n', '\t\tcurrentPhaseAddress = privatesaleAddress;\n', '\t\tstartsAt = 0;\n', '\t\tendsAt = 0;\n', '\t\tethMin = 0;\n', '\t\tethMax = numToWei(1000, decimals);\n', '\t}\n', '\n', '\tfunction setTokenAddress(address _tokenAddress) external onlyOwner {\n', '\t\trequire(tokenAddress == 0x0);\n', '\t\ttokenAddress = _tokenAddress;\n', '\t\ttoken = TTTToken(tokenAddress);\n', '\t}\n', '\n', '\tfunction startPhase(uint _phase, uint _currentPhaseRate, uint256 _startsAt, uint256 _endsAt) external onlyOwner {\n', '\t\trequire(_phase >= 0 && _phase <= 2);\n', '\t\trequire(_startsAt > endsAt && _endsAt > _startsAt);\n', '\t\trequire(_currentPhaseRate > 0);\n', '\t\tcurrentPhase = CurrentPhase(_phase);\n', '\t\tcurrentPhaseAddress = getPhaseAddress();\n', '\t\tassert(currentPhaseAddress != 0x0);\n', '\t\tcurrentPhaseRate = _currentPhaseRate;\n', '\t\tif(currentPhase == CurrentPhase.Privatesale) ethMin = numToWei(10, decimals);\n', '\t\telse {\n', '\t\t\tethMin = 0;\n', '\t\t\tethMax = numToWei(15, decimals);\n', '\t\t}\n', '\t\tstartsAt = _startsAt;\n', '\t\tendsAt = _endsAt;\n', '\t\tTokenPhaseStarted(currentPhase, startsAt, endsAt);\n', '\t}\n', '\n', '\tfunction buyTokens(address _to) tokenPhaseIsActive whenNotPaused payable {\n', '\t\trequire(whitelist[_to]);\n', '\t\trequire(msg.value >= ethMin && msg.value <= ethMax);\n', '\t\trequire(_to != 0x0);\n', '\t\tuint256 weiAmount = msg.value;\n', '\t\tuint256 tokens = weiAmount.mul(currentPhaseRate);\n', '\t\t// 100% bonus for privatesale\n', '\t\tif(currentPhase == CurrentPhase.Privatesale) tokens = tokens.add(tokens);\n', '\t\tweiRaised = weiRaised.add(weiAmount);\n', '\t\twallet.transfer(weiAmount);\n', '\t\tif(!token.transferFromTokenSell(_to, currentPhaseAddress, tokens)) revert();\n', '\t\tTokenPurchased(_to, tokens, weiAmount);\n', '\t}\n', '\n', '\t// To contribute, send a value transaction to the token sell Address.\n', '\t// Please include at least 100 000 gas.\n', '\tfunction () payable {\n', '\t\tbuyTokens(msg.sender);\n', '\t}\n', '\n', '\tfunction finalizePhase() external onlyOwner {\n', '\t\tif(currentPhase == CurrentPhase.Privatesale) token.finalizePrivatesale();\n', '\t\telse if(currentPhase == CurrentPhase.Presale) token.finalizePresale();\n', '\t\tendsAt = block.timestamp;\n', '\t\tcurrentPhase = CurrentPhase.None;\n', '\t\tTokenPhaseEnded(currentPhase);\n', '\t}\n', '\n', '\tfunction finalizeIto(uint256 _burnAmount, uint256 _ecoAmount, uint256 _airdropAmount) external onlyOwner {\n', '\t\ttoken.finalizeCrowdsale(numToWei(_burnAmount, decimals), numToWei(_ecoAmount, decimals), numToWei(_airdropAmount, decimals));\n', '\t\tendsAt = block.timestamp;\n', '\t\tcurrentPhase = CurrentPhase.None;\n', '\t\tTokenPhaseEnded(currentPhase);\n', '\t}\n', '\n', '\tfunction getPhaseAddress() internal view returns (address phase) {\n', '\t\tif(currentPhase == CurrentPhase.Privatesale) return privatesaleAddress;\n', '\t\telse if(currentPhase == CurrentPhase.Presale) return presaleAddress;\n', '\t\telse if(currentPhase == CurrentPhase.Crowdsale) return crowdsaleAddress;\n', '\t\treturn 0x0;\n', '\t}\n', '\n', '\tfunction numToWei(uint256 _num, uint _decimals) internal pure returns (uint256 w) {\n', '\t\treturn _num.mul(10**_decimals);\n', '\t}\n', '}']