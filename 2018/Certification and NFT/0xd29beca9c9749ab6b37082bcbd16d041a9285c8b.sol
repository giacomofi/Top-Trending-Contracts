['/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', 'pragma solidity 0.4.21;\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="98fcf9f6f1fdf4d8f4f7f7e8eaf1f6ffb6f7eaff">[email&#160;protected]</a>>\n', 'library MathUint {\n', '    function mul(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function sub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function tolerantSub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        return (a >= b) ? a - b : 0;\n', '    }\n', '    /// @dev calculate the square of Coefficient of Variation (CV)\n', '    /// https://en.wikipedia.org/wiki/Coefficient_of_variation\n', '    function cvsquare(\n', '        uint[] arr,\n', '        uint scale\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        uint len = arr.length;\n', '        require(len > 1);\n', '        require(scale > 0);\n', '        uint avg = 0;\n', '        for (uint i = 0; i < len; i++) {\n', '            avg = add(avg, arr[i]);\n', '        }\n', '        avg = avg / len;\n', '        if (avg == 0) {\n', '            return 0;\n', '        }\n', '        uint cvs = 0;\n', '        uint s;\n', '        uint item;\n', '        for (i = 0; i < len; i++) {\n', '            item = arr[i];\n', '            s = item > avg ? item - avg : avg - item;\n', '            cvs = add(cvs, mul(s, s));\n', '        }\n', '        return ((mul(mul(cvs, scale), scale) / avg) / avg) / (len - 1);\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Utility Functions for address\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4d292c232428210d2122223d3f24232a63223f2a">[email&#160;protected]</a>>\n', 'library AddressUtil {\n', '    function isContract(\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (addr == 0x0) {\n', '            return false;\n', '        } else {\n', '            uint size;\n', '            assembly { size := extcodesize(addr) }\n', '            return size > 0;\n', '        }\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5236333c3b373e123e3d3d22203b3c357c3d2035">[email&#160;protected]</a>>\n', 'contract ERC20 {\n', '    function balanceOf(\n', '        address who\n', '        )\n', '        view\n', '        public\n', '        returns (uint256);\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '        )\n', '        view\n', '        public\n', '        returns (uint256);\n', '    function transfer(\n', '        address to,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '    function approve(\n', '        address spender,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Loopring Token Exchange Protocol Contract Interface\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4c282d222529200c2023233c3e25222b62233e2b">[email&#160;protected]</a>>\n', '/// @author Kongliang Zhong - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="fd9692939a91949c939abd9192928d8f94939ad3928f9a">[email&#160;protected]</a>>\n', 'contract LoopringProtocol {\n', '    uint8   public constant MARGIN_SPLIT_PERCENTAGE_BASE = 100;\n', '    /// @dev Event to emit if a ring is successfully mined.\n', '    /// _amountsList is an array of:\n', '    /// [_amountS, _amountB, _lrcReward, _lrcFee, splitS, splitB].\n', '    event RingMined(\n', '        uint            _ringIndex,\n', '        bytes32 indexed _ringHash,\n', '        address         _miner,\n', '        bytes32[]       _orderInfoList\n', '    );\n', '    event OrderCancelled(\n', '        bytes32 indexed _orderHash,\n', '        uint            _amountCancelled\n', '    );\n', '    event AllOrdersCancelled(\n', '        address indexed _address,\n', '        uint            _cutoff\n', '    );\n', '    event OrdersCancelled(\n', '        address indexed _address,\n', '        address         _token1,\n', '        address         _token2,\n', '        uint            _cutoff\n', '    );\n', '    /// @dev Cancel a order. cancel amount(amountS or amountB) can be specified\n', '    ///      in orderValues.\n', '    /// @param addresses          owner, tokenS, tokenB, wallet, authAddr\n', '    /// @param orderValues        amountS, amountB, validSince (second),\n', '    ///                           validUntil (second), lrcFee, and cancelAmount.\n', '    /// @param buyNoMoreThanAmountB -\n', '    ///                           This indicates when a order should be considered\n', '    ///                           as &#39;completely filled&#39;.\n', '    /// @param marginSplitPercentage -\n', '    ///                           Percentage of margin split to share with miner.\n', '    /// @param v                  Order ECDSA signature parameter v.\n', '    /// @param r                  Order ECDSA signature parameters r.\n', '    /// @param s                  Order ECDSA signature parameters s.\n', '    function cancelOrder(\n', '        address[5] addresses,\n', '        uint[6]    orderValues,\n', '        bool       buyNoMoreThanAmountB,\n', '        uint8      marginSplitPercentage,\n', '        uint8      v,\n', '        bytes32    r,\n', '        bytes32    s\n', '        )\n', '        external;\n', '    /// @dev   Set a cutoff timestamp to invalidate all orders whose timestamp\n', '    ///        is smaller than or equal to the new value of the address&#39;s cutoff\n', '    ///        timestamp, for a specific trading pair.\n', '    /// @param cutoff The cutoff timestamp, will default to `block.timestamp`\n', '    ///        if it is 0.\n', '    function cancelAllOrdersByTradingPair(\n', '        address token1,\n', '        address token2,\n', '        uint cutoff\n', '        )\n', '        external;\n', '    /// @dev   Set a cutoff timestamp to invalidate all orders whose timestamp\n', '    ///        is smaller than or equal to the new value of the address&#39;s cutoff\n', '    ///        timestamp.\n', '    /// @param cutoff The cutoff timestamp, will default to `block.timestamp`\n', '    ///        if it is 0.\n', '    function cancelAllOrders(\n', '        uint cutoff\n', '        )\n', '        external;\n', '    /// @dev Submit a order-ring for validation and settlement.\n', '    /// @param addressList  List of each order&#39;s owner, tokenS, wallet, authAddr.\n', '    ///                     Note that next order&#39;s `tokenS` equals this order&#39;s\n', '    ///                     `tokenB`.\n', '    /// @param uintArgsList List of uint-type arguments in this order:\n', '    ///                     amountS, amountB, validSince (second),\n', '    ///                     validUntil (second), lrcFee, and rateAmountS.\n', '    /// @param uint8ArgsList -\n', '    ///                     List of unit8-type arguments, in this order:\n', '    ///                     marginSplitPercentageList.\n', '    /// @param buyNoMoreThanAmountBList -\n', '    ///                     This indicates when a order should be considered\n', '    /// @param vList        List of v for each order. This list is 1-larger than\n', '    ///                     the previous lists, with the last element being the\n', '    ///                     v value of the ring signature.\n', '    /// @param rList        List of r for each order. This list is 1-larger than\n', '    ///                     the previous lists, with the last element being the\n', '    ///                     r value of the ring signature.\n', '    /// @param sList        List of s for each order. This list is 1-larger than\n', '    ///                     the previous lists, with the last element being the\n', '    ///                     s value of the ring signature.\n', '    /// @param miner        Miner address.\n', '    /// @param feeSelections -\n', '    ///                     Bits to indicate fee selections. `1` represents margin\n', '    ///                     split and `0` represents LRC as fee.\n', '    function submitRing(\n', '        address[4][]    addressList,\n', '        uint[6][]       uintArgsList,\n', '        uint8[1][]      uint8ArgsList,\n', '        bool[]          buyNoMoreThanAmountBList,\n', '        uint8[]         vList,\n', '        bytes32[]       rList,\n', '        bytes32[]       sList,\n', '        address         miner,\n', '        uint16          feeSelections\n', '        )\n', '        public;\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Token Register Contract\n', '/// @dev This contract maintains a list of tokens the Protocol supports.\n', '/// @author Kongliang Zhong - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b8d3d7d6dfd4d1d9d6dff8d4d7d7c8cad1d6df96d7cadf">[email&#160;protected]</a>>,\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c0a4a1aea9a5ac80acafafb0b2a9aea7eeafb2a7">[email&#160;protected]</a>>.\n', 'contract TokenRegistry {\n', '    event TokenRegistered(\n', '        address indexed addr,\n', '        string          symbol\n', '    );\n', '    event TokenUnregistered(\n', '        address indexed addr,\n', '        string          symbol\n', '    );\n', '    function registerToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external;\n', '    function registerMintedToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external;\n', '    function unregisterToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external;\n', '    function areAllTokensRegistered(\n', '        address[] addressList\n', '        )\n', '        external\n', '        view\n', '        returns (bool);\n', '    function getAddressBySymbol(\n', '        string symbol\n', '        )\n', '        external\n', '        view\n', '        returns (address);\n', '    function isTokenRegisteredBySymbol(\n', '        string symbol\n', '        )\n', '        public\n', '        view\n', '        returns (bool);\n', '    function isTokenRegistered(\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool);\n', '    function getTokens(\n', '        uint start,\n', '        uint count\n', '        )\n', '        public\n', '        view\n', '        returns (address[] addressList);\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title TokenTransferDelegate\n', '/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different\n', '/// versions of Loopring protocol to avoid ERC20 re-authorization.\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7410151a1d111834181b1b04061d1a135a1b0613">[email&#160;protected]</a>>.\n', 'contract TokenTransferDelegate {\n', '    event AddressAuthorized(\n', '        address indexed addr,\n', '        uint32          number\n', '    );\n', '    event AddressDeauthorized(\n', '        address indexed addr,\n', '        uint32          number\n', '    );\n', '    // The following map is used to keep trace of order fill and cancellation\n', '    // history.\n', '    mapping (bytes32 => uint) public cancelledOrFilled;\n', '    // This map is used to keep trace of order&#39;s cancellation history.\n', '    mapping (bytes32 => uint) public cancelled;\n', '    // A map from address to its cutoff timestamp.\n', '    mapping (address => uint) public cutoffs;\n', '    // A map from address to its trading-pair cutoff timestamp.\n', '    mapping (address => mapping (bytes20 => uint)) public tradingPairCutoffs;\n', '    /// @dev Add a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function authorizeAddress(\n', '        address addr\n', '        )\n', '        external;\n', '    /// @dev Remove a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function deauthorizeAddress(\n', '        address addr\n', '        )\n', '        external;\n', '    function getLatestAuthorizedAddresses(\n', '        uint max\n', '        )\n', '        external\n', '        view\n', '        returns (address[] addresses);\n', '    /// @dev Invoke ERC20 transferFrom method.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    function transferToken(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        external;\n', '    function batchTransferToken(\n', '        address lrcTokenAddress,\n', '        address minerFeeRecipient,\n', '        uint8 walletSplitPercentage,\n', '        bytes32[] batch\n', '        )\n', '        external;\n', '    function isAddressAuthorized(\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool);\n', '    function addCancelled(bytes32 orderHash, uint cancelAmount)\n', '        external;\n', '    function addCancelledOrFilled(bytes32 orderHash, uint cancelOrFillAmount)\n', '        public;\n', '    function batchAddCancelledOrFilled(bytes32[] batch)\n', '        public;\n', '    function setCutoffs(uint t)\n', '        external;\n', '    function setTradingPairCutoffs(bytes20 tokenPair, uint t)\n', '        external;\n', '    function checkCutoffsBatch(address[] owners, bytes20[] tradingPairs, uint[] validSince)\n', '        external\n', '        view;\n', '    function suspend() external;\n', '    function resume() external;\n', '    function kill() external;\n', '}\n', '/// @title An Implementation of LoopringProtocol.\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1d797c737478715d7172726d6f74737a33726f7a">[email&#160;protected]</a>>,\n', '/// @author Kongliang Zhong - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="761d1918111a1f171811361a191906041f181158190411">[email&#160;protected]</a>>\n', '///\n', '/// Recognized contributing developers from the community:\n', '///     https://github.com/Brechtpd\n', '///     https://github.com/rainydio\n', '///     https://github.com/BenjaminPrice\n', '///     https://github.com/jonasshen\n', '///     https://github.com/Hephyrius\n', 'contract LoopringProtocolImpl is LoopringProtocol {\n', '    using AddressUtil   for address;\n', '    using MathUint      for uint;\n', '    address public constant lrcTokenAddress             = 0xEF68e7C694F40c8202821eDF525dE3782458639f;\n', '    address public constant tokenRegistryAddress        = 0x004DeF62C71992615CF22786d0b7Efb22850Df4a;\n', '    address public constant delegateAddress             = 0xD22f97BCEc8E029e109412763b889fC16C4bca8B;\n', '    uint64  public  ringIndex                   = 0;\n', '    uint8   public constant walletSplitPercentage       = 20;\n', '    // Exchange rate (rate) is the amount to sell or sold divided by the amount\n', '    // to buy or bought.\n', '    //\n', '    // Rate ratio is the ratio between executed rate and an order&#39;s original\n', '    // rate.\n', '    //\n', '    // To require all orders&#39; rate ratios to have coefficient ofvariation (CV)\n', '    // smaller than 2.5%, for an example , rateRatioCVSThreshold should be:\n', '    //     `(0.025 * RATE_RATIO_SCALE)^2` or 62500.\n', '    uint    public constant rateRatioCVSThreshold        = 62500;\n', '    uint    public constant MAX_RING_SIZE       = 16;\n', '    uint    public constant RATE_RATIO_SCALE    = 10000;\n', '    /// @param orderHash    The order&#39;s hash\n', '    /// @param feeSelection -\n', '    ///                     A miner-supplied value indicating if LRC (value = 0)\n', '    ///                     or margin split is choosen by the miner (value = 1).\n', '    ///                     We may support more fee model in the future.\n', '    /// @param rateS        Sell Exchange rate provided by miner.\n', '    /// @param rateB        Buy Exchange rate provided by miner.\n', '    /// @param fillAmountS  Amount of tokenS to sell, calculated by protocol.\n', '    /// @param lrcReward    The amount of LRC paid by miner to order owner in\n', '    ///                     exchange for margin split.\n', '    /// @param lrcFeeState  The amount of LR paid by order owner to miner.\n', '    /// @param splitS      TokenS paid to miner.\n', '    /// @param splitB      TokenB paid to miner.\n', '    struct OrderState {\n', '        address owner;\n', '        address tokenS;\n', '        address tokenB;\n', '        address wallet;\n', '        address authAddr;\n', '        uint    validSince;\n', '        uint    validUntil;\n', '        uint    amountS;\n', '        uint    amountB;\n', '        uint    lrcFee;\n', '        bool    buyNoMoreThanAmountB;\n', '        bool    marginSplitAsFee;\n', '        bytes32 orderHash;\n', '        uint8   marginSplitPercentage;\n', '        uint    rateS;\n', '        uint    rateB;\n', '        uint    fillAmountS;\n', '        uint    lrcReward;\n', '        uint    lrcFeeState;\n', '        uint    splitS;\n', '        uint    splitB;\n', '    }\n', '    /// @dev A struct to capture parameters passed to submitRing method and\n', '    ///      various of other variables used across the submitRing core logics.\n', '    struct RingParams {\n', '        uint8[]       vList;\n', '        bytes32[]     rList;\n', '        bytes32[]     sList;\n', '        address       miner;\n', '        uint16        feeSelections;\n', '        uint          ringSize;         // computed\n', '        bytes32       ringHash;         // computed\n', '    }\n', '    /// @dev Disable default function.\n', '    function ()\n', '        payable\n', '        public\n', '    {\n', '        revert();\n', '    }\n', '    function cancelOrder(\n', '        address[5] addresses,\n', '        uint[6]    orderValues,\n', '        bool       buyNoMoreThanAmountB,\n', '        uint8      marginSplitPercentage,\n', '        uint8      v,\n', '        bytes32    r,\n', '        bytes32    s\n', '        )\n', '        external\n', '    {\n', '        uint cancelAmount = orderValues[5];\n', '        require(cancelAmount > 0); // "amount to cancel is zero");\n', '        OrderState memory order = OrderState(\n', '            addresses[0],\n', '            addresses[1],\n', '            addresses[2],\n', '            addresses[3],\n', '            addresses[4],\n', '            orderValues[2],\n', '            orderValues[3],\n', '            orderValues[0],\n', '            orderValues[1],\n', '            orderValues[4],\n', '            buyNoMoreThanAmountB,\n', '            false,\n', '            0x0,\n', '            marginSplitPercentage,\n', '            0,\n', '            0,\n', '            0,\n', '            0,\n', '            0,\n', '            0,\n', '            0\n', '        );\n', '        require(msg.sender == order.owner); // "cancelOrder not submitted by order owner");\n', '        bytes32 orderHash = calculateOrderHash(order);\n', '        verifySignature(\n', '            order.owner,\n', '            orderHash,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '        TokenTransferDelegate delegate = TokenTransferDelegate(delegateAddress);\n', '        delegate.addCancelled(orderHash, cancelAmount);\n', '        delegate.addCancelledOrFilled(orderHash, cancelAmount);\n', '        emit OrderCancelled(orderHash, cancelAmount);\n', '    }\n', '    function cancelAllOrdersByTradingPair(\n', '        address token1,\n', '        address token2,\n', '        uint    cutoff\n', '        )\n', '        external\n', '    {\n', '        uint t = (cutoff == 0 || cutoff >= block.timestamp) ? block.timestamp : cutoff;\n', '        bytes20 tokenPair = bytes20(token1) ^ bytes20(token2);\n', '        TokenTransferDelegate delegate = TokenTransferDelegate(delegateAddress);\n', '        require(delegate.tradingPairCutoffs(msg.sender, tokenPair) < t);\n', '        // "attempted to set cutoff to a smaller value"\n', '        delegate.setTradingPairCutoffs(tokenPair, t);\n', '        emit OrdersCancelled(\n', '            msg.sender,\n', '            token1,\n', '            token2,\n', '            t\n', '        );\n', '    }\n', '    function cancelAllOrders(\n', '        uint cutoff\n', '        )\n', '        external\n', '    {\n', '        uint t = (cutoff == 0 || cutoff >= block.timestamp) ? block.timestamp : cutoff;\n', '        TokenTransferDelegate delegate = TokenTransferDelegate(delegateAddress);\n', '        require(delegate.cutoffs(msg.sender) < t); // "attempted to set cutoff to a smaller value"\n', '        delegate.setCutoffs(t);\n', '        emit AllOrdersCancelled(msg.sender, t);\n', '    }\n', '    function submitRing(\n', '        address[4][]  addressList,\n', '        uint[6][]     uintArgsList,\n', '        uint8[1][]    uint8ArgsList,\n', '        bool[]        buyNoMoreThanAmountBList,\n', '        uint8[]       vList,\n', '        bytes32[]     rList,\n', '        bytes32[]     sList,\n', '        address       miner,\n', '        uint16        feeSelections\n', '        )\n', '        public\n', '    {\n', '        // Check if the highest bit of ringIndex is &#39;1&#39;.\n', '        require((ringIndex >> 63) == 0); // "attempted to re-ent submitRing function");\n', '        // Set the highest bit of ringIndex to &#39;1&#39;.\n', '        uint64 _ringIndex = ringIndex;\n', '        ringIndex |= (1 << 63);\n', '        RingParams memory params = RingParams(\n', '            vList,\n', '            rList,\n', '            sList,\n', '            miner,\n', '            feeSelections,\n', '            addressList.length,\n', '            0x0 // ringHash\n', '        );\n', '        verifyInputDataIntegrity(\n', '            params,\n', '            addressList,\n', '            uintArgsList,\n', '            uint8ArgsList,\n', '            buyNoMoreThanAmountBList\n', '        );\n', '        // Assemble input data into structs so we can pass them to other functions.\n', '        // This method also calculates ringHash, therefore it must be called before\n', '        // calling `verifyRingSignatures`.\n', '        TokenTransferDelegate delegate = TokenTransferDelegate(delegateAddress);\n', '        OrderState[] memory orders = assembleOrders(\n', '            params,\n', '            delegate,\n', '            addressList,\n', '            uintArgsList,\n', '            uint8ArgsList,\n', '            buyNoMoreThanAmountBList\n', '        );\n', '        verifyRingSignatures(params, orders);\n', '        verifyTokensRegistered(params, orders);\n', '        handleRing(_ringIndex, params, orders, delegate);\n', '        ringIndex = _ringIndex + 1;\n', '    }\n', '    /// @dev Validate a ring.\n', '    function verifyRingHasNoSubRing(\n', '        uint          ringSize,\n', '        OrderState[]  orders\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        // Check the ring has no sub-ring.\n', '        for (uint i = 0; i < ringSize - 1; i++) {\n', '            address tokenS = orders[i].tokenS;\n', '            for (uint j = i + 1; j < ringSize; j++) {\n', '                require(tokenS != orders[j].tokenS); // "found sub-ring");\n', '            }\n', '        }\n', '    }\n', '    /// @dev Verify the ringHash has been signed with each order&#39;s auth private\n', '    ///      keys as well as the miner&#39;s private key.\n', '    function verifyRingSignatures(\n', '        RingParams params,\n', '        OrderState[] orders\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        uint j;\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            j = i + params.ringSize;\n', '            verifySignature(\n', '                orders[i].authAddr,\n', '                params.ringHash,\n', '                params.vList[j],\n', '                params.rList[j],\n', '                params.sList[j]\n', '            );\n', '        }\n', '    }\n', '    function verifyTokensRegistered(\n', '        RingParams params,\n', '        OrderState[] orders\n', '        )\n', '        private\n', '        view\n', '    {\n', '        // Extract the token addresses\n', '        address[] memory tokens = new address[](params.ringSize);\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            tokens[i] = orders[i].tokenS;\n', '        }\n', '        // Test all token addresses at once\n', '        require(\n', '            TokenRegistry(tokenRegistryAddress).areAllTokensRegistered(tokens)\n', '        ); // "token not registered");\n', '    }\n', '    function handleRing(\n', '        uint64       _ringIndex,\n', '        RingParams   params,\n', '        OrderState[] orders,\n', '        TokenTransferDelegate delegate\n', '        )\n', '        private\n', '    {\n', '        address _lrcTokenAddress = lrcTokenAddress;\n', '        // Do the hard work.\n', '        verifyRingHasNoSubRing(params.ringSize, orders);\n', '        // Exchange rates calculation are performed by ring-miners as solidity\n', '        // cannot get power-of-1/n operation, therefore we have to verify\n', '        // these rates are correct.\n', '        verifyMinerSuppliedFillRates(params.ringSize, orders);\n', '        // Scale down each order independently by substracting amount-filled and\n', '        // amount-cancelled. Order owner&#39;s current balance and allowance are\n', '        // not taken into consideration in these operations.\n', '        scaleRingBasedOnHistoricalRecords(delegate, params.ringSize, orders);\n', '        // Based on the already verified exchange rate provided by ring-miners,\n', '        // we can furthur scale down orders based on token balance and allowance,\n', '        // then find the smallest order of the ring, then calculate each order&#39;s\n', '        // `fillAmountS`.\n', '        calculateRingFillAmount(params.ringSize, orders);\n', '        // Calculate each order&#39;s `lrcFee` and `lrcRewrard` and splict how much\n', '        // of `fillAmountS` shall be paid to matching order or miner as margin\n', '        // split.\n', '        calculateRingFees(\n', '            delegate,\n', '            params.ringSize,\n', '            orders,\n', '            params.miner,\n', '            _lrcTokenAddress\n', '        );\n', '        /// Make transfers.\n', '        bytes32[] memory orderInfoList = settleRing(\n', '            delegate,\n', '            params.ringSize,\n', '            orders,\n', '            params.miner,\n', '            _lrcTokenAddress\n', '        );\n', '        emit RingMined(\n', '            _ringIndex,\n', '            params.ringHash,\n', '            params.miner,\n', '            orderInfoList\n', '        );\n', '    }\n', '    function settleRing(\n', '        TokenTransferDelegate delegate,\n', '        uint          ringSize,\n', '        OrderState[]  orders,\n', '        address       miner,\n', '        address       _lrcTokenAddress\n', '        )\n', '        private\n', '        returns (bytes32[] memory orderInfoList)\n', '    {\n', '        bytes32[] memory batch = new bytes32[](ringSize * 7); // ringSize * (owner + tokenS + 4 amounts + wallet)\n', '        bytes32[] memory historyBatch = new bytes32[](ringSize * 2); // ringSize * (orderhash, fillAmount)\n', '        orderInfoList = new bytes32[](ringSize * 7);\n', '        uint p = 0;\n', '        uint q = 0;\n', '        uint r = 0;\n', '        uint prevSplitB = orders[ringSize - 1].splitB;\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            OrderState memory state = orders[i];\n', '            uint nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;\n', '            // Store owner and tokenS of every order\n', '            batch[p++] = bytes32(state.owner);\n', '            batch[p++] = bytes32(state.tokenS);\n', '            // Store all amounts\n', '            batch[p++] = bytes32(state.fillAmountS.sub(prevSplitB));\n', '            batch[p++] = bytes32(prevSplitB.add(state.splitS));\n', '            batch[p++] = bytes32(state.lrcReward);\n', '            batch[p++] = bytes32(state.lrcFeeState);\n', '            batch[p++] = bytes32(state.wallet);\n', '            historyBatch[r++] = state.orderHash;\n', '            historyBatch[r++] = bytes32(\n', '                state.buyNoMoreThanAmountB ? nextFillAmountS : state.fillAmountS);\n', '            orderInfoList[q++] = bytes32(state.orderHash);\n', '            orderInfoList[q++] = bytes32(state.owner);\n', '            orderInfoList[q++] = bytes32(state.tokenS);\n', '            orderInfoList[q++] = bytes32(state.fillAmountS);\n', '            orderInfoList[q++] = bytes32(state.lrcReward);\n', '            orderInfoList[q++] = bytes32(\n', '                state.lrcFeeState > 0 ? int(state.lrcFeeState) : -int(state.lrcReward)\n', '            );\n', '            orderInfoList[q++] = bytes32(\n', '                state.splitS > 0 ? int(state.splitS) : -int(state.splitB)\n', '            );\n', '            prevSplitB = state.splitB;\n', '        }\n', '        // Update fill records\n', '        delegate.batchAddCancelledOrFilled(historyBatch);\n', '        // Do all transactions\n', '        delegate.batchTransferToken(\n', '            _lrcTokenAddress,\n', '            miner,\n', '            walletSplitPercentage,\n', '            batch\n', '        );\n', '    }\n', '    /// @dev Verify miner has calculte the rates correctly.\n', '    function verifyMinerSuppliedFillRates(\n', '        uint         ringSize,\n', '        OrderState[] orders\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        uint[] memory rateRatios = new uint[](ringSize);\n', '        uint _rateRatioScale = RATE_RATIO_SCALE;\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            uint s1b0 = orders[i].rateS.mul(orders[i].amountB);\n', '            uint s0b1 = orders[i].amountS.mul(orders[i].rateB);\n', '            require(s1b0 <= s0b1); // "miner supplied exchange rate provides invalid discount");\n', '            rateRatios[i] = _rateRatioScale.mul(s1b0) / s0b1;\n', '        }\n', '        uint cvs = MathUint.cvsquare(rateRatios, _rateRatioScale);\n', '        require(cvs <= rateRatioCVSThreshold);\n', '        // "miner supplied exchange rate is not evenly discounted");\n', '    }\n', '    /// @dev Calculate each order&#39;s fee or LRC reward.\n', '    function calculateRingFees(\n', '        TokenTransferDelegate delegate,\n', '        uint            ringSize,\n', '        OrderState[]    orders,\n', '        address         miner,\n', '        address         _lrcTokenAddress\n', '        )\n', '        private\n', '        view\n', '    {\n', '        bool checkedMinerLrcSpendable = false;\n', '        uint minerLrcSpendable = 0;\n', '        uint8 _marginSplitPercentageBase = MARGIN_SPLIT_PERCENTAGE_BASE;\n', '        uint nextFillAmountS;\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            OrderState memory state = orders[i];\n', '            uint lrcReceiable = 0;\n', '            if (state.lrcFeeState == 0) {\n', '                // When an order&#39;s LRC fee is 0 or smaller than the specified fee,\n', '                // we help miner automatically select margin-split.\n', '                state.marginSplitAsFee = true;\n', '                state.marginSplitPercentage = _marginSplitPercentageBase;\n', '            } else {\n', '                uint lrcSpendable = getSpendable(\n', '                    delegate,\n', '                    _lrcTokenAddress,\n', '                    state.owner\n', '                );\n', '                // If the order is selling LRC, we need to calculate how much LRC\n', '                // is left that can be used as fee.\n', '                if (state.tokenS == _lrcTokenAddress) {\n', '                    lrcSpendable = lrcSpendable.sub(state.fillAmountS);\n', '                }\n', '                // If the order is buyign LRC, it will has more to pay as fee.\n', '                if (state.tokenB == _lrcTokenAddress) {\n', '                    nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;\n', '                    lrcReceiable = nextFillAmountS;\n', '                }\n', '                uint lrcTotal = lrcSpendable.add(lrcReceiable);\n', '                // If order doesn&#39;t have enough LRC, set margin split to 100%.\n', '                if (lrcTotal < state.lrcFeeState) {\n', '                    state.lrcFeeState = lrcTotal;\n', '                    state.marginSplitPercentage = _marginSplitPercentageBase;\n', '                }\n', '                if (state.lrcFeeState == 0) {\n', '                    state.marginSplitAsFee = true;\n', '                }\n', '            }\n', '            if (!state.marginSplitAsFee) {\n', '                if (lrcReceiable > 0) {\n', '                    if (lrcReceiable >= state.lrcFeeState) {\n', '                        state.splitB = state.lrcFeeState;\n', '                        state.lrcFeeState = 0;\n', '                    } else {\n', '                        state.splitB = lrcReceiable;\n', '                        state.lrcFeeState = state.lrcFeeState.sub(lrcReceiable);\n', '                    }\n', '                }\n', '            } else {\n', '                // Only check the available miner balance when absolutely needed\n', '                if (!checkedMinerLrcSpendable && minerLrcSpendable < state.lrcFeeState) {\n', '                    checkedMinerLrcSpendable = true;\n', '                    minerLrcSpendable = getSpendable(delegate, _lrcTokenAddress, miner);\n', '                }\n', '                // Only calculate split when miner has enough LRC;\n', '                // otherwise all splits are 0.\n', '                if (minerLrcSpendable >= state.lrcFeeState) {\n', '                    nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;\n', '                    uint split;\n', '                    if (state.buyNoMoreThanAmountB) {\n', '                        split = (nextFillAmountS.mul(\n', '                            state.amountS\n', '                        ) / state.amountB).sub(\n', '                            state.fillAmountS\n', '                        );\n', '                    } else {\n', '                        split = nextFillAmountS.sub(\n', '                            state.fillAmountS.mul(\n', '                                state.amountB\n', '                            ) / state.amountS\n', '                        );\n', '                    }\n', '                    if (state.marginSplitPercentage != _marginSplitPercentageBase) {\n', '                        split = split.mul(\n', '                            state.marginSplitPercentage\n', '                        ) / _marginSplitPercentageBase;\n', '                    }\n', '                    if (state.buyNoMoreThanAmountB) {\n', '                        state.splitS = split;\n', '                    } else {\n', '                        state.splitB = split;\n', '                    }\n', '                    // This implicits order with smaller index in the ring will\n', '                    // be paid LRC reward first, so the orders in the ring does\n', '                    // mater.\n', '                    if (split > 0) {\n', '                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFeeState);\n', '                        state.lrcReward = state.lrcFeeState;\n', '                    }\n', '                }\n', '                state.lrcFeeState = 0;\n', '            }\n', '        }\n', '    }\n', '    /// @dev Calculate each order&#39;s fill amount.\n', '    function calculateRingFillAmount(\n', '        uint          ringSize,\n', '        OrderState[]  orders\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        uint smallestIdx = 0;\n', '        uint i;\n', '        uint j;\n', '        for (i = 0; i < ringSize; i++) {\n', '            j = (i + 1) % ringSize;\n', '            smallestIdx = calculateOrderFillAmount(\n', '                orders[i],\n', '                orders[j],\n', '                i,\n', '                j,\n', '                smallestIdx\n', '            );\n', '        }\n', '        for (i = 0; i < smallestIdx; i++) {\n', '            calculateOrderFillAmount(\n', '                orders[i],\n', '                orders[(i + 1) % ringSize],\n', '                0,               // Not needed\n', '                0,               // Not needed\n', '                0                // Not needed\n', '            );\n', '        }\n', '    }\n', '    /// @return The smallest order&#39;s index.\n', '    function calculateOrderFillAmount(\n', '        OrderState state,\n', '        OrderState next,\n', '        uint       i,\n', '        uint       j,\n', '        uint       smallestIdx\n', '        )\n', '        private\n', '        pure\n', '        returns (uint newSmallestIdx)\n', '    {\n', '        // Default to the same smallest index\n', '        newSmallestIdx = smallestIdx;\n', '        uint fillAmountB = state.fillAmountS.mul(\n', '            state.rateB\n', '        ) / state.rateS;\n', '        if (state.buyNoMoreThanAmountB) {\n', '            if (fillAmountB > state.amountB) {\n', '                fillAmountB = state.amountB;\n', '                state.fillAmountS = fillAmountB.mul(\n', '                    state.rateS\n', '                ) / state.rateB;\n', '                require(state.fillAmountS > 0);\n', '                newSmallestIdx = i;\n', '            }\n', '            state.lrcFeeState = state.lrcFee.mul(\n', '                fillAmountB\n', '            ) / state.amountB;\n', '        } else {\n', '            state.lrcFeeState = state.lrcFee.mul(\n', '                state.fillAmountS\n', '            ) / state.amountS;\n', '        }\n', '        if (fillAmountB <= next.fillAmountS) {\n', '            next.fillAmountS = fillAmountB;\n', '        } else {\n', '            newSmallestIdx = j;\n', '        }\n', '    }\n', '    /// @dev Scale down all orders based on historical fill or cancellation\n', '    ///      stats but key the order&#39;s original exchange rate.\n', '    function scaleRingBasedOnHistoricalRecords(\n', '        TokenTransferDelegate delegate,\n', '        uint ringSize,\n', '        OrderState[] orders\n', '        )\n', '        private\n', '        view\n', '    {\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            OrderState memory state = orders[i];\n', '            uint amount;\n', '            if (state.buyNoMoreThanAmountB) {\n', '                amount = state.amountB.tolerantSub(\n', '                    delegate.cancelledOrFilled(state.orderHash)\n', '                );\n', '                state.amountS = amount.mul(state.amountS) / state.amountB;\n', '                state.lrcFee = amount.mul(state.lrcFee) / state.amountB;\n', '                state.amountB = amount;\n', '            } else {\n', '                amount = state.amountS.tolerantSub(\n', '                    delegate.cancelledOrFilled(state.orderHash)\n', '                );\n', '                state.amountB = amount.mul(state.amountB) / state.amountS;\n', '                state.lrcFee = amount.mul(state.lrcFee) / state.amountS;\n', '                state.amountS = amount;\n', '            }\n', '            require(state.amountS > 0); // "amountS is zero");\n', '            require(state.amountB > 0); // "amountB is zero");\n', '            uint availableAmountS = getSpendable(delegate, state.tokenS, state.owner);\n', '            require(availableAmountS > 0); // "order spendable amountS is zero");\n', '            state.fillAmountS = (\n', '                state.amountS < availableAmountS ?\n', '                state.amountS : availableAmountS\n', '            );\n', '            require(state.fillAmountS > 0);\n', '        }\n', '    }\n', '    /// @return Amount of ERC20 token that can be spent by this contract.\n', '    function getSpendable(\n', '        TokenTransferDelegate delegate,\n', '        address tokenAddress,\n', '        address tokenOwner\n', '        )\n', '        private\n', '        view\n', '        returns (uint)\n', '    {\n', '        ERC20 token = ERC20(tokenAddress);\n', '        uint allowance = token.allowance(\n', '            tokenOwner,\n', '            address(delegate)\n', '        );\n', '        uint balance = token.balanceOf(tokenOwner);\n', '        return (allowance < balance ? allowance : balance);\n', '    }\n', '    /// @dev verify input data&#39;s basic integrity.\n', '    function verifyInputDataIntegrity(\n', '        RingParams params,\n', '        address[4][]  addressList,\n', '        uint[6][]     uintArgsList,\n', '        uint8[1][]    uint8ArgsList,\n', '        bool[]        buyNoMoreThanAmountBList\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        require(params.miner != 0x0);\n', '        require(params.ringSize == addressList.length);\n', '        require(params.ringSize == uintArgsList.length);\n', '        require(params.ringSize == uint8ArgsList.length);\n', '        require(params.ringSize == buyNoMoreThanAmountBList.length);\n', '        // Validate ring-mining related arguments.\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            require(uintArgsList[i][5] > 0); // "order rateAmountS is zero");\n', '        }\n', '        //Check ring size\n', '        require(params.ringSize > 1 && params.ringSize <= MAX_RING_SIZE); // "invalid ring size");\n', '        uint sigSize = params.ringSize << 1;\n', '        require(sigSize == params.vList.length);\n', '        require(sigSize == params.rList.length);\n', '        require(sigSize == params.sList.length);\n', '    }\n', '    /// @dev        assmble order parameters into Order struct.\n', '    /// @return     A list of orders.\n', '    function assembleOrders(\n', '        RingParams params,\n', '        TokenTransferDelegate delegate,\n', '        address[4][]  addressList,\n', '        uint[6][]     uintArgsList,\n', '        uint8[1][]    uint8ArgsList,\n', '        bool[]        buyNoMoreThanAmountBList\n', '        )\n', '        private\n', '        view\n', '        returns (OrderState[] memory orders)\n', '    {\n', '        orders = new OrderState[](params.ringSize);\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            uint[6] memory uintArgs = uintArgsList[i];\n', '            bool marginSplitAsFee = (params.feeSelections & (uint16(1) << i)) > 0;\n', '            orders[i] = OrderState(\n', '                addressList[i][0],\n', '                addressList[i][1],\n', '                addressList[(i + 1) % params.ringSize][1],\n', '                addressList[i][2],\n', '                addressList[i][3],\n', '                uintArgs[2],\n', '                uintArgs[3],\n', '                uintArgs[0],\n', '                uintArgs[1],\n', '                uintArgs[4],\n', '                buyNoMoreThanAmountBList[i],\n', '                marginSplitAsFee,\n', '                bytes32(0),\n', '                uint8ArgsList[i][0],\n', '                uintArgs[5],\n', '                uintArgs[1],\n', '                0,   // fillAmountS\n', '                0,   // lrcReward\n', '                0,   // lrcFee\n', '                0,   // splitS\n', '                0    // splitB\n', '            );\n', '            validateOrder(orders[i]);\n', '            bytes32 orderHash = calculateOrderHash(orders[i]);\n', '            orders[i].orderHash = orderHash;\n', '            verifySignature(\n', '                orders[i].owner,\n', '                orderHash,\n', '                params.vList[i],\n', '                params.rList[i],\n', '                params.sList[i]\n', '            );\n', '            params.ringHash ^= orderHash;\n', '        }\n', '        validateOrdersCutoffs(orders, delegate);\n', '        params.ringHash = keccak256(\n', '            params.ringHash,\n', '            params.miner,\n', '            params.feeSelections\n', '        );\n', '    }\n', '    /// @dev validate order&#39;s parameters are OK.\n', '    function validateOrder(\n', '        OrderState order\n', '        )\n', '        private\n', '        view\n', '    {\n', '        require(order.owner != 0x0); // invalid order owner\n', '        require(order.tokenS != 0x0); // invalid order tokenS\n', '        require(order.tokenB != 0x0); // invalid order tokenB\n', '        require(order.amountS != 0); // invalid order amountS\n', '        require(order.amountB != 0); // invalid order amountB\n', '        require(order.marginSplitPercentage <= MARGIN_SPLIT_PERCENTAGE_BASE);\n', '        // invalid order marginSplitPercentage\n', '        require(order.validSince <= block.timestamp); // order is too early to match\n', '        require(order.validUntil > block.timestamp); // order is expired\n', '    }\n', '    function validateOrdersCutoffs(OrderState[] orders, TokenTransferDelegate delegate)\n', '        private\n', '        view\n', '    {\n', '        address[] memory owners = new address[](orders.length);\n', '        bytes20[] memory tradingPairs = new bytes20[](orders.length);\n', '        uint[] memory validSinceTimes = new uint[](orders.length);\n', '        for (uint i = 0; i < orders.length; i++) {\n', '            owners[i] = orders[i].owner;\n', '            tradingPairs[i] = bytes20(orders[i].tokenS) ^ bytes20(orders[i].tokenB);\n', '            validSinceTimes[i] = orders[i].validSince;\n', '        }\n', '        delegate.checkCutoffsBatch(owners, tradingPairs, validSinceTimes);\n', '    }\n', '    /// @dev Get the Keccak-256 hash of order with specified parameters.\n', '    function calculateOrderHash(\n', '        OrderState order\n', '        )\n', '        private\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            delegateAddress,\n', '            order.owner,\n', '            order.tokenS,\n', '            order.tokenB,\n', '            order.wallet,\n', '            order.authAddr,\n', '            order.amountS,\n', '            order.amountB,\n', '            order.validSince,\n', '            order.validUntil,\n', '            order.lrcFee,\n', '            order.buyNoMoreThanAmountB,\n', '            order.marginSplitPercentage\n', '        );\n', '    }\n', '    /// @dev Verify signer&#39;s signature.\n', '    function verifySignature(\n', '        address signer,\n', '        bytes32 hash,\n', '        uint8   v,\n', '        bytes32 r,\n', '        bytes32 s\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        require(\n', '            signer == ecrecover(\n', '                keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '                v,\n', '                r,\n', '                s\n', '            )\n', '        ); // "invalid signature");\n', '    }\n', '    function getTradingPairCutoffs(\n', '        address orderOwner,\n', '        address token1,\n', '        address token2\n', '        )\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        bytes20 tokenPair = bytes20(token1) ^ bytes20(token2);\n', '        TokenTransferDelegate delegate = TokenTransferDelegate(delegateAddress);\n', '        return delegate.tradingPairCutoffs(orderOwner, tokenPair);\n', '    }\n', '}']
['/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', 'pragma solidity 0.4.21;\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library MathUint {\n', '    function mul(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function sub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function tolerantSub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        return (a >= b) ? a - b : 0;\n', '    }\n', '    /// @dev calculate the square of Coefficient of Variation (CV)\n', '    /// https://en.wikipedia.org/wiki/Coefficient_of_variation\n', '    function cvsquare(\n', '        uint[] arr,\n', '        uint scale\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        uint len = arr.length;\n', '        require(len > 1);\n', '        require(scale > 0);\n', '        uint avg = 0;\n', '        for (uint i = 0; i < len; i++) {\n', '            avg = add(avg, arr[i]);\n', '        }\n', '        avg = avg / len;\n', '        if (avg == 0) {\n', '            return 0;\n', '        }\n', '        uint cvs = 0;\n', '        uint s;\n', '        uint item;\n', '        for (i = 0; i < len; i++) {\n', '            item = arr[i];\n', '            s = item > avg ? item - avg : avg - item;\n', '            cvs = add(cvs, mul(s, s));\n', '        }\n', '        return ((mul(mul(cvs, scale), scale) / avg) / avg) / (len - 1);\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Utility Functions for address\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library AddressUtil {\n', '    function isContract(\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (addr == 0x0) {\n', '            return false;\n', '        } else {\n', '            uint size;\n', '            assembly { size := extcodesize(addr) }\n', '            return size > 0;\n', '        }\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract ERC20 {\n', '    function balanceOf(\n', '        address who\n', '        )\n', '        view\n', '        public\n', '        returns (uint256);\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '        )\n', '        view\n', '        public\n', '        returns (uint256);\n', '    function transfer(\n', '        address to,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '    function approve(\n', '        address spender,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Loopring Token Exchange Protocol Contract Interface\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>\n', 'contract LoopringProtocol {\n', '    uint8   public constant MARGIN_SPLIT_PERCENTAGE_BASE = 100;\n', '    /// @dev Event to emit if a ring is successfully mined.\n', '    /// _amountsList is an array of:\n', '    /// [_amountS, _amountB, _lrcReward, _lrcFee, splitS, splitB].\n', '    event RingMined(\n', '        uint            _ringIndex,\n', '        bytes32 indexed _ringHash,\n', '        address         _miner,\n', '        bytes32[]       _orderInfoList\n', '    );\n', '    event OrderCancelled(\n', '        bytes32 indexed _orderHash,\n', '        uint            _amountCancelled\n', '    );\n', '    event AllOrdersCancelled(\n', '        address indexed _address,\n', '        uint            _cutoff\n', '    );\n', '    event OrdersCancelled(\n', '        address indexed _address,\n', '        address         _token1,\n', '        address         _token2,\n', '        uint            _cutoff\n', '    );\n', '    /// @dev Cancel a order. cancel amount(amountS or amountB) can be specified\n', '    ///      in orderValues.\n', '    /// @param addresses          owner, tokenS, tokenB, wallet, authAddr\n', '    /// @param orderValues        amountS, amountB, validSince (second),\n', '    ///                           validUntil (second), lrcFee, and cancelAmount.\n', '    /// @param buyNoMoreThanAmountB -\n', '    ///                           This indicates when a order should be considered\n', "    ///                           as 'completely filled'.\n", '    /// @param marginSplitPercentage -\n', '    ///                           Percentage of margin split to share with miner.\n', '    /// @param v                  Order ECDSA signature parameter v.\n', '    /// @param r                  Order ECDSA signature parameters r.\n', '    /// @param s                  Order ECDSA signature parameters s.\n', '    function cancelOrder(\n', '        address[5] addresses,\n', '        uint[6]    orderValues,\n', '        bool       buyNoMoreThanAmountB,\n', '        uint8      marginSplitPercentage,\n', '        uint8      v,\n', '        bytes32    r,\n', '        bytes32    s\n', '        )\n', '        external;\n', '    /// @dev   Set a cutoff timestamp to invalidate all orders whose timestamp\n', "    ///        is smaller than or equal to the new value of the address's cutoff\n", '    ///        timestamp, for a specific trading pair.\n', '    /// @param cutoff The cutoff timestamp, will default to `block.timestamp`\n', '    ///        if it is 0.\n', '    function cancelAllOrdersByTradingPair(\n', '        address token1,\n', '        address token2,\n', '        uint cutoff\n', '        )\n', '        external;\n', '    /// @dev   Set a cutoff timestamp to invalidate all orders whose timestamp\n', "    ///        is smaller than or equal to the new value of the address's cutoff\n", '    ///        timestamp.\n', '    /// @param cutoff The cutoff timestamp, will default to `block.timestamp`\n', '    ///        if it is 0.\n', '    function cancelAllOrders(\n', '        uint cutoff\n', '        )\n', '        external;\n', '    /// @dev Submit a order-ring for validation and settlement.\n', "    /// @param addressList  List of each order's owner, tokenS, wallet, authAddr.\n", "    ///                     Note that next order's `tokenS` equals this order's\n", '    ///                     `tokenB`.\n', '    /// @param uintArgsList List of uint-type arguments in this order:\n', '    ///                     amountS, amountB, validSince (second),\n', '    ///                     validUntil (second), lrcFee, and rateAmountS.\n', '    /// @param uint8ArgsList -\n', '    ///                     List of unit8-type arguments, in this order:\n', '    ///                     marginSplitPercentageList.\n', '    /// @param buyNoMoreThanAmountBList -\n', '    ///                     This indicates when a order should be considered\n', '    /// @param vList        List of v for each order. This list is 1-larger than\n', '    ///                     the previous lists, with the last element being the\n', '    ///                     v value of the ring signature.\n', '    /// @param rList        List of r for each order. This list is 1-larger than\n', '    ///                     the previous lists, with the last element being the\n', '    ///                     r value of the ring signature.\n', '    /// @param sList        List of s for each order. This list is 1-larger than\n', '    ///                     the previous lists, with the last element being the\n', '    ///                     s value of the ring signature.\n', '    /// @param miner        Miner address.\n', '    /// @param feeSelections -\n', '    ///                     Bits to indicate fee selections. `1` represents margin\n', '    ///                     split and `0` represents LRC as fee.\n', '    function submitRing(\n', '        address[4][]    addressList,\n', '        uint[6][]       uintArgsList,\n', '        uint8[1][]      uint8ArgsList,\n', '        bool[]          buyNoMoreThanAmountBList,\n', '        uint8[]         vList,\n', '        bytes32[]       rList,\n', '        bytes32[]       sList,\n', '        address         miner,\n', '        uint16          feeSelections\n', '        )\n', '        public;\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Token Register Contract\n', '/// @dev This contract maintains a list of tokens the Protocol supports.\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>,\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'contract TokenRegistry {\n', '    event TokenRegistered(\n', '        address indexed addr,\n', '        string          symbol\n', '    );\n', '    event TokenUnregistered(\n', '        address indexed addr,\n', '        string          symbol\n', '    );\n', '    function registerToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external;\n', '    function registerMintedToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external;\n', '    function unregisterToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external;\n', '    function areAllTokensRegistered(\n', '        address[] addressList\n', '        )\n', '        external\n', '        view\n', '        returns (bool);\n', '    function getAddressBySymbol(\n', '        string symbol\n', '        )\n', '        external\n', '        view\n', '        returns (address);\n', '    function isTokenRegisteredBySymbol(\n', '        string symbol\n', '        )\n', '        public\n', '        view\n', '        returns (bool);\n', '    function isTokenRegistered(\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool);\n', '    function getTokens(\n', '        uint start,\n', '        uint count\n', '        )\n', '        public\n', '        view\n', '        returns (address[] addressList);\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title TokenTransferDelegate\n', '/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different\n', '/// versions of Loopring protocol to avoid ERC20 re-authorization.\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'contract TokenTransferDelegate {\n', '    event AddressAuthorized(\n', '        address indexed addr,\n', '        uint32          number\n', '    );\n', '    event AddressDeauthorized(\n', '        address indexed addr,\n', '        uint32          number\n', '    );\n', '    // The following map is used to keep trace of order fill and cancellation\n', '    // history.\n', '    mapping (bytes32 => uint) public cancelledOrFilled;\n', "    // This map is used to keep trace of order's cancellation history.\n", '    mapping (bytes32 => uint) public cancelled;\n', '    // A map from address to its cutoff timestamp.\n', '    mapping (address => uint) public cutoffs;\n', '    // A map from address to its trading-pair cutoff timestamp.\n', '    mapping (address => mapping (bytes20 => uint)) public tradingPairCutoffs;\n', '    /// @dev Add a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function authorizeAddress(\n', '        address addr\n', '        )\n', '        external;\n', '    /// @dev Remove a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function deauthorizeAddress(\n', '        address addr\n', '        )\n', '        external;\n', '    function getLatestAuthorizedAddresses(\n', '        uint max\n', '        )\n', '        external\n', '        view\n', '        returns (address[] addresses);\n', '    /// @dev Invoke ERC20 transferFrom method.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    function transferToken(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        external;\n', '    function batchTransferToken(\n', '        address lrcTokenAddress,\n', '        address minerFeeRecipient,\n', '        uint8 walletSplitPercentage,\n', '        bytes32[] batch\n', '        )\n', '        external;\n', '    function isAddressAuthorized(\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool);\n', '    function addCancelled(bytes32 orderHash, uint cancelAmount)\n', '        external;\n', '    function addCancelledOrFilled(bytes32 orderHash, uint cancelOrFillAmount)\n', '        public;\n', '    function batchAddCancelledOrFilled(bytes32[] batch)\n', '        public;\n', '    function setCutoffs(uint t)\n', '        external;\n', '    function setTradingPairCutoffs(bytes20 tokenPair, uint t)\n', '        external;\n', '    function checkCutoffsBatch(address[] owners, bytes20[] tradingPairs, uint[] validSince)\n', '        external\n', '        view;\n', '    function suspend() external;\n', '    function resume() external;\n', '    function kill() external;\n', '}\n', '/// @title An Implementation of LoopringProtocol.\n', '/// @author Daniel Wang - <daniel@loopring.org>,\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>\n', '///\n', '/// Recognized contributing developers from the community:\n', '///     https://github.com/Brechtpd\n', '///     https://github.com/rainydio\n', '///     https://github.com/BenjaminPrice\n', '///     https://github.com/jonasshen\n', '///     https://github.com/Hephyrius\n', 'contract LoopringProtocolImpl is LoopringProtocol {\n', '    using AddressUtil   for address;\n', '    using MathUint      for uint;\n', '    address public constant lrcTokenAddress             = 0xEF68e7C694F40c8202821eDF525dE3782458639f;\n', '    address public constant tokenRegistryAddress        = 0x004DeF62C71992615CF22786d0b7Efb22850Df4a;\n', '    address public constant delegateAddress             = 0xD22f97BCEc8E029e109412763b889fC16C4bca8B;\n', '    uint64  public  ringIndex                   = 0;\n', '    uint8   public constant walletSplitPercentage       = 20;\n', '    // Exchange rate (rate) is the amount to sell or sold divided by the amount\n', '    // to buy or bought.\n', '    //\n', "    // Rate ratio is the ratio between executed rate and an order's original\n", '    // rate.\n', '    //\n', "    // To require all orders' rate ratios to have coefficient ofvariation (CV)\n", '    // smaller than 2.5%, for an example , rateRatioCVSThreshold should be:\n', '    //     `(0.025 * RATE_RATIO_SCALE)^2` or 62500.\n', '    uint    public constant rateRatioCVSThreshold        = 62500;\n', '    uint    public constant MAX_RING_SIZE       = 16;\n', '    uint    public constant RATE_RATIO_SCALE    = 10000;\n', "    /// @param orderHash    The order's hash\n", '    /// @param feeSelection -\n', '    ///                     A miner-supplied value indicating if LRC (value = 0)\n', '    ///                     or margin split is choosen by the miner (value = 1).\n', '    ///                     We may support more fee model in the future.\n', '    /// @param rateS        Sell Exchange rate provided by miner.\n', '    /// @param rateB        Buy Exchange rate provided by miner.\n', '    /// @param fillAmountS  Amount of tokenS to sell, calculated by protocol.\n', '    /// @param lrcReward    The amount of LRC paid by miner to order owner in\n', '    ///                     exchange for margin split.\n', '    /// @param lrcFeeState  The amount of LR paid by order owner to miner.\n', '    /// @param splitS      TokenS paid to miner.\n', '    /// @param splitB      TokenB paid to miner.\n', '    struct OrderState {\n', '        address owner;\n', '        address tokenS;\n', '        address tokenB;\n', '        address wallet;\n', '        address authAddr;\n', '        uint    validSince;\n', '        uint    validUntil;\n', '        uint    amountS;\n', '        uint    amountB;\n', '        uint    lrcFee;\n', '        bool    buyNoMoreThanAmountB;\n', '        bool    marginSplitAsFee;\n', '        bytes32 orderHash;\n', '        uint8   marginSplitPercentage;\n', '        uint    rateS;\n', '        uint    rateB;\n', '        uint    fillAmountS;\n', '        uint    lrcReward;\n', '        uint    lrcFeeState;\n', '        uint    splitS;\n', '        uint    splitB;\n', '    }\n', '    /// @dev A struct to capture parameters passed to submitRing method and\n', '    ///      various of other variables used across the submitRing core logics.\n', '    struct RingParams {\n', '        uint8[]       vList;\n', '        bytes32[]     rList;\n', '        bytes32[]     sList;\n', '        address       miner;\n', '        uint16        feeSelections;\n', '        uint          ringSize;         // computed\n', '        bytes32       ringHash;         // computed\n', '    }\n', '    /// @dev Disable default function.\n', '    function ()\n', '        payable\n', '        public\n', '    {\n', '        revert();\n', '    }\n', '    function cancelOrder(\n', '        address[5] addresses,\n', '        uint[6]    orderValues,\n', '        bool       buyNoMoreThanAmountB,\n', '        uint8      marginSplitPercentage,\n', '        uint8      v,\n', '        bytes32    r,\n', '        bytes32    s\n', '        )\n', '        external\n', '    {\n', '        uint cancelAmount = orderValues[5];\n', '        require(cancelAmount > 0); // "amount to cancel is zero");\n', '        OrderState memory order = OrderState(\n', '            addresses[0],\n', '            addresses[1],\n', '            addresses[2],\n', '            addresses[3],\n', '            addresses[4],\n', '            orderValues[2],\n', '            orderValues[3],\n', '            orderValues[0],\n', '            orderValues[1],\n', '            orderValues[4],\n', '            buyNoMoreThanAmountB,\n', '            false,\n', '            0x0,\n', '            marginSplitPercentage,\n', '            0,\n', '            0,\n', '            0,\n', '            0,\n', '            0,\n', '            0,\n', '            0\n', '        );\n', '        require(msg.sender == order.owner); // "cancelOrder not submitted by order owner");\n', '        bytes32 orderHash = calculateOrderHash(order);\n', '        verifySignature(\n', '            order.owner,\n', '            orderHash,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '        TokenTransferDelegate delegate = TokenTransferDelegate(delegateAddress);\n', '        delegate.addCancelled(orderHash, cancelAmount);\n', '        delegate.addCancelledOrFilled(orderHash, cancelAmount);\n', '        emit OrderCancelled(orderHash, cancelAmount);\n', '    }\n', '    function cancelAllOrdersByTradingPair(\n', '        address token1,\n', '        address token2,\n', '        uint    cutoff\n', '        )\n', '        external\n', '    {\n', '        uint t = (cutoff == 0 || cutoff >= block.timestamp) ? block.timestamp : cutoff;\n', '        bytes20 tokenPair = bytes20(token1) ^ bytes20(token2);\n', '        TokenTransferDelegate delegate = TokenTransferDelegate(delegateAddress);\n', '        require(delegate.tradingPairCutoffs(msg.sender, tokenPair) < t);\n', '        // "attempted to set cutoff to a smaller value"\n', '        delegate.setTradingPairCutoffs(tokenPair, t);\n', '        emit OrdersCancelled(\n', '            msg.sender,\n', '            token1,\n', '            token2,\n', '            t\n', '        );\n', '    }\n', '    function cancelAllOrders(\n', '        uint cutoff\n', '        )\n', '        external\n', '    {\n', '        uint t = (cutoff == 0 || cutoff >= block.timestamp) ? block.timestamp : cutoff;\n', '        TokenTransferDelegate delegate = TokenTransferDelegate(delegateAddress);\n', '        require(delegate.cutoffs(msg.sender) < t); // "attempted to set cutoff to a smaller value"\n', '        delegate.setCutoffs(t);\n', '        emit AllOrdersCancelled(msg.sender, t);\n', '    }\n', '    function submitRing(\n', '        address[4][]  addressList,\n', '        uint[6][]     uintArgsList,\n', '        uint8[1][]    uint8ArgsList,\n', '        bool[]        buyNoMoreThanAmountBList,\n', '        uint8[]       vList,\n', '        bytes32[]     rList,\n', '        bytes32[]     sList,\n', '        address       miner,\n', '        uint16        feeSelections\n', '        )\n', '        public\n', '    {\n', "        // Check if the highest bit of ringIndex is '1'.\n", '        require((ringIndex >> 63) == 0); // "attempted to re-ent submitRing function");\n', "        // Set the highest bit of ringIndex to '1'.\n", '        uint64 _ringIndex = ringIndex;\n', '        ringIndex |= (1 << 63);\n', '        RingParams memory params = RingParams(\n', '            vList,\n', '            rList,\n', '            sList,\n', '            miner,\n', '            feeSelections,\n', '            addressList.length,\n', '            0x0 // ringHash\n', '        );\n', '        verifyInputDataIntegrity(\n', '            params,\n', '            addressList,\n', '            uintArgsList,\n', '            uint8ArgsList,\n', '            buyNoMoreThanAmountBList\n', '        );\n', '        // Assemble input data into structs so we can pass them to other functions.\n', '        // This method also calculates ringHash, therefore it must be called before\n', '        // calling `verifyRingSignatures`.\n', '        TokenTransferDelegate delegate = TokenTransferDelegate(delegateAddress);\n', '        OrderState[] memory orders = assembleOrders(\n', '            params,\n', '            delegate,\n', '            addressList,\n', '            uintArgsList,\n', '            uint8ArgsList,\n', '            buyNoMoreThanAmountBList\n', '        );\n', '        verifyRingSignatures(params, orders);\n', '        verifyTokensRegistered(params, orders);\n', '        handleRing(_ringIndex, params, orders, delegate);\n', '        ringIndex = _ringIndex + 1;\n', '    }\n', '    /// @dev Validate a ring.\n', '    function verifyRingHasNoSubRing(\n', '        uint          ringSize,\n', '        OrderState[]  orders\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        // Check the ring has no sub-ring.\n', '        for (uint i = 0; i < ringSize - 1; i++) {\n', '            address tokenS = orders[i].tokenS;\n', '            for (uint j = i + 1; j < ringSize; j++) {\n', '                require(tokenS != orders[j].tokenS); // "found sub-ring");\n', '            }\n', '        }\n', '    }\n', "    /// @dev Verify the ringHash has been signed with each order's auth private\n", "    ///      keys as well as the miner's private key.\n", '    function verifyRingSignatures(\n', '        RingParams params,\n', '        OrderState[] orders\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        uint j;\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            j = i + params.ringSize;\n', '            verifySignature(\n', '                orders[i].authAddr,\n', '                params.ringHash,\n', '                params.vList[j],\n', '                params.rList[j],\n', '                params.sList[j]\n', '            );\n', '        }\n', '    }\n', '    function verifyTokensRegistered(\n', '        RingParams params,\n', '        OrderState[] orders\n', '        )\n', '        private\n', '        view\n', '    {\n', '        // Extract the token addresses\n', '        address[] memory tokens = new address[](params.ringSize);\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            tokens[i] = orders[i].tokenS;\n', '        }\n', '        // Test all token addresses at once\n', '        require(\n', '            TokenRegistry(tokenRegistryAddress).areAllTokensRegistered(tokens)\n', '        ); // "token not registered");\n', '    }\n', '    function handleRing(\n', '        uint64       _ringIndex,\n', '        RingParams   params,\n', '        OrderState[] orders,\n', '        TokenTransferDelegate delegate\n', '        )\n', '        private\n', '    {\n', '        address _lrcTokenAddress = lrcTokenAddress;\n', '        // Do the hard work.\n', '        verifyRingHasNoSubRing(params.ringSize, orders);\n', '        // Exchange rates calculation are performed by ring-miners as solidity\n', '        // cannot get power-of-1/n operation, therefore we have to verify\n', '        // these rates are correct.\n', '        verifyMinerSuppliedFillRates(params.ringSize, orders);\n', '        // Scale down each order independently by substracting amount-filled and\n', "        // amount-cancelled. Order owner's current balance and allowance are\n", '        // not taken into consideration in these operations.\n', '        scaleRingBasedOnHistoricalRecords(delegate, params.ringSize, orders);\n', '        // Based on the already verified exchange rate provided by ring-miners,\n', '        // we can furthur scale down orders based on token balance and allowance,\n', "        // then find the smallest order of the ring, then calculate each order's\n", '        // `fillAmountS`.\n', '        calculateRingFillAmount(params.ringSize, orders);\n', "        // Calculate each order's `lrcFee` and `lrcRewrard` and splict how much\n", '        // of `fillAmountS` shall be paid to matching order or miner as margin\n', '        // split.\n', '        calculateRingFees(\n', '            delegate,\n', '            params.ringSize,\n', '            orders,\n', '            params.miner,\n', '            _lrcTokenAddress\n', '        );\n', '        /// Make transfers.\n', '        bytes32[] memory orderInfoList = settleRing(\n', '            delegate,\n', '            params.ringSize,\n', '            orders,\n', '            params.miner,\n', '            _lrcTokenAddress\n', '        );\n', '        emit RingMined(\n', '            _ringIndex,\n', '            params.ringHash,\n', '            params.miner,\n', '            orderInfoList\n', '        );\n', '    }\n', '    function settleRing(\n', '        TokenTransferDelegate delegate,\n', '        uint          ringSize,\n', '        OrderState[]  orders,\n', '        address       miner,\n', '        address       _lrcTokenAddress\n', '        )\n', '        private\n', '        returns (bytes32[] memory orderInfoList)\n', '    {\n', '        bytes32[] memory batch = new bytes32[](ringSize * 7); // ringSize * (owner + tokenS + 4 amounts + wallet)\n', '        bytes32[] memory historyBatch = new bytes32[](ringSize * 2); // ringSize * (orderhash, fillAmount)\n', '        orderInfoList = new bytes32[](ringSize * 7);\n', '        uint p = 0;\n', '        uint q = 0;\n', '        uint r = 0;\n', '        uint prevSplitB = orders[ringSize - 1].splitB;\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            OrderState memory state = orders[i];\n', '            uint nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;\n', '            // Store owner and tokenS of every order\n', '            batch[p++] = bytes32(state.owner);\n', '            batch[p++] = bytes32(state.tokenS);\n', '            // Store all amounts\n', '            batch[p++] = bytes32(state.fillAmountS.sub(prevSplitB));\n', '            batch[p++] = bytes32(prevSplitB.add(state.splitS));\n', '            batch[p++] = bytes32(state.lrcReward);\n', '            batch[p++] = bytes32(state.lrcFeeState);\n', '            batch[p++] = bytes32(state.wallet);\n', '            historyBatch[r++] = state.orderHash;\n', '            historyBatch[r++] = bytes32(\n', '                state.buyNoMoreThanAmountB ? nextFillAmountS : state.fillAmountS);\n', '            orderInfoList[q++] = bytes32(state.orderHash);\n', '            orderInfoList[q++] = bytes32(state.owner);\n', '            orderInfoList[q++] = bytes32(state.tokenS);\n', '            orderInfoList[q++] = bytes32(state.fillAmountS);\n', '            orderInfoList[q++] = bytes32(state.lrcReward);\n', '            orderInfoList[q++] = bytes32(\n', '                state.lrcFeeState > 0 ? int(state.lrcFeeState) : -int(state.lrcReward)\n', '            );\n', '            orderInfoList[q++] = bytes32(\n', '                state.splitS > 0 ? int(state.splitS) : -int(state.splitB)\n', '            );\n', '            prevSplitB = state.splitB;\n', '        }\n', '        // Update fill records\n', '        delegate.batchAddCancelledOrFilled(historyBatch);\n', '        // Do all transactions\n', '        delegate.batchTransferToken(\n', '            _lrcTokenAddress,\n', '            miner,\n', '            walletSplitPercentage,\n', '            batch\n', '        );\n', '    }\n', '    /// @dev Verify miner has calculte the rates correctly.\n', '    function verifyMinerSuppliedFillRates(\n', '        uint         ringSize,\n', '        OrderState[] orders\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        uint[] memory rateRatios = new uint[](ringSize);\n', '        uint _rateRatioScale = RATE_RATIO_SCALE;\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            uint s1b0 = orders[i].rateS.mul(orders[i].amountB);\n', '            uint s0b1 = orders[i].amountS.mul(orders[i].rateB);\n', '            require(s1b0 <= s0b1); // "miner supplied exchange rate provides invalid discount");\n', '            rateRatios[i] = _rateRatioScale.mul(s1b0) / s0b1;\n', '        }\n', '        uint cvs = MathUint.cvsquare(rateRatios, _rateRatioScale);\n', '        require(cvs <= rateRatioCVSThreshold);\n', '        // "miner supplied exchange rate is not evenly discounted");\n', '    }\n', "    /// @dev Calculate each order's fee or LRC reward.\n", '    function calculateRingFees(\n', '        TokenTransferDelegate delegate,\n', '        uint            ringSize,\n', '        OrderState[]    orders,\n', '        address         miner,\n', '        address         _lrcTokenAddress\n', '        )\n', '        private\n', '        view\n', '    {\n', '        bool checkedMinerLrcSpendable = false;\n', '        uint minerLrcSpendable = 0;\n', '        uint8 _marginSplitPercentageBase = MARGIN_SPLIT_PERCENTAGE_BASE;\n', '        uint nextFillAmountS;\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            OrderState memory state = orders[i];\n', '            uint lrcReceiable = 0;\n', '            if (state.lrcFeeState == 0) {\n', "                // When an order's LRC fee is 0 or smaller than the specified fee,\n", '                // we help miner automatically select margin-split.\n', '                state.marginSplitAsFee = true;\n', '                state.marginSplitPercentage = _marginSplitPercentageBase;\n', '            } else {\n', '                uint lrcSpendable = getSpendable(\n', '                    delegate,\n', '                    _lrcTokenAddress,\n', '                    state.owner\n', '                );\n', '                // If the order is selling LRC, we need to calculate how much LRC\n', '                // is left that can be used as fee.\n', '                if (state.tokenS == _lrcTokenAddress) {\n', '                    lrcSpendable = lrcSpendable.sub(state.fillAmountS);\n', '                }\n', '                // If the order is buyign LRC, it will has more to pay as fee.\n', '                if (state.tokenB == _lrcTokenAddress) {\n', '                    nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;\n', '                    lrcReceiable = nextFillAmountS;\n', '                }\n', '                uint lrcTotal = lrcSpendable.add(lrcReceiable);\n', "                // If order doesn't have enough LRC, set margin split to 100%.\n", '                if (lrcTotal < state.lrcFeeState) {\n', '                    state.lrcFeeState = lrcTotal;\n', '                    state.marginSplitPercentage = _marginSplitPercentageBase;\n', '                }\n', '                if (state.lrcFeeState == 0) {\n', '                    state.marginSplitAsFee = true;\n', '                }\n', '            }\n', '            if (!state.marginSplitAsFee) {\n', '                if (lrcReceiable > 0) {\n', '                    if (lrcReceiable >= state.lrcFeeState) {\n', '                        state.splitB = state.lrcFeeState;\n', '                        state.lrcFeeState = 0;\n', '                    } else {\n', '                        state.splitB = lrcReceiable;\n', '                        state.lrcFeeState = state.lrcFeeState.sub(lrcReceiable);\n', '                    }\n', '                }\n', '            } else {\n', '                // Only check the available miner balance when absolutely needed\n', '                if (!checkedMinerLrcSpendable && minerLrcSpendable < state.lrcFeeState) {\n', '                    checkedMinerLrcSpendable = true;\n', '                    minerLrcSpendable = getSpendable(delegate, _lrcTokenAddress, miner);\n', '                }\n', '                // Only calculate split when miner has enough LRC;\n', '                // otherwise all splits are 0.\n', '                if (minerLrcSpendable >= state.lrcFeeState) {\n', '                    nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;\n', '                    uint split;\n', '                    if (state.buyNoMoreThanAmountB) {\n', '                        split = (nextFillAmountS.mul(\n', '                            state.amountS\n', '                        ) / state.amountB).sub(\n', '                            state.fillAmountS\n', '                        );\n', '                    } else {\n', '                        split = nextFillAmountS.sub(\n', '                            state.fillAmountS.mul(\n', '                                state.amountB\n', '                            ) / state.amountS\n', '                        );\n', '                    }\n', '                    if (state.marginSplitPercentage != _marginSplitPercentageBase) {\n', '                        split = split.mul(\n', '                            state.marginSplitPercentage\n', '                        ) / _marginSplitPercentageBase;\n', '                    }\n', '                    if (state.buyNoMoreThanAmountB) {\n', '                        state.splitS = split;\n', '                    } else {\n', '                        state.splitB = split;\n', '                    }\n', '                    // This implicits order with smaller index in the ring will\n', '                    // be paid LRC reward first, so the orders in the ring does\n', '                    // mater.\n', '                    if (split > 0) {\n', '                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFeeState);\n', '                        state.lrcReward = state.lrcFeeState;\n', '                    }\n', '                }\n', '                state.lrcFeeState = 0;\n', '            }\n', '        }\n', '    }\n', "    /// @dev Calculate each order's fill amount.\n", '    function calculateRingFillAmount(\n', '        uint          ringSize,\n', '        OrderState[]  orders\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        uint smallestIdx = 0;\n', '        uint i;\n', '        uint j;\n', '        for (i = 0; i < ringSize; i++) {\n', '            j = (i + 1) % ringSize;\n', '            smallestIdx = calculateOrderFillAmount(\n', '                orders[i],\n', '                orders[j],\n', '                i,\n', '                j,\n', '                smallestIdx\n', '            );\n', '        }\n', '        for (i = 0; i < smallestIdx; i++) {\n', '            calculateOrderFillAmount(\n', '                orders[i],\n', '                orders[(i + 1) % ringSize],\n', '                0,               // Not needed\n', '                0,               // Not needed\n', '                0                // Not needed\n', '            );\n', '        }\n', '    }\n', "    /// @return The smallest order's index.\n", '    function calculateOrderFillAmount(\n', '        OrderState state,\n', '        OrderState next,\n', '        uint       i,\n', '        uint       j,\n', '        uint       smallestIdx\n', '        )\n', '        private\n', '        pure\n', '        returns (uint newSmallestIdx)\n', '    {\n', '        // Default to the same smallest index\n', '        newSmallestIdx = smallestIdx;\n', '        uint fillAmountB = state.fillAmountS.mul(\n', '            state.rateB\n', '        ) / state.rateS;\n', '        if (state.buyNoMoreThanAmountB) {\n', '            if (fillAmountB > state.amountB) {\n', '                fillAmountB = state.amountB;\n', '                state.fillAmountS = fillAmountB.mul(\n', '                    state.rateS\n', '                ) / state.rateB;\n', '                require(state.fillAmountS > 0);\n', '                newSmallestIdx = i;\n', '            }\n', '            state.lrcFeeState = state.lrcFee.mul(\n', '                fillAmountB\n', '            ) / state.amountB;\n', '        } else {\n', '            state.lrcFeeState = state.lrcFee.mul(\n', '                state.fillAmountS\n', '            ) / state.amountS;\n', '        }\n', '        if (fillAmountB <= next.fillAmountS) {\n', '            next.fillAmountS = fillAmountB;\n', '        } else {\n', '            newSmallestIdx = j;\n', '        }\n', '    }\n', '    /// @dev Scale down all orders based on historical fill or cancellation\n', "    ///      stats but key the order's original exchange rate.\n", '    function scaleRingBasedOnHistoricalRecords(\n', '        TokenTransferDelegate delegate,\n', '        uint ringSize,\n', '        OrderState[] orders\n', '        )\n', '        private\n', '        view\n', '    {\n', '        for (uint i = 0; i < ringSize; i++) {\n', '            OrderState memory state = orders[i];\n', '            uint amount;\n', '            if (state.buyNoMoreThanAmountB) {\n', '                amount = state.amountB.tolerantSub(\n', '                    delegate.cancelledOrFilled(state.orderHash)\n', '                );\n', '                state.amountS = amount.mul(state.amountS) / state.amountB;\n', '                state.lrcFee = amount.mul(state.lrcFee) / state.amountB;\n', '                state.amountB = amount;\n', '            } else {\n', '                amount = state.amountS.tolerantSub(\n', '                    delegate.cancelledOrFilled(state.orderHash)\n', '                );\n', '                state.amountB = amount.mul(state.amountB) / state.amountS;\n', '                state.lrcFee = amount.mul(state.lrcFee) / state.amountS;\n', '                state.amountS = amount;\n', '            }\n', '            require(state.amountS > 0); // "amountS is zero");\n', '            require(state.amountB > 0); // "amountB is zero");\n', '            uint availableAmountS = getSpendable(delegate, state.tokenS, state.owner);\n', '            require(availableAmountS > 0); // "order spendable amountS is zero");\n', '            state.fillAmountS = (\n', '                state.amountS < availableAmountS ?\n', '                state.amountS : availableAmountS\n', '            );\n', '            require(state.fillAmountS > 0);\n', '        }\n', '    }\n', '    /// @return Amount of ERC20 token that can be spent by this contract.\n', '    function getSpendable(\n', '        TokenTransferDelegate delegate,\n', '        address tokenAddress,\n', '        address tokenOwner\n', '        )\n', '        private\n', '        view\n', '        returns (uint)\n', '    {\n', '        ERC20 token = ERC20(tokenAddress);\n', '        uint allowance = token.allowance(\n', '            tokenOwner,\n', '            address(delegate)\n', '        );\n', '        uint balance = token.balanceOf(tokenOwner);\n', '        return (allowance < balance ? allowance : balance);\n', '    }\n', "    /// @dev verify input data's basic integrity.\n", '    function verifyInputDataIntegrity(\n', '        RingParams params,\n', '        address[4][]  addressList,\n', '        uint[6][]     uintArgsList,\n', '        uint8[1][]    uint8ArgsList,\n', '        bool[]        buyNoMoreThanAmountBList\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        require(params.miner != 0x0);\n', '        require(params.ringSize == addressList.length);\n', '        require(params.ringSize == uintArgsList.length);\n', '        require(params.ringSize == uint8ArgsList.length);\n', '        require(params.ringSize == buyNoMoreThanAmountBList.length);\n', '        // Validate ring-mining related arguments.\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            require(uintArgsList[i][5] > 0); // "order rateAmountS is zero");\n', '        }\n', '        //Check ring size\n', '        require(params.ringSize > 1 && params.ringSize <= MAX_RING_SIZE); // "invalid ring size");\n', '        uint sigSize = params.ringSize << 1;\n', '        require(sigSize == params.vList.length);\n', '        require(sigSize == params.rList.length);\n', '        require(sigSize == params.sList.length);\n', '    }\n', '    /// @dev        assmble order parameters into Order struct.\n', '    /// @return     A list of orders.\n', '    function assembleOrders(\n', '        RingParams params,\n', '        TokenTransferDelegate delegate,\n', '        address[4][]  addressList,\n', '        uint[6][]     uintArgsList,\n', '        uint8[1][]    uint8ArgsList,\n', '        bool[]        buyNoMoreThanAmountBList\n', '        )\n', '        private\n', '        view\n', '        returns (OrderState[] memory orders)\n', '    {\n', '        orders = new OrderState[](params.ringSize);\n', '        for (uint i = 0; i < params.ringSize; i++) {\n', '            uint[6] memory uintArgs = uintArgsList[i];\n', '            bool marginSplitAsFee = (params.feeSelections & (uint16(1) << i)) > 0;\n', '            orders[i] = OrderState(\n', '                addressList[i][0],\n', '                addressList[i][1],\n', '                addressList[(i + 1) % params.ringSize][1],\n', '                addressList[i][2],\n', '                addressList[i][3],\n', '                uintArgs[2],\n', '                uintArgs[3],\n', '                uintArgs[0],\n', '                uintArgs[1],\n', '                uintArgs[4],\n', '                buyNoMoreThanAmountBList[i],\n', '                marginSplitAsFee,\n', '                bytes32(0),\n', '                uint8ArgsList[i][0],\n', '                uintArgs[5],\n', '                uintArgs[1],\n', '                0,   // fillAmountS\n', '                0,   // lrcReward\n', '                0,   // lrcFee\n', '                0,   // splitS\n', '                0    // splitB\n', '            );\n', '            validateOrder(orders[i]);\n', '            bytes32 orderHash = calculateOrderHash(orders[i]);\n', '            orders[i].orderHash = orderHash;\n', '            verifySignature(\n', '                orders[i].owner,\n', '                orderHash,\n', '                params.vList[i],\n', '                params.rList[i],\n', '                params.sList[i]\n', '            );\n', '            params.ringHash ^= orderHash;\n', '        }\n', '        validateOrdersCutoffs(orders, delegate);\n', '        params.ringHash = keccak256(\n', '            params.ringHash,\n', '            params.miner,\n', '            params.feeSelections\n', '        );\n', '    }\n', "    /// @dev validate order's parameters are OK.\n", '    function validateOrder(\n', '        OrderState order\n', '        )\n', '        private\n', '        view\n', '    {\n', '        require(order.owner != 0x0); // invalid order owner\n', '        require(order.tokenS != 0x0); // invalid order tokenS\n', '        require(order.tokenB != 0x0); // invalid order tokenB\n', '        require(order.amountS != 0); // invalid order amountS\n', '        require(order.amountB != 0); // invalid order amountB\n', '        require(order.marginSplitPercentage <= MARGIN_SPLIT_PERCENTAGE_BASE);\n', '        // invalid order marginSplitPercentage\n', '        require(order.validSince <= block.timestamp); // order is too early to match\n', '        require(order.validUntil > block.timestamp); // order is expired\n', '    }\n', '    function validateOrdersCutoffs(OrderState[] orders, TokenTransferDelegate delegate)\n', '        private\n', '        view\n', '    {\n', '        address[] memory owners = new address[](orders.length);\n', '        bytes20[] memory tradingPairs = new bytes20[](orders.length);\n', '        uint[] memory validSinceTimes = new uint[](orders.length);\n', '        for (uint i = 0; i < orders.length; i++) {\n', '            owners[i] = orders[i].owner;\n', '            tradingPairs[i] = bytes20(orders[i].tokenS) ^ bytes20(orders[i].tokenB);\n', '            validSinceTimes[i] = orders[i].validSince;\n', '        }\n', '        delegate.checkCutoffsBatch(owners, tradingPairs, validSinceTimes);\n', '    }\n', '    /// @dev Get the Keccak-256 hash of order with specified parameters.\n', '    function calculateOrderHash(\n', '        OrderState order\n', '        )\n', '        private\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            delegateAddress,\n', '            order.owner,\n', '            order.tokenS,\n', '            order.tokenB,\n', '            order.wallet,\n', '            order.authAddr,\n', '            order.amountS,\n', '            order.amountB,\n', '            order.validSince,\n', '            order.validUntil,\n', '            order.lrcFee,\n', '            order.buyNoMoreThanAmountB,\n', '            order.marginSplitPercentage\n', '        );\n', '    }\n', "    /// @dev Verify signer's signature.\n", '    function verifySignature(\n', '        address signer,\n', '        bytes32 hash,\n', '        uint8   v,\n', '        bytes32 r,\n', '        bytes32 s\n', '        )\n', '        private\n', '        pure\n', '    {\n', '        require(\n', '            signer == ecrecover(\n', '                keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '                v,\n', '                r,\n', '                s\n', '            )\n', '        ); // "invalid signature");\n', '    }\n', '    function getTradingPairCutoffs(\n', '        address orderOwner,\n', '        address token1,\n', '        address token2\n', '        )\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        bytes20 tokenPair = bytes20(token1) ^ bytes20(token2);\n', '        TokenTransferDelegate delegate = TokenTransferDelegate(delegateAddress);\n', '        return delegate.tradingPairCutoffs(orderOwner, tokenPair);\n', '    }\n', '}']
