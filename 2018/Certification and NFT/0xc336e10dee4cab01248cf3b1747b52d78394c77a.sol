['/**\n', ' * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n', ' *\n', ' * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n', ' * \n', ' ** Code Modified by : TokenMagic\n', ' ** Change Log: \n', ' *** Solidity version upgraded from 0.4.8 to 0.4.23\n', ' *** Functions Added: setPresaleParticipantWhitelist, setFreezeEnd, getInvestorsCount\n', ' */\n', '\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract HoardCrowdsale {\n', '    function invest(address addr,uint tokenAmount) public payable {\n', '    }\n', '}\n', 'library SafeMathLib {\n', '\n', '  function times(uint a, uint b) public pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  \n', '}\n', '\n', '\n', 'contract HoardPresale is Ownable {\n', '\n', '  using SafeMathLib for uint;\n', '  \n', '  /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */\n', '  mapping (address => bool) public presaleParticipantWhitelist;\n', '  \n', '  /** Who are our investors */\n', '  address[] public investors;\n', '  mapping (address => bool) private investorsMapping;\n', '\n', '  /** How much they have invested */\n', '  mapping(address => uint) public balances;\n', '  \n', '  /** A mapping of buyers and their amounts of total tokens due */\n', '  mapping(address => uint256) public tokenDue;\n', '\n', '  /** When our refund freeze is over (UNIX timestamp) */\n', '  uint public freezeEndsAt;\n', '  \n', '  /* How many wei of funding pre-sale have raised */\n', '  uint public weiRaised = 0;\n', '\n', '  /** Maximum pre-sale ETH fund limit in Wei  */\n', '  uint public maxFundLimit = 5333000000000000000000; //5333 ETH\n', '  \n', '  /** Our ICO contract where we will move the funds */\n', '  HoardCrowdsale public crowdsale;\n', '\n', '  /**\n', '  * Define pricing schedule using tranches.\n', '  */\n', '  struct Tranche {\n', '    // Amount in weis when this tranche becomes active\n', '    uint amount;\n', '    // How many tokens per satoshi you will get while this tranche is active\n', '    uint price;\n', '  }\n', '  \n', '  // Store tranches in a fixed array, so that it can be seen in a blockchain explorer\n', '  // Tranche 0 is always (0, 0)\n', '  // (TODO: change this when we confirm dynamic arrays are explorable)\n', '  //\n', '  /* Calculations made by $500/ETH as rate */\n', '  /*\n', '  0 to 114 ETH = 120000000000000 WEI = 0.00012 ETH\n', '  114 ETH to 10000 ETH = 142857142857500 WEI = 0.0001428571428575 ETH\n', '  10000 ETH to 14000 ETH = 200000000000000 WEI = 0.0002 ETH\n', '  */\n', '  Tranche[10] public tranches;\n', '\n', '  // How many active tranches we have\n', '  uint public trancheCount;\n', '  uint public constant MAX_TRANCHES = 10;\n', '  uint public tokenDecimals = 18;\n', '  \n', '  event Invested(address investor, uint value);\n', '  event Refunded(address investor, uint value);\n', '  \n', '  //Event to show whitelisted address\n', '  event Whitelisted(address[] addr, bool status);\n', '  \n', '  //Event to show when freezeends data changed\n', '  event FreezeEndChanged(uint newFreezeEnd);\n', '  \n', '  //Event to show crowdsale address changes\n', '  event CrowdsaleAdded(address newCrowdsale);\n', '  \n', '  /**\n', '   * Create presale contract\n', '   */\n', '   \n', '  constructor(address _owner, uint _freezeEndsAt) public {\n', '    require(_owner != address(0) && _freezeEndsAt != 0);\n', '    owner = _owner;\n', '    freezeEndsAt = _freezeEndsAt;\n', '  }\n', '\n', '  /**\n', '   * Receive funds for presale\n', '   * Modified by: TokenMagic\n', '   */\n', '   \n', '  function() public payable {  \n', '    // Only Whitelisted addresses can contribute\n', '    require(presaleParticipantWhitelist[msg.sender]);\n', '    require(trancheCount > 0);\n', '    \n', '    address investor = msg.sender;\n', '\n', '    bool existing = investorsMapping[investor];\n', '\n', '    balances[investor] = balances[investor].add(msg.value);\n', '    weiRaised = weiRaised.add(msg.value);\n', '    require(weiRaised <= maxFundLimit);\n', '    \n', '    uint weiAmount = msg.value;\n', '    uint tokenAmount = calculatePrice(weiAmount);\n', '    \n', '    // Add the amount of tokens they are now due to total tally\n', '    tokenDue[investor] = tokenDue[investor].add(tokenAmount);\n', '        \n', '    if(!existing) {\n', '      investors.push(investor);\n', '      investorsMapping[investor] = true;\n', '    }\n', '\n', '    emit Invested(investor, msg.value);\n', '  }\n', '  \n', '  /**\n', '   * Add KYC whitelisted pre-sale participant ETH addresses to contract.\n', '   * Added by: TokenMagic\n', '   */\n', '  function setPresaleParticipantWhitelist(address[] addr, bool status) public onlyOwner {\n', '    for(uint i = 0; i < addr.length; i++ ){\n', '      presaleParticipantWhitelist[addr[i]] = status;\n', '    }\n', '    emit Whitelisted(addr, status);\n', '  }\n', '    \n', '   /**\n', '   * Allow owner to set freezeEndsAt (Timestamp).\n', '   * Added by: TokenMagic\n', '   */\n', '  function setFreezeEnd(uint _freezeEndsAt) public onlyOwner {\n', '    require(_freezeEndsAt != 0);\n', '    freezeEndsAt = _freezeEndsAt;\n', '    emit FreezeEndChanged(freezeEndsAt);\n', '  }  \n', '    \n', '  /**\n', "   * Move single pre-sale participant's fund to the crowdsale contract.\n", '   * Modified by: TokenMagic\n', '   */\n', '  function participateCrowdsaleInvestor(address investor) public onlyOwner {\n', '\n', '    // Crowdsale not yet set\n', '    require(address(crowdsale) != 0);\n', '\n', '    if(balances[investor] > 0) {\n', '      uint amount = balances[investor];\n', '      uint tokenAmount = tokenDue[investor];\n', '      delete balances[investor];\n', '      delete tokenDue[investor];\n', '      crowdsale.invest.value(amount)(investor,tokenAmount);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Move all pre-sale participants fund to the crowdsale contract.\n', '   *\n', '   */\n', '  function participateCrowdsaleAll() public onlyOwner {\n', '    // We might hit a max gas limit in this loop,\n', '    // and in this case you can simply call participateCrowdsaleInvestor() for all investors\n', '    for(uint i = 0; i < investors.length; i++) {\n', '      participateCrowdsaleInvestor(investors[i]);\n', '    }\n', '  }\n', '  \n', '  /**\n', '   * Move selected pre-sale participants fund to the crowdsale contract.\n', '   *\n', '   */\n', '  function participateCrowdsaleSelected(address[] addr) public onlyOwner {\n', '    for(uint i = 0; i < addr.length; i++ ){\n', '      participateCrowdsaleInvestor(investors[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * ICO never happened. Allow refund.\n', '   * Modified by: TokenMagic\n', '   */\n', '  function refund() public {\n', '\n', '    // Trying to ask refund too soon\n', '    require(now > freezeEndsAt && balances[msg.sender] > 0);\n', '\n', '    address investor = msg.sender;\n', '    uint amount = balances[investor];\n', '    delete balances[investor];\n', '    emit Refunded(investor, amount);\n', '    investor.transfer(amount);\n', '  }\n', '\n', '  /**\n', '   * Set the crowdsale contract address, where we will move presale funds when the crowdsale opens.\n', '   */\n', '  function setCrowdsale(HoardCrowdsale _crowdsale) public onlyOwner {\n', '    crowdsale = _crowdsale;\n', '    emit CrowdsaleAdded(crowdsale);\n', '  }\n', '\n', '  /**\n', '  * Get total investors count\n', '  * Added by: TokenMagic\n', '  */ \n', '  function getInvestorsCount() public view returns(uint investorsCount) {\n', '    return investors.length;\n', '  }\n', '  \n', '  /// @dev Contruction, creating a list of tranches\n', '  /// @param _tranches uint[] tranches Pairs of (start amount, price)\n', '  function setPricing(uint[] _tranches) public onlyOwner {\n', '    // Need to have tuples, length check\n', '    if(_tranches.length % 2 == 1 || _tranches.length >= MAX_TRANCHES*2) {\n', '      revert();\n', '    }\n', '\n', '    trancheCount = _tranches.length / 2;\n', '\n', '    uint highestAmount = 0;\n', '\n', '    for(uint i=0; i<_tranches.length/2; i++) {\n', '      tranches[i].amount = _tranches[i*2];\n', '      tranches[i].price = _tranches[i*2+1];\n', '\n', '      // No invalid steps\n', '      if((highestAmount != 0) && (tranches[i].amount <= highestAmount)) {\n', '        revert();\n', '      }\n', '\n', '      highestAmount = tranches[i].amount;\n', '    }\n', '\n', '    // We need to start from zero, otherwise we blow up our deployment\n', '    if(tranches[0].amount != 0) {\n', '      revert();\n', '    }\n', '\n', '    // Last tranche price must be zero, terminating the crowdale\n', '    if(tranches[trancheCount-1].price != 0) {\n', '      revert();\n', '    }\n', '  }\n', '  \n', '  /// @dev Get the current tranche or bail out if we are not in the tranche periods.\n', '  /// @return {[type]} [description]\n', '  function getCurrentTranche() private view returns (Tranche) {\n', '    uint i;\n', '\n', '    for(i=0; i < tranches.length; i++) {\n', '      if(weiRaised <= tranches[i].amount) {\n', '        return tranches[i-1];\n', '      }\n', '    }\n', '  }\n', '  \n', '  /// @dev Get the current price.\n', '  /// @return The current price or 0 if we are outside trache ranges\n', '  function getCurrentPrice() public view returns (uint result) {\n', '    return getCurrentTranche().price;\n', '  }\n', '  \n', '  /// @dev Calculate the current price for buy in amount.\n', '  function calculatePrice(uint value) public view returns (uint) {\n', '    uint multiplier = 10 ** tokenDecimals;\n', '    uint price = getCurrentPrice();\n', '    return value.times(multiplier) / price;\n', '  }\n', '  \n', '  /// @dev Iterate through tranches. You reach end of tranches when price = 0\n', '  /// @return tuple (time, price)\n', '  function getTranche(uint n) public view returns (uint, uint) {\n', '    return (tranches[n].amount, tranches[n].price);\n', '  }\n', '\n', '  function getFirstTranche() private view returns (Tranche) {\n', '    return tranches[0];\n', '  }\n', '\n', '  function getLastTranche() private view returns (Tranche) {\n', '    return tranches[trancheCount-1];\n', '  }\n', '\n', '  function getPricingStartsAt() public view returns (uint) {\n', '    return getFirstTranche().amount;\n', '  }\n', '\n', '  function getPricingEndsAt() public view returns (uint) {\n', '    return getLastTranche().amount;\n', '  }\n', '  \n', '}']