['pragma solidity ^0.4.21;\n', '\n', 'contract SafeMath {\n', '    \n', '    uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        require(x <= MAX_UINT256 - y);\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        require(x >= y);\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        if (y == 0) {\n', '            return 0;\n', '        }\n', '        require(x <= (MAX_UINT256 / y));\n', '        return x * y;\n', '    }\n', '}\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', 'contract IERC20Token {\n', '\n', '    /// @return total amount of tokens\n', '    function totalSupply() constant returns (uint256 supply) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}   \n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract CreditGAMEInterface {\n', '    function isGameApproved(address _gameAddress) view public returns(bool);\n', '    function createLock(address _winner, uint _totalParticipationAmount, uint _tokenLockDuration) public;\n', '    function removeFailedGame() public;\n', '    function removeLock() public;\n', '    function cleanUp() public;\n', '    function checkIfLockCanBeRemoved(address _gameAddress) public view returns(bool);\n', '}\n', '\n', '\n', 'contract LuckyTree is Owned, SafeMath{\n', '    \n', '    uint public leafPrice;\n', '    uint public gameStart;\n', '    uint public gameDuration;\n', '    uint public tokenLockDuration;\n', '    uint public totalParticipationAmount;\n', '    uint public totalLockedAmount;\n', '    uint public numberOfLeafs;\n', '    uint public participantIndex;\n', '    bool public fundsTransfered;\n', '    address public winner;\n', '    mapping(uint => address) public participants;\n', '    mapping(uint => uint) public participationAmount;\n', '    mapping(address => bool) public hasParticipated;\n', '    mapping(address => bool) public hasWithdrawn;\n', '    mapping(address => uint) public participantIndexes;\n', '    mapping(uint => address) public leafOwners;\n', '    \n', '    event GameWinner(address winner);\n', '    event GameEnded(uint block);\n', '    event GameStarted(uint block);\n', '    event GameFailed(uint block);\n', '    event GameLocked(uint block);\n', '    event GameUnlocked(uint block);\n', '    \n', '    enum state{\n', '        pending,\n', '        running,\n', '        paused,\n', '        finished,\n', '        closed,\n', '        claimed\n', '    }\n', '    \n', '    state public gameState;\n', '    \n', '    //SET BEFORE DEPLOY\n', '    address public tokenAddress = 0xfc6b46d20584a7f736c0d9084ab8b1a8e8c01a38;\n', '    address public creditGameAddress = 0x7f135d5d5c1d2d44cf6abb7d09735466ba474799;\n', '\n', '    /**\n', '     *leafPrice = price in crb for one leafPrice\n', '     * _gamestart = block.number when the game _gamestart\n', '     * _gameduration = block.number when game ends\n', '     * _tokenLockDuration = number of block for when the tokens are locked\n', '     */\n', '    function LuckyTree(\n', '        uint _leafPrice,\n', '        uint _gameStart,\n', '        uint _gameDuration,\n', '        uint _tokenLockDuration) public{\n', '        \n', '        leafPrice = _leafPrice;\n', '        gameStart = _gameStart;\n', '        gameDuration = _gameDuration;\n', '        tokenLockDuration = _tokenLockDuration;\n', '        \n', '        gameState = state.pending;\n', '        totalParticipationAmount = 0;\n', '        numberOfLeafs = 0;\n', '        participantIndex = 0;\n', '        fundsTransfered = false;\n', '        winner = 0x0;\n', '    }\n', '    \n', '    /**\n', '     * Generate random winner.\n', '     * \n', '     **/\n', '    function random() internal view returns(uint){\n', '        return uint(keccak256(block.number, block.difficulty, numberOfLeafs));\n', '    }\n', '    \n', '    /**\n', '     * Set token address.\n', '     * \n', '     **/\n', '    function setTokenAddress(address _tokenAddress) public onlyOwner{\n', '        tokenAddress = _tokenAddress;\n', '    }\n', '    \n', '    /**\n', '     * Set game address.\n', '     * \n', '     **/\n', '    function setCreditGameAddress(address _creditGameAddress) public onlyOwner{\n', '        creditGameAddress = _creditGameAddress;\n', '    }\n', '    \n', '    /**\n', '     * Method called when game ends. \n', '     * Check that more than 1 wallet contributed\n', '     **/\n', '    function pickWinner() internal{\n', '        if(numberOfLeafs > 0){\n', '            if(participantIndex == 1){\n', '                //a single account contributed - just transfer funds back\n', '                IERC20Token(tokenAddress).transfer(leafOwners[0], totalParticipationAmount);\n', '                hasWithdrawn[leafOwners[0]] = true;\n', '                CreditGAMEInterface(creditGameAddress).removeFailedGame();\n', '                emit GameFailed(block.number);\n', '            }else{\n', '                uint leafOwnerIndex = random() % numberOfLeafs;\n', '                winner = leafOwners[leafOwnerIndex];\n', '                emit GameWinner(winner);\n', '                lockFunds(winner);\n', '                \n', '            }\n', '        }\n', '        gameState = state.closed;\n', '    }\n', '    \n', '    /**\n', '     * Method called when winner is picked\n', '     * Funds are transferred to game contract and lock is created by calling game contract\n', '     **/\n', '    function lockFunds(address _winner) internal{\n', '        require(totalParticipationAmount != 0);\n', '        //transfer and lock tokens on game contract\n', '        IERC20Token(tokenAddress).transfer(creditGameAddress, totalParticipationAmount);\n', '        CreditGAMEInterface(creditGameAddress).createLock(_winner, totalParticipationAmount, tokenLockDuration);\n', '        totalLockedAmount = totalParticipationAmount;\n', '        emit GameLocked(block.number);\n', '    }\n', '    \n', '    /**\n', '     * Method for manually Locking fiunds\n', '     **/\n', '    function manualLockFunds() public onlyOwner{\n', '        require(totalParticipationAmount != 0);\n', '        require(CreditGAMEInterface(creditGameAddress).isGameApproved(address(this)) == true);\n', '        require(gameState == state.closed);\n', '        //pick winner\n', '        pickWinner();\n', '    }\n', '    \n', '    /**\n', '     * To manually allow game locking\n', '     */\n', '    function closeGame() public onlyOwner{\n', '        gameState = state.closed;\n', '    }\n', '    \n', '    /**\n', '     * Method called by participants to unlock and transfer their funds \n', '     * First call to method transfers tokens from game contract to this contractÄ‘\n', '     * Last call to method cleans up the game contract\n', '     **/\n', '    function unlockFunds() public {\n', '        require(gameState == state.closed);\n', '        require(hasParticipated[msg.sender] == true);\n', '        require(hasWithdrawn[msg.sender] == false);\n', '        \n', '        if(fundsTransfered == false){\n', '            require(CreditGAMEInterface(creditGameAddress).checkIfLockCanBeRemoved(address(this)) == true);\n', '            CreditGAMEInterface(creditGameAddress).removeLock();\n', '            fundsTransfered = true;\n', '            emit GameUnlocked(block.number);\n', '        }\n', '        \n', '        hasWithdrawn[msg.sender] = true;\n', '        uint index = participantIndexes[msg.sender];\n', '        uint amount = participationAmount[index];\n', '        IERC20Token(tokenAddress).transfer(msg.sender, amount);\n', '        totalLockedAmount = IERC20Token(tokenAddress).balanceOf(address(this));\n', '        if(totalLockedAmount == 0){\n', '            gameState = state.claimed;\n', '            CreditGAMEInterface(creditGameAddress).cleanUp();\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Check internall balance of this.\n', '     * \n', '     **/\n', '    function checkInternalBalance() public view returns(uint256 tokenBalance) {\n', '        return IERC20Token(tokenAddress).balanceOf(address(this));\n', '    }\n', '    \n', '    /**\n', '     * Implemented token interface to transfer tokens to this.\n', '     * \n', '     **/\n', '    function receiveApproval(address _from, uint256 _value, address _to, bytes _extraData) public {\n', '        require(_to == tokenAddress);\n', '        require(_value == leafPrice);\n', '        require(gameState != state.closed);\n', '        //check if game approved;\n', '        require(CreditGAMEInterface(creditGameAddress).isGameApproved(address(this)) == true);\n', '\n', '        uint tokensToTake = processTransaction(_from, _value);\n', '        IERC20Token(tokenAddress).transferFrom(_from, address(this), tokensToTake);\n', '    }\n', '\n', '    /**\n', '     * Calibrate game state and take tokens.\n', '     * \n', '     **/\n', '    function processTransaction(address _from, uint _value) internal returns (uint) {\n', '        require(gameStart <= block.number);\n', '        \n', '        uint valueToProcess = 0;\n', '        \n', '        if(gameStart <= block.number && gameDuration >= block.number){\n', '            if(gameState != state.running){\n', '                gameState = state.running;\n', '                emit GameStarted(block.number);\n', '            }\n', '            // take tokens\n', '            leafOwners[numberOfLeafs] = _from;\n', '            numberOfLeafs++;\n', '            totalParticipationAmount += _value;\n', '            \n', '            //check if contributed before\n', '            if(hasParticipated[_from] == false){\n', '                hasParticipated[_from] = true;\n', '                \n', '                participants[participantIndex] = _from;\n', '                participationAmount[participantIndex] = _value;\n', '                participantIndexes[_from] = participantIndex;\n', '                participantIndex++;\n', '            }else{\n', '                uint index = participantIndexes[_from];\n', '                participationAmount[index] = participationAmount[index] + _value;\n', '            }\n', '            \n', '            valueToProcess = _value;\n', '            return valueToProcess;\n', '        //If block.number over game duration, pick winner\n', '        }else if(gameDuration < block.number){\n', '            gameState = state.finished;\n', '            pickWinner();\n', '            return valueToProcess;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Return all variables needed for dapp in a single call\n', '     * \n', '     **/\n', '    function getVariablesForDapp() public view returns(uint, uint, uint, uint, uint, uint, state){\n', '      return(leafPrice, gameStart, gameDuration, tokenLockDuration, totalParticipationAmount, numberOfLeafs, gameState);\n', '    }\n', '\n', '    /**\n', '     * Manually send tokens to this.\n', '     * \n', '     **/\n', '    function manuallyProcessTransaction(address _from, uint _value) onlyOwner public {\n', '        require(_value == leafPrice);\n', '        require(IERC20Token(tokenAddress).balanceOf(address(this)) >= _value + totalParticipationAmount);\n', '\n', '        if(gameState == state.running && block.number < gameDuration){\n', '            uint tokensToTake = processTransaction(_from, _value);\n', '            IERC20Token(tokenAddress).transferFrom(_from, address(this), tokensToTake);\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '     * Salvage tokens from this.\n', '     * \n', '     **/\n', '    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n', '        require(_tokenAddress != tokenAddress);\n', '        IERC20Token(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '\n', '    /**\n', '     * Kill contract if needed\n', '     * \n', '     **/\n', '    function killContract() onlyOwner public {\n', '      selfdestruct(owner);\n', '    }\n', '}']