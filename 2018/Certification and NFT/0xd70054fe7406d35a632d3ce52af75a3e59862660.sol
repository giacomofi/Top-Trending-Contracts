['pragma solidity ^0.4.23;\n', '\n', '/* Controls state and access rights for contract functions\n', ' * @title Operational Control\n', ' * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\n', ' * Inspired and adapted from contract created by OpenZeppelin\n', ' * Ref: https://github.com/OpenZeppelin/zeppelin-solidity/\n', ' */\n', 'contract OperationalControl {\n', '    // Facilitates access & control for the game.\n', '    // Roles:\n', '    //  -The Managers (Primary/Secondary): Has universal control of all elements (No ability to withdraw)\n', '    //  -The Banker: The Bank can withdraw funds and adjust fees / prices.\n', '    //  -otherManagers: Contracts that need access to functions for gameplay\n', '\n', '    /// @dev Emited when contract is upgraded\n', '    event ContractUpgrade(address newContract);\n', '\n', '    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public managerPrimary;\n', '    address public managerSecondary;\n', '    address public bankManager;\n', '\n', '    // Contracts that require access for gameplay\n', '    mapping(address => uint8) public otherManagers;\n', '\n', '    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused = false;\n', '\n', '    // @dev Keeps track whether the contract erroredOut. When that is true, most actions are blocked & refund can be claimed\n', '    bool public error = false;\n', '\n', '    /// @dev Operation modifiers for limiting access\n', '    modifier onlyManager() {\n', '        require(msg.sender == managerPrimary || msg.sender == managerSecondary);\n', '        _;\n', '    }\n', '\n', '    modifier onlyBanker() {\n', '        require(msg.sender == bankManager);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOtherManagers() {\n', '        require(otherManagers[msg.sender] == 1);\n', '        _;\n', '    }\n', '\n', '\n', '    modifier anyOperator() {\n', '        require(\n', '            msg.sender == managerPrimary ||\n', '            msg.sender == managerSecondary ||\n', '            msg.sender == bankManager ||\n', '            otherManagers[msg.sender] == 1\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Other Manager. (State = 1 is active, 0 is disabled)\n', '    function setOtherManager(address _newOp, uint8 _state) external onlyManager {\n', '        require(_newOp != address(0));\n', '\n', '        otherManagers[_newOp] = _state;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Primary Manager.\n', '    function setPrimaryManager(address _newGM) external onlyManager {\n', '        require(_newGM != address(0));\n', '\n', '        managerPrimary = _newGM;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Secondary Manager.\n', '    function setSecondaryManager(address _newGM) external onlyManager {\n', '        require(_newGM != address(0));\n', '\n', '        managerSecondary = _newGM;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Banker.\n', '    function setBanker(address _newBK) external onlyManager {\n', '        require(_newBK != address(0));\n', '\n', '        bankManager = _newBK;\n', '    }\n', '\n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract has Error\n', '    modifier whenError {\n', '        require(error);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any Operator role to pause the contract.\n', '    /// Used only if a bug or exploit is discovered (Here to limit losses / damage)\n', '    function pause() external onlyManager whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the Game Master\n', '    /// @notice This is public rather than external so it can be called by derived contracts. \n', '    function unpause() public onlyManager whenPaused {\n', '        // can&#39;t unpause if contract was upgraded\n', '        paused = false;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the Game Master\n', '    /// @notice This is public rather than external so it can be called by derived contracts. \n', '    function hasError() public onlyManager whenPaused {\n', '        error = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the Game Master\n', '    /// @notice This is public rather than external so it can be called by derived contracts. \n', '    function noError() public onlyManager whenPaused {\n', '        error = false;\n', '    }\n', '}\n', '\n', 'contract CCNFTFactory {\n', '\n', '   \n', '    /** Public Functions */\n', '\n', '    function getAssetDetails(uint256 _assetId) public view returns(\n', '        uint256 assetId,\n', '        uint256 ownersIndex,\n', '        uint256 assetTypeSeqId,\n', '        uint256 assetType,\n', '        uint256 createdTimestamp,\n', '        uint256 isAttached,\n', '        address creator,\n', '        address owner\n', '    );\n', '\n', '    function getAssetDetailsURI(uint256 _assetId) public view returns(\n', '        uint256 assetId,\n', '        uint256 ownersIndex,\n', '        uint256 assetTypeSeqId,\n', '        uint256 assetType,\n', '        uint256 createdTimestamp,\n', '        uint256 isAttached,\n', '        address creator,\n', '        address owner,\n', '        string metaUriAddress\n', '    );\n', '\n', '    function getAssetRawMeta(uint256 _assetId) public view returns(\n', '        uint256 dataA,\n', '        uint128 dataB\n', '    );\n', '\n', '    function getAssetIdItemType(uint256 _assetId) public view returns(\n', '        uint256 assetType\n', '    );\n', '\n', '    function getAssetIdTypeSequenceId(uint256 _assetId) public view returns(\n', '        uint256 assetTypeSequenceId\n', '    );\n', '    \n', '    function getIsNFTAttached( uint256 _tokenId) \n', '    public view returns(\n', '        uint256 isAttached\n', '    );\n', '\n', '    function getAssetIdCreator(uint256 _assetId) public view returns(\n', '        address creator\n', '    );\n', '    function getAssetIdOwnerAndOIndex(uint256 _assetId) public view returns(\n', '        address owner,\n', '        uint256 ownerIndex\n', '    );\n', '    function getAssetIdOwnerIndex(uint256 _assetId) public view returns(\n', '        uint256 ownerIndex\n', '    );\n', '\n', '    function getAssetIdOwner(uint256 _assetId) public view returns(\n', '        address owner\n', '    );\n', '\n', '    function spawnAsset(address _to, uint256 _assetType, uint256 _assetID, uint256 _isAttached) public;\n', '\n', '    function isAssetIdOwnerOrApproved(address requesterAddress, uint256 _assetId) public view returns(\n', '        bool\n', '    );\n', '    /// @param _owner The owner whose ships tokens we are interested in.\n', '    /// @dev This method MUST NEVER be called by smart contract code. First, it&#39;s fairly\n', '    ///  expensive (it walks the entire NFT owners array looking for NFT belonging to owner),\n', '    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '    ///  not contract-to-contract calls.\n', '    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens);\n', '    // Get the name of the Asset type\n', '    function getTypeName (uint32 _type) public returns(string);\n', '    function RequestDetachment(\n', '        uint256 _tokenId\n', '    )\n', '        public;\n', '    function AttachAsset(\n', '        uint256 _tokenId\n', '    )\n', '        public;\n', '    function BatchAttachAssets(uint256[10] _ids) public;\n', '    function BatchDetachAssets(uint256[10] _ids) public;\n', '    function RequestDetachmentOnPause (uint256 _tokenId) public;\n', '    function burnAsset(uint256 _assetID) public;\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '    function exists(uint256 _tokenId) public view returns (bool _exists);\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function getApproved(uint256 _tokenId)\n', '        public view returns (address _operator);\n', '    function setApprovalForAll(address _operator, bool _approved) public;\n', '    function isApprovedForAll(address _owner, address _operator)\n', '        public view returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function safeTransferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId,\n', '        bytes _data\n', '    )\n', '        public;\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' *  from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver {\n', '    /**\n', '    * @dev Magic value to be returned upon successful reception of an NFT\n', '    *  Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`,\n', '    *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '    */\n', '    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '    /**\n', '    * @notice Handle the receipt of an NFT\n', '    * @dev The ERC721 smart contract calls this function on the recipient\n', '    *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '    *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    *  than the magic value MUST result in the transaction being reverted.\n', '    *  Note: the contract address is always the message sender.\n', '    * @param _from The sending address\n', '    * @param _tokenId The NFT identifier which is being transfered\n', '    * @param _data Additional data with no specified format\n', '    * @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '    */\n', '    function onERC721Received(\n', '        address _from,\n', '        uint256 _tokenId,\n', '        bytes _data\n', '    )\n', '        public\n', '        returns(bytes4);\n', '}\n', 'contract ERC721Holder is ERC721Receiver {\n', '    function onERC721Received(address, uint256, bytes) public returns(bytes4) {\n', '        return ERC721_RECEIVED;\n', '    }\n', '}\n', '\n', 'contract CCTimeSaleManager is ERC721Holder, OperationalControl {\n', '    //DATATYPES & CONSTANTS\n', '    struct CollectibleSale {\n', '        // Current owner of NFT (ERC721)\n', '        address seller;\n', '        // Price (in wei) at beginning of sale (For Buying)\n', '        uint256 startingPrice;\n', '        // Price (in wei) at end of sale (For Buying)\n', '        uint256 endingPrice;\n', '        // Duration (in seconds) of sale, 2592000 = 30 days\n', '        uint256 duration;\n', '        // Time when sale started\n', '        // NOTE: 0 if this sale has been concluded\n', '        uint64 startedAt;\n', '        // Flag denoting is the Sale still active\n', '        bool isActive;\n', '        // address of the wallet who bought the asset\n', '        address buyer;\n', '        // ERC721 AssetID\n', '        uint256 tokenId;\n', '    }\n', '    struct PastSales {\n', '        uint256[5] sales;\n', '    }\n', '\n', '    // CCNTFAddress\n', '    address public NFTAddress;\n', '\n', '    // Map from token to their corresponding sale.\n', '    mapping (uint256 => CollectibleSale) public tokenIdToSale;\n', '\n', '    // Count of AssetType Sales\n', '    mapping (uint256 => uint256) public assetTypeSaleCount;\n', '\n', '    // Last 5 Prices of AssetType Sales\n', '    mapping (uint256 => PastSales) internal assetTypeSalePrices;\n', '\n', '    uint256 public avgSalesToCount = 5;\n', '\n', '    // type to sales of type\n', '    mapping(uint256 => uint256[]) public assetTypeSalesTokenId;\n', '\n', '    event SaleWinner(address owner, uint256 collectibleId, uint256 buyingPrice);\n', '    event SaleCreated(uint256 tokenID, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint64 startedAt);\n', '    event SaleCancelled(address seller, uint256 collectibleId);\n', '\n', '    // If > 0 then vending is enable for item type\n', '    mapping (uint256 => uint256) internal vendingAmountType;\n', '\n', '    // If > 0 then vending is enable for item type\n', '    mapping (uint256 => uint256) internal vendingTypeSold;\n', '\n', '    // Current Price for vending type \n', '    mapping (uint256 => uint256) internal vendingPrice;\n', '\n', '    // Price to step up for vending type\n', '    mapping (uint256 => uint256) internal vendingStepUpAmount;\n', '\n', '    // Qty to step up vending item\n', '    mapping (uint256 => uint256) internal vendingStepUpQty;\n', '\n', '    uint256 public startingIndex = 100000;\n', '\n', '    uint256 public vendingAttachedState = 1;\n', '\n', '\n', '    constructor() public {\n', '        require(msg.sender != address(0));\n', '        paused = true;\n', '        error = false;\n', '        managerPrimary = msg.sender;\n', '        managerSecondary = msg.sender;\n', '        bankManager = msg.sender;\n', '    }\n', '\n', '    function  setNFTAddress(address _address) public onlyManager {\n', '        NFTAddress = _address;\n', '    }\n', '\n', '    function setAvgSalesCount(uint256 _count) public onlyManager  {\n', '        avgSalesToCount = _count;\n', '    }\n', '\n', '    /// @dev Creates and begins a new sale.\n', '    function CreateSale(uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint64 _duration, address _seller) public anyOperator {\n', '        _createSale(_tokenId, _startingPrice, _endingPrice, _duration, _seller);\n', '    }\n', '\n', '    function BatchCreateSales(uint256[] _tokenIds, uint256 _startingPrice, uint256 _endingPrice, uint64 _duration, address _seller) public anyOperator {\n', '        uint256 _tokenId;\n', '        for (uint256 i = 0; i < _tokenIds.length; ++i) {\n', '            _tokenId = _tokenIds[i];\n', '            _createSale(_tokenId, _startingPrice, _endingPrice, _duration, _seller);\n', '        }\n', '    }\n', '\n', '    function CreateSaleAvgPrice(uint256 _tokenId, uint256 _margin, uint _minPrice, uint256 _endingPrice, uint64 _duration, address _seller) public anyOperator {\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '        uint256 assetType = ccNFT.getAssetIdItemType(_tokenId);\n', '        // Avg Price of last sales\n', '        uint256 salePrice = GetAssetTypeAverageSalePrice(assetType);\n', '\n', '        //  0-10,000 is mapped to 0%-100% - will be typically 12000 or 120%\n', '        salePrice = salePrice * _margin / 10000;\n', '\n', '        if(salePrice < _minPrice) {\n', '            salePrice = _minPrice;\n', '        } \n', '       \n', '        _createSale(_tokenId, salePrice, _endingPrice, _duration, _seller);\n', '    }\n', '\n', '    function BatchCreateSaleAvgPrice(uint256[] _tokenIds, uint256 _margin, uint _minPrice, uint256 _endingPrice, uint64 _duration, address _seller) public anyOperator {\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '        uint256 assetType;\n', '        uint256 _tokenId;\n', '        uint256 salePrice;\n', '        for (uint256 i = 0; i < _tokenIds.length; ++i) {\n', '            _tokenId = _tokenIds[i];\n', '            assetType = ccNFT.getAssetIdItemType(_tokenId);\n', '            // Avg Price of last sales\n', '            salePrice = GetAssetTypeAverageSalePrice(assetType);\n', '\n', '            //  0-10,000 is mapped to 0%-100% - will be typically 12000 or 120%\n', '            salePrice = salePrice * _margin / 10000;\n', '\n', '            if(salePrice < _minPrice) {\n', '                salePrice = _minPrice;\n', '            } \n', '            \n', '            _tokenId = _tokenIds[i];\n', '            _createSale(_tokenId, salePrice, _endingPrice, _duration, _seller);\n', '        }\n', '    }\n', '\n', '    function BatchCancelSales(uint256[] _tokenIds) public anyOperator {\n', '        uint256 _tokenId;\n', '        for (uint256 i = 0; i < _tokenIds.length; ++i) {\n', '            _tokenId = _tokenIds[i];\n', '            _cancelSale(_tokenId);\n', '        }\n', '    }\n', '\n', '    function CancelSale(uint256 _assetId) public anyOperator {\n', '        _cancelSale(_assetId);\n', '    }\n', '\n', '    function GetCurrentSalePrice(uint256 _assetId) external view returns(uint256 _price) {\n', '        CollectibleSale memory _sale = tokenIdToSale[_assetId];\n', '        \n', '        return _currentPrice(_sale);\n', '    }\n', '\n', '    function GetCurrentTypeSalePrice(uint256 _assetType) external view returns(uint256 _price) {\n', '        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\n', '        return _currentPrice(_sale);\n', '    }\n', '\n', '    function GetCurrentTypeDuration(uint256 _assetType) external view returns(uint256 _duration) {\n', '        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\n', '        return  _sale.duration;\n', '    }\n', '\n', '    function GetCurrentTypeStartTime(uint256 _assetType) external view returns(uint256 _startedAt) {\n', '        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\n', '        return  _sale.startedAt;\n', '    }\n', '\n', '    function GetCurrentTypeSaleItem(uint256 _assetType) external view returns(address seller, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt, uint256 tokenId) {\n', '        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\n', '        return (\n', '            _sale.seller,\n', '            _sale.startingPrice,\n', '            _sale.endingPrice,\n', '            _sale.duration,\n', '            _sale.startedAt,\n', '            _sale.tokenId\n', '        );\n', '    }\n', '\n', '    function GetCurrentTypeSaleCount(uint256 _assetType) external view returns(uint256 _count) {\n', '        return assetTypeSalesTokenId[_assetType].length;\n', '    }\n', '\n', '    function BuyCurrentTypeOfAsset(uint256 _assetType) external whenNotPaused payable {\n', '        require(msg.sender != address(0));\n', '        require(msg.sender != address(this));\n', '\n', '        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\n', '        require(_isOnSale(_sale));\n', '\n', '        _buy(_sale.tokenId, msg.sender, msg.value);\n', '    }\n', '\n', '    /// @dev BuyNow Function which call the interncal buy function\n', '    /// after doing all the pre-checks required to initiate a buy\n', '    function BuyAsset(uint256 _assetId) external whenNotPaused payable {\n', '        require(msg.sender != address(0));\n', '        require(msg.sender != address(this));\n', '        CollectibleSale memory _sale = tokenIdToSale[_assetId];\n', '        require(_isOnSale(_sale));\n', '        \n', '        //address seller = _sale.seller;\n', '\n', '        _buy(_assetId, msg.sender, msg.value);\n', '    }\n', '\n', '    function GetAssetTypeAverageSalePrice(uint256 _assetType) public view returns (uint256) {\n', '        uint256 sum = 0;\n', '        for (uint256 i = 0; i < avgSalesToCount; i++) {\n', '            sum += assetTypeSalePrices[_assetType].sales[i];\n', '        }\n', '        return sum / 5;\n', '    }\n', '\n', '    /// @dev Override unpause so it requires all external contract addresses\n', '    ///  to be set before contract can be unpaused. Also, we can&#39;t have\n', '    ///  newContractAddress set either, because then the contract was upgraded.\n', '    /// @notice This is public rather than external so we can call super.unpause\n', '    ///  without using an expensive CALL.\n', '    function unpause() public anyOperator whenPaused {\n', '        // Actually unpause the contract.\n', '        super.unpause();\n', '    }\n', '\n', '    /// @dev Remove all Ether from the contract, which is the owner&#39;s cuts\n', '    ///  as well as any Ether sent directly to the contract address.\n', '    ///  Always transfers to the NFT (ERC721) contract, but can be called either by\n', '    ///  the owner or the NFT (ERC721) contract.\n', '    function withdrawBalance() public onlyBanker {\n', '        // We are using this boolean method to make sure that even if one fails it will still work\n', '        bankManager.transfer(address(this).balance);\n', '    }\n', '\n', '    /// @dev Returns sales info for an CSLCollectibles (ERC721) on sale.\n', '    /// @param _assetId - ID of the token on sale\n', '    function getSale(uint256 _assetId) external view returns (address seller, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt, bool isActive, address buyer, uint256 tokenId) {\n', '        CollectibleSale memory sale = tokenIdToSale[_assetId];\n', '        require(_isOnSale(sale));\n', '        return (\n', '            sale.seller,\n', '            sale.startingPrice,\n', '            sale.endingPrice,\n', '            sale.duration,\n', '            sale.startedAt,\n', '            sale.isActive,\n', '            sale.buyer,\n', '            sale.tokenId\n', '        );\n', '    }\n', '\n', '\n', '    /** Internal Functions */\n', '\n', '    function _createSale(uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint64 _duration, address _seller) internal {\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '\n', '        require(ccNFT.isAssetIdOwnerOrApproved(this, _tokenId) == true);\n', '        \n', '        CollectibleSale memory onSale = tokenIdToSale[_tokenId];\n', '        require(onSale.isActive == false);\n', '\n', '        // Sanity check that no inputs overflow how many bits we&#39;ve allocated\n', '        // to store them in the sale struct.\n', '        require(_startingPrice == uint256(uint128(_startingPrice)));\n', '        require(_endingPrice == uint256(uint128(_endingPrice)));\n', '        require(_duration == uint256(uint64(_duration)));\n', '\n', '        //Transfer ownership if needed\n', '        if(ccNFT.ownerOf(_tokenId) != address(this)) {\n', '            \n', '            require(ccNFT.isApprovedForAll(msg.sender, this) == true);\n', '\n', '            ccNFT.safeTransferFrom(ccNFT.ownerOf(_tokenId), this, _tokenId);\n', '        }\n', '\n', '        CollectibleSale memory sale = CollectibleSale(\n', '            _seller,\n', '            uint128(_startingPrice),\n', '            uint128(_endingPrice),\n', '            uint64(_duration),\n', '            uint64(now),\n', '            true,\n', '            address(0),\n', '            uint256(_tokenId)\n', '        );\n', '        _addSale(_tokenId, sale);\n', '    }\n', '\n', '    /// @dev Adds an sale to the list of open sales. Also fires the\n', '    ///  SaleCreated event.\n', '    function _addSale(uint256 _assetId, CollectibleSale _sale) internal {\n', '        // Require that all sales have a duration of\n', '        // at least one minute.\n', '        require(_sale.duration >= 1 minutes);\n', '        \n', '        tokenIdToSale[_assetId] = _sale;\n', '\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '        uint256 assetType = ccNFT.getAssetIdItemType(_assetId);\n', '        assetTypeSalesTokenId[assetType].push(_assetId);\n', '\n', '        SaleCreated(\n', '            uint256(_assetId),\n', '            uint256(_sale.startingPrice),\n', '            uint256(_sale.endingPrice),\n', '            uint256(_sale.duration),\n', '            uint64(_sale.startedAt)\n', '        );\n', '    }\n', '\n', '    /// @dev Returns current price of a Collectible (ERC721) on sale. Broken into two\n', '    ///  functions (this one, that computes the duration from the sale\n', '    ///  structure, and the other that does the price computation) so we\n', '    ///  can easily test that the price computation works correctly.\n', '    function _currentPrice(CollectibleSale memory _sale) internal view returns (uint256) {\n', '        uint256 secondsPassed = 0;\n', '\n', '        // A bit of insurance against negative values (or wraparound).\n', '        // Probably not necessary (since Ethereum guarnatees that the\n', '        // now variable doesn&#39;t ever go backwards).\n', '        if (now > _sale.startedAt) {\n', '            secondsPassed = now - _sale.startedAt;\n', '        }\n', '\n', '        return _computeCurrentPrice(\n', '            _sale.startingPrice,\n', '            _sale.endingPrice,\n', '            _sale.duration,\n', '            secondsPassed\n', '        );\n', '    }\n', '\n', '    /// @dev Computes the current price of an sale. Factored out\n', '    ///  from _currentPrice so we can run extensive unit tests.\n', '    ///  When testing, make this function public and turn on\n', '    ///  `Current price computation` test suite.\n', '    function _computeCurrentPrice(uint256 _startingPrice, uint256 _endingPrice, uint256 _duration, uint256 _secondsPassed) internal pure returns (uint256) {\n', '        // NOTE: We don&#39;t use SafeMath (or similar) in this function because\n', '        //  all of our public functions carefully cap the maximum values for\n', '        //  time (at 64-bits) and currency (at 128-bits). _duration is\n', '        //  also known to be non-zero (see the require() statement in\n', '        //  _addSale())\n', '        if (_secondsPassed >= _duration) {\n', '            // We&#39;ve reached the end of the dynamic pricing portion\n', '            // of the sale, just return the end price.\n', '            return _endingPrice;\n', '        } else {\n', '            // Starting price can be higher than ending price (and often is!), so\n', '            // this delta can be negative.\n', '            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\n', '\n', '            // This multiplication can&#39;t overflow, _secondsPassed will easily fit within\n', '            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\n', '            // will always fit within 256-bits.\n', '            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\n', '\n', '            // currentPriceChange can be negative, but if so, will have a magnitude\n', '            // less that _startingPrice. Thus, this result will always end up positive.\n', '            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\n', '\n', '            return uint256(currentPrice);\n', '        }\n', '    }\n', '\n', '    function _buy(uint256 _assetId, address _buyer, uint256 _price) internal {\n', '\n', '        CollectibleSale storage _sale = tokenIdToSale[_assetId];\n', '\n', '        // Check that the bid is greater than or equal to the current buyOut price\n', '        uint256 currentPrice = _currentPrice(_sale);\n', '\n', '        require(_price >= currentPrice);\n', '        _sale.buyer = _buyer;\n', '        _sale.isActive = false;\n', '\n', '        _removeSale(_assetId);\n', '\n', '        uint256 bidExcess = _price - currentPrice;\n', '        _buyer.transfer(bidExcess);\n', '\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '        uint256 assetType = ccNFT.getAssetIdItemType(_assetId);\n', '        _updateSaleAvgHistory(assetType, _price);\n', '        ccNFT.safeTransferFrom(this, _buyer, _assetId);\n', '\n', '        emit SaleWinner(_buyer, _assetId, _price);\n', '    }\n', '\n', '    function _cancelSale (uint256 _assetId) internal {\n', '        CollectibleSale storage _sale = tokenIdToSale[_assetId];\n', '\n', '        require(_sale.isActive == true);\n', '\n', '        address sellerAddress = _sale.seller;\n', '\n', '        _removeSale(_assetId);\n', '\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '\n', '        ccNFT.safeTransferFrom(this, sellerAddress, _assetId);\n', '\n', '        emit SaleCancelled(sellerAddress, _assetId);\n', '    }\n', '    \n', '    /// @dev Returns true if the FT (ERC721) is on sale.\n', '    function _isOnSale(CollectibleSale memory _sale) internal view returns (bool) {\n', '        return (_sale.startedAt > 0 && _sale.isActive);\n', '    }\n', '\n', '    function _updateSaleAvgHistory(uint256 _assetType, uint256 _price) internal {\n', '        assetTypeSaleCount[_assetType] += 1;\n', '        assetTypeSalePrices[_assetType].sales[assetTypeSaleCount[_assetType] % avgSalesToCount] = _price;\n', '    }\n', '\n', '    /// @dev Removes an sale from the list of open sales.\n', '    /// @param _assetId - ID of the token on sale\n', '    function _removeSale(uint256 _assetId) internal {\n', '        delete tokenIdToSale[_assetId];\n', '\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '        uint256 assetType = ccNFT.getAssetIdItemType(_assetId);\n', '\n', '        bool hasFound = false;\n', '        for (uint i = 0; i < assetTypeSalesTokenId[assetType].length; i++) {\n', '            if ( assetTypeSalesTokenId[assetType][i] == _assetId) {\n', '                hasFound = true;\n', '            }\n', '            if(hasFound == true) {\n', '                if(i+1 < assetTypeSalesTokenId[assetType].length)\n', '                    assetTypeSalesTokenId[assetType][i] = assetTypeSalesTokenId[assetType][i+1];\n', '                else \n', '                    delete assetTypeSalesTokenId[assetType][i];\n', '            }\n', '        }\n', '        assetTypeSalesTokenId[assetType].length--;\n', '    }\n', '\n', '\n', '    // Vending\n', '\n', '    function setVendingAttachedState (uint256 _collectibleType, uint256 _state) external onlyManager {\n', '        vendingAttachedState = _state;\n', '    }\n', '\n', '    /// @dev Function toggle vending for collectible\n', '    function setVendingAmount (uint256 _collectibleType, uint256 _vendingQty) external onlyManager {\n', '        vendingAmountType[_collectibleType] = _vendingQty;\n', '    }\n', '\n', '    /// @dev Function sets the starting price / reset price\n', '    function setVendingStartPrice (uint256 _collectibleType, uint256 _startingPrice) external onlyManager {\n', '        vendingPrice[_collectibleType] = _startingPrice;\n', '    }\n', '\n', '    /// @dev Sets Step Value\n', '    function setVendingStepValues(uint256 _collectibleType, uint256 _stepAmount, uint256 _stepQty) external onlyManager {\n', '        vendingStepUpQty[_collectibleType] = _stepQty;\n', '        vendingStepUpAmount[_collectibleType] = _stepAmount;\n', '    }\n', '\n', '    /// @dev Create Vending Helper\n', '    function createVendingItem(uint256 _collectibleType, uint256 _vendingQty, uint256 _startingPrice, uint256 _stepAmount, uint256 _stepQty) external onlyManager {\n', '        vendingAmountType[_collectibleType] = _vendingQty;\n', '        vendingPrice[_collectibleType] = _startingPrice;\n', '        vendingStepUpQty[_collectibleType] = _stepQty;\n', '        vendingStepUpAmount[_collectibleType] = _stepAmount;\n', '    }\n', '\n', '    /// @dev This helps in creating a collectible and then \n', '    /// transfer it _toAddress\n', '    function vendingCreateCollectible(uint256 _collectibleType, address _toAddress) payable external whenNotPaused {\n', '        \n', '        //Only if Vending is Allowed for this Asset\n', '        require((vendingAmountType[_collectibleType] - vendingTypeSold[_collectibleType]) > 0);\n', '\n', '        require(msg.value >= vendingPrice[_collectibleType]);\n', '\n', '        require(msg.sender != address(0));\n', '        require(msg.sender != address(this));\n', '        \n', '        require(_toAddress != address(0));\n', '        require(_toAddress != address(this));\n', '\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '\n', '        ccNFT.spawnAsset(_toAddress, _collectibleType, startingIndex, vendingAttachedState);\n', '\n', '        startingIndex += 1;\n', '\n', '        vendingTypeSold[_collectibleType] += 1;\n', '\n', '        uint256 excessBid = msg.value - vendingPrice[_collectibleType];\n', '\n', '        if(vendingTypeSold[_collectibleType] % vendingStepUpQty[_collectibleType] == 0) {\n', '            vendingPrice[_collectibleType] += vendingStepUpAmount[_collectibleType];\n', '        }\n', '\n', '        if(excessBid > 0) {\n', '            msg.sender.transfer(excessBid);\n', '        }\n', ' \n', '    }\n', '\n', '    function getVendingAmountLeft (uint256 _collectibleType) view public returns (uint256) {\n', '        return (vendingAmountType[_collectibleType] - vendingTypeSold[_collectibleType]);\n', '    }\n', '\n', '    function getVendingAmountSold (uint256 _collectibleType) view public returns (uint256) {\n', '        return (vendingTypeSold[_collectibleType]);\n', '    }\n', '\n', '    function getVendingPrice (uint256 _collectibleType) view public returns (uint256) {\n', '        return (vendingPrice[_collectibleType]);\n', '    }\n', '\n', '    function getVendingStepPrice (uint256 _collectibleType) view public returns (uint256) {\n', '        return (vendingStepUpAmount[_collectibleType]);\n', '    }\n', '\n', '    function getVendingStepQty (uint256 _collectibleType) view public returns (uint256) {\n', '        return (vendingStepUpQty[_collectibleType]);\n', '    }\n', '\n', '    function getVendingInfo (uint256 _collectibleType) view public returns (uint256 amountRemaining, uint256 sold, uint256 price, uint256 stepPrice, uint256 stepQty) {\n', '        amountRemaining = (vendingAmountType[_collectibleType] - vendingTypeSold[_collectibleType]);\n', '        sold = vendingTypeSold[_collectibleType];\n', '        price = vendingPrice[_collectibleType];\n', '        stepPrice = vendingStepUpAmount[_collectibleType];\n', '        stepQty = vendingStepUpQty[_collectibleType];\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/* Controls state and access rights for contract functions\n', ' * @title Operational Control\n', ' * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\n', ' * Inspired and adapted from contract created by OpenZeppelin\n', ' * Ref: https://github.com/OpenZeppelin/zeppelin-solidity/\n', ' */\n', 'contract OperationalControl {\n', '    // Facilitates access & control for the game.\n', '    // Roles:\n', '    //  -The Managers (Primary/Secondary): Has universal control of all elements (No ability to withdraw)\n', '    //  -The Banker: The Bank can withdraw funds and adjust fees / prices.\n', '    //  -otherManagers: Contracts that need access to functions for gameplay\n', '\n', '    /// @dev Emited when contract is upgraded\n', '    event ContractUpgrade(address newContract);\n', '\n', '    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public managerPrimary;\n', '    address public managerSecondary;\n', '    address public bankManager;\n', '\n', '    // Contracts that require access for gameplay\n', '    mapping(address => uint8) public otherManagers;\n', '\n', '    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused = false;\n', '\n', '    // @dev Keeps track whether the contract erroredOut. When that is true, most actions are blocked & refund can be claimed\n', '    bool public error = false;\n', '\n', '    /// @dev Operation modifiers for limiting access\n', '    modifier onlyManager() {\n', '        require(msg.sender == managerPrimary || msg.sender == managerSecondary);\n', '        _;\n', '    }\n', '\n', '    modifier onlyBanker() {\n', '        require(msg.sender == bankManager);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOtherManagers() {\n', '        require(otherManagers[msg.sender] == 1);\n', '        _;\n', '    }\n', '\n', '\n', '    modifier anyOperator() {\n', '        require(\n', '            msg.sender == managerPrimary ||\n', '            msg.sender == managerSecondary ||\n', '            msg.sender == bankManager ||\n', '            otherManagers[msg.sender] == 1\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Other Manager. (State = 1 is active, 0 is disabled)\n', '    function setOtherManager(address _newOp, uint8 _state) external onlyManager {\n', '        require(_newOp != address(0));\n', '\n', '        otherManagers[_newOp] = _state;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Primary Manager.\n', '    function setPrimaryManager(address _newGM) external onlyManager {\n', '        require(_newGM != address(0));\n', '\n', '        managerPrimary = _newGM;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Secondary Manager.\n', '    function setSecondaryManager(address _newGM) external onlyManager {\n', '        require(_newGM != address(0));\n', '\n', '        managerSecondary = _newGM;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Banker.\n', '    function setBanker(address _newBK) external onlyManager {\n', '        require(_newBK != address(0));\n', '\n', '        bankManager = _newBK;\n', '    }\n', '\n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract has Error\n', '    modifier whenError {\n', '        require(error);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any Operator role to pause the contract.\n', '    /// Used only if a bug or exploit is discovered (Here to limit losses / damage)\n', '    function pause() external onlyManager whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the Game Master\n', '    /// @notice This is public rather than external so it can be called by derived contracts. \n', '    function unpause() public onlyManager whenPaused {\n', "        // can't unpause if contract was upgraded\n", '        paused = false;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the Game Master\n', '    /// @notice This is public rather than external so it can be called by derived contracts. \n', '    function hasError() public onlyManager whenPaused {\n', '        error = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the Game Master\n', '    /// @notice This is public rather than external so it can be called by derived contracts. \n', '    function noError() public onlyManager whenPaused {\n', '        error = false;\n', '    }\n', '}\n', '\n', 'contract CCNFTFactory {\n', '\n', '   \n', '    /** Public Functions */\n', '\n', '    function getAssetDetails(uint256 _assetId) public view returns(\n', '        uint256 assetId,\n', '        uint256 ownersIndex,\n', '        uint256 assetTypeSeqId,\n', '        uint256 assetType,\n', '        uint256 createdTimestamp,\n', '        uint256 isAttached,\n', '        address creator,\n', '        address owner\n', '    );\n', '\n', '    function getAssetDetailsURI(uint256 _assetId) public view returns(\n', '        uint256 assetId,\n', '        uint256 ownersIndex,\n', '        uint256 assetTypeSeqId,\n', '        uint256 assetType,\n', '        uint256 createdTimestamp,\n', '        uint256 isAttached,\n', '        address creator,\n', '        address owner,\n', '        string metaUriAddress\n', '    );\n', '\n', '    function getAssetRawMeta(uint256 _assetId) public view returns(\n', '        uint256 dataA,\n', '        uint128 dataB\n', '    );\n', '\n', '    function getAssetIdItemType(uint256 _assetId) public view returns(\n', '        uint256 assetType\n', '    );\n', '\n', '    function getAssetIdTypeSequenceId(uint256 _assetId) public view returns(\n', '        uint256 assetTypeSequenceId\n', '    );\n', '    \n', '    function getIsNFTAttached( uint256 _tokenId) \n', '    public view returns(\n', '        uint256 isAttached\n', '    );\n', '\n', '    function getAssetIdCreator(uint256 _assetId) public view returns(\n', '        address creator\n', '    );\n', '    function getAssetIdOwnerAndOIndex(uint256 _assetId) public view returns(\n', '        address owner,\n', '        uint256 ownerIndex\n', '    );\n', '    function getAssetIdOwnerIndex(uint256 _assetId) public view returns(\n', '        uint256 ownerIndex\n', '    );\n', '\n', '    function getAssetIdOwner(uint256 _assetId) public view returns(\n', '        address owner\n', '    );\n', '\n', '    function spawnAsset(address _to, uint256 _assetType, uint256 _assetID, uint256 _isAttached) public;\n', '\n', '    function isAssetIdOwnerOrApproved(address requesterAddress, uint256 _assetId) public view returns(\n', '        bool\n', '    );\n', '    /// @param _owner The owner whose ships tokens we are interested in.\n', "    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\n", '    ///  expensive (it walks the entire NFT owners array looking for NFT belonging to owner),\n', '    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '    ///  not contract-to-contract calls.\n', '    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens);\n', '    // Get the name of the Asset type\n', '    function getTypeName (uint32 _type) public returns(string);\n', '    function RequestDetachment(\n', '        uint256 _tokenId\n', '    )\n', '        public;\n', '    function AttachAsset(\n', '        uint256 _tokenId\n', '    )\n', '        public;\n', '    function BatchAttachAssets(uint256[10] _ids) public;\n', '    function BatchDetachAssets(uint256[10] _ids) public;\n', '    function RequestDetachmentOnPause (uint256 _tokenId) public;\n', '    function burnAsset(uint256 _assetID) public;\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '    function exists(uint256 _tokenId) public view returns (bool _exists);\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function getApproved(uint256 _tokenId)\n', '        public view returns (address _operator);\n', '    function setApprovalForAll(address _operator, bool _approved) public;\n', '    function isApprovedForAll(address _owner, address _operator)\n', '        public view returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function safeTransferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId,\n', '        bytes _data\n', '    )\n', '        public;\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' *  from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver {\n', '    /**\n', '    * @dev Magic value to be returned upon successful reception of an NFT\n', '    *  Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`,\n', '    *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '    */\n', '    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '    /**\n', '    * @notice Handle the receipt of an NFT\n', '    * @dev The ERC721 smart contract calls this function on the recipient\n', '    *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '    *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    *  than the magic value MUST result in the transaction being reverted.\n', '    *  Note: the contract address is always the message sender.\n', '    * @param _from The sending address\n', '    * @param _tokenId The NFT identifier which is being transfered\n', '    * @param _data Additional data with no specified format\n', '    * @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '    */\n', '    function onERC721Received(\n', '        address _from,\n', '        uint256 _tokenId,\n', '        bytes _data\n', '    )\n', '        public\n', '        returns(bytes4);\n', '}\n', 'contract ERC721Holder is ERC721Receiver {\n', '    function onERC721Received(address, uint256, bytes) public returns(bytes4) {\n', '        return ERC721_RECEIVED;\n', '    }\n', '}\n', '\n', 'contract CCTimeSaleManager is ERC721Holder, OperationalControl {\n', '    //DATATYPES & CONSTANTS\n', '    struct CollectibleSale {\n', '        // Current owner of NFT (ERC721)\n', '        address seller;\n', '        // Price (in wei) at beginning of sale (For Buying)\n', '        uint256 startingPrice;\n', '        // Price (in wei) at end of sale (For Buying)\n', '        uint256 endingPrice;\n', '        // Duration (in seconds) of sale, 2592000 = 30 days\n', '        uint256 duration;\n', '        // Time when sale started\n', '        // NOTE: 0 if this sale has been concluded\n', '        uint64 startedAt;\n', '        // Flag denoting is the Sale still active\n', '        bool isActive;\n', '        // address of the wallet who bought the asset\n', '        address buyer;\n', '        // ERC721 AssetID\n', '        uint256 tokenId;\n', '    }\n', '    struct PastSales {\n', '        uint256[5] sales;\n', '    }\n', '\n', '    // CCNTFAddress\n', '    address public NFTAddress;\n', '\n', '    // Map from token to their corresponding sale.\n', '    mapping (uint256 => CollectibleSale) public tokenIdToSale;\n', '\n', '    // Count of AssetType Sales\n', '    mapping (uint256 => uint256) public assetTypeSaleCount;\n', '\n', '    // Last 5 Prices of AssetType Sales\n', '    mapping (uint256 => PastSales) internal assetTypeSalePrices;\n', '\n', '    uint256 public avgSalesToCount = 5;\n', '\n', '    // type to sales of type\n', '    mapping(uint256 => uint256[]) public assetTypeSalesTokenId;\n', '\n', '    event SaleWinner(address owner, uint256 collectibleId, uint256 buyingPrice);\n', '    event SaleCreated(uint256 tokenID, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint64 startedAt);\n', '    event SaleCancelled(address seller, uint256 collectibleId);\n', '\n', '    // If > 0 then vending is enable for item type\n', '    mapping (uint256 => uint256) internal vendingAmountType;\n', '\n', '    // If > 0 then vending is enable for item type\n', '    mapping (uint256 => uint256) internal vendingTypeSold;\n', '\n', '    // Current Price for vending type \n', '    mapping (uint256 => uint256) internal vendingPrice;\n', '\n', '    // Price to step up for vending type\n', '    mapping (uint256 => uint256) internal vendingStepUpAmount;\n', '\n', '    // Qty to step up vending item\n', '    mapping (uint256 => uint256) internal vendingStepUpQty;\n', '\n', '    uint256 public startingIndex = 100000;\n', '\n', '    uint256 public vendingAttachedState = 1;\n', '\n', '\n', '    constructor() public {\n', '        require(msg.sender != address(0));\n', '        paused = true;\n', '        error = false;\n', '        managerPrimary = msg.sender;\n', '        managerSecondary = msg.sender;\n', '        bankManager = msg.sender;\n', '    }\n', '\n', '    function  setNFTAddress(address _address) public onlyManager {\n', '        NFTAddress = _address;\n', '    }\n', '\n', '    function setAvgSalesCount(uint256 _count) public onlyManager  {\n', '        avgSalesToCount = _count;\n', '    }\n', '\n', '    /// @dev Creates and begins a new sale.\n', '    function CreateSale(uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint64 _duration, address _seller) public anyOperator {\n', '        _createSale(_tokenId, _startingPrice, _endingPrice, _duration, _seller);\n', '    }\n', '\n', '    function BatchCreateSales(uint256[] _tokenIds, uint256 _startingPrice, uint256 _endingPrice, uint64 _duration, address _seller) public anyOperator {\n', '        uint256 _tokenId;\n', '        for (uint256 i = 0; i < _tokenIds.length; ++i) {\n', '            _tokenId = _tokenIds[i];\n', '            _createSale(_tokenId, _startingPrice, _endingPrice, _duration, _seller);\n', '        }\n', '    }\n', '\n', '    function CreateSaleAvgPrice(uint256 _tokenId, uint256 _margin, uint _minPrice, uint256 _endingPrice, uint64 _duration, address _seller) public anyOperator {\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '        uint256 assetType = ccNFT.getAssetIdItemType(_tokenId);\n', '        // Avg Price of last sales\n', '        uint256 salePrice = GetAssetTypeAverageSalePrice(assetType);\n', '\n', '        //  0-10,000 is mapped to 0%-100% - will be typically 12000 or 120%\n', '        salePrice = salePrice * _margin / 10000;\n', '\n', '        if(salePrice < _minPrice) {\n', '            salePrice = _minPrice;\n', '        } \n', '       \n', '        _createSale(_tokenId, salePrice, _endingPrice, _duration, _seller);\n', '    }\n', '\n', '    function BatchCreateSaleAvgPrice(uint256[] _tokenIds, uint256 _margin, uint _minPrice, uint256 _endingPrice, uint64 _duration, address _seller) public anyOperator {\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '        uint256 assetType;\n', '        uint256 _tokenId;\n', '        uint256 salePrice;\n', '        for (uint256 i = 0; i < _tokenIds.length; ++i) {\n', '            _tokenId = _tokenIds[i];\n', '            assetType = ccNFT.getAssetIdItemType(_tokenId);\n', '            // Avg Price of last sales\n', '            salePrice = GetAssetTypeAverageSalePrice(assetType);\n', '\n', '            //  0-10,000 is mapped to 0%-100% - will be typically 12000 or 120%\n', '            salePrice = salePrice * _margin / 10000;\n', '\n', '            if(salePrice < _minPrice) {\n', '                salePrice = _minPrice;\n', '            } \n', '            \n', '            _tokenId = _tokenIds[i];\n', '            _createSale(_tokenId, salePrice, _endingPrice, _duration, _seller);\n', '        }\n', '    }\n', '\n', '    function BatchCancelSales(uint256[] _tokenIds) public anyOperator {\n', '        uint256 _tokenId;\n', '        for (uint256 i = 0; i < _tokenIds.length; ++i) {\n', '            _tokenId = _tokenIds[i];\n', '            _cancelSale(_tokenId);\n', '        }\n', '    }\n', '\n', '    function CancelSale(uint256 _assetId) public anyOperator {\n', '        _cancelSale(_assetId);\n', '    }\n', '\n', '    function GetCurrentSalePrice(uint256 _assetId) external view returns(uint256 _price) {\n', '        CollectibleSale memory _sale = tokenIdToSale[_assetId];\n', '        \n', '        return _currentPrice(_sale);\n', '    }\n', '\n', '    function GetCurrentTypeSalePrice(uint256 _assetType) external view returns(uint256 _price) {\n', '        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\n', '        return _currentPrice(_sale);\n', '    }\n', '\n', '    function GetCurrentTypeDuration(uint256 _assetType) external view returns(uint256 _duration) {\n', '        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\n', '        return  _sale.duration;\n', '    }\n', '\n', '    function GetCurrentTypeStartTime(uint256 _assetType) external view returns(uint256 _startedAt) {\n', '        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\n', '        return  _sale.startedAt;\n', '    }\n', '\n', '    function GetCurrentTypeSaleItem(uint256 _assetType) external view returns(address seller, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt, uint256 tokenId) {\n', '        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\n', '        return (\n', '            _sale.seller,\n', '            _sale.startingPrice,\n', '            _sale.endingPrice,\n', '            _sale.duration,\n', '            _sale.startedAt,\n', '            _sale.tokenId\n', '        );\n', '    }\n', '\n', '    function GetCurrentTypeSaleCount(uint256 _assetType) external view returns(uint256 _count) {\n', '        return assetTypeSalesTokenId[_assetType].length;\n', '    }\n', '\n', '    function BuyCurrentTypeOfAsset(uint256 _assetType) external whenNotPaused payable {\n', '        require(msg.sender != address(0));\n', '        require(msg.sender != address(this));\n', '\n', '        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\n', '        require(_isOnSale(_sale));\n', '\n', '        _buy(_sale.tokenId, msg.sender, msg.value);\n', '    }\n', '\n', '    /// @dev BuyNow Function which call the interncal buy function\n', '    /// after doing all the pre-checks required to initiate a buy\n', '    function BuyAsset(uint256 _assetId) external whenNotPaused payable {\n', '        require(msg.sender != address(0));\n', '        require(msg.sender != address(this));\n', '        CollectibleSale memory _sale = tokenIdToSale[_assetId];\n', '        require(_isOnSale(_sale));\n', '        \n', '        //address seller = _sale.seller;\n', '\n', '        _buy(_assetId, msg.sender, msg.value);\n', '    }\n', '\n', '    function GetAssetTypeAverageSalePrice(uint256 _assetType) public view returns (uint256) {\n', '        uint256 sum = 0;\n', '        for (uint256 i = 0; i < avgSalesToCount; i++) {\n', '            sum += assetTypeSalePrices[_assetType].sales[i];\n', '        }\n', '        return sum / 5;\n', '    }\n', '\n', '    /// @dev Override unpause so it requires all external contract addresses\n', "    ///  to be set before contract can be unpaused. Also, we can't have\n", '    ///  newContractAddress set either, because then the contract was upgraded.\n', '    /// @notice This is public rather than external so we can call super.unpause\n', '    ///  without using an expensive CALL.\n', '    function unpause() public anyOperator whenPaused {\n', '        // Actually unpause the contract.\n', '        super.unpause();\n', '    }\n', '\n', "    /// @dev Remove all Ether from the contract, which is the owner's cuts\n", '    ///  as well as any Ether sent directly to the contract address.\n', '    ///  Always transfers to the NFT (ERC721) contract, but can be called either by\n', '    ///  the owner or the NFT (ERC721) contract.\n', '    function withdrawBalance() public onlyBanker {\n', '        // We are using this boolean method to make sure that even if one fails it will still work\n', '        bankManager.transfer(address(this).balance);\n', '    }\n', '\n', '    /// @dev Returns sales info for an CSLCollectibles (ERC721) on sale.\n', '    /// @param _assetId - ID of the token on sale\n', '    function getSale(uint256 _assetId) external view returns (address seller, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt, bool isActive, address buyer, uint256 tokenId) {\n', '        CollectibleSale memory sale = tokenIdToSale[_assetId];\n', '        require(_isOnSale(sale));\n', '        return (\n', '            sale.seller,\n', '            sale.startingPrice,\n', '            sale.endingPrice,\n', '            sale.duration,\n', '            sale.startedAt,\n', '            sale.isActive,\n', '            sale.buyer,\n', '            sale.tokenId\n', '        );\n', '    }\n', '\n', '\n', '    /** Internal Functions */\n', '\n', '    function _createSale(uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint64 _duration, address _seller) internal {\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '\n', '        require(ccNFT.isAssetIdOwnerOrApproved(this, _tokenId) == true);\n', '        \n', '        CollectibleSale memory onSale = tokenIdToSale[_tokenId];\n', '        require(onSale.isActive == false);\n', '\n', "        // Sanity check that no inputs overflow how many bits we've allocated\n", '        // to store them in the sale struct.\n', '        require(_startingPrice == uint256(uint128(_startingPrice)));\n', '        require(_endingPrice == uint256(uint128(_endingPrice)));\n', '        require(_duration == uint256(uint64(_duration)));\n', '\n', '        //Transfer ownership if needed\n', '        if(ccNFT.ownerOf(_tokenId) != address(this)) {\n', '            \n', '            require(ccNFT.isApprovedForAll(msg.sender, this) == true);\n', '\n', '            ccNFT.safeTransferFrom(ccNFT.ownerOf(_tokenId), this, _tokenId);\n', '        }\n', '\n', '        CollectibleSale memory sale = CollectibleSale(\n', '            _seller,\n', '            uint128(_startingPrice),\n', '            uint128(_endingPrice),\n', '            uint64(_duration),\n', '            uint64(now),\n', '            true,\n', '            address(0),\n', '            uint256(_tokenId)\n', '        );\n', '        _addSale(_tokenId, sale);\n', '    }\n', '\n', '    /// @dev Adds an sale to the list of open sales. Also fires the\n', '    ///  SaleCreated event.\n', '    function _addSale(uint256 _assetId, CollectibleSale _sale) internal {\n', '        // Require that all sales have a duration of\n', '        // at least one minute.\n', '        require(_sale.duration >= 1 minutes);\n', '        \n', '        tokenIdToSale[_assetId] = _sale;\n', '\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '        uint256 assetType = ccNFT.getAssetIdItemType(_assetId);\n', '        assetTypeSalesTokenId[assetType].push(_assetId);\n', '\n', '        SaleCreated(\n', '            uint256(_assetId),\n', '            uint256(_sale.startingPrice),\n', '            uint256(_sale.endingPrice),\n', '            uint256(_sale.duration),\n', '            uint64(_sale.startedAt)\n', '        );\n', '    }\n', '\n', '    /// @dev Returns current price of a Collectible (ERC721) on sale. Broken into two\n', '    ///  functions (this one, that computes the duration from the sale\n', '    ///  structure, and the other that does the price computation) so we\n', '    ///  can easily test that the price computation works correctly.\n', '    function _currentPrice(CollectibleSale memory _sale) internal view returns (uint256) {\n', '        uint256 secondsPassed = 0;\n', '\n', '        // A bit of insurance against negative values (or wraparound).\n', '        // Probably not necessary (since Ethereum guarnatees that the\n', "        // now variable doesn't ever go backwards).\n", '        if (now > _sale.startedAt) {\n', '            secondsPassed = now - _sale.startedAt;\n', '        }\n', '\n', '        return _computeCurrentPrice(\n', '            _sale.startingPrice,\n', '            _sale.endingPrice,\n', '            _sale.duration,\n', '            secondsPassed\n', '        );\n', '    }\n', '\n', '    /// @dev Computes the current price of an sale. Factored out\n', '    ///  from _currentPrice so we can run extensive unit tests.\n', '    ///  When testing, make this function public and turn on\n', '    ///  `Current price computation` test suite.\n', '    function _computeCurrentPrice(uint256 _startingPrice, uint256 _endingPrice, uint256 _duration, uint256 _secondsPassed) internal pure returns (uint256) {\n', "        // NOTE: We don't use SafeMath (or similar) in this function because\n", '        //  all of our public functions carefully cap the maximum values for\n', '        //  time (at 64-bits) and currency (at 128-bits). _duration is\n', '        //  also known to be non-zero (see the require() statement in\n', '        //  _addSale())\n', '        if (_secondsPassed >= _duration) {\n', "            // We've reached the end of the dynamic pricing portion\n", '            // of the sale, just return the end price.\n', '            return _endingPrice;\n', '        } else {\n', '            // Starting price can be higher than ending price (and often is!), so\n', '            // this delta can be negative.\n', '            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\n', '\n', "            // This multiplication can't overflow, _secondsPassed will easily fit within\n", '            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\n', '            // will always fit within 256-bits.\n', '            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\n', '\n', '            // currentPriceChange can be negative, but if so, will have a magnitude\n', '            // less that _startingPrice. Thus, this result will always end up positive.\n', '            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\n', '\n', '            return uint256(currentPrice);\n', '        }\n', '    }\n', '\n', '    function _buy(uint256 _assetId, address _buyer, uint256 _price) internal {\n', '\n', '        CollectibleSale storage _sale = tokenIdToSale[_assetId];\n', '\n', '        // Check that the bid is greater than or equal to the current buyOut price\n', '        uint256 currentPrice = _currentPrice(_sale);\n', '\n', '        require(_price >= currentPrice);\n', '        _sale.buyer = _buyer;\n', '        _sale.isActive = false;\n', '\n', '        _removeSale(_assetId);\n', '\n', '        uint256 bidExcess = _price - currentPrice;\n', '        _buyer.transfer(bidExcess);\n', '\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '        uint256 assetType = ccNFT.getAssetIdItemType(_assetId);\n', '        _updateSaleAvgHistory(assetType, _price);\n', '        ccNFT.safeTransferFrom(this, _buyer, _assetId);\n', '\n', '        emit SaleWinner(_buyer, _assetId, _price);\n', '    }\n', '\n', '    function _cancelSale (uint256 _assetId) internal {\n', '        CollectibleSale storage _sale = tokenIdToSale[_assetId];\n', '\n', '        require(_sale.isActive == true);\n', '\n', '        address sellerAddress = _sale.seller;\n', '\n', '        _removeSale(_assetId);\n', '\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '\n', '        ccNFT.safeTransferFrom(this, sellerAddress, _assetId);\n', '\n', '        emit SaleCancelled(sellerAddress, _assetId);\n', '    }\n', '    \n', '    /// @dev Returns true if the FT (ERC721) is on sale.\n', '    function _isOnSale(CollectibleSale memory _sale) internal view returns (bool) {\n', '        return (_sale.startedAt > 0 && _sale.isActive);\n', '    }\n', '\n', '    function _updateSaleAvgHistory(uint256 _assetType, uint256 _price) internal {\n', '        assetTypeSaleCount[_assetType] += 1;\n', '        assetTypeSalePrices[_assetType].sales[assetTypeSaleCount[_assetType] % avgSalesToCount] = _price;\n', '    }\n', '\n', '    /// @dev Removes an sale from the list of open sales.\n', '    /// @param _assetId - ID of the token on sale\n', '    function _removeSale(uint256 _assetId) internal {\n', '        delete tokenIdToSale[_assetId];\n', '\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '        uint256 assetType = ccNFT.getAssetIdItemType(_assetId);\n', '\n', '        bool hasFound = false;\n', '        for (uint i = 0; i < assetTypeSalesTokenId[assetType].length; i++) {\n', '            if ( assetTypeSalesTokenId[assetType][i] == _assetId) {\n', '                hasFound = true;\n', '            }\n', '            if(hasFound == true) {\n', '                if(i+1 < assetTypeSalesTokenId[assetType].length)\n', '                    assetTypeSalesTokenId[assetType][i] = assetTypeSalesTokenId[assetType][i+1];\n', '                else \n', '                    delete assetTypeSalesTokenId[assetType][i];\n', '            }\n', '        }\n', '        assetTypeSalesTokenId[assetType].length--;\n', '    }\n', '\n', '\n', '    // Vending\n', '\n', '    function setVendingAttachedState (uint256 _collectibleType, uint256 _state) external onlyManager {\n', '        vendingAttachedState = _state;\n', '    }\n', '\n', '    /// @dev Function toggle vending for collectible\n', '    function setVendingAmount (uint256 _collectibleType, uint256 _vendingQty) external onlyManager {\n', '        vendingAmountType[_collectibleType] = _vendingQty;\n', '    }\n', '\n', '    /// @dev Function sets the starting price / reset price\n', '    function setVendingStartPrice (uint256 _collectibleType, uint256 _startingPrice) external onlyManager {\n', '        vendingPrice[_collectibleType] = _startingPrice;\n', '    }\n', '\n', '    /// @dev Sets Step Value\n', '    function setVendingStepValues(uint256 _collectibleType, uint256 _stepAmount, uint256 _stepQty) external onlyManager {\n', '        vendingStepUpQty[_collectibleType] = _stepQty;\n', '        vendingStepUpAmount[_collectibleType] = _stepAmount;\n', '    }\n', '\n', '    /// @dev Create Vending Helper\n', '    function createVendingItem(uint256 _collectibleType, uint256 _vendingQty, uint256 _startingPrice, uint256 _stepAmount, uint256 _stepQty) external onlyManager {\n', '        vendingAmountType[_collectibleType] = _vendingQty;\n', '        vendingPrice[_collectibleType] = _startingPrice;\n', '        vendingStepUpQty[_collectibleType] = _stepQty;\n', '        vendingStepUpAmount[_collectibleType] = _stepAmount;\n', '    }\n', '\n', '    /// @dev This helps in creating a collectible and then \n', '    /// transfer it _toAddress\n', '    function vendingCreateCollectible(uint256 _collectibleType, address _toAddress) payable external whenNotPaused {\n', '        \n', '        //Only if Vending is Allowed for this Asset\n', '        require((vendingAmountType[_collectibleType] - vendingTypeSold[_collectibleType]) > 0);\n', '\n', '        require(msg.value >= vendingPrice[_collectibleType]);\n', '\n', '        require(msg.sender != address(0));\n', '        require(msg.sender != address(this));\n', '        \n', '        require(_toAddress != address(0));\n', '        require(_toAddress != address(this));\n', '\n', '        var ccNFT = CCNFTFactory(NFTAddress);\n', '\n', '        ccNFT.spawnAsset(_toAddress, _collectibleType, startingIndex, vendingAttachedState);\n', '\n', '        startingIndex += 1;\n', '\n', '        vendingTypeSold[_collectibleType] += 1;\n', '\n', '        uint256 excessBid = msg.value - vendingPrice[_collectibleType];\n', '\n', '        if(vendingTypeSold[_collectibleType] % vendingStepUpQty[_collectibleType] == 0) {\n', '            vendingPrice[_collectibleType] += vendingStepUpAmount[_collectibleType];\n', '        }\n', '\n', '        if(excessBid > 0) {\n', '            msg.sender.transfer(excessBid);\n', '        }\n', ' \n', '    }\n', '\n', '    function getVendingAmountLeft (uint256 _collectibleType) view public returns (uint256) {\n', '        return (vendingAmountType[_collectibleType] - vendingTypeSold[_collectibleType]);\n', '    }\n', '\n', '    function getVendingAmountSold (uint256 _collectibleType) view public returns (uint256) {\n', '        return (vendingTypeSold[_collectibleType]);\n', '    }\n', '\n', '    function getVendingPrice (uint256 _collectibleType) view public returns (uint256) {\n', '        return (vendingPrice[_collectibleType]);\n', '    }\n', '\n', '    function getVendingStepPrice (uint256 _collectibleType) view public returns (uint256) {\n', '        return (vendingStepUpAmount[_collectibleType]);\n', '    }\n', '\n', '    function getVendingStepQty (uint256 _collectibleType) view public returns (uint256) {\n', '        return (vendingStepUpQty[_collectibleType]);\n', '    }\n', '\n', '    function getVendingInfo (uint256 _collectibleType) view public returns (uint256 amountRemaining, uint256 sold, uint256 price, uint256 stepPrice, uint256 stepQty) {\n', '        amountRemaining = (vendingAmountType[_collectibleType] - vendingTypeSold[_collectibleType]);\n', '        sold = vendingTypeSold[_collectibleType];\n', '        price = vendingPrice[_collectibleType];\n', '        stepPrice = vendingStepUpAmount[_collectibleType];\n', '        stepQty = vendingStepUpQty[_collectibleType];\n', '    }\n', '\n', '}']
