['/*\n', '  Zethr | https://zethr.io\n', '  (c) Copyright 2018 | All Rights Reserved\n', '  This smart contract was developed by the Zethr Dev Team and its source code remains property of the Zethr Project.\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '// File: contracts/Libraries/SafeMath.sol\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/Bankroll/ZethrSnap.sol\n', '\n', 'contract ZethrInterface {\n', '  function transfer(address _from, uint _amount) public;\n', '\n', '  function myFrontEndTokens() public view returns (uint);\n', '}\n', '\n', 'contract ZethrMultiSigWalletInterface {\n', '  mapping(address => bool) public isOwner;\n', '}\n', '\n', 'contract ZethrSnap {\n', '\n', '  struct SnapEntry {\n', '    uint blockNumber;\n', '    uint profit;\n', '  }\n', '\n', '  struct Sig {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '  }\n', '\n', '  // Reference to the Zethr multi sig wallet for authentication\n', '  ZethrMultiSigWalletInterface public multiSigWallet;\n', '\n', '  // Reference to Zethr token contract\n', '  ZethrInterface zethr;\n', '\n', '  // The server&#39;s public address (used to confirm valid claims)\n', '  address signer;\n', '\n', '  // Mapping of user address => snap.id => claimStatus\n', '  mapping(address => mapping(uint => bool)) public claimedMap;\n', '\n', '  // Array of all snaps\n', '  SnapEntry[] public snaps;\n', '\n', '  // Used to pause the contract in an emergency\n', '  bool public paused;\n', '\n', '  // The number of tokens in this contract allocated to snaps\n', '  uint public allocatedTokens;\n', '\n', '  constructor(address _multiSigWalletAddress, address _zethrAddress, address _signer)\n', '  public\n', '  {\n', '    multiSigWallet = ZethrMultiSigWalletInterface(_multiSigWalletAddress);\n', '    zethr = ZethrInterface(_zethrAddress);\n', '    signer = _signer;\n', '    paused = false;\n', '  }\n', '\n', '  /**\n', '   * @dev Needs to accept ETH dividends from Zethr token contract\n', '   */\n', '  function()\n', '  public payable\n', '  {}\n', '\n', '  /**\n', '   * @dev Paused claims in an emergency\n', '   * @param _paused The new pause state\n', '   */\n', '  function ownerSetPaused(bool _paused)\n', '  public\n', '  ownerOnly\n', '  {\n', '    paused = _paused;\n', '  }\n', '\n', '  /**\n', '   * @dev Updates the multi sig wallet reference\n', '   * @param _multiSigWalletAddress The new multi sig wallet address\n', '   */\n', '  function walletSetWallet(address _multiSigWalletAddress)\n', '  public\n', '  walletOnly\n', '  {\n', '    multiSigWallet = ZethrMultiSigWalletInterface(_multiSigWalletAddress);\n', '  }\n', '\n', '  /**\n', '   * @dev Withdraws dividends to multi sig wallet\n', '   */\n', '  function withdraw()\n', '  public\n', '  {\n', '    (address(multiSigWallet)).transfer(address(this).balance);\n', '  }\n', '\n', '  /**\n', '   * @dev Updates the signer address\n', '   */\n', '  function walletSetSigner(address _signer)\n', '  public walletOnly\n', '  {\n', '    signer = _signer;\n', '  }\n', '\n', '  /**\n', '   * @dev Withdraws tokens (for migrating to a new contract)\n', '   */\n', '  function walletWithdrawTokens(uint _amount)\n', '  public walletOnly\n', '  {\n', '    zethr.transfer(address(multiSigWallet), _amount);\n', '  }\n', '\n', '  /**\n', '   * @return Total number of snaps stored\n', '   */\n', '  function getSnapsLength()\n', '  public view\n', '  returns (uint)\n', '  {\n', '    return snaps.length;\n', '  }\n', '\n', '  /**\n', '   * @dev Creates a new snap\n', '   * @param _blockNumber The block number the server should use to calculate ownership\n', '   * @param _profitToShare The amount of profit to divide between all holders\n', '   */\n', '  function walletCreateSnap(uint _blockNumber, uint _profitToShare)\n', '  public\n', '  walletOnly\n', '  {\n', '    uint index = snaps.length;\n', '    snaps.length++;\n', '\n', '    snaps[index].blockNumber = _blockNumber;\n', '    snaps[index].profit = _profitToShare;\n', '\n', '    // Make sure we have enough free tokens to create this snap\n', '    uint balance = zethr.myFrontEndTokens();\n', '    balance = balance - allocatedTokens;\n', '    require(balance >= _profitToShare);\n', '\n', '    // Update allocation token count\n', '    allocatedTokens = allocatedTokens + _profitToShare;\n', '  }\n', '\n', '  /**\n', '   * @dev Retrieves snap details\n', '   * @param _snapId The ID of the snap to get details of\n', '   */\n', '  function getSnap(uint _snapId)\n', '  public view\n', '  returns (uint blockNumber, uint profit, bool claimed)\n', '  {\n', '    SnapEntry storage entry = snaps[_snapId];\n', '    return (entry.blockNumber, entry.profit, claimedMap[msg.sender][_snapId]);\n', '  }\n', '\n', '  /**\n', '   * @dev Process a claim\n', '   * @param _snapId ID of the snap this claim is for\n', '   * @param _payTo Address to send the proceeds to\n', '   * @param _amount The amount of profit claiming\n', '   * @param _signatureBytes Signature of the server approving this claim\n', '   */\n', '  function claim(uint _snapId, address _payTo, uint _amount, bytes _signatureBytes)\n', '  public\n', '  {\n', '    // Check pause state\n', '    require(!paused);\n', '\n', '    // Prevent multiple calls\n', '    require(claimedMap[msg.sender][_snapId] == false);\n', '    claimedMap[msg.sender][_snapId] = true;\n', '\n', '    // Confirm that the server has approved this claim\n', '    // Note: the player cannot modify the _amount arbitrarily because it will invalidate the signature\n', '    Sig memory sig = toSig(_signatureBytes);\n', '    bytes32 hash = keccak256(abi.encodePacked("SNAP", _snapId, msg.sender, _amount));\n', '    address recoveredSigner = ecrecover(hash, sig.v, sig.r, sig.s);\n', '    require(signer == recoveredSigner);\n', '\n', '    // Reduce allocated tokens by claim amount\n', '    require(_amount <= allocatedTokens);\n', '    allocatedTokens = allocatedTokens - _amount;\n', '\n', '    // Send tokens\n', '    zethr.transfer(_payTo, _amount);\n', '  }\n', '\n', '  /**\n', '   * @dev The contract accepts ZTH tokens in order to pay out claims\n', '   */\n', '  function tokenFallback(address /*_from*/, uint /*_amountOfTokens*/, bytes /*_data*/)\n', '  public view\n', '  returns (bool)\n', '  {\n', '    require(msg.sender == address(zethr), "Tokens must be ZTH");\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Extract a Sig struct from given bytes\n', '   */\n', '  function toSig(bytes b)\n', '  internal pure\n', '  returns (Sig memory sig)\n', '  {\n', '    sig.r = bytes32(toUint(b, 0));\n', '    sig.s = bytes32(toUint(b, 32));\n', '    sig.v = uint8(b[64]);\n', '  }\n', '\n', '  /**\n', '   * @dev Extracts a uint from bytes\n', '   */\n', '  function toUint(bytes _bytes, uint _start)\n', '  internal pure\n', '  returns (uint256)\n', '  {\n', '    require(_bytes.length >= (_start + 32));\n', '    uint256 tempUint;\n', '\n', '    assembly {\n', '      tempUint := mload(add(add(_bytes, 0x20), _start))\n', '    }\n', '\n', '    return tempUint;\n', '  }\n', '\n', '  // Only the multi sig wallet can call this method\n', '  modifier walletOnly()\n', '  {\n', '    require(msg.sender == address(multiSigWallet));\n', '    _;\n', '  }\n', '\n', '  // Only an owner can call this method (multi sig is always an owner)\n', '  modifier ownerOnly()\n', '  {\n', '    require(msg.sender == address(multiSigWallet) || multiSigWallet.isOwner(msg.sender));\n', '    _;\n', '  }\n', '}']
['/*\n', '  Zethr | https://zethr.io\n', '  (c) Copyright 2018 | All Rights Reserved\n', '  This smart contract was developed by the Zethr Dev Team and its source code remains property of the Zethr Project.\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '// File: contracts/Libraries/SafeMath.sol\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/Bankroll/ZethrSnap.sol\n', '\n', 'contract ZethrInterface {\n', '  function transfer(address _from, uint _amount) public;\n', '\n', '  function myFrontEndTokens() public view returns (uint);\n', '}\n', '\n', 'contract ZethrMultiSigWalletInterface {\n', '  mapping(address => bool) public isOwner;\n', '}\n', '\n', 'contract ZethrSnap {\n', '\n', '  struct SnapEntry {\n', '    uint blockNumber;\n', '    uint profit;\n', '  }\n', '\n', '  struct Sig {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '  }\n', '\n', '  // Reference to the Zethr multi sig wallet for authentication\n', '  ZethrMultiSigWalletInterface public multiSigWallet;\n', '\n', '  // Reference to Zethr token contract\n', '  ZethrInterface zethr;\n', '\n', "  // The server's public address (used to confirm valid claims)\n", '  address signer;\n', '\n', '  // Mapping of user address => snap.id => claimStatus\n', '  mapping(address => mapping(uint => bool)) public claimedMap;\n', '\n', '  // Array of all snaps\n', '  SnapEntry[] public snaps;\n', '\n', '  // Used to pause the contract in an emergency\n', '  bool public paused;\n', '\n', '  // The number of tokens in this contract allocated to snaps\n', '  uint public allocatedTokens;\n', '\n', '  constructor(address _multiSigWalletAddress, address _zethrAddress, address _signer)\n', '  public\n', '  {\n', '    multiSigWallet = ZethrMultiSigWalletInterface(_multiSigWalletAddress);\n', '    zethr = ZethrInterface(_zethrAddress);\n', '    signer = _signer;\n', '    paused = false;\n', '  }\n', '\n', '  /**\n', '   * @dev Needs to accept ETH dividends from Zethr token contract\n', '   */\n', '  function()\n', '  public payable\n', '  {}\n', '\n', '  /**\n', '   * @dev Paused claims in an emergency\n', '   * @param _paused The new pause state\n', '   */\n', '  function ownerSetPaused(bool _paused)\n', '  public\n', '  ownerOnly\n', '  {\n', '    paused = _paused;\n', '  }\n', '\n', '  /**\n', '   * @dev Updates the multi sig wallet reference\n', '   * @param _multiSigWalletAddress The new multi sig wallet address\n', '   */\n', '  function walletSetWallet(address _multiSigWalletAddress)\n', '  public\n', '  walletOnly\n', '  {\n', '    multiSigWallet = ZethrMultiSigWalletInterface(_multiSigWalletAddress);\n', '  }\n', '\n', '  /**\n', '   * @dev Withdraws dividends to multi sig wallet\n', '   */\n', '  function withdraw()\n', '  public\n', '  {\n', '    (address(multiSigWallet)).transfer(address(this).balance);\n', '  }\n', '\n', '  /**\n', '   * @dev Updates the signer address\n', '   */\n', '  function walletSetSigner(address _signer)\n', '  public walletOnly\n', '  {\n', '    signer = _signer;\n', '  }\n', '\n', '  /**\n', '   * @dev Withdraws tokens (for migrating to a new contract)\n', '   */\n', '  function walletWithdrawTokens(uint _amount)\n', '  public walletOnly\n', '  {\n', '    zethr.transfer(address(multiSigWallet), _amount);\n', '  }\n', '\n', '  /**\n', '   * @return Total number of snaps stored\n', '   */\n', '  function getSnapsLength()\n', '  public view\n', '  returns (uint)\n', '  {\n', '    return snaps.length;\n', '  }\n', '\n', '  /**\n', '   * @dev Creates a new snap\n', '   * @param _blockNumber The block number the server should use to calculate ownership\n', '   * @param _profitToShare The amount of profit to divide between all holders\n', '   */\n', '  function walletCreateSnap(uint _blockNumber, uint _profitToShare)\n', '  public\n', '  walletOnly\n', '  {\n', '    uint index = snaps.length;\n', '    snaps.length++;\n', '\n', '    snaps[index].blockNumber = _blockNumber;\n', '    snaps[index].profit = _profitToShare;\n', '\n', '    // Make sure we have enough free tokens to create this snap\n', '    uint balance = zethr.myFrontEndTokens();\n', '    balance = balance - allocatedTokens;\n', '    require(balance >= _profitToShare);\n', '\n', '    // Update allocation token count\n', '    allocatedTokens = allocatedTokens + _profitToShare;\n', '  }\n', '\n', '  /**\n', '   * @dev Retrieves snap details\n', '   * @param _snapId The ID of the snap to get details of\n', '   */\n', '  function getSnap(uint _snapId)\n', '  public view\n', '  returns (uint blockNumber, uint profit, bool claimed)\n', '  {\n', '    SnapEntry storage entry = snaps[_snapId];\n', '    return (entry.blockNumber, entry.profit, claimedMap[msg.sender][_snapId]);\n', '  }\n', '\n', '  /**\n', '   * @dev Process a claim\n', '   * @param _snapId ID of the snap this claim is for\n', '   * @param _payTo Address to send the proceeds to\n', '   * @param _amount The amount of profit claiming\n', '   * @param _signatureBytes Signature of the server approving this claim\n', '   */\n', '  function claim(uint _snapId, address _payTo, uint _amount, bytes _signatureBytes)\n', '  public\n', '  {\n', '    // Check pause state\n', '    require(!paused);\n', '\n', '    // Prevent multiple calls\n', '    require(claimedMap[msg.sender][_snapId] == false);\n', '    claimedMap[msg.sender][_snapId] = true;\n', '\n', '    // Confirm that the server has approved this claim\n', '    // Note: the player cannot modify the _amount arbitrarily because it will invalidate the signature\n', '    Sig memory sig = toSig(_signatureBytes);\n', '    bytes32 hash = keccak256(abi.encodePacked("SNAP", _snapId, msg.sender, _amount));\n', '    address recoveredSigner = ecrecover(hash, sig.v, sig.r, sig.s);\n', '    require(signer == recoveredSigner);\n', '\n', '    // Reduce allocated tokens by claim amount\n', '    require(_amount <= allocatedTokens);\n', '    allocatedTokens = allocatedTokens - _amount;\n', '\n', '    // Send tokens\n', '    zethr.transfer(_payTo, _amount);\n', '  }\n', '\n', '  /**\n', '   * @dev The contract accepts ZTH tokens in order to pay out claims\n', '   */\n', '  function tokenFallback(address /*_from*/, uint /*_amountOfTokens*/, bytes /*_data*/)\n', '  public view\n', '  returns (bool)\n', '  {\n', '    require(msg.sender == address(zethr), "Tokens must be ZTH");\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Extract a Sig struct from given bytes\n', '   */\n', '  function toSig(bytes b)\n', '  internal pure\n', '  returns (Sig memory sig)\n', '  {\n', '    sig.r = bytes32(toUint(b, 0));\n', '    sig.s = bytes32(toUint(b, 32));\n', '    sig.v = uint8(b[64]);\n', '  }\n', '\n', '  /**\n', '   * @dev Extracts a uint from bytes\n', '   */\n', '  function toUint(bytes _bytes, uint _start)\n', '  internal pure\n', '  returns (uint256)\n', '  {\n', '    require(_bytes.length >= (_start + 32));\n', '    uint256 tempUint;\n', '\n', '    assembly {\n', '      tempUint := mload(add(add(_bytes, 0x20), _start))\n', '    }\n', '\n', '    return tempUint;\n', '  }\n', '\n', '  // Only the multi sig wallet can call this method\n', '  modifier walletOnly()\n', '  {\n', '    require(msg.sender == address(multiSigWallet));\n', '    _;\n', '  }\n', '\n', '  // Only an owner can call this method (multi sig is always an owner)\n', '  modifier ownerOnly()\n', '  {\n', '    require(msg.sender == address(multiSigWallet) || multiSigWallet.isOwner(msg.sender));\n', '    _;\n', '  }\n', '}']
