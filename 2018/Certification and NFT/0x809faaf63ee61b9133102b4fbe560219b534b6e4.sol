['pragma solidity ^0.4.18;\n', '/*\n', 'Author:     www.purplethrone.com\n', 'Email:      aziz@purplethrone.com\n', '\n', '\n', '*/\n', '// Math contract to avoid overflow and underflow of variables\n', 'contract SafeMath {\n', '\n', '    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x + y;\n', '      assert((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n', '      assert(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x * y;\n', '      assert((x == 0)||(z/x == y));\n', '      return z;\n', '    }\n', '\n', '}\n', '// Abstracct of ERC20 Token\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/*  Implementation of ERC20 token standard functions */\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '/**\n', '* @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '* account.\n', '*/\n', 'function Ownable() {\n', '  owner = msg.sender;\n', '}\n', '/**\n', '* @dev Throws if called by any account other than the owner.\n', '*/\n', 'modifier onlyOwner() {\n', '  require(msg.sender == owner);\n', '_;\n', '}\n', '/**\n', '* @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '* @param newOwner The address to transfer ownership to.\n', '*/\n', 'function transferOwnership(address newOwner) onlyOwner {\n', '  if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '  }\n', '}\n', '\n', '}\n', '\n', '\n', 'contract PPCToken is StandardToken,Ownable, SafeMath {\n', '\n', '    // crowdsale parameters\n', '    string  public constant name = "PurpleCoin";\n', '    string  public constant symbol = "PPC";\n', '    uint256 public constant decimals = 18;\n', '    string  public version = "1.0";\n', '    address public constant ethFundDeposit= 0x20D9053d3f7fccC069c9a8e7dDEf5374CD22b6C8;                         // Deposit address for ETH\n', '    bool public emergencyFlag;                                      //  Switched to true in  crownsale end  state\n', '    uint256 public fundingStartBlock;                              //   Starting blocknumber\n', '    uint256 public fundingEndBlock;                               //    Ending blocknumber\n', '    uint256 public constant minTokenPurchaseAmount= .008 ether;  //     Minimum purchase\n', '    uint256 public constant tokenPreSaleRate=800;    // PPCCoin per 1 ETH during presale\n', '    uint256 public constant tokenCrowdsaleRate=500; //  PPCCoin per 1 ETH during crowdsale\n', '    uint256 public constant tokenCreationPreSaleCap =  10 * (10**6) * 10**decimals;// 10 million token cap for presale\n', '    uint256 public constant tokenCreationCap =  100 * (10**6) * 10**decimals;      //  100 million token generated\n', '    uint256 public constant preSaleBlockNumber = 169457;\n', '    uint256 public finalBlockNumber =370711;\n', '\n', '\n', '    // events\n', '    event CreatePPC(address indexed _to, uint256 _value);// Return address of buyer and purchase token\n', '    event Mint(address indexed _to,uint256 _value);     //  Reutn address to which we send the mint token and token assigned.\n', '    // Constructor\n', '    function PPCToken(){\n', '      emergencyFlag = false;                             // False at initialization will be false during ICO\n', '      fundingStartBlock = block.number;                 //  Current deploying block number is the starting block number for ICO\n', '      fundingEndBlock=safeAdd(fundingStartBlock,finalBlockNumber);  //   Ending time depending upon the block number\n', '    }\n', '\n', '    /**\n', '    * @dev creates new PPC tokens\n', '    *      It is a internal function it will be called by fallback function or buyToken functions.\n', '    */\n', '    function createTokens() internal  {\n', '      if (emergencyFlag) revert();                     //  Revert when the sale is over before time and emergencyFlag is true.\n', '      if (block.number > fundingEndBlock) revert();   //   If the blocknumber exceed the ending block it will revert\n', '      if (msg.value<minTokenPurchaseAmount)revert();  //    If someone send 0.08 ether it will fail\n', '      uint256 tokenExchangeRate=tokenRate();        //     It will get value depending upon block number and presale cap\n', '      uint256 tokens = safeMult(msg.value, tokenExchangeRate);//  Calculating number of token for sender\n', '      totalSupply = safeAdd(totalSupply, tokens);            //   Add token to total supply\n', '      if(totalSupply>tokenCreationCap)revert();             //    Check the total supply if it is more then hardcap it will throw\n', '      balances[msg.sender] += tokens;                      //     Adding token to sender account\n', '      forwardfunds();                                     //      forwardfunds to the owner\n', '      CreatePPC(msg.sender, tokens);                      //      Logs sender address and  token creation\n', '    }\n', '\n', '    /**\n', '    * @dev people can access contract and choose buyToken function to get token\n', '    *It is used by using myetherwallet\n', '    *It is a payable function it will be called by sender.\n', '    */\n', '    function buyToken() payable external{\n', '      createTokens();   // This will call the internal createToken function to get token\n', '    }\n', '\n', '    /**\n', '    * @dev      it is a internal function called by create function to get the amount according to the blocknumber.\n', '    * @return   It will return the token price at a particular time.\n', '    */\n', '    function tokenRate() internal returns (uint256 _tokenPrice){\n', '      // It is a presale it will return price for presale\n', '      if(block.number<safeAdd(fundingStartBlock,preSaleBlockNumber)&&(totalSupply<tokenCreationPreSaleCap)){\n', '          return tokenPreSaleRate;\n', '        }else\n', '            return tokenCrowdsaleRate;\n', '    }\n', '\n', '    /**\n', '    * @dev     it will  assign token to a particular address by owner only\n', '    * @param   _to the address whom you want to send token to\n', '    * @param   _amount the amount you want to send\n', '    * @return  It will return true if success.\n', '    */\n', '    function mint(address _to, uint256 _amount) external onlyOwner returns (bool) {\n', '      if (emergencyFlag) revert();\n', '      totalSupply = safeAdd(totalSupply,_amount);// Add the minted token to total suppy\n', '      if(totalSupply>tokenCreationCap)revert();\n', '      balances[_to] +=_amount;                 //   Adding token to the input address\n', '      Mint(_to, _amount);                     //    Log the mint with address and token given to particular address\n', '      return true;\n', '    }\n', '\n', '    /**\n', '    * @dev     it will change the ending date of ico and access by owner only\n', '    * @param   _newBlock enter the future blocknumber\n', '    * @return  It will return the blocknumber\n', '    */\n', '    function changeEndBlock(uint256 _newBlock) external onlyOwner returns (uint256 _endblock )\n', '    {   // we are expecting that owner will input number greater than current block.\n', '        require(_newBlock > fundingStartBlock);\n', '        fundingEndBlock = _newBlock;         // New block is assigned to extend the Crowd Sale time\n', '        return fundingEndBlock;\n', '    }\n', '\n', '    /**\n', '    * @dev   it will let Owner withdrawn ether at any time during the ICO\n', '    **/\n', '    function drain() external onlyOwner {\n', '        if (!ethFundDeposit.send(this.balance)) revert();// It will revert if transfer fails.\n', '    }\n', '\n', '    \n', '    \n', '    // Automate the ETH drain\n', '    \n', '    function forwardfunds() internal {\n', '         if (!ethFundDeposit.send(this.balance)) revert(); // It will revert if transfer fails.\n', '        \n', '        \n', '    }\n', '    \n', '    /**\n', '    * @dev  it will let Owner Stop the crowdsale and mint function to work.\n', '    *\n', '    */\n', '    \n', '    function emergencyToggle() external onlyOwner{\n', '      emergencyFlag = !emergencyFlag;\n', '    }\n', '\n', '    // Fallback function let user send ether without calling the buy function.\n', '    function() payable {\n', '      createTokens();\n', '\n', '    }\n', '\n', '\n', '}']