['pragma solidity ^0.4.13;\n', '\n', 'contract EthicHubStorageInterface {\n', '\n', '    //modifier for access in sets and deletes\n', '    modifier onlyEthicHubContracts() {_;}\n', '\n', '    // Setters\n', '    function setAddress(bytes32 _key, address _value) external;\n', '    function setUint(bytes32 _key, uint _value) external;\n', '    function setString(bytes32 _key, string _value) external;\n', '    function setBytes(bytes32 _key, bytes _value) external;\n', '    function setBool(bytes32 _key, bool _value) external;\n', '    function setInt(bytes32 _key, int _value) external;\n', '    // Deleters\n', '    function deleteAddress(bytes32 _key) external;\n', '    function deleteUint(bytes32 _key) external;\n', '    function deleteString(bytes32 _key) external;\n', '    function deleteBytes(bytes32 _key) external;\n', '    function deleteBool(bytes32 _key) external;\n', '    function deleteInt(bytes32 _key) external;\n', '\n', '    // Getters\n', '    function getAddress(bytes32 _key) external view returns (address);\n', '    function getUint(bytes32 _key) external view returns (uint);\n', '    function getString(bytes32 _key) external view returns (string);\n', '    function getBytes(bytes32 _key) external view returns (bytes);\n', '    function getBool(bytes32 _key) external view returns (bool);\n', '    function getInt(bytes32 _key) external view returns (int);\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract EthicHubReputationInterface {\n', '    modifier onlyUsersContract(){_;}\n', '    modifier onlyLendingContract(){_;}\n', '    function burnReputation(uint delayDays)  external;\n', '    function incrementReputation(uint completedProjectsByTier)  external;\n', '    function initLocalNodeReputation(address localNode)  external;\n', '    function initCommunityReputation(address community)  external;\n', '    function getCommunityReputation(address target) public view returns(uint256);\n', '    function getLocalNodeReputation(address target) public view returns(uint256);\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', 'contract EthicHubBase {\n', '\n', '    uint8 public version;\n', '\n', '    EthicHubStorageInterface public ethicHubStorage = EthicHubStorageInterface(0);\n', '\n', '    constructor(address _storageAddress) public {\n', '        require(_storageAddress != address(0));\n', '        ethicHubStorage = EthicHubStorageInterface(_storageAddress);\n', '    }\n', '\n', '}\n', '\n', 'contract EthicHubLending is EthicHubBase, Ownable, Pausable {\n', '    using SafeMath for uint256;\n', '    //uint256 public minContribAmount = 0.1 ether;                          // 0.1 ether\n', '    enum LendingState {\n', '        Uninitialized,\n', '        AcceptingContributions,\n', '        ExchangingToFiat,\n', '        AwaitingReturn,\n', '        ProjectNotFunded,\n', '        ContributionReturned,\n', '        Default\n', '    }\n', '    mapping(address => Investor) public investors;\n', '    uint256 public investorCount;\n', '    uint256 public fundingStartTime;                                     // Start time of contribution period in UNIX time\n', '    uint256 public fundingEndTime;                                       // End time of contribution period in UNIX time\n', '    uint256 public totalContributed;\n', '    bool public capReached;\n', '    LendingState public state;\n', '    uint256 public annualInterest;\n', '    uint256 public totalLendingAmount;\n', '    uint256 public lendingDays;\n', '    uint256 public initialEthPerFiatRate;\n', '    uint256 public totalLendingFiatAmount;\n', '    address public borrower;\n', '    address public localNode;\n', '    address public ethicHubTeam;\n', '    uint256 public borrowerReturnDate;\n', '    uint256 public borrowerReturnEthPerFiatRate;\n', '    uint256 public ethichubFee;\n', '    uint256 public localNodeFee;\n', '    uint256 public tier;\n', '    // interest rate is using base uint 100 and 100% 10000, this means 1% is 100\n', '    // this guarantee we can have a 2 decimal presicion in our calculation\n', '    uint256 public constant interestBaseUint = 100;\n', '    uint256 public constant interestBasePercent = 10000;\n', '    bool public localNodeFeeReclaimed;\n', '    bool public ethicHubTeamFeeReclaimed;\n', '    uint256 public surplusEth;\n', '    uint256 public returnedEth;\n', '\n', '    struct Investor {\n', '        uint256 amount;\n', '        bool isCompensated;\n', '        bool surplusEthReclaimed;\n', '    }\n', '\n', '    // events\n', '    event onCapReached(uint endTime);\n', '    event onContribution(uint totalContributed, address indexed investor, uint amount, uint investorsCount);\n', '    event onCompensated(address indexed contributor, uint amount);\n', '    event onSurplusSent(uint256 amount);\n', '    event onSurplusReclaimed(address indexed contributor, uint amount);\n', '    event StateChange(uint state);\n', '    event onInitalRateSet(uint rate);\n', '    event onReturnRateSet(uint rate);\n', '    event onReturnAmount(address indexed borrower, uint amount);\n', '    event onBorrowerChanged(address indexed newBorrower);\n', '    event onInvestorChanged(address indexed oldInvestor, address indexed newInvestor);\n', '\n', '    // modifiers\n', '    modifier checkProfileRegistered(string profile) {\n', '        bool isRegistered = ethicHubStorage.getBool(keccak256("user", profile, msg.sender));\n', '        require(isRegistered);\n', '        _;\n', '    }\n', '\n', '    modifier checkIfArbiter() {\n', '        address arbiter = ethicHubStorage.getAddress(keccak256("arbiter", this));\n', '        require(arbiter == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrLocalNode() {\n', '        require(localNode == msg.sender || owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyInvestorOrPaymentGateway() {\n', '        bool isInvestor = ethicHubStorage.getBool(keccak256("user", "investor", msg.sender));\n', '        bool isPaymentGateway = ethicHubStorage.getBool(keccak256("user", "paymentGateway", msg.sender));\n', '        require(isPaymentGateway || isInvestor);\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        uint256 _fundingStartTime,\n', '        uint256 _fundingEndTime,\n', '        address _borrower,\n', '        uint256 _annualInterest,\n', '        uint256 _totalLendingAmount,\n', '        uint256 _lendingDays,\n', '        address _storageAddress,\n', '        address _localNode,\n', '        address _ethicHubTeam,\n', '        uint256 _ethichubFee, \n', '        uint256 _localNodeFee \n', '        )\n', '        EthicHubBase(_storageAddress)\n', '        public {\n', '        require(_fundingStartTime > now);\n', '        require(_fundingEndTime > fundingStartTime);\n', '        require(_borrower != address(0));\n', '        require(ethicHubStorage.getBool(keccak256("user", "representative", _borrower)));\n', '        require(_localNode != address(0));\n', '        require(_ethicHubTeam != address(0));\n', '        require(ethicHubStorage.getBool(keccak256("user", "localNode", _localNode)));\n', '        require(_totalLendingAmount > 0);\n', '        require(_lendingDays > 0);\n', '        require(_annualInterest > 0 && _annualInterest < 100);\n', '        version = 3;\n', '        fundingStartTime = _fundingStartTime;\n', '        fundingEndTime = _fundingEndTime;\n', '        localNode = _localNode;\n', '        ethicHubTeam = _ethicHubTeam;\n', '        borrower = _borrower;\n', '        annualInterest = _annualInterest;\n', '        totalLendingAmount = _totalLendingAmount;\n', '        lendingDays = _lendingDays;\n', '        ethichubFee = _ethichubFee;\n', '        localNodeFee = _localNodeFee;\n', '        state = LendingState.Uninitialized;\n', '    }\n', '\n', '    function saveInitialParametersToStorage(uint256 _maxDelayDays, uint256 _tier, uint256 _communityMembers, address _community) external onlyOwnerOrLocalNode {\n', '        require(_maxDelayDays != 0);\n', '        require(state == LendingState.Uninitialized);\n', '        require(_tier > 0);\n', '        require(_communityMembers > 0);\n', '        require(ethicHubStorage.getBool(keccak256("user", "community", _community)));\n', '        ethicHubStorage.setUint(keccak256("lending.maxDelayDays", this), _maxDelayDays);\n', '        ethicHubStorage.setAddress(keccak256("lending.community", this), _community);\n', '        ethicHubStorage.setAddress(keccak256("lending.localNode", this), localNode);\n', '        ethicHubStorage.setUint(keccak256("lending.tier", this), _tier);\n', '        ethicHubStorage.setUint(keccak256("lending.communityMembers", this), _communityMembers);\n', '        tier = _tier;\n', '        state = LendingState.AcceptingContributions;\n', '        emit StateChange(uint(state));\n', '\n', '    }\n', '\n', '    function setBorrower(address _borrower) external checkIfArbiter {\n', '        require(_borrower != address(0));\n', '        require(ethicHubStorage.getBool(keccak256("user", "representative", _borrower)));\n', '        borrower = _borrower;\n', '        emit onBorrowerChanged(borrower);\n', '    }\n', '\n', '    function changeInvestorAddress(address oldInvestor, address newInvestor) external checkIfArbiter {\n', '        require(newInvestor != address(0));\n', '        require(ethicHubStorage.getBool(keccak256("user", "investor", newInvestor)));\n', '        //oldInvestor should have invested in this project\n', '        require(investors[oldInvestor].amount != 0);\n', '        //newInvestor should not have invested anything in this project to not complicate return calculation\n', '        require(investors[newInvestor].amount == 0);\n', '        investors[newInvestor].amount = investors[oldInvestor].amount;\n', '        investors[newInvestor].isCompensated = investors[oldInvestor].isCompensated;\n', '        investors[newInvestor].surplusEthReclaimed = investors[oldInvestor].surplusEthReclaimed;\n', '        delete investors[oldInvestor];\n', '        emit onInvestorChanged(oldInvestor, newInvestor);\n', '    }\n', '\n', '    function() public payable whenNotPaused {\n', '        require(state == LendingState.AwaitingReturn || state == LendingState.AcceptingContributions || state == LendingState.ExchangingToFiat);\n', '        if(state == LendingState.AwaitingReturn) {\n', '            returnBorrowedEth();\n', '        } else if (state == LendingState.ExchangingToFiat) {\n', '            // borrower can send surplus eth back to contract to avoid paying interest\n', '            sendBackSurplusEth();\n', '        } else {\n', '            require(ethicHubStorage.getBool(keccak256("user", "investor", msg.sender)));\n', '            contributeWithAddress(msg.sender);\n', '        }\n', '    }\n', '\n', '    function sendBackSurplusEth() internal {\n', '        require(state == LendingState.ExchangingToFiat);\n', '        require(msg.sender == borrower);\n', '        surplusEth = surplusEth.add(msg.value);\n', '        require(surplusEth <= totalLendingAmount);\n', '        emit onSurplusSent(msg.value);\n', '    }\n', '\n', '    /**\n', '     * After the contribution period ends unsuccesfully, this method enables the contributor\n', '     *  to retrieve their contribution\n', '     */\n', '    function declareProjectNotFunded() external onlyOwnerOrLocalNode {\n', '        require(totalContributed < totalLendingAmount);\n', '        require(state == LendingState.AcceptingContributions);\n', '        require(now > fundingEndTime);\n', '        state = LendingState.ProjectNotFunded;\n', '        emit StateChange(uint(state));\n', '    }\n', '\n', '    function declareProjectDefault() external onlyOwnerOrLocalNode {\n', '        require(state == LendingState.AwaitingReturn);\n', '        uint maxDelayDays = getMaxDelayDays();\n', '        require(getDelayDays(now) >= maxDelayDays);\n', '        EthicHubReputationInterface reputation = EthicHubReputationInterface(ethicHubStorage.getAddress(keccak256("contract.name", "reputation")));\n', '        require(reputation != address(0));\n', '        ethicHubStorage.setUint(keccak256("lending.delayDays", this), maxDelayDays);\n', '        reputation.burnReputation(maxDelayDays);\n', '        state = LendingState.Default;\n', '        emit StateChange(uint(state));\n', '    }\n', '\n', '    function setBorrowerReturnEthPerFiatRate(uint256 _borrowerReturnEthPerFiatRate) external onlyOwnerOrLocalNode {\n', '        require(state == LendingState.AwaitingReturn);\n', '        borrowerReturnEthPerFiatRate = _borrowerReturnEthPerFiatRate;\n', '        emit onReturnRateSet(borrowerReturnEthPerFiatRate);\n', '    }\n', '\n', '    function finishInitialExchangingPeriod(uint256 _initialEthPerFiatRate) external onlyOwnerOrLocalNode {\n', '        require(capReached == true);\n', '        require(state == LendingState.ExchangingToFiat);\n', '        initialEthPerFiatRate = _initialEthPerFiatRate;\n', '        if (surplusEth > 0) {\n', '            totalLendingAmount = totalLendingAmount.sub(surplusEth);\n', '        }\n', '        totalLendingFiatAmount = totalLendingAmount.mul(initialEthPerFiatRate);\n', '        emit onInitalRateSet(initialEthPerFiatRate);\n', '        state = LendingState.AwaitingReturn;\n', '        emit StateChange(uint(state));\n', '    }\n', '\n', '    /**\n', '     * Method to reclaim contribution after project is declared default (% of partial funds)\n', '     * @param  beneficiary the contributor\n', '     *\n', '     */\n', '    function reclaimContributionDefault(address beneficiary) external {\n', '        require(state == LendingState.Default);\n', '        require(!investors[beneficiary].isCompensated);\n', '        // contribution = contribution * partial_funds / total_funds\n', '        uint256 contribution = checkInvestorReturns(beneficiary);\n', '        require(contribution > 0);\n', '        investors[beneficiary].isCompensated = true;\n', '        beneficiary.transfer(contribution);\n', '    }\n', '\n', '    /**\n', '     * Method to reclaim contribution after a project is declared as not funded\n', '     * @param  beneficiary the contributor\n', '     *\n', '     */\n', '    function reclaimContribution(address beneficiary) external {\n', '        require(state == LendingState.ProjectNotFunded);\n', '        require(!investors[beneficiary].isCompensated);\n', '        uint256 contribution = investors[beneficiary].amount;\n', '        require(contribution > 0);\n', '        investors[beneficiary].isCompensated = true;\n', '        beneficiary.transfer(contribution);\n', '    }\n', '\n', '    function reclaimSurplusEth(address beneficiary) external {\n', '        require(surplusEth > 0);\n', '        // only can be reclaimed after cap reduced\n', '        require(state != LendingState.ExchangingToFiat);\n', '        require(!investors[beneficiary].surplusEthReclaimed);\n', '        uint256 surplusContribution = investors[beneficiary].amount.mul(surplusEth).div(surplusEth.add(totalLendingAmount));\n', '        require(surplusContribution > 0);\n', '        investors[beneficiary].surplusEthReclaimed = true;\n', '        emit onSurplusReclaimed(beneficiary, surplusContribution);\n', '        beneficiary.transfer(surplusContribution);\n', '    }\n', '\n', '    function reclaimContributionWithInterest(address beneficiary) external {\n', '        require(state == LendingState.ContributionReturned);\n', '        require(!investors[beneficiary].isCompensated);\n', '        uint256 contribution = checkInvestorReturns(beneficiary);\n', '        require(contribution > 0);\n', '        investors[beneficiary].isCompensated = true;\n', '        beneficiary.transfer(contribution);\n', '    }\n', '\n', '    function reclaimLocalNodeFee() external {\n', '        require(state == LendingState.ContributionReturned);\n', '        require(localNodeFeeReclaimed == false);\n', '        uint256 fee = totalLendingFiatAmount.mul(localNodeFee).mul(interestBaseUint).div(interestBasePercent).div(borrowerReturnEthPerFiatRate);\n', '        require(fee > 0);\n', '        localNodeFeeReclaimed = true;\n', '        localNode.transfer(fee);\n', '    }\n', '\n', '    function reclaimEthicHubTeamFee() external {\n', '        require(state == LendingState.ContributionReturned);\n', '        require(ethicHubTeamFeeReclaimed == false);\n', '        uint256 fee = totalLendingFiatAmount.mul(ethichubFee).mul(interestBaseUint).div(interestBasePercent).div(borrowerReturnEthPerFiatRate);\n', '        require(fee > 0);\n', '        ethicHubTeamFeeReclaimed = true;\n', '        ethicHubTeam.transfer(fee);\n', '    }\n', '\n', '    function returnBorrowedEth() internal {\n', '        require(state == LendingState.AwaitingReturn);\n', '        require(msg.sender == borrower);\n', '        require(borrowerReturnEthPerFiatRate > 0);\n', '        bool projectRepayed = false;\n', '        uint excessRepayment = 0;\n', '        uint newReturnedEth = 0;\n', '        emit onReturnAmount(msg.sender, msg.value);\n', '        (newReturnedEth, projectRepayed, excessRepayment) = calculatePaymentGoal(\n', '                                                                                    borrowerReturnAmount(),\n', '                                                                                    returnedEth,\n', '                                                                                    msg.value);\n', '        returnedEth = newReturnedEth;\n', '        if (projectRepayed == true) {\n', '            state = LendingState.ContributionReturned;\n', '            emit StateChange(uint(state));\n', '            updateReputation();\n', '        }\n', '        if (excessRepayment > 0) {\n', '            msg.sender.transfer(excessRepayment);\n', '        }\n', '    }\n', '\n', '    // @notice make cotribution throught a paymentGateway\n', '    // @param contributor Address\n', "    function contributeForAddress(address contributor) external checkProfileRegistered('paymentGateway') payable whenNotPaused {\n", '        contributeWithAddress(contributor);\n', '    }\n', '\n', '    // @notice Function to participate in contribution period\n', '    //  Amounts from the same address should be added up\n', '    //  If cap is reached, end time should be modified\n', '    //  Funds should be transferred into multisig wallet\n', '    // @param contributor Address\n', '    function contributeWithAddress(address contributor) internal whenNotPaused {\n', '        require(state == LendingState.AcceptingContributions);\n', '        //require(msg.value >= minContribAmount);\n', '        require(isContribPeriodRunning());\n', '\n', '        uint oldTotalContributed = totalContributed;\n', '        uint newTotalContributed = 0;\n', '        uint excessContribValue = 0;\n', '        (newTotalContributed, capReached, excessContribValue) = calculatePaymentGoal(\n', '                                                                                    totalLendingAmount,\n', '                                                                                    oldTotalContributed,\n', '                                                                                    msg.value);\n', '        totalContributed = newTotalContributed;\n', '        if (capReached) {\n', '            fundingEndTime = now;\n', '            emit onCapReached(fundingEndTime);\n', '        }\n', '        if (investors[contributor].amount == 0) {\n', '            investorCount = investorCount.add(1);\n', '        }\n', '        if (excessContribValue > 0) {\n', '            msg.sender.transfer(excessContribValue);\n', '            investors[contributor].amount = investors[contributor].amount.add(msg.value).sub(excessContribValue);\n', '            emit onContribution(newTotalContributed, contributor, msg.value.sub(excessContribValue), investorCount);\n', '        } else {\n', '            investors[contributor].amount = investors[contributor].amount.add(msg.value);\n', '            emit onContribution(newTotalContributed, contributor, msg.value, investorCount);\n', '        }\n', '    }\n', '\n', '    function calculatePaymentGoal(uint goal, uint oldTotal, uint contribValue) internal pure returns(uint, bool, uint) {\n', '        uint newTotal = oldTotal.add(contribValue);\n', '        bool goalReached = false;\n', '        uint excess = 0;\n', '        if (newTotal >= goal && oldTotal < goal) {\n', '            goalReached = true;\n', '            excess = newTotal.sub(goal);\n', '            contribValue = contribValue.sub(excess);\n', '            newTotal = goal;\n', '        }\n', '        return (newTotal, goalReached, excess);\n', '    }\n', '\n', '    function sendFundsToBorrower() external onlyOwnerOrLocalNode {\n', '      //Waiting for Exchange\n', '        require(state == LendingState.AcceptingContributions);\n', '        require(capReached);\n', '        state = LendingState.ExchangingToFiat;\n', '        emit StateChange(uint(state));\n', '        borrower.transfer(totalContributed);\n', '    }\n', '\n', '    function updateReputation() internal {\n', '        uint delayDays = getDelayDays(now);\n', '        EthicHubReputationInterface reputation = EthicHubReputationInterface(ethicHubStorage.getAddress(keccak256("contract.name", "reputation")));\n', '        require(reputation != address(0));\n', '        if (delayDays > 0) {\n', '            ethicHubStorage.setUint(keccak256("lending.delayDays", this), delayDays);\n', '            reputation.burnReputation(delayDays);\n', '        } else {\n', '            uint completedProjectsByTier  = ethicHubStorage.getUint(keccak256("community.completedProjectsByTier", this, tier)).add(1);\n', '            ethicHubStorage.setUint(keccak256("community.completedProjectsByTier", this, tier), completedProjectsByTier);\n', '            reputation.incrementReputation(completedProjectsByTier);\n', '        }\n', '    }\n', '\n', '    function getDelayDays(uint date) public view returns(uint) {\n', '        uint lendingDaysSeconds = lendingDays * 1 days;\n', '        uint defaultTime = fundingEndTime.add(lendingDaysSeconds);\n', '        if (date < defaultTime) {\n', '            return 0;\n', '        } else {\n', '            return date.sub(defaultTime).div(60).div(60).div(24);\n', '        }\n', '    }\n', '\n', '    // lendingInterestRate with 2 decimal\n', '    // 15 * (lending days)/ 365 + 4% local node fee + 3% LendingDev fee\n', '    function lendingInterestRatePercentage() public view returns(uint256){\n', '        return annualInterest.mul(interestBaseUint).mul(lendingDays.add(getDelayDays(now))).div(365).add(localNodeFee.mul(interestBaseUint)).add(ethichubFee.mul(interestBaseUint)).add(interestBasePercent);\n', '    }\n', '\n', '    // lendingInterestRate with 2 decimal\n', '    function investorInterest() public view returns(uint256){\n', '        return annualInterest.mul(interestBaseUint).mul(lendingDays.add(getDelayDays(now))).div(365).add(interestBasePercent);\n', '    }\n', '\n', '    function borrowerReturnFiatAmount() public view returns(uint256) {\n', '        return totalLendingFiatAmount.mul(lendingInterestRatePercentage()).div(interestBasePercent);\n', '    }\n', '\n', '    function borrowerReturnAmount() public view returns(uint256) {\n', '        return borrowerReturnFiatAmount().div(borrowerReturnEthPerFiatRate);\n', '    }\n', '\n', '    function isContribPeriodRunning() public view returns(bool) {\n', '        return fundingStartTime <= now && fundingEndTime > now && !capReached;\n', '    }\n', '\n', '    function checkInvestorContribution(address investor) public view returns(uint256){\n', '        return investors[investor].amount;\n', '    }\n', '\n', '    function checkInvestorReturns(address investor) public view returns(uint256) {\n', '        uint256 investorAmount = 0;\n', '        if (state == LendingState.ContributionReturned) {\n', '            investorAmount = investors[investor].amount;\n', '            if (surplusEth > 0){\n', '                investorAmount  = investors[investor].amount.mul(totalLendingAmount).div(totalContributed);\n', '            }\n', '            return investorAmount.mul(initialEthPerFiatRate).mul(investorInterest()).div(borrowerReturnEthPerFiatRate).div(interestBasePercent);\n', '        } else if (state == LendingState.Default){\n', '            investorAmount = investors[investor].amount;\n', '            // contribution = contribution * partial_funds / total_funds\n', '            return investorAmount.mul(returnedEth).div(totalLendingAmount);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function getMaxDelayDays() public view returns(uint256){\n', '        return ethicHubStorage.getUint(keccak256("lending.maxDelayDays", this));\n', '    }\n', '\n', '    function getUserContributionReclaimStatus(address userAddress) public view returns(bool isCompensated, bool surplusEthReclaimed){\n', '        isCompensated = investors[userAddress].isCompensated;\n', '        surplusEthReclaimed = investors[userAddress].surplusEthReclaimed;\n', '    }\n', '}']