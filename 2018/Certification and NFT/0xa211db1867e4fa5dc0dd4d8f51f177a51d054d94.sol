['pragma solidity ^0.4.18;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() public{\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      revert();\n', '    }\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner public{\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) pure internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) pure internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint);\n', '  function allowance(address owner, address spender) public constant returns (uint);\n', '\n', '  function transfer(address to, uint value) public returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '  function approve(address spender, uint value) public returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transfer(address _to, uint _value) public returns (bool success) {\n', '      \n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '    \n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) public constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) public returns (bool success) {\n', '      \n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract ZTKGamers is Ownable, StandardToken {\n', '\n', '    string public name = "ZTKGamers";                     // name of the token\n', '    string public symbol = "ZTK";                         // ERC20 compliant 4 digit token code\n', '    uint public decimals = 18;                            // 18 digit precision\n', '\n', '    uint256 public totalSupply =  5000000000 * (10**decimals); // 5B INITIAL SUPPLY\n', '    uint256 public tokenSupplyFromCheck = 0;              // Total from check!\n', '        \n', '    /// Base exchange rate is set\n', '    uint256 public ratePerOneEther = 962;\n', '    uint256 public totalZTKCheckAmounts = 0;\n', '\n', '    /// Issue event index starting from 0.\n', '    uint64 public issueIndex = 0;\n', '\n', '    /// Emitted for each sucuessful token purchase.\n', '    event Issue(uint64 issueIndex, address addr, uint256 tokenAmount);\n', '    \n', '    // All funds will be transferred in this wallet.\n', '    address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953;\n', '\n', '    /// Emitted for each ZTKCHECKS register.\n', '    event ZTKCheckIssue(string chequeIndex);\n', '      \n', '    struct ZTKCheck {\n', '      string accountId;\n', '      string accountNumber;\n', '      string fullName;\n', '      string routingNumber;\n', '      string institution;\n', '      uint256 amount;\n', '      uint256 tokens;\n', '      string checkFilePath;\n', '      string digitalCheckFingerPrint;\n', '    }\n', '    \n', '    mapping (address => ZTKCheck) ZTKChecks;\n', '    address[] public ZTKCheckAccts;\n', '    \n', '    \n', '    /// @dev Initializes the contract and allocates all initial tokens to the owner\n', '    function ZTKGamers() public{\n', '        balances[msg.sender] = totalSupply;\n', '    }\n', '  \n', '    //////////////// owner only functions below\n', '\n', '    /// @dev To transfer token contract ownership\n', '    /// @param _newOwner The address of the new owner of this contract\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        balances[_newOwner] = balances[owner];\n', '        balances[owner] = 0;\n', '        Ownable.transferOwnership(_newOwner);\n', '    }\n', '    \n', '    /// check functionality\n', '    \n', '    /// @dev Register ZTKCheck to the chain\n', '    /// @param _beneficiary recipient ether address\n', '    /// @param _accountId the id generated from the db\n', '    /// @param _accountNumber the account number stated in the check\n', '    /// @param _routingNumber the routing number stated in the check\n', '    /// @param _institution the name of the institution / bank in the check\n', '    /// @param _fullname the name printed on the check\n', '    /// @param _amount the amount in currency in the chek\n', '    /// @param _checkFilePath the url path where the cheque has been uploaded\n', '    /// @param _digitalCheckFingerPrint the hash of the file\n', '    /// @param _tokens number of tokens issued to the beneficiary\n', '    function registerZTKCheck(address _beneficiary, string _accountId,  string _accountNumber, string _routingNumber, string _institution, string _fullname,  uint256 _amount, string _checkFilePath, string _digitalCheckFingerPrint, uint256 _tokens) public payable onlyOwner {\n', '      \n', '      require(_beneficiary != address(0));\n', '      require(bytes(_accountId).length != 0);\n', '      require(bytes(_accountNumber).length != 0);\n', '      require(bytes(_routingNumber).length != 0);\n', '      require(bytes(_institution).length != 0);\n', '      require(bytes(_fullname).length != 0);\n', '      require(_amount > 0);\n', '      require(_tokens > 0);\n', '      require(bytes(_checkFilePath).length != 0);\n', '      require(bytes(_digitalCheckFingerPrint).length != 0);\n', '      \n', '      var __conToken = _tokens * (10**(decimals));\n', '\n', '      \n', '      var ztkCheck = ZTKChecks[_beneficiary];\n', '      \n', '      ztkCheck.accountId = _accountId;\n', '      ztkCheck.accountNumber = _accountNumber;\n', '      ztkCheck.routingNumber = _routingNumber;\n', '      ztkCheck.institution = _institution;\n', '      ztkCheck.fullName = _fullname;\n', '      ztkCheck.amount = _amount;\n', '      ztkCheck.tokens = _tokens;\n', '      \n', '      ztkCheck.checkFilePath = _checkFilePath;\n', '      ztkCheck.digitalCheckFingerPrint = _digitalCheckFingerPrint;\n', '      \n', '      totalZTKCheckAmounts = safeAdd(totalZTKCheckAmounts, _amount);\n', '      tokenSupplyFromCheck = safeAdd(tokenSupplyFromCheck, _tokens);\n', '      \n', '      ZTKCheckAccts.push(_beneficiary) -1;\n', '      \n', '      // Issue token when registered ZTKCheck is complete to the _beneficiary\n', '      doIssueTokens(_beneficiary, __conToken);\n', '      \n', '      // Fire Event ZTKCheckIssue\n', '      ZTKCheckIssue(_accountId);\n', '    }\n', '    \n', '    /// @dev List all the checks in the\n', '    function getZTKChecks() public view returns (address[]) {\n', '      return ZTKCheckAccts;\n', '    }\n', '    \n', '    /// @dev Return ZTKCheck information by supplying beneficiary adddress\n', '    function getZTKCheck(address _address) public view returns(string, string, string, string, uint256, string, string) {\n', '            \n', '      return (ZTKChecks[_address].accountNumber,\n', '              ZTKChecks[_address].routingNumber,\n', '              ZTKChecks[_address].institution,\n', '              ZTKChecks[_address].fullName,\n', '              ZTKChecks[_address].amount,\n', '              ZTKChecks[_address].checkFilePath,\n', '              ZTKChecks[_address].digitalCheckFingerPrint);\n', '    }\n', '    \n', '    /// @dev This default function allows token to be purchased by directly\n', '    /// sending ether to this smart contract.\n', '    function () public payable {\n', '      purchaseTokens(msg.sender);\n', '    }\n', '\n', '    /// @dev return total count of registered ZTKChecks\n', '    function countZTKChecks() public view returns (uint) {\n', '        return ZTKCheckAccts.length;\n', '    }\n', '    \n', '\n', '    /// @dev issue tokens for a single buyer\n', '    /// @param _beneficiary addresses that the tokens will be sent to.\n', '    /// @param _tokens the amount of tokens, with decimals expanded (full).\n', '    function doIssueTokens(address _beneficiary, uint256 _tokens) internal {\n', '      require(_beneficiary != address(0));    \n', '\n', '      // compute without actually increasing it\n', '      uint256 increasedTotalSupply = safeAdd(totalSupply, _tokens);\n', '      \n', '      // increase token total supply\n', '      totalSupply = increasedTotalSupply;\n', '      // update the beneficiary balance to number of tokens sent\n', '      balances[_beneficiary] = safeAdd(balances[_beneficiary], _tokens);\n', '      \n', '      Transfer(msg.sender, _beneficiary, _tokens);\n', '    \n', '      // event is fired when tokens issued\n', '      Issue(\n', '          issueIndex++,\n', '          _beneficiary,\n', '          _tokens\n', '      );\n', '    }\n', '    \n', '    /// @dev Issue token based on Ether received.\n', '    /// @param _beneficiary Address that newly issued token will be sent to.\n', '    function purchaseTokens(address _beneficiary) public payable {\n', '      \n', '      uint _tokens = safeDiv(safeMul(msg.value, ratePerOneEther), (10**(18-decimals)));\n', '      doIssueTokens(_beneficiary, _tokens);\n', '\n', '      /// forward the money to the money wallet\n', '      moneyWallet.transfer(this.balance);\n', '    }\n', '    \n', '    \n', '    /// @dev Change money wallet owner\n', '    /// @param _address new address to received the ether\n', '    function setMoneyWallet(address _address) public onlyOwner {\n', '        moneyWallet = _address;\n', '    }\n', '    \n', '    /// @dev Change Rate per token in one ether\n', '    /// @param _value the amount of tokens, with decimals expanded (full).\n', '    function setRatePerOneEther(uint256 _value) public onlyOwner {\n', '      require(_value >= 1);\n', '      ratePerOneEther = _value;\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() public{\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      revert();\n', '    }\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner public{\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) pure internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) pure internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint);\n', '  function allowance(address owner, address spender) public constant returns (uint);\n', '\n', '  function transfer(address to, uint value) public returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '  function approve(address spender, uint value) public returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transfer(address _to, uint _value) public returns (bool success) {\n', '      \n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '    \n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) public constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) public returns (bool success) {\n', '      \n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract ZTKGamers is Ownable, StandardToken {\n', '\n', '    string public name = "ZTKGamers";                     // name of the token\n', '    string public symbol = "ZTK";                         // ERC20 compliant 4 digit token code\n', '    uint public decimals = 18;                            // 18 digit precision\n', '\n', '    uint256 public totalSupply =  5000000000 * (10**decimals); // 5B INITIAL SUPPLY\n', '    uint256 public tokenSupplyFromCheck = 0;              // Total from check!\n', '        \n', '    /// Base exchange rate is set\n', '    uint256 public ratePerOneEther = 962;\n', '    uint256 public totalZTKCheckAmounts = 0;\n', '\n', '    /// Issue event index starting from 0.\n', '    uint64 public issueIndex = 0;\n', '\n', '    /// Emitted for each sucuessful token purchase.\n', '    event Issue(uint64 issueIndex, address addr, uint256 tokenAmount);\n', '    \n', '    // All funds will be transferred in this wallet.\n', '    address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953;\n', '\n', '    /// Emitted for each ZTKCHECKS register.\n', '    event ZTKCheckIssue(string chequeIndex);\n', '      \n', '    struct ZTKCheck {\n', '      string accountId;\n', '      string accountNumber;\n', '      string fullName;\n', '      string routingNumber;\n', '      string institution;\n', '      uint256 amount;\n', '      uint256 tokens;\n', '      string checkFilePath;\n', '      string digitalCheckFingerPrint;\n', '    }\n', '    \n', '    mapping (address => ZTKCheck) ZTKChecks;\n', '    address[] public ZTKCheckAccts;\n', '    \n', '    \n', '    /// @dev Initializes the contract and allocates all initial tokens to the owner\n', '    function ZTKGamers() public{\n', '        balances[msg.sender] = totalSupply;\n', '    }\n', '  \n', '    //////////////// owner only functions below\n', '\n', '    /// @dev To transfer token contract ownership\n', '    /// @param _newOwner The address of the new owner of this contract\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        balances[_newOwner] = balances[owner];\n', '        balances[owner] = 0;\n', '        Ownable.transferOwnership(_newOwner);\n', '    }\n', '    \n', '    /// check functionality\n', '    \n', '    /// @dev Register ZTKCheck to the chain\n', '    /// @param _beneficiary recipient ether address\n', '    /// @param _accountId the id generated from the db\n', '    /// @param _accountNumber the account number stated in the check\n', '    /// @param _routingNumber the routing number stated in the check\n', '    /// @param _institution the name of the institution / bank in the check\n', '    /// @param _fullname the name printed on the check\n', '    /// @param _amount the amount in currency in the chek\n', '    /// @param _checkFilePath the url path where the cheque has been uploaded\n', '    /// @param _digitalCheckFingerPrint the hash of the file\n', '    /// @param _tokens number of tokens issued to the beneficiary\n', '    function registerZTKCheck(address _beneficiary, string _accountId,  string _accountNumber, string _routingNumber, string _institution, string _fullname,  uint256 _amount, string _checkFilePath, string _digitalCheckFingerPrint, uint256 _tokens) public payable onlyOwner {\n', '      \n', '      require(_beneficiary != address(0));\n', '      require(bytes(_accountId).length != 0);\n', '      require(bytes(_accountNumber).length != 0);\n', '      require(bytes(_routingNumber).length != 0);\n', '      require(bytes(_institution).length != 0);\n', '      require(bytes(_fullname).length != 0);\n', '      require(_amount > 0);\n', '      require(_tokens > 0);\n', '      require(bytes(_checkFilePath).length != 0);\n', '      require(bytes(_digitalCheckFingerPrint).length != 0);\n', '      \n', '      var __conToken = _tokens * (10**(decimals));\n', '\n', '      \n', '      var ztkCheck = ZTKChecks[_beneficiary];\n', '      \n', '      ztkCheck.accountId = _accountId;\n', '      ztkCheck.accountNumber = _accountNumber;\n', '      ztkCheck.routingNumber = _routingNumber;\n', '      ztkCheck.institution = _institution;\n', '      ztkCheck.fullName = _fullname;\n', '      ztkCheck.amount = _amount;\n', '      ztkCheck.tokens = _tokens;\n', '      \n', '      ztkCheck.checkFilePath = _checkFilePath;\n', '      ztkCheck.digitalCheckFingerPrint = _digitalCheckFingerPrint;\n', '      \n', '      totalZTKCheckAmounts = safeAdd(totalZTKCheckAmounts, _amount);\n', '      tokenSupplyFromCheck = safeAdd(tokenSupplyFromCheck, _tokens);\n', '      \n', '      ZTKCheckAccts.push(_beneficiary) -1;\n', '      \n', '      // Issue token when registered ZTKCheck is complete to the _beneficiary\n', '      doIssueTokens(_beneficiary, __conToken);\n', '      \n', '      // Fire Event ZTKCheckIssue\n', '      ZTKCheckIssue(_accountId);\n', '    }\n', '    \n', '    /// @dev List all the checks in the\n', '    function getZTKChecks() public view returns (address[]) {\n', '      return ZTKCheckAccts;\n', '    }\n', '    \n', '    /// @dev Return ZTKCheck information by supplying beneficiary adddress\n', '    function getZTKCheck(address _address) public view returns(string, string, string, string, uint256, string, string) {\n', '            \n', '      return (ZTKChecks[_address].accountNumber,\n', '              ZTKChecks[_address].routingNumber,\n', '              ZTKChecks[_address].institution,\n', '              ZTKChecks[_address].fullName,\n', '              ZTKChecks[_address].amount,\n', '              ZTKChecks[_address].checkFilePath,\n', '              ZTKChecks[_address].digitalCheckFingerPrint);\n', '    }\n', '    \n', '    /// @dev This default function allows token to be purchased by directly\n', '    /// sending ether to this smart contract.\n', '    function () public payable {\n', '      purchaseTokens(msg.sender);\n', '    }\n', '\n', '    /// @dev return total count of registered ZTKChecks\n', '    function countZTKChecks() public view returns (uint) {\n', '        return ZTKCheckAccts.length;\n', '    }\n', '    \n', '\n', '    /// @dev issue tokens for a single buyer\n', '    /// @param _beneficiary addresses that the tokens will be sent to.\n', '    /// @param _tokens the amount of tokens, with decimals expanded (full).\n', '    function doIssueTokens(address _beneficiary, uint256 _tokens) internal {\n', '      require(_beneficiary != address(0));    \n', '\n', '      // compute without actually increasing it\n', '      uint256 increasedTotalSupply = safeAdd(totalSupply, _tokens);\n', '      \n', '      // increase token total supply\n', '      totalSupply = increasedTotalSupply;\n', '      // update the beneficiary balance to number of tokens sent\n', '      balances[_beneficiary] = safeAdd(balances[_beneficiary], _tokens);\n', '      \n', '      Transfer(msg.sender, _beneficiary, _tokens);\n', '    \n', '      // event is fired when tokens issued\n', '      Issue(\n', '          issueIndex++,\n', '          _beneficiary,\n', '          _tokens\n', '      );\n', '    }\n', '    \n', '    /// @dev Issue token based on Ether received.\n', '    /// @param _beneficiary Address that newly issued token will be sent to.\n', '    function purchaseTokens(address _beneficiary) public payable {\n', '      \n', '      uint _tokens = safeDiv(safeMul(msg.value, ratePerOneEther), (10**(18-decimals)));\n', '      doIssueTokens(_beneficiary, _tokens);\n', '\n', '      /// forward the money to the money wallet\n', '      moneyWallet.transfer(this.balance);\n', '    }\n', '    \n', '    \n', '    /// @dev Change money wallet owner\n', '    /// @param _address new address to received the ether\n', '    function setMoneyWallet(address _address) public onlyOwner {\n', '        moneyWallet = _address;\n', '    }\n', '    \n', '    /// @dev Change Rate per token in one ether\n', '    /// @param _value the amount of tokens, with decimals expanded (full).\n', '    function setRatePerOneEther(uint256 _value) public onlyOwner {\n', '      require(_value >= 1);\n', '      ratePerOneEther = _value;\n', '    }\n', '    \n', '}']
