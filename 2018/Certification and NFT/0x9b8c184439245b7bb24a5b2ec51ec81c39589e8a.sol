['pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Owner {\n', '    address public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Owner(address _owner) public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function changeOwner(address _newOwnerAddr) public onlyOwner {\n', '        require(_newOwnerAddr != address(0));\n', '        owner = _newOwnerAddr;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract KIMEX is Owner {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name = "KIMEX";\n', '    string public constant symbol = "KMX";\n', '    uint public constant decimals = 18;\n', '    uint256 constant public totalSupply = 250000000 * 10 ** 18; // 375 mil tokens will be supplied\n', '  \n', '    mapping(address => uint256) internal balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '    address public adminAddress;\n', '    address public walletAddress;\n', '    address public founderAddress;\n', '    address public teamAddress;\n', '\n', '    mapping(address => bool) public whiteList;\n', '    mapping(address => uint256) public totalInvestedAmountOf;\n', '\n', '    uint constant lockPeriod1 = 1 years; // 1nd locked period for tokens allocation of founder and team\n', '   \n', '    uint constant NOT_SALE = 0; // Not in sales\n', '    uint constant IN_SALE = 1;  // In sales\n', '    uint constant END_SALE = 2; // End sales\n', '\n', '    uint256 public constant salesAllocation = 150000000 * 10 ** 18; // 150 mil tokens allocated for sales\n', '    uint256 public constant reservedAllocation = 22500000 * 10 ** 18; // 22.5 mil tokens allocated for reserved, bounty campaigns, ICO partners, and bonus fund\n', '    uint256 public constant founderAllocation = 50000000 * 10 ** 18; // 50 mil tokens allocated for founders\n', '    uint256 public constant teamAllocation = 22500000 * 10 ** 18; // 22.5 mil tokens allocated for team\n', '    uint256 public constant minInvestedCap = 5000 * 10 ** 18; // 5000 ether for softcap \n', '    uint256 public constant minInvestedAmount = 0.1 * 10 ** 18; // 0.1 ether for mininum ether contribution per transaction\n', '    \n', '    uint saleState;\n', '    uint256 totalInvestedAmount;\n', '    uint public icoStartTime;\n', '    uint public icoEndTime;\n', '    bool public inActive;\n', '    bool public isSelling;\n', '    bool public isTransferable;\n', '    uint public founderAllocatedTime = 1;\n', '    uint public teamAllocatedTime = 1;\n', '    uint256 public icoStandardPrice;\n', ' \n', '    uint256 public totalRemainingTokensForSales; // Total tokens remaining for sales\n', '    uint256 public totalReservedTokenAllocation; // Total tokens allocated for reserved and bonuses\n', '    uint256 public totalLoadedRefund; // Total ether will be loaded to contract for refund\n', '    uint256 public totalRefundedAmount; // Total ether refunded to investors\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value); // ERC20 standard event\n', '    event Transfer(address indexed from, address indexed to, uint256 value); // ERC20 standard event\n', '\n', '    event ModifyWhiteList(address investorAddress, bool isWhiteListed);  // Add or remove investor&#39;s address to or from white list\n', '    event StartICO(uint state); // Start ICO sales\n', '    event EndICO(uint state); // End ICO sales\n', '    \n', '    event SetICOPrice(uint256 price); // Set ICO standard price\n', '    \n', '    \n', '    event IssueTokens(address investorAddress, uint256 amount, uint256 tokenAmount, uint state); // Issue tokens to investor\n', '    event AllocateTokensForFounder(address founderAddress, uint256 founderAllocatedTime, uint256 tokenAmount); // Allocate tokens to founders&#39; address\n', '    event AllocateTokensForTeam(address teamAddress, uint256 teamAllocatedTime, uint256 tokenAmount); // Allocate tokens to team&#39;s address\n', '    event AllocateReservedTokens(address reservedAddress, uint256 tokenAmount); // Allocate reserved tokens\n', '    event AllocateSalesTokens(address salesAllocation, uint256 tokenAmount); // Allocate sales tokens\n', '    \n', '\n', '    modifier isActive() {\n', '        require(inActive == false);\n', '        _;\n', '    }\n', '\n', '    modifier isInSale() {\n', '        require(isSelling == true);\n', '        _;\n', '    }\n', '\n', '    modifier transferable() {\n', '        require(isTransferable == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrAdminOrPortal() {\n', '        require(msg.sender == owner || msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrAdmin() {\n', '        require(msg.sender == owner || msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    function KIMEX(address _walletAddr, address _adminAddr) public Owner(msg.sender) {\n', '        require(_walletAddr != address(0));\n', '        require(_adminAddr != address(0));\n', '\t\t\n', '        walletAddress = _walletAddr;\n', '        adminAddress = _adminAddr;\n', '        inActive = true;\n', '        totalInvestedAmount = 0;\n', '        totalRemainingTokensForSales = salesAllocation;\n', '        totalReservedTokenAllocation = reservedAllocation;\n', '    }\n', '\n', '    // Fallback function for token purchasing  \n', '    function () external payable isActive isInSale {\n', '        uint state = getCurrentState();\n', '        require(state < END_SALE);\n', '        require(msg.value >= minInvestedAmount);\n', '       \n', '        if (state <= IN_SALE) {\n', '            return issueTokensForICO(state);\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Load ether amount to contract for refunding or revoking\n', '    function loadFund() external payable {\n', '        require(msg.value > 0);\n', '\t\t\n', '        totalLoadedRefund = totalLoadedRefund.add(msg.value);\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function transfer(address _to, uint256 _value) external transferable returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function transferFrom(address _from, address _to, uint256 _value) external transferable returns (bool) {\n', '        require(_to != address(0));\n', '        require(_from != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function approve(address _spender, uint256 _value) external transferable returns (bool) {\n', '        require(_spender != address(0));\n', '        require(_value > 0);\n', '\t\t\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // Modify white list\n', '    function modifyWhiteList(address[] _investorAddrs, bool _isWhiteListed) external isActive onlyOwnerOrAdminOrPortal returns(bool) {\n', '        for (uint256 i = 0; i < _investorAddrs.length; i++) {\n', '            whiteList[_investorAddrs[i]] = _isWhiteListed;\n', '            emit ModifyWhiteList(_investorAddrs[i], _isWhiteListed);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Start ICO\n', '    function startICO() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(icoStandardPrice > 0);\n', '        saleState = IN_SALE;\n', '        icoStartTime = now;\n', '        isSelling = true;\n', '        emit StartICO(saleState);\n', '        return true;\n', '    }\n', '\n', '    // End ICO\n', '    function endICO() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(icoEndTime == 0);\n', '\t\t\n', '        saleState = END_SALE;\n', '        isSelling = false;\n', '        icoEndTime = now;\n', '        emit EndICO(saleState);\n', '        return true;\n', '    }\n', '    \n', '    // Set ICO price including ICO standard price\n', '    function setICOPrice(uint256 _tokenPerEther) external onlyOwnerOrAdmin returns(bool) {\n', '        require(_tokenPerEther > 0);\n', '    \t\t\n', '        icoStandardPrice = _tokenPerEther;\n', '        emit SetICOPrice(icoStandardPrice);\n', '        return true;\n', '    }\n', '    // Activate token sale function\n', '    function activate() external onlyOwner {\n', '        inActive = false;\n', '    }\n', '\n', '    // Deacivate token sale function\n', '    function deActivate() external onlyOwner {\n', '        inActive = true;\n', '    }\n', '\n', '    // Enable transfer feature of tokens\n', '    function enableTokenTransfer() external isActive onlyOwner {\n', '        isTransferable = true;\n', '    }\n', '\n', '    // Modify wallet\n', '    function changeWallet(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(walletAddress != _newAddress);\n', '        walletAddress = _newAddress;\n', '    }\n', '\n', '    // Modify admin\n', '    function changeAdminAddress(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(adminAddress != _newAddress);\n', '        adminAddress = _newAddress;\n', '    }\n', '  \n', '    // Modify founder address to receive founder tokens allocation\n', '    function changeFounderAddress(address _newAddress) external onlyOwnerOrAdmin {\n', '        require(_newAddress != address(0));\n', '        require(founderAddress != _newAddress);\n', '        founderAddress = _newAddress;\n', '    }\n', '\n', '    // Modify team address to receive team tokens allocation\n', '    function changeTeamAddress(address _newAddress) external onlyOwnerOrAdmin {\n', '        require(_newAddress != address(0));\n', '        require(teamAddress != _newAddress);\n', '        teamAddress = _newAddress;\n', '    }\n', '\n', '    // Allocate tokens for founder vested gradually for 1 year\n', '    function allocateTokensForFounder() external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(founderAddress != address(0));\n', '        uint256 amount;\n', '        if (founderAllocatedTime == 1) {\n', '            amount = founderAllocation;\n', '            balances[founderAddress] = balances[founderAddress].add(amount);\n', '            emit AllocateTokensForFounder(founderAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 2;\n', '            return;\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Allocate tokens for team vested gradually for 1 year\n', '    function allocateTokensForTeam() external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(teamAddress != address(0));\n', '        uint256 amount;\n', '        if (teamAllocatedTime == 1) {\n', '            amount = teamAllocation * 40/100;\n', '            balances[teamAddress] = balances[teamAddress].add(amount);\n', '            emit AllocateTokensForTeam(teamAddress, teamAllocatedTime, amount);\n', '            teamAllocatedTime = 2;\n', '            return;\n', '        }\n', '        if (teamAllocatedTime == 2) {\n', '            require(now >= icoEndTime + lockPeriod1);\n', '            amount = teamAllocation * 60/100;\n', '            balances[teamAddress] = balances[teamAddress].add(amount);\n', '            emit AllocateTokensForTeam(teamAddress, teamAllocatedTime, amount);\n', '            teamAllocatedTime = 3;\n', '            return;\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Allocate reserved tokens\n', '    function allocateReservedTokens(address _addr, uint _amount) external isActive onlyOwnerOrAdmin {\n', '        require(_amount > 0);\n', '        require(_addr != address(0));\n', '\t\t\n', '        balances[_addr] = balances[_addr].add(_amount);\n', '        totalReservedTokenAllocation = totalReservedTokenAllocation.sub(_amount);\n', '        emit AllocateReservedTokens(_addr, _amount);\n', '    }\n', '    \n', '    // Allocate sales tokens\n', '    function allocateSalesTokens(address _addr, uint _amount) external isActive onlyOwnerOrAdmin {\n', '        require(_amount > 0);\n', '        require(_addr != address(0));\n', '\t\t\n', '        balances[_addr] = balances[_addr].add(_amount);\n', '        totalRemainingTokensForSales = totalRemainingTokensForSales.sub(_amount);\n', '        emit AllocateSalesTokens(_addr, _amount);\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function allowance(address _owner, address _spender) external constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function balanceOf(address _owner) external constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Get current sales state\n', '    function getCurrentState() public view returns(uint256) {\n', '        return saleState;\n', '    }\n', '\n', '    // Get softcap reaching status\n', '    function isSoftCapReached() public view returns (bool) {\n', '        return totalInvestedAmount >= minInvestedCap;\n', '    }\n', '    \n', '     // Issue tokens to normal investors through ICO rounds\n', '    function issueTokensForICO(uint _state) private {\n', '        uint256 price = icoStandardPrice;\n', '        issueTokens(price, _state);\n', '    }\n', '\n', '    // Issue tokens to investors and transfer ether to wallet\n', '    function issueTokens(uint256 _price, uint _state) private {\n', '        require(walletAddress != address(0));\n', '\t\t\n', '        uint tokenAmount = msg.value.mul(_price).mul(10**18).div(1 ether);\n', '        balances[msg.sender] = balances[msg.sender].add(tokenAmount);\n', '        totalInvestedAmountOf[msg.sender] = totalInvestedAmountOf[msg.sender].add(msg.value);\n', '        totalRemainingTokensForSales = totalRemainingTokensForSales.sub(tokenAmount);\n', '        totalInvestedAmount = totalInvestedAmount.add(msg.value);\n', '        walletAddress.transfer(msg.value);\n', '        emit IssueTokens(msg.sender, msg.value, tokenAmount, _state);\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Owner {\n', '    address public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Owner(address _owner) public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function changeOwner(address _newOwnerAddr) public onlyOwner {\n', '        require(_newOwnerAddr != address(0));\n', '        owner = _newOwnerAddr;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract KIMEX is Owner {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name = "KIMEX";\n', '    string public constant symbol = "KMX";\n', '    uint public constant decimals = 18;\n', '    uint256 constant public totalSupply = 250000000 * 10 ** 18; // 375 mil tokens will be supplied\n', '  \n', '    mapping(address => uint256) internal balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '    address public adminAddress;\n', '    address public walletAddress;\n', '    address public founderAddress;\n', '    address public teamAddress;\n', '\n', '    mapping(address => bool) public whiteList;\n', '    mapping(address => uint256) public totalInvestedAmountOf;\n', '\n', '    uint constant lockPeriod1 = 1 years; // 1nd locked period for tokens allocation of founder and team\n', '   \n', '    uint constant NOT_SALE = 0; // Not in sales\n', '    uint constant IN_SALE = 1;  // In sales\n', '    uint constant END_SALE = 2; // End sales\n', '\n', '    uint256 public constant salesAllocation = 150000000 * 10 ** 18; // 150 mil tokens allocated for sales\n', '    uint256 public constant reservedAllocation = 22500000 * 10 ** 18; // 22.5 mil tokens allocated for reserved, bounty campaigns, ICO partners, and bonus fund\n', '    uint256 public constant founderAllocation = 50000000 * 10 ** 18; // 50 mil tokens allocated for founders\n', '    uint256 public constant teamAllocation = 22500000 * 10 ** 18; // 22.5 mil tokens allocated for team\n', '    uint256 public constant minInvestedCap = 5000 * 10 ** 18; // 5000 ether for softcap \n', '    uint256 public constant minInvestedAmount = 0.1 * 10 ** 18; // 0.1 ether for mininum ether contribution per transaction\n', '    \n', '    uint saleState;\n', '    uint256 totalInvestedAmount;\n', '    uint public icoStartTime;\n', '    uint public icoEndTime;\n', '    bool public inActive;\n', '    bool public isSelling;\n', '    bool public isTransferable;\n', '    uint public founderAllocatedTime = 1;\n', '    uint public teamAllocatedTime = 1;\n', '    uint256 public icoStandardPrice;\n', ' \n', '    uint256 public totalRemainingTokensForSales; // Total tokens remaining for sales\n', '    uint256 public totalReservedTokenAllocation; // Total tokens allocated for reserved and bonuses\n', '    uint256 public totalLoadedRefund; // Total ether will be loaded to contract for refund\n', '    uint256 public totalRefundedAmount; // Total ether refunded to investors\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value); // ERC20 standard event\n', '    event Transfer(address indexed from, address indexed to, uint256 value); // ERC20 standard event\n', '\n', "    event ModifyWhiteList(address investorAddress, bool isWhiteListed);  // Add or remove investor's address to or from white list\n", '    event StartICO(uint state); // Start ICO sales\n', '    event EndICO(uint state); // End ICO sales\n', '    \n', '    event SetICOPrice(uint256 price); // Set ICO standard price\n', '    \n', '    \n', '    event IssueTokens(address investorAddress, uint256 amount, uint256 tokenAmount, uint state); // Issue tokens to investor\n', "    event AllocateTokensForFounder(address founderAddress, uint256 founderAllocatedTime, uint256 tokenAmount); // Allocate tokens to founders' address\n", "    event AllocateTokensForTeam(address teamAddress, uint256 teamAllocatedTime, uint256 tokenAmount); // Allocate tokens to team's address\n", '    event AllocateReservedTokens(address reservedAddress, uint256 tokenAmount); // Allocate reserved tokens\n', '    event AllocateSalesTokens(address salesAllocation, uint256 tokenAmount); // Allocate sales tokens\n', '    \n', '\n', '    modifier isActive() {\n', '        require(inActive == false);\n', '        _;\n', '    }\n', '\n', '    modifier isInSale() {\n', '        require(isSelling == true);\n', '        _;\n', '    }\n', '\n', '    modifier transferable() {\n', '        require(isTransferable == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrAdminOrPortal() {\n', '        require(msg.sender == owner || msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrAdmin() {\n', '        require(msg.sender == owner || msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    function KIMEX(address _walletAddr, address _adminAddr) public Owner(msg.sender) {\n', '        require(_walletAddr != address(0));\n', '        require(_adminAddr != address(0));\n', '\t\t\n', '        walletAddress = _walletAddr;\n', '        adminAddress = _adminAddr;\n', '        inActive = true;\n', '        totalInvestedAmount = 0;\n', '        totalRemainingTokensForSales = salesAllocation;\n', '        totalReservedTokenAllocation = reservedAllocation;\n', '    }\n', '\n', '    // Fallback function for token purchasing  \n', '    function () external payable isActive isInSale {\n', '        uint state = getCurrentState();\n', '        require(state < END_SALE);\n', '        require(msg.value >= minInvestedAmount);\n', '       \n', '        if (state <= IN_SALE) {\n', '            return issueTokensForICO(state);\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Load ether amount to contract for refunding or revoking\n', '    function loadFund() external payable {\n', '        require(msg.value > 0);\n', '\t\t\n', '        totalLoadedRefund = totalLoadedRefund.add(msg.value);\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function transfer(address _to, uint256 _value) external transferable returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function transferFrom(address _from, address _to, uint256 _value) external transferable returns (bool) {\n', '        require(_to != address(0));\n', '        require(_from != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function approve(address _spender, uint256 _value) external transferable returns (bool) {\n', '        require(_spender != address(0));\n', '        require(_value > 0);\n', '\t\t\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // Modify white list\n', '    function modifyWhiteList(address[] _investorAddrs, bool _isWhiteListed) external isActive onlyOwnerOrAdminOrPortal returns(bool) {\n', '        for (uint256 i = 0; i < _investorAddrs.length; i++) {\n', '            whiteList[_investorAddrs[i]] = _isWhiteListed;\n', '            emit ModifyWhiteList(_investorAddrs[i], _isWhiteListed);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Start ICO\n', '    function startICO() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(icoStandardPrice > 0);\n', '        saleState = IN_SALE;\n', '        icoStartTime = now;\n', '        isSelling = true;\n', '        emit StartICO(saleState);\n', '        return true;\n', '    }\n', '\n', '    // End ICO\n', '    function endICO() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(icoEndTime == 0);\n', '\t\t\n', '        saleState = END_SALE;\n', '        isSelling = false;\n', '        icoEndTime = now;\n', '        emit EndICO(saleState);\n', '        return true;\n', '    }\n', '    \n', '    // Set ICO price including ICO standard price\n', '    function setICOPrice(uint256 _tokenPerEther) external onlyOwnerOrAdmin returns(bool) {\n', '        require(_tokenPerEther > 0);\n', '    \t\t\n', '        icoStandardPrice = _tokenPerEther;\n', '        emit SetICOPrice(icoStandardPrice);\n', '        return true;\n', '    }\n', '    // Activate token sale function\n', '    function activate() external onlyOwner {\n', '        inActive = false;\n', '    }\n', '\n', '    // Deacivate token sale function\n', '    function deActivate() external onlyOwner {\n', '        inActive = true;\n', '    }\n', '\n', '    // Enable transfer feature of tokens\n', '    function enableTokenTransfer() external isActive onlyOwner {\n', '        isTransferable = true;\n', '    }\n', '\n', '    // Modify wallet\n', '    function changeWallet(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(walletAddress != _newAddress);\n', '        walletAddress = _newAddress;\n', '    }\n', '\n', '    // Modify admin\n', '    function changeAdminAddress(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(adminAddress != _newAddress);\n', '        adminAddress = _newAddress;\n', '    }\n', '  \n', '    // Modify founder address to receive founder tokens allocation\n', '    function changeFounderAddress(address _newAddress) external onlyOwnerOrAdmin {\n', '        require(_newAddress != address(0));\n', '        require(founderAddress != _newAddress);\n', '        founderAddress = _newAddress;\n', '    }\n', '\n', '    // Modify team address to receive team tokens allocation\n', '    function changeTeamAddress(address _newAddress) external onlyOwnerOrAdmin {\n', '        require(_newAddress != address(0));\n', '        require(teamAddress != _newAddress);\n', '        teamAddress = _newAddress;\n', '    }\n', '\n', '    // Allocate tokens for founder vested gradually for 1 year\n', '    function allocateTokensForFounder() external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(founderAddress != address(0));\n', '        uint256 amount;\n', '        if (founderAllocatedTime == 1) {\n', '            amount = founderAllocation;\n', '            balances[founderAddress] = balances[founderAddress].add(amount);\n', '            emit AllocateTokensForFounder(founderAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 2;\n', '            return;\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Allocate tokens for team vested gradually for 1 year\n', '    function allocateTokensForTeam() external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(teamAddress != address(0));\n', '        uint256 amount;\n', '        if (teamAllocatedTime == 1) {\n', '            amount = teamAllocation * 40/100;\n', '            balances[teamAddress] = balances[teamAddress].add(amount);\n', '            emit AllocateTokensForTeam(teamAddress, teamAllocatedTime, amount);\n', '            teamAllocatedTime = 2;\n', '            return;\n', '        }\n', '        if (teamAllocatedTime == 2) {\n', '            require(now >= icoEndTime + lockPeriod1);\n', '            amount = teamAllocation * 60/100;\n', '            balances[teamAddress] = balances[teamAddress].add(amount);\n', '            emit AllocateTokensForTeam(teamAddress, teamAllocatedTime, amount);\n', '            teamAllocatedTime = 3;\n', '            return;\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Allocate reserved tokens\n', '    function allocateReservedTokens(address _addr, uint _amount) external isActive onlyOwnerOrAdmin {\n', '        require(_amount > 0);\n', '        require(_addr != address(0));\n', '\t\t\n', '        balances[_addr] = balances[_addr].add(_amount);\n', '        totalReservedTokenAllocation = totalReservedTokenAllocation.sub(_amount);\n', '        emit AllocateReservedTokens(_addr, _amount);\n', '    }\n', '    \n', '    // Allocate sales tokens\n', '    function allocateSalesTokens(address _addr, uint _amount) external isActive onlyOwnerOrAdmin {\n', '        require(_amount > 0);\n', '        require(_addr != address(0));\n', '\t\t\n', '        balances[_addr] = balances[_addr].add(_amount);\n', '        totalRemainingTokensForSales = totalRemainingTokensForSales.sub(_amount);\n', '        emit AllocateSalesTokens(_addr, _amount);\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function allowance(address _owner, address _spender) external constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function balanceOf(address _owner) external constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Get current sales state\n', '    function getCurrentState() public view returns(uint256) {\n', '        return saleState;\n', '    }\n', '\n', '    // Get softcap reaching status\n', '    function isSoftCapReached() public view returns (bool) {\n', '        return totalInvestedAmount >= minInvestedCap;\n', '    }\n', '    \n', '     // Issue tokens to normal investors through ICO rounds\n', '    function issueTokensForICO(uint _state) private {\n', '        uint256 price = icoStandardPrice;\n', '        issueTokens(price, _state);\n', '    }\n', '\n', '    // Issue tokens to investors and transfer ether to wallet\n', '    function issueTokens(uint256 _price, uint _state) private {\n', '        require(walletAddress != address(0));\n', '\t\t\n', '        uint tokenAmount = msg.value.mul(_price).mul(10**18).div(1 ether);\n', '        balances[msg.sender] = balances[msg.sender].add(tokenAmount);\n', '        totalInvestedAmountOf[msg.sender] = totalInvestedAmountOf[msg.sender].add(msg.value);\n', '        totalRemainingTokensForSales = totalRemainingTokensForSales.sub(tokenAmount);\n', '        totalInvestedAmount = totalInvestedAmount.add(msg.value);\n', '        walletAddress.transfer(msg.value);\n', '        emit IssueTokens(msg.sender, msg.value, tokenAmount, _state);\n', '    }\n', '}']
