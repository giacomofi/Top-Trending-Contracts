['pragma solidity ^0.4.13;\n', '\n', 'contract Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    address constant public TOKEN_OWNER = 0x57Cdd07287f668eC4D58f3E362b4FCC2bC54F5b8; //Token Owner\n', '    address constant public WALLET = 0x1513F644590d866e25490687AB1b3Ad262d5b6dF; //Investment storage;\n', '    uint256 constant public MINSALESCAP = 200 ether;\n', '    uint256 constant public MAXSALESCAP = 126000 ether;\n', '    uint256 constant public STARTDATE = 1533686401; //Friday, Wednesday, August 8, 2018 2:00:01 AM\n', '    uint256 constant public ENDDATE = 1543536060; // November 30, 2018 12:01:00 AM\n', '    uint256 constant public FXRATE = 50000;\n', '    uint256 constant public MINCONTRIBUTION = 5000000000000 wei; //0,005 eth\n', '\n', '    //set on deployment\n', '    address public TOKEN;\n', '    address public owner;\n', '    uint256 public weiRaised;\n', '\n', '    enum State { Running, Expired, Funded }\n', '    State public state;\n', '\n', '    struct ContributorStruct {\n', '        bool whitelisted;\n', '        uint256 contributions;\n', '    }\n', '    mapping(address => ContributorStruct) public whitelist;\n', '\n', '    modifier isContributor() {require(whitelist[msg.sender].contributions > 0x00); _;}\n', '    modifier isOwner() {require(msg.sender == owner); _;}\n', '    modifier inState(State _state) {require(state == _state); _;}\n', '    modifier inPaymentLimits(uint256 _payment) {require(_payment >= MINCONTRIBUTION); _;}\n', '    modifier inWhitelist(address _contributor) {require(whitelist[_contributor].whitelisted == true); _;}\n', '\n', '    event WhitelistingLog(address indexed _contributor);\n', '    event RefundLog(address indexed _contributor, uint256 _amount);\n', '    event PurchaseLog(address indexed _contributor, address indexed _beneficiary, uint256 _amount);\n', '\n', '    constructor (address _token) public {\n', '        require(_token != address(0x00));\n', '\n', '        owner = msg.sender;\n', '        TOKEN = _token;\n', '    }\n', '\n', '    function () public payable {\n', '        _updateStateIfExpired();\n', '    }\n', '\n', '    //available only to whitelisted addresses after startBlock\n', '    function buyTokens(address _beneficiary)\n', '        public\n', '        inState(State.Running)\n', '        inPaymentLimits(msg.value)\n', '        inWhitelist(_beneficiary)\n', '        payable\n', '        returns (bool success)\n', '    {\n', '        require(_beneficiary != address(0x00));\n', '\n', '        assert(block.timestamp >= STARTDATE); //check if sale has started\n', '\n', '        uint256 tokenAmount = _calculateTokenAmount(msg.value);\n', '        YOUToken token = YOUToken(TOKEN);\n', '\n', '        weiRaised = weiRaised.add(msg.value);\n', '        whitelist[_beneficiary].contributions = whitelist[_beneficiary].contributions.add(msg.value);\n', '        if (!token.mint.gas(700000)(_beneficiary, tokenAmount)) {\n', '            return false;\n', '        }\n', '\n', '        if (weiRaised >= MAXSALESCAP\n', '            || weiRaised >= MINSALESCAP && block.timestamp >= ENDDATE) {\n', '            state = State.Funded;\n', '        } else {\n', '            _updateStateIfExpired();\n', '        }\n', '\n', '        emit PurchaseLog(msg.sender, _beneficiary, msg.value);\n', '        return true;\n', '    }\n', '\n', '    //available to contributers after deadline and only if unfunded\n', '    //if contributer used a different address as _beneficiary, only this address can claim refund\n', '    function refund(address _contributor)\n', '        public\n', '        isContributor\n', '        inState(State.Expired)\n', '        returns (bool success)\n', '    {\n', '        require(_contributor != address(0x00));\n', '\n', '        uint256 amount = whitelist[_contributor].contributions;\n', '        whitelist[_contributor].contributions = 0x00;\n', '\n', '        _contributor.transfer(amount);\n', '\n', '        emit RefundLog(_contributor, amount);\n', '        return true;\n', '    }\n', '\n', '    //as owner, whitelist individual address\n', '    function whitelistAddr(address _contributor)\n', '        public\n', '        isOwner\n', '        returns(bool)\n', '    {\n', '        require(_contributor != address(0x00));\n', '\n', '        // whitelist[_contributor] = true;\n', '        whitelist[_contributor].whitelisted = true;\n', '\n', '        emit WhitelistingLog(_contributor);\n', '        return true;\n', '    }\n', '\n', '    //in cases where funds are not payed in ETH to this contract,\n', '    //as owner, whitelist and give tokens to address.\n', '    function whitelistAddrAndBuyTokens(address _contributor, uint256 _weiAmount)\n', '        public\n', '        isOwner\n', '        returns(bool)\n', '    {\n', '        require(_contributor != address(0x00));\n', '\n', '        uint256 tokenAmount = _calculateTokenAmount(_weiAmount);\n', '        YOUToken token = YOUToken(TOKEN);\n', '\n', '        whitelist[_contributor].whitelisted = true;\n', '        weiRaised = weiRaised.add(_weiAmount);\n', '        if (!token.mint.gas(700000)(_contributor, tokenAmount)) {\n', '            return false;\n', '        }\n', '\n', '        emit WhitelistingLog(_contributor);\n', '        return true;\n', '    }\n', '\n', '    //withdraw Funds only if funded, as owner\n', '    function withdraw() public isOwner inState(State.Funded) {\n', '        WALLET.transfer(address(this).balance);\n', '    }\n', '\n', '    function delistAddress(address _contributor)\n', '        public\n', '        isOwner\n', '        inState(State.Running)\n', '        returns (bool)\n', '    {\n', '        require(_contributor != address(0x00));\n', '        require(whitelist[_contributor].whitelisted);\n', '\n', '        whitelist[_contributor].whitelisted = false;\n', '\n', '        return true;\n', '    }\n', '\n', '    function emergencyStop()\n', '        public\n', '        isOwner\n', '        inState(State.Running)\n', '    {\n', '        //prevent more contributions and allow refunds\n', '        state = State.Expired;\n', '    }\n', '\n', '    function transferOwnership()\n', '        public\n', '        isOwner\n', '        inState(State.Running)\n', '    {\n', '        //after deployment is complete run once\n', '        owner = TOKEN_OWNER;\n', '    }\n', '\n', '    function _updateStateIfExpired() internal {\n', '        if ((block.timestamp >= ENDDATE && state == State.Running)\n', '            || (block.timestamp >= ENDDATE && weiRaised < MINSALESCAP)) {\n', '            state = State.Expired;\n', '        }\n', '    }\n', '\n', '    function _calculateTokenAmount(uint256 _weiAmount)\n', '        internal\n', '        view\n', '        returns (uint256 tokenAmount)\n', '    {\n', '        uint256 discount;\n', '        if (block.timestamp <= 1535241660) {\n', '            if (_weiAmount >= 1700 ether) {\n', '                discount = 30;\n', '            } else if (_weiAmount > 0.2 ether) {\n', '                discount = 25;\n', '            }\n', '        } else if (block.timestamp <= 1537747260) {\n', '            discount = 15;\n', '        } else if (block.timestamp <= 1540339260) {\n', '            discount = 10;\n', '        } else if (block.timestamp <= 1543536060) {\n', '            discount = 5;\n', '        }\n', '\n', '        _weiAmount = _weiAmount.mul(discount).div(100).add(_weiAmount);\n', '\n', '        return _weiAmount.mul(FXRATE);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', 'contract YOUToken {\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '    function transferOwnership(address _newOwner) public;\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    address constant public TOKEN_OWNER = 0x57Cdd07287f668eC4D58f3E362b4FCC2bC54F5b8; //Token Owner\n', '    address constant public WALLET = 0x1513F644590d866e25490687AB1b3Ad262d5b6dF; //Investment storage;\n', '    uint256 constant public MINSALESCAP = 200 ether;\n', '    uint256 constant public MAXSALESCAP = 126000 ether;\n', '    uint256 constant public STARTDATE = 1533686401; //Friday, Wednesday, August 8, 2018 2:00:01 AM\n', '    uint256 constant public ENDDATE = 1543536060; // November 30, 2018 12:01:00 AM\n', '    uint256 constant public FXRATE = 50000;\n', '    uint256 constant public MINCONTRIBUTION = 5000000000000 wei; //0,005 eth\n', '\n', '    //set on deployment\n', '    address public TOKEN;\n', '    address public owner;\n', '    uint256 public weiRaised;\n', '\n', '    enum State { Running, Expired, Funded }\n', '    State public state;\n', '\n', '    struct ContributorStruct {\n', '        bool whitelisted;\n', '        uint256 contributions;\n', '    }\n', '    mapping(address => ContributorStruct) public whitelist;\n', '\n', '    modifier isContributor() {require(whitelist[msg.sender].contributions > 0x00); _;}\n', '    modifier isOwner() {require(msg.sender == owner); _;}\n', '    modifier inState(State _state) {require(state == _state); _;}\n', '    modifier inPaymentLimits(uint256 _payment) {require(_payment >= MINCONTRIBUTION); _;}\n', '    modifier inWhitelist(address _contributor) {require(whitelist[_contributor].whitelisted == true); _;}\n', '\n', '    event WhitelistingLog(address indexed _contributor);\n', '    event RefundLog(address indexed _contributor, uint256 _amount);\n', '    event PurchaseLog(address indexed _contributor, address indexed _beneficiary, uint256 _amount);\n', '\n', '    constructor (address _token) public {\n', '        require(_token != address(0x00));\n', '\n', '        owner = msg.sender;\n', '        TOKEN = _token;\n', '    }\n', '\n', '    function () public payable {\n', '        _updateStateIfExpired();\n', '    }\n', '\n', '    //available only to whitelisted addresses after startBlock\n', '    function buyTokens(address _beneficiary)\n', '        public\n', '        inState(State.Running)\n', '        inPaymentLimits(msg.value)\n', '        inWhitelist(_beneficiary)\n', '        payable\n', '        returns (bool success)\n', '    {\n', '        require(_beneficiary != address(0x00));\n', '\n', '        assert(block.timestamp >= STARTDATE); //check if sale has started\n', '\n', '        uint256 tokenAmount = _calculateTokenAmount(msg.value);\n', '        YOUToken token = YOUToken(TOKEN);\n', '\n', '        weiRaised = weiRaised.add(msg.value);\n', '        whitelist[_beneficiary].contributions = whitelist[_beneficiary].contributions.add(msg.value);\n', '        if (!token.mint.gas(700000)(_beneficiary, tokenAmount)) {\n', '            return false;\n', '        }\n', '\n', '        if (weiRaised >= MAXSALESCAP\n', '            || weiRaised >= MINSALESCAP && block.timestamp >= ENDDATE) {\n', '            state = State.Funded;\n', '        } else {\n', '            _updateStateIfExpired();\n', '        }\n', '\n', '        emit PurchaseLog(msg.sender, _beneficiary, msg.value);\n', '        return true;\n', '    }\n', '\n', '    //available to contributers after deadline and only if unfunded\n', '    //if contributer used a different address as _beneficiary, only this address can claim refund\n', '    function refund(address _contributor)\n', '        public\n', '        isContributor\n', '        inState(State.Expired)\n', '        returns (bool success)\n', '    {\n', '        require(_contributor != address(0x00));\n', '\n', '        uint256 amount = whitelist[_contributor].contributions;\n', '        whitelist[_contributor].contributions = 0x00;\n', '\n', '        _contributor.transfer(amount);\n', '\n', '        emit RefundLog(_contributor, amount);\n', '        return true;\n', '    }\n', '\n', '    //as owner, whitelist individual address\n', '    function whitelistAddr(address _contributor)\n', '        public\n', '        isOwner\n', '        returns(bool)\n', '    {\n', '        require(_contributor != address(0x00));\n', '\n', '        // whitelist[_contributor] = true;\n', '        whitelist[_contributor].whitelisted = true;\n', '\n', '        emit WhitelistingLog(_contributor);\n', '        return true;\n', '    }\n', '\n', '    //in cases where funds are not payed in ETH to this contract,\n', '    //as owner, whitelist and give tokens to address.\n', '    function whitelistAddrAndBuyTokens(address _contributor, uint256 _weiAmount)\n', '        public\n', '        isOwner\n', '        returns(bool)\n', '    {\n', '        require(_contributor != address(0x00));\n', '\n', '        uint256 tokenAmount = _calculateTokenAmount(_weiAmount);\n', '        YOUToken token = YOUToken(TOKEN);\n', '\n', '        whitelist[_contributor].whitelisted = true;\n', '        weiRaised = weiRaised.add(_weiAmount);\n', '        if (!token.mint.gas(700000)(_contributor, tokenAmount)) {\n', '            return false;\n', '        }\n', '\n', '        emit WhitelistingLog(_contributor);\n', '        return true;\n', '    }\n', '\n', '    //withdraw Funds only if funded, as owner\n', '    function withdraw() public isOwner inState(State.Funded) {\n', '        WALLET.transfer(address(this).balance);\n', '    }\n', '\n', '    function delistAddress(address _contributor)\n', '        public\n', '        isOwner\n', '        inState(State.Running)\n', '        returns (bool)\n', '    {\n', '        require(_contributor != address(0x00));\n', '        require(whitelist[_contributor].whitelisted);\n', '\n', '        whitelist[_contributor].whitelisted = false;\n', '\n', '        return true;\n', '    }\n', '\n', '    function emergencyStop()\n', '        public\n', '        isOwner\n', '        inState(State.Running)\n', '    {\n', '        //prevent more contributions and allow refunds\n', '        state = State.Expired;\n', '    }\n', '\n', '    function transferOwnership()\n', '        public\n', '        isOwner\n', '        inState(State.Running)\n', '    {\n', '        //after deployment is complete run once\n', '        owner = TOKEN_OWNER;\n', '    }\n', '\n', '    function _updateStateIfExpired() internal {\n', '        if ((block.timestamp >= ENDDATE && state == State.Running)\n', '            || (block.timestamp >= ENDDATE && weiRaised < MINSALESCAP)) {\n', '            state = State.Expired;\n', '        }\n', '    }\n', '\n', '    function _calculateTokenAmount(uint256 _weiAmount)\n', '        internal\n', '        view\n', '        returns (uint256 tokenAmount)\n', '    {\n', '        uint256 discount;\n', '        if (block.timestamp <= 1535241660) {\n', '            if (_weiAmount >= 1700 ether) {\n', '                discount = 30;\n', '            } else if (_weiAmount > 0.2 ether) {\n', '                discount = 25;\n', '            }\n', '        } else if (block.timestamp <= 1537747260) {\n', '            discount = 15;\n', '        } else if (block.timestamp <= 1540339260) {\n', '            discount = 10;\n', '        } else if (block.timestamp <= 1543536060) {\n', '            discount = 5;\n', '        }\n', '\n', '        _weiAmount = _weiAmount.mul(discount).div(100).add(_weiAmount);\n', '\n', '        return _weiAmount.mul(FXRATE);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', 'contract YOUToken {\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '    function transferOwnership(address _newOwner) public;\n', '}']
