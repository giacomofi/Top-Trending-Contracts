['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title RefundVault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Supports refunding the money if crowdsale fails,\n', ' * and forwarding it if crowdsale is successful.\n', ' */\n', 'contract RefundVault is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  enum State { Active, Refunding, Closed }\n', '\n', '  mapping (address => uint256) public deposited;\n', '  address public wallet;\n', '  State public state;\n', '\n', '  event Closed();\n', '  event RefundsEnabled();\n', '  event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '  /**\n', '   * @param _wallet Vault address\n', '   */\n', '  function RefundVault(address _wallet) public {\n', '    require(_wallet != address(0));\n', '    wallet = _wallet;\n', '    state = State.Active;\n', '  }\n', '\n', '  /**\n', '   * @param investor Investor address\n', '   */\n', '  function deposit(address investor) onlyOwner public payable {\n', '    require(state == State.Active);\n', '    deposited[investor] = deposited[investor].add(msg.value);\n', '  }\n', '\n', '  function close() onlyOwner public {\n', '    require(state == State.Active);\n', '    state = State.Closed;\n', '    Closed();\n', '    wallet.transfer(this.balance);\n', '  }\n', '\n', '  function enableRefunds() onlyOwner public {\n', '    require(state == State.Active);\n', '    state = State.Refunding;\n', '    RefundsEnabled();\n', '  }\n', '\n', '  /**\n', '   * @param investor Investor address\n', '   */\n', '  function refund(address investor) public {\n', '    require(state == State.Refunding);\n', '    uint256 depositedValue = deposited[investor];\n', '    deposited[investor] = 0;\n', '    investor.transfer(depositedValue);\n', '    Refunded(investor, depositedValue);\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ACAToken is ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    address public owner;\n', '    address public admin;\n', '    address public saleAddress;\n', '\n', '    string public name = "ACA Network Token";\n', '    string public symbol = "ACA";\n', '    uint8 public decimals = 18;\n', '\n', '    uint256 totalSupply_;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    mapping (address => uint256) balances;\n', '\n', '    bool transferable = false;\n', '    mapping (address => bool) internal transferLocked;\n', '\n', '    event Genesis(address owner, uint256 value);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event AdminTransferred(address indexed previousAdmin, address indexed newAdmin);\n', '    event Burn(address indexed burner, uint256 value);\n', '    event LogAddress(address indexed addr);\n', '    event LogUint256(uint256 value);\n', '    event TransferLock(address indexed target, bool value);\n', '\n', '    // modifiers\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == owner || msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier canTransfer(address _from, address _to) {\n', '        require(_to != address(0x0));\n', '        require(_to != address(this));\n', '\n', '        if ( _from != owner && _from != admin ) {\n', '            require(transferable);\n', '            require (!transferLocked[_from]);\n', '        }\n', '        _;\n', '    }\n', '\n', '    // constructor\n', '    function ACAToken(uint256 _totalSupply, address _saleAddress, address _admin) public {\n', '        require(_totalSupply > 0);\n', '        owner = msg.sender;\n', '        require(_saleAddress != address(0x0));\n', '        require(_saleAddress != address(this));\n', '        require(_saleAddress != owner);\n', '\n', '        require(_admin != address(0x0));\n', '        require(_admin != address(this));\n', '        require(_admin != owner);\n', '\n', '        require(_admin != _saleAddress);\n', '\n', '        admin = _admin;\n', '        saleAddress = _saleAddress;\n', '\n', '        totalSupply_ = _totalSupply;\n', '\n', '        balances[owner] = totalSupply_;\n', '        approve(saleAddress, totalSupply_);\n', '\n', '        emit Genesis(owner, totalSupply_);\n', '    }\n', '\n', '    // permission related\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        require(newOwner != address(this));\n', '        require(newOwner != admin);\n', '\n', '        owner = newOwner;\n', '        emit OwnershipTransferred(owner, newOwner);\n', '    }\n', '\n', '    function transferAdmin(address _newAdmin) public onlyOwner {\n', '        require(_newAdmin != address(0));\n', '        require(_newAdmin != address(this));\n', '        require(_newAdmin != owner);\n', '\n', '        admin = _newAdmin;\n', '        emit AdminTransferred(admin, _newAdmin);\n', '    }\n', '\n', '    function setTransferable(bool _transferable) public onlyAdmin {\n', '        transferable = _transferable;\n', '    }\n', '\n', '    function isTransferable() public view returns (bool) {\n', '        return transferable;\n', '    }\n', '\n', '    function transferLock() public returns (bool) {\n', '        transferLocked[msg.sender] = true;\n', '        emit TransferLock(msg.sender, true);\n', '        return true;\n', '    }\n', '\n', '    function manageTransferLock(address _target, bool _value) public onlyAdmin returns (bool) {\n', '        transferLocked[_target] = _value;\n', '        emit TransferLock(_target, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferAllowed(address _target) public view returns (bool) {\n', '        return (transferable && transferLocked[_target] == false);\n', '    }\n', '\n', '    // token related\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) canTransfer(msg.sender, _to) public returns (bool) {\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        // SafeMath.sub will throw if there is not enough balance.\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function balanceOfOwner() public view returns (uint256 balance) {\n', '        return balances[owner];\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public canTransfer(msg.sender, _spender) returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public canTransfer(msg.sender, _spender) returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function burn(uint256 _value) public {\n', '        require(_value <= balances[msg.sender]);\n', '        // no need to require value <= totalSupply, since that would imply the\n', '        // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        totalSupply_ = totalSupply_.sub(_value);\n', '        emit Burn(burner, _value);\n', '    }\n', '\n', '    function emergencyERC20Drain(ERC20 _token, uint256 _amount) public onlyOwner {\n', '        _token.transfer(owner, _amount);\n', '    }\n', '}\n', '\n', 'contract ACATokenSale {\n', '    using SafeMath for uint256;\n', '\n', '    address public owner;\n', '    address public admin;\n', '\n', '    address public wallet;\n', '    ACAToken public token;\n', '\n', '    uint256 totalSupply;\n', '\n', '    struct StageInfo {\n', '        uint256 opening;\n', '        uint256 closing;\n', '        uint256 capacity;\n', '        uint256 minimumWei;\n', '        uint256 maximumWei;\n', '        uint256 rate;\n', '        uint256 sold;\n', '    }\n', '    bool public tokenSaleEnabled = false;\n', '\n', '    mapping(address => bool) public whitelist;\n', '    mapping(address => bool) public kyclist;\n', '    mapping(address => bool) public whitelistBonus;\n', '\n', '    uint256 public whitelistBonusClosingTime;\n', '    uint256 public whitelistBonusSent = 0;\n', '    uint256 public whitelistBonusRate;\n', '    uint256 public whitelistBonusAmount;\n', '\n', '    mapping (address => uint256) public sales;\n', '    uint256 public softCap;\n', '    uint256 public hardCap;\n', '    uint256 public weiRaised = 0;\n', '\n', '    RefundVault public vault;\n', '\n', '    mapping (address => address) public referrals;\n', '    uint256 public referralAmount;\n', '    uint256 public referralRateInviter;\n', '    uint256 public referralRateInvitee;\n', '    uint256 public referralSent = 0;\n', '    bool public referralDone = false;\n', '\n', '    mapping (address => uint256) public bounties;\n', '    uint256 public bountyAmount;\n', '    uint256 public bountySent = 0;\n', '\n', '    StageInfo[] public stages;\n', '    uint256 public currentStage = 0;\n', '\n', '    bool public isFinalized = false;\n', '    bool public isClaimable = false;\n', '\n', '    // events\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event AdminTransferred(address indexed previousAdmin, address indexed newAdmin);\n', '    event TokenSaleCreated(address indexed wallet, uint256 totalSupply);\n', '    event StageAdded(uint256 openingTime, uint256 closingTime, uint256 capacity, uint256 minimumWei, uint256 maximumWei, uint256 rate);\n', '    event TokenSaleEnabled();\n', '\n', '    event WhitelistUpdated(address indexed beneficiary, bool flag);\n', '    event VerificationUpdated(address indexed beneficiary, bool flag);\n', '    event BulkWhitelistUpdated(address[] beneficiary, bool flag);\n', '    event BulkVerificationUpdated(address[] beneficiary, bool flag);\n', '\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    event TokenClaimed(address indexed beneficiary, uint256 amount);\n', '    event Finalized();\n', '    event BountySetupDone();\n', '    event BountyUpdated(address indexed target, bool flag, uint256 amount);\n', '    event PurchaseReferral(address indexed beneficiary, uint256 amount);\n', '    event StageUpdated(uint256 stage);\n', '    event StageCapReached(uint256 stage);\n', '    event ReferralCapReached();\n', '\n', '    // do not use this on mainnet!\n', '    event LogAddress(address indexed addr);\n', '    event LogUint256(uint256 value);\n', '\n', '    // modifiers\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == owner || msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhileOpen {\n', '        require(tokenSaleEnabled == true);\n', '        require(now >= stages[currentStage].opening && now <= stages[currentStage].closing);\n', '        _;\n', '    }\n', '\n', '    modifier isVerified(address _beneficiary) {\n', '        require(whitelist[_beneficiary] == true);\n', '        require(kyclist[_beneficiary] == true);\n', '        _;\n', '    }\n', '\n', '    modifier claimable {\n', '        require(isFinalized == true || isClaimable == true);\n', '        require(isGoalReached());\n', '        _;\n', '    }\n', '\n', '    // getters\n', '    function isEnabled() public view returns (bool) {\n', '        return tokenSaleEnabled;\n', '    }\n', '\n', '    function isClosed() public view returns (bool) {\n', '        return now > stages[stages.length - 1].closing;\n', '    }\n', '\n', '    function isGoalReached() public view returns (bool) {\n', '        return getTotalTokenSold() >= softCap;\n', '    }\n', '\n', '    function getTotalTokenSold() public view returns (uint256) {\n', '        uint256 sold = 0;\n', '        for ( uint i = 0; i < stages.length; ++i ) {\n', '            sold = sold.add(stages[i].sold);\n', '        }\n', '\n', '        return sold;\n', '    }\n', '\n', '    function getOpeningTime() public view returns (uint256) {\n', '        return stages[currentStage].opening;\n', '    }\n', '\n', '    function getOpeningTimeByStage(uint _index) public view returns (uint256) {\n', '        require(_index < stages.length);\n', '        return stages[_index].opening;\n', '    }\n', '\n', '    function getClosingTime() public view returns (uint256) {\n', '        return stages[currentStage].closing;\n', '    }\n', '\n', '    function getClosingTimeByStage(uint _index) public view returns (uint256) {\n', '        require(_index < stages.length);\n', '        return stages[_index].closing;\n', '    }\n', '\n', '    function getCurrentCapacity() public view returns (uint256) {\n', '        return stages[currentStage].capacity;\n', '    }\n', '\n', '    function getCapacity(uint _index) public view returns (uint256) {\n', '        require(_index < stages.length);\n', '        return stages[_index].capacity;\n', '    }\n', '\n', '    function getCurrentSold() public view returns (uint256) {\n', '        return stages[currentStage].sold;\n', '    }\n', '\n', '    function getSold(uint _index) public view returns (uint256) {\n', '        require(_index < stages.length);\n', '        return stages[_index].sold;\n', '    }\n', '\n', '    function getCurrentRate() public view returns (uint256) {\n', '        return stages[currentStage].rate;\n', '    }\n', '\n', '    function getRate(uint _index) public view returns (uint256) {\n', '        require(_index < stages.length);\n', '        return stages[_index].rate;\n', '    }\n', '\n', '    function getRateWithoutBonus() public view returns (uint256) {\n', '        return stages[stages.length - 1].rate;\n', '    }\n', '\n', '    function getSales(address _beneficiary) public view returns (uint256) {\n', '        return sales[_beneficiary];\n', '    }\n', '    \n', '    // setter\n', '    function setSalePeriod(uint _index, uint256 _openingTime, uint256 _closingTime) onlyOwner public {\n', '        require(_openingTime > now);\n', '        require(_closingTime > _openingTime);\n', '\n', '        require(_index > currentStage);\n', '        require(_index < stages.length);\n', '\n', '        stages[_index].opening = _openingTime;        \n', '        stages[_index].closing = _closingTime;        \n', '    }\n', '\n', '    function setRate(uint _index, uint256 _rate) onlyOwner public {\n', '        require(_index > currentStage);\n', '        require(_index < stages.length);\n', '\n', '        require(_rate > 0);\n', '\n', '        stages[_index].rate = _rate;\n', '    }\n', '\n', '    function setCapacity(uint _index, uint256 _capacity) onlyOwner public {\n', '        require(_index > currentStage);\n', '        require(_index < stages.length);\n', '\n', '        require(_capacity > 0);\n', '\n', '        stages[_index].capacity = _capacity;\n', '    }\n', '\n', '    function setClaimable(bool _claimable) onlyOwner public {\n', '        if ( _claimable == true ) {\n', '            require(isGoalReached());\n', '        }\n', '\n', '        isClaimable = _claimable;\n', '    }\n', '\n', '    function addPrivateSale(uint256 _amount) onlyOwner public {\n', '        require(currentStage == 0);\n', '        require(_amount > 0);\n', '        require(_amount < stages[0].capacity.sub(stages[0].sold));\n', '\n', '        stages[0].sold = stages[0].sold.add(_amount);\n', '    }\n', '\n', '    function subPrivateSale(uint256 _amount) onlyOwner public {\n', '        require(currentStage == 0);\n', '        require(_amount > 0);\n', '        require(stages[0].sold > _amount);\n', '\n', '        stages[0].sold = stages[0].sold.sub(_amount);\n', '    }\n', '\n', '    // permission\n', '    function setAdmin(address _newAdmin) public onlyOwner {\n', '        require(_newAdmin != address(0x0));\n', '        require(_newAdmin != address(this));\n', '        require(_newAdmin != owner);\n', '\n', '        emit AdminTransferred(admin, _newAdmin);\n', '        admin = _newAdmin;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        require(newOwner != address(this));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    // constructor\n', '    function ACATokenSale(\n', '        address _wallet, \n', '        address _admin,\n', '        uint256 _totalSupply,\n', '        uint256 _softCap,\n', '        uint256 _hardCap) public {\n', '        owner = msg.sender;\n', '\n', '        require(_admin != address(0));\n', '        require(_wallet != address(0));\n', '\n', '        require(_totalSupply > 0);\n', '        require(_softCap > 0);\n', '        require(_hardCap > _softCap);\n', '\n', '        admin = _admin;\n', '        wallet = _wallet;\n', '\n', '        totalSupply = _totalSupply;\n', '        softCap = _softCap;\n', '        hardCap = _hardCap;\n', '\n', '        emit TokenSaleCreated(wallet, _totalSupply);\n', '    }\n', '\n', '    // state related\n', '    function setupBounty(\n', '        uint256 _referralAmount,\n', '        uint256 _referralRateInviter,\n', '        uint256 _referralRateInvitee,\n', '        uint256 _bountyAmount,\n', '        uint256 _whitelistBonusClosingTime,\n', '        uint256 _whitelistBonusRate,\n', '        uint256 _whitelistBonusAmount\n', '    ) onlyOwner public {\n', '        \n', '        require(_referralAmount > 0);\n', '\n', '        require(_referralRateInviter > 0 && _referralRateInviter < 100);\n', '        require(_referralRateInvitee > 0 && _referralRateInvitee < 100);\n', '\n', '        require(_whitelistBonusClosingTime > now);\n', '        require(_whitelistBonusRate > 0);\n', '        require(_whitelistBonusAmount > _whitelistBonusRate);\n', '        require(_bountyAmount > 0);\n', '\n', '        referralAmount = _referralAmount;\n', '        referralRateInviter = _referralRateInviter;\n', '        referralRateInvitee = _referralRateInvitee;\n', '        bountyAmount = _bountyAmount;\n', '        whitelistBonusClosingTime = _whitelistBonusClosingTime;\n', '        whitelistBonusRate = _whitelistBonusRate;\n', '        whitelistBonusAmount = _whitelistBonusAmount;\n', '\n', '        emit BountySetupDone();\n', '    }\n', '    function addStage(\n', '        uint256 _openingTime, \n', '        uint256 _closingTime, \n', '        uint256 _capacity, \n', '        uint256 _minimumWei, \n', '        uint256 _maximumWei, \n', '        uint256 _rate) onlyOwner public {\n', '        require(tokenSaleEnabled == false);\n', '\n', '        // require(_openingTime > now);\n', '        require(_closingTime > _openingTime);\n', '\n', '        require(_capacity > 0);\n', '        require(_capacity < hardCap);\n', '\n', '        require(_minimumWei > 0);\n', '        require(_maximumWei >= _minimumWei);\n', '\n', '        require(_rate > 0);\n', '\n', '        require(_minimumWei.mul(_rate) < _capacity);\n', '        require(_maximumWei.mul(_rate) < _capacity);\n', '        if ( stages.length > 0 ) {\n', '            StageInfo memory prevStage = stages[stages.length - 1];\n', '            require(_openingTime > prevStage.closing);\n', '        }\n', '\n', '        stages.push(StageInfo(_openingTime, _closingTime, _capacity, _minimumWei, _maximumWei, _rate, 0));\n', '\n', '        emit StageAdded(_openingTime, _closingTime, _capacity, _minimumWei, _maximumWei, _rate);\n', '    }\n', '\n', '    function setToken(ACAToken _token) onlyOwner public {\n', '        token = _token;\n', '    }\n', '\n', '    function enableTokenSale() onlyOwner public returns (bool) {\n', '        require(stages.length > 0);\n', '\n', '        vault = new RefundVault(wallet);\n', '\n', '        tokenSaleEnabled = true;\n', '        emit TokenSaleEnabled();\n', '        return true;\n', '    }\n', '\n', '    function updateStage() public returns (uint256) {\n', '        require(tokenSaleEnabled == true);\n', '        require(currentStage < stages.length);\n', '        require(now >= stages[currentStage].opening);\n', '\n', '        uint256 remains = stages[currentStage].capacity.sub(stages[currentStage].sold);\n', '        if ( now > stages[currentStage].closing ) {\n', '            uint256 nextStage = currentStage.add(1);\n', '            if ( remains > 0 && nextStage < stages.length ) {\n', '                stages[nextStage].capacity = stages[nextStage].capacity.add(remains);\n', '                remains = stages[nextStage].capacity;\n', '            }\n', '\n', '            currentStage = nextStage;\n', '            emit StageUpdated(nextStage);\n', '        }\n', '\n', '        return remains;\n', '    }\n', '\n', '    function finalize() onlyOwner public {\n', '        require(isFinalized == false);\n', '        require(isClosed());\n', '\n', '        finalization();\n', '        emit Finalized();\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '    function finalization() internal {\n', '        if (isGoalReached()) {\n', '            vault.close();\n', '        } else {\n', '            vault.enableRefunds();\n', '        }\n', '\n', '    }\n', '\n', '    // transaction\n', '    function () public payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function buyTokens(address _beneficiary) public payable {\n', '        uint256 weiAmount = msg.value;\n', '\n', '        _preValidatePurchase(_beneficiary, weiAmount);\n', '        // calculate token amount to be created\n', '        uint256 tokens = _getTokenAmount(weiAmount);\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '\n', '        _processPurchase(_beneficiary, tokens);\n', '        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '\n', '        _updatePurchasingState(_beneficiary, weiAmount);\n', '\n', '        _forwardFunds();\n', '        _postValidatePurchase(_beneficiary, weiAmount);\n', '    }\n', '\n', '    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n', '        return _weiAmount.mul(getCurrentRate());\n', '    }\n', '\n', '    function _getTokenAmountWithoutBonus(uint256 _weiAmount) internal view returns (uint256) {\n', '        return _weiAmount.mul(getRateWithoutBonus());\n', '    }\n', '\n', '    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal isVerified(_beneficiary) {\n', '        require(_beneficiary != address(0));\n', '        require(_weiAmount != 0);\n', '\n', '        require(tokenSaleEnabled == true);\n', '\n', '        require(now >= stages[currentStage].opening);\n', '\n', '        // lazy execution\n', '        uint256 remains = updateStage();\n', '\n', '        require(currentStage < stages.length);\n', '        require(now >= stages[currentStage].opening && now <= stages[currentStage].closing);\n', '\n', '        require(_weiAmount >= stages[currentStage].minimumWei);\n', '        require(_weiAmount <= stages[currentStage].maximumWei);\n', '\n', '        uint256 amount = _getTokenAmount(_weiAmount);\n', '\n', '        require(remains > amount);\n', '    }\n', '\n', '    function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n', '        if ( getCurrentSold() == getCurrentCapacity() ) {\n', '            currentStage = currentStage.add(1);\n', '            emit StageUpdated(currentStage);\n', '        }\n', '    }\n', '\n', '    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '        if ( isClaimable ) {\n', '            token.transferFrom(owner, _beneficiary, _tokenAmount);\n', '        }\n', '        else {\n', '            sales[_beneficiary] = sales[_beneficiary].add(_tokenAmount);\n', '        }\n', '    }\n', '\n', '    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '\n', '        stages[currentStage].sold = stages[currentStage].sold.add(_tokenAmount);\n', '        _deliverTokens(_beneficiary, _tokenAmount);\n', '\n', '        uint256 weiAmount = msg.value;\n', '        address inviter = referrals[_beneficiary];\n', '        if ( inviter != address(0x0) && referralDone == false ) {\n', '            uint256 baseRate = _getTokenAmountWithoutBonus(weiAmount);\n', '            uint256 referralAmountInviter = baseRate.div(100).mul(referralRateInviter);\n', '            uint256 referralAmountInvitee = baseRate.div(100).mul(referralRateInvitee);\n', '            uint256 referralRemains = referralAmount.sub(referralSent);\n', '            if ( referralRemains == 0 ) {\n', '                referralDone = true;\n', '            }\n', '            else {\n', '                if ( referralAmountInviter >= referralRemains ) {\n', '                    referralAmountInviter = referralRemains;\n', '                    referralAmountInvitee = 0; // priority to inviter\n', '                    emit ReferralCapReached();\n', '                    referralDone = true;\n', '                }\n', '                if ( referralDone == false && referralAmountInviter >= referralRemains ) {\n', '                    referralAmountInvitee = referralRemains.sub(referralAmountInviter);\n', '                    emit ReferralCapReached();\n', '                    referralDone = true;\n', '                }\n', '\n', '                uint256 referralAmountTotal = referralAmountInviter.add(referralAmountInvitee);\n', '                referralSent = referralSent.add(referralAmountTotal);\n', '\n', '                if ( referralAmountInviter > 0 ) {\n', '                    _deliverTokens(inviter, referralAmountInviter);\n', '                    emit PurchaseReferral(inviter, referralAmountInviter);\n', '                }\n', '                if ( referralAmountInvitee > 0 ) {\n', '                    _deliverTokens(_beneficiary, referralAmountInvitee);\n', '                    emit PurchaseReferral(_beneficiary, referralAmountInvitee);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n', '        // optional override\n', '    }\n', '\n', '    function _forwardFunds() internal {\n', '        vault.deposit.value(msg.value)(msg.sender);\n', '    }\n', '\n', '    // claim\n', '    function claimToken() public claimable isVerified(msg.sender) returns (bool) {\n', '        address beneficiary = msg.sender;\n', '        uint256 amount = sales[beneficiary];\n', '\n', '        emit TokenClaimed(beneficiary, amount);\n', '\n', '        sales[beneficiary] = 0;\n', '        return token.transferFrom(owner, beneficiary, amount);\n', '    }\n', '\n', '    function claimRefund() isVerified(msg.sender) public {\n', '        require(isFinalized == true);\n', '        require(!isGoalReached());\n', '\n', '        vault.refund(msg.sender);\n', '    }\n', '\n', '    function claimBountyToken() public claimable isVerified(msg.sender) returns (bool) {\n', '        address beneficiary = msg.sender;\n', '        uint256 amount = bounties[beneficiary];\n', '\n', '        emit TokenClaimed(beneficiary, amount);\n', '\n', '        bounties[beneficiary] = 0;\n', '        return token.transferFrom(owner, beneficiary, amount);\n', '    }\n', '\n', '    // bounty\n', '    function addBounty(address _address, uint256 _amount) public onlyAdmin isVerified(_address) returns (bool) {\n', '        require(bountyAmount.sub(bountySent) >= _amount);\n', '\n', '        bountySent = bountySent.add(_amount);\n', '        bounties[_address] = bounties[_address].add(_amount);\n', '        emit BountyUpdated(_address, true, _amount);\n', '    }\n', '    function delBounty(address _address, uint256 _amount) public onlyAdmin isVerified(_address) returns (bool) {\n', '        require(bounties[_address] >= _amount);\n', '        require(_amount >= bountySent);\n', '\n', '        bountySent = bountySent.sub(_amount);\n', '        bounties[_address] = bounties[_address].sub(_amount);\n', '        emit BountyUpdated(_address, false, _amount);\n', '    }\n', '    function getBountyAmount(address _address) public view returns (uint256) {\n', '        return bounties[_address];\n', '    }\n', '\n', '    // referral\n', '    function addReferral(address _inviter, address _invitee) public onlyAdmin isVerified(_inviter) isVerified(_invitee) returns (bool) {\n', '        referrals[_invitee] = _inviter;\n', '    }\n', '    function delReferral(address _inviter, address _invitee) public onlyAdmin isVerified(_inviter) isVerified(_invitee) returns (bool) {\n', '        delete referrals[_invitee];\n', '    }\n', '    function getReferral(address _address) public view returns (address) {\n', '        return referrals[_address];\n', '    }\n', '\n', '    // whitelist\n', '    function _deliverWhitelistBonus(address _beneficiary) internal {\n', '        if ( _beneficiary == address(0x0) ) {\n', '            return;\n', '        }\n', '\n', '        if ( whitelistBonus[_beneficiary] == true ) {\n', '            return;\n', '        }\n', '        \n', '        if (whitelistBonusAmount.sub(whitelistBonusSent) > whitelistBonusRate ) {\n', '            whitelistBonus[_beneficiary] = true;\n', '\n', '            whitelistBonusSent = whitelistBonusSent.add(whitelistBonusRate);\n', '            bounties[_beneficiary] = bounties[_beneficiary].add(whitelistBonusRate);\n', '            emit BountyUpdated(_beneficiary, true, whitelistBonusRate);\n', '        }\n', '    }\n', '    function isAccountWhitelisted(address _beneficiary) public view returns (bool) {\n', '        return whitelist[_beneficiary];\n', '    }\n', '\n', '    function addToWhitelist(address _beneficiary) external onlyAdmin {\n', '        whitelist[_beneficiary] = true;\n', '\n', '        if ( whitelistBonus[_beneficiary] == false && now < whitelistBonusClosingTime ) {\n', '            _deliverWhitelistBonus(_beneficiary);\n', '        }\n', '\n', '        emit WhitelistUpdated(_beneficiary, true);\n', '    }\n', '\n', '    function addManyToWhitelist(address[] _beneficiaries) external onlyAdmin {\n', '        uint256 i = 0;\n', '        if ( now < whitelistBonusClosingTime ) {\n', '            for (i = 0; i < _beneficiaries.length; i++) {\n', '                whitelist[_beneficiaries[i]] = true;\n', '                _deliverWhitelistBonus(_beneficiaries[i]);\n', '            }\n', '            return;\n', '        }\n', '\n', '        for (i = 0; i < _beneficiaries.length; i++) {\n', '            whitelist[_beneficiaries[i]] = true;\n', '        }\n', '\n', '        emit BulkWhitelistUpdated(_beneficiaries, true);\n', '    }\n', '\n', '    function removeFromWhitelist(address _beneficiary) external onlyAdmin {\n', '        whitelist[_beneficiary] = false;\n', '\n', '        emit WhitelistUpdated(_beneficiary, false);\n', '    }\n', '\n', '    // kyc\n', '    function isAccountVerified(address _beneficiary) public view returns (bool) {\n', '        return kyclist[_beneficiary];\n', '    }\n', '\n', '    function setAccountVerified(address _beneficiary) external onlyAdmin {\n', '        kyclist[_beneficiary] = true;\n', '\n', '        emit VerificationUpdated(_beneficiary, true);\n', '    }\n', '\n', '    function setManyAccountsVerified(address[] _beneficiaries) external onlyAdmin {\n', '        for (uint256 i = 0; i < _beneficiaries.length; i++) {\n', '            kyclist[_beneficiaries[i]] = true;\n', '        }\n', '\n', '        emit BulkVerificationUpdated(_beneficiaries, true);\n', '    }\n', '\n', '    function unverifyAccount(address _beneficiary) external onlyAdmin {\n', '        kyclist[_beneficiary] = false;\n', '\n', '        emit VerificationUpdated(_beneficiary, false);\n', '    }\n', '}']