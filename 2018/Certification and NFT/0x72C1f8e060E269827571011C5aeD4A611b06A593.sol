['contract Certifier {\n', '\tevent Confirmed(address indexed who);\n', '\tevent Revoked(address indexed who);\n', '\tfunction certified(address _who) view public returns (bool);\n', '}\n', '\n', '/// @title Contract that supports the receival of ERC223 tokens.\n', 'contract ERC223ReceivingContract {\n', '\n', '    /// @dev Standard ERC223 function that will handle incoming token transfers.\n', '    /// @param _from  Token sender address.\n', '    /// @param _value Amount of tokens.\n', '    /// @param _data  Transaction metadata.\n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '\n', '}\n', '\n', '\n', 'contract SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC223Basic is ERC20Basic {\n', '\n', '    /**\n', '      * @dev Transfer the specified amount of tokens to the specified address.\n', '      *      Now with a new parameter _data.\n', '      *\n', '      * @param _to    Receiver address.\n', '      * @param _value Amount of tokens that will be transferred.\n', '      * @param _data  Transaction metadata.\n', '      */\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool);\n', '\n', '    /**\n', '      * @dev triggered when transfer is successfully called.\n', '      *\n', '      * @param _from  Sender address.\n', '      * @param _to    Receiver address.\n', '      * @param _value Amount of tokens that will be transferred.\n', '      * @param _data  Transaction metadata.\n', '      */\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data);\n', '}\n', '\n', 'contract DetherAccessControl {\n', '    // This facet controls access control for Dether. There are four roles managed here:\n', '    //\n', '    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n', '    //         contracts. It is also the only role that can unpause the smart contract.\n', '    //\n', '    //     - The CMO: The CMO is in charge to open or close activity in zone\n', '    //\n', '    // It should be noted that these roles are distinct without overlap in their access abilities, the\n', '    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\n', '    // address to any role, the CEO address itself doesn&#39;t have the ability to act in those roles. This\n', '    // restriction is intentional so that we aren&#39;t tempted to use the CEO address frequently out of\n', '    // convenience. The less we use an address, the less likely it is that we somehow compromise the\n', '    // account.\n', '\n', '    /// @dev Emited when contract is upgraded\n', '    event ContractUpgrade(address newContract);\n', '\n', '    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public ceoAddress;\n', '    address public cmoAddress;\n', '    address public csoAddress; // CHIEF SHOP OFFICER\n', '    address public cfoAddress; // CHIEF FINANCIAL OFFICER\n', '\t  mapping (address => bool) public shopModerators;   // centralised moderator, would become decentralised\n', '    mapping (address => bool) public tellerModerators;   // centralised moderator, would become decentralised\n', '\n', '    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused = false;\n', '\n', '    /// @dev Access modifier for CEO-only functionality\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for CMO-only functionality\n', '    modifier onlyCMO() {\n', '        require(msg.sender == cmoAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCSO() {\n', '        require(msg.sender == csoAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    modifier isShopModerator(address _user) {\n', '      require(shopModerators[_user]);\n', '      _;\n', '    }\n', '    modifier isTellerModerator(address _user) {\n', '      require(tellerModerators[_user]);\n', '      _;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '    /// @param _newCEO The address of the new CEO\n', '    function setCEO(address _newCEO) external onlyCEO {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CMO. Only available to the current CEO.\n', '    /// @param _newCMO The address of the new CMO\n', '    function setCMO(address _newCMO) external onlyCEO {\n', '        require(_newCMO != address(0));\n', '        cmoAddress = _newCMO;\n', '    }\n', '\n', '    function setCSO(address _newCSO) external onlyCEO {\n', '        require(_newCSO != address(0));\n', '        csoAddress = _newCSO;\n', '    }\n', '\n', '    function setCFO(address _newCFO) external onlyCEO {\n', '        require(_newCFO != address(0));\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    function setShopModerator(address _moderator) external onlyCEO {\n', '      require(_moderator != address(0));\n', '      shopModerators[_moderator] = true;\n', '    }\n', '\n', '    function removeShopModerator(address _moderator) external onlyCEO {\n', '      shopModerators[_moderator] = false;\n', '    }\n', '\n', '    function setTellerModerator(address _moderator) external onlyCEO {\n', '      require(_moderator != address(0));\n', '      tellerModerators[_moderator] = true;\n', '    }\n', '\n', '    function removeTellerModerator(address _moderator) external onlyCEO {\n', '      tellerModerators[_moderator] = false;\n', '    }\n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '    ///  a bug or exploit is detected and we need to limit damage.\n', '    function pause() external onlyCEO whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '    ///  one reason we may pause the contract is when CMO account are\n', '    ///  compromised.\n', '    /// @notice This is public rather than external so it can be called by\n', '    ///  derived contracts.\n', '    function unpause() public onlyCEO whenPaused {\n', '        // can&#39;t unpause if contract was upgraded\n', '        paused = false;\n', '    }\n', '}\n', '\n', '\n', 'contract DetherSetup is DetherAccessControl  {\n', '\n', '  bool public run1 = false;\n', '  bool public run2 = false;\n', '  // -Need to be whitelisted to be able to register in the contract as a shop or\n', '  // teller, there is two level of identification.\n', '  // -This identification method are now centralised and processed by dether, but\n', '  // will be decentralised soon\n', '  Certifier public smsCertifier;\n', '  Certifier public kycCertifier;\n', '  // Zone need to be open by the CMO before accepting registration\n', '  // The bytes2 parameter wait for a country ID (ex: FR (0x4652 in hex) for france cf:README)\n', '  mapping(bytes2 => bool) public openedCountryShop;\n', '  mapping(bytes2 => bool) public openedCountryTeller;\n', '  // For registering in a zone you need to stake DTH\n', '  // The price can differ by country\n', '  // Uts now a fixed price by the CMO but the price will adjusted automatically\n', '  // regarding different factor in the futur smart contract\n', '  mapping(bytes2 => uint) public licenceShop;\n', '  mapping(bytes2 => uint) public licenceTeller;\n', '\n', '  modifier tier1(address _user) {\n', '    require(smsCertifier.certified(_user));\n', '    _;\n', '  }\n', '  modifier tier2(address _user) {\n', '    require(kycCertifier.certified(_user));\n', '    _;\n', '  }\n', '  modifier isZoneShopOpen(bytes2 _country) {\n', '    require(openedCountryShop[_country]);\n', '    _;\n', '  }\n', '  modifier isZoneTellerOpen(bytes2 _country) {\n', '    require(openedCountryTeller[_country]);\n', '    _;\n', '  }\n', '\n', '  function isTier1(address _user) public view returns(bool) {\n', '    return smsCertifier.certified(_user);\n', '  }\n', '  function isTier2(address _user) public view returns(bool) {\n', '    return kycCertifier.certified(_user);\n', '  }\n', '\n', '  /**\n', '   * INIT\n', '   */\n', '  function setSmsCertifier (address _smsCertifier) external onlyCEO {\n', '    require(!run1);\n', '    smsCertifier = Certifier(_smsCertifier);\n', '    run1 = true;\n', '  }\n', '  /**\n', '   * CORE FUNCTION\n', '   */\n', '  function setKycCertifier (address _kycCertifier) external onlyCEO {\n', '    require(!run2);\n', '    kycCertifier = Certifier(_kycCertifier);\n', '    run2 = true;\n', '  }\n', '  function setLicenceShopPrice(bytes2 country, uint price) external onlyCMO {\n', '    licenceShop[country] = price;\n', '  }\n', '  function setLicenceTellerPrice(bytes2 country, uint price) external onlyCMO {\n', '    licenceTeller[country] = price;\n', '  }\n', '  function openZoneShop(bytes2 _country) external onlyCMO {\n', '    openedCountryShop[_country] = true;\n', '  }\n', '  function closeZoneShop(bytes2 _country) external onlyCMO {\n', '    openedCountryShop[_country] = false;\n', '  }\n', '  function openZoneTeller(bytes2 _country) external onlyCMO {\n', '    openedCountryTeller[_country] = true;\n', '  }\n', '  function closeZoneTeller(bytes2 _country) external onlyCMO {\n', '    openedCountryTeller[_country] = false;\n', '  }\n', '}\n', '\n', 'library BytesLib {\n', '    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) {\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            // Get a location of some free memory and store it in tempBytes as\n', '            // Solidity does for memory variables.\n', '            tempBytes := mload(0x40)\n', '\n', '            // Store the length of the first bytes array at the beginning of\n', '            // the memory for tempBytes.\n', '            let length := mload(_preBytes)\n', '            mstore(tempBytes, length)\n', '\n', '            // Maintain a memory counter for the current write location in the\n', '            // temp bytes array by adding the 32 bytes for the array length to\n', '            // the starting location.\n', '            let mc := add(tempBytes, 0x20)\n', '            // Stop copying when the memory counter reaches the length of the\n', '            // first bytes array.\n', '            let end := add(mc, length)\n', '\n', '            for {\n', '                // Initialize a copy counter to the start of the _preBytes data,\n', '                // 32 bytes into its memory.\n', '                let cc := add(_preBytes, 0x20)\n', '            } lt(mc, end) {\n', '                // Increase both counters by 32 bytes each iteration.\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                // Write the _preBytes data into the tempBytes memory 32 bytes\n', '                // at a time.\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Add the length of _postBytes to the current length of tempBytes\n', '            // and store it as the new length in the first 32 bytes of the\n', '            // tempBytes memory.\n', '            length := mload(_postBytes)\n', '            mstore(tempBytes, add(length, mload(tempBytes)))\n', '\n', '            // Move the memory counter back from a multiple of 0x20 to the\n', '            // actual end of the _preBytes data.\n', '            mc := end\n', '            // Stop copying when the memory counter reaches the new combined\n', '            // length of the arrays.\n', '            end := add(mc, length)\n', '\n', '            for {\n', '                let cc := add(_postBytes, 0x20)\n', '            } lt(mc, end) {\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Update the free-memory pointer by padding our last write location\n', '            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n', '            // next 32 byte block, then round down to the nearest multiple of\n', '            // 32. If the sum of the length of the two arrays is zero then add\n', '            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n', '            mstore(0x40, and(\n', '              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n', '              not(31) // Round down to the nearest 32 bytes.\n', '            ))\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n', '        assembly {\n', '            // Read the first 32 bytes of _preBytes storage, which is the length\n', '            // of the array. (We don&#39;t need to use the offset into the slot\n', '            // because arrays use the entire slot.)\n', '            let fslot := sload(_preBytes_slot)\n', '            // Arrays of 31 bytes or less have an even value in their slot,\n', '            // while longer arrays have an odd value. The actual length is\n', '            // the slot divided by two for odd values, and the lowest order\n', '            // byte divided by two for even values.\n', '            // If the slot is even, bitwise and the slot with 255 and divide by\n', '            // two to get the length. If the slot is odd, bitwise and the slot\n', '            // with -1 and divide by two.\n', '            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n', '            let mlength := mload(_postBytes)\n', '            let newlength := add(slength, mlength)\n', '            // slength can contain both the length and contents of the array\n', '            // if length < 32 bytes so let&#39;s prepare for that\n', '            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n', '            switch add(lt(slength, 32), lt(newlength, 32))\n', '            case 2 {\n', '                // Since the new array still fits in the slot, we just need to\n', '                // update the contents of the slot.\n', '                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n', '                sstore(\n', '                    _preBytes_slot,\n', '                    // all the modifications to the slot are inside this\n', '                    // next block\n', '                    add(\n', '                        // we can just add to the slot contents because the\n', '                        // bytes we want to change are the LSBs\n', '                        fslot,\n', '                        add(\n', '                            mul(\n', '                                div(\n', '                                    // load the bytes from memory\n', '                                    mload(add(_postBytes, 0x20)),\n', '                                    // zero all bytes to the right\n', '                                    exp(0x100, sub(32, mlength))\n', '                                ),\n', '                                // and now shift left the number of bytes to\n', '                                // leave space for the length in the slot\n', '                                exp(0x100, sub(32, newlength))\n', '                            ),\n', '                            // increase length by the double of the memory\n', '                            // bytes length\n', '                            mul(mlength, 2)\n', '                        )\n', '                    )\n', '                )\n', '            }\n', '            case 1 {\n', '                // The stored value fits in the slot, but the combined value\n', '                // will exceed it.\n', '                // get the keccak hash to get the contents of the array\n', '                mstore(0x0, _preBytes_slot)\n', '                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n', '\n', '                // save new length\n', '                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n', '\n', '                // The contents of the _postBytes array start 32 bytes into\n', '                // the structure. Our first read should obtain the `submod`\n', '                // bytes that can fit into the unused space in the last word\n', '                // of the stored array. To get this, we read 32 bytes starting\n', '                // from `submod`, so the data we read overlaps with the array\n', '                // contents by `submod` bytes. Masking the lowest-order\n', '                // `submod` bytes allows us to add that value directly to the\n', '                // stored value.\n', '\n', '                let submod := sub(32, slength)\n', '                let mc := add(_postBytes, submod)\n', '                let end := add(_postBytes, mlength)\n', '                let mask := sub(exp(0x100, submod), 1)\n', '\n', '                sstore(\n', '                    sc,\n', '                    add(\n', '                        and(\n', '                            fslot,\n', '                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n', '                        ),\n', '                        and(mload(mc), mask)\n', '                    )\n', '                )\n', '\n', '                for {\n', '                    mc := add(mc, 0x20)\n', '                    sc := add(sc, 1)\n', '                } lt(mc, end) {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } {\n', '                    sstore(sc, mload(mc))\n', '                }\n', '\n', '                mask := exp(0x100, sub(mc, end))\n', '\n', '                sstore(sc, mul(div(mload(mc), mask), mask))\n', '            }\n', '            default {\n', '                // get the keccak hash to get the contents of the array\n', '                mstore(0x0, _preBytes_slot)\n', '                // Start copying to the last used word of the stored array.\n', '                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n', '\n', '                // save new length\n', '                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n', '\n', '                // Copy over the first `submod` bytes of the new data as in\n', '                // case 1 above.\n', '                let slengthmod := mod(slength, 32)\n', '                let mlengthmod := mod(mlength, 32)\n', '                let submod := sub(32, slengthmod)\n', '                let mc := add(_postBytes, submod)\n', '                let end := add(_postBytes, mlength)\n', '                let mask := sub(exp(0x100, submod), 1)\n', '\n', '                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n', '\n', '                for {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } lt(mc, end) {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } {\n', '                    sstore(sc, mload(mc))\n', '                }\n', '\n', '                mask := exp(0x100, sub(mc, end))\n', '\n', '                sstore(sc, mul(div(mload(mc), mask), mask))\n', '            }\n', '        }\n', '    }\n', '\n', '    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {\n', '        require(_bytes.length >= (_start + _length));\n', '\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            switch iszero(_length)\n', '            case 0 {\n', '                // Get a location of some free memory and store it in tempBytes as\n', '                // Solidity does for memory variables.\n', '                tempBytes := mload(0x40)\n', '\n', '                // The first word of the slice result is potentially a partial\n', '                // word read from the original array. To read it, we calculate\n', '                // the length of that partial word and start copying that many\n', '                // bytes into the array. The first word we copy will start with\n', '                // data we don&#39;t care about, but the last `lengthmod` bytes will\n', '                // land at the beginning of the contents of the new array. When\n', '                // we&#39;re done copying, we overwrite the full first word with\n', '                // the actual length of the slice.\n', '                let lengthmod := and(_length, 31)\n', '\n', '                // The multiplication in the next line is necessary\n', '                // because when slicing multiples of 32 bytes (lengthmod == 0)\n', '                // the following copy loop was copying the origin&#39;s length\n', '                // and then ending prematurely not copying everything it should.\n', '                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n', '                let end := add(mc, _length)\n', '\n', '                for {\n', '                    // The multiplication in the next line has the same exact purpose\n', '                    // as the one above.\n', '                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n', '                } lt(mc, end) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    mstore(mc, mload(cc))\n', '                }\n', '\n', '                mstore(tempBytes, _length)\n', '\n', '                //update free-memory pointer\n', '                //allocating the array padded to 32 bytes like the compiler does now\n', '                mstore(0x40, and(add(mc, 31), not(31)))\n', '            }\n', '            //if we want a zero-length slice let&#39;s just return a zero-length array\n', '            default {\n', '                tempBytes := mload(0x40)\n', '\n', '                mstore(0x40, add(tempBytes, 0x20))\n', '            }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function toAddress(bytes _bytes, uint _start) internal  pure returns (address) {\n', '        require(_bytes.length >= (_start + 20));\n', '        address tempAddress;\n', '\n', '        assembly {\n', '            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '\n', '    function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) {\n', '        require(_bytes.length >= (_start + 32));\n', '        uint256 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toBytes32(bytes _bytes, uint _start) internal  pure returns (bytes32) {\n', '        require(_bytes.length >= (_start + 32));\n', '        bytes32 tempBytes32;\n', '\n', '        assembly {\n', '            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes32;\n', '    }\n', '\n', '    function toBytes16(bytes _bytes, uint _start) internal  pure returns (bytes16) {\n', '        require(_bytes.length >= (_start + 16));\n', '        bytes16 tempBytes16;\n', '\n', '        assembly {\n', '            tempBytes16 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes16;\n', '    }\n', '\n', '    function toBytes2(bytes _bytes, uint _start) internal  pure returns (bytes2) {\n', '        require(_bytes.length >= (_start + 2));\n', '        bytes2 tempBytes2;\n', '\n', '        assembly {\n', '            tempBytes2 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes2;\n', '    }\n', '\n', '    function toBytes4(bytes _bytes, uint _start) internal  pure returns (bytes4) {\n', '        require(_bytes.length >= (_start + 4));\n', '        bytes4 tempBytes4;\n', '\n', '        assembly {\n', '            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '        return tempBytes4;\n', '    }\n', '\n', '    function toBytes1(bytes _bytes, uint _start) internal  pure returns (bytes1) {\n', '        require(_bytes.length >= (_start + 1));\n', '        bytes1 tempBytes1;\n', '\n', '        assembly {\n', '            tempBytes1 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes1;\n', '    }\n', '\n', '    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n', '        bool success = true;\n', '\n', '        assembly {\n', '            let length := mload(_preBytes)\n', '\n', '            // if lengths don&#39;t match the arrays are not equal\n', '            switch eq(length, mload(_postBytes))\n', '            case 1 {\n', '                // cb is a circuit breaker in the for loop since there&#39;s\n', '                //  no said feature for inline assembly loops\n', '                // cb = 1 - don&#39;t breaker\n', '                // cb = 0 - break\n', '                let cb := 1\n', '\n', '                let mc := add(_preBytes, 0x20)\n', '                let end := add(mc, length)\n', '\n', '                for {\n', '                    let cc := add(_postBytes, 0x20)\n', '                // the next line is the loop condition:\n', '                // while(uint(mc < end) + cb == 2)\n', '                } eq(add(lt(mc, end), cb), 2) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    // if any of these checks fails then arrays are not equal\n', '                    if iszero(eq(mload(mc), mload(cc))) {\n', '                        // unsuccess:\n', '                        success := 0\n', '                        cb := 0\n', '                    }\n', '                }\n', '            }\n', '            default {\n', '                // unsuccess:\n', '                success := 0\n', '            }\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n', '        bool success = true;\n', '\n', '        assembly {\n', '            // we know _preBytes_offset is 0\n', '            let fslot := sload(_preBytes_slot)\n', '            // Decode the length of the stored array like in concatStorage().\n', '            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n', '            let mlength := mload(_postBytes)\n', '\n', '            // if lengths don&#39;t match the arrays are not equal\n', '            switch eq(slength, mlength)\n', '            case 1 {\n', '                // slength can contain both the length and contents of the array\n', '                // if length < 32 bytes so let&#39;s prepare for that\n', '                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n', '                if iszero(iszero(slength)) {\n', '                    switch lt(slength, 32)\n', '                    case 1 {\n', '                        // blank the last byte which is the length\n', '                        fslot := mul(div(fslot, 0x100), 0x100)\n', '\n', '                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n', '                            // unsuccess:\n', '                            success := 0\n', '                        }\n', '                    }\n', '                    default {\n', '                        // cb is a circuit breaker in the for loop since there&#39;s\n', '                        //  no said feature for inline assembly loops\n', '                        // cb = 1 - don&#39;t breaker\n', '                        // cb = 0 - break\n', '                        let cb := 1\n', '\n', '                        // get the keccak hash to get the contents of the array\n', '                        mstore(0x0, _preBytes_slot)\n', '                        let sc := keccak256(0x0, 0x20)\n', '\n', '                        let mc := add(_postBytes, 0x20)\n', '                        let end := add(mc, mlength)\n', '\n', '                        // the next line is the loop condition:\n', '                        // while(uint(mc < end) + cb == 2)\n', '                        for {} eq(add(lt(mc, end), cb), 2) {\n', '                            sc := add(sc, 1)\n', '                            mc := add(mc, 0x20)\n', '                        } {\n', '                            if iszero(eq(sload(sc), mload(mc))) {\n', '                                // unsuccess:\n', '                                success := 0\n', '                                cb := 0\n', '                            }\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '            default {\n', '                // unsuccess:\n', '                success := 0\n', '            }\n', '        }\n', '\n', '        return success;\n', '    }\n', '}\n', 'contract ExchangeRateOracle {\n', '  function getWeiPriceOneUsd() external view returns(uint256);\n', '}\n', '\n', '// only interface to save gas\n', 'contract DetherBank {\n', '  function withdrawDthTeller(address _receiver) external;\n', '  function withdrawDthShop(address _receiver) external;\n', '  function withdrawDthShopAdmin(address _from, address _receiver) external;\n', '  function addTokenShop(address _from, uint _value) external;\n', '  function addTokenTeller(address _from, uint _value) external;\n', '  function addEthTeller(address _from, uint _value) external payable returns (bool);\n', '  function withdrawEth(address _from, address _to, uint _amount) external;\n', '  function refundEth(address _from) external;\n', '  function getDthTeller(address _user) public view returns (uint);\n', '  function getDthShop(address _user) public view returns (uint);\n', '  function getEthBalTeller(address _user) public view returns (uint);\n', '  function getWeiSoldToday(address _user) public view returns (uint256 weiSoldToday);\n', '  function transferOwnership(address newOwner) public;\n', '}\n', '\n', 'contract DetherCore is DetherSetup, ERC223ReceivingContract, SafeMath {\n', '  using BytesLib for bytes;\n', '\n', '  /**\n', '  * Event\n', '  */\n', '  // when a Teller is registered\n', '  event RegisterTeller(address indexed tellerAddress);\n', '  // when a teller is deleted\n', '  event DeleteTeller(address indexed tellerAddress);\n', '  // when teller update\n', '  event UpdateTeller(address indexed tellerAddress);\n', '  // when a teller send to a buyer\n', '  event Sent(address indexed _from, address indexed _to, uint amount);\n', '  // when a shop register\n', '  event RegisterShop(address shopAddress);\n', '  // when a shop delete\n', '  event DeleteShop(address shopAddress);\n', '  // when a moderator delete a shop\n', '  event DeleteShopModerator(address indexed moderator, address shopAddress);\n', '  // when a moderator delete a teller\n', '  event DeleteTellerModerator(address indexed moderator, address tellerAddress);\n', '\n', '  /**\n', '   * Modifier\n', '   */\n', '  // if teller has staked enough dth to\n', '  modifier tellerHasStaked(uint amount) {\n', '    require(bank.getDthTeller(msg.sender) >= amount);\n', '    _;\n', '  }\n', '  // if shop has staked enough dth to\n', '  modifier shopHasStaked(uint amount) {\n', '    require(bank.getDthShop(msg.sender) >= amount);\n', '    _;\n', '  }\n', '\n', '  /*\n', '   * External contract\n', '   */\n', '  // DTH contract\n', '  ERC223Basic public dth;\n', '  // bank contract where are stored ETH and DTH\n', '  DetherBank public bank;\n', '\n', '  ExchangeRateOracle public priceOracle;\n', '\n', '  // teller struct\n', '  struct Teller {\n', '    int32 lat;            // Latitude\n', '    int32 lng;            // Longitude\n', '    bytes2 countryId;     // countryID (in hexa), ISO ALPHA 2 https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\n', '    bytes16 postalCode;   // postalCode if present, in Hexa https://en.wikipedia.org/wiki/List_of_postal_codes\n', '\n', '    int8 currencyId;      // 1 - 100 , cf README\n', '    bytes16 messenger;    // telegrame nickname\n', '    int8 avatarId;        // 1 - 100 , regarding the front-end app you use\n', '    int16 rates;          // margin of tellers , -999 - +9999 , corresponding to -99,9% x 10  , 999,9% x 10\n', '    bool buyer;           // appear as a buyer as well on the map\n', '    int16 buyRates;         // margin of tellers of\n', '\n', '    uint zoneIndex;       // index of the zone mapping\n', '    uint generalIndex;    // index of general mapping\n', '    bool online;          // switch online/offline, if the tellers want to be inactive without deleting his point\n', '  }\n', '\n', '  mapping(address => mapping(address => uint)) internal pairSellsLoyaltyPerc;\n', '  //      from               to         percentage of loyalty points from gets\n', '\n', '  /*\n', '   * Reputation field V0.1\n', '   * Reputation is based on volume sell, volume buy, and number of transaction\n', '   */\n', '  mapping(address => uint) volumeBuy;\n', '  mapping(address => uint) volumeSell;\n', '  mapping(address => uint) nbTrade;\n', '  mapping(address => uint256) loyaltyPoints;\n', '\n', '  // general mapping of teller\n', '  mapping(address => Teller) teller;\n', '  // mappoing of teller by COUNTRYCODE => POSTALCODE\n', '  mapping(bytes2 => mapping(bytes16 => address[])) tellerInZone;\n', '  // teller array currently registered\n', '  address[] public tellerIndex; // unordered list of teller register on it\n', '  bool isStarted = false;\n', '  // shop struct\n', '  struct Shop {\n', '    int32 lat;            // latitude\n', '    int32 lng;            // longitude\n', '    bytes2 countryId;     // countryID (in hexa char), ISO ALPHA 2 https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\n', '    bytes16 postalCode;   // postalCode if present (in hexa char), in Hexa https://en.wikipedia.org/wiki/List_of_postal_codes\n', '    bytes16 cat;          // Category of the shop (in hex char), will be used later for search engine and auction by zone\n', '    bytes16 name;         // name of the shop (in hex char)\n', '    bytes32 description;  // description of the shop\n', '    bytes16 opening;      // opening hours, cf README for the format\n', '\n', '    uint zoneIndex;       // index of the zone mapping\n', '    uint generalIndex;    // index of general mapping\n', '    bool detherShop;      // bool if shop is registered by dether as business partnership (still required DTH)\n', '  }\n', '\n', '  // general mapping of shop\n', '  mapping(address => Shop) shop;\n', '  // mapping of teller by COUNTRYCODE => POSTALCODE\n', '  mapping(bytes2 => mapping(bytes16 => address[])) shopInZone;\n', '  // shop array currently registered\n', '  address[] public shopIndex; // unordered list of shop register on it\n', '\n', '  /*\n', '   * Instanciation\n', '   */\n', '  function DetherCore() {\n', '   ceoAddress = msg.sender;\n', '  }\n', '  function initContract (address _dth, address _bank) external onlyCEO {\n', '    require(!isStarted);\n', '    dth = ERC223Basic(_dth);\n', '    bank = DetherBank(_bank);\n', '    isStarted = true;\n', '  }\n', '\n', '  function setPriceOracle (address _priceOracle) external onlyCFO {\n', '    priceOracle = ExchangeRateOracle(_priceOracle);\n', '  }\n', '\n', '  /**\n', '   * Core fonction\n', '   */\n', '\n', '  /**\n', '   * @dev Standard ERC223 function that will handle incoming token transfers.\n', '   * This is the main function to register SHOP or TELLER, its calling when you\n', '   * send token to the DTH contract and by passing data as bytes on the third\n', '   * parameter.\n', '   * Its not supposed to be use on its own but will only handle incoming DTH\n', '   * transaction.\n', '   * The _data will wait for\n', '   * [1st byte] 1 (0x31) for shop OR 2 (0x32) for teller\n', '   * FOR SHOP AND TELLER:\n', '   * 2sd to 5th bytes lat\n', '   * 6th to 9th bytes lng\n', '   * ...\n', '   * Modifier tier1: Check if address is whitelisted with the sms verification\n', '   */\n', '  function tokenFallback(address _from, uint _value, bytes _data) whenNotPaused tier1(_from ) {\n', '    // require than the token fallback is triggered from the dth token contract\n', '    require(msg.sender == address(dth));\n', '    // check first byte to know if its shop or teller registration\n', '    // 1 / 0x31 = shop // 2 / 0x32 = teller\n', '    bytes1 _func = _data.toBytes1(0);\n', '    int32 posLat = _data.toBytes1(1) == bytes1(0x01) ? int32(_data.toBytes4(2)) * -1 : int32(_data.toBytes4(2));\n', '    int32 posLng = _data.toBytes1(6) == bytes1(0x01) ? int32(_data.toBytes4(7)) * -1 : int32(_data.toBytes4(7));\n', '    if (_func == bytes1(0x31)) { // shop registration // GAS USED 311000\n', '      // require staked greater than licence price\n', '      require(_value >= licenceShop[_data.toBytes2(11)]);\n', '      // require its not already shop\n', '      require(!isShop(_from));\n', '      // require zone is open\n', '      require(openedCountryShop[_data.toBytes2(11)]);\n', '\n', '      shop[_from].lat = posLat;\n', '      shop[_from].lng = posLng;\n', '      shop[_from].countryId = _data.toBytes2(11);\n', '      shop[_from].postalCode = _data.toBytes16(13);\n', '      shop[_from].cat = _data.toBytes16(29);\n', '      shop[_from].name = _data.toBytes16(45);\n', '      shop[_from].description = _data.toBytes32(61);\n', '      shop[_from].opening = _data.toBytes16(93);\n', '      shop[_from].generalIndex = shopIndex.push(_from) - 1;\n', '      shop[_from].zoneIndex = shopInZone[_data.toBytes2(11)][_data.toBytes16(13)].push(_from) - 1;\n', '      emit RegisterShop(_from);\n', '      bank.addTokenShop(_from,_value);\n', '      dth.transfer(address(bank), _value);\n', '    } else if (_func == bytes1(0x32)) { // teller registration -- GAS USED 310099\n', '      // require staked greater than licence price\n', '      require(_value >= licenceTeller[_data.toBytes2(11)]);\n', '      // require is not already a teller\n', '      require(!isTeller(_from));\n', '      // require zone is open\n', '      require(openedCountryTeller[_data.toBytes2(11)]);\n', '\n', '      teller[_from].lat = posLat;\n', '      teller[_from].lng = posLng;\n', '      teller[_from].countryId = _data.toBytes2(11);\n', '      teller[_from].postalCode = _data.toBytes16(13);\n', '      teller[_from].avatarId = int8(_data.toBytes1(29));\n', '      teller[_from].currencyId = int8(_data.toBytes1(30));\n', '      teller[_from].messenger = _data.toBytes16(31);\n', '      teller[_from].rates = int16(_data.toBytes2(47));\n', '      teller[_from].buyer = _data.toBytes1(49) == bytes1(0x01) ? true : false;\n', '      teller[_from].buyRates = int16(_data.toBytes2(50));\n', '      teller[_from].generalIndex = tellerIndex.push(_from) - 1;\n', '      teller[_from].zoneIndex = tellerInZone[_data.toBytes2(11)][_data.toBytes16(13)].push(_from) - 1;\n', '      teller[_from].online = true;\n', '      emit RegisterTeller(_from);\n', '      bank.addTokenTeller(_from, _value);\n', '      dth.transfer(address(bank), _value);\n', '    } else if (_func == bytes1(0x33)) {  // shop bulk registration\n', '      // We need to have the possibility to register in bulk some shop\n', '      // For big retailer company willing to be listed on dether, we need to have a way to add\n', '      // all their shop from one address\n', '      // This functionnality will become available for anyone willing to list multiple shop\n', '      // in the futures contract\n', '\n', '      // Only the CSO should be able to register shop in bulk\n', '      require(_from == csoAddress);\n', '      // Each shop still need his own staking\n', '      require(_value >= licenceShop[_data.toBytes2(11)]);\n', '      // require the addresses not already registered\n', '      require(!isShop(address(_data.toAddress(109))));\n', '      // require zone is open\n', '      require(openedCountryShop[_data.toBytes2(11)]);\n', '      address newShopAddress = _data.toAddress(109);\n', '      shop[newShopAddress].lat = posLat;\n', '      shop[newShopAddress].lng = posLng;\n', '      shop[newShopAddress].countryId = _data.toBytes2(11);\n', '      shop[newShopAddress].postalCode = _data.toBytes16(13);\n', '      shop[newShopAddress].cat = _data.toBytes16(29);\n', '      shop[newShopAddress].name = _data.toBytes16(45);\n', '      shop[newShopAddress].description = _data.toBytes32(61);\n', '      shop[newShopAddress].opening = _data.toBytes16(93);\n', '      shop[newShopAddress].generalIndex = shopIndex.push(newShopAddress) - 1;\n', '      shop[newShopAddress].zoneIndex = shopInZone[_data.toBytes2(11)][_data.toBytes16(13)].push(newShopAddress) - 1;\n', '      shop[newShopAddress].detherShop = true;\n', '      emit RegisterShop(newShopAddress);\n', '      bank.addTokenShop(newShopAddress, _value);\n', '      dth.transfer(address(bank), _value);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * a teller can update his profile\n', '   * If a teller want to change his location, he would need to delete and recreate\n', '   * a new point\n', '   */\n', '  function updateTeller(\n', '    int8 currencyId,\n', '    bytes16 messenger,\n', '    int8 avatarId,\n', '    int16 rates,\n', '    bool online\n', '   ) public payable {\n', '    require(isTeller(msg.sender));\n', '    if (currencyId != teller[msg.sender].currencyId)\n', '    teller[msg.sender].currencyId = currencyId;\n', '    if (teller[msg.sender].messenger != messenger)\n', '     teller[msg.sender].messenger = messenger;\n', '    if (teller[msg.sender].avatarId != avatarId)\n', '     teller[msg.sender].avatarId = avatarId;\n', '    if (teller[msg.sender].rates != rates)\n', '     teller[msg.sender].rates = rates;\n', '    if (teller[msg.sender].online != online)\n', '      teller[msg.sender].online = online;\n', '    if (msg.value > 0) {\n', '      bank.addEthTeller.value(msg.value)(msg.sender, msg.value);\n', '    }\n', '    emit UpdateTeller(msg.sender);\n', '  }\n', '\n', '  // mapping for limiting the sell amount\n', '  //      tier             countryId usdDailyLimit\n', '  mapping(uint => mapping (bytes2 => uint)) limitTier;\n', '\n', '  function setSellDailyLimit(uint _tier, bytes2 _countryId, uint256 _limitUsd) public onlyCFO {\n', '    limitTier[_tier][_countryId] = _limitUsd;\n', '  }\n', '  function getSellDailyLimit(uint _tier, bytes2 _countryId) public view returns(uint256 limitUsd) {\n', '    limitUsd = limitTier[_tier][_countryId];\n', '  }\n', '\n', '  modifier doesNotExceedDailySellLimit(address _teller, uint256 _weiSellAmount) {\n', '    // limits are set per country\n', '    bytes2 countryId = teller[_teller].countryId;\n', '\n', '    // user is always tier1, and could be tier2\n', '    uint256 usdDailyLimit = getSellDailyLimit(isTier2(_teller) ? 2 : 1, countryId);\n', '\n', '    // weiPriceOneUsd is set by the oracle (which runs every day at midnight)\n', '    uint256 weiDailyLimit = SafeMath.mul(priceOracle.getWeiPriceOneUsd(), usdDailyLimit);\n', '\n', '    // with each sell we update wei sold today for that user inside the Bank contract\n', '    uint256 weiSoldToday = bank.getWeiSoldToday(_teller);\n', '\n', '    uint256 newWeiSoldToday = SafeMath.add(weiSoldToday, _weiSellAmount);\n', '\n', '    // we may not exceed the daily wei limit with this sell\n', '    require(newWeiSoldToday <= weiDailyLimit);\n', '    _;\n', '  }\n', '\n', '  function getPairSellLoyaltyPerc(address _from, address _to) public view returns(uint256) {\n', '    return pairSellsLoyaltyPerc[_from][_to];\n', '  }\n', '\n', '  function getLoyaltyPoints(address who) public view returns (uint256) {\n', '    return loyaltyPoints[who];\n', '  }\n', '\n', '  /**\n', '   * SellEth\n', '   * average gas cost: 123173\n', '   * @param _to -> the address for the receiver\n', '   * @param _amount -> the amount to send\n', '   */\n', '  function sellEth(address _to, uint _amount)\n', '    whenNotPaused\n', '    doesNotExceedDailySellLimit(msg.sender, _amount)\n', '    external\n', '  {\n', '    require(isTeller(msg.sender));\n', '    require(_to != msg.sender);\n', '    // send eth to the receiver from the bank contract\n', '    // this will also update eth amount sold &#39;today&#39; by msg.sender\n', '    bank.withdrawEth(msg.sender, _to, _amount);\n', '\n', '    // increase reput for the buyer and the seller Only if the buyer is also whitelisted,\n', '    // It&#39;s a way to incentive user to trade on the system\n', '    if (smsCertifier.certified(_to)) {\n', '      uint currentSellerLoyaltyPointsPerc = pairSellsLoyaltyPerc[msg.sender][_to];\n', '      if (currentSellerLoyaltyPointsPerc == 0) {\n', '        // this is the first sell between seller and buyer, set to 100%\n', '        pairSellsLoyaltyPerc[msg.sender][_to] = 10000;\n', '        currentSellerLoyaltyPointsPerc = 10000;\n', '      }\n', '\n', '      // add percentage of loyaltyPoints of this sell to seller&#39;s loyaltyPoints\n', '      loyaltyPoints[msg.sender] = SafeMath.add(loyaltyPoints[msg.sender], SafeMath.mul(_amount, currentSellerLoyaltyPointsPerc) / 10000);\n', '\n', '      // update the loyaltyPoints percentage of the seller, there will be a 21% decrease with every sell to the same buyer (100 - 21 = 79)\n', '      pairSellsLoyaltyPerc[msg.sender][_to] = SafeMath.mul(currentSellerLoyaltyPointsPerc, 79) / 100;\n', '\n', '      volumeBuy[_to] = SafeMath.add(volumeBuy[_to], _amount);\n', '      volumeSell[msg.sender] = SafeMath.add(volumeSell[msg.sender], _amount);\n', '      nbTrade[msg.sender] += 1;\n', '    }\n', '    emit Sent(msg.sender, _to, _amount);\n', '  }\n', '\n', '  /**\n', '   * switchStatus\n', '   * Turn status teller on/off\n', '   */\n', '  function switchStatus(bool _status) external {\n', '    if (teller[msg.sender].online != _status)\n', '     teller[msg.sender].online = _status;\n', '  }\n', '\n', '  /**\n', '   * addFunds\n', '   * teller can add more funds on his sellpoint\n', '   */\n', '  function addFunds() external payable {\n', '    require(isTeller(msg.sender));\n', '    require(bank.addEthTeller.value(msg.value)(msg.sender, msg.value));\n', '  }\n', '\n', '  // gas used 67841\n', '  // a teller can delete a sellpoint\n', '  function deleteTeller() external {\n', '    require(isTeller(msg.sender));\n', '    uint rowToDelete1 = teller[msg.sender].zoneIndex;\n', '    address keyToMove1 = tellerInZone[teller[msg.sender].countryId][teller[msg.sender].postalCode][tellerInZone[teller[msg.sender].countryId][teller[msg.sender].postalCode].length - 1];\n', '    tellerInZone[teller[msg.sender].countryId][teller[msg.sender].postalCode][rowToDelete1] = keyToMove1;\n', '    teller[keyToMove1].zoneIndex = rowToDelete1;\n', '    tellerInZone[teller[msg.sender].countryId][teller[msg.sender].postalCode].length--;\n', '\n', '    uint rowToDelete2 = teller[msg.sender].generalIndex;\n', '    address keyToMove2 = tellerIndex[tellerIndex.length - 1];\n', '    tellerIndex[rowToDelete2] = keyToMove2;\n', '    teller[keyToMove2].generalIndex = rowToDelete2;\n', '    tellerIndex.length--;\n', '    delete teller[msg.sender];\n', '    bank.withdrawDthTeller(msg.sender);\n', '    bank.refundEth(msg.sender);\n', '    emit DeleteTeller(msg.sender);\n', '  }\n', '\n', '  // gas used 67841\n', '  // A moderator can delete a sellpoint\n', '  function deleteTellerMods(address _toDelete) isTellerModerator(msg.sender) external {\n', '    require(isTeller(_toDelete));\n', '    uint rowToDelete1 = teller[_toDelete].zoneIndex;\n', '    address keyToMove1 = tellerInZone[teller[_toDelete].countryId][teller[_toDelete].postalCode][tellerInZone[teller[_toDelete].countryId][teller[_toDelete].postalCode].length - 1];\n', '    tellerInZone[teller[_toDelete].countryId][teller[_toDelete].postalCode][rowToDelete1] = keyToMove1;\n', '    teller[keyToMove1].zoneIndex = rowToDelete1;\n', '    tellerInZone[teller[_toDelete].countryId][teller[_toDelete].postalCode].length--;\n', '\n', '    uint rowToDelete2 = teller[_toDelete].generalIndex;\n', '    address keyToMove2 = tellerIndex[tellerIndex.length - 1];\n', '    tellerIndex[rowToDelete2] = keyToMove2;\n', '    teller[keyToMove2].generalIndex = rowToDelete2;\n', '    tellerIndex.length--;\n', '    delete teller[_toDelete];\n', '    bank.withdrawDthTeller(_toDelete);\n', '    bank.refundEth(_toDelete);\n', '    emit DeleteTellerModerator(msg.sender, _toDelete);\n', '  }\n', '\n', '  // gas used 67841\n', '  // A shop owner can delete his point.\n', '  function deleteShop() external {\n', '    require(isShop(msg.sender));\n', '    uint rowToDelete1 = shop[msg.sender].zoneIndex;\n', '    address keyToMove1 = shopInZone[shop[msg.sender].countryId][shop[msg.sender].postalCode][shopInZone[shop[msg.sender].countryId][shop[msg.sender].postalCode].length - 1];\n', '    shopInZone[shop[msg.sender].countryId][shop[msg.sender].postalCode][rowToDelete1] = keyToMove1;\n', '    shop[keyToMove1].zoneIndex = rowToDelete1;\n', '    shopInZone[shop[msg.sender].countryId][shop[msg.sender].postalCode].length--;\n', '\n', '    uint rowToDelete2 = shop[msg.sender].generalIndex;\n', '    address keyToMove2 = shopIndex[shopIndex.length - 1];\n', '    shopIndex[rowToDelete2] = keyToMove2;\n', '    shop[keyToMove2].generalIndex = rowToDelete2;\n', '    shopIndex.length--;\n', '    delete shop[msg.sender];\n', '    bank.withdrawDthShop(msg.sender);\n', '    emit DeleteShop(msg.sender);\n', '  }\n', '\n', '  // gas used 67841\n', '  // Moderator can delete a shop point\n', '  function deleteShopMods(address _toDelete) isShopModerator(msg.sender) external {\n', '    uint rowToDelete1 = shop[_toDelete].zoneIndex;\n', '    address keyToMove1 = shopInZone[shop[_toDelete].countryId][shop[_toDelete].postalCode][shopInZone[shop[_toDelete].countryId][shop[_toDelete].postalCode].length - 1];\n', '    shopInZone[shop[_toDelete].countryId][shop[_toDelete].postalCode][rowToDelete1] = keyToMove1;\n', '    shop[keyToMove1].zoneIndex = rowToDelete1;\n', '    shopInZone[shop[_toDelete].countryId][shop[_toDelete].postalCode].length--;\n', '\n', '    uint rowToDelete2 = shop[_toDelete].generalIndex;\n', '    address keyToMove2 = shopIndex[shopIndex.length - 1];\n', '    shopIndex[rowToDelete2] = keyToMove2;\n', '    shop[keyToMove2].generalIndex = rowToDelete2;\n', '    shopIndex.length--;\n', '    if (!shop[_toDelete].detherShop)\n', '      bank.withdrawDthShop(_toDelete);\n', '    else\n', '      bank.withdrawDthShopAdmin(_toDelete, csoAddress);\n', '    delete shop[_toDelete];\n', '    emit DeleteShopModerator(msg.sender, _toDelete);\n', '  }\n', '\n', '  /**\n', '   *  GETTER\n', '   */\n', '\n', '  // get teller\n', '  // return teller info\n', '  function getTeller(address _teller) public view returns (\n', '    int32 lat,\n', '    int32 lng,\n', '    bytes2 countryId,\n', '    bytes16 postalCode,\n', '    int8 currencyId,\n', '    bytes16 messenger,\n', '    int8 avatarId,\n', '    int16 rates,\n', '    uint balance,\n', '    bool online,\n', '    bool buyer,\n', '    int16 buyRates\n', '    ) {\n', '    Teller storage theTeller = teller[_teller];\n', '    lat = theTeller.lat;\n', '    lng = theTeller.lng;\n', '    countryId = theTeller.countryId;\n', '    postalCode = theTeller.postalCode;\n', '    currencyId = theTeller.currencyId;\n', '    messenger = theTeller.messenger;\n', '    avatarId = theTeller.avatarId;\n', '    rates = theTeller.rates;\n', '    online = theTeller.online;\n', '    buyer = theTeller.buyer;\n', '    buyRates = theTeller.buyRates;\n', '    balance = bank.getEthBalTeller(_teller);\n', '  }\n', '\n', '  /*\n', '   * Shop ----------------------------------\n', '   * return Shop value\n', '   */\n', '  function getShop(address _shop) public view returns (\n', '   int32 lat,\n', '   int32 lng,\n', '   bytes2 countryId,\n', '   bytes16 postalCode,\n', '   bytes16 cat,\n', '   bytes16 name,\n', '   bytes32 description,\n', '   bytes16 opening\n', '   ) {\n', '    Shop storage theShop = shop[_shop];\n', '    lat = theShop.lat;\n', '    lng = theShop.lng;\n', '    countryId = theShop.countryId;\n', '    postalCode = theShop.postalCode;\n', '    cat = theShop.cat;\n', '    name = theShop.name;\n', '    description = theShop.description;\n', '    opening = theShop.opening;\n', '   }\n', '\n', '   // get reput\n', '   // return reputation data from teller\n', '  function getReput(address _teller) public view returns (\n', '   uint buyVolume,\n', '   uint sellVolume,\n', '   uint numTrade,\n', '   uint256 loyaltyPoints_\n', '   ) {\n', '     buyVolume = volumeBuy[_teller];\n', '     sellVolume = volumeSell[_teller];\n', '     numTrade = nbTrade[_teller];\n', '     loyaltyPoints_ = loyaltyPoints[_teller];\n', '  }\n', '  // return balance of teller put in escrow\n', '  function getTellerBalance(address _teller) public view returns (uint) {\n', '    return bank.getEthBalTeller(_teller);\n', '  }\n', '\n', '  // return an array of address of all zone present on a zone\n', '  // zone is a mapping COUNTRY => POSTALCODE\n', '  function getZoneShop(bytes2 _country, bytes16 _postalcode) public view returns (address[]) {\n', '     return shopInZone[_country][_postalcode];\n', '  }\n', '\n', '  // return array of address of all shop\n', '  function getAllShops() public view returns (address[]) {\n', '   return shopIndex;\n', '  }\n', '\n', '  function isShop(address _shop) public view returns (bool ){\n', '   return (shop[_shop].countryId != bytes2(0x0));\n', '  }\n', '\n', '  // return an array of address of all teller present on a zone\n', '  // zone is a mapping COUNTRY => POSTALCODE\n', '  function getZoneTeller(bytes2 _country, bytes16 _postalcode) public view returns (address[]) {\n', '     return tellerInZone[_country][_postalcode];\n', '  }\n', '\n', '  // return array of address of all teller\n', '  function getAllTellers() public view returns (address[]) {\n', '   return tellerIndex;\n', '  }\n', '\n', '  // return if teller or not\n', '  function isTeller(address _teller) public view returns (bool ){\n', '    return (teller[_teller].countryId != bytes2(0x0));\n', '  }\n', '\n', '  /*\n', '   * misc\n', '   */\n', '   // return info about how much DTH the shop has staked\n', '  function getStakedShop(address _shop) public view returns (uint) {\n', '    return bank.getDthShop(_shop);\n', '  }\n', '  // return info about how much DTH the teller has staked\n', '  function getStakedTeller(address _teller) public view returns (uint) {\n', '    return bank.getDthTeller(_teller);\n', '  }\n', '  // give ownership to the bank contract\n', '  function transferBankOwnership(address _newbankowner) external onlyCEO whenPaused {\n', '    bank.transferOwnership(_newbankowner);\n', '  }\n', '}']