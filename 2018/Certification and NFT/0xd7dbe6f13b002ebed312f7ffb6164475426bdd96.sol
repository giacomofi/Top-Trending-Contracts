['pragma solidity 0.4.24;\n', '\n', 'interface tokenRecipient {\n', '    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n', '}\n', '\n', 'interface ERC20CompatibleToken {\n', '    function transfer (address to, uint256 value) external returns (bool);\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks that throw on overflows.\n', ' */\n', 'library SafeMath {\n', '    \n', '    function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function div (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '    \n', '    function sub (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * DreamTeam test token contract. It implements the next capabilities:\n', ' * 1. Standard ERC20 functionality. [OK]\n', ' * 2. Additional utility function approveAndCall. [OK]\n', ' * 3. Function to rescue "lost forever" tokens, which were accidentally sent to this smart contract. [OK]\n', ' * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n', ' *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [OK]\n', ' * 5. Token sale distribution rules. [OK]\n', ' */ \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', 'contract ZeroGravityToken {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 6; // Allows JavaScript to handle precise calculations (until totalSupply < 9 milliards)\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n', '    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n', '    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    modifier rescueAccountOnly {require(msg.sender == rescueAccount); _;}\n', '    modifier tokenDistributionPeriodOnly {require(tokenDistributor == msg.sender); _;}\n', '\n', '    enum sigStandard { typed, personal, stringHex }\n', '    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n', '\n', '    bytes constant public ethSignedMessagePrefix = "\\x19Ethereum Signed Message:\\n";\n', '    bytes32 constant public sigDestinationTransfer = keccak256(\n', '        "address Token Contract Address",\n', '        "address Sender&#39;s Address",\n', '        "address Recipient&#39;s Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "address Account which Receives Fee",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n', '    bytes32 constant public sigDestinationTransferFrom = keccak256(\n', '        "address Token Contract Address",\n', '        "address Address Approved for Withdraw",\n', '        "address Account to Withdraw From",\n', '        "address Withdrawal Recipient Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "address Account which Receives Fee",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n', '    bytes32 constant public sigDestinationApprove = keccak256(\n', '        "address Token Contract Address",\n', '        "address Withdrawal Approval Address",\n', '        "address Withdrawal Recipient Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "address Account which Receives Fee",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n', '    bytes32 constant public sigDestinationApproveAndCall = keccak256(\n', '        "address Token Contract Address",\n', '        "address Withdrawal Approval Address",\n', '        "address Withdrawal Recipient Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "bytes Data to Transfer",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "address Account which Receives Fee",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n', '\n', '    /**\n', '     * @param tokenName - full token name\n', '     * @param tokenSymbol - token symbol\n', '     */\n', '    constructor (string tokenName, string tokenSymbol) public {\n', '        name = tokenName;\n', '        symbol = tokenSymbol;\n', '        rescueAccount = tokenDistributor = msg.sender;\n', '    } \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '\n', '    /**\n', '     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n', '     * @param from - account to make the transfer from\n', '     * @param to - account to transfer `value` tokens to\n', '     * @param value - tokens to transfer to account `to`\n', '     */\n', '    function internalTransfer (address from, address to, uint value) internal {\n', '        require(to != 0x0); // Prevent people from accidentally burning their tokens\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n', '     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n', '     * transfers are impossible.\n', '     * @param from - account to make the transfer from\n', '     * @param to1 - account to transfer `value1` tokens to\n', '     * @param value1 - tokens to transfer to account `to1`\n', '     * @param to2 - account to transfer `value2` tokens to\n', '     * @param value2 - tokens to transfer to account `to2`\n', '     */\n', '    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n', '        require(to1 != 0x0 && to2 != 0x0); // Prevent people from accidentally burning their tokens\n', '        balanceOf[from] = balanceOf[from].sub(value1.add(value2));\n', '        balanceOf[to1] = balanceOf[to1].add(value1);\n', '        emit Transfer(from, to1, value1);\n', '        if (value2 > 0) {\n', '            balanceOf[to2] = balanceOf[to2].add(value2);\n', '            emit Transfer(from, to2, value2);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n', '     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n', '     * development there is no single signing standard defined. For example, Metamask and Geth both support\n', '     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support "widely adopted"\n', '     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n', '     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n', '     * third-party wallets must adopt a single standard for signing messages.\n', '     * @param data - original data which had to be signed by `signer`\n', '     * @param signer - account which made a signature\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', '     * @param sig - signature made by `from`, which is the proof of `from`&#39;s agreement with the above parameters\n', '     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n', '     * @param sigDest - for which type of action this signature was made\n', '     */\n', '    function requireSignature (\n', '        bytes32 data,\n', '        address signer,\n', '        uint256 deadline,\n', '        uint256 sigId,\n', '        bytes sig,\n', '        sigStandard sigStd,\n', '        sigDestination sigDest\n', '    ) internal {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '        assembly { // solium-disable-line security/no-inline-assembly\n', '            r := mload(add(sig, 32))\n', '            s := mload(add(sig, 64)) \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '            v := byte(0, mload(add(sig, 96)))\n', '        }\n', '        if (v < 27)\n', '            v += 27;\n', '        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n', '        if (sigStd == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n', '            require(\n', '                signer == ecrecover(\n', '                    keccak256(\n', '                        sigDest == sigDestination.transfer\n', '                            ? sigDestinationTransfer\n', '                            : sigDest == sigDestination.approve\n', '                                ? sigDestinationApprove\n', '                                : sigDest == sigDestination.approveAndCall\n', '                                    ? sigDestinationApproveAndCall\n', '                                    : sigDestinationTransferFrom,\n', '                        data\n', '                    ),\n', '                    v, r, s\n', '                )\n', '            );\n', '        } else if (sigStd == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n', '            require(\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "32", data), v, r, s) // Geth-adopted\n', '                ||\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\\x20", data), v, r, s) // Trezor-adopted\n', '            );\n', '        } else { // == 2; Signed string hash signature (the most expensive but universal)\n', '            require(\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "64", hexToString(data)), v, r, s) // Geth\n', '                ||\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\\x40", hexToString(data)), v, r, s) // Trezor\n', '            );\n', '        }\n', '        usedSigIds[signer][sigId] = true;\n', '    }\n', '\n', '    /**\n', '     * Utility costly function to encode bytes HEX representation as string.\n', '     * @param sig - signature as bytes32 to represent as string\n', '     */\n', '    function hexToString (bytes32 sig) internal pure returns (bytes) {\n', '        bytes memory str = new bytes(64);\n', '        for (uint8 i = 0; i < 32; ++i) {\n', '            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n', '            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n', '        }\n', '        return str;\n', '    }\n', '\n', '    /**\n', '     * Transfer `value` tokens to `to` address from the account of sender.\n', '     * @param to - the address of the recipient\n', '     * @param value - the amount to send\n', '     */\n', '    function transfer (address to, uint256 value) public returns (bool) {\n', '        internalTransfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n', '     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n', '     * owner.\n', '     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there&#39;s\n', '     * a need to make signature once again (because the first one is lost or whatever), user should sign the message\n', '     * with the same sigId, thus ensuring that the previous signature can&#39;t be used if the new one passes.\n', '     * Use case: the user wants to send some tokens to another user or smart contract, but don&#39;t have ether to do so.\n', '     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n', '     * @param to - the account receiving `value` tokens\n', '     * @param value - the value in tokens to transfer\n', '     * @param fee - a fee to pay to `feeRecipient`\n', '     * @param feeRecipient - account which will receive fee\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', '     * @param sig - signature made by `from`, which is the proof of `from`&#39;s agreement with the above parameters\n', '     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n', '     */\n', '    function transferViaSignature ( \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '        address     from,\n', '        address     to,\n', '        uint256     value,\n', '        uint256     fee,\n', '        address     feeRecipient,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), from, to, value, fee, feeRecipient, deadline, sigId),\n', '            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n', '        );\n', '        internalDoubleTransfer(from, to, value, feeRecipient, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Allow `spender` to take `value` tokens from the transaction sender&#39;s account.\n', '     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '     * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender - the address authorized to spend\n', '     * @param value - the maximum amount they can spend\n', '     */\n', '    function approve (address spender, uint256 value) public returns (bool) {\n', '        allowance[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Same as `transferViaSignature`, but for `approve`.\n', '     * Use case: the user wants to set an allowance for the smart contract or another user without having Ether on\n', '     * their balance.\n', '     * @param from - the account to approve withdrawal from, which signed all below parameters\n', '     * @param spender - the account allowed to withdraw tokens from `from` address\n', '     * @param value - the value in tokens to approve to withdraw\n', '     * @param fee - a fee to pay to `feeRecipient`\n', '     * @param feeRecipient - account which will receive fee\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', '     * @param sig - signature made by `from`, which is the proof of `from`&#39;s agreement with the above parameters\n', '     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n', '     */\n', '    function approveViaSignature (\n', '        address     from,\n', '        address     spender,\n', '        uint256     value,\n', '        uint256     fee,\n', '        address     feeRecipient,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), from, spender, value, fee, feeRecipient, deadline, sigId),\n', '            from, deadline, sigId, sig, sigStd, sigDestination.approve\n', '        );\n', '        allowance[from][spender] = value;\n', '        emit Approval(from, spender, value);\n', '        internalTransfer(from, feeRecipient, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n', '     * @param from - the address to transfer tokens from\n', '     * @param to - the address of the recipient\n', '     * @param value - the amount to send\n', '     */\n', '    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n', '        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n', '        internalTransfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Same as `transferViaSignature`, but for `transferFrom`.\n', '     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to\n', '     * do so. Important note: the fee is subtracted from the `value`, and `to` address receives `value - fee`.\n', '     * @param signer - the address allowed to call transferFrom, which signed all below parameters\n', '     * @param from - the account to make withdrawal from\n', '     * @param to - the address of the recipient\n', '     * @param value - the value in tokens to withdraw\n', '     * @param fee - a fee to pay to `feeRecipient`\n', '     * @param feeRecipient - account which will receive fee\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', '     * @param sig - signature made by `from`, which is the proof of `from`&#39;s agreement with the above parameters\n', '     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n', '     */\n', '    function transferFromViaSignature (\n', '        address     signer,\n', '        address     from,\n', '        address     to,\n', '        uint256     value,\n', '        uint256     fee,\n', '        address     feeRecipient,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) { \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '        requireSignature(\n', '            keccak256(address(this), from, to, value, fee, feeRecipient, deadline, sigId),\n', '            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n', '        );\n', '        allowance[from][signer] = allowance[from][signer].sub(value);\n', '        internalDoubleTransfer(from, to, value.sub(fee), feeRecipient, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Utility function, which acts the same as approve(...), but also calls `receiveApproval` function on a\n', '     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n', '     * withdraw tokens from the sender&#39;s account and receive additional `extraData` for processing.\n', '     * @param spender - the address to be authorized to spend tokens\n', '     * @param value - the max amount the `spender` can withdraw\n', '     * @param extraData - some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n', '        approve(spender, value);\n', '        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Same as `approveViaSignature`, but for `approveAndCall`.\n', '     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n', '     * @param from - the account to approve withdrawal from, which signed all below parameters\n', '     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n', '     * @param value - the value in tokens to approve to withdraw\n', '     * @param extraData - additional data to pass to the `spender` smart contract\n', '     * @param fee - a fee to pay to `feeRecipient`\n', '     * @param feeRecipient - account which will receive fee\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', '     * @param sig - signature made by `from`, which is the proof of `from`&#39;s agreement with the above parameters\n', '     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n', '     */\n', '    function approveAndCallViaSignature (\n', '        address     from,\n', '        address     spender,\n', '        uint256     value,\n', '        bytes       extraData,\n', '        uint256     fee,\n', '        address     feeRecipient,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), from, spender, value, extraData, fee, feeRecipient, deadline, sigId),\n', '            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n', '        );\n', '        allowance[from][spender] = value;\n', '        emit Approval(from, spender, value);\n', '        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n', '        internalTransfer(from, feeRecipient, fee);\n', '        return true;\n', '    } \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '\n', '    /**\n', '     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n', '     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n', '     * Once the token distribution event ends (lastMint is triggered), tokenDistributor will become 0x0 and multiMint\n', '     * function will never work again.\n', '     * @param recipients - addresses of token recipients\n', '     * @param amounts - corresponding amount of each token recipient in `recipients`\n', '     */\n', '    function multiMint (address[] recipients, uint256[] amounts) external tokenDistributionPeriodOnly {\n', '        \n', '        require(recipients.length == amounts.length);\n', '\n', '        uint total = 0;\n', '\n', '        for (uint i = 0; i < recipients.length; ++i) {\n', '            balanceOf[recipients[i]] = balanceOf[recipients[i]].add(amounts[i]);\n', '            total = total.add(amounts[i]);\n', '            emit Transfer(0x0, recipients[i], amounts[i]);\n', '        }\n', '\n', '        totalSupply = totalSupply.add(total);\n', '        \n', '    }\n', ' \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '    /**\n', '     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n', '     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n', '     */\n', '    function lastMint () external tokenDistributionPeriodOnly {\n', '\n', '        require(totalSupply > 0);\n', '\n', '        uint256 remaining = totalSupply.mul(40).div(60); // Portion of tokens for DreamTeam (40%)\n', '\n', '        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam&#39;s balance\n', '        uint256 fractionalPart = remaining.add(totalSupply) % (uint256(10) ** decimals);\n', '        remaining = remaining.sub(fractionalPart); // Remove the fractional part to round the totalSupply\n', '\n', '        balanceOf[tokenDistributor] = balanceOf[tokenDistributor].add(remaining);\n', '        emit Transfer(0x0, tokenDistributor, remaining);\n', '\n', '        totalSupply = totalSupply.add(remaining);\n', '        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n', '\n', '    }\n', '\n', '    /**\n', '     * ERC20 tokens are not designed to hold any other tokens (or Ether) on their balances. There were thousands\n', '     * of cases when people accidentally transfer tokens to a contract address while there is no way to get them\n', '     * back. This function adds a possibility to "rescue" tokens that were accidentally sent to this smart contract.\n', '     * @param tokenContract - ERC20-compatible token\n', '     * @param value - amount to rescue\n', '     */\n', '    function rescueLostTokens (ERC20CompatibleToken tokenContract, uint256 value) external rescueAccountOnly {\n', '        tokenContract.transfer(rescueAccount, value);\n', '    }\n', '\n', '    /**\n', '     * Utility function that allows to change the rescueAccount address, which can "rescue" tokens accidentally sent to\n', '     * this smart contract address.\n', '     * @param newRescueAccount - account which will become authorized to rescue tokens\n', '     */ \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '    function changeRescueAccount (address newRescueAccount) external rescueAccountOnly {\n', '        rescueAccount = newRescueAccount;\n', '    }\n', ' \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'interface tokenRecipient {\n', '    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n', '}\n', '\n', 'interface ERC20CompatibleToken {\n', '    function transfer (address to, uint256 value) external returns (bool);\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks that throw on overflows.\n', ' */\n', 'library SafeMath {\n', '    \n', '    function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function div (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '    \n', '    function sub (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * DreamTeam test token contract. It implements the next capabilities:\n', ' * 1. Standard ERC20 functionality. [OK]\n', ' * 2. Additional utility function approveAndCall. [OK]\n', ' * 3. Function to rescue "lost forever" tokens, which were accidentally sent to this smart contract. [OK]\n', ' * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n', ' *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [OK]\n', ' * 5. Token sale distribution rules. [OK]\n', ' */ \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', 'contract ZeroGravityToken {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 6; // Allows JavaScript to handle precise calculations (until totalSupply < 9 milliards)\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n', '    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n', '    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    modifier rescueAccountOnly {require(msg.sender == rescueAccount); _;}\n', '    modifier tokenDistributionPeriodOnly {require(tokenDistributor == msg.sender); _;}\n', '\n', '    enum sigStandard { typed, personal, stringHex }\n', '    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n', '\n', '    bytes constant public ethSignedMessagePrefix = "\\x19Ethereum Signed Message:\\n";\n', '    bytes32 constant public sigDestinationTransfer = keccak256(\n', '        "address Token Contract Address",\n', '        "address Sender\'s Address",\n', '        "address Recipient\'s Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "address Account which Receives Fee",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n', '    bytes32 constant public sigDestinationTransferFrom = keccak256(\n', '        "address Token Contract Address",\n', '        "address Address Approved for Withdraw",\n', '        "address Account to Withdraw From",\n', '        "address Withdrawal Recipient Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "address Account which Receives Fee",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n', '    bytes32 constant public sigDestinationApprove = keccak256(\n', '        "address Token Contract Address",\n', '        "address Withdrawal Approval Address",\n', '        "address Withdrawal Recipient Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "address Account which Receives Fee",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n', '    bytes32 constant public sigDestinationApproveAndCall = keccak256(\n', '        "address Token Contract Address",\n', '        "address Withdrawal Approval Address",\n', '        "address Withdrawal Recipient Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "bytes Data to Transfer",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "address Account which Receives Fee",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n', '\n', '    /**\n', '     * @param tokenName - full token name\n', '     * @param tokenSymbol - token symbol\n', '     */\n', '    constructor (string tokenName, string tokenSymbol) public {\n', '        name = tokenName;\n', '        symbol = tokenSymbol;\n', '        rescueAccount = tokenDistributor = msg.sender;\n', '    } \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '\n', '    /**\n', '     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n', '     * @param from - account to make the transfer from\n', '     * @param to - account to transfer `value` tokens to\n', '     * @param value - tokens to transfer to account `to`\n', '     */\n', '    function internalTransfer (address from, address to, uint value) internal {\n', '        require(to != 0x0); // Prevent people from accidentally burning their tokens\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n', '     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n', '     * transfers are impossible.\n', '     * @param from - account to make the transfer from\n', '     * @param to1 - account to transfer `value1` tokens to\n', '     * @param value1 - tokens to transfer to account `to1`\n', '     * @param to2 - account to transfer `value2` tokens to\n', '     * @param value2 - tokens to transfer to account `to2`\n', '     */\n', '    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n', '        require(to1 != 0x0 && to2 != 0x0); // Prevent people from accidentally burning their tokens\n', '        balanceOf[from] = balanceOf[from].sub(value1.add(value2));\n', '        balanceOf[to1] = balanceOf[to1].add(value1);\n', '        emit Transfer(from, to1, value1);\n', '        if (value2 > 0) {\n', '            balanceOf[to2] = balanceOf[to2].add(value2);\n', '            emit Transfer(from, to2, value2);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n', '     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n', '     * development there is no single signing standard defined. For example, Metamask and Geth both support\n', '     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support "widely adopted"\n', '     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n', '     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n', '     * third-party wallets must adopt a single standard for signing messages.\n', '     * @param data - original data which had to be signed by `signer`\n', '     * @param signer - account which made a signature\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', "     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n", '     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n', '     * @param sigDest - for which type of action this signature was made\n', '     */\n', '    function requireSignature (\n', '        bytes32 data,\n', '        address signer,\n', '        uint256 deadline,\n', '        uint256 sigId,\n', '        bytes sig,\n', '        sigStandard sigStd,\n', '        sigDestination sigDest\n', '    ) internal {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '        assembly { // solium-disable-line security/no-inline-assembly\n', '            r := mload(add(sig, 32))\n', '            s := mload(add(sig, 64)) \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '            v := byte(0, mload(add(sig, 96)))\n', '        }\n', '        if (v < 27)\n', '            v += 27;\n', '        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n', '        if (sigStd == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n', '            require(\n', '                signer == ecrecover(\n', '                    keccak256(\n', '                        sigDest == sigDestination.transfer\n', '                            ? sigDestinationTransfer\n', '                            : sigDest == sigDestination.approve\n', '                                ? sigDestinationApprove\n', '                                : sigDest == sigDestination.approveAndCall\n', '                                    ? sigDestinationApproveAndCall\n', '                                    : sigDestinationTransferFrom,\n', '                        data\n', '                    ),\n', '                    v, r, s\n', '                )\n', '            );\n', '        } else if (sigStd == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n', '            require(\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "32", data), v, r, s) // Geth-adopted\n', '                ||\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\\x20", data), v, r, s) // Trezor-adopted\n', '            );\n', '        } else { // == 2; Signed string hash signature (the most expensive but universal)\n', '            require(\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "64", hexToString(data)), v, r, s) // Geth\n', '                ||\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\\x40", hexToString(data)), v, r, s) // Trezor\n', '            );\n', '        }\n', '        usedSigIds[signer][sigId] = true;\n', '    }\n', '\n', '    /**\n', '     * Utility costly function to encode bytes HEX representation as string.\n', '     * @param sig - signature as bytes32 to represent as string\n', '     */\n', '    function hexToString (bytes32 sig) internal pure returns (bytes) {\n', '        bytes memory str = new bytes(64);\n', '        for (uint8 i = 0; i < 32; ++i) {\n', '            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n', '            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n', '        }\n', '        return str;\n', '    }\n', '\n', '    /**\n', '     * Transfer `value` tokens to `to` address from the account of sender.\n', '     * @param to - the address of the recipient\n', '     * @param value - the amount to send\n', '     */\n', '    function transfer (address to, uint256 value) public returns (bool) {\n', '        internalTransfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n', '     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n', '     * owner.\n', "     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n", '     * a need to make signature once again (because the first one is lost or whatever), user should sign the message\n', "     * with the same sigId, thus ensuring that the previous signature can't be used if the new one passes.\n", "     * Use case: the user wants to send some tokens to another user or smart contract, but don't have ether to do so.\n", '     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n', '     * @param to - the account receiving `value` tokens\n', '     * @param value - the value in tokens to transfer\n', '     * @param fee - a fee to pay to `feeRecipient`\n', '     * @param feeRecipient - account which will receive fee\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', "     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n", '     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n', '     */\n', '    function transferViaSignature ( \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '        address     from,\n', '        address     to,\n', '        uint256     value,\n', '        uint256     fee,\n', '        address     feeRecipient,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), from, to, value, fee, feeRecipient, deadline, sigId),\n', '            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n', '        );\n', '        internalDoubleTransfer(from, to, value, feeRecipient, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * Allow `spender` to take `value` tokens from the transaction sender's account.\n", '     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender - the address authorized to spend\n', '     * @param value - the maximum amount they can spend\n', '     */\n', '    function approve (address spender, uint256 value) public returns (bool) {\n', '        allowance[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Same as `transferViaSignature`, but for `approve`.\n', '     * Use case: the user wants to set an allowance for the smart contract or another user without having Ether on\n', '     * their balance.\n', '     * @param from - the account to approve withdrawal from, which signed all below parameters\n', '     * @param spender - the account allowed to withdraw tokens from `from` address\n', '     * @param value - the value in tokens to approve to withdraw\n', '     * @param fee - a fee to pay to `feeRecipient`\n', '     * @param feeRecipient - account which will receive fee\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', "     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n", '     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n', '     */\n', '    function approveViaSignature (\n', '        address     from,\n', '        address     spender,\n', '        uint256     value,\n', '        uint256     fee,\n', '        address     feeRecipient,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), from, spender, value, fee, feeRecipient, deadline, sigId),\n', '            from, deadline, sigId, sig, sigStd, sigDestination.approve\n', '        );\n', '        allowance[from][spender] = value;\n', '        emit Approval(from, spender, value);\n', '        internalTransfer(from, feeRecipient, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n', '     * @param from - the address to transfer tokens from\n', '     * @param to - the address of the recipient\n', '     * @param value - the amount to send\n', '     */\n', '    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n', '        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n', '        internalTransfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Same as `transferViaSignature`, but for `transferFrom`.\n', '     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to\n', '     * do so. Important note: the fee is subtracted from the `value`, and `to` address receives `value - fee`.\n', '     * @param signer - the address allowed to call transferFrom, which signed all below parameters\n', '     * @param from - the account to make withdrawal from\n', '     * @param to - the address of the recipient\n', '     * @param value - the value in tokens to withdraw\n', '     * @param fee - a fee to pay to `feeRecipient`\n', '     * @param feeRecipient - account which will receive fee\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', "     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n", '     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n', '     */\n', '    function transferFromViaSignature (\n', '        address     signer,\n', '        address     from,\n', '        address     to,\n', '        uint256     value,\n', '        uint256     fee,\n', '        address     feeRecipient,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) { \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '        requireSignature(\n', '            keccak256(address(this), from, to, value, fee, feeRecipient, deadline, sigId),\n', '            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n', '        );\n', '        allowance[from][signer] = allowance[from][signer].sub(value);\n', '        internalDoubleTransfer(from, to, value.sub(fee), feeRecipient, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Utility function, which acts the same as approve(...), but also calls `receiveApproval` function on a\n', '     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n', "     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n", '     * @param spender - the address to be authorized to spend tokens\n', '     * @param value - the max amount the `spender` can withdraw\n', '     * @param extraData - some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n', '        approve(spender, value);\n', '        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Same as `approveViaSignature`, but for `approveAndCall`.\n', '     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n', '     * @param from - the account to approve withdrawal from, which signed all below parameters\n', '     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n', '     * @param value - the value in tokens to approve to withdraw\n', '     * @param extraData - additional data to pass to the `spender` smart contract\n', '     * @param fee - a fee to pay to `feeRecipient`\n', '     * @param feeRecipient - account which will receive fee\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', "     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n", '     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n', '     */\n', '    function approveAndCallViaSignature (\n', '        address     from,\n', '        address     spender,\n', '        uint256     value,\n', '        bytes       extraData,\n', '        uint256     fee,\n', '        address     feeRecipient,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), from, spender, value, extraData, fee, feeRecipient, deadline, sigId),\n', '            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n', '        );\n', '        allowance[from][spender] = value;\n', '        emit Approval(from, spender, value);\n', '        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n', '        internalTransfer(from, feeRecipient, fee);\n', '        return true;\n', '    } \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '\n', '    /**\n', '     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n', '     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n', '     * Once the token distribution event ends (lastMint is triggered), tokenDistributor will become 0x0 and multiMint\n', '     * function will never work again.\n', '     * @param recipients - addresses of token recipients\n', '     * @param amounts - corresponding amount of each token recipient in `recipients`\n', '     */\n', '    function multiMint (address[] recipients, uint256[] amounts) external tokenDistributionPeriodOnly {\n', '        \n', '        require(recipients.length == amounts.length);\n', '\n', '        uint total = 0;\n', '\n', '        for (uint i = 0; i < recipients.length; ++i) {\n', '            balanceOf[recipients[i]] = balanceOf[recipients[i]].add(amounts[i]);\n', '            total = total.add(amounts[i]);\n', '            emit Transfer(0x0, recipients[i], amounts[i]);\n', '        }\n', '\n', '        totalSupply = totalSupply.add(total);\n', '        \n', '    }\n', ' \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '    /**\n', '     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n', '     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n', '     */\n', '    function lastMint () external tokenDistributionPeriodOnly {\n', '\n', '        require(totalSupply > 0);\n', '\n', '        uint256 remaining = totalSupply.mul(40).div(60); // Portion of tokens for DreamTeam (40%)\n', '\n', "        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n", '        uint256 fractionalPart = remaining.add(totalSupply) % (uint256(10) ** decimals);\n', '        remaining = remaining.sub(fractionalPart); // Remove the fractional part to round the totalSupply\n', '\n', '        balanceOf[tokenDistributor] = balanceOf[tokenDistributor].add(remaining);\n', '        emit Transfer(0x0, tokenDistributor, remaining);\n', '\n', '        totalSupply = totalSupply.add(remaining);\n', '        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n', '\n', '    }\n', '\n', '    /**\n', '     * ERC20 tokens are not designed to hold any other tokens (or Ether) on their balances. There were thousands\n', '     * of cases when people accidentally transfer tokens to a contract address while there is no way to get them\n', '     * back. This function adds a possibility to "rescue" tokens that were accidentally sent to this smart contract.\n', '     * @param tokenContract - ERC20-compatible token\n', '     * @param value - amount to rescue\n', '     */\n', '    function rescueLostTokens (ERC20CompatibleToken tokenContract, uint256 value) external rescueAccountOnly {\n', '        tokenContract.transfer(rescueAccount, value);\n', '    }\n', '\n', '    /**\n', '     * Utility function that allows to change the rescueAccount address, which can "rescue" tokens accidentally sent to\n', '     * this smart contract address.\n', '     * @param newRescueAccount - account which will become authorized to rescue tokens\n', '     */ \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '    function changeRescueAccount (address newRescueAccount) external rescueAccountOnly {\n', '        rescueAccount = newRescueAccount;\n', '    }\n', ' \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '}']
