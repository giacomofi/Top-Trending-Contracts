['pragma solidity 0.4.20;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public pendingOwner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Owned() internal {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == pendingOwner);\n', '        OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '// Support accounts using for change Ether price, manual migration and sending tokens during ICO, see endOfFreeze field\n', 'contract Support is Owned {\n', '    mapping (address => bool) public supportAccounts;\n', '\n', '    event SupportAdded(address indexed _who);\n', '    event SupportRemoved(address indexed _who);\n', '\n', '    modifier supportOrOwner {\n', '        require(msg.sender == owner || supportAccounts[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function addSupport(address _who) public onlyOwner {\n', '        require(_who != address(0));\n', '        require(_who != owner);\n', '        require(!supportAccounts[_who]);\n', '        supportAccounts[_who] = true;\n', '        SupportAdded(_who);\n', '    }\n', '\n', '    function removeSupport(address _who) public onlyOwner {\n', '        require(supportAccounts[_who]);\n', '        supportAccounts[_who] = false;\n', '        SupportRemoved(_who);\n', '    }\n', '}\n', '\n', '// Math operations with safety checks that throw on error\n', 'library SafeMath {\n', '    // Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    // Adds two numbers, throws on overflow.\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// ERC20 interface https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint balance);\n', '    function allowance(address owner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint value) public returns (bool success);\n', '    function transferFrom(address from, address to, uint value) public returns (bool success);\n', '    function approve(address spender, uint value) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '// Interface for migration to a new contract address\n', 'contract MigrationAgent {\n', '    function migrateFrom(address _from, uint256 _value) public;\n', '}\n', '\n', 'contract AdvancedToken is ERC20, Support {\n', '    using SafeMath for uint;\n', '\n', '    uint internal MAX_SUPPLY = 110000000 * 1 ether;\n', '    address public migrationAgent;\n', '\n', '    mapping (address => uint) internal balances;\n', '\n', '    enum State { Waiting, ICO, Running, Migration }\n', '    State public state = State.Waiting;\n', '\n', '    event NewState(State state);\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    /**\n', '     * The migration process to transfer tokens to the new token contract, when in the contract, a sufficiently large\n', "     * number of investors that the company can't cover a miner fees to transfer all tokens, this will\n", '     * be used in the following cases:\n', '     * 1. If a critical error is found in the contract\n', '     * 2. When will be released and approved a new standard for digital identification ERC-725 or similar\n', '     * @param _agent The new token contract\n', '     */\n', '    function setMigrationAgent(address _agent) public onlyOwner {\n', '        require(state == State.Running);\n', '        migrationAgent = _agent;\n', '    }\n', '\n', '    // Called after setMigrationAgent function to make sure that a new contract address is valid\n', '    function startMigration() public onlyOwner {\n', '        require(migrationAgent != address(0));\n', '        require(state == State.Running);\n', '        state = State.Migration;\n', '        NewState(state);\n', '    }\n', '\n', '    // Migration can be canceled if tokens have not yet been sent to the new contract\n', '    function cancelMigration() public onlyOwner {\n', '        require(state == State.Migration);\n', '        require(totalSupply == MAX_SUPPLY);\n', '        migrationAgent = address(0);\n', '        state = State.Running;\n', '        NewState(state);\n', '    }\n', '\n', '    // Manual migration if someone has problems moving\n', '    function manualMigrate(address _who) public supportOrOwner {\n', '        require(state == State.Migration);\n', '        require(_who != address(this));\n', '        require(balances[_who] > 0);\n', '        uint value = balances[_who];\n', '        balances[_who] = balances[_who].sub(value);\n', '        totalSupply = totalSupply.sub(value);\n', '        Burn(_who, value);\n', '        MigrationAgent(migrationAgent).migrateFrom(_who, value);\n', '    }\n', '\n', "    // Migrate the holder's tokens to a new contract and burn the holder's tokens on the current contract\n", '    function migrate() public {\n', '        require(state == State.Migration);\n', '        require(balances[msg.sender] > 0);\n', '        uint value = balances[msg.sender];\n', '        balances[msg.sender] = balances[msg.sender].sub(value);\n', '        totalSupply = totalSupply.sub(value);\n', '        Burn(msg.sender, value);\n', '        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\n', '    }\n', '\n', '    // The withdraw of Tokens from the contract after the end of ICO\n', '    function withdrawTokens(uint _value) public onlyOwner {\n', '        require(state == State.Running || state == State.Migration);\n', '        require(balances[address(this)] > 0 && balances[address(this)] >= _value);\n', '        balances[address(this)] = balances[address(this)].sub(_value);\n', '        balances[msg.sender] = balances[msg.sender].add(_value);\n', '        Transfer(address(this), msg.sender, _value);\n', '    }\n', '\n', '    // The withdraw of Ether from the contract\n', '    function withdrawEther(uint256 _value) public onlyOwner {\n', '        require(this.balance >= _value);\n', '        owner.transfer(_value);\n', '    }\n', '}\n', '\n', 'contract Crowdsale is AdvancedToken {\n', '    uint internal endOfFreeze = 1522569600; // Sun, 01 Apr 2018 00:00:00 PST\n', '    uint private tokensForSalePhase2;\n', '    uint public tokensPerEther;\n', '\n', '    address internal reserve = 0x4B046B05C29E535E152A3D9c8FB7540a8e15c7A6;\n', '\n', '    function Crowdsale() internal {\n', '        assert(reserve != address(0));\n', '        tokensPerEther = 2000 * 1 ether; // Tokens ^ 18\n', '        totalSupply = MAX_SUPPLY;\n', '        uint MARKET_SHARE = 66000000 * 1 ether;\n', '        uint tokensSoldPhase1 = 11110257 * 1 ether;\n', '        tokensForSalePhase2 = MARKET_SHARE - tokensSoldPhase1;\n', '\n', '        // Tokens for the Phase 2 are on the contract and not available to withdraw by owner during the ICO\n', '        balances[address(this)] = tokensForSalePhase2;\n', '        // Tokens for the Phase 1 are on the owner to distribution by manually processes\n', '        balances[owner] = totalSupply - tokensForSalePhase2;\n', '\n', '        assert(balances[address(this)] + balances[owner] == MAX_SUPPLY);\n', '        Transfer(0, address(this), balances[address(this)]);\n', '        Transfer(0, owner, balances[owner]);\n', '    }\n', '\n', '    // Setting the number of tokens to buy for 1 Ether, changes automatically by owner or support account\n', '    function setTokensPerEther(uint _tokens) public supportOrOwner {\n', '        require(state == State.ICO || state == State.Waiting);\n', '        require(_tokens > 100 ether); // Min 100 tokens ^ 18\n', '        tokensPerEther = _tokens;\n', '    }\n', '\n', '    // The payable function to buy Skraps tokens\n', '    function () internal payable {\n', '        require(msg.sender != address(0));\n', '        require(state == State.ICO || state == State.Migration);\n', '        if (state == State.ICO) {\n', '            // The minimum ether to participate\n', '            require(msg.value >= 0.01 ether);\n', '            // Counting and sending tokens to the investor\n', '            uint _tokens = msg.value * tokensPerEther / 1 ether;\n', '            require(balances[address(this)] >= _tokens);\n', '            balances[address(this)] = balances[address(this)].sub(_tokens);\n', '            balances[msg.sender] = balances[msg.sender].add(_tokens);\n', '            Transfer(address(this), msg.sender, _tokens);\n', '\n', '            // send 25% of ether received to reserve address\n', '            uint to_reserve = msg.value * 25 / 100;\n', '            reserve.transfer(to_reserve);\n', '        } else {\n', '            require(msg.value == 0);\n', '            migrate();\n', '        }\n', '    }\n', '\n', '    // Start ISO manually because the block timestamp is not mean the current time\n', '    function startICO() public supportOrOwner {\n', '        require(state == State.Waiting);\n', '        state = State.ICO;\n', '        NewState(state);\n', '    }\n', '\n', '    // Since a contracts can not call itself, we must manually close the ICO\n', '    function closeICO() public onlyOwner {\n', '        require(state == State.ICO);\n', '        state = State.Running;\n', '        NewState(state);\n', '    }\n', '\n', '    // Anti-scam function, if the tokens are obtained by dishonest means, can be used only during ICO\n', '    function refundTokens(address _from, uint _value) public onlyOwner {\n', '        require(state == State.ICO);\n', '        require(balances[_from] >= _value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[address(this)] = balances[address(this)].add(_value);\n', '        Transfer(_from, address(this), _value);\n', '    }\n', '}\n', '\n', '/**\n', ' * Standard ERC20 implementation, see the interface above,\n', ' * with a small modification to block the transfer of tokens until a specific date, see endOfFreeze field\n', ' */\n', 'contract Skraps is Crowdsale {\n', '    using SafeMath for uint;\n', '\n', '    string public name = "Skraps";\n', '    string public symbol = "SKRP";\n', '    uint8 public decimals = 18;\n', '\n', '    mapping (address => mapping (address => uint)) private allowed;\n', '\n', '    function balanceOf(address _who) public constant returns (uint) {\n', '        return balances[_who];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[msg.sender] >= _value);\n', '        require(now > endOfFreeze || msg.sender == owner || supportAccounts[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[_from] >= _value);\n', '        require(allowed[_from][msg.sender] >= _value);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        require(_spender != address(0));\n', '        require(now > endOfFreeze || msg.sender == owner || supportAccounts[msg.sender]);\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '}']