['pragma solidity ^0.4.13;\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', "    // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract WETH9_ {\n', '    string public name     = "Wrapped Ether";\n', '    string public symbol   = "WETH";\n', '    uint8  public decimals = 18;\n', '\n', '    event  Approval(address indexed src, address indexed guy, uint wad);\n', '    event  Transfer(address indexed src, address indexed dst, uint wad);\n', '    event  Deposit(address indexed dst, uint wad);\n', '    event  Withdrawal(address indexed src, uint wad);\n', '\n', '    mapping (address => uint)                       public  balanceOf;\n', '    mapping (address => mapping (address => uint))  public  allowance;\n', '\n', '    function() public payable {\n', '        deposit();\n', '    }\n', '    function deposit() public payable {\n', '        balanceOf[msg.sender] += msg.value;\n', '        Deposit(msg.sender, msg.value);\n', '    }\n', '    function withdraw(uint wad) public {\n', '        require(balanceOf[msg.sender] >= wad);\n', '        balanceOf[msg.sender] -= wad;\n', '        msg.sender.transfer(wad);\n', '        Withdrawal(msg.sender, wad);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return this.balance;\n', '    }\n', '\n', '    function approve(address guy, uint wad) public returns (bool) {\n', '        allowance[msg.sender][guy] = wad;\n', '        Approval(msg.sender, guy, wad);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(balanceOf[src] >= wad);\n', '\n', '        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n', '            require(allowance[src][msg.sender] >= wad);\n', '            allowance[src][msg.sender] -= wad;\n', '        }\n', '\n', '        balanceOf[src] -= wad;\n', '        balanceOf[dst] += wad;\n', '\n', '        Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'interface FundInterface {\n', '\n', '    // EVENTS\n', '\n', '    event PortfolioContent(uint holdings, uint price, uint decimals);\n', '    event RequestUpdated(uint id);\n', '    event Invested(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\n', '    event Redeemed(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\n', '    event SpendingApproved(address onConsigned, address ofAsset, uint amount);\n', '    event FeesConverted(uint atTimestamp, uint shareQuantityConverted, uint unclaimed);\n', '    event CalculationUpdate(uint atTimestamp, uint managementFee, uint performanceFee, uint nav, uint sharePrice, uint totalSupply);\n', '    event OrderUpdated(uint id);\n', '    event LogError(uint ERROR_CODE);\n', '    event ErrorMessage(string errorMessage);\n', '\n', '    // EXTERNAL METHODS\n', '    // Compliance by Investor\n', '    function requestInvestment(uint giveQuantity, uint shareQuantity, bool isNativeAsset) external;\n', '    function requestRedemption(uint shareQuantity, uint receiveQuantity, bool isNativeAsset) external;\n', '    function executeRequest(uint requestId) external;\n', '    function cancelRequest(uint requestId) external;\n', '    function redeemAllOwnedAssets(uint shareQuantity) external returns (bool);\n', '    // Administration by Manager\n', '    function enableInvestment() external;\n', '    function disableInvestment() external;\n', '    function enableRedemption() external;\n', '    function disableRedemption() external;\n', '    function shutDown() external;\n', '    // Managing by Manager\n', '    function makeOrder(uint exchangeId, address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) external;\n', '    function takeOrder(uint exchangeId, uint id, uint quantity) external;\n', '    function cancelOrder(uint exchangeId, uint id) external;\n', '\n', '    // PUBLIC METHODS\n', '    function emergencyRedeem(uint shareQuantity, address[] requestedAssets) public returns (bool success);\n', '    // Fees by Manager\n', '    function allocateUnclaimedFees();\n', '\n', '    // PUBLIC VIEW METHODS\n', '    // Get general information\n', '    function getModules() view returns (address, address, address);\n', '    function getLastOrderId() view returns (uint);\n', '    function getLastRequestId() view returns (uint);\n', '    function getNameHash() view returns (bytes32);\n', '    function getManager() view returns (address);\n', '\n', '    // Get accounting information\n', '    function performCalculations() view returns (uint, uint, uint, uint, uint, uint, uint);\n', '    function calcSharePrice() view returns (uint);\n', '}\n', '\n', 'interface AssetInterface {\n', '    /*\n', '     * Implements ERC 20 standard.\n', '     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\n', '     * https://github.com/ethereum/EIPs/issues/20\n', '     *\n', '     *  Added support for the ERC 223 "tokenFallback" method in a "transfer" function with a payload.\n', '     *  https://github.com/ethereum/EIPs/issues/223\n', '     */\n', '\n', '    // Events\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    // There is no ERC223 compatible Transfer event, with `_data` included.\n', '\n', '    //ERC 223\n', '    // PUBLIC METHODS\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool success);\n', '\n', '    // ERC 20\n', '    // PUBLIC METHODS\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    // PUBLIC VIEW METHODS\n', '    function balanceOf(address _owner) view public returns (uint balance);\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '}\n', '\n', 'interface ERC223Interface {\n', '    function balanceOf(address who) constant returns (uint);\n', '    function transfer(address to, uint value) returns (bool);\n', '    function transfer(address to, uint value, bytes data) returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '}\n', '\n', 'contract Asset is DSMath, AssetInterface, ERC223Interface {\n', '\n', '    // DATA STRUCTURES\n', '\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '    uint public totalSupply;\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /**\n', '     * @notice Send `_value` tokens to `_to` from `msg.sender`\n', "     * @dev Transfers sender's tokens to a given address\n", '     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\n', '     * @param _to Address of token receiver\n', '     * @param _value Number of tokens to transfer\n', '     * @return Returns success of function call\n', '     */\n', '    function transfer(address _to, uint _value)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        uint codeLength;\n', '        bytes memory empty;\n', '\n', '        assembly {\n', '            // Retrieve the size of the code on target address, this needs assembly.\n', '            codeLength := extcodesize(_to)\n', '        }\n', ' \n', '        require(balances[msg.sender] >= _value); // sanity checks\n', '        require(balances[_to] + _value >= balances[_to]);\n', '\n', '        balances[msg.sender] = sub(balances[msg.sender], _value);\n', '        balances[_to] = add(balances[_to], _value);\n', '        // if (codeLength > 0) {\n', '        //     ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '        //     receiver.tokenFallback(msg.sender, _value, empty);\n', '        // }\n', '        Transfer(msg.sender, _to, _value, empty);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Send `_value` tokens to `_to` from `msg.sender` and trigger tokenFallback if sender is a contract\n', '     * @dev Function that is called when a user or contract wants to transfer funds\n', '     * @param _to Address of token receiver\n', '     * @param _value Number of tokens to transfer\n', '     * @param _data Data to be sent to tokenFallback\n', '     * @return Returns success of function call\n', '     */\n', '    function transfer(address _to, uint _value, bytes _data)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        uint codeLength;\n', '\n', '        assembly {\n', '            // Retrieve the size of the code on target address, this needs assembly.\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        require(balances[msg.sender] >= _value); // sanity checks\n', '        require(balances[_to] + _value >= balances[_to]);\n', '\n', '        balances[msg.sender] = sub(balances[msg.sender], _value);\n', '        balances[_to] = add(balances[_to], _value);\n', '        // if (codeLength > 0) {\n', '        //     ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '        //     receiver.tokenFallback(msg.sender, _value, _data);\n', '        // }\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Transfer `_value` tokens from `_from` to `_to` if `msg.sender` is allowed.\n', '    /// @notice Restriction: An account can only use this function to send to itself\n', '    /// @dev Allows for an approved third party to transfer tokens from one\n', '    /// address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @return Returns success of function call.\n', '    function transferFrom(address _from, address _to, uint _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(_from != 0x0);\n', '        require(_to != 0x0);\n', '        require(_to != address(this));\n', '        require(balances[_from] >= _value);\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]);\n', '        // require(_to == msg.sender); // can only use transferFrom to send to self\n', '\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    /// @return Returns success of function call.\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        require(_spender != 0x0);\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        // allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        // already 0 to mitigate the race condition described here:\n', '        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        // require(_value == 0 || allowed[msg.sender][_spender] == 0);\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @dev Returns number of allowed tokens that a spender can transfer on\n', '    /// behalf of a token owner.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    /// @return Returns remaining allowance for spender.\n', '    function allowance(address _owner, address _spender)\n', '        constant\n', '        public\n', '        returns (uint)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by the given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @return Returns balance of owner.\n', '    function balanceOf(address _owner) constant public returns (uint) {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', 'interface ERC223ReceivingContract {\n', '\n', '    /// @dev Function that is called when a user or another contract wants to transfer funds.\n', '    /// @param _from Transaction initiator, analogue of msg.sender\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @param _data Data containing a function signature and/or parameters\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) public;\n', '}\n', '\n', 'interface NativeAssetInterface {\n', '\n', '    // PUBLIC METHODS\n', '    function deposit() public payable;\n', '    function withdraw(uint wad) public;\n', '}\n', '\n', 'interface SharesInterface {\n', '\n', '    event Created(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\n', '    event Annihilated(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\n', '\n', '    // VIEW METHODS\n', '\n', '    function getName() view returns (string);\n', '    function getSymbol() view returns (string);\n', '    function getDecimals() view returns (uint);\n', '    function getCreationTime() view returns (uint);\n', '    function toSmallestShareUnit(uint quantity) view returns (uint);\n', '    function toWholeShareUnit(uint quantity) view returns (uint);\n', '\n', '}\n', '\n', 'contract Shares is Asset, SharesInterface {\n', '\n', '    // FIELDS\n', '\n', '    // Constructor fields\n', '    string public name;\n', '    string public symbol;\n', '    uint public decimal;\n', '    uint public creationTime;\n', '\n', '    // METHODS\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @param _name Name these shares\n', '    /// @param _symbol Symbol of shares\n', '    /// @param _decimal Amount of decimals sharePrice is denominated in, defined to be equal as deciamls in REFERENCE_ASSET contract\n', '    /// @param _creationTime Timestamp of share creation\n', '    function Shares(string _name, string _symbol, uint _decimal, uint _creationTime) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimal = _decimal;\n', '        creationTime = _creationTime;\n', '    }\n', '\n', '    // PUBLIC METHODS\n', '    // PUBLIC VIEW METHODS\n', '\n', '    function getName() view returns (string) { return name; }\n', '    function getSymbol() view returns (string) { return symbol; }\n', '    function getDecimals() view returns (uint) { return decimal; }\n', '    function getCreationTime() view returns (uint) { return creationTime; }\n', '    function toSmallestShareUnit(uint quantity) view returns (uint) { return mul(quantity, 10 ** getDecimals()); }\n', '    function toWholeShareUnit(uint quantity) view returns (uint) { return quantity / (10 ** getDecimals()); }\n', '    function transfer(address _to, uint256 _value) public returns (bool) { require(_to == address(this)); }\n', '    function transfer(address _to, uint256 _value, bytes _data) public returns (bool) { require(_to == address(this)); }\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to == address(this)); }\n', '\n', '    // INTERNAL METHODS\n', '\n', '    /// @param recipient Address the new shares should be sent to\n', '    /// @param shareQuantity Number of shares to be created\n', '    function createShares(address recipient, uint shareQuantity) internal {\n', '        totalSupply = add(totalSupply, shareQuantity);\n', '        balances[recipient] = add(balances[recipient], shareQuantity);\n', '        Created(msg.sender, now, shareQuantity);\n', '    }\n', '\n', '    /// @param recipient Address the new shares should be taken from when destroyed\n', '    /// @param shareQuantity Number of shares to be annihilated\n', '    function annihilateShares(address recipient, uint shareQuantity) internal {\n', '        totalSupply = sub(totalSupply, shareQuantity);\n', '        balances[recipient] = sub(balances[recipient], shareQuantity);\n', '        Annihilated(msg.sender, now, shareQuantity);\n', '    }\n', '}\n', '\n', 'contract RestrictedShares is Shares {\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @param _name Name these shares\n', '    /// @param _symbol Symbol of shares\n', '    /// @param _decimal Amount of decimals sharePrice is denominated in, defined to be equal as deciamls in REFERENCE_ASSET contract\n', '    /// @param _creationTime Timestamp of share creation\n', '    function RestrictedShares(\n', '        string _name,\n', '        string _symbol,\n', '        uint _decimal,\n', '        uint _creationTime\n', '    ) Shares(_name, _symbol, _decimal, _creationTime) {}\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /**\n', '     * @notice Send `_value` tokens to `_to` from `msg.sender`\n', "     * @dev Transfers sender's tokens to a given address\n", '     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\n', '     * @param _to Address of token receiver\n', '     * @param _value Number of tokens to transfer\n', '     * @return Returns success of function call\n', '     */\n', '    function transfer(address _to, uint _value)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(msg.sender == address(this) || _to == address(this));\n', '        uint codeLength;\n', '        bytes memory empty;\n', '\n', '        assembly {\n', '            // Retrieve the size of the code on target address, this needs assembly.\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        require(balances[msg.sender] >= _value); // sanity checks\n', '        require(balances[_to] + _value >= balances[_to]);\n', '\n', '        balances[msg.sender] = sub(balances[msg.sender], _value);\n', '        balances[_to] = add(balances[_to], _value);\n', '        if (codeLength > 0) {\n', '            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '            receiver.tokenFallback(msg.sender, _value, empty);\n', '        }\n', '        Transfer(msg.sender, _to, _value, empty);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Send `_value` tokens to `_to` from `msg.sender` and trigger tokenFallback if sender is a contract\n', '     * @dev Function that is called when a user or contract wants to transfer funds\n', '     * @param _to Address of token receiver\n', '     * @param _value Number of tokens to transfer\n', '     * @param _data Data to be sent to tokenFallback\n', '     * @return Returns success of function call\n', '     */\n', '    function transfer(address _to, uint _value, bytes _data)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(msg.sender == address(this) || _to == address(this));\n', '        uint codeLength;\n', '\n', '        assembly {\n', '            // Retrieve the size of the code on target address, this needs assembly.\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        require(balances[msg.sender] >= _value); // sanity checks\n', '        require(balances[_to] + _value >= balances[_to]);\n', '\n', '        balances[msg.sender] = sub(balances[msg.sender], _value);\n', '        balances[_to] = add(balances[_to], _value);\n', '        if (codeLength > 0) {\n', '            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '            receiver.tokenFallback(msg.sender, _value, _data);\n', '        }\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    /// @return Returns success of function call.\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        require(msg.sender == address(this));\n', '        require(_spender != 0x0);\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        // allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        // already 0 to mitigate the race condition described here:\n', '        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require(_value == 0 || allowed[msg.sender][_spender] == 0);\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', 'interface ComplianceInterface {\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @notice Checks whether investment is permitted for a participant\n', '    /// @param ofParticipant Address requesting to invest in a Melon fund\n', '    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\n', '    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\n', '    /// @return Whether identity is eligible to invest in a Melon fund.\n', '    function isInvestmentPermitted(\n', '        address ofParticipant,\n', '        uint256 giveQuantity,\n', '        uint256 shareQuantity\n', '    ) view returns (bool);\n', '\n', '    /// @notice Checks whether redemption is permitted for a participant\n', '    /// @param ofParticipant Address requesting to redeem from a Melon fund\n', '    /// @param shareQuantity Quantity of shares times 10 ** 18 offered to redeem\n', '    /// @param receiveQuantity Quantity of Melon token times 10 ** 18 requested to receive for shareQuantity\n', '    /// @return Whether identity is eligible to redeem from a Melon fund.\n', '    function isRedemptionPermitted(\n', '        address ofParticipant,\n', '        uint256 shareQuantity,\n', '        uint256 receiveQuantity\n', '    ) view returns (bool);\n', '}\n', '\n', 'contract DBC {\n', '\n', '    // MODIFIERS\n', '\n', '    modifier pre_cond(bool condition) {\n', '        require(condition);\n', '        _;\n', '    }\n', '\n', '    modifier post_cond(bool condition) {\n', '        _;\n', '        assert(condition);\n', '    }\n', '\n', '    modifier invariant(bool condition) {\n', '        require(condition);\n', '        _;\n', '        assert(condition);\n', '    }\n', '}\n', '\n', 'contract Owned is DBC {\n', '\n', '    // FIELDS\n', '\n', '    address public owner;\n', '\n', '    // NON-CONSTANT METHODS\n', '\n', '    function Owned() { owner = msg.sender; }\n', '\n', '    function changeOwner(address ofNewOwner) pre_cond(isOwner()) { owner = ofNewOwner; }\n', '\n', '    // PRE, POST, INVARIANT CONDITIONS\n', '\n', '    function isOwner() internal returns (bool) { return msg.sender == owner; }\n', '\n', '}\n', '\n', 'contract Fund is DSMath, DBC, Owned, RestrictedShares, FundInterface, ERC223ReceivingContract {\n', '    // TYPES\n', '\n', '    struct Modules { // Describes all modular parts, standardised through an interface\n', '        PriceFeedInterface pricefeed; // Provides all external data\n', '        ComplianceInterface compliance; // Boolean functions regarding invest/redeem\n', '        RiskMgmtInterface riskmgmt; // Boolean functions regarding make/take orders\n', '    }\n', '\n', '    struct Calculations { // List of internal calculations\n', '        uint gav; // Gross asset value\n', '        uint managementFee; // Time based fee\n', '        uint performanceFee; // Performance based fee measured against QUOTE_ASSET\n', '        uint unclaimedFees; // Fees not yet allocated to the fund manager\n', '        uint nav; // Net asset value\n', '        uint highWaterMark; // A record of best all-time fund performance\n', '        uint totalSupply; // Total supply of shares\n', '        uint timestamp; // Time when calculations are performed in seconds\n', '    }\n', '\n', '    enum RequestStatus { active, cancelled, executed }\n', '    enum RequestType { invest, redeem, tokenFallbackRedeem }\n', '    struct Request { // Describes and logs whenever asset enter and leave fund due to Participants\n', '        address participant; // Participant in Melon fund requesting investment or redemption\n', '        RequestStatus status; // Enum: active, cancelled, executed; Status of request\n', '        RequestType requestType; // Enum: invest, redeem, tokenFallbackRedeem\n', '        address requestAsset; // Address of the asset being requested\n', '        uint shareQuantity; // Quantity of Melon fund shares\n', '        uint giveQuantity; // Quantity in Melon asset to give to Melon fund to receive shareQuantity\n', '        uint receiveQuantity; // Quantity in Melon asset to receive from Melon fund for given shareQuantity\n', '        uint timestamp;     // Time of request creation in seconds\n', '        uint atUpdateId;    // Pricefeed updateId when this request was created\n', '    }\n', '\n', '    enum OrderStatus { active, partiallyFilled, fullyFilled, cancelled }\n', '    enum OrderType { make, take }\n', '    struct Order { // Describes and logs whenever assets enter and leave fund due to Manager\n', '        uint exchangeId; // Id as returned from exchange\n', '        OrderStatus status; // Enum: active, partiallyFilled, fullyFilled, cancelled\n', '        OrderType orderType; // Enum: make, take\n', '        address sellAsset; // Asset (as registered in Asset registrar) to be sold\n', '        address buyAsset; // Asset (as registered in Asset registrar) to be bought\n', '        uint sellQuantity; // Quantity of sellAsset to be sold\n', '        uint buyQuantity; // Quantity of sellAsset to be bought\n', '        uint timestamp; // Time of order creation in seconds\n', '        uint fillQuantity; // Buy quantity filled; Always less than buy_quantity\n', '    }\n', '\n', '    struct Exchange {\n', '        address exchange; // Address of the exchange\n', '        ExchangeInterface exchangeAdapter; //Exchange adapter contracts respective to the exchange\n', '        bool isApproveOnly; // True in case of exchange implementation which requires  are approved when an order is made instead of transfer\n', '    }\n', '\n', '    // FIELDS\n', '\n', '    // Constant fields\n', '    uint public constant MAX_FUND_ASSETS = 90; // Max ownable assets by the fund supported by gas limits\n', '    // Constructor fields\n', '    uint public MANAGEMENT_FEE_RATE; // Fee rate in QUOTE_ASSET per delta improvement in WAD\n', '    uint public PERFORMANCE_FEE_RATE; // Fee rate in QUOTE_ASSET per managed seconds in WAD\n', '    address public VERSION; // Address of Version contract\n', '    Asset public QUOTE_ASSET; // QUOTE asset as ERC20 contract\n', '    NativeAssetInterface public NATIVE_ASSET; // Native asset as ERC20 contract\n', '    // Methods fields\n', '    Modules public module; // Struct which holds all the initialised module instances\n', '    Exchange[] public exchanges; // Array containing exchanges this fund supports\n', '    Calculations public atLastUnclaimedFeeAllocation; // Calculation results at last allocateUnclaimedFees() call\n', '    bool public isShutDown; // Security feature, if yes than investing, managing, allocateUnclaimedFees gets blocked\n', '    Request[] public requests; // All the requests this fund received from participants\n', '    bool public isInvestAllowed; // User option, if false fund rejects Melon investments\n', '    bool public isRedeemAllowed; // User option, if false fund rejects Melon redemptions; Redemptions using slices always possible\n', '    Order[] public orders; // All the orders this fund placed on exchanges\n', '    mapping (uint => mapping(address => uint)) public exchangeIdsToOpenMakeOrderIds; // exchangeIndex to: asset to open make order ID ; if no open make orders, orderID is zero\n', '    address[] public ownedAssets; // List of all assets owned by the fund or for which the fund has open make orders\n', '    mapping (address => bool) public isInAssetList; // Mapping from asset to whether the asset exists in ownedAssets\n', '    mapping (address => bool) public isInOpenMakeOrder; // Mapping from asset to whether the asset is in a open make order as buy asset\n', '\n', '    // METHODS\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @dev Should only be called via Version.setupFund(..)\n', '    /// @param withName human-readable descriptive name (not necessarily unique)\n', '    /// @param ofQuoteAsset Asset against which mgmt and performance fee is measured against and which can be used to invest/redeem using this single asset\n', '    /// @param ofManagementFee A time based fee expressed, given in a number which is divided by 1 WAD\n', '    /// @param ofPerformanceFee A time performance based fee, performance relative to ofQuoteAsset, given in a number which is divided by 1 WAD\n', '    /// @param ofCompliance Address of compliance module\n', '    /// @param ofRiskMgmt Address of risk management module\n', '    /// @param ofPriceFeed Address of price feed module\n', '    /// @param ofExchanges Addresses of exchange on which this fund can trade\n', '    /// @param ofExchangeAdapters Addresses of exchange adapters\n', '    /// @return Deployed Fund with manager set as ofManager\n', '    function Fund(\n', '        address ofManager,\n', '        string withName,\n', '        address ofQuoteAsset,\n', '        uint ofManagementFee,\n', '        uint ofPerformanceFee,\n', '        address ofNativeAsset,\n', '        address ofCompliance,\n', '        address ofRiskMgmt,\n', '        address ofPriceFeed,\n', '        address[] ofExchanges,\n', '        address[] ofExchangeAdapters\n', '    )\n', '        RestrictedShares(withName, "MLNF", 18, now)\n', '    {\n', '        isInvestAllowed = true;\n', '        isRedeemAllowed = true;\n', '        owner = ofManager;\n', '        require(ofManagementFee < 10 ** 18); // Require management fee to be less than 100 percent\n', '        MANAGEMENT_FEE_RATE = ofManagementFee; // 1 percent is expressed as 0.01 * 10 ** 18\n', '        require(ofPerformanceFee < 10 ** 18); // Require performance fee to be less than 100 percent\n', '        PERFORMANCE_FEE_RATE = ofPerformanceFee; // 1 percent is expressed as 0.01 * 10 ** 18\n', '        VERSION = msg.sender;\n', '        module.compliance = ComplianceInterface(ofCompliance);\n', '        module.riskmgmt = RiskMgmtInterface(ofRiskMgmt);\n', '        module.pricefeed = PriceFeedInterface(ofPriceFeed);\n', '        // Bridged to Melon exchange interface by exchangeAdapter library\n', '        for (uint i = 0; i < ofExchanges.length; ++i) {\n', '            ExchangeInterface adapter = ExchangeInterface(ofExchangeAdapters[i]);\n', '            bool isApproveOnly = adapter.isApproveOnly();\n', '            exchanges.push(Exchange({\n', '                exchange: ofExchanges[i],\n', '                exchangeAdapter: adapter,\n', '                isApproveOnly: isApproveOnly\n', '            }));\n', '        }\n', '        // Require Quote assets exists in pricefeed\n', '        QUOTE_ASSET = Asset(ofQuoteAsset);\n', '        NATIVE_ASSET = NativeAssetInterface(ofNativeAsset);\n', '        // Quote Asset and Native asset always in owned assets list\n', '        ownedAssets.push(ofQuoteAsset);\n', '        isInAssetList[ofQuoteAsset] = true;\n', '        ownedAssets.push(ofNativeAsset);\n', '        isInAssetList[ofNativeAsset] = true;\n', '        require(address(QUOTE_ASSET) == module.pricefeed.getQuoteAsset()); // Sanity check\n', '        atLastUnclaimedFeeAllocation = Calculations({\n', '            gav: 0,\n', '            managementFee: 0,\n', '            performanceFee: 0,\n', '            unclaimedFees: 0,\n', '            nav: 0,\n', '            highWaterMark: 10 ** getDecimals(),\n', '            totalSupply: totalSupply,\n', '            timestamp: now\n', '        });\n', '    }\n', '\n', '    // EXTERNAL METHODS\n', '\n', '    // EXTERNAL : ADMINISTRATION\n', '\n', '    function enableInvestment() external pre_cond(isOwner()) { isInvestAllowed = true; }\n', '    function disableInvestment() external pre_cond(isOwner()) { isInvestAllowed = false; }\n', '    function enableRedemption() external pre_cond(isOwner()) { isRedeemAllowed = true; }\n', '    function disableRedemption() external pre_cond(isOwner()) { isRedeemAllowed = false; }\n', '    function shutDown() external pre_cond(msg.sender == VERSION) { isShutDown = true; }\n', '\n', '\n', '    // EXTERNAL : PARTICIPATION\n', '\n', '    /// @notice Give melon tokens to receive shares of this fund\n', '    /// @dev Recommended to give some leeway in prices to account for possibly slightly changing prices\n', '    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\n', '    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\n', '    function requestInvestment(\n', '        uint giveQuantity,\n', '        uint shareQuantity,\n', '        bool isNativeAsset\n', '    )\n', '        external\n', '        pre_cond(!isShutDown)\n', '        pre_cond(isInvestAllowed) // investment using Melon has not been deactivated by the Manager\n', '        pre_cond(module.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity))    // Compliance Module: Investment permitted\n', '    {\n', '        requests.push(Request({\n', '            participant: msg.sender,\n', '            status: RequestStatus.active,\n', '            requestType: RequestType.invest,\n', '            requestAsset: isNativeAsset ? address(NATIVE_ASSET) : address(QUOTE_ASSET),\n', '            shareQuantity: shareQuantity,\n', '            giveQuantity: giveQuantity,\n', '            receiveQuantity: shareQuantity,\n', '            timestamp: now,\n', '            atUpdateId: module.pricefeed.getLastUpdateId()\n', '        }));\n', '        RequestUpdated(getLastRequestId());\n', '    }\n', '\n', '    /// @notice Give shares of this fund to receive melon tokens\n', '    /// @dev Recommended to give some leeway in prices to account for possibly slightly changing prices\n', '    /// @param shareQuantity Quantity of shares times 10 ** 18 offered to redeem\n', '    /// @param receiveQuantity Quantity of Melon token times 10 ** 18 requested to receive for shareQuantity\n', '    function requestRedemption(\n', '        uint shareQuantity,\n', '        uint receiveQuantity,\n', '        bool isNativeAsset\n', '      )\n', '        external\n', '        pre_cond(!isShutDown)\n', '        pre_cond(isRedeemAllowed) // Redemption using Melon has not been deactivated by Manager\n', '        pre_cond(module.compliance.isRedemptionPermitted(msg.sender, shareQuantity, receiveQuantity)) // Compliance Module: Redemption permitted\n', '    {\n', '        requests.push(Request({\n', '            participant: msg.sender,\n', '            status: RequestStatus.active,\n', '            requestType: RequestType.redeem,\n', '            requestAsset: isNativeAsset ? address(NATIVE_ASSET) : address(QUOTE_ASSET),\n', '            shareQuantity: shareQuantity,\n', '            giveQuantity: shareQuantity,\n', '            receiveQuantity: receiveQuantity,\n', '            timestamp: now,\n', '            atUpdateId: module.pricefeed.getLastUpdateId()\n', '        }));\n', '        RequestUpdated(getLastRequestId());\n', '    }\n', '\n', '    /// @notice Executes active investment and redemption requests, in a way that minimises information advantages of investor\n', '    /// @dev Distributes melon and shares according to the request\n', '    /// @param id Index of request to be executed\n', '    /// @dev Active investment or redemption request executed\n', '    function executeRequest(uint id)\n', '        external\n', '        pre_cond(!isShutDown)\n', '        pre_cond(requests[id].status == RequestStatus.active)\n', '        pre_cond(requests[id].requestType != RequestType.redeem || requests[id].shareQuantity <= balances[requests[id].participant]) // request owner does not own enough shares\n', '        pre_cond(\n', '            totalSupply == 0 ||\n', '            (\n', '                now >= add(requests[id].timestamp, module.pricefeed.getInterval()) &&\n', '                module.pricefeed.getLastUpdateId() >= add(requests[id].atUpdateId, 2)\n', '            )\n', '        )   // PriceFeed Module: Wait at least one interval time and two updates before continuing (unless it is the first investment)\n', '         // PriceFeed Module: No recent updates for fund asset list\n', '    {\n', '        // sharePrice quoted in QUOTE_ASSET and multiplied by 10 ** fundDecimals\n', '        // based in QUOTE_ASSET and multiplied by 10 ** fundDecimals\n', '        require(module.pricefeed.hasRecentPrice(address(QUOTE_ASSET)));\n', '        require(module.pricefeed.hasRecentPrices(ownedAssets));\n', '        var (isRecent, , ) = module.pricefeed.getInvertedPrice(address(QUOTE_ASSET));\n', '        // TODO: check precision of below otherwise use; uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePrice()));\n', '        // By definition quoteDecimals == fundDecimals\n', '        Request request = requests[id];\n', '\n', '        uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePrice()));\n', '        if (request.requestAsset == address(NATIVE_ASSET)) {\n', '            var (isPriceRecent, invertedNativeAssetPrice, nativeAssetDecimal) = module.pricefeed.getInvertedPrice(address(NATIVE_ASSET));\n', '            if (!isPriceRecent) {\n', '                revert();\n', '            }\n', '            costQuantity = mul(costQuantity, invertedNativeAssetPrice) / 10 ** nativeAssetDecimal;\n', '        }\n', '\n', '        if (\n', '            isInvestAllowed &&\n', '            request.requestType == RequestType.invest &&\n', '            costQuantity <= request.giveQuantity\n', '        ) {\n', '            request.status = RequestStatus.executed;\n', '            assert(AssetInterface(request.requestAsset).transferFrom(request.participant, this, costQuantity)); // Allocate Value\n', '            createShares(request.participant, request.shareQuantity); // Accounting\n', '        } else if (\n', '            isRedeemAllowed &&\n', '            request.requestType == RequestType.redeem &&\n', '            request.receiveQuantity <= costQuantity\n', '        ) {\n', '            request.status = RequestStatus.executed;\n', '            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity)); // Return value\n', '            annihilateShares(request.participant, request.shareQuantity); // Accounting\n', '        } else if (\n', '            isRedeemAllowed &&\n', '            request.requestType == RequestType.tokenFallbackRedeem &&\n', '            request.receiveQuantity <= costQuantity\n', '        ) {\n', '            request.status = RequestStatus.executed;\n', '            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity)); // Return value\n', '            annihilateShares(this, request.shareQuantity); // Accounting\n', '        } else {\n', '            revert(); // Invalid Request or invalid giveQuantity / receiveQuantity\n', '        }\n', '    }\n', '\n', '    /// @notice Cancels active investment and redemption requests\n', '    /// @param id Index of request to be executed\n', '    function cancelRequest(uint id)\n', '        external\n', '        pre_cond(requests[id].status == RequestStatus.active) // Request is active\n', '        pre_cond(requests[id].participant == msg.sender || isShutDown) // Either request creator or fund is shut down\n', '    {\n', '        requests[id].status = RequestStatus.cancelled;\n', '    }\n', '\n', '    /// @notice Redeems by allocating an ownership percentage of each asset to the participant\n', '    /// @dev Independent of running price feed!\n', '    /// @param shareQuantity Number of shares owned by the participant, which the participant would like to redeem for individual assets\n', '    /// @return Whether all assets sent to shareholder or not\n', '    function redeemAllOwnedAssets(uint shareQuantity)\n', '        external\n', '        returns (bool success)\n', '    {\n', '        return emergencyRedeem(shareQuantity, ownedAssets);\n', '    }\n', '\n', '    // EXTERNAL : MANAGING\n', '\n', '    /// @notice Makes an order on the selected exchange\n', '    /// @dev These are orders that are not expected to settle immediately.  Sufficient balance (== sellQuantity) of sellAsset\n', '    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\n', '    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\n', '    /// @param sellQuantity Quantity of sellAsset to be sold\n', '    /// @param buyQuantity Quantity of buyAsset to be bought\n', '    function makeOrder(\n', '        uint exchangeNumber,\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    )\n', '        external\n', '        pre_cond(isOwner())\n', '        pre_cond(!isShutDown)\n', '    {\n', '        require(buyAsset != address(this)); // Prevent buying of own fund token\n', '        require(quantityHeldInCustodyOfExchange(sellAsset) == 0); // Curr only one make order per sellAsset allowed. Please wait or cancel existing make order.\n', '        require(module.pricefeed.existsPriceOnAssetPair(sellAsset, buyAsset)); // PriceFeed module: Requested asset pair not valid\n', '        var (isRecent, referencePrice, ) = module.pricefeed.getReferencePrice(sellAsset, buyAsset);\n', '        require(isRecent);  // Reference price is required to be recent\n', '        require(\n', '            module.riskmgmt.isMakePermitted(\n', '                module.pricefeed.getOrderPrice(\n', '                    sellAsset,\n', '                    buyAsset,\n', '                    sellQuantity,\n', '                    buyQuantity\n', '                ),\n', '                referencePrice,\n', '                sellAsset,\n', '                buyAsset,\n', '                sellQuantity,\n', '                buyQuantity\n', '            )\n', '        ); // RiskMgmt module: Make order not permitted\n', '        require(isInAssetList[buyAsset] || ownedAssets.length < MAX_FUND_ASSETS); // Limit for max ownable assets by the fund reached\n', '        require(AssetInterface(sellAsset).approve(exchanges[exchangeNumber].exchange, sellQuantity)); // Approve exchange to spend assets\n', '\n', '        // Since there is only one openMakeOrder allowed for each asset, we can assume that openMakeOrderId is set as zero by quantityHeldInCustodyOfExchange() function\n', '        require(address(exchanges[exchangeNumber].exchangeAdapter).delegatecall(bytes4(keccak256("makeOrder(address,address,address,uint256,uint256)")), exchanges[exchangeNumber].exchange, sellAsset, buyAsset, sellQuantity, buyQuantity));\n', '        exchangeIdsToOpenMakeOrderIds[exchangeNumber][sellAsset] = exchanges[exchangeNumber].exchangeAdapter.getLastOrderId(exchanges[exchangeNumber].exchange);\n', '\n', '        // Success defined as non-zero order id\n', '        require(exchangeIdsToOpenMakeOrderIds[exchangeNumber][sellAsset] != 0);\n', '\n', '        // Update ownedAssets array and isInAssetList, isInOpenMakeOrder mapping\n', '        isInOpenMakeOrder[buyAsset] = true;\n', '        if (!isInAssetList[buyAsset]) {\n', '            ownedAssets.push(buyAsset);\n', '            isInAssetList[buyAsset] = true;\n', '        }\n', '\n', '        orders.push(Order({\n', '            exchangeId: exchangeIdsToOpenMakeOrderIds[exchangeNumber][sellAsset],\n', '            status: OrderStatus.active,\n', '            orderType: OrderType.make,\n', '            sellAsset: sellAsset,\n', '            buyAsset: buyAsset,\n', '            sellQuantity: sellQuantity,\n', '            buyQuantity: buyQuantity,\n', '            timestamp: now,\n', '            fillQuantity: 0\n', '        }));\n', '\n', '        OrderUpdated(exchangeIdsToOpenMakeOrderIds[exchangeNumber][sellAsset]);\n', '    }\n', '\n', '    /// @notice Takes an active order on the selected exchange\n', '    /// @dev These are orders that are expected to settle immediately\n', '    /// @param id Active order id\n', '    /// @param receiveQuantity Buy quantity of what others are selling on selected Exchange\n', '    function takeOrder(uint exchangeNumber, uint id, uint receiveQuantity)\n', '        external\n', '        pre_cond(isOwner())\n', '        pre_cond(!isShutDown)\n', '    {\n', '        // Get information of order by order id\n', '        Order memory order; // Inverse variable terminology! Buying what another person is selling\n', '        (\n', '            order.sellAsset,\n', '            order.buyAsset,\n', '            order.sellQuantity,\n', '            order.buyQuantity\n', '        ) = exchanges[exchangeNumber].exchangeAdapter.getOrder(exchanges[exchangeNumber].exchange, id);\n', '        // Check pre conditions\n', '        require(order.sellAsset != address(this)); // Prevent buying of own fund token\n', '        require(module.pricefeed.existsPriceOnAssetPair(order.buyAsset, order.sellAsset)); // PriceFeed module: Requested asset pair not valid\n', '        require(isInAssetList[order.sellAsset] || ownedAssets.length < MAX_FUND_ASSETS); // Limit for max ownable assets by the fund reached\n', '        var (isRecent, referencePrice, ) = module.pricefeed.getReferencePrice(order.buyAsset, order.sellAsset);\n', '        require(isRecent); // Reference price is required to be recent\n', '        require(receiveQuantity <= order.sellQuantity); // Not enough quantity of order for what is trying to be bought\n', '        uint spendQuantity = mul(receiveQuantity, order.buyQuantity) / order.sellQuantity;\n', '        require(AssetInterface(order.buyAsset).approve(exchanges[exchangeNumber].exchange, spendQuantity)); // Could not approve spending of spendQuantity of order.buyAsset\n', '        require(\n', '            module.riskmgmt.isTakePermitted(\n', '            module.pricefeed.getOrderPrice(\n', '                order.buyAsset,\n', '                order.sellAsset,\n', '                order.buyQuantity, // spendQuantity\n', '                order.sellQuantity // receiveQuantity\n', '            ),\n', '            referencePrice,\n', '            order.buyAsset,\n', '            order.sellAsset,\n', '            order.buyQuantity,\n', '            order.sellQuantity\n', '        )); // RiskMgmt module: Take order not permitted\n', '\n', '        // Execute request\n', '        require(address(exchanges[exchangeNumber].exchangeAdapter).delegatecall(bytes4(keccak256("takeOrder(address,uint256,uint256)")), exchanges[exchangeNumber].exchange, id, receiveQuantity));\n', '\n', '        // Update ownedAssets array and isInAssetList mapping\n', '        if (!isInAssetList[order.sellAsset]) {\n', '            ownedAssets.push(order.sellAsset);\n', '            isInAssetList[order.sellAsset] = true;\n', '        }\n', '\n', '        order.exchangeId = id;\n', '        order.status = OrderStatus.fullyFilled;\n', '        order.orderType = OrderType.take;\n', '        order.timestamp = now;\n', '        order.fillQuantity = receiveQuantity;\n', '        orders.push(order);\n', '        OrderUpdated(id);\n', '    }\n', '\n', '    /// @notice Cancels orders that were not expected to settle immediately, i.e. makeOrders\n', '    /// @dev Reduce exposure with exchange interaction\n', '    /// @param id Active order id of this order array with order owner of this contract on selected Exchange\n', '    function cancelOrder(uint exchangeNumber, uint id)\n', '        external\n', '        pre_cond(isOwner() || isShutDown)\n', '    {\n', '        // Get information of fund order by order id\n', '        Order order = orders[id];\n', '\n', '        // Execute request\n', '        require(address(exchanges[exchangeNumber].exchangeAdapter).delegatecall(bytes4(keccak256("cancelOrder(address,uint256)")), exchanges[exchangeNumber].exchange, order.exchangeId));\n', '\n', '        order.status = OrderStatus.cancelled;\n', '        OrderUpdated(id);\n', '    }\n', '\n', '\n', '    // PUBLIC METHODS\n', '\n', '    // PUBLIC METHODS : ERC223\n', '\n', '    /// @dev Standard ERC223 function that handles incoming token transfers.\n', '    /// @dev This type of redemption can be seen as a "market order", where price is calculated at execution time\n', '    /// @param ofSender  Token sender address.\n', '    /// @param tokenAmount Amount of tokens sent.\n', '    /// @param metadata  Transaction metadata.\n', '    function tokenFallback(\n', '        address ofSender,\n', '        uint tokenAmount,\n', '        bytes metadata\n', '    ) {\n', '        if (msg.sender != address(this)) {\n', '            // when ofSender is a recognized exchange, receive tokens, otherwise revert\n', '            for (uint i; i < exchanges.length; i++) {\n', '                if (exchanges[i].exchange == ofSender) return; // receive tokens and do nothing\n', '            }\n', '            revert();\n', '        } else {    // otherwise, make a redemption request\n', '            requests.push(Request({\n', '                participant: ofSender,\n', '                status: RequestStatus.active,\n', '                requestType: RequestType.tokenFallbackRedeem,\n', '                requestAsset: address(QUOTE_ASSET), // redeem in QUOTE_ASSET\n', '                shareQuantity: tokenAmount,\n', '                giveQuantity: tokenAmount,              // shares being sent\n', '                receiveQuantity: 0,          // value of the shares at request time\n', '                timestamp: now,\n', '                atUpdateId: module.pricefeed.getLastUpdateId()\n', '            }));\n', '            RequestUpdated(getLastRequestId());\n', '        }\n', '    }\n', '\n', '\n', '    // PUBLIC METHODS : ACCOUNTING\n', '\n', '    /// @notice Calculates gross asset value of the fund\n', '    /// @dev Decimals in assets must be equal to decimals in PriceFeed for all entries in AssetRegistrar\n', '    /// @dev Assumes that module.pricefeed.getPrice(..) returns recent prices\n', '    /// @return gav Gross asset value quoted in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    function calcGav() returns (uint gav) {\n', '        // prices quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\n', '        address[] memory tempOwnedAssets; // To store ownedAssets\n', '        tempOwnedAssets = ownedAssets;\n', '        delete ownedAssets;\n', '        for (uint i = 0; i < tempOwnedAssets.length; ++i) {\n', '            address ofAsset = tempOwnedAssets[i];\n', '            // assetHoldings formatting: mul(exchangeHoldings, 10 ** assetDecimal)\n', '            uint assetHoldings = add(\n', '                uint(AssetInterface(ofAsset).balanceOf(this)), // asset base units held by fund\n', '                quantityHeldInCustodyOfExchange(ofAsset)\n', '            );\n', '            // assetPrice formatting: mul(exchangePrice, 10 ** assetDecimal)\n', '            var (isRecent, assetPrice, assetDecimals) = module.pricefeed.getPrice(ofAsset);\n', '            if (!isRecent) {\n', '                revert();\n', '            }\n', '            // gav as sum of mul(assetHoldings, assetPrice) with formatting: mul(mul(exchangeHoldings, exchangePrice), 10 ** shareDecimals)\n', '            gav = add(gav, mul(assetHoldings, assetPrice) / (10 ** uint256(assetDecimals)));   // Sum up product of asset holdings of this vault and asset prices\n', '            if (assetHoldings != 0 || ofAsset == address(QUOTE_ASSET) || ofAsset == address(NATIVE_ASSET) || isInOpenMakeOrder[ofAsset]) { // Check if asset holdings is not zero or is address(QUOTE_ASSET) or in open make order\n', '                ownedAssets.push(ofAsset);\n', '            } else {\n', '                isInAssetList[ofAsset] = false; // Remove from ownedAssets if asset holdings are zero\n', '            }\n', '            PortfolioContent(assetHoldings, assetPrice, assetDecimals);\n', '        }\n', '    }\n', '\n', '    /**\n', '    @notice Calculates unclaimed fees of the fund manager\n', '    @param gav Gross asset value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    @return {\n', '      "managementFees": "A time (seconds) based fee in QUOTE_ASSET and multiplied by 10 ** shareDecimals",\n', '      "performanceFees": "A performance (rise of sharePrice measured in QUOTE_ASSET) based fee in QUOTE_ASSET and multiplied by 10 ** shareDecimals",\n', '      "unclaimedfees": "The sum of both managementfee and performancefee in QUOTE_ASSET and multiplied by 10 ** shareDecimals"\n', '    }\n', '    */\n', '    function calcUnclaimedFees(uint gav)\n', '        view\n', '        returns (\n', '            uint managementFee,\n', '            uint performanceFee,\n', '            uint unclaimedFees)\n', '    {\n', '        // Management fee calculation\n', '        uint timePassed = sub(now, atLastUnclaimedFeeAllocation.timestamp);\n', '        uint gavPercentage = mul(timePassed, gav) / (1 years);\n', '        managementFee = wmul(gavPercentage, MANAGEMENT_FEE_RATE);\n', '\n', '        // Performance fee calculation\n', '        // Handle potential division through zero by defining a default value\n', '        uint valuePerShareExclMgmtFees = totalSupply > 0 ? calcValuePerShare(sub(gav, managementFee), totalSupply) : toSmallestShareUnit(1);\n', '        if (valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation.highWaterMark) {\n', '            uint gainInSharePrice = sub(valuePerShareExclMgmtFees, atLastUnclaimedFeeAllocation.highWaterMark);\n', '            uint investmentProfits = wmul(gainInSharePrice, totalSupply);\n', '            performanceFee = wmul(investmentProfits, PERFORMANCE_FEE_RATE);\n', '        }\n', '\n', '        // Sum of all FEES\n', '        unclaimedFees = add(managementFee, performanceFee);\n', '    }\n', '\n', '    /// @notice Calculates the Net asset value of this fund\n', '    /// @param gav Gross asset value of this fund in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    /// @param unclaimedFees The sum of both managementFee and performanceFee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    /// @return nav Net asset value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    function calcNav(uint gav, uint unclaimedFees)\n', '        view\n', '        returns (uint nav)\n', '    {\n', '        nav = sub(gav, unclaimedFees);\n', '    }\n', '\n', '    /// @notice Calculates the share price of the fund\n', '    /// @dev Convention for valuePerShare (== sharePrice) formatting: mul(totalValue / numShares, 10 ** decimal), to avoid floating numbers\n', '    /// @dev Non-zero share supply; value denominated in [base unit of melonAsset]\n', '    /// @param totalValue the total value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    /// @param numShares the number of shares multiplied by 10 ** shareDecimals\n', '    /// @return valuePerShare Share price denominated in QUOTE_ASSET and multiplied by 10 ** shareDecimals\n', '    function calcValuePerShare(uint totalValue, uint numShares)\n', '        view\n', '        pre_cond(numShares > 0)\n', '        returns (uint valuePerShare)\n', '    {\n', '        valuePerShare = toSmallestShareUnit(totalValue) / numShares;\n', '    }\n', '\n', '    /**\n', '    @notice Calculates essential fund metrics\n', '    @return {\n', '      "gav": "Gross asset value of this fund denominated in [base unit of melonAsset]",\n', '      "managementFee": "A time (seconds) based fee",\n', '      "performanceFee": "A performance (rise of sharePrice measured in QUOTE_ASSET) based fee",\n', '      "unclaimedFees": "The sum of both managementFee and performanceFee denominated in [base unit of melonAsset]",\n', '      "feesShareQuantity": "The number of shares to be given as fees to the manager",\n', '      "nav": "Net asset value denominated in [base unit of melonAsset]",\n', '      "sharePrice": "Share price denominated in [base unit of melonAsset]"\n', '    }\n', '    */\n', '    function performCalculations()\n', '        view\n', '        returns (\n', '            uint gav,\n', '            uint managementFee,\n', '            uint performanceFee,\n', '            uint unclaimedFees,\n', '            uint feesShareQuantity,\n', '            uint nav,\n', '            uint sharePrice\n', '        )\n', '    {\n', '        gav = calcGav(); // Reflects value independent of fees\n', '        (managementFee, performanceFee, unclaimedFees) = calcUnclaimedFees(gav);\n', '        nav = calcNav(gav, unclaimedFees);\n', '\n', '        // The value of unclaimedFees measured in shares of this fund at current value\n', '        feesShareQuantity = (gav == 0) ? 0 : mul(totalSupply, unclaimedFees) / gav;\n', '        // The total share supply including the value of unclaimedFees, measured in shares of this fund\n', '        uint totalSupplyAccountingForFees = add(totalSupply, feesShareQuantity);\n', '        sharePrice = nav > 0 ? calcValuePerShare(nav, totalSupplyAccountingForFees) : toSmallestShareUnit(1); // Handle potential division through zero by defining a default value\n', '    }\n', '\n', '    /// @notice Converts unclaimed fees of the manager into fund shares\n', '    /// @dev Only Owner\n', '    function allocateUnclaimedFees()\n', '        pre_cond(isOwner())\n', '    {\n', '        var (\n', '            gav,\n', '            managementFee,\n', '            performanceFee,\n', '            unclaimedFees,\n', '            feesShareQuantity,\n', '            nav,\n', '            sharePrice\n', '        ) = performCalculations();\n', '\n', '        createShares(owner, feesShareQuantity); // Updates totalSupply by creating shares allocated to manager\n', '\n', '        // Update Calculations\n', '        uint highWaterMark = atLastUnclaimedFeeAllocation.highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation.highWaterMark : sharePrice;\n', '        atLastUnclaimedFeeAllocation = Calculations({\n', '            gav: gav,\n', '            managementFee: managementFee,\n', '            performanceFee: performanceFee,\n', '            unclaimedFees: unclaimedFees,\n', '            nav: nav,\n', '            highWaterMark: highWaterMark,\n', '            totalSupply: totalSupply,\n', '            timestamp: now\n', '        });\n', '\n', '        FeesConverted(now, feesShareQuantity, unclaimedFees);\n', '        CalculationUpdate(now, managementFee, performanceFee, nav, sharePrice, totalSupply);\n', '    }\n', '\n', '    // PUBLIC : REDEEMING\n', '\n', '    /// @notice Redeems by allocating an ownership percentage only of requestedAssets to the participant\n', '    /// @dev Independent of running price feed! Note: if requestedAssets != ownedAssets then participant misses out on some owned value\n', '    /// @param shareQuantity Number of shares owned by the participant, which the participant would like to redeem for individual assets\n', '    /// @param requestedAssets List of addresses that consitute a subset of ownedAssets.\n', '    /// @return Whether all assets sent to shareholder or not\n', '    function emergencyRedeem(uint shareQuantity, address[] requestedAssets)\n', '        public\n', '        pre_cond(balances[msg.sender] >= shareQuantity)  // sender owns enough shares\n', '        returns (bool)\n', '    {\n', '        uint[] memory ownershipQuantities = new uint[](requestedAssets.length);\n', '\n', '        // Check whether enough assets held by fund\n', '        for (uint i = 0; i < requestedAssets.length; ++i) {\n', '            address ofAsset = requestedAssets[i];\n', '            uint assetHoldings = add(\n', '                uint(AssetInterface(ofAsset).balanceOf(this)),\n', '                quantityHeldInCustodyOfExchange(ofAsset)\n', '            );\n', '\n', '            if (assetHoldings == 0) continue;\n', '\n', "            // participant's ownership percentage of asset holdings\n", '            ownershipQuantities[i] = mul(assetHoldings, shareQuantity) / totalSupply;\n', '\n', '            // CRITICAL ERR: Not enough fund asset balance for owed ownershipQuantitiy, eg in case of unreturned asset quantity at address(exchanges[i].exchange) address\n', '            if (uint(AssetInterface(ofAsset).balanceOf(this)) < ownershipQuantities[i]) {\n', '                isShutDown = true;\n', '                ErrorMessage("CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy");\n', '                return false;\n', '            }\n', '        }\n', '\n', '        // Annihilate shares before external calls to prevent reentrancy\n', '        annihilateShares(msg.sender, shareQuantity);\n', '\n', '        // Transfer ownershipQuantity of Assets\n', '        for (uint j = 0; j < ownershipQuantities.length; ++j) {\n', '            // Failed to send owed ownershipQuantity from fund to participant\n', '            if (!AssetInterface(ofAsset).transfer(msg.sender, ownershipQuantities[j])) {\n', '                revert();\n', '            }\n', '        }\n', '        Redeemed(msg.sender, now, shareQuantity);\n', '        return true;\n', '    }\n', '\n', '    // PUBLIC : FEES\n', '\n', '    /// @dev Quantity of asset held in exchange according to associated order id\n', '    /// @param ofAsset Address of asset\n', '    /// @return Quantity of input asset held in exchange\n', '    function quantityHeldInCustodyOfExchange(address ofAsset) returns (uint) {\n', '        uint totalSellQuantity;     // quantity in custody across exchanges\n', '        uint totalSellQuantityInApprove; // quantity of asset in approve (allowance) but not custody of exchange\n', '        for (uint i; i < exchanges.length; i++) {\n', '            if (exchangeIdsToOpenMakeOrderIds[i][ofAsset] == 0) {\n', '                continue;\n', '            }\n', '            var (sellAsset, , sellQuantity, ) = exchanges[i].exchangeAdapter.getOrder(exchanges[i].exchange, exchangeIdsToOpenMakeOrderIds[i][ofAsset]);\n', '            if (sellQuantity == 0) {\n', '                exchangeIdsToOpenMakeOrderIds[i][ofAsset] = 0;\n', '            }\n', '            totalSellQuantity = add(totalSellQuantity, sellQuantity);\n', '            if (exchanges[i].isApproveOnly) {\n', '                totalSellQuantityInApprove += sellQuantity;\n', '            }\n', '        }\n', '        if (totalSellQuantity == 0) {\n', '            isInOpenMakeOrder[sellAsset] = false;\n', '        }\n', '        return sub(totalSellQuantity, totalSellQuantityInApprove); // Since quantity in approve is not actually in custody\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @notice Calculates sharePrice denominated in [base unit of melonAsset]\n', '    /// @return sharePrice Share price denominated in [base unit of melonAsset]\n', '    function calcSharePrice() view returns (uint sharePrice) {\n', '        (, , , , , sharePrice) = performCalculations();\n', '        return sharePrice;\n', '    }\n', '\n', '    function getModules() view returns (address, address, address) {\n', '        return (\n', '            address(module.pricefeed),\n', '            address(module.compliance),\n', '            address(module.riskmgmt)\n', '        );\n', '    }\n', '\n', '    function getLastOrderId() view returns (uint) { return orders.length - 1; }\n', '    function getLastRequestId() view returns (uint) { return requests.length - 1; }\n', '    function getNameHash() view returns (bytes32) { return bytes32(keccak256(name)); }\n', '    function getManager() view returns (address) { return owner; }\n', '}\n', '\n', 'interface ExchangeInterface {\n', '\n', '    // EVENTS\n', '\n', '    event OrderUpdated(uint id);\n', '\n', '    // METHODS\n', '    // EXTERNAL METHODS\n', '\n', '    function makeOrder(\n', '        address onExchange,\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    ) external returns (uint);\n', '    function takeOrder(address onExchange, uint id, uint quantity) external returns (bool);\n', '    function cancelOrder(address onExchange, uint id) external returns (bool);\n', '\n', '\n', '    // PUBLIC METHODS\n', '    // PUBLIC VIEW METHODS\n', '\n', '    function isApproveOnly() view returns (bool);\n', '    function getLastOrderId(address onExchange) view returns (uint);\n', '    function isActive(address onExchange, uint id) view returns (bool);\n', '    function getOwner(address onExchange, uint id) view returns (address);\n', '    function getOrder(address onExchange, uint id) view returns (address, address, uint, uint);\n', '    function getTimestamp(address onExchange, uint id) view returns (uint);\n', '\n', '}\n', '\n', 'interface PriceFeedInterface {\n', '\n', '    // EVENTS\n', '\n', '    event PriceUpdated(uint timestamp);\n', '\n', '    // PUBLIC METHODS\n', '\n', '    function update(address[] ofAssets, uint[] newPrices);\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    // Get asset specific information\n', '    function getName(address ofAsset) view returns (string);\n', '    function getSymbol(address ofAsset) view returns (string);\n', '    function getDecimals(address ofAsset) view returns (uint);\n', '    // Get price feed operation specific information\n', '    function getQuoteAsset() view returns (address);\n', '    function getInterval() view returns (uint);\n', '    function getValidity() view returns (uint);\n', '    function getLastUpdateId() view returns (uint);\n', '    // Get asset specific information as updated in price feed\n', '    function hasRecentPrice(address ofAsset) view returns (bool isRecent);\n', '    function hasRecentPrices(address[] ofAssets) view returns (bool areRecent);\n', '    function getPrice(address ofAsset) view returns (bool isRecent, uint price, uint decimal);\n', '    function getPrices(address[] ofAssets) view returns (bool areRecent, uint[] prices, uint[] decimals);\n', '    function getInvertedPrice(address ofAsset) view returns (bool isRecent, uint invertedPrice, uint decimal);\n', '    function getReferencePrice(address ofBase, address ofQuote) view returns (bool isRecent, uint referencePrice, uint decimal);\n', '    function getOrderPrice(\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    ) view returns (uint orderPrice);\n', '    function existsPriceOnAssetPair(address sellAsset, address buyAsset) view returns (bool isExistent);\n', '}\n', '\n', 'interface RiskMgmtInterface {\n', '\n', '    // METHODS\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @notice Checks if the makeOrder price is reasonable and not manipulative\n', '    /// @param orderPrice Price of Order\n', '    /// @param referencePrice Reference price obtained through PriceFeed contract\n', '    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\n', '    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\n', '    /// @param sellQuantity Quantity of sellAsset to be sold\n', '    /// @param buyQuantity Quantity of buyAsset to be bought\n', '    /// @return If makeOrder is permitted\n', '    function isMakePermitted(\n', '        uint orderPrice,\n', '        uint referencePrice,\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    ) view returns (bool);\n', '\n', '    /// @notice Checks if the takeOrder price is reasonable and not manipulative\n', '    /// @param orderPrice Price of Order\n', '    /// @param referencePrice Reference price obtained through PriceFeed contract\n', '    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\n', '    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\n', '    /// @param sellQuantity Quantity of sellAsset to be sold\n', '    /// @param buyQuantity Quantity of buyAsset to be bought\n', '    /// @return If takeOrder is permitted\n', '    function isTakePermitted(\n', '        uint orderPrice,\n', '        uint referencePrice,\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    ) view returns (bool);\n', '}\n', '\n', 'interface VersionInterface {\n', '\n', '    // EVENTS\n', '\n', '    event FundUpdated(uint id);\n', '\n', '    // PUBLIC METHODS\n', '\n', '    function shutDown() external;\n', '\n', '    function setupFund(\n', '        string ofFundName,\n', '        address ofQuoteAsset,\n', '        uint ofManagementFee,\n', '        uint ofPerformanceFee,\n', '        address ofCompliance,\n', '        address ofRiskMgmt,\n', '        address ofPriceFeed,\n', '        address[] ofExchanges,\n', '        address[] ofExchangeAdapters,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    );\n', '    function shutDownFund(address ofFund);\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    function getNativeAsset() view returns (address);\n', '    function getFundById(uint withId) view returns (address);\n', '    function getLastFundId() view returns (uint);\n', '    function getFundByManager(address ofManager) view returns (address);\n', '    function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed);\n', '\n', '}\n', '\n', 'contract Version is DBC, Owned, VersionInterface {\n', '    // FIELDS\n', '\n', '    // Constant fields\n', '    bytes32 public constant TERMS_AND_CONDITIONS = 0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad; // Hashed terms and conditions as displayed on IPFS.\n', '    // Constructor fields\n', '    string public VERSION_NUMBER; // SemVer of Melon protocol version\n', '    address public NATIVE_ASSET; // Address of wrapped native asset contract\n', '    address public GOVERNANCE; // Address of Melon protocol governance contract\n', '    // Methods fields\n', '    bool public isShutDown; // Governance feature, if yes than setupFund gets blocked and shutDownFund gets opened\n', '    address[] public listOfFunds; // A complete list of fund addresses created using this version\n', '    mapping (address => address) public managerToFunds; // Links manager address to fund address created using this version\n', '\n', '    // EVENTS\n', '\n', '    event FundUpdated(address ofFund);\n', '\n', '    // METHODS\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @param versionNumber SemVer of Melon protocol version\n', '    /// @param ofGovernance Address of Melon governance contract\n', '    /// @param ofNativeAsset Address of wrapped native asset contract\n', '    function Version(\n', '        string versionNumber,\n', '        address ofGovernance,\n', '        address ofNativeAsset\n', '    ) {\n', '        VERSION_NUMBER = versionNumber;\n', '        GOVERNANCE = ofGovernance;\n', '        NATIVE_ASSET = ofNativeAsset;\n', '    }\n', '\n', '    // EXTERNAL METHODS\n', '\n', '    function shutDown() external pre_cond(msg.sender == GOVERNANCE) { isShutDown = true; }\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /// @param ofFundName human-readable descriptive name (not necessarily unique)\n', '    /// @param ofQuoteAsset Asset against which performance fee is measured against\n', '    /// @param ofManagementFee A time based fee, given in a number which is divided by 10 ** 15\n', '    /// @param ofPerformanceFee A time performance based fee, performance relative to ofQuoteAsset, given in a number which is divided by 10 ** 15\n', '    /// @param ofCompliance Address of participation module\n', '    /// @param ofRiskMgmt Address of risk management module\n', '    /// @param ofPriceFeed Address of price feed module\n', '    /// @param ofExchanges Addresses of exchange on which this fund can trade\n', '    /// @param ofExchangeAdapters Addresses of exchange adapters\n', '    /// @param v ellipitc curve parameter v\n', '    /// @param r ellipitc curve parameter r\n', '    /// @param s ellipitc curve parameter s\n', '    function setupFund(\n', '        string ofFundName,\n', '        address ofQuoteAsset,\n', '        uint ofManagementFee,\n', '        uint ofPerformanceFee,\n', '        address ofCompliance,\n', '        address ofRiskMgmt,\n', '        address ofPriceFeed,\n', '        address[] ofExchanges,\n', '        address[] ofExchangeAdapters,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) {\n', '        require(!isShutDown);\n', '        require(termsAndConditionsAreSigned(v, r, s));\n', '        // Either novel fund name or previous owner of fund name\n', '        require(managerToFunds[msg.sender] == 0); // Add limitation for simpler migration process of shutting down and setting up fund\n', '        address ofFund = new Fund(\n', '            msg.sender,\n', '            ofFundName,\n', '            ofQuoteAsset,\n', '            ofManagementFee,\n', '            ofPerformanceFee,\n', '            NATIVE_ASSET,\n', '            ofCompliance,\n', '            ofRiskMgmt,\n', '            ofPriceFeed,\n', '            ofExchanges,\n', '            ofExchangeAdapters\n', '        );\n', '        listOfFunds.push(ofFund);\n', '        managerToFunds[msg.sender] = ofFund;\n', '        FundUpdated(ofFund);\n', '    }\n', '\n', '    /// @dev Dereference Fund and trigger selfdestruct\n', '    /// @param ofFund Address of the fund to be shut down\n', '    function shutDownFund(address ofFund)\n', '        pre_cond(isShutDown || managerToFunds[msg.sender] == ofFund)\n', '    {\n', '        Fund fund = Fund(ofFund);\n', '        delete managerToFunds[msg.sender];\n', '        fund.shutDown();\n', '        FundUpdated(ofFund);\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @dev Proof that terms and conditions have been read and understood\n', '    /// @param v ellipitc curve parameter v\n', '    /// @param r ellipitc curve parameter r\n', '    /// @param s ellipitc curve parameter s\n', '    /// @return signed Whether or not terms and conditions have been read and understood\n', '    function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed) {\n', '        return ecrecover(\n', '            // Parity does prepend \\x19Ethereum Signed Message:\\n{len(message)} before signing.\n', '            //  Signature order has also been changed in 1.6.7 and upcoming 1.7.x,\n', '            //  it will return rsv (same as geth; where v is [27, 28]).\n', '            // Note that if you are using ecrecover, v will be either "00" or "01".\n', '            //  As a result, in order to use this value, you will have to parse it to an\n', '            //  integer and then add 27. This will result in either a 27 or a 28.\n', '            //  https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethsign\n', '            keccak256("\\x19Ethereum Signed Message:\\n32", TERMS_AND_CONDITIONS),\n', '            v,\n', '            r,\n', '            s\n', '        ) == msg.sender; // Has sender signed TERMS_AND_CONDITIONS\n', '    }\n', '\n', '    function getNativeAsset() view returns (address) { return NATIVE_ASSET; }\n', '    function getFundById(uint withId) view returns (address) { return listOfFunds[withId]; }\n', '    function getLastFundId() view returns (uint) { return listOfFunds.length - 1; }\n', '    function getFundByManager(address ofManager) view returns (address) { return managerToFunds[ofManager]; }\n', '}']