['pragma solidity ^0.4.24;\n', '\n', 'contract Owned\n', '{\n', '  address internal owner;\n', '  address private manager;\n', '  address internal sink;\n', '\n', '  constructor() public\n', '  {\n', '    owner = msg.sender;\n', '    manager = msg.sender;\n', '    sink = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner\n', '  {\n', '    require(msg.sender == owner, "Contract owner is required");\n', '    _;\n', '  }\n', '\n', '  modifier onlyManager\n', '  {\n', '    require(msg.sender == manager, "Contract manager is required");\n', '    _;\n', '  }\n', '\n', '  modifier onlyManagerNUser(address user)\n', '  {\n', '    require(msg.sender == manager || msg.sender == user, "Contract manager or wallet owner is required");\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner, address newManager, address newSink) onlyOwner public\n', '  {\n', '    owner = newOwner;\n', '    manager = newManager;\n', '    sink = newSink;\n', '  }\n', '}\n', '\n', '/*\n', 'interface tokenRecipient\n', '{\n', '  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '*/\n', '\n', 'contract SupplyInfo\n', '{\n', '  string public name;\n', '  string public symbol;\n', '  uint8 constant public decimals = 18;\n', '  uint256 constant internal denominator = 10 ** uint256(decimals);\n', '  uint256 public totalSupply;\n', '\n', '  constructor(\n', '      uint256 initialSupply,\n', '      string tokenName,\n', '      string tokenSymbol\n', '  )\n', '    public\n', '  {\n', '    totalSupply = initialSupply * denominator;\n', '    name = tokenName;\n', '    symbol = tokenSymbol;\n', '  }\n', '}\n', '\n', 'contract Transferable\n', '{\n', '  mapping (address => uint256) public balanceOf;\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  function _transferTokens(address _from, address _to, uint _value) internal\n', '  {\n', '    require(balanceOf[_from] >= _value, "Not enough funds");\n', '    require(balanceOf[_to] + _value >= balanceOf[_to], "BufferOverflow on receiver side");\n', '\n', '    // uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '\n', '    balanceOf[_from] -= _value;\n', '    balanceOf[_to] += _value;\n', '    emit Transfer(_from, _to, _value);\n', '\n', '    // assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool success)\n', '  {\n', '    _transferTokens(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '}\n', '\n', '\n', 'contract ERC20 is SupplyInfo, Transferable\n', '{\n', '  constructor(\n', '      uint256 initialSupply,\n', '      string tokenName,\n', '      string tokenSymbol\n', '  ) SupplyInfo(initialSupply, tokenName, tokenSymbol)\n', '    public\n', '  {\n', '    balanceOf[this] = totalSupply;\n', '  }\n', '}\n', '\n', 'contract Manageable is Transferable, Owned {\n', '  event Deposit(\n', '      address indexed _from,\n', '      // bytes32 indexed _id,\n', '      uint _value,\n', '      string comment\n', '  );\n', '\n', '  event Withdraw(\n', '      address indexed _to,\n', '      uint _value,\n', '      string comment\n', '  );\n', '\n', '  // function deposit(bytes32 _id) public payable {\n', '  function deposit(string comment) public payable {\n', '    emit Deposit(msg.sender, msg.value, comment);\n', '  }\n', '\n', '  function withdraw(uint256 amount, string comment) onlyOwner public {\n', '    _transferEther(sink, amount);\n', '    emit Withdraw(sink, amount, comment);\n', '  }\n', '\n', '  function _transferEther(address _to, uint _value) internal {\n', '    address contractAddress = this;\n', '    require(contractAddress.balance >= _value);\n', '    _to.transfer(_value);\n', '  }\n', '}\n', '\n', 'contract Tradeable is ERC20, Manageable {\n', '\n', '\n', '  event Buy(address indexed who, uint256 amount, uint256 buyPrice, string comment);\n', '  event Sell(address indexed who, uint256 amount, uint256 sellPrice, string comment);\n', '\n', '  function _convertEtherToToken(uint256 etherAmount, uint256 buyPrice) pure internal returns (uint256) {\n', '    require(buyPrice > 0, "Buy price cant be zero");\n', '\n', '    // BufferOverflow just in case\n', '    require(etherAmount * denominator > etherAmount, "BufferOverflow");\n', '    uint256 tokenAmount = etherAmount * denominator / buyPrice;\n', '\n', '    return tokenAmount;\n', '  }\n', '\n', '  function _convertTokenToEther(uint256 tokenAmount, uint256 sellPrice) pure internal returns (uint256) {\n', '    require(sellPrice > 0, "Sell price cant be zero");\n', '\n', '    // BufferOverflow just in case\n', '    require(tokenAmount * sellPrice > tokenAmount, "BufferOverflow");\n', '    uint256 etherAmount = tokenAmount * sellPrice / denominator;\n', '    return etherAmount;\n', '  }\n', '\n', '  function _buy(uint256 etherAmount, uint256 buyPrice, string comment) internal {\n', '    require(etherAmount > 0, "Ether amount cant be zero");\n', '    uint256 tokenAmount = _convertEtherToToken(etherAmount, buyPrice);\n', '\n', '    // At this point transaction is accepted, just send tokens in return\n', '    _transferTokens(this, msg.sender, tokenAmount);\n', '    _transferEther(sink, etherAmount);\n', '    emit Buy(msg.sender, tokenAmount, buyPrice, comment);\n', '  }\n', '\n', '  function _sell(uint256 tokenAmount, uint256 sellPrice, string comment) internal {\n', '    uint256 etherAmount = _convertTokenToEther(tokenAmount, sellPrice);\n', '    require(etherAmount > 0, "Ether amount after convert become zero - reverting"); // makes no sense otherwise\n', '\n', '    _transferTokens(msg.sender, this, tokenAmount);\n', '    _transferEther(msg.sender, tokenAmount);\n', '    emit Sell(msg.sender, tokenAmount,sellPrice, comment);\n', '  }\n', '}\n', '\n', 'contract FrezeeableAccounts is Transferable, Owned {\n', '  mapping (address => bool) internal frozenAccount;\n', '  /* This generates a public event  on the blockchain that will notify clients */\n', '  event FrozenFunds(address indexed target, bool indexed frozen);\n', '\n', '  modifier notFrozen(address target)\n', '  {\n', '    require(!frozenAccount[target], "Account is frozen");\n', '    _;\n', '  }\n', '\n', '  function freezeAccount(address target, bool freeze) onlyManager public {\n', '    frozenAccount[target] = freeze;\n', '    emit FrozenFunds(target, freeze);\n', '  }\n', '\n', '  function iamFrozen() view public returns(bool isFrozen)\n', '  {\n', '    return frozenAccount[msg.sender];\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) public notFrozen(msg.sender) notFrozen(_to) returns (bool success)\n', '  {\n', '    return super.transfer(_to, _value);\n', '  }\n', '}\n', '\n', 'contract Destructable is Owned {\n', '  event Destruct(string indexed comment);\n', '\n', '  function destruct(string comment) onlyOwner public {\n', '    selfdestruct(owner);\n', '    emit Destruct(comment);\n', '  }\n', '}\n', '\n', 'contract CoeficientTransform is SupplyInfo\n', '{\n', '  function applyChange(uint256 currentCoeficient, uint256 value) pure internal returns(uint256)\n', '  {\n', '    return currentCoeficient * value / denominator;\n', '  }\n', '\n', '  function deduceChange(uint256 currentCoeficient, uint256 value) pure internal returns(uint256)\n', '  {\n', '    require(value > 0, "Cant deduce zero change");\n', '    uint256 opposite = denominator * denominator / value;\n', '    return applyChange(currentCoeficient, opposite);\n', '  }\n', '}\n', '\n', 'contract DayCounter\n', '{\n', '  uint private DayZero;\n', '  uint internal constant SecondsInDay = 60 * 60 * 24;\n', '\n', '  constructor(uint ZeroDayTimestamp) public\n', '  {\n', '    DayZero = ZeroDayTimestamp;\n', '  }\n', '\n', '  function daysSince(uint a, uint b) pure internal returns(uint)\n', '  {\n', '    return (b - a) / SecondsInDay;\n', '  }\n', '\n', '  function DaysPast() view public returns(uint)\n', '  {\n', '    return daysSince(DayZero, now);\n', '  }\n', '}\n', '\n', 'contract InvestmentTransform is CoeficientTransform, DayCounter\n', '{\n', '  uint constant private percentsPerDay = 3;\n', '\n', '  function currentRoiInPersents() view public returns(uint)\n', '  {\n', '    uint currentPercents = percentsPerDay * DaysPast();\n', '    return 100 + currentPercents;\n', '  }\n', '\n', '  function investmentRate(uint256 currentCoeficient) view internal returns(uint256)\n', '  {\n', '    uint256 dailyMultiply = denominator * currentRoiInPersents() / 100;\n', '    return applyChange(currentCoeficient, dailyMultiply);\n', '  }\n', '}\n', '\n', 'contract LinkedToFiatTransform is CoeficientTransform, Owned\n', '{\n', '  uint256 public fiatDriftAncor;\n', '  uint256 public etherToFiatRate;\n', '\n', '  event FiatLink(uint256 ancorDrift, uint exchangeRate);\n', '\n', '  function setFiatLinkedCoef(uint256 newAncor, uint256 newRate) public onlyManager {\n', '    require(newAncor > 0 && newRate > 0, "Coeficients cant be zero");\n', '    fiatDriftAncor = newAncor;\n', '    etherToFiatRate = newRate;\n', '    emit FiatLink(newAncor, newRate);\n', '  }\n', '\n', '  function fiatDrift(uint256 currentCoeficient) view internal returns(uint256)\n', '  {\n', '    return applyChange(currentCoeficient, fiatDriftAncor);\n', '  }\n', '\n', '  function FiatToEther(uint256 amount) view internal returns(uint256)\n', '  {\n', '    return deduceChange(amount, etherToFiatRate);\n', '  }\n', '\n', '  function EtherToFiat(uint256 amount) view internal returns(uint256)\n', '  {\n', '    return applyChange(amount, etherToFiatRate);\n', '  }\n', '}\n', '\n', 'contract StartStopSell is CoeficientTransform, Owned\n', '{\n', '  bool internal buyAvailable = false;\n', '  bool internal sellAvailable = false;\n', '\n', '  function updateBuySellFlags(bool allowBuy, bool allowSell) public onlyManager\n', '  {\n', '    buyAvailable = allowBuy;\n', '    sellAvailable = allowSell;\n', '  }\n', '\n', '  modifier canBuy()\n', '  {\n', '    require(buyAvailable, "Buy currently disabled");\n', '    _;\n', '  }\n', '\n', '  modifier canSell()\n', '  {\n', '    require(sellAvailable, "Sell currently disabled");\n', '    _;\n', '  }\n', '}\n', '\n', 'contract LISCTrade is FrezeeableAccounts, Tradeable, LinkedToFiatTransform, InvestmentTransform, StartStopSell\n', '{\n', '  uint256 internal baseFiatPrice;\n', '  uint256 public minBuyAmount;\n', '\n', '  constructor(uint256 basePrice) public\n', '  {\n', '    baseFiatPrice = basePrice;\n', '  }\n', '\n', '  function setMinTrade(uint256 _minBuyAmount) onlyManager public\n', '  {\n', '    minBuyAmount = _minBuyAmount;\n', '  }\n', '\n', '  function priceInUSD() view public returns(uint256)\n', '  {\n', '    uint256 price = baseFiatPrice;\n', '    price = fiatDrift(price);\n', '    price = investmentRate(price);\n', '    require(price > 0, "USD price cant be zero");\n', '    return price;\n', '  }\n', '\n', '  function priceInETH() view public returns(uint256)\n', '  {\n', '    return FiatToEther(priceInUSD());\n', '  }\n', '\n', '  function tokensPerETH() view public returns(uint256)\n', '  {\n', '    uint256 EthPerToken = priceInETH();\n', '    return deduceChange(denominator, EthPerToken);\n', '  }\n', '\n', '  function buy(string comment) payable public canBuy notFrozen(msg.sender)\n', '  {\n', '    uint256 USDAmount = EtherToFiat(msg.value);\n', '    require(USDAmount > minBuyAmount, "You cant buy lesser than min USD amount");\n', '    _buy(msg.value, priceInETH(), comment);\n', '  }\n', '\n', '  function sell(uint256 tokenAmount, string comment) public canSell notFrozen(msg.sender)\n', '  {\n', '    _sell(tokenAmount, priceInETH(), comment);\n', '  }\n', '}\n', '\n', '\n', 'contract MintNBurn is ERC20\n', '{\n', '  event Mint(address indexed target, uint256 mintedAmount, string comment);\n', '  event Burn(address indexed target, uint256 mintedAmount, string comment);\n', '\n', '\n', '  function mintToken(address target, uint256 mintedAmount, string comment) internal\n', '  {\n', '    balanceOf[this] += mintedAmount;\n', '    totalSupply += mintedAmount;\n', '\n', '    _transferTokens(this, target, mintedAmount);\n', '    emit Mint(target, mintedAmount, comment);\n', '  }\n', '\n', '  function burnToken(address target, uint256 amount, string comment) internal\n', '  {\n', '    _transferTokens(msg.sender, this, amount);\n', '    balanceOf[this] -= amount;\n', '    totalSupply -= amount;\n', '    emit Burn(target, amount, comment);\n', '  }\n', '}\n', '\n', 'contract Upgradeable is MintNBurn, Owned\n', '{\n', '  address private prevVersion;\n', '  address private newVersion = 0x0;\n', '  mapping (address => bool) public upgraded;\n', '\n', '  constructor(address upgradeFrom) internal {\n', '    prevVersion = upgradeFrom;\n', '  }\n', '\n', '  function setUpgradeTo(address upgradeTo) public onlyOwner {\n', '    newVersion = upgradeTo;\n', '  }\n', '\n', '  function upgradeAvalable() view public returns(bool) {\n', '    return newVersion != 0x0;\n', '  }\n', '\n', '  function upgradeMe() public {\n', '    upgradeUser(msg.sender);\n', '  }\n', '\n', '  function upgradeUser(address target) public onlyManagerNUser(target)\n', '  {\n', '    require(upgradeAvalable(), "New version not yet available");\n', '    Upgradeable newContract = Upgradeable(newVersion);\n', '    require(!newContract.upgraded(target), "Your account already been upgraded");\n', '    newContract.importUser(target);\n', '    burnToken(target, balanceOf[target], "Upgrading to new version");\n', '  }\n', '\n', '  function importMe() public {\n', '    importUser(msg.sender);\n', '  }\n', '\n', '  function importUser(address target) onlyManager public\n', '  {\n', '    require(!upgraded[target], "Account already been upgraded");\n', '    upgraded[target] = true;\n', '    Transferable oldContract = Transferable(prevVersion);\n', '    uint256 amount = oldContract.balanceOf(target);\n', '    mintToken(target, amount, "Upgrade from previous version");\n', '  }\n', '}\n', '\n', 'contract TOKEN is ERC20, Owned, Destructable, LISCTrade, Upgradeable  {\n', '\n', '  event Init(uint256 basePrice, uint dayZero);\n', '\n', '  constructor(\n', '      string tokenName,\n', '      string tokenSymbol,\n', '      uint basePrice,\n', '      uint dayZero\n', '  ) ERC20(0, tokenName, tokenSymbol) DayCounter(dayZero) LISCTrade(basePrice * denominator) Upgradeable(0x0) public\n', '  {\n', '    emit Init(basePrice, dayZero);\n', '  }\n', '\n', '  event Mint(address indexed target, uint256 mintedAmount, string comment);\n', '\n', '  function mint(address target, uint256 mintedAmount, string comment) onlyOwner public {\n', '    mintedAmount *= denominator;\n', '    mintToken(target, mintedAmount, comment);\n', '  }\n', '\n', '  function burn(uint256 amount, string comment) private\n', '  {\n', '    burnToken(msg.sender, amount, comment);\n', '  }\n', '\n', '  function balance() view public returns(uint256)\n', '  {\n', '    return balanceOf[msg.sender];\n', '  }\n', '\n', '  event Broadcast(string message);\n', '\n', '  function broadcast(string _message) public onlyManager\n', '  {\n', '    emit Broadcast(_message);\n', '  }\n', '\n', '\n', '}']