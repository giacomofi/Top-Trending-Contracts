['pragma solidity 0.4.21;\n', '\n', '// File: contracts/land/LANDStorage.sol\n', '\n', 'contract LANDStorage {\n', '\n', '  mapping (address => uint) public latestPing;\n', '\n', '  uint256 constant clearLow = 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000;\n', '  uint256 constant clearHigh = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\n', '  uint256 constant factor = 0x100000000000000000000000000000000;\n', '\n', '  mapping (address => bool) public authorizedDeploy;\n', '\n', '  mapping (uint256 => address) public updateOperator;\n', '}\n', '\n', '// File: contracts/upgradable/OwnableStorage.sol\n', '\n', 'contract OwnableStorage {\n', '\n', '  address public owner;\n', '\n', '  function OwnableStorage() internal {\n', '    owner = msg.sender;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/upgradable/ProxyStorage.sol\n', '\n', 'contract ProxyStorage {\n', '\n', '  /**\n', '   * Current contract to which we are proxing\n', '   */\n', '  address public currentContract;\n', '  address public proxyOwner;\n', '}\n', '\n', '// File: erc821/contracts/AssetRegistryStorage.sol\n', '\n', 'contract AssetRegistryStorage {\n', '\n', '  string internal _name;\n', '  string internal _symbol;\n', '  string internal _description;\n', '\n', '  /**\n', '   * Stores the total count of assets managed by this registry\n', '   */\n', '  uint256 internal _count;\n', '\n', '  /**\n', '   * Stores an array of assets owned by a given account\n', '   */\n', '  mapping(address => uint256[]) internal _assetsOf;\n', '\n', '  /**\n', '   * Stores the current holder of an asset\n', '   */\n', '  mapping(uint256 => address) internal _holderOf;\n', '\n', '  /**\n', '   * Stores the index of an asset in the `_assetsOf` array of its holder\n', '   */\n', '  mapping(uint256 => uint256) internal _indexOfAsset;\n', '\n', '  /**\n', '   * Stores the data associated with an asset\n', '   */\n', '  mapping(uint256 => string) internal _assetData;\n', '\n', '  /**\n', '   * For a given account, for a given operator, store whether that operator is\n', '   * allowed to transfer and modify assets on behalf of them.\n', '   */\n', '  mapping(address => mapping(address => bool)) internal _operators;\n', '\n', '  /**\n', '   * Approval array\n', '   */\n', '  mapping(uint256 => address) internal _approval;\n', '}\n', '\n', '// File: contracts/Storage.sol\n', '\n', 'contract Storage is ProxyStorage, OwnableStorage, AssetRegistryStorage, LANDStorage {\n', '}\n', '\n', '// File: contracts/upgradable/IApplication.sol\n', '\n', 'contract IApplication {\n', '  function initialize(bytes data) public;\n', '}\n', '\n', '// File: contracts/upgradable/Ownable.sol\n', '\n', 'contract Ownable is Storage {\n', '\n', '  event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '  function bytesToAddress (bytes b) pure public returns (address) {\n', '    uint result = 0;\n', '    for (uint i = b.length-1; i+1 > 0; i--) {\n', '      uint c = uint(b[i]);\n', '      uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\n', '      result += to_inc;\n', '    }\n', '    return address(result);\n', '  }\n', '\n', '  modifier onlyOwner {\n', '    assert(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != owner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/land/ILANDRegistry.sol\n', '\n', 'interface ILANDRegistry {\n', '\n', '  // LAND can be assigned by the owner\n', '  function assignNewParcel(int x, int y, address beneficiary) public;\n', '  function assignMultipleParcels(int[] x, int[] y, address beneficiary) public;\n', '\n', '  // After one year, land can be claimed from an inactive public key\n', '  function ping() public;\n', '\n', '  // LAND-centric getters\n', '  function encodeTokenId(int x, int y) view public returns (uint256);\n', '  function decodeTokenId(uint value) view public returns (int, int);\n', '  function exists(int x, int y) view public returns (bool);\n', '  function ownerOfLand(int x, int y) view public returns (address);\n', '  function ownerOfLandMany(int[] x, int[] y) view public returns (address[]);\n', '  function landOf(address owner) view public returns (int[], int[]);\n', '  function landData(int x, int y) view public returns (string);\n', '\n', '  // Transfer LAND\n', '  function transferLand(int x, int y, address to) public;\n', '  function transferManyLand(int[] x, int[] y, address to) public;\n', '\n', '  // Update LAND\n', '  function updateLandData(int x, int y, string data) public;\n', '  function updateManyLandData(int[] x, int[] y, string data) public;\n', '\n', '  // Events\n', '\n', '  event Update(  \n', '    uint256 indexed assetId, \n', '    address indexed holder,  \n', '    address indexed operator,  \n', '    string data  \n', '  );\n', '}\n', '\n', '// File: erc821/contracts/IERC721Base.sol\n', '\n', 'interface IERC721Base {\n', '  function totalSupply() public view returns (uint256);\n', '\n', '  // function exists(uint256 assetId) public view returns (bool);\n', '  function ownerOf(uint256 assetId) public view returns (address);\n', '\n', '  function balanceOf(address holder) public view returns (uint256);\n', '\n', '  function safeTransferFrom(address from, address to, uint256 assetId) public;\n', '  function safeTransferFrom(address from, address to, uint256 assetId, bytes userData) public;\n', '\n', '  function transferFrom(address from, address to, uint256 assetId) public;\n', '\n', '  function approve(address operator, uint256 assetId) public;\n', '  function setApprovalForAll(address operator, bool authorized) public;\n', '\n', '  function getApprovedAddress(uint256 assetId) public view returns (address);\n', '  function isApprovedForAll(address operator, address assetOwner) public view returns (bool);\n', '\n', '  function isAuthorized(address operator, uint256 assetId) public view returns (bool);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 indexed assetId,\n', '    address operator,\n', '    bytes userData\n', '  );\n', '  event ApprovalForAll(\n', '    address indexed operator,\n', '    address indexed holder,\n', '    bool authorized\n', '  );\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed operator,\n', '    uint256 indexed assetId\n', '  );\n', '}\n', '\n', '// File: erc821/contracts/IERC721Receiver.sol\n', '\n', 'interface IERC721Receiver {\n', '  function onERC721Received(\n', '    uint256 _tokenId,\n', '    address _oldOwner,\n', '    bytes   _userData\n', '  ) public returns (bytes4);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: erc821/contracts/ERC721Base.sol\n', '\n', 'interface ERC165 {\n', '  function supportsInterface(bytes4 interfaceID) public view returns (bool);\n', '}\n', '\n', 'contract ERC721Base is AssetRegistryStorage, IERC721Base, ERC165 {\n', '  using SafeMath for uint256;\n', '\n', '  //\n', '  // Global Getters\n', '  //\n', '\n', '  /**\n', '   * @dev Gets the total amount of assets stored by the contract\n', '   * @return uint256 representing the total amount of assets\n', '   */\n', '  function totalSupply() public view returns (uint256) {\n', '    return _count;\n', '  }\n', '\n', '  //\n', '  // Asset-centric getter functions\n', '  //\n', '\n', '  /**\n', '   * @dev Queries what address owns an asset. This method does not throw.\n', '   * In order to check if the asset exists, use the `exists` function or check if the\n', '   * return value of this call is `0`.\n', '   * @return uint256 the assetId\n', '   */\n', '  function ownerOf(uint256 assetId) public view returns (address) {\n', '    return _holderOf[assetId];\n', '  }\n', '\n', '  //\n', '  // Holder-centric getter functions\n', '  //\n', '  /**\n', '   * @dev Gets the balance of the specified address\n', '   * @param owner address to query the balance of\n', '   * @return uint256 representing the amount owned by the passed address\n', '   */\n', '  function balanceOf(address owner) public view returns (uint256) {\n', '    return _assetsOf[owner].length;\n', '  }\n', '\n', '  //\n', '  // Authorization getters\n', '  //\n', '\n', '  /**\n', '   * @dev Query whether an address has been authorized to move any assets on behalf of someone else\n', '   * @param operator the address that might be authorized\n', '   * @param assetHolder the address that provided the authorization\n', '   * @return bool true if the operator has been authorized to move any assets\n', '   */\n', '  function isApprovedForAll(address operator, address assetHolder)\n', '    public view returns (bool)\n', '  {\n', '    return _operators[assetHolder][operator];\n', '  }\n', '\n', '  /**\n', '   * @dev Query what address has been particularly authorized to move an asset\n', '   * @param assetId the asset to be queried for\n', '   * @return bool true if the asset has been approved by the holder\n', '   */\n', '  function getApprovedAddress(uint256 assetId) public view returns (address) {\n', '    return _approval[assetId];\n', '  }\n', '\n', '  /**\n', '   * @dev Query if an operator can move an asset.\n', '   * @param operator the address that might be authorized\n', '   * @param assetId the asset that has been `approved` for transfer\n', '   * @return bool true if the asset has been approved by the holder\n', '   */\n', '  function isAuthorized(address operator, uint256 assetId)\n', '    public view returns (bool)\n', '  {\n', '    require(operator != 0);\n', '    address owner = ownerOf(assetId);\n', '    if (operator == owner) {\n', '      return true;\n', '    }\n', '    return isApprovedForAll(operator, owner) || getApprovedAddress(assetId) == operator;\n', '  }\n', '\n', '  //\n', '  // Authorization\n', '  //\n', '\n', '  /**\n', '   * @dev Authorize a third party operator to manage (send) msg.sender&#39;s asset\n', '   * @param operator address to be approved\n', '   * @param authorized bool set to true to authorize, false to withdraw authorization\n', '   */\n', '  function setApprovalForAll(address operator, bool authorized) public {\n', '    if (authorized) {\n', '      require(!isApprovedForAll(operator, msg.sender));\n', '      _addAuthorization(operator, msg.sender);\n', '    } else {\n', '      require(isApprovedForAll(operator, msg.sender));\n', '      _clearAuthorization(operator, msg.sender);\n', '    }\n', '    ApprovalForAll(operator, msg.sender, authorized);\n', '  }\n', '\n', '  /**\n', '   * @dev Authorize a third party operator to manage one particular asset\n', '   * @param operator address to be approved\n', '   * @param assetId asset to approve\n', '   */\n', '  function approve(address operator, uint256 assetId) public {\n', '    address holder = ownerOf(assetId);\n', '    require(operator != holder);\n', '    if (getApprovedAddress(assetId) != operator) {\n', '      _approval[assetId] = operator;\n', '      Approval(holder, operator, assetId);\n', '    }\n', '  }\n', '\n', '  function _addAuthorization(address operator, address holder) private {\n', '    _operators[holder][operator] = true;\n', '  }\n', '\n', '  function _clearAuthorization(address operator, address holder) private {\n', '    _operators[holder][operator] = false;\n', '  }\n', '\n', '  //\n', '  // Internal Operations\n', '  //\n', '\n', '  function _addAssetTo(address to, uint256 assetId) internal {\n', '    _holderOf[assetId] = to;\n', '\n', '    uint256 length = balanceOf(to);\n', '\n', '    _assetsOf[to].push(assetId);\n', '\n', '    _indexOfAsset[assetId] = length;\n', '\n', '    _count = _count.add(1);\n', '  }\n', '\n', '  function _removeAssetFrom(address from, uint256 assetId) internal {\n', '    uint256 assetIndex = _indexOfAsset[assetId];\n', '    uint256 lastAssetIndex = balanceOf(from).sub(1);\n', '    uint256 lastAssetId = _assetsOf[from][lastAssetIndex];\n', '\n', '    _holderOf[assetId] = 0;\n', '\n', '    // Insert the last asset into the position previously occupied by the asset to be removed\n', '    _assetsOf[from][assetIndex] = lastAssetId;\n', '\n', '    // Resize the array\n', '    _assetsOf[from][lastAssetIndex] = 0;\n', '    _assetsOf[from].length--;\n', '\n', '    // Remove the array if no more assets are owned to prevent pollution\n', '    if (_assetsOf[from].length == 0) {\n', '      delete _assetsOf[from];\n', '    }\n', '\n', '    // Update the index of positions for the asset\n', '    _indexOfAsset[assetId] = 0;\n', '    _indexOfAsset[lastAssetId] = assetIndex;\n', '\n', '    _count = _count.sub(1);\n', '  }\n', '\n', '  function _clearApproval(address holder, uint256 assetId) internal {\n', '    if (ownerOf(assetId) == holder && _approval[assetId] != 0) {\n', '      _approval[assetId] = 0;\n', '      Approval(holder, 0, assetId);\n', '    }\n', '  }\n', '\n', '  //\n', '  // Supply-altering functions\n', '  //\n', '\n', '  function _generate(uint256 assetId, address beneficiary) internal {\n', '    require(_holderOf[assetId] == 0);\n', '\n', '    _addAssetTo(beneficiary, assetId);\n', '\n', '    Transfer(0, beneficiary, assetId, msg.sender, &#39;&#39;);\n', '  }\n', '\n', '  function _destroy(uint256 assetId) internal {\n', '    address holder = _holderOf[assetId];\n', '    require(holder != 0);\n', '\n', '    _removeAssetFrom(holder, assetId);\n', '\n', '    Transfer(holder, 0, assetId, msg.sender, &#39;&#39;);\n', '  }\n', '\n', '  //\n', '  // Transaction related operations\n', '  //\n', '\n', '  modifier onlyHolder(uint256 assetId) {\n', '    require(_holderOf[assetId] == msg.sender);\n', '    _;\n', '  }\n', '\n', '  modifier onlyAuthorized(uint256 assetId) {\n', '    require(isAuthorized(msg.sender, assetId));\n', '    _;\n', '  }\n', '\n', '  modifier isCurrentOwner(address from, uint256 assetId) {\n', '    require(_holderOf[assetId] == from);\n', '    _;\n', '  }\n', '\n', '  modifier isDestinataryDefined(address destinatary) {\n', '    require(destinatary != 0);\n', '    _;\n', '  }\n', '\n', '  modifier destinataryIsNotHolder(uint256 assetId, address to) {\n', '    require(_holderOf[assetId] != to);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Alias of `safeTransferFrom(from, to, assetId, &#39;&#39;)`\n', '   *\n', '   * @param from address that currently owns an asset\n', '   * @param to address to receive the ownership of the asset\n', '   * @param assetId uint256 ID of the asset to be transferred\n', '   */\n', '  function safeTransferFrom(address from, address to, uint256 assetId) public {\n', '    return _doTransferFrom(from, to, assetId, &#39;&#39;, msg.sender, true);\n', '  }\n', '\n', '  /**\n', '   * @dev Securely transfers the ownership of a given asset from one address to\n', '   * another address, calling the method `onNFTReceived` on the target address if\n', '   * there&#39;s code associated with it\n', '   *\n', '   * @param from address that currently owns an asset\n', '   * @param to address to receive the ownership of the asset\n', '   * @param assetId uint256 ID of the asset to be transferred\n', '   * @param userData bytes arbitrary user information to attach to this transfer\n', '   */\n', '  function safeTransferFrom(address from, address to, uint256 assetId, bytes userData) public {\n', '    return _doTransferFrom(from, to, assetId, userData, msg.sender, true);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of a given asset from one address to another address\n', '   * Warning! This function does not attempt to verify that the target address can send\n', '   * tokens.\n', '   *\n', '   * @param from address sending the asset\n', '   * @param to address to receive the ownership of the asset\n', '   * @param assetId uint256 ID of the asset to be transferred\n', '   */\n', '  function transferFrom(address from, address to, uint256 assetId) public {\n', '    return _doTransferFrom(from, to, assetId, &#39;&#39;, msg.sender, false);\n', '  }\n', '\n', '  function _doTransferFrom(\n', '    address from,\n', '    address to,\n', '    uint256 assetId,\n', '    bytes userData,\n', '    address operator,\n', '    bool doCheck\n', '  )\n', '    isDestinataryDefined(to)\n', '    destinataryIsNotHolder(assetId, to)\n', '    isCurrentOwner(from, assetId)\n', '    onlyAuthorized(assetId)\n', '    internal\n', '  {\n', '    address holder = _holderOf[assetId];\n', '    _removeAssetFrom(holder, assetId);\n', '    _clearApproval(holder, assetId);\n', '    _addAssetTo(to, assetId);\n', '\n', '    if (doCheck && _isContract(to)) {\n', '      // Equals to bytes4(keccak256("onERC721Received(address,uint256,bytes)"))\n', '      bytes4 ERC721_RECEIVED = bytes4(0xf0b9e5ba);\n', '      require(\n', '        IERC721Receiver(to).onERC721Received(\n', '          assetId, holder, userData\n', '        ) == ERC721_RECEIVED\n', '      );\n', '    }\n', '\n', '    Transfer(holder, to, assetId, operator, userData);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns `true` if the contract implements `interfaceID` and `interfaceID` is not 0xffffffff, `false` otherwise\n', '   * @param  _interfaceID The interface identifier, as specified in ERC-165\n', '   */\n', '  function supportsInterface(bytes4 _interfaceID) public view returns (bool) {\n', '\n', '    if (_interfaceID == 0xffffffff) {\n', '      return false;\n', '    }\n', '    return _interfaceID == 0x01ffc9a7 || _interfaceID == 0x7c0633c6;\n', '  }\n', '\n', '  //\n', '  // Utilities\n', '  //\n', '\n', '  function _isContract(address addr) internal view returns (bool) {\n', '    uint size;\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '}\n', '\n', '// File: erc821/contracts/IERC721Enumerable.sol\n', '\n', 'contract IERC721Enumerable {\n', '\n', '  /**\n', '   * @notice Enumerate active tokens\n', '   * @dev Throws if `index` >= `totalSupply()`, otherwise SHALL NOT throw.\n', '   * @param index A counter less than `totalSupply()`\n', '   * @return The identifier for the `index`th asset, (sort order not\n', '   *  specified)\n', '   */\n', '  // TODO (eordano): Not implemented\n', '  // function tokenByIndex(uint256 index) public view returns (uint256 _assetId);\n', '\n', '  /**\n', '   * @notice Count of owners which own at least one asset\n', '   *  Must not throw.\n', '   * @return A count of the number of owners which own asset\n', '   */\n', '  // TODO (eordano): Not implemented\n', '  // function countOfOwners() public view returns (uint256 _count);\n', '\n', '  /**\n', '   * @notice Enumerate owners\n', '   * @dev Throws if `index` >= `countOfOwners()`, otherwise must not throw.\n', '   * @param index A counter less than `countOfOwners()`\n', '   * @return The address of the `index`th owner (sort order not specified)\n', '   */\n', '  // TODO (eordano): Not implemented\n', '  // function ownerByIndex(uint256 index) public view returns (address owner);\n', '\n', '  /**\n', '   * @notice Get all tokens of a given address\n', '   * @dev This is not intended to be used on-chain\n', '   * @param owner address of the owner to query\n', '   * @return a list of all assetIds of a user\n', '   */\n', '  function tokensOf(address owner) public view returns (uint256[]);\n', '\n', '  /**\n', '   * @notice Enumerate tokens assigned to an owner\n', '   * @dev Throws if `index` >= `balanceOf(owner)` or if\n', '   *  `owner` is the zero address, representing invalid assets.\n', '   *  Otherwise this must not throw.\n', '   * @param owner An address where we are interested in assets owned by them\n', '   * @param index A counter less than `balanceOf(owner)`\n', '   * @return The identifier for the `index`th asset assigned to `owner`,\n', '   *   (sort order not specified)\n', '   */\n', '  function tokenOfOwnerByIndex(\n', '    address owner, uint256 index\n', '  ) public view returns (uint256 tokenId);\n', '}\n', '\n', '// File: erc821/contracts/ERC721Enumerable.sol\n', '\n', 'contract ERC721Enumerable is AssetRegistryStorage, IERC721Enumerable {\n', '\n', '  /**\n', '   * @notice Get all tokens of a given address\n', '   * @dev This is not intended to be used on-chain\n', '   * @param owner address of the owner to query\n', '   * @return a list of all assetIds of a user\n', '   */\n', '  function tokensOf(address owner) public view returns (uint256[]) {\n', '    return _assetsOf[owner];\n', '  }\n', '\n', '  /**\n', '   * @notice Enumerate tokens assigned to an owner\n', '   * @dev Throws if `index` >= `balanceOf(owner)` or if\n', '   *  `owner` is the zero address, representing invalid assets.\n', '   *  Otherwise this must not throw.\n', '   * @param owner An address where we are interested in assets owned by them\n', '   * @param index A counter less than `balanceOf(owner)`\n', '   * @return The identifier for the `index`th asset assigned to `owner`,\n', '   *   (sort order not specified)\n', '   */\n', '  function tokenOfOwnerByIndex(\n', '    address owner, uint256 index\n', '    ) public view returns (uint256 assetId)\n', '  {\n', '    require(index < _assetsOf[owner].length);\n', '    require(index < (1<<127));\n', '    return _assetsOf[owner][index];\n', '  }\n', '\n', '}\n', '\n', '// File: erc821/contracts/IERC721Metadata.sol\n', '\n', 'contract IERC721Metadata {\n', '\n', '  /**\n', '   * @notice A descriptive name for a collection of NFTs in this contract\n', '   */\n', '  function name() public view returns (string);\n', '\n', '  /**\n', '   * @notice An abbreviated name for NFTs in this contract\n', '   */\n', '  function symbol() public view returns (string);\n', '\n', '  /**\n', '   * @notice A description of what this DAR is used for\n', '   */\n', '  function description() public view returns (string);\n', '\n', '  /**\n', '   * Stores arbitrary info about a token\n', '   */\n', '  function tokenMetadata(uint256 assetId) public view returns (string);\n', '}\n', '\n', '// File: erc821/contracts/ERC721Metadata.sol\n', '\n', 'contract ERC721Metadata is AssetRegistryStorage, IERC721Metadata {\n', '  function name() public view returns (string) {\n', '    return _name;\n', '  }\n', '  function symbol() public view returns (string) {\n', '    return _symbol;\n', '  }\n', '  function description() public view returns (string) {\n', '    return _description;\n', '  }\n', '  function tokenMetadata(uint256 assetId) public view returns (string) {\n', '    return _assetData[assetId];\n', '  }\n', '  function _update(uint256 assetId, string data) internal {\n', '    _assetData[assetId] = data;\n', '  }\n', '}\n', '\n', '// File: erc821/contracts/FullAssetRegistry.sol\n', '\n', 'contract FullAssetRegistry is ERC721Base, ERC721Enumerable, ERC721Metadata {\n', '  function FullAssetRegistry() public {\n', '  }\n', '\n', '  /**\n', '   * @dev Method to check if an asset identified by the given id exists under this DAR.\n', '   * @return uint256 the assetId\n', '   */\n', '  function exists(uint256 assetId) public view returns (bool) {\n', '    return _holderOf[assetId] != 0;\n', '  }\n', '\n', '  function decimals() public pure returns (uint256) {\n', '    return 0;\n', '  }\n', '}\n', '\n', '// File: contracts/land/LANDRegistry.sol\n', '\n', 'contract LANDRegistry is Storage,\n', '  Ownable, FullAssetRegistry,\n', '  ILANDRegistry\n', '{\n', '\n', '  function initialize(bytes) public {\n', '    _name = &#39;Decentraland LAND&#39;;\n', '    _symbol = &#39;LAND&#39;;\n', '    _description = &#39;Contract that stores the Decentraland LAND registry&#39;;\n', '  }\n', '\n', '  modifier onlyProxyOwner() {\n', '    require(msg.sender == proxyOwner);\n', '    _;\n', '  }\n', '\n', '  //\n', '  // LAND Create and destroy\n', '  //\n', '\n', '  modifier onlyOwnerOf(uint256 assetId) {\n', '    require(msg.sender == ownerOf(assetId));\n', '    _;\n', '  }\n', '\n', '  modifier onlyUpdateAuthorized(uint256 tokenId) {\n', '    require(msg.sender == ownerOf(tokenId) || isUpdateAuthorized(msg.sender, tokenId));\n', '    _;\n', '  }\n', '\n', '  function isUpdateAuthorized(address operator, uint256 assetId) public view returns (bool) {\n', '    return operator == ownerOf(assetId) || updateOperator[assetId] == operator;\n', '  }\n', '\n', '  function authorizeDeploy(address beneficiary) public onlyProxyOwner {\n', '    authorizedDeploy[beneficiary] = true;\n', '  }\n', '  function forbidDeploy(address beneficiary) public onlyProxyOwner {\n', '    authorizedDeploy[beneficiary] = false;\n', '  }\n', '\n', '  function assignNewParcel(int x, int y, address beneficiary) public onlyProxyOwner {\n', '    _generate(encodeTokenId(x, y), beneficiary);\n', '  }\n', '\n', '  function assignMultipleParcels(int[] x, int[] y, address beneficiary) public onlyProxyOwner {\n', '    for (uint i = 0; i < x.length; i++) {\n', '      _generate(encodeTokenId(x[i], y[i]), beneficiary);\n', '    }\n', '  }\n', '\n', '  //\n', '  // Inactive keys after 1 year lose ownership\n', '  //\n', '\n', '  function ping() public {\n', '    latestPing[msg.sender] = now;\n', '  }\n', '\n', '  function setLatestToNow(address user) public {\n', '    require(msg.sender == proxyOwner || isApprovedForAll(msg.sender, user));\n', '    latestPing[user] = now;\n', '  }\n', '\n', '  //\n', '  // LAND Getters\n', '  //\n', '\n', '  function encodeTokenId(int x, int y) view public returns (uint) {\n', '    return ((uint(x) * factor) & clearLow) | (uint(y) & clearHigh);\n', '  }\n', '\n', '  function decodeTokenId(uint value) view public returns (int, int) {\n', '    uint x = (value & clearLow) >> 128;\n', '    uint y = (value & clearHigh);\n', '    return (expandNegative128BitCast(x), expandNegative128BitCast(y));\n', '  }\n', '\n', '  function expandNegative128BitCast(uint value) pure internal returns (int) {\n', '    if (value & (1<<127) != 0) {\n', '      return int(value | clearLow);\n', '    }\n', '    return int(value);\n', '  }\n', '\n', '  function exists(int x, int y) view public returns (bool) {\n', '    return exists(encodeTokenId(x, y));\n', '  }\n', '\n', '  function ownerOfLand(int x, int y) view public returns (address) {\n', '    return ownerOf(encodeTokenId(x, y));\n', '  }\n', '\n', '  function ownerOfLandMany(int[] x, int[] y) view public returns (address[]) {\n', '    require(x.length > 0);\n', '    require(x.length == y.length);\n', '\n', '    address[] memory addrs = new address[](x.length);\n', '    for (uint i = 0; i < x.length; i++) {\n', '      addrs[i] = ownerOfLand(x[i], y[i]);\n', '    }\n', '\n', '    return addrs;\n', '  }\n', '\n', '  function landOf(address owner) public view returns (int[], int[]) {\n', '    uint256 len = _assetsOf[owner].length;\n', '    int[] memory x = new int[](len);\n', '    int[] memory y = new int[](len);\n', '\n', '    int assetX;\n', '    int assetY;\n', '    for (uint i = 0; i < len; i++) {\n', '      (assetX, assetY) = decodeTokenId(_assetsOf[owner][i]);\n', '      x[i] = assetX;\n', '      y[i] = assetY;\n', '    }\n', '\n', '    return (x, y);\n', '  }\n', '\n', '  function landData(int x, int y) view public returns (string) {\n', '    return tokenMetadata(encodeTokenId(x, y));\n', '  }\n', '\n', '  //\n', '  // LAND Transfer\n', '  //\n', '\n', '  function transferLand(int x, int y, address to) public {\n', '    uint256 tokenId = encodeTokenId(x, y);\n', '    safeTransferFrom(ownerOf(tokenId), to, tokenId);\n', '  }\n', '\n', '  function transferManyLand(int[] x, int[] y, address to) public {\n', '    require(x.length > 0);\n', '    require(x.length == y.length);\n', '\n', '    for (uint i = 0; i < x.length; i++) {\n', '      uint256 tokenId = encodeTokenId(x[i], y[i]);\n', '      safeTransferFrom(ownerOf(tokenId), to, tokenId);\n', '    }\n', '  }\n', '\n', '  function setUpdateOperator(uint256 assetId, address operator) public onlyOwnerOf(assetId) {\n', '    updateOperator[assetId] = operator;\n', '  }\n', '\n', '  //\n', '  // LAND Update\n', '  //\n', '\n', '  function updateLandData(int x, int y, string data) public onlyUpdateAuthorized (encodeTokenId(x, y)) {\n', '    uint256 assetId = encodeTokenId(x, y);\n', '    _update(assetId, data);\n', '\n', '    Update(assetId, _holderOf[assetId], msg.sender, data);\n', '  }\n', '\n', '  function updateManyLandData(int[] x, int[] y, string data) public {\n', '    require(x.length > 0);\n', '    require(x.length == y.length);\n', '    for (uint i = 0; i < x.length; i++) {\n', '      updateLandData(x[i], y[i], data);\n', '    }\n', '  }\n', '\n', '  function _doTransferFrom(\n', '    address from,\n', '    address to,\n', '    uint256 assetId,\n', '    bytes userData,\n', '    address operator,\n', '    bool doCheck\n', '  ) internal {\n', '    updateOperator[assetId] = address(0);\n', '    super._doTransferFrom(from, to, assetId, userData, operator, doCheck);\n', '  }\n', '}']
['pragma solidity 0.4.21;\n', '\n', '// File: contracts/land/LANDStorage.sol\n', '\n', 'contract LANDStorage {\n', '\n', '  mapping (address => uint) public latestPing;\n', '\n', '  uint256 constant clearLow = 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000;\n', '  uint256 constant clearHigh = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\n', '  uint256 constant factor = 0x100000000000000000000000000000000;\n', '\n', '  mapping (address => bool) public authorizedDeploy;\n', '\n', '  mapping (uint256 => address) public updateOperator;\n', '}\n', '\n', '// File: contracts/upgradable/OwnableStorage.sol\n', '\n', 'contract OwnableStorage {\n', '\n', '  address public owner;\n', '\n', '  function OwnableStorage() internal {\n', '    owner = msg.sender;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/upgradable/ProxyStorage.sol\n', '\n', 'contract ProxyStorage {\n', '\n', '  /**\n', '   * Current contract to which we are proxing\n', '   */\n', '  address public currentContract;\n', '  address public proxyOwner;\n', '}\n', '\n', '// File: erc821/contracts/AssetRegistryStorage.sol\n', '\n', 'contract AssetRegistryStorage {\n', '\n', '  string internal _name;\n', '  string internal _symbol;\n', '  string internal _description;\n', '\n', '  /**\n', '   * Stores the total count of assets managed by this registry\n', '   */\n', '  uint256 internal _count;\n', '\n', '  /**\n', '   * Stores an array of assets owned by a given account\n', '   */\n', '  mapping(address => uint256[]) internal _assetsOf;\n', '\n', '  /**\n', '   * Stores the current holder of an asset\n', '   */\n', '  mapping(uint256 => address) internal _holderOf;\n', '\n', '  /**\n', '   * Stores the index of an asset in the `_assetsOf` array of its holder\n', '   */\n', '  mapping(uint256 => uint256) internal _indexOfAsset;\n', '\n', '  /**\n', '   * Stores the data associated with an asset\n', '   */\n', '  mapping(uint256 => string) internal _assetData;\n', '\n', '  /**\n', '   * For a given account, for a given operator, store whether that operator is\n', '   * allowed to transfer and modify assets on behalf of them.\n', '   */\n', '  mapping(address => mapping(address => bool)) internal _operators;\n', '\n', '  /**\n', '   * Approval array\n', '   */\n', '  mapping(uint256 => address) internal _approval;\n', '}\n', '\n', '// File: contracts/Storage.sol\n', '\n', 'contract Storage is ProxyStorage, OwnableStorage, AssetRegistryStorage, LANDStorage {\n', '}\n', '\n', '// File: contracts/upgradable/IApplication.sol\n', '\n', 'contract IApplication {\n', '  function initialize(bytes data) public;\n', '}\n', '\n', '// File: contracts/upgradable/Ownable.sol\n', '\n', 'contract Ownable is Storage {\n', '\n', '  event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '  function bytesToAddress (bytes b) pure public returns (address) {\n', '    uint result = 0;\n', '    for (uint i = b.length-1; i+1 > 0; i--) {\n', '      uint c = uint(b[i]);\n', '      uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\n', '      result += to_inc;\n', '    }\n', '    return address(result);\n', '  }\n', '\n', '  modifier onlyOwner {\n', '    assert(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != owner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/land/ILANDRegistry.sol\n', '\n', 'interface ILANDRegistry {\n', '\n', '  // LAND can be assigned by the owner\n', '  function assignNewParcel(int x, int y, address beneficiary) public;\n', '  function assignMultipleParcels(int[] x, int[] y, address beneficiary) public;\n', '\n', '  // After one year, land can be claimed from an inactive public key\n', '  function ping() public;\n', '\n', '  // LAND-centric getters\n', '  function encodeTokenId(int x, int y) view public returns (uint256);\n', '  function decodeTokenId(uint value) view public returns (int, int);\n', '  function exists(int x, int y) view public returns (bool);\n', '  function ownerOfLand(int x, int y) view public returns (address);\n', '  function ownerOfLandMany(int[] x, int[] y) view public returns (address[]);\n', '  function landOf(address owner) view public returns (int[], int[]);\n', '  function landData(int x, int y) view public returns (string);\n', '\n', '  // Transfer LAND\n', '  function transferLand(int x, int y, address to) public;\n', '  function transferManyLand(int[] x, int[] y, address to) public;\n', '\n', '  // Update LAND\n', '  function updateLandData(int x, int y, string data) public;\n', '  function updateManyLandData(int[] x, int[] y, string data) public;\n', '\n', '  // Events\n', '\n', '  event Update(  \n', '    uint256 indexed assetId, \n', '    address indexed holder,  \n', '    address indexed operator,  \n', '    string data  \n', '  );\n', '}\n', '\n', '// File: erc821/contracts/IERC721Base.sol\n', '\n', 'interface IERC721Base {\n', '  function totalSupply() public view returns (uint256);\n', '\n', '  // function exists(uint256 assetId) public view returns (bool);\n', '  function ownerOf(uint256 assetId) public view returns (address);\n', '\n', '  function balanceOf(address holder) public view returns (uint256);\n', '\n', '  function safeTransferFrom(address from, address to, uint256 assetId) public;\n', '  function safeTransferFrom(address from, address to, uint256 assetId, bytes userData) public;\n', '\n', '  function transferFrom(address from, address to, uint256 assetId) public;\n', '\n', '  function approve(address operator, uint256 assetId) public;\n', '  function setApprovalForAll(address operator, bool authorized) public;\n', '\n', '  function getApprovedAddress(uint256 assetId) public view returns (address);\n', '  function isApprovedForAll(address operator, address assetOwner) public view returns (bool);\n', '\n', '  function isAuthorized(address operator, uint256 assetId) public view returns (bool);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 indexed assetId,\n', '    address operator,\n', '    bytes userData\n', '  );\n', '  event ApprovalForAll(\n', '    address indexed operator,\n', '    address indexed holder,\n', '    bool authorized\n', '  );\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed operator,\n', '    uint256 indexed assetId\n', '  );\n', '}\n', '\n', '// File: erc821/contracts/IERC721Receiver.sol\n', '\n', 'interface IERC721Receiver {\n', '  function onERC721Received(\n', '    uint256 _tokenId,\n', '    address _oldOwner,\n', '    bytes   _userData\n', '  ) public returns (bytes4);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: erc821/contracts/ERC721Base.sol\n', '\n', 'interface ERC165 {\n', '  function supportsInterface(bytes4 interfaceID) public view returns (bool);\n', '}\n', '\n', 'contract ERC721Base is AssetRegistryStorage, IERC721Base, ERC165 {\n', '  using SafeMath for uint256;\n', '\n', '  //\n', '  // Global Getters\n', '  //\n', '\n', '  /**\n', '   * @dev Gets the total amount of assets stored by the contract\n', '   * @return uint256 representing the total amount of assets\n', '   */\n', '  function totalSupply() public view returns (uint256) {\n', '    return _count;\n', '  }\n', '\n', '  //\n', '  // Asset-centric getter functions\n', '  //\n', '\n', '  /**\n', '   * @dev Queries what address owns an asset. This method does not throw.\n', '   * In order to check if the asset exists, use the `exists` function or check if the\n', '   * return value of this call is `0`.\n', '   * @return uint256 the assetId\n', '   */\n', '  function ownerOf(uint256 assetId) public view returns (address) {\n', '    return _holderOf[assetId];\n', '  }\n', '\n', '  //\n', '  // Holder-centric getter functions\n', '  //\n', '  /**\n', '   * @dev Gets the balance of the specified address\n', '   * @param owner address to query the balance of\n', '   * @return uint256 representing the amount owned by the passed address\n', '   */\n', '  function balanceOf(address owner) public view returns (uint256) {\n', '    return _assetsOf[owner].length;\n', '  }\n', '\n', '  //\n', '  // Authorization getters\n', '  //\n', '\n', '  /**\n', '   * @dev Query whether an address has been authorized to move any assets on behalf of someone else\n', '   * @param operator the address that might be authorized\n', '   * @param assetHolder the address that provided the authorization\n', '   * @return bool true if the operator has been authorized to move any assets\n', '   */\n', '  function isApprovedForAll(address operator, address assetHolder)\n', '    public view returns (bool)\n', '  {\n', '    return _operators[assetHolder][operator];\n', '  }\n', '\n', '  /**\n', '   * @dev Query what address has been particularly authorized to move an asset\n', '   * @param assetId the asset to be queried for\n', '   * @return bool true if the asset has been approved by the holder\n', '   */\n', '  function getApprovedAddress(uint256 assetId) public view returns (address) {\n', '    return _approval[assetId];\n', '  }\n', '\n', '  /**\n', '   * @dev Query if an operator can move an asset.\n', '   * @param operator the address that might be authorized\n', '   * @param assetId the asset that has been `approved` for transfer\n', '   * @return bool true if the asset has been approved by the holder\n', '   */\n', '  function isAuthorized(address operator, uint256 assetId)\n', '    public view returns (bool)\n', '  {\n', '    require(operator != 0);\n', '    address owner = ownerOf(assetId);\n', '    if (operator == owner) {\n', '      return true;\n', '    }\n', '    return isApprovedForAll(operator, owner) || getApprovedAddress(assetId) == operator;\n', '  }\n', '\n', '  //\n', '  // Authorization\n', '  //\n', '\n', '  /**\n', "   * @dev Authorize a third party operator to manage (send) msg.sender's asset\n", '   * @param operator address to be approved\n', '   * @param authorized bool set to true to authorize, false to withdraw authorization\n', '   */\n', '  function setApprovalForAll(address operator, bool authorized) public {\n', '    if (authorized) {\n', '      require(!isApprovedForAll(operator, msg.sender));\n', '      _addAuthorization(operator, msg.sender);\n', '    } else {\n', '      require(isApprovedForAll(operator, msg.sender));\n', '      _clearAuthorization(operator, msg.sender);\n', '    }\n', '    ApprovalForAll(operator, msg.sender, authorized);\n', '  }\n', '\n', '  /**\n', '   * @dev Authorize a third party operator to manage one particular asset\n', '   * @param operator address to be approved\n', '   * @param assetId asset to approve\n', '   */\n', '  function approve(address operator, uint256 assetId) public {\n', '    address holder = ownerOf(assetId);\n', '    require(operator != holder);\n', '    if (getApprovedAddress(assetId) != operator) {\n', '      _approval[assetId] = operator;\n', '      Approval(holder, operator, assetId);\n', '    }\n', '  }\n', '\n', '  function _addAuthorization(address operator, address holder) private {\n', '    _operators[holder][operator] = true;\n', '  }\n', '\n', '  function _clearAuthorization(address operator, address holder) private {\n', '    _operators[holder][operator] = false;\n', '  }\n', '\n', '  //\n', '  // Internal Operations\n', '  //\n', '\n', '  function _addAssetTo(address to, uint256 assetId) internal {\n', '    _holderOf[assetId] = to;\n', '\n', '    uint256 length = balanceOf(to);\n', '\n', '    _assetsOf[to].push(assetId);\n', '\n', '    _indexOfAsset[assetId] = length;\n', '\n', '    _count = _count.add(1);\n', '  }\n', '\n', '  function _removeAssetFrom(address from, uint256 assetId) internal {\n', '    uint256 assetIndex = _indexOfAsset[assetId];\n', '    uint256 lastAssetIndex = balanceOf(from).sub(1);\n', '    uint256 lastAssetId = _assetsOf[from][lastAssetIndex];\n', '\n', '    _holderOf[assetId] = 0;\n', '\n', '    // Insert the last asset into the position previously occupied by the asset to be removed\n', '    _assetsOf[from][assetIndex] = lastAssetId;\n', '\n', '    // Resize the array\n', '    _assetsOf[from][lastAssetIndex] = 0;\n', '    _assetsOf[from].length--;\n', '\n', '    // Remove the array if no more assets are owned to prevent pollution\n', '    if (_assetsOf[from].length == 0) {\n', '      delete _assetsOf[from];\n', '    }\n', '\n', '    // Update the index of positions for the asset\n', '    _indexOfAsset[assetId] = 0;\n', '    _indexOfAsset[lastAssetId] = assetIndex;\n', '\n', '    _count = _count.sub(1);\n', '  }\n', '\n', '  function _clearApproval(address holder, uint256 assetId) internal {\n', '    if (ownerOf(assetId) == holder && _approval[assetId] != 0) {\n', '      _approval[assetId] = 0;\n', '      Approval(holder, 0, assetId);\n', '    }\n', '  }\n', '\n', '  //\n', '  // Supply-altering functions\n', '  //\n', '\n', '  function _generate(uint256 assetId, address beneficiary) internal {\n', '    require(_holderOf[assetId] == 0);\n', '\n', '    _addAssetTo(beneficiary, assetId);\n', '\n', "    Transfer(0, beneficiary, assetId, msg.sender, '');\n", '  }\n', '\n', '  function _destroy(uint256 assetId) internal {\n', '    address holder = _holderOf[assetId];\n', '    require(holder != 0);\n', '\n', '    _removeAssetFrom(holder, assetId);\n', '\n', "    Transfer(holder, 0, assetId, msg.sender, '');\n", '  }\n', '\n', '  //\n', '  // Transaction related operations\n', '  //\n', '\n', '  modifier onlyHolder(uint256 assetId) {\n', '    require(_holderOf[assetId] == msg.sender);\n', '    _;\n', '  }\n', '\n', '  modifier onlyAuthorized(uint256 assetId) {\n', '    require(isAuthorized(msg.sender, assetId));\n', '    _;\n', '  }\n', '\n', '  modifier isCurrentOwner(address from, uint256 assetId) {\n', '    require(_holderOf[assetId] == from);\n', '    _;\n', '  }\n', '\n', '  modifier isDestinataryDefined(address destinatary) {\n', '    require(destinatary != 0);\n', '    _;\n', '  }\n', '\n', '  modifier destinataryIsNotHolder(uint256 assetId, address to) {\n', '    require(_holderOf[assetId] != to);\n', '    _;\n', '  }\n', '\n', '  /**\n', "   * @dev Alias of `safeTransferFrom(from, to, assetId, '')`\n", '   *\n', '   * @param from address that currently owns an asset\n', '   * @param to address to receive the ownership of the asset\n', '   * @param assetId uint256 ID of the asset to be transferred\n', '   */\n', '  function safeTransferFrom(address from, address to, uint256 assetId) public {\n', "    return _doTransferFrom(from, to, assetId, '', msg.sender, true);\n", '  }\n', '\n', '  /**\n', '   * @dev Securely transfers the ownership of a given asset from one address to\n', '   * another address, calling the method `onNFTReceived` on the target address if\n', "   * there's code associated with it\n", '   *\n', '   * @param from address that currently owns an asset\n', '   * @param to address to receive the ownership of the asset\n', '   * @param assetId uint256 ID of the asset to be transferred\n', '   * @param userData bytes arbitrary user information to attach to this transfer\n', '   */\n', '  function safeTransferFrom(address from, address to, uint256 assetId, bytes userData) public {\n', '    return _doTransferFrom(from, to, assetId, userData, msg.sender, true);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of a given asset from one address to another address\n', '   * Warning! This function does not attempt to verify that the target address can send\n', '   * tokens.\n', '   *\n', '   * @param from address sending the asset\n', '   * @param to address to receive the ownership of the asset\n', '   * @param assetId uint256 ID of the asset to be transferred\n', '   */\n', '  function transferFrom(address from, address to, uint256 assetId) public {\n', "    return _doTransferFrom(from, to, assetId, '', msg.sender, false);\n", '  }\n', '\n', '  function _doTransferFrom(\n', '    address from,\n', '    address to,\n', '    uint256 assetId,\n', '    bytes userData,\n', '    address operator,\n', '    bool doCheck\n', '  )\n', '    isDestinataryDefined(to)\n', '    destinataryIsNotHolder(assetId, to)\n', '    isCurrentOwner(from, assetId)\n', '    onlyAuthorized(assetId)\n', '    internal\n', '  {\n', '    address holder = _holderOf[assetId];\n', '    _removeAssetFrom(holder, assetId);\n', '    _clearApproval(holder, assetId);\n', '    _addAssetTo(to, assetId);\n', '\n', '    if (doCheck && _isContract(to)) {\n', '      // Equals to bytes4(keccak256("onERC721Received(address,uint256,bytes)"))\n', '      bytes4 ERC721_RECEIVED = bytes4(0xf0b9e5ba);\n', '      require(\n', '        IERC721Receiver(to).onERC721Received(\n', '          assetId, holder, userData\n', '        ) == ERC721_RECEIVED\n', '      );\n', '    }\n', '\n', '    Transfer(holder, to, assetId, operator, userData);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns `true` if the contract implements `interfaceID` and `interfaceID` is not 0xffffffff, `false` otherwise\n', '   * @param  _interfaceID The interface identifier, as specified in ERC-165\n', '   */\n', '  function supportsInterface(bytes4 _interfaceID) public view returns (bool) {\n', '\n', '    if (_interfaceID == 0xffffffff) {\n', '      return false;\n', '    }\n', '    return _interfaceID == 0x01ffc9a7 || _interfaceID == 0x7c0633c6;\n', '  }\n', '\n', '  //\n', '  // Utilities\n', '  //\n', '\n', '  function _isContract(address addr) internal view returns (bool) {\n', '    uint size;\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '}\n', '\n', '// File: erc821/contracts/IERC721Enumerable.sol\n', '\n', 'contract IERC721Enumerable {\n', '\n', '  /**\n', '   * @notice Enumerate active tokens\n', '   * @dev Throws if `index` >= `totalSupply()`, otherwise SHALL NOT throw.\n', '   * @param index A counter less than `totalSupply()`\n', '   * @return The identifier for the `index`th asset, (sort order not\n', '   *  specified)\n', '   */\n', '  // TODO (eordano): Not implemented\n', '  // function tokenByIndex(uint256 index) public view returns (uint256 _assetId);\n', '\n', '  /**\n', '   * @notice Count of owners which own at least one asset\n', '   *  Must not throw.\n', '   * @return A count of the number of owners which own asset\n', '   */\n', '  // TODO (eordano): Not implemented\n', '  // function countOfOwners() public view returns (uint256 _count);\n', '\n', '  /**\n', '   * @notice Enumerate owners\n', '   * @dev Throws if `index` >= `countOfOwners()`, otherwise must not throw.\n', '   * @param index A counter less than `countOfOwners()`\n', '   * @return The address of the `index`th owner (sort order not specified)\n', '   */\n', '  // TODO (eordano): Not implemented\n', '  // function ownerByIndex(uint256 index) public view returns (address owner);\n', '\n', '  /**\n', '   * @notice Get all tokens of a given address\n', '   * @dev This is not intended to be used on-chain\n', '   * @param owner address of the owner to query\n', '   * @return a list of all assetIds of a user\n', '   */\n', '  function tokensOf(address owner) public view returns (uint256[]);\n', '\n', '  /**\n', '   * @notice Enumerate tokens assigned to an owner\n', '   * @dev Throws if `index` >= `balanceOf(owner)` or if\n', '   *  `owner` is the zero address, representing invalid assets.\n', '   *  Otherwise this must not throw.\n', '   * @param owner An address where we are interested in assets owned by them\n', '   * @param index A counter less than `balanceOf(owner)`\n', '   * @return The identifier for the `index`th asset assigned to `owner`,\n', '   *   (sort order not specified)\n', '   */\n', '  function tokenOfOwnerByIndex(\n', '    address owner, uint256 index\n', '  ) public view returns (uint256 tokenId);\n', '}\n', '\n', '// File: erc821/contracts/ERC721Enumerable.sol\n', '\n', 'contract ERC721Enumerable is AssetRegistryStorage, IERC721Enumerable {\n', '\n', '  /**\n', '   * @notice Get all tokens of a given address\n', '   * @dev This is not intended to be used on-chain\n', '   * @param owner address of the owner to query\n', '   * @return a list of all assetIds of a user\n', '   */\n', '  function tokensOf(address owner) public view returns (uint256[]) {\n', '    return _assetsOf[owner];\n', '  }\n', '\n', '  /**\n', '   * @notice Enumerate tokens assigned to an owner\n', '   * @dev Throws if `index` >= `balanceOf(owner)` or if\n', '   *  `owner` is the zero address, representing invalid assets.\n', '   *  Otherwise this must not throw.\n', '   * @param owner An address where we are interested in assets owned by them\n', '   * @param index A counter less than `balanceOf(owner)`\n', '   * @return The identifier for the `index`th asset assigned to `owner`,\n', '   *   (sort order not specified)\n', '   */\n', '  function tokenOfOwnerByIndex(\n', '    address owner, uint256 index\n', '    ) public view returns (uint256 assetId)\n', '  {\n', '    require(index < _assetsOf[owner].length);\n', '    require(index < (1<<127));\n', '    return _assetsOf[owner][index];\n', '  }\n', '\n', '}\n', '\n', '// File: erc821/contracts/IERC721Metadata.sol\n', '\n', 'contract IERC721Metadata {\n', '\n', '  /**\n', '   * @notice A descriptive name for a collection of NFTs in this contract\n', '   */\n', '  function name() public view returns (string);\n', '\n', '  /**\n', '   * @notice An abbreviated name for NFTs in this contract\n', '   */\n', '  function symbol() public view returns (string);\n', '\n', '  /**\n', '   * @notice A description of what this DAR is used for\n', '   */\n', '  function description() public view returns (string);\n', '\n', '  /**\n', '   * Stores arbitrary info about a token\n', '   */\n', '  function tokenMetadata(uint256 assetId) public view returns (string);\n', '}\n', '\n', '// File: erc821/contracts/ERC721Metadata.sol\n', '\n', 'contract ERC721Metadata is AssetRegistryStorage, IERC721Metadata {\n', '  function name() public view returns (string) {\n', '    return _name;\n', '  }\n', '  function symbol() public view returns (string) {\n', '    return _symbol;\n', '  }\n', '  function description() public view returns (string) {\n', '    return _description;\n', '  }\n', '  function tokenMetadata(uint256 assetId) public view returns (string) {\n', '    return _assetData[assetId];\n', '  }\n', '  function _update(uint256 assetId, string data) internal {\n', '    _assetData[assetId] = data;\n', '  }\n', '}\n', '\n', '// File: erc821/contracts/FullAssetRegistry.sol\n', '\n', 'contract FullAssetRegistry is ERC721Base, ERC721Enumerable, ERC721Metadata {\n', '  function FullAssetRegistry() public {\n', '  }\n', '\n', '  /**\n', '   * @dev Method to check if an asset identified by the given id exists under this DAR.\n', '   * @return uint256 the assetId\n', '   */\n', '  function exists(uint256 assetId) public view returns (bool) {\n', '    return _holderOf[assetId] != 0;\n', '  }\n', '\n', '  function decimals() public pure returns (uint256) {\n', '    return 0;\n', '  }\n', '}\n', '\n', '// File: contracts/land/LANDRegistry.sol\n', '\n', 'contract LANDRegistry is Storage,\n', '  Ownable, FullAssetRegistry,\n', '  ILANDRegistry\n', '{\n', '\n', '  function initialize(bytes) public {\n', "    _name = 'Decentraland LAND';\n", "    _symbol = 'LAND';\n", "    _description = 'Contract that stores the Decentraland LAND registry';\n", '  }\n', '\n', '  modifier onlyProxyOwner() {\n', '    require(msg.sender == proxyOwner);\n', '    _;\n', '  }\n', '\n', '  //\n', '  // LAND Create and destroy\n', '  //\n', '\n', '  modifier onlyOwnerOf(uint256 assetId) {\n', '    require(msg.sender == ownerOf(assetId));\n', '    _;\n', '  }\n', '\n', '  modifier onlyUpdateAuthorized(uint256 tokenId) {\n', '    require(msg.sender == ownerOf(tokenId) || isUpdateAuthorized(msg.sender, tokenId));\n', '    _;\n', '  }\n', '\n', '  function isUpdateAuthorized(address operator, uint256 assetId) public view returns (bool) {\n', '    return operator == ownerOf(assetId) || updateOperator[assetId] == operator;\n', '  }\n', '\n', '  function authorizeDeploy(address beneficiary) public onlyProxyOwner {\n', '    authorizedDeploy[beneficiary] = true;\n', '  }\n', '  function forbidDeploy(address beneficiary) public onlyProxyOwner {\n', '    authorizedDeploy[beneficiary] = false;\n', '  }\n', '\n', '  function assignNewParcel(int x, int y, address beneficiary) public onlyProxyOwner {\n', '    _generate(encodeTokenId(x, y), beneficiary);\n', '  }\n', '\n', '  function assignMultipleParcels(int[] x, int[] y, address beneficiary) public onlyProxyOwner {\n', '    for (uint i = 0; i < x.length; i++) {\n', '      _generate(encodeTokenId(x[i], y[i]), beneficiary);\n', '    }\n', '  }\n', '\n', '  //\n', '  // Inactive keys after 1 year lose ownership\n', '  //\n', '\n', '  function ping() public {\n', '    latestPing[msg.sender] = now;\n', '  }\n', '\n', '  function setLatestToNow(address user) public {\n', '    require(msg.sender == proxyOwner || isApprovedForAll(msg.sender, user));\n', '    latestPing[user] = now;\n', '  }\n', '\n', '  //\n', '  // LAND Getters\n', '  //\n', '\n', '  function encodeTokenId(int x, int y) view public returns (uint) {\n', '    return ((uint(x) * factor) & clearLow) | (uint(y) & clearHigh);\n', '  }\n', '\n', '  function decodeTokenId(uint value) view public returns (int, int) {\n', '    uint x = (value & clearLow) >> 128;\n', '    uint y = (value & clearHigh);\n', '    return (expandNegative128BitCast(x), expandNegative128BitCast(y));\n', '  }\n', '\n', '  function expandNegative128BitCast(uint value) pure internal returns (int) {\n', '    if (value & (1<<127) != 0) {\n', '      return int(value | clearLow);\n', '    }\n', '    return int(value);\n', '  }\n', '\n', '  function exists(int x, int y) view public returns (bool) {\n', '    return exists(encodeTokenId(x, y));\n', '  }\n', '\n', '  function ownerOfLand(int x, int y) view public returns (address) {\n', '    return ownerOf(encodeTokenId(x, y));\n', '  }\n', '\n', '  function ownerOfLandMany(int[] x, int[] y) view public returns (address[]) {\n', '    require(x.length > 0);\n', '    require(x.length == y.length);\n', '\n', '    address[] memory addrs = new address[](x.length);\n', '    for (uint i = 0; i < x.length; i++) {\n', '      addrs[i] = ownerOfLand(x[i], y[i]);\n', '    }\n', '\n', '    return addrs;\n', '  }\n', '\n', '  function landOf(address owner) public view returns (int[], int[]) {\n', '    uint256 len = _assetsOf[owner].length;\n', '    int[] memory x = new int[](len);\n', '    int[] memory y = new int[](len);\n', '\n', '    int assetX;\n', '    int assetY;\n', '    for (uint i = 0; i < len; i++) {\n', '      (assetX, assetY) = decodeTokenId(_assetsOf[owner][i]);\n', '      x[i] = assetX;\n', '      y[i] = assetY;\n', '    }\n', '\n', '    return (x, y);\n', '  }\n', '\n', '  function landData(int x, int y) view public returns (string) {\n', '    return tokenMetadata(encodeTokenId(x, y));\n', '  }\n', '\n', '  //\n', '  // LAND Transfer\n', '  //\n', '\n', '  function transferLand(int x, int y, address to) public {\n', '    uint256 tokenId = encodeTokenId(x, y);\n', '    safeTransferFrom(ownerOf(tokenId), to, tokenId);\n', '  }\n', '\n', '  function transferManyLand(int[] x, int[] y, address to) public {\n', '    require(x.length > 0);\n', '    require(x.length == y.length);\n', '\n', '    for (uint i = 0; i < x.length; i++) {\n', '      uint256 tokenId = encodeTokenId(x[i], y[i]);\n', '      safeTransferFrom(ownerOf(tokenId), to, tokenId);\n', '    }\n', '  }\n', '\n', '  function setUpdateOperator(uint256 assetId, address operator) public onlyOwnerOf(assetId) {\n', '    updateOperator[assetId] = operator;\n', '  }\n', '\n', '  //\n', '  // LAND Update\n', '  //\n', '\n', '  function updateLandData(int x, int y, string data) public onlyUpdateAuthorized (encodeTokenId(x, y)) {\n', '    uint256 assetId = encodeTokenId(x, y);\n', '    _update(assetId, data);\n', '\n', '    Update(assetId, _holderOf[assetId], msg.sender, data);\n', '  }\n', '\n', '  function updateManyLandData(int[] x, int[] y, string data) public {\n', '    require(x.length > 0);\n', '    require(x.length == y.length);\n', '    for (uint i = 0; i < x.length; i++) {\n', '      updateLandData(x[i], y[i], data);\n', '    }\n', '  }\n', '\n', '  function _doTransferFrom(\n', '    address from,\n', '    address to,\n', '    uint256 assetId,\n', '    bytes userData,\n', '    address operator,\n', '    bool doCheck\n', '  ) internal {\n', '    updateOperator[assetId] = address(0);\n', '    super._doTransferFrom(from, to, assetId, userData, operator, doCheck);\n', '  }\n', '}']
