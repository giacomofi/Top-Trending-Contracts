['pragma solidity ^0.4.17;\n', '\n', '/**\n', ' * @title ERC721 interface\n', ' * @dev see https://github.com/ethereum/eips/issues/721\n', ' */\n', '\n', '/* solium-disable zeppelin/missing-natspec-comments */\n', 'contract ERC721 {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n', '  function transfer(address _to, uint256 _tokenId) external;\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function approve(address _to, uint256 _tokenId) external;\n', '  function setApprovalForAll(address _to, bool _approved) external;\n', '  function getApproved(uint256 _tokenId) public view returns (address);\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '}\n', '\n', 'interface ERC165 {\n', '    /// @notice Query if a contract implements an interface\n', '    /// @param interfaceID The interface identifier, as specified in ERC-165\n', '    /// @dev Interface identification is specified in ERC-165. This function\n', '    ///  uses less than 30,000 gas.\n', '    /// @return `true` if the contract implements `interfaceID` and\n', '    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', '/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\n', 'interface ERC721TokenReceiver {\n', '    /// @notice Handle the receipt of an NFT\n', '    /// @dev The ERC721 smart contract calls this function on the recipient\n', '    ///  after a `transfer`. This function MAY throw to revert and reject the\n', '    ///  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    ///  than the magic value MUST result in the transaction being reverted.\n', '    ///  Note: the contract address is always the message sender.\n', '    /// @param _from The sending address\n', '    /// @param _tokenId The NFT identifier which is being transfered\n', '    /// @param _data Additional data with no specified format\n', '    /// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '    ///  unless throwing\n', '  function onERC721Received(address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '}\n', 'library Strings {\n', '  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n', '  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n', '      bytes memory _ba = bytes(_a);\n', '      bytes memory _bb = bytes(_b);\n', '      bytes memory _bc = bytes(_c);\n', '      bytes memory _bd = bytes(_d);\n', '      bytes memory _be = bytes(_e);\n', '      string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '      bytes memory babcde = bytes(abcde);\n', '      uint k = 0;\n', '      for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '      for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '      for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '      for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '      for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '      return string(babcde);\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n', '        return strConcat(_a, _b, _c, _d, "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n', '        return strConcat(_a, _b, _c, "", "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b) internal pure returns (string) {\n', '        return strConcat(_a, _b, "", "", "");\n', '    }\n', '\n', '    function uint2str(uint i) internal pure returns (string) {\n', '        if (i == 0) return "0";\n', '        uint j = i;\n', '        uint len;\n', '        while (j != 0){\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len - 1;\n', '        while (i != 0){\n', '            bstr[k--] = byte(48 + i % 10);\n', '            i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\n', 'interface ERC721Metadata /* is ERC721 */ {\n', '    /// @notice A descriptive name for a collection of NFTs in this contract\n', '    function name() external pure returns (string _name);\n', '\n', '    /// @notice An abbreviated name for NFTs in this contract\n', '    function symbol() external pure returns (string _symbol);\n', '\n', '    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n', '    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n', '    ///  3986. The URI may point to a JSON file that conforms to the "ERC721\n', '    ///  Metadata JSON Schema".\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', 'contract ERC721SlimToken is Ownable, ERC721, ERC165, ERC721Metadata {\n', '  using SafeMath for uint256;\n', '\n', '  string public constant NAME = "EtherLoot";\n', '  string public constant SYMBOL = "ETLT";\n', '  string public tokenMetadataBaseURI = "http://api.etherloot.moonshadowgames.com/tokenmetadata/";\n', '\n', '  struct AddressAndTokenIndex {\n', '    address owner;\n', '    uint32 tokenIndex;\n', '  }\n', '\n', '  mapping (uint256 => AddressAndTokenIndex) private tokenOwnerAndTokensIndex;\n', '\n', '  mapping (address => uint256[]) private ownedTokens;\n', '\n', '  mapping (uint256 => address) private tokenApprovals;\n', '\n', '  mapping (address => mapping (address => bool)) private operatorApprovals;\n', '\n', '  mapping (address => bool) private approvedContractAddresses;\n', '\n', '  bool approvedContractsFinalized = false;\n', '\n', '  function implementsERC721() external pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '\n', '\n', '  function supportsInterface(\n', '    bytes4 interfaceID)\n', '    external view returns (bool)\n', '  {\n', '    return\n', '      interfaceID == this.supportsInterface.selector || // ERC165\n', '      interfaceID == 0x5b5e139f || // ERC721Metadata\n', '      interfaceID == 0x6466353c; // ERC-721\n', '  }\n', '\n', '  function name() external pure returns (string) {\n', '    return NAME;\n', '  }\n', '\n', '  function symbol() external pure returns (string) {\n', '    return SYMBOL;\n', '  }\n', '\n', '  function setTokenMetadataBaseURI(string _tokenMetadataBaseURI) external onlyOwner {\n', '    tokenMetadataBaseURI = _tokenMetadataBaseURI;\n', '  }\n', '\n', '  function tokenURI(uint256 tokenId)\n', '    external\n', '    view\n', '    returns (string infoUrl)\n', '  {\n', '    return Strings.strConcat(\n', '      tokenMetadataBaseURI,\n', '      Strings.uint2str(tokenId));\n', '  }\n', '\n', '  /**\n', '  * @notice Guarantees msg.sender is owner of the given token\n', '  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n', '  */\n', '  modifier onlyOwnerOf(uint256 _tokenId) {\n', '    require(ownerOf(_tokenId) == msg.sender, "not owner");\n', '    _;\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the balance of the specified address\n', '  * @param _owner address to query the balance of\n', '  * @return uint256 representing the amount owned by the passed address\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    require(_owner != address(0), "null owner");\n', '    return ownedTokens[_owner].length;\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the list of tokens owned by a given address\n', '  * @param _owner address to query the tokens of\n', '  * @return uint256[] representing the list of tokens owned by the passed address\n', '  */\n', '  function tokensOf(address _owner) public view returns (uint256[]) {\n', '    return ownedTokens[_owner];\n', '  }\n', '\n', '  /**\n', '  * @notice Enumerate NFTs assigned to an owner\n', '  * @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '  *  `_owner` is the zero address, representing invalid NFTs.\n', '  * @param _owner An address where we are interested in NFTs owned by them\n', '  * @param _index A counter less than `balanceOf(_owner)`\n', '  * @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '  */\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index)\n', '    external\n', '    view\n', '    returns (uint256 _tokenId)\n', '  {\n', '    require(_index < balanceOf(_owner), "invalid index");\n', '    return ownedTokens[_owner][_index];\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the owner of the specified token ID\n', '  * @param _tokenId uint256 ID of the token to query the owner of\n', '  * @return owner address currently marked as the owner of the given token ID\n', '  */\n', '  function ownerOf(uint256 _tokenId) public view returns (address) {\n', '    address _owner = tokenOwnerAndTokensIndex[_tokenId].owner;\n', '    require(_owner != address(0), "invalid owner");\n', '    return _owner;\n', '  }\n', '\n', '  function exists(uint256 _tokenId) public view returns (bool) {\n', '    address _owner = tokenOwnerAndTokensIndex[_tokenId].owner;\n', '    return (_owner != address(0));\n', '  }\n', '\n', '  /**\n', '   * @notice Gets the approved address to take ownership of a given token ID\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return address currently approved to take ownership of the given token ID\n', '   */\n', '  function getApproved(uint256 _tokenId) public view returns (address) {\n', '    return tokenApprovals[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @notice Tells whether the msg.sender is approved to transfer the given token ID or not\n', '   * Checks both for specific approval and operator approval\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return bool whether transfer by msg.sender is approved for the given token ID or not\n', '   */\n', '  function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {\n', '    return\n', '      ownerOf(_tokenId) == msg.sender ||\n', '      isSpecificallyApprovedFor(msg.sender, _tokenId) ||\n', '      isApprovedForAll(ownerOf(_tokenId), msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @notice Tells whether the msg.sender is approved for the given token ID or not\n', '   * @param _asker address of asking for approval\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return bool whether the msg.sender is approved for the given token ID or not\n', '   */\n', '  function isSpecificallyApprovedFor(address _asker, uint256 _tokenId) internal view returns (bool) {\n', '    return getApproved(_tokenId) == _asker;\n', '  }\n', '\n', '  /**\n', '   * @notice Tells whether an operator is approved by a given owner\n', '   * @param _owner owner address which you want to query the approval of\n', '   * @param _operator operator address which you want to query the approval of\n', '   * @return bool whether the given operator is approved by the given owner\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool)\n', '  {\n', '    return operatorApprovals[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '  * @notice Transfers the ownership of a given token ID to another address\n', '  * @param _to address to receive the ownership of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function transfer(address _to, uint256 _tokenId)\n', '    external\n', '    onlyOwnerOf(_tokenId)\n', '  {\n', '    _clearApprovalAndTransfer(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Approves another address to claim for the ownership of the given token ID\n', '  * @param _to address to be approved for the given token ID\n', '  * @param _tokenId uint256 ID of the token to be approved\n', '  */\n', '  function approve(address _to, uint256 _tokenId)\n', '    external\n', '    onlyOwnerOf(_tokenId)\n', '  {\n', '    address _owner = ownerOf(_tokenId);\n', '    require(_to != _owner, "already owns");\n', '    if (getApproved(_tokenId) != 0 || _to != 0) {\n', '      tokenApprovals[_tokenId] = _to;\n', '      emit Approval(_owner, _to, _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Enable or disable approval for a third party ("operator") to manage all your assets\n', '  * @dev Emits the ApprovalForAll event\n', '  * @param _to Address to add to the set of authorized operators.\n', '  * @param _approved True if the operators is approved, false to revoke approval\n', '  */\n', '  function setApprovalForAll(address _to, bool _approved)\n', '    external\n', '  {\n', '    if(_approved) {\n', '      approveAll(_to);\n', '    } else {\n', '      disapproveAll(_to);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Approves another address to claim for the ownership of any tokens owned by this account\n', '  * @param _to address to be approved for the given token ID\n', '  */\n', '  function approveAll(address _to)\n', '    public\n', '  {\n', '    require(_to != msg.sender, "cant approve yourself");\n', '    require(_to != address(0), "invalid owner");\n', '    operatorApprovals[msg.sender][_to] = true;\n', '    emit ApprovalForAll(msg.sender, _to, true);\n', '  }\n', '\n', '  /**\n', '  * @notice Removes approval for another address to claim for the ownership of any\n', '  *  tokens owned by this account.\n', '  * @dev Note that this only removes the operator approval and\n', '  *  does not clear any independent, specific approvals of token transfers to this address\n', '  * @param _to address to be disapproved for the given token ID\n', '  */\n', '  function disapproveAll(address _to)\n', '    public\n', '  {\n', '    require(_to != msg.sender, "cant unapprove yourself");\n', '    delete operatorApprovals[msg.sender][_to];\n', '    emit ApprovalForAll(msg.sender, _to, false);\n', '  }\n', '\n', '  /**\n', '  * @notice Claims the ownership of a given token ID\n', '  * @param _tokenId uint256 ID of the token being claimed by the msg.sender\n', '  */\n', '  function takeOwnership(uint256 _tokenId)\n', '   external\n', '  {\n', '    require(isSenderApprovedFor(_tokenId), "not approved");\n', '    _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Transfer a token owned by another address, for which the calling address has\n', '  *  previously been granted transfer approval by the owner.\n', '  * @param _from The address that owns the token\n', '  * @param _to The address that will take ownership of the token. Can be any address, including the caller\n', '  * @param _tokenId The ID of the token to be transferred\n', '  */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '  {\n', '    address tokenOwner = ownerOf(_tokenId);\n', '    require(isSenderApprovedFor(_tokenId) || \n', '      (approvedContractAddresses[msg.sender] && tokenOwner == tx.origin), "not an approved sender");\n', '    require(tokenOwner == _from, "wrong owner");\n', '    _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Transfers the ownership of an NFT from one address to another address\n', '  * @dev Throws unless `msg.sender` is the current owner, an authorized\n', '  * operator, or the approved address for this NFT. Throws if `_from` is\n', '  * not the current owner. Throws if `_to` is the zero address. Throws if\n', '  * `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '  * checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '  * `onERC721Received` on `_to` and throws if the return value is not\n', '  * `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '  * @param _from The current owner of the NFT\n', '  * @param _to The new owner\n', '  * @param _tokenId The NFT to transfer\n', '  * @param _data Additional data with no specified format, sent in call to `_to`\n', '  */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public\n', '  {\n', '    require(_to != address(0), "invalid target address");\n', '    transferFrom(_from, _to, _tokenId);\n', '    if (_isContract(_to)) {\n', '      bytes4 tokenReceiverResponse = ERC721TokenReceiver(_to).onERC721Received.gas(50000)(\n', '        _from, _tokenId, _data\n', '      );\n', '      require(tokenReceiverResponse == bytes4(keccak256("onERC721Received(address,uint256,bytes)")), "invalid receiver respononse");\n', '    }\n', '  }\n', '\n', '  /*\n', '   * @notice Transfers the ownership of an NFT from one address to another address\n', '   * @dev This works identically to the other function with an extra data parameter,\n', '   *  except this function just sets data to ""\n', '   * @param _from The current owner of the NFT\n', '   * @param _to The new owner\n', '   * @param _tokenId The NFT to transfer\n', '  */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '  {\n', '    safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '  * @notice Approve a contract address for minting tokens and transferring tokens, when approved by the owner\n', '  * @param contractAddress The address that will be approved\n', '  */\n', '  function addApprovedContractAddress(address contractAddress) public onlyOwner\n', '  {\n', '    require(!approvedContractsFinalized);\n', '    approvedContractAddresses[contractAddress] = true;\n', '  }\n', '\n', '  /**\n', '  * @notice Unapprove a contract address for minting tokens and transferring tokens\n', '  * @param contractAddress The address that will be unapproved\n', '  */\n', '  function removeApprovedContractAddress(address contractAddress) public onlyOwner\n', '  {\n', '    require(!approvedContractsFinalized);\n', '    approvedContractAddresses[contractAddress] = false;\n', '  }\n', '\n', '  /**\n', '  * @notice Finalize the contract so it will be forever impossible to change the approved contracts list\n', '  */\n', '  function finalizeApprovedContracts() public onlyOwner {\n', '    approvedContractsFinalized = true;\n', '  }\n', '\n', '  /**\n', '  * @notice Mint token function\n', '  * @param _to The address that will own the minted token\n', '  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '  */\n', '  function mint(address _to, uint256 _tokenId) public {\n', '    require(\n', '      approvedContractAddresses[msg.sender] ||\n', '      msg.sender == owner, "minter not approved"\n', '    );\n', '    _mint(_to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Mint token function\n', '  * @param _to The address that will own the minted token\n', '  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '  */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0), "invalid target address");\n', '    require(tokenOwnerAndTokensIndex[_tokenId].owner == address(0), "token already exists");\n', '    _addToken(_to, _tokenId);\n', '    emit Transfer(0x0, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to clear current approval and transfer the ownership of a given token ID\n', '  * @param _from address which you want to send tokens from\n', '  * @param _to address which you want to transfer the token to\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function _clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0), "invalid target address");\n', '    require(_to != ownerOf(_tokenId), "already owns");\n', '    require(ownerOf(_tokenId) == _from, "wrong owner");\n', '\n', '    _clearApproval(_from, _tokenId);\n', '    _removeToken(_from, _tokenId);\n', '    _addToken(_to, _tokenId);\n', '    emit Transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to clear current approval of a given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function _clearApproval(address _owner, uint256 _tokenId) private {\n', '    require(ownerOf(_tokenId) == _owner, "wrong owner");\n', '    if (tokenApprovals[_tokenId] != 0) {\n', '      tokenApprovals[_tokenId] = 0;\n', '      emit Approval(_owner, 0, _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to add a token ID to the list of a given address\n', '  * @param _to address representing the new owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '  */\n', '  function _addToken(address _to, uint256 _tokenId) private {\n', '    uint256 newTokenIndex = ownedTokens[_to].length;\n', '    ownedTokens[_to].push(_tokenId);\n', '\n', '    // I don&#39;t expect anyone to own 4 billion tokens, but just in case...\n', '    require(newTokenIndex == uint256(uint32(newTokenIndex)), "overflow");\n', '\n', '    tokenOwnerAndTokensIndex[_tokenId] = AddressAndTokenIndex({owner: _to, tokenIndex: uint32(newTokenIndex)});\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to remove a token ID from the list of a given address\n', '  * @param _from address representing the previous owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '  */\n', '  function _removeToken(address _from, uint256 _tokenId) private {\n', '    require(ownerOf(_tokenId) == _from, "wrong owner");\n', '\n', '    uint256 tokenIndex = tokenOwnerAndTokensIndex[_tokenId].tokenIndex;\n', '    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n', '    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n', '\n', '    ownedTokens[_from][tokenIndex] = lastToken;\n', '\n', '    ownedTokens[_from].length--;\n', '    tokenOwnerAndTokensIndex[lastToken] = AddressAndTokenIndex({owner: _from, tokenIndex: uint32(tokenIndex)});\n', '  }\n', '\n', '  function _isContract(address addr) internal view returns (bool) {\n', '    uint size;\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '}\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function smax256(int256 a, int256 b) internal pure returns (int256) {\n', '    return a >= b ? a : b;\n', '  }\n', '}\n', '\n', 'contract ContractAccessControl {\n', '\n', '  event ContractUpgrade(address newContract);\n', '  event Paused();\n', '  event Unpaused();\n', '\n', '  address public ceoAddress;\n', '\n', '  address public cfoAddress;\n', '\n', '  address public cooAddress;\n', '\n', '  address public withdrawalAddress;\n', '\n', '  bool public paused = false;\n', '\n', '  modifier onlyCEO() {\n', '    require(msg.sender == ceoAddress);\n', '    _;\n', '  }\n', '\n', '  modifier onlyCFO() {\n', '    require(msg.sender == cfoAddress);\n', '    _;\n', '  }\n', '\n', '  modifier onlyCOO() {\n', '    require(msg.sender == cooAddress);\n', '    _;\n', '  }\n', '\n', '  modifier onlyCLevel() {\n', '    require(\n', '      msg.sender == cooAddress ||\n', '      msg.sender == ceoAddress ||\n', '      msg.sender == cfoAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier onlyCEOOrCFO() {\n', '    require(\n', '      msg.sender == cfoAddress ||\n', '      msg.sender == ceoAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier onlyCEOOrCOO() {\n', '    require(\n', '      msg.sender == cooAddress ||\n', '      msg.sender == ceoAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  function setCEO(address _newCEO) external onlyCEO {\n', '    require(_newCEO != address(0));\n', '    ceoAddress = _newCEO;\n', '  }\n', '\n', '  function setCFO(address _newCFO) external onlyCEO {\n', '    require(_newCFO != address(0));\n', '    cfoAddress = _newCFO;\n', '  }\n', '\n', '  function setCOO(address _newCOO) external onlyCEO {\n', '    require(_newCOO != address(0));\n', '    cooAddress = _newCOO;\n', '  }\n', '\n', '  function setWithdrawalAddress(address _newWithdrawalAddress) external onlyCEO {\n', '    require(_newWithdrawalAddress != address(0));\n', '    withdrawalAddress = _newWithdrawalAddress;\n', '  }\n', '\n', '  function withdrawBalance() external onlyCEOOrCFO {\n', '    require(withdrawalAddress != address(0));\n', '    withdrawalAddress.transfer(this.balance);\n', '  }\n', '\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  function pause() public onlyCLevel whenNotPaused {\n', '    paused = true;\n', '    emit Paused();\n', '  }\n', '\n', '  function unpause() public onlyCEO whenPaused {\n', '    paused = false;\n', '    emit Unpaused();\n', '  }\n', '}\n', '\n', 'contract CryptoBoss is ContractAccessControl {\n', '\n', '  address constant tokenContractAddress = 0xe1015a79a7d488f8fecf073b187d38c6f1a77368;\n', '  ERC721SlimToken constant tokenContract = ERC721SlimToken(tokenContractAddress);\n', '\n', '  event Participating(address indexed player, uint encounterId);\n', '  event LootClaimed(address indexed player, uint encounterId);\n', '  event DailyLootClaimed(uint day);\n', '\n', '  struct ParticipantData {\n', '    uint32 damage;\n', '    uint64 cumulativeDamage;\n', '    uint8 forgeWeaponRarity;\n', '    uint8 forgeWeaponDamagePure;\n', '    bool lootClaimed;\n', '    bool consolationPrizeClaimed;\n', '  }\n', '\n', '  struct Encounter {\n', '    mapping (address => ParticipantData) participantData;\n', '    address[] participants;\n', '  }\n', '\n', '  //encounterId is the starting block number / encounterBlockDuration\n', '  mapping (uint => Encounter) encountersById;\n', '\n', '  mapping (uint => address) winnerPerDay;\n', '  mapping (uint => mapping (address => uint)) dayToAddressToScore;\n', '  mapping (uint => bool) dailyLootClaimedPerDay;\n', '\n', '   uint constant encounterBlockDuration = 80;\n', '   uint constant blocksInADay = 5760;\n', '\n', '//   uint constant encounterBlockDuration = 20;\n', '//   uint constant blocksInADay = 60;    // must be a multiple of encounterBlockDuration\n', '\n', '  uint256 gasRefundForClaimLoot = 279032000000000;\n', '  uint256 gasRefundForClaimConsolationPrizeLoot = 279032000000000;\n', '  uint256 gasRefundForClaimLootWithConsolationPrize = 279032000000000;\n', '\n', '  uint participateFee = 0.002 ether;\n', '  uint participateDailyLootContribution = 0.001 ether;\n', '\n', '  constructor() public {\n', '\n', '    paused = false;\n', '\n', '    ceoAddress = msg.sender;\n', '    cooAddress = msg.sender;\n', '    cfoAddress = msg.sender;\n', '    withdrawalAddress = msg.sender;\n', '  }\n', '  \n', '  function setGasRefundForClaimLoot(uint256 _gasRefundForClaimLoot) external onlyCEO {\n', '      gasRefundForClaimLoot = _gasRefundForClaimLoot;\n', '  }\n', '\n', '  function setGasRefundForClaimConsolationPrizeLoot(uint256 _gasRefundForClaimConsolationPrizeLoot) external onlyCEO {\n', '      gasRefundForClaimConsolationPrizeLoot = _gasRefundForClaimConsolationPrizeLoot;\n', '  }\n', '\n', '  function setGasRefundForClaimLootWithConsolationPrize(uint256 _gasRefundForClaimLootWithConsolationPrize) external onlyCEO {\n', '      gasRefundForClaimLootWithConsolationPrize = _gasRefundForClaimLootWithConsolationPrize;\n', '  }\n', '\n', '  function setParticipateFee(uint _participateFee) public onlyCLevel {\n', '    participateFee = _participateFee;\n', '  }\n', '\n', '  function setParticipateDailyLootContribution(uint _participateDailyLootContribution) public onlyCLevel {\n', '    participateDailyLootContribution = _participateDailyLootContribution;\n', '  }\n', '\n', '  function getFirstEncounterIdFromDay(uint day) internal pure returns (uint) {\n', '    return (day * blocksInADay) / encounterBlockDuration;\n', '  }\n', '\n', '  function leaderboardEntries(uint day) public view returns\n', '    (uint etherPot, bool dailyLootClaimed, uint blockDeadline, address[] memory entryAddresses, uint[] memory entryDamages) {    \n', '\n', '    dailyLootClaimed = dailyLootClaimedPerDay[day];\n', '    blockDeadline = (((day+1) * blocksInADay) / encounterBlockDuration) * encounterBlockDuration;\n', '\n', '    uint participantCount = 0;\n', '    etherPot = 0;\n', '\n', '    for (uint encounterId = getFirstEncounterIdFromDay(day); encounterId < getFirstEncounterIdFromDay(day+1); encounterId++)\n', '    {\n', '      address[] storage participants = encountersById[encounterId].participants;\n', '      participantCount += participants.length;\n', '      etherPot += participateDailyLootContribution * participants.length;\n', '    }\n', '\n', '    entryAddresses = new address[](participantCount);\n', '    entryDamages = new uint[](participantCount);\n', '\n', '    participantCount = 0;\n', '\n', '    for (encounterId = getFirstEncounterIdFromDay(day); encounterId < getFirstEncounterIdFromDay(day+1); encounterId++)\n', '    {\n', '      participants = encountersById[encounterId].participants;\n', '      mapping (address => ParticipantData) participantData = encountersById[encounterId].participantData;\n', '      for (uint i = 0; i < participants.length; i++)\n', '      {\n', '        address participant = participants[i];\n', '        entryAddresses[participantCount] = participant;\n', '        entryDamages[participantCount] = participantData[participant].damage;\n', '        participantCount++;\n', '      }\n', '    }\n', '  }\n', '\n', '  function claimDailyLoot(uint day) public {\n', '    require(!dailyLootClaimedPerDay[day]);\n', '    require(winnerPerDay[day] == msg.sender);\n', '\n', '    uint firstEncounterId = day * blocksInADay / encounterBlockDuration;\n', '    uint firstEncounterIdTomorrow = ((day+1) * blocksInADay / encounterBlockDuration);\n', '    uint etherPot = 0;\n', '    for (uint encounterId = firstEncounterId; encounterId < firstEncounterIdTomorrow; encounterId++)\n', '    {\n', '      etherPot += participateDailyLootContribution * encountersById[encounterId].participants.length;\n', '    }\n', '\n', '    dailyLootClaimedPerDay[day] = true;\n', '\n', '    msg.sender.transfer(etherPot);\n', '\n', '    emit DailyLootClaimed(day);\n', '  }\n', '\n', '  function blockBeforeEncounter(uint encounterId) private pure returns (uint) {\n', '    return encounterId*encounterBlockDuration - 1;\n', '  }\n', '\n', '  function getEncounterDetails() public view\n', '    returns (uint encounterId, uint encounterFinishedBlockNumber, bool isParticipating, uint day, uint monsterDna) {\n', '    encounterId = block.number / encounterBlockDuration;\n', '    encounterFinishedBlockNumber = (encounterId+1) * encounterBlockDuration;\n', '    Encounter storage encounter = encountersById[encounterId];\n', '    isParticipating = (encounter.participantData[msg.sender].damage != 0);\n', '    day = (encounterId * encounterBlockDuration) / blocksInADay;\n', '    monsterDna = uint(blockhash(blockBeforeEncounter(encounterId)));\n', '  }\n', '\n', '  function getParticipants(uint encounterId) public view returns (address[]) {\n', '\n', '    Encounter storage encounter = encountersById[encounterId];\n', '    return encounter.participants;\n', '  }\n', '\n', '  function calculateWinner(uint numParticipants, Encounter storage encounter, uint blockToHash) internal view returns\n', '    (address winnerAddress, uint rand, uint totalDamageDealt) {\n', '\n', '    if (numParticipants == 0) {\n', '      return;\n', '    }\n', '\n', '    totalDamageDealt = encounter.participantData[encounter.participants[numParticipants-1]].cumulativeDamage;\n', '\n', '    rand = uint(keccak256(blockhash(blockToHash)));\n', '    uint winnerDamageValue = rand % totalDamageDealt;\n', '\n', '    uint winnerIndex = numParticipants;\n', '\n', '    // binary search for a value winnerIndex where\n', '    // winnerDamageValue < cumulativeDamage[winnerIndex] and \n', '    // winnerDamageValue >= cumulativeDamage[winnerIndex-1]\n', '\n', '    uint min = 0;\n', '    uint max = numParticipants - 1;\n', '    while(max >= min) {\n', '      uint guess = (min+max)/2;\n', '      if (guess > 0 && winnerDamageValue < encounter.participantData[encounter.participants[guess-1]].cumulativeDamage) {\n', '        max = guess-1;\n', '      }\n', '      else if (winnerDamageValue >= encounter.participantData[encounter.participants[guess]].cumulativeDamage) {\n', '        min = guess+1;\n', '      } else {\n', '        winnerIndex = guess;\n', '        break;\n', '      }\n', '\n', '    }\n', '\n', '    require(winnerIndex < numParticipants, "error in binary search");\n', '\n', '    winnerAddress = encounter.participants[winnerIndex];\n', '  }\n', '\n', '  function getBlockToHashForResults(uint encounterId) public view returns (uint) {\n', '      \n', '    uint blockToHash = (encounterId+1)*encounterBlockDuration - 1;\n', '    \n', '    require(block.number > blockToHash);\n', '    \n', '    uint diff = block.number - (blockToHash+1);\n', '    if (diff > 255) {\n', '        blockToHash += (diff/256)*256;\n', '    }\n', '    \n', '    return blockToHash;\n', '  }\n', '  \n', '  function getEncounterResults(uint encounterId, address player) public view returns (\n', '    address winnerAddress, uint lootTokenId, uint consolationPrizeTokenId,\n', '    bool lootClaimed, uint damageDealt, uint totalDamageDealt) {\n', '\n', '    uint blockToHash = getBlockToHashForResults(encounterId);\n', '\n', '    Encounter storage encounter = encountersById[encounterId];\n', '    uint numParticipants = encounter.participants.length;\n', '    if (numParticipants == 0) {\n', '      return (address(0), 0, 0, false, 0, 0);\n', '    }\n', '\n', '    damageDealt = encounter.participantData[player].damage;\n', '\n', '    uint rand;\n', '    (winnerAddress, rand, totalDamageDealt) = calculateWinner(numParticipants, encounter, blockToHash);\n', '\n', '    lootTokenId = constructWeaponTokenIdForWinner(rand, numParticipants);\n', '\n', '    lootClaimed = true;\n', '    consolationPrizeTokenId = getConsolationPrizeTokenId(encounterId, player);\n', '\n', '    if (consolationPrizeTokenId != 0) {\n', '        lootClaimed = encounter.participantData[player].consolationPrizeClaimed;\n', '        \n', '        // This way has problems:\n', '    //   lootClaimed = tokenContract.exists(consolationPrizeTokenId);\n', '    }\n', '  }\n', '  \n', '    function getLootClaimed(uint encounterId, address player) external view returns (bool, bool) {\n', '        ParticipantData memory participantData = encountersById[encounterId].participantData[player];\n', '        return (\n', '            participantData.lootClaimed,\n', '            participantData.consolationPrizeClaimed\n', '        );\n', '    }\n', '\n', '  function constructWeaponTokenIdForWinner(uint rand, uint numParticipants) pure internal returns (uint) {\n', '\n', '    uint rarity = 0;\n', '    if (numParticipants > 1) rarity = 1;\n', '    if (numParticipants > 10) rarity = 2;\n', '\n', '    return constructWeaponTokenId(rand, rarity, 0);\n', '  }\n', '\n', '  function getWeaponRarityFromTokenId(uint tokenId) pure internal returns (uint) {\n', '    return tokenId & 0xff;\n', '  }  \n', '\n', '  // damageType: 0=physical 1=magic 2=water 3=earth 4=fire\n', '  function getWeaponDamageFromTokenId(uint tokenId, uint damageType) pure internal returns (uint) {\n', '    return ((tokenId >> (64 + damageType*8)) & 0xff);\n', '  }  \n', '\n', '  function getPureWeaponDamageFromTokenId(uint tokenId) pure internal returns (uint) {\n', '    return ((tokenId >> (56)) & 0xff);\n', '  }  \n', '\n', '  function getMonsterDefenseFromDna(uint monsterDna, uint damageType) pure internal returns (uint) {\n', '    return ((monsterDna >> (64 + damageType*8)) & 0xff);\n', '  }\n', '\n', '\n', '  // constant lookup table\n', '\n', '  bytes10 constant elementsAvailableForCommon =     hex"01020408100102040810";   // Each byte has 1 bit set\n', '  bytes10 constant elementsAvailableForRare =       hex"030506090A0C11121418";   // Each byte has 2 bits set\n', '  bytes10 constant elementsAvailableForEpic =       hex"070B0D0E131516191A1C";   // 3 bits\n', '  bytes10 constant elementsAvailableForLegendary =  hex"0F171B1D1E0F171B1D1E";   // 4 bits\n', '\n', '  // rarity 0: common (1 element)\n', '  // rarity 1: rare (2 elements)\n', '  // rarity 2: epic (3 elements)\n', '  // rarity 3: legendary (4 elements)\n', '  // rarity 4: ultimate (all 5 elements)\n', '  function constructWeaponTokenId(uint rand, uint rarity, uint pureDamage) pure internal returns (uint) {\n', '    uint lootTokenId = (rand & 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000) + rarity;\n', '\n', '    bytes10[4] memory elementsAvailablePerRarity = [\n', '      elementsAvailableForCommon,\n', '      elementsAvailableForRare,\n', '      elementsAvailableForEpic,\n', '      elementsAvailableForLegendary\n', '      ];\n', '\n', '    bytes10 elementsAvailable = elementsAvailablePerRarity[rarity];\n', '    // Select a random byte in elementsAvailable\n', '    uint8 elementsUsed = uint8(elementsAvailable[((rand >> 104) & 0xffff) % 10]);\n', '    // The bits of elementsUsed represent which elements we will allow this weapon to deal damage for\n', '    // Zero out the other element damages\n', '    for (uint i = 0; i < 5; i++) {\n', '      if ((elementsUsed & (1 << i)) == 0) {\n', '        lootTokenId = lootTokenId & ~(0xff << (64 + i*8));\n', '      }\n', '    }\n', '\n', '    pureDamage = Math.min256(100, pureDamage);\n', '\n', '    lootTokenId = lootTokenId | (pureDamage << 56);\n', '\n', '    return lootTokenId;\n', '  }\n', '\n', '  function weaponTokenIdToDamageForEncounter(uint weaponTokenId, uint encounterId) view internal returns (uint) {\n', '    uint monsterDna = uint(blockhash(encounterId*encounterBlockDuration - 1));\n', '\n', '    uint physicalDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 0)) - int(getMonsterDefenseFromDna(monsterDna, 0))));\n', '    uint fireDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 4)) - int(getMonsterDefenseFromDna(monsterDna, 4))));\n', '    uint earthDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 3)) - int(getMonsterDefenseFromDna(monsterDna, 3))));\n', '    uint waterDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 2)) - int(getMonsterDefenseFromDna(monsterDna, 2))));\n', '    uint magicDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 1)) - int(getMonsterDefenseFromDna(monsterDna, 1))));\n', '    uint pureDamage = getPureWeaponDamageFromTokenId(weaponTokenId);\n', '\n', '    uint damage = physicalDamage + fireDamage + earthDamage + waterDamage + magicDamage + pureDamage;\n', '    damage = Math.max256(1, damage);\n', '\n', '    return damage;\n', '  }\n', '\n', '  function forgeWeaponPureDamage(uint sacrificeTokenId1, uint sacrificeTokenId2, uint sacrificeTokenId3, uint sacrificeTokenId4)\n', '    internal pure returns (uint8) {\n', '    if (sacrificeTokenId1 == 0) {\n', '      return 0;\n', '    }\n', '    return uint8(Math.min256(255,\n', '        getPureWeaponDamageFromTokenId(sacrificeTokenId1) +\n', '        getPureWeaponDamageFromTokenId(sacrificeTokenId2) +\n', '        getPureWeaponDamageFromTokenId(sacrificeTokenId3) +\n', '        getPureWeaponDamageFromTokenId(sacrificeTokenId4)));\n', '  }\n', '\n', '  function forgeWeaponRarity(uint sacrificeTokenId1, uint sacrificeTokenId2, uint sacrificeTokenId3, uint sacrificeTokenId4)\n', '    internal pure returns (uint8) {\n', '    if (sacrificeTokenId1 == 0) {\n', '      return 0;\n', '    }\n', '    uint rarity = getWeaponRarityFromTokenId(sacrificeTokenId1);\n', '    rarity = Math.min256(rarity, getWeaponRarityFromTokenId(sacrificeTokenId2));\n', '    rarity = Math.min256(rarity, getWeaponRarityFromTokenId(sacrificeTokenId3));\n', '    rarity = Math.min256(rarity, getWeaponRarityFromTokenId(sacrificeTokenId4)) + 1;\n', '    require(rarity < 5, "cant forge an ultimate weapon");\n', '    return uint8(rarity);\n', '  }\n', '\n', '  function participate(uint encounterId, uint weaponTokenId,\n', '    uint sacrificeTokenId1, uint sacrificeTokenId2, uint sacrificeTokenId3, uint sacrificeTokenId4) public whenNotPaused payable {\n', '    require(msg.value >= participateFee);  // half goes to dev, half goes to ether pot\n', '\n', '    require(encounterId == block.number / encounterBlockDuration, "a new encounter is available");\n', '\n', '    Encounter storage encounter = encountersById[encounterId];\n', '\n', '    require(encounter.participantData[msg.sender].damage == 0, "you are already participating");\n', '\n', '    uint damage = 1;\n', '    // weaponTokenId of zero means they are using their fists\n', '    if (weaponTokenId != 0) {\n', '      require(tokenContract.ownerOf(weaponTokenId) == msg.sender, "you dont own that weapon");\n', '      damage = weaponTokenIdToDamageForEncounter(weaponTokenId, encounterId);\n', '    }\n', '\n', '    uint day = (encounterId * encounterBlockDuration) / blocksInADay;\n', '    uint newScore = dayToAddressToScore[day][msg.sender] + damage;\n', '    dayToAddressToScore[day][msg.sender] = newScore;\n', '\n', '    if (newScore > dayToAddressToScore[day][winnerPerDay[day]] &&\n', '      winnerPerDay[day] != msg.sender) {\n', '      winnerPerDay[day] = msg.sender;\n', '    }\n', '\n', '    uint cumulativeDamage = damage;\n', '    if (encounter.participants.length > 0) {\n', '      cumulativeDamage = cumulativeDamage + encounter.participantData[encounter.participants[encounter.participants.length-1]].cumulativeDamage;\n', '    }\n', '\n', '    if (sacrificeTokenId1 != 0) {\n', '\n', '      // the requires in the transfer functions here will verify\n', '      // that msg.sender owns all of these tokens and they are unique\n', '\n', '      // burn all four input tokens\n', '\n', '      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId1);\n', '      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId2);\n', '      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId3);\n', '      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId4);\n', '    }\n', '\n', '    encounter.participantData[msg.sender] = ParticipantData(uint32(damage), uint64(cumulativeDamage), \n', '      forgeWeaponRarity(sacrificeTokenId1, sacrificeTokenId2, sacrificeTokenId3, sacrificeTokenId4),\n', '      forgeWeaponPureDamage(sacrificeTokenId1, sacrificeTokenId2, sacrificeTokenId3, sacrificeTokenId4),\n', '      false, false);\n', '    encounter.participants.push(msg.sender);\n', '\n', '    emit Participating(msg.sender, encounterId);\n', '  }\n', '\n', '  function claimLoot(uint encounterId, address player) public whenNotPaused {\n', '    address winnerAddress;\n', '    uint lootTokenId;\n', '    uint consolationPrizeTokenId;\n', '    (winnerAddress, lootTokenId, consolationPrizeTokenId, , ,,) = getEncounterResults(encounterId, player);\n', '    require(winnerAddress == player, "player is not the winner");\n', '\n', '    ParticipantData storage participantData = encountersById[encounterId].participantData[player];\n', '\n', '    require(!participantData.lootClaimed, "loot already claimed");\n', '\n', '    participantData.lootClaimed = true;\n', '    tokenContract.mint(player, lootTokenId);\n', '\n', '    // The winner also gets a consolation prize\n', '    // It&#39;s possible he called claimConsolationPrizeLoot first, so allow that\n', '\n', '    require(consolationPrizeTokenId != 0, "consolation prize invalid");\n', '\n', '    if (!participantData.consolationPrizeClaimed) {\n', '        participantData.consolationPrizeClaimed = true;\n', '        // this will throw if the token already exists\n', '        tokenContract.mint(player, consolationPrizeTokenId);\n', '\n', '        // refund gas\n', '        msg.sender.transfer(gasRefundForClaimLootWithConsolationPrize);\n', '    } else {\n', '        \n', '        // refund gas\n', '        msg.sender.transfer(gasRefundForClaimLoot);\n', '    }\n', '\n', '    emit LootClaimed(player, encounterId);\n', '  }\n', '\n', '  function getConsolationPrizeTokenId(uint encounterId, address player) internal view returns (uint) {\n', '\n', '    ParticipantData memory participantData = encountersById[encounterId].participantData[player];\n', '    if (participantData.damage == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint blockToHash = getBlockToHashForResults(encounterId);\n', '\n', '    uint rand = uint(keccak256(uint(blockhash(blockToHash)) ^ uint(player)));\n', '\n', '    if (participantData.forgeWeaponRarity != 0) {\n', '      return constructWeaponTokenId(rand, participantData.forgeWeaponRarity, participantData.forgeWeaponDamagePure);\n', '    }\n', '\n', '    return constructWeaponTokenId(rand, 0, 0);\n', '  }\n', '\n', '  function claimConsolationPrizeLoot(uint encounterId, address player) public whenNotPaused {\n', '    uint lootTokenId = getConsolationPrizeTokenId(encounterId, player);\n', '    require(lootTokenId != 0, "player didnt participate");\n', '\n', '    ParticipantData storage participantData = encountersById[encounterId].participantData[player];\n', '    require(!participantData.consolationPrizeClaimed, "consolation prize already claimed");\n', '\n', '    participantData.consolationPrizeClaimed = true;\n', '    tokenContract.mint(player, lootTokenId);\n', '\n', '    msg.sender.transfer(gasRefundForClaimConsolationPrizeLoot);\n', '\n', '    emit LootClaimed(player, encounterId);\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return tokenContract.balanceOf(_owner);\n', '  }\n', '\n', '  function tokensOf(address _owner) public view returns (uint256[]) {\n', '    return tokenContract.tokensOf(_owner);\n', '  }\n', '\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index)\n', '    external\n', '    view\n', '    returns (uint256 _tokenId)\n', '  {\n', '    return tokenContract.tokenOfOwnerByIndex(_owner, _index);\n', '  }\n', '}']
['pragma solidity ^0.4.17;\n', '\n', '/**\n', ' * @title ERC721 interface\n', ' * @dev see https://github.com/ethereum/eips/issues/721\n', ' */\n', '\n', '/* solium-disable zeppelin/missing-natspec-comments */\n', 'contract ERC721 {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n', '  function transfer(address _to, uint256 _tokenId) external;\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function approve(address _to, uint256 _tokenId) external;\n', '  function setApprovalForAll(address _to, bool _approved) external;\n', '  function getApproved(uint256 _tokenId) public view returns (address);\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '}\n', '\n', 'interface ERC165 {\n', '    /// @notice Query if a contract implements an interface\n', '    /// @param interfaceID The interface identifier, as specified in ERC-165\n', '    /// @dev Interface identification is specified in ERC-165. This function\n', '    ///  uses less than 30,000 gas.\n', '    /// @return `true` if the contract implements `interfaceID` and\n', '    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', '/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\n', 'interface ERC721TokenReceiver {\n', '    /// @notice Handle the receipt of an NFT\n', '    /// @dev The ERC721 smart contract calls this function on the recipient\n', '    ///  after a `transfer`. This function MAY throw to revert and reject the\n', '    ///  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    ///  than the magic value MUST result in the transaction being reverted.\n', '    ///  Note: the contract address is always the message sender.\n', '    /// @param _from The sending address\n', '    /// @param _tokenId The NFT identifier which is being transfered\n', '    /// @param _data Additional data with no specified format\n', '    /// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '    ///  unless throwing\n', '  function onERC721Received(address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '}\n', 'library Strings {\n', '  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n', '  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n', '      bytes memory _ba = bytes(_a);\n', '      bytes memory _bb = bytes(_b);\n', '      bytes memory _bc = bytes(_c);\n', '      bytes memory _bd = bytes(_d);\n', '      bytes memory _be = bytes(_e);\n', '      string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '      bytes memory babcde = bytes(abcde);\n', '      uint k = 0;\n', '      for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '      for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '      for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '      for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '      for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '      return string(babcde);\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n', '        return strConcat(_a, _b, _c, _d, "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n', '        return strConcat(_a, _b, _c, "", "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b) internal pure returns (string) {\n', '        return strConcat(_a, _b, "", "", "");\n', '    }\n', '\n', '    function uint2str(uint i) internal pure returns (string) {\n', '        if (i == 0) return "0";\n', '        uint j = i;\n', '        uint len;\n', '        while (j != 0){\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len - 1;\n', '        while (i != 0){\n', '            bstr[k--] = byte(48 + i % 10);\n', '            i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\n', 'interface ERC721Metadata /* is ERC721 */ {\n', '    /// @notice A descriptive name for a collection of NFTs in this contract\n', '    function name() external pure returns (string _name);\n', '\n', '    /// @notice An abbreviated name for NFTs in this contract\n', '    function symbol() external pure returns (string _symbol);\n', '\n', '    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n', '    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n', '    ///  3986. The URI may point to a JSON file that conforms to the "ERC721\n', '    ///  Metadata JSON Schema".\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', 'contract ERC721SlimToken is Ownable, ERC721, ERC165, ERC721Metadata {\n', '  using SafeMath for uint256;\n', '\n', '  string public constant NAME = "EtherLoot";\n', '  string public constant SYMBOL = "ETLT";\n', '  string public tokenMetadataBaseURI = "http://api.etherloot.moonshadowgames.com/tokenmetadata/";\n', '\n', '  struct AddressAndTokenIndex {\n', '    address owner;\n', '    uint32 tokenIndex;\n', '  }\n', '\n', '  mapping (uint256 => AddressAndTokenIndex) private tokenOwnerAndTokensIndex;\n', '\n', '  mapping (address => uint256[]) private ownedTokens;\n', '\n', '  mapping (uint256 => address) private tokenApprovals;\n', '\n', '  mapping (address => mapping (address => bool)) private operatorApprovals;\n', '\n', '  mapping (address => bool) private approvedContractAddresses;\n', '\n', '  bool approvedContractsFinalized = false;\n', '\n', '  function implementsERC721() external pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '\n', '\n', '  function supportsInterface(\n', '    bytes4 interfaceID)\n', '    external view returns (bool)\n', '  {\n', '    return\n', '      interfaceID == this.supportsInterface.selector || // ERC165\n', '      interfaceID == 0x5b5e139f || // ERC721Metadata\n', '      interfaceID == 0x6466353c; // ERC-721\n', '  }\n', '\n', '  function name() external pure returns (string) {\n', '    return NAME;\n', '  }\n', '\n', '  function symbol() external pure returns (string) {\n', '    return SYMBOL;\n', '  }\n', '\n', '  function setTokenMetadataBaseURI(string _tokenMetadataBaseURI) external onlyOwner {\n', '    tokenMetadataBaseURI = _tokenMetadataBaseURI;\n', '  }\n', '\n', '  function tokenURI(uint256 tokenId)\n', '    external\n', '    view\n', '    returns (string infoUrl)\n', '  {\n', '    return Strings.strConcat(\n', '      tokenMetadataBaseURI,\n', '      Strings.uint2str(tokenId));\n', '  }\n', '\n', '  /**\n', '  * @notice Guarantees msg.sender is owner of the given token\n', '  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n', '  */\n', '  modifier onlyOwnerOf(uint256 _tokenId) {\n', '    require(ownerOf(_tokenId) == msg.sender, "not owner");\n', '    _;\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the balance of the specified address\n', '  * @param _owner address to query the balance of\n', '  * @return uint256 representing the amount owned by the passed address\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    require(_owner != address(0), "null owner");\n', '    return ownedTokens[_owner].length;\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the list of tokens owned by a given address\n', '  * @param _owner address to query the tokens of\n', '  * @return uint256[] representing the list of tokens owned by the passed address\n', '  */\n', '  function tokensOf(address _owner) public view returns (uint256[]) {\n', '    return ownedTokens[_owner];\n', '  }\n', '\n', '  /**\n', '  * @notice Enumerate NFTs assigned to an owner\n', '  * @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '  *  `_owner` is the zero address, representing invalid NFTs.\n', '  * @param _owner An address where we are interested in NFTs owned by them\n', '  * @param _index A counter less than `balanceOf(_owner)`\n', '  * @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '  */\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index)\n', '    external\n', '    view\n', '    returns (uint256 _tokenId)\n', '  {\n', '    require(_index < balanceOf(_owner), "invalid index");\n', '    return ownedTokens[_owner][_index];\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the owner of the specified token ID\n', '  * @param _tokenId uint256 ID of the token to query the owner of\n', '  * @return owner address currently marked as the owner of the given token ID\n', '  */\n', '  function ownerOf(uint256 _tokenId) public view returns (address) {\n', '    address _owner = tokenOwnerAndTokensIndex[_tokenId].owner;\n', '    require(_owner != address(0), "invalid owner");\n', '    return _owner;\n', '  }\n', '\n', '  function exists(uint256 _tokenId) public view returns (bool) {\n', '    address _owner = tokenOwnerAndTokensIndex[_tokenId].owner;\n', '    return (_owner != address(0));\n', '  }\n', '\n', '  /**\n', '   * @notice Gets the approved address to take ownership of a given token ID\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return address currently approved to take ownership of the given token ID\n', '   */\n', '  function getApproved(uint256 _tokenId) public view returns (address) {\n', '    return tokenApprovals[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @notice Tells whether the msg.sender is approved to transfer the given token ID or not\n', '   * Checks both for specific approval and operator approval\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return bool whether transfer by msg.sender is approved for the given token ID or not\n', '   */\n', '  function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {\n', '    return\n', '      ownerOf(_tokenId) == msg.sender ||\n', '      isSpecificallyApprovedFor(msg.sender, _tokenId) ||\n', '      isApprovedForAll(ownerOf(_tokenId), msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @notice Tells whether the msg.sender is approved for the given token ID or not\n', '   * @param _asker address of asking for approval\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return bool whether the msg.sender is approved for the given token ID or not\n', '   */\n', '  function isSpecificallyApprovedFor(address _asker, uint256 _tokenId) internal view returns (bool) {\n', '    return getApproved(_tokenId) == _asker;\n', '  }\n', '\n', '  /**\n', '   * @notice Tells whether an operator is approved by a given owner\n', '   * @param _owner owner address which you want to query the approval of\n', '   * @param _operator operator address which you want to query the approval of\n', '   * @return bool whether the given operator is approved by the given owner\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool)\n', '  {\n', '    return operatorApprovals[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '  * @notice Transfers the ownership of a given token ID to another address\n', '  * @param _to address to receive the ownership of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function transfer(address _to, uint256 _tokenId)\n', '    external\n', '    onlyOwnerOf(_tokenId)\n', '  {\n', '    _clearApprovalAndTransfer(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Approves another address to claim for the ownership of the given token ID\n', '  * @param _to address to be approved for the given token ID\n', '  * @param _tokenId uint256 ID of the token to be approved\n', '  */\n', '  function approve(address _to, uint256 _tokenId)\n', '    external\n', '    onlyOwnerOf(_tokenId)\n', '  {\n', '    address _owner = ownerOf(_tokenId);\n', '    require(_to != _owner, "already owns");\n', '    if (getApproved(_tokenId) != 0 || _to != 0) {\n', '      tokenApprovals[_tokenId] = _to;\n', '      emit Approval(_owner, _to, _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Enable or disable approval for a third party ("operator") to manage all your assets\n', '  * @dev Emits the ApprovalForAll event\n', '  * @param _to Address to add to the set of authorized operators.\n', '  * @param _approved True if the operators is approved, false to revoke approval\n', '  */\n', '  function setApprovalForAll(address _to, bool _approved)\n', '    external\n', '  {\n', '    if(_approved) {\n', '      approveAll(_to);\n', '    } else {\n', '      disapproveAll(_to);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Approves another address to claim for the ownership of any tokens owned by this account\n', '  * @param _to address to be approved for the given token ID\n', '  */\n', '  function approveAll(address _to)\n', '    public\n', '  {\n', '    require(_to != msg.sender, "cant approve yourself");\n', '    require(_to != address(0), "invalid owner");\n', '    operatorApprovals[msg.sender][_to] = true;\n', '    emit ApprovalForAll(msg.sender, _to, true);\n', '  }\n', '\n', '  /**\n', '  * @notice Removes approval for another address to claim for the ownership of any\n', '  *  tokens owned by this account.\n', '  * @dev Note that this only removes the operator approval and\n', '  *  does not clear any independent, specific approvals of token transfers to this address\n', '  * @param _to address to be disapproved for the given token ID\n', '  */\n', '  function disapproveAll(address _to)\n', '    public\n', '  {\n', '    require(_to != msg.sender, "cant unapprove yourself");\n', '    delete operatorApprovals[msg.sender][_to];\n', '    emit ApprovalForAll(msg.sender, _to, false);\n', '  }\n', '\n', '  /**\n', '  * @notice Claims the ownership of a given token ID\n', '  * @param _tokenId uint256 ID of the token being claimed by the msg.sender\n', '  */\n', '  function takeOwnership(uint256 _tokenId)\n', '   external\n', '  {\n', '    require(isSenderApprovedFor(_tokenId), "not approved");\n', '    _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Transfer a token owned by another address, for which the calling address has\n', '  *  previously been granted transfer approval by the owner.\n', '  * @param _from The address that owns the token\n', '  * @param _to The address that will take ownership of the token. Can be any address, including the caller\n', '  * @param _tokenId The ID of the token to be transferred\n', '  */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '  {\n', '    address tokenOwner = ownerOf(_tokenId);\n', '    require(isSenderApprovedFor(_tokenId) || \n', '      (approvedContractAddresses[msg.sender] && tokenOwner == tx.origin), "not an approved sender");\n', '    require(tokenOwner == _from, "wrong owner");\n', '    _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Transfers the ownership of an NFT from one address to another address\n', '  * @dev Throws unless `msg.sender` is the current owner, an authorized\n', '  * operator, or the approved address for this NFT. Throws if `_from` is\n', '  * not the current owner. Throws if `_to` is the zero address. Throws if\n', '  * `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '  * checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '  * `onERC721Received` on `_to` and throws if the return value is not\n', '  * `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '  * @param _from The current owner of the NFT\n', '  * @param _to The new owner\n', '  * @param _tokenId The NFT to transfer\n', '  * @param _data Additional data with no specified format, sent in call to `_to`\n', '  */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public\n', '  {\n', '    require(_to != address(0), "invalid target address");\n', '    transferFrom(_from, _to, _tokenId);\n', '    if (_isContract(_to)) {\n', '      bytes4 tokenReceiverResponse = ERC721TokenReceiver(_to).onERC721Received.gas(50000)(\n', '        _from, _tokenId, _data\n', '      );\n', '      require(tokenReceiverResponse == bytes4(keccak256("onERC721Received(address,uint256,bytes)")), "invalid receiver respononse");\n', '    }\n', '  }\n', '\n', '  /*\n', '   * @notice Transfers the ownership of an NFT from one address to another address\n', '   * @dev This works identically to the other function with an extra data parameter,\n', '   *  except this function just sets data to ""\n', '   * @param _from The current owner of the NFT\n', '   * @param _to The new owner\n', '   * @param _tokenId The NFT to transfer\n', '  */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '  {\n', '    safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '  * @notice Approve a contract address for minting tokens and transferring tokens, when approved by the owner\n', '  * @param contractAddress The address that will be approved\n', '  */\n', '  function addApprovedContractAddress(address contractAddress) public onlyOwner\n', '  {\n', '    require(!approvedContractsFinalized);\n', '    approvedContractAddresses[contractAddress] = true;\n', '  }\n', '\n', '  /**\n', '  * @notice Unapprove a contract address for minting tokens and transferring tokens\n', '  * @param contractAddress The address that will be unapproved\n', '  */\n', '  function removeApprovedContractAddress(address contractAddress) public onlyOwner\n', '  {\n', '    require(!approvedContractsFinalized);\n', '    approvedContractAddresses[contractAddress] = false;\n', '  }\n', '\n', '  /**\n', '  * @notice Finalize the contract so it will be forever impossible to change the approved contracts list\n', '  */\n', '  function finalizeApprovedContracts() public onlyOwner {\n', '    approvedContractsFinalized = true;\n', '  }\n', '\n', '  /**\n', '  * @notice Mint token function\n', '  * @param _to The address that will own the minted token\n', '  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '  */\n', '  function mint(address _to, uint256 _tokenId) public {\n', '    require(\n', '      approvedContractAddresses[msg.sender] ||\n', '      msg.sender == owner, "minter not approved"\n', '    );\n', '    _mint(_to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Mint token function\n', '  * @param _to The address that will own the minted token\n', '  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '  */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0), "invalid target address");\n', '    require(tokenOwnerAndTokensIndex[_tokenId].owner == address(0), "token already exists");\n', '    _addToken(_to, _tokenId);\n', '    emit Transfer(0x0, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to clear current approval and transfer the ownership of a given token ID\n', '  * @param _from address which you want to send tokens from\n', '  * @param _to address which you want to transfer the token to\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function _clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0), "invalid target address");\n', '    require(_to != ownerOf(_tokenId), "already owns");\n', '    require(ownerOf(_tokenId) == _from, "wrong owner");\n', '\n', '    _clearApproval(_from, _tokenId);\n', '    _removeToken(_from, _tokenId);\n', '    _addToken(_to, _tokenId);\n', '    emit Transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to clear current approval of a given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function _clearApproval(address _owner, uint256 _tokenId) private {\n', '    require(ownerOf(_tokenId) == _owner, "wrong owner");\n', '    if (tokenApprovals[_tokenId] != 0) {\n', '      tokenApprovals[_tokenId] = 0;\n', '      emit Approval(_owner, 0, _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to add a token ID to the list of a given address\n', '  * @param _to address representing the new owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '  */\n', '  function _addToken(address _to, uint256 _tokenId) private {\n', '    uint256 newTokenIndex = ownedTokens[_to].length;\n', '    ownedTokens[_to].push(_tokenId);\n', '\n', "    // I don't expect anyone to own 4 billion tokens, but just in case...\n", '    require(newTokenIndex == uint256(uint32(newTokenIndex)), "overflow");\n', '\n', '    tokenOwnerAndTokensIndex[_tokenId] = AddressAndTokenIndex({owner: _to, tokenIndex: uint32(newTokenIndex)});\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to remove a token ID from the list of a given address\n', '  * @param _from address representing the previous owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '  */\n', '  function _removeToken(address _from, uint256 _tokenId) private {\n', '    require(ownerOf(_tokenId) == _from, "wrong owner");\n', '\n', '    uint256 tokenIndex = tokenOwnerAndTokensIndex[_tokenId].tokenIndex;\n', '    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n', '    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n', '\n', '    ownedTokens[_from][tokenIndex] = lastToken;\n', '\n', '    ownedTokens[_from].length--;\n', '    tokenOwnerAndTokensIndex[lastToken] = AddressAndTokenIndex({owner: _from, tokenIndex: uint32(tokenIndex)});\n', '  }\n', '\n', '  function _isContract(address addr) internal view returns (bool) {\n', '    uint size;\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '}\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function smax256(int256 a, int256 b) internal pure returns (int256) {\n', '    return a >= b ? a : b;\n', '  }\n', '}\n', '\n', 'contract ContractAccessControl {\n', '\n', '  event ContractUpgrade(address newContract);\n', '  event Paused();\n', '  event Unpaused();\n', '\n', '  address public ceoAddress;\n', '\n', '  address public cfoAddress;\n', '\n', '  address public cooAddress;\n', '\n', '  address public withdrawalAddress;\n', '\n', '  bool public paused = false;\n', '\n', '  modifier onlyCEO() {\n', '    require(msg.sender == ceoAddress);\n', '    _;\n', '  }\n', '\n', '  modifier onlyCFO() {\n', '    require(msg.sender == cfoAddress);\n', '    _;\n', '  }\n', '\n', '  modifier onlyCOO() {\n', '    require(msg.sender == cooAddress);\n', '    _;\n', '  }\n', '\n', '  modifier onlyCLevel() {\n', '    require(\n', '      msg.sender == cooAddress ||\n', '      msg.sender == ceoAddress ||\n', '      msg.sender == cfoAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier onlyCEOOrCFO() {\n', '    require(\n', '      msg.sender == cfoAddress ||\n', '      msg.sender == ceoAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier onlyCEOOrCOO() {\n', '    require(\n', '      msg.sender == cooAddress ||\n', '      msg.sender == ceoAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  function setCEO(address _newCEO) external onlyCEO {\n', '    require(_newCEO != address(0));\n', '    ceoAddress = _newCEO;\n', '  }\n', '\n', '  function setCFO(address _newCFO) external onlyCEO {\n', '    require(_newCFO != address(0));\n', '    cfoAddress = _newCFO;\n', '  }\n', '\n', '  function setCOO(address _newCOO) external onlyCEO {\n', '    require(_newCOO != address(0));\n', '    cooAddress = _newCOO;\n', '  }\n', '\n', '  function setWithdrawalAddress(address _newWithdrawalAddress) external onlyCEO {\n', '    require(_newWithdrawalAddress != address(0));\n', '    withdrawalAddress = _newWithdrawalAddress;\n', '  }\n', '\n', '  function withdrawBalance() external onlyCEOOrCFO {\n', '    require(withdrawalAddress != address(0));\n', '    withdrawalAddress.transfer(this.balance);\n', '  }\n', '\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  function pause() public onlyCLevel whenNotPaused {\n', '    paused = true;\n', '    emit Paused();\n', '  }\n', '\n', '  function unpause() public onlyCEO whenPaused {\n', '    paused = false;\n', '    emit Unpaused();\n', '  }\n', '}\n', '\n', 'contract CryptoBoss is ContractAccessControl {\n', '\n', '  address constant tokenContractAddress = 0xe1015a79a7d488f8fecf073b187d38c6f1a77368;\n', '  ERC721SlimToken constant tokenContract = ERC721SlimToken(tokenContractAddress);\n', '\n', '  event Participating(address indexed player, uint encounterId);\n', '  event LootClaimed(address indexed player, uint encounterId);\n', '  event DailyLootClaimed(uint day);\n', '\n', '  struct ParticipantData {\n', '    uint32 damage;\n', '    uint64 cumulativeDamage;\n', '    uint8 forgeWeaponRarity;\n', '    uint8 forgeWeaponDamagePure;\n', '    bool lootClaimed;\n', '    bool consolationPrizeClaimed;\n', '  }\n', '\n', '  struct Encounter {\n', '    mapping (address => ParticipantData) participantData;\n', '    address[] participants;\n', '  }\n', '\n', '  //encounterId is the starting block number / encounterBlockDuration\n', '  mapping (uint => Encounter) encountersById;\n', '\n', '  mapping (uint => address) winnerPerDay;\n', '  mapping (uint => mapping (address => uint)) dayToAddressToScore;\n', '  mapping (uint => bool) dailyLootClaimedPerDay;\n', '\n', '   uint constant encounterBlockDuration = 80;\n', '   uint constant blocksInADay = 5760;\n', '\n', '//   uint constant encounterBlockDuration = 20;\n', '//   uint constant blocksInADay = 60;    // must be a multiple of encounterBlockDuration\n', '\n', '  uint256 gasRefundForClaimLoot = 279032000000000;\n', '  uint256 gasRefundForClaimConsolationPrizeLoot = 279032000000000;\n', '  uint256 gasRefundForClaimLootWithConsolationPrize = 279032000000000;\n', '\n', '  uint participateFee = 0.002 ether;\n', '  uint participateDailyLootContribution = 0.001 ether;\n', '\n', '  constructor() public {\n', '\n', '    paused = false;\n', '\n', '    ceoAddress = msg.sender;\n', '    cooAddress = msg.sender;\n', '    cfoAddress = msg.sender;\n', '    withdrawalAddress = msg.sender;\n', '  }\n', '  \n', '  function setGasRefundForClaimLoot(uint256 _gasRefundForClaimLoot) external onlyCEO {\n', '      gasRefundForClaimLoot = _gasRefundForClaimLoot;\n', '  }\n', '\n', '  function setGasRefundForClaimConsolationPrizeLoot(uint256 _gasRefundForClaimConsolationPrizeLoot) external onlyCEO {\n', '      gasRefundForClaimConsolationPrizeLoot = _gasRefundForClaimConsolationPrizeLoot;\n', '  }\n', '\n', '  function setGasRefundForClaimLootWithConsolationPrize(uint256 _gasRefundForClaimLootWithConsolationPrize) external onlyCEO {\n', '      gasRefundForClaimLootWithConsolationPrize = _gasRefundForClaimLootWithConsolationPrize;\n', '  }\n', '\n', '  function setParticipateFee(uint _participateFee) public onlyCLevel {\n', '    participateFee = _participateFee;\n', '  }\n', '\n', '  function setParticipateDailyLootContribution(uint _participateDailyLootContribution) public onlyCLevel {\n', '    participateDailyLootContribution = _participateDailyLootContribution;\n', '  }\n', '\n', '  function getFirstEncounterIdFromDay(uint day) internal pure returns (uint) {\n', '    return (day * blocksInADay) / encounterBlockDuration;\n', '  }\n', '\n', '  function leaderboardEntries(uint day) public view returns\n', '    (uint etherPot, bool dailyLootClaimed, uint blockDeadline, address[] memory entryAddresses, uint[] memory entryDamages) {    \n', '\n', '    dailyLootClaimed = dailyLootClaimedPerDay[day];\n', '    blockDeadline = (((day+1) * blocksInADay) / encounterBlockDuration) * encounterBlockDuration;\n', '\n', '    uint participantCount = 0;\n', '    etherPot = 0;\n', '\n', '    for (uint encounterId = getFirstEncounterIdFromDay(day); encounterId < getFirstEncounterIdFromDay(day+1); encounterId++)\n', '    {\n', '      address[] storage participants = encountersById[encounterId].participants;\n', '      participantCount += participants.length;\n', '      etherPot += participateDailyLootContribution * participants.length;\n', '    }\n', '\n', '    entryAddresses = new address[](participantCount);\n', '    entryDamages = new uint[](participantCount);\n', '\n', '    participantCount = 0;\n', '\n', '    for (encounterId = getFirstEncounterIdFromDay(day); encounterId < getFirstEncounterIdFromDay(day+1); encounterId++)\n', '    {\n', '      participants = encountersById[encounterId].participants;\n', '      mapping (address => ParticipantData) participantData = encountersById[encounterId].participantData;\n', '      for (uint i = 0; i < participants.length; i++)\n', '      {\n', '        address participant = participants[i];\n', '        entryAddresses[participantCount] = participant;\n', '        entryDamages[participantCount] = participantData[participant].damage;\n', '        participantCount++;\n', '      }\n', '    }\n', '  }\n', '\n', '  function claimDailyLoot(uint day) public {\n', '    require(!dailyLootClaimedPerDay[day]);\n', '    require(winnerPerDay[day] == msg.sender);\n', '\n', '    uint firstEncounterId = day * blocksInADay / encounterBlockDuration;\n', '    uint firstEncounterIdTomorrow = ((day+1) * blocksInADay / encounterBlockDuration);\n', '    uint etherPot = 0;\n', '    for (uint encounterId = firstEncounterId; encounterId < firstEncounterIdTomorrow; encounterId++)\n', '    {\n', '      etherPot += participateDailyLootContribution * encountersById[encounterId].participants.length;\n', '    }\n', '\n', '    dailyLootClaimedPerDay[day] = true;\n', '\n', '    msg.sender.transfer(etherPot);\n', '\n', '    emit DailyLootClaimed(day);\n', '  }\n', '\n', '  function blockBeforeEncounter(uint encounterId) private pure returns (uint) {\n', '    return encounterId*encounterBlockDuration - 1;\n', '  }\n', '\n', '  function getEncounterDetails() public view\n', '    returns (uint encounterId, uint encounterFinishedBlockNumber, bool isParticipating, uint day, uint monsterDna) {\n', '    encounterId = block.number / encounterBlockDuration;\n', '    encounterFinishedBlockNumber = (encounterId+1) * encounterBlockDuration;\n', '    Encounter storage encounter = encountersById[encounterId];\n', '    isParticipating = (encounter.participantData[msg.sender].damage != 0);\n', '    day = (encounterId * encounterBlockDuration) / blocksInADay;\n', '    monsterDna = uint(blockhash(blockBeforeEncounter(encounterId)));\n', '  }\n', '\n', '  function getParticipants(uint encounterId) public view returns (address[]) {\n', '\n', '    Encounter storage encounter = encountersById[encounterId];\n', '    return encounter.participants;\n', '  }\n', '\n', '  function calculateWinner(uint numParticipants, Encounter storage encounter, uint blockToHash) internal view returns\n', '    (address winnerAddress, uint rand, uint totalDamageDealt) {\n', '\n', '    if (numParticipants == 0) {\n', '      return;\n', '    }\n', '\n', '    totalDamageDealt = encounter.participantData[encounter.participants[numParticipants-1]].cumulativeDamage;\n', '\n', '    rand = uint(keccak256(blockhash(blockToHash)));\n', '    uint winnerDamageValue = rand % totalDamageDealt;\n', '\n', '    uint winnerIndex = numParticipants;\n', '\n', '    // binary search for a value winnerIndex where\n', '    // winnerDamageValue < cumulativeDamage[winnerIndex] and \n', '    // winnerDamageValue >= cumulativeDamage[winnerIndex-1]\n', '\n', '    uint min = 0;\n', '    uint max = numParticipants - 1;\n', '    while(max >= min) {\n', '      uint guess = (min+max)/2;\n', '      if (guess > 0 && winnerDamageValue < encounter.participantData[encounter.participants[guess-1]].cumulativeDamage) {\n', '        max = guess-1;\n', '      }\n', '      else if (winnerDamageValue >= encounter.participantData[encounter.participants[guess]].cumulativeDamage) {\n', '        min = guess+1;\n', '      } else {\n', '        winnerIndex = guess;\n', '        break;\n', '      }\n', '\n', '    }\n', '\n', '    require(winnerIndex < numParticipants, "error in binary search");\n', '\n', '    winnerAddress = encounter.participants[winnerIndex];\n', '  }\n', '\n', '  function getBlockToHashForResults(uint encounterId) public view returns (uint) {\n', '      \n', '    uint blockToHash = (encounterId+1)*encounterBlockDuration - 1;\n', '    \n', '    require(block.number > blockToHash);\n', '    \n', '    uint diff = block.number - (blockToHash+1);\n', '    if (diff > 255) {\n', '        blockToHash += (diff/256)*256;\n', '    }\n', '    \n', '    return blockToHash;\n', '  }\n', '  \n', '  function getEncounterResults(uint encounterId, address player) public view returns (\n', '    address winnerAddress, uint lootTokenId, uint consolationPrizeTokenId,\n', '    bool lootClaimed, uint damageDealt, uint totalDamageDealt) {\n', '\n', '    uint blockToHash = getBlockToHashForResults(encounterId);\n', '\n', '    Encounter storage encounter = encountersById[encounterId];\n', '    uint numParticipants = encounter.participants.length;\n', '    if (numParticipants == 0) {\n', '      return (address(0), 0, 0, false, 0, 0);\n', '    }\n', '\n', '    damageDealt = encounter.participantData[player].damage;\n', '\n', '    uint rand;\n', '    (winnerAddress, rand, totalDamageDealt) = calculateWinner(numParticipants, encounter, blockToHash);\n', '\n', '    lootTokenId = constructWeaponTokenIdForWinner(rand, numParticipants);\n', '\n', '    lootClaimed = true;\n', '    consolationPrizeTokenId = getConsolationPrizeTokenId(encounterId, player);\n', '\n', '    if (consolationPrizeTokenId != 0) {\n', '        lootClaimed = encounter.participantData[player].consolationPrizeClaimed;\n', '        \n', '        // This way has problems:\n', '    //   lootClaimed = tokenContract.exists(consolationPrizeTokenId);\n', '    }\n', '  }\n', '  \n', '    function getLootClaimed(uint encounterId, address player) external view returns (bool, bool) {\n', '        ParticipantData memory participantData = encountersById[encounterId].participantData[player];\n', '        return (\n', '            participantData.lootClaimed,\n', '            participantData.consolationPrizeClaimed\n', '        );\n', '    }\n', '\n', '  function constructWeaponTokenIdForWinner(uint rand, uint numParticipants) pure internal returns (uint) {\n', '\n', '    uint rarity = 0;\n', '    if (numParticipants > 1) rarity = 1;\n', '    if (numParticipants > 10) rarity = 2;\n', '\n', '    return constructWeaponTokenId(rand, rarity, 0);\n', '  }\n', '\n', '  function getWeaponRarityFromTokenId(uint tokenId) pure internal returns (uint) {\n', '    return tokenId & 0xff;\n', '  }  \n', '\n', '  // damageType: 0=physical 1=magic 2=water 3=earth 4=fire\n', '  function getWeaponDamageFromTokenId(uint tokenId, uint damageType) pure internal returns (uint) {\n', '    return ((tokenId >> (64 + damageType*8)) & 0xff);\n', '  }  \n', '\n', '  function getPureWeaponDamageFromTokenId(uint tokenId) pure internal returns (uint) {\n', '    return ((tokenId >> (56)) & 0xff);\n', '  }  \n', '\n', '  function getMonsterDefenseFromDna(uint monsterDna, uint damageType) pure internal returns (uint) {\n', '    return ((monsterDna >> (64 + damageType*8)) & 0xff);\n', '  }\n', '\n', '\n', '  // constant lookup table\n', '\n', '  bytes10 constant elementsAvailableForCommon =     hex"01020408100102040810";   // Each byte has 1 bit set\n', '  bytes10 constant elementsAvailableForRare =       hex"030506090A0C11121418";   // Each byte has 2 bits set\n', '  bytes10 constant elementsAvailableForEpic =       hex"070B0D0E131516191A1C";   // 3 bits\n', '  bytes10 constant elementsAvailableForLegendary =  hex"0F171B1D1E0F171B1D1E";   // 4 bits\n', '\n', '  // rarity 0: common (1 element)\n', '  // rarity 1: rare (2 elements)\n', '  // rarity 2: epic (3 elements)\n', '  // rarity 3: legendary (4 elements)\n', '  // rarity 4: ultimate (all 5 elements)\n', '  function constructWeaponTokenId(uint rand, uint rarity, uint pureDamage) pure internal returns (uint) {\n', '    uint lootTokenId = (rand & 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000) + rarity;\n', '\n', '    bytes10[4] memory elementsAvailablePerRarity = [\n', '      elementsAvailableForCommon,\n', '      elementsAvailableForRare,\n', '      elementsAvailableForEpic,\n', '      elementsAvailableForLegendary\n', '      ];\n', '\n', '    bytes10 elementsAvailable = elementsAvailablePerRarity[rarity];\n', '    // Select a random byte in elementsAvailable\n', '    uint8 elementsUsed = uint8(elementsAvailable[((rand >> 104) & 0xffff) % 10]);\n', '    // The bits of elementsUsed represent which elements we will allow this weapon to deal damage for\n', '    // Zero out the other element damages\n', '    for (uint i = 0; i < 5; i++) {\n', '      if ((elementsUsed & (1 << i)) == 0) {\n', '        lootTokenId = lootTokenId & ~(0xff << (64 + i*8));\n', '      }\n', '    }\n', '\n', '    pureDamage = Math.min256(100, pureDamage);\n', '\n', '    lootTokenId = lootTokenId | (pureDamage << 56);\n', '\n', '    return lootTokenId;\n', '  }\n', '\n', '  function weaponTokenIdToDamageForEncounter(uint weaponTokenId, uint encounterId) view internal returns (uint) {\n', '    uint monsterDna = uint(blockhash(encounterId*encounterBlockDuration - 1));\n', '\n', '    uint physicalDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 0)) - int(getMonsterDefenseFromDna(monsterDna, 0))));\n', '    uint fireDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 4)) - int(getMonsterDefenseFromDna(monsterDna, 4))));\n', '    uint earthDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 3)) - int(getMonsterDefenseFromDna(monsterDna, 3))));\n', '    uint waterDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 2)) - int(getMonsterDefenseFromDna(monsterDna, 2))));\n', '    uint magicDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 1)) - int(getMonsterDefenseFromDna(monsterDna, 1))));\n', '    uint pureDamage = getPureWeaponDamageFromTokenId(weaponTokenId);\n', '\n', '    uint damage = physicalDamage + fireDamage + earthDamage + waterDamage + magicDamage + pureDamage;\n', '    damage = Math.max256(1, damage);\n', '\n', '    return damage;\n', '  }\n', '\n', '  function forgeWeaponPureDamage(uint sacrificeTokenId1, uint sacrificeTokenId2, uint sacrificeTokenId3, uint sacrificeTokenId4)\n', '    internal pure returns (uint8) {\n', '    if (sacrificeTokenId1 == 0) {\n', '      return 0;\n', '    }\n', '    return uint8(Math.min256(255,\n', '        getPureWeaponDamageFromTokenId(sacrificeTokenId1) +\n', '        getPureWeaponDamageFromTokenId(sacrificeTokenId2) +\n', '        getPureWeaponDamageFromTokenId(sacrificeTokenId3) +\n', '        getPureWeaponDamageFromTokenId(sacrificeTokenId4)));\n', '  }\n', '\n', '  function forgeWeaponRarity(uint sacrificeTokenId1, uint sacrificeTokenId2, uint sacrificeTokenId3, uint sacrificeTokenId4)\n', '    internal pure returns (uint8) {\n', '    if (sacrificeTokenId1 == 0) {\n', '      return 0;\n', '    }\n', '    uint rarity = getWeaponRarityFromTokenId(sacrificeTokenId1);\n', '    rarity = Math.min256(rarity, getWeaponRarityFromTokenId(sacrificeTokenId2));\n', '    rarity = Math.min256(rarity, getWeaponRarityFromTokenId(sacrificeTokenId3));\n', '    rarity = Math.min256(rarity, getWeaponRarityFromTokenId(sacrificeTokenId4)) + 1;\n', '    require(rarity < 5, "cant forge an ultimate weapon");\n', '    return uint8(rarity);\n', '  }\n', '\n', '  function participate(uint encounterId, uint weaponTokenId,\n', '    uint sacrificeTokenId1, uint sacrificeTokenId2, uint sacrificeTokenId3, uint sacrificeTokenId4) public whenNotPaused payable {\n', '    require(msg.value >= participateFee);  // half goes to dev, half goes to ether pot\n', '\n', '    require(encounterId == block.number / encounterBlockDuration, "a new encounter is available");\n', '\n', '    Encounter storage encounter = encountersById[encounterId];\n', '\n', '    require(encounter.participantData[msg.sender].damage == 0, "you are already participating");\n', '\n', '    uint damage = 1;\n', '    // weaponTokenId of zero means they are using their fists\n', '    if (weaponTokenId != 0) {\n', '      require(tokenContract.ownerOf(weaponTokenId) == msg.sender, "you dont own that weapon");\n', '      damage = weaponTokenIdToDamageForEncounter(weaponTokenId, encounterId);\n', '    }\n', '\n', '    uint day = (encounterId * encounterBlockDuration) / blocksInADay;\n', '    uint newScore = dayToAddressToScore[day][msg.sender] + damage;\n', '    dayToAddressToScore[day][msg.sender] = newScore;\n', '\n', '    if (newScore > dayToAddressToScore[day][winnerPerDay[day]] &&\n', '      winnerPerDay[day] != msg.sender) {\n', '      winnerPerDay[day] = msg.sender;\n', '    }\n', '\n', '    uint cumulativeDamage = damage;\n', '    if (encounter.participants.length > 0) {\n', '      cumulativeDamage = cumulativeDamage + encounter.participantData[encounter.participants[encounter.participants.length-1]].cumulativeDamage;\n', '    }\n', '\n', '    if (sacrificeTokenId1 != 0) {\n', '\n', '      // the requires in the transfer functions here will verify\n', '      // that msg.sender owns all of these tokens and they are unique\n', '\n', '      // burn all four input tokens\n', '\n', '      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId1);\n', '      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId2);\n', '      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId3);\n', '      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId4);\n', '    }\n', '\n', '    encounter.participantData[msg.sender] = ParticipantData(uint32(damage), uint64(cumulativeDamage), \n', '      forgeWeaponRarity(sacrificeTokenId1, sacrificeTokenId2, sacrificeTokenId3, sacrificeTokenId4),\n', '      forgeWeaponPureDamage(sacrificeTokenId1, sacrificeTokenId2, sacrificeTokenId3, sacrificeTokenId4),\n', '      false, false);\n', '    encounter.participants.push(msg.sender);\n', '\n', '    emit Participating(msg.sender, encounterId);\n', '  }\n', '\n', '  function claimLoot(uint encounterId, address player) public whenNotPaused {\n', '    address winnerAddress;\n', '    uint lootTokenId;\n', '    uint consolationPrizeTokenId;\n', '    (winnerAddress, lootTokenId, consolationPrizeTokenId, , ,,) = getEncounterResults(encounterId, player);\n', '    require(winnerAddress == player, "player is not the winner");\n', '\n', '    ParticipantData storage participantData = encountersById[encounterId].participantData[player];\n', '\n', '    require(!participantData.lootClaimed, "loot already claimed");\n', '\n', '    participantData.lootClaimed = true;\n', '    tokenContract.mint(player, lootTokenId);\n', '\n', '    // The winner also gets a consolation prize\n', "    // It's possible he called claimConsolationPrizeLoot first, so allow that\n", '\n', '    require(consolationPrizeTokenId != 0, "consolation prize invalid");\n', '\n', '    if (!participantData.consolationPrizeClaimed) {\n', '        participantData.consolationPrizeClaimed = true;\n', '        // this will throw if the token already exists\n', '        tokenContract.mint(player, consolationPrizeTokenId);\n', '\n', '        // refund gas\n', '        msg.sender.transfer(gasRefundForClaimLootWithConsolationPrize);\n', '    } else {\n', '        \n', '        // refund gas\n', '        msg.sender.transfer(gasRefundForClaimLoot);\n', '    }\n', '\n', '    emit LootClaimed(player, encounterId);\n', '  }\n', '\n', '  function getConsolationPrizeTokenId(uint encounterId, address player) internal view returns (uint) {\n', '\n', '    ParticipantData memory participantData = encountersById[encounterId].participantData[player];\n', '    if (participantData.damage == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint blockToHash = getBlockToHashForResults(encounterId);\n', '\n', '    uint rand = uint(keccak256(uint(blockhash(blockToHash)) ^ uint(player)));\n', '\n', '    if (participantData.forgeWeaponRarity != 0) {\n', '      return constructWeaponTokenId(rand, participantData.forgeWeaponRarity, participantData.forgeWeaponDamagePure);\n', '    }\n', '\n', '    return constructWeaponTokenId(rand, 0, 0);\n', '  }\n', '\n', '  function claimConsolationPrizeLoot(uint encounterId, address player) public whenNotPaused {\n', '    uint lootTokenId = getConsolationPrizeTokenId(encounterId, player);\n', '    require(lootTokenId != 0, "player didnt participate");\n', '\n', '    ParticipantData storage participantData = encountersById[encounterId].participantData[player];\n', '    require(!participantData.consolationPrizeClaimed, "consolation prize already claimed");\n', '\n', '    participantData.consolationPrizeClaimed = true;\n', '    tokenContract.mint(player, lootTokenId);\n', '\n', '    msg.sender.transfer(gasRefundForClaimConsolationPrizeLoot);\n', '\n', '    emit LootClaimed(player, encounterId);\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return tokenContract.balanceOf(_owner);\n', '  }\n', '\n', '  function tokensOf(address _owner) public view returns (uint256[]) {\n', '    return tokenContract.tokensOf(_owner);\n', '  }\n', '\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index)\n', '    external\n', '    view\n', '    returns (uint256 _tokenId)\n', '  {\n', '    return tokenContract.tokenOfOwnerByIndex(_owner, _index);\n', '  }\n', '}']
