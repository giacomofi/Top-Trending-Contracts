['pragma solidity 0.4.24;\n', '\n', '/*\n', '\n', '    Copyright 2018, Vicent Nos & Mireia Puig\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '*/\n', '\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor() internal {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', '////////////////////////////////////////////////////////\n', '//:                                                  ://\n', '//:          SpaceImpulse Public Engagement          ://\n', '//:..................................................://\n', '////////////////////////////////////////////////////////\n', '\n', '\n', '\n', '\n', 'contract TokenCHK {\n', '\n', '  function balanceOf(address _owner) public pure returns (uint256 balance) {}\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', 'contract SpaceImpulse is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    string public name = "Space Impulse Public Engagement";      // Extended name of this contract\n', '    uint256 public tokenPrice;            // Set the fixed SpaceImpulse token price\n', '    uint256 public maxCap = 0;            // Set the target maximum cap in ETH\n', '    address public FWDaddrETH;            // Set the address to forward the received ETH to\n', '    address public SpaceImpulseERC20;     // Set the SpaceImpulse ERC20 contract address\n', '    uint256 public totalSold;             // Keep track of the contributions total\n', '    uint256 public minPersonalCap;        // Set the minimal cap in ETH\n', '    uint256 public decimals = 18;         // The decimals to consider\n', '\n', '    mapping (address => uint256) public sold;         // Map the SpaceImpulse token allcations\n', '\n', '    uint256 public pubEnd;                            // Set the unixtime END for the public engagement\n', '    address contractAddr = this;                      // Better way to point to this from this\n', '\n', '    // Constant to simplify the conversion of token amounts into integer form\n', '    uint256 public tokenUnit = uint256(10)**decimals;\n', '\n', '\n', '\n', '    //\n', '    // "toETHaddr" is the address to which the ETH contributions are forwarded to, aka FWDaddrETH\n', '    // "SpaceImpulseERC20" is the address of the SpaceImpulseERC20 token contract.\n', '    //\n', '    // NOTE: this contract will sell only its token balance on the ERC20 specified in SpaceImpulseERC20\n', '    //       the maxCap in ETH and the tokenPrice will indirectly set the SpaceImpulse token amount on sale\n', '    //\n', '    // NOTE: this contract should have sufficient SpaceImpulse token balance to be > maxCap / tokenPrice\n', '    //\n', '    // NOTE: this contract will stop REGARDLESS of the above (maxCap) when its token balance is all sold\n', '    //\n', '    // The Owner of this contract can set: Price, End, MaxCap, SpaceImpulseERC20 and ETH Forward address\n', '    //\n', '    // The received ETH are directly forwarded to the external FWDaddrETH address\n', '    // The SpaceImpulse tokens are transferred to the contributing addresses once withdrawPUB is executed\n', '    //\n', '\n', '\n', '    constructor\n', '        (\n', '        address SpaceImpulse_ERC20\n', '        ) public {\n', '        FWDaddrETH = 0xD9614b3FaC2B523504AbC18104e4B32EE0605855;\n', '        SpaceImpulseERC20 = SpaceImpulse_ERC20;\n', '        tokenPrice = 150000000000000;\n', '        minPersonalCap = 150000000000000000;\n', '        pubEnd = 1540987140;\n', '\n', '    }\n', '\n', '    function () public payable {\n', '        buy();               // Allow to buy tokens sending ETH directly to the contract, fallback\n', '    }\n', '\n', '    function setFWDaddrETH(address _value) public onlyOwner {\n', '      FWDaddrETH = _value;     // Set the forward address default toETHaddr\n', '\n', '    }\n', '\n', '\n', '    function setSpaceImpulse(address _value) public onlyOwner {\n', '      SpaceImpulseERC20 = _value;     // Set the SpaceImpulseERC20 contract address\n', '\n', '    }\n', '\n', '\n', '    function setMaxCap(uint256 _value) public onlyOwner {\n', '      maxCap = _value;         // Set the max cap in ETH default 0\n', '\n', '    }\n', '\n', '\n', '    function setPrice(uint256 _value) public onlyOwner {\n', '      tokenPrice = _value;     // Set the token price default 0\n', '\n', '    }\n', '\n', '\n', '    function setPubEnd(uint256 _value) public onlyOwner {\n', '      pubEnd = _value;         // Set the END of the public engagement unixtime default 0\n', '\n', '    }\n', '\n', '    function setMinPersonalCap(uint256 _value) public onlyOwner {\n', '      minPersonalCap = _value;  // Set min amount to buy\n', '    }\n', '\n', '\n', '\n', '    function buy() public payable {\n', '\n', '        require(block.timestamp < pubEnd);          // Require the current unixtime to be lower than the END unixtime\n', '        require(msg.value > 0);                     // Require the sender to send an ETH tx higher than 0\n', '        require(msg.value <= msg.sender.balance + msg.value);   // Require the sender to have sufficient ETH balance for the tx\n', '        require(msg.value >= minPersonalCap);        // Require sender eth amount be higher than minPersonalCap\n', '\n', '        // Requiring this to avoid going out of tokens, aka we are getting just true/false from the transfer call\n', '        require(msg.value + totalSold <= maxCap);\n', '\n', '        // Calculate the amount of tokens per contribution\n', '        uint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice;\n', '\n', '        // Requiring sufficient token balance on this contract to accept the tx\n', '        require(tokenAmount + ((totalSold * tokenUnit) / tokenPrice)<=TokenCHK(SpaceImpulseERC20).balanceOf(contractAddr));\n', '\n', '        transferBuy(msg.sender, tokenAmount);       // Instruct the accounting function\n', '        totalSold = totalSold.add(msg.value);       // Account for the total contributed/sold\n', '        FWDaddrETH.transfer(msg.value);             // Forward the ETH received to the external address\n', '\n', '    }\n', '\n', '\n', '\n', '\n', '    function withdrawPUB() public returns(bool){\n', '\n', '        require(block.timestamp > pubEnd);          // Require the SpaceImpulse to be over - actual time higher than end unixtime\n', '        require(sold[msg.sender] > 0);              // Require the SpaceImpulseERC20 token balance to be sent to be higher than 0\n', '\n', '        // Send SpaceImpulseERC20 tokens to the contributors proportionally to their contribution/s\n', '        if(!SpaceImpulseERC20.call(bytes4(keccak256("transfer(address,uint256)")), msg.sender, sold[msg.sender])){revert();}\n', '\n', '        delete sold[msg.sender];\n', '        return true;\n', '\n', '    }\n', '\n', '\n', '\n', '\n', '    function transferBuy(address _to, uint256 _value) internal returns (bool) {\n', '\n', '        require(_to != address(0));                 // Require the destination address being non-zero\n', '\n', '        sold[_to] = sold[_to].add(_value);            // Account for multiple txs from the same address\n', '\n', '        return true;\n', '\n', '    }\n', '\n', '\n', '\n', '        //\n', '        // Probably the sky would fall down first but, in case skynet feels funny..\n', '        // ..we try to make sure anyway that no ETH would get stuck in this contract\n', '        //\n', '    function EMGwithdraw(uint256 weiValue) external onlyOwner {\n', '        require(block.timestamp > pubEnd);          // Require the public engagement to be over\n', '        require(weiValue > 0);                      // Require a non-zero value\n', '\n', '        FWDaddrETH.transfer(weiValue);              // Transfer to the external ETH forward address\n', '    }\n', '\n', '    function sweep(address _token, uint256 _amount) public onlyOwner {\n', '        TokenCHK token = TokenCHK(_token);\n', '\n', '        if(!token.transfer(owner, _amount)) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '}']
['pragma solidity 0.4.24;\n', '\n', '/*\n', '\n', '    Copyright 2018, Vicent Nos & Mireia Puig\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '*/\n', '\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor() internal {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', '////////////////////////////////////////////////////////\n', '//:                                                  ://\n', '//:          SpaceImpulse Public Engagement          ://\n', '//:..................................................://\n', '////////////////////////////////////////////////////////\n', '\n', '\n', '\n', '\n', 'contract TokenCHK {\n', '\n', '  function balanceOf(address _owner) public pure returns (uint256 balance) {}\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', 'contract SpaceImpulse is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    string public name = "Space Impulse Public Engagement";      // Extended name of this contract\n', '    uint256 public tokenPrice;            // Set the fixed SpaceImpulse token price\n', '    uint256 public maxCap = 0;            // Set the target maximum cap in ETH\n', '    address public FWDaddrETH;            // Set the address to forward the received ETH to\n', '    address public SpaceImpulseERC20;     // Set the SpaceImpulse ERC20 contract address\n', '    uint256 public totalSold;             // Keep track of the contributions total\n', '    uint256 public minPersonalCap;        // Set the minimal cap in ETH\n', '    uint256 public decimals = 18;         // The decimals to consider\n', '\n', '    mapping (address => uint256) public sold;         // Map the SpaceImpulse token allcations\n', '\n', '    uint256 public pubEnd;                            // Set the unixtime END for the public engagement\n', '    address contractAddr = this;                      // Better way to point to this from this\n', '\n', '    // Constant to simplify the conversion of token amounts into integer form\n', '    uint256 public tokenUnit = uint256(10)**decimals;\n', '\n', '\n', '\n', '    //\n', '    // "toETHaddr" is the address to which the ETH contributions are forwarded to, aka FWDaddrETH\n', '    // "SpaceImpulseERC20" is the address of the SpaceImpulseERC20 token contract.\n', '    //\n', '    // NOTE: this contract will sell only its token balance on the ERC20 specified in SpaceImpulseERC20\n', '    //       the maxCap in ETH and the tokenPrice will indirectly set the SpaceImpulse token amount on sale\n', '    //\n', '    // NOTE: this contract should have sufficient SpaceImpulse token balance to be > maxCap / tokenPrice\n', '    //\n', '    // NOTE: this contract will stop REGARDLESS of the above (maxCap) when its token balance is all sold\n', '    //\n', '    // The Owner of this contract can set: Price, End, MaxCap, SpaceImpulseERC20 and ETH Forward address\n', '    //\n', '    // The received ETH are directly forwarded to the external FWDaddrETH address\n', '    // The SpaceImpulse tokens are transferred to the contributing addresses once withdrawPUB is executed\n', '    //\n', '\n', '\n', '    constructor\n', '        (\n', '        address SpaceImpulse_ERC20\n', '        ) public {\n', '        FWDaddrETH = 0xD9614b3FaC2B523504AbC18104e4B32EE0605855;\n', '        SpaceImpulseERC20 = SpaceImpulse_ERC20;\n', '        tokenPrice = 150000000000000;\n', '        minPersonalCap = 150000000000000000;\n', '        pubEnd = 1540987140;\n', '\n', '    }\n', '\n', '    function () public payable {\n', '        buy();               // Allow to buy tokens sending ETH directly to the contract, fallback\n', '    }\n', '\n', '    function setFWDaddrETH(address _value) public onlyOwner {\n', '      FWDaddrETH = _value;     // Set the forward address default toETHaddr\n', '\n', '    }\n', '\n', '\n', '    function setSpaceImpulse(address _value) public onlyOwner {\n', '      SpaceImpulseERC20 = _value;     // Set the SpaceImpulseERC20 contract address\n', '\n', '    }\n', '\n', '\n', '    function setMaxCap(uint256 _value) public onlyOwner {\n', '      maxCap = _value;         // Set the max cap in ETH default 0\n', '\n', '    }\n', '\n', '\n', '    function setPrice(uint256 _value) public onlyOwner {\n', '      tokenPrice = _value;     // Set the token price default 0\n', '\n', '    }\n', '\n', '\n', '    function setPubEnd(uint256 _value) public onlyOwner {\n', '      pubEnd = _value;         // Set the END of the public engagement unixtime default 0\n', '\n', '    }\n', '\n', '    function setMinPersonalCap(uint256 _value) public onlyOwner {\n', '      minPersonalCap = _value;  // Set min amount to buy\n', '    }\n', '\n', '\n', '\n', '    function buy() public payable {\n', '\n', '        require(block.timestamp < pubEnd);          // Require the current unixtime to be lower than the END unixtime\n', '        require(msg.value > 0);                     // Require the sender to send an ETH tx higher than 0\n', '        require(msg.value <= msg.sender.balance + msg.value);   // Require the sender to have sufficient ETH balance for the tx\n', '        require(msg.value >= minPersonalCap);        // Require sender eth amount be higher than minPersonalCap\n', '\n', '        // Requiring this to avoid going out of tokens, aka we are getting just true/false from the transfer call\n', '        require(msg.value + totalSold <= maxCap);\n', '\n', '        // Calculate the amount of tokens per contribution\n', '        uint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice;\n', '\n', '        // Requiring sufficient token balance on this contract to accept the tx\n', '        require(tokenAmount + ((totalSold * tokenUnit) / tokenPrice)<=TokenCHK(SpaceImpulseERC20).balanceOf(contractAddr));\n', '\n', '        transferBuy(msg.sender, tokenAmount);       // Instruct the accounting function\n', '        totalSold = totalSold.add(msg.value);       // Account for the total contributed/sold\n', '        FWDaddrETH.transfer(msg.value);             // Forward the ETH received to the external address\n', '\n', '    }\n', '\n', '\n', '\n', '\n', '    function withdrawPUB() public returns(bool){\n', '\n', '        require(block.timestamp > pubEnd);          // Require the SpaceImpulse to be over - actual time higher than end unixtime\n', '        require(sold[msg.sender] > 0);              // Require the SpaceImpulseERC20 token balance to be sent to be higher than 0\n', '\n', '        // Send SpaceImpulseERC20 tokens to the contributors proportionally to their contribution/s\n', '        if(!SpaceImpulseERC20.call(bytes4(keccak256("transfer(address,uint256)")), msg.sender, sold[msg.sender])){revert();}\n', '\n', '        delete sold[msg.sender];\n', '        return true;\n', '\n', '    }\n', '\n', '\n', '\n', '\n', '    function transferBuy(address _to, uint256 _value) internal returns (bool) {\n', '\n', '        require(_to != address(0));                 // Require the destination address being non-zero\n', '\n', '        sold[_to] = sold[_to].add(_value);            // Account for multiple txs from the same address\n', '\n', '        return true;\n', '\n', '    }\n', '\n', '\n', '\n', '        //\n', '        // Probably the sky would fall down first but, in case skynet feels funny..\n', '        // ..we try to make sure anyway that no ETH would get stuck in this contract\n', '        //\n', '    function EMGwithdraw(uint256 weiValue) external onlyOwner {\n', '        require(block.timestamp > pubEnd);          // Require the public engagement to be over\n', '        require(weiValue > 0);                      // Require a non-zero value\n', '\n', '        FWDaddrETH.transfer(weiValue);              // Transfer to the external ETH forward address\n', '    }\n', '\n', '    function sweep(address _token, uint256 _amount) public onlyOwner {\n', '        TokenCHK token = TokenCHK(_token);\n', '\n', '        if(!token.transfer(owner, _amount)) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '}']
