['pragma solidity ^0.4.25;\n', '\n', '  /**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '    \n', '    \n', '    /// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '    /// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="046061706144657c6d6b697e616a2a676b">[email&#160;protected]</a>> (https://github.com/dete)\n', '    contract ERC721 {\n', '    function totalSupply() external view returns (uint256 total);\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '    function ownerOf(string _diamondId) public view returns (address owner);\n', '    function approve(address _to, string _diamondId) external;\n', '    function transfer(address _to, string _diamondId) external;\n', '    function transferFrom(address _from, address _to, string _diamondId) external;\n', '    \n', '    // Events\n', '    event Transfer(address indexed from, address indexed to, string indexed diamondId);\n', '    event Approval(address indexed owner, address indexed approved, string indexed diamondId);\n', '    }\n', '    \n', '    contract DiamondAccessControl {\n', '    \n', '    address public CEO;\n', '    \n', '    mapping (address => bool) public admins;\n', '    \n', '    bool public paused = false;\n', '    \n', '    modifier onlyCEO() {\n', '      require(msg.sender == CEO);\n', '      _;\n', '    }\n', '    \n', '    modifier onlyAdmin() {\n', '      require(admins[msg.sender]);\n', '      _;\n', '    }\n', '    \n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '    \n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '      require(!paused);\n', '      _;\n', '    }\n', '    \n', '    modifier onlyAdminOrCEO() \n', '{      require(admins[msg.sender] || msg.sender == CEO);\n', '      _;\n', '    }\n', '    \n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '      require(paused);\n', '      _;\n', '    }\n', '    \n', '    function setCEO(address _newCEO) external onlyCEO {\n', '      require(_newCEO != address(0));\n', '      CEO = _newCEO;\n', '    }\n', '    \n', '    function setAdmin(address _newAdmin, bool isAdmin) external onlyCEO {\n', '      require(_newAdmin != address(0));\n', '      admins[_newAdmin] = isAdmin;\n', '    }\n', '    \n', '    /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '    ///  a bug or exploit is detected and we need to limit damage.\n', '    function pause() external onlyAdminOrCEO whenNotPaused {\n', '      paused = true;\n', '    }\n', '    \n', '    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '    ///  one reason we may pause the contract is when admin account are\n', '    ///  compromised.\n', '    /// @notice This is public rather than external so it can be called by\n', '    ///  derived contracts.\n', '    function unpause() external onlyCEO whenPaused {\n', '      // can&#39;t unpause if contract was upgraded\n', '      paused = false;\n', '    }\n', '}\n', '    \n', '/// @title Base contract for CryptoDiamond. Holds all common structs, events and base variables.\n', 'contract DiamondBase is DiamondAccessControl {\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    event Transfer(address indexed from, address indexed to, string indexed diamondId);\n', '    event TransactionHistory(  \n', '      string indexed _diamondId, \n', '      address indexed _seller, \n', '      string _sellerId, \n', '      address indexed _buyer, \n', '      string _buyerId, \n', '      uint256 _usdPrice, \n', '      uint256 _cedexPrice,\n', '      uint256 timestamp\n', '    );\n', '    \n', '    /*** DATA TYPE ***/\n', '    /// @dev The main Diamond struct. Every dimond is represented by a copy of this structure\n', '    struct Diamond {\n', '      string ownerId;\n', '      string status;\n', '      string gemCompositeScore;\n', '      string gemSubcategory;\n', '      string media;\n', '      string custodian;\n', '      uint256 arrivalTime;\n', '    }\n', '    \n', '    // variable to store total amount of diamonds\n', '    uint256 internal total;\n', '    \n', '    // Mapping for checking the existence of token with such diamond ID\n', '    mapping(string => bool) internal diamondExists;\n', '    \n', '    // Mapping from adress to number of diamonds owned by this address\n', '    mapping(address => uint256) internal balances;\n', '    \n', '    // Mapping from diamond ID to owner address\n', '    mapping (string => address) internal diamondIdToOwner;\n', '    \n', '    // Mapping from diamond ID to metadata\n', '    mapping(string => Diamond) internal diamondIdToMetadata;\n', '    \n', '    // Mapping from diamond ID to an address that has been approved to call transferFrom()\n', '    mapping(string => address) internal diamondIdToApproved;\n', '    \n', '    //Status Constants\n', '    string constant STATUS_PENDING = "Pending";\n', '    string constant STATUS_VERIFIED = "Verified";\n', '    string constant STATUS_OUTSIDE  = "Outside";\n', '\n', '    function _createDiamond(\n', '      string _diamondId, \n', '      address _owner, \n', '      string _ownerId, \n', '      string _gemCompositeScore, \n', '      string _gemSubcategory, \n', '      string _media\n', '    )  \n', '      internal \n', '    {\n', '      Diamond memory diamond;\n', '      \n', '      diamond.status = "Pending";\n', '      diamond.ownerId = _ownerId;\n', '      diamond.gemCompositeScore = _gemCompositeScore;\n', '      diamond.gemSubcategory = _gemSubcategory;\n', '      diamond.media = _media;\n', '      \n', '      diamondIdToMetadata[_diamondId] = diamond;\n', '\n', '      total = total.add(1); \n', '      diamondExists[_diamondId] = true;\n', '    \n', '      _transfer(address(0), _owner, _diamondId); \n', '    }\n', '    \n', '    function _transferInternal(\n', '      string _diamondId, \n', '      address _seller, \n', '      string _sellerId, \n', '      address _buyer, \n', '      string _buyerId, \n', '      uint256 _usdPrice, \n', '      uint256 _cedexPrice\n', '    )   \n', '      internal \n', '    {\n', '      Diamond storage diamond = diamondIdToMetadata[_diamondId];\n', '      diamond.ownerId = _buyerId;\n', '      _transfer(_seller, _buyer, _diamondId);   \n', '      emit TransactionHistory(_diamondId, _seller, _sellerId, _buyer, _buyerId, _usdPrice, _cedexPrice, now);\n', '    \n', '    }\n', '    \n', '    function _transfer(address _from, address _to, string _diamondId) internal {\n', '      if (_from != address(0)) {\n', '          balances[_from] = balances[_from].sub(1);\n', '      }\n', '      balances[_to] = balances[_to].add(1);\n', '      diamondIdToOwner[_diamondId] = _to;\n', '      delete diamondIdToApproved[_diamondId];\n', '      emit Transfer(_from, _to, _diamondId);\n', '    }\n', '    \n', '    function _burn(string _diamondId) internal {\n', '      address _from = diamondIdToOwner[_diamondId];\n', '      balances[_from] = balances[_from].sub(1);\n', '      total = total.sub(1);\n', '      delete diamondIdToOwner[_diamondId];\n', '      delete diamondIdToMetadata[_diamondId];\n', '      delete diamondExists[_diamondId];\n', '      delete diamondIdToApproved[_diamondId];\n', '      emit Transfer(_from, address(0), _diamondId);\n', '    }\n', '    \n', '    function _isDiamondOutside(string _diamondId) internal view returns (bool) {\n', '      require(diamondExists[_diamondId]);\n', '      return keccak256(abi.encodePacked(diamondIdToMetadata[_diamondId].status)) == keccak256(abi.encodePacked(STATUS_OUTSIDE));\n', '    }\n', '    \n', '    function _isDiamondVerified(string _diamondId) internal view returns (bool) {\n', '      require(diamondExists[_diamondId]);\n', '      return keccak256(abi.encodePacked(diamondIdToMetadata[_diamondId].status)) == keccak256(abi.encodePacked(STATUS_VERIFIED));\n', '    }\n', '}\n', '    \n', '/// @title The ontract that manages ownership, ERC-721 (draft) compliant.\n', 'contract DiamondBase721 is DiamondBase, ERC721 {\n', '    \n', '    function totalSupply() external view returns (uint256) {\n', '      return total;\n', '    }\n', '    \n', '    /**\n', '    * @dev Gets the balance of the specified address\n', '    * @param _owner address to query the balance of\n', '    * @return uint256 representing the amount owned by the passed address\n', '    */\n', '    function balanceOf(address _owner) external view returns (uint256) {\n', '      return balances[_owner];\n', '    \n', '    }\n', '    \n', '    /**\n', '    * @dev Gets the owner of the specified diamond ID\n', '    * @param _diamondId string ID of the diamond to query the owner of\n', '    * @return owner address currently marked as the owner of the given diamond ID\n', '    */\n', '    function ownerOf(string _diamondId) public view returns (address) {\n', '      require(diamondExists[_diamondId]);\n', '      return diamondIdToOwner[_diamondId];\n', '    }\n', '    \n', '    function approve(address _to, string _diamondId) external whenNotPaused {\n', '      require(_isDiamondOutside(_diamondId));\n', '      require(msg.sender == ownerOf(_diamondId));\n', '      diamondIdToApproved[_diamondId] = _to;\n', '      emit Approval(msg.sender, _to, _diamondId);\n', '    }\n', '    \n', '    /**\n', '    * @dev Transfers the ownership of a given diamond ID to another address\n', '    * @param _to address to receive the ownership of the given diamond ID\n', '    * @param _diamondId uint256 ID of the diamond to be transferred\n', '    */\n', '    function transfer(address _to, string _diamondId) external whenNotPaused {\n', '      require(_isDiamondOutside(_diamondId));\n', '      require(msg.sender == ownerOf(_diamondId));\n', '      require(_to != address(0));\n', '      require(_to != address(this));\n', '      require(_to != ownerOf(_diamondId));\n', '      _transfer(msg.sender, _to, _diamondId);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to,  string _diamondId)\n', '      external \n', '      whenNotPaused \n', '    {\n', '      require(_isDiamondOutside(_diamondId));\n', '      require(_from == ownerOf(_diamondId));\n', '      require(_to != address(0));\n', '      require(_to != address(this));\n', '      require(_to != ownerOf(_diamondId));\n', '      require(diamondIdToApproved[_diamondId] == msg.sender);\n', '      _transfer(_from, _to, _diamondId);\n', '    }\n', '    \n', '}\n', '    \n', '/// @dev The main contract, keeps track of diamonds.\n', 'contract DiamondCore is DiamondBase721 {\n', '\n', '    /// @notice Creates the main Diamond smart contract instance.\n', '    constructor() public {\n', '      // the creator of the contract is the initial CEO\n', '      CEO = msg.sender;\n', '    }\n', '    \n', '    function createDiamond(\n', '      string _diamondId, \n', '      address _owner, \n', '      string _ownerId, \n', '      string _gemCompositeScore, \n', '      string _gemSubcategory, \n', '      string _media\n', '    ) \n', '      external \n', '      onlyAdminOrCEO \n', '      whenNotPaused \n', '    {\n', '      require(!diamondExists[_diamondId]);\n', '      require(_owner != address(0));\n', '      require(_owner != address(this));\n', '      _createDiamond( \n', '          _diamondId, \n', '          _owner, \n', '          _ownerId, \n', '          _gemCompositeScore, \n', '          _gemSubcategory, \n', '          _media\n', '      );\n', '    }\n', '    \n', '    function updateDiamond(\n', '      string _diamondId, \n', '      string _custodian, \n', '      uint256 _arrivalTime\n', '    ) \n', '      external \n', '      onlyAdminOrCEO \n', '      whenNotPaused \n', '    {\n', '      require(!_isDiamondOutside(_diamondId));\n', '      \n', '      Diamond storage diamond = diamondIdToMetadata[_diamondId];\n', '      \n', '      diamond.status = "Verified";\n', '      diamond.custodian = _custodian;\n', '      diamond.arrivalTime = _arrivalTime;\n', '    }\n', '    \n', '    function transferInternal(\n', '      string _diamondId, \n', '      address _seller, \n', '      string _sellerId, \n', '      address _buyer, \n', '      string _buyerId, \n', '      uint256 _usdPrice, \n', '      uint256 _cedexPrice\n', '    ) \n', '      external \n', '      onlyAdminOrCEO                                                                                                                                                                                                                                              \n', '      whenNotPaused \n', '    {\n', '      require(_isDiamondVerified(_diamondId));\n', '      require(_seller == ownerOf(_diamondId));\n', '      require(_buyer != address(0));\n', '      require(_buyer != address(this));\n', '      require(_buyer != ownerOf(_diamondId));\n', '      _transferInternal(_diamondId, _seller, _sellerId, _buyer, _buyerId, _usdPrice, _cedexPrice);\n', '    }\n', '    \n', '    function burn(string _diamondId) external onlyAdminOrCEO whenNotPaused {\n', '      require(!_isDiamondOutside(_diamondId));\n', '      _burn(_diamondId);\n', '    }\n', '    \n', '    function getDiamond(string _diamondId) \n', '        external\n', '        view\n', '        returns(\n', '            string ownerId,\n', '            string status,\n', '            string gemCompositeScore,\n', '            string gemSubcategory,\n', '            string media,\n', '            string custodian,\n', '            uint256 arrivalTime\n', '        )\n', '    {\n', '        require(diamondExists[_diamondId]);\n', '        \n', '         ownerId = diamondIdToMetadata[_diamondId].ownerId;\n', '         status = diamondIdToMetadata[_diamondId].status;\n', '         gemCompositeScore = diamondIdToMetadata[_diamondId].gemCompositeScore;\n', '         gemSubcategory = diamondIdToMetadata[_diamondId].gemSubcategory;\n', '         media = diamondIdToMetadata[_diamondId].media;\n', '         custodian = diamondIdToMetadata[_diamondId].custodian;\n', '         arrivalTime = diamondIdToMetadata[_diamondId].arrivalTime;\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', '  /**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '    \n', '    \n', '    /// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '    /// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\n', '    contract ERC721 {\n', '    function totalSupply() external view returns (uint256 total);\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '    function ownerOf(string _diamondId) public view returns (address owner);\n', '    function approve(address _to, string _diamondId) external;\n', '    function transfer(address _to, string _diamondId) external;\n', '    function transferFrom(address _from, address _to, string _diamondId) external;\n', '    \n', '    // Events\n', '    event Transfer(address indexed from, address indexed to, string indexed diamondId);\n', '    event Approval(address indexed owner, address indexed approved, string indexed diamondId);\n', '    }\n', '    \n', '    contract DiamondAccessControl {\n', '    \n', '    address public CEO;\n', '    \n', '    mapping (address => bool) public admins;\n', '    \n', '    bool public paused = false;\n', '    \n', '    modifier onlyCEO() {\n', '      require(msg.sender == CEO);\n', '      _;\n', '    }\n', '    \n', '    modifier onlyAdmin() {\n', '      require(admins[msg.sender]);\n', '      _;\n', '    }\n', '    \n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '    \n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '      require(!paused);\n', '      _;\n', '    }\n', '    \n', '    modifier onlyAdminOrCEO() \n', '{      require(admins[msg.sender] || msg.sender == CEO);\n', '      _;\n', '    }\n', '    \n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '      require(paused);\n', '      _;\n', '    }\n', '    \n', '    function setCEO(address _newCEO) external onlyCEO {\n', '      require(_newCEO != address(0));\n', '      CEO = _newCEO;\n', '    }\n', '    \n', '    function setAdmin(address _newAdmin, bool isAdmin) external onlyCEO {\n', '      require(_newAdmin != address(0));\n', '      admins[_newAdmin] = isAdmin;\n', '    }\n', '    \n', '    /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '    ///  a bug or exploit is detected and we need to limit damage.\n', '    function pause() external onlyAdminOrCEO whenNotPaused {\n', '      paused = true;\n', '    }\n', '    \n', '    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '    ///  one reason we may pause the contract is when admin account are\n', '    ///  compromised.\n', '    /// @notice This is public rather than external so it can be called by\n', '    ///  derived contracts.\n', '    function unpause() external onlyCEO whenPaused {\n', "      // can't unpause if contract was upgraded\n", '      paused = false;\n', '    }\n', '}\n', '    \n', '/// @title Base contract for CryptoDiamond. Holds all common structs, events and base variables.\n', 'contract DiamondBase is DiamondAccessControl {\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    event Transfer(address indexed from, address indexed to, string indexed diamondId);\n', '    event TransactionHistory(  \n', '      string indexed _diamondId, \n', '      address indexed _seller, \n', '      string _sellerId, \n', '      address indexed _buyer, \n', '      string _buyerId, \n', '      uint256 _usdPrice, \n', '      uint256 _cedexPrice,\n', '      uint256 timestamp\n', '    );\n', '    \n', '    /*** DATA TYPE ***/\n', '    /// @dev The main Diamond struct. Every dimond is represented by a copy of this structure\n', '    struct Diamond {\n', '      string ownerId;\n', '      string status;\n', '      string gemCompositeScore;\n', '      string gemSubcategory;\n', '      string media;\n', '      string custodian;\n', '      uint256 arrivalTime;\n', '    }\n', '    \n', '    // variable to store total amount of diamonds\n', '    uint256 internal total;\n', '    \n', '    // Mapping for checking the existence of token with such diamond ID\n', '    mapping(string => bool) internal diamondExists;\n', '    \n', '    // Mapping from adress to number of diamonds owned by this address\n', '    mapping(address => uint256) internal balances;\n', '    \n', '    // Mapping from diamond ID to owner address\n', '    mapping (string => address) internal diamondIdToOwner;\n', '    \n', '    // Mapping from diamond ID to metadata\n', '    mapping(string => Diamond) internal diamondIdToMetadata;\n', '    \n', '    // Mapping from diamond ID to an address that has been approved to call transferFrom()\n', '    mapping(string => address) internal diamondIdToApproved;\n', '    \n', '    //Status Constants\n', '    string constant STATUS_PENDING = "Pending";\n', '    string constant STATUS_VERIFIED = "Verified";\n', '    string constant STATUS_OUTSIDE  = "Outside";\n', '\n', '    function _createDiamond(\n', '      string _diamondId, \n', '      address _owner, \n', '      string _ownerId, \n', '      string _gemCompositeScore, \n', '      string _gemSubcategory, \n', '      string _media\n', '    )  \n', '      internal \n', '    {\n', '      Diamond memory diamond;\n', '      \n', '      diamond.status = "Pending";\n', '      diamond.ownerId = _ownerId;\n', '      diamond.gemCompositeScore = _gemCompositeScore;\n', '      diamond.gemSubcategory = _gemSubcategory;\n', '      diamond.media = _media;\n', '      \n', '      diamondIdToMetadata[_diamondId] = diamond;\n', '\n', '      total = total.add(1); \n', '      diamondExists[_diamondId] = true;\n', '    \n', '      _transfer(address(0), _owner, _diamondId); \n', '    }\n', '    \n', '    function _transferInternal(\n', '      string _diamondId, \n', '      address _seller, \n', '      string _sellerId, \n', '      address _buyer, \n', '      string _buyerId, \n', '      uint256 _usdPrice, \n', '      uint256 _cedexPrice\n', '    )   \n', '      internal \n', '    {\n', '      Diamond storage diamond = diamondIdToMetadata[_diamondId];\n', '      diamond.ownerId = _buyerId;\n', '      _transfer(_seller, _buyer, _diamondId);   \n', '      emit TransactionHistory(_diamondId, _seller, _sellerId, _buyer, _buyerId, _usdPrice, _cedexPrice, now);\n', '    \n', '    }\n', '    \n', '    function _transfer(address _from, address _to, string _diamondId) internal {\n', '      if (_from != address(0)) {\n', '          balances[_from] = balances[_from].sub(1);\n', '      }\n', '      balances[_to] = balances[_to].add(1);\n', '      diamondIdToOwner[_diamondId] = _to;\n', '      delete diamondIdToApproved[_diamondId];\n', '      emit Transfer(_from, _to, _diamondId);\n', '    }\n', '    \n', '    function _burn(string _diamondId) internal {\n', '      address _from = diamondIdToOwner[_diamondId];\n', '      balances[_from] = balances[_from].sub(1);\n', '      total = total.sub(1);\n', '      delete diamondIdToOwner[_diamondId];\n', '      delete diamondIdToMetadata[_diamondId];\n', '      delete diamondExists[_diamondId];\n', '      delete diamondIdToApproved[_diamondId];\n', '      emit Transfer(_from, address(0), _diamondId);\n', '    }\n', '    \n', '    function _isDiamondOutside(string _diamondId) internal view returns (bool) {\n', '      require(diamondExists[_diamondId]);\n', '      return keccak256(abi.encodePacked(diamondIdToMetadata[_diamondId].status)) == keccak256(abi.encodePacked(STATUS_OUTSIDE));\n', '    }\n', '    \n', '    function _isDiamondVerified(string _diamondId) internal view returns (bool) {\n', '      require(diamondExists[_diamondId]);\n', '      return keccak256(abi.encodePacked(diamondIdToMetadata[_diamondId].status)) == keccak256(abi.encodePacked(STATUS_VERIFIED));\n', '    }\n', '}\n', '    \n', '/// @title The ontract that manages ownership, ERC-721 (draft) compliant.\n', 'contract DiamondBase721 is DiamondBase, ERC721 {\n', '    \n', '    function totalSupply() external view returns (uint256) {\n', '      return total;\n', '    }\n', '    \n', '    /**\n', '    * @dev Gets the balance of the specified address\n', '    * @param _owner address to query the balance of\n', '    * @return uint256 representing the amount owned by the passed address\n', '    */\n', '    function balanceOf(address _owner) external view returns (uint256) {\n', '      return balances[_owner];\n', '    \n', '    }\n', '    \n', '    /**\n', '    * @dev Gets the owner of the specified diamond ID\n', '    * @param _diamondId string ID of the diamond to query the owner of\n', '    * @return owner address currently marked as the owner of the given diamond ID\n', '    */\n', '    function ownerOf(string _diamondId) public view returns (address) {\n', '      require(diamondExists[_diamondId]);\n', '      return diamondIdToOwner[_diamondId];\n', '    }\n', '    \n', '    function approve(address _to, string _diamondId) external whenNotPaused {\n', '      require(_isDiamondOutside(_diamondId));\n', '      require(msg.sender == ownerOf(_diamondId));\n', '      diamondIdToApproved[_diamondId] = _to;\n', '      emit Approval(msg.sender, _to, _diamondId);\n', '    }\n', '    \n', '    /**\n', '    * @dev Transfers the ownership of a given diamond ID to another address\n', '    * @param _to address to receive the ownership of the given diamond ID\n', '    * @param _diamondId uint256 ID of the diamond to be transferred\n', '    */\n', '    function transfer(address _to, string _diamondId) external whenNotPaused {\n', '      require(_isDiamondOutside(_diamondId));\n', '      require(msg.sender == ownerOf(_diamondId));\n', '      require(_to != address(0));\n', '      require(_to != address(this));\n', '      require(_to != ownerOf(_diamondId));\n', '      _transfer(msg.sender, _to, _diamondId);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to,  string _diamondId)\n', '      external \n', '      whenNotPaused \n', '    {\n', '      require(_isDiamondOutside(_diamondId));\n', '      require(_from == ownerOf(_diamondId));\n', '      require(_to != address(0));\n', '      require(_to != address(this));\n', '      require(_to != ownerOf(_diamondId));\n', '      require(diamondIdToApproved[_diamondId] == msg.sender);\n', '      _transfer(_from, _to, _diamondId);\n', '    }\n', '    \n', '}\n', '    \n', '/// @dev The main contract, keeps track of diamonds.\n', 'contract DiamondCore is DiamondBase721 {\n', '\n', '    /// @notice Creates the main Diamond smart contract instance.\n', '    constructor() public {\n', '      // the creator of the contract is the initial CEO\n', '      CEO = msg.sender;\n', '    }\n', '    \n', '    function createDiamond(\n', '      string _diamondId, \n', '      address _owner, \n', '      string _ownerId, \n', '      string _gemCompositeScore, \n', '      string _gemSubcategory, \n', '      string _media\n', '    ) \n', '      external \n', '      onlyAdminOrCEO \n', '      whenNotPaused \n', '    {\n', '      require(!diamondExists[_diamondId]);\n', '      require(_owner != address(0));\n', '      require(_owner != address(this));\n', '      _createDiamond( \n', '          _diamondId, \n', '          _owner, \n', '          _ownerId, \n', '          _gemCompositeScore, \n', '          _gemSubcategory, \n', '          _media\n', '      );\n', '    }\n', '    \n', '    function updateDiamond(\n', '      string _diamondId, \n', '      string _custodian, \n', '      uint256 _arrivalTime\n', '    ) \n', '      external \n', '      onlyAdminOrCEO \n', '      whenNotPaused \n', '    {\n', '      require(!_isDiamondOutside(_diamondId));\n', '      \n', '      Diamond storage diamond = diamondIdToMetadata[_diamondId];\n', '      \n', '      diamond.status = "Verified";\n', '      diamond.custodian = _custodian;\n', '      diamond.arrivalTime = _arrivalTime;\n', '    }\n', '    \n', '    function transferInternal(\n', '      string _diamondId, \n', '      address _seller, \n', '      string _sellerId, \n', '      address _buyer, \n', '      string _buyerId, \n', '      uint256 _usdPrice, \n', '      uint256 _cedexPrice\n', '    ) \n', '      external \n', '      onlyAdminOrCEO                                                                                                                                                                                                                                              \n', '      whenNotPaused \n', '    {\n', '      require(_isDiamondVerified(_diamondId));\n', '      require(_seller == ownerOf(_diamondId));\n', '      require(_buyer != address(0));\n', '      require(_buyer != address(this));\n', '      require(_buyer != ownerOf(_diamondId));\n', '      _transferInternal(_diamondId, _seller, _sellerId, _buyer, _buyerId, _usdPrice, _cedexPrice);\n', '    }\n', '    \n', '    function burn(string _diamondId) external onlyAdminOrCEO whenNotPaused {\n', '      require(!_isDiamondOutside(_diamondId));\n', '      _burn(_diamondId);\n', '    }\n', '    \n', '    function getDiamond(string _diamondId) \n', '        external\n', '        view\n', '        returns(\n', '            string ownerId,\n', '            string status,\n', '            string gemCompositeScore,\n', '            string gemSubcategory,\n', '            string media,\n', '            string custodian,\n', '            uint256 arrivalTime\n', '        )\n', '    {\n', '        require(diamondExists[_diamondId]);\n', '        \n', '         ownerId = diamondIdToMetadata[_diamondId].ownerId;\n', '         status = diamondIdToMetadata[_diamondId].status;\n', '         gemCompositeScore = diamondIdToMetadata[_diamondId].gemCompositeScore;\n', '         gemSubcategory = diamondIdToMetadata[_diamondId].gemSubcategory;\n', '         media = diamondIdToMetadata[_diamondId].media;\n', '         custodian = diamondIdToMetadata[_diamondId].custodian;\n', '         arrivalTime = diamondIdToMetadata[_diamondId].arrivalTime;\n', '    }\n', '}']
