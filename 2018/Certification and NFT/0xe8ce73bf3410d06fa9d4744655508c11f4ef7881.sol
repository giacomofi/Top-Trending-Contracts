['pragma solidity ^0.4.19;\n', '\n', '\n', '//\n', '// SVLightBallotBox\n', '// Single use contract to manage a ballot\n', '// Author: Max Kaye <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7419150c340711170106115a021b0011">[email&#160;protected]</a>>\n', '// (c) SecureVote 2018\n', '//\n', '// Architecture:\n', '// * Ballot authority declares public key with which to encrypt ballots (optional - stored in ballot spec)\n', '// * Users submit encrypted or plaintext ballots as blobs (dependent on above)\n', '// * These ballots are tracked by the ETH address of the sender\n', '// * Following the conclusion of the ballot, the secret key is provided\n', '//   by the ballot authority, and all users may transparently and\n', '//   independently validate the results\n', '//\n', '// Notes:\n', '// * Since ballots are encrypted the only validation we can do is length, but UI takes care of most of the rest\n', '//\n', '\n', '\n', 'contract SVLightBallotBox {\n', '    //// ** Storage Variables\n', '\n', '    // Std owner pattern\n', '    address public owner;\n', '\n', '    // test mode - operations like changing start/end times\n', '    bool public testMode = false;\n', '\n', '    // struct for ballot\n', '    struct Ballot {\n', '        bytes32 ballotData;\n', '        address sender;\n', '        // we use a uint32 here because addresses are 20 bytes and this might help\n', '        // solidity pack the block number well. gives us a little room to expand too if needed.\n', '        uint32 blockN;\n', '    }\n', '\n', '    // Maps to store ballots, along with corresponding log of voters.\n', '    // Should only be modified through `addBallotAndVoter` internal function\n', '    mapping (uint256 => Ballot) public ballotMap;\n', '    mapping (uint256 => bytes32) public associatedPubkeys;\n', '    uint256 public nVotesCast = 0;\n', '\n', '    // Use a map for voters to look up their ballot\n', '    mapping (address => uint256) public voterToBallotID;\n', '\n', '    // NOTE - We don&#39;t actually want to include the PublicKey because _it&#39;s included in the ballotSpec_.\n', '    // It&#39;s better to ensure ppl actually have the ballot spec by not including it in the contract.\n', '    // Plus we&#39;re already storing the hash of the ballotSpec anyway...\n', '\n', '    // Private key to be set after ballot conclusion - curve25519\n', '    bytes32 public ballotEncryptionSeckey;\n', '    bool seckeyRevealed = false;\n', '\n', '    // Timestamps for start and end of ballot (UTC)\n', '    uint64 public startTime;\n', '    uint64 public endTime;\n', '    uint64 public creationBlock;\n', '    uint64 public startingBlockAround;\n', '\n', '    // specHash by which to validate the ballots integrity\n', '    bytes32 public specHash;\n', '    bool public useEncryption;\n', '\n', '    // deprecation flag - doesn&#39;t actually do anything besides signal that this contract is deprecated;\n', '    bool public deprecated = false;\n', '\n', '    //// ** Events\n', '    event CreatedBallot(address _creator, uint64[2] _openPeriod, bool _useEncryption, bytes32 _specHash);\n', '    event SuccessfulPkVote(address voter, bytes32 ballot, bytes32 pubkey);\n', '    event SuccessfulVote(address voter, bytes32 ballot);\n', '    event SeckeyRevealed(bytes32 secretKey);\n', '    event TestingEnabled();\n', '    event Error(string error);\n', '    event DeprecatedContract();\n', '    event SetOwner(address _owner);\n', '\n', '\n', '    //// ** Modifiers\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier ballotOpen {\n', '        require(uint64(block.timestamp) >= startTime && uint64(block.timestamp) < endTime);\n', '        _;\n', '    }\n', '\n', '    modifier onlyTesting {\n', '        require(testMode);\n', '        _;\n', '    }\n', '\n', '    modifier isTrue(bool _b) {\n', '        require(_b == true);\n', '        _;\n', '    }\n', '\n', '    modifier isFalse(bool _b) {\n', '        require(_b == false);\n', '        _;\n', '    }\n', '\n', '    //// ** Functions\n', '\n', '    uint16 constant F_USE_ENC = 0;\n', '    uint16 constant F_TESTING = 1;\n', '    // Constructor function - init core params on deploy\n', '    // timestampts are uint64s to give us plenty of room for millennia\n', '    // flags are [_useEncryption, enableTesting]\n', '    function SVLightBallotBox(bytes32 _specHash, uint64[2] openPeriod, bool[2] flags) public {\n', '        owner = msg.sender;\n', '\n', '        // take the max of the start time provided and the blocks timestamp to avoid a DoS against recent token holders\n', '        // (which someone might be able to do if they could set the timestamp in the past)\n', '        startTime = max(openPeriod[0], uint64(block.timestamp));\n', '        endTime = openPeriod[1];\n', '        useEncryption = flags[F_USE_ENC];\n', '        specHash = _specHash;\n', '        creationBlock = uint64(block.number);\n', '        // add a rough prediction of what block is the starting block\n', '        startingBlockAround = uint64((startTime - block.timestamp) / 15 + block.number);\n', '\n', '        if (flags[F_TESTING]) {\n', '            testMode = true;\n', '            TestingEnabled();\n', '        }\n', '\n', '        CreatedBallot(msg.sender, [startTime, endTime], useEncryption, specHash);\n', '    }\n', '\n', '    // Ballot submission\n', '    function submitBallotWithPk(bytes32 encryptedBallot, bytes32 senderPubkey) isTrue(useEncryption) ballotOpen public {\n', '        addBallotAndVoterWithPk(encryptedBallot, senderPubkey);\n', '        SuccessfulPkVote(msg.sender, encryptedBallot, senderPubkey);\n', '    }\n', '\n', '    function submitBallotNoPk(bytes32 ballot) isFalse(useEncryption) ballotOpen public {\n', '        addBallotAndVoterNoPk(ballot);\n', '        SuccessfulVote(msg.sender, ballot);\n', '    }\n', '\n', '    // Internal function to ensure atomicity of voter log\n', '    function addBallotAndVoterWithPk(bytes32 encryptedBallot, bytes32 senderPubkey) internal {\n', '        uint256 ballotNumber = addBallotAndVoterNoPk(encryptedBallot);\n', '        associatedPubkeys[ballotNumber] = senderPubkey;\n', '    }\n', '\n', '    function addBallotAndVoterNoPk(bytes32 encryptedBallot) internal returns (uint256) {\n', '        uint256 ballotNumber = nVotesCast;\n', '        ballotMap[ballotNumber] = Ballot(encryptedBallot, msg.sender, uint32(block.number));\n', '        voterToBallotID[msg.sender] = ballotNumber;\n', '        nVotesCast += 1;\n', '        return ballotNumber;\n', '    }\n', '\n', '    // Allow the owner to reveal the secret key after ballot conclusion\n', '    function revealSeckey(bytes32 _secKey) onlyOwner public {\n', '        require(block.timestamp > endTime);\n', '\n', '        ballotEncryptionSeckey = _secKey;\n', '        seckeyRevealed = true; // this flag allows the contract to be locked\n', '        SeckeyRevealed(_secKey);\n', '    }\n', '\n', '    function getEncSeckey() public constant returns (bytes32) {\n', '        return ballotEncryptionSeckey;\n', '    }\n', '\n', '    // Test functions\n', '    function setEndTime(uint64 newEndTime) onlyTesting onlyOwner public {\n', '        endTime = newEndTime;\n', '    }\n', '\n', '    function setDeprecated() onlyOwner public {\n', '        deprecated = true;\n', '        DeprecatedContract();\n', '    }\n', '\n', '    function setOwner(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '        SetOwner(newOwner);\n', '    }\n', '\n', '    // utils\n', '    function max(uint64 a, uint64 b) pure internal returns(uint64) {\n', '        if (a > b) {\n', '            return a;\n', '        }\n', '        return b;\n', '    }\n', '}\n', '\n', '\n', '//\n', '// The Index by which democracies and ballots are tracked (and optionally deployed).\n', '// Author: Max Kaye <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="016c6079417264627473642f776e7564">[email&#160;protected]</a>>\n', '// (c) SecureVote 2018\n', '//\n', '\n', 'contract SVLightIndexShim {\n', '\n', '    address public owner;\n', '\n', '    struct Ballot {\n', '        bytes32 specHash;\n', '        bytes32 extraData;\n', '        address votingContract;\n', '        uint64 startTs;\n', '    }\n', '\n', '    struct Democ {\n', '        string name;\n', '        address admin;\n', '        Ballot[] ballots;\n', '    }\n', '\n', '    mapping (bytes32 => Democ) public democs;\n', '    bytes32[] public democList;\n', '\n', '    bool public paymentEnabled = false;\n', '\n', '    SVLightIndexShim prevIndex;\n', '\n', '    //* EVENTS /\n', '\n', '    event PaymentMade(uint128[2] valAndRemainder);\n', '    event DemocInit(string name, bytes32 democHash, address admin);\n', '    event BallotInit(bytes32 specHash, uint64[2] openPeriod, bool[2] flags);\n', '    event BallotAdded(bytes32 democHash, bytes32 specHash, bytes32 extraData, address votingContract);\n', '    event SetFees(uint128[2] _newFees);\n', '    event PaymentEnabled(bool _feeEnabled);\n', '\n', '    //* MODIFIERS /\n', '\n', '    modifier onlyBy(address _account) {\n', '        require(msg.sender == _account);\n', '        _;\n', '    }\n', '\n', '    //* FUNCTIONS /\n', '\n', '\n', '    // constructor\n', '    constructor(SVLightIndexShim _prevIndex) public {\n', '        owner = msg.sender;\n', '        prevIndex = _prevIndex;\n', '\n', '        bytes32 democHash;\n', '        bytes32 specHash;\n', '        bytes32 extraData;\n', '        address votingContract;\n', '        uint64 startTime;\n', '\n', '        for (uint i = 0; i < prevIndex.nDemocs(); i++) {\n', '            democHash = prevIndex.democList(i);\n', '            democList.push(democHash);\n', '            // only democracies are SWM\n', '            democs[democHash].admin = msg.sender;\n', '\n', '            for (uint j = 0; j < prevIndex.nBallots(democHash); j++) {\n', '                (specHash, extraData, votingContract, startTime) = prevIndex.getNthBallot(democHash, j);\n', '                democs[democHash].ballots.push(Ballot(specHash, extraData, votingContract, startTime));\n', '            }\n', '        }\n', '    }\n', '\n', '    //* GLOBAL INFO */\n', '\n', '    function nDemocs() public constant returns (uint256) {\n', '        return democList.length;\n', '    }\n', '\n', '    //* PAYMENT AND OWNER FUNCTIONS */\n', '\n', '    function setOwner(address _owner) onlyBy(owner) public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function setDemocAdminEmergency(bytes32 democHash, address newAdmin) onlyBy(owner) public {\n', '        democs[democHash].admin = newAdmin;\n', '    }\n', '\n', '    //* DEMOCRACY FUNCTIONS - INDIVIDUAL */\n', '\n', '    function getDemocInfo(bytes32 democHash) public constant returns (string name, address admin, uint256 nBallots) {\n', '        // only democs are SWM Gov democs\n', '        return ("SWM Governance", democs[democHash].admin, democs[democHash].ballots.length);\n', '    }\n', '\n', '    function setAdmin(bytes32 democHash, address newAdmin) onlyBy(democs[democHash].admin) public {\n', '        democs[democHash].admin = newAdmin;\n', '    }\n', '\n', '    function nBallots(bytes32 democHash) public constant returns (uint256) {\n', '        return democs[democHash].ballots.length;\n', '    }\n', '\n', '    function getNthBallot(bytes32 democHash, uint256 n) public constant returns (bytes32 specHash, bytes32 extraData, address votingContract, uint64 startTime) {\n', '        return (democs[democHash].ballots[n].specHash, democs[democHash].ballots[n].extraData, democs[democHash].ballots[n].votingContract, democs[democHash].ballots[n].startTs);\n', '    }\n', '\n', '    //* ADD BALLOT TO RECORD */\n', '\n', '    function _commitBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, address votingContract, uint64 startTs) internal {\n', '        democs[democHash].ballots.push(Ballot(specHash, extraData, votingContract, startTs));\n', '        BallotAdded(democHash, specHash, extraData, votingContract);\n', '    }\n', '\n', '    function addBallot(bytes32 democHash, bytes32 extraData, address votingContract)\n', '                      onlyBy(democs[democHash].admin)\n', '                      public\n', '                      {\n', '        SVLightBallotBox bb = SVLightBallotBox(votingContract);\n', '        bytes32 specHash = bb.specHash();\n', '        uint64 startTs = bb.startTime();\n', '        _commitBallot(democHash, specHash, extraData, votingContract, startTs);\n', '    }\n', '\n', '    function deployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData,\n', '                          uint64[2] openPeriod, bool[2] flags)\n', '                          onlyBy(democs[democHash].admin)\n', '                          public payable {\n', '        // the start time is max(startTime, block.timestamp) to avoid a DoS whereby a malicious electioneer could disenfranchise\n', '        // token holders who have recently acquired tokens.\n', '        uint64 startTs = max(openPeriod[0], uint64(block.timestamp));\n', '        SVLightBallotBox votingContract = new SVLightBallotBox(specHash, [startTs, openPeriod[1]], flags);\n', '        votingContract.setOwner(msg.sender);\n', '        _commitBallot(democHash, specHash, extraData, address(votingContract), startTs);\n', '        BallotInit(specHash, [startTs, openPeriod[1]], flags);\n', '    }\n', '\n', '    // utils\n', '    function max(uint64 a, uint64 b) pure internal returns(uint64) {\n', '        if (a > b) {\n', '            return a;\n', '        }\n', '        return b;\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '\n', '//\n', '// SVLightBallotBox\n', '// Single use contract to manage a ballot\n', '// Author: Max Kaye <max@secure.vote>\n', '// (c) SecureVote 2018\n', '//\n', '// Architecture:\n', '// * Ballot authority declares public key with which to encrypt ballots (optional - stored in ballot spec)\n', '// * Users submit encrypted or plaintext ballots as blobs (dependent on above)\n', '// * These ballots are tracked by the ETH address of the sender\n', '// * Following the conclusion of the ballot, the secret key is provided\n', '//   by the ballot authority, and all users may transparently and\n', '//   independently validate the results\n', '//\n', '// Notes:\n', '// * Since ballots are encrypted the only validation we can do is length, but UI takes care of most of the rest\n', '//\n', '\n', '\n', 'contract SVLightBallotBox {\n', '    //// ** Storage Variables\n', '\n', '    // Std owner pattern\n', '    address public owner;\n', '\n', '    // test mode - operations like changing start/end times\n', '    bool public testMode = false;\n', '\n', '    // struct for ballot\n', '    struct Ballot {\n', '        bytes32 ballotData;\n', '        address sender;\n', '        // we use a uint32 here because addresses are 20 bytes and this might help\n', '        // solidity pack the block number well. gives us a little room to expand too if needed.\n', '        uint32 blockN;\n', '    }\n', '\n', '    // Maps to store ballots, along with corresponding log of voters.\n', '    // Should only be modified through `addBallotAndVoter` internal function\n', '    mapping (uint256 => Ballot) public ballotMap;\n', '    mapping (uint256 => bytes32) public associatedPubkeys;\n', '    uint256 public nVotesCast = 0;\n', '\n', '    // Use a map for voters to look up their ballot\n', '    mapping (address => uint256) public voterToBallotID;\n', '\n', "    // NOTE - We don't actually want to include the PublicKey because _it's included in the ballotSpec_.\n", "    // It's better to ensure ppl actually have the ballot spec by not including it in the contract.\n", "    // Plus we're already storing the hash of the ballotSpec anyway...\n", '\n', '    // Private key to be set after ballot conclusion - curve25519\n', '    bytes32 public ballotEncryptionSeckey;\n', '    bool seckeyRevealed = false;\n', '\n', '    // Timestamps for start and end of ballot (UTC)\n', '    uint64 public startTime;\n', '    uint64 public endTime;\n', '    uint64 public creationBlock;\n', '    uint64 public startingBlockAround;\n', '\n', '    // specHash by which to validate the ballots integrity\n', '    bytes32 public specHash;\n', '    bool public useEncryption;\n', '\n', "    // deprecation flag - doesn't actually do anything besides signal that this contract is deprecated;\n", '    bool public deprecated = false;\n', '\n', '    //// ** Events\n', '    event CreatedBallot(address _creator, uint64[2] _openPeriod, bool _useEncryption, bytes32 _specHash);\n', '    event SuccessfulPkVote(address voter, bytes32 ballot, bytes32 pubkey);\n', '    event SuccessfulVote(address voter, bytes32 ballot);\n', '    event SeckeyRevealed(bytes32 secretKey);\n', '    event TestingEnabled();\n', '    event Error(string error);\n', '    event DeprecatedContract();\n', '    event SetOwner(address _owner);\n', '\n', '\n', '    //// ** Modifiers\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier ballotOpen {\n', '        require(uint64(block.timestamp) >= startTime && uint64(block.timestamp) < endTime);\n', '        _;\n', '    }\n', '\n', '    modifier onlyTesting {\n', '        require(testMode);\n', '        _;\n', '    }\n', '\n', '    modifier isTrue(bool _b) {\n', '        require(_b == true);\n', '        _;\n', '    }\n', '\n', '    modifier isFalse(bool _b) {\n', '        require(_b == false);\n', '        _;\n', '    }\n', '\n', '    //// ** Functions\n', '\n', '    uint16 constant F_USE_ENC = 0;\n', '    uint16 constant F_TESTING = 1;\n', '    // Constructor function - init core params on deploy\n', '    // timestampts are uint64s to give us plenty of room for millennia\n', '    // flags are [_useEncryption, enableTesting]\n', '    function SVLightBallotBox(bytes32 _specHash, uint64[2] openPeriod, bool[2] flags) public {\n', '        owner = msg.sender;\n', '\n', '        // take the max of the start time provided and the blocks timestamp to avoid a DoS against recent token holders\n', '        // (which someone might be able to do if they could set the timestamp in the past)\n', '        startTime = max(openPeriod[0], uint64(block.timestamp));\n', '        endTime = openPeriod[1];\n', '        useEncryption = flags[F_USE_ENC];\n', '        specHash = _specHash;\n', '        creationBlock = uint64(block.number);\n', '        // add a rough prediction of what block is the starting block\n', '        startingBlockAround = uint64((startTime - block.timestamp) / 15 + block.number);\n', '\n', '        if (flags[F_TESTING]) {\n', '            testMode = true;\n', '            TestingEnabled();\n', '        }\n', '\n', '        CreatedBallot(msg.sender, [startTime, endTime], useEncryption, specHash);\n', '    }\n', '\n', '    // Ballot submission\n', '    function submitBallotWithPk(bytes32 encryptedBallot, bytes32 senderPubkey) isTrue(useEncryption) ballotOpen public {\n', '        addBallotAndVoterWithPk(encryptedBallot, senderPubkey);\n', '        SuccessfulPkVote(msg.sender, encryptedBallot, senderPubkey);\n', '    }\n', '\n', '    function submitBallotNoPk(bytes32 ballot) isFalse(useEncryption) ballotOpen public {\n', '        addBallotAndVoterNoPk(ballot);\n', '        SuccessfulVote(msg.sender, ballot);\n', '    }\n', '\n', '    // Internal function to ensure atomicity of voter log\n', '    function addBallotAndVoterWithPk(bytes32 encryptedBallot, bytes32 senderPubkey) internal {\n', '        uint256 ballotNumber = addBallotAndVoterNoPk(encryptedBallot);\n', '        associatedPubkeys[ballotNumber] = senderPubkey;\n', '    }\n', '\n', '    function addBallotAndVoterNoPk(bytes32 encryptedBallot) internal returns (uint256) {\n', '        uint256 ballotNumber = nVotesCast;\n', '        ballotMap[ballotNumber] = Ballot(encryptedBallot, msg.sender, uint32(block.number));\n', '        voterToBallotID[msg.sender] = ballotNumber;\n', '        nVotesCast += 1;\n', '        return ballotNumber;\n', '    }\n', '\n', '    // Allow the owner to reveal the secret key after ballot conclusion\n', '    function revealSeckey(bytes32 _secKey) onlyOwner public {\n', '        require(block.timestamp > endTime);\n', '\n', '        ballotEncryptionSeckey = _secKey;\n', '        seckeyRevealed = true; // this flag allows the contract to be locked\n', '        SeckeyRevealed(_secKey);\n', '    }\n', '\n', '    function getEncSeckey() public constant returns (bytes32) {\n', '        return ballotEncryptionSeckey;\n', '    }\n', '\n', '    // Test functions\n', '    function setEndTime(uint64 newEndTime) onlyTesting onlyOwner public {\n', '        endTime = newEndTime;\n', '    }\n', '\n', '    function setDeprecated() onlyOwner public {\n', '        deprecated = true;\n', '        DeprecatedContract();\n', '    }\n', '\n', '    function setOwner(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '        SetOwner(newOwner);\n', '    }\n', '\n', '    // utils\n', '    function max(uint64 a, uint64 b) pure internal returns(uint64) {\n', '        if (a > b) {\n', '            return a;\n', '        }\n', '        return b;\n', '    }\n', '}\n', '\n', '\n', '//\n', '// The Index by which democracies and ballots are tracked (and optionally deployed).\n', '// Author: Max Kaye <max@secure.vote>\n', '// (c) SecureVote 2018\n', '//\n', '\n', 'contract SVLightIndexShim {\n', '\n', '    address public owner;\n', '\n', '    struct Ballot {\n', '        bytes32 specHash;\n', '        bytes32 extraData;\n', '        address votingContract;\n', '        uint64 startTs;\n', '    }\n', '\n', '    struct Democ {\n', '        string name;\n', '        address admin;\n', '        Ballot[] ballots;\n', '    }\n', '\n', '    mapping (bytes32 => Democ) public democs;\n', '    bytes32[] public democList;\n', '\n', '    bool public paymentEnabled = false;\n', '\n', '    SVLightIndexShim prevIndex;\n', '\n', '    //* EVENTS /\n', '\n', '    event PaymentMade(uint128[2] valAndRemainder);\n', '    event DemocInit(string name, bytes32 democHash, address admin);\n', '    event BallotInit(bytes32 specHash, uint64[2] openPeriod, bool[2] flags);\n', '    event BallotAdded(bytes32 democHash, bytes32 specHash, bytes32 extraData, address votingContract);\n', '    event SetFees(uint128[2] _newFees);\n', '    event PaymentEnabled(bool _feeEnabled);\n', '\n', '    //* MODIFIERS /\n', '\n', '    modifier onlyBy(address _account) {\n', '        require(msg.sender == _account);\n', '        _;\n', '    }\n', '\n', '    //* FUNCTIONS /\n', '\n', '\n', '    // constructor\n', '    constructor(SVLightIndexShim _prevIndex) public {\n', '        owner = msg.sender;\n', '        prevIndex = _prevIndex;\n', '\n', '        bytes32 democHash;\n', '        bytes32 specHash;\n', '        bytes32 extraData;\n', '        address votingContract;\n', '        uint64 startTime;\n', '\n', '        for (uint i = 0; i < prevIndex.nDemocs(); i++) {\n', '            democHash = prevIndex.democList(i);\n', '            democList.push(democHash);\n', '            // only democracies are SWM\n', '            democs[democHash].admin = msg.sender;\n', '\n', '            for (uint j = 0; j < prevIndex.nBallots(democHash); j++) {\n', '                (specHash, extraData, votingContract, startTime) = prevIndex.getNthBallot(democHash, j);\n', '                democs[democHash].ballots.push(Ballot(specHash, extraData, votingContract, startTime));\n', '            }\n', '        }\n', '    }\n', '\n', '    //* GLOBAL INFO */\n', '\n', '    function nDemocs() public constant returns (uint256) {\n', '        return democList.length;\n', '    }\n', '\n', '    //* PAYMENT AND OWNER FUNCTIONS */\n', '\n', '    function setOwner(address _owner) onlyBy(owner) public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function setDemocAdminEmergency(bytes32 democHash, address newAdmin) onlyBy(owner) public {\n', '        democs[democHash].admin = newAdmin;\n', '    }\n', '\n', '    //* DEMOCRACY FUNCTIONS - INDIVIDUAL */\n', '\n', '    function getDemocInfo(bytes32 democHash) public constant returns (string name, address admin, uint256 nBallots) {\n', '        // only democs are SWM Gov democs\n', '        return ("SWM Governance", democs[democHash].admin, democs[democHash].ballots.length);\n', '    }\n', '\n', '    function setAdmin(bytes32 democHash, address newAdmin) onlyBy(democs[democHash].admin) public {\n', '        democs[democHash].admin = newAdmin;\n', '    }\n', '\n', '    function nBallots(bytes32 democHash) public constant returns (uint256) {\n', '        return democs[democHash].ballots.length;\n', '    }\n', '\n', '    function getNthBallot(bytes32 democHash, uint256 n) public constant returns (bytes32 specHash, bytes32 extraData, address votingContract, uint64 startTime) {\n', '        return (democs[democHash].ballots[n].specHash, democs[democHash].ballots[n].extraData, democs[democHash].ballots[n].votingContract, democs[democHash].ballots[n].startTs);\n', '    }\n', '\n', '    //* ADD BALLOT TO RECORD */\n', '\n', '    function _commitBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, address votingContract, uint64 startTs) internal {\n', '        democs[democHash].ballots.push(Ballot(specHash, extraData, votingContract, startTs));\n', '        BallotAdded(democHash, specHash, extraData, votingContract);\n', '    }\n', '\n', '    function addBallot(bytes32 democHash, bytes32 extraData, address votingContract)\n', '                      onlyBy(democs[democHash].admin)\n', '                      public\n', '                      {\n', '        SVLightBallotBox bb = SVLightBallotBox(votingContract);\n', '        bytes32 specHash = bb.specHash();\n', '        uint64 startTs = bb.startTime();\n', '        _commitBallot(democHash, specHash, extraData, votingContract, startTs);\n', '    }\n', '\n', '    function deployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData,\n', '                          uint64[2] openPeriod, bool[2] flags)\n', '                          onlyBy(democs[democHash].admin)\n', '                          public payable {\n', '        // the start time is max(startTime, block.timestamp) to avoid a DoS whereby a malicious electioneer could disenfranchise\n', '        // token holders who have recently acquired tokens.\n', '        uint64 startTs = max(openPeriod[0], uint64(block.timestamp));\n', '        SVLightBallotBox votingContract = new SVLightBallotBox(specHash, [startTs, openPeriod[1]], flags);\n', '        votingContract.setOwner(msg.sender);\n', '        _commitBallot(democHash, specHash, extraData, address(votingContract), startTs);\n', '        BallotInit(specHash, [startTs, openPeriod[1]], flags);\n', '    }\n', '\n', '    // utils\n', '    function max(uint64 a, uint64 b) pure internal returns(uint64) {\n', '        if (a > b) {\n', '            return a;\n', '        }\n', '        return b;\n', '    }\n', '}']
