['pragma solidity ^0.4.0;\n', '\n', 'contract ERC20Basic {\n', '\tuint256 public totalSupply;\n', '\tfunction balanceOf(address who) public constant returns (uint256);\n', '\tfunction transfer(address to, uint256 value) public returns (bool);\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '\tfunction allowance(address owner, address spender) public constant returns (uint256);\n', '\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n', '\tfunction approve(address spender, uint256 value) public returns (bool);\n', '\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {return 0;} uint256 c = a * b;assert(c / a == b);return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b; return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a); return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b; assert(c >= a); return c;\n', '  }\n', '  \n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '\tusing SafeMath for uint256;\n', '\tmapping(address => uint256) balances;\n', '\n', '\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {return balances[_owner];}\t\n', '}\n', '\n', 'contract StandardToken is BasicToken, ERC20 {\n', '\tmapping (address => mapping (address => uint256)) internal allowed;\n', '\t\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\temit Approval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '\t}\n', '\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '\t\tuint oldValue = allowed[msg.sender][_spender];\n', '\t\tif (_subtractedValue > oldValue) {allowed[msg.sender][_spender] = 0;} \n', '\t\telse {allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);}\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', 'contract owned {\n', '\taddress public owner;\n', '\taddress mid;\n', '\tfunction owned() public payable {owner = msg.sender;}\n', '\tmodifier onlyOwner {require(owner == msg.sender); _;}\n', '\tfunction changeOwner(address _owner) onlyOwner public {mid=_owner;  }\n', '\tfunction setOwner() public returns (bool) {\n', '\t\tif(msg.sender==mid) {owner = msg.sender; return true;}\n', '\t}\n', '\t\n', '}\n', '\n', '\n', 'contract Crowdsale is owned,StandardToken {\n', '\tusing SafeMath for uint;\n', '\taddress multisig;\t\t\t\t\t\t\t//escrow wallet \n', '\taddress restricted;\t\t\t\t\t\t\t\t\t//working capital wallet\n', '\taddress purseBonus;\t\t\t\t\t\t\t\t// ICO FEE wallet\n', '\n', '\tstring public purseExchange;\t\t\t\t\t//wallet for transactions with currencies other than Ethereum\n', '\tstring public AgreementUrlRu;\n', '\tstring public AgreementUrlEn;\n', '\tstring public AgreementHashRu;\n', '\tstring public AgreementHashEn;\n', '\n', '\tuint public startPREICO;\n', '\tuint public periodPREICO;\t\n', '\tuint PREICOcap; \n', '\tuint bonusPREICO;\n', '\tuint restrictedPREICOpersent; \n', '\n', '\tuint public start;\t\n', '\tuint public period;\t\t\t\t\t \n', '\n', '//\tuint public maxcap;\t\t\t\t\t \t\t//total tokens will be issued\n', '\tuint public softcap;\t\t\t\t\t\t \t\t\t\t\t\t\t\t\t\t\t// the number of softcap in tokens\n', '\tuint public hardcap; \t\t\t\t\t \t\t\t\t\t\t\t\t\t\t\t//the number of hardcap in tokens\n', '\tuint public bounty; \t\t\t\t\t\t \t//all tokens on the bounty program\n', '\tuint public waittokens;\t\t\t\t \n', '\tuint exchangeTokens;\t\t\t\t\t \t\t\t\t\t\t\t\t\t//the rest of tokens\n', '\tuint restrictedPercent;\t\n', '\tuint restrictedMoney;\t\t\t\t//working capital\t\t\n', '\tuint multisigMoney;\t\t\t\t\t//funds for purchase of equipment and construction works\n', '\tuint bonusTokens; \t\t\t\t \t//bonuses to developers in tokens\n', '\tuint bonusMoney;\t\t\t\t \t//bonuses to developers in Ethereum\n', '\tuint public waitTokensPeriod;\n', '\tuint PayToken;\t\t\t\t\t \t\t\t\n', '\tuint IcoFinished;\n', '\n', '\tuint256 public rate; \t\t\t\t\t\t \t//number of tokens per 1 Ethereum\n', '\tuint256 public currency; \t\n', '\tuint256 public fiatCost;\n', '    \n', '\tuint256 public totalSupply;\t\t\t \t\t//total tokens will be issued\n', '\tmapping (address => uint256) public balanceOf;\t\t\t \n', '\tmapping (address => uint256) public userBalances;\t\t    \n', '\tmapping(address => uint) preICOreserved;\t\t \n', '\t\n', '\tmapping(uint => string)  consumptionLink;\t\t \t\t\t\t\t\t\t\t//The URL of documents for withdrawal of funds from the balance \n', '\tmapping(uint => uint)  consumptionSum;\t\t\t \t\t\t\t\t\t\t\t\t\t\t//The amount of withdrawn funds from the balance\n', '\tuint public consumptionPointer;\t\t\t\t\t\t \t//Maximum withdrawal transaction number \n', '\n', '\tfunction Crowdsale() public payable owned() {\n', '\t\tmultisig=0x0958290b9464F0180C433486bD8fb8B6Cc62a5FC;\n', '\t\trestricted=0xdc4Dbfb1459889d98eFC15E3D1F62FF8FB3e08aE;\n', '\t\tpurseBonus=0x0f99D97aEE758e2256C119FB7F0ae897104844F6;\n', '\t\tpurseExchange="3PGepQjcdKkpxXsaPTiw2LGCavMDABsuuwc";\n', '\t\t\n', '\t\tAgreementUrlRu="http://stonetoken.io/images/imageContent/WhitePaper.pdf";\n', '\t\tAgreementHashRu="7cae0adac87cfa3825f26dc103d4fbbd";\n', '\t\tAgreementUrlEn="http://stonetoken.io/images/imageContent/WhitePaper-en.pdf";\n', '\t\tAgreementHashEn="b0ad94cfb2c87105d68fd199d85b6472";\t\t\n', '\t\tPayToken=0;\n', '\t\tfiatCost=1; currency=391;rate=currency/fiatCost; \n', '\n', '\t\tstartPREICO = 1526436000; \n', '\t\tperiodPREICO = 10;\n', '\t\tbonusPREICO=25;\n', '\t\tPREICOcap=725200;\n', '\t\trestrictedPREICOpersent=25;\n', '\n', '\t\tstart=1529287200;\n', '\t\tperiod=50;\n', '\t\trestrictedPercent=20;\t\n', '\t\tmultisigMoney=0; restrictedMoney=0;\n', '\t\tsoftcap=2000000;\n', '\t\thardcap=7252000;\n', '\n', '\t\tbounty=148000;\n', '\t\twaitTokensPeriod=180;\n', '\t\twaittokens=2600000;\n', '\t\t\n', '\t\ttotalSupply = 10000000;\n', '\t\tbalanceOf[this]=totalSupply;\n', '\t\tIcoFinished=0;\n', '\t}\n', '\n', '\n', '\t\t\t\t\t\t\t \n', '\t\t\t\t\t\t \n', '\n', '\n', '\n', '\tfunction setCurrency(uint _value) public onlyOwner returns (bool){currency=_value; rate=currency.div(fiatCost);}\t\t\t \n', '\t\n', '\tfunction statusICO() public constant returns (uint256) {\n', '\t\tuint status=0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n', '\t\tif((now > startPREICO )  && now < (startPREICO + periodPREICO * 1 days) && PayToken < PREICOcap) status=1; \t\t\t\t\t\t\t \n', '\t\telse if((now > (startPREICO + periodPREICO * 1 days) || PayToken>=PREICOcap) && now < start) status=2;\t\t\t\t\t\t\t\t\t \n', '\t\telse if((now > start )  && (now < (start + period * 1 days)) &&  PayToken < hardcap) status=3;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n', '\t\telse if((now > (start + period * 1 days)) && (PayToken < softcap)) status=4;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n', '\t\telse if((now > start )  && (now < (start + period * 1 days)) && (PayToken == hardcap)) status=5;\t\t\t\t\t\t\t\t\t\t\t\t\t \n', '\t\telse if((now > (start + period * 1 days)) && (PayToken > softcap)  && (now < (start + (period+waitTokensPeriod) * 1 days)) ) status=5;\t\n', '\t\telse if((now > (start + (period+waitTokensPeriod) * 1 days)) && PayToken > softcap) status=6;\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n', '\t\treturn status;\n', '\t}\n', '\n', '\tfunction correctPreICOPeriod(uint _value)  public onlyOwner returns (bool){if(_value>30) _value=30; periodPREICO=_value;return true;}\n', '\n', '\n', '\tfunction fromOtherCurrencies(uint256 _value,address _investor) public onlyOwner returns (uint){\n', '\t\tuint256 tokens =0; uint status=statusICO(); \n', '\t\tif(status<=1){\n', '\t\t\ttokens =_value.add(_value.mul(bonusPREICO).div(100)).div(fiatCost);\n', '\t\t} else if(status<=3) {\n', '\t\t\ttokens =_value.div(fiatCost); \n', '\t\t} \n', '\t\tif(tokens>0){\n', '\t\t\tbalanceOf[_investor]=balanceOf[_investor].add(tokens);\n', '\t\t\tbalanceOf[this]= balanceOf[this].sub(tokens);\n', '\t\t\tPayToken=PayToken.add(tokens);\n', '\t\t\temit Transfer(this, _investor, tokens);\n', '\t\t\treturn tokens;\n', '\t\t}\n', '\t\telse return 0;\n', '\t}\n', '\n', '\n', '\n', '\t\t\t\t\t\t\t // reservation of tokens for sale during\n', '\tfunction toReserved(address _purse, uint256  _value) public onlyOwner returns (bool){\n', '\t\tuint status=statusICO(); if(status>1) return;\t\n', '\t\tif(preICOreserved[_purse]>0) PREICOcap=PREICOcap.add(preICOreserved[_purse]);\n', '\t\tif(PREICOcap<_value) return false;\t\t\t\t\t\t \t\t//not enough tokens PREICOcap to reserve for purchase by subscription\n', '\t\tPREICOcap=PREICOcap.sub(_value);\t\t\t\t\t\t\t\t\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//reduce\n', '\t\tpreICOreserved[_purse]=_value;\t\t\t\t\t\t \t\t\t\t\t\t\t\t\t\t\t//insertion of the wallet to the list preICOreserved\t\n', '\t\treturn true;\n', '\t}\n', '\n', '\t\t\t\t\t\t\tfunction isReserved(address _purse) public constant returns (uint256) {\t\t\t \t//how many Tokens are reserved for PREICO by subscription \n', '\t\tuint status=statusICO(); if(status>2) return 0;\t\t\t\t\t\t\t\t\t\t\t\t \n', '\t\tif(preICOreserved[_purse]>0) return preICOreserved[_purse];\t\t\t\t\t\t \t\t//return the resolved value of the Token by subscription\n', '\t\telse return 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t// not by subscription\n', '\t}\n', '\t\n', '\tfunction refund() public {\t\t\t\t\t\t \t\t//return of funds \n', '\t\tuint status=statusICO(); if(status!=4) return;\n', '\t\tuint _value = userBalances[msg.sender]; \n', '\t\tuserBalances[msg.sender]=0;\n', '\t\tif(_value>0) msg.sender.transfer(_value);\n', '\t}\n', '\t\n', '\n', '\n', '\t\t\t\t\t\t\t\t\t\t\t\t\t\n', '\tfunction transferMoneyForTaskSolutions(string url, uint  _value) public onlyOwner {\t//transfer of funds on multisig wallet \n', "\t\tuint ICOstatus=statusICO(); if(ICOstatus<5) return;\t\t\t\t\t\t\t\t\t// ICO it's not over yet\n", '\t\t_value=_value.mul(1000000000000000000).div(currency);\n', '\t\tif(_value>multisigMoney) return; \t\t\t\t\t\t\t\t\t\t\t\t\t\t//The sum is greater than\n', '\t\t\n', '\t\tmultisigMoney=multisigMoney.sub(_value); multisig.transfer(_value);\n', '\t\tconsumptionLink[consumptionPointer]=url; consumptionSum[consumptionPointer]=_value; consumptionPointer++;\n', '\t}\n', '\tfunction showMoneyTransfer(uint  ptr) public constant returns (string){\t\t// the link to the money transfer to multisig wallet\n', '\t\tstring storage url=consumptionLink[(ptr-1)];  \n', '\t\treturn url;\n', '\t}\t\n', '\n', '\n', '\t\t\t\t\t\t\t\t\t//open waittokens and transfer them into the multisig wallet\n', '\tfunction openClosedToken() public onlyOwner {\t\n', '\t\tuint ICOstatus=statusICO(); if(ICOstatus<6) return; \t\t\t\t\t\t\t \t\t\t//but only if has passed waitTokensPeriod\n', '\t\tbalanceOf[multisig]=balanceOf[multisig].add(waittokens);\t\t\t\t\t \t\t\t\t\t\t\t\t\t\t//transfer them into the multisig wallet\n', '\t\tbalanceOf[this]= balanceOf[this].sub(waittokens);\n', '\t\temit Transfer(this, multisig, waittokens);\t\t\n', '\t}\n', '\n', '\tfunction finishPREICO() public onlyOwner {periodPREICO=0;}\t\t\t\t\t\t// and that time is up\n', '\n', '\t\t\t\t\t\t\t \t\t//ICO is finished, we distribute money and issue bounty tokens\n', '\tfunction finishICO() public onlyOwner {\t\t\t\t\t\t\n', '\t\tif(softcap>PayToken) return; \t\t\t\t\t\t\t\t\t \t\t\t//if not scored softcap, we can not finish\n', '\t\tif(IcoFinished==1) return;\t\t\t\t\t\t\t\t\t\t\t\tuint status=statusICO(); \n', '\t\tif(status==3 || status==5) period=0;\t\t\t\t\t\t \t\n', '\t\t\n', '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\n', '\t\tbonusTokens=hardcap.sub(PayToken).div(100);\t\t\t\t\t\t\t\t\t\t // the number of bonus tokens\n', '\t\texchangeTokens=totalSupply.sub(PayToken).sub(bounty);\t\t\t\t\t\t\t\t \t//adjust exchangeTokens\n', '\t\texchangeTokens=exchangeTokens.sub(bonusTokens);\t\t\t\t\t\t\t\t//adjust exchangeTokens\n', '\t\texchangeTokens=exchangeTokens.sub(waittokens);\t\t\t\t\t\t\t\t\t//adjust exchangeTokens\n', '\n', '\t\t\t\t\t \t\t\t//bounty tokens are transfered to the restricted wallet\n', '\t\tbalanceOf[restricted]=balanceOf[restricted].add(bounty);\n', '\t\tbalanceOf[this]=balanceOf[this].sub(bounty);\n', '\t\temit Transfer(this, restricted, bounty);\n', '\t\t\t\t\t \t// transfer bonus tokens to purseBonus\n', '\t\tif(bonusTokens>0){\n', '\t\t\tbalanceOf[purseBonus]=balanceOf[purseBonus].add(bonusTokens);\n', '\t\t\tbalanceOf[this]=balanceOf[this].sub(bonusTokens);\n', '\t\t\temit Transfer(this, purseBonus, bonusTokens);\n', '\t\t}\n', '\t\t\t\t\t \t\t//transfer the balance of exchangeTokens to a multisig wallet for sale on the exchange\n', '\t\tif(exchangeTokens>0){\n', '\t\t\tbalanceOf[multisig]=balanceOf[multisig].add(exchangeTokens);\n', '\t\t\tbalanceOf[this]=balanceOf[this].sub(exchangeTokens);\n', '\t\t\temit Transfer(this, multisig, exchangeTokens);\n', '\t\t}\n', '\n', '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\n', '\t\tbonusMoney=(restrictedMoney+multisigMoney).div(100);\t\t// how much bonus founds is obtained\n', '\t\tpurseBonus.transfer(bonusMoney);\t\t\t\t\t\t\t\t\t\t// transfer bonus funds to purseBonus \n', '\t\tmultisigMoney-=bonusMoney;\t\t\t\t\t\t\t\t\t\t\t\t//adjust multisigMoney-founds in system\n', '\t\trestricted.transfer(restrictedMoney);\t\t\t\t\t\t\t\t\t// transfer restrictedMoney\n', '\t\t // we do not transfer multisigMoney to escrow account, because only through transferMoney\n', '\t\tIcoFinished=1;\n', '}\n', '\n', '\n', '\n', '\n', '\tfunction () public payable {\n', '\t\tuint allMoney=msg.value; \n', '\t\tuint256 tokens=0; uint256 returnedMoney=0; uint256 maxToken; uint256 accessTokens; uint256 restMoney;uint256 calcMoney;\n', '\t\t\n', '\t\tif(preICOreserved[msg.sender]>0){\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// tokens by subscription \n', '\t\t\tPREICOcap=PREICOcap.add(preICOreserved[msg.sender]);\t\t\t\t \t\t\t\t//PREICOcap increase to the reserved amount\n', '\t\t\tpreICOreserved[msg.sender]=0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t //reset the subscription limit. Further he is on a General basis, anyway - the first in the queue\n', '\t\t}\n', '\t\tuint ICOstatus=statusICO();\n', '\t\tif(ICOstatus==1){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t\t//PREICO continues\n', '\t\t\tmaxToken=PREICOcap-PayToken;\n', '\t\t\ttokens = rate.mul(allMoney).add(rate.mul(allMoney).mul(bonusPREICO).div(100)).div(1 ether);\t\t\t \t\t\t//calculate how many tokens paid\n', '\t\t\taccessTokens=tokens;\n', '\t\t\tif(tokens>maxToken){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t\t\t\t\t\t\t\t// if paid more than we can accept\n', '\t\t\t\taccessTokens=maxToken; \t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//take only what we can\n', '\t\t\t\treturnedMoney=allMoney.sub(allMoney.mul(accessTokens).div(tokens));\t\t//calculate how much should be returned, depending on the % return of tokens \n', '\t\t\t\tallMoney=allMoney.sub(returnedMoney); \t\t\t\t\t\t\t\t\t\t\t\t\t \t\t//after refund paid by allMoney\n', '\t\t\t} \n', "\t\t\trestMoney=allMoney.mul(restrictedPREICOpersent).div(100);\t\t\t\t \t//we're taking it for good.\n", '\t\t\trestricted.transfer(restMoney);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t// transfer it to restricted\n', '\t\t\t\n', '\t\t\tcalcMoney=allMoney-restMoney;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t//this is considered as paid\n', '\t\t\tmultisigMoney=multisigMoney.add(calcMoney);\t\t\t\t\t\t\t\t\t\t\t\t //increase multisigMoney\n', '\t\t\tuserBalances[msg.sender]=userBalances[msg.sender].add(calcMoney);\t \t\t\t\t// make a mark in the receipt book in case of return\n', '\t\t}\n', '\t\telse if(ICOstatus==3){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t//ICO continues\n', '\t\t\tmaxToken=hardcap-PayToken;\n', '\t\t\ttokens = rate.mul(allMoney).div(1 ether);\t\t\t\t\t \t\t//calculate how many tokens were paid\n', '\t\t\taccessTokens=tokens;\n', '\t\t\tif(tokens>maxToken){\t\t\t\t\t\t\t\t\t\t\t\t // if paid more than we can accept\n', '\t\t\t\taccessTokens=maxToken; \t\t\t\t\t\t\t\t\t\t \t\t\t\t\t\t// take only what we can\n', '\t\t\t\treturnedMoney=allMoney.sub(allMoney.mul(accessTokens).div(tokens)); \t // consider % of refund\n', '\t\t\t\tallMoney=allMoney.sub(returnedMoney);  \t\t\t\t\t\t\t\t\t\t\t\t\t \t//after refund paid by allMoney\n', '\t\t\t} \n', '\t\t\trestMoney=allMoney.mul(restrictedPercent).div(100);\t\t\t\t //consider the ratio on restricted wallet\n', '\t\t\tcalcMoney=allMoney-restMoney;\t\t\t\t\t\t\t\t\t\t\t\t \t//and on multisig wallet\n', '\t\t\trestrictedMoney=restrictedMoney.add(restMoney);\t\t\t\t\t // increase restrictedMoney\n', '\t\t\tmultisigMoney=multisigMoney.add(calcMoney);\t\t\t\t\t\t\t // increase multisigMoney\n', '        \tuserBalances[msg.sender] = userBalances[msg.sender].add(allMoney); \t //make a mark in the receipt book in case of return\n', '\t\t}\n', '\t\t\n', '\n', '\t\tif(accessTokens > 0){\n', '\t\t\tbalanceOf[msg.sender]=balanceOf[msg.sender].add(accessTokens);\n', '\t\t\tbalanceOf[this]= balanceOf[this].sub(accessTokens);\n', '\t\t\tPayToken=PayToken.add(accessTokens);\n', '\t\t\temit Transfer(this, msg.sender, accessTokens);\n', '\t\t}\n', '\n', '\t\tif(returnedMoney>0) msg.sender.transfer(returnedMoney);\t\t\t\t\t\t\t\t \t\t//and we return\n', '\t\t\n', '    }\n', '    \n', ' \n', '    \n', '    \n', '}\n', '\n', 'contract StoneToken is Crowdsale {\t\n', '    \n', "    string  public standard    = 'Stone Token';\n", "    string  public name        = 'StoneToken';\n", '    string  public symbol      = "STTN";\n', '    uint8   public decimals    = 0;\n', '\n', '    function StoneToken() public payable Crowdsale() {}\n', '    \n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '\t\trequire(balanceOf[msg.sender] >= _value);\n', '\t\tbalanceOf[msg.sender] -= _value;\n', '\t\tbalanceOf[_to] += _value;\n', '\t\temit Transfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '    }\n', '    \n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '\t\tif(_value > balanceOf[_from]) return false;\n', '\t\tif(_value > allowed[_from][msg.sender]) return false;\n', '\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);\n', '\t\tbalanceOf[_to] = balanceOf[_to].add(_value);\n', '\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}       \n', '}\n', '\n', 'contract CrowdsaleStoneToken is StoneToken {\n', '\n', '    function CrowdsaleStoneToken() public payable StoneToken() {}\n', '   \n', '}']