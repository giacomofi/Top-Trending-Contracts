['pragma solidity ^0.4.24;\n', '\n', 'contract ERC20 {\n', '  function balanceOf (address owner) public view returns (uint256);\n', '  function transfer (address to, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract FSTSaleServiceWindowReferral {\n', '  using Math for uint256;\n', '\n', '  address public owner;\n', '  address private rf = address(0);\n', '\n', '  bytes32 private secretHash;\n', '  ERC20 public funderSmartToken;\n', '  Math.Fraction public fstPrice;\n', '\n', '  uint256 public totalEtherReceived = 0;\n', '\n', '  bool public isEnabled = true;\n', '  bool public finalized = false;\n', '\n', '  event TokenPurchase(\n', '    ERC20 indexed token,\n', '    address indexed buyer,\n', '    address indexed receiver,\n', '    uint256 value,\n', '    uint256 amount\n', '  );\n', '  \n', '  event RFDeclare(address rf);\n', '  event Finalize(address receiver, address rf, uint256 fstkRevenue);\n', '\n', '  constructor (\n', '    address _fstAddress,\n', '    bytes32 _secretHash\n', '  ) public {\n', '    owner = msg.sender;\n', '    secretHash = _secretHash;\n', '    funderSmartToken = ERC20(_fstAddress);\n', '    fstPrice.numerator = 1;\n', '    fstPrice.denominator = 3600;\n', '  }\n', '\n', '  function () public payable {\n', '    uint256 available = funderSmartToken.balanceOf(address(this));\n', '    uint256 revenue;\n', '    uint256 purchaseAmount = msg.value.div(fstPrice);\n', '\n', '    require(\n', '      isEnabled &&\n', '      finalized == false &&\n', '      available > 0 &&\n', '      purchaseAmount > 0\n', '    );\n', '\n', '    if (available >= purchaseAmount) {\n', '      revenue = msg.value;\n', '    } else {\n', '      purchaseAmount = available;\n', '      revenue = available.mulCeil(fstPrice);\n', '      isEnabled = false;\n', '\n', '      msg.sender.transfer(msg.value - revenue);\n', '    }\n', '\n', '    funderSmartToken.transfer(msg.sender, purchaseAmount);\n', '\n', '    emit TokenPurchase(funderSmartToken, msg.sender, msg.sender, revenue, purchaseAmount);\n', '    \n', '    totalEtherReceived += revenue;\n', '  }\n', '  \n', '  function declareRF(string _secret) public {\n', '    require(\n', '      secretHash == keccak256(abi.encodePacked(_secret)) &&\n', '      rf == address(0)\n', '    );\n', '\n', '    rf = msg.sender;\n', '    \n', '    emit RFDeclare(rf);\n', '  }\n', '\n', '  function finalize (address _receiver) public {\n', '    require(\n', '      msg.sender == owner &&\n', '      isEnabled == false &&\n', '      finalized == false &&\n', '      rf != address(0)\n', '    );\n', '\n', '    finalized = true;\n', '\n', '    // 15% referral\n', '    rf.transfer(address(this).balance * 15 / 100);\n', '    _receiver.transfer(address(this).balance);\n', '\n', '    uint256 available = funderSmartToken.balanceOf(address(this));\n', '    if (available > 0) {\n', '      funderSmartToken.transfer(_receiver, available);\n', '    }\n', '\n', '    emit Finalize(_receiver, rf, totalEtherReceived * 85 / 100);\n', '  }\n', '\n', '  function setOwner (address _ownder) public {\n', '    require(msg.sender == owner);\n', '    owner = _ownder;\n', '  }\n', '\n', '  function setFunderSmartToken(address _fstAddress) public {\n', '    require(msg.sender == owner);\n', '    funderSmartToken = ERC20(_fstAddress);\n', '  }\n', '\n', '  function setFSTPrice(uint256 numerator, uint256 denominator) public {\n', '    require(msg.sender == owner);\n', '    require(\n', '      numerator > 0 &&\n', '      denominator > 0\n', '    );\n', '\n', '    fstPrice.numerator = numerator;\n', '    fstPrice.denominator = denominator;\n', '  }\n', '\n', '  function setEnabled (bool _isEnabled) public {\n', '    require(msg.sender == owner);\n', '    isEnabled = _isEnabled;\n', '  }\n', '\n', '}\n', '\n', 'library Math {\n', '\n', '  struct Fraction {\n', '    uint256 numerator;\n', '    uint256 denominator;\n', '  }\n', '\n', '  function isPositive(Fraction memory fraction) internal pure returns (bool) {\n', '    return fraction.numerator > 0 && fraction.denominator > 0;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    r = a * b;\n', '    require((a == 0) || (r / a == b));\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    r = a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    require((r = a - b) <= a);\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    require((r = a + b) >= a);\n', '  }\n', '\n', '  function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\n', '    return x <= y ? x : y;\n', '  }\n', '\n', '  function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\n', '    return x >= y ? x : y;\n', '  }\n', '\n', '  function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n', '    // try mul\n', '    r = value * m;\n', '    if (r / value == m) {\n', '      // if mul not overflow\n', '      r /= d;\n', '    } else {\n', '      // else div first\n', '      r = mul(value / d, m);\n', '    }\n', '  }\n', '\n', '  function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n', '    // try mul\n', '    r = value * m;\n', '    if (r / value == m) {\n', '      // mul not overflow\n', '      if (r % d == 0) {\n', '        r /= d;\n', '      } else {\n', '        r = (r / d) + 1;\n', '      }\n', '    } else {\n', '      // mul overflow then div first\n', '      r = mul(value / d, m);\n', '      if (value % d != 0) {\n', '        r += 1;\n', '      }\n', '    }\n', '  }\n', '\n', '  function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDiv(x, f.numerator, f.denominator);\n', '  }\n', '\n', '  function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDivCeil(x, f.numerator, f.denominator);\n', '  }\n', '\n', '  function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDiv(x, f.denominator, f.numerator);\n', '  }\n', '\n', '  function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDivCeil(x, f.denominator, f.numerator);\n', '  }\n', '\n', '  function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) {\n', '    return Math.Fraction({\n', '      numerator: mul(x.numerator, y.numerator),\n', '      denominator: mul(x.denominator, y.denominator)\n', '    });\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract ERC20 {\n', '  function balanceOf (address owner) public view returns (uint256);\n', '  function transfer (address to, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract FSTSaleServiceWindowReferral {\n', '  using Math for uint256;\n', '\n', '  address public owner;\n', '  address private rf = address(0);\n', '\n', '  bytes32 private secretHash;\n', '  ERC20 public funderSmartToken;\n', '  Math.Fraction public fstPrice;\n', '\n', '  uint256 public totalEtherReceived = 0;\n', '\n', '  bool public isEnabled = true;\n', '  bool public finalized = false;\n', '\n', '  event TokenPurchase(\n', '    ERC20 indexed token,\n', '    address indexed buyer,\n', '    address indexed receiver,\n', '    uint256 value,\n', '    uint256 amount\n', '  );\n', '  \n', '  event RFDeclare(address rf);\n', '  event Finalize(address receiver, address rf, uint256 fstkRevenue);\n', '\n', '  constructor (\n', '    address _fstAddress,\n', '    bytes32 _secretHash\n', '  ) public {\n', '    owner = msg.sender;\n', '    secretHash = _secretHash;\n', '    funderSmartToken = ERC20(_fstAddress);\n', '    fstPrice.numerator = 1;\n', '    fstPrice.denominator = 3600;\n', '  }\n', '\n', '  function () public payable {\n', '    uint256 available = funderSmartToken.balanceOf(address(this));\n', '    uint256 revenue;\n', '    uint256 purchaseAmount = msg.value.div(fstPrice);\n', '\n', '    require(\n', '      isEnabled &&\n', '      finalized == false &&\n', '      available > 0 &&\n', '      purchaseAmount > 0\n', '    );\n', '\n', '    if (available >= purchaseAmount) {\n', '      revenue = msg.value;\n', '    } else {\n', '      purchaseAmount = available;\n', '      revenue = available.mulCeil(fstPrice);\n', '      isEnabled = false;\n', '\n', '      msg.sender.transfer(msg.value - revenue);\n', '    }\n', '\n', '    funderSmartToken.transfer(msg.sender, purchaseAmount);\n', '\n', '    emit TokenPurchase(funderSmartToken, msg.sender, msg.sender, revenue, purchaseAmount);\n', '    \n', '    totalEtherReceived += revenue;\n', '  }\n', '  \n', '  function declareRF(string _secret) public {\n', '    require(\n', '      secretHash == keccak256(abi.encodePacked(_secret)) &&\n', '      rf == address(0)\n', '    );\n', '\n', '    rf = msg.sender;\n', '    \n', '    emit RFDeclare(rf);\n', '  }\n', '\n', '  function finalize (address _receiver) public {\n', '    require(\n', '      msg.sender == owner &&\n', '      isEnabled == false &&\n', '      finalized == false &&\n', '      rf != address(0)\n', '    );\n', '\n', '    finalized = true;\n', '\n', '    // 15% referral\n', '    rf.transfer(address(this).balance * 15 / 100);\n', '    _receiver.transfer(address(this).balance);\n', '\n', '    uint256 available = funderSmartToken.balanceOf(address(this));\n', '    if (available > 0) {\n', '      funderSmartToken.transfer(_receiver, available);\n', '    }\n', '\n', '    emit Finalize(_receiver, rf, totalEtherReceived * 85 / 100);\n', '  }\n', '\n', '  function setOwner (address _ownder) public {\n', '    require(msg.sender == owner);\n', '    owner = _ownder;\n', '  }\n', '\n', '  function setFunderSmartToken(address _fstAddress) public {\n', '    require(msg.sender == owner);\n', '    funderSmartToken = ERC20(_fstAddress);\n', '  }\n', '\n', '  function setFSTPrice(uint256 numerator, uint256 denominator) public {\n', '    require(msg.sender == owner);\n', '    require(\n', '      numerator > 0 &&\n', '      denominator > 0\n', '    );\n', '\n', '    fstPrice.numerator = numerator;\n', '    fstPrice.denominator = denominator;\n', '  }\n', '\n', '  function setEnabled (bool _isEnabled) public {\n', '    require(msg.sender == owner);\n', '    isEnabled = _isEnabled;\n', '  }\n', '\n', '}\n', '\n', 'library Math {\n', '\n', '  struct Fraction {\n', '    uint256 numerator;\n', '    uint256 denominator;\n', '  }\n', '\n', '  function isPositive(Fraction memory fraction) internal pure returns (bool) {\n', '    return fraction.numerator > 0 && fraction.denominator > 0;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    r = a * b;\n', '    require((a == 0) || (r / a == b));\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    r = a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    require((r = a - b) <= a);\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    require((r = a + b) >= a);\n', '  }\n', '\n', '  function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\n', '    return x <= y ? x : y;\n', '  }\n', '\n', '  function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\n', '    return x >= y ? x : y;\n', '  }\n', '\n', '  function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n', '    // try mul\n', '    r = value * m;\n', '    if (r / value == m) {\n', '      // if mul not overflow\n', '      r /= d;\n', '    } else {\n', '      // else div first\n', '      r = mul(value / d, m);\n', '    }\n', '  }\n', '\n', '  function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n', '    // try mul\n', '    r = value * m;\n', '    if (r / value == m) {\n', '      // mul not overflow\n', '      if (r % d == 0) {\n', '        r /= d;\n', '      } else {\n', '        r = (r / d) + 1;\n', '      }\n', '    } else {\n', '      // mul overflow then div first\n', '      r = mul(value / d, m);\n', '      if (value % d != 0) {\n', '        r += 1;\n', '      }\n', '    }\n', '  }\n', '\n', '  function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDiv(x, f.numerator, f.denominator);\n', '  }\n', '\n', '  function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDivCeil(x, f.numerator, f.denominator);\n', '  }\n', '\n', '  function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDiv(x, f.denominator, f.numerator);\n', '  }\n', '\n', '  function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDivCeil(x, f.denominator, f.numerator);\n', '  }\n', '\n', '  function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) {\n', '    return Math.Fraction({\n', '      numerator: mul(x.numerator, y.numerator),\n', '      denominator: mul(x.denominator, y.denominator)\n', '    });\n', '  }\n', '}']
