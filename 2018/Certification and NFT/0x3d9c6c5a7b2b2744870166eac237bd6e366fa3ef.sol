['pragma solidity ^0.4.24;\n', '// produced by the Solididy File Flattener (c) David Appleton 2018\n', '// contact : dave@akomba.com\n', '// released under Apache 2.0 licence\n', '// input  /home/henry/learning/git/smartContract/truffle/022-sht/contracts-bak/SibbayHealthToken.sol\n', '// flattened :  Saturday, 17-Nov-18 06:24:45 UTC\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Management is Ownable {\n', '\n', '  /**\n', '   * 暂停和取消暂停事件\n', '   * */\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  /**\n', '   * 打开锁定期自动释放事件\n', '   * 关闭锁定期自动释放事件\n', '   * 打开强制锁定期自动释放事件\n', '   * */\n', '  event OpenAutoFree(address indexed admin, address indexed who);\n', '  event CloseAutoFree(address indexed admin, address indexed who);\n', '  event OpenForceAutoFree(address indexed admin, address indexed who);\n', '\n', '  /**\n', '   * 增加和删除管理员事件\n', '   * */\n', '  event AddAdministrator(address indexed admin);\n', '  event DelAdministrator(address indexed admin);\n', '\n', '  /**\n', '   * 合约暂停标志, True 暂停，false 未暂停\n', '   * 锁定余额自动释放开关\n', '   * 强制锁定余额自动释放开关\n', '   * 合约管理员\n', '   * */\n', '  bool public paused = false;\n', '  mapping(address => bool) public autoFreeLockBalance;          // false(default) for auto frce, true for not free\n', '  mapping(address => bool) public forceAutoFreeLockBalance;     // false(default) for not force free, true for froce free\n', '  mapping(address => bool) public adminList;\n', '\n', '  /**\n', '   * 构造函数\n', '   * */\n', '  constructor() public {\n', '  }\n', '\n', '  /**\n', '   * modifier 要求合约正在运行状态\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * modifier 要求合约暂停状态\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * 要求是管理员\n', '   * */\n', '  modifier whenAdministrator(address who) {\n', '    require(adminList[who]);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * 要求不是管理员\n', '   * */\n', '  modifier whenNotAdministrator(address who) {\n', '    require(!adminList[who]);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * * 暂停合约\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * 取消暂停合约\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '\n', '  /**\n', '   * 打开锁定期自动释放开关\n', '   * */\n', '  function openAutoFree(address who) whenAdministrator(msg.sender) public {\n', '    delete autoFreeLockBalance[who];\n', '    emit OpenAutoFree(msg.sender, who);\n', '  }\n', '\n', '  /**\n', '   * 关闭锁定期自动释放开关\n', '   * */\n', '  function closeAutoFree(address who) whenAdministrator(msg.sender) public {\n', '    autoFreeLockBalance[who] = true;\n', '    emit CloseAutoFree(msg.sender, who);\n', '  }\n', '\n', '  /**\n', '   * 打开强制锁定期自动释放开关\n', '   * 该开关只能打开，不能关闭\n', '   * */\n', '  function openForceAutoFree(address who) onlyOwner public {\n', '    forceAutoFreeLockBalance[who] = true;\n', '    emit OpenForceAutoFree(msg.sender, who);\n', '  }\n', '\n', '  /**\n', '   * 添加管理员\n', '   * */\n', '  function addAdministrator(address who) onlyOwner public {\n', '    adminList[who] = true;\n', '    emit AddAdministrator(who);\n', '  }\n', '\n', '  /**\n', '   * 删除管理员\n', '   * */\n', '  function delAdministrator(address who) onlyOwner public {\n', '    delete adminList[who];\n', '    emit DelAdministrator(who);\n', '  }\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  /**\n', '   * 账户总余额\n', '   * */\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '   * 总供应量\n', '   * */\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '   * 获取总供应量\n', '   * */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  // 记录代理账户\n', '  // 第一个address是token的所有者，即被代理账户\n', '  // 第二个address是token的使用者，即代理账户\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  // 代理转账事件\n', '  // spender: 代理\n', '  // from: token所有者\n', '  // to: token接收账户\n', '  // value: token的转账数量\n', '  event TransferFrom(address indexed spender,\n', '                     address indexed from,\n', '                     address indexed to,\n', '                     uint256 value);\n', '\n', '\n', '  /**\n', '   * 设置代理\n', '   * _spender 代理账户\n', '   * _value 代理额度\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * 查询代理额度\n', '   * _owner token拥有者账户\n', '   * _spender 代理账户\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * 提高代理额度\n', '   * _spender 代理账户\n', '   * _addValue 需要提高的代理额度\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * 降低代理额度\n', '   * _spender 代理账户\n', '   * _subtractedValue 降低的代理额度\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract SibbayHealthToken is StandardToken, Management {\n', '\n', '  string public constant name = "Sibbay Health Token"; // solium-disable-line uppercase\n', '  string public constant symbol = "SHT"; // solium-disable-line uppercase\n', '  uint8 public constant decimals = 18; // solium-disable-line uppercase\n', '\n', '  /**\n', '   * 常量\n', '   * 单位量, 即1个token有多少wei(假定token的最小单位为wei)\n', '   * */\n', '  uint256 constant internal MAGNITUDE = 10 ** uint256(decimals);\n', '\n', '  uint256 public constant INITIAL_SUPPLY = 1000000000 * MAGNITUDE;\n', '\n', '  // 设置赎回价格事件\n', '  event SetSellPrice(address indexed admin, uint256 price);\n', '  // 锁定期转账事件\n', '  event TransferByDate(address indexed from, address indexed to, uint256[] values, uint256[] dates);\n', '  event TransferFromByDate(address indexed spender, address indexed from, address indexed to, uint256[] values, uint256[] dates);\n', '  // 关闭赎回事件\n', '  event CloseSell(address indexed who);\n', '  // 赎回事件\n', '  event Sell(address indexed from, address indexed to, uint256 tokenValue, uint256 etherValue);\n', '  // withdraw 事件\n', '  event Withdraw(address indexed who, uint256 etherValue);\n', '  // 添加token到fundAccount账户\n', '  event AddTokenToFund(address indexed who, address indexed from, uint256 value);\n', '  // refresh 事件\n', '  event Refresh(address indexed from, address indexed who);\n', '\n', '  /**\n', '   * 将锁定期的map做成一个list\n', '   * value 锁定的余额\n', '   * _next 下个锁定期的到期时间\n', '   * */\n', '  struct Element {\n', '    uint256 value;\n', '    uint256 next;\n', '  }\n', '\n', '  /**\n', '   * 账户\n', '   * lockedBalances 锁定余额\n', '   * lockedElement 锁定期余额\n', '   * start_date 锁定期最早到期时间\n', '   * end_date 锁定期最晚到期时间\n', '   * */\n', '  struct Account {\n', '    uint256 lockedBalances;\n', '    mapping(uint256 => Element) lockedElement;\n', '    uint256 start_date;\n', '    uint256 end_date;\n', '  }\n', '\n', '  /**\n', '   * 所有账户\n', '   * */\n', '  mapping(address => Account) public accounts;\n', '\n', '  /**\n', '   * sellPrice: token 赎回价格, 即1 token的赎回价格是多少wei(wei为以太币最小单位)\n', '   * fundAccount: 特殊资金账户，赎回token，接收购买token资金\n', '   * sellFlag: 赎回标记\n', '   * */\n', '  uint256 public sellPrice;\n', '  address public fundAccount;\n', '  bool public sellFlag;\n', '\n', '  /**\n', '   * 需求：owner 每年释放的金额不得超过年初余额的10%\n', '   * curYear:  当前年初时间\n', '   * YEAR:  一年365天的时间\n', '   * vault: owner限制额度\n', '   * VAULT_FLOOR_VALUE: vault 最低限值\n', '   * */\n', '  uint256 public curYear;\n', '  uint256 constant internal YEAR = 365 * 24 * 3600;\n', '  uint256 public vault;\n', '  uint256 constant internal VAULT_FLOOR_VALUE = 10000000 * MAGNITUDE;\n', '\n', '  /**\n', '   * 合约构造函数\n', '   * 初始化合约的总供应量\n', '   */\n', '  constructor(address _owner, address _fund) public {\n', '    // 要求_owner, _fund不为0\n', '    require(_owner != address(0));\n', '    require(_fund != address(0));\n', '\n', '    // 设置owner, fund\n', '    owner = _owner;\n', '    fundAccount = _fund;\n', '\n', '    // 初始化owner是管理员\n', '    adminList[owner] = true;\n', '\n', '    // 初始化发行量\n', '    totalSupply_ = INITIAL_SUPPLY;\n', '    balances[owner] = INITIAL_SUPPLY;\n', '    emit Transfer(0x0, owner, INITIAL_SUPPLY);\n', '\n', '    /**\n', '     * 初始化合约属性\n', '     * 赎回价格\n', '     * 赎回标记为false\n', '     * */\n', '    sellPrice = 0;\n', '    sellFlag = true;\n', '\n', '    /**\n', '     * 初始化owner限制额度\n', '     * 2018/01/01 00:00:00\n', '     * */\n', '    vault = totalSupply_.mul(10).div(100);\n', '    curYear = 1514736000;\n', '  }\n', '\n', '  /**\n', '   * fallback函数\n', '   * */\n', '  function () external payable {\n', '  }\n', '\n', '  /**\n', '   * modifier 要求开启赎回token\n', '   * */\n', '  modifier whenOpenSell()\n', '  {\n', '    require(sellFlag);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * modifier 要求关闭赎回token\n', '   * */\n', '  modifier whenCloseSell()\n', '  {\n', '    require(!sellFlag);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * 刷新owner限制余额vault\n', '   * */\n', '  function refreshVault(address _who, uint256 _value) internal\n', '  {\n', '    uint256 balance;\n', '\n', '    // 只对owner操作\n', '    if (_who != owner)\n', '      return ;\n', '    // 记录balance of owner\n', '    balance = balances[owner];\n', '    // 如果是新的一年, 则计算vault为当前余额的10%\n', '    if (now >= (curYear + YEAR))\n', '    {\n', '      if (balance <= VAULT_FLOOR_VALUE)\n', '        vault = balance;\n', '      else\n', '        vault = balance.mul(10).div(100);\n', '      curYear = curYear.add(YEAR);\n', '    }\n', '\n', '    // vault 必须大于等于 _value\n', '    require(vault >= _value);\n', '    vault = vault.sub(_value);\n', '    return ;\n', '  }\n', '\n', '  /**\n', '   * 重新计算到期的锁定期余额, 内部接口\n', '   * _who: 账户地址\n', '   * */\n', '  function refreshlockedBalances(address _who, bool _update) internal returns (uint256)\n', '  {\n', '    uint256 tmp_date = accounts[_who].start_date;\n', '    uint256 tmp_value = accounts[_who].lockedElement[tmp_date].value;\n', '    uint256 tmp_balances = 0;\n', '    uint256 tmp_var;\n', '\n', '    // 强制自动释放打开则跳过判断，直接释放锁定期余额\n', '    if (!forceAutoFreeLockBalance[_who])\n', '    {\n', '      // 强制自动释放未打开，则判断自动释放开关\n', '      if(autoFreeLockBalance[_who])\n', '      {\n', '        // 自动释放开关未打开(true), 直接返回0\n', '        return 0;\n', '      }\n', '    }\n', '\n', '    // 锁定期到期\n', '    while(tmp_date != 0 &&\n', '          tmp_date <= now)\n', '    {\n', '      // 记录到期余额\n', '      tmp_balances = tmp_balances.add(tmp_value);\n', '\n', '      // 记录 tmp_date\n', '      tmp_var = tmp_date;\n', '\n', '      // 跳到下一个锁定期\n', '      tmp_date = accounts[_who].lockedElement[tmp_date].next;\n', '      tmp_value = accounts[_who].lockedElement[tmp_date].value;\n', '\n', '      // delete 锁定期余额\n', '      if (_update)\n', '        delete accounts[_who].lockedElement[tmp_var];\n', '    }\n', '\n', '    // return expired balance\n', '    if(!_update)\n', '      return tmp_balances;\n', '\n', '    // 修改锁定期数据\n', '    accounts[_who].start_date = tmp_date;\n', '    accounts[_who].lockedBalances = accounts[_who].lockedBalances.sub(tmp_balances);\n', '    balances[_who] = balances[_who].add(tmp_balances);\n', '\n', '    // 将最早和最晚时间的标志，都置0，即最初状态\n', '    if (accounts[_who].start_date == 0)\n', '        accounts[_who].end_date = 0;\n', '\n', '    return tmp_balances;\n', '  }\n', '\n', '  /**\n', '   * 可用余额转账，内部接口\n', '   * _from token的拥有者\n', '   * _to token的接收者\n', '   * _value token的数量\n', '   * */\n', '  function transferAvailableBalances(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    // 检查可用余额\n', '    require(_value <= balances[_from]);\n', '\n', '    // 修改可用余额\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '\n', '    // 触发转账事件\n', '    if(_from == msg.sender)\n', '      emit Transfer(_from, _to, _value);\n', '    else\n', '      emit TransferFrom(msg.sender, _from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * 锁定余额转账，内部接口\n', '   * _from token的拥有者\n', '   * _to token的接收者\n', '   * _value token的数量\n', '   * */\n', '  function transferLockedBalances(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    // 检查可用余额\n', '    require(_value <= balances[_from]);\n', '\n', '    // 修改可用余额和锁定余额\n', '    balances[_from] = balances[_from].sub(_value);\n', '    accounts[_to].lockedBalances = accounts[_to].lockedBalances.add(_value);\n', '  }\n', '\n', '  /**\n', '   * 回传以太币, 内部接口\n', '   * _from token来源账户\n', '   * _to token目标账户\n', '   * _value 为token数目\n', '   * */\n', '  function transferEther(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    /**\n', '     * 要求 _to 账户接收地址为特殊账户地址\n', '     * 这里只能为return，不能为revert\n', '     * 普通转账在这里返回, 不赎回ether\n', '     * */\n', '    if (_to != fundAccount)\n', '        return ;\n', '\n', '    /**\n', '     * 没有打开赎回功能，不能向fundAccount转账\n', '     * */\n', '    require(sellFlag);\n', '\n', '    /**\n', '     * 赎回价格必须大于0\n', '     * 赎回的token必须大于0\n', '     * */\n', '    require(_value > 0);\n', '\n', '    // 赎回的以太币必须小于账户余额, evalue 单位是wei，即以太币的最小单位\n', '    uint256 evalue = _value.mul(sellPrice).div(MAGNITUDE);\n', '    require(evalue <= address(this).balance);\n', '\n', '    // 回传以太币\n', '    if (evalue > 0)\n', '    {\n', '      _from.transfer(evalue);\n', '      emit Sell(_from, _to, _value, evalue);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * 取回合约上所有的以太币\n', '   * 只有owner才能取回\n', '   * */\n', '  function withdraw() public onlyOwner {\n', '    uint256 value = address(this).balance;\n', '    owner.transfer(value);\n', '    emit Withdraw(msg.sender, value);\n', '  }\n', '\n', '  /**\n', '   * 从from账户向fundAccount添加token\n', '   * */\n', '  function addTokenToFund(address _from, uint256 _value) \n', '    whenNotPaused\n', '    public\n', '  {\n', '    if (_from != msg.sender)\n', '    {\n', '      // 检查代理额度\n', '      require(_value <= allowed[_from][msg.sender]);\n', '\n', '      // 修改代理额度\n', '      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    }\n', '\n', '    // 刷新vault余额\n', '    refreshVault(_from, _value);\n', '\n', '    // 修改可用账户余额\n', '    transferAvailableBalances(_from, fundAccount, _value);\n', '    emit AddTokenToFund(msg.sender, _from, _value);\n', '  }\n', '\n', '  /**\n', '   * 转账\n', '   * */\n', '  function transfer(\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    // 不能给地址0转账\n', '    require(_to != address(0));\n', '\n', '    /**\n', '     * 获取到期的锁定期余额\n', '     * */\n', '    refreshlockedBalances(msg.sender, true);\n', '    refreshlockedBalances(_to, true);\n', '\n', '    // 刷新vault余额\n', '    refreshVault(msg.sender, _value);\n', '\n', '    // 修改可用账户余额\n', '    transferAvailableBalances(msg.sender, _to, _value);\n', '\n', '    // 回传以太币\n', '    transferEther(msg.sender, _to, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * 代理转账\n', '   * 代理从 _from 转账 _value 到 _to\n', '   * */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    // 不能向赎回地址发送token\n', '    require(_to != fundAccount);\n', '\n', '    // 不能向0地址转账\n', '    require(_to != address(0));\n', '\n', '    /**\n', '     * 获取到期的锁定期余额\n', '     * */\n', '    refreshlockedBalances(_from, true);\n', '    refreshlockedBalances(_to, true);\n', '\n', '    // 检查代理额度\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    // 修改代理额度\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '    // 刷新vault余额\n', '    refreshVault(_from, _value);\n', '\n', '    // 修改可用账户余额\n', '    transferAvailableBalances(_from, _to, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * 设定代理和代理额度\n', '   * 设定代理为 _spender 额度为 _value\n', '   * */\n', '  function approve(\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.approve(_spender, _value);\n', '  }\n', '\n', '  /**\n', '   * 提高代理的代理额度\n', '   * 提高代理 _spender 的代理额度 _addedValue\n', '   * */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool success)\n', '  {\n', '    return super.increaseApproval(_spender, _addedValue);\n', '  }\n', '\n', '  /**\n', '   * 降低代理的代理额度\n', '   * 降低代理 _spender 的代理额度 _subtractedValue\n', '   * */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool success)\n', '  {\n', '    return super.decreaseApproval(_spender, _subtractedValue);\n', '  }\n', '\n', '  /**\n', '   * 批量转账 token\n', '   * 批量用户 _receivers\n', '   * 对应的转账数量 _values\n', '   * */\n', '  function batchTransfer(\n', '    address[] _receivers,\n', '    uint256[] _values\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    // 判断接收账号和token数量为一一对应\n', '    require(_receivers.length > 0 && _receivers.length == _values.length);\n', '\n', '    /**\n', '     * 获取到期的锁定期余额\n', '     * */\n', '    refreshlockedBalances(msg.sender, true);\n', '\n', '    // 判断可用余额足够\n', '    uint32 i = 0;\n', '    uint256 total = 0;\n', '    for (i = 0; i < _values.length; i ++)\n', '    {\n', '      total = total.add(_values[i]);\n', '    }\n', '    require(total <= balances[msg.sender]);\n', '\n', '    // 刷新vault余额\n', '    refreshVault(msg.sender, total);\n', '\n', '    // 一一 转账\n', '    for (i = 0; i < _receivers.length; i ++)\n', '    {\n', '      // 不能向赎回地址发送token\n', '      require(_receivers[i] != fundAccount);\n', '\n', '      // 不能向0地址转账\n', '      require(_receivers[i] != address(0));\n', '\n', '      refreshlockedBalances(_receivers[i], true);\n', '      // 修改可用账户余额\n', '      transferAvailableBalances(msg.sender, _receivers[i], _values[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * 代理批量转账 token\n', '   * 被代理人 _from\n', '   * 批量用户 _receivers\n', '   * 对应的转账数量 _values\n', '   * */\n', '  function batchTransferFrom(\n', '    address _from,\n', '    address[] _receivers,\n', '    uint256[] _values\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    // 判断接收账号和token数量为一一对应\n', '    require(_receivers.length > 0 && _receivers.length == _values.length);\n', '\n', '    /**\n', '     * 获取到期的锁定期余额\n', '     * */\n', '    refreshlockedBalances(_from, true);\n', '\n', '    // 判断可用余额足够\n', '    uint32 i = 0;\n', '    uint256 total = 0;\n', '    for (i = 0; i < _values.length; i ++)\n', '    {\n', '      total = total.add(_values[i]);\n', '    }\n', '    require(total <= balances[_from]);\n', '\n', '    // 判断代理额度足够\n', '    require(total <= allowed[_from][msg.sender]);\n', '\n', '    // 修改代理额度\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(total);\n', '\n', '    // 刷新vault余额\n', '    refreshVault(_from, total);\n', '\n', '    // 一一 转账\n', '    for (i = 0; i < _receivers.length; i ++)\n', '    {\n', '      // 不能向赎回地址发送token\n', '      require(_receivers[i] != fundAccount);\n', '\n', '      // 不能向0地址转账\n', '      require(_receivers[i] != address(0));\n', '\n', '      refreshlockedBalances(_receivers[i], true);\n', '      // 修改可用账户余额\n', '      transferAvailableBalances(_from, _receivers[i], _values[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * 带有锁定期的转账, 当锁定期到期之后，锁定token数量将转入可用余额\n', '   * _receiver 转账接收账户\n', '   * _values 转账数量\n', '   * _dates 锁定期，即到期时间\n', '   *        格式：UTC时间，单位秒，即从1970年1月1日开始到指定时间所经历的秒\n', '   * */\n', '  function transferByDate(\n', '    address _receiver,\n', '    uint256[] _values,\n', '    uint256[] _dates\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    // 判断接收账号和token数量为一一对应\n', '    require(_values.length > 0 &&\n', '        _values.length == _dates.length);\n', '\n', '    // 不能向赎回地址发送token\n', '    require(_receiver != fundAccount);\n', '\n', '    // 不能向0地址转账\n', '    require(_receiver != address(0));\n', '\n', '    /**\n', '     * 获取到期的锁定期余额\n', '     * */\n', '    refreshlockedBalances(msg.sender, true);\n', '    refreshlockedBalances(_receiver, true);\n', '\n', '    // 判断可用余额足够\n', '    uint32 i = 0;\n', '    uint256 total = 0;\n', '    for (i = 0; i < _values.length; i ++)\n', '    {\n', '      total = total.add(_values[i]);\n', '    }\n', '    require(total <= balances[msg.sender]);\n', '\n', '    // 刷新vault余额\n', '    refreshVault(msg.sender, total);\n', '\n', '    // 转账\n', '    for(i = 0; i < _values.length; i ++)\n', '    {\n', '      transferByDateSingle(msg.sender, _receiver, _values[i], _dates[i]);\n', '    }\n', '\n', '    emit TransferByDate(msg.sender, _receiver, _values, _dates);\n', '  }\n', '\n', '  /**\n', '   * 代理带有锁定期的转账, 当锁定期到期之后，锁定token数量将转入可用余额\n', '   * _from 被代理账户\n', '   * _receiver 转账接收账户\n', '   * _values 转账数量\n', '   * _dates 锁定期，即到期时间\n', '   *        格式：UTC时间，单位秒，即从1970年1月1日开始到指定时间所经历的秒\n', '   * */\n', '  function transferFromByDate(\n', '    address _from,\n', '    address _receiver,\n', '    uint256[] _values,\n', '    uint256[] _dates\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    // 判断接收账号和token数量为一一对应\n', '    require(_values.length > 0 &&\n', '        _values.length == _dates.length);\n', '\n', '    // 不能向赎回地址发送token\n', '    require(_receiver != fundAccount);\n', '\n', '    // 不能向0地址转账\n', '    require(_receiver != address(0));\n', '\n', '    /**\n', '     * 获取到期的锁定期余额\n', '     * */\n', '    refreshlockedBalances(_from, true);\n', '    refreshlockedBalances(_receiver, true);\n', '\n', '    // 判断可用余额足够\n', '    uint32 i = 0;\n', '    uint256 total = 0;\n', '    for (i = 0; i < _values.length; i ++)\n', '    {\n', '      total = total.add(_values[i]);\n', '    }\n', '    require(total <= balances[_from]);\n', '\n', '    // 判断代理额度足够\n', '    require(total <= allowed[_from][msg.sender]);\n', '\n', '    // 修改代理额度\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(total);\n', '\n', '    // 刷新vault余额\n', '    refreshVault(_from, total);\n', '\n', '    // 转账\n', '    for(i = 0; i < _values.length; i ++)\n', '    {\n', '      transferByDateSingle(_from, _receiver, _values[i], _dates[i]);\n', '    }\n', '\n', '    emit TransferFromByDate(msg.sender, _from, _receiver, _values, _dates);\n', '  }\n', '\n', '  /**\n', '   * _from token拥有者\n', '   * _to 转账接收账户\n', '   * _value 转账数量\n', '   * _date 锁定期，即到期时间\n', '   *       格式：UTC时间，单位秒，即从1970年1月1日开始到指定时间所经历的秒\n', '   * */\n', '  function transferByDateSingle(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value,\n', '    uint256 _date\n', '  )\n', '    internal\n', '  {\n', '    uint256 start_date = accounts[_to].start_date;\n', '    uint256 end_date = accounts[_to].end_date;\n', '    uint256 tmp_var = accounts[_to].lockedElement[_date].value;\n', '    uint256 tmp_date;\n', '\n', '    if (_value == 0)\n', '    {\n', '        // 不做任何处理\n', '        return ;\n', '    }\n', '\n', '    if (_date <= now)\n', '    {\n', '      // 到期时间比当前早，直接转入可用余额\n', '      // 修改可用账户余额\n', '      transferAvailableBalances(_from, _to, _value);\n', '\n', '      return ;\n', '    }\n', '\n', '    if (start_date == 0)\n', '    {\n', '      // 还没有收到过锁定期转账\n', '      // 最早时间和最晚时间一样\n', '      accounts[_to].start_date = _date;\n', '      accounts[_to].end_date = _date;\n', '      accounts[_to].lockedElement[_date].value = _value;\n', '    }\n', '    else if (tmp_var > 0)\n', '    {\n', '      // 收到过相同的锁定期\n', '      accounts[_to].lockedElement[_date].value = tmp_var.add(_value);\n', '    }\n', '    else if (_date < start_date)\n', '    {\n', '      // 锁定期比最早到期的还早\n', '      // 添加锁定期，并加入到锁定期列表\n', '      accounts[_to].lockedElement[_date].value = _value;\n', '      accounts[_to].lockedElement[_date].next = start_date;\n', '      accounts[_to].start_date = _date;\n', '    }\n', '    else if (_date > end_date)\n', '    {\n', '      // 锁定期比最晚到期还晚\n', '      // 添加锁定期，并加入到锁定期列表\n', '      accounts[_to].lockedElement[_date].value = _value;\n', '      accounts[_to].lockedElement[end_date].next = _date;\n', '      accounts[_to].end_date = _date;\n', '    }\n', '    else\n', '    {\n', '      /**\n', '       * 锁定期在 最早和最晚之间\n', '       * 首先找到插入的位置\n', '       * 然后在插入的位置插入数据\n', '       * tmp_var 即 tmp_next\n', '       * */\n', '      tmp_date = start_date;\n', '      tmp_var = accounts[_to].lockedElement[tmp_date].next;\n', '      while(tmp_var < _date)\n', '      {\n', '        tmp_date = tmp_var;\n', '        tmp_var = accounts[_to].lockedElement[tmp_date].next;\n', '      }\n', '\n', '      // 记录锁定期并加入列表\n', '      accounts[_to].lockedElement[_date].value = _value;\n', '      accounts[_to].lockedElement[_date].next = tmp_var;\n', '      accounts[_to].lockedElement[tmp_date].next = _date;\n', '    }\n', '\n', '    // 锁定期转账\n', '    transferLockedBalances(_from, _to, _value);\n', '\n', '    return ;\n', '  }\n', '\n', '  /**\n', '   * sell tokens\n', '   * */\n', '  function sell(uint256 _value) public whenOpenSell whenNotPaused {\n', '    transfer(fundAccount, _value);\n', '  }\n', '\n', '  /**\n', '   * 设置token赎回价格\n', '   * */\n', '  function setSellPrice(uint256 price) public whenAdministrator(msg.sender) {\n', '    require(price > 0);\n', '    sellPrice = price;\n', '\n', '    emit SetSellPrice(msg.sender, price);\n', '  }\n', '\n', '  /**\n', '   * 关闭购买赎回token\n', '   * */\n', '  function closeSell() public whenOpenSell onlyOwner {\n', '    sellFlag = false;\n', '    emit CloseSell(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * 重新计算账号的lockbalance\n', '   * */\n', '  function refresh(address _who) public whenNotPaused {\n', '    refreshlockedBalances(_who, true);\n', '    emit Refresh(msg.sender, _who);\n', '  }\n', '\n', '  /**\n', '   * 查询账户可用余额\n', '   * */\n', '  function availableBalanceOf(address _owner) public view returns (uint256) {\n', '    return (balances[_owner] + refreshlockedBalances(_owner, false));\n', '  }\n', '\n', '  /**\n', '   * 查询账户总余额\n', '   * */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner] + accounts[_owner].lockedBalances;\n', '  }\n', '\n', '  /**\n', '   * 获取锁定余额\n', '   * */\n', '  function lockedBalanceOf(address _who) public view returns (uint256) {\n', '    return (accounts[_who].lockedBalances - refreshlockedBalances(_who, false));\n', '  }\n', '\n', '  /**\n', '   * 根据日期获取锁定余额\n', '   * 返回：锁定余额，下一个锁定期\n', '   * */\n', '  function lockedBalanceOfByDate(address _who, uint256 date) public view returns (uint256, uint256) {\n', '    return (accounts[_who].lockedElement[date].value, accounts[_who].lockedElement[date].next);\n', '  }\n', '\n', '}']