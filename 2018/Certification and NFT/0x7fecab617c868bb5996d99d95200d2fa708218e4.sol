['//  the azimuth polls data store\n', '//  https://azimuth.network\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '//  Imports\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '// OpenZeppelin&#39;s SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// Azimuth&#39;s SafeMath8.sol\n', '\n', '/**\n', ' * @title SafeMath8\n', ' * @dev Math operations for uint8 with safety checks that throw on error\n', ' */\n', 'library SafeMath8 {\n', '  function mul(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    uint8 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint8 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    uint8 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// Azimuth&#39;s SafeMath16.sol\n', '\n', '/**\n', ' * @title SafeMath16\n', ' * @dev Math operations for uint16 with safety checks that throw on error\n', ' */\n', 'library SafeMath16 {\n', '  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint16 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// OpenZeppelin&#39;s Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '//  Polls\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '//  Polls: proposals & votes data contract\n', '//\n', '//    This contract is used for storing all data related to the proposals\n', '//    of the senate (galaxy owners) and their votes on those proposals.\n', '//    It keeps track of votes and uses them to calculate whether a majority\n', '//    is in favor of a proposal.\n', '//\n', '//    Every galaxy can only vote on a proposal exactly once. Votes cannot\n', '//    be changed. If a proposal fails to achieve majority within its\n', '//    duration, it can be restarted after its cooldown period has passed.\n', '//\n', '//    The requirements for a proposal to achieve majority are as follows:\n', '//    - At least 1/4 of the currently active voters (rounded down) must have\n', '//      voted in favor of the proposal,\n', '//    - More than half of the votes cast must be in favor of the proposal,\n', '//      and this can no longer change, either because\n', '//      - the poll duration has passed, or\n', '//      - not enough voters remain to take away the in-favor majority.\n', '//    As soon as these conditions are met, no further interaction with\n', '//    the proposal is possible. Achieving majority is permanent.\n', '//\n', '//    Since data stores are difficult to upgrade, all of the logic unrelated\n', '//    to the voting itself (that is, determining who is eligible to vote)\n', '//    is expected to be implemented by this contract&#39;s owner.\n', '//\n', '//    This contract will be owned by the Ecliptic contract.\n', '//\n', 'contract Polls is Ownable\n', '{\n', '  using SafeMath for uint256;\n', '  using SafeMath16 for uint16;\n', '  using SafeMath8 for uint8;\n', '\n', '  //  UpgradePollStarted: a poll on :proposal has opened\n', '  //\n', '  event UpgradePollStarted(address proposal);\n', '\n', '  //  DocumentPollStarted: a poll on :proposal has opened\n', '  //\n', '  event DocumentPollStarted(bytes32 proposal);\n', '\n', '  //  UpgradeMajority: :proposal has achieved majority\n', '  //\n', '  event UpgradeMajority(address proposal);\n', '\n', '  //  DocumentMajority: :proposal has achieved majority\n', '  //\n', '  event DocumentMajority(bytes32 proposal);\n', '\n', '  //  Poll: full poll state\n', '  //\n', '  struct Poll\n', '  {\n', '    //  start: the timestamp at which the poll was started\n', '    //\n', '    uint256 start;\n', '\n', '    //  voted: per galaxy, whether they have voted on this poll\n', '    //\n', '    bool[256] voted;\n', '\n', '    //  yesVotes: amount of votes in favor of the proposal\n', '    //\n', '    uint16 yesVotes;\n', '\n', '    //  noVotes: amount of votes against the proposal\n', '    //\n', '    uint16 noVotes;\n', '\n', '    //  duration: amount of time during which the poll can be voted on\n', '    //\n', '    uint256 duration;\n', '\n', '    //  cooldown: amount of time before the (non-majority) poll can be reopened\n', '    //\n', '    uint256 cooldown;\n', '  }\n', '\n', '  //  pollDuration: duration set for new polls. see also Poll.duration above\n', '  //\n', '  uint256 public pollDuration;\n', '\n', '  //  pollCooldown: cooldown set for new polls. see also Poll.cooldown above\n', '  //\n', '  uint256 public pollCooldown;\n', '\n', '  //  totalVoters: amount of active galaxies\n', '  //\n', '  uint16 public totalVoters;\n', '\n', '  //  upgradeProposals: list of all upgrades ever proposed\n', '  //\n', '  //    this allows clients to discover the existence of polls.\n', '  //    from there, they can do liveness checks on the polls themselves.\n', '  //\n', '  address[] public upgradeProposals;\n', '\n', '  //  upgradePolls: per address, poll held to determine if that address\n', '  //                will become the new ecliptic\n', '  //\n', '  mapping(address => Poll) public upgradePolls;\n', '\n', '  //  upgradeHasAchievedMajority: per address, whether that address\n', '  //                              has ever achieved majority\n', '  //\n', '  //    If we did not store this, we would have to look at old poll data\n', '  //    to see whether or not a proposal has ever achieved majority.\n', '  //    Since the outcome of a poll is calculated based on :totalVoters,\n', '  //    which may not be consistent across time, we need to store outcomes\n', '  //    explicitly instead of re-calculating them. This allows us to always\n', '  //    tell with certainty whether or not a majority was achieved,\n', '  //    regardless of the current :totalVoters.\n', '  //\n', '  mapping(address => bool) public upgradeHasAchievedMajority;\n', '\n', '  //  documentProposals: list of all documents ever proposed\n', '  //\n', '  //    this allows clients to discover the existence of polls.\n', '  //    from there, they can do liveness checks on the polls themselves.\n', '  //\n', '  bytes32[] public documentProposals;\n', '\n', '  //  documentPolls: per hash, poll held to determine if the corresponding\n', '  //                 document is accepted by the galactic senate\n', '  //\n', '  mapping(bytes32 => Poll) public documentPolls;\n', '\n', '  //  documentHasAchievedMajority: per hash, whether that hash has ever\n', '  //                               achieved majority\n', '  //\n', '  //    the note for upgradeHasAchievedMajority above applies here as well\n', '  //\n', '  mapping(bytes32 => bool) public documentHasAchievedMajority;\n', '\n', '  //  documentMajorities: all hashes that have achieved majority\n', '  //\n', '  bytes32[] public documentMajorities;\n', '\n', '  //  constructor(): initial contract configuration\n', '  //\n', '  constructor(uint256 _pollDuration, uint256 _pollCooldown)\n', '    public\n', '  {\n', '    reconfigure(_pollDuration, _pollCooldown);\n', '  }\n', '\n', '  //  reconfigure(): change poll duration and cooldown\n', '  //\n', '  function reconfigure(uint256 _pollDuration, uint256 _pollCooldown)\n', '    public\n', '    onlyOwner\n', '  {\n', '    require( (5 days <= _pollDuration) && (_pollDuration <= 90 days) &&\n', '             (5 days <= _pollCooldown) && (_pollCooldown <= 90 days) );\n', '    pollDuration = _pollDuration;\n', '    pollCooldown = _pollCooldown;\n', '  }\n', '\n', '  //  incrementTotalVoters(): increase the amount of registered voters\n', '  //\n', '  function incrementTotalVoters()\n', '    external\n', '    onlyOwner\n', '  {\n', '    require(totalVoters < 256);\n', '    totalVoters = totalVoters.add(1);\n', '  }\n', '\n', '  //  getAllUpgradeProposals(): return array of all upgrade proposals ever made\n', '  //\n', '  //    Note: only useful for clients, as Solidity does not currently\n', '  //    support returning dynamic arrays.\n', '  //\n', '  function getUpgradeProposals()\n', '    external\n', '    view\n', '    returns (address[] proposals)\n', '  {\n', '    return upgradeProposals;\n', '  }\n', '\n', '  //  getUpgradeProposalCount(): get the number of unique proposed upgrades\n', '  //\n', '  function getUpgradeProposalCount()\n', '    external\n', '    view\n', '    returns (uint256 count)\n', '  {\n', '    return upgradeProposals.length;\n', '  }\n', '\n', '  //  getAllDocumentProposals(): return array of all upgrade proposals ever made\n', '  //\n', '  //    Note: only useful for clients, as Solidity does not currently\n', '  //    support returning dynamic arrays.\n', '  //\n', '  function getDocumentProposals()\n', '    external\n', '    view\n', '    returns (bytes32[] proposals)\n', '  {\n', '    return documentProposals;\n', '  }\n', '\n', '  //  getDocumentProposalCount(): get the number of unique proposed upgrades\n', '  //\n', '  function getDocumentProposalCount()\n', '    external\n', '    view\n', '    returns (uint256 count)\n', '  {\n', '    return documentProposals.length;\n', '  }\n', '\n', '  //  getDocumentMajorities(): return array of all document majorities\n', '  //\n', '  //    Note: only useful for clients, as Solidity does not currently\n', '  //    support returning dynamic arrays.\n', '  //\n', '  function getDocumentMajorities()\n', '    external\n', '    view\n', '    returns (bytes32[] majorities)\n', '  {\n', '    return documentMajorities;\n', '  }\n', '\n', '  //  hasVotedOnUpgradePoll(): returns true if _galaxy has voted\n', '  //                           on the _proposal\n', '  //\n', '  function hasVotedOnUpgradePoll(uint8 _galaxy, address _proposal)\n', '    external\n', '    view\n', '    returns (bool result)\n', '  {\n', '    return upgradePolls[_proposal].voted[_galaxy];\n', '  }\n', '\n', '  //  hasVotedOnDocumentPoll(): returns true if _galaxy has voted\n', '  //                            on the _proposal\n', '  //\n', '  function hasVotedOnDocumentPoll(uint8 _galaxy, bytes32 _proposal)\n', '    external\n', '    view\n', '    returns (bool result)\n', '  {\n', '    return documentPolls[_proposal].voted[_galaxy];\n', '  }\n', '\n', '  //  startUpgradePoll(): open a poll on making _proposal the new ecliptic\n', '  //\n', '  function startUpgradePoll(address _proposal)\n', '    external\n', '    onlyOwner\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!upgradeHasAchievedMajority[_proposal]);\n', '\n', '    Poll storage poll = upgradePolls[_proposal];\n', '\n', '    //  if the proposal is being made for the first time, register it.\n', '    //\n', '    if (0 == poll.start)\n', '    {\n', '      upgradeProposals.push(_proposal);\n', '    }\n', '\n', '    startPoll(poll);\n', '    emit UpgradePollStarted(_proposal);\n', '  }\n', '\n', '  //  startDocumentPoll(): open a poll on accepting the document\n', '  //                       whose hash is _proposal\n', '  //\n', '  function startDocumentPoll(bytes32 _proposal)\n', '    external\n', '    onlyOwner\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!documentHasAchievedMajority[_proposal]);\n', '\n', '    Poll storage poll = documentPolls[_proposal];\n', '\n', '    //  if the proposal is being made for the first time, register it.\n', '    //\n', '    if (0 == poll.start)\n', '    {\n', '      documentProposals.push(_proposal);\n', '    }\n', '\n', '    startPoll(poll);\n', '    emit DocumentPollStarted(_proposal);\n', '  }\n', '\n', '  //  startPoll(): open a new poll, or re-open an old one\n', '  //\n', '  function startPoll(Poll storage _poll)\n', '    internal\n', '  {\n', '    //  check that the poll has cooled down enough to be started again\n', '    //\n', '    //    for completely new polls, the values used will be zero\n', '    //\n', '    require( block.timestamp > ( _poll.start.add(\n', '                                 _poll.duration.add(\n', '                                 _poll.cooldown )) ) );\n', '\n', '    //  set started poll state\n', '    //\n', '    _poll.start = block.timestamp;\n', '    delete _poll.voted;\n', '    _poll.yesVotes = 0;\n', '    _poll.noVotes = 0;\n', '    _poll.duration = pollDuration;\n', '    _poll.cooldown = pollCooldown;\n', '  }\n', '\n', '  //  castUpgradeVote(): as galaxy _as, cast a vote on the _proposal\n', '  //\n', '  //    _vote is true when in favor of the proposal, false otherwise\n', '  //\n', '  function castUpgradeVote(uint8 _as, address _proposal, bool _vote)\n', '    external\n', '    onlyOwner\n', '    returns (bool majority)\n', '  {\n', '    Poll storage poll = upgradePolls[_proposal];\n', '    processVote(poll, _as, _vote);\n', '    return updateUpgradePoll(_proposal);\n', '  }\n', '\n', '  //  castDocumentVote(): as galaxy _as, cast a vote on the _proposal\n', '  //\n', '  //    _vote is true when in favor of the proposal, false otherwise\n', '  //\n', '  function castDocumentVote(uint8 _as, bytes32 _proposal, bool _vote)\n', '    external\n', '    onlyOwner\n', '    returns (bool majority)\n', '  {\n', '    Poll storage poll = documentPolls[_proposal];\n', '    processVote(poll, _as, _vote);\n', '    return updateDocumentPoll(_proposal);\n', '  }\n', '\n', '  //  processVote(): record a vote from _as on the _poll\n', '  //\n', '  function processVote(Poll storage _poll, uint8 _as, bool _vote)\n', '    internal\n', '  {\n', '    //  assist symbolic execution tools\n', '    //\n', '    assert(block.timestamp >= _poll.start);\n', '\n', '    require( //  may only vote once\n', '             //\n', '             !_poll.voted[_as] &&\n', '             //\n', '             //  may only vote when the poll is open\n', '             //\n', '             (block.timestamp < _poll.start.add(_poll.duration)) );\n', '\n', '    //  update poll state to account for the new vote\n', '    //\n', '    _poll.voted[_as] = true;\n', '    if (_vote)\n', '    {\n', '      _poll.yesVotes = _poll.yesVotes.add(1);\n', '    }\n', '    else\n', '    {\n', '      _poll.noVotes = _poll.noVotes.add(1);\n', '    }\n', '  }\n', '\n', '  //  updateUpgradePoll(): check whether the _proposal has achieved\n', '  //                            majority, updating state, sending an event,\n', '  //                            and returning true if it has\n', '  //\n', '  function updateUpgradePoll(address _proposal)\n', '    public\n', '    onlyOwner\n', '    returns (bool majority)\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!upgradeHasAchievedMajority[_proposal]);\n', '\n', '    //  check for majority in the poll\n', '    //\n', '    Poll storage poll = upgradePolls[_proposal];\n', '    majority = checkPollMajority(poll);\n', '\n', '    //  if majority was achieved, update the state and send an event\n', '    //\n', '    if (majority)\n', '    {\n', '      upgradeHasAchievedMajority[_proposal] = true;\n', '      emit UpgradeMajority(_proposal);\n', '    }\n', '    return majority;\n', '  }\n', '\n', '  //  updateDocumentPoll(): check whether the _proposal has achieved majority,\n', '  //                        updating the state and sending an event if it has\n', '  //\n', '  //    this can be called by anyone, because the ecliptic does not\n', '  //    need to be aware of the result\n', '  //\n', '  function updateDocumentPoll(bytes32 _proposal)\n', '    public\n', '    returns (bool majority)\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!documentHasAchievedMajority[_proposal]);\n', '\n', '    //  check for majority in the poll\n', '    //\n', '    Poll storage poll = documentPolls[_proposal];\n', '    majority = checkPollMajority(poll);\n', '\n', '    //  if majority was achieved, update state and send an event\n', '    //\n', '    if (majority)\n', '    {\n', '      documentHasAchievedMajority[_proposal] = true;\n', '      documentMajorities.push(_proposal);\n', '      emit DocumentMajority(_proposal);\n', '    }\n', '    return majority;\n', '  }\n', '\n', '  //  checkPollMajority(): returns true if the majority is in favor of\n', '  //                       the subject of the poll\n', '  //\n', '  function checkPollMajority(Poll _poll)\n', '    internal\n', '    view\n', '    returns (bool majority)\n', '  {\n', '    return ( //  poll must have at least the minimum required yes-votes\n', '             //\n', '             (_poll.yesVotes >= (totalVoters / 4)) &&\n', '             //\n', '             //  and have a majority...\n', '             //\n', '             (_poll.yesVotes > _poll.noVotes) &&\n', '             //\n', '             //  ...that is indisputable\n', '             //\n', '             ( //  either because the poll has ended\n', '               //\n', '               (block.timestamp > _poll.start.add(_poll.duration)) ||\n', '               //\n', '               //  or there are more yes votes than there can be no votes\n', '               //\n', '               ( _poll.yesVotes > totalVoters.sub(_poll.yesVotes) ) ) );\n', '  }\n', '}']
['//  the azimuth polls data store\n', '//  https://azimuth.network\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '//  Imports\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', "// OpenZeppelin's SafeMath.sol\n", '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', "// Azimuth's SafeMath8.sol\n", '\n', '/**\n', ' * @title SafeMath8\n', ' * @dev Math operations for uint8 with safety checks that throw on error\n', ' */\n', 'library SafeMath8 {\n', '  function mul(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    uint8 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint8 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    uint8 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', "// Azimuth's SafeMath16.sol\n", '\n', '/**\n', ' * @title SafeMath16\n', ' * @dev Math operations for uint16 with safety checks that throw on error\n', ' */\n', 'library SafeMath16 {\n', '  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint16 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', "// OpenZeppelin's Ownable.sol\n", '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '//  Polls\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '//  Polls: proposals & votes data contract\n', '//\n', '//    This contract is used for storing all data related to the proposals\n', '//    of the senate (galaxy owners) and their votes on those proposals.\n', '//    It keeps track of votes and uses them to calculate whether a majority\n', '//    is in favor of a proposal.\n', '//\n', '//    Every galaxy can only vote on a proposal exactly once. Votes cannot\n', '//    be changed. If a proposal fails to achieve majority within its\n', '//    duration, it can be restarted after its cooldown period has passed.\n', '//\n', '//    The requirements for a proposal to achieve majority are as follows:\n', '//    - At least 1/4 of the currently active voters (rounded down) must have\n', '//      voted in favor of the proposal,\n', '//    - More than half of the votes cast must be in favor of the proposal,\n', '//      and this can no longer change, either because\n', '//      - the poll duration has passed, or\n', '//      - not enough voters remain to take away the in-favor majority.\n', '//    As soon as these conditions are met, no further interaction with\n', '//    the proposal is possible. Achieving majority is permanent.\n', '//\n', '//    Since data stores are difficult to upgrade, all of the logic unrelated\n', '//    to the voting itself (that is, determining who is eligible to vote)\n', "//    is expected to be implemented by this contract's owner.\n", '//\n', '//    This contract will be owned by the Ecliptic contract.\n', '//\n', 'contract Polls is Ownable\n', '{\n', '  using SafeMath for uint256;\n', '  using SafeMath16 for uint16;\n', '  using SafeMath8 for uint8;\n', '\n', '  //  UpgradePollStarted: a poll on :proposal has opened\n', '  //\n', '  event UpgradePollStarted(address proposal);\n', '\n', '  //  DocumentPollStarted: a poll on :proposal has opened\n', '  //\n', '  event DocumentPollStarted(bytes32 proposal);\n', '\n', '  //  UpgradeMajority: :proposal has achieved majority\n', '  //\n', '  event UpgradeMajority(address proposal);\n', '\n', '  //  DocumentMajority: :proposal has achieved majority\n', '  //\n', '  event DocumentMajority(bytes32 proposal);\n', '\n', '  //  Poll: full poll state\n', '  //\n', '  struct Poll\n', '  {\n', '    //  start: the timestamp at which the poll was started\n', '    //\n', '    uint256 start;\n', '\n', '    //  voted: per galaxy, whether they have voted on this poll\n', '    //\n', '    bool[256] voted;\n', '\n', '    //  yesVotes: amount of votes in favor of the proposal\n', '    //\n', '    uint16 yesVotes;\n', '\n', '    //  noVotes: amount of votes against the proposal\n', '    //\n', '    uint16 noVotes;\n', '\n', '    //  duration: amount of time during which the poll can be voted on\n', '    //\n', '    uint256 duration;\n', '\n', '    //  cooldown: amount of time before the (non-majority) poll can be reopened\n', '    //\n', '    uint256 cooldown;\n', '  }\n', '\n', '  //  pollDuration: duration set for new polls. see also Poll.duration above\n', '  //\n', '  uint256 public pollDuration;\n', '\n', '  //  pollCooldown: cooldown set for new polls. see also Poll.cooldown above\n', '  //\n', '  uint256 public pollCooldown;\n', '\n', '  //  totalVoters: amount of active galaxies\n', '  //\n', '  uint16 public totalVoters;\n', '\n', '  //  upgradeProposals: list of all upgrades ever proposed\n', '  //\n', '  //    this allows clients to discover the existence of polls.\n', '  //    from there, they can do liveness checks on the polls themselves.\n', '  //\n', '  address[] public upgradeProposals;\n', '\n', '  //  upgradePolls: per address, poll held to determine if that address\n', '  //                will become the new ecliptic\n', '  //\n', '  mapping(address => Poll) public upgradePolls;\n', '\n', '  //  upgradeHasAchievedMajority: per address, whether that address\n', '  //                              has ever achieved majority\n', '  //\n', '  //    If we did not store this, we would have to look at old poll data\n', '  //    to see whether or not a proposal has ever achieved majority.\n', '  //    Since the outcome of a poll is calculated based on :totalVoters,\n', '  //    which may not be consistent across time, we need to store outcomes\n', '  //    explicitly instead of re-calculating them. This allows us to always\n', '  //    tell with certainty whether or not a majority was achieved,\n', '  //    regardless of the current :totalVoters.\n', '  //\n', '  mapping(address => bool) public upgradeHasAchievedMajority;\n', '\n', '  //  documentProposals: list of all documents ever proposed\n', '  //\n', '  //    this allows clients to discover the existence of polls.\n', '  //    from there, they can do liveness checks on the polls themselves.\n', '  //\n', '  bytes32[] public documentProposals;\n', '\n', '  //  documentPolls: per hash, poll held to determine if the corresponding\n', '  //                 document is accepted by the galactic senate\n', '  //\n', '  mapping(bytes32 => Poll) public documentPolls;\n', '\n', '  //  documentHasAchievedMajority: per hash, whether that hash has ever\n', '  //                               achieved majority\n', '  //\n', '  //    the note for upgradeHasAchievedMajority above applies here as well\n', '  //\n', '  mapping(bytes32 => bool) public documentHasAchievedMajority;\n', '\n', '  //  documentMajorities: all hashes that have achieved majority\n', '  //\n', '  bytes32[] public documentMajorities;\n', '\n', '  //  constructor(): initial contract configuration\n', '  //\n', '  constructor(uint256 _pollDuration, uint256 _pollCooldown)\n', '    public\n', '  {\n', '    reconfigure(_pollDuration, _pollCooldown);\n', '  }\n', '\n', '  //  reconfigure(): change poll duration and cooldown\n', '  //\n', '  function reconfigure(uint256 _pollDuration, uint256 _pollCooldown)\n', '    public\n', '    onlyOwner\n', '  {\n', '    require( (5 days <= _pollDuration) && (_pollDuration <= 90 days) &&\n', '             (5 days <= _pollCooldown) && (_pollCooldown <= 90 days) );\n', '    pollDuration = _pollDuration;\n', '    pollCooldown = _pollCooldown;\n', '  }\n', '\n', '  //  incrementTotalVoters(): increase the amount of registered voters\n', '  //\n', '  function incrementTotalVoters()\n', '    external\n', '    onlyOwner\n', '  {\n', '    require(totalVoters < 256);\n', '    totalVoters = totalVoters.add(1);\n', '  }\n', '\n', '  //  getAllUpgradeProposals(): return array of all upgrade proposals ever made\n', '  //\n', '  //    Note: only useful for clients, as Solidity does not currently\n', '  //    support returning dynamic arrays.\n', '  //\n', '  function getUpgradeProposals()\n', '    external\n', '    view\n', '    returns (address[] proposals)\n', '  {\n', '    return upgradeProposals;\n', '  }\n', '\n', '  //  getUpgradeProposalCount(): get the number of unique proposed upgrades\n', '  //\n', '  function getUpgradeProposalCount()\n', '    external\n', '    view\n', '    returns (uint256 count)\n', '  {\n', '    return upgradeProposals.length;\n', '  }\n', '\n', '  //  getAllDocumentProposals(): return array of all upgrade proposals ever made\n', '  //\n', '  //    Note: only useful for clients, as Solidity does not currently\n', '  //    support returning dynamic arrays.\n', '  //\n', '  function getDocumentProposals()\n', '    external\n', '    view\n', '    returns (bytes32[] proposals)\n', '  {\n', '    return documentProposals;\n', '  }\n', '\n', '  //  getDocumentProposalCount(): get the number of unique proposed upgrades\n', '  //\n', '  function getDocumentProposalCount()\n', '    external\n', '    view\n', '    returns (uint256 count)\n', '  {\n', '    return documentProposals.length;\n', '  }\n', '\n', '  //  getDocumentMajorities(): return array of all document majorities\n', '  //\n', '  //    Note: only useful for clients, as Solidity does not currently\n', '  //    support returning dynamic arrays.\n', '  //\n', '  function getDocumentMajorities()\n', '    external\n', '    view\n', '    returns (bytes32[] majorities)\n', '  {\n', '    return documentMajorities;\n', '  }\n', '\n', '  //  hasVotedOnUpgradePoll(): returns true if _galaxy has voted\n', '  //                           on the _proposal\n', '  //\n', '  function hasVotedOnUpgradePoll(uint8 _galaxy, address _proposal)\n', '    external\n', '    view\n', '    returns (bool result)\n', '  {\n', '    return upgradePolls[_proposal].voted[_galaxy];\n', '  }\n', '\n', '  //  hasVotedOnDocumentPoll(): returns true if _galaxy has voted\n', '  //                            on the _proposal\n', '  //\n', '  function hasVotedOnDocumentPoll(uint8 _galaxy, bytes32 _proposal)\n', '    external\n', '    view\n', '    returns (bool result)\n', '  {\n', '    return documentPolls[_proposal].voted[_galaxy];\n', '  }\n', '\n', '  //  startUpgradePoll(): open a poll on making _proposal the new ecliptic\n', '  //\n', '  function startUpgradePoll(address _proposal)\n', '    external\n', '    onlyOwner\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!upgradeHasAchievedMajority[_proposal]);\n', '\n', '    Poll storage poll = upgradePolls[_proposal];\n', '\n', '    //  if the proposal is being made for the first time, register it.\n', '    //\n', '    if (0 == poll.start)\n', '    {\n', '      upgradeProposals.push(_proposal);\n', '    }\n', '\n', '    startPoll(poll);\n', '    emit UpgradePollStarted(_proposal);\n', '  }\n', '\n', '  //  startDocumentPoll(): open a poll on accepting the document\n', '  //                       whose hash is _proposal\n', '  //\n', '  function startDocumentPoll(bytes32 _proposal)\n', '    external\n', '    onlyOwner\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!documentHasAchievedMajority[_proposal]);\n', '\n', '    Poll storage poll = documentPolls[_proposal];\n', '\n', '    //  if the proposal is being made for the first time, register it.\n', '    //\n', '    if (0 == poll.start)\n', '    {\n', '      documentProposals.push(_proposal);\n', '    }\n', '\n', '    startPoll(poll);\n', '    emit DocumentPollStarted(_proposal);\n', '  }\n', '\n', '  //  startPoll(): open a new poll, or re-open an old one\n', '  //\n', '  function startPoll(Poll storage _poll)\n', '    internal\n', '  {\n', '    //  check that the poll has cooled down enough to be started again\n', '    //\n', '    //    for completely new polls, the values used will be zero\n', '    //\n', '    require( block.timestamp > ( _poll.start.add(\n', '                                 _poll.duration.add(\n', '                                 _poll.cooldown )) ) );\n', '\n', '    //  set started poll state\n', '    //\n', '    _poll.start = block.timestamp;\n', '    delete _poll.voted;\n', '    _poll.yesVotes = 0;\n', '    _poll.noVotes = 0;\n', '    _poll.duration = pollDuration;\n', '    _poll.cooldown = pollCooldown;\n', '  }\n', '\n', '  //  castUpgradeVote(): as galaxy _as, cast a vote on the _proposal\n', '  //\n', '  //    _vote is true when in favor of the proposal, false otherwise\n', '  //\n', '  function castUpgradeVote(uint8 _as, address _proposal, bool _vote)\n', '    external\n', '    onlyOwner\n', '    returns (bool majority)\n', '  {\n', '    Poll storage poll = upgradePolls[_proposal];\n', '    processVote(poll, _as, _vote);\n', '    return updateUpgradePoll(_proposal);\n', '  }\n', '\n', '  //  castDocumentVote(): as galaxy _as, cast a vote on the _proposal\n', '  //\n', '  //    _vote is true when in favor of the proposal, false otherwise\n', '  //\n', '  function castDocumentVote(uint8 _as, bytes32 _proposal, bool _vote)\n', '    external\n', '    onlyOwner\n', '    returns (bool majority)\n', '  {\n', '    Poll storage poll = documentPolls[_proposal];\n', '    processVote(poll, _as, _vote);\n', '    return updateDocumentPoll(_proposal);\n', '  }\n', '\n', '  //  processVote(): record a vote from _as on the _poll\n', '  //\n', '  function processVote(Poll storage _poll, uint8 _as, bool _vote)\n', '    internal\n', '  {\n', '    //  assist symbolic execution tools\n', '    //\n', '    assert(block.timestamp >= _poll.start);\n', '\n', '    require( //  may only vote once\n', '             //\n', '             !_poll.voted[_as] &&\n', '             //\n', '             //  may only vote when the poll is open\n', '             //\n', '             (block.timestamp < _poll.start.add(_poll.duration)) );\n', '\n', '    //  update poll state to account for the new vote\n', '    //\n', '    _poll.voted[_as] = true;\n', '    if (_vote)\n', '    {\n', '      _poll.yesVotes = _poll.yesVotes.add(1);\n', '    }\n', '    else\n', '    {\n', '      _poll.noVotes = _poll.noVotes.add(1);\n', '    }\n', '  }\n', '\n', '  //  updateUpgradePoll(): check whether the _proposal has achieved\n', '  //                            majority, updating state, sending an event,\n', '  //                            and returning true if it has\n', '  //\n', '  function updateUpgradePoll(address _proposal)\n', '    public\n', '    onlyOwner\n', '    returns (bool majority)\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!upgradeHasAchievedMajority[_proposal]);\n', '\n', '    //  check for majority in the poll\n', '    //\n', '    Poll storage poll = upgradePolls[_proposal];\n', '    majority = checkPollMajority(poll);\n', '\n', '    //  if majority was achieved, update the state and send an event\n', '    //\n', '    if (majority)\n', '    {\n', '      upgradeHasAchievedMajority[_proposal] = true;\n', '      emit UpgradeMajority(_proposal);\n', '    }\n', '    return majority;\n', '  }\n', '\n', '  //  updateDocumentPoll(): check whether the _proposal has achieved majority,\n', '  //                        updating the state and sending an event if it has\n', '  //\n', '  //    this can be called by anyone, because the ecliptic does not\n', '  //    need to be aware of the result\n', '  //\n', '  function updateDocumentPoll(bytes32 _proposal)\n', '    public\n', '    returns (bool majority)\n', '  {\n', '    //  _proposal must not have achieved majority before\n', '    //\n', '    require(!documentHasAchievedMajority[_proposal]);\n', '\n', '    //  check for majority in the poll\n', '    //\n', '    Poll storage poll = documentPolls[_proposal];\n', '    majority = checkPollMajority(poll);\n', '\n', '    //  if majority was achieved, update state and send an event\n', '    //\n', '    if (majority)\n', '    {\n', '      documentHasAchievedMajority[_proposal] = true;\n', '      documentMajorities.push(_proposal);\n', '      emit DocumentMajority(_proposal);\n', '    }\n', '    return majority;\n', '  }\n', '\n', '  //  checkPollMajority(): returns true if the majority is in favor of\n', '  //                       the subject of the poll\n', '  //\n', '  function checkPollMajority(Poll _poll)\n', '    internal\n', '    view\n', '    returns (bool majority)\n', '  {\n', '    return ( //  poll must have at least the minimum required yes-votes\n', '             //\n', '             (_poll.yesVotes >= (totalVoters / 4)) &&\n', '             //\n', '             //  and have a majority...\n', '             //\n', '             (_poll.yesVotes > _poll.noVotes) &&\n', '             //\n', '             //  ...that is indisputable\n', '             //\n', '             ( //  either because the poll has ended\n', '               //\n', '               (block.timestamp > _poll.start.add(_poll.duration)) ||\n', '               //\n', '               //  or there are more yes votes than there can be no votes\n', '               //\n', '               ( _poll.yesVotes > totalVoters.sub(_poll.yesVotes) ) ) );\n', '  }\n', '}']
