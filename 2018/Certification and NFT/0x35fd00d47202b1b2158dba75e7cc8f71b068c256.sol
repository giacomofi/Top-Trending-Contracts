['pragma solidity ^ 0.4.17;\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint a, uint b) internal pure returns(uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure  returns(uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal  pure returns(uint) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '\n', '    function balanceOf(address who) public view returns(uint);\n', '\n', '    function allowance(address owner, address spender) public view returns(uint);\n', '\n', '    function transfer(address to, uint value) public returns(bool ok);\n', '\n', '    function transferFrom(address from, address to, uint value) public returns(bool ok);\n', '\n', '    function approve(address spender, uint value) public returns(bool ok);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '    \n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '    function pause() public onlyOwner whenNotPaused {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '    function unpause() public onlyOwner whenPaused {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', '\n', '// Whitelist smart contract\n', '// This smart contract keeps list of addresses to whitelist\n', 'contract WhiteList is Ownable {\n', '    \n', '    mapping(address => bool) public whiteList;\n', '    uint public totalWhiteListed; //white listed users number\n', '\n', '    event LogWhiteListed(address indexed user, uint whiteListedNum);\n', '    event LogWhiteListedMultiple(uint whiteListedNum);\n', '    event LogRemoveWhiteListed(address indexed user);\n', '\n', '    // @notice it will return status of white listing\n', '    // @return true if user is white listed and false if is not\n', '    function isWhiteListed(address _user) external view returns (bool) {\n', '\n', '        return whiteList[_user]; \n', '    }\n', '\n', '    // @notice it will remove whitelisted user\n', '    // @param _contributor {address} of user to unwhitelist\n', '    function removeFromWhiteList(address _user) external onlyOwner() returns (bool) {\n', '       \n', '        require(whiteList[_user] == true);\n', '        whiteList[_user] = false;\n', '        totalWhiteListed--;\n', '        LogRemoveWhiteListed(_user);\n', '        return true;\n', '    }\n', '\n', '    // @notice it will white list one member\n', '    // @param _user {address} of user to whitelist\n', '    // @return true if successful\n', '    function addToWhiteList(address _user) external onlyOwner()  returns (bool) {\n', '\n', '        if (whiteList[_user] != true) {\n', '            whiteList[_user] = true;\n', '            totalWhiteListed++;\n', '            LogWhiteListed(_user, totalWhiteListed);            \n', '        }\n', '        return true;\n', '    }\n', '\n', '    // @notice it will white list multiple members\n', '    // @param _user {address[]} of users to whitelist\n', '    // @return true if successful\n', '    function addToWhiteListMultiple(address[] _users) external onlyOwner()  returns (bool) {\n', '\n', '        for (uint i = 0; i < _users.length; ++i) {\n', '\n', '            if (whiteList[_users[i]] != true) {\n', '                whiteList[_users[i]] = true;\n', '                totalWhiteListed++;                          \n', '            }           \n', '        }\n', '        LogWhiteListedMultiple(totalWhiteListed); \n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '// @note this contract can be inherited by Crowdsale and TeamAllocation contracts and\n', '// control release of tokens through even time release based on the inputted duration time interval\n', 'contract TokenVesting is Ownable {\n', '    using SafeMath for uint;\n', '\n', '    struct TokenHolder {\n', '        uint weiReceived; // amount of ETH contributed\n', '        uint tokensToSend; // amount of tokens  sent  \n', '        bool refunded; // true if user has been refunded       \n', '        uint releasedAmount; // amount released through vesting schedule\n', '        bool revoked; // true if right to continue vesting is revoked\n', '    }\n', '\n', '    event Released(uint256 amount, uint256 tokenDecimals);\n', '    event ContractUpdated(bool done);\n', '\n', '    uint256 public cliff;  // time in  when vesting should begin\n', '    uint256 public startCountDown;  // time when countdown starts\n', '    uint256 public duration; // duration of period in which vesting takes place   \n', '    Token public token;  // token contract containing tokens\n', '    mapping(address => TokenHolder) public tokenHolders; //tokenHolder list\n', '    WhiteList public whiteList; // whitelist contract\n', '    uint256 public presaleBonus;\n', '    \n', '    // @note constructor \n', '    /**\n', '    function TokenVesting(uint256 _start, uint256 _cliff, uint256 _duration) public {   \n', '         require(_cliff <= _duration);   \n', '        duration = _duration;\n', '        cliff = _start.add(_cliff);\n', '        startCountDown = _start;         \n', '        ContractUpdated(true);                    \n', '    }\n', '    */\n', '    // @notice Specify address of token contract\n', '    // @param _tokenAddress {address} address of token contract\n', '    // @return res {bool}\n', '    function initilizeVestingAndTokenAndWhiteList(Token _tokenAddress, \n', '                                        uint256 _start, \n', '                                        uint256 _cliff, \n', '                                        uint256 _duration,\n', '                                        uint256 _presaleBonus, \n', '                                        WhiteList _whiteList) external onlyOwner() returns(bool res) {\n', '        require(_cliff <= _duration);   \n', '        require(_tokenAddress != address(0));\n', '        duration = _duration;\n', '        cliff = _start.add(_cliff);\n', '        startCountDown = _start;  \n', '        token = _tokenAddress; \n', '        whiteList = _whiteList;\n', '        presaleBonus = _presaleBonus;\n', '        ContractUpdated(true);\n', '        return true;    \n', '    }\n', '\n', '    // @notice Specify address of token contract\n', '    // @param _tokenAddress {address} address of token contract\n', '    // @return res {bool}\n', '    function initilizeVestingAndToken(Token _tokenAddress, \n', '                                        uint256 _start, \n', '                                        uint256 _cliff, \n', '                                        uint256 _duration,\n', '                                        uint256 _presaleBonus\n', '                                        ) external onlyOwner() returns(bool res) {\n', '        require(_cliff <= _duration);   \n', '        require(_tokenAddress != address(0));\n', '        duration = _duration;\n', '        cliff = _start.add(_cliff);\n', '        startCountDown = _start;  \n', '        token = _tokenAddress;        \n', '        presaleBonus = _presaleBonus;\n', '        ContractUpdated(true);\n', '        return true;    \n', '    }\n', '\n', '    function returnVestingSchedule() external view returns (uint, uint, uint) {\n', '\n', '        return (duration, cliff, startCountDown);\n', '    }\n', '\n', '    // @note owner can revoke access to continue vesting of tokens\n', '    // @param _user {address} of user to revoke their right to vesting\n', '    function revoke(address _user) public onlyOwner() {\n', '\n', '        TokenHolder storage tokenHolder = tokenHolders[_user];\n', '        tokenHolder.revoked = true; \n', '    }\n', '\n', '    function vestedAmountAvailable() public view returns (uint amount, uint decimals) {\n', '\n', '        TokenHolder storage tokenHolder = tokenHolders[msg.sender];\n', '        uint tokensToRelease = vestedAmount(tokenHolder.tokensToSend);\n', '\n', '     //   if (tokenHolder.releasedAmount + tokensToRelease > tokenHolder.tokensToSend)\n', '      //      return (tokenHolder.tokensToSend - tokenHolder.releasedAmount, token.decimals());\n', '     //   else \n', '        return (tokensToRelease - tokenHolder.releasedAmount, token.decimals());\n', '    }\n', '    \n', '    // @notice Transfers vested available tokens to beneficiary   \n', '    function release() public {\n', '\n', '        TokenHolder storage tokenHolder = tokenHolders[msg.sender];        \n', '        // check if right to vesting is not revoked\n', '        require(!tokenHolder.revoked);                                   \n', '        uint tokensToRelease = vestedAmount(tokenHolder.tokensToSend);      \n', '        uint currentTokenToRelease = tokensToRelease - tokenHolder.releasedAmount;\n', '        tokenHolder.releasedAmount += currentTokenToRelease;            \n', '        token.transfer(msg.sender, currentTokenToRelease);\n', '\n', '        Released(currentTokenToRelease, token.decimals());\n', '    }\n', '  \n', '    // @notice this function will determine vested amount\n', '    // @param _totalBalance {uint} total balance of tokens assigned to this user\n', '    // @return {uint} amount of tokens available to transfer\n', '    function vestedAmount(uint _totalBalance) public view returns (uint) {\n', '\n', '        if (now < cliff) {\n', '            return 0;\n', '        } else if (now >= startCountDown.add(duration)) {\n', '            return _totalBalance;\n', '        } else {\n', '            return _totalBalance.mul(now.sub(startCountDown)) / duration;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// Crowdsale Smart Contract\n', '// This smart contract collects ETH and in return sends  tokens to the Backers\n', 'contract Crowdsale is Pausable, TokenVesting {\n', '\n', '    using SafeMath for uint;\n', '\n', '    address public multisigETH; // Multisig contract that will receive the ETH\n', '    address public commissionAddress;  // address to deposit commissions\n', '    uint public tokensForTeam; // tokens for the team\n', '    uint public ethReceivedPresale; // Number of ETH received in presale\n', '    uint public ethReceivedMain; // Number of ETH received in main sale\n', '    uint public totalTokensSent; // Number of tokens sent to ETH contributors\n', '    uint public tokensSentMain;\n', '    uint public tokensSentPresale;       \n', '    uint public tokensSentDev;         \n', '    uint public startBlock; // Crowdsale start block\n', '    uint public endBlock; // Crowdsale end block\n', '    uint public maxCap; // Maximum number of token to sell\n', '    uint public minCap; // Minimum number of ETH to raise\n', '    uint public minContributionMainSale; // Minimum amount to contribute in main sale\n', '    uint public minContributionPresale; // Minimum amount to contribut in presale\n', '    uint public maxContribution;\n', '    bool public crowdsaleClosed; // Is crowdsale still on going\n', '    uint public tokenPriceWei;\n', '    uint public refundCount;\n', '    uint public totalRefunded;\n', '    uint public campaignDurationDays; // campaign duration in days \n', '    uint public firstPeriod; \n', '    uint public secondPeriod; \n', '    uint public thirdPeriod; \n', '    uint public firstBonus; \n', '    uint public secondBonus;\n', '    uint public thirdBonus;\n', '    uint public multiplier;\n', '    uint public status;    \n', '    Step public currentStep;  // To allow for controlled steps of the campaign \n', '   \n', '    // Looping through Backer\n', '    //mapping(address => Backer) public backers; //backer list\n', '    address[] public holdersIndex;   // to be able to itarate through backers when distributing the tokens\n', '    address[] public devIndex;   // to be able to itarate through backers when distributing the tokens\n', '\n', '    // @notice to set and determine steps of crowdsale\n', '    enum Step {      \n', '        FundingPreSale,     // presale mode\n', '        FundingMainSale,  // public mode\n', '        Refunding  // in case campaign failed during this step contributors will be able to receive refunds\n', '    }\n', '\n', '    // @notice to verify if action is not performed out of the campaing range\n', '    modifier respectTimeFrame() {\n', '        if ((block.number < startBlock) || (block.number > endBlock)) \n', '            revert();\n', '        _;\n', '    }\n', '\n', '    modifier minCapNotReached() {\n', '        if (totalTokensSent >= minCap) \n', '            revert();\n', '        _;\n', '    }\n', '\n', '    // Events\n', '    event LogReceivedETH(address indexed backer, uint amount, uint tokenAmount);\n', '    event LogStarted(uint startBlockLog, uint endBlockLog);\n', '    event LogFinalized(bool success);  \n', '    event LogRefundETH(address indexed backer, uint amount);\n', '    event LogStepAdvanced();\n', '    event LogDevTokensAllocated(address indexed dev, uint amount);\n', '    event LogNonVestedTokensSent(address indexed user, uint amount);\n', '\n', '    // Crowdsale  {constructor}\n', '    // @notice fired when contract is crated. Initilizes all constnat variables.\n', '    function Crowdsale(uint _decimalPoints,\n', '                        address _multisigETH,\n', '                        uint _toekensForTeam, \n', '                        uint _minContributionPresale,\n', '                        uint _minContributionMainSale,\n', '                        uint _maxContribution,                        \n', '                        uint _maxCap, \n', '                        uint _minCap, \n', '                        uint _tokenPriceWei, \n', '                        uint _campaignDurationDays,\n', '                        uint _firstPeriod, \n', '                        uint _secondPeriod, \n', '                        uint _thirdPeriod, \n', '                        uint _firstBonus, \n', '                        uint _secondBonus,\n', '                        uint _thirdBonus) public {\n', '        multiplier = 10**_decimalPoints;\n', '        multisigETH = _multisigETH; \n', '        tokensForTeam = _toekensForTeam * multiplier; \n', '        minContributionPresale = _minContributionPresale; \n', '        minContributionMainSale = _minContributionMainSale;\n', '        maxContribution = _maxContribution;       \n', '        maxCap = _maxCap * multiplier;       \n', '        minCap = _minCap * multiplier;\n', '        tokenPriceWei = _tokenPriceWei;\n', '        campaignDurationDays = _campaignDurationDays;\n', '        firstPeriod = _firstPeriod; \n', '        secondPeriod = _secondPeriod; \n', '        thirdPeriod = _thirdPeriod;\n', '        firstBonus = _firstBonus;\n', '        secondBonus = _secondBonus;\n', '        thirdBonus = _thirdBonus;       \n', '        //TODO replace this address below with correct address.\n', '        commissionAddress = 0x326B5E9b8B2ebf415F9e91b42c7911279d296ea1;\n', '        //commissionAddress = 0x853A3F142430658A32f75A0dc891b98BF4bDF5c1;\n', '        currentStep = Step.FundingPreSale; \n', '    }\n', '\n', '    // @notice to populate website with status of the sale \n', '    function returnWebsiteData() external view returns(uint, \n', '        uint, uint, uint, uint, uint, uint, uint, uint, uint, bool, bool, uint, Step) {\n', '    \n', '        return (startBlock, endBlock, numberOfBackers(), ethReceivedPresale + ethReceivedMain, maxCap, minCap, \n', '                totalTokensSent, tokenPriceWei, minContributionPresale, minContributionMainSale, \n', '                paused, crowdsaleClosed, token.decimals(), currentStep);\n', '    }\n', '    \n', '    // @notice this function will determine status of crowdsale\n', '    function determineStatus() external view returns (uint) {\n', '       \n', '        if (crowdsaleClosed)            // ICO finihsed\n', '            return 1;   \n', '\n', '        if (block.number < endBlock && totalTokensSent < maxCap - 100)   // ICO in progress\n', '            return 2;            \n', '    \n', '        if (totalTokensSent < minCap && block.number > endBlock)      // ICO failed    \n', '            return 3;            \n', '    \n', '        if (endBlock == 0)           // ICO hasn&#39;t been started yet \n', '            return 4;            \n', '    \n', '        return 0;         \n', '    } \n', '\n', '    // {fallback function}\n', '    // @notice It will call internal function which handels allocation of Ether and calculates tokens.\n', '    function () public payable {    \n', '             \n', '        contribute(msg.sender);\n', '    }\n', '\n', '    // @notice to allow for contribution from interface\n', '    function contributePublic() external payable {\n', '        contribute(msg.sender);\n', '    }\n', '\n', '    // @notice set the step of the campaign from presale to public sale\n', '    // contract is deployed in presale mode\n', '    // WARNING: there is no way to go back\n', '    function advanceStep() external onlyOwner() {\n', '        currentStep = Step.FundingMainSale;\n', '        LogStepAdvanced();\n', '    }\n', '\n', '    // @notice It will be called by owner to start the sale    \n', '    function start() external onlyOwner() {\n', '        startBlock = block.number;\n', '        endBlock = startBlock + (4*60*24*campaignDurationDays); // assumption is that one block takes 15 sec. \n', '        crowdsaleClosed = false;\n', '        LogStarted(startBlock, endBlock);\n', '    }\n', '\n', '    // @notice This function will finalize the sale.\n', '    // It will only execute if predetermined sale time passed or all tokens are sold.\n', '    function finalize() external onlyOwner() {\n', '\n', '        require(!crowdsaleClosed);                       \n', '        require(block.number >= endBlock || totalTokensSent > maxCap - 1000);\n', '                    // - 1000 is used to allow closing of the campaing when contribution is near \n', '                    // finished as exact amount of maxCap might be not feasible e.g. you can&#39;t easily buy few tokens. \n', '                    // when min contribution is 0.1 Eth.  \n', '\n', '        require(totalTokensSent >= minCap);\n', '        crowdsaleClosed = true;\n', '        \n', '        // transfer commission portion to the platform\n', '        commissionAddress.transfer(determineCommissions());         \n', '        \n', '        // transfer remaning funds to the campaign wallet\n', '        multisigETH.transfer(this.balance);\n', '        \n', '        /*if (!token.transfer(owner, token.balanceOf(this))) \n', '            revert(); // transfer tokens to admin account  \n', '            \n', '        if (!token.burn(this, token.balanceOf(this))) \n', '            revert();  // burn all the tokens remaining in the contract   */\n', '        token.unlock();    // release lock from transfering tokens. \n', '\n', '        LogFinalized(true);        \n', '    }\n', '\n', '    // @notice it will allow contributors to get refund in case campaign failed\n', '    // @return {bool} true if successful\n', '    function refund() external whenNotPaused returns (bool) {      \n', '        \n', '        uint totalEtherReceived = ethReceivedPresale + ethReceivedMain;\n', '\n', '        require(totalEtherReceived < minCap);  // ensure that campaign failed\n', '        require(this.balance > 0);  // contract will hold 0 ether at the end of campaign.\n', '                                    // contract needs to be funded through fundContract() \n', '        TokenHolder storage backer = tokenHolders[msg.sender];\n', '\n', '        require(backer.weiReceived > 0);  // ensure that user has sent contribution\n', '        require(!backer.refunded);        // ensure that user hasn&#39;t been refunded yet\n', '\n', '        backer.refunded = true;  // save refund status to true\n', '        refundCount++;\n', '        totalRefunded += backer.weiReceived;\n', '\n', '        if (!token.burn(msg.sender, backer.tokensToSend)) // burn tokens\n', '            revert();        \n', '        msg.sender.transfer(backer.weiReceived);  // send back the contribution \n', '        LogRefundETH(msg.sender, backer.weiReceived);\n', '        return true;\n', '    }\n', '\n', '    // @notice allocate tokens to dev/team/advisors\n', '    // @param _dev {address} \n', '    // @param _amount {uint} amount of tokens\n', '    function devAllocation(address _dev, uint _amount) external onlyOwner() returns (bool) {\n', '\n', '        require(_dev != address(0));\n', '        require(crowdsaleClosed); \n', '        require(totalTokensSent.add(_amount) <= token.totalSupply());\n', '        devIndex.push(_dev);\n', '        TokenHolder storage tokenHolder = tokenHolders[_dev];\n', '        tokenHolder.tokensToSend = _amount;\n', '        tokensSentDev += _amount;\n', '        totalTokensSent += _amount;        \n', '        LogDevTokensAllocated(_dev, _amount); // Register event\n', '        return true;\n', '\n', '    }\n', '\n', '    // @notice Failsafe drain\n', '    function drain(uint _amount) external onlyOwner() {\n', '        owner.transfer(_amount);           \n', '    }\n', '\n', '    // @notice transfer tokens which are not subject to vesting\n', '    // @param _recipient {addres}\n', '    // @param _amont {uint} amount to transfer\n', '    function transferTokens(address _recipient, uint _amount) external onlyOwner() returns (bool) {\n', '\n', '        require(_recipient != address(0));\n', '        if (!token.transfer(_recipient, _amount))\n', '            revert();\n', '        LogNonVestedTokensSent(_recipient, _amount);\n', '    }\n', '\n', '    // @notice determine amount of commissions for the platform    \n', '    function determineCommissions() public view returns (uint) {\n', '     \n', '        if (this.balance <= 500 ether) {\n', '            return (this.balance * 10)/100;\n', '        }else if (this.balance <= 1000 ether) {\n', '            return (this.balance * 8)/100;\n', '        }else if (this.balance < 10000 ether) {\n', '            return (this.balance * 6)/100;\n', '        }else {\n', '            return (this.balance * 6)/100;\n', '        }\n', '    }\n', '\n', '    // @notice return number of contributors\n', '    // @return  {uint} number of contributors\n', '    function numberOfBackers() public view returns (uint) {\n', '        return holdersIndex.length;\n', '    }\n', '\n', '    // @notice It will be called by fallback function whenever ether is sent to it\n', '    // @param  _backer {address} address of beneficiary\n', '    // @return res {bool} true if transaction was successful\n', '    function contribute(address _backer) internal whenNotPaused respectTimeFrame returns(bool res) {\n', '\n', '        //require(msg.value <= maxContribution);\n', '\n', '        if (whiteList != address(0))  // if whitelist initialized verify member whitelist status\n', '            require(whiteList.isWhiteListed(_backer));  // ensure that user is whitelisted\n', '          \n', '        uint tokensToSend = calculateNoOfTokensToSend(); // calculate number of tokens\n', '\n', '        // Ensure that max cap hasn&#39;t been reached\n', '        require(totalTokensSent + tokensToSend <= maxCap);\n', '        \n', '        TokenHolder storage backer = tokenHolders[_backer];\n', '\n', '        if (backer.weiReceived == 0)\n', '            holdersIndex.push(_backer);\n', '\n', '        if (Step.FundingMainSale == currentStep) { // Update the total Ether received and tokens sent during public sale\n', '            require(msg.value >= minContributionMainSale); // stop when required minimum is not met    \n', '            ethReceivedMain = ethReceivedMain.add(msg.value);\n', '            tokensSentMain += tokensToSend;\n', '        }else {  \n', '            require(msg.value >= minContributionPresale); // stop when required minimum is not met\n', '            ethReceivedPresale = ethReceivedPresale.add(msg.value); \n', '            tokensSentPresale += tokensToSend;\n', '        }  \n', '       \n', '        backer.tokensToSend += tokensToSend;\n', '        backer.weiReceived = backer.weiReceived.add(msg.value);       \n', '        totalTokensSent += tokensToSend;      \n', '        \n', '        // tokens are not transferrd to contributors during this phase\n', '        // tokens will be transferred based on the vesting schedule, when contributor\n', '        // calls release() function of this contract\n', '        LogReceivedETH(_backer, msg.value, tokensToSend); // Register event\n', '        return true;\n', '    }\n', '\n', '    // @notice This function will return number of tokens based on time intervals in the campaign\n', '    function calculateNoOfTokensToSend() internal view returns (uint) {\n', '\n', '        uint tokenAmount = msg.value.mul(multiplier) / tokenPriceWei;\n', '\n', '        if (Step.FundingMainSale == currentStep) {\n', '        \n', '            if (block.number <= startBlock + firstPeriod) {  \n', '                return  tokenAmount + tokenAmount.mul(firstBonus) / 100;\n', '            }else if (block.number <= startBlock + secondPeriod) {\n', '                return  tokenAmount + tokenAmount.mul(secondBonus) / 100; \n', '            }else if (block.number <= startBlock + thirdPeriod) { \n', '                return  tokenAmount + tokenAmount.mul(thirdBonus) / 100;        \n', '            }else {              \n', '                return  tokenAmount; \n', '            }\n', '        }else \n', '            return  tokenAmount + tokenAmount.mul(presaleBonus) / 100;\n', '    }  \n', '}\n', '\n', '\n', '// The  token\n', 'contract Token is ERC20, Ownable {\n', '\n', '    using SafeMath for uint;\n', '    // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    uint public decimals; // How many decimals to show.\n', '    string public version = "v0.1";\n', '    uint public totalSupply;\n', '    bool public locked;\n', '    address public crowdSaleAddress;\n', '\n', '    mapping(address => uint) public balances;\n', '    mapping(address => mapping(address => uint)) public allowed;\n', '    \n', '    // Lock transfer during the ICO\n', '    modifier onlyUnlocked() {\n', '        if (msg.sender != crowdSaleAddress && locked && msg.sender != owner) \n', '            revert();\n', '        _;\n', '    }\n', '\n', '    modifier onlyAuthorized() {\n', '        if (msg.sender != crowdSaleAddress && msg.sender != owner) \n', '            revert();\n', '        _;\n', '    }\n', '\n', '    // The Token constructor     \n', '    function Token(uint _initialSupply,\n', '            string _tokenName,\n', '            uint _decimalUnits,\n', '            string _tokenSymbol,\n', '            string _version,\n', '            address _crowdSaleAddress) public {      \n', '        locked = true;  // Lock the transfer of tokens during the crowdsale\n', '        totalSupply = _initialSupply * (10**_decimalUnits);     \n', '                                        \n', '        name = _tokenName; // Set the name for display purposes\n', '        symbol = _tokenSymbol; // Set the symbol for display purposes\n', '        decimals = _decimalUnits; // Amount of decimals for display purposes\n', '        version = _version;\n', '        crowdSaleAddress = _crowdSaleAddress;              \n', '        balances[crowdSaleAddress] = totalSupply;   \n', '    }\n', '\n', '    function unlock() public onlyAuthorized {\n', '        locked = false;\n', '    }\n', '\n', '    function lock() public onlyAuthorized {\n', '        locked = true;\n', '    }\n', '\n', '    function burn(address _member, uint256 _value) public onlyAuthorized returns(bool) {\n', '        require(balances[_member] >= _value);\n', '        balances[_member] -= _value;\n', '        totalSupply -= _value;\n', '        Transfer(_member, 0x0, _value);\n', '        return true;\n', '    }\n', '\n', '   \n', '    // @notice transfer tokens to given address\n', '    // @param _to {address} address or recipient\n', '    // @param _value {uint} amount to transfer\n', '    // @return  {bool} true if successful\n', '    function transfer(address _to, uint _value) public onlyUnlocked returns(bool) {\n', '\n', '        require(_to != address(0));\n', '        require(balances[msg.sender] >= _value);\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // @notice transfer tokens from given address to another address\n', '    // @param _from {address} from whom tokens are transferred\n', '    // @param _to {address} to whom tokens are transferred\n', '    // @param _value {uint} amount of tokens to transfer\n', '    // @return  {bool} true if successful\n', '    function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns(bool success) {\n', '\n', '        require(_to != address(0));\n', '        require(balances[_from] >= _value); // Check if the sender has enough\n', '        require(_value <= allowed[_from][msg.sender]); // Check if allowed is greater or equal\n', '        balances[_from] -= _value; // Subtract from the sender\n', '        balances[_to] += _value; // Add the same to the recipient\n', '        allowed[_from][msg.sender] -= _value;  // adjust allowed\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '      // @notice to query balance of account\n', '    // @return _owner {address} address of user to query balance\n', '    function balanceOf(address _owner) public view returns(uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    *\n', '    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '    * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint _value) public returns(bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // @notice to query of allowance of one user to the other\n', '    // @param _owner {address} of the owner of the account\n', '    // @param _spender {address} of the spender of the account\n', '    // @return remaining {uint} amount of remaining allowance\n', '    function allowance(address _owner, address _spender) public view returns(uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '    * approve should be called when allowed[_spender] == 0. To increment\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    */\n', '    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}']