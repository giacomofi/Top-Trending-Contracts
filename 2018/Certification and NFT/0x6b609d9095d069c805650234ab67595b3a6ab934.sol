['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * IPausable\n', ' *\n', ' * Simple interface to pause and resume \n', ' *\n', ' * #created 11/10/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'interface IPausable {\n', '\n', '\n', '    /**\n', '     * Returns whether the implementing contract is \n', '     * currently paused or not\n', '     *\n', '     * @return Whether the paused state is active\n', '     */\n', '    function isPaused() public view returns (bool);\n', '\n', '\n', '    /**\n', '     * Change the state to paused\n', '     */\n', '    function pause() public;\n', '\n', '\n', '    /**\n', '     * Change the state to resume, undo the effects \n', '     * of calling pause\n', '     */\n', '    function resume() public;\n', '}\n', '\n', '\n', '/**\n', ' * IOwnership\n', ' *\n', ' * Perminent ownership\n', ' *\n', ' * #created 01/10/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'interface IOwnership {\n', '\n', '    /**\n', '     * Returns true if `_account` is the current owner\n', '     *\n', '     * @param _account The address to test against\n', '     */\n', '    function isOwner(address _account) public view returns (bool);\n', '\n', '\n', '    /**\n', '     * Gets the current owner\n', '     *\n', '     * @return address The current owner\n', '     */\n', '    function getOwner() public view returns (address);\n', '}\n', '\n', '\n', '/**\n', ' * Ownership\n', ' *\n', ' * Perminent ownership\n', ' *\n', ' * #created 01/10/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'contract Ownership is IOwnership {\n', '\n', '    // Owner\n', '    address internal owner;\n', '\n', '\n', '    /**\n', '     * Access is restricted to the current owner\n', '     */\n', '    modifier only_owner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * The publisher is the inital owner\n', '     */\n', '    function Ownership() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * Returns true if `_account` is the current owner\n', '     *\n', '     * @param _account The address to test against\n', '     */\n', '    function isOwner(address _account) public view returns (bool) {\n', '        return _account == owner;\n', '    }\n', '\n', '\n', '    /**\n', '     * Gets the current owner\n', '     *\n', '     * @return address The current owner\n', '     */\n', '    function getOwner() public view returns (address) {\n', '        return owner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * ERC20 compatible token interface\n', ' *\n', ' * - Implements ERC 20 Token standard\n', ' * - Implements short address attack fix\n', ' *\n', ' * #created 29/09/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'interface IToken { \n', '\n', '    /** \n', '     * Get the total supply of tokens\n', '     * \n', '     * @return The total supply\n', '     */\n', '    function totalSupply() public view returns (uint);\n', '\n', '\n', '    /** \n', '     * Get balance of `_owner` \n', '     * \n', '     * @param _owner The address from which the balance will be retrieved\n', '     * @return The balance\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint);\n', '\n', '\n', '    /** \n', '     * Send `_value` token to `_to` from `msg.sender`\n', '     * \n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transfer(address _to, uint _value) public returns (bool);\n', '\n', '\n', '    /** \n', '     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '     * \n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool);\n', '\n', '\n', '    /** \n', '     * `msg.sender` approves `_spender` to spend `_value` tokens\n', '     * \n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @param _value The amount of tokens to be approved for transfer\n', '     * @return Whether the approval was successful or not\n', '     */\n', '    function approve(address _spender, uint _value) public returns (bool);\n', '\n', '\n', '    /** \n', '     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\n', '     * \n', '     * @param _owner The address of the account owning tokens\n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @return Amount of remaining tokens allowed to spent\n', '     */\n', '    function allowance(address _owner, address _spender) public view returns (uint);\n', '}\n', '\n', '\n', '/**\n', ' * IManagedToken\n', ' *\n', ' * Adds the following functionality to the basic ERC20 token\n', ' * - Locking\n', ' * - Issuing\n', ' * - Burning \n', ' *\n', ' * #created 29/09/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'interface IManagedToken { \n', '\n', '    /** \n', '     * Returns true if the token is locked\n', '     * \n', '     * @return Whether the token is locked\n', '     */\n', '    function isLocked() public view returns (bool);\n', '\n', '\n', '    /**\n', '     * Locks the token so that the transfering of value is disabled \n', '     *\n', '     * @return Whether the unlocking was successful or not\n', '     */\n', '    function lock() public returns (bool);\n', '\n', '\n', '    /**\n', '     * Unlocks the token so that the transfering of value is enabled \n', '     *\n', '     * @return Whether the unlocking was successful or not\n', '     */\n', '    function unlock() public returns (bool);\n', '\n', '\n', '    /**\n', '     * Issues `_value` new tokens to `_to`\n', '     *\n', '     * @param _to The address to which the tokens will be issued\n', '     * @param _value The amount of new tokens to issue\n', '     * @return Whether the tokens where sucessfully issued or not\n', '     */\n', '    function issue(address _to, uint _value) public returns (bool);\n', '\n', '\n', '    /**\n', '     * Burns `_value` tokens of `_from`\n', '     *\n', '     * @param _from The address that owns the tokens to be burned\n', '     * @param _value The amount of tokens to be burned\n', '     * @return Whether the tokens where sucessfully burned or not \n', '     */\n', '    function burn(address _from, uint _value) public returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * ITokenRetriever\n', ' *\n', ' * Allows tokens to be retrieved from a contract\n', ' *\n', ' * #created 29/09/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'interface ITokenRetriever {\n', '\n', '    /**\n', '     * Extracts tokens from the contract\n', '     *\n', '     * @param _tokenContract The address of ERC20 compatible token\n', '     */\n', '    function retrieveTokens(address _tokenContract) public;\n', '}\n', '\n', '\n', '/**\n', ' * TokenRetriever\n', ' *\n', ' * Allows tokens to be retrieved from a contract\n', ' *\n', ' * #created 18/10/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'contract TokenRetriever is ITokenRetriever {\n', '\n', '    /**\n', '     * Extracts tokens from the contract\n', '     *\n', '     * @param _tokenContract The address of ERC20 compatible token\n', '     */\n', '    function retrieveTokens(address _tokenContract) public {\n', '        IToken tokenInstance = IToken(_tokenContract);\n', '        uint tokenBalance = tokenInstance.balanceOf(this);\n', '        if (tokenBalance > 0) {\n', '            tokenInstance.transfer(msg.sender, tokenBalance);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * IAuthenticator \n', ' *\n', ' * Authenticator interface\n', ' *\n', ' * #created 15/10/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'interface IAuthenticator {\n', '    \n', '\n', '    /**\n', '     * Authenticate \n', '     *\n', '     * Returns whether `_account` is authenticated or not\n', '     *\n', '     * @param _account The account to authenticate\n', '     * @return whether `_account` is successfully authenticated\n', '     */\n', '    function authenticate(address _account) public view returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * IAuthenticationManager \n', ' *\n', ' * Allows the authentication process to be enabled and disabled\n', ' *\n', ' * #created 15/10/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'interface IAuthenticationManager {\n', '    \n', '\n', '    /**\n', '     * Returns true if authentication is enabled and false \n', '     * otherwise\n', '     *\n', '     * @return Whether the converter is currently authenticating or not\n', '     */\n', '    function isAuthenticating() public view returns (bool);\n', '\n', '\n', '    /**\n', '     * Enable authentication\n', '     */\n', '    function enableAuthentication() public;\n', '\n', '\n', '    /**\n', '     * Disable authentication\n', '     */\n', '    function disableAuthentication() public;\n', '}\n', '\n', '\n', '/**\n', ' * IWingsAdapter\n', ' * \n', ' * WINGS DAO Price Discovery & Promotion Pre-Beta https://www.wings.ai\n', ' *\n', ' * #created 04/10/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'interface IWingsAdapter {\n', '\n', '    /**\n', '     * Get the total raised amount of Ether\n', '     *\n', '     * Can only increase, meaning if you withdraw ETH from the wallet, it should be not modified (you can use two fields \n', '     * to keep one with a total accumulated amount) amount of ETH in contract and totalCollected for total amount of ETH collected\n', '     *\n', '     * @return Total raised Ether amount\n', '     */\n', '    function totalCollected() public view returns (uint);\n', '}\n', '\n', '\n', '/**\n', ' * IPersonalCrowdsaleProxy\n', ' *\n', ' * #created 22/11/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'interface IPersonalCrowdsaleProxy {\n', '\n', '    /**\n', '     * Receive ether and issue tokens\n', '     * \n', "     * This function requires that msg.sender is not a contract. This is required because it's \n", '     * not possible for a contract to specify a gas amount when calling the (internal) send() \n', '     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\n', '     * \n', '     * Contracts can call the contribute() function instead\n', '     */\n', '    function () public payable;\n', '}\n', '\n', '\n', '/**\n', ' * PersonalCrowdsaleProxy\n', ' *\n', ' * #created 22/11/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'contract PersonalCrowdsaleProxy is IPersonalCrowdsaleProxy {\n', '\n', '    address public owner;\n', '    ICrowdsale public target;\n', '    \n', '\n', '    /**\n', '     * Deploy proxy\n', '     *\n', '     * @param _owner Owner of the proxy\n', '     * @param _target Target crowdsale\n', '     */\n', '    function PersonalCrowdsaleProxy(address _owner, address _target) public {\n', '        target = ICrowdsale(_target);\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /**\n', '     * Receive contribution and forward to the target crowdsale\n', '     * \n', "     * This function requires that msg.sender is not a contract. This is required because it's \n", '     * not possible for a contract to specify a gas amount when calling the (internal) send() \n', '     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\n', '     */\n', '    function () public payable {\n', '        target.contributeFor.value(msg.value)(owner);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * ICrowdsaleProxy\n', ' *\n', ' * #created 23/11/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'interface ICrowdsaleProxy {\n', '\n', '    /**\n', '     * Receive ether and issue tokens to the sender\n', '     * \n', "     * This function requires that msg.sender is not a contract. This is required because it's \n", '     * not possible for a contract to specify a gas amount when calling the (internal) send() \n', '     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\n', '     * \n', '     * Contracts can call the contribute() function instead\n', '     */\n', '    function () public payable;\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to the sender\n', '     *\n', '     * @return The accepted ether amount\n', '     */\n', '    function contribute() public payable returns (uint);\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to `_beneficiary`\n', '     *\n', '     * @param _beneficiary The account that receives the tokens\n', '     * @return The accepted ether amount\n', '     */\n', '    function contributeFor(address _beneficiary) public payable returns (uint);\n', '}\n', '\n', '\n', '/**\n', ' * CrowdsaleProxy\n', ' *\n', ' * #created 22/11/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'contract CrowdsaleProxy is ICrowdsaleProxy {\n', '\n', '    address public owner;\n', '    ICrowdsale public target;\n', '    \n', '\n', '    /**\n', '     * Deploy proxy\n', '     *\n', '     * @param _owner Owner of the proxy\n', '     * @param _target Target crowdsale\n', '     */\n', '    function CrowdsaleProxy(address _owner, address _target) public {\n', '        target = ICrowdsale(_target);\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /**\n', '     * Receive contribution and forward to the crowdsale\n', '     * \n', "     * This function requires that msg.sender is not a contract. This is required because it's \n", '     * not possible for a contract to specify a gas amount when calling the (internal) send() \n', '     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\n', '     */\n', '    function () public payable {\n', '        target.contributeFor.value(msg.value)(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to the sender\n', '     *\n', '     * @return The accepted ether amount\n', '     */\n', '    function contribute() public payable returns (uint) {\n', '        target.contributeFor.value(msg.value)(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to `_beneficiary`\n', '     *\n', '     * @param _beneficiary The account that receives the tokens\n', '     * @return The accepted ether amount\n', '     */\n', '    function contributeFor(address _beneficiary) public payable returns (uint) {\n', '        target.contributeFor.value(msg.value)(_beneficiary);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * ICrowdsale\n', ' *\n', ' * Base crowdsale interface to manage the sale of \n', ' * an ERC20 token\n', ' *\n', ' * #created 09/09/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'interface ICrowdsale {\n', '\n', '    /**\n', '     * Returns true if the contract is currently in the presale phase\n', '     *\n', '     * @return True if in presale phase\n', '     */\n', '    function isInPresalePhase() public view returns (bool);\n', '\n', '\n', '    /**\n', '     * Returns true if the contract is currently in the ended stage\n', '     *\n', '     * @return True if ended\n', '     */\n', '    function isEnded() public view returns (bool);\n', '\n', '\n', '    /**\n', '     * Returns true if `_beneficiary` has a balance allocated\n', '     *\n', '     * @param _beneficiary The account that the balance is allocated for\n', '     * @param _releaseDate The date after which the balance can be withdrawn\n', '     * @return True if there is a balance that belongs to `_beneficiary`\n', '     */\n', '    function hasBalance(address _beneficiary, uint _releaseDate) public view returns (bool);\n', '\n', '\n', '    /** \n', '     * Get the allocated token balance of `_owner`\n', '     * \n', '     * @param _owner The address from which the allocated token balance will be retrieved\n', '     * @return The allocated token balance\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint);\n', '\n', '\n', '    /** \n', '     * Get the allocated eth balance of `_owner`\n', '     * \n', '     * @param _owner The address from which the allocated eth balance will be retrieved\n', '     * @return The allocated eth balance\n', '     */\n', '    function ethBalanceOf(address _owner) public view returns (uint);\n', '\n', '\n', '    /** \n', '     * Get invested and refundable balance of `_owner` (only contributions during the ICO phase are registered)\n', '     * \n', '     * @param _owner The address from which the refundable balance will be retrieved\n', '     * @return The invested refundable balance\n', '     */\n', '    function refundableEthBalanceOf(address _owner) public view returns (uint);\n', '\n', '\n', '    /**\n', '     * Returns the rate and bonus release date\n', '     *\n', '     * @param _phase The phase to use while determining the rate\n', '     * @param _volume The amount wei used to determine what volume multiplier to use\n', '     * @return The rate used in `_phase` multiplied by the corresponding volume multiplier\n', '     */\n', '    function getRate(uint _phase, uint _volume) public view returns (uint);\n', '\n', '\n', '    /**\n', '     * Convert `_wei` to an amount in tokens using \n', '     * the `_rate`\n', '     *\n', '     * @param _wei amount of wei to convert\n', '     * @param _rate rate to use for the conversion\n', '     * @return Amount in tokens\n', '     */\n', '    function toTokens(uint _wei, uint _rate) public view returns (uint);\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to the sender\n', '     * \n', "     * This function requires that msg.sender is not a contract. This is required because it's \n", '     * not possible for a contract to specify a gas amount when calling the (internal) send() \n', '     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\n', '     * \n', '     * Contracts can call the contribute() function instead\n', '     */\n', '    function () public payable;\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to the sender\n', '     *\n', '     * @return The accepted ether amount\n', '     */\n', '    function contribute() public payable returns (uint);\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to `_beneficiary`\n', '     *\n', '     * @param _beneficiary The account that receives the tokens\n', '     * @return The accepted ether amount\n', '     */\n', '    function contributeFor(address _beneficiary) public payable returns (uint);\n', '\n', '\n', '    /**\n', '     * Withdraw allocated tokens\n', '     */\n', '    function withdrawTokens() public;\n', '\n', '\n', '    /**\n', '     * Withdraw allocated ether\n', '     */\n', '    function withdrawEther() public;\n', '\n', '\n', '    /**\n', '     * Refund in the case of an unsuccessful crowdsale. The \n', '     * crowdsale is considered unsuccessful if minAmount was \n', '     * not raised before end of the crowdsale\n', '     */\n', '    function refund() public;\n', '}\n', '\n', '\n', '/**\n', ' * Crowdsale\n', ' *\n', ' * Abstract base crowdsale contract that manages the sale of \n', ' * an ERC20 token\n', ' *\n', ' * #created 29/09/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'contract Crowdsale is ICrowdsale, Ownership {\n', '\n', '    enum Stages {\n', '        Deploying,\n', '        Deployed,\n', '        InProgress,\n', '        Ended\n', '    }\n', '\n', '    struct Balance {\n', '        uint eth;\n', '        uint tokens;\n', '        uint index;\n', '    }\n', '\n', '    struct Percentage {\n', '        uint eth;\n', '        uint tokens;\n', '        bool overwriteReleaseDate;\n', '        uint fixedReleaseDate;\n', '        uint index; \n', '    }\n', '\n', '    struct Payout {\n', '        uint percentage;\n', '        uint vestingPeriod;\n', '    }\n', '\n', '    struct Phase {\n', '        uint rate;\n', '        uint end;\n', '        uint bonusReleaseDate;\n', '        bool useVolumeMultiplier;\n', '    }\n', '\n', '    struct VolumeMultiplier {\n', '        uint rateMultiplier;\n', '        uint bonusReleaseDateMultiplier;\n', '    }\n', '\n', '    // Crowdsale details\n', '    uint public baseRate;\n', '    uint public minAmount; \n', '    uint public maxAmount; \n', '    uint public minAcceptedAmount;\n', '    uint public minAmountPresale; \n', '    uint public maxAmountPresale;\n', '    uint public minAcceptedAmountPresale;\n', '\n', '    // Company address\n', '    address public beneficiary; \n', '\n', '    // Denominators\n', '    uint internal percentageDenominator;\n', '    uint internal tokenDenominator;\n', '\n', '    // Crowdsale state\n', '    uint public start;\n', '    uint public presaleEnd;\n', '    uint public crowdsaleEnd;\n', '    uint public raised;\n', '    uint public allocatedEth;\n', '    uint public allocatedTokens;\n', '    Stages public stage;\n', '\n', '    // Token contract\n', '    IManagedToken public token;\n', '\n', '    // Invested balances\n', '    mapping (address => uint) private balances;\n', '\n', '    // Alocated balances\n', '    mapping (address => mapping(uint => Balance)) private allocated;\n', '    mapping(address => uint[]) private allocatedIndex;\n', '\n', '    // Stakeholders\n', '    mapping (address => Percentage) private stakeholderPercentages;\n', '    address[] private stakeholderPercentagesIndex;\n', '    Payout[] private stakeholdersPayouts;\n', '\n', '    // Crowdsale phases\n', '    Phase[] private phases;\n', '\n', '    // Volume multipliers\n', '    mapping (uint => VolumeMultiplier) private volumeMultipliers;\n', '    uint[] private volumeMultiplierThresholds;\n', '\n', '    \n', '    /**\n', '     * Throw if at stage other than current stage\n', '     * \n', '     * @param _stage expected stage to test for\n', '     */\n', '    modifier at_stage(Stages _stage) {\n', '        require(stage == _stage);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * Only after crowdsaleEnd plus `_time`\n', '     * \n', '     * @param _time Time to pass\n', '     */\n', '    modifier only_after(uint _time) {\n', '        require(now > crowdsaleEnd + _time);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * Only after crowdsale\n', '     */\n', '    modifier only_after_crowdsale() {\n', '        require(now > crowdsaleEnd);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * Throw if sender is not beneficiary\n', '     */\n', '    modifier only_beneficiary() {\n', '        require(beneficiary == msg.sender);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * Start in the deploying stage\n', '     */\n', '    function Crowdsale() public {\n', '        stage = Stages.Deploying;\n', '    }\n', '\n', '\n', '    /**\n', '     * Setup the crowdsale\n', '     *\n', '     * @param _start The timestamp of the start date\n', '     * @param _token The token that is sold\n', '     * @param _tokenDenominator The token amount of decimals that the token uses\n', '     * @param _percentageDenominator The percision of percentages\n', '     * @param _minAmountPresale The min cap for the presale\n', '     * @param _maxAmountPresale The max cap for the presale\n', '     * @param _minAcceptedAmountPresale The lowest accepted amount during the presale phase\n', '     * @param _minAmount The min cap for the ICO\n', '     * @param _maxAmount The max cap for the ICO\n', '     * @param _minAcceptedAmount The lowest accepted amount during the ICO phase\n', '     */\n', '    function setup(uint _start, address _token, uint _tokenDenominator, uint _percentageDenominator, uint _minAmountPresale, uint _maxAmountPresale, uint _minAcceptedAmountPresale, uint _minAmount, uint _maxAmount, uint _minAcceptedAmount) public only_owner at_stage(Stages.Deploying) {\n', '        token = IManagedToken(_token);\n', '        tokenDenominator = _tokenDenominator;\n', '        percentageDenominator = _percentageDenominator;\n', '        start = _start;\n', '        minAmountPresale = _minAmountPresale;\n', '        maxAmountPresale = _maxAmountPresale;\n', '        minAcceptedAmountPresale = _minAcceptedAmountPresale;\n', '        minAmount = _minAmount;\n', '        maxAmount = _maxAmount;\n', '        minAcceptedAmount = _minAcceptedAmount;\n', '    }\n', '\n', '\n', '    /**\n', '     * Setup rates and phases\n', '     *\n', '     * @param _baseRate The rate without bonus\n', '     * @param _phaseRates The rates for each phase\n', '     * @param _phasePeriods The periods that each phase lasts (first phase is the presale phase)\n', '     * @param _phaseBonusLockupPeriods The lockup period that each phase lasts\n', '     * @param _phaseUsesVolumeMultiplier Wheter or not volume bonusses are used in the respective phase\n', '     */\n', '    function setupPhases(uint _baseRate, uint[] _phaseRates, uint[] _phasePeriods, uint[] _phaseBonusLockupPeriods, bool[] _phaseUsesVolumeMultiplier) public only_owner at_stage(Stages.Deploying) {\n', '        baseRate = _baseRate;\n', '        presaleEnd = start + _phasePeriods[0]; // First phase is expected to be the presale phase\n', '        crowdsaleEnd = start; // Plus the sum of the rate phases\n', '\n', '        for (uint i = 0; i < _phaseRates.length; i++) {\n', '            crowdsaleEnd += _phasePeriods[i];\n', '            phases.push(Phase(_phaseRates[i], crowdsaleEnd, 0, _phaseUsesVolumeMultiplier[i]));\n', '        }\n', '\n', '        for (uint ii = 0; ii < _phaseRates.length; ii++) {\n', '            if (_phaseBonusLockupPeriods[ii] > 0) {\n', '                phases[ii].bonusReleaseDate = crowdsaleEnd + _phaseBonusLockupPeriods[ii];\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Setup stakeholders\n', '     *\n', '     * @param _stakeholders The addresses of the stakeholders (first stakeholder is the beneficiary)\n', '     * @param _stakeholderEthPercentages The eth percentages of the stakeholders\n', '     * @param _stakeholderTokenPercentages The token percentages of the stakeholders\n', '     * @param _stakeholderTokenPayoutOverwriteReleaseDates Wheter the vesting period is overwritten for the respective stakeholder\n', '     * @param _stakeholderTokenPayoutFixedReleaseDates The vesting period after which the whole percentage of the tokens is released to the respective stakeholder\n', '     * @param _stakeholderTokenPayoutPercentages The percentage of the tokens that is released at the respective date\n', '     * @param _stakeholderTokenPayoutVestingPeriods The vesting period after which the respective percentage of the tokens is released\n', '     */\n', '    function setupStakeholders(address[] _stakeholders, uint[] _stakeholderEthPercentages, uint[] _stakeholderTokenPercentages, bool[] _stakeholderTokenPayoutOverwriteReleaseDates, uint[] _stakeholderTokenPayoutFixedReleaseDates, uint[] _stakeholderTokenPayoutPercentages, uint[] _stakeholderTokenPayoutVestingPeriods) public only_owner at_stage(Stages.Deploying) {\n', '        beneficiary = _stakeholders[0]; // First stakeholder is expected to be the beneficiary\n', '        for (uint i = 0; i < _stakeholders.length; i++) {\n', '            stakeholderPercentagesIndex.push(_stakeholders[i]);\n', '            stakeholderPercentages[_stakeholders[i]] = Percentage(\n', '                _stakeholderEthPercentages[i], \n', '                _stakeholderTokenPercentages[i], \n', '                _stakeholderTokenPayoutOverwriteReleaseDates[i],\n', '                _stakeholderTokenPayoutFixedReleaseDates[i], i);\n', '        }\n', '\n', '        // Percentages add up to 100\n', '        for (uint ii = 0; ii < _stakeholderTokenPayoutPercentages.length; ii++) {\n', '            stakeholdersPayouts.push(Payout(_stakeholderTokenPayoutPercentages[ii], _stakeholderTokenPayoutVestingPeriods[ii]));\n', '        }\n', '    }\n', '\n', '    \n', '    /**\n', '     * Setup volume multipliers\n', '     *\n', '     * @param _volumeMultiplierRates The rates will be multiplied by this value (denominated by 4)\n', '     * @param _volumeMultiplierLockupPeriods The lockup periods will be multiplied by this value (denominated by 4)\n', '     * @param _volumeMultiplierThresholds The volume thresholds for each respective multiplier\n', '     */\n', '    function setupVolumeMultipliers(uint[] _volumeMultiplierRates, uint[] _volumeMultiplierLockupPeriods, uint[] _volumeMultiplierThresholds) public only_owner at_stage(Stages.Deploying) {\n', '        require(phases.length > 0);\n', '        volumeMultiplierThresholds = _volumeMultiplierThresholds;\n', '        for (uint i = 0; i < volumeMultiplierThresholds.length; i++) {\n', '            volumeMultipliers[volumeMultiplierThresholds[i]] = VolumeMultiplier(_volumeMultiplierRates[i], _volumeMultiplierLockupPeriods[i]);\n', '        }\n', '    }\n', '    \n', '\n', '    /**\n', '     * After calling the deploy function the crowdsale\n', '     * rules become immutable \n', '     */\n', '    function deploy() public only_owner at_stage(Stages.Deploying) {\n', '        require(phases.length > 0);\n', '        require(stakeholderPercentagesIndex.length > 0);\n', '        stage = Stages.Deployed;\n', '    }\n', '\n', '\n', '    /**\n', '     * Prove that beneficiary is able to sign transactions \n', '     * and start the crowdsale\n', '     */\n', '    function confirmBeneficiary() public only_beneficiary at_stage(Stages.Deployed) {\n', '        stage = Stages.InProgress;\n', '    }\n', '\n', '\n', '    /**\n', '     * Returns true if the contract is currently in the presale phase\n', '     *\n', '     * @return True if in presale phase\n', '     */\n', '    function isInPresalePhase() public view returns (bool) {\n', '        return stage == Stages.InProgress && now >= start && now <= presaleEnd;\n', '    }\n', '\n', '\n', '    /**\n', '     * Returns true if the contract is currently in the ended stage\n', '     *\n', '     * @return True if ended\n', '     */\n', '    function isEnded() public view returns (bool) {\n', '        return stage == Stages.Ended;\n', '    }\n', '\n', '\n', '    /**\n', '     * Returns true if `_beneficiary` has a balance allocated\n', '     *\n', '     * @param _beneficiary The account that the balance is allocated for\n', '     * @param _releaseDate The date after which the balance can be withdrawn\n', '     * @return True if there is a balance that belongs to `_beneficiary`\n', '     */\n', '    function hasBalance(address _beneficiary, uint _releaseDate) public view returns (bool) {\n', '        return allocatedIndex[_beneficiary].length > 0 && _releaseDate == allocatedIndex[_beneficiary][allocated[_beneficiary][_releaseDate].index];\n', '    }\n', '\n', '\n', '    /** \n', '     * Get the allocated token balance of `_owner`\n', '     * \n', '     * @param _owner The address from which the allocated token balance will be retrieved\n', '     * @return The allocated token balance\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint) {\n', '        uint sum = 0;\n', '        for (uint i = 0; i < allocatedIndex[_owner].length; i++) {\n', '            sum += allocated[_owner][allocatedIndex[_owner][i]].tokens;\n', '        }\n', '\n', '        return sum;\n', '    }\n', '\n', '\n', '    /** \n', '     * Get the allocated eth balance of `_owner`\n', '     * \n', '     * @param _owner The address from which the allocated eth balance will be retrieved\n', '     * @return The allocated eth balance\n', '     */\n', '    function ethBalanceOf(address _owner) public view returns (uint) {\n', '        uint sum = 0;\n', '        for (uint i = 0; i < allocatedIndex[_owner].length; i++) {\n', '            sum += allocated[_owner][allocatedIndex[_owner][i]].eth;\n', '        }\n', '\n', '        return sum;\n', '    }\n', '\n', '\n', '    /** \n', '     * Get invested and refundable balance of `_owner` (only contributions during the ICO phase are registered)\n', '     * \n', '     * @param _owner The address from which the refundable balance will be retrieved\n', '     * @return The invested refundable balance\n', '     */\n', '    function refundableEthBalanceOf(address _owner) public view returns (uint) {\n', '        return now > crowdsaleEnd && raised < minAmount ? balances[_owner] : 0;\n', '    }\n', '\n', '\n', '    /**\n', '     * Returns the current phase based on the current time\n', '     *\n', '     * @return The index of the current phase\n', '     */\n', '    function getCurrentPhase() public view returns (uint) {\n', '        for (uint i = 0; i < phases.length; i++) {\n', '            if (now <= phases[i].end) {\n', '                return i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        return uint(-1); // Does not exist (underflow)\n', '    }\n', '\n', '\n', '    /**\n', '     * Returns the rate and bonus release date\n', '     *\n', '     * @param _phase The phase to use while determining the rate\n', '     * @param _volume The amount wei used to determin what volume multiplier to use\n', '     * @return The rate used in `_phase` multiplied by the corresponding volume multiplier\n', '     */\n', '    function getRate(uint _phase, uint _volume) public view returns (uint) {\n', '        uint rate = 0;\n', '        if (stage == Stages.InProgress && now >= start) {\n', '            Phase storage phase = phases[_phase];\n', '            rate = phase.rate;\n', '\n', '            // Find volume multiplier\n', '            if (phase.useVolumeMultiplier && volumeMultiplierThresholds.length > 0 && _volume >= volumeMultiplierThresholds[0]) {\n', '                for (uint i = volumeMultiplierThresholds.length; i > 0; i--) {\n', '                    if (_volume >= volumeMultiplierThresholds[i - 1]) {\n', '                        VolumeMultiplier storage multiplier = volumeMultipliers[volumeMultiplierThresholds[i - 1]];\n', '                        rate += phase.rate * multiplier.rateMultiplier / percentageDenominator;\n', '                        break;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        \n', '        return rate;\n', '    }\n', '\n', '\n', '    /**\n', '     * Get distribution data based on the current phase and \n', '     * the volume in wei that is being distributed\n', '     * \n', '     * @param _phase The current crowdsale phase\n', '     * @param _volume The amount wei used to determine what volume multiplier to use\n', '     * @return Volumes and corresponding release dates\n', '     */\n', '    function getDistributionData(uint _phase, uint _volume) internal view returns (uint[], uint[]) {\n', '        Phase storage phase = phases[_phase];\n', '        uint remainingVolume = _volume;\n', '\n', '        bool usingMultiplier = false;\n', '        uint[] memory volumes = new uint[](1);\n', '        uint[] memory releaseDates = new uint[](1);\n', '\n', '        // Find volume multipliers\n', '        if (phase.useVolumeMultiplier && volumeMultiplierThresholds.length > 0 && _volume >= volumeMultiplierThresholds[0]) {\n', '            uint phaseReleasePeriod = phase.bonusReleaseDate - crowdsaleEnd;\n', '            for (uint i = volumeMultiplierThresholds.length; i > 0; i--) {\n', '                if (_volume >= volumeMultiplierThresholds[i - 1]) {\n', '                    if (!usingMultiplier) {\n', '                        volumes = new uint[](i + 1);\n', '                        releaseDates = new uint[](i + 1);\n', '                        usingMultiplier = true;\n', '                    }\n', '\n', '                    VolumeMultiplier storage multiplier = volumeMultipliers[volumeMultiplierThresholds[i - 1]];\n', '                    uint releaseDate = phase.bonusReleaseDate + phaseReleasePeriod * multiplier.bonusReleaseDateMultiplier / percentageDenominator;\n', '                    uint volume = remainingVolume - volumeMultiplierThresholds[i - 1];\n', '\n', '                    // Store increment\n', '                    volumes[i] = volume;\n', '                    releaseDates[i] = releaseDate;\n', '\n', '                    remainingVolume -= volume;\n', '                }\n', '            }\n', '        }\n', '\n', '        // Store increment\n', '        volumes[0] = remainingVolume;\n', '        releaseDates[0] = phase.bonusReleaseDate;\n', '\n', '        return (volumes, releaseDates);\n', '    }\n', '\n', '\n', '    /**\n', '     * Convert `_wei` to an amount in tokens using \n', '     * the `_rate`\n', '     *\n', '     * @param _wei amount of wei to convert\n', '     * @param _rate rate to use for the conversion\n', '     * @return Amount in tokens\n', '     */\n', '    function toTokens(uint _wei, uint _rate) public view returns (uint) {\n', '        return _wei * _rate * tokenDenominator / 1 ether;\n', '    }\n', '\n', '\n', '    /**\n', '     * Receive Eth and issue tokens to the sender\n', '     * \n', "     * This function requires that msg.sender is not a contract. This is required because it's \n", '     * not possible for a contract to specify a gas amount when calling the (internal) send() \n', '     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\n', '     * \n', '     * Contracts can call the contribute() function instead\n', '     */\n', '    function () public payable {\n', '        require(msg.sender == tx.origin);\n', '        _handleTransaction(msg.sender, msg.value);\n', '    }\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to the sender\n', '     *\n', '     * @return The accepted ether amount\n', '     */\n', '    function contribute() public payable returns (uint) {\n', '        return _handleTransaction(msg.sender, msg.value);\n', '    }\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to `_beneficiary`\n', '     *\n', '     * @param _beneficiary The account that receives the tokens\n', '     * @return The accepted ether amount\n', '     */\n', '    function contributeFor(address _beneficiary) public payable returns (uint) {\n', '        return _handleTransaction(_beneficiary, msg.value);\n', '    }\n', '\n', '\n', '    /**\n', '     * Function to end the crowdsale by setting \n', '     * the stage to Ended\n', '     */\n', '    function endCrowdsale() public at_stage(Stages.InProgress) {\n', '        require(now > crowdsaleEnd || raised >= maxAmount);\n', '        require(raised >= minAmount);\n', '        stage = Stages.Ended;\n', '\n', '        // Unlock token\n', '        if (!token.unlock()) {\n', '            revert();\n', '        }\n', '\n', '        // Allocate tokens (no allocation can be done after this period)\n', '        uint totalTokenSupply = IToken(token).totalSupply() + allocatedTokens;\n', '        for (uint i = 0; i < stakeholdersPayouts.length; i++) {\n', '            Payout storage p = stakeholdersPayouts[i];\n', '            _allocateStakeholdersTokens(totalTokenSupply * p.percentage / percentageDenominator, now + p.vestingPeriod);\n', '        }\n', '\n', '        // Allocate remaining ETH\n', '        _allocateStakeholdersEth(this.balance - allocatedEth, 0);\n', '    }\n', '\n', '\n', '    /**\n', '     * Withdraw allocated tokens\n', '     */\n', '    function withdrawTokens() public {\n', '        withdrawTokensTo(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * Withdraw allocated tokens\n', '     *\n', '     * @param _beneficiary Address to send to\n', '     */\n', '    function withdrawTokensTo(address _beneficiary) public {\n', '        uint tokensToSend = 0;\n', '        for (uint i = 0; i < allocatedIndex[msg.sender].length; i++) {\n', '            uint releaseDate = allocatedIndex[msg.sender][i];\n', '            if (releaseDate <= now) {\n', '                Balance storage b = allocated[msg.sender][releaseDate];\n', '                tokensToSend += b.tokens;\n', '                b.tokens = 0;\n', '            }\n', '        }\n', '\n', '        if (tokensToSend > 0) {\n', '            allocatedTokens -= tokensToSend;\n', '            if (!token.issue(_beneficiary, tokensToSend)) {\n', '                revert();\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Withdraw allocated ether\n', '     */\n', '    function withdrawEther() public {\n', '        withdrawEtherTo(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * Withdraw allocated ether\n', '     *\n', '     * @param _beneficiary Address to send to\n', '     */\n', '    function withdrawEtherTo(address _beneficiary) public {\n', '        uint ethToSend = 0;\n', '        for (uint i = 0; i < allocatedIndex[msg.sender].length; i++) {\n', '            uint releaseDate = allocatedIndex[msg.sender][i];\n', '            if (releaseDate <= now) {\n', '                Balance storage b = allocated[msg.sender][releaseDate];\n', '                ethToSend += b.eth;\n', '                b.eth = 0;\n', '            }\n', '        }\n', '\n', '        if (ethToSend > 0) {\n', '            allocatedEth -= ethToSend;\n', '            if (!_beneficiary.send(ethToSend)) {\n', '                revert();\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Refund in the case of an unsuccessful crowdsale. The \n', '     * crowdsale is considered unsuccessful if minAmount was \n', '     * not raised before end of the crowdsale\n', '     */\n', '    function refund() public only_after_crowdsale at_stage(Stages.InProgress) {\n', '        refundTo(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * Refund in the case of an unsuccessful crowdsale. The \n', '     * crowdsale is considered unsuccessful if minAmount was \n', '     * not raised before end of the crowdsale\n', '     *\n', '     * @param _beneficiary Address to send to\n', '     */\n', '    function refundTo(address _beneficiary) public only_after_crowdsale at_stage(Stages.InProgress) {\n', '        require(raised < minAmount);\n', '\n', '        uint receivedAmount = balances[msg.sender];\n', '        balances[msg.sender] = 0;\n', '\n', '        if (receivedAmount > 0 && !_beneficiary.send(receivedAmount)) {\n', '            balances[msg.sender] = receivedAmount;\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Failsafe and clean-up mechanism\n', '     */\n', '    function destroy() public only_beneficiary only_after(2 years) {\n', '        selfdestruct(beneficiary);\n', '    }\n', '\n', '\n', '    /**\n', '     * Handle incoming transaction\n', '     * \n', '     * @param _beneficiary Tokens are issued to this account\n', '     * @param _received The amount that was received\n', '     * @return The accepted ether amount\n', '     */\n', '    function _handleTransaction(address _beneficiary, uint _received) internal at_stage(Stages.InProgress) returns (uint) {\n', '        require(now >= start && now <= crowdsaleEnd);\n', '        require(isAcceptingContributions());\n', '        require(isAcceptedContributor(_beneficiary));\n', '\n', '        if (isInPresalePhase()) {\n', '            return _handlePresaleTransaction(\n', '                _beneficiary, _received);\n', '        } else {\n', '            return _handlePublicsaleTransaction(\n', '                _beneficiary, _received);\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Handle incoming transaction during the presale phase\n', '     * \n', '     * @param _beneficiary Tokens are issued to this account\n', '     * @param _received The amount that was received\n', '     * @return The accepted ether amount\n', '     */\n', '    function _handlePresaleTransaction(address _beneficiary, uint _received) private returns (uint) {\n', '        require(_received >= minAcceptedAmountPresale);\n', '        require(raised < maxAmountPresale);\n', '\n', '        uint acceptedAmount;\n', '        if (raised + _received > maxAmountPresale) {\n', '            acceptedAmount = maxAmountPresale - raised;\n', '        } else {\n', '            acceptedAmount = _received;\n', '        }\n', '\n', '        raised += acceptedAmount;\n', '\n', '        // During the presale phase - Non refundable\n', '        _allocateStakeholdersEth(acceptedAmount, 0); \n', '\n', '        // Issue tokens\n', '        _distributeTokens(_beneficiary, _received, acceptedAmount);\n', '        return acceptedAmount;\n', '    }\n', '\n', '\n', '    /**\n', '     * Handle incoming transaction during the publicsale phase\n', '     * \n', '     * @param _beneficiary Tokens are issued to this account\n', '     * @param _received The amount that was received\n', '     * @return The accepted ether amount\n', '     */\n', '    function _handlePublicsaleTransaction(address _beneficiary, uint _received) private returns (uint) {\n', '        require(_received >= minAcceptedAmount);\n', '        require(raised >= minAmountPresale);\n', '        require(raised < maxAmount);\n', '\n', '        uint acceptedAmount;\n', '        if (raised + _received > maxAmount) {\n', '            acceptedAmount = maxAmount - raised;\n', '        } else {\n', '            acceptedAmount = _received;\n', '        }\n', '\n', '        raised += acceptedAmount;\n', '        \n', '        // During the ICO phase - 100% refundable\n', '        balances[_beneficiary] += acceptedAmount; \n', '\n', '        // Issue tokens\n', '        _distributeTokens(_beneficiary, _received, acceptedAmount);\n', '        return acceptedAmount;\n', '    }\n', '\n', '\n', '    /**\n', '     * Distribute tokens \n', '     *\n', '     * Tokens can be issued by instructing the token contract to create new tokens or by \n', '     * allocating tokens and instructing the token contract to create the tokens later\n', '     * \n', '     * @param _beneficiary Tokens are issued to this account\n', '     * @param _received The amount that was received\n', '     * @param _acceptedAmount The amount that was accepted\n', '     */\n', '    function _distributeTokens(address _beneficiary, uint _received, uint _acceptedAmount) private {\n', '        uint tokensToIssue = 0;\n', '        uint phase = getCurrentPhase();\n', '        var rate = getRate(phase, _acceptedAmount);\n', '        if (rate == 0) {\n', '            revert(); // Paused phase\n', '        }\n', '\n', '        // Volume multipliers\n', '        var (volumes, releaseDates) = getDistributionData(\n', '            phase, _acceptedAmount);\n', '        \n', '        // Allocate tokens\n', '        for (uint i = 0; i < volumes.length; i++) {\n', '            var tokensAtCurrentRate = toTokens(volumes[i], rate);\n', '            if (rate > baseRate && releaseDates[i] > now) {\n', '                uint bonusTokens = tokensAtCurrentRate * (rate - baseRate) / rate;\n', '                _allocateTokens(_beneficiary, bonusTokens, releaseDates[i]);\n', '\n', '                tokensToIssue += tokensAtCurrentRate - bonusTokens;\n', '            } else {\n', '                tokensToIssue += tokensAtCurrentRate;\n', '            }\n', '        }\n', '\n', '        // Issue tokens\n', '        if (tokensToIssue > 0 && !token.issue(_beneficiary, tokensToIssue)) {\n', '            revert();\n', '        }\n', '\n', '        // Refund due to max cap hit\n', '        if (_received - _acceptedAmount > 0 && !_beneficiary.send(_received - _acceptedAmount)) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Allocate ETH\n', '     *\n', '     * @param _beneficiary The account to alocate the eth for\n', '     * @param _amount The amount of ETH to allocate\n', '     * @param _releaseDate The date after which the eth can be withdrawn\n', '     */    \n', '    function _allocateEth(address _beneficiary, uint _amount, uint _releaseDate) internal {\n', '        if (hasBalance(_beneficiary, _releaseDate)) {\n', '            allocated[_beneficiary][_releaseDate].eth += _amount;\n', '        } else {\n', '            allocated[_beneficiary][_releaseDate] = Balance(\n', '                _amount, 0, allocatedIndex[_beneficiary].push(_releaseDate) - 1);\n', '        }\n', '\n', '        allocatedEth += _amount;\n', '    }\n', '\n', '\n', '    /**\n', '     * Allocate Tokens\n', '     *\n', '     * @param _beneficiary The account to allocate the tokens for\n', '     * @param _amount The amount of tokens to allocate\n', '     * @param _releaseDate The date after which the tokens can be withdrawn\n', '     */    \n', '    function _allocateTokens(address _beneficiary, uint _amount, uint _releaseDate) internal {\n', '        if (hasBalance(_beneficiary, _releaseDate)) {\n', '            allocated[_beneficiary][_releaseDate].tokens += _amount;\n', '        } else {\n', '            allocated[_beneficiary][_releaseDate] = Balance(\n', '                0, _amount, allocatedIndex[_beneficiary].push(_releaseDate) - 1);\n', '        }\n', '\n', '        allocatedTokens += _amount;\n', '    }\n', '\n', '\n', '    /**\n', '     * Allocate ETH for stakeholders\n', '     *\n', '     * @param _amount The amount of ETH to allocate\n', '     * @param _releaseDate The date after which the eth can be withdrawn\n', '     */    \n', '    function _allocateStakeholdersEth(uint _amount, uint _releaseDate) internal {\n', '        for (uint i = 0; i < stakeholderPercentagesIndex.length; i++) {\n', '            Percentage storage p = stakeholderPercentages[stakeholderPercentagesIndex[i]];\n', '            if (p.eth > 0) {\n', '                _allocateEth(stakeholderPercentagesIndex[i], _amount * p.eth / percentageDenominator, _releaseDate);\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Allocate Tokens for stakeholders\n', '     *\n', '     * @param _amount The amount of tokens created\n', '     * @param _releaseDate The date after which the tokens can be withdrawn (unless overwitten)\n', '     */    \n', '    function _allocateStakeholdersTokens(uint _amount, uint _releaseDate) internal {\n', '        for (uint i = 0; i < stakeholderPercentagesIndex.length; i++) {\n', '            Percentage storage p = stakeholderPercentages[stakeholderPercentagesIndex[i]];\n', '            if (p.tokens > 0) {\n', '                _allocateTokens(\n', '                    stakeholderPercentagesIndex[i], \n', '                    _amount * p.tokens / percentageDenominator, \n', '                    p.overwriteReleaseDate ? p.fixedReleaseDate : _releaseDate);\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Allows the implementing contract to validate a \n', '     * contributing account\n', '     *\n', '     * @param _contributor Address that is being validated\n', '     * @return Wheter the contributor is accepted or not\n', '     */\n', '    function isAcceptedContributor(address _contributor) internal view returns (bool);\n', '\n', '\n', '    /**\n', '     * Allows the implementing contract to prevent the accepting \n', '     * of contributions\n', '     *\n', '     * @return Wheter contributions are accepted or not\n', '     */\n', '    function isAcceptingContributions() internal view returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * MoxyOne Crowdsale\n', ' *\n', ' * Advancing the blockchain industry by creating seamless and secure debit card \n', ' * and payment infrastructure for every company, project and ICO that issues cryptocurrency tokens. \n', ' *\n', ' * #created 06/01/2018\n', ' * #author Frank Bonnet\n', ' */\n', 'contract MoxyOneCrowdsale is Crowdsale, TokenRetriever, IPausable, IAuthenticationManager, IWingsAdapter {\n', '\n', '    // State\n', '    bool private paused;\n', '\n', '    // Authentication\n', '    IAuthenticator private authenticator;\n', '    bool private requireAuthentication;\n', '\n', '\n', '    /**\n', '     * Returns whether the implementing contract is \n', '     * currently paused or not\n', '     *\n', '     * @return Whether the paused state is active\n', '     */\n', '    function isPaused() public view returns (bool) {\n', '        return paused;\n', '    }\n', '\n', '\n', '    /**\n', '     * Change the state to paused\n', '     */\n', '    function pause() public only_owner {\n', '        paused = true;\n', '    }\n', '\n', '\n', '    /**\n', '     * Change the state to resume, undo the effects \n', '     * of calling pause\n', '     */\n', '    function resume() public only_owner {\n', '        paused = false;\n', '    }\n', '\n', '\n', '    /**\n', '     * Setup authentication\n', '     *\n', '     * @param _authenticator The address of the authenticator (whitelist)\n', '     * @param _requireAuthentication Wether the crowdale requires contributors to be authenticated\n', '     */\n', '    function setupAuthentication(address _authenticator, bool _requireAuthentication) public only_owner at_stage(Stages.Deploying) {\n', '        authenticator = IAuthenticator(_authenticator);\n', '        requireAuthentication = _requireAuthentication;\n', '    }\n', '\n', '\n', '    /**\n', '     * Returns true if authentication is enabled and false \n', '     * otherwise\n', '     *\n', '     * @return Whether the converter is currently authenticating or not\n', '     */\n', '    function isAuthenticating() public view returns (bool) {\n', '        return requireAuthentication;\n', '    }\n', '\n', '\n', '    /**\n', '     * Enable authentication\n', '     */\n', '    function enableAuthentication() public only_owner {\n', '        requireAuthentication = true;\n', '    }\n', '\n', '\n', '    /**\n', '     * Disable authentication\n', '     */\n', '    function disableAuthentication() public only_owner {\n', '        requireAuthentication = false;\n', '    }\n', '\n', '\n', '    /**\n', '     * Validate a contributing account\n', '     *\n', '     * @param _contributor Address that is being validated\n', '     * @return Wheter the contributor is accepted or not\n', '     */\n', '    function isAcceptedContributor(address _contributor) internal view returns (bool) {\n', '        return !requireAuthentication || authenticator.authenticate(_contributor);\n', '    }\n', '\n', '\n', '    /**\n', '     * Indicate if contributions are currently accepted\n', '     *\n', '     * @return Wheter contributions are accepted or not\n', '     */\n', '    function isAcceptingContributions() internal view returns (bool) {\n', '        return !paused;\n', '    }\n', '\n', '\n', '    /**\n', '     * Wings integration - Get the total raised amount of Ether\n', '     *\n', '     * Can only increased, means if you withdraw ETH from the wallet, should be not modified (you can use two fields \n', '     * to keep one with a total accumulated amount) amount of ETH in contract and totalCollected for total amount of ETH collected\n', '     *\n', '     * @return Total raised Ether amount\n', '     */\n', '    function totalCollected() public view returns (uint) {\n', '        return raised;\n', '    }\n', '\n', '\n', '    /**\n', '     * Failsafe mechanism\n', '     * \n', '     * Allows the owner to retrieve tokens from the contract that \n', '     * might have been send there by accident\n', '     *\n', '     * @param _tokenContract The address of ERC20 compatible token\n', '     */\n', '    function retrieveTokens(address _tokenContract) public only_owner {\n', '        super.retrieveTokens(_tokenContract);\n', '\n', '        // Retrieve tokens from our token contract\n', '        ITokenRetriever(token).retrieveTokens(_tokenContract);\n', '    }\n', '}']