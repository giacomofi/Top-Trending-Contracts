['pragma solidity ^0.4.17;\n', '\n', 'contract AccessControl {\n', '    address public creatorAddress;\n', '    uint16 public totalSeraphims = 0;\n', '    mapping (address => bool) public seraphims;\n', '\n', '    bool public isMaintenanceMode = true;\n', ' \n', '    modifier onlyCREATOR() {\n', '        require(msg.sender == creatorAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlySERAPHIM() {\n', '        require(seraphims[msg.sender] == true);\n', '        _;\n', '    }\n', '    \n', '    modifier isContractActive {\n', '        require(!isMaintenanceMode);\n', '        _;\n', '    }\n', '    \n', '    // Constructor\n', '    function AccessControl() public {\n', '        creatorAddress = msg.sender;\n', '    }\n', '    \n', '\n', '    function addSERAPHIM(address _newSeraphim) onlyCREATOR public {\n', '        if (seraphims[_newSeraphim] == false) {\n', '            seraphims[_newSeraphim] = true;\n', '            totalSeraphims += 1;\n', '        }\n', '    }\n', '    \n', '    function removeSERAPHIM(address _oldSeraphim) onlyCREATOR public {\n', '        if (seraphims[_oldSeraphim] == true) {\n', '            seraphims[_oldSeraphim] = false;\n', '            totalSeraphims -= 1;\n', '        }\n', '    }\n', '\n', '    function updateMaintenanceMode(bool _isMaintaining) onlyCREATOR public {\n', '        isMaintenanceMode = _isMaintaining;\n', '    }\n', '\n', '  \n', '} \n', '\n', '\n', 'contract IBattleboardData is AccessControl  {\n', '\n', '  \n', '\n', '      // write functions\n', '  \n', 'function createBattleboard(uint prize, uint8 restrictions) onlySERAPHIM external returns (uint16);\n', 'function killMonster(uint16 battleboardId, uint8 monsterId)  onlySERAPHIM external;\n', 'function createNullTile(uint16 _battleboardId) private ;\n', 'function createTile(uint16 _battleboardId, uint8 _tileType, uint8 _value, uint8 _position, uint32 _hp, uint16 _petPower, uint64 _angelId, uint64 _petId, address _owner, uint8 _team) onlySERAPHIM external  returns (uint8);\n', 'function killTile(uint16 battleboardId, uint8 tileId) onlySERAPHIM external ;\n', 'function addTeamtoBoard(uint16 battleboardId, address owner, uint8 team) onlySERAPHIM external;\n', 'function setTilePosition (uint16 battleboardId, uint8 tileId, uint8 _positionTo) onlySERAPHIM public ;\n', 'function setTileHp(uint16 battleboardId, uint8 tileId, uint32 _hp) onlySERAPHIM external ;\n', 'function addMedalBurned(uint16 battleboardId) onlySERAPHIM external ;\n', 'function setLastMoveTime(uint16 battleboardId) onlySERAPHIM external ;\n', 'function iterateTurn(uint16 battleboardId) onlySERAPHIM external ;\n', 'function killBoard(uint16 battleboardId) onlySERAPHIM external ;\n', 'function clearAngelsFromBoard(uint16 battleboardId) private;\n', '//Read functions\n', '     \n', 'function getTileHp(uint16 battleboardId, uint8 tileId) constant external returns (uint32) ;\n', 'function getMedalsBurned(uint16 battleboardId) constant external returns (uint8) ;\n', 'function getTeam(uint16 battleboardId, uint8 tileId) constant external returns (uint8) ;\n', 'function getMaxFreeTeams() constant public returns (uint8);\n', 'function getBarrierNum(uint16 battleboardId) public constant returns (uint8) ;\n', 'function getTileFromBattleboard(uint16 battleboardId, uint8 tileId) public constant returns (uint8 tileType, uint8 value, uint8 id, uint8 position, uint32 hp, uint16 petPower, uint64 angelId, uint64 petId, bool isLive, address owner)   ;\n', 'function getTileIDByOwner(uint16 battleboardId, address _owner) constant public returns (uint8) ;\n', 'function getPetbyTileId( uint16 battleboardId, uint8 tileId) constant public returns (uint64) ;\n', 'function getOwner (uint16 battleboardId, uint8 team,  uint8 ownerNumber) constant external returns (address);\n', 'function getTileIDbyPosition(uint16 battleboardId, uint8 position) public constant returns (uint8) ;\n', 'function getPositionFromBattleboard(uint16 battleboardId, uint8 _position) public constant returns (uint8 tileType, uint8 value, uint8 id, uint8 position, uint32 hp, uint32 petPower, uint64 angelId, uint64 petId, bool isLive)  ;\n', 'function getBattleboard(uint16 id) public constant returns (uint8 turn, bool isLive, uint prize, uint8 numTeams, uint8 numTiles, uint8 createdBarriers, uint8 restrictions, uint lastMoveTime, uint8 numTeams1, uint8 numTeams2, uint8 monster1, uint8 monster2) ;\n', 'function isBattleboardLive(uint16 battleboardId) constant public returns (bool);\n', 'function isTileLive(uint16 battleboardId, uint8 tileId) constant  external returns (bool) ;\n', 'function getLastMoveTime(uint16 battleboardId) constant public returns (uint) ;\n', 'function getNumTilesFromBoard (uint16 _battleboardId) constant public returns (uint8) ; \n', 'function angelOnBattleboards(uint64 angelID) external constant returns (bool) ;\n', 'function getTurn(uint16 battleboardId) constant public returns (address) ;\n', 'function getNumTeams(uint16 battleboardId, uint8 team) public constant returns (uint8);\n', 'function getMonsters(uint16 BattleboardId) external constant returns (uint8 monster1, uint8 monster2) ;\n', 'function getTotalBattleboards() public constant returns (uint16) ;\n', '  \n', '        \n', ' \n', '   \n', '}\n', '\n', 'contract BattleboardData is IBattleboardData  {\n', '\n', '    /*** DATA TYPES ***/\n', '       \n', '  \n', '  //Most main pieces on the board are tiles.   \n', '      struct Tile {\n', '        uint8 tileType;\n', '        uint8 value; //speed for angels, otherwise value of other types. \n', '        uint8 id;\n', '        uint8 position;\n', '        uint32 hp;\n', '        uint16 petPower;\n', '        uint8 team; //which team they are on. \n', '        uint64 angelId;\n', '        uint64 petId;\n', '        bool isLive;\n', '        address owner;\n', '        \n', '    }\n', '    \n', '      struct Battleboard {\n', '        uint8 turn; //turn number - turn 0 is the first player who enters the board. \n', '        address[] players;\n', '        bool isLive;\n', '        uint prize;\n', '        uint16 id;\n', '        uint8 numTeams; //number of angel/pet teams on the board, different than TEAM1 vs TEAM2\n', '        uint8 numTiles;\n', '        uint8 createdBarriers;\n', '        uint8 restrictions; //number of which angels can be added. \n', '        uint lastMoveTime;\n', '        address[] team1;\n', '        address[] team2; //addresses of the owners of teams 1 and 2\n', '        uint8 numTeams1;\n', '        uint8 numTeams2;\n', '        uint8 monster1; //tile number of the monster locations. \n', '        uint8 monster2;\n', '        uint8 medalsBurned;\n', '    }\n', '\n', '    //main storage\n', '    Battleboard []  Battleboards;\n', '    \n', '    uint16 public totalBattleboards;\n', '    \n', '    uint8 maxFreeTeams = 6;\n', '    uint8 maxPaidTeams = 4;\n', '    \n', '    //Each angel can only be on one board at a time. \n', '    mapping (uint64 => bool) angelsOnBattleboards; \n', '\n', '    //Map the battleboard ID to an array of all tiles on that board. \n', '    mapping (uint32 => Tile[]) TilesonBoard;\n', '    \n', '    //for each battleboardId(uint16) there is a number with the tileId of the tile. TileId 0 means blank. \n', '    mapping (uint16 => uint8 [64]) positionsTiles;\n', '    \n', '    \n', '    \n', '      // write functions\n', '  \n', '       function createBattleboard(uint prize, uint8 restrictions) onlySERAPHIM external returns (uint16) {\n', '           Battleboard memory battleboard;\n', '           battleboard.restrictions = restrictions;\n', '           battleboard.isLive = false; //will be live once ALL teams are added. \n', '           battleboard.prize = prize;\n', '           battleboard.id = totalBattleboards;\n', '           battleboard.numTeams = 0;\n', '           battleboard.lastMoveTime = now;\n', '           totalBattleboards += 1;\n', '           battleboard.numTiles = 0;\n', '          //set the monster positions\n', '           battleboard.monster1 = getRandomNumber(30,17,1);\n', '           battleboard.monster2 = getRandomNumber(48,31,2); \n', '           Battleboards.push(battleboard);\n', '          createNullTile(totalBattleboards-1);\n', '           return (totalBattleboards - 1);\n', '       }\n', '       \n', '         \n', '      \n', '      function killMonster(uint16 battleboardId, uint8 monsterId)  onlySERAPHIM external{\n', '          if (monsterId == 1) {\n', '              Battleboards[battleboardId].monster1 = 0;\n', '          }\n', '          if (monsterId ==2) {\n', '               Battleboards[battleboardId].monster2 = 0;\n', '          }\n', '      }\n', '        \n', '        function createNullTile(uint16 _battleboardId) private    {\n', '      //We need to create a tile with ID 0 that won&#39;t be on the board. This lets us know if any other tile is ID 0 then that means it&#39;s a blank tile. \n', '        if ((_battleboardId <0) || (_battleboardId > totalBattleboards)) {revert();}\n', '        Tile memory tile ;\n', '        tile.tileType = 0; \n', '        tile.id = 0;\n', '        tile.isLive = true;\n', '        TilesonBoard[_battleboardId].push(tile);\n', '     \n', '    }\n', '        \n', '        function createTile(uint16 _battleboardId, uint8 _tileType, uint8 _value, uint8 _position, uint32 _hp, uint16 _petPower, uint64 _angelId, uint64 _petId, address _owner, uint8 _team) onlySERAPHIM external  returns (uint8)   {\n', '      //main function to create a tile and add it to the board. \n', '        if ((_battleboardId <0) || (_battleboardId > totalBattleboards)) {revert();}\n', '        if ((angelsOnBattleboards[_angelId] == true) && (_angelId != 0)) {revert();}\n', '        angelsOnBattleboards[_angelId] = true;\n', '        Tile memory tile ;\n', '        tile.tileType = _tileType; \n', '        tile.value = _value;\n', '        tile.position= _position;\n', '        tile.hp = _hp;\n', '        Battleboards[_battleboardId].numTiles +=1;\n', '        tile.id = Battleboards[_battleboardId].numTiles;\n', '        positionsTiles[_battleboardId][_position+1] = tile.id;\n', '        tile.petPower = _petPower;\n', '        tile.angelId = _angelId;\n', '        tile.petId = _petId;\n', '        tile.owner = _owner;\n', '        tile.team = _team;\n', '        tile.isLive = true;\n', '        TilesonBoard[_battleboardId].push(tile);\n', '        return (Battleboards[_battleboardId].numTiles);\n', '    }\n', '     \n', '     function killTile(uint16 battleboardId, uint8 tileId) onlySERAPHIM external {\n', '     \n', '      TilesonBoard[battleboardId][tileId].isLive= false;\n', '      TilesonBoard[battleboardId][tileId].tileType= 0;\n', '      for (uint i =0; i< Battleboards[battleboardId].team1.length; i++) {\n', '          if (Battleboards[battleboardId].team1[i] == TilesonBoard[battleboardId][tileId].owner) {\n', '             //should be safe because a team can&#39;t be killed if there are 0 teams to kill. \n', '             Battleboards[battleboardId].numTeams1 -= 1; \n', '          }\n', '      }\n', '      for (i =0; i< Battleboards[battleboardId].team2.length; i++) {\n', '          if (Battleboards[battleboardId].team2[i] == TilesonBoard[battleboardId][tileId].owner) {\n', '             //should be safe because a team can&#39;t be killed if there are 0 teams to kill. \n', '             Battleboards[battleboardId].numTeams2 -= 1; \n', '          }\n', '      }\n', '    }\n', '     \n', '     function addTeamtoBoard(uint16 battleboardId, address owner, uint8 team) onlySERAPHIM external {\n', '        \n', '        //Can&#39;t add a team if the board is live, or if the board is already full of teams. \n', '         if (Battleboards[battleboardId].isLive == true) {revert();}\n', '         if ((Battleboards[battleboardId].prize == 0) &&(Battleboards[battleboardId].numTeams == maxFreeTeams)) {revert();}\n', '         if ((Battleboards[battleboardId].prize != 0) &&(Battleboards[battleboardId].numTeams == maxPaidTeams)) {revert();}\n', '         \n', '         //only one team per address can be on the board. \n', '         for (uint i =0; i<Battleboards[battleboardId].numTeams; i++) {\n', '             if (Battleboards[battleboardId].players[i] == owner) {revert();}\n', '         }\n', '         Battleboards[battleboardId].numTeams += 1;\n', '         Battleboards[battleboardId].players.push(owner);\n', '         \n', '         if (team == 1) {\n', '         Battleboards[battleboardId].numTeams1 += 1;\n', '         Battleboards[battleboardId].team1.push(owner);\n', '         }\n', '         if (team == 2) {\n', '         Battleboards[battleboardId].numTeams2 += 1;\n', '         Battleboards[battleboardId].team2.push(owner);\n', '         \n', '         //if the board is now full, then go ahead and make it live. \n', '         if ((Battleboards[battleboardId].numTeams1 == 3) && (Battleboards[battleboardId].numTeams2 ==3)) {Battleboards[battleboardId].isLive = true;}\n', '        if ((Battleboards[battleboardId].prize != 0) &&(Battleboards[battleboardId].numTeams == maxPaidTeams)) {Battleboards[battleboardId].isLive = true;}\n', '         }\n', '          \n', '     }\n', '       \n', '        function setTilePosition (uint16 battleboardId, uint8 tileId, uint8 _positionTo) onlySERAPHIM public  {\n', '            uint8 oldPos = TilesonBoard[battleboardId][tileId].position;\n', '            positionsTiles[battleboardId][oldPos+1] = 0;\n', '            TilesonBoard[battleboardId][tileId].position = _positionTo;\n', '            positionsTiles[battleboardId][_positionTo+1] = tileId;\n', '            \n', '        }\n', '        \n', '        function setTileHp(uint16 battleboardId, uint8 tileId, uint32 _hp) onlySERAPHIM external {\n', '            TilesonBoard[battleboardId][tileId].hp = _hp;\n', '        }\n', '        \n', '          function addMedalBurned(uint16 battleboardId) onlySERAPHIM external {\n', '            Battleboards[battleboardId].medalsBurned += 1;\n', '        }\n', '        \n', '        function withdrawEther()  onlyCREATOR external {\n', '   //shouldn&#39;t have any eth here but just in case. \n', '    creatorAddress.transfer(this.balance);\n', '}\n', '\n', 'function setLastMoveTime(uint16 battleboardId) onlySERAPHIM external {\n', '        Battleboards[battleboardId].lastMoveTime = now;\n', '        \n', '        \n', '    }\n', '    \n', '      function iterateTurn(uint16 battleboardId) onlySERAPHIM external {\n', '            if (Battleboards[battleboardId].turn  == (Battleboards[battleboardId].players.length-1)) {\n', '                Battleboards[battleboardId].turn = 0;\n', '            } \n', '            else {Battleboards[battleboardId].turn += 1;}\n', '        }\n', '        \n', '         function killBoard(uint16 battleboardId) onlySERAPHIM external {\n', '           Battleboards[battleboardId].isLive = false;\n', '           clearAngelsFromBoard(battleboardId);\n', '       }\n', '    \n', '    \n', '        function clearAngelsFromBoard(uint16 battleboardId) private {\n', '         //Free up angels to be used on other boards. \n', '         for (uint i = 0; i < Battleboards[battleboardId].numTiles; i++) {\n', '            if (TilesonBoard[battleboardId][i].angelId != 0) {\n', '                angelsOnBattleboards[TilesonBoard[battleboardId][i].angelId] = false;\n', '              }\n', '         } \n', '  \n', '    }\n', '\n', '//Read functions\n', '     \n', '        function getTileHp(uint16 battleboardId, uint8 tileId) constant external returns (uint32) {\n', '            return TilesonBoard[battleboardId][tileId].hp;\n', '        }\n', '        \n', '      \n', '        function getMedalsBurned(uint16 battleboardId) constant external returns (uint8) {\n', '            return Battleboards[battleboardId].medalsBurned;\n', '        }\n', '  \n', ' \n', ' function getTeam(uint16 battleboardId, uint8 tileId) constant external returns (uint8) {\n', '     return TilesonBoard[battleboardId][tileId].team;\n', ' }\n', '        \n', '\n', '\n', 'function getRandomNumber(uint16 maxRandom, uint8 min, address privateAddress) constant public returns(uint8) {\n', '        uint256 genNum = uint256(block.blockhash(block.number-1)) + uint256(privateAddress);\n', '        return uint8(genNum % (maxRandom - min + 1)+min);\n', '        }\n', '\n', '       \n', '       function getMaxFreeTeams() constant public returns (uint8) {\n', '          return maxFreeTeams;\n', '       }\n', '  \n', '        function getBarrierNum(uint16 battleboardId) public constant returns (uint8) {\n', '            return Battleboards[battleboardId].createdBarriers;\n', '        }\n', '\n', '    // Call to get the specified tile at a certain position of a certain board. \n', '   function getTileFromBattleboard(uint16 battleboardId, uint8 tileId) public constant returns (uint8 tileType, uint8 value, uint8 id, uint8 position, uint32 hp, uint16 petPower, uint64 angelId, uint64 petId, bool isLive, address owner)   {\n', '      \n', '        if ((battleboardId <0) ||  (battleboardId > totalBattleboards)) {revert();}\n', '        Battleboard memory battleboard = Battleboards[battleboardId];\n', '        Tile memory tile;\n', '        if ((tileId <0) || (tileId> battleboard.numTiles)) {revert();}\n', '        tile = TilesonBoard[battleboardId][tileId];\n', '        tileType = tile.tileType; \n', '        value = tile.value;\n', '        id= tile.id;\n', '        position = tile.position;\n', '        hp = tile.hp;\n', '        petPower = tile.petPower;\n', '        angelId = tile.angelId;\n', '        petId = tile.petId;\n', '        owner = tile.owner;\n', '        isLive = tile.isLive;\n', '        \n', '    }\n', '    \n', '    //Each player (address) can only have one tile on each board. \n', '    function getTileIDByOwner(uint16 battleboardId, address _owner) constant public returns (uint8) {\n', '        for (uint8 i = 0; i < Battleboards[battleboardId].numTiles+1; i++) {\n', '            if (TilesonBoard[battleboardId][i].owner == _owner) {\n', '                return TilesonBoard[battleboardId][i].id;\n', '        }\n', '    }\n', '       return 0;\n', '    }\n', '    \n', '    \n', '    \n', '    function getPetbyTileId( uint16 battleboardId, uint8 tileId) constant public returns (uint64) {\n', '       return TilesonBoard[battleboardId][tileId].petId;\n', '    }\n', '    \n', '    function getOwner (uint16 battleboardId, uint8 team,  uint8 ownerNumber) constant external returns (address) {\n', '        \n', '       if (team == 0) {return Battleboards[battleboardId].players[ownerNumber];}\n', '       if (team == 1) {return Battleboards[battleboardId].team1[ownerNumber];}\n', '       if (team == 2) {return Battleboards[battleboardId].team2[ownerNumber];}\n', '       \n', '       \n', '    }\n', '    \n', '\n', '    \n', '      function getTileIDbyPosition(uint16 battleboardId, uint8 position) public constant returns (uint8) {\n', '        return positionsTiles[battleboardId][position+1];\n', '    }\n', '    //If tile is empty, this returns 0\n', '     \n', '        // Call to get the specified tile at a certain position of a certain board. \n', '   function getPositionFromBattleboard(uint16 battleboardId, uint8 _position) public constant returns (uint8 tileType, uint8 value, uint8 id, uint8 position, uint32 hp, uint32 petPower, uint64 angelId, uint64 petId, bool isLive)   {\n', '      \n', '        if ((battleboardId <0) ||  (battleboardId > totalBattleboards)) {revert();}\n', '    \n', '        Tile memory tile;\n', '        uint8 tileId = positionsTiles[battleboardId][_position+1];\n', '        tile = TilesonBoard[battleboardId][tileId];\n', '        tileType = tile.tileType; \n', '        value = tile.value;\n', '        id= tile.id;\n', '        position = tile.position;\n', '        hp = tile.hp;\n', '        petPower = tile.petPower;\n', '        angelId = tile.angelId;\n', '        petId = tile.petId;\n', '        isLive = tile.isLive;\n', '        \n', '    } \n', '     \n', ' \n', '    function getBattleboard(uint16 id) public constant returns (uint8 turn, bool isLive, uint prize, uint8 numTeams, uint8 numTiles, uint8 createdBarriers, uint8 restrictions, uint lastMoveTime, uint8 numTeams1, uint8 numTeams2, uint8 monster1, uint8 monster2) {\n', '            \n', '            Battleboard memory battleboard = Battleboards[id];\n', '    \n', '        turn = battleboard.turn;\n', '        isLive = battleboard.isLive;\n', '        prize = battleboard.prize;\n', '        numTeams = battleboard.numTeams;\n', '        numTiles = battleboard.numTiles;\n', '        createdBarriers = battleboard.createdBarriers;\n', '        restrictions = battleboard.restrictions;\n', '        lastMoveTime = battleboard.lastMoveTime;\n', '        numTeams1 = battleboard.numTeams1;\n', '        numTeams2 = battleboard.numTeams2;\n', '        monster1 = battleboard.monster1;\n', '        monster2 = battleboard.monster2;\n', '    }\n', '\n', '    \n', '    \n', '\n', '     \n', '     function isBattleboardLive(uint16 battleboardId) constant public returns (bool) {\n', '         return Battleboards[battleboardId].isLive;\n', '     }\n', '\n', '\n', '     function isTileLive(uint16 battleboardId, uint8 tileId) constant  external returns (bool) {\n', '     \n', '      return TilesonBoard[battleboardId][tileId].isLive;\n', '    }\n', '    \n', '    function getLastMoveTime(uint16 battleboardId) constant public returns (uint) {\n', '        return Battleboards[battleboardId].lastMoveTime;\n', '    }\n', '     \n', '  \n', '        function getNumTilesFromBoard (uint16 _battleboardId) constant public returns (uint8) {\n', '            return Battleboards[_battleboardId].numTiles;\n', '        }\n', '   \n', '        \n', '        //each angel can only be on ONE sponsored battleboard at a time. \n', '        function angelOnBattleboards(uint64 angelID) external constant returns (bool) {\n', '           \n', '            return angelsOnBattleboards[angelID]; \n', '        }\n', '   \n', '        \n', '        function getTurn(uint16 battleboardId) constant public returns (address) {\n', '            return Battleboards[battleboardId].players[Battleboards[battleboardId].turn];\n', '        }\n', '        \n', '      \n', '     \n', '     function getNumTeams(uint16 battleboardId, uint8 team) public constant returns (uint8) {\n', '         if (team == 1) {return Battleboards[battleboardId].numTeams1;}\n', '         if (team == 2) {return Battleboards[battleboardId].numTeams2;}\n', '     }\n', '        \n', '      \n', '    \n', '    function getMonsters(uint16 BattleboardId) external constant returns (uint8 monster1, uint8 monster2) {\n', '        \n', '        monster1 = Battleboards[BattleboardId].monster1;\n', '        monster2 = Battleboards[BattleboardId].monster2;\n', '   \n', '    }\n', '    \n', '    \n', '    function safeMult(uint x, uint y) pure internal returns(uint) {\n', '      uint z = x * y;\n', '      assert((x == 0)||(z/x == y));\n', '      return z;\n', '    }\n', '    \n', '     function SafeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '    /// Read access\n', '     }\n', '   \n', '   \n', '    function getTotalBattleboards() public constant returns (uint16) {\n', '        return totalBattleboards;\n', '    }\n', '      \n', '  \n', '        \n', '   \n', '        \n', '        \n', '        \n', '   \n', '      \n', '        \n', '   \n', '}']
['pragma solidity ^0.4.17;\n', '\n', 'contract AccessControl {\n', '    address public creatorAddress;\n', '    uint16 public totalSeraphims = 0;\n', '    mapping (address => bool) public seraphims;\n', '\n', '    bool public isMaintenanceMode = true;\n', ' \n', '    modifier onlyCREATOR() {\n', '        require(msg.sender == creatorAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlySERAPHIM() {\n', '        require(seraphims[msg.sender] == true);\n', '        _;\n', '    }\n', '    \n', '    modifier isContractActive {\n', '        require(!isMaintenanceMode);\n', '        _;\n', '    }\n', '    \n', '    // Constructor\n', '    function AccessControl() public {\n', '        creatorAddress = msg.sender;\n', '    }\n', '    \n', '\n', '    function addSERAPHIM(address _newSeraphim) onlyCREATOR public {\n', '        if (seraphims[_newSeraphim] == false) {\n', '            seraphims[_newSeraphim] = true;\n', '            totalSeraphims += 1;\n', '        }\n', '    }\n', '    \n', '    function removeSERAPHIM(address _oldSeraphim) onlyCREATOR public {\n', '        if (seraphims[_oldSeraphim] == true) {\n', '            seraphims[_oldSeraphim] = false;\n', '            totalSeraphims -= 1;\n', '        }\n', '    }\n', '\n', '    function updateMaintenanceMode(bool _isMaintaining) onlyCREATOR public {\n', '        isMaintenanceMode = _isMaintaining;\n', '    }\n', '\n', '  \n', '} \n', '\n', '\n', 'contract IBattleboardData is AccessControl  {\n', '\n', '  \n', '\n', '      // write functions\n', '  \n', 'function createBattleboard(uint prize, uint8 restrictions) onlySERAPHIM external returns (uint16);\n', 'function killMonster(uint16 battleboardId, uint8 monsterId)  onlySERAPHIM external;\n', 'function createNullTile(uint16 _battleboardId) private ;\n', 'function createTile(uint16 _battleboardId, uint8 _tileType, uint8 _value, uint8 _position, uint32 _hp, uint16 _petPower, uint64 _angelId, uint64 _petId, address _owner, uint8 _team) onlySERAPHIM external  returns (uint8);\n', 'function killTile(uint16 battleboardId, uint8 tileId) onlySERAPHIM external ;\n', 'function addTeamtoBoard(uint16 battleboardId, address owner, uint8 team) onlySERAPHIM external;\n', 'function setTilePosition (uint16 battleboardId, uint8 tileId, uint8 _positionTo) onlySERAPHIM public ;\n', 'function setTileHp(uint16 battleboardId, uint8 tileId, uint32 _hp) onlySERAPHIM external ;\n', 'function addMedalBurned(uint16 battleboardId) onlySERAPHIM external ;\n', 'function setLastMoveTime(uint16 battleboardId) onlySERAPHIM external ;\n', 'function iterateTurn(uint16 battleboardId) onlySERAPHIM external ;\n', 'function killBoard(uint16 battleboardId) onlySERAPHIM external ;\n', 'function clearAngelsFromBoard(uint16 battleboardId) private;\n', '//Read functions\n', '     \n', 'function getTileHp(uint16 battleboardId, uint8 tileId) constant external returns (uint32) ;\n', 'function getMedalsBurned(uint16 battleboardId) constant external returns (uint8) ;\n', 'function getTeam(uint16 battleboardId, uint8 tileId) constant external returns (uint8) ;\n', 'function getMaxFreeTeams() constant public returns (uint8);\n', 'function getBarrierNum(uint16 battleboardId) public constant returns (uint8) ;\n', 'function getTileFromBattleboard(uint16 battleboardId, uint8 tileId) public constant returns (uint8 tileType, uint8 value, uint8 id, uint8 position, uint32 hp, uint16 petPower, uint64 angelId, uint64 petId, bool isLive, address owner)   ;\n', 'function getTileIDByOwner(uint16 battleboardId, address _owner) constant public returns (uint8) ;\n', 'function getPetbyTileId( uint16 battleboardId, uint8 tileId) constant public returns (uint64) ;\n', 'function getOwner (uint16 battleboardId, uint8 team,  uint8 ownerNumber) constant external returns (address);\n', 'function getTileIDbyPosition(uint16 battleboardId, uint8 position) public constant returns (uint8) ;\n', 'function getPositionFromBattleboard(uint16 battleboardId, uint8 _position) public constant returns (uint8 tileType, uint8 value, uint8 id, uint8 position, uint32 hp, uint32 petPower, uint64 angelId, uint64 petId, bool isLive)  ;\n', 'function getBattleboard(uint16 id) public constant returns (uint8 turn, bool isLive, uint prize, uint8 numTeams, uint8 numTiles, uint8 createdBarriers, uint8 restrictions, uint lastMoveTime, uint8 numTeams1, uint8 numTeams2, uint8 monster1, uint8 monster2) ;\n', 'function isBattleboardLive(uint16 battleboardId) constant public returns (bool);\n', 'function isTileLive(uint16 battleboardId, uint8 tileId) constant  external returns (bool) ;\n', 'function getLastMoveTime(uint16 battleboardId) constant public returns (uint) ;\n', 'function getNumTilesFromBoard (uint16 _battleboardId) constant public returns (uint8) ; \n', 'function angelOnBattleboards(uint64 angelID) external constant returns (bool) ;\n', 'function getTurn(uint16 battleboardId) constant public returns (address) ;\n', 'function getNumTeams(uint16 battleboardId, uint8 team) public constant returns (uint8);\n', 'function getMonsters(uint16 BattleboardId) external constant returns (uint8 monster1, uint8 monster2) ;\n', 'function getTotalBattleboards() public constant returns (uint16) ;\n', '  \n', '        \n', ' \n', '   \n', '}\n', '\n', 'contract BattleboardData is IBattleboardData  {\n', '\n', '    /*** DATA TYPES ***/\n', '       \n', '  \n', '  //Most main pieces on the board are tiles.   \n', '      struct Tile {\n', '        uint8 tileType;\n', '        uint8 value; //speed for angels, otherwise value of other types. \n', '        uint8 id;\n', '        uint8 position;\n', '        uint32 hp;\n', '        uint16 petPower;\n', '        uint8 team; //which team they are on. \n', '        uint64 angelId;\n', '        uint64 petId;\n', '        bool isLive;\n', '        address owner;\n', '        \n', '    }\n', '    \n', '      struct Battleboard {\n', '        uint8 turn; //turn number - turn 0 is the first player who enters the board. \n', '        address[] players;\n', '        bool isLive;\n', '        uint prize;\n', '        uint16 id;\n', '        uint8 numTeams; //number of angel/pet teams on the board, different than TEAM1 vs TEAM2\n', '        uint8 numTiles;\n', '        uint8 createdBarriers;\n', '        uint8 restrictions; //number of which angels can be added. \n', '        uint lastMoveTime;\n', '        address[] team1;\n', '        address[] team2; //addresses of the owners of teams 1 and 2\n', '        uint8 numTeams1;\n', '        uint8 numTeams2;\n', '        uint8 monster1; //tile number of the monster locations. \n', '        uint8 monster2;\n', '        uint8 medalsBurned;\n', '    }\n', '\n', '    //main storage\n', '    Battleboard []  Battleboards;\n', '    \n', '    uint16 public totalBattleboards;\n', '    \n', '    uint8 maxFreeTeams = 6;\n', '    uint8 maxPaidTeams = 4;\n', '    \n', '    //Each angel can only be on one board at a time. \n', '    mapping (uint64 => bool) angelsOnBattleboards; \n', '\n', '    //Map the battleboard ID to an array of all tiles on that board. \n', '    mapping (uint32 => Tile[]) TilesonBoard;\n', '    \n', '    //for each battleboardId(uint16) there is a number with the tileId of the tile. TileId 0 means blank. \n', '    mapping (uint16 => uint8 [64]) positionsTiles;\n', '    \n', '    \n', '    \n', '      // write functions\n', '  \n', '       function createBattleboard(uint prize, uint8 restrictions) onlySERAPHIM external returns (uint16) {\n', '           Battleboard memory battleboard;\n', '           battleboard.restrictions = restrictions;\n', '           battleboard.isLive = false; //will be live once ALL teams are added. \n', '           battleboard.prize = prize;\n', '           battleboard.id = totalBattleboards;\n', '           battleboard.numTeams = 0;\n', '           battleboard.lastMoveTime = now;\n', '           totalBattleboards += 1;\n', '           battleboard.numTiles = 0;\n', '          //set the monster positions\n', '           battleboard.monster1 = getRandomNumber(30,17,1);\n', '           battleboard.monster2 = getRandomNumber(48,31,2); \n', '           Battleboards.push(battleboard);\n', '          createNullTile(totalBattleboards-1);\n', '           return (totalBattleboards - 1);\n', '       }\n', '       \n', '         \n', '      \n', '      function killMonster(uint16 battleboardId, uint8 monsterId)  onlySERAPHIM external{\n', '          if (monsterId == 1) {\n', '              Battleboards[battleboardId].monster1 = 0;\n', '          }\n', '          if (monsterId ==2) {\n', '               Battleboards[battleboardId].monster2 = 0;\n', '          }\n', '      }\n', '        \n', '        function createNullTile(uint16 _battleboardId) private    {\n', "      //We need to create a tile with ID 0 that won't be on the board. This lets us know if any other tile is ID 0 then that means it's a blank tile. \n", '        if ((_battleboardId <0) || (_battleboardId > totalBattleboards)) {revert();}\n', '        Tile memory tile ;\n', '        tile.tileType = 0; \n', '        tile.id = 0;\n', '        tile.isLive = true;\n', '        TilesonBoard[_battleboardId].push(tile);\n', '     \n', '    }\n', '        \n', '        function createTile(uint16 _battleboardId, uint8 _tileType, uint8 _value, uint8 _position, uint32 _hp, uint16 _petPower, uint64 _angelId, uint64 _petId, address _owner, uint8 _team) onlySERAPHIM external  returns (uint8)   {\n', '      //main function to create a tile and add it to the board. \n', '        if ((_battleboardId <0) || (_battleboardId > totalBattleboards)) {revert();}\n', '        if ((angelsOnBattleboards[_angelId] == true) && (_angelId != 0)) {revert();}\n', '        angelsOnBattleboards[_angelId] = true;\n', '        Tile memory tile ;\n', '        tile.tileType = _tileType; \n', '        tile.value = _value;\n', '        tile.position= _position;\n', '        tile.hp = _hp;\n', '        Battleboards[_battleboardId].numTiles +=1;\n', '        tile.id = Battleboards[_battleboardId].numTiles;\n', '        positionsTiles[_battleboardId][_position+1] = tile.id;\n', '        tile.petPower = _petPower;\n', '        tile.angelId = _angelId;\n', '        tile.petId = _petId;\n', '        tile.owner = _owner;\n', '        tile.team = _team;\n', '        tile.isLive = true;\n', '        TilesonBoard[_battleboardId].push(tile);\n', '        return (Battleboards[_battleboardId].numTiles);\n', '    }\n', '     \n', '     function killTile(uint16 battleboardId, uint8 tileId) onlySERAPHIM external {\n', '     \n', '      TilesonBoard[battleboardId][tileId].isLive= false;\n', '      TilesonBoard[battleboardId][tileId].tileType= 0;\n', '      for (uint i =0; i< Battleboards[battleboardId].team1.length; i++) {\n', '          if (Battleboards[battleboardId].team1[i] == TilesonBoard[battleboardId][tileId].owner) {\n', "             //should be safe because a team can't be killed if there are 0 teams to kill. \n", '             Battleboards[battleboardId].numTeams1 -= 1; \n', '          }\n', '      }\n', '      for (i =0; i< Battleboards[battleboardId].team2.length; i++) {\n', '          if (Battleboards[battleboardId].team2[i] == TilesonBoard[battleboardId][tileId].owner) {\n', "             //should be safe because a team can't be killed if there are 0 teams to kill. \n", '             Battleboards[battleboardId].numTeams2 -= 1; \n', '          }\n', '      }\n', '    }\n', '     \n', '     function addTeamtoBoard(uint16 battleboardId, address owner, uint8 team) onlySERAPHIM external {\n', '        \n', "        //Can't add a team if the board is live, or if the board is already full of teams. \n", '         if (Battleboards[battleboardId].isLive == true) {revert();}\n', '         if ((Battleboards[battleboardId].prize == 0) &&(Battleboards[battleboardId].numTeams == maxFreeTeams)) {revert();}\n', '         if ((Battleboards[battleboardId].prize != 0) &&(Battleboards[battleboardId].numTeams == maxPaidTeams)) {revert();}\n', '         \n', '         //only one team per address can be on the board. \n', '         for (uint i =0; i<Battleboards[battleboardId].numTeams; i++) {\n', '             if (Battleboards[battleboardId].players[i] == owner) {revert();}\n', '         }\n', '         Battleboards[battleboardId].numTeams += 1;\n', '         Battleboards[battleboardId].players.push(owner);\n', '         \n', '         if (team == 1) {\n', '         Battleboards[battleboardId].numTeams1 += 1;\n', '         Battleboards[battleboardId].team1.push(owner);\n', '         }\n', '         if (team == 2) {\n', '         Battleboards[battleboardId].numTeams2 += 1;\n', '         Battleboards[battleboardId].team2.push(owner);\n', '         \n', '         //if the board is now full, then go ahead and make it live. \n', '         if ((Battleboards[battleboardId].numTeams1 == 3) && (Battleboards[battleboardId].numTeams2 ==3)) {Battleboards[battleboardId].isLive = true;}\n', '        if ((Battleboards[battleboardId].prize != 0) &&(Battleboards[battleboardId].numTeams == maxPaidTeams)) {Battleboards[battleboardId].isLive = true;}\n', '         }\n', '          \n', '     }\n', '       \n', '        function setTilePosition (uint16 battleboardId, uint8 tileId, uint8 _positionTo) onlySERAPHIM public  {\n', '            uint8 oldPos = TilesonBoard[battleboardId][tileId].position;\n', '            positionsTiles[battleboardId][oldPos+1] = 0;\n', '            TilesonBoard[battleboardId][tileId].position = _positionTo;\n', '            positionsTiles[battleboardId][_positionTo+1] = tileId;\n', '            \n', '        }\n', '        \n', '        function setTileHp(uint16 battleboardId, uint8 tileId, uint32 _hp) onlySERAPHIM external {\n', '            TilesonBoard[battleboardId][tileId].hp = _hp;\n', '        }\n', '        \n', '          function addMedalBurned(uint16 battleboardId) onlySERAPHIM external {\n', '            Battleboards[battleboardId].medalsBurned += 1;\n', '        }\n', '        \n', '        function withdrawEther()  onlyCREATOR external {\n', "   //shouldn't have any eth here but just in case. \n", '    creatorAddress.transfer(this.balance);\n', '}\n', '\n', 'function setLastMoveTime(uint16 battleboardId) onlySERAPHIM external {\n', '        Battleboards[battleboardId].lastMoveTime = now;\n', '        \n', '        \n', '    }\n', '    \n', '      function iterateTurn(uint16 battleboardId) onlySERAPHIM external {\n', '            if (Battleboards[battleboardId].turn  == (Battleboards[battleboardId].players.length-1)) {\n', '                Battleboards[battleboardId].turn = 0;\n', '            } \n', '            else {Battleboards[battleboardId].turn += 1;}\n', '        }\n', '        \n', '         function killBoard(uint16 battleboardId) onlySERAPHIM external {\n', '           Battleboards[battleboardId].isLive = false;\n', '           clearAngelsFromBoard(battleboardId);\n', '       }\n', '    \n', '    \n', '        function clearAngelsFromBoard(uint16 battleboardId) private {\n', '         //Free up angels to be used on other boards. \n', '         for (uint i = 0; i < Battleboards[battleboardId].numTiles; i++) {\n', '            if (TilesonBoard[battleboardId][i].angelId != 0) {\n', '                angelsOnBattleboards[TilesonBoard[battleboardId][i].angelId] = false;\n', '              }\n', '         } \n', '  \n', '    }\n', '\n', '//Read functions\n', '     \n', '        function getTileHp(uint16 battleboardId, uint8 tileId) constant external returns (uint32) {\n', '            return TilesonBoard[battleboardId][tileId].hp;\n', '        }\n', '        \n', '      \n', '        function getMedalsBurned(uint16 battleboardId) constant external returns (uint8) {\n', '            return Battleboards[battleboardId].medalsBurned;\n', '        }\n', '  \n', ' \n', ' function getTeam(uint16 battleboardId, uint8 tileId) constant external returns (uint8) {\n', '     return TilesonBoard[battleboardId][tileId].team;\n', ' }\n', '        \n', '\n', '\n', 'function getRandomNumber(uint16 maxRandom, uint8 min, address privateAddress) constant public returns(uint8) {\n', '        uint256 genNum = uint256(block.blockhash(block.number-1)) + uint256(privateAddress);\n', '        return uint8(genNum % (maxRandom - min + 1)+min);\n', '        }\n', '\n', '       \n', '       function getMaxFreeTeams() constant public returns (uint8) {\n', '          return maxFreeTeams;\n', '       }\n', '  \n', '        function getBarrierNum(uint16 battleboardId) public constant returns (uint8) {\n', '            return Battleboards[battleboardId].createdBarriers;\n', '        }\n', '\n', '    // Call to get the specified tile at a certain position of a certain board. \n', '   function getTileFromBattleboard(uint16 battleboardId, uint8 tileId) public constant returns (uint8 tileType, uint8 value, uint8 id, uint8 position, uint32 hp, uint16 petPower, uint64 angelId, uint64 petId, bool isLive, address owner)   {\n', '      \n', '        if ((battleboardId <0) ||  (battleboardId > totalBattleboards)) {revert();}\n', '        Battleboard memory battleboard = Battleboards[battleboardId];\n', '        Tile memory tile;\n', '        if ((tileId <0) || (tileId> battleboard.numTiles)) {revert();}\n', '        tile = TilesonBoard[battleboardId][tileId];\n', '        tileType = tile.tileType; \n', '        value = tile.value;\n', '        id= tile.id;\n', '        position = tile.position;\n', '        hp = tile.hp;\n', '        petPower = tile.petPower;\n', '        angelId = tile.angelId;\n', '        petId = tile.petId;\n', '        owner = tile.owner;\n', '        isLive = tile.isLive;\n', '        \n', '    }\n', '    \n', '    //Each player (address) can only have one tile on each board. \n', '    function getTileIDByOwner(uint16 battleboardId, address _owner) constant public returns (uint8) {\n', '        for (uint8 i = 0; i < Battleboards[battleboardId].numTiles+1; i++) {\n', '            if (TilesonBoard[battleboardId][i].owner == _owner) {\n', '                return TilesonBoard[battleboardId][i].id;\n', '        }\n', '    }\n', '       return 0;\n', '    }\n', '    \n', '    \n', '    \n', '    function getPetbyTileId( uint16 battleboardId, uint8 tileId) constant public returns (uint64) {\n', '       return TilesonBoard[battleboardId][tileId].petId;\n', '    }\n', '    \n', '    function getOwner (uint16 battleboardId, uint8 team,  uint8 ownerNumber) constant external returns (address) {\n', '        \n', '       if (team == 0) {return Battleboards[battleboardId].players[ownerNumber];}\n', '       if (team == 1) {return Battleboards[battleboardId].team1[ownerNumber];}\n', '       if (team == 2) {return Battleboards[battleboardId].team2[ownerNumber];}\n', '       \n', '       \n', '    }\n', '    \n', '\n', '    \n', '      function getTileIDbyPosition(uint16 battleboardId, uint8 position) public constant returns (uint8) {\n', '        return positionsTiles[battleboardId][position+1];\n', '    }\n', '    //If tile is empty, this returns 0\n', '     \n', '        // Call to get the specified tile at a certain position of a certain board. \n', '   function getPositionFromBattleboard(uint16 battleboardId, uint8 _position) public constant returns (uint8 tileType, uint8 value, uint8 id, uint8 position, uint32 hp, uint32 petPower, uint64 angelId, uint64 petId, bool isLive)   {\n', '      \n', '        if ((battleboardId <0) ||  (battleboardId > totalBattleboards)) {revert();}\n', '    \n', '        Tile memory tile;\n', '        uint8 tileId = positionsTiles[battleboardId][_position+1];\n', '        tile = TilesonBoard[battleboardId][tileId];\n', '        tileType = tile.tileType; \n', '        value = tile.value;\n', '        id= tile.id;\n', '        position = tile.position;\n', '        hp = tile.hp;\n', '        petPower = tile.petPower;\n', '        angelId = tile.angelId;\n', '        petId = tile.petId;\n', '        isLive = tile.isLive;\n', '        \n', '    } \n', '     \n', ' \n', '    function getBattleboard(uint16 id) public constant returns (uint8 turn, bool isLive, uint prize, uint8 numTeams, uint8 numTiles, uint8 createdBarriers, uint8 restrictions, uint lastMoveTime, uint8 numTeams1, uint8 numTeams2, uint8 monster1, uint8 monster2) {\n', '            \n', '            Battleboard memory battleboard = Battleboards[id];\n', '    \n', '        turn = battleboard.turn;\n', '        isLive = battleboard.isLive;\n', '        prize = battleboard.prize;\n', '        numTeams = battleboard.numTeams;\n', '        numTiles = battleboard.numTiles;\n', '        createdBarriers = battleboard.createdBarriers;\n', '        restrictions = battleboard.restrictions;\n', '        lastMoveTime = battleboard.lastMoveTime;\n', '        numTeams1 = battleboard.numTeams1;\n', '        numTeams2 = battleboard.numTeams2;\n', '        monster1 = battleboard.monster1;\n', '        monster2 = battleboard.monster2;\n', '    }\n', '\n', '    \n', '    \n', '\n', '     \n', '     function isBattleboardLive(uint16 battleboardId) constant public returns (bool) {\n', '         return Battleboards[battleboardId].isLive;\n', '     }\n', '\n', '\n', '     function isTileLive(uint16 battleboardId, uint8 tileId) constant  external returns (bool) {\n', '     \n', '      return TilesonBoard[battleboardId][tileId].isLive;\n', '    }\n', '    \n', '    function getLastMoveTime(uint16 battleboardId) constant public returns (uint) {\n', '        return Battleboards[battleboardId].lastMoveTime;\n', '    }\n', '     \n', '  \n', '        function getNumTilesFromBoard (uint16 _battleboardId) constant public returns (uint8) {\n', '            return Battleboards[_battleboardId].numTiles;\n', '        }\n', '   \n', '        \n', '        //each angel can only be on ONE sponsored battleboard at a time. \n', '        function angelOnBattleboards(uint64 angelID) external constant returns (bool) {\n', '           \n', '            return angelsOnBattleboards[angelID]; \n', '        }\n', '   \n', '        \n', '        function getTurn(uint16 battleboardId) constant public returns (address) {\n', '            return Battleboards[battleboardId].players[Battleboards[battleboardId].turn];\n', '        }\n', '        \n', '      \n', '     \n', '     function getNumTeams(uint16 battleboardId, uint8 team) public constant returns (uint8) {\n', '         if (team == 1) {return Battleboards[battleboardId].numTeams1;}\n', '         if (team == 2) {return Battleboards[battleboardId].numTeams2;}\n', '     }\n', '        \n', '      \n', '    \n', '    function getMonsters(uint16 BattleboardId) external constant returns (uint8 monster1, uint8 monster2) {\n', '        \n', '        monster1 = Battleboards[BattleboardId].monster1;\n', '        monster2 = Battleboards[BattleboardId].monster2;\n', '   \n', '    }\n', '    \n', '    \n', '    function safeMult(uint x, uint y) pure internal returns(uint) {\n', '      uint z = x * y;\n', '      assert((x == 0)||(z/x == y));\n', '      return z;\n', '    }\n', '    \n', '     function SafeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '    /// Read access\n', '     }\n', '   \n', '   \n', '    function getTotalBattleboards() public constant returns (uint16) {\n', '        return totalBattleboards;\n', '    }\n', '      \n', '  \n', '        \n', '   \n', '        \n', '        \n', '        \n', '   \n', '      \n', '        \n', '   \n', '}']
