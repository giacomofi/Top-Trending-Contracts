['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/Ownable.sol\n', '\n', '/**\n', '     * @title Ownable\n', '     * @dev The Ownable contract has an owner address, and provides basic authorization control\n', '     * functions, this simplifies the implementation of "user permissions".\n', '     */\n', '    contract Ownable {\n', '      address public owner;\n', '    \n', '      event OwnershipRenounced(address indexed previousOwner);\n', '      event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    \n', '      /**\n', '       * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '       * account.\n', '       */\n', '      //function Ownable() public {\n', '      constructor() public {\n', '        owner = msg.sender;\n', '      }\n', '    \n', '      /**\n', '       * @dev Throws if called by any account other than the owner.\n', '       */\n', '      modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '      }\n', '    \n', '      /**\n', '       * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '       * @param newOwner The address to transfer ownership to.\n', '       */\n', '      function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '      }\n', '    \n', '      /**\n', '       * @dev Allows the current owner to relinquish control of the contract.\n', '       */\n', '      function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '      }\n', '    }\n', '\n', '// File: contracts/CeoOwner.sol\n', '\n', 'contract CeoOwner is Ownable{\n', '\n', '\t// The primary address which is permitted to interact with the contract\n', '\t// Address of wallet account on WEB3.js account.\n', '\taddress public ceoAddress; \n', '\n', '\tmodifier onlyCEO() {\n', '\t\trequire(msg.sender == ceoAddress);\n', '\t\t_;\n', '\t}\n', '\n', '}\n', '\n', '// File: contracts/ReentrancyGuard.sol\n', '\n', '/**\n', ' * @title Helps contracts guard agains reentrancy attacks.\n', ' * @author Remco Bloemen <remco@2Ï€.com>\n', ' * @notice If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', ' contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '   bool private reentrancyLock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '   modifier nonReentrant() {\n', '    require(!reentrancyLock);\n', '    reentrancyLock = true;\n', '    _;\n', '    reentrancyLock = false;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/SafeMath.sol\n', '\n', '/**\n', '     * @title SafeMath\n', '     * @dev Math operations with safety checks that throw on error\n', '     */\n', '     library SafeMath {\n', '      \n', '      /**\n', '      * @dev Multiplies two numbers, throws on overflow.\n', '      */\n', '      function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '          return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '      }\n', '      \n', '      /**\n', '      * @dev Integer division of two numbers, truncating the quotient.\n', '      */\n', '      function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '      }\n', '      \n', '      /**\n', '      * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '      */\n', '      function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '      }\n', '      \n', '      /**\n', '      * @dev Adds two numbers, throws on overflow.\n', '      */\n', '      function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '      }\n', '    }\n', '\n', '// File: contracts/CertificateCore.sol\n', '\n', 'contract CertificateCore is CeoOwner, ReentrancyGuard { \n', '   \n', '    using SafeMath for uint256; \n', '\n', '    uint256 public constant KEY_CREATION_LIMIT = 10000;\n', '    uint256 public totalSupplyOfKeys;\n', '    uint256 public totalReclaimedKeys;\n', '    \n', '    // Track who is making the deposits and the amount made\n', '    mapping(address => uint256) public balanceOf; \n', '\n', '    // Main data structure to hold all of the public keys   \n', '    mapping(address => bool) public allThePublicKeys;\n', '    \n', '    // A bonus deposit has been made\n', '    event DepositBonusEvent(address sender, uint256 amount); \n', '    \n', '    // A new certificate has been successfully sold and a deposit added\n', '    event DepositCertificateSaleEvent(address sender, address publicKey, uint256 amount);\n', '\n', '    // A certificate has been payed out.\n', '    event CertPayedOutEvent(address sender, address recpublicKey, uint256 payoutValue);\n', '    \n', '\n', '    constructor(address _ceoAddress) public{\n', '        require(_ceoAddress != address(0));\n', '        owner = msg.sender;\n', '        ceoAddress = _ceoAddress;\n', '    }\n', ' \n', '    \n', '    /**\n', '     *\n', '     * Main function for creating certificates\n', '     * \n', '     */\n', '    //function createANewCert(address _publicKey, uint256 _amount) external payable onlyCEO{\n', '    function depositCertificateSale(address _publicKey, uint256 _amount) external payable onlyCEO{\n', '        require(msg.sender != address(0));\n', '        require(_amount > 0);\n', '        require(msg.value == _amount);\n', '        require(_publicKey != address(0));\n', '        require(totalSupplyOfKeys < KEY_CREATION_LIMIT);\n', '        require(totalReclaimedKeys < KEY_CREATION_LIMIT);\n', ' \n', '        require(!allThePublicKeys[_publicKey]);\n', '\n', '        allThePublicKeys[_publicKey]=true;\n', '        totalSupplyOfKeys ++;\n', '\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(_amount);\n', '        \n', '        emit DepositCertificateSaleEvent(msg.sender, _publicKey, _amount);\n', '    }\n', '    \n', '    /**\n', '     *  Allow the CEO to deposit ETH without creating a new certificate\n', '     * \n', '     * */\n', '    //function deposit(uint256 _amount) external payable onlyCEO {\n', '    function depositBonus(uint256 _amount) external payable onlyCEO {\n', '        require(_amount > 0);\n', '        require(msg.value == _amount);\n', '      \n', '        require((totalSupplyOfKeys > 0) && (totalSupplyOfKeys < KEY_CREATION_LIMIT));\n', '        require(totalReclaimedKeys < KEY_CREATION_LIMIT);\n', '      \n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(_amount);\n', '        \n', '        emit DepositBonusEvent(msg.sender, _amount);\n', '    }\n', '    \n', '    /**\n', '     * Payout a certificate. \n', '     * \n', '     */\n', '    function payoutACert(bytes32 _msgHash, uint8 _v, bytes32 _r, bytes32 _s) external nonReentrant{\n', '        require(msg.sender != address(0));\n', '        require(address(this).balance > 0);\n', '        require(totalSupplyOfKeys > 0);\n', '        require(totalReclaimedKeys < KEY_CREATION_LIMIT);\n', '         \n', '        address _recoveredAddress = ecrecover(_msgHash, _v, _r, _s);\n', '        require(allThePublicKeys[_recoveredAddress]);\n', '    \n', '        allThePublicKeys[_recoveredAddress]=false;\n', '\n', '        uint256 _validKeys = totalSupplyOfKeys.sub(totalReclaimedKeys);\n', '        uint256 _payoutValue = address(this).balance.div(_validKeys);\n', '\n', '        msg.sender.transfer(_payoutValue);\n', '        emit CertPayedOutEvent(msg.sender, _recoveredAddress, _payoutValue);\n', '        \n', '        totalReclaimedKeys ++;\n', '    }\n', ' \n', '     /**\n', '     * Update payout value per certificate.\n', '     */\n', '     //\n', '     // debug only. remove in Live deploy.\n', '     // do this operation on the Dapp side.\n', '    function calculatePayout() view external returns(\n', '        uint256 _etherValue\n', '        ){\n', '        uint256 _validKeys = totalSupplyOfKeys.sub(totalReclaimedKeys);\n', '        // Last key has been paid out.\n', '        if(_validKeys == 0){\n', '            _etherValue = 0;\n', '        }else{\n', '            _etherValue = address(this).balance.div(_validKeys);\n', '        }\n', '    }\n', ' \n', ' \n', '    /**\n', "     * Check to see if a Key has been payed out or if it's still valid\n", '     */\n', '    function checkIfValidKey(address _publicKey) view external{ // external\n', '        require(_publicKey != address(0));\n', '        require(allThePublicKeys[_publicKey]);\n', '    }\n', '\n', '    function getBalance() view external returns(\n', '         uint256 contractBalance\n', '    ){\n', '        contractBalance = address(this).balance;\n', '    }\n', '    \n', '    /**\n', '     * Saftey Mechanism\n', '     * \n', '     */\n', '    function kill() external onlyOwner \n', '    { \n', '        selfdestruct(owner); \n', '    }\n', ' \n', '    /**\n', '     * Payable fallback function.\n', '     * No Tipping! \n', '     * \n', '     */\n', '    //function () payable public{\n', '    //    throw;\n', '    //}\n', '    \n', '}\n', '\n', '// File: contracts/Migrations.sol\n', '\n', 'contract Migrations {\n', '  address public owner;\n', '  uint public last_completed_migration;\n', '\n', '  modifier restricted() {\n', '    if (msg.sender == owner) _;\n', '  }\n', '\n', '  //function Migrations() public {\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function setCompleted(uint completed) public restricted {\n', '    last_completed_migration = completed;\n', '  }\n', '\n', '  function upgrade(address new_address) public restricted {\n', '    Migrations upgraded = Migrations(new_address);\n', '    upgraded.setCompleted(last_completed_migration);\n', '  }\n', '}']