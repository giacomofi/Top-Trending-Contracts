['pragma solidity ^0.4.24; // 23 May 2018\n', '\n', '/*    Copyright &#169; 2018  -  All Rights Reserved\n', '  High-Capacity IonChain Transactional System\n', '*/\n', '\n', 'contract InCodeWeTrust {\n', '  modifier onlyPayloadSize(uint256 size) {\n', '    if(msg.data.length < size + 4) {\n', '       throw;\n', '     }\n', '     _;\n', '  }\n', '  uint256 public totalSupply;\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  function transfer_Different_amounts_of_assets_to_many (address[] _recipients, uint[] _amount_comma_space_amount) public payable;\n', '  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public payable;\n', '  function early_supporters_distribution (address[] address_to_comma_space_address_to_, uint256 _value) public payable;\n', '  function balanceOf(address _owner) constant public returns (uint256 balance);\n', '  function buy_fromContract() payable public returns (uint256 _amount_);                                    \n', '  function sell_toContract (uint256 amount_toSell)  public; \n', '  function show_Balance_available_for_Sale_in_ETH_equivalent () constant public returns (uint256 you_can_buy_all_the_available_assets_with_this_amount_in_ETH);\n', '  function Show_automated_Sell_price() constant public returns (uint256 assets_per_1_ETH);\n', '  function show_automated_Buy_price() constant public returns (uint256 assets_per_1_ETH);\n', '  \n', '\n', '  function developer_edit_text_price (string edit_text_Price)   public;\n', '  function developer_edit_text_crowdsale (string string_crowdsale)   public;\n', '  function developer_edit_text_Exchanges_links (string update_links)   public;\n', '  function developer_string_contract_verified (string string_contract_verified) public;\n', '  function developer_update_Terms_of_service (string update_text_Terms_of_service)   public;\n', '  function developer_edit_name (string edit_text_name)   public;\n', '  function developer_How_To  (string edit_text_How_to)   public;\n', '  function totally_decrease_the_supply(uint256 amount_to_burn_from_supply) public payable;\n', ' }\n', '\n', 'contract investor is InCodeWeTrust {\n', '  address internal owner; \n', '\n', '  mapping(address => uint256) balances;\n', '}\n', '/*  SafeMath - the lowest risk library\n', '  Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract Satoshi is investor {\n', '  using SafeMath for uint256;\n', '  uint256 totalFund = 112 ** 3; \n', '  uint256 buyPrice =   2857 * 10 ** 12 ;   // 0,002857 ETH per 1 Asset  or 350,02 Assets per 1 ETH\n', '  uint256 public Buy_Wall_level_in_wei = (2800 * 10 ** 12) / 35 ; // 0,00008 ETH per 1 Asset\n', ' \n', '    /* Batch assets transfer. Used  to distribute  assets to holders */\n', '  function transfer_Different_amounts_of_assets_to_many (address[] _recipients, uint[] _amount_comma_space_amount) public payable {\n', '        require( _recipients.length > 0 && _recipients.length == _amount_comma_space_amount.length);\n', '\n', '        uint256 total = 0;\n', '        for(uint i = 0; i < _amount_comma_space_amount.length; i++){\n', '            total = total.add(_amount_comma_space_amount[i]);\n', '        }\n', '        require(total <= balances[msg.sender]);\n', '\n', '        for(uint j = 0; j < _recipients.length; j++){\n', '            balances[_recipients[j]] = balances[_recipients[j]].add(_amount_comma_space_amount[j]);\n', '            Transfer(msg.sender, _recipients[j], _amount_comma_space_amount[j]);\n', '        }\n', '        balances[msg.sender] = balances[msg.sender].sub(total);\n', '       \n', '  } \n', ' \n', '  function early_supporters_distribution (address[] address_to_comma_space_address_to_, uint256 _value) public payable { \n', '        require(_value <= balances[msg.sender]);\n', '        for (uint i = 0; i < address_to_comma_space_address_to_.length; i++){\n', '         if(balances[msg.sender] >= _value)  { \n', '         balances[msg.sender] = balances[msg.sender].sub(_value);\n', '         balances[address_to_comma_space_address_to_[i]] = balances[address_to_comma_space_address_to_[i]].add(_value);\n', '           Transfer(msg.sender, address_to_comma_space_address_to_[i], _value);\n', '         }\n', '        }\n', '  }\n', '}\n', ' \n', 'contract Inventor is Satoshi {\n', ' function Inventor() internal {\n', '    owner = msg.sender;\n', ' }\n', ' modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', ' }\n', ' function developer_Transfer_ownership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', ' }\n', ' function developer_increase_prices (uint256 _increase, uint256 increase) onlyOwner public {\n', '   Buy_Wall_level_in_wei = _increase; \n', '   buyPrice = increase;\n', ' }\n', '} \n', '\n', 'contract Transparent is Inventor {\n', '    function Show_automated_Sell_price() constant public returns (uint256 assets_per_1_ETH) {\n', '        assets_per_1_ETH = 1e18 / Buy_Wall_level_in_wei;\n', '        return assets_per_1_ETH;\n', '    }\n', '  \n', '    function show_automated_Buy_price() constant public returns (uint256 assets_per_1_ETH) {\n', '        assets_per_1_ETH = 1e18 / buyPrice;\n', '        return assets_per_1_ETH;\n', '    }   \n', '    \n', '    function balanceOf(address _owner) constant public returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', 'contract TheSmartAsset is Transparent {\n', '  uint256 internal initialSupply;\n', '  \n', '  function totally_decrease_the_supply(uint256 amount_to_burn_from_supply) public payable {\n', '        require(balances[msg.sender] >= amount_to_burn_from_supply);\n', '        balances[msg.sender] = balances[msg.sender].sub(amount_to_burn_from_supply);\n', '        totalSupply = totalSupply.sub(amount_to_burn_from_supply);\n', '  }\n', '}\n', '\n', 'contract ERC20 is TheSmartAsset {\n', ' string public name = "IonChain";\n', ' string public positive_terms_of_Service;\n', ' string public crowdsale;\n', ' string public alternative_Exchanges_links;\n', ' string public How_to_interact_with_Smartcontract;\n', ' string public Price;  \n', ' string public contract_verified;\n', ' uint constant internal decimals = 6;\n', ' string public symbol = "IONC";\n', '  function Voter () {\n', '      balances[this] = 0;  // this is the total initial assets sale limit\n', '      balances[owner] = 1 * (10 ** 9) * decimals;  // total amount for all bounty programs\n', '      initialSupply =  balances[owner];\n', '      totalSupply  =  balances[this]  + balances[owner];\n', '      Transfer(0x0, owner, totalSupply);    \n', '  }\n', '  \n', '  //Show_Available_balance_for_Sale_in_ETH_equivalent\n', '  function show_Balance_available_for_Sale_in_ETH_equivalent () constant public returns (uint256 you_can_buy_all_the_available_assets_with_this_amount_in_ETH) {\n', '     you_can_buy_all_the_available_assets_with_this_amount_in_ETH =  buyPrice * balances[this] / 1e18;\n', '  }\n', '  \n', '} \n', '\n', 'contract Assets is  ERC20 {\n', '\n', ' function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public payable {\n', '        if (balances[msg.sender] < _value) {\n', '            _value = balances[msg.sender];\n', '        }\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '       \n', ' }\n', '\n', '}\n', '\n', 'contract Functions is Assets {\n', ' \n', '  \n', '  function developer_string_symbol (string symbol_new)   public {\n', '    if (msg.sender == owner) symbol = symbol_new;\n', '  }\n', '  function developer_edit_text_price (string edit_text_Price)   public {\n', '    if (msg.sender == owner) Price = edit_text_Price;\n', '  }\n', '  \n', '  function developer_edit_text_crowdsale (string string_crowdsale)   public {\n', '    if (msg.sender == owner) crowdsale = string_crowdsale;\n', '  }\n', '  function developer_edit_text_Exchanges_links (string update_links)   public {\n', '    if (msg.sender == owner) alternative_Exchanges_links = update_links;\n', '  }\n', '  function developer_string_contract_verified (string string_contract_verified) public {\n', '    if (msg.sender == owner) contract_verified = string_contract_verified;\n', '  }\n', '  function developer_update_Terms_of_service (string update_text_Terms_of_service)   public {\n', '    if (msg.sender == owner) positive_terms_of_Service = update_text_Terms_of_service;\n', '  }\n', '  function developer_edit_name (string edit_text_name)   public {\n', '    if (msg.sender == owner) name = edit_text_name;\n', '  }\n', '  function developer_How_To  (string edit_text_How_to)   public {\n', '    if (msg.sender == owner) How_to_interact_with_Smartcontract = edit_text_How_to;\n', '  }\n', ' \n', '\n', ' function () payable {\n', '    uint256 assets =  msg.value/(buyPrice);\n', '     if (assets > (balances[this])) {\n', '        assets = balances[this];\n', '        uint valueWei = assets * buyPrice ;\n', '        msg.sender.transfer(msg.value - valueWei);\n', '    }\n', '    require(msg.value >= (10 ** 15));\n', '    balances[msg.sender] += assets;\n', '    balances[this] -= assets;\n', '    Transfer(this, msg.sender, assets);\n', ' }\n', '}\n', '\n', '\n', 'contract IonChain is Functions {\n', '\n', ' function buy_fromContract() payable public returns (uint256 _amount_) {\n', '        require (msg.value >= 0);\n', '        _amount_ =  msg.value / buyPrice;                 // calculates the amount\n', '        if (_amount_ > balances[this]) {\n', '            _amount_ = balances[this];\n', '            uint256 valueWei = _amount_ * buyPrice;\n', '            msg.sender.transfer(msg.value - valueWei);\n', '        }\n', '        balances[msg.sender] += _amount_;                  // adds the amount to buyer&#39;s balance\n', '        balances[this] -= _amount_;                        // subtracts amount from seller&#39;s balance\n', '        Transfer(this, msg.sender, _amount_);              \n', '        \n', '         uint64 _now = uint64(now);\n', '        return _amount_;                                    \n', ' }\n', '\n', ' function sell_toContract (uint256 amount_toSell)  public { \n', '        if (balances[msg.sender] < amount_toSell) {\n', '            amount_toSell = balances[msg.sender];\n', '        }\n', '        require (amount_toSell <= (8 * 1e18 / Buy_Wall_level_in_wei)); // max to sell by 1 function&#39;s call is 100 000 assets  \n', '        balances[this] += amount_toSell;                           // adds the amount to owner&#39;s balance\n', '        balances[msg.sender] -= amount_toSell;  \n', '        msg.sender.transfer(amount_toSell * Buy_Wall_level_in_wei);          \n', '        Transfer(msg.sender, this, amount_toSell);              \n', '   \n', '        \n', ' }\n', ' /* \n', '  High-Capacity IonChain Transactional System\n', '*/\n', '}']