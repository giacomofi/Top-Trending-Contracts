['pragma solidity ^0.4.18;\n', '\n', '// SafeMath\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '}\n', '\n', '// Standard token interface (ERC 20)\n', '// https://github.com/ethereum/EIPs/issues/20\n', '// Token\n', 'contract Token is SafeMath {\n', '    // Functions:\n', '    /// @return total amount of tokens\n', '    function totalSupply() public constant returns (uint256 supply);\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    function transferTo(address _to, uint256 _value) public returns (bool);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    // Events:\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '//StdToken\n', 'contract StdToken is Token {\n', '    // Fields:\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '    uint public supply = 0;\n', '\n', '    // Functions:\n', '    function transferTo(address _to, uint256 _value) public returns (bool) {\n', '        require(balances[msg.sender] >= _value);\n', '        require(balances[_to] + _value > balances[_to]);\n', '\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){\n', '        require(balances[_from] >= _value);\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        require(balances[_to] + _value > balances[_to]);\n', '\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256) {\n', '        return supply;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '// EvoNineToken\n', 'contract EvoNineToken is StdToken\n', '{\n', '    /// Fields:\n', '    string public name = "";\n', '    string public symbol = "EVG";\n', '    string public website = "https://evonine.co";\n', '    uint public decimals = 18;\n', '\n', '    uint public constant TOTAL_SUPPLY = 19000000 * (1 ether / 1 wei);\n', '    uint public constant DEVELOPER_BONUS = 4500000 * (1 ether / 1 wei);\n', '    uint public constant TEAM_BONUS = 3800000 * (1 ether / 1 wei);\n', '    uint public constant ECO_SYSTEM_BONUS = 5700000 * (1 ether / 1 wei);\n', '    uint public constant CONTRACT_HOLDER_BONUS = 5000000 * (1 ether / 1 wei);\n', '\n', '    uint public constant ICO_PRICE1 = 2000;     // per 1 Ether\n', '    uint public constant ICO_PRICE2 = 1818;     // per 1 Ether\n', '    uint public constant ICO_PRICE3 = 1666;     // per 1 Ether\n', '    uint public constant ICO_PRICE4 = 1538;     // per 1 Ether\n', '    uint public constant ICO_PRICE5 = 1250;     // per 1 Ether\n', '    uint public constant ICO_PRICE6 = 1000;     // per 1 Ether\n', '    uint public constant ICO_PRICE7 = 800;     // per 1 Ether\n', '    uint public constant ICO_PRICE8 = 666;     // per 1 Ether\n', '\n', '    enum State{\n', '        Init,\n', '        Paused,\n', '        ICORunning,\n', '        ICOFinished\n', '    }\n', '\n', '    State public currentState = State.Init;\n', '    bool public enableTransfers = true;\n', '\n', '    // Token manager has exclusive priveleges to call administrative\n', '    // functions on this contract.\n', '    address public tokenManagerAddress = 0;\n', '\n', "    // Gathered funds can be withdrawn only to escrow's address.\n", '    address public escrowAddress = 0;\n', '\n', '    // Team bonus address\n', '    address public teamAddress = 0;\n', '\n', '    // Development holder address\n', '    address public developmentAddress = 0;\n', '\n', '    // Eco system holder address\n', '    address public ecoSystemAddress = 0;\n', '\n', '    // Contract holder address\n', '    address public contractHolderAddress = 0;\n', '\n', '\n', '    uint public icoSoldTokens = 0;\n', '    uint public totalSoldTokens = 0;\n', '\n', '    /// Modifiers:\n', '    modifier onlytokenManagerAddress()\n', '    {\n', '        require(msg.sender == tokenManagerAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyTokenCrowner()\n', '    {\n', '        require(msg.sender == escrowAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyInState(State state)\n', '    {\n', '        require(state == currentState);\n', '        _;\n', '    }\n', '\n', '    /// Events:\n', '    event LogBuy(address indexed owner, uint value);\n', '    event LogBurn(address indexed owner, uint value);\n', '\n', '    /// Functions:\n', '    /// @dev Constructor\n', '    /// @param _tokenManagerAddress Token manager address: 0x911AA92E796b10A2c79049FbACA219875a7fd1c9\n', '    /// @param _escrowAddress Escrow address: 0x14522Ed2EcecA9059e5EC2700C3A715CF7d5b69e\n', '    /// @param _teamAddress Team address: 0xfB03a82b11E0BB61f2DFA4eDcFadd6A841eD1496\n', '    /// @param _developmentAddress Development address: 0x0814288347dA7fbA44a6ecEBD5Be2dCeDe035D91\n', '    /// @param _ecoSystemAddress Eco system address: 0x0230a2b2F79274014E7FC71aD04c22188908F69B\n', '    /// @param _contractHolderAddress Contract holder address: 0x4E8eC6420e529819b5A2cD477A083E5459d7A566\n', '    function EvoNineToken(string _name, address _tokenManagerAddress, address _escrowAddress, address _teamAddress, address _developmentAddress, address _ecoSystemAddress, address _contractHolderAddress) public\n', '    {\n', '        name = _name;\n', '        tokenManagerAddress = _tokenManagerAddress;\n', '        escrowAddress = _escrowAddress;\n', '        teamAddress = _teamAddress;\n', '        developmentAddress = _developmentAddress;\n', '        ecoSystemAddress = _ecoSystemAddress;\n', '        contractHolderAddress = _contractHolderAddress;\n', '\n', '        balances[_contractHolderAddress] += TOTAL_SUPPLY;\n', '        supply += TOTAL_SUPPLY;\n', '    }\n', '\n', '    function buyTokens() public payable returns (uint256)\n', '    {\n', '        require(msg.value >= ((1 ether / 1 wei) / 100));\n', '        uint newTokens = msg.value * getPrice();\n', '        balances[msg.sender] += newTokens;\n', '        supply += newTokens;\n', '        icoSoldTokens += newTokens;\n', '        totalSoldTokens += newTokens;\n', '\n', '        LogBuy(msg.sender, newTokens);\n', '    }\n', '\n', '    function getPrice() public constant returns (uint)\n', '    {\n', '        if (icoSoldTokens < (4100000 * (1 ether / 1 wei))) {\n', '            return ICO_PRICE1;\n', '        }\n', '        if (icoSoldTokens < (4300000 * (1 ether / 1 wei))) {\n', '            return ICO_PRICE2;\n', '        }\n', '        if (icoSoldTokens < (4700000 * (1 ether / 1 wei))) {\n', '            return ICO_PRICE3;\n', '        }\n', '        if (icoSoldTokens < (5200000 * (1 ether / 1 wei))) {\n', '            return ICO_PRICE4;\n', '        }\n', '        if (icoSoldTokens < (6000000 * (1 ether / 1 wei))) {\n', '            return ICO_PRICE5;\n', '        }\n', '        if (icoSoldTokens < (7000000 * (1 ether / 1 wei))) {\n', '            return ICO_PRICE6;\n', '        }\n', '        if (icoSoldTokens < (8000000 * (1 ether / 1 wei))) {\n', '            return ICO_PRICE7;\n', '        }\n', '        return ICO_PRICE8;\n', '    }\n', '\n', '    function setState(State _nextState) public onlytokenManagerAddress\n', '    {\n', "        //setState() method call shouldn't be entertained after ICOFinished\n", '        require(currentState != State.ICOFinished);\n', '\n', '        currentState = _nextState;\n', '        // enable/disable transfers\n', '        //enable transfers only after ICOFinished, disable otherwise\n', '        //enableTransfers = (currentState==State.ICOFinished);\n', '    }\n', '\n', '    function DisableTransfer() public onlytokenManagerAddress\n', '    {\n', '        enableTransfers = false;\n', '    }\n', '\n', '\n', '    function EnableTransfer() public onlytokenManagerAddress\n', '    {\n', '        enableTransfers = true;\n', '    }\n', '\n', '    function withdrawEther() public onlytokenManagerAddress\n', '    {\n', '        if (this.balance > 0)\n', '        {\n', '            escrowAddress.transfer(this.balance);\n', '        }\n', '    }\n', '\n', '    /// Overrides:\n', '    function transferTo(address _to, uint256 _value) public returns (bool){\n', '        require(enableTransfers);\n', '        return super.transferTo(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){\n', '        require(enableTransfers);\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        require(enableTransfers);\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '    // Setters/getters\n', '    function ChangetokenManagerAddress(address _mgr) public onlytokenManagerAddress\n', '    {\n', '        tokenManagerAddress = _mgr;\n', '    }\n', '\n', '    // Setters/getters\n', '    function ChangeCrowner(address _mgr) public onlyTokenCrowner\n', '    {\n', '        escrowAddress = _mgr;\n', '    }\n', '}']