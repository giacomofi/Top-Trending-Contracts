['/**\n', " * The edgeless casino contract holds the players's funds and provides state channel functionality.\n", " * The casino has at no time control over the players's funds.\n", ' * State channels can be updated and closed from both parties: the player and the casino.\n', ' * author: Julia Altenried\n', ' **/\n', '\n', 'pragma solidity ^0.4.17;\n', '\n', 'contract SafeMath {\n', '\n', '\tfunction safeSub(uint a, uint b) pure internal returns(uint) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\t\n', '\tfunction safeSub(int a, int b) pure internal returns(int) {\n', '\t\tif(b < 0) assert(a - b > a);\n', '\t\telse assert(a - b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction safeAdd(uint a, uint b) pure internal returns(uint) {\n', '\t\tuint c = a + b;\n', '\t\tassert(c >= a && c >= b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction safeMul(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract owned {\n', '  address public owner;\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function owned() public{\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function changeOwner(address newOwner) onlyOwner public{\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '/** owner should be able to close the contract is nobody has been using it for at least 30 days */\n', 'contract mortal is owned {\n', '\t/** contract can be closed by the owner anytime after this timestamp if non-zero */\n', '\tuint public closeAt;\n', '\t/**\n', '\t* lets the owner close the contract if there are no player funds on it or if nobody has been using it for at least 30 days\n', '\t*/\n', '  function closeContract(uint playerBalance) internal{\n', '\t\tif(playerBalance == 0) selfdestruct(owner);\n', '\t\tif(closeAt == 0) closeAt = now + 30 days;\n', '\t\telse if(closeAt < now) selfdestruct(owner);\n', '  }\n', '\n', '\t/**\n', '\t* in case close has been called accidentally.\n', '\t**/\n', '\tfunction open() onlyOwner public{\n', '\t\tcloseAt = 0;\n', '\t}\n', '\n', '\t/**\n', '\t* make sure the contract is not in process of being closed.\n', '\t**/\n', '\tmodifier isAlive {\n', '\t\trequire(closeAt == 0);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* delays the time of closing.\n', '\t**/\n', '\tmodifier keepAlive {\n', '\t\tif(closeAt > 0) closeAt = now + 30 days;\n', '\t\t_;\n', '\t}\n', '}\n', '\n', '\n', 'contract chargingGas is mortal, SafeMath{\n', '  /** the price per kgas and GWei in tokens (5 decimals) */\n', '\tuint public gasPrice;\n', '\t/** the amount of gas used per transaction in kGas */\n', '\tmapping(bytes4 => uint) public gasPerTx;\n', '\t\n', '\t/**\n', '\t * sets the amount of gas consumed by methods with the given sigantures.\n', '\t * only called from the edgeless casino constructor.\n', '\t * @param signatures an array of method-signatures\n', '\t *        gasNeeded  the amount of gas consumed by these methods\n', '\t * */\n', '\tfunction setGasUsage(bytes4[3] signatures, uint[3] gasNeeded) internal{\n', '\t  require(signatures.length == gasNeeded.length);\n', '\t  for(uint8 i = 0; i < signatures.length; i++)\n', '\t    gasPerTx[signatures[i]] = gasNeeded[i];\n', '\t}\n', '\t\n', '\t/**\n', '\t * adds the gas cost of the tx to the given value.\n', '\t * @param value the value to add the gas cost to\n', '\t * */\n', '\tfunction addGas(uint value) internal constant returns(uint){\n', '  \treturn safeAdd(value,getGasCost());\n', '\t}\n', '\t\n', '\t/**\n', '\t * subtracts the gas cost of the tx from the given value.\n', '\t * @param value the value to subtract the gas cost from\n', '\t * */\n', '\tfunction subtractGas(uint value) internal constant returns(uint){\n', '  \treturn safeSub(value,getGasCost());\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t* updates the price per 1000 gas in EDG.\n', '\t* @param price the new gas price (4 decimals, max 0.0256 EDG)\n', '\t**/\n', '\tfunction setGasPrice(uint8 price) public onlyOwner{\n', '\t\tgasPrice = price;\n', '\t}\n', '\t\n', '\t/**\n', '\t * returns the gas cost of the called function.\n', '\t * */\n', '\tfunction getGasCost() internal constant returns(uint){\n', '\t  return safeMul(safeMul(gasPerTx[msg.sig], gasPrice), tx.gasprice)/1000000000;\n', '\t}\n', '\n', '}\n', '\n', 'contract Token {\n', '\tfunction transferFrom(address sender, address receiver, uint amount) public returns(bool success) {}\n', '\n', '\tfunction transfer(address receiver, uint amount) public returns(bool success) {}\n', '\n', '\tfunction balanceOf(address holder) public constant returns(uint) {}\n', '}\n', '\n', 'contract CasinoBank is chargingGas{\n', '\t/** the total balance of all players with 5 virtual decimals **/\n', '\tuint public playerBalance;\n', '\t/** the balance per player in edgeless tokens with 5 virtual decimals */\n', '\tmapping(address=>uint) public balanceOf;\n', '\t/** in case the user wants/needs to call the withdraw function from his own wallet, he first needs to request a withdrawal */\n', '\tmapping(address=>uint) public withdrawAfter;\n', '\t/** the edgeless token contract */\n', '\tToken edg;\n', '\t/** the maximum amount of tokens the user is allowed to deposit (5 decimals) */\n', '\tuint public maxDeposit;\n', '\t/** waiting time for withdrawal if not requested via the server **/\n', '\tuint public waitingTime;\n', '\t\n', '\t/** informs listeners how many tokens were deposited for a player */\n', '\tevent Deposit(address _player, uint _numTokens, bool _chargeGas);\n', '\t/** informs listeners how many tokens were withdrawn from the player to the receiver address */\n', '\tevent Withdrawal(address _player, address _receiver, uint _numTokens);\n', '\n', '\tfunction CasinoBank(address tokenContract, uint depositLimit) public{\n', '\t\tedg = Token(tokenContract);\n', '\t\tmaxDeposit = depositLimit;\n', '\t\twaitingTime = 90 minutes;\n', '\t}\n', '\n', '\t/**\n', '\t* accepts deposits for an arbitrary address.\n', '\t* retrieves tokens from the message sender and adds them to the balance of the specified address.\n', '\t* edgeless tokens do not have any decimals, but are represented on this contract with 5 decimals.\n', '\t* @param receiver  address of the receiver\n', '\t*        numTokens number of tokens to deposit (0 decimals)\n', "\t*\t\t\t\t chargeGas indicates if the gas cost is subtracted from the user's edgeless token balance\n", '\t**/\n', '\tfunction deposit(address receiver, uint numTokens, bool chargeGas) public isAlive{\n', '\t\trequire(numTokens > 0);\n', '\t\tuint value = safeMul(numTokens,100000);\n', '\t\tif(chargeGas) value = subtractGas(value);\n', '\t\tuint newBalance = safeAdd(balanceOf[receiver], value);\n', '\t\trequire(newBalance <= maxDeposit);\n', '\t\tassert(edg.transferFrom(msg.sender, address(this), numTokens));\n', '\t\tbalanceOf[receiver] = newBalance;\n', '\t\tplayerBalance = safeAdd(playerBalance, value);\n', '\t\tDeposit(receiver, numTokens, chargeGas);\n', '  }\n', '\n', '\t/**\n', '\t* If the user wants/needs to withdraw his funds himself, he needs to request the withdrawal first.\n', "\t* This method sets the earliest possible withdrawal date to 'waitingTime from now (default 90m, but up to 24h).\n", '\t* Reason: The user should not be able to withdraw his funds, while the the last game methods have not yet been mined.\n', '\t**/\n', '\tfunction requestWithdrawal() public{\n', '\t\twithdrawAfter[msg.sender] = now + waitingTime;\n', '\t}\n', '\n', '\t/**\n', '\t* In case the user requested a withdrawal and changes his mind.\n', '\t* Necessary to be able to continue playing.\n', '\t**/\n', '\tfunction cancelWithdrawalRequest() public{\n', '\t\twithdrawAfter[msg.sender] = 0;\n', '\t}\n', '\n', '\t/**\n', '\t* withdraws an amount from the user balance if the waiting time passed since the request.\n', '\t* @param amount the amount of tokens to withdraw\n', '\t**/\n', '\tfunction withdraw(uint amount) public keepAlive{\n', '\t\trequire(withdrawAfter[msg.sender]>0 && now>withdrawAfter[msg.sender]);\n', '\t\twithdrawAfter[msg.sender] = 0;\n', '\t\tuint value = safeMul(amount,100000);\n', '\t\tbalanceOf[msg.sender]=safeSub(balanceOf[msg.sender],value);\n', '\t\tplayerBalance = safeSub(playerBalance, value);\n', '\t\tassert(edg.transfer(msg.sender, amount));\n', '\t\tWithdrawal(msg.sender, msg.sender, amount);\n', '\t}\n', '\n', '\t/**\n', '\t* lets the owner withdraw from the bankroll\n', '\t* @param numTokens the number of tokens to withdraw (0 decimals)\n', '\t**/\n', '\tfunction withdrawBankroll(uint numTokens) public onlyOwner {\n', '\t\trequire(numTokens <= bankroll());\n', '\t\tassert(edg.transfer(owner, numTokens));\n', '\t}\n', '\n', '\t/**\n', '\t* returns the current bankroll in tokens with 0 decimals\n', '\t**/\n', '\tfunction bankroll() constant public returns(uint){\n', '\t\treturn safeSub(edg.balanceOf(address(this)), playerBalance/100000);\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t* updates the maximum deposit.\n', '\t* @param newMax the new maximum deposit (5 decimals)\n', '\t**/\n', '\tfunction setMaxDeposit(uint newMax) public onlyOwner{\n', '\t\tmaxDeposit = newMax;\n', '\t}\n', '\t\n', '\t/**\n', '\t * sets the time the player has to wait for his funds to be unlocked before withdrawal (if not withdrawing with help of the casino server).\n', '\t * the time may not be longer than 24 hours.\n', '\t * @param newWaitingTime the new waiting time in seconds\n', '\t * */\n', '\tfunction setWaitingTime(uint newWaitingTime) public onlyOwner{\n', '\t\trequire(newWaitingTime <= 24 hours);\n', '\t\twaitingTime = newWaitingTime;\n', '\t}\n', '\n', '\t/**\n', '\t * lets the owner close the contract if there are no player funds on it or if nobody has been using it for at least 30 days\n', '\t * */\n', '\tfunction close() public onlyOwner{\n', '\t\tcloseContract(playerBalance);\n', '\t}\n', '}\n', '\n', 'contract EdgelessCasino is CasinoBank{\n', "\t/** indicates if an address is authorized to act in the casino's name  */\n", '    mapping(address => bool) public authorized;\n', '\t/** a number to count withdrawal signatures to ensure each signature is different even if withdrawing the same amount to the same address */\n', '\tmapping(address => uint) public withdrawCount;\n', '\t/** the most recent known state of a state channel */\n', '\tmapping(address => State) public lastState;\n', '    /** fired when the state is updated */\n', '    event StateUpdate(uint128 count, int128 winBalance, int difference, uint gasCost, address player, uint128 lcount);\n', '    /** fired if one of the parties chooses to log the seeds and results */\n', '    event GameData(address player, bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results);\n', '  \n', '\tstruct State{\n', '\t\tuint128 count;\n', '\t\tint128 winBalance;\n', '\t}\n', '\n', '    modifier onlyAuthorized {\n', '        require(authorized[msg.sender]);\n', '        _;\n', '    }\n', '\n', '\n', '  /**\n', '  * creates a new edgeless casino contract.\n', '  * @param authorizedAddress the address which may send transactions to the Edgeless Casino\n', '  *\t\t\t\t tokenContract     the address of the Edgeless token contract\n', '  * \t\t\t depositLimit      the maximum deposit allowed\n', '  * \t\t\t kGasPrice\t\t\t\t the price per kGas in WEI\n', '  **/\n', '  function EdgelessCasino(address authorizedAddress, address tokenContract, uint depositLimit, uint8 kGasPrice) CasinoBank(tokenContract, depositLimit) public{\n', '    authorized[authorizedAddress] = true;\n', '    //deposit, withdrawFor, updateChannel\n', '    bytes4[3] memory signatures = [bytes4(0x3edd1128),0x9607610a, 0x713d30c6];\n', '    //amount of gas consumed by the above methods in GWei\n', '    uint[3] memory gasUsage = [uint(141),95,60];\n', '    setGasUsage(signatures, gasUsage);\n', '    setGasPrice(kGasPrice);\n', '  }\n', '\n', '\n', '  /**\n', "  * transfers an amount from the contract balance to the owner's wallet.\n", '  * @param receiver the receiver address\n', '\t*\t\t\t\t amount   the amount of tokens to withdraw (0 decimals)\n', '\t*\t\t\t\t v,r,s \t\tthe signature of the player\n', '  **/\n', '  function withdrawFor(address receiver, uint amount, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized keepAlive{\n', '\tvar player = ecrecover(keccak256(receiver, amount, withdrawCount[receiver]), v, r, s);\n', '\twithdrawCount[receiver]++;\n', '\tuint value = addGas(safeMul(amount,100000));\n', '    balanceOf[player] = safeSub(balanceOf[player], value);\n', '\tplayerBalance = safeSub(playerBalance, value);\n', '    assert(edg.transfer(receiver, amount));\n', '\tWithdrawal(player, receiver, amount);\n', '  }\n', '\n', '  /**\n', '  * authorize a address to call game functions.\n', '  * @param addr the address to be authorized\n', '  **/\n', '  function authorize(address addr) public onlyOwner{\n', '    authorized[addr] = true;\n', '  }\n', '\n', '  /**\n', '  * deauthorize a address to call game functions.\n', '  * @param addr the address to be deauthorized\n', '  **/\n', '  function deauthorize(address addr) public onlyOwner{\n', '    authorized[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * closes a state channel. can also be used for intermediate state updates. can be called by both parties.\n', '   * 1. verifies the signature.\n', '   * 2. verifies if the signed game-count is higher than the last known game-count of this channel.\n', '   * 3. updates the balances accordingly. This means: It checks the already performed updates for this channel and computes\n', '   *    the new balance difference to add or subtract from the playerâ€˜s balance.\n', '   * @param winBalance the current win or loss\n', '   *\t\t\t\tgameCount  the number of signed game moves\n', '   *\t\t\t\tv,r,s      the signature of either the casino or the player\n', '   * */\n', '  function updateState(int128 winBalance,  uint128 gameCount, uint8 v, bytes32 r, bytes32 s) public{\n', '  \taddress player = determinePlayer(winBalance, gameCount, v, r, s);\n', '  \tuint gasCost = 0;\n', '  \tif(player == msg.sender)//if the player closes the state channel himself, make sure the signer is a casino wallet\n', '  \t\trequire(authorized[ecrecover(keccak256(player, winBalance, gameCount), v, r, s)]);\n', '  \telse//if the casino wallet is the sender, subtract the gas costs from the player balance\n', '  \t\tgasCost = getGasCost();\n', '  \tState storage last = lastState[player];\n', '  \trequire(gameCount > last.count);\n', '  \tint difference = updatePlayerBalance(player, winBalance, last.winBalance, gasCost);\n', '  \tlastState[player] = State(gameCount, winBalance);\n', '  \tStateUpdate(gameCount, winBalance, difference, gasCost, player, last.count);\n', '  }\n', '\n', '  /**\n', "   * determines if the msg.sender or the signer of the passed signature is the player. returns the player's address\n", '   * @param winBalance the current winBalance, used to calculate the msg hash\n', '   *\t\t\t\tgameCount  the current gameCount, used to calculate the msg.hash\n', '   *\t\t\t\tv, r, s    the signature of the non-sending party\n', '   * */\n', '  function determinePlayer(int128 winBalance, uint128 gameCount, uint8 v, bytes32 r, bytes32 s) constant internal returns(address){\n', '  \tif (authorized[msg.sender])//casino is the sender -> player is the signer\n', '  \t\treturn ecrecover(keccak256(winBalance, gameCount), v, r, s);\n', '  \telse\n', '  \t\treturn msg.sender;\n', '  }\n', '\n', '\t/**\n', "\t * computes the difference of the win balance relative to the last known state and adds it to the player's balance.\n", "\t * in case the casino is the sender, the gas cost in EDG gets subtracted from the player's balance.\n", '\t * @param player the address of the player\n', '\t *\t\t\t\twinBalance the current win-balance\n', '\t *\t\t\t\tlastWinBalance the win-balance of the last known state\n', '\t *\t\t\t\tgasCost the gas cost of the tx\n', '\t * */\n', '  function updatePlayerBalance(address player, int128 winBalance, int128 lastWinBalance, uint gasCost) internal returns(int difference){\n', '  \tdifference = safeSub(winBalance, lastWinBalance);\n', '  \tint outstanding = safeSub(difference, int(gasCost));\n', '  \tuint outs;\n', '  \tif(outstanding < 0){\n', '  \t\touts = uint256(outstanding * (-1));\n', '  \t\tplayerBalance = safeSub(playerBalance, outs);\n', '  \t\tbalanceOf[player] = safeSub(balanceOf[player], outs);\n', '  \t}\n', '  \telse{\n', '  \t\touts = uint256(outstanding);\n', '  \t  playerBalance = safeAdd(playerBalance, outs);\n', '  \t  balanceOf[player] = safeAdd(balanceOf[player], outs);\n', '  \t}\n', '  }\n', '  \n', '  /**\n', '   * logs some seeds and game results for players wishing to have their game history logged by the contract\n', '   * @param serverSeeds array containing the server seeds\n', '   *        clientSeeds array containing the client seeds\n', '   *        results     array containing the results\n', '   *        v, r, s     the signature of the non-sending party (to make sure the corrcet results are logged)\n', '   * */\n', '  function logGameData(bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint8 v, bytes32 r, bytes32 s) public{\n', '    address player = determinePlayer(serverSeeds, clientSeeds, results, v, r, s);\n', '    GameData(player, serverSeeds, clientSeeds, results);\n', '    //charge gas in case the server is logging the results for the player\n', '    if(player != msg.sender){\n', '      uint gasCost = (57 + 768 * serverSeeds.length / 1000)*gasPrice;\n', '      balanceOf[player] = safeSub(balanceOf[player], gasCost);\n', '      playerBalance = safeSub(playerBalance, gasCost);\n', '    }\n', '  }\n', '  \n', '  /**\n', "   * determines if the msg.sender or the signer of the passed signature is the player. returns the player's address\n", '   * @param serverSeeds array containing the server seeds\n', '   *        clientSeeds array containing the client seeds\n', '   *        results     array containing the results\n', '   *\t\t\t\tv, r, s    the signature of the non-sending party\n', '   * */\n', '  function determinePlayer(bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint8 v, bytes32 r, bytes32 s) constant internal returns(address){\n', '  \tif (authorized[msg.sender])//casino is the sender -> player is the signer\n', '  \t\treturn ecrecover(keccak256(serverSeeds, clientSeeds, results), v, r, s);\n', '  \telse\n', '  \t\treturn msg.sender;\n', '  }\n', '\n', '}']