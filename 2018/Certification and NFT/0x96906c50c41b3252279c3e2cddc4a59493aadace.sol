['pragma solidity ^0.4.16;\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', 'contract Voter {\n', '    \n', '    struct Proposal{\n', '        bytes32 name;\n', '    }\n', '    \n', '    struct Ballot{\n', '        bytes32 name;\n', '        address chainperson;\n', '        bool blind;\n', '        bool finished;\n', '    }\n', '    \n', '    struct votedData{\n', '        uint256 proposal;\n', '        bool isVal;\n', '    }\n', '    \n', '    event Vote(\n', '        address votedPerson,\n', '        uint256 proposalIndex\n', '        );\n', '        \n', '    event Finish(\n', '        bool finished\n', '        );\n', '\n', '    mapping (address => mapping(uint256 => mapping(address => votedData))) votedDatas;\n', '    mapping (address => mapping(uint256 => address[])) voted;\n', '    mapping (address => mapping(uint256 => mapping(uint256 => uint256))) voteCount;\n', '    mapping (address => Ballot[]) public ballots;   \n', '    mapping (address => mapping(uint256 => Proposal[])) public proposals;\n', '    \n', '    function getBallotsNum(address chainperson) public constant returns (uint count) {\n', '        return ballots[chainperson].length; \n', '    }\n', '    function getProposalsNum(address chainperson, uint ballot) public constant returns (uint count) {\n', '        return proposals[chainperson][ballot].length;\n', '    }\n', '    \n', '    function getBallotIndex(address chainperson, bytes32 ballotName) public constant returns (uint index){\n', '        for (uint i=0;i<ballots[chainperson].length;i++){\n', '            if (ballots[chainperson][i].name == ballotName){\n', '                return i;\n', '            }\n', '        }\n', '    }\n', '    function isVoted(address chainperson, uint ballot) public constant returns (bool result){\n', '        for (uint8 i=0;i<voted[chainperson][ballot].length;i++){\n', '            if (voted[chainperson][ballot][i] == msg.sender){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '    function startNewBallot(bytes32 ballotName, bool blindParam, bytes32[] proposalNames) external returns (bool success){\n', '        for (uint8 y=0;y<ballots[msg.sender].length;y++){\n', '            if (ballots[msg.sender][i].name == ballotName){\n', '                revert();\n', '            }\n', '        }\n', '        ballots[msg.sender].push(Ballot({\n', '            name: ballotName, \n', '            chainperson: msg.sender, \n', '            blind: blindParam,\n', '            finished: false\n', '        }));\n', '        \n', '        uint ballotsNum = ballots[msg.sender].length;\n', '        for (uint8 i=0;i<proposalNames.length;i++){\n', '            proposals[msg.sender][ballotsNum-1].push(Proposal({name:proposalNames[i]}));\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function getVoted(address chainperson, uint256 ballot) public constant returns (address[]){\n', '        if (ballots[chainperson][ballot].blind == true){\n', '            revert();\n', '        }\n', '        return voted[chainperson][ballot];\n', '    }\n', '    \n', '    function getVotesCount(address chainperson, uint256 ballot, bytes32 proposalName) public constant returns (uint256 count){\n', '        if (ballots[chainperson][ballot].blind == true){\n', '            revert();\n', '        }\n', '        \n', '        for (uint8 i=0;i<proposals[chainperson][ballot].length;i++){\n', '            if (proposals[chainperson][ballot][i].name == proposalName){\n', '                return voteCount[chainperson][ballot][i];\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getVotedData(address chainperson, uint256 ballot, address voter) public constant returns (uint256 proposalNum){\n', '        if (ballots[chainperson][ballot].blind == true){\n', '            revert();\n', '        }\n', '        \n', '        if (votedDatas[chainperson][ballot][voter].isVal == true){\n', '            return votedDatas[chainperson][ballot][voter].proposal;\n', '        }\n', '    }\n', '    \n', '    function vote(address chainperson, uint256 ballot, uint256 proposalNum) external returns (bool success){\n', '        \n', '        if (ballots[chainperson][ballot].finished == true){\n', '            revert();\n', '        }\n', '        for (uint8 i = 0;i<voted[chainperson][ballot].length;i++){\n', '            if (votedDatas[chainperson][ballot][msg.sender].isVal == true){\n', '                revert();\n', '            }\n', '        }\n', '        voted[chainperson][ballot].push(msg.sender);\n', '        voteCount[chainperson][ballot][proposalNum]++;\n', '        votedDatas[chainperson][ballot][msg.sender] = votedData({proposal: proposalNum, isVal: true});\n', '        Vote(msg.sender, proposalNum);\n', '        return true;\n', '    }\n', '    \n', '    function getProposalIndex(address chainperson, uint256 ballot, bytes32 proposalName) public constant returns (uint index){\n', '        for (uint8 i=0;i<proposals[chainperson][ballot].length;i++){\n', '            if (proposals[chainperson][ballot][i].name == proposalName){\n', '                return i;\n', '            }\n', '        }\n', '    }\n', '    \n', '    \n', '    function finishBallot(bytes32 ballot) external returns (bool success){\n', '        for (uint8 i=0;i<ballots[msg.sender].length;i++){\n', '            if (ballots[msg.sender][i].name == ballot) {\n', '                if (ballots[msg.sender][i].chainperson == msg.sender){\n', '                    ballots[msg.sender][i].finished = true;\n', '                    Finish(true);\n', '                    return true;\n', '                } else {\n', '                    return false;\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getWinner(address chainperson, uint ballotIndex) public constant returns (bytes32 winnerName){\n', '            if (ballots[chainperson][ballotIndex].finished == false){\n', '                revert();\n', '            }\n', '            uint256 maxVotes;\n', '            bytes32 winner;\n', '            for (uint8 i=0;i<proposals[chainperson][ballotIndex].length;i++){\n', '                if (voteCount[chainperson][ballotIndex][i]>maxVotes){\n', '                    maxVotes = voteCount[chainperson][ballotIndex][i];\n', '                    winner = proposals[chainperson][ballotIndex][i].name;\n', '                }\n', '            }\n', '            return winner;\n', '    }\n', '}\n', 'contract Multisig {\n', '\n', '    /*\n', '    * Types\n', '    */\n', '    struct Transaction {\n', '        uint id;\n', '        address destination;\n', '        uint value;\n', '        bytes data;\n', '        TxnStatus status;\n', '        address[] confirmed;\n', '        address creator;\n', '    }\n', '\n', '    struct Wallet {\n', '        bytes32 name;\n', '        address creator;\n', '        uint id;\n', '        uint allowance;\n', '        address[] owners;\n', '        Log[] logs;\n', '        Transaction[] transactions;\n', '        uint appovalsreq;\n', '    }\n', '    \n', '    struct Log {\n', '        uint amount;\n', '        address sender;\n', '    }\n', '    \n', '    enum TxnStatus { Unconfirmed, Pending, Executed }\n', '    \n', '    /*\n', '    * Modifiers\n', '    */\n', '    modifier onlyOwner ( address creator, uint walletId ) {\n', '        bool found;\n', '        for (uint i = 0;i<wallets[creator][walletId].owners.length;i++){\n', '            if (wallets[creator][walletId].owners[i] == msg.sender){\n', '                found = true;\n', '            }\n', '        }\n', '        if (found){\n', '            _;\n', '        }\n', '    }\n', '    \n', '    /*\n', '    * Events\n', '    */\n', '    event WalletCreated(uint id);\n', '    event TxnSumbitted(uint id);\n', '    event TxnConfirmed(uint id);\n', '    event topUpBalance(uint value);\n', '\n', '    /*\n', '    * Storage\n', '    */\n', '    mapping (address => Wallet[]) public wallets;\n', '    \n', '    /*\n', '    * Constructor\n', '    */\n', '    function ibaMultisig() public{\n', '\n', '    }\n', '\n', '    /*\n', '    * Getters\n', '    */\n', '    function getWalletId(address creator, bytes32 name) external view returns (uint, bool){\n', '        for (uint i = 0;i<wallets[creator].length;i++){\n', '            if (wallets[creator][i].name == name){\n', '                return (i, true);\n', '            }\n', '        }\n', '    }\n', '\n', '    function getOwners(address creator, uint id) external view returns (address[]){\n', '        return wallets[creator][id].owners;\n', '    }\n', '    \n', '    function getTxnNum(address creator, uint id) external view returns (uint){\n', '        require(wallets[creator][id].owners.length > 0);\n', '        return wallets[creator][id].transactions.length;\n', '    }\n', '    \n', '    function getTxn(address creator, uint walletId, uint id) external view returns (uint, address, uint, bytes, TxnStatus, address[], address){\n', '        Transaction storage txn = wallets[creator][walletId].transactions[id];\n', '        return (txn.id, txn.destination, txn.value, txn.data, txn.status, txn.confirmed, txn.creator);\n', '    }\n', '    \n', '    function getLogsNum(address creator, uint id) external view returns (uint){\n', '        return wallets[creator][id].logs.length;\n', '    }\n', '    \n', '    function getLog(address creator, uint id, uint logId) external view returns (address, uint){\n', '        return(wallets[creator][id].logs[logId].sender, wallets[creator][id].logs[logId].amount);\n', '    }\n', '    \n', '    /*\n', '    * Methods\n', '    */\n', '    \n', '    function createWallet(uint approvals, address[] owners, bytes32 name) external payable{\n', '\n', '        /* check if name was actually given */\n', '        require(name.length != 0);\n', '        \n', '        /*check if approvals num equals or greater than given owners num*/\n', '        require(approvals <= owners.length);\n', '        \n', '        /* check if wallets with given name already exists */\n', '        bool found;\n', '        for (uint i = 0; i<wallets[msg.sender].length;i++){\n', '            if (wallets[msg.sender][i].name == name){\n', '                found = true;\n', '            }\n', '        }\n', '        require (found == false);\n', '        \n', '        /*instantiate new wallet*/\n', '        uint currentLen = wallets[msg.sender].length++;\n', '        wallets[msg.sender][currentLen].name = name;\n', '        wallets[msg.sender][currentLen].creator = msg.sender;\n', '        wallets[msg.sender][currentLen].id = currentLen;\n', '        wallets[msg.sender][currentLen].allowance = msg.value;\n', '        wallets[msg.sender][currentLen].owners = owners;\n', '        wallets[msg.sender][currentLen].appovalsreq = approvals;\n', '        emit WalletCreated(currentLen);\n', '    }\n', '\n', '    function topBalance(address creator, uint id) external payable {\n', '        require (msg.value > 0 wei);\n', '        wallets[creator][id].allowance += msg.value;\n', '        \n', '        /* create new log entry */\n', '        uint loglen = wallets[creator][id].logs.length++;\n', '        wallets[creator][id].logs[loglen].amount = msg.value;\n', '        wallets[creator][id].logs[loglen].sender = msg.sender;\n', '        emit topUpBalance(msg.value);\n', '    }\n', '    \n', '    function submitTransaction(address creator, address destination, uint walletId, uint value, bytes data) onlyOwner (creator,walletId) external returns (bool) {\n', '        uint newTxId = wallets[creator][walletId].transactions.length++;\n', '        wallets[creator][walletId].transactions[newTxId].id = newTxId;\n', '        wallets[creator][walletId].transactions[newTxId].destination = destination;\n', '        wallets[creator][walletId].transactions[newTxId].value = value;\n', '        wallets[creator][walletId].transactions[newTxId].data = data;\n', '        wallets[creator][walletId].transactions[newTxId].creator = msg.sender;\n', '        emit TxnSumbitted(newTxId);\n', '        return true;\n', '    }\n', '\n', '    function confirmTransaction(address creator, uint walletId, uint txId) onlyOwner(creator, walletId) external returns (bool){\n', '        Wallet storage wallet = wallets[creator][walletId];\n', '        Transaction storage txn = wallet.transactions[txId];\n', '\n', '        //check whether this owner has already confirmed this txn\n', '                \n', '        bool f;\n', '        for (uint8 i = 0; i<txn.confirmed.length;i++){\n', '            if (txn.confirmed[i] == msg.sender){\n', '                f = true;\n', '            }\n', '        }\n', '        //push sender address into confirmed array if havent found\n', '                                                       \n', '        require(!f);\n', '        txn.confirmed.push(msg.sender);\n', '        \n', '        if (txn.confirmed.length == wallet.appovalsreq){\n', '            txn.status = TxnStatus.Pending;\n', '        }\n', '        \n', '        //fire event\n', '                                                       \n', '        emit TxnConfirmed(txId);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function executeTxn(address creator, uint walletId, uint txId) onlyOwner(creator, walletId) external returns (bool){\n', '        Wallet storage wallet = wallets[creator][walletId];\n', '        \n', '        Transaction storage txn = wallet.transactions[txId];\n', '        \n', '        /* check txn status */\n', '        require(txn.status == TxnStatus.Pending);\n', '        \n', '        /* check whether wallet has sufficient balance to send this transaction */\n', '        require(wallet.allowance >= txn.value);\n', '        \n', '        /* send transaction */\n', '        address dest = txn.destination;\n', '        uint val = txn.value;\n', '        bytes memory dat = txn.data;\n', '        assert(dest.call.value(val)(dat));\n', '            \n', '        /* change transaction&#39;s status to executed */\n', '        txn.status = TxnStatus.Executed;\n', '\n', '        /* change wallet&#39;s balance */\n', '        wallet.allowance = wallet.allowance - txn.value;\n', '\n', '        return true;\n', '        \n', '    }\n', '}\n', 'contract Escrow{\n', '    \n', '    struct Bid{\n', '        bytes32 name;\n', '        address oracle;\n', '        address seller;\n', '        address buyer;\n', '        uint price;\n', '        uint timeout;\n', '        dealStatus status;\n', '        uint fee;\n', '        bool isLimited;\n', '    }\n', '    \n', '    enum dealStatus{ unPaid, Pending, Closed, Rejected, Refund }\n', '    \n', '    mapping (address => Bid[]) public bids;\n', '    mapping (address => uint) public pendingWithdrawals;\n', '    \n', '    event amountRecieved(\n', '        address seller,\n', '        uint bidId\n', '    );\n', '    \n', '    event bidClosed(\n', '        address seller,\n', '        uint bidId\n', '        );\n', '        \n', '    event bidCreated(\n', '        address seller,\n', '        bytes32 name,\n', '        uint bidId\n', '        );\n', '        \n', '    event refundDone(\n', '        address seller,\n', '        uint bidId\n', '        );\n', '        \n', '    event withdrawDone(\n', '        address person,\n', '        uint amount\n', '        );\n', '    \n', '    event bidRejected(\n', '        address seller,\n', '        uint bidId\n', '        );\n', '        \n', '    function getBidIndex(address seller, bytes32 name) public constant returns (uint){\n', '        for (uint8 i=0;i<bids[seller].length;i++){\n', '            if (bids[seller][i].name == name){\n', '                return i;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getBidsNum (address seller) public constant returns (uint bidsNum) {\n', '        return bids[seller].length;\n', '    }\n', '    \n', '    function sendAmount (address seller, uint bidId) external payable{\n', '        Bid storage a = bids[seller][bidId];\n', '        require(msg.value == a.price && a.status == dealStatus.unPaid);\n', '        if (a.isLimited == true){\n', '            require(a.timeout > block.number);\n', '        }\n', '        a.status = dealStatus.Pending;\n', '        amountRecieved(seller, bidId);\n', '    }\n', '    \n', '    function createBid (bytes32 name, address seller, address oracle, address buyer, uint price, uint timeout, uint fee) external{\n', '        require(name.length != 0 && price !=0);\n', '        bool limited = true;\n', '        if (timeout == 0){\n', '            limited = false;\n', '        }\n', '        bids[seller].push(Bid({\n', '            name: name, \n', '            oracle: oracle, \n', '            seller: seller, \n', '            buyer: buyer,\n', '            price: price,\n', '            timeout: block.number+timeout,\n', '            status: dealStatus.unPaid,\n', '            fee: fee,\n', '            isLimited: limited\n', '        }));\n', '        uint bidId = bids[seller].length-1;\n', '        bidCreated(seller, name, bidId);\n', '    }\n', '    \n', '    function closeBid(address seller, uint bidId) external returns (bool){\n', '        Bid storage bid = bids[seller][bidId];\n', '        if (bid.isLimited == true){\n', '            require(bid.timeout > block.number);\n', '        }\n', '        require(msg.sender == bid.oracle && bid.status == dealStatus.Pending);\n', '        bid.status = dealStatus.Closed;\n', '        pendingWithdrawals[bid.seller]+=bid.price-bid.fee;\n', '        pendingWithdrawals[bid.oracle]+=bid.fee;\n', '        withdraw(bid.seller);\n', '        withdraw(bid.oracle);\n', '        bidClosed(seller, bidId);\n', '        return true;\n', '    }\n', '    \n', '    function refund(address seller, uint bidId) external returns (bool){\n', '        require(bids[seller][bidId].buyer == msg.sender && bids[seller][bidId].isLimited == true && bids[seller][bidId].timeout < block.number && bids[seller][bidId].status == dealStatus.Pending);\n', '        Bid storage a = bids[seller][bidId];\n', '        a.status = dealStatus.Refund;\n', '        pendingWithdrawals[a.buyer] = a.price;\n', '        withdraw(a.buyer);\n', '        refundDone(seller,bidId);\n', '        return true;\n', '    }\n', '    function rejectBid(address seller, uint bidId) external returns (bool){\n', '        if (bids[seller][bidId].isLimited == true){\n', '            require(bids[seller][bidId].timeout > block.number);\n', '        }\n', '        require(msg.sender == bids[seller][bidId].oracle && bids[seller][bidId].status == dealStatus.Pending);\n', '        Bid storage bid = bids[seller][bidId];\n', '        bid.status = dealStatus.Rejected;\n', '        pendingWithdrawals[bid.oracle] = bid.fee;\n', '        pendingWithdrawals[bid.buyer] = bid.price-bid.fee;\n', '        withdraw(bid.buyer);\n', '        withdraw(bid.oracle);\n', '        bidRejected(seller, bidId);\n', '        return true;\n', '    }\n', '    \n', '    function withdraw(address person) private{\n', '        uint amount = pendingWithdrawals[person];\n', '        pendingWithdrawals[person] = 0;\n', '        person.transfer(amount);\n', '        withdrawDone(person, amount);\n', '    }\n', '    \n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract HideraNetwork {\n', '                \n', '    // Public variables of the token\n', '                \n', '    string public name;\n', '                \n', '    string public symbol;\n', '                \n', '    uint8 public decimals = 8;\n', '                \n', '    // 8 decimals is the strongly suggested default, avoid changing it\n', '                \n', '    uint256 public totalSupply;\n', '\n', '    // This creates an array with all balances\n', '                \n', '    mapping (address => uint256) public balanceOf;\n', '                \n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '                \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '    // This generates a public event on the blockchain that will notify clients\n', '                \n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    // This notifies clients about the amount burnt\n', '                \n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    /**\n', '     * Constrctor function\n', '     *\n', '     * Initializes contract with initial supply tokens to the creator of the contract\n', '     */\n', '    function HideraNetwork(\n', '        uint256 initialSupply,\n', '        string tokenName,\n', '        string tokenSymbol\n', '    ) public {\n', '        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n', '                \n', '        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n', '                \n', '        name = tokenName;                                   // Set the name for display purposes\n', '                \n', '        symbol = tokenSymbol;                               // Set the symbol for display purposes\n', '                \n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '                \n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '                \n', '        require(_to != 0x0);\n', '                \n', '        // Check if the sender has enough\n', '                \n', '        require(balanceOf[_from] >= _value);\n', '                \n', '        // Check for overflows\n', '                \n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '                \n', '        // Save this for an assertion in the future\n', '                \n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '                \n', '        // Subtract from the sender\n', '                \n', '        balanceOf[_from] -= _value;\n', '                \n', '        // Add the same to the recipient\n', '                \n', '        balanceOf[_to] += _value;\n', '                \n', '        emit Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '                \n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply -= _value;                      // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n', '        allowance[_from][msg.sender] -= _value;             // Subtract from the senders allowance\n', '        totalSupply -= _value;                              // Update totalSupply\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', '/******************************************/\n', '/*       ADVANCED TOKEN STARTS HERE       */\n', '/******************************************/\n', '\n', 'contract HIDERA is owned, HideraNetwork {\n', '\n', '    uint256 public sellPrice;\n', '    uint256 public buyPrice;\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function HIDERA(\n', '        uint256 initialSupply,\n', '        string tokenName,\n', '        string tokenSymbol,\n', '        uint256 tokenDecimals\n', '        \n', '    ) HideraNetwork(initialSupply, tokenName, tokenSymbol) public {}\n', '\n', '    /* Internal transfer, only can be called by this contract */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n', '        require (balanceOf[_from] >= _value);               // Check if the sender has enough\n', '        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n', '        require(!frozenAccount[_from]);                     // Check if sender is frozen\n', '        require(!frozenAccount[_to]);                       // Check if recipient is frozen\n', '        balanceOf[_from] -= _value;                         // Subtract from the sender\n', '        balanceOf[_to] += _value;                           // Add the same to the recipient\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /// @notice Create `mintedAmount` tokens and send it to `target`\n', '                \n', '    /// @param target Address to receive the tokens\n', '                \n', '    /// @param mintedAmount the amount of tokens it will receive\n', '                \n', '    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n', '        balanceOf[target] += mintedAmount;\n', '        totalSupply += mintedAmount;\n', '        emit Transfer(0, this, mintedAmount);\n', '        emit Transfer(this, target, mintedAmount);\n', '    }\n', '\n', '    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '                \n', '    /// @param target Address to be frozen\n', '                \n', '    /// @param freeze either to freeze it or not\n', '                \n', '    function freezeAccount(address target, bool freeze) onlyOwner public {\n', '        frozenAccount[target] = freeze;\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '\n', '    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\n', '                \n', '    /// @param newSellPrice Price the users can sell to the contract\n', '                \n', '    /// @param newBuyPrice Price users can buy from the contract\n', '                \n', '    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {\n', '        sellPrice = newSellPrice;\n', '        buyPrice = newBuyPrice;\n', '    }\n', '\n', '    /// @notice Buy tokens from contract by sending ether\n', '                \n', '    function buy() payable public {\n', '        uint amount = msg.value / buyPrice;               // calculates the amount\n', '        _transfer(this, msg.sender, amount);              // makes the transfers\n', '    }\n', '\n', '    /// @notice Sell `amount` tokens to contract\n', '                \n', '    /// @param amount amount of tokens to be sold\n', '                \n', '    function sell(uint256 amount) public {\n', '        address myAddress = this;\n', '        require(myAddress.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy\n', '        _transfer(msg.sender, this, amount);              // makes the transfers\n', '        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. Its important to do this last to avoid recursion attacks\n', '    }\n', '}']