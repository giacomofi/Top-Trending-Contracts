['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract UserRegistryInterface {\n', '  event AddAddress(address indexed who);\n', '  event AddIdentity(address indexed who);\n', '\n', '  function knownAddress(address _who) public constant returns(bool);\n', '  function hasIdentity(address _who) public constant returns(bool);\n', '  function systemAddresses(address _to, address _from) public constant returns(bool);\n', '}\n', '\n', 'contract MultiOwners {\n', '\n', '    event AccessGrant(address indexed owner);\n', '    event AccessRevoke(address indexed owner);\n', '    \n', '    mapping(address => bool) owners;\n', '    address public publisher;\n', '\n', '    function MultiOwners() public {\n', '        owners[msg.sender] = true;\n', '        publisher = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() { \n', '        require(owners[msg.sender] == true);\n', '        _; \n', '    }\n', '\n', '    function isOwner() public constant returns (bool) {\n', '        return owners[msg.sender] ? true : false;\n', '    }\n', '\n', '    function checkOwner(address maybe_owner) public constant returns (bool) {\n', '        return owners[maybe_owner] ? true : false;\n', '    }\n', '\n', '    function grant(address _owner) onlyOwner public {\n', '        owners[_owner] = true;\n', '        AccessGrant(_owner);\n', '    }\n', '\n', '    function revoke(address _owner) onlyOwner public {\n', '        require(_owner != publisher);\n', '        require(msg.sender != _owner);\n', '\n', '        owners[_owner] = false;\n', '        AccessRevoke(_owner);\n', '    }\n', '}\n', '\n', 'contract TokenRecipient {\n', '  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; \n', '}\n', '\n', 'contract TokenInterface is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint public decimals;\n', '}\n', '\n', 'contract MintableTokenInterface is TokenInterface {\n', '  address public owner;\n', '  function mint(address beneficiary, uint amount) public returns(bool);\n', '  function transferOwnership(address nextOwner) public;\n', '}\n', '\n', '/**\n', ' * Complex crowdsale with huge posibilities\n', ' * Core features:\n', ' * - Whitelisting\n', ' *  - Min\\max invest amounts\n', ' * - Only known users\n', ' * - Buy with allowed tokens\n', ' *  - Oraclize based pairs (ETH to TOKEN)\n', ' * - Revert\\refund\n', ' * - Personal bonuses\n', ' * - Amount bonuses\n', ' * - Total supply bonuses\n', ' * - Early birds bonuses\n', ' * - Extra distribution (team, foundation and also)\n', ' * - Soft and hard caps\n', ' * - Finalization logics\n', '**/\n', 'contract Crowdsale is MultiOwners, TokenRecipient {\n', '  using SafeMath for uint;\n', '\n', '  //  ██████╗ ██████╗ ███╗   ██╗███████╗████████╗███████╗\n', '  // ██╔════╝██╔═══██╗████╗  ██║██╔════╝╚══██╔══╝██╔════╝\n', '  // ██║     ██║   ██║██╔██╗ ██║███████╗   ██║   ███████╗\n', '  // ██║     ██║   ██║██║╚██╗██║╚════██║   ██║   ╚════██║\n', '  // ╚██████╗╚██████╔╝██║ ╚████║███████║   ██║   ███████║\n', '  //  ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚══════╝\n', '  uint public constant VERSION = 0x1;\n', '  enum State {\n', '    Setup,          // Non active yet (require to be setuped)\n', '    Active,         // Crowdsale in a live\n', '    Claim,          // Claim funds by owner\n', '    Refund,         // Unsucceseful crowdsale (refund ether)\n', '    History         // Close and store only historical fact of existence\n', '  }\n', '\n', '\n', '  struct PersonalBonusRecord {\n', '    uint bonus;\n', '    address refererAddress;\n', '    uint refererBonus;\n', '  }\n', '\n', '  struct WhitelistRecord {\n', '    bool allow;\n', '    uint min;\n', '    uint max;\n', '  }\n', '\n', '\n', '  //  ██████╗ ██████╗ ███╗   ██╗███████╗██╗███╗   ██╗ ██████╗ \n', '  // ██╔════╝██╔═══██╗████╗  ██║██╔════╝██║████╗  ██║██╔════╝ \n', '  // ██║     ██║   ██║██╔██╗ ██║█████╗  ██║██╔██╗ ██║██║  ███╗\n', '  // ██║     ██║   ██║██║╚██╗██║██╔══╝  ██║██║╚██╗██║██║   ██║\n', '  // ╚██████╗╚██████╔╝██║ ╚████║██║     ██║██║ ╚████║╚██████╔╝\n', '  //  ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝     ╚═╝╚═╝  ╚═══╝ ╚═════╝ \n', '                                                           \n', '  bool public isWhitelisted;            // Should be whitelisted to buy tokens\n', '  bool public isKnownOnly;              // Should be known user to buy tokens\n', '  bool public isAmountBonus;            // Enable amount bonuses in crowdsale?\n', '  bool public isEarlyBonus;             // Enable early bird bonus in crowdsale?\n', '  bool public isTokenExchange;          // Allow to buy tokens for another tokens?\n', '  bool public isAllowToIssue;           // Allow to issue tokens with tx hash (ex bitcoin)\n', '  bool public isDisableEther;           // Disable purchase with the Ether\n', '  bool public isExtraDistribution;      // Should distribute extra tokens to special contract?\n', '  bool public isTransferShipment;       // Will ship token via minting?\n', '  bool public isCappedInEther;          // Should be capped in Ether \n', '  bool public isPersonalBonuses;        // Should check personal beneficiary bonus?\n', '  bool public isAllowClaimBeforeFinalization;\n', '                                        // Should allow to claim funds before finalization?\n', '  bool public isMinimumValue;           // Validate minimum amount to purchase\n', '  bool public isMinimumInEther;         // Is minimum amount setuped in Ether or Tokens?\n', '\n', '  uint public minimumPurchaseValue;     // How less buyer could to purchase\n', '\n', '  // List of allowed beneficiaries\n', '  mapping (address => WhitelistRecord) public whitelist;\n', '\n', '  // Known users registry (required to known rules)\n', '  UserRegistryInterface public userRegistry;\n', '\n', '  mapping (uint => uint) public amountBonuses; // Amount bonuses\n', '  uint[] public amountSlices;                  // Key is min amount of buy\n', '  uint public amountSlicesCount;               // 10000 - 100.00% bonus over base pricetotaly free\n', '                                               //  5000 - 50.00% bonus\n', '                                               //     0 - no bonus at all\n', '  mapping (uint => uint) public timeBonuses;   // Time bonuses\n', '  uint[] public timeSlices;                    // Same as amount but key is seconds after start\n', '  uint public timeSlicesCount;\n', '\n', '  mapping (address => PersonalBonusRecord) public personalBonuses; \n', '                                        // personal bonuses\n', '  MintableTokenInterface public token;  // The token being sold\n', '  uint public tokenDecimals;            // Token decimals\n', '\n', '  mapping (address => TokenInterface) public allowedTokens;\n', '                                        // allowed tokens list\n', '  mapping (address => uint) public tokensValues;\n', '                                        // TOKEN to ETH conversion rate (oraclized)\n', '  uint public startTime;                // start and end timestamps where \n', '  uint public endTime;                  // investments are allowed (both inclusive)\n', '  address public wallet;                // address where funds are collected\n', '  uint public price;                    // how many token (1 * 10 ** decimals) a buyer gets per wei\n', '  uint public hardCap;\n', '  uint public softCap;\n', '\n', '  address public extraTokensHolder;     // address to mint/transfer extra tokens (0 – 0%, 1000 - 100.0%)\n', '  uint public extraDistributionPart;    // % of extra distribution\n', '\n', '  // ███████╗████████╗ █████╗ ████████╗███████╗\n', '  // ██╔════╝╚══██╔══╝██╔══██╗╚══██╔══╝██╔════╝\n', '  // ███████╗   ██║   ███████║   ██║   █████╗  \n', '  // ╚════██║   ██║   ██╔══██║   ██║   ██╔══╝  \n', '  // ███████║   ██║   ██║  ██║   ██║   ███████╗\n', '  // ╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝   ╚══════╝\n', '  // amount of raised money in wei\n', '  uint public weiRaised;\n', '  // Current crowdsale state\n', '  State public state;\n', '  // Temporal balances to pull tokens after token sale\n', '  // requires to ship required balance to smart contract\n', '  mapping (address => uint) public beneficiaryInvest;\n', '  uint public soldTokens;\n', '\n', '  mapping (address => uint) public weiDeposit;\n', '  mapping (address => mapping(address => uint)) public altDeposit;\n', '\n', '  modifier inState(State _target) {\n', '    require(state == _target);\n', '    _;\n', '  }\n', '\n', '  // ███████╗██╗   ██╗███████╗███╗   ██╗████████╗███████╗\n', '  // ██╔════╝██║   ██║██╔════╝████╗  ██║╚══██╔══╝██╔════╝\n', '  // █████╗  ██║   ██║█████╗  ██╔██╗ ██║   ██║   ███████╗\n', '  // ██╔══╝  ╚██╗ ██╔╝██╔══╝  ██║╚██╗██║   ██║   ╚════██║\n', '  // ███████╗ ╚████╔╝ ███████╗██║ ╚████║   ██║   ███████║\n', '  // ╚══════╝  ╚═══╝  ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝\n', '  \n', '  event EthBuy(\n', '    address indexed purchaser, \n', '    address indexed beneficiary, \n', '    uint value, \n', '    uint amount);\n', '  event HashBuy(\n', '    address indexed beneficiary, \n', '    uint value, \n', '    uint amount, \n', '    uint timestamp, \n', '    bytes32 indexed bitcoinHash);\n', '  event AltBuy(\n', '    address indexed beneficiary, \n', '    address indexed allowedToken, \n', '    uint allowedTokenValue, \n', '    uint ethValue, \n', '    uint shipAmount);\n', '    \n', '  event ShipTokens(address indexed owner, uint amount);\n', '\n', '  event Sanetize();\n', '  event Finalize();\n', '\n', '  event Whitelisted(address indexed beneficiary, uint min, uint max);\n', '  event PersonalBonus(address indexed beneficiary, address indexed referer, uint bonus, uint refererBonus);\n', '  event FundsClaimed(address indexed owner, uint amount);\n', '\n', '\n', '  // ███████╗███████╗████████╗██╗   ██╗██████╗     ███╗   ███╗███████╗████████╗██╗  ██╗ ██████╗ ██████╗ ███████╗\n', '  // ██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗    ████╗ ████║██╔════╝╚══██╔══╝██║  ██║██╔═══██╗██╔══██╗██╔════╝\n', '  // ███████╗█████╗     ██║   ██║   ██║██████╔╝    ██╔████╔██║█████╗     ██║   ███████║██║   ██║██║  ██║███████╗\n', '  // ╚════██║██╔══╝     ██║   ██║   ██║██╔═══╝     ██║╚██╔╝██║██╔══╝     ██║   ██╔══██║██║   ██║██║  ██║╚════██║\n', '  // ███████║███████╗   ██║   ╚██████╔╝██║         ██║ ╚═╝ ██║███████╗   ██║   ██║  ██║╚██████╔╝██████╔╝███████║\n', '  // ╚══════╝╚══════╝   ╚═╝    ╚═════╝ ╚═╝         ╚═╝     ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚══════╝\n', '\n', '  function setFlags(\n', '    // Should be whitelisted to buy tokens\n', '    bool _isWhitelisted,\n', '    // Should be known user to buy tokens\n', '    bool _isKnownOnly,\n', '    // Enable amount bonuses in crowdsale?\n', '    bool _isAmountBonus,\n', '    // Enable early bird bonus in crowdsale?\n', '    bool _isEarlyBonus,\n', '    // Allow to buy tokens for another tokens?\n', '    bool _isTokenExchange,\n', '    // Allow to issue tokens with tx hash (ex bitcoin)\n', '    bool _isAllowToIssue,\n', '    // Should reject purchases with Ether?\n', '    bool _isDisableEther,\n', '    // Should mint extra tokens for future distribution?\n', '    bool _isExtraDistribution,\n', '    // Will ship token via minting? \n', '    bool _isTransferShipment,\n', '    // Should be capped in ether\n', '    bool _isCappedInEther,\n', '    // Should beneficiaries pull their tokens? \n', '    bool _isPersonalBonuses,\n', '    // Should allow to claim funds before finalization?\n', '    bool _isAllowClaimBeforeFinalization)\n', '    inState(State.Setup) onlyOwner public \n', '  {\n', '    isWhitelisted = _isWhitelisted;\n', '    isKnownOnly = _isKnownOnly;\n', '    isAmountBonus = _isAmountBonus;\n', '    isEarlyBonus = _isEarlyBonus;\n', '    isTokenExchange = _isTokenExchange;\n', '    isAllowToIssue = _isAllowToIssue;\n', '    isDisableEther = _isDisableEther;\n', '    isExtraDistribution = _isExtraDistribution;\n', '    isTransferShipment = _isTransferShipment;\n', '    isCappedInEther = _isCappedInEther;\n', '    isPersonalBonuses = _isPersonalBonuses;\n', '    isAllowClaimBeforeFinalization = _isAllowClaimBeforeFinalization;\n', '  }\n', '\n', '  // ! Could be changed in process of sale (since 02.2018)\n', '  function setMinimum(uint _amount, bool _inToken) \n', '    onlyOwner public\n', '  {\n', '    if (_amount == 0) {\n', '      isMinimumValue = false;\n', '      minimumPurchaseValue = 0;\n', '    } else {\n', '      isMinimumValue = true;\n', '      isMinimumInEther = !_inToken;\n', '      minimumPurchaseValue = _amount;\n', '    }\n', '  }\n', '\n', '  function setPrice(uint _price)\n', '    inState(State.Setup) onlyOwner public\n', '  {\n', '    require(_price > 0);\n', '    price = _price;\n', '  }\n', '\n', '  function setSoftHardCaps(uint _softCap, uint _hardCap)\n', '    inState(State.Setup) onlyOwner public\n', '  {\n', '    hardCap = _hardCap;\n', '    softCap = _softCap;\n', '  }\n', '\n', '  function setTime(uint _start, uint _end)\n', '    inState(State.Setup) onlyOwner public \n', '  {\n', '    require(_start < _end);\n', '    require(_end > block.timestamp);\n', '    startTime = _start;\n', '    endTime = _end;\n', '  }\n', '\n', '  function setToken(address _tokenAddress) \n', '    inState(State.Setup) onlyOwner public\n', '  {\n', '    token = MintableTokenInterface(_tokenAddress);\n', '    tokenDecimals = token.decimals();\n', '  }\n', '\n', '  function setWallet(address _wallet) \n', '    inState(State.Setup) onlyOwner public \n', '  {\n', '    require(_wallet != address(0));\n', '    wallet = _wallet;\n', '  }\n', '  \n', '  function setRegistry(address _registry) \n', '    inState(State.Setup) onlyOwner public \n', '  {\n', '    require(_registry != address(0));\n', '    userRegistry = UserRegistryInterface(_registry);\n', '  }\n', '\n', '  function setExtraDistribution(address _holder, uint _extraPart) \n', '    inState(State.Setup) onlyOwner public\n', '  {\n', '    require(_holder != address(0));\n', '    extraTokensHolder = _holder;\n', '    extraDistributionPart = _extraPart;\n', '  }\n', '\n', '  function setAmountBonuses(uint[] _amountSlices, uint[] _bonuses) \n', '    inState(State.Setup) onlyOwner public \n', '  {\n', '    require(_amountSlices.length > 1);\n', '    require(_bonuses.length == _amountSlices.length);\n', '    uint lastSlice = 0;\n', '    for (uint index = 0; index < _amountSlices.length; index++) {\n', '      require(_amountSlices[index] > lastSlice);\n', '      lastSlice = _amountSlices[index];\n', '      amountSlices.push(lastSlice);\n', '      amountBonuses[lastSlice] = _bonuses[index];\n', '    }\n', '\n', '    amountSlicesCount = amountSlices.length;\n', '  }\n', '\n', '  function setTimeBonuses(uint[] _timeSlices, uint[] _bonuses) \n', '    // ! Not need to check state since changes at 02.2018\n', '    // inState(State.Setup)\n', '    onlyOwner \n', '    public \n', '  {\n', '    // Only once in life time\n', '    // ! Time bonuses is changable after 02.2018\n', '    // require(timeSlicesCount == 0);\n', '    require(_timeSlices.length > 0);\n', '    require(_bonuses.length == _timeSlices.length);\n', '    uint lastSlice = 0;\n', '    uint lastBonus = 10000;\n', '    if (timeSlicesCount > 0) {\n', '      // ! Since time bonuses is changable we should take latest first\n', '      lastSlice = timeSlices[timeSlicesCount - 1];\n', '      lastBonus = timeBonuses[lastSlice];\n', '    }\n', '\n', '    for (uint index = 0; index < _timeSlices.length; index++) {\n', '      require(_timeSlices[index] > lastSlice);\n', '\n', '      // ! Add check for next bonus is equal or less than previous\n', '      require(_bonuses[index] <= lastBonus);\n', '\n', '      // ? Should we check bonus in a future\n', '      lastSlice = _timeSlices[index];\n', '      timeSlices.push(lastSlice);\n', '      timeBonuses[lastSlice] = _bonuses[index];\n', '    }\n', '    timeSlicesCount = timeSlices.length;\n', '  }\n', '  \n', '  function setTokenExcange(address _token, uint _value)\n', '    inState(State.Setup) onlyOwner public\n', '  {\n', '    allowedTokens[_token] = TokenInterface(_token);\n', '    updateTokenValue(_token, _value); \n', '  }\n', '\n', '  function saneIt() \n', '    inState(State.Setup) onlyOwner public \n', '  {\n', '    require(startTime < endTime);\n', '    require(endTime > now);\n', '\n', '    require(price > 0);\n', '\n', '    require(wallet != address(0));\n', '    require(token != address(0));\n', '\n', '    if (isKnownOnly) {\n', '      require(userRegistry != address(0));\n', '    }\n', '\n', '    if (isAmountBonus) {\n', '      require(amountSlicesCount > 0);\n', '    }\n', '\n', '    if (isExtraDistribution) {\n', '      require(extraTokensHolder != address(0));\n', '    }\n', '\n', '    if (isTransferShipment) {\n', '      require(token.balanceOf(address(this)) >= hardCap);\n', '    } else {\n', '      require(token.owner() == address(this));\n', '    }\n', '\n', '    state = State.Active;\n', '  }\n', '\n', '  function finalizeIt(address _futureOwner) inState(State.Active) onlyOwner public {\n', '    require(ended());\n', '\n', '    token.transferOwnership(_futureOwner);\n', '\n', '    if (success()) {\n', '      state = State.Claim;\n', '    } else {\n', '      state = State.Refund;\n', '    }\n', '  }\n', '\n', '  function historyIt() inState(State.Claim) onlyOwner public {\n', '    require(address(this).balance == 0);\n', '    state = State.History;\n', '  }\n', '\n', '  // ███████╗██╗  ██╗███████╗ ██████╗██╗   ██╗████████╗███████╗\n', '  // ██╔════╝╚██╗██╔╝██╔════╝██╔════╝██║   ██║╚══██╔══╝██╔════╝\n', '  // █████╗   ╚███╔╝ █████╗  ██║     ██║   ██║   ██║   █████╗  \n', '  // ██╔══╝   ██╔██╗ ██╔══╝  ██║     ██║   ██║   ██║   ██╔══╝  \n', '  // ███████╗██╔╝ ██╗███████╗╚██████╗╚██████╔╝   ██║   ███████╗\n', '  // ╚══════╝╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═════╝    ╚═╝   ╚══════╝\n', '\n', '  function calculateEthAmount(\n', '    address _beneficiary,\n', '    uint _weiAmount,\n', '    uint _time,\n', '    uint _totalSupply\n', '  ) public constant returns(\n', '    uint calculatedTotal, \n', '    uint calculatedBeneficiary, \n', '    uint calculatedExtra, \n', '    uint calculatedreferer, \n', '    address refererAddress) \n', '  {\n', '    _totalSupply;\n', '    uint bonus = 0;\n', '    \n', '    if (isAmountBonus) {\n', '      bonus = bonus.add(calculateAmountBonus(_weiAmount));\n', '    }\n', '\n', '    if (isEarlyBonus) {\n', '      bonus = bonus.add(calculateTimeBonus(_time.sub(startTime)));\n', '    }\n', '\n', '    if (isPersonalBonuses && personalBonuses[_beneficiary].bonus > 0) {\n', '      bonus = bonus.add(personalBonuses[_beneficiary].bonus);\n', '    }\n', '\n', '    calculatedBeneficiary = _weiAmount.mul(10 ** tokenDecimals).div(price);\n', '    if (bonus > 0) {\n', '      calculatedBeneficiary = calculatedBeneficiary.add(calculatedBeneficiary.mul(bonus).div(10000));\n', '    }\n', '\n', '    if (isExtraDistribution) {\n', '      calculatedExtra = calculatedBeneficiary.mul(extraDistributionPart).div(10000);\n', '    }\n', '\n', '    if (isPersonalBonuses && \n', '        personalBonuses[_beneficiary].refererAddress != address(0) && \n', '        personalBonuses[_beneficiary].refererBonus > 0) \n', '    {\n', '      calculatedreferer = calculatedBeneficiary.mul(personalBonuses[_beneficiary].refererBonus).div(10000);\n', '      refererAddress = personalBonuses[_beneficiary].refererAddress;\n', '    }\n', '\n', '    calculatedTotal = calculatedBeneficiary.add(calculatedExtra).add(calculatedreferer);\n', '  }\n', '\n', '  function calculateAmountBonus(uint _changeAmount) public constant returns(uint) {\n', '    uint bonus = 0;\n', '    for (uint index = 0; index < amountSlices.length; index++) {\n', '      if(amountSlices[index] > _changeAmount) {\n', '        break;\n', '      }\n', '\n', '      bonus = amountBonuses[amountSlices[index]];\n', '    }\n', '    return bonus;\n', '  }\n', '\n', '  function calculateTimeBonus(uint _at) public constant returns(uint) {\n', '    uint bonus = 0;\n', '    for (uint index = timeSlices.length; index > 0; index--) {\n', '      if(timeSlices[index - 1] < _at) {\n', '        break;\n', '      }\n', '      bonus = timeBonuses[timeSlices[index - 1]];\n', '    }\n', '\n', '    return bonus;\n', '  }\n', '\n', '  function validPurchase(\n', '    address _beneficiary, \n', '    uint _weiAmount, \n', '    uint _tokenAmount,\n', '    uint _extraAmount,\n', '    uint _totalAmount,\n', '    uint _time) \n', '  public constant returns(bool) \n', '  {\n', '    _tokenAmount;\n', '    _extraAmount;\n', '\n', '    // ! Check min purchase value (since 02.2018)\n', '    if (isMinimumValue) {\n', '      // ! Check min purchase value in ether (since 02.2018)\n', '      if (isMinimumInEther && _weiAmount < minimumPurchaseValue) {\n', '        return false;\n', '      }\n', '\n', '      // ! Check min purchase value in tokens (since 02.2018)\n', '      if (!isMinimumInEther && _tokenAmount < minimumPurchaseValue) {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    if (_time < startTime || _time > endTime) {\n', '      return false;\n', '    }\n', '\n', '    if (isKnownOnly && !userRegistry.knownAddress(_beneficiary)) {\n', '      return false;\n', '    }\n', '\n', '    uint finalBeneficiaryInvest = beneficiaryInvest[_beneficiary].add(_weiAmount);\n', '    uint finalTotalSupply = soldTokens.add(_totalAmount);\n', '\n', '    if (isWhitelisted) {\n', '      WhitelistRecord storage record = whitelist[_beneficiary];\n', '      if (!record.allow || \n', '          record.min > finalBeneficiaryInvest ||\n', '          record.max < finalBeneficiaryInvest) {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    if (isCappedInEther) {\n', '      if (weiRaised.add(_weiAmount) > hardCap) {\n', '        return false;\n', '      }\n', '    } else {\n', '      if (finalTotalSupply > hardCap) {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '                                                                                        \n', '  function updateTokenValue(address _token, uint _value) onlyOwner public {\n', '    require(address(allowedTokens[_token]) != address(0x0));\n', '    tokensValues[_token] = _value;\n', '  }\n', '\n', '  // ██████╗ ███████╗ █████╗ ██████╗ \n', '  // ██╔══██╗██╔════╝██╔══██╗██╔══██╗\n', '  // ██████╔╝█████╗  ███████║██║  ██║\n', '  // ██╔══██╗██╔══╝  ██╔══██║██║  ██║\n', '  // ██║  ██║███████╗██║  ██║██████╔╝\n', '  // ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ \n', '  function success() public constant returns(bool) {\n', '    if (isCappedInEther) {\n', '      return weiRaised >= softCap;\n', '    } else {\n', '      return token.totalSupply() >= softCap;\n', '    }\n', '  }\n', '\n', '  function capped() public constant returns(bool) {\n', '    if (isCappedInEther) {\n', '      return weiRaised >= hardCap;\n', '    } else {\n', '      return token.totalSupply() >= hardCap;\n', '    }\n', '  }\n', '\n', '  function ended() public constant returns(bool) {\n', '    return capped() || block.timestamp >= endTime;\n', '  }\n', '\n', '\n', '  //  ██████╗ ██╗   ██╗████████╗███████╗██╗██████╗ ███████╗\n', '  // ██╔═══██╗██║   ██║╚══██╔══╝██╔════╝██║██╔══██╗██╔════╝\n', '  // ██║   ██║██║   ██║   ██║   ███████╗██║██║  ██║█████╗  \n', '  // ██║   ██║██║   ██║   ██║   ╚════██║██║██║  ██║██╔══╝  \n', '  // ╚██████╔╝╚██████╔╝   ██║   ███████║██║██████╔╝███████╗\n', '  //  ╚═════╝  ╚═════╝    ╚═╝   ╚══════╝╚═╝╚═════╝ ╚══════╝\n', '  // fallback function can be used to buy tokens\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function buyTokens(address _beneficiary) inState(State.Active) public payable {\n', '    require(!isDisableEther);\n', '    uint shipAmount = sellTokens(_beneficiary, msg.value, block.timestamp);\n', '    require(shipAmount > 0);\n', '    forwardEther();\n', '  }\n', '\n', '  function buyWithHash(address _beneficiary, uint _value, uint _timestamp, bytes32 _hash) \n', '    inState(State.Active) onlyOwner public \n', '  {\n', '    require(isAllowToIssue);\n', '    uint shipAmount = sellTokens(_beneficiary, _value, _timestamp);\n', '    require(shipAmount > 0);\n', '    HashBuy(_beneficiary, _value, shipAmount, _timestamp, _hash);\n', '  }\n', '  \n', '  function receiveApproval(address _from, \n', '                           uint256 _value, \n', '                           address _token, \n', '                           bytes _extraData) public \n', '  {\n', '    if (_token == address(token)) {\n', '      TokenInterface(_token).transferFrom(_from, address(this), _value);\n', '      return;\n', '    }\n', '\n', '    require(isTokenExchange);\n', '    \n', '    require(toUint(_extraData) == tokensValues[_token]);\n', '    require(tokensValues[_token] > 0);\n', '    require(forwardTokens(_from, _token, _value));\n', '\n', '    uint weiValue = _value.mul(tokensValues[_token]).div(10 ** allowedTokens[_token].decimals());\n', '    require(weiValue > 0);\n', '\n', '    uint shipAmount = sellTokens(_from, weiValue, block.timestamp);\n', '    require(shipAmount > 0);\n', '\n', '    AltBuy(_from, _token, _value, weiValue, shipAmount);\n', '  }\n', '\n', '  function claimFunds() onlyOwner public returns(bool) {\n', '    require(state == State.Claim || (isAllowClaimBeforeFinalization && success()));\n', '    wallet.transfer(address(this).balance);\n', '    return true;\n', '  }\n', '\n', '  function claimTokenFunds(address _token) onlyOwner public returns(bool) {\n', '    require(state == State.Claim || (isAllowClaimBeforeFinalization && success()));\n', '    uint balance = allowedTokens[_token].balanceOf(address(this));\n', '    require(balance > 0);\n', '    require(allowedTokens[_token].transfer(wallet, balance));\n', '    return true;\n', '  }\n', '\n', '  function claimRefundEther(address _beneficiary) inState(State.Refund) public returns(bool) {\n', '    require(weiDeposit[_beneficiary] > 0);\n', '    _beneficiary.transfer(weiDeposit[_beneficiary]);\n', '    return true;\n', '  }\n', '\n', '  function claimRefundTokens(address _beneficiary, address _token) inState(State.Refund) public returns(bool) {\n', '    require(altDeposit[_token][_beneficiary] > 0);\n', '    require(allowedTokens[_token].transfer(_beneficiary, altDeposit[_token][_beneficiary]));\n', '    return true;\n', '  }\n', '\n', '  function addToWhitelist(address _beneficiary, uint _min, uint _max) onlyOwner public\n', '  {\n', '    require(_beneficiary != address(0));\n', '    require(_min <= _max);\n', '\n', '    if (_max == 0) {\n', '      _max = 10 ** 40; // should be huge enough? :0\n', '    }\n', '\n', '    whitelist[_beneficiary] = WhitelistRecord(true, _min, _max);\n', '    Whitelisted(_beneficiary, _min, _max);\n', '  }\n', '  \n', '  function setPersonalBonus(\n', '    address _beneficiary, \n', '    uint _bonus, \n', '    address _refererAddress, \n', '    uint _refererBonus) onlyOwner public {\n', '    personalBonuses[_beneficiary] = PersonalBonusRecord(\n', '      _bonus,\n', '      _refererAddress,\n', '      _refererBonus\n', '    );\n', '\n', '    PersonalBonus(_beneficiary, _refererAddress, _bonus, _refererBonus);\n', '  }\n', '\n', '  // ██╗███╗   ██╗████████╗███████╗██████╗ ███╗   ██╗ █████╗ ██╗     ███████╗\n', '  // ██║████╗  ██║╚══██╔══╝██╔════╝██╔══██╗████╗  ██║██╔══██╗██║     ██╔════╝\n', '  // ██║██╔██╗ ██║   ██║   █████╗  ██████╔╝██╔██╗ ██║███████║██║     ███████╗\n', '  // ██║██║╚██╗██║   ██║   ██╔══╝  ██╔══██╗██║╚██╗██║██╔══██║██║     ╚════██║\n', '  // ██║██║ ╚████║   ██║   ███████╗██║  ██║██║ ╚████║██║  ██║███████╗███████║\n', '  // ╚═╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚══════╝╚══════╝\n', '  // low level token purchase function\n', '  function sellTokens(address _beneficiary, uint _weiAmount, uint timestamp) \n', '    inState(State.Active) internal returns(uint)\n', '  {\n', '    uint beneficiaryTokens;\n', '    uint extraTokens;\n', '    uint totalTokens;\n', '    uint refererTokens;\n', '    address refererAddress;\n', '    (totalTokens, beneficiaryTokens, extraTokens, refererTokens, refererAddress) = calculateEthAmount(\n', '      _beneficiary, \n', '      _weiAmount, \n', '      timestamp, \n', '      token.totalSupply());\n', '\n', '    require(validPurchase(_beneficiary,   // Check if current purchase is valid\n', '                          _weiAmount, \n', '                          beneficiaryTokens,\n', '                          extraTokens,\n', '                          totalTokens,\n', '                          timestamp));\n', '\n', '    weiRaised = weiRaised.add(_weiAmount); // update state (wei amount)\n', '    beneficiaryInvest[_beneficiary] = beneficiaryInvest[_beneficiary].add(_weiAmount);\n', '    shipTokens(_beneficiary, beneficiaryTokens);     // ship tokens to beneficiary\n', '    EthBuy(msg.sender,             // Fire purchase event\n', '                  _beneficiary, \n', '                  _weiAmount, \n', '                  beneficiaryTokens);\n', '    ShipTokens(_beneficiary, beneficiaryTokens);\n', '\n', '    if (isExtraDistribution) {            // calculate and\n', '      shipTokens(extraTokensHolder, extraTokens);\n', '      ShipTokens(extraTokensHolder, extraTokens);\n', '    }\n', '\n', '    if (isPersonalBonuses) {\n', '      PersonalBonusRecord storage record = personalBonuses[_beneficiary];\n', '      if (record.refererAddress != address(0) && record.refererBonus > 0) {\n', '        shipTokens(record.refererAddress, refererTokens);\n', '        ShipTokens(record.refererAddress, refererTokens);\n', '      }\n', '    }\n', '\n', '    soldTokens = soldTokens.add(totalTokens);\n', '    return beneficiaryTokens;\n', '  }\n', '\n', '  function shipTokens(address _beneficiary, uint _amount) \n', '    inState(State.Active) internal \n', '  {\n', '    if (isTransferShipment) {\n', '      token.transfer(_beneficiary, _amount);\n', '    } else {\n', '      token.mint(address(this), _amount);\n', '      token.transfer(_beneficiary, _amount);\n', '    }\n', '  }\n', '\n', '  function forwardEther() internal returns (bool) {\n', '    weiDeposit[msg.sender] = msg.value;\n', '    return true;\n', '  }\n', '\n', '  function forwardTokens(address _beneficiary, address _tokenAddress, uint _amount) internal returns (bool) {\n', '    TokenInterface allowedToken = allowedTokens[_tokenAddress];\n', '    allowedToken.transferFrom(_beneficiary, address(this), _amount);\n', '    altDeposit[_tokenAddress][_beneficiary] = _amount;\n', '    return true;\n', '  }\n', '\n', '  // ██╗   ██╗████████╗██╗██╗     ███████╗\n', '  // ██║   ██║╚══██╔══╝██║██║     ██╔════╝\n', '  // ██║   ██║   ██║   ██║██║     ███████╗\n', '  // ██║   ██║   ██║   ██║██║     ╚════██║\n', '  // ╚██████╔╝   ██║   ██║███████╗███████║\n', '  //  ╚═════╝    ╚═╝   ╚═╝╚══════╝╚══════╝\n', '  function toUint(bytes left) public pure returns (uint) {\n', '      uint out;\n', '      for (uint i = 0; i < 32; i++) {\n', '          out |= uint(left[i]) << (31 * 8 - i * 8);\n', '      }\n', '      \n', '      return out;\n', '  }\n', '}\n', '\n', 'contract BaseAltCrowdsale is Crowdsale {\n', '  function BaseAltCrowdsale(\n', '    address _registry,\n', '    address _token,\n', '    address _extraTokensHolder,\n', '    address _wallet,\n', '    bool _isWhitelisted,\n', '    uint _price,\n', '    uint _start,\n', '    uint _end,\n', '    uint _softCap,\n', '    uint _hardCap\n', '  ) public {\n', '    setFlags(\n', '      // Should be whitelisted to buy tokens\n', '      // _isWhitelisted,\n', '      _isWhitelisted,\n', '      // Should be known user to buy tokens\n', '      // _isKnownOnly,\n', '      true,\n', '      // Enable amount bonuses in crowdsale? \n', '      // _isAmountBonus,\n', '      true,\n', '      // Enable early bird bonus in crowdsale?\n', '      // _isEarlyBonus,\n', '      true,\n', '      // Allow to buy tokens for another tokens?\n', '      // _isTokenExcange,\n', '      false,\n', '      // Allow to issue tokens with tx hash (ex bitcoin)\n', '      // _isAllowToIssue,\n', '      true,\n', '      // Should reject purchases with Ether?\n', '      // _isDisableEther,\n', '      false,\n', '      // Should mint extra tokens for future distribution?\n', '      // _isExtraDistribution,\n', '      true,\n', '      // Will ship token via minting? \n', '      // _isTransferShipment,\n', '      false,\n', '      // Should be capped in ether\n', '      // bool _isCappedInEther,\n', '      true,\n', '      // Should check personal bonuses?\n', '      // _isPersonalBonuses\n', '      true,\n', '      // Should allow to claimFunds before finalizations?\n', '      false\n', '    );\n', '\n', '    setToken(_token); \n', '    setTime(_start, _end);\n', '    setRegistry(_registry);\n', '    setWallet(_wallet);\n', '    setExtraDistribution(\n', '      _extraTokensHolder,\n', '      6667 // 66.67%\n', '    );\n', '\n', '    setSoftHardCaps(\n', '      _softCap, // soft\n', '      _hardCap  // hard\n', '    );\n', '\n', '    // 200 ALT per 1 ETH\n', '    setPrice(_price);\n', '  }\n', '}\n', '\n', 'contract AltCrowdsalePhaseOne is BaseAltCrowdsale {\n', '  function AltCrowdsalePhaseOne (\n', '    address _registry,\n', '    address _token,\n', '    address _extraTokensHolder,\n', '    address _wallet\n', '  )\n', '  BaseAltCrowdsale(\n', '    _registry,\n', '    _token,\n', '    _extraTokensHolder,\n', '    _wallet,\n', '\n', '    // Whitelisted\n', '    false,\n', '\n', '    // price 1 ETH -> 100000 ALT\n', '    uint(1 ether).div(100000), \n', '\n', '    // start\n', '    block.timestamp,\n', '    // end \n', '    1527764400,\n', '\n', '    // _softCap,\n', '    2500 ether,\n', '    // _hardCap\n', '    7500 ether\n', '  ) \n', '  public {\n', '  } \n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract UserRegistryInterface {\n', '  event AddAddress(address indexed who);\n', '  event AddIdentity(address indexed who);\n', '\n', '  function knownAddress(address _who) public constant returns(bool);\n', '  function hasIdentity(address _who) public constant returns(bool);\n', '  function systemAddresses(address _to, address _from) public constant returns(bool);\n', '}\n', '\n', 'contract MultiOwners {\n', '\n', '    event AccessGrant(address indexed owner);\n', '    event AccessRevoke(address indexed owner);\n', '    \n', '    mapping(address => bool) owners;\n', '    address public publisher;\n', '\n', '    function MultiOwners() public {\n', '        owners[msg.sender] = true;\n', '        publisher = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() { \n', '        require(owners[msg.sender] == true);\n', '        _; \n', '    }\n', '\n', '    function isOwner() public constant returns (bool) {\n', '        return owners[msg.sender] ? true : false;\n', '    }\n', '\n', '    function checkOwner(address maybe_owner) public constant returns (bool) {\n', '        return owners[maybe_owner] ? true : false;\n', '    }\n', '\n', '    function grant(address _owner) onlyOwner public {\n', '        owners[_owner] = true;\n', '        AccessGrant(_owner);\n', '    }\n', '\n', '    function revoke(address _owner) onlyOwner public {\n', '        require(_owner != publisher);\n', '        require(msg.sender != _owner);\n', '\n', '        owners[_owner] = false;\n', '        AccessRevoke(_owner);\n', '    }\n', '}\n', '\n', 'contract TokenRecipient {\n', '  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; \n', '}\n', '\n', 'contract TokenInterface is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint public decimals;\n', '}\n', '\n', 'contract MintableTokenInterface is TokenInterface {\n', '  address public owner;\n', '  function mint(address beneficiary, uint amount) public returns(bool);\n', '  function transferOwnership(address nextOwner) public;\n', '}\n', '\n', '/**\n', ' * Complex crowdsale with huge posibilities\n', ' * Core features:\n', ' * - Whitelisting\n', ' *  - Min\\max invest amounts\n', ' * - Only known users\n', ' * - Buy with allowed tokens\n', ' *  - Oraclize based pairs (ETH to TOKEN)\n', ' * - Revert\\refund\n', ' * - Personal bonuses\n', ' * - Amount bonuses\n', ' * - Total supply bonuses\n', ' * - Early birds bonuses\n', ' * - Extra distribution (team, foundation and also)\n', ' * - Soft and hard caps\n', ' * - Finalization logics\n', '**/\n', 'contract Crowdsale is MultiOwners, TokenRecipient {\n', '  using SafeMath for uint;\n', '\n', '  //  ██████╗ ██████╗ ███╗   ██╗███████╗████████╗███████╗\n', '  // ██╔════╝██╔═══██╗████╗  ██║██╔════╝╚══██╔══╝██╔════╝\n', '  // ██║     ██║   ██║██╔██╗ ██║███████╗   ██║   ███████╗\n', '  // ██║     ██║   ██║██║╚██╗██║╚════██║   ██║   ╚════██║\n', '  // ╚██████╗╚██████╔╝██║ ╚████║███████║   ██║   ███████║\n', '  //  ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚══════╝\n', '  uint public constant VERSION = 0x1;\n', '  enum State {\n', '    Setup,          // Non active yet (require to be setuped)\n', '    Active,         // Crowdsale in a live\n', '    Claim,          // Claim funds by owner\n', '    Refund,         // Unsucceseful crowdsale (refund ether)\n', '    History         // Close and store only historical fact of existence\n', '  }\n', '\n', '\n', '  struct PersonalBonusRecord {\n', '    uint bonus;\n', '    address refererAddress;\n', '    uint refererBonus;\n', '  }\n', '\n', '  struct WhitelistRecord {\n', '    bool allow;\n', '    uint min;\n', '    uint max;\n', '  }\n', '\n', '\n', '  //  ██████╗ ██████╗ ███╗   ██╗███████╗██╗███╗   ██╗ ██████╗ \n', '  // ██╔════╝██╔═══██╗████╗  ██║██╔════╝██║████╗  ██║██╔════╝ \n', '  // ██║     ██║   ██║██╔██╗ ██║█████╗  ██║██╔██╗ ██║██║  ███╗\n', '  // ██║     ██║   ██║██║╚██╗██║██╔══╝  ██║██║╚██╗██║██║   ██║\n', '  // ╚██████╗╚██████╔╝██║ ╚████║██║     ██║██║ ╚████║╚██████╔╝\n', '  //  ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝     ╚═╝╚═╝  ╚═══╝ ╚═════╝ \n', '                                                           \n', '  bool public isWhitelisted;            // Should be whitelisted to buy tokens\n', '  bool public isKnownOnly;              // Should be known user to buy tokens\n', '  bool public isAmountBonus;            // Enable amount bonuses in crowdsale?\n', '  bool public isEarlyBonus;             // Enable early bird bonus in crowdsale?\n', '  bool public isTokenExchange;          // Allow to buy tokens for another tokens?\n', '  bool public isAllowToIssue;           // Allow to issue tokens with tx hash (ex bitcoin)\n', '  bool public isDisableEther;           // Disable purchase with the Ether\n', '  bool public isExtraDistribution;      // Should distribute extra tokens to special contract?\n', '  bool public isTransferShipment;       // Will ship token via minting?\n', '  bool public isCappedInEther;          // Should be capped in Ether \n', '  bool public isPersonalBonuses;        // Should check personal beneficiary bonus?\n', '  bool public isAllowClaimBeforeFinalization;\n', '                                        // Should allow to claim funds before finalization?\n', '  bool public isMinimumValue;           // Validate minimum amount to purchase\n', '  bool public isMinimumInEther;         // Is minimum amount setuped in Ether or Tokens?\n', '\n', '  uint public minimumPurchaseValue;     // How less buyer could to purchase\n', '\n', '  // List of allowed beneficiaries\n', '  mapping (address => WhitelistRecord) public whitelist;\n', '\n', '  // Known users registry (required to known rules)\n', '  UserRegistryInterface public userRegistry;\n', '\n', '  mapping (uint => uint) public amountBonuses; // Amount bonuses\n', '  uint[] public amountSlices;                  // Key is min amount of buy\n', '  uint public amountSlicesCount;               // 10000 - 100.00% bonus over base pricetotaly free\n', '                                               //  5000 - 50.00% bonus\n', '                                               //     0 - no bonus at all\n', '  mapping (uint => uint) public timeBonuses;   // Time bonuses\n', '  uint[] public timeSlices;                    // Same as amount but key is seconds after start\n', '  uint public timeSlicesCount;\n', '\n', '  mapping (address => PersonalBonusRecord) public personalBonuses; \n', '                                        // personal bonuses\n', '  MintableTokenInterface public token;  // The token being sold\n', '  uint public tokenDecimals;            // Token decimals\n', '\n', '  mapping (address => TokenInterface) public allowedTokens;\n', '                                        // allowed tokens list\n', '  mapping (address => uint) public tokensValues;\n', '                                        // TOKEN to ETH conversion rate (oraclized)\n', '  uint public startTime;                // start and end timestamps where \n', '  uint public endTime;                  // investments are allowed (both inclusive)\n', '  address public wallet;                // address where funds are collected\n', '  uint public price;                    // how many token (1 * 10 ** decimals) a buyer gets per wei\n', '  uint public hardCap;\n', '  uint public softCap;\n', '\n', '  address public extraTokensHolder;     // address to mint/transfer extra tokens (0 – 0%, 1000 - 100.0%)\n', '  uint public extraDistributionPart;    // % of extra distribution\n', '\n', '  // ███████╗████████╗ █████╗ ████████╗███████╗\n', '  // ██╔════╝╚══██╔══╝██╔══██╗╚══██╔══╝██╔════╝\n', '  // ███████╗   ██║   ███████║   ██║   █████╗  \n', '  // ╚════██║   ██║   ██╔══██║   ██║   ██╔══╝  \n', '  // ███████║   ██║   ██║  ██║   ██║   ███████╗\n', '  // ╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝   ╚══════╝\n', '  // amount of raised money in wei\n', '  uint public weiRaised;\n', '  // Current crowdsale state\n', '  State public state;\n', '  // Temporal balances to pull tokens after token sale\n', '  // requires to ship required balance to smart contract\n', '  mapping (address => uint) public beneficiaryInvest;\n', '  uint public soldTokens;\n', '\n', '  mapping (address => uint) public weiDeposit;\n', '  mapping (address => mapping(address => uint)) public altDeposit;\n', '\n', '  modifier inState(State _target) {\n', '    require(state == _target);\n', '    _;\n', '  }\n', '\n', '  // ███████╗██╗   ██╗███████╗███╗   ██╗████████╗███████╗\n', '  // ██╔════╝██║   ██║██╔════╝████╗  ██║╚══██╔══╝██╔════╝\n', '  // █████╗  ██║   ██║█████╗  ██╔██╗ ██║   ██║   ███████╗\n', '  // ██╔══╝  ╚██╗ ██╔╝██╔══╝  ██║╚██╗██║   ██║   ╚════██║\n', '  // ███████╗ ╚████╔╝ ███████╗██║ ╚████║   ██║   ███████║\n', '  // ╚══════╝  ╚═══╝  ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝\n', '  \n', '  event EthBuy(\n', '    address indexed purchaser, \n', '    address indexed beneficiary, \n', '    uint value, \n', '    uint amount);\n', '  event HashBuy(\n', '    address indexed beneficiary, \n', '    uint value, \n', '    uint amount, \n', '    uint timestamp, \n', '    bytes32 indexed bitcoinHash);\n', '  event AltBuy(\n', '    address indexed beneficiary, \n', '    address indexed allowedToken, \n', '    uint allowedTokenValue, \n', '    uint ethValue, \n', '    uint shipAmount);\n', '    \n', '  event ShipTokens(address indexed owner, uint amount);\n', '\n', '  event Sanetize();\n', '  event Finalize();\n', '\n', '  event Whitelisted(address indexed beneficiary, uint min, uint max);\n', '  event PersonalBonus(address indexed beneficiary, address indexed referer, uint bonus, uint refererBonus);\n', '  event FundsClaimed(address indexed owner, uint amount);\n', '\n', '\n', '  // ███████╗███████╗████████╗██╗   ██╗██████╗     ███╗   ███╗███████╗████████╗██╗  ██╗ ██████╗ ██████╗ ███████╗\n', '  // ██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗    ████╗ ████║██╔════╝╚══██╔══╝██║  ██║██╔═══██╗██╔══██╗██╔════╝\n', '  // ███████╗█████╗     ██║   ██║   ██║██████╔╝    ██╔████╔██║█████╗     ██║   ███████║██║   ██║██║  ██║███████╗\n', '  // ╚════██║██╔══╝     ██║   ██║   ██║██╔═══╝     ██║╚██╔╝██║██╔══╝     ██║   ██╔══██║██║   ██║██║  ██║╚════██║\n', '  // ███████║███████╗   ██║   ╚██████╔╝██║         ██║ ╚═╝ ██║███████╗   ██║   ██║  ██║╚██████╔╝██████╔╝███████║\n', '  // ╚══════╝╚══════╝   ╚═╝    ╚═════╝ ╚═╝         ╚═╝     ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚══════╝\n', '\n', '  function setFlags(\n', '    // Should be whitelisted to buy tokens\n', '    bool _isWhitelisted,\n', '    // Should be known user to buy tokens\n', '    bool _isKnownOnly,\n', '    // Enable amount bonuses in crowdsale?\n', '    bool _isAmountBonus,\n', '    // Enable early bird bonus in crowdsale?\n', '    bool _isEarlyBonus,\n', '    // Allow to buy tokens for another tokens?\n', '    bool _isTokenExchange,\n', '    // Allow to issue tokens with tx hash (ex bitcoin)\n', '    bool _isAllowToIssue,\n', '    // Should reject purchases with Ether?\n', '    bool _isDisableEther,\n', '    // Should mint extra tokens for future distribution?\n', '    bool _isExtraDistribution,\n', '    // Will ship token via minting? \n', '    bool _isTransferShipment,\n', '    // Should be capped in ether\n', '    bool _isCappedInEther,\n', '    // Should beneficiaries pull their tokens? \n', '    bool _isPersonalBonuses,\n', '    // Should allow to claim funds before finalization?\n', '    bool _isAllowClaimBeforeFinalization)\n', '    inState(State.Setup) onlyOwner public \n', '  {\n', '    isWhitelisted = _isWhitelisted;\n', '    isKnownOnly = _isKnownOnly;\n', '    isAmountBonus = _isAmountBonus;\n', '    isEarlyBonus = _isEarlyBonus;\n', '    isTokenExchange = _isTokenExchange;\n', '    isAllowToIssue = _isAllowToIssue;\n', '    isDisableEther = _isDisableEther;\n', '    isExtraDistribution = _isExtraDistribution;\n', '    isTransferShipment = _isTransferShipment;\n', '    isCappedInEther = _isCappedInEther;\n', '    isPersonalBonuses = _isPersonalBonuses;\n', '    isAllowClaimBeforeFinalization = _isAllowClaimBeforeFinalization;\n', '  }\n', '\n', '  // ! Could be changed in process of sale (since 02.2018)\n', '  function setMinimum(uint _amount, bool _inToken) \n', '    onlyOwner public\n', '  {\n', '    if (_amount == 0) {\n', '      isMinimumValue = false;\n', '      minimumPurchaseValue = 0;\n', '    } else {\n', '      isMinimumValue = true;\n', '      isMinimumInEther = !_inToken;\n', '      minimumPurchaseValue = _amount;\n', '    }\n', '  }\n', '\n', '  function setPrice(uint _price)\n', '    inState(State.Setup) onlyOwner public\n', '  {\n', '    require(_price > 0);\n', '    price = _price;\n', '  }\n', '\n', '  function setSoftHardCaps(uint _softCap, uint _hardCap)\n', '    inState(State.Setup) onlyOwner public\n', '  {\n', '    hardCap = _hardCap;\n', '    softCap = _softCap;\n', '  }\n', '\n', '  function setTime(uint _start, uint _end)\n', '    inState(State.Setup) onlyOwner public \n', '  {\n', '    require(_start < _end);\n', '    require(_end > block.timestamp);\n', '    startTime = _start;\n', '    endTime = _end;\n', '  }\n', '\n', '  function setToken(address _tokenAddress) \n', '    inState(State.Setup) onlyOwner public\n', '  {\n', '    token = MintableTokenInterface(_tokenAddress);\n', '    tokenDecimals = token.decimals();\n', '  }\n', '\n', '  function setWallet(address _wallet) \n', '    inState(State.Setup) onlyOwner public \n', '  {\n', '    require(_wallet != address(0));\n', '    wallet = _wallet;\n', '  }\n', '  \n', '  function setRegistry(address _registry) \n', '    inState(State.Setup) onlyOwner public \n', '  {\n', '    require(_registry != address(0));\n', '    userRegistry = UserRegistryInterface(_registry);\n', '  }\n', '\n', '  function setExtraDistribution(address _holder, uint _extraPart) \n', '    inState(State.Setup) onlyOwner public\n', '  {\n', '    require(_holder != address(0));\n', '    extraTokensHolder = _holder;\n', '    extraDistributionPart = _extraPart;\n', '  }\n', '\n', '  function setAmountBonuses(uint[] _amountSlices, uint[] _bonuses) \n', '    inState(State.Setup) onlyOwner public \n', '  {\n', '    require(_amountSlices.length > 1);\n', '    require(_bonuses.length == _amountSlices.length);\n', '    uint lastSlice = 0;\n', '    for (uint index = 0; index < _amountSlices.length; index++) {\n', '      require(_amountSlices[index] > lastSlice);\n', '      lastSlice = _amountSlices[index];\n', '      amountSlices.push(lastSlice);\n', '      amountBonuses[lastSlice] = _bonuses[index];\n', '    }\n', '\n', '    amountSlicesCount = amountSlices.length;\n', '  }\n', '\n', '  function setTimeBonuses(uint[] _timeSlices, uint[] _bonuses) \n', '    // ! Not need to check state since changes at 02.2018\n', '    // inState(State.Setup)\n', '    onlyOwner \n', '    public \n', '  {\n', '    // Only once in life time\n', '    // ! Time bonuses is changable after 02.2018\n', '    // require(timeSlicesCount == 0);\n', '    require(_timeSlices.length > 0);\n', '    require(_bonuses.length == _timeSlices.length);\n', '    uint lastSlice = 0;\n', '    uint lastBonus = 10000;\n', '    if (timeSlicesCount > 0) {\n', '      // ! Since time bonuses is changable we should take latest first\n', '      lastSlice = timeSlices[timeSlicesCount - 1];\n', '      lastBonus = timeBonuses[lastSlice];\n', '    }\n', '\n', '    for (uint index = 0; index < _timeSlices.length; index++) {\n', '      require(_timeSlices[index] > lastSlice);\n', '\n', '      // ! Add check for next bonus is equal or less than previous\n', '      require(_bonuses[index] <= lastBonus);\n', '\n', '      // ? Should we check bonus in a future\n', '      lastSlice = _timeSlices[index];\n', '      timeSlices.push(lastSlice);\n', '      timeBonuses[lastSlice] = _bonuses[index];\n', '    }\n', '    timeSlicesCount = timeSlices.length;\n', '  }\n', '  \n', '  function setTokenExcange(address _token, uint _value)\n', '    inState(State.Setup) onlyOwner public\n', '  {\n', '    allowedTokens[_token] = TokenInterface(_token);\n', '    updateTokenValue(_token, _value); \n', '  }\n', '\n', '  function saneIt() \n', '    inState(State.Setup) onlyOwner public \n', '  {\n', '    require(startTime < endTime);\n', '    require(endTime > now);\n', '\n', '    require(price > 0);\n', '\n', '    require(wallet != address(0));\n', '    require(token != address(0));\n', '\n', '    if (isKnownOnly) {\n', '      require(userRegistry != address(0));\n', '    }\n', '\n', '    if (isAmountBonus) {\n', '      require(amountSlicesCount > 0);\n', '    }\n', '\n', '    if (isExtraDistribution) {\n', '      require(extraTokensHolder != address(0));\n', '    }\n', '\n', '    if (isTransferShipment) {\n', '      require(token.balanceOf(address(this)) >= hardCap);\n', '    } else {\n', '      require(token.owner() == address(this));\n', '    }\n', '\n', '    state = State.Active;\n', '  }\n', '\n', '  function finalizeIt(address _futureOwner) inState(State.Active) onlyOwner public {\n', '    require(ended());\n', '\n', '    token.transferOwnership(_futureOwner);\n', '\n', '    if (success()) {\n', '      state = State.Claim;\n', '    } else {\n', '      state = State.Refund;\n', '    }\n', '  }\n', '\n', '  function historyIt() inState(State.Claim) onlyOwner public {\n', '    require(address(this).balance == 0);\n', '    state = State.History;\n', '  }\n', '\n', '  // ███████╗██╗  ██╗███████╗ ██████╗██╗   ██╗████████╗███████╗\n', '  // ██╔════╝╚██╗██╔╝██╔════╝██╔════╝██║   ██║╚══██╔══╝██╔════╝\n', '  // █████╗   ╚███╔╝ █████╗  ██║     ██║   ██║   ██║   █████╗  \n', '  // ██╔══╝   ██╔██╗ ██╔══╝  ██║     ██║   ██║   ██║   ██╔══╝  \n', '  // ███████╗██╔╝ ██╗███████╗╚██████╗╚██████╔╝   ██║   ███████╗\n', '  // ╚══════╝╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═════╝    ╚═╝   ╚══════╝\n', '\n', '  function calculateEthAmount(\n', '    address _beneficiary,\n', '    uint _weiAmount,\n', '    uint _time,\n', '    uint _totalSupply\n', '  ) public constant returns(\n', '    uint calculatedTotal, \n', '    uint calculatedBeneficiary, \n', '    uint calculatedExtra, \n', '    uint calculatedreferer, \n', '    address refererAddress) \n', '  {\n', '    _totalSupply;\n', '    uint bonus = 0;\n', '    \n', '    if (isAmountBonus) {\n', '      bonus = bonus.add(calculateAmountBonus(_weiAmount));\n', '    }\n', '\n', '    if (isEarlyBonus) {\n', '      bonus = bonus.add(calculateTimeBonus(_time.sub(startTime)));\n', '    }\n', '\n', '    if (isPersonalBonuses && personalBonuses[_beneficiary].bonus > 0) {\n', '      bonus = bonus.add(personalBonuses[_beneficiary].bonus);\n', '    }\n', '\n', '    calculatedBeneficiary = _weiAmount.mul(10 ** tokenDecimals).div(price);\n', '    if (bonus > 0) {\n', '      calculatedBeneficiary = calculatedBeneficiary.add(calculatedBeneficiary.mul(bonus).div(10000));\n', '    }\n', '\n', '    if (isExtraDistribution) {\n', '      calculatedExtra = calculatedBeneficiary.mul(extraDistributionPart).div(10000);\n', '    }\n', '\n', '    if (isPersonalBonuses && \n', '        personalBonuses[_beneficiary].refererAddress != address(0) && \n', '        personalBonuses[_beneficiary].refererBonus > 0) \n', '    {\n', '      calculatedreferer = calculatedBeneficiary.mul(personalBonuses[_beneficiary].refererBonus).div(10000);\n', '      refererAddress = personalBonuses[_beneficiary].refererAddress;\n', '    }\n', '\n', '    calculatedTotal = calculatedBeneficiary.add(calculatedExtra).add(calculatedreferer);\n', '  }\n', '\n', '  function calculateAmountBonus(uint _changeAmount) public constant returns(uint) {\n', '    uint bonus = 0;\n', '    for (uint index = 0; index < amountSlices.length; index++) {\n', '      if(amountSlices[index] > _changeAmount) {\n', '        break;\n', '      }\n', '\n', '      bonus = amountBonuses[amountSlices[index]];\n', '    }\n', '    return bonus;\n', '  }\n', '\n', '  function calculateTimeBonus(uint _at) public constant returns(uint) {\n', '    uint bonus = 0;\n', '    for (uint index = timeSlices.length; index > 0; index--) {\n', '      if(timeSlices[index - 1] < _at) {\n', '        break;\n', '      }\n', '      bonus = timeBonuses[timeSlices[index - 1]];\n', '    }\n', '\n', '    return bonus;\n', '  }\n', '\n', '  function validPurchase(\n', '    address _beneficiary, \n', '    uint _weiAmount, \n', '    uint _tokenAmount,\n', '    uint _extraAmount,\n', '    uint _totalAmount,\n', '    uint _time) \n', '  public constant returns(bool) \n', '  {\n', '    _tokenAmount;\n', '    _extraAmount;\n', '\n', '    // ! Check min purchase value (since 02.2018)\n', '    if (isMinimumValue) {\n', '      // ! Check min purchase value in ether (since 02.2018)\n', '      if (isMinimumInEther && _weiAmount < minimumPurchaseValue) {\n', '        return false;\n', '      }\n', '\n', '      // ! Check min purchase value in tokens (since 02.2018)\n', '      if (!isMinimumInEther && _tokenAmount < minimumPurchaseValue) {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    if (_time < startTime || _time > endTime) {\n', '      return false;\n', '    }\n', '\n', '    if (isKnownOnly && !userRegistry.knownAddress(_beneficiary)) {\n', '      return false;\n', '    }\n', '\n', '    uint finalBeneficiaryInvest = beneficiaryInvest[_beneficiary].add(_weiAmount);\n', '    uint finalTotalSupply = soldTokens.add(_totalAmount);\n', '\n', '    if (isWhitelisted) {\n', '      WhitelistRecord storage record = whitelist[_beneficiary];\n', '      if (!record.allow || \n', '          record.min > finalBeneficiaryInvest ||\n', '          record.max < finalBeneficiaryInvest) {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    if (isCappedInEther) {\n', '      if (weiRaised.add(_weiAmount) > hardCap) {\n', '        return false;\n', '      }\n', '    } else {\n', '      if (finalTotalSupply > hardCap) {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '                                                                                        \n', '  function updateTokenValue(address _token, uint _value) onlyOwner public {\n', '    require(address(allowedTokens[_token]) != address(0x0));\n', '    tokensValues[_token] = _value;\n', '  }\n', '\n', '  // ██████╗ ███████╗ █████╗ ██████╗ \n', '  // ██╔══██╗██╔════╝██╔══██╗██╔══██╗\n', '  // ██████╔╝█████╗  ███████║██║  ██║\n', '  // ██╔══██╗██╔══╝  ██╔══██║██║  ██║\n', '  // ██║  ██║███████╗██║  ██║██████╔╝\n', '  // ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ \n', '  function success() public constant returns(bool) {\n', '    if (isCappedInEther) {\n', '      return weiRaised >= softCap;\n', '    } else {\n', '      return token.totalSupply() >= softCap;\n', '    }\n', '  }\n', '\n', '  function capped() public constant returns(bool) {\n', '    if (isCappedInEther) {\n', '      return weiRaised >= hardCap;\n', '    } else {\n', '      return token.totalSupply() >= hardCap;\n', '    }\n', '  }\n', '\n', '  function ended() public constant returns(bool) {\n', '    return capped() || block.timestamp >= endTime;\n', '  }\n', '\n', '\n', '  //  ██████╗ ██╗   ██╗████████╗███████╗██╗██████╗ ███████╗\n', '  // ██╔═══██╗██║   ██║╚══██╔══╝██╔════╝██║██╔══██╗██╔════╝\n', '  // ██║   ██║██║   ██║   ██║   ███████╗██║██║  ██║█████╗  \n', '  // ██║   ██║██║   ██║   ██║   ╚════██║██║██║  ██║██╔══╝  \n', '  // ╚██████╔╝╚██████╔╝   ██║   ███████║██║██████╔╝███████╗\n', '  //  ╚═════╝  ╚═════╝    ╚═╝   ╚══════╝╚═╝╚═════╝ ╚══════╝\n', '  // fallback function can be used to buy tokens\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function buyTokens(address _beneficiary) inState(State.Active) public payable {\n', '    require(!isDisableEther);\n', '    uint shipAmount = sellTokens(_beneficiary, msg.value, block.timestamp);\n', '    require(shipAmount > 0);\n', '    forwardEther();\n', '  }\n', '\n', '  function buyWithHash(address _beneficiary, uint _value, uint _timestamp, bytes32 _hash) \n', '    inState(State.Active) onlyOwner public \n', '  {\n', '    require(isAllowToIssue);\n', '    uint shipAmount = sellTokens(_beneficiary, _value, _timestamp);\n', '    require(shipAmount > 0);\n', '    HashBuy(_beneficiary, _value, shipAmount, _timestamp, _hash);\n', '  }\n', '  \n', '  function receiveApproval(address _from, \n', '                           uint256 _value, \n', '                           address _token, \n', '                           bytes _extraData) public \n', '  {\n', '    if (_token == address(token)) {\n', '      TokenInterface(_token).transferFrom(_from, address(this), _value);\n', '      return;\n', '    }\n', '\n', '    require(isTokenExchange);\n', '    \n', '    require(toUint(_extraData) == tokensValues[_token]);\n', '    require(tokensValues[_token] > 0);\n', '    require(forwardTokens(_from, _token, _value));\n', '\n', '    uint weiValue = _value.mul(tokensValues[_token]).div(10 ** allowedTokens[_token].decimals());\n', '    require(weiValue > 0);\n', '\n', '    uint shipAmount = sellTokens(_from, weiValue, block.timestamp);\n', '    require(shipAmount > 0);\n', '\n', '    AltBuy(_from, _token, _value, weiValue, shipAmount);\n', '  }\n', '\n', '  function claimFunds() onlyOwner public returns(bool) {\n', '    require(state == State.Claim || (isAllowClaimBeforeFinalization && success()));\n', '    wallet.transfer(address(this).balance);\n', '    return true;\n', '  }\n', '\n', '  function claimTokenFunds(address _token) onlyOwner public returns(bool) {\n', '    require(state == State.Claim || (isAllowClaimBeforeFinalization && success()));\n', '    uint balance = allowedTokens[_token].balanceOf(address(this));\n', '    require(balance > 0);\n', '    require(allowedTokens[_token].transfer(wallet, balance));\n', '    return true;\n', '  }\n', '\n', '  function claimRefundEther(address _beneficiary) inState(State.Refund) public returns(bool) {\n', '    require(weiDeposit[_beneficiary] > 0);\n', '    _beneficiary.transfer(weiDeposit[_beneficiary]);\n', '    return true;\n', '  }\n', '\n', '  function claimRefundTokens(address _beneficiary, address _token) inState(State.Refund) public returns(bool) {\n', '    require(altDeposit[_token][_beneficiary] > 0);\n', '    require(allowedTokens[_token].transfer(_beneficiary, altDeposit[_token][_beneficiary]));\n', '    return true;\n', '  }\n', '\n', '  function addToWhitelist(address _beneficiary, uint _min, uint _max) onlyOwner public\n', '  {\n', '    require(_beneficiary != address(0));\n', '    require(_min <= _max);\n', '\n', '    if (_max == 0) {\n', '      _max = 10 ** 40; // should be huge enough? :0\n', '    }\n', '\n', '    whitelist[_beneficiary] = WhitelistRecord(true, _min, _max);\n', '    Whitelisted(_beneficiary, _min, _max);\n', '  }\n', '  \n', '  function setPersonalBonus(\n', '    address _beneficiary, \n', '    uint _bonus, \n', '    address _refererAddress, \n', '    uint _refererBonus) onlyOwner public {\n', '    personalBonuses[_beneficiary] = PersonalBonusRecord(\n', '      _bonus,\n', '      _refererAddress,\n', '      _refererBonus\n', '    );\n', '\n', '    PersonalBonus(_beneficiary, _refererAddress, _bonus, _refererBonus);\n', '  }\n', '\n', '  // ██╗███╗   ██╗████████╗███████╗██████╗ ███╗   ██╗ █████╗ ██╗     ███████╗\n', '  // ██║████╗  ██║╚══██╔══╝██╔════╝██╔══██╗████╗  ██║██╔══██╗██║     ██╔════╝\n', '  // ██║██╔██╗ ██║   ██║   █████╗  ██████╔╝██╔██╗ ██║███████║██║     ███████╗\n', '  // ██║██║╚██╗██║   ██║   ██╔══╝  ██╔══██╗██║╚██╗██║██╔══██║██║     ╚════██║\n', '  // ██║██║ ╚████║   ██║   ███████╗██║  ██║██║ ╚████║██║  ██║███████╗███████║\n', '  // ╚═╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚══════╝╚══════╝\n', '  // low level token purchase function\n', '  function sellTokens(address _beneficiary, uint _weiAmount, uint timestamp) \n', '    inState(State.Active) internal returns(uint)\n', '  {\n', '    uint beneficiaryTokens;\n', '    uint extraTokens;\n', '    uint totalTokens;\n', '    uint refererTokens;\n', '    address refererAddress;\n', '    (totalTokens, beneficiaryTokens, extraTokens, refererTokens, refererAddress) = calculateEthAmount(\n', '      _beneficiary, \n', '      _weiAmount, \n', '      timestamp, \n', '      token.totalSupply());\n', '\n', '    require(validPurchase(_beneficiary,   // Check if current purchase is valid\n', '                          _weiAmount, \n', '                          beneficiaryTokens,\n', '                          extraTokens,\n', '                          totalTokens,\n', '                          timestamp));\n', '\n', '    weiRaised = weiRaised.add(_weiAmount); // update state (wei amount)\n', '    beneficiaryInvest[_beneficiary] = beneficiaryInvest[_beneficiary].add(_weiAmount);\n', '    shipTokens(_beneficiary, beneficiaryTokens);     // ship tokens to beneficiary\n', '    EthBuy(msg.sender,             // Fire purchase event\n', '                  _beneficiary, \n', '                  _weiAmount, \n', '                  beneficiaryTokens);\n', '    ShipTokens(_beneficiary, beneficiaryTokens);\n', '\n', '    if (isExtraDistribution) {            // calculate and\n', '      shipTokens(extraTokensHolder, extraTokens);\n', '      ShipTokens(extraTokensHolder, extraTokens);\n', '    }\n', '\n', '    if (isPersonalBonuses) {\n', '      PersonalBonusRecord storage record = personalBonuses[_beneficiary];\n', '      if (record.refererAddress != address(0) && record.refererBonus > 0) {\n', '        shipTokens(record.refererAddress, refererTokens);\n', '        ShipTokens(record.refererAddress, refererTokens);\n', '      }\n', '    }\n', '\n', '    soldTokens = soldTokens.add(totalTokens);\n', '    return beneficiaryTokens;\n', '  }\n', '\n', '  function shipTokens(address _beneficiary, uint _amount) \n', '    inState(State.Active) internal \n', '  {\n', '    if (isTransferShipment) {\n', '      token.transfer(_beneficiary, _amount);\n', '    } else {\n', '      token.mint(address(this), _amount);\n', '      token.transfer(_beneficiary, _amount);\n', '    }\n', '  }\n', '\n', '  function forwardEther() internal returns (bool) {\n', '    weiDeposit[msg.sender] = msg.value;\n', '    return true;\n', '  }\n', '\n', '  function forwardTokens(address _beneficiary, address _tokenAddress, uint _amount) internal returns (bool) {\n', '    TokenInterface allowedToken = allowedTokens[_tokenAddress];\n', '    allowedToken.transferFrom(_beneficiary, address(this), _amount);\n', '    altDeposit[_tokenAddress][_beneficiary] = _amount;\n', '    return true;\n', '  }\n', '\n', '  // ██╗   ██╗████████╗██╗██╗     ███████╗\n', '  // ██║   ██║╚══██╔══╝██║██║     ██╔════╝\n', '  // ██║   ██║   ██║   ██║██║     ███████╗\n', '  // ██║   ██║   ██║   ██║██║     ╚════██║\n', '  // ╚██████╔╝   ██║   ██║███████╗███████║\n', '  //  ╚═════╝    ╚═╝   ╚═╝╚══════╝╚══════╝\n', '  function toUint(bytes left) public pure returns (uint) {\n', '      uint out;\n', '      for (uint i = 0; i < 32; i++) {\n', '          out |= uint(left[i]) << (31 * 8 - i * 8);\n', '      }\n', '      \n', '      return out;\n', '  }\n', '}\n', '\n', 'contract BaseAltCrowdsale is Crowdsale {\n', '  function BaseAltCrowdsale(\n', '    address _registry,\n', '    address _token,\n', '    address _extraTokensHolder,\n', '    address _wallet,\n', '    bool _isWhitelisted,\n', '    uint _price,\n', '    uint _start,\n', '    uint _end,\n', '    uint _softCap,\n', '    uint _hardCap\n', '  ) public {\n', '    setFlags(\n', '      // Should be whitelisted to buy tokens\n', '      // _isWhitelisted,\n', '      _isWhitelisted,\n', '      // Should be known user to buy tokens\n', '      // _isKnownOnly,\n', '      true,\n', '      // Enable amount bonuses in crowdsale? \n', '      // _isAmountBonus,\n', '      true,\n', '      // Enable early bird bonus in crowdsale?\n', '      // _isEarlyBonus,\n', '      true,\n', '      // Allow to buy tokens for another tokens?\n', '      // _isTokenExcange,\n', '      false,\n', '      // Allow to issue tokens with tx hash (ex bitcoin)\n', '      // _isAllowToIssue,\n', '      true,\n', '      // Should reject purchases with Ether?\n', '      // _isDisableEther,\n', '      false,\n', '      // Should mint extra tokens for future distribution?\n', '      // _isExtraDistribution,\n', '      true,\n', '      // Will ship token via minting? \n', '      // _isTransferShipment,\n', '      false,\n', '      // Should be capped in ether\n', '      // bool _isCappedInEther,\n', '      true,\n', '      // Should check personal bonuses?\n', '      // _isPersonalBonuses\n', '      true,\n', '      // Should allow to claimFunds before finalizations?\n', '      false\n', '    );\n', '\n', '    setToken(_token); \n', '    setTime(_start, _end);\n', '    setRegistry(_registry);\n', '    setWallet(_wallet);\n', '    setExtraDistribution(\n', '      _extraTokensHolder,\n', '      6667 // 66.67%\n', '    );\n', '\n', '    setSoftHardCaps(\n', '      _softCap, // soft\n', '      _hardCap  // hard\n', '    );\n', '\n', '    // 200 ALT per 1 ETH\n', '    setPrice(_price);\n', '  }\n', '}\n', '\n', 'contract AltCrowdsalePhaseOne is BaseAltCrowdsale {\n', '  function AltCrowdsalePhaseOne (\n', '    address _registry,\n', '    address _token,\n', '    address _extraTokensHolder,\n', '    address _wallet\n', '  )\n', '  BaseAltCrowdsale(\n', '    _registry,\n', '    _token,\n', '    _extraTokensHolder,\n', '    _wallet,\n', '\n', '    // Whitelisted\n', '    false,\n', '\n', '    // price 1 ETH -> 100000 ALT\n', '    uint(1 ether).div(100000), \n', '\n', '    // start\n', '    block.timestamp,\n', '    // end \n', '    1527764400,\n', '\n', '    // _softCap,\n', '    2500 ether,\n', '    // _hardCap\n', '    7500 ether\n', '  ) \n', '  public {\n', '  } \n', '}']
