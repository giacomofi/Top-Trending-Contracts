['pragma solidity ^0.5.0;\n', '\n', 'library SafeMath {\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '  /*function mul(uint a, uint b) internal pure returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }*/\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  address public owner; //owner\n', '  function balanceOf(address who) public view returns (uint);\n', '  function transfer(address to, uint value) public;\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  function commitDividend(address who) public; // pays remaining dividend\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint);\n', '  function transferFrom(address from, address to, uint value) public;\n', '  function approve(address spender, uint value) public;\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint;\n', '  // users\n', '  struct User {\n', '    uint120 tokens; // current tokens of user\n', '    uint120 asks;   // current tokens in asks\n', '    uint120 votes;  // current voting power\n', '    uint120 weis;   // current wei balance of user\n', "    uint32 lastProposalID; // last processed dividend period of user's tokens\n", '    address owner;  // votes for new owner\n', '    uint8   voted;  // vote for proposal\n', '  }\n', '  mapping (address => User) users;\n', '\n', '  modifier onlyPayloadSize(uint size) {\n', '    assert(msg.data.length >= size + 4);\n', '    _;\n', '  }\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n', '    commitDividend(msg.sender);\n', '    users[msg.sender].tokens = uint120(uint(users[msg.sender].tokens).sub(_value));\n', '    if(_to == address(this)) {\n', '      commitDividend(owner);\n', '      users[owner].tokens = uint120(uint(users[owner].tokens).add(_value));\n', '      emit Transfer(msg.sender, owner, _value);\n', '    }\n', '    else {\n', '      commitDividend(_to);\n', '      users[_to].tokens = uint120(uint(users[_to].tokens).add(_value));\n', '      emit Transfer(msg.sender, _to, _value);\n', '    }\n', '  }\n', '  /**\n', '  * @dev Gets the amount of tokens\n', '  * @param _owner The address to query.\n', '  * @return An uint representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint) {\n', '    return uint(users[_owner].tokens);\n', '  }\n', '  /**\n', '  * @dev Gets the amount of tokens offered for sale (in asks)\n', '  * @param _owner The address to query.\n', '  * @return An uint representing the amount offered by the passed address.\n', '  */\n', '  function askOf(address _owner) public view returns (uint) {\n', '    return uint(users[_owner].asks);\n', '  }\n', '  /**\n', '  * @dev Gets the amount of tokens offered for sale (in asks)\n', '  * @param _owner The address to query.\n', '  * @return An uint representing the amount offered by the passed address.\n', '  */\n', '  function voteOf(address _owner) public view returns (uint) {\n', '    return uint(users[_owner].votes);\n', '  }\n', '  /**\n', '  * @dev Gets the amount of wei owned by user and stored in contract\n', '  * @param _owner The address to query.\n', '  * @return An uint representing the amount wei stored in contract.\n', '  */\n', '  function weiOf(address _owner) public view returns (uint) {\n', '    return uint(users[_owner].weis);\n', '  }\n', '  /**\n', '  * @dev Gets the id of last proccesed proposal period\n', '  * @param _owner The address to query.\n', '  * @return An uint representing the id of last processed proposal period\n', '  */\n', '  function lastOf(address _owner) public view returns (uint) {\n', '    return uint(users[_owner].lastProposalID);\n', '  }\n', '  /**\n', '  * @dev Gets the proposed address of new contract owner / manager\n', '  * @param _owner The address to query.\n', '  * @return An address proposed as new contract owner / manager\n', '  */\n', '  function ownerOf(address _owner) public view returns (address) {\n', '    return users[_owner].owner;\n', '  }\n', '  /**\n', '  * @dev Gets the status of voting\n', '  * @param _owner The address to query.\n', '  * @return An uint > 0 if user already voted\n', '  */\n', '  function votedOf(address _owner) public view returns (uint) {\n', '    return uint(users[_owner].voted);\n', '  }\n', '}\n', '\n', 'contract StandardToken is BasicToken, ERC20 {\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint the amount of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n', '    uint _allowance = allowed[_from][msg.sender];\n', '    commitDividend(_from);\n', '    commitDividend(_to);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    users[_from].tokens = uint120(uint(users[_from].tokens).sub(_value));\n', '    users[_to].tokens = uint120(uint(users[_to].tokens).add(_value));\n', '    emit Transfer(_from, _to, _value);\n', '  }\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint _value) public {\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '  }\n', '  /**\n', '   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', '/**\n', ' * @title PicoStocksAsset contract\n', ' */\n', 'contract PicoStocksAsset is StandardToken {\n', '\n', '    // metadata\n', '    string public constant version = "0.2";\n', '    string public constant name = "PicoStocks Asset";\n', '    uint public constant decimals = 0;\n', '    uint public picoid = 0; // Asset ID on PicoStocks\n', '    string public symbol = ""; // Asset code on PicoStocks\n', '    string public www = ""; // Official web page\n', '\n', '    uint public totalWeis = 0; // sum of wei owned by users\n', '    uint public totalVotes = 0;  // number of alligible votes\n', '\n', '    struct Order {\n', '        uint64 prev;   // previous order, need this to enable safe/fast order cancel\n', '        uint64 next;   // next order\n', '        uint128 price; // offered/requested price of 1 token\n', '        uint96 amount; // number of offered/requested tokens\n', '        address who;   // address of owner of tokens or funds\n', '    }\n', '    mapping (uint => Order) asks;\n', '    mapping (uint => Order) bids;\n', '    uint64 firstask=0; // key of lowest ask\n', '    uint64 lastask=0;  // key of last inserted ask\n', '    uint64 firstbid=0; // key of highest bid\n', '    uint64 lastbid=0;  // key of last inserted bid\n', '\n', '    uint constant weekBlocks = 4*60*24*7; // number of blocks in 1 week\n', '    uint constant minPrice  = 0xFFFF;                             // min price per token\n', '    uint constant maxPrice  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // max price per token\n', '    uint constant maxTokens = 0xFFFFFFFFFFFFFFFFFFFFFFFF;         // max number of tokens\n', '\n', '    address public custodian = 0xd720a4768CACE6d508d8B390471d83BA3aE6dD32;\n', '\n', '    // investment parameters\n', '    uint public investOwner; // number of tokens assigned to owner if first round successfull\n', '    uint public investPrice; // price of 1 token\n', '    uint public investStart; // first block of funding round\n', '    uint public investEnd;   // last block of funding round\n', '    uint public investGot;   // funding collected\n', '    uint public investMin;   // minimum funding\n', '    uint public investMax;   // maximum funding\n', '    uint public investKYC = 1;   // KYC requirement\n', '\n', '    //dividends\n', '    uint[] public dividends; // dividens collected per period, growing array\n', '\n', '    //proposal\n', '    uint public proposalID = 1;   // proposal number and dividend period\n', '    uint public proposalVotesYes; // yes-votes collected\n', '    uint public proposalVotesNo;  // no-votes collected\n', '    uint public proposalBlock;    // block number proposal published\n', '    uint public proposalDividendPerShare; // dividend per share\n', '    uint public proposalBudget;   // budget for the owner for next period\n', '    uint public proposalTokens;   // number of new tokens for next round\n', '    uint public proposalPrice;    // price of new token in next round\n', '    uint public acceptedBudget;   // unspent budget for the owner in current round\n', '\n', '    //change owner\n', '    mapping (address => uint) owners; // votes for new owners / managers of the contract\n', '\n', '    // events\n', '    event LogBuy(address indexed who, uint amount, uint price);\n', '    event LogSell(address indexed who, uint amount, uint price);\n', '    event LogCancelBuy(address indexed who, uint amount, uint price);\n', '    event LogCancelSell(address indexed who, uint amount, uint price);\n', '    event LogTransaction(address indexed from, address indexed to, uint amount, uint price);\n', '    event LogDeposit(address indexed who,uint amount);\n', '    event LogWithdraw(address indexed who,uint amount);\n', '    event LogExec(address indexed who,uint amount);\n', '    event LogPayment(address indexed who, address from, uint amount);\n', '    event LogDividend(uint amount);\n', '    event LogDividend(address indexed who, uint amount, uint period);\n', '    event LogNextInvestment(uint price,uint amount);\n', '    event LogNewOwner(address indexed who);\n', '    event LogNewCustodian(address indexed who);\n', '    event LogNewWww(string www);\n', '    event LogProposal(uint dividendpershare,uint budget,uint moretokens,uint minprice);\n', '    event LogVotes(uint proposalVotesYes,uint proposalVotesNo);\n', '    event LogBudget(uint proposalBudget);\n', '    event LogAccepted(uint proposalDividendPerShare,uint proposalBudget,uint proposalTokens,uint proposalPrice);\n', '    event LogRejected(uint proposalDividendPerShare,uint proposalBudget,uint proposalTokens,uint proposalPrice);\n', '    \n', '    modifier onlyOwner() {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // constructor\n', '    /**\n', '     * @dev Contract constructor\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '/* initial investment functions */\n', '\n', '    /**\n', '     * @dev Set first funding round parameters\n', '     * @param _tokens number of tokens given to admin\n', '     * @param _budget initial approved budget\n', '     * @param _price price of 1 token in first founding round\n', '     * @param _from block number of start of funding round\n', '     * @param _length length of the funding round in blocks\n', '     * @param _min minimum number of tokens to sell\n', '     * @param _max maximum number of tokens to sell\n', '     * @param _kyc require KYC during first investment round\n', '     * @param _picoid asset id on picostocks\n', '     * @param _symbol asset symmbol on picostocks\n', '     */\n', '    function setFirstInvestPeriod(uint _tokens,uint _budget,uint _price,uint _from,uint _length,uint _min,uint _max,uint _kyc,uint _picoid,string memory _symbol) public onlyOwner {\n', '        require(investEnd == 0 && _price < maxPrice && _length <= weekBlocks * 12 && _min <= _max && _tokens.add(_max) < maxTokens );\n', '        investOwner = _tokens;\n', '        acceptedBudget = _budget;\n', '        users[owner].lastProposalID = uint32(proposalID);\n', '        users[custodian].lastProposalID = uint32(proposalID);\n', '        if(_price <= minPrice){\n', '          _price = minPrice+1;\n', '        }\n', '        investPrice = _price;\n', '        if(_from < block.number){\n', '          _from = block.number;\n', '        }\n', '        investStart = _from;\n', '        if(_length == 0){\n', '          _length = weekBlocks * 4;\n', '        }\n', '        investEnd = _from + _length;\n', '        investMin = _min;\n', '        investMax = _max;\n', '        investKYC = _kyc;\n', '        picoid = _picoid;\n', '        symbol = _symbol;\n', '        dividends.push(0); // not used\n', '        dividends.push(0); // current dividend\n', '        if(investMax == 0){\n', '          closeInvestPeriod();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Accept address for first investment\n', '     * @param _who accepted address (investor)\n', '     */\n', '    function acceptKYC(address _who) external onlyOwner {\n', '        if(users[_who].lastProposalID==0){\n', '          users[_who].lastProposalID=1;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Buy tokens\n', '     */\n', '    function invest() payable public {\n', '        commitDividend(msg.sender);\n', '        require(msg.value > 0 && block.number >= investStart && block.number < investEnd && totalSupply < investMax && investPrice > 0);\n', '        uint tokens = msg.value / investPrice;\n', '        if(investMax < totalSupply.add(tokens)){\n', '            tokens = investMax.sub(totalSupply);\n', '        }\n', '        totalSupply += tokens;\n', '        users[msg.sender].tokens += uint120(tokens);\n', '        emit Transfer(address(0),msg.sender,tokens);\n', '        uint _value = msg.value.sub(tokens * investPrice);\n', '        if(_value > 0){ // send back excess funds immediately\n', '            emit LogWithdraw(msg.sender,_value);\n', '            (bool success, /*bytes memory _unused*/) = msg.sender.call.value(_value)("");\n', '            require(success);\n', '        }\n', '        if(totalSupply>=investMax){\n', '            closeInvestPeriod();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Buy tokens\n', '     */\n', '    function () payable external {\n', '        invest();\n', '    }\n', '\n', '    /**\n', '     * @dev Return wei to token owners if first funding round failes\n', '     */\n', '    function disinvest() public {\n', '        require(investEnd < block.number && totalSupply < investMin && totalSupply>0 && proposalID > 1);\n', '        payDividend((address(this).balance-totalWeis)/totalSupply); //CHANGED\n', '        investEnd = block.number + weekBlocks*4; // enable future dividend payment if contract has funds\n', '    }\n', '\n', '/* management functions */\n', '\n', '    /**\n', '     * @dev Propose dividend, budget and optional funding parameters for next round\n', '     * @param _dividendpershare amount of wei per share to pay out\n', '     * @param _budget amount of wei to give to owner\n', '     * @param _tokens amount of new tokens to issue\n', '     * @param _price price of 1 new token\n', '     */\n', '    function propose(uint _dividendpershare,uint _budget,uint _tokens,uint _price) external onlyOwner {\n', '        require(proposalBlock + weekBlocks*4 < block.number && investEnd < block.number && proposalID > 1); //can not send more than 1 proposal per 28 days\n', '        if(block.number>investEnd && investStart>0 && investPrice>0 && investMax>0){\n', '          totalVotes=totalSupply;\n', '          investStart=0;\n', '          investMax=0;\n', '        }\n', '        proposalVotesYes=0;\n', '        proposalVotesNo=0;\n', '        proposalID++;\n', '        dividends.push(0);\n', '        proposalBlock=block.number;\n', '        proposalDividendPerShare=_dividendpershare;\n', '        proposalBudget=_budget;\n', '        proposalTokens=_tokens;\n', '        proposalPrice=_price;\n', '        emit LogProposal(_dividendpershare,_budget,_tokens,_price);\n', '    }\n', '\n', '    /**\n', '     * @dev Execute proposed plan if passed\n', '     */\n', '    function executeProposal() public {\n', '        require(proposalVotesYes > 0 && (proposalBlock + weekBlocks*4 < block.number || proposalVotesYes>totalVotes/2 || proposalVotesNo>totalVotes/2) && proposalID > 1);\n', '        //old require(proposalVotesYes > 0);\n', '        emit LogVotes(proposalVotesYes,proposalVotesNo);\n', '        if(proposalVotesYes >= proposalVotesNo && (proposalTokens==0 || proposalPrice>=investPrice || proposalVotesYes>totalVotes/2)){\n', '          if(payDividend(proposalDividendPerShare) > 0){\n', '            emit LogBudget(proposalBudget);\n', '            acceptedBudget=proposalBudget;}\n', '          if(proposalTokens>0){\n', '            emit LogNextInvestment(proposalPrice,proposalTokens);\n', '            setNextInvestPeriod(proposalPrice,proposalTokens);}\n', '          emit LogAccepted(proposalDividendPerShare,proposalBudget,proposalTokens,proposalPrice);}\n', '        else{\n', '          emit LogRejected(proposalDividendPerShare,proposalBudget,proposalTokens,proposalPrice);}\n', '        proposalBlock=0;\n', '        proposalVotesYes=0;\n', '        proposalVotesNo=0;\n', '        proposalDividendPerShare=0;\n', '        proposalBudget=0;\n', '        proposalTokens=0;\n', '        proposalPrice=0;\n', '    }\n', '\n', '    /**\n', '     * @dev Set next funding round parameters\n', '     * @param _price price of 1 new token\n', '     * @param _tokens amount of new tokens to issue\n', '     */\n', '    function setNextInvestPeriod(uint _price,uint _tokens) internal {\n', '        require(totalSupply >= investMin && _price > 0 && _price < maxPrice && totalSupply + _tokens < 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '        investStart = block.number + weekBlocks*2;\n', '        investEnd = block.number + weekBlocks*4;\n', '        investPrice = _price; // too high price will disable future investments\n', '        investMax = totalSupply + _tokens;\n', '        investKYC=0;\n', '    }\n', '\n', '    /**\n', '     * @dev Finish funding round and update voting power\n', '     */\n', '    function closeInvestPeriod() public {\n', '        require((block.number>investEnd || totalSupply>=investMax) && investStart>0);\n', '        if(proposalID == 1){\n', '          totalSupply += investOwner;\n', '          users[owner].tokens += uint120(investOwner);\n', '          if(totalSupply == 0){\n', '            totalSupply = 1;\n', '            users[owner].tokens = 1;\n', '          }\n', '        }\n', '        proposalID++;\n', '        dividends.push(0);\n', '        totalVotes=totalSupply;\n', '        investStart=0;\n', '        investMax=0;\n', '        investKYC=0;\n', '    }\n', '\n', '    /**\n', '     * @dev Pay dividend per share \n', '     * @param _wei The amount of wei to pay per share\n', '     */\n', '    function payDividend(uint _wei) internal returns (uint) {\n', '        if(_wei == 0){\n', '          return 1;}\n', '        //uint newdividend = _wei.mul(totalSupply);\n', '        uint newdividend = _wei * totalSupply;\n', '        require(newdividend / _wei == totalSupply);\n', '        if(address(this).balance < newdividend.add(totalWeis)){\n', '          emit LogDividend(0); //indicates failure\n', '          return 0;}\n', '        totalWeis += newdividend;\n', '        dividends[proposalID] = _wei;\n', '        proposalID++;\n', '        dividends.push(0);\n', '        totalVotes=totalSupply;\n', '        emit LogDividend(_wei);\n', '        return(_wei);\n', '    }\n', '\n', '    /**\n', '     * @dev Commit remaining dividends and update votes before transfer of tokens\n', '     * @param _who User to process\n', '     */\n', '    function commitDividend(address _who) public {\n', '        uint last = users[_who].lastProposalID;\n', '        require(investKYC==0 || last>0); // only authorized investors during KYC period\n', '        uint tokens=users[_who].tokens+users[_who].asks;\n', '        if((tokens==0) || (last==0)){\n', '            users[_who].lastProposalID=uint32(proposalID);\n', '            return;\n', '        }\n', '        if(last==proposalID) {\n', '            return;\n', '        }\n', '        if(tokens != users[_who].votes){\n', '            if(users[_who].owner != address(0)){\n', '                owners[users[_who].owner] = owners[users[_who].owner].add(tokens).sub(uint(users[_who].votes));\n', '            }\n', '            users[_who].votes=uint120(tokens); // store voting power\n', '        }\n', '        uint balance = 0;\n', '        for(; last < proposalID ; last ++) {\n', '            balance += tokens * dividends[last];\n', '        }\n', '        users[_who].weis += uint120(balance);\n', '        users[_who].lastProposalID = uint32(last);\n', '        users[_who].voted=0;\n', '        emit LogDividend(_who,balance,last);\n', '    }\n', '\n', '/* administrative functions */\n', '\n', '    /**\n', '     * @dev Change owner\n', '     * @param _who The address of new owner\n', '     */\n', '    function changeOwner(address _who) external onlyOwner {\n', '        assert(_who != address(0));\n', '        owner = _who;\n', '        emit LogNewOwner(_who);\n', '    }\n', '\n', '    /**\n', '     * @dev Change the official www address\n', '     * @param _www The new www address\n', '     */\n', '    function changeWww(string calldata _www) external onlyOwner {\n', '        www=_www;\n', '        emit LogNewWww(_www);\n', '    }\n', '\n', '    /**\n', '     * @dev Change owner\n', '     * @param _who The address of new owner\n', '     */\n', '    function changeCustodian(address _who) external { //CHANGED\n', '        assert(msg.sender == custodian);\n', '        assert(_who != address(0));\n', '        custodian = _who;\n', '        emit LogNewCustodian(_who);\n', '    }\n', '\n', '    /**\n', '     * @dev Execute a call\n', '     * @param _to destination address\n', '     * @param _data The call data\n', '     */\n', '    function exec(address _to,bytes calldata _data) payable external onlyOwner {\n', '        emit LogExec(_to,msg.value);\n', '        (bool success, /*bytes memory _unused*/) =_to.call.value(msg.value)(_data);\n', '        require(success);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw funds from contract by contract owner / manager\n', '     * @param _amount The amount of wei to withdraw\n', '     * @param _who The addres to send wei to\n', '     */\n', '    function spend(uint _amount,address _who) external onlyOwner {\n', '        require(_amount > 0 && address(this).balance >= _amount.add(totalWeis) && totalSupply >= investMin);\n', '        acceptedBudget=acceptedBudget.sub(_amount); //check for excess withdrawal\n', '        if(_who == address(0)){\n', '          emit LogWithdraw(msg.sender,_amount);\n', '          (bool success, /*bytes memory _unused*/) = msg.sender.call.value(_amount)("");\n', '          require(success);}\n', '        else{\n', '          emit LogWithdraw(_who,_amount);\n', '          (bool success, /*bytes memory _unused*/) = _who.call.value(_amount)("");\n', '          require(success);}\n', '    }\n', '\n', '/* user functions */\n', '\n', '    /**\n', '     * @dev Vote to change contract owner / manager\n', '     * @param _who The addres of the proposed new contract owner / manager\n', '     */\n', '    function voteOwner(address _who) external {\n', '        require(_who != users[msg.sender].owner);\n', '        if(users[msg.sender].owner != address(0)){\n', '          owners[users[msg.sender].owner] = owners[users[msg.sender].owner].sub(users[msg.sender].votes);\n', '        }\n', '        users[msg.sender].owner=_who;\n', '        if(_who != address(0)){\n', '          owners[_who] = owners[_who].add(users[msg.sender].votes);\n', '          if(owners[_who] > totalVotes/2 && _who != owner){\n', '            owner = _who;\n', '            emit LogNewOwner(_who);\n', '          }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Vote in favor of the current proposal\n', '     */\n', '    function voteYes() public {\n', '        commitDividend(msg.sender);\n', '        require(users[msg.sender].voted == 0 && proposalBlock + weekBlocks*4 > block.number && proposalBlock > 0);\n', '        users[msg.sender].voted=1;\n', '        proposalVotesYes+=users[msg.sender].votes;\n', '    }\n', '\n', '    /**\n', '     * @dev Vote against the current proposal\n', '     */\n', '    function voteNo() public {\n', '        commitDividend(msg.sender);\n', '        require(users[msg.sender].voted == 0 && proposalBlock + weekBlocks*4 > block.number && proposalBlock > 0);\n', '        users[msg.sender].voted=1;\n', '        proposalVotesNo+=users[msg.sender].votes;\n', '    }\n', '\n', '    /**\n', '     * @dev Vote in favor of the proposal defined by ID\n', '     * @param _id Proposal ID\n', '     */\n', '    function voteYes(uint _id) external {\n', '        require(proposalID==_id);\n', '        voteYes();\n', '    }\n', '\n', '    /**\n', '     * @dev Vote against the proposal defined by ID\n', '     * @param _id Proposal ID\n', '     */\n', '    function voteNo(uint _id) external {\n', '        require(proposalID==_id);\n', '        voteNo();\n', '    }\n', '\n', '    /**\n', '     * @dev Store funds in contract\n', '     */\n', '    function deposit() payable external {\n', '        commitDividend(msg.sender); //CHANGED\n', '        users[msg.sender].weis += uint120(msg.value);\n', '        totalWeis += msg.value;\n', '        emit LogDeposit(msg.sender,msg.value);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw funds from contract\n', '     * @param _amount Amount of wei to withdraw\n', '     */\n', '    function withdraw(uint _amount) external {\n', '        commitDividend(msg.sender);\n', '        uint amount=_amount;\n', '        if(amount > 0){\n', '           require(users[msg.sender].weis >= amount);\n', '        }\n', '        else{\n', '           require(users[msg.sender].weis > 0);\n', '           amount=users[msg.sender].weis;\n', '        }\n', '        users[msg.sender].weis = uint120(uint(users[msg.sender].weis).sub(amount));\n', '        totalWeis = totalWeis.sub(amount);\n', '        //msg.sender.transfer(amount);\n', '        emit LogWithdraw(msg.sender,amount);\n', '        (bool success, /*bytes memory _unused*/) = msg.sender.call.value(amount)("");\n', '        require(success);\n', '    }\n', '\n', '    /**\n', '     * @dev Wire funds from one user to another user\n', '     * @param _amount Amount of wei to wire\n', '     * @param _who Address of the user to wire to\n', '     */\n', '    function wire(uint _amount,address _who) external {\n', '        users[msg.sender].weis = uint120(uint(users[msg.sender].weis).sub(_amount));\n', '        users[_who].weis = uint120(uint(users[_who].weis).add(_amount));\n', '    }\n', '\n', '    /**\n', '     * @dev Send wei to contract\n', '     * @param _who Address of the payee\n', '     */\n', '    function pay(address _who) payable external {\n', '        emit LogPayment(_who,msg.sender,msg.value);\n', '    }\n', '\n', '/* market view functions */\n', '\n', '    /**\n', '     * @dev Return ask orders optionally filtered by user\n', '     * @param _who Optional address of the user\n', '     * @return An array of uint representing the (filtered) orders, 4 uints per order (id,price,amount,user)\n', '     */\n', '    function ordersSell(address _who) external view returns (uint[256] memory) {\n', '        uint[256] memory ret;\n', '        uint num=firstask;\n', '        uint id=0;\n', '        for(;asks[num].price>0 && id<64;num=uint(asks[num].next)){\n', '          if(_who!=address(0) && _who!=asks[num].who){\n', '            continue;\n', '          }\n', '          ret[4*id+0]=num;\n', '          ret[4*id+1]=uint(asks[num].price);\n', '          ret[4*id+2]=uint(asks[num].amount);\n', '          ret[4*id+3]=uint(asks[num].who);\n', '          id++;}\n', '        return ret;\n', '    }\n', '\n', '    /**\n', '     * @dev Return bid orders optionally filtered by user\n', '     * @param _who Optional address of the user\n', '     * @return An array of uint representing the (filtered) orders, 4 uints per order (id,price,amount,user)\n', '     */\n', '    function ordersBuy(address _who) external view returns (uint[256] memory) {\n', '        uint[256] memory ret;\n', '        uint num=firstbid;\n', '        uint id=0;\n', '        for(;bids[num].price>0 && id<64;num=uint(bids[num].next)){\n', '          if(_who!=address(0) && _who!=bids[num].who){\n', '            continue;\n', '          }\n', '          ret[4*id+0]=num;\n', '          ret[4*id+1]=uint(bids[num].price);\n', '          ret[4*id+2]=uint(bids[num].amount);\n', '          ret[4*id+3]=uint(bids[num].who);\n', '          id++;}\n', '        return ret;\n', '    }\n', '\n', '    /**\n', '     * @dev Find the ask order id for a user\n', '     * @param _who The address of the user\n', '     * @param _minprice Optional minimum price\n', '     * @param _maxprice Optional maximum price\n', '     * @return The id of the order\n', '     */\n', '    function findSell(address _who,uint _minprice,uint _maxprice) external view returns (uint) {\n', '        uint num=firstask;\n', '        for(;asks[num].price>0;num=asks[num].next){\n', '          if(_maxprice > 0 && asks[num].price > _maxprice){\n', '            return 0;}\n', '          if(_minprice > 0 && asks[num].price < _minprice){\n', '            continue;}\n', '          if(_who == asks[num].who){ //FIXED !!!\n', '            return num;}}\n', '    }\n', '\n', '    /**\n', '     * @dev Find the bid order id for a user\n', '     * @param _who The address of the user\n', '     * @param _minprice Optional minimum price\n', '     * @param _maxprice Optional maximum price\n', '     * @return The id of the order\n', '     */\n', '    function findBuy(address _who,uint _minprice,uint _maxprice) external view returns (uint) {\n', '        uint num=firstbid;\n', '        for(;bids[num].price>0;num=bids[num].next){\n', '          if(_minprice > 0 && bids[num].price < _minprice){\n', '            return 0;}\n', '          if(_maxprice > 0 && bids[num].price > _maxprice){\n', '            continue;}\n', '          if(_who == bids[num].who){\n', '            return num;}}\n', '    }\n', '\n', '    /**\n', '     * @dev Report the user address of an ask order\n', '     * @param _id The id of the order\n', '     * @return The address of the user placing the order\n', '     */\n', '    function whoSell(uint _id) external view returns (address) {\n', '        if(_id>0){\n', '          return address(asks[_id].who);\n', '        }\n', '        return address(asks[firstask].who);\n', '    }\n', '\n', '    /**\n', '     * @dev Report the user address of a bid order\n', '     * @param _id The id of the order\n', '     * @return The address of the user placing the order\n', '     */\n', '    function whoBuy(uint _id) external view returns (address) {\n', '        if(_id>0){\n', '          return address(bids[_id].who);\n', '        }\n', '        return address(bids[firstbid].who);\n', '    }\n', '\n', '    /**\n', '     * @dev Report the amount of tokens of an ask order\n', '     * @param _id The id of the order\n', '     * @return The amount of tokens offered\n', '     */\n', '    function amountSell(uint _id) external view returns (uint) {\n', '        if(_id>0){\n', '          return uint(asks[_id].amount);\n', '        }\n', '        return uint(asks[firstask].amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Report the amount of tokens of a bid order\n', '     * @param _id The id of the order\n', '     * @return The amount of tokens requested\n', '     */\n', '    function amountBuy(uint _id) external view returns (uint) {\n', '        if(_id>0){\n', '          return uint(bids[_id].amount);\n', '        }\n', '        return uint(bids[firstbid].amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Report the price of 1 token of an ask order\n', '     * @param _id The id of the order\n', '     * @return The requested price for 1 token\n', '     */\n', '    function priceSell(uint _id) external view returns (uint) {\n', '        if(_id>0){\n', '          return uint(asks[_id].price);\n', '        }\n', '        return uint(asks[firstask].price);\n', '    }\n', '\n', '    /**\n', '     * @dev Report the price of 1 token of a bid order\n', '     * @param _id The id of the order\n', '     * @return The offered price for 1 token\n', '     */\n', '    function priceBuy(uint _id) external view returns (uint) {\n', '        if(_id>0){\n', '          return uint(bids[_id].price);\n', '        }\n', '        return uint(bids[firstbid].price);\n', '    }\n', '\n', '/* trade functions */\n', '\n', '    /**\n', '     * @dev Cancel an ask order\n', '     * @param _id The id of the order\n', '     */\n', '    function cancelSell(uint _id) external {\n', '        require(asks[_id].price>0 && asks[_id].who==msg.sender);\n', '        users[msg.sender].tokens=uint120(uint(users[msg.sender].tokens).add(asks[_id].amount));\n', '        users[msg.sender].asks=uint120(uint(users[msg.sender].asks).sub(asks[_id].amount));\n', '        if(asks[_id].prev>0){\n', '          asks[asks[_id].prev].next=asks[_id].next;}\n', '        else{\n', '          firstask=asks[_id].next;}\n', '        if(asks[_id].next>0){\n', '          asks[asks[_id].next].prev=asks[_id].prev;}\n', '        emit LogCancelSell(msg.sender,asks[_id].amount,asks[_id].price);\n', '        delete(asks[_id]);\n', '    }\n', '\n', '    /**\n', '     * @dev Cancel a bid order\n', '     * @param _id The id of the order\n', '     */\n', '    function cancelBuy(uint _id) external {\n', '        require(bids[_id].price>0 && bids[_id].who==msg.sender);\n', '        uint value=bids[_id].amount*bids[_id].price;\n', '        users[msg.sender].weis+=uint120(value);\n', '        if(bids[_id].prev>0){\n', '          bids[bids[_id].prev].next=bids[_id].next;}\n', '        else{\n', '          firstbid=bids[_id].next;}\n', '        if(bids[_id].next>0){\n', '          bids[bids[_id].next].prev=bids[_id].prev;}\n', '        emit LogCancelBuy(msg.sender,bids[_id].amount,bids[_id].price);\n', '        delete(bids[_id]);\n', '    }\n', '\n', '    /**\n', '     * @dev Place and ask order (sell tokens)\n', '     * @param _amount The amount of tokens to sell\n', '     * @param _price The minimum price per token in wei\n', '     */\n', '    function sell(uint _amount, uint _price) external {\n', '        require(0 < _price && _price < maxPrice && 0 < _amount && _amount < maxTokens && _amount <= users[msg.sender].tokens);\n', '        commitDividend(msg.sender);\n', '        users[msg.sender].tokens-=uint120(_amount); //we will sell that much\n', '        uint funds=0;\n', '        uint amount=_amount;\n', '        for(;bids[firstbid].price>0 && bids[firstbid].price>=_price;){\n', '          uint value=uint(bids[firstbid].price)*uint(bids[firstbid].amount);\n', '          uint fee=value >> 9; //0.4% fee\n', '          if(amount>=bids[firstbid].amount){\n', '            amount=amount.sub(uint(bids[firstbid].amount));\n', '            commitDividend(bids[firstbid].who);\n', '            emit LogTransaction(msg.sender,bids[firstbid].who,bids[firstbid].amount,bids[firstbid].price);\n', '            //seller\n', '            //users[msg.sender].tokens-=bids[firstbid].amount;\n', '            funds=funds.add(value-fee-fee);\n', '            users[custodian].weis+=uint120(fee);\n', '            totalWeis=totalWeis.sub(fee);\n', '            //buyer\n', '            users[bids[firstbid].who].tokens+=bids[firstbid].amount;\n', '            //clear\n', '            uint64 next=bids[firstbid].next;\n', '            delete bids[firstbid];\n', '            firstbid=next; // optimize and move outside ?\n', '            if(amount==0){\n', '              break;}\n', '            continue;}\n', '          value=amount*uint(bids[firstbid].price);\n', '          fee=value >> 9; //0.4% fee\n', '          commitDividend(bids[firstbid].who);\n', '          funds=funds.add(value-fee-fee);\n', '          emit LogTransaction(msg.sender,bids[firstbid].who,amount,bids[firstbid].price);\n', '          //seller\n', '          //users[msg.sender].tokens-=amount;\n', '          users[custodian].weis+=uint120(fee);\n', '          totalWeis=totalWeis.sub(fee);\n', '          bids[firstbid].amount=uint96(uint(bids[firstbid].amount).sub(amount));\n', '          require(bids[firstbid].amount>0);\n', '          //buyer\n', '          users[bids[firstbid].who].tokens+=uint120(amount);\n', '          bids[firstbid].prev=0;\n', '          totalWeis=totalWeis.sub(funds);\n', '          (bool success, /*bytes memory _unused*/) = msg.sender.call.value(funds)("");\n', '          require(success);\n', '          return;}\n', '        if(firstbid>0){\n', '          bids[firstbid].prev=0;}\n', '        if(amount>0){\n', '          uint64 ask=firstask;\n', '          uint64 last=0;\n', '          for(;asks[ask].price>0 && asks[ask].price<=_price;ask=asks[ask].next){\n', '            last=ask;}\n', '          lastask++;\n', '          asks[lastask].prev=last;\n', '          asks[lastask].next=ask;\n', '          asks[lastask].price=uint128(_price);\n', '          asks[lastask].amount=uint96(amount);\n', '          asks[lastask].who=msg.sender;\n', '          users[msg.sender].asks+=uint120(amount);\n', '          emit LogSell(msg.sender,amount,_price);\n', '          if(last>0){\n', '            asks[last].next=lastask;}\n', '          else{\n', '            firstask=lastask;}\n', '          if(ask>0){\n', '            asks[ask].prev=lastask;}}\n', '        if(funds>0){\n', '          totalWeis=totalWeis.sub(funds);\n', '          (bool success, /*bytes memory _unused*/) = msg.sender.call.value(funds)("");\n', '          require(success);}\n', '    }\n', '\n', '    /**\n', '     * @dev Place and bid order (buy tokens using Ether of the transaction)\n', '     * @param _amount The maximum amount of tokens to buy\n', '     * @param _price The maximum price per token in wei\n', '     */\n', '    function buy(uint _amount, uint _price) payable external {\n', '        require(0 < _price && _price < maxPrice && 0 < _amount && _amount < maxTokens && _price <= msg.value);\n', '        commitDividend(msg.sender);\n', '        uint funds=msg.value;\n', '        uint amount=_amount;\n', '        uint value;\n', '        for(;asks[firstask].price>0 && asks[firstask].price<=_price;){\n', '          value=uint(asks[firstask].price)*uint(asks[firstask].amount);\n', '          uint fee=value >> 9; //2*0.4% fee\n', '          if(funds>=value+fee+fee && amount>=asks[firstask].amount){\n', '            amount=amount.sub(uint(asks[firstask].amount));\n', '            commitDividend(asks[firstask].who);\n', '            funds=funds.sub(value+fee+fee);\n', '            emit LogTransaction(asks[firstask].who,msg.sender,asks[firstask].amount,asks[firstask].price);\n', '            //seller\n', '            users[asks[firstask].who].asks-=asks[firstask].amount;\n', '            users[asks[firstask].who].weis+=uint120(value);\n', '            users[custodian].weis+=uint120(fee);\n', '            totalWeis=totalWeis.add(value+fee);\n', '            //buyer\n', '            users[msg.sender].tokens+=asks[firstask].amount;\n', '            //clear\n', '            uint64 next=asks[firstask].next;\n', '            delete asks[firstask];\n', '            firstask=next; // optimize and move outside ?\n', '            if(funds<asks[firstask].price){\n', '              break;}\n', '            continue;}\n', '          if(amount>asks[firstask].amount){\n', '            amount=asks[firstask].amount;}\n', '          if((funds-(funds>>8))<amount*asks[firstask].price){\n', '            amount=(funds-(funds>>8))/asks[firstask].price;}\n', '          if(amount>0){\n', '            value=amount*uint(asks[firstask].price);\n', '            fee=value >> 9; //2*0.4% fee\n', '            commitDividend(asks[firstask].who);\n', '            funds=funds.sub(value+fee+fee);\n', '            emit LogTransaction(asks[firstask].who,msg.sender,amount,asks[firstask].price);\n', '            //seller\n', '            users[asks[firstask].who].asks-=uint120(amount);\n', '            users[asks[firstask].who].weis+=uint120(value);\n', '            users[custodian].weis+=uint120(fee);\n', '            totalWeis=totalWeis.add(value+fee);\n', '            asks[firstask].amount=uint96(uint(asks[firstask].amount).sub(amount));\n', '            require(asks[firstask].amount>0);\n', '            //buyer\n', '            users[msg.sender].tokens+=uint120(amount);}\n', '          asks[firstask].prev=0;\n', '          if(funds>0){\n', '            (bool success, /*bytes memory _unused*/) = msg.sender.call.value(funds)("");\n', '            require(success);}\n', '          return;}\n', '        if(firstask>0){ //all orders removed\n', '          asks[firstask].prev=0;}\n', '        if(amount>funds/_price){\n', '          amount=funds/_price;}\n', '        if(amount>0){\n', '          uint64 bid=firstbid;\n', '          uint64 last=0;\n', '          for(;bids[bid].price>0 && bids[bid].price>=_price;bid=bids[bid].next){\n', '            last=bid;}\n', '          lastbid++;\n', '          bids[lastbid].prev=last;\n', '          bids[lastbid].next=bid;\n', '          bids[lastbid].price=uint128(_price);\n', '          bids[lastbid].amount=uint96(amount);\n', '          bids[lastbid].who=msg.sender;\n', '          value=amount*_price;\n', '          totalWeis=totalWeis.add(value);\n', '          funds=funds.sub(value);\n', '          emit LogBuy(msg.sender,amount,_price);\n', '          if(last>0){\n', '            bids[last].next=lastbid;}\n', '          else{\n', '            firstbid=lastbid;}\n', '          if(bid>0){\n', '            bids[bid].prev=lastbid;}}\n', '        if(funds>0){\n', '          (bool success, /*bytes memory _unused*/) = msg.sender.call.value(funds)("");\n', '          require(success);}\n', '    }\n', '\n', '}']