['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) public {\n', '    require(_value <= balances[msg.sender]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', '    // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '    address burner = msg.sender;\n', '    balances[burner] = balances[burner].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    Burn(burner, _value);\n', '    Transfer(burner, address(0), _value);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract Cloudbric is StandardToken, BurnableToken, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant symbol = "CLB";\n', '    string public constant name = "Cloudbric";\n', '    uint8 public constant decimals = 18;\n', '    uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));\n', '    uint256 public constant TOKEN_SALE_ALLOWANCE = 540000000 * (10 ** uint256(decimals));\n', '    uint256 public constant ADMIN_ALLOWANCE = INITIAL_SUPPLY - TOKEN_SALE_ALLOWANCE;\n', '\n', '    // Address of token administrator\n', '    address public adminAddr;\n', '\n', '    // Address of token sale contract\n', '    address public tokenSaleAddr;\n', '\n', '    // Enable transfer after token sale is completed\n', '    bool public transferEnabled = false;\n', '\n', '    // Accounts to be locked for certain period\n', '    mapping(address => uint256) private lockedAccounts;\n', '\n', '    /*\n', '     *\n', '     * Permissions when transferEnabled is false :\n', '     *              ContractOwner    Admin    SaleContract    Others\n', '     * transfer            x           v            v           x\n', '     * transferFrom        x           v            v           x\n', '     *\n', '     * Permissions when transferEnabled is true :\n', '     *              ContractOwner    Admin    SaleContract    Others\n', '     * transfer            v           v            v           v\n', '     * transferFrom        v           v            v           v\n', '     *\n', '     */\n', '\n', '    /*\n', '     * Check if token transfer is allowed\n', '     * Permission table above is result of this modifier\n', '     */\n', '    modifier onlyWhenTransferAllowed() {\n', '        require(transferEnabled == true\n', '            || msg.sender == adminAddr\n', '            || msg.sender == tokenSaleAddr);\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * Check if token sale address is not set\n', '     */\n', '    modifier onlyWhenTokenSaleAddrNotSet() {\n', '        require(tokenSaleAddr == address(0x0));\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * Check if token transfer destination is valid\n', '     */\n', '    modifier onlyValidDestination(address to) {\n', '        require(to != address(0x0)\n', '            && to != address(this)\n', '            && to != owner\n', '            && to != adminAddr\n', '            && to != tokenSaleAddr);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAllowedAmount(address from, uint256 amount) {\n', '        require(balances[from].sub(amount) >= lockedAccounts[from]);\n', '        _;\n', '    }\n', '    /*\n', '     * The constructor of Cloudbric contract\n', '     *\n', '     * @param _adminAddr: Address of token administrator\n', '     */\n', '    function Cloudbric(address _adminAddr) public {\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '\n', '        balances[msg.sender] = totalSupply_;\n', '        Transfer(address(0x0), msg.sender, totalSupply_);\n', '\n', '        adminAddr = _adminAddr;\n', '        approve(adminAddr, ADMIN_ALLOWANCE);\n', '    }\n', '\n', '    /*\n', '     * Set amount of token sale to approve allowance for sale contract\n', '     *\n', '     * @param _tokenSaleAddr: Address of sale contract\n', '     * @param _amountForSale: Amount of token for sale\n', '     */\n', '    function setTokenSaleAmount(address _tokenSaleAddr, uint256 amountForSale)\n', '        external\n', '        onlyOwner\n', '        onlyWhenTokenSaleAddrNotSet\n', '    {\n', '        require(!transferEnabled);\n', '\n', '        uint256 amount = (amountForSale == 0) ? TOKEN_SALE_ALLOWANCE : amountForSale;\n', '        require(amount <= TOKEN_SALE_ALLOWANCE);\n', '\n', '        approve(_tokenSaleAddr, amount);\n', '        tokenSaleAddr = _tokenSaleAddr;\n', '    }\n', '\n', '    /*\n', '     * Set transferEnabled variable to true\n', '     */\n', '    function enableTransfer() external onlyOwner {\n', '        transferEnabled = true;\n', '        approve(tokenSaleAddr, 0);\n', '    }\n', '\n', '    /*\n', '     * Set transferEnabled variable to false\n', '     */\n', '    function disableTransfer() external onlyOwner {\n', '        transferEnabled = false;\n', '    }\n', '\n', '    /*\n', '     * Transfer token from message sender to another\n', '     *\n', '     * @param to: Destination address\n', '     * @param value: Amount of AMO token to transfer\n', '     */\n', '    function transfer(address to, uint256 value)\n', '        public\n', '        onlyWhenTransferAllowed\n', '        onlyValidDestination(to)\n', '        onlyAllowedAmount(msg.sender, value)\n', '        returns (bool)\n', '    {\n', '        return super.transfer(to, value);\n', '    }\n', '\n', '    /*\n', '     * Transfer token from &#39;from&#39; address to &#39;to&#39; addreess\n', '     *\n', '     * @param from: Origin address\n', '     * @param to: Destination address\n', '     * @param value: Amount of tokens to transfer\n', '     */\n', '    function transferFrom(address from, address to, uint256 value)\n', '        public\n', '        onlyWhenTransferAllowed\n', '        onlyValidDestination(to)\n', '        onlyAllowedAmount(from, value)\n', '        returns (bool)\n', '    {\n', '        return super.transferFrom(from, to, value);\n', '    }\n', '\n', '    /*\n', '     * Burn token, only owner is allowed\n', '     *\n', '     * @param value: Amount of tokens to burn\n', '     */\n', '    function burn(uint256 value) public onlyOwner {\n', '        require(transferEnabled);\n', '        super.burn(value);\n', '    }\n', '\n', '    /*\n', '     * Disable transfering tokens more than allowed amount from certain account\n', '     *\n', '     * @param addr: Account to set allowed amount\n', '     * @param amount: Amount of tokens to allow\n', '     */\n', '    function lockAccount(address addr, uint256 amount)\n', '        external\n', '        onlyOwner\n', '        onlyValidDestination(addr)\n', '    {\n', '        require(amount > 0);\n', '        lockedAccounts[addr] = amount;\n', '    }\n', '\n', '    /*\n', '     * Enable transfering tokens of locked account\n', '     *\n', '     * @param addr: Account to unlock\n', '     */\n', '\n', '    function unlockAccount(address addr)\n', '        external\n', '        onlyOwner\n', '        onlyValidDestination(addr)\n', '    {\n', '        lockedAccounts[addr] = 0;\n', '    }\n', '}\n', '\n', 'contract CloudbricSale is Pausable {\n', '    using SafeMath for uint256;\n', '\n', '    // Start time of sale\n', '    uint256 public startTime;\n', '    // End time of sale\n', '    uint256 public endTime;\n', '    // Address to collect fund\n', '    address private fundAddr;\n', '    // Token contract instance\n', '    Cloudbric public token;\n', '    // Amount of raised in Wei (1 ether)\n', '    uint256 public totalWeiRaised;\n', '    // Base hard cap for each round in ether\n', '    uint256 public constant BASE_HARD_CAP_PER_ROUND = 20000 * 1 ether;\n', '\n', '    uint256 public constant UINT256_MAX = ~uint256(0);\n', '    // Base CLB to Ether rate\n', '    uint256 public constant BASE_CLB_TO_ETH_RATE = 10000;\n', '    // Base minimum contribution\n', '    uint256 public constant BASE_MIN_CONTRIBUTION = 0.1 * 1 ether;\n', '    // Whitelisted addresses\n', '    mapping(address => bool) public whitelist;\n', '    // Whitelisted users&#39; contributions per round\n', '    mapping(address => mapping(uint8 => uint256)) public contPerRound;\n', '\n', '    // For each round, there are three stages.\n', '    enum Stages {\n', '        SetUp,\n', '        Started,\n', '        Ended\n', '    }\n', '    // The current stage of the sale\n', '    Stages public stage;\n', '\n', '    // There are three rounds in sale\n', '    enum SaleRounds {\n', '        EarlyInvestment,\n', '        PreSale1,\n', '        PreSale2,\n', '        CrowdSale\n', '    }\n', '    // The current round of the sale\n', '    SaleRounds public round;\n', '\n', '    // Each round has different inforamation\n', '    struct RoundInfo {\n', '        uint256 minContribution;\n', '        uint256 maxContribution;\n', '        uint256 hardCap;\n', '        uint256 rate;\n', '        uint256 weiRaised;\n', '    }\n', '\n', '    // SaleRounds(key) : RoundInfo(value) map\n', '    // Since solidity does not support enum as key of map, converted enum to uint8\n', '    mapping(uint8 => RoundInfo) public roundInfos;\n', '\n', '    struct AllocationInfo {\n', '        bool isAllowed;\n', '        uint256 allowedAmount;\n', '    }\n', '\n', '    // List of users who will be allocated tokens and their allowed amount\n', '    mapping(address => AllocationInfo) private allocationList;\n', '\n', '    /*\n', '     * Event for sale start logging\n', '     *\n', '     * @param startTime: Start date of sale\n', '     * @param endTime: End date of sale\n', '     * @param round: Round of sale started\n', '     */\n', '    event SaleStarted(uint256 startTime, uint256 endTime, SaleRounds round);\n', '\n', '    /*\n', '     * Event for sale end logging\n', '     *\n', '     * @param endTime: End date of sale\n', '     * @param totalWeiRaised: Total amount of raised in Wei after sale ended\n', '     * @param round: Round of sale ended\n', '     */\n', '    event SaleEnded(uint256 endTime, uint256 totalWeiRaised, SaleRounds round);\n', '\n', '    /*\n', '     * Event for token purchase\n', '     *\n', '     * @param purchaser: Who paid for the tokens\n', '     * @param value: Amount in Wei paid for purchase\n', '     * @param amount: Amount of tokens purchased\n', '     */\n', '    event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n', '\n', '    /*\n', '     * Modifier to check current stage is same as expected stage\n', '     *\n', '     * @param expectedStage: Expected current stage\n', '     */\n', '    modifier atStage(Stages expectedStage) {\n', '        require(stage == expectedStage);\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * Modifier to check current round is sane as expected round\n', '     *\n', '     * @param expectedRound: Expected current round\n', '     */\n', '    modifier atRound(SaleRounds expectedRound) {\n', '        require(round == expectedRound);\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * Modifier to check purchase is valid\n', '     *\n', '     * 1. Current round must be smaller than CrowdSale\n', '     * 2. Current time must be within sale period\n', '     * 3. Purchaser must be enrolled to whitelist\n', '     * 4. Purchaser address must be correct\n', '     * 5. Contribution must be bigger than minimum contribution for current round\n', '     * 6. Sum of contributions must be smaller than max contribution for current round\n', '     * 7. Total funds raised in current round must be smaller than hard cap for current round\n', '     */\n', '    modifier onlyValidPurchase() {\n', '        require(round <= SaleRounds.CrowdSale);\n', '        require(now >= startTime && now <= endTime);\n', '\n', '        uint256 contributionInWei = msg.value;\n', '        address purchaser = msg.sender;\n', '\n', '        require(whitelist[purchaser]);\n', '        require(purchaser != address(0));\n', '        require(contributionInWei >= roundInfos[uint8(round)].minContribution);\n', '        require(\n', '            contPerRound[purchaser][uint8(round)].add(contributionInWei)\n', '            <= roundInfos[uint8(round)].maxContribution\n', '        );\n', '        require(\n', '            roundInfos[uint8(round)].weiRaised.add(contributionInWei)\n', '            <= roundInfos[uint8(round)].hardCap\n', '        );\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * Constructor for CloudbricSale contract\n', '     *\n', '     * @param fundAddress: Address where funds are collected\n', '     * @param tokenAddress: Address of Cloudbric Token Contract\n', '     */\n', '    function CloudbricSale(\n', '        address fundAddress,\n', '        address tokenAddress\n', '    )\n', '        public\n', '    {\n', '        require(fundAddress != address(0));\n', '        require(tokenAddress != address(0));\n', '\n', '        token = Cloudbric(tokenAddress);\n', '        fundAddr = fundAddress;\n', '        stage = Stages.Ended;\n', '        round = SaleRounds.EarlyInvestment;\n', '        uint8 roundIndex = uint8(round);\n', '\n', '        roundInfos[roundIndex].minContribution = BASE_MIN_CONTRIBUTION;\n', '        roundInfos[roundIndex].maxContribution = UINT256_MAX;\n', '        roundInfos[roundIndex].hardCap = BASE_HARD_CAP_PER_ROUND;\n', '        roundInfos[roundIndex].weiRaised = 0;\n', '        roundInfos[roundIndex].rate = BASE_CLB_TO_ETH_RATE;\n', '    }\n', '\n', '    /*\n', '     * Fallback function to buy Cloudbric tokens\n', '     */\n', '    function () public payable {\n', '        buy();\n', '    }\n', '\n', '    /*\n', '     * Withdraw ethers to fund address\n', '     */\n', '    function withdraw() external onlyOwner {\n', '        fundAddr.transfer(this.balance);\n', '    }\n', '\n', '    /*\n', '     * Add users to whitelist\n', '     * Whitelisted users are accumulated on each round\n', '     *\n', '     * @param users: Addresses of users who passed KYC\n', '     */\n', '    function addManyToWhitelist(address[] users) external onlyOwner {\n', '        for (uint32 i = 0; i < users.length; i++) {\n', '            addToWhitelist(users[i]);\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Add one user to whitelist\n', '     *\n', '     * @param user: Address of user who passed KYC\n', '     */\n', '    function addToWhitelist(address user) public onlyOwner {\n', '        whitelist[user] = true;\n', '    }\n', '\n', '    /*\n', '     * Remove users from whitelist\n', '     *\n', '     * @param users: Addresses of users who should not belong to whitelist\n', '     */\n', '    function removeManyFromWhitelist(address[] users) external onlyOwner {\n', '        for (uint32 i = 0; i < users.length; i++) {\n', '            removeFromWhitelist(users[i]);\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Remove users from whitelist\n', '     *\n', '     * @param users: Addresses of users who should not belong to whitelist\n', '     */\n', '    function removeFromWhitelist(address user) public onlyOwner {\n', '        whitelist[user] = false;\n', '    }\n', '\n', '    /*\n', '     * Set minimum contribution for round\n', '     * User have to send more ether than minimum contribution\n', '     *\n', '     * @param _round: Round to set\n', '     * @param _minContribution: Minimum contribution in wei\n', '     */\n', '    function setMinContributionForRound(\n', '        SaleRounds _round,\n', '        uint256 _minContribution\n', '    )\n', '        public\n', '        onlyOwner\n', '        atStage(Stages.SetUp)\n', '    {\n', '        require(round <= _round);\n', '        roundInfos[uint8(_round)].minContribution =\n', '            (_minContribution == 0) ? BASE_MIN_CONTRIBUTION : _minContribution;\n', '    }\n', '\n', '    /*\n', '     * Set max contribution for round\n', '     * User can&#39;t send more ether than the max contributions in round\n', '     *\n', '     * @param _round: Round to set\n', '     * @param _maxContribution: Max contribution in wei\n', '     */\n', '    function setMaxContributionForRound(\n', '        SaleRounds _round,\n', '        uint256 _maxContribution\n', '    )\n', '        public\n', '        onlyOwner\n', '        atStage(Stages.SetUp)\n', '    {\n', '        require(round <= _round);\n', '        roundInfos[uint8(_round)].maxContribution =\n', '            (_maxContribution == 0) ? UINT256_MAX : _maxContribution;\n', '    }\n', '\n', '    /*\n', '     * Set hard cap for round\n', '     * Total wei raised in round should be smaller than hard cap\n', '     *\n', '     * @param _round: Round to set\n', '     * @param _hardCap: Hard cap in wei\n', '     */\n', '    function setHardCapForRound(\n', '        SaleRounds _round,\n', '        uint256 _hardCap\n', '    )\n', '        public\n', '        onlyOwner\n', '        atStage(Stages.SetUp)\n', '    {\n', '        require(round <= _round);\n', '        roundInfos[uint8(_round)].hardCap =\n', '            (_hardCap == 0) ? BASE_HARD_CAP_PER_ROUND : _hardCap;\n', '    }\n', '\n', '    /*\n', '     * Set CLB to Ether rate for round\n', '     *\n', '     * @param _round: Round to set\n', '     * @param _rate: CLB to Ether rate\n', '     */\n', '    function setRateForRound(\n', '        SaleRounds _round,\n', '        uint256 _rate\n', '    )\n', '        public\n', '        onlyOwner\n', '        atStage(Stages.SetUp)\n', '    {\n', '        require(round <= _round);\n', '        roundInfos[uint8(_round)].rate =\n', '            (_rate == 0) ? BASE_CLB_TO_ETH_RATE : _rate;\n', '    }\n', '\n', '    /*\n', '     * Set up several information for next round\n', '     * Only owner can call this method\n', '     */\n', '    function setUpSale(\n', '        SaleRounds _round,\n', '        uint256 _minContribution,\n', '        uint256 _maxContribution,\n', '        uint256 _hardCap,\n', '        uint256 _rate\n', '    )\n', '        external\n', '        onlyOwner\n', '        atStage(Stages.Ended)\n', '    {\n', '        require(round <= _round);\n', '        stage = Stages.SetUp;\n', '        round = _round;\n', '        setMinContributionForRound(_round, _minContribution);\n', '        setMaxContributionForRound(_round, _maxContribution);\n', '        setHardCapForRound(_round, _hardCap);\n', '        setRateForRound(_round, _rate);\n', '    }\n', '\n', '    /*\n', '     * Start sale in current round\n', '     */\n', '    function startSale(uint256 durationInSeconds)\n', '        external\n', '        onlyOwner\n', '        atStage(Stages.SetUp)\n', '    {\n', '        require(roundInfos[uint8(round)].minContribution > 0\n', '            && roundInfos[uint8(round)].hardCap > 0);\n', '        stage = Stages.Started;\n', '        startTime = now;\n', '        endTime = startTime.add(durationInSeconds);\n', '        SaleStarted(startTime, endTime, round);\n', '    }\n', '\n', '    /*\n', '     * End sale in crrent round\n', '     */\n', '    function endSale() external onlyOwner atStage(Stages.Started) {\n', '        endTime = now;\n', '        stage = Stages.Ended;\n', '\n', '        SaleEnded(endTime, totalWeiRaised, round);\n', '    }\n', '\n', '    function buy()\n', '        public\n', '        payable\n', '        whenNotPaused\n', '        atStage(Stages.Started)\n', '        onlyValidPurchase()\n', '        returns (bool)\n', '    {\n', '        address purchaser = msg.sender;\n', '        uint256 contributionInWei = msg.value;\n', '        uint256 tokenAmount = contributionInWei.mul(roundInfos[uint8(round)].rate);\n', '\n', '        if (!token.transferFrom(token.owner(), purchaser, tokenAmount)) {\n', '            revert();\n', '        }\n', '\n', '        totalWeiRaised = totalWeiRaised.add(contributionInWei);\n', '        roundInfos[uint8(round)].weiRaised =\n', '            roundInfos[uint8(round)].weiRaised.add(contributionInWei);\n', '\n', '        contPerRound[purchaser][uint8(round)] =\n', '            contPerRound[purchaser][uint8(round)].add(contributionInWei);\n', '\n', '        // Transfer contributions to fund address\n', '        fundAddr.transfer(contributionInWei);\n', '        TokenPurchase(msg.sender, contributionInWei, tokenAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Add user and his allowed amount to allocation list\n', '     *\n', '     * @param user: Address of user to be allocated tokens\n', '     * @param amount: Allowed allocation amount of user\n', '     */\n', '    function addToAllocationList(address user, uint256 amount)\n', '        public\n', '        onlyOwner\n', '        atRound(SaleRounds.EarlyInvestment)\n', '    {\n', '        allocationList[user].isAllowed = true;\n', '        allocationList[user].allowedAmount = amount;\n', '    }\n', '\n', '    /*\n', '     * Add users and their allowed amount to allocation list\n', '     *\n', '     * @param users: List of Address to be allocated tokens\n', '     * @param amount: List of allowed allocation amount of each user\n', '     */\n', '    function addManyToAllocationList(address[] users, uint256[] amounts)\n', '        external\n', '        onlyOwner\n', '        atRound(SaleRounds.EarlyInvestment)\n', '    {\n', '        require(users.length == amounts.length);\n', '\n', '        for (uint32 i = 0; i < users.length; i++) {\n', '            addToAllocationList(users[i], amounts[i]);\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Remove user from allocation list\n', '     *\n', '     * @param user: Address of user to be removed\n', '     */\n', '    function removeFromAllocationList(address user)\n', '        public\n', '        onlyOwner\n', '        atRound(SaleRounds.EarlyInvestment)\n', '    {\n', '        allocationList[user].isAllowed = false;\n', '    }\n', '\n', '    /*\n', '     * Remove users from allocation list\n', '     *\n', '     * @param user: Address list of users to be removed\n', '     */\n', '    function removeManyFromAllocationList(address[] users)\n', '        external\n', '        onlyOwner\n', '        atRound(SaleRounds.EarlyInvestment)\n', '    {\n', '        for (uint32 i = 0; i < users.length; i++) {\n', '            removeFromAllocationList(users[i]);\n', '        }\n', '    }\n', '\n', '\n', '    /*\n', '     * Allocate  tokens to user\n', '     * Only avaliable on early investment\n', '     *\n', '     * @param to: Address of user to be allocated tokens\n', '     * @param tokenAmount: Amount of tokens to be allocated\n', '     */\n', '    function allocateTokens(address to, uint256 tokenAmount)\n', '        public\n', '        onlyOwner\n', '        atRound(SaleRounds.EarlyInvestment)\n', '        returns (bool)\n', '    {\n', '        require(allocationList[to].isAllowed\n', '            && tokenAmount <= allocationList[to].allowedAmount);\n', '\n', '        if (!token.transferFrom(token.owner(), to, tokenAmount)) {\n', '            revert();\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Allocate  tokens to user\n', '     * Only avaliable on early investment\n', '     *\n', '     * @param toList: List of addresses to be allocated tokens\n', '     * @param tokenAmountList: List of token amount to be allocated to each address\n', '     */\n', '    function allocateTokensToMany(address[] toList, uint256[] tokenAmountList)\n', '        external\n', '        onlyOwner\n', '        atRound(SaleRounds.EarlyInvestment)\n', '        returns (bool)\n', '    {\n', '        require(toList.length == tokenAmountList.length);\n', '\n', '        for (uint32 i = 0; i < toList.length; i++) {\n', '            allocateTokens(toList[i], tokenAmountList[i]);\n', '        }\n', '        return true;\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) public {\n', '    require(_value <= balances[msg.sender]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', "    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '\n', '    address burner = msg.sender;\n', '    balances[burner] = balances[burner].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    Burn(burner, _value);\n', '    Transfer(burner, address(0), _value);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract Cloudbric is StandardToken, BurnableToken, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant symbol = "CLB";\n', '    string public constant name = "Cloudbric";\n', '    uint8 public constant decimals = 18;\n', '    uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));\n', '    uint256 public constant TOKEN_SALE_ALLOWANCE = 540000000 * (10 ** uint256(decimals));\n', '    uint256 public constant ADMIN_ALLOWANCE = INITIAL_SUPPLY - TOKEN_SALE_ALLOWANCE;\n', '\n', '    // Address of token administrator\n', '    address public adminAddr;\n', '\n', '    // Address of token sale contract\n', '    address public tokenSaleAddr;\n', '\n', '    // Enable transfer after token sale is completed\n', '    bool public transferEnabled = false;\n', '\n', '    // Accounts to be locked for certain period\n', '    mapping(address => uint256) private lockedAccounts;\n', '\n', '    /*\n', '     *\n', '     * Permissions when transferEnabled is false :\n', '     *              ContractOwner    Admin    SaleContract    Others\n', '     * transfer            x           v            v           x\n', '     * transferFrom        x           v            v           x\n', '     *\n', '     * Permissions when transferEnabled is true :\n', '     *              ContractOwner    Admin    SaleContract    Others\n', '     * transfer            v           v            v           v\n', '     * transferFrom        v           v            v           v\n', '     *\n', '     */\n', '\n', '    /*\n', '     * Check if token transfer is allowed\n', '     * Permission table above is result of this modifier\n', '     */\n', '    modifier onlyWhenTransferAllowed() {\n', '        require(transferEnabled == true\n', '            || msg.sender == adminAddr\n', '            || msg.sender == tokenSaleAddr);\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * Check if token sale address is not set\n', '     */\n', '    modifier onlyWhenTokenSaleAddrNotSet() {\n', '        require(tokenSaleAddr == address(0x0));\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * Check if token transfer destination is valid\n', '     */\n', '    modifier onlyValidDestination(address to) {\n', '        require(to != address(0x0)\n', '            && to != address(this)\n', '            && to != owner\n', '            && to != adminAddr\n', '            && to != tokenSaleAddr);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAllowedAmount(address from, uint256 amount) {\n', '        require(balances[from].sub(amount) >= lockedAccounts[from]);\n', '        _;\n', '    }\n', '    /*\n', '     * The constructor of Cloudbric contract\n', '     *\n', '     * @param _adminAddr: Address of token administrator\n', '     */\n', '    function Cloudbric(address _adminAddr) public {\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '\n', '        balances[msg.sender] = totalSupply_;\n', '        Transfer(address(0x0), msg.sender, totalSupply_);\n', '\n', '        adminAddr = _adminAddr;\n', '        approve(adminAddr, ADMIN_ALLOWANCE);\n', '    }\n', '\n', '    /*\n', '     * Set amount of token sale to approve allowance for sale contract\n', '     *\n', '     * @param _tokenSaleAddr: Address of sale contract\n', '     * @param _amountForSale: Amount of token for sale\n', '     */\n', '    function setTokenSaleAmount(address _tokenSaleAddr, uint256 amountForSale)\n', '        external\n', '        onlyOwner\n', '        onlyWhenTokenSaleAddrNotSet\n', '    {\n', '        require(!transferEnabled);\n', '\n', '        uint256 amount = (amountForSale == 0) ? TOKEN_SALE_ALLOWANCE : amountForSale;\n', '        require(amount <= TOKEN_SALE_ALLOWANCE);\n', '\n', '        approve(_tokenSaleAddr, amount);\n', '        tokenSaleAddr = _tokenSaleAddr;\n', '    }\n', '\n', '    /*\n', '     * Set transferEnabled variable to true\n', '     */\n', '    function enableTransfer() external onlyOwner {\n', '        transferEnabled = true;\n', '        approve(tokenSaleAddr, 0);\n', '    }\n', '\n', '    /*\n', '     * Set transferEnabled variable to false\n', '     */\n', '    function disableTransfer() external onlyOwner {\n', '        transferEnabled = false;\n', '    }\n', '\n', '    /*\n', '     * Transfer token from message sender to another\n', '     *\n', '     * @param to: Destination address\n', '     * @param value: Amount of AMO token to transfer\n', '     */\n', '    function transfer(address to, uint256 value)\n', '        public\n', '        onlyWhenTransferAllowed\n', '        onlyValidDestination(to)\n', '        onlyAllowedAmount(msg.sender, value)\n', '        returns (bool)\n', '    {\n', '        return super.transfer(to, value);\n', '    }\n', '\n', '    /*\n', "     * Transfer token from 'from' address to 'to' addreess\n", '     *\n', '     * @param from: Origin address\n', '     * @param to: Destination address\n', '     * @param value: Amount of tokens to transfer\n', '     */\n', '    function transferFrom(address from, address to, uint256 value)\n', '        public\n', '        onlyWhenTransferAllowed\n', '        onlyValidDestination(to)\n', '        onlyAllowedAmount(from, value)\n', '        returns (bool)\n', '    {\n', '        return super.transferFrom(from, to, value);\n', '    }\n', '\n', '    /*\n', '     * Burn token, only owner is allowed\n', '     *\n', '     * @param value: Amount of tokens to burn\n', '     */\n', '    function burn(uint256 value) public onlyOwner {\n', '        require(transferEnabled);\n', '        super.burn(value);\n', '    }\n', '\n', '    /*\n', '     * Disable transfering tokens more than allowed amount from certain account\n', '     *\n', '     * @param addr: Account to set allowed amount\n', '     * @param amount: Amount of tokens to allow\n', '     */\n', '    function lockAccount(address addr, uint256 amount)\n', '        external\n', '        onlyOwner\n', '        onlyValidDestination(addr)\n', '    {\n', '        require(amount > 0);\n', '        lockedAccounts[addr] = amount;\n', '    }\n', '\n', '    /*\n', '     * Enable transfering tokens of locked account\n', '     *\n', '     * @param addr: Account to unlock\n', '     */\n', '\n', '    function unlockAccount(address addr)\n', '        external\n', '        onlyOwner\n', '        onlyValidDestination(addr)\n', '    {\n', '        lockedAccounts[addr] = 0;\n', '    }\n', '}\n', '\n', 'contract CloudbricSale is Pausable {\n', '    using SafeMath for uint256;\n', '\n', '    // Start time of sale\n', '    uint256 public startTime;\n', '    // End time of sale\n', '    uint256 public endTime;\n', '    // Address to collect fund\n', '    address private fundAddr;\n', '    // Token contract instance\n', '    Cloudbric public token;\n', '    // Amount of raised in Wei (1 ether)\n', '    uint256 public totalWeiRaised;\n', '    // Base hard cap for each round in ether\n', '    uint256 public constant BASE_HARD_CAP_PER_ROUND = 20000 * 1 ether;\n', '\n', '    uint256 public constant UINT256_MAX = ~uint256(0);\n', '    // Base CLB to Ether rate\n', '    uint256 public constant BASE_CLB_TO_ETH_RATE = 10000;\n', '    // Base minimum contribution\n', '    uint256 public constant BASE_MIN_CONTRIBUTION = 0.1 * 1 ether;\n', '    // Whitelisted addresses\n', '    mapping(address => bool) public whitelist;\n', "    // Whitelisted users' contributions per round\n", '    mapping(address => mapping(uint8 => uint256)) public contPerRound;\n', '\n', '    // For each round, there are three stages.\n', '    enum Stages {\n', '        SetUp,\n', '        Started,\n', '        Ended\n', '    }\n', '    // The current stage of the sale\n', '    Stages public stage;\n', '\n', '    // There are three rounds in sale\n', '    enum SaleRounds {\n', '        EarlyInvestment,\n', '        PreSale1,\n', '        PreSale2,\n', '        CrowdSale\n', '    }\n', '    // The current round of the sale\n', '    SaleRounds public round;\n', '\n', '    // Each round has different inforamation\n', '    struct RoundInfo {\n', '        uint256 minContribution;\n', '        uint256 maxContribution;\n', '        uint256 hardCap;\n', '        uint256 rate;\n', '        uint256 weiRaised;\n', '    }\n', '\n', '    // SaleRounds(key) : RoundInfo(value) map\n', '    // Since solidity does not support enum as key of map, converted enum to uint8\n', '    mapping(uint8 => RoundInfo) public roundInfos;\n', '\n', '    struct AllocationInfo {\n', '        bool isAllowed;\n', '        uint256 allowedAmount;\n', '    }\n', '\n', '    // List of users who will be allocated tokens and their allowed amount\n', '    mapping(address => AllocationInfo) private allocationList;\n', '\n', '    /*\n', '     * Event for sale start logging\n', '     *\n', '     * @param startTime: Start date of sale\n', '     * @param endTime: End date of sale\n', '     * @param round: Round of sale started\n', '     */\n', '    event SaleStarted(uint256 startTime, uint256 endTime, SaleRounds round);\n', '\n', '    /*\n', '     * Event for sale end logging\n', '     *\n', '     * @param endTime: End date of sale\n', '     * @param totalWeiRaised: Total amount of raised in Wei after sale ended\n', '     * @param round: Round of sale ended\n', '     */\n', '    event SaleEnded(uint256 endTime, uint256 totalWeiRaised, SaleRounds round);\n', '\n', '    /*\n', '     * Event for token purchase\n', '     *\n', '     * @param purchaser: Who paid for the tokens\n', '     * @param value: Amount in Wei paid for purchase\n', '     * @param amount: Amount of tokens purchased\n', '     */\n', '    event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n', '\n', '    /*\n', '     * Modifier to check current stage is same as expected stage\n', '     *\n', '     * @param expectedStage: Expected current stage\n', '     */\n', '    modifier atStage(Stages expectedStage) {\n', '        require(stage == expectedStage);\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * Modifier to check current round is sane as expected round\n', '     *\n', '     * @param expectedRound: Expected current round\n', '     */\n', '    modifier atRound(SaleRounds expectedRound) {\n', '        require(round == expectedRound);\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * Modifier to check purchase is valid\n', '     *\n', '     * 1. Current round must be smaller than CrowdSale\n', '     * 2. Current time must be within sale period\n', '     * 3. Purchaser must be enrolled to whitelist\n', '     * 4. Purchaser address must be correct\n', '     * 5. Contribution must be bigger than minimum contribution for current round\n', '     * 6. Sum of contributions must be smaller than max contribution for current round\n', '     * 7. Total funds raised in current round must be smaller than hard cap for current round\n', '     */\n', '    modifier onlyValidPurchase() {\n', '        require(round <= SaleRounds.CrowdSale);\n', '        require(now >= startTime && now <= endTime);\n', '\n', '        uint256 contributionInWei = msg.value;\n', '        address purchaser = msg.sender;\n', '\n', '        require(whitelist[purchaser]);\n', '        require(purchaser != address(0));\n', '        require(contributionInWei >= roundInfos[uint8(round)].minContribution);\n', '        require(\n', '            contPerRound[purchaser][uint8(round)].add(contributionInWei)\n', '            <= roundInfos[uint8(round)].maxContribution\n', '        );\n', '        require(\n', '            roundInfos[uint8(round)].weiRaised.add(contributionInWei)\n', '            <= roundInfos[uint8(round)].hardCap\n', '        );\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * Constructor for CloudbricSale contract\n', '     *\n', '     * @param fundAddress: Address where funds are collected\n', '     * @param tokenAddress: Address of Cloudbric Token Contract\n', '     */\n', '    function CloudbricSale(\n', '        address fundAddress,\n', '        address tokenAddress\n', '    )\n', '        public\n', '    {\n', '        require(fundAddress != address(0));\n', '        require(tokenAddress != address(0));\n', '\n', '        token = Cloudbric(tokenAddress);\n', '        fundAddr = fundAddress;\n', '        stage = Stages.Ended;\n', '        round = SaleRounds.EarlyInvestment;\n', '        uint8 roundIndex = uint8(round);\n', '\n', '        roundInfos[roundIndex].minContribution = BASE_MIN_CONTRIBUTION;\n', '        roundInfos[roundIndex].maxContribution = UINT256_MAX;\n', '        roundInfos[roundIndex].hardCap = BASE_HARD_CAP_PER_ROUND;\n', '        roundInfos[roundIndex].weiRaised = 0;\n', '        roundInfos[roundIndex].rate = BASE_CLB_TO_ETH_RATE;\n', '    }\n', '\n', '    /*\n', '     * Fallback function to buy Cloudbric tokens\n', '     */\n', '    function () public payable {\n', '        buy();\n', '    }\n', '\n', '    /*\n', '     * Withdraw ethers to fund address\n', '     */\n', '    function withdraw() external onlyOwner {\n', '        fundAddr.transfer(this.balance);\n', '    }\n', '\n', '    /*\n', '     * Add users to whitelist\n', '     * Whitelisted users are accumulated on each round\n', '     *\n', '     * @param users: Addresses of users who passed KYC\n', '     */\n', '    function addManyToWhitelist(address[] users) external onlyOwner {\n', '        for (uint32 i = 0; i < users.length; i++) {\n', '            addToWhitelist(users[i]);\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Add one user to whitelist\n', '     *\n', '     * @param user: Address of user who passed KYC\n', '     */\n', '    function addToWhitelist(address user) public onlyOwner {\n', '        whitelist[user] = true;\n', '    }\n', '\n', '    /*\n', '     * Remove users from whitelist\n', '     *\n', '     * @param users: Addresses of users who should not belong to whitelist\n', '     */\n', '    function removeManyFromWhitelist(address[] users) external onlyOwner {\n', '        for (uint32 i = 0; i < users.length; i++) {\n', '            removeFromWhitelist(users[i]);\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Remove users from whitelist\n', '     *\n', '     * @param users: Addresses of users who should not belong to whitelist\n', '     */\n', '    function removeFromWhitelist(address user) public onlyOwner {\n', '        whitelist[user] = false;\n', '    }\n', '\n', '    /*\n', '     * Set minimum contribution for round\n', '     * User have to send more ether than minimum contribution\n', '     *\n', '     * @param _round: Round to set\n', '     * @param _minContribution: Minimum contribution in wei\n', '     */\n', '    function setMinContributionForRound(\n', '        SaleRounds _round,\n', '        uint256 _minContribution\n', '    )\n', '        public\n', '        onlyOwner\n', '        atStage(Stages.SetUp)\n', '    {\n', '        require(round <= _round);\n', '        roundInfos[uint8(_round)].minContribution =\n', '            (_minContribution == 0) ? BASE_MIN_CONTRIBUTION : _minContribution;\n', '    }\n', '\n', '    /*\n', '     * Set max contribution for round\n', "     * User can't send more ether than the max contributions in round\n", '     *\n', '     * @param _round: Round to set\n', '     * @param _maxContribution: Max contribution in wei\n', '     */\n', '    function setMaxContributionForRound(\n', '        SaleRounds _round,\n', '        uint256 _maxContribution\n', '    )\n', '        public\n', '        onlyOwner\n', '        atStage(Stages.SetUp)\n', '    {\n', '        require(round <= _round);\n', '        roundInfos[uint8(_round)].maxContribution =\n', '            (_maxContribution == 0) ? UINT256_MAX : _maxContribution;\n', '    }\n', '\n', '    /*\n', '     * Set hard cap for round\n', '     * Total wei raised in round should be smaller than hard cap\n', '     *\n', '     * @param _round: Round to set\n', '     * @param _hardCap: Hard cap in wei\n', '     */\n', '    function setHardCapForRound(\n', '        SaleRounds _round,\n', '        uint256 _hardCap\n', '    )\n', '        public\n', '        onlyOwner\n', '        atStage(Stages.SetUp)\n', '    {\n', '        require(round <= _round);\n', '        roundInfos[uint8(_round)].hardCap =\n', '            (_hardCap == 0) ? BASE_HARD_CAP_PER_ROUND : _hardCap;\n', '    }\n', '\n', '    /*\n', '     * Set CLB to Ether rate for round\n', '     *\n', '     * @param _round: Round to set\n', '     * @param _rate: CLB to Ether rate\n', '     */\n', '    function setRateForRound(\n', '        SaleRounds _round,\n', '        uint256 _rate\n', '    )\n', '        public\n', '        onlyOwner\n', '        atStage(Stages.SetUp)\n', '    {\n', '        require(round <= _round);\n', '        roundInfos[uint8(_round)].rate =\n', '            (_rate == 0) ? BASE_CLB_TO_ETH_RATE : _rate;\n', '    }\n', '\n', '    /*\n', '     * Set up several information for next round\n', '     * Only owner can call this method\n', '     */\n', '    function setUpSale(\n', '        SaleRounds _round,\n', '        uint256 _minContribution,\n', '        uint256 _maxContribution,\n', '        uint256 _hardCap,\n', '        uint256 _rate\n', '    )\n', '        external\n', '        onlyOwner\n', '        atStage(Stages.Ended)\n', '    {\n', '        require(round <= _round);\n', '        stage = Stages.SetUp;\n', '        round = _round;\n', '        setMinContributionForRound(_round, _minContribution);\n', '        setMaxContributionForRound(_round, _maxContribution);\n', '        setHardCapForRound(_round, _hardCap);\n', '        setRateForRound(_round, _rate);\n', '    }\n', '\n', '    /*\n', '     * Start sale in current round\n', '     */\n', '    function startSale(uint256 durationInSeconds)\n', '        external\n', '        onlyOwner\n', '        atStage(Stages.SetUp)\n', '    {\n', '        require(roundInfos[uint8(round)].minContribution > 0\n', '            && roundInfos[uint8(round)].hardCap > 0);\n', '        stage = Stages.Started;\n', '        startTime = now;\n', '        endTime = startTime.add(durationInSeconds);\n', '        SaleStarted(startTime, endTime, round);\n', '    }\n', '\n', '    /*\n', '     * End sale in crrent round\n', '     */\n', '    function endSale() external onlyOwner atStage(Stages.Started) {\n', '        endTime = now;\n', '        stage = Stages.Ended;\n', '\n', '        SaleEnded(endTime, totalWeiRaised, round);\n', '    }\n', '\n', '    function buy()\n', '        public\n', '        payable\n', '        whenNotPaused\n', '        atStage(Stages.Started)\n', '        onlyValidPurchase()\n', '        returns (bool)\n', '    {\n', '        address purchaser = msg.sender;\n', '        uint256 contributionInWei = msg.value;\n', '        uint256 tokenAmount = contributionInWei.mul(roundInfos[uint8(round)].rate);\n', '\n', '        if (!token.transferFrom(token.owner(), purchaser, tokenAmount)) {\n', '            revert();\n', '        }\n', '\n', '        totalWeiRaised = totalWeiRaised.add(contributionInWei);\n', '        roundInfos[uint8(round)].weiRaised =\n', '            roundInfos[uint8(round)].weiRaised.add(contributionInWei);\n', '\n', '        contPerRound[purchaser][uint8(round)] =\n', '            contPerRound[purchaser][uint8(round)].add(contributionInWei);\n', '\n', '        // Transfer contributions to fund address\n', '        fundAddr.transfer(contributionInWei);\n', '        TokenPurchase(msg.sender, contributionInWei, tokenAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Add user and his allowed amount to allocation list\n', '     *\n', '     * @param user: Address of user to be allocated tokens\n', '     * @param amount: Allowed allocation amount of user\n', '     */\n', '    function addToAllocationList(address user, uint256 amount)\n', '        public\n', '        onlyOwner\n', '        atRound(SaleRounds.EarlyInvestment)\n', '    {\n', '        allocationList[user].isAllowed = true;\n', '        allocationList[user].allowedAmount = amount;\n', '    }\n', '\n', '    /*\n', '     * Add users and their allowed amount to allocation list\n', '     *\n', '     * @param users: List of Address to be allocated tokens\n', '     * @param amount: List of allowed allocation amount of each user\n', '     */\n', '    function addManyToAllocationList(address[] users, uint256[] amounts)\n', '        external\n', '        onlyOwner\n', '        atRound(SaleRounds.EarlyInvestment)\n', '    {\n', '        require(users.length == amounts.length);\n', '\n', '        for (uint32 i = 0; i < users.length; i++) {\n', '            addToAllocationList(users[i], amounts[i]);\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Remove user from allocation list\n', '     *\n', '     * @param user: Address of user to be removed\n', '     */\n', '    function removeFromAllocationList(address user)\n', '        public\n', '        onlyOwner\n', '        atRound(SaleRounds.EarlyInvestment)\n', '    {\n', '        allocationList[user].isAllowed = false;\n', '    }\n', '\n', '    /*\n', '     * Remove users from allocation list\n', '     *\n', '     * @param user: Address list of users to be removed\n', '     */\n', '    function removeManyFromAllocationList(address[] users)\n', '        external\n', '        onlyOwner\n', '        atRound(SaleRounds.EarlyInvestment)\n', '    {\n', '        for (uint32 i = 0; i < users.length; i++) {\n', '            removeFromAllocationList(users[i]);\n', '        }\n', '    }\n', '\n', '\n', '    /*\n', '     * Allocate  tokens to user\n', '     * Only avaliable on early investment\n', '     *\n', '     * @param to: Address of user to be allocated tokens\n', '     * @param tokenAmount: Amount of tokens to be allocated\n', '     */\n', '    function allocateTokens(address to, uint256 tokenAmount)\n', '        public\n', '        onlyOwner\n', '        atRound(SaleRounds.EarlyInvestment)\n', '        returns (bool)\n', '    {\n', '        require(allocationList[to].isAllowed\n', '            && tokenAmount <= allocationList[to].allowedAmount);\n', '\n', '        if (!token.transferFrom(token.owner(), to, tokenAmount)) {\n', '            revert();\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Allocate  tokens to user\n', '     * Only avaliable on early investment\n', '     *\n', '     * @param toList: List of addresses to be allocated tokens\n', '     * @param tokenAmountList: List of token amount to be allocated to each address\n', '     */\n', '    function allocateTokensToMany(address[] toList, uint256[] tokenAmountList)\n', '        external\n', '        onlyOwner\n', '        atRound(SaleRounds.EarlyInvestment)\n', '        returns (bool)\n', '    {\n', '        require(toList.length == tokenAmountList.length);\n', '\n', '        for (uint32 i = 0; i < toList.length; i++) {\n', '            allocateTokens(toList[i], tokenAmountList[i]);\n', '        }\n', '        return true;\n', '    }\n', '}']
