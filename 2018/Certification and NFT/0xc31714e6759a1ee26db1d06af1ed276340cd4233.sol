['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title Interface for the polymath ticker registry contract\n', ' */\n', 'contract ITickerRegistry {\n', '    /**\n', '    * @notice Check the validity of the symbol\n', '    * @param _symbol token symbol\n', '    * @param _owner address of the owner\n', '    * @param _tokenName Name of the token\n', '    * @return bool\n', '    */\n', '    function checkValidity(string _symbol, address _owner, string _tokenName) public returns(bool);\n', '\n', '    /**\n', '    * @notice Returns the owner and timestamp for a given symbol\n', '    * @param _symbol symbol\n', '    */\n', '    function getDetails(string _symbol) public view returns (address, uint256, string, bytes32, bool);\n', '\n', '    /**\n', '     * @notice Check the symbol is reserved or not\n', '     * @param _symbol Symbol of the token\n', '     * @return bool\n', '     */\n', '     function isReserved(string _symbol, address _owner, string _tokenName, bytes32 _swarmHash) public returns(bool);\n', '\n', '}\n', '\n', '/**\n', ' * @title Utility contract for reusable code\n', ' */\n', 'contract Util {\n', '\n', '   /**\n', '    * @notice changes a string to upper case\n', '    * @param _base string to change\n', '    */\n', '    function upper(string _base) internal pure returns (string) {\n', '        bytes memory _baseBytes = bytes(_base);\n', '        for (uint i = 0; i < _baseBytes.length; i++) {\n', '            bytes1 b1 = _baseBytes[i];\n', '            if (b1 >= 0x61 && b1 <= 0x7A) {\n', '                b1 = bytes1(uint8(b1)-32);\n', '            }\n', '            _baseBytes[i] = b1;\n', '        }\n', '        return string(_baseBytes);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Utility contract to allow pausing and unpausing of certain functions\n', ' */\n', 'contract Pausable {\n', '\n', '    event Pause(uint256 _timestammp);\n', '    event Unpause(uint256 _timestamp);\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '   /**\n', '    * @notice called by the owner to pause, triggers stopped state\n', '    */\n', '    function _pause() internal {\n', '        require(!paused);\n', '        paused = true;\n', '        emit Pause(now);\n', '    }\n', '\n', '    /**\n', '    * @notice called by the owner to unpause, returns to normal state\n', '    */\n', '    function _unpause() internal {\n', '        require(paused);\n', '        paused = false;\n', '        emit Unpause(now);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Utility contract to allow owner to retreive any ERC20 sent to the contract\n', ' */\n', 'contract ReclaimTokens is Ownable {\n', '\n', '    /**\n', '    * @notice Reclaim all ERC20Basic compatible tokens\n', '    * @param _tokenContract The address of the token contract\n', '    */\n', '    function reclaimERC20(address _tokenContract) external onlyOwner {\n', '        require(_tokenContract != address(0));\n', '        ERC20Basic token = ERC20Basic(_tokenContract);\n', '        uint256 balance = token.balanceOf(address(this));\n', '        require(token.transfer(owner, balance));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Core functionality for registry upgradability\n', ' */\n', 'contract PolymathRegistry is ReclaimTokens {\n', '\n', '    mapping (bytes32 => address) public storedAddresses;\n', '\n', '    event LogChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);\n', '\n', '    /**\n', '     * @notice Get the contract address\n', '     * @param _nameKey is the key for the contract address mapping\n', '     * @return address\n', '     */\n', '    function getAddress(string _nameKey) view public returns(address) {\n', '        bytes32 key = keccak256(bytes(_nameKey));\n', '        require(storedAddresses[key] != address(0), "Invalid address key");\n', '        return storedAddresses[key];\n', '    }\n', '\n', '    /**\n', '     * @notice change the contract address\n', '     * @param _nameKey is the key for the contract address mapping\n', '     * @param _newAddress is the new contract address\n', '     */\n', '    function changeAddress(string _nameKey, address _newAddress) public onlyOwner {\n', '        bytes32 key = keccak256(bytes(_nameKey));\n', '        emit LogChangeAddress(_nameKey, storedAddresses[key], _newAddress);\n', '        storedAddresses[key] = _newAddress;\n', '    }\n', '\n', '\n', '}\n', '\n', 'contract RegistryUpdater is Ownable {\n', '\n', '    address public polymathRegistry;\n', '    address public moduleRegistry;\n', '    address public securityTokenRegistry;\n', '    address public tickerRegistry;\n', '    address public polyToken;\n', '\n', '    constructor (address _polymathRegistry) public {\n', '        require(_polymathRegistry != address(0));\n', '        polymathRegistry = _polymathRegistry;\n', '    }\n', '\n', '    function updateFromRegistry() onlyOwner public {\n', '        moduleRegistry = PolymathRegistry(polymathRegistry).getAddress("ModuleRegistry");\n', '        securityTokenRegistry = PolymathRegistry(polymathRegistry).getAddress("SecurityTokenRegistry");\n', '        tickerRegistry = PolymathRegistry(polymathRegistry).getAddress("TickerRegistry");\n', '        polyToken = PolymathRegistry(polymathRegistry).getAddress("PolyToken");\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Registry contract for issuers to reserve their security token symbols\n', ' * @notice Allows issuers to reserve their token symbols ahead of actually generating their security token.\n', ' * @dev SecurityTokenRegistry would reference this contract and ensure that a token symbol exists here and only its owner can deploy the token with that symbol.\n', ' */\n', 'contract TickerRegistry is ITickerRegistry, Util, Pausable, RegistryUpdater, ReclaimTokens {\n', '\n', '    using SafeMath for uint256;\n', '    // constant variable to check the validity to use the symbol\n', '    // For now it&#39;s value is 15 days;\n', '    uint256 public expiryLimit = 15 * 1 days;\n', '\n', '    // Details of the symbol that get registered with the polymath platform\n', '    struct SymbolDetails {\n', '        address owner;\n', '        uint256 timestamp;\n', '        string tokenName;\n', '        bytes32 swarmHash;\n', '        bool status;\n', '    }\n', '\n', '    // Storage of symbols correspond to their details.\n', '    mapping(string => SymbolDetails) registeredSymbols;\n', '\n', '    // Emit after the symbol registration\n', '    event LogRegisterTicker(address indexed _owner, string _symbol, string _name, bytes32 _swarmHash, uint256 indexed _timestamp);\n', '    // Emit when the token symbol expiry get changed\n', '    event LogChangeExpiryLimit(uint256 _oldExpiry, uint256 _newExpiry);\n', '\n', '    // Registration fee in POLY base 18 decimals\n', '    uint256 public registrationFee;\n', '    // Emit when changePolyRegisterationFee is called\n', '    event LogChangePolyRegisterationFee(uint256 _oldFee, uint256 _newFee);\n', '\n', '    constructor (address _polymathRegistry, uint256 _registrationFee) public\n', '    RegistryUpdater(_polymathRegistry)\n', '    {\n', '        registrationFee = _registrationFee;\n', '    }\n', '\n', '    /**\n', '     * @notice Register the token symbol for its particular owner\n', '     * @notice Once the token symbol is registered to its owner then no other issuer can claim\n', '     * @notice its ownership. If the symbol expires and its issuer hasn&#39;t used it, then someone else can take it.\n', '     * @param _symbol token symbol\n', '     * @param _tokenName Name of the token\n', '     * @param _owner Address of the owner of the token\n', '     * @param _swarmHash Off-chain details of the issuer and token\n', '     */\n', '    function registerTicker(address _owner, string _symbol, string _tokenName, bytes32 _swarmHash) public whenNotPaused {\n', '        require(_owner != address(0), "Owner should not be 0x");\n', '        require(bytes(_symbol).length > 0 && bytes(_symbol).length <= 10, "Ticker length should always between 0 & 10");\n', '        if(registrationFee > 0)\n', '            require(ERC20(polyToken).transferFrom(msg.sender, this, registrationFee), "Failed transferFrom because of sufficent Allowance is not provided");\n', '        string memory symbol = upper(_symbol);\n', '        require(expiryCheck(symbol), "Ticker is already reserved");\n', '        registeredSymbols[symbol] = SymbolDetails(_owner, now, _tokenName, _swarmHash, false);\n', '        emit LogRegisterTicker (_owner, symbol, _tokenName, _swarmHash, now);\n', '    }\n', '\n', '    /**\n', '     * @notice Change the expiry time for the token symbol\n', '     * @param _newExpiry new time period for token symbol expiry\n', '     */\n', '    function changeExpiryLimit(uint256 _newExpiry) public onlyOwner {\n', '        require(_newExpiry >= 1 days, "Expiry should greater than or equal to 1 day");\n', '        uint256 _oldExpiry = expiryLimit;\n', '        expiryLimit = _newExpiry;\n', '        emit LogChangeExpiryLimit(_oldExpiry, _newExpiry);\n', '    }\n', '\n', '    /**\n', '     * @notice Check the validity of the symbol\n', '     * @param _symbol token symbol\n', '     * @param _owner address of the owner\n', '     * @param _tokenName Name of the token\n', '     * @return bool\n', '     */\n', '    function checkValidity(string _symbol, address _owner, string _tokenName) public returns(bool) {\n', '        string memory symbol = upper(_symbol);\n', '        require(msg.sender == securityTokenRegistry, "msg.sender should be SecurityTokenRegistry contract");\n', '        require(registeredSymbols[symbol].status != true, "Symbol status should not equal to true");\n', '        require(registeredSymbols[symbol].owner == _owner, "Owner of the symbol should matched with the requested issuer address");\n', '        require(registeredSymbols[symbol].timestamp.add(expiryLimit) >= now, "Ticker should not be expired");\n', '        registeredSymbols[symbol].tokenName = _tokenName;\n', '        registeredSymbols[symbol].status = true;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Check the symbol is reserved or not\n', '     * @param _symbol Symbol of the token\n', '     * @param _owner Owner of the token\n', '     * @param _tokenName Name of the token\n', '     * @param _swarmHash off-chain hash\n', '     * @return bool\n', '     */\n', '     function isReserved(string _symbol, address _owner, string _tokenName, bytes32 _swarmHash) public returns(bool) {\n', '        string memory symbol = upper(_symbol);\n', '        require(msg.sender == securityTokenRegistry, "msg.sender should be SecurityTokenRegistry contract");\n', '        if (registeredSymbols[symbol].owner == _owner && !expiryCheck(_symbol)) {\n', '            registeredSymbols[symbol].status = true;\n', '            return false;\n', '        }\n', '        else if (registeredSymbols[symbol].owner == address(0) || expiryCheck(symbol)) {\n', '            registeredSymbols[symbol] = SymbolDetails(_owner, now, _tokenName, _swarmHash, true);\n', '            emit LogRegisterTicker (_owner, symbol, _tokenName, _swarmHash, now);\n', '            return false;\n', '        } else\n', '            return true;\n', '     }\n', '\n', '    /**\n', '     * @notice Returns the owner and timestamp for a given symbol\n', '     * @param _symbol symbol\n', '     * @return address\n', '     * @return uint256\n', '     * @return string\n', '     * @return bytes32\n', '     * @return bool\n', '     */\n', '    function getDetails(string _symbol) public view returns (address, uint256, string, bytes32, bool) {\n', '        string memory symbol = upper(_symbol);\n', '        if (registeredSymbols[symbol].status == true||registeredSymbols[symbol].timestamp.add(expiryLimit) > now) {\n', '            return\n', '            (\n', '                registeredSymbols[symbol].owner,\n', '                registeredSymbols[symbol].timestamp,\n', '                registeredSymbols[symbol].tokenName,\n', '                registeredSymbols[symbol].swarmHash,\n', '                registeredSymbols[symbol].status\n', '            );\n', '        }else\n', '            return (address(0), uint256(0), "", bytes32(0), false);\n', '    }\n', '\n', '    /**\n', '     * @notice To re-initialize the token symbol details if symbol validity expires\n', '     * @param _symbol token symbol\n', '     * @return bool\n', '     */\n', '    function expiryCheck(string _symbol) internal returns(bool) {\n', '        if (registeredSymbols[_symbol].owner != address(0)) {\n', '            if (now > registeredSymbols[_symbol].timestamp.add(expiryLimit) && registeredSymbols[_symbol].status != true) {\n', '                registeredSymbols[_symbol] = SymbolDetails(address(0), uint256(0), "", bytes32(0), false);\n', '                return true;\n', '            }else\n', '                return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice set the ticker registration fee in POLY tokens\n', '     * @param _registrationFee registration fee in POLY tokens (base 18 decimals)\n', '     */\n', '    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {\n', '        require(registrationFee != _registrationFee);\n', '        emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);\n', '        registrationFee = _registrationFee;\n', '    }\n', '\n', '     /**\n', '     * @notice pause registration function\n', '     */\n', '    function unpause() public onlyOwner  {\n', '        _unpause();\n', '    }\n', '\n', '    /**\n', '     * @notice unpause registration function\n', '     */\n', '    function pause() public onlyOwner {\n', '        _pause();\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title Interface for the polymath ticker registry contract\n', ' */\n', 'contract ITickerRegistry {\n', '    /**\n', '    * @notice Check the validity of the symbol\n', '    * @param _symbol token symbol\n', '    * @param _owner address of the owner\n', '    * @param _tokenName Name of the token\n', '    * @return bool\n', '    */\n', '    function checkValidity(string _symbol, address _owner, string _tokenName) public returns(bool);\n', '\n', '    /**\n', '    * @notice Returns the owner and timestamp for a given symbol\n', '    * @param _symbol symbol\n', '    */\n', '    function getDetails(string _symbol) public view returns (address, uint256, string, bytes32, bool);\n', '\n', '    /**\n', '     * @notice Check the symbol is reserved or not\n', '     * @param _symbol Symbol of the token\n', '     * @return bool\n', '     */\n', '     function isReserved(string _symbol, address _owner, string _tokenName, bytes32 _swarmHash) public returns(bool);\n', '\n', '}\n', '\n', '/**\n', ' * @title Utility contract for reusable code\n', ' */\n', 'contract Util {\n', '\n', '   /**\n', '    * @notice changes a string to upper case\n', '    * @param _base string to change\n', '    */\n', '    function upper(string _base) internal pure returns (string) {\n', '        bytes memory _baseBytes = bytes(_base);\n', '        for (uint i = 0; i < _baseBytes.length; i++) {\n', '            bytes1 b1 = _baseBytes[i];\n', '            if (b1 >= 0x61 && b1 <= 0x7A) {\n', '                b1 = bytes1(uint8(b1)-32);\n', '            }\n', '            _baseBytes[i] = b1;\n', '        }\n', '        return string(_baseBytes);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Utility contract to allow pausing and unpausing of certain functions\n', ' */\n', 'contract Pausable {\n', '\n', '    event Pause(uint256 _timestammp);\n', '    event Unpause(uint256 _timestamp);\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '   /**\n', '    * @notice called by the owner to pause, triggers stopped state\n', '    */\n', '    function _pause() internal {\n', '        require(!paused);\n', '        paused = true;\n', '        emit Pause(now);\n', '    }\n', '\n', '    /**\n', '    * @notice called by the owner to unpause, returns to normal state\n', '    */\n', '    function _unpause() internal {\n', '        require(paused);\n', '        paused = false;\n', '        emit Unpause(now);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Utility contract to allow owner to retreive any ERC20 sent to the contract\n', ' */\n', 'contract ReclaimTokens is Ownable {\n', '\n', '    /**\n', '    * @notice Reclaim all ERC20Basic compatible tokens\n', '    * @param _tokenContract The address of the token contract\n', '    */\n', '    function reclaimERC20(address _tokenContract) external onlyOwner {\n', '        require(_tokenContract != address(0));\n', '        ERC20Basic token = ERC20Basic(_tokenContract);\n', '        uint256 balance = token.balanceOf(address(this));\n', '        require(token.transfer(owner, balance));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Core functionality for registry upgradability\n', ' */\n', 'contract PolymathRegistry is ReclaimTokens {\n', '\n', '    mapping (bytes32 => address) public storedAddresses;\n', '\n', '    event LogChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);\n', '\n', '    /**\n', '     * @notice Get the contract address\n', '     * @param _nameKey is the key for the contract address mapping\n', '     * @return address\n', '     */\n', '    function getAddress(string _nameKey) view public returns(address) {\n', '        bytes32 key = keccak256(bytes(_nameKey));\n', '        require(storedAddresses[key] != address(0), "Invalid address key");\n', '        return storedAddresses[key];\n', '    }\n', '\n', '    /**\n', '     * @notice change the contract address\n', '     * @param _nameKey is the key for the contract address mapping\n', '     * @param _newAddress is the new contract address\n', '     */\n', '    function changeAddress(string _nameKey, address _newAddress) public onlyOwner {\n', '        bytes32 key = keccak256(bytes(_nameKey));\n', '        emit LogChangeAddress(_nameKey, storedAddresses[key], _newAddress);\n', '        storedAddresses[key] = _newAddress;\n', '    }\n', '\n', '\n', '}\n', '\n', 'contract RegistryUpdater is Ownable {\n', '\n', '    address public polymathRegistry;\n', '    address public moduleRegistry;\n', '    address public securityTokenRegistry;\n', '    address public tickerRegistry;\n', '    address public polyToken;\n', '\n', '    constructor (address _polymathRegistry) public {\n', '        require(_polymathRegistry != address(0));\n', '        polymathRegistry = _polymathRegistry;\n', '    }\n', '\n', '    function updateFromRegistry() onlyOwner public {\n', '        moduleRegistry = PolymathRegistry(polymathRegistry).getAddress("ModuleRegistry");\n', '        securityTokenRegistry = PolymathRegistry(polymathRegistry).getAddress("SecurityTokenRegistry");\n', '        tickerRegistry = PolymathRegistry(polymathRegistry).getAddress("TickerRegistry");\n', '        polyToken = PolymathRegistry(polymathRegistry).getAddress("PolyToken");\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Registry contract for issuers to reserve their security token symbols\n', ' * @notice Allows issuers to reserve their token symbols ahead of actually generating their security token.\n', ' * @dev SecurityTokenRegistry would reference this contract and ensure that a token symbol exists here and only its owner can deploy the token with that symbol.\n', ' */\n', 'contract TickerRegistry is ITickerRegistry, Util, Pausable, RegistryUpdater, ReclaimTokens {\n', '\n', '    using SafeMath for uint256;\n', '    // constant variable to check the validity to use the symbol\n', "    // For now it's value is 15 days;\n", '    uint256 public expiryLimit = 15 * 1 days;\n', '\n', '    // Details of the symbol that get registered with the polymath platform\n', '    struct SymbolDetails {\n', '        address owner;\n', '        uint256 timestamp;\n', '        string tokenName;\n', '        bytes32 swarmHash;\n', '        bool status;\n', '    }\n', '\n', '    // Storage of symbols correspond to their details.\n', '    mapping(string => SymbolDetails) registeredSymbols;\n', '\n', '    // Emit after the symbol registration\n', '    event LogRegisterTicker(address indexed _owner, string _symbol, string _name, bytes32 _swarmHash, uint256 indexed _timestamp);\n', '    // Emit when the token symbol expiry get changed\n', '    event LogChangeExpiryLimit(uint256 _oldExpiry, uint256 _newExpiry);\n', '\n', '    // Registration fee in POLY base 18 decimals\n', '    uint256 public registrationFee;\n', '    // Emit when changePolyRegisterationFee is called\n', '    event LogChangePolyRegisterationFee(uint256 _oldFee, uint256 _newFee);\n', '\n', '    constructor (address _polymathRegistry, uint256 _registrationFee) public\n', '    RegistryUpdater(_polymathRegistry)\n', '    {\n', '        registrationFee = _registrationFee;\n', '    }\n', '\n', '    /**\n', '     * @notice Register the token symbol for its particular owner\n', '     * @notice Once the token symbol is registered to its owner then no other issuer can claim\n', "     * @notice its ownership. If the symbol expires and its issuer hasn't used it, then someone else can take it.\n", '     * @param _symbol token symbol\n', '     * @param _tokenName Name of the token\n', '     * @param _owner Address of the owner of the token\n', '     * @param _swarmHash Off-chain details of the issuer and token\n', '     */\n', '    function registerTicker(address _owner, string _symbol, string _tokenName, bytes32 _swarmHash) public whenNotPaused {\n', '        require(_owner != address(0), "Owner should not be 0x");\n', '        require(bytes(_symbol).length > 0 && bytes(_symbol).length <= 10, "Ticker length should always between 0 & 10");\n', '        if(registrationFee > 0)\n', '            require(ERC20(polyToken).transferFrom(msg.sender, this, registrationFee), "Failed transferFrom because of sufficent Allowance is not provided");\n', '        string memory symbol = upper(_symbol);\n', '        require(expiryCheck(symbol), "Ticker is already reserved");\n', '        registeredSymbols[symbol] = SymbolDetails(_owner, now, _tokenName, _swarmHash, false);\n', '        emit LogRegisterTicker (_owner, symbol, _tokenName, _swarmHash, now);\n', '    }\n', '\n', '    /**\n', '     * @notice Change the expiry time for the token symbol\n', '     * @param _newExpiry new time period for token symbol expiry\n', '     */\n', '    function changeExpiryLimit(uint256 _newExpiry) public onlyOwner {\n', '        require(_newExpiry >= 1 days, "Expiry should greater than or equal to 1 day");\n', '        uint256 _oldExpiry = expiryLimit;\n', '        expiryLimit = _newExpiry;\n', '        emit LogChangeExpiryLimit(_oldExpiry, _newExpiry);\n', '    }\n', '\n', '    /**\n', '     * @notice Check the validity of the symbol\n', '     * @param _symbol token symbol\n', '     * @param _owner address of the owner\n', '     * @param _tokenName Name of the token\n', '     * @return bool\n', '     */\n', '    function checkValidity(string _symbol, address _owner, string _tokenName) public returns(bool) {\n', '        string memory symbol = upper(_symbol);\n', '        require(msg.sender == securityTokenRegistry, "msg.sender should be SecurityTokenRegistry contract");\n', '        require(registeredSymbols[symbol].status != true, "Symbol status should not equal to true");\n', '        require(registeredSymbols[symbol].owner == _owner, "Owner of the symbol should matched with the requested issuer address");\n', '        require(registeredSymbols[symbol].timestamp.add(expiryLimit) >= now, "Ticker should not be expired");\n', '        registeredSymbols[symbol].tokenName = _tokenName;\n', '        registeredSymbols[symbol].status = true;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Check the symbol is reserved or not\n', '     * @param _symbol Symbol of the token\n', '     * @param _owner Owner of the token\n', '     * @param _tokenName Name of the token\n', '     * @param _swarmHash off-chain hash\n', '     * @return bool\n', '     */\n', '     function isReserved(string _symbol, address _owner, string _tokenName, bytes32 _swarmHash) public returns(bool) {\n', '        string memory symbol = upper(_symbol);\n', '        require(msg.sender == securityTokenRegistry, "msg.sender should be SecurityTokenRegistry contract");\n', '        if (registeredSymbols[symbol].owner == _owner && !expiryCheck(_symbol)) {\n', '            registeredSymbols[symbol].status = true;\n', '            return false;\n', '        }\n', '        else if (registeredSymbols[symbol].owner == address(0) || expiryCheck(symbol)) {\n', '            registeredSymbols[symbol] = SymbolDetails(_owner, now, _tokenName, _swarmHash, true);\n', '            emit LogRegisterTicker (_owner, symbol, _tokenName, _swarmHash, now);\n', '            return false;\n', '        } else\n', '            return true;\n', '     }\n', '\n', '    /**\n', '     * @notice Returns the owner and timestamp for a given symbol\n', '     * @param _symbol symbol\n', '     * @return address\n', '     * @return uint256\n', '     * @return string\n', '     * @return bytes32\n', '     * @return bool\n', '     */\n', '    function getDetails(string _symbol) public view returns (address, uint256, string, bytes32, bool) {\n', '        string memory symbol = upper(_symbol);\n', '        if (registeredSymbols[symbol].status == true||registeredSymbols[symbol].timestamp.add(expiryLimit) > now) {\n', '            return\n', '            (\n', '                registeredSymbols[symbol].owner,\n', '                registeredSymbols[symbol].timestamp,\n', '                registeredSymbols[symbol].tokenName,\n', '                registeredSymbols[symbol].swarmHash,\n', '                registeredSymbols[symbol].status\n', '            );\n', '        }else\n', '            return (address(0), uint256(0), "", bytes32(0), false);\n', '    }\n', '\n', '    /**\n', '     * @notice To re-initialize the token symbol details if symbol validity expires\n', '     * @param _symbol token symbol\n', '     * @return bool\n', '     */\n', '    function expiryCheck(string _symbol) internal returns(bool) {\n', '        if (registeredSymbols[_symbol].owner != address(0)) {\n', '            if (now > registeredSymbols[_symbol].timestamp.add(expiryLimit) && registeredSymbols[_symbol].status != true) {\n', '                registeredSymbols[_symbol] = SymbolDetails(address(0), uint256(0), "", bytes32(0), false);\n', '                return true;\n', '            }else\n', '                return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice set the ticker registration fee in POLY tokens\n', '     * @param _registrationFee registration fee in POLY tokens (base 18 decimals)\n', '     */\n', '    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {\n', '        require(registrationFee != _registrationFee);\n', '        emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);\n', '        registrationFee = _registrationFee;\n', '    }\n', '\n', '     /**\n', '     * @notice pause registration function\n', '     */\n', '    function unpause() public onlyOwner  {\n', '        _unpause();\n', '    }\n', '\n', '    /**\n', '     * @notice unpause registration function\n', '     */\n', '    function pause() public onlyOwner {\n', '        _pause();\n', '    }\n', '\n', '}']
