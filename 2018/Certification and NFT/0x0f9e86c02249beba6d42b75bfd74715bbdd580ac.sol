['pragma solidity ^0.4.20;\n', '\n', 'contract owned {\n', '    address public owner;\n', '    address public tokenContract;\n', '    constructor() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerAndtokenContract {\n', '        require(msg.sender == owner || msg.sender == tokenContract);\n', '        _;\n', '    }\n', '\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '    \n', '    function transfertokenContract(address newOwner) onlyOwner public {\n', '        if (newOwner != address(0)) {\n', '            tokenContract = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract DataContract is owned {\n', '    struct Good {\n', '        bytes32 preset;\n', '        uint price;\n', '        uint time;\n', '    }\n', '\n', '    mapping (bytes32 => Good) public goods;\n', '\n', '    function setGood(bytes32 _preset, uint _price) onlyOwnerAndtokenContract external {\n', '        goods[_preset] = Good({preset: _preset, price: _price, time: now});\n', '    }\n', '    \n', '    function getGoodPreset(bytes32 _preset) view public returns (bytes32) {\n', '        return goods[_preset].preset;\n', '    }\n', '    \n', '    function getGoodPrice(bytes32 _preset) view public returns (uint) {\n', '        return goods[_preset].price;\n', '    }\n', '\n', '    mapping (bytes32 => address) public decisionOf;\n', '\n', '    function setDecision(bytes32 _preset, address _address) onlyOwnerAndtokenContract external {\n', '        decisionOf[_preset] = _address;\n', '    }\n', '\n', '    function getDecision(bytes32 _preset) view public returns (address) {\n', '        return decisionOf[_preset];\n', '    }\n', '}\n', '\n', '\n', 'contract Token is owned {\n', '\n', '    DataContract DC;\n', '\n', '    constructor(address _dataContractAddr) public{\n', '        DC = DataContract(_dataContractAddr);\n', '    }\n', '    \n', '    uint _seed = now;\n', '\n', '    struct Good {\n', '        bytes32 preset;\n', '        uint price;\n', '        uint time;\n', '    }\n', '\n', '    // controll\n', '\n', '    event Decision(uint result, address finalAddress, address[] buyers, uint[] amounts);\n', '\n', '    function _random() internal returns (uint randomNumber) {\n', '        _seed = uint(keccak256(keccak256(block.blockhash(block.number-100))));\n', '        return _seed ;\n', '    }\n', '\n', '    function _stringToBytes32(string memory _source) internal pure returns (bytes32 result) {\n', '        bytes memory tempEmptyStringTest = bytes(_source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '        assembly {\n', '            result := mload(add(_source, 32))\n', '        }\n', '    }\n', '\n', '    // get decision result address\n', '    function _getFinalAddress(uint[] _amounts, address[] _buyers, uint result) internal pure returns (address finalAddress) {\n', '        uint congest = 0;\n', '        address _finalAddress = address(0);\n', '        for (uint j = 0; j < _amounts.length; j++) {\n', '            congest += _amounts[j];\n', '            if (result <= congest && _finalAddress == address(0)) {\n', '                _finalAddress = _buyers[j];\n', '            }\n', '        }\n', '        return _finalAddress;\n', '    }\n', '\n', '    function postTrade(bytes32 _preset, uint _price) onlyOwner public {\n', '        require(DC.getGoodPreset(_preset) == "");\n', '        DC.setGood(_preset, _price);\n', '    }\n', '\n', '    function decision(bytes32 _preset, string _presetSrc, address[] _buyers, uint[] _amounts) onlyOwner public payable{\n', '        \n', '        // execute it only once\n', '        require(DC.getDecision(_preset) == address(0));\n', '\n', '        // preset authenticity\n', '        require(sha256(_presetSrc) == DC.getGoodPreset(_preset));\n', '\n', '        // address added, parameter 1\n', '        uint160 allAddress;\n', '        for (uint i = 0; i < _buyers.length; i++) {\n', '            allAddress += uint160(_buyers[i]);\n', '        }\n', '        \n', '        // random, parameter 2\n', '        uint random = _random();\n', '\n', '        uint goodPrice = DC.getGoodPrice(_preset);\n', '\n', '        // preset is parameter 3, add and take the remainder\n', '        uint result = uint(uint(_stringToBytes32(_presetSrc)) + allAddress + random) % goodPrice;\n', '\n', '        address finalAddress = _getFinalAddress(_amounts, _buyers, result);\n', '        // save decision result\n', '        DC.setDecision(_preset, finalAddress);\n', '        Decision(result, finalAddress, _buyers, _amounts);\n', '    }\n', '}']
['pragma solidity ^0.4.20;\n', '\n', 'contract owned {\n', '    address public owner;\n', '    address public tokenContract;\n', '    constructor() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerAndtokenContract {\n', '        require(msg.sender == owner || msg.sender == tokenContract);\n', '        _;\n', '    }\n', '\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '    \n', '    function transfertokenContract(address newOwner) onlyOwner public {\n', '        if (newOwner != address(0)) {\n', '            tokenContract = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract DataContract is owned {\n', '    struct Good {\n', '        bytes32 preset;\n', '        uint price;\n', '        uint time;\n', '    }\n', '\n', '    mapping (bytes32 => Good) public goods;\n', '\n', '    function setGood(bytes32 _preset, uint _price) onlyOwnerAndtokenContract external {\n', '        goods[_preset] = Good({preset: _preset, price: _price, time: now});\n', '    }\n', '    \n', '    function getGoodPreset(bytes32 _preset) view public returns (bytes32) {\n', '        return goods[_preset].preset;\n', '    }\n', '    \n', '    function getGoodPrice(bytes32 _preset) view public returns (uint) {\n', '        return goods[_preset].price;\n', '    }\n', '\n', '    mapping (bytes32 => address) public decisionOf;\n', '\n', '    function setDecision(bytes32 _preset, address _address) onlyOwnerAndtokenContract external {\n', '        decisionOf[_preset] = _address;\n', '    }\n', '\n', '    function getDecision(bytes32 _preset) view public returns (address) {\n', '        return decisionOf[_preset];\n', '    }\n', '}\n', '\n', '\n', 'contract Token is owned {\n', '\n', '    DataContract DC;\n', '\n', '    constructor(address _dataContractAddr) public{\n', '        DC = DataContract(_dataContractAddr);\n', '    }\n', '    \n', '    uint _seed = now;\n', '\n', '    struct Good {\n', '        bytes32 preset;\n', '        uint price;\n', '        uint time;\n', '    }\n', '\n', '    // controll\n', '\n', '    event Decision(uint result, address finalAddress, address[] buyers, uint[] amounts);\n', '\n', '    function _random() internal returns (uint randomNumber) {\n', '        _seed = uint(keccak256(keccak256(block.blockhash(block.number-100))));\n', '        return _seed ;\n', '    }\n', '\n', '    function _stringToBytes32(string memory _source) internal pure returns (bytes32 result) {\n', '        bytes memory tempEmptyStringTest = bytes(_source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '        assembly {\n', '            result := mload(add(_source, 32))\n', '        }\n', '    }\n', '\n', '    // get decision result address\n', '    function _getFinalAddress(uint[] _amounts, address[] _buyers, uint result) internal pure returns (address finalAddress) {\n', '        uint congest = 0;\n', '        address _finalAddress = address(0);\n', '        for (uint j = 0; j < _amounts.length; j++) {\n', '            congest += _amounts[j];\n', '            if (result <= congest && _finalAddress == address(0)) {\n', '                _finalAddress = _buyers[j];\n', '            }\n', '        }\n', '        return _finalAddress;\n', '    }\n', '\n', '    function postTrade(bytes32 _preset, uint _price) onlyOwner public {\n', '        require(DC.getGoodPreset(_preset) == "");\n', '        DC.setGood(_preset, _price);\n', '    }\n', '\n', '    function decision(bytes32 _preset, string _presetSrc, address[] _buyers, uint[] _amounts) onlyOwner public payable{\n', '        \n', '        // execute it only once\n', '        require(DC.getDecision(_preset) == address(0));\n', '\n', '        // preset authenticity\n', '        require(sha256(_presetSrc) == DC.getGoodPreset(_preset));\n', '\n', '        // address added, parameter 1\n', '        uint160 allAddress;\n', '        for (uint i = 0; i < _buyers.length; i++) {\n', '            allAddress += uint160(_buyers[i]);\n', '        }\n', '        \n', '        // random, parameter 2\n', '        uint random = _random();\n', '\n', '        uint goodPrice = DC.getGoodPrice(_preset);\n', '\n', '        // preset is parameter 3, add and take the remainder\n', '        uint result = uint(uint(_stringToBytes32(_presetSrc)) + allAddress + random) % goodPrice;\n', '\n', '        address finalAddress = _getFinalAddress(_amounts, _buyers, result);\n', '        // save decision result\n', '        DC.setDecision(_preset, finalAddress);\n', '        Decision(result, finalAddress, _buyers, _amounts);\n', '    }\n', '}']
