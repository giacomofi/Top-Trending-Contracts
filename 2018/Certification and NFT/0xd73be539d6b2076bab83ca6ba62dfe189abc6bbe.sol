['pragma solidity ^0.4.20;\n', '\n', '/// BlockchainCuties: Collectible and breedable cuties on the Ethereum blockchain.\n', '/// https://blockchaincuties.co/\n', '\n', '\n', '/// @title defined the interface that will be referenced in main Cutie contract\n', 'contract GeneMixerInterface {\n', '    /// @dev simply a boolean to indicate this is the contract we expect to be\n', '    function isGeneMixer() external pure returns (bool);\n', '\n', '    /// @dev given genes of cutie 1 & 2, return a genetic combination - may have a random factor\n', '    /// @param genes1 genes of mom\n', '    /// @param genes2 genes of dad\n', '    /// @return the genes that are supposed to be passed down the child\n', '    function mixGenes(uint256 genes1, uint256 genes2) public view returns (uint256);\n', '\n', '    function canBreed(uint40 momId, uint256 genes1, uint40 dadId, uint256 genes2) public view returns (bool);\n', '}\n', '\n', '\n', '\n', '/// @author https://BlockChainArchitect.iocontract Bank is CutiePluginBase\n', 'contract PluginInterface\n', '{\n', '    /// @dev simply a boolean to indicate this is the contract we expect to be\n', '    function isPluginInterface() public pure returns (bool);\n', '\n', '    function onRemove() public;\n', '\n', '    /// @dev Begins new feature.\n', '    /// @param _cutieId - ID of token to auction, sender must be owner.\n', '    /// @param _parameter - arbitrary parameter\n', '    /// @param _seller - Old owner, if not the message sender\n', '    function run(\n', '        uint40 _cutieId,\n', '        uint256 _parameter,\n', '        address _seller\n', '    ) \n', '    public\n', '    payable;\n', '\n', '    /// @dev Begins new feature, approved and signed by COO.\n', '    /// @param _cutieId - ID of token to auction, sender must be owner.\n', '    /// @param _parameter - arbitrary parameter\n', '    function runSigned(\n', '        uint40 _cutieId,\n', '        uint256 _parameter,\n', '        address _owner\n', '    )\n', '    external\n', '    payable;\n', '\n', '    function withdraw() public;\n', '}\n', '\n', '\n', '\n', '/// @title Auction Market for Blockchain Cuties.\n', '/// @author https://BlockChainArchitect.io\n', 'contract MarketInterface \n', '{\n', '    function withdrawEthFromBalance() external;    \n', '\n', '    function createAuction(uint40 _cutieId, uint128 _startPrice, uint128 _endPrice, uint40 _duration, address _seller) public payable;\n', '\n', '    function bid(uint40 _cutieId) public payable;\n', '\n', '    function cancelActiveAuctionWhenPaused(uint40 _cutieId) public;\n', '\n', '\tfunction getAuctionInfo(uint40 _cutieId)\n', '        public\n', '        view\n', '        returns\n', '    (\n', '        address seller,\n', '        uint128 startPrice,\n', '        uint128 endPrice,\n', '        uint40 duration,\n', '        uint40 startedAt,\n', '        uint128 featuringFee\n', '    );\n', '}\n', '\n', '\n', '\n', '/// @title BlockchainCuties: Collectible and breedable cuties on the Ethereum blockchain.\n', '/// @author https://BlockChainArchitect.io\n', '/// @dev This is the BlockchainCuties configuration. It can be changed redeploying another version.\n', 'contract ConfigInterface\n', '{\n', '    function isConfig() public pure returns (bool);\n', '\n', '    function getCooldownIndexFromGeneration(uint16 _generation) public view returns (uint16);\n', '    \n', '    function getCooldownEndTimeFromIndex(uint16 _cooldownIndex) public view returns (uint40);\n', '\n', '    function getCooldownIndexCount() public view returns (uint256);\n', '    \n', '    function getBabyGen(uint16 _momGen, uint16 _dadGen) public pure returns (uint16);\n', '\n', '    function getTutorialBabyGen(uint16 _dadGen) public pure returns (uint16);\n', '\n', '    function getBreedingFee(uint40 _momId, uint40 _dadId) public pure returns (uint256);\n', '}\n', '\n', '\n', '\n', '/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\n', 'interface ERC721TokenReceiver {\n', '    /// @notice Handle the receipt of an NFT\n', '    /// @dev The ERC721 smart contract calls this function on the recipient\n', '    ///  after a `transfer`. This function MAY throw to revert and reject the\n', '    ///  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    ///  than the magic value MUST result in the transaction being reverted.\n', '    ///  Note: the contract address is always the message sender.\n', '    /// @param _from The sending address \n', '    /// @param _tokenId The NFT identifier which is being transfered\n', '    /// @param data Additional data with no specified format\n', '    /// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '    ///  unless throwing\n', '    function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n', '}\n', '\n', '\n', '/// @title BlockchainCuties: Collectible and breedable cuties on the Ethereum blockchain.\n', '/// @author https://BlockChainArchitect.io\n', '/// @dev This is the main BlockchainCuties contract. For separated logical sections the code is divided in \n', '// several separately-instantiated sibling contracts that handle auctions and the genetic combination algorithm. \n', '// By keeping auctions separate it is possible to upgrade them without disrupting the main contract that tracks\n', '// the ownership of the cutie. The genetic combination algorithm is kept separate so that all of the rest of the \n', '// code can be open-sourced.\n', '// The contracts:\n', '//\n', '//      - BlockchainCuties: The fundamental code, including main data storage, constants and data types, as well as\n', '//             internal functions for managing these items ans ERC-721 implementation.\n', '//             Various addresses and constraints for operations can be executed only by specific roles - \n', '//             Owner, Operator and Parties.\n', '//             Methods for interacting with additional features (Plugins).\n', '//             The methods for breeding and keeping track of breeding offers, relies on external genetic combination \n', '//             contract.\n', '//             Public methods for auctioning or bidding or breeding. \n', '//\n', '//      - SaleMarket and BreedingMarket: The actual auction functionality is handled in two sibling contracts - one\n', '//             for sales and one for breeding. Auction creation and bidding is mostly mediated through this side of \n', '//             the core contract.\n', '//\n', '//      - Effects: Contracts allow to use item effects on cuties, implemented as plugins. Items are not stored in \n', '//             blockchain to not overload Ethereum network. Operator generates signatures, and Plugins check it\n', '//             and perform effect.\n', '//\n', '//      - ItemMarket: Plugin contract used to transfer money from buyer to seller.\n', '//\n', '//      - Bank: Plugin contract used to receive payments for payed features.\n', '\n', 'contract BlockchainCutiesCore /*is ERC721, CutieCoreInterface*/\n', '{\n', '    /// @notice A descriptive name for a collection of NFTs in this contract\n', '    function name() external pure returns (string _name) \n', '    {\n', '        return "BlockchainCuties"; \n', '    }\n', '\n', '    /// @notice An abbreviated name for NFTs in this contract\n', '    function symbol() external pure returns (string _symbol)\n', '    {\n', '        return "BC";\n', '    }\n', '    \n', '    /// @notice Query if a contract implements an interface\n', '    /// @param interfaceID The interface identifier, as specified in ERC-165\n', '    /// @dev Interface identification is specified in ERC-165. This function\n', '    ///  uses less than 30,000 gas.\n', '    /// @return `true` if the contract implements `interfaceID` and\n', '    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '    function supportsInterface(bytes4 interfaceID) external pure returns (bool)\n', '    {\n', '        return\n', '            interfaceID == 0x6466353c || \n', '            interfaceID == bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    /// @dev The Birth event is fired as soon as a new cutie is created. This\n', '    ///  is any time a cutie comes into existence through the giveBirth method, as well as\n', '    ///  when a new gen0 cutie is created.\n', '    event Birth(address indexed owner, uint40 cutieId, uint40 momId, uint40 dadId, uint256 genes);\n', '\n', '    /// @dev This struct represents a blockchain Cutie. It was ensured that struct fits well into\n', '    ///  exactly two 256-bit words. The order of the members in this structure\n', '    ///  matters because of the Ethereum byte-packing rules.\n', '    ///  Reference: http://solidity.readthedocs.io/en/develop/miscellaneous.html\n', '    struct Cutie\n', '    {\n', '        // The Cutie&#39;s genetic code is in these 256-bits. Cutie&#39;s genes never change.\n', '        uint256 genes;\n', '\n', '        // The timestamp from the block when this cutie was created.\n', '        uint40 birthTime;\n', '\n', '        // The minimum timestamp after which the cutie can start breeding\n', '        // again.\n', '        uint40 cooldownEndTime;\n', '\n', '        // The cutie&#39;s parents ID is set to 0 for gen0 cuties.\n', '        // Because of using 32-bit unsigned integers the limit is 4 billion cuties. \n', '        // Current Ethereum annual limit is about 500 million transactions.\n', '        uint40 momId;\n', '        uint40 dadId;\n', '\n', '        // Set the index in the cooldown array (see below) that means\n', '        // the current cooldown duration for this Cutie. Starts at 0\n', '        // for gen0 cats, and is initialized to floor(generation/2) for others.\n', '        // Incremented by one for each successful breeding, regardless\n', '        // of being cutie mom or cutie dad.\n', '        uint16 cooldownIndex;\n', '\n', '        // The "generation number" of the cutie. Cutioes minted by the contract\n', '        // for sale are called "gen0" with generation number of 0. All other cuties&#39; \n', '        // generation number is the larger of their parents&#39; two generation\n', '        // numbers, plus one (i.e. max(mom.generation, dad.generation) + 1)\n', '        uint16 generation;\n', '\n', '        // Some optional data used by external contracts\n', '        // Cutie struct is 2x256 bits long.\n', '        uint64 optional;\n', '    }\n', '\n', '    /// @dev An array containing the Cutie struct for all Cuties in existence. The ID\n', '    ///  of each cutie is actually an index into this array. ID 0 is the parent \n', '    /// of all generation 0 cats, and both parents to itself. It is an invalid genetic code.\n', '    Cutie[] public cuties;\n', '\n', '    /// @dev A mapping from cutie IDs to the address that owns them. All cuties have\n', '    ///  some valid owner address, even gen0 cuties are created with a non-zero owner.\n', '    mapping (uint40 => address) public cutieIndexToOwner;\n', '\n', '    // @dev A mapping from owner address to count of tokens that address owns.\n', '    //  Used internally inside balanceOf() to resolve ownership count.\n', '    mapping (address => uint256) ownershipTokenCount;\n', '\n', '    /// @dev A mapping from CutieIDs to an address that has been approved to call\n', '    ///  transferFrom(). A Cutie can have one approved address for transfer\n', '    ///  at any time. A zero value means that there is no outstanding approval.\n', '    mapping (uint40 => address) public cutieIndexToApproved;\n', '\n', '    /// @dev A mapping from CutieIDs to an address that has been approved to use\n', '    ///  this Cutie for breeding via breedWith(). A Cutie can have one approved\n', '    ///  address for breeding at any time. A zero value means that there is no outstanding approval.\n', '    mapping (uint40 => address) public sireAllowedToAddress;\n', '\n', '\n', '    /// @dev The address of the Market contract used to sell cuties. This\n', '    ///  contract used both peer-to-peer sales and the gen0 sales that are\n', '    ///  initiated each 15 minutes.\n', '    MarketInterface public saleMarket;\n', '\n', '    /// @dev The address of a custom Market subclassed contract used for breeding\n', '    ///  auctions. Is to be separated from saleMarket as the actions taken on success\n', '    ///  after a sales and breeding auction are quite different.\n', '    MarketInterface public breedingMarket;\n', '\n', '\n', '    // Modifiers to check that inputs can be safely stored with a certain\n', '    // number of bits.\n', '    modifier canBeStoredIn40Bits(uint256 _value) {\n', '        require(_value <= 0xFFFFFFFFFF);\n', '        _;\n', '    }    \n', '\n', '    /// @notice Returns the total number of Cuties in existence.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function totalSupply() external view returns (uint256)\n', '    {\n', '        return cuties.length - 1;\n', '    }\n', '\n', '    /// @notice Returns the total number of Cuties in existence.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function _totalSupply() internal view returns (uint256)\n', '    {\n', '        return cuties.length - 1;\n', '    }\n', '    \n', '    // Internal utility functions assume that their input arguments\n', '    // are valid. Public methods sanitize their inputs and follow\n', '    // the required logic.\n', '\n', '    /// @dev Checks if a given address is the current owner of a certain Cutie.\n', '    /// @param _claimant the address we are validating against.\n', '    /// @param _cutieId cutie id, only valid when > 0\n', '    function _isOwner(address _claimant, uint40 _cutieId) internal view returns (bool)\n', '    {\n', '        return cutieIndexToOwner[_cutieId] == _claimant;\n', '    }\n', '\n', '    /// @dev Checks if a given address currently has transferApproval for a certain Cutie.\n', '    /// @param _claimant the address we are confirming the cutie is approved for.\n', '    /// @param _cutieId cutie id, only valid when > 0\n', '    function _approvedFor(address _claimant, uint40 _cutieId) internal view returns (bool)\n', '    {\n', '        return cutieIndexToApproved[_cutieId] == _claimant;\n', '    }\n', '\n', '    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n', '    ///  approval. Setting _approved to address(0) clears all transfer approval.\n', '    ///  NOTE: _approve() does NOT send the Approval event. This is done on purpose:\n', '    ///  _approve() and transferFrom() are used together for putting Cuties on auction. \n', '    ///  There is no value in spamming the log with Approval events in that case.\n', '    function _approve(uint40 _cutieId, address _approved) internal\n', '    {\n', '        cutieIndexToApproved[_cutieId] = _approved;\n', '    }\n', '\n', '    /// @notice Returns the number of Cuties owned by a specific address.\n', '    /// @param _owner The owner address to check.\n', '    /// @dev Required for ERC-721 compliance\n', '    function balanceOf(address _owner) external view returns (uint256 count)\n', '    {\n', '        return ownershipTokenCount[_owner];\n', '    }\n', '\n', '    /// @notice Transfers a Cutie to another address. When transferring to a smart\n', '    ///  contract, ensure that it is aware of ERC-721 (or\n', '    ///  BlockchainCuties specifically), otherwise the Cutie may be lost forever.\n', '    /// @param _to The address of the recipient, can be a user or contract.\n', '    /// @param _cutieId The ID of the Cutie to transfer.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function transfer(address _to, uint256 _cutieId) external whenNotPaused canBeStoredIn40Bits(_cutieId)\n', '    {\n', '        // You can only send your own cutie.\n', '        require(_isOwner(msg.sender, uint40(_cutieId)));\n', '\n', '        // Reassign ownership, clear pending approvals, emit Transfer event.\n', '        _transfer(msg.sender, _to, uint40(_cutieId));\n', '    }\n', '\n', '    /// @notice Grant another address the right to transfer a perticular Cutie via transferFrom().\n', '    /// This flow is preferred for transferring NFTs to contracts.\n', '    /// @param _to The address to be granted transfer approval. Pass address(0) to clear all approvals.\n', '    /// @param _cutieId The ID of the Cutie that can be transferred if this call succeeds.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function approve(address _to, uint256 _cutieId) external whenNotPaused canBeStoredIn40Bits(_cutieId)\n', '    {\n', '        // Only cutie&#39;s owner can grant transfer approval.\n', '        require(_isOwner(msg.sender, uint40(_cutieId)));\n', '\n', '        // Registering approval replaces any previous approval.\n', '        _approve(uint40(_cutieId), _to);\n', '\n', '        // Emit approval event.\n', '        emit Approval(msg.sender, _to, _cutieId);\n', '    }\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address.\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '    ///  `onERC721Received` on `_to` and throws if the return value is not\n', '    ///  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    /// @param data Additional data with no specified format, sent in call to `_to`\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) \n', '        external whenNotPaused canBeStoredIn40Bits(_tokenId)\n', '    {\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        require(_to != address(saleMarket));\n', '        require(_to != address(breedingMarket));\n', '       \n', '        // Check for approval and valid ownership\n', '        require(_approvedFor(msg.sender, uint40(_tokenId)) || _isApprovedForAll(_from, msg.sender));\n', '        require(_isOwner(_from, uint40(_tokenId)));\n', '\n', '        // Reassign ownership, clearing pending approvals and emitting Transfer event.\n', '        _transfer(_from, _to, uint40(_tokenId));\n', '        ERC721TokenReceiver (_to).onERC721Received(_from, _tokenId, data);\n', '    }\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev This works identically to the other function with an extra data parameter,\n', '    ///  except this function just sets data to ""\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) \n', '        external whenNotPaused canBeStoredIn40Bits(_tokenId)\n', '    {\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        require(_to != address(saleMarket));\n', '        require(_to != address(breedingMarket));\n', '       \n', '        // Check for approval and valid ownership\n', '        require(_approvedFor(msg.sender, uint40(_tokenId)) || _isApprovedForAll(_from, msg.sender));\n', '        require(_isOwner(_from, uint40(_tokenId)));\n', '\n', '        // Reassign ownership, clearing pending approvals and emitting Transfer event.\n', '        _transfer(_from, _to, uint40(_tokenId));\n', '    }\n', '\n', '    /// @notice Transfer a Cutie owned by another address, for which the calling address\n', '    ///  has been granted transfer approval by the owner.\n', '    /// @param _from The address that owns the Cutie to be transfered.\n', '    /// @param _to Any address, including the caller address, can take ownership of the Cutie.\n', '    /// @param _tokenId The ID of the Cutie to be transferred.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) \n', '        external whenNotPaused canBeStoredIn40Bits(_tokenId) \n', '    {\n', '        // Check for approval and valid ownership\n', '        require(_approvedFor(msg.sender, uint40(_tokenId)) || _isApprovedForAll(_from, msg.sender));\n', '        require(_isOwner(_from, uint40(_tokenId)));\n', '\n', '        // Reassign ownership, clearing pending approvals and emitting Transfer event.\n', '        _transfer(_from, _to, uint40(_tokenId));\n', '    }\n', '\n', '    /// @notice Returns the address currently assigned ownership of a given Cutie.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function ownerOf(uint256 _cutieId)\n', '        external\n', '        view\n', '        canBeStoredIn40Bits(_cutieId)\n', '        returns (address owner)\n', '    {\n', '        owner = cutieIndexToOwner[uint40(_cutieId)];\n', '\n', '        require(owner != address(0));\n', '    }\n', '\n', '    /// @notice Returns the nth Cutie assigned to an address, with n specified by the\n', '    ///  _index argument.\n', '    /// @param _owner The owner of the Cuties we are interested in.\n', '    /// @param _index The zero-based index of the cutie within the owner&#39;s list of cuties.\n', '    ///  Must be less than balanceOf(_owner).\n', '    /// @dev This method must not be called by smart contract code. It will almost\n', '    ///  certainly blow past the block gas limit once there are a large number of\n', '    ///  Cuties in existence. Exists only to allow off-chain queries of ownership.\n', '    ///  Optional method for ERC-721.\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index)\n', '        external\n', '        view\n', '        returns (uint256 cutieId)\n', '    {\n', '        uint40 count = 0;\n', '        for (uint40 i = 1; i <= _totalSupply(); ++i) {\n', '            if (cutieIndexToOwner[i] == _owner) {\n', '                if (count == _index) {\n', '                    return i;\n', '                } else {\n', '                    count++;\n', '                }\n', '            }\n', '        }\n', '        revert();\n', '    }\n', '\n', '    /// @notice Enumerate valid NFTs\n', '    /// @dev Throws if `_index` >= `totalSupply()`.\n', '    /// @param _index A counter less than `totalSupply()`\n', '    /// @return The token identifier for the `_index`th NFT,\n', '    ///  (sort order not specified)\n', '    function tokenByIndex(uint256 _index) external pure returns (uint256)\n', '    {\n', '        return _index;\n', '    }\n', '\n', '    /// @dev A mapping from Cuties owner (account) to an address that has been approved to call\n', '    ///  transferFrom() for all cuties, owned by owner.\n', '    ///  Only one approved address is permitted for each account for transfer\n', '    ///  at any time. A zero value means there is no outstanding approval.\n', '    mapping (address => address) public addressToApprovedAll;\n', '\n', '    /// @notice Enable or disable approval for a third party ("operator") to manage\n', '    ///  all your asset.\n', '    /// @dev Emits the ApprovalForAll event\n', '    /// @param _operator Address to add to the set of authorized operators.\n', '    /// @param _approved True if the operators is approved, false to revoke approval\n', '    function setApprovalForAll(address _operator, bool _approved) external\n', '    {\n', '        if (_approved)\n', '        {\n', '            addressToApprovedAll[msg.sender] = _operator;\n', '        }\n', '        else\n', '        {\n', '            delete addressToApprovedAll[msg.sender];\n', '        }\n', '        emit ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '\n', '    /// @notice Get the approved address for a single NFT\n', '    /// @dev Throws if `_tokenId` is not a valid NFT\n', '    /// @param _tokenId The NFT to find the approved address for\n', '    /// @return The approved address for this NFT, or the zero address if there is none\n', '    function getApproved(uint256 _tokenId) \n', '        external view canBeStoredIn40Bits(_tokenId) \n', '        returns (address)\n', '    {\n', '        require(_tokenId <= _totalSupply());\n', '\n', '        if (cutieIndexToApproved[uint40(_tokenId)] != address(0))\n', '        {\n', '            return cutieIndexToApproved[uint40(_tokenId)];\n', '        }\n', '\n', '        address owner = cutieIndexToOwner[uint40(_tokenId)];\n', '        return addressToApprovedAll[owner];\n', '    }\n', '\n', '    /// @notice Query if an address is an authorized operator for another address\n', '    /// @param _owner The address that owns the NFTs\n', '    /// @param _operator The address that acts on behalf of the owner\n', '    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool)\n', '    {\n', '        return addressToApprovedAll[_owner] == _operator;\n', '    }\n', '\n', '    function _isApprovedForAll(address _owner, address _operator) internal view returns (bool)\n', '    {\n', '        return addressToApprovedAll[_owner] == _operator;\n', '    }\n', '\n', '    ConfigInterface public config;\n', '\n', '    /// @dev Update the address of the config contract.\n', '    /// @param _address An address of a ConfigInterface contract instance to be used from this point forward.\n', '    function setConfigAddress(address _address) public onlyOwner\n', '    {\n', '        ConfigInterface candidateContract = ConfigInterface(_address);\n', '\n', '        require(candidateContract.isConfig());\n', '\n', '        // Set the new contract address\n', '        config = candidateContract;\n', '    }\n', '\n', '    function getCooldownIndexFromGeneration(uint16 _generation) internal view returns (uint16)\n', '    {\n', '        return config.getCooldownIndexFromGeneration(_generation);\n', '    }\n', '\n', '    /// @dev An internal method that creates a new cutie and stores it. This\n', '    ///  method does not check anything and should only be called when the\n', '    ///  input data is valid for sure. Will generate both a Birth event\n', '    ///  and a Transfer event.\n', '    /// @param _momId The cutie ID of the mom of this cutie (zero for gen0)\n', '    /// @param _dadId The cutie ID of the dad of this cutie (zero for gen0)\n', '    /// @param _generation The generation number of this cutie, must be computed by caller.\n', '    /// @param _genes The cutie&#39;s genetic code.\n', '    /// @param _owner The initial owner of this cutie, must be non-zero (except for the unCutie, ID 0)\n', '    function _createCutie(\n', '        uint40 _momId,\n', '        uint40 _dadId,\n', '        uint16 _generation,\n', '        uint16 _cooldownIndex,\n', '        uint256 _genes,\n', '        address _owner,\n', '        uint40 _birthTime\n', '    )\n', '        internal\n', '        returns (uint40)\n', '    {\n', '        Cutie memory _cutie = Cutie({\n', '            genes: _genes, \n', '            birthTime: _birthTime, \n', '            cooldownEndTime: 0, \n', '            momId: _momId, \n', '            dadId: _dadId, \n', '            cooldownIndex: _cooldownIndex, \n', '            generation: _generation,\n', '            optional: 0\n', '        });\n', '        uint256 newCutieId256 = cuties.push(_cutie) - 1;\n', '\n', '        // Check if id can fit into 40 bits\n', '        require(newCutieId256 <= 0xFFFFFFFFFF);\n', '\n', '        uint40 newCutieId = uint40(newCutieId256);\n', '\n', '        // emit the birth event\n', '        emit Birth(_owner, newCutieId, _cutie.momId, _cutie.dadId, _cutie.genes);\n', '\n', '        // This will assign ownership, as well as emit the Transfer event as\n', '        // per ERC721 draft\n', '        _transfer(0, _owner, newCutieId);\n', '\n', '        return newCutieId;\n', '    }\n', '  \n', '    /// @notice Returns all the relevant information about a certain cutie.\n', '    /// @param _id The ID of the cutie of interest.\n', '    function getCutie(uint40 _id)\n', '        external\n', '        view\n', '        returns (\n', '        uint256 genes,\n', '        uint40 birthTime,\n', '        uint40 cooldownEndTime,\n', '        uint40 momId,\n', '        uint40 dadId,\n', '        uint16 cooldownIndex,\n', '        uint16 generation\n', '    ) {\n', '        Cutie storage cutie = cuties[_id];\n', '\n', '        genes = cutie.genes;\n', '        birthTime = cutie.birthTime;\n', '        cooldownEndTime = cutie.cooldownEndTime;\n', '        momId = cutie.momId;\n', '        dadId = cutie.dadId;\n', '        cooldownIndex = cutie.cooldownIndex;\n', '        generation = cutie.generation;\n', '    }    \n', '    \n', '    /// @dev Assigns ownership of a particular Cutie to an address.\n', '    function _transfer(address _from, address _to, uint40 _cutieId) internal {\n', '        // since the number of cuties is capped to 2^40\n', '        // there is no way to overflow this\n', '        ownershipTokenCount[_to]++;\n', '        // transfer ownership\n', '        cutieIndexToOwner[_cutieId] = _to;\n', '        // When creating new cuties _from is 0x0, but we cannot account that address.\n', '        if (_from != address(0)) {\n', '            ownershipTokenCount[_from]--;\n', '            // once the cutie is transferred also clear breeding allowances\n', '            delete sireAllowedToAddress[_cutieId];\n', '            // clear any previously approved ownership exchange\n', '            delete cutieIndexToApproved[_cutieId];\n', '        }\n', '        // Emit the transfer event.\n', '        emit Transfer(_from, _to, _cutieId);\n', '    }\n', '\n', '    /// @dev For transferring a cutie owned by this contract to the specified address.\n', '    ///  Used to rescue lost cuties. (There is no "proper" flow where this contract\n', '    ///  should be the owner of any Cutie. This function exists for us to reassign\n', '    ///  the ownership of Cuties that users may have accidentally sent to our address.)\n', '    /// @param _cutieId - ID of cutie\n', '    /// @param _recipient - Address to send the cutie to\n', '    function restoreCutieToAddress(uint40 _cutieId, address _recipient) public onlyOperator whenNotPaused {\n', '        require(_isOwner(this, _cutieId));\n', '        _transfer(this, _recipient, _cutieId);\n', '    }\n', '\n', '    address ownerAddress;\n', '    address operatorAddress;\n', '\n', '    bool public paused = false;\n', '\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == ownerAddress);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _newOwner) public onlyOwner\n', '    {\n', '        require(_newOwner != address(0));\n', '\n', '        ownerAddress = _newOwner;\n', '    }\n', '\n', '    modifier onlyOperator() {\n', '        require(msg.sender == operatorAddress || msg.sender == ownerAddress);\n', '        _;\n', '    }\n', '\n', '    function setOperator(address _newOperator) public onlyOwner {\n', '        require(_newOperator != address(0));\n', '\n', '        operatorAddress = _newOperator;\n', '    }\n', '\n', '    modifier whenNotPaused()\n', '    {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused\n', '    {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() public onlyOwner whenNotPaused\n', '    {\n', '        paused = true;\n', '    }\n', '\n', '    string public metadataUrlPrefix = "https://blockchaincuties.co/cutie/";\n', '    string public metadataUrlSuffix = ".svg";\n', '\n', '    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n', '    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n', '    ///  3986. The URI may point to a JSON file that conforms to the "ERC721\n', '    ///  Metadata JSON Schema".\n', '    function tokenURI(uint256 _tokenId) external view returns (string infoUrl)\n', '    {\n', '        return \n', '            concat(toSlice(metadataUrlPrefix), \n', '                toSlice(concat(toSlice(uintToString(_tokenId)), toSlice(metadataUrlSuffix))));\n', '    }\n', '\n', '    function setMetadataUrl(string _metadataUrlPrefix, string _metadataUrlSuffix) public onlyOwner\n', '    {\n', '        metadataUrlPrefix = _metadataUrlPrefix;\n', '        metadataUrlSuffix = _metadataUrlSuffix;\n', '    }\n', '\n', '\n', '    mapping(address => PluginInterface) public plugins;\n', '    PluginInterface[] public pluginsArray;\n', '    mapping(uint40 => address) public usedSignes;\n', '    uint40 public minSignId;\n', '\n', '    event GenesChanged(uint40 indexed cutieId, uint256 oldValue, uint256 newValue);\n', '    event CooldownEndTimeChanged(uint40 indexed cutieId, uint40 oldValue, uint40 newValue);\n', '    event CooldownIndexChanged(uint40 indexed cutieId, uint16 ololdValue, uint16 newValue);\n', '    event GenerationChanged(uint40 indexed cutieId, uint16 oldValue, uint16 newValue);\n', '    event OptionalChanged(uint40 indexed cutieId, uint64 oldValue, uint64 newValue);\n', '    event SignUsed(uint40 signId, address sender);\n', '    event MinSignSet(uint40 signId);\n', '\n', '    /// @dev Sets the reference to the plugin contract.\n', '    /// @param _address - Address of plugin contract.\n', '    function addPlugin(address _address) public onlyOwner\n', '    {\n', '        PluginInterface candidateContract = PluginInterface(_address);\n', '\n', '        // verify that a contract is what we expect\n', '        require(candidateContract.isPluginInterface());\n', '\n', '        // Set the new contract address\n', '        plugins[_address] = candidateContract;\n', '        pluginsArray.push(candidateContract);\n', '    }\n', '\n', '    /// @dev Remove plugin and calls onRemove to cleanup\n', '    function removePlugin(address _address) public onlyOwner\n', '    {\n', '        plugins[_address].onRemove();\n', '        delete plugins[_address];\n', '\n', '        uint256 kindex = 0;\n', '        while (kindex < pluginsArray.length)\n', '        {\n', '            if (address(pluginsArray[kindex]) == _address)\n', '            {\n', '                pluginsArray[kindex] = pluginsArray[pluginsArray.length-1];\n', '                pluginsArray.length--;\n', '            }\n', '            else\n', '            {\n', '                kindex++;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Put a cutie up for plugin feature.\n', '    function runPlugin(\n', '        address _pluginAddress,\n', '        uint40 _cutieId,\n', '        uint256 _parameter\n', '    )\n', '        public\n', '        whenNotPaused\n', '        payable\n', '    {\n', '        // If cutie is already on any auction or in adventure, this will throw\n', '        // because it will be owned by the other contract.\n', '        // If _cutieId is 0, then cutie is not used on this feature.\n', '        require(_cutieId == 0 || _isOwner(msg.sender, _cutieId));\n', '        require(address(plugins[_pluginAddress]) != address(0));\n', '        if (_cutieId > 0)\n', '        {\n', '            _approve(_cutieId, _pluginAddress);\n', '        }\n', '\n', '        // Plugin contract throws if inputs are invalid and clears\n', '        // transfer after escrowing the cutie.\n', '        plugins[_pluginAddress].run.value(msg.value)(\n', '            _cutieId,\n', '            _parameter,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /// @dev Called from plugin contract when using items as effect\n', '    function getGenes(uint40 _id)\n', '        public\n', '        view\n', '        returns (\n', '        uint256 genes\n', '    )\n', '    {\n', '        Cutie storage cutie = cuties[_id];\n', '        genes = cutie.genes;\n', '    }\n', '\n', '    /// @dev Called from plugin contract when using items as effect\n', '    function changeGenes(\n', '        uint40 _cutieId,\n', '        uint256 _genes)\n', '        public\n', '        whenNotPaused\n', '    {\n', '        // if caller is registered plugin contract\n', '        require(address(plugins[msg.sender]) != address(0));\n', '\n', '        Cutie storage cutie = cuties[_cutieId];\n', '        if (cutie.genes != _genes)\n', '        {\n', '            emit GenesChanged(_cutieId, cutie.genes, _genes);\n', '            cutie.genes = _genes;\n', '        }\n', '    }\n', '\n', '    function getCooldownEndTime(uint40 _id)\n', '        public\n', '        view\n', '        returns (\n', '        uint40 cooldownEndTime\n', '    ) {\n', '        Cutie storage cutie = cuties[_id];\n', '\n', '        cooldownEndTime = cutie.cooldownEndTime;\n', '    }\n', '\n', '    function changeCooldownEndTime(\n', '        uint40 _cutieId,\n', '        uint40 _cooldownEndTime)\n', '        public\n', '        whenNotPaused\n', '    {\n', '        require(address(plugins[msg.sender]) != address(0));\n', '\n', '        Cutie storage cutie = cuties[_cutieId];\n', '        if (cutie.cooldownEndTime != _cooldownEndTime)\n', '        {\n', '            emit CooldownEndTimeChanged(_cutieId, cutie.cooldownEndTime, _cooldownEndTime);\n', '            cutie.cooldownEndTime = _cooldownEndTime;\n', '        }\n', '    }\n', '\n', '    function getCooldownIndex(uint40 _id)\n', '        public\n', '        view\n', '        returns (\n', '        uint16 cooldownIndex\n', '    ) {\n', '        Cutie storage cutie = cuties[_id];\n', '\n', '        cooldownIndex = cutie.cooldownIndex;\n', '    }\n', '\n', '    function changeCooldownIndex(\n', '        uint40 _cutieId,\n', '        uint16 _cooldownIndex)\n', '        public\n', '        whenNotPaused\n', '    {\n', '        require(address(plugins[msg.sender]) != address(0));\n', '\n', '        Cutie storage cutie = cuties[_cutieId];\n', '        if (cutie.cooldownIndex != _cooldownIndex)\n', '        {\n', '            emit CooldownIndexChanged(_cutieId, cutie.cooldownIndex, _cooldownIndex);\n', '            cutie.cooldownIndex = _cooldownIndex;\n', '        }\n', '    }\n', '\n', '    function changeGeneration(\n', '        uint40 _cutieId,\n', '        uint16 _generation)\n', '        public\n', '        whenNotPaused\n', '    {\n', '        require(address(plugins[msg.sender]) != address(0));\n', '\n', '        Cutie storage cutie = cuties[_cutieId];\n', '        if (cutie.generation != _generation)\n', '        {\n', '            emit GenerationChanged(_cutieId, cutie.generation, _generation);\n', '            cutie.generation = _generation;\n', '        }\n', '    }\n', '\n', '    function getGeneration(uint40 _id)\n', '        public\n', '        view\n', '        returns (uint16 generation)\n', '    {\n', '        Cutie storage cutie = cuties[_id];\n', '        generation = cutie.generation;\n', '    }\n', '\n', '    function changeOptional(\n', '        uint40 _cutieId,\n', '        uint64 _optional)\n', '        public\n', '        whenNotPaused\n', '    {\n', '        require(address(plugins[msg.sender]) != address(0));\n', '\n', '        Cutie storage cutie = cuties[_cutieId];\n', '        if (cutie.optional != _optional)\n', '        {\n', '            emit OptionalChanged(_cutieId, cutie.optional, _optional);\n', '            cutie.optional = _optional;\n', '        }\n', '    }\n', '\n', '    function getOptional(uint40 _id)\n', '        public\n', '        view\n', '        returns (uint64 optional)\n', '    {\n', '        Cutie storage cutie = cuties[_id];\n', '        optional = cutie.optional;\n', '    }\n', '\n', '    /// @dev Common function to be used also in backend\n', '    function hashArguments(\n', '        address _pluginAddress,\n', '        uint40 _signId,\n', '        uint40 _cutieId,\n', '        uint128 _value,\n', '        uint256 _parameter)\n', '        public pure returns (bytes32 msgHash)\n', '    {\n', '        msgHash = keccak256(_pluginAddress, _signId, _cutieId, _value, _parameter);\n', '    }\n', '\n', '    /// @dev Common function to be used also in backend\n', '    function getSigner(\n', '        address _pluginAddress,\n', '        uint40 _signId,\n', '        uint40 _cutieId,\n', '        uint128 _value,\n', '        uint256 _parameter,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '        )\n', '        public pure returns (address)\n', '    {\n', '        bytes32 msgHash = hashArguments(_pluginAddress, _signId, _cutieId, _value, _parameter);\n', '        return ecrecover(msgHash, _v, _r, _s);\n', '    }\n', '\n', '    /// @dev Common function to be used also in backend\n', '    function isValidSignature(\n', '        address _pluginAddress,\n', '        uint40 _signId,\n', '        uint40 _cutieId,\n', '        uint128 _value,\n', '        uint256 _parameter,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '        )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return getSigner(_pluginAddress, _signId, _cutieId, _value, _parameter, _v, _r, _s) == operatorAddress;\n', '    }\n', '\n', '    /// @dev Put a cutie up for plugin feature with signature.\n', '    ///  Can be used for items equip, item sales and other features.\n', '    ///  Signatures are generated by Operator role.\n', '    function runPluginSigned(\n', '        address _pluginAddress,\n', '        uint40 _signId,\n', '        uint40 _cutieId,\n', '        uint128 _value,\n', '        uint256 _parameter,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        public\n', '        whenNotPaused\n', '        payable\n', '    {\n', '        // If cutie is already on any auction or in adventure, this will throw\n', '        // as it will be owned by the other contract.\n', '        // If _cutieId is 0, then cutie is not used on this feature.\n', '        require(_cutieId == 0 || _isOwner(msg.sender, _cutieId));\n', '    \n', '        require(address(plugins[_pluginAddress]) != address(0));    \n', '\n', '        require (usedSignes[_signId] == address(0));\n', '        require (_signId >= minSignId);\n', '        // value can also be zero for free calls\n', '        require (_value <= msg.value);\n', '\n', '        require (isValidSignature(_pluginAddress, _signId, _cutieId, _value, _parameter, _v, _r, _s));\n', '        \n', '        usedSignes[_signId] = msg.sender;\n', '        emit SignUsed(_signId, msg.sender);\n', '\n', '        // Plugin contract throws if inputs are invalid and clears\n', '        // transfer after escrowing the cutie.\n', '        plugins[_pluginAddress].runSigned.value(_value)(\n', '            _cutieId,\n', '            _parameter,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /// @dev Sets minimal signId, than can be used.\n', '    ///       All unused signatures less than signId will be cancelled on off-chain server\n', '    ///       and unused items will be transfered back to owner.\n', '    function setMinSign(uint40 _newMinSignId)\n', '        public\n', '        onlyOperator\n', '    {\n', '        require (_newMinSignId > minSignId);\n', '        minSignId = _newMinSignId;\n', '        emit MinSignSet(minSignId);\n', '    }\n', '\n', '\n', '    event BreedingApproval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '    // Set in case the core contract is broken and an upgrade is required\n', '    address public upgradedContractAddress;\n', '\n', '    function isCutieCore() pure public returns (bool) { return true; }\n', '\n', '    /// @notice Creates the main BlockchainCuties smart contract instance.\n', '    function BlockchainCutiesCore() public\n', '    {\n', '        // Starts paused.\n', '        paused = true;\n', '\n', '        // the creator of the contract is the initial owner\n', '        ownerAddress = msg.sender;\n', '\n', '        // the creator of the contract is also the initial operator\n', '        operatorAddress = msg.sender;\n', '\n', '        // start with the mythical cutie 0 - so there are no generation-0 parent issues\n', '        _createCutie(0, 0, 0, 0, uint256(-1), address(0), 0);\n', '    }\n', '\n', '    event ContractUpgrade(address newContract);\n', '\n', '    /// @dev Aimed to mark the smart contract as upgraded if there is a crucial\n', '    ///  bug. This keeps track of the new contract and indicates that the new address is set. \n', '    /// Updating to the new contract address is up to the clients. (This contract will\n', '    ///  be paused indefinitely if such an upgrade takes place.)\n', '    /// @param _newAddress new address\n', '    function setUpgradedAddress(address _newAddress) public onlyOwner whenPaused\n', '    {\n', '        require(_newAddress != address(0));\n', '        upgradedContractAddress = _newAddress;\n', '        emit ContractUpgrade(upgradedContractAddress);\n', '    }\n', '\n', '    /// @dev Import cuties from previous version of Core contract.\n', '    /// @param _oldAddress Old core contract address\n', '    /// @param _fromIndex (inclusive)\n', '    /// @param _toIndex (inclusive)\n', '    function migrate(address _oldAddress, uint40 _fromIndex, uint40 _toIndex) public onlyOwner whenPaused\n', '    {\n', '        require(_totalSupply() + 1 == _fromIndex);\n', '\n', '        BlockchainCutiesCore old = BlockchainCutiesCore(_oldAddress);\n', '\n', '        for (uint40 i = _fromIndex; i <= _toIndex; i++)\n', '        {\n', '            uint256 genes;\n', '            uint40 birthTime;\n', '            uint40 cooldownEndTime;\n', '            uint40 momId;\n', '            uint40 dadId;\n', '            uint16 cooldownIndex;\n', '            uint16 generation;            \n', '            (genes, birthTime, cooldownEndTime, momId, dadId, cooldownIndex, generation) = old.getCutie(i);\n', '\n', '            Cutie memory _cutie = Cutie({\n', '                genes: genes, \n', '                birthTime: birthTime, \n', '                cooldownEndTime: cooldownEndTime, \n', '                momId: momId, \n', '                dadId: dadId, \n', '                cooldownIndex: cooldownIndex, \n', '                generation: generation,\n', '                optional: 0\n', '            });\n', '            cuties.push(_cutie);\n', '        }\n', '    }\n', '\n', '    /// @dev Import cuties from previous version of Core contract (part 2).\n', '    /// @param _oldAddress Old core contract address\n', '    /// @param _fromIndex (inclusive)\n', '    /// @param _toIndex (inclusive)\n', '    function migrate2(address _oldAddress, uint40 _fromIndex, uint40 _toIndex, address saleAddress, address breedingAddress) public onlyOwner whenPaused\n', '    {\n', '        BlockchainCutiesCore old = BlockchainCutiesCore(_oldAddress);\n', '        MarketInterface oldSaleMarket = MarketInterface(saleAddress);\n', '        MarketInterface oldBreedingMarket = MarketInterface(breedingAddress);\n', '\n', '        for (uint40 i = _fromIndex; i <= _toIndex; i++)\n', '        {\n', '            address owner = old.ownerOf(i);\n', '\n', '            if (owner == saleAddress)\n', '            {\n', '                (owner,,,,,) = oldSaleMarket.getAuctionInfo(i);\n', '            }\n', '\n', '            if (owner == breedingAddress)\n', '            {\n', '                (owner,,,,,) = oldBreedingMarket.getAuctionInfo(i);\n', '            }\n', '            _transfer(0, owner, i);\n', '        }\n', '    }\n', '\n', '    /// @dev Override unpause so it requires upgradedContractAddress not set, because then the contract was upgraded.\n', '    function unpause() public onlyOwner whenPaused\n', '    {\n', '        require(upgradedContractAddress == address(0));\n', '\n', '        paused = false;\n', '    }\n', '\n', '    // Counts the number of cuties the contract owner has created.\n', '    uint40 public promoCutieCreatedCount;\n', '    uint40 public gen0CutieCreatedCount;\n', '    uint40 public gen0Limit = 50000;\n', '    uint40 public promoLimit = 5000;\n', '\n', '    /// @dev Creates a new gen0 cutie with the given genes and\n', '    ///  creates an auction for it.\n', '    function createGen0Auction(uint256 _genes, uint128 startPrice, uint128 endPrice, uint40 duration) public onlyOperator\n', '    {\n', '        require(gen0CutieCreatedCount < gen0Limit);\n', '        uint40 cutieId = _createCutie(0, 0, 0, 0, _genes, address(this), uint40(now));\n', '        _approve(cutieId, saleMarket);\n', '\n', '        saleMarket.createAuction(\n', '            cutieId,\n', '            startPrice,\n', '            endPrice,\n', '            duration,\n', '            address(this)\n', '        );\n', '\n', '        gen0CutieCreatedCount++;\n', '    }\n', '\n', '    function createPromoCutie(uint256 _genes, address _owner) public onlyOperator\n', '    {\n', '        require(promoCutieCreatedCount < promoLimit);\n', '        if (_owner == address(0)) {\n', '             _owner = operatorAddress;\n', '        }\n', '        promoCutieCreatedCount++;\n', '        gen0CutieCreatedCount++;\n', '        _createCutie(0, 0, 0, 0, _genes, _owner, uint40(now));\n', '    }\n', '\n', '    /// @dev Put a cutie up for auction to be dad.\n', '    ///  Performs checks to ensure the cutie can be dad, then\n', '    ///  delegates to reverse auction.\n', '    ///  Optional money amount can be sent to contract to feature auction.\n', '    ///  Pricea are available on web.\n', '    function createBreedingAuction(\n', '        uint40 _cutieId,\n', '        uint128 _startPrice,\n', '        uint128 _endPrice,\n', '        uint40 _duration\n', '    )\n', '        public\n', '        whenNotPaused\n', '        payable\n', '    {\n', '        // Auction contract checks input sizes\n', '        // If cutie is already on any auction, this will throw\n', '        // because it will be owned by the auction contract.\n', '        require(_isOwner(msg.sender, _cutieId));\n', '        require(canBreed(_cutieId));\n', '        _approve(_cutieId, breedingMarket);\n', '        // breeding auction function is called if inputs are invalid and clears\n', '        // transfer and sire approval after escrowing the cutie.\n', '        breedingMarket.createAuction.value(msg.value)(\n', '            _cutieId,\n', '            _startPrice,\n', '            _endPrice,\n', '            _duration,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /// @dev Sets the reference to the breeding auction.\n', '    /// @param _breedingAddress - Address of breeding market contract.\n', '    /// @param _saleAddress - Address of sale market contract.\n', '    function setMarketAddress(address _breedingAddress, address _saleAddress) public onlyOwner\n', '    {\n', '        //require(address(breedingMarket) == address(0));\n', '        //require(address(saleMarket) == address(0));\n', '\n', '        breedingMarket = MarketInterface(_breedingAddress);\n', '        saleMarket = MarketInterface(_saleAddress);\n', '    }\n', '\n', '    /// @dev Completes a breeding auction by bidding.\n', '    ///  Immediately breeds the winning mom with the dad on auction.\n', '    /// @param _dadId - ID of the dad on auction.\n', '    /// @param _momId - ID of the mom owned by the bidder.\n', '    function bidOnBreedingAuction(\n', '        uint40 _dadId,\n', '        uint40 _momId\n', '    )\n', '        public\n', '        payable\n', '        whenNotPaused\n', '        returns (uint256)\n', '    {\n', '        // Auction contract checks input sizes\n', '        require(_isOwner(msg.sender, _momId));\n', '        require(canBreed(_momId));\n', '        require(_canMateViaMarketplace(_momId, _dadId));\n', '        // Take breeding fee\n', '        uint256 fee = getBreedingFee(_momId, _dadId);\n', '        require(msg.value >= fee);\n', '\n', '        // breeding auction will throw if the bid fails.\n', '        breedingMarket.bid.value(msg.value - fee)(_dadId);\n', '        return _breedWith(_momId, _dadId);\n', '    }\n', '\n', '    /// @dev Put a cutie up for auction.\n', '    ///  Does some ownership trickery for creating auctions in one transaction.\n', '    ///  Optional money amount can be sent to contract to feature auction.\n', '    ///  Pricea are available on web.\n', '    function createSaleAuction(\n', '        uint40 _cutieId,\n', '        uint128 _startPrice,\n', '        uint128 _endPrice,\n', '        uint40 _duration\n', '    )\n', '        public\n', '        whenNotPaused\n', '        payable\n', '    {\n', '        // Auction contract checks input sizes\n', '        // If cutie is already on any auction, this will throw\n', '        // because it will be owned by the auction contract.\n', '        require(_isOwner(msg.sender, _cutieId));\n', '        _approve(_cutieId, saleMarket);\n', '        // Sale auction throws if inputs are invalid and clears\n', '        // transfer and sire approval after escrowing the cutie.\n', '        saleMarket.createAuction.value(msg.value)(\n', '            _cutieId,\n', '            _startPrice,\n', '            _endPrice,\n', '            _duration,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /// @dev The address of the sibling contract that is used to implement the genetic combination algorithm.\n', '    GeneMixerInterface geneMixer;\n', '\n', '    /// @dev Check if dad has authorized breeding with the mom. True if both dad\n', '    ///  and mom have the same owner, or if the dad has given breeding permission to\n', '    ///  the mom&#39;s owner (via approveBreeding()).\n', '    function _isBreedingPermitted(uint40 _dadId, uint40 _momId) internal view returns (bool)\n', '    {\n', '        address momOwner = cutieIndexToOwner[_momId];\n', '        address dadOwner = cutieIndexToOwner[_dadId];\n', '\n', '        // Breeding is approved if they have same owner, or if the mom&#39;s owner was given\n', '        // permission to breed with the dad.\n', '        return (momOwner == dadOwner || sireAllowedToAddress[_dadId] == momOwner);\n', '    }\n', '\n', '    /// @dev Update the address of the genetic contract.\n', '    /// @param _address An address of a GeneMixer contract instance to be used from this point forward.\n', '    function setGeneMixerAddress(address _address) public onlyOwner\n', '    {\n', '        GeneMixerInterface candidateContract = GeneMixerInterface(_address);\n', '\n', '        require(candidateContract.isGeneMixer());\n', '\n', '        // Set the new contract address\n', '        geneMixer = candidateContract;\n', '    }\n', '\n', '    /// @dev Checks that a given cutie is able to breed. Requires that the\n', '    ///  current cooldown is finished (for dads)\n', '    function _canBreed(Cutie _cutie) internal view returns (bool)\n', '    {\n', '        return _cutie.cooldownEndTime <= now;\n', '    }\n', '\n', '    /// @notice Grants approval to another user to sire with one of your Cuties.\n', '    /// @param _addr The address that will be able to sire with your Cutie. Set to\n', '    ///  address(0) to clear all breeding approvals for this Cutie.\n', '    /// @param _dadId A Cutie that you own that _addr will now be able to dad with.\n', '    function approveBreeding(address _addr, uint40 _dadId) public whenNotPaused\n', '    {\n', '        require(_isOwner(msg.sender, _dadId));\n', '        sireAllowedToAddress[_dadId] = _addr;\n', '        emit BreedingApproval(msg.sender, _addr, _dadId);\n', '    }\n', '\n', '    /// @dev Set the cooldownEndTime for the given Cutie, based on its current cooldownIndex.\n', '    ///  Also increments the cooldownIndex (unless it has hit the cap).\n', '    /// @param _cutie A reference to the Cutie in storage which needs its timer started.\n', '    function _triggerCooldown(uint40 _cutieId, Cutie storage _cutie) internal\n', '    {\n', '        // Compute the end of the cooldown time, based on current cooldownIndex\n', '        uint40 oldValue = _cutie.cooldownIndex;\n', '        _cutie.cooldownEndTime = config.getCooldownEndTimeFromIndex(_cutie.cooldownIndex);\n', '        emit CooldownEndTimeChanged(_cutieId, oldValue, _cutie.cooldownEndTime);\n', '\n', '        // Increment the breeding count.\n', '        if (_cutie.cooldownIndex + 1 < config.getCooldownIndexCount()) {\n', '            uint16 oldValue2 = _cutie.cooldownIndex;\n', '            _cutie.cooldownIndex++;\n', '            emit CooldownIndexChanged(_cutieId, oldValue2, _cutie.cooldownIndex);\n', '        }\n', '    }\n', '\n', '    /// @notice Checks that a certain cutie is not\n', '    ///  in the middle of a breeding cooldown and is able to breed.\n', '    /// @param _cutieId reference the id of the cutie, any user can inquire about it\n', '    function canBreed(uint40 _cutieId)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        require(_cutieId > 0);\n', '        Cutie storage cutie = cuties[_cutieId];\n', '        return _canBreed(cutie);\n', '    }\n', '\n', '    /// @dev Check if given mom and dad are a valid mating pair.\n', '    function _canPairMate(\n', '        Cutie storage _mom,\n', '        uint40 _momId,\n', '        Cutie storage _dad,\n', '        uint40 _dadId\n', '    )\n', '        private\n', '        view\n', '        returns(bool)\n', '    {\n', '        // A Cutie can&#39;t breed with itself.\n', '        if (_dadId == _momId) { \n', '            return false; \n', '        }\n', '\n', '        // Cuties can&#39;t breed with their parents.\n', '        if (_mom.momId == _dadId) {\n', '            return false;\n', '        }\n', '        if (_mom.dadId == _dadId) {\n', '            return false;\n', '        }\n', '\n', '        if (_dad.momId == _momId) {\n', '            return false;\n', '        }\n', '        if (_dad.dadId == _momId) {\n', '            return false;\n', '        }\n', '\n', '        // We can short circuit the sibling check (below) if either cat is\n', '        // gen zero (has a mom ID of zero).\n', '        if (_dad.momId == 0) {\n', '            return true;\n', '        }\n', '        if (_mom.momId == 0) {\n', '            return true;\n', '        }\n', '\n', '        // Cuties can&#39;t breed with full or half siblings.\n', '        if (_dad.momId == _mom.momId) {\n', '            return false;\n', '        }\n', '        if (_dad.momId == _mom.dadId) {\n', '            return false;\n', '        }\n', '        if (_dad.dadId == _mom.momId) {\n', '            return false;\n', '        }\n', '        if (_dad.dadId == _mom.dadId) {\n', '            return false;\n', '        }\n', '\n', '        if (geneMixer.canBreed(_momId, _mom.genes, _dadId, _dad.genes)) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /// @notice Checks to see if two cuties can breed together (checks both\n', '    ///  ownership and breeding approvals, but does not check if both cuties are ready for\n', '    ///  breeding).\n', '    /// @param _momId The ID of the proposed mom.\n', '    /// @param _dadId The ID of the proposed dad.\n', '    function canBreedWith(uint40 _momId, uint40 _dadId)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        require(_momId > 0);\n', '        require(_dadId > 0);\n', '        Cutie storage mom = cuties[_momId];\n', '        Cutie storage dad = cuties[_dadId];\n', '        return _canPairMate(mom, _momId, dad, _dadId) && _isBreedingPermitted(_dadId, _momId);\n', '    }\n', '    \n', '    /// @dev Internal check to see if a given dad and mom are a valid mating pair for\n', '    ///  breeding via market (this method doesn&#39;t check ownership and if mating is allowed).\n', '    function _canMateViaMarketplace(uint40 _momId, uint40 _dadId)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        Cutie storage mom = cuties[_momId];\n', '        Cutie storage dad = cuties[_dadId];\n', '        return _canPairMate(mom, _momId, dad, _dadId);\n', '    }\n', '\n', '    function getBreedingFee(uint40 _momId, uint40 _dadId)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return config.getBreedingFee(_momId, _dadId);\n', '    }\n', '\n', '\n', '    /// @notice Breed cuties that you own, or for which you\n', '    ///  have previously been given Breeding approval. Will either make your cutie give birth, or will\n', '    ///  fail.\n', '    /// @param _momId The ID of the Cutie acting as mom (will end up give birth if successful)\n', '    /// @param _dadId The ID of the Cutie acting as dad (will begin its breeding cooldown if successful)\n', '    function breedWith(uint40 _momId, uint40 _dadId) \n', '        public\n', '        whenNotPaused\n', '        payable\n', '        returns (uint40)\n', '    {\n', '        // Caller must own the mom.\n', '        require(_isOwner(msg.sender, _momId));\n', '\n', '        // Neither dad nor mom can be on auction during\n', '        // breeding.\n', '        // For mom: The caller of this function can&#39;t be the owner of the mom\n', '        //   because the owner of a Cutie on auction is the auction house, and the\n', '        //   auction house will never call breedWith().\n', '        // For dad: Similarly, a dad on auction will be owned by the auction house\n', '        //   and the act of transferring ownership will have cleared any outstanding\n', '        //   breeding approval.\n', '        // Thus we don&#39;t need check if either cutie\n', '        // is on auction.\n', '\n', '        // Check that mom and dad are both owned by caller, or that the dad\n', '        // has given breeding permission to caller (i.e. mom&#39;s owner).\n', '        // Will fail for _dadId = 0\n', '        require(_isBreedingPermitted(_dadId, _momId));\n', '\n', '        // Check breeding fee\n', '        require(getBreedingFee(_momId, _dadId) <= msg.value);\n', '\n', '        // Grab a reference to the potential mom\n', '        Cutie storage mom = cuties[_momId];\n', '\n', '        // Make sure mom&#39;s cooldown isn&#39;t active, or in the middle of a breeding cooldown\n', '        require(_canBreed(mom));\n', '\n', '        // Grab a reference to the potential dad\n', '        Cutie storage dad = cuties[_dadId];\n', '\n', '        // Make sure dad cooldown isn&#39;t active, or in the middle of a breeding cooldown\n', '        require(_canBreed(dad));\n', '\n', '        // Test that these cuties are a valid mating pair.\n', '        require(_canPairMate(\n', '            mom,\n', '            _momId,\n', '            dad,\n', '            _dadId\n', '        ));\n', '\n', '        return _breedWith(_momId, _dadId);\n', '    }\n', '\n', '    /// @dev Internal utility function to start breeding, assumes that all breeding\n', '    ///  requirements have been checked.\n', '    function _breedWith(uint40 _momId, uint40 _dadId) internal returns (uint40)\n', '    {\n', '        // Grab a reference to the Cuties from storage.\n', '        Cutie storage dad = cuties[_dadId];\n', '        Cutie storage mom = cuties[_momId];\n', '\n', '        // Trigger the cooldown for both parents.\n', '        _triggerCooldown(_dadId, dad);\n', '        _triggerCooldown(_momId, mom);\n', '\n', '        // Clear breeding permission for both parents.\n', '        delete sireAllowedToAddress[_momId];\n', '        delete sireAllowedToAddress[_dadId];\n', '\n', '        // Check that the mom is a valid cutie.\n', '        require(mom.birthTime != 0);\n', '\n', '        // Determine the higher generation number of the two parents\n', '        uint16 babyGen = config.getBabyGen(mom.generation, dad.generation);\n', '\n', '        // Call the gene mixing operation.\n', '        uint256 childGenes = geneMixer.mixGenes(mom.genes, dad.genes);\n', '\n', '        // Make the new cutie\n', '        address owner = cutieIndexToOwner[_momId];\n', '        uint40 cutieId = _createCutie(_momId, _dadId, babyGen, getCooldownIndexFromGeneration(babyGen), childGenes, owner, mom.cooldownEndTime);\n', '\n', '        // return the new cutie&#39;s ID\n', '        return cutieId;\n', '    }\n', '\n', '    mapping(address => uint40) isTutorialPetUsed;\n', '\n', '    /// @dev Completes a breeding tutorial cutie (non existing in blockchain)\n', '    ///  with auction by bidding. Immediately breeds with dad on auction.\n', '    /// @param _dadId - ID of the dad on auction.\n', '    function bidOnBreedingAuctionTutorial(\n', '        uint40 _dadId\n', '    )\n', '        public\n', '        payable\n', '        whenNotPaused\n', '        returns (uint)\n', '    {\n', '        require(isTutorialPetUsed[msg.sender] == 0);\n', '\n', '        // Take breeding fee\n', '        uint256 fee = getBreedingFee(0, _dadId);\n', '        require(msg.value >= fee);\n', '\n', '        // breeding auction will throw if the bid fails.\n', '        breedingMarket.bid.value(msg.value - fee)(_dadId);\n', '\n', '        // Grab a reference to the Cuties from storage.\n', '        Cutie storage dad = cuties[_dadId];\n', '\n', '        // Trigger the cooldown for parent.\n', '        _triggerCooldown(_dadId, dad);\n', '\n', '        // Clear breeding permission for parent.\n', '        delete sireAllowedToAddress[_dadId];\n', '\n', '        uint16 babyGen = config.getTutorialBabyGen(dad.generation);\n', '\n', '        // tutorial pet genome is zero\n', '        uint256 childGenes = geneMixer.mixGenes(0x0, dad.genes);\n', '\n', '        // tutorial pet id is zero\n', '        uint40 cutieId = _createCutie(0, _dadId, babyGen, getCooldownIndexFromGeneration(babyGen), childGenes, msg.sender, 12);\n', '\n', '        isTutorialPetUsed[msg.sender] = cutieId;\n', '\n', '        // return the new cutie&#39;s ID\n', '        return cutieId;\n', '    }\n', '\n', '    address party1address;\n', '    address party2address;\n', '    address party3address;\n', '    address party4address;\n', '    address party5address;\n', '\n', '    /// @dev Setup project owners\n', '    function setParties(address _party1, address _party2, address _party3, address _party4, address _party5) public onlyOwner\n', '    {\n', '        require(_party1 != address(0));\n', '        require(_party2 != address(0));\n', '        require(_party3 != address(0));\n', '        require(_party4 != address(0));\n', '        require(_party5 != address(0));\n', '\n', '        party1address = _party1;\n', '        party2address = _party2;\n', '        party3address = _party3;\n', '        party4address = _party4;\n', '        party5address = _party5;\n', '    }\n', '\n', '    /// @dev Reject all Ether which is not from game contracts from being sent here.\n', '    function() external payable {\n', '        require(\n', '            msg.sender == address(saleMarket) ||\n', '            msg.sender == address(breedingMarket) ||\n', '            address(plugins[msg.sender]) != address(0)\n', '        );\n', '    }\n', '\n', '    /// @dev The balance transfer from the market and plugins contract\n', '    /// to the CutieCore contract.\n', '    function withdrawBalances() external\n', '    {\n', '        require(\n', '            msg.sender == ownerAddress || \n', '            msg.sender == operatorAddress);\n', '\n', '        saleMarket.withdrawEthFromBalance();\n', '        breedingMarket.withdrawEthFromBalance();\n', '        for (uint32 i = 0; i < pluginsArray.length; ++i)        \n', '        {\n', '            pluginsArray[i].withdraw();\n', '        }\n', '    }\n', '\n', '    /// @dev The balance transfer from CutieCore contract to project owners\n', '    function withdrawEthFromBalance() external\n', '    {\n', '        require(\n', '            msg.sender == party1address ||\n', '            msg.sender == party2address ||\n', '            msg.sender == party3address ||\n', '            msg.sender == party4address ||\n', '            msg.sender == party5address ||\n', '            msg.sender == ownerAddress || \n', '            msg.sender == operatorAddress);\n', '\n', '        require(party1address != 0);\n', '        require(party2address != 0);\n', '        require(party3address != 0);\n', '        require(party4address != 0);\n', '        require(party5address != 0);\n', '\n', '        uint256 total = address(this).balance;\n', '\n', '        party1address.transfer(total*105/1000);\n', '        party2address.transfer(total*105/1000);\n', '        party3address.transfer(total*140/1000);\n', '        party4address.transfer(total*140/1000);\n', '        party5address.transfer(total*510/1000);\n', '    }\n', '\n', '/*\n', ' * @title String & slice utility library for Solidity contracts.\n', ' * @author Nick Johnson <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9afbe8fbf9f2f4f3fedaf4f5eefef5eeb4f4ffee">[email&#160;protected]</a>>\n', ' *\n', ' * @dev Functionality in this library is largely implemented using an\n', ' *      abstraction called a &#39;slice&#39;. A slice represents a part of a string -\n', ' *      anything from the entire string to a single character, or even no\n', ' *      characters at all (a 0-length slice). Since a slice only has to specify\n', ' *      an offset and a length, copying and manipulating slices is a lot less\n', ' *      expensive than copying and manipulating the strings they reference.\n', ' *\n', ' *      To further reduce gas costs, most functions on slice that need to return\n', ' *      a slice modify the original one instead of allocating a new one; for\n', ' *      instance, `s.split(".")` will return the text up to the first &#39;.&#39;,\n', ' *      modifying s to only contain the remainder of the string after the &#39;.&#39;.\n', ' *      In situations where you do not want to modify the original slice, you\n', ' *      can make a copy first with `.copy()`, for example:\n', ' *      `s.copy().split(".")`. Try and avoid using this idiom in loops; since\n', ' *      Solidity has no memory management, it will result in allocating many\n', ' *      short-lived slices that are later discarded.\n', ' *\n', ' *      Functions that return two slices come in two versions: a non-allocating\n', ' *      version that takes the second slice as an argument, modifying it in\n', ' *      place, and an allocating version that allocates and returns the second\n', ' *      slice; see `nextRune` for example.\n', ' *\n', ' *      Functions that have to copy string data will return strings rather than\n', ' *      slices; these can be cast back to slices for further processing if\n', ' *      required.\n', ' *\n', ' *      For convenience, some functions are provided with non-modifying\n', ' *      variants that create a new slice and return both; for instance,\n', ' *      `s.splitNew(&#39;.&#39;)` leaves s unmodified, and returns two values\n', ' *      corresponding to the left and right parts of the string.\n', ' */\n', '\n', '    struct slice\n', '    {\n', '        uint _len;\n', '        uint _ptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire string.\n', '     * @param self The string to make a slice from.\n', '     * @return A newly allocated slice containing the entire string.\n', '     */\n', '    function toSlice(string self) internal pure returns (slice)\n', '    {\n', '        uint ptr;\n', '        assembly {\n', '            ptr := add(self, 0x20)\n', '        }\n', '        return slice(bytes(self).length, ptr);\n', '    }\n', '\n', '    function memcpy(uint dest, uint src, uint len) private pure\n', '    {\n', '        // Copy word-length chunks while possible\n', '        for(; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a newly allocated string containing the concatenation of\n', '     *      `self` and `other`.\n', '     * @param self The first slice to concatenate.\n', '     * @param other The second slice to concatenate.\n', '     * @return The concatenation of the two strings.\n', '     */\n', '    function concat(slice self, slice other) internal pure returns (string)\n', '    {\n', '        string memory ret = new string(self._len + other._len);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '        memcpy(retptr, self._ptr, self._len);\n', '        memcpy(retptr + self._len, other._ptr, other._len);\n', '        return ret;\n', '    }\n', '\n', '\n', '    function uintToString(uint256 a) internal pure returns (string result)\n', '    {\n', '        string memory r = "";\n', '        do\n', '        {\n', '            uint b = a % 10;\n', '            a /= 10;\n', '\n', '            string memory c = "";\n', '\n', '            if (b == 0) c = "0";\n', '            else if (b == 1) c = "1";\n', '            else if (b == 2) c = "2";\n', '            else if (b == 3) c = "3";\n', '            else if (b == 4) c = "4";\n', '            else if (b == 5) c = "5";\n', '            else if (b == 6) c = "6";\n', '            else if (b == 7) c = "7";\n', '            else if (b == 8) c = "8";\n', '            else if (b == 9) c = "9";\n', '\n', '            r = concat(toSlice(c), toSlice(r));\n', '        }\n', '        while (a > 0);\n', '        result = r;\n', '    }\n', '}']
['pragma solidity ^0.4.20;\n', '\n', '/// BlockchainCuties: Collectible and breedable cuties on the Ethereum blockchain.\n', '/// https://blockchaincuties.co/\n', '\n', '\n', '/// @title defined the interface that will be referenced in main Cutie contract\n', 'contract GeneMixerInterface {\n', '    /// @dev simply a boolean to indicate this is the contract we expect to be\n', '    function isGeneMixer() external pure returns (bool);\n', '\n', '    /// @dev given genes of cutie 1 & 2, return a genetic combination - may have a random factor\n', '    /// @param genes1 genes of mom\n', '    /// @param genes2 genes of dad\n', '    /// @return the genes that are supposed to be passed down the child\n', '    function mixGenes(uint256 genes1, uint256 genes2) public view returns (uint256);\n', '\n', '    function canBreed(uint40 momId, uint256 genes1, uint40 dadId, uint256 genes2) public view returns (bool);\n', '}\n', '\n', '\n', '\n', '/// @author https://BlockChainArchitect.iocontract Bank is CutiePluginBase\n', 'contract PluginInterface\n', '{\n', '    /// @dev simply a boolean to indicate this is the contract we expect to be\n', '    function isPluginInterface() public pure returns (bool);\n', '\n', '    function onRemove() public;\n', '\n', '    /// @dev Begins new feature.\n', '    /// @param _cutieId - ID of token to auction, sender must be owner.\n', '    /// @param _parameter - arbitrary parameter\n', '    /// @param _seller - Old owner, if not the message sender\n', '    function run(\n', '        uint40 _cutieId,\n', '        uint256 _parameter,\n', '        address _seller\n', '    ) \n', '    public\n', '    payable;\n', '\n', '    /// @dev Begins new feature, approved and signed by COO.\n', '    /// @param _cutieId - ID of token to auction, sender must be owner.\n', '    /// @param _parameter - arbitrary parameter\n', '    function runSigned(\n', '        uint40 _cutieId,\n', '        uint256 _parameter,\n', '        address _owner\n', '    )\n', '    external\n', '    payable;\n', '\n', '    function withdraw() public;\n', '}\n', '\n', '\n', '\n', '/// @title Auction Market for Blockchain Cuties.\n', '/// @author https://BlockChainArchitect.io\n', 'contract MarketInterface \n', '{\n', '    function withdrawEthFromBalance() external;    \n', '\n', '    function createAuction(uint40 _cutieId, uint128 _startPrice, uint128 _endPrice, uint40 _duration, address _seller) public payable;\n', '\n', '    function bid(uint40 _cutieId) public payable;\n', '\n', '    function cancelActiveAuctionWhenPaused(uint40 _cutieId) public;\n', '\n', '\tfunction getAuctionInfo(uint40 _cutieId)\n', '        public\n', '        view\n', '        returns\n', '    (\n', '        address seller,\n', '        uint128 startPrice,\n', '        uint128 endPrice,\n', '        uint40 duration,\n', '        uint40 startedAt,\n', '        uint128 featuringFee\n', '    );\n', '}\n', '\n', '\n', '\n', '/// @title BlockchainCuties: Collectible and breedable cuties on the Ethereum blockchain.\n', '/// @author https://BlockChainArchitect.io\n', '/// @dev This is the BlockchainCuties configuration. It can be changed redeploying another version.\n', 'contract ConfigInterface\n', '{\n', '    function isConfig() public pure returns (bool);\n', '\n', '    function getCooldownIndexFromGeneration(uint16 _generation) public view returns (uint16);\n', '    \n', '    function getCooldownEndTimeFromIndex(uint16 _cooldownIndex) public view returns (uint40);\n', '\n', '    function getCooldownIndexCount() public view returns (uint256);\n', '    \n', '    function getBabyGen(uint16 _momGen, uint16 _dadGen) public pure returns (uint16);\n', '\n', '    function getTutorialBabyGen(uint16 _dadGen) public pure returns (uint16);\n', '\n', '    function getBreedingFee(uint40 _momId, uint40 _dadId) public pure returns (uint256);\n', '}\n', '\n', '\n', '\n', '/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\n', 'interface ERC721TokenReceiver {\n', '    /// @notice Handle the receipt of an NFT\n', '    /// @dev The ERC721 smart contract calls this function on the recipient\n', '    ///  after a `transfer`. This function MAY throw to revert and reject the\n', '    ///  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    ///  than the magic value MUST result in the transaction being reverted.\n', '    ///  Note: the contract address is always the message sender.\n', '    /// @param _from The sending address \n', '    /// @param _tokenId The NFT identifier which is being transfered\n', '    /// @param data Additional data with no specified format\n', '    /// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '    ///  unless throwing\n', '    function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n', '}\n', '\n', '\n', '/// @title BlockchainCuties: Collectible and breedable cuties on the Ethereum blockchain.\n', '/// @author https://BlockChainArchitect.io\n', '/// @dev This is the main BlockchainCuties contract. For separated logical sections the code is divided in \n', '// several separately-instantiated sibling contracts that handle auctions and the genetic combination algorithm. \n', '// By keeping auctions separate it is possible to upgrade them without disrupting the main contract that tracks\n', '// the ownership of the cutie. The genetic combination algorithm is kept separate so that all of the rest of the \n', '// code can be open-sourced.\n', '// The contracts:\n', '//\n', '//      - BlockchainCuties: The fundamental code, including main data storage, constants and data types, as well as\n', '//             internal functions for managing these items ans ERC-721 implementation.\n', '//             Various addresses and constraints for operations can be executed only by specific roles - \n', '//             Owner, Operator and Parties.\n', '//             Methods for interacting with additional features (Plugins).\n', '//             The methods for breeding and keeping track of breeding offers, relies on external genetic combination \n', '//             contract.\n', '//             Public methods for auctioning or bidding or breeding. \n', '//\n', '//      - SaleMarket and BreedingMarket: The actual auction functionality is handled in two sibling contracts - one\n', '//             for sales and one for breeding. Auction creation and bidding is mostly mediated through this side of \n', '//             the core contract.\n', '//\n', '//      - Effects: Contracts allow to use item effects on cuties, implemented as plugins. Items are not stored in \n', '//             blockchain to not overload Ethereum network. Operator generates signatures, and Plugins check it\n', '//             and perform effect.\n', '//\n', '//      - ItemMarket: Plugin contract used to transfer money from buyer to seller.\n', '//\n', '//      - Bank: Plugin contract used to receive payments for payed features.\n', '\n', 'contract BlockchainCutiesCore /*is ERC721, CutieCoreInterface*/\n', '{\n', '    /// @notice A descriptive name for a collection of NFTs in this contract\n', '    function name() external pure returns (string _name) \n', '    {\n', '        return "BlockchainCuties"; \n', '    }\n', '\n', '    /// @notice An abbreviated name for NFTs in this contract\n', '    function symbol() external pure returns (string _symbol)\n', '    {\n', '        return "BC";\n', '    }\n', '    \n', '    /// @notice Query if a contract implements an interface\n', '    /// @param interfaceID The interface identifier, as specified in ERC-165\n', '    /// @dev Interface identification is specified in ERC-165. This function\n', '    ///  uses less than 30,000 gas.\n', '    /// @return `true` if the contract implements `interfaceID` and\n', '    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '    function supportsInterface(bytes4 interfaceID) external pure returns (bool)\n', '    {\n', '        return\n', '            interfaceID == 0x6466353c || \n', "            interfaceID == bytes4(keccak256('supportsInterface(bytes4)'));\n", '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    /// @dev The Birth event is fired as soon as a new cutie is created. This\n', '    ///  is any time a cutie comes into existence through the giveBirth method, as well as\n', '    ///  when a new gen0 cutie is created.\n', '    event Birth(address indexed owner, uint40 cutieId, uint40 momId, uint40 dadId, uint256 genes);\n', '\n', '    /// @dev This struct represents a blockchain Cutie. It was ensured that struct fits well into\n', '    ///  exactly two 256-bit words. The order of the members in this structure\n', '    ///  matters because of the Ethereum byte-packing rules.\n', '    ///  Reference: http://solidity.readthedocs.io/en/develop/miscellaneous.html\n', '    struct Cutie\n', '    {\n', "        // The Cutie's genetic code is in these 256-bits. Cutie's genes never change.\n", '        uint256 genes;\n', '\n', '        // The timestamp from the block when this cutie was created.\n', '        uint40 birthTime;\n', '\n', '        // The minimum timestamp after which the cutie can start breeding\n', '        // again.\n', '        uint40 cooldownEndTime;\n', '\n', "        // The cutie's parents ID is set to 0 for gen0 cuties.\n", '        // Because of using 32-bit unsigned integers the limit is 4 billion cuties. \n', '        // Current Ethereum annual limit is about 500 million transactions.\n', '        uint40 momId;\n', '        uint40 dadId;\n', '\n', '        // Set the index in the cooldown array (see below) that means\n', '        // the current cooldown duration for this Cutie. Starts at 0\n', '        // for gen0 cats, and is initialized to floor(generation/2) for others.\n', '        // Incremented by one for each successful breeding, regardless\n', '        // of being cutie mom or cutie dad.\n', '        uint16 cooldownIndex;\n', '\n', '        // The "generation number" of the cutie. Cutioes minted by the contract\n', '        // for sale are called "gen0" with generation number of 0. All other cuties\' \n', "        // generation number is the larger of their parents' two generation\n", '        // numbers, plus one (i.e. max(mom.generation, dad.generation) + 1)\n', '        uint16 generation;\n', '\n', '        // Some optional data used by external contracts\n', '        // Cutie struct is 2x256 bits long.\n', '        uint64 optional;\n', '    }\n', '\n', '    /// @dev An array containing the Cutie struct for all Cuties in existence. The ID\n', '    ///  of each cutie is actually an index into this array. ID 0 is the parent \n', '    /// of all generation 0 cats, and both parents to itself. It is an invalid genetic code.\n', '    Cutie[] public cuties;\n', '\n', '    /// @dev A mapping from cutie IDs to the address that owns them. All cuties have\n', '    ///  some valid owner address, even gen0 cuties are created with a non-zero owner.\n', '    mapping (uint40 => address) public cutieIndexToOwner;\n', '\n', '    // @dev A mapping from owner address to count of tokens that address owns.\n', '    //  Used internally inside balanceOf() to resolve ownership count.\n', '    mapping (address => uint256) ownershipTokenCount;\n', '\n', '    /// @dev A mapping from CutieIDs to an address that has been approved to call\n', '    ///  transferFrom(). A Cutie can have one approved address for transfer\n', '    ///  at any time. A zero value means that there is no outstanding approval.\n', '    mapping (uint40 => address) public cutieIndexToApproved;\n', '\n', '    /// @dev A mapping from CutieIDs to an address that has been approved to use\n', '    ///  this Cutie for breeding via breedWith(). A Cutie can have one approved\n', '    ///  address for breeding at any time. A zero value means that there is no outstanding approval.\n', '    mapping (uint40 => address) public sireAllowedToAddress;\n', '\n', '\n', '    /// @dev The address of the Market contract used to sell cuties. This\n', '    ///  contract used both peer-to-peer sales and the gen0 sales that are\n', '    ///  initiated each 15 minutes.\n', '    MarketInterface public saleMarket;\n', '\n', '    /// @dev The address of a custom Market subclassed contract used for breeding\n', '    ///  auctions. Is to be separated from saleMarket as the actions taken on success\n', '    ///  after a sales and breeding auction are quite different.\n', '    MarketInterface public breedingMarket;\n', '\n', '\n', '    // Modifiers to check that inputs can be safely stored with a certain\n', '    // number of bits.\n', '    modifier canBeStoredIn40Bits(uint256 _value) {\n', '        require(_value <= 0xFFFFFFFFFF);\n', '        _;\n', '    }    \n', '\n', '    /// @notice Returns the total number of Cuties in existence.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function totalSupply() external view returns (uint256)\n', '    {\n', '        return cuties.length - 1;\n', '    }\n', '\n', '    /// @notice Returns the total number of Cuties in existence.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function _totalSupply() internal view returns (uint256)\n', '    {\n', '        return cuties.length - 1;\n', '    }\n', '    \n', '    // Internal utility functions assume that their input arguments\n', '    // are valid. Public methods sanitize their inputs and follow\n', '    // the required logic.\n', '\n', '    /// @dev Checks if a given address is the current owner of a certain Cutie.\n', '    /// @param _claimant the address we are validating against.\n', '    /// @param _cutieId cutie id, only valid when > 0\n', '    function _isOwner(address _claimant, uint40 _cutieId) internal view returns (bool)\n', '    {\n', '        return cutieIndexToOwner[_cutieId] == _claimant;\n', '    }\n', '\n', '    /// @dev Checks if a given address currently has transferApproval for a certain Cutie.\n', '    /// @param _claimant the address we are confirming the cutie is approved for.\n', '    /// @param _cutieId cutie id, only valid when > 0\n', '    function _approvedFor(address _claimant, uint40 _cutieId) internal view returns (bool)\n', '    {\n', '        return cutieIndexToApproved[_cutieId] == _claimant;\n', '    }\n', '\n', '    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n', '    ///  approval. Setting _approved to address(0) clears all transfer approval.\n', '    ///  NOTE: _approve() does NOT send the Approval event. This is done on purpose:\n', '    ///  _approve() and transferFrom() are used together for putting Cuties on auction. \n', '    ///  There is no value in spamming the log with Approval events in that case.\n', '    function _approve(uint40 _cutieId, address _approved) internal\n', '    {\n', '        cutieIndexToApproved[_cutieId] = _approved;\n', '    }\n', '\n', '    /// @notice Returns the number of Cuties owned by a specific address.\n', '    /// @param _owner The owner address to check.\n', '    /// @dev Required for ERC-721 compliance\n', '    function balanceOf(address _owner) external view returns (uint256 count)\n', '    {\n', '        return ownershipTokenCount[_owner];\n', '    }\n', '\n', '    /// @notice Transfers a Cutie to another address. When transferring to a smart\n', '    ///  contract, ensure that it is aware of ERC-721 (or\n', '    ///  BlockchainCuties specifically), otherwise the Cutie may be lost forever.\n', '    /// @param _to The address of the recipient, can be a user or contract.\n', '    /// @param _cutieId The ID of the Cutie to transfer.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function transfer(address _to, uint256 _cutieId) external whenNotPaused canBeStoredIn40Bits(_cutieId)\n', '    {\n', '        // You can only send your own cutie.\n', '        require(_isOwner(msg.sender, uint40(_cutieId)));\n', '\n', '        // Reassign ownership, clear pending approvals, emit Transfer event.\n', '        _transfer(msg.sender, _to, uint40(_cutieId));\n', '    }\n', '\n', '    /// @notice Grant another address the right to transfer a perticular Cutie via transferFrom().\n', '    /// This flow is preferred for transferring NFTs to contracts.\n', '    /// @param _to The address to be granted transfer approval. Pass address(0) to clear all approvals.\n', '    /// @param _cutieId The ID of the Cutie that can be transferred if this call succeeds.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function approve(address _to, uint256 _cutieId) external whenNotPaused canBeStoredIn40Bits(_cutieId)\n', '    {\n', "        // Only cutie's owner can grant transfer approval.\n", '        require(_isOwner(msg.sender, uint40(_cutieId)));\n', '\n', '        // Registering approval replaces any previous approval.\n', '        _approve(uint40(_cutieId), _to);\n', '\n', '        // Emit approval event.\n', '        emit Approval(msg.sender, _to, _cutieId);\n', '    }\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address.\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '    ///  `onERC721Received` on `_to` and throws if the return value is not\n', '    ///  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    /// @param data Additional data with no specified format, sent in call to `_to`\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) \n', '        external whenNotPaused canBeStoredIn40Bits(_tokenId)\n', '    {\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        require(_to != address(saleMarket));\n', '        require(_to != address(breedingMarket));\n', '       \n', '        // Check for approval and valid ownership\n', '        require(_approvedFor(msg.sender, uint40(_tokenId)) || _isApprovedForAll(_from, msg.sender));\n', '        require(_isOwner(_from, uint40(_tokenId)));\n', '\n', '        // Reassign ownership, clearing pending approvals and emitting Transfer event.\n', '        _transfer(_from, _to, uint40(_tokenId));\n', '        ERC721TokenReceiver (_to).onERC721Received(_from, _tokenId, data);\n', '    }\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev This works identically to the other function with an extra data parameter,\n', '    ///  except this function just sets data to ""\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) \n', '        external whenNotPaused canBeStoredIn40Bits(_tokenId)\n', '    {\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        require(_to != address(saleMarket));\n', '        require(_to != address(breedingMarket));\n', '       \n', '        // Check for approval and valid ownership\n', '        require(_approvedFor(msg.sender, uint40(_tokenId)) || _isApprovedForAll(_from, msg.sender));\n', '        require(_isOwner(_from, uint40(_tokenId)));\n', '\n', '        // Reassign ownership, clearing pending approvals and emitting Transfer event.\n', '        _transfer(_from, _to, uint40(_tokenId));\n', '    }\n', '\n', '    /// @notice Transfer a Cutie owned by another address, for which the calling address\n', '    ///  has been granted transfer approval by the owner.\n', '    /// @param _from The address that owns the Cutie to be transfered.\n', '    /// @param _to Any address, including the caller address, can take ownership of the Cutie.\n', '    /// @param _tokenId The ID of the Cutie to be transferred.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) \n', '        external whenNotPaused canBeStoredIn40Bits(_tokenId) \n', '    {\n', '        // Check for approval and valid ownership\n', '        require(_approvedFor(msg.sender, uint40(_tokenId)) || _isApprovedForAll(_from, msg.sender));\n', '        require(_isOwner(_from, uint40(_tokenId)));\n', '\n', '        // Reassign ownership, clearing pending approvals and emitting Transfer event.\n', '        _transfer(_from, _to, uint40(_tokenId));\n', '    }\n', '\n', '    /// @notice Returns the address currently assigned ownership of a given Cutie.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function ownerOf(uint256 _cutieId)\n', '        external\n', '        view\n', '        canBeStoredIn40Bits(_cutieId)\n', '        returns (address owner)\n', '    {\n', '        owner = cutieIndexToOwner[uint40(_cutieId)];\n', '\n', '        require(owner != address(0));\n', '    }\n', '\n', '    /// @notice Returns the nth Cutie assigned to an address, with n specified by the\n', '    ///  _index argument.\n', '    /// @param _owner The owner of the Cuties we are interested in.\n', "    /// @param _index The zero-based index of the cutie within the owner's list of cuties.\n", '    ///  Must be less than balanceOf(_owner).\n', '    /// @dev This method must not be called by smart contract code. It will almost\n', '    ///  certainly blow past the block gas limit once there are a large number of\n', '    ///  Cuties in existence. Exists only to allow off-chain queries of ownership.\n', '    ///  Optional method for ERC-721.\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index)\n', '        external\n', '        view\n', '        returns (uint256 cutieId)\n', '    {\n', '        uint40 count = 0;\n', '        for (uint40 i = 1; i <= _totalSupply(); ++i) {\n', '            if (cutieIndexToOwner[i] == _owner) {\n', '                if (count == _index) {\n', '                    return i;\n', '                } else {\n', '                    count++;\n', '                }\n', '            }\n', '        }\n', '        revert();\n', '    }\n', '\n', '    /// @notice Enumerate valid NFTs\n', '    /// @dev Throws if `_index` >= `totalSupply()`.\n', '    /// @param _index A counter less than `totalSupply()`\n', '    /// @return The token identifier for the `_index`th NFT,\n', '    ///  (sort order not specified)\n', '    function tokenByIndex(uint256 _index) external pure returns (uint256)\n', '    {\n', '        return _index;\n', '    }\n', '\n', '    /// @dev A mapping from Cuties owner (account) to an address that has been approved to call\n', '    ///  transferFrom() for all cuties, owned by owner.\n', '    ///  Only one approved address is permitted for each account for transfer\n', '    ///  at any time. A zero value means there is no outstanding approval.\n', '    mapping (address => address) public addressToApprovedAll;\n', '\n', '    /// @notice Enable or disable approval for a third party ("operator") to manage\n', '    ///  all your asset.\n', '    /// @dev Emits the ApprovalForAll event\n', '    /// @param _operator Address to add to the set of authorized operators.\n', '    /// @param _approved True if the operators is approved, false to revoke approval\n', '    function setApprovalForAll(address _operator, bool _approved) external\n', '    {\n', '        if (_approved)\n', '        {\n', '            addressToApprovedAll[msg.sender] = _operator;\n', '        }\n', '        else\n', '        {\n', '            delete addressToApprovedAll[msg.sender];\n', '        }\n', '        emit ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '\n', '    /// @notice Get the approved address for a single NFT\n', '    /// @dev Throws if `_tokenId` is not a valid NFT\n', '    /// @param _tokenId The NFT to find the approved address for\n', '    /// @return The approved address for this NFT, or the zero address if there is none\n', '    function getApproved(uint256 _tokenId) \n', '        external view canBeStoredIn40Bits(_tokenId) \n', '        returns (address)\n', '    {\n', '        require(_tokenId <= _totalSupply());\n', '\n', '        if (cutieIndexToApproved[uint40(_tokenId)] != address(0))\n', '        {\n', '            return cutieIndexToApproved[uint40(_tokenId)];\n', '        }\n', '\n', '        address owner = cutieIndexToOwner[uint40(_tokenId)];\n', '        return addressToApprovedAll[owner];\n', '    }\n', '\n', '    /// @notice Query if an address is an authorized operator for another address\n', '    /// @param _owner The address that owns the NFTs\n', '    /// @param _operator The address that acts on behalf of the owner\n', '    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool)\n', '    {\n', '        return addressToApprovedAll[_owner] == _operator;\n', '    }\n', '\n', '    function _isApprovedForAll(address _owner, address _operator) internal view returns (bool)\n', '    {\n', '        return addressToApprovedAll[_owner] == _operator;\n', '    }\n', '\n', '    ConfigInterface public config;\n', '\n', '    /// @dev Update the address of the config contract.\n', '    /// @param _address An address of a ConfigInterface contract instance to be used from this point forward.\n', '    function setConfigAddress(address _address) public onlyOwner\n', '    {\n', '        ConfigInterface candidateContract = ConfigInterface(_address);\n', '\n', '        require(candidateContract.isConfig());\n', '\n', '        // Set the new contract address\n', '        config = candidateContract;\n', '    }\n', '\n', '    function getCooldownIndexFromGeneration(uint16 _generation) internal view returns (uint16)\n', '    {\n', '        return config.getCooldownIndexFromGeneration(_generation);\n', '    }\n', '\n', '    /// @dev An internal method that creates a new cutie and stores it. This\n', '    ///  method does not check anything and should only be called when the\n', '    ///  input data is valid for sure. Will generate both a Birth event\n', '    ///  and a Transfer event.\n', '    /// @param _momId The cutie ID of the mom of this cutie (zero for gen0)\n', '    /// @param _dadId The cutie ID of the dad of this cutie (zero for gen0)\n', '    /// @param _generation The generation number of this cutie, must be computed by caller.\n', "    /// @param _genes The cutie's genetic code.\n", '    /// @param _owner The initial owner of this cutie, must be non-zero (except for the unCutie, ID 0)\n', '    function _createCutie(\n', '        uint40 _momId,\n', '        uint40 _dadId,\n', '        uint16 _generation,\n', '        uint16 _cooldownIndex,\n', '        uint256 _genes,\n', '        address _owner,\n', '        uint40 _birthTime\n', '    )\n', '        internal\n', '        returns (uint40)\n', '    {\n', '        Cutie memory _cutie = Cutie({\n', '            genes: _genes, \n', '            birthTime: _birthTime, \n', '            cooldownEndTime: 0, \n', '            momId: _momId, \n', '            dadId: _dadId, \n', '            cooldownIndex: _cooldownIndex, \n', '            generation: _generation,\n', '            optional: 0\n', '        });\n', '        uint256 newCutieId256 = cuties.push(_cutie) - 1;\n', '\n', '        // Check if id can fit into 40 bits\n', '        require(newCutieId256 <= 0xFFFFFFFFFF);\n', '\n', '        uint40 newCutieId = uint40(newCutieId256);\n', '\n', '        // emit the birth event\n', '        emit Birth(_owner, newCutieId, _cutie.momId, _cutie.dadId, _cutie.genes);\n', '\n', '        // This will assign ownership, as well as emit the Transfer event as\n', '        // per ERC721 draft\n', '        _transfer(0, _owner, newCutieId);\n', '\n', '        return newCutieId;\n', '    }\n', '  \n', '    /// @notice Returns all the relevant information about a certain cutie.\n', '    /// @param _id The ID of the cutie of interest.\n', '    function getCutie(uint40 _id)\n', '        external\n', '        view\n', '        returns (\n', '        uint256 genes,\n', '        uint40 birthTime,\n', '        uint40 cooldownEndTime,\n', '        uint40 momId,\n', '        uint40 dadId,\n', '        uint16 cooldownIndex,\n', '        uint16 generation\n', '    ) {\n', '        Cutie storage cutie = cuties[_id];\n', '\n', '        genes = cutie.genes;\n', '        birthTime = cutie.birthTime;\n', '        cooldownEndTime = cutie.cooldownEndTime;\n', '        momId = cutie.momId;\n', '        dadId = cutie.dadId;\n', '        cooldownIndex = cutie.cooldownIndex;\n', '        generation = cutie.generation;\n', '    }    \n', '    \n', '    /// @dev Assigns ownership of a particular Cutie to an address.\n', '    function _transfer(address _from, address _to, uint40 _cutieId) internal {\n', '        // since the number of cuties is capped to 2^40\n', '        // there is no way to overflow this\n', '        ownershipTokenCount[_to]++;\n', '        // transfer ownership\n', '        cutieIndexToOwner[_cutieId] = _to;\n', '        // When creating new cuties _from is 0x0, but we cannot account that address.\n', '        if (_from != address(0)) {\n', '            ownershipTokenCount[_from]--;\n', '            // once the cutie is transferred also clear breeding allowances\n', '            delete sireAllowedToAddress[_cutieId];\n', '            // clear any previously approved ownership exchange\n', '            delete cutieIndexToApproved[_cutieId];\n', '        }\n', '        // Emit the transfer event.\n', '        emit Transfer(_from, _to, _cutieId);\n', '    }\n', '\n', '    /// @dev For transferring a cutie owned by this contract to the specified address.\n', '    ///  Used to rescue lost cuties. (There is no "proper" flow where this contract\n', '    ///  should be the owner of any Cutie. This function exists for us to reassign\n', '    ///  the ownership of Cuties that users may have accidentally sent to our address.)\n', '    /// @param _cutieId - ID of cutie\n', '    /// @param _recipient - Address to send the cutie to\n', '    function restoreCutieToAddress(uint40 _cutieId, address _recipient) public onlyOperator whenNotPaused {\n', '        require(_isOwner(this, _cutieId));\n', '        _transfer(this, _recipient, _cutieId);\n', '    }\n', '\n', '    address ownerAddress;\n', '    address operatorAddress;\n', '\n', '    bool public paused = false;\n', '\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == ownerAddress);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _newOwner) public onlyOwner\n', '    {\n', '        require(_newOwner != address(0));\n', '\n', '        ownerAddress = _newOwner;\n', '    }\n', '\n', '    modifier onlyOperator() {\n', '        require(msg.sender == operatorAddress || msg.sender == ownerAddress);\n', '        _;\n', '    }\n', '\n', '    function setOperator(address _newOperator) public onlyOwner {\n', '        require(_newOperator != address(0));\n', '\n', '        operatorAddress = _newOperator;\n', '    }\n', '\n', '    modifier whenNotPaused()\n', '    {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused\n', '    {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() public onlyOwner whenNotPaused\n', '    {\n', '        paused = true;\n', '    }\n', '\n', '    string public metadataUrlPrefix = "https://blockchaincuties.co/cutie/";\n', '    string public metadataUrlSuffix = ".svg";\n', '\n', '    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n', '    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n', '    ///  3986. The URI may point to a JSON file that conforms to the "ERC721\n', '    ///  Metadata JSON Schema".\n', '    function tokenURI(uint256 _tokenId) external view returns (string infoUrl)\n', '    {\n', '        return \n', '            concat(toSlice(metadataUrlPrefix), \n', '                toSlice(concat(toSlice(uintToString(_tokenId)), toSlice(metadataUrlSuffix))));\n', '    }\n', '\n', '    function setMetadataUrl(string _metadataUrlPrefix, string _metadataUrlSuffix) public onlyOwner\n', '    {\n', '        metadataUrlPrefix = _metadataUrlPrefix;\n', '        metadataUrlSuffix = _metadataUrlSuffix;\n', '    }\n', '\n', '\n', '    mapping(address => PluginInterface) public plugins;\n', '    PluginInterface[] public pluginsArray;\n', '    mapping(uint40 => address) public usedSignes;\n', '    uint40 public minSignId;\n', '\n', '    event GenesChanged(uint40 indexed cutieId, uint256 oldValue, uint256 newValue);\n', '    event CooldownEndTimeChanged(uint40 indexed cutieId, uint40 oldValue, uint40 newValue);\n', '    event CooldownIndexChanged(uint40 indexed cutieId, uint16 ololdValue, uint16 newValue);\n', '    event GenerationChanged(uint40 indexed cutieId, uint16 oldValue, uint16 newValue);\n', '    event OptionalChanged(uint40 indexed cutieId, uint64 oldValue, uint64 newValue);\n', '    event SignUsed(uint40 signId, address sender);\n', '    event MinSignSet(uint40 signId);\n', '\n', '    /// @dev Sets the reference to the plugin contract.\n', '    /// @param _address - Address of plugin contract.\n', '    function addPlugin(address _address) public onlyOwner\n', '    {\n', '        PluginInterface candidateContract = PluginInterface(_address);\n', '\n', '        // verify that a contract is what we expect\n', '        require(candidateContract.isPluginInterface());\n', '\n', '        // Set the new contract address\n', '        plugins[_address] = candidateContract;\n', '        pluginsArray.push(candidateContract);\n', '    }\n', '\n', '    /// @dev Remove plugin and calls onRemove to cleanup\n', '    function removePlugin(address _address) public onlyOwner\n', '    {\n', '        plugins[_address].onRemove();\n', '        delete plugins[_address];\n', '\n', '        uint256 kindex = 0;\n', '        while (kindex < pluginsArray.length)\n', '        {\n', '            if (address(pluginsArray[kindex]) == _address)\n', '            {\n', '                pluginsArray[kindex] = pluginsArray[pluginsArray.length-1];\n', '                pluginsArray.length--;\n', '            }\n', '            else\n', '            {\n', '                kindex++;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Put a cutie up for plugin feature.\n', '    function runPlugin(\n', '        address _pluginAddress,\n', '        uint40 _cutieId,\n', '        uint256 _parameter\n', '    )\n', '        public\n', '        whenNotPaused\n', '        payable\n', '    {\n', '        // If cutie is already on any auction or in adventure, this will throw\n', '        // because it will be owned by the other contract.\n', '        // If _cutieId is 0, then cutie is not used on this feature.\n', '        require(_cutieId == 0 || _isOwner(msg.sender, _cutieId));\n', '        require(address(plugins[_pluginAddress]) != address(0));\n', '        if (_cutieId > 0)\n', '        {\n', '            _approve(_cutieId, _pluginAddress);\n', '        }\n', '\n', '        // Plugin contract throws if inputs are invalid and clears\n', '        // transfer after escrowing the cutie.\n', '        plugins[_pluginAddress].run.value(msg.value)(\n', '            _cutieId,\n', '            _parameter,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /// @dev Called from plugin contract when using items as effect\n', '    function getGenes(uint40 _id)\n', '        public\n', '        view\n', '        returns (\n', '        uint256 genes\n', '    )\n', '    {\n', '        Cutie storage cutie = cuties[_id];\n', '        genes = cutie.genes;\n', '    }\n', '\n', '    /// @dev Called from plugin contract when using items as effect\n', '    function changeGenes(\n', '        uint40 _cutieId,\n', '        uint256 _genes)\n', '        public\n', '        whenNotPaused\n', '    {\n', '        // if caller is registered plugin contract\n', '        require(address(plugins[msg.sender]) != address(0));\n', '\n', '        Cutie storage cutie = cuties[_cutieId];\n', '        if (cutie.genes != _genes)\n', '        {\n', '            emit GenesChanged(_cutieId, cutie.genes, _genes);\n', '            cutie.genes = _genes;\n', '        }\n', '    }\n', '\n', '    function getCooldownEndTime(uint40 _id)\n', '        public\n', '        view\n', '        returns (\n', '        uint40 cooldownEndTime\n', '    ) {\n', '        Cutie storage cutie = cuties[_id];\n', '\n', '        cooldownEndTime = cutie.cooldownEndTime;\n', '    }\n', '\n', '    function changeCooldownEndTime(\n', '        uint40 _cutieId,\n', '        uint40 _cooldownEndTime)\n', '        public\n', '        whenNotPaused\n', '    {\n', '        require(address(plugins[msg.sender]) != address(0));\n', '\n', '        Cutie storage cutie = cuties[_cutieId];\n', '        if (cutie.cooldownEndTime != _cooldownEndTime)\n', '        {\n', '            emit CooldownEndTimeChanged(_cutieId, cutie.cooldownEndTime, _cooldownEndTime);\n', '            cutie.cooldownEndTime = _cooldownEndTime;\n', '        }\n', '    }\n', '\n', '    function getCooldownIndex(uint40 _id)\n', '        public\n', '        view\n', '        returns (\n', '        uint16 cooldownIndex\n', '    ) {\n', '        Cutie storage cutie = cuties[_id];\n', '\n', '        cooldownIndex = cutie.cooldownIndex;\n', '    }\n', '\n', '    function changeCooldownIndex(\n', '        uint40 _cutieId,\n', '        uint16 _cooldownIndex)\n', '        public\n', '        whenNotPaused\n', '    {\n', '        require(address(plugins[msg.sender]) != address(0));\n', '\n', '        Cutie storage cutie = cuties[_cutieId];\n', '        if (cutie.cooldownIndex != _cooldownIndex)\n', '        {\n', '            emit CooldownIndexChanged(_cutieId, cutie.cooldownIndex, _cooldownIndex);\n', '            cutie.cooldownIndex = _cooldownIndex;\n', '        }\n', '    }\n', '\n', '    function changeGeneration(\n', '        uint40 _cutieId,\n', '        uint16 _generation)\n', '        public\n', '        whenNotPaused\n', '    {\n', '        require(address(plugins[msg.sender]) != address(0));\n', '\n', '        Cutie storage cutie = cuties[_cutieId];\n', '        if (cutie.generation != _generation)\n', '        {\n', '            emit GenerationChanged(_cutieId, cutie.generation, _generation);\n', '            cutie.generation = _generation;\n', '        }\n', '    }\n', '\n', '    function getGeneration(uint40 _id)\n', '        public\n', '        view\n', '        returns (uint16 generation)\n', '    {\n', '        Cutie storage cutie = cuties[_id];\n', '        generation = cutie.generation;\n', '    }\n', '\n', '    function changeOptional(\n', '        uint40 _cutieId,\n', '        uint64 _optional)\n', '        public\n', '        whenNotPaused\n', '    {\n', '        require(address(plugins[msg.sender]) != address(0));\n', '\n', '        Cutie storage cutie = cuties[_cutieId];\n', '        if (cutie.optional != _optional)\n', '        {\n', '            emit OptionalChanged(_cutieId, cutie.optional, _optional);\n', '            cutie.optional = _optional;\n', '        }\n', '    }\n', '\n', '    function getOptional(uint40 _id)\n', '        public\n', '        view\n', '        returns (uint64 optional)\n', '    {\n', '        Cutie storage cutie = cuties[_id];\n', '        optional = cutie.optional;\n', '    }\n', '\n', '    /// @dev Common function to be used also in backend\n', '    function hashArguments(\n', '        address _pluginAddress,\n', '        uint40 _signId,\n', '        uint40 _cutieId,\n', '        uint128 _value,\n', '        uint256 _parameter)\n', '        public pure returns (bytes32 msgHash)\n', '    {\n', '        msgHash = keccak256(_pluginAddress, _signId, _cutieId, _value, _parameter);\n', '    }\n', '\n', '    /// @dev Common function to be used also in backend\n', '    function getSigner(\n', '        address _pluginAddress,\n', '        uint40 _signId,\n', '        uint40 _cutieId,\n', '        uint128 _value,\n', '        uint256 _parameter,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '        )\n', '        public pure returns (address)\n', '    {\n', '        bytes32 msgHash = hashArguments(_pluginAddress, _signId, _cutieId, _value, _parameter);\n', '        return ecrecover(msgHash, _v, _r, _s);\n', '    }\n', '\n', '    /// @dev Common function to be used also in backend\n', '    function isValidSignature(\n', '        address _pluginAddress,\n', '        uint40 _signId,\n', '        uint40 _cutieId,\n', '        uint128 _value,\n', '        uint256 _parameter,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '        )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return getSigner(_pluginAddress, _signId, _cutieId, _value, _parameter, _v, _r, _s) == operatorAddress;\n', '    }\n', '\n', '    /// @dev Put a cutie up for plugin feature with signature.\n', '    ///  Can be used for items equip, item sales and other features.\n', '    ///  Signatures are generated by Operator role.\n', '    function runPluginSigned(\n', '        address _pluginAddress,\n', '        uint40 _signId,\n', '        uint40 _cutieId,\n', '        uint128 _value,\n', '        uint256 _parameter,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        public\n', '        whenNotPaused\n', '        payable\n', '    {\n', '        // If cutie is already on any auction or in adventure, this will throw\n', '        // as it will be owned by the other contract.\n', '        // If _cutieId is 0, then cutie is not used on this feature.\n', '        require(_cutieId == 0 || _isOwner(msg.sender, _cutieId));\n', '    \n', '        require(address(plugins[_pluginAddress]) != address(0));    \n', '\n', '        require (usedSignes[_signId] == address(0));\n', '        require (_signId >= minSignId);\n', '        // value can also be zero for free calls\n', '        require (_value <= msg.value);\n', '\n', '        require (isValidSignature(_pluginAddress, _signId, _cutieId, _value, _parameter, _v, _r, _s));\n', '        \n', '        usedSignes[_signId] = msg.sender;\n', '        emit SignUsed(_signId, msg.sender);\n', '\n', '        // Plugin contract throws if inputs are invalid and clears\n', '        // transfer after escrowing the cutie.\n', '        plugins[_pluginAddress].runSigned.value(_value)(\n', '            _cutieId,\n', '            _parameter,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /// @dev Sets minimal signId, than can be used.\n', '    ///       All unused signatures less than signId will be cancelled on off-chain server\n', '    ///       and unused items will be transfered back to owner.\n', '    function setMinSign(uint40 _newMinSignId)\n', '        public\n', '        onlyOperator\n', '    {\n', '        require (_newMinSignId > minSignId);\n', '        minSignId = _newMinSignId;\n', '        emit MinSignSet(minSignId);\n', '    }\n', '\n', '\n', '    event BreedingApproval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '    // Set in case the core contract is broken and an upgrade is required\n', '    address public upgradedContractAddress;\n', '\n', '    function isCutieCore() pure public returns (bool) { return true; }\n', '\n', '    /// @notice Creates the main BlockchainCuties smart contract instance.\n', '    function BlockchainCutiesCore() public\n', '    {\n', '        // Starts paused.\n', '        paused = true;\n', '\n', '        // the creator of the contract is the initial owner\n', '        ownerAddress = msg.sender;\n', '\n', '        // the creator of the contract is also the initial operator\n', '        operatorAddress = msg.sender;\n', '\n', '        // start with the mythical cutie 0 - so there are no generation-0 parent issues\n', '        _createCutie(0, 0, 0, 0, uint256(-1), address(0), 0);\n', '    }\n', '\n', '    event ContractUpgrade(address newContract);\n', '\n', '    /// @dev Aimed to mark the smart contract as upgraded if there is a crucial\n', '    ///  bug. This keeps track of the new contract and indicates that the new address is set. \n', '    /// Updating to the new contract address is up to the clients. (This contract will\n', '    ///  be paused indefinitely if such an upgrade takes place.)\n', '    /// @param _newAddress new address\n', '    function setUpgradedAddress(address _newAddress) public onlyOwner whenPaused\n', '    {\n', '        require(_newAddress != address(0));\n', '        upgradedContractAddress = _newAddress;\n', '        emit ContractUpgrade(upgradedContractAddress);\n', '    }\n', '\n', '    /// @dev Import cuties from previous version of Core contract.\n', '    /// @param _oldAddress Old core contract address\n', '    /// @param _fromIndex (inclusive)\n', '    /// @param _toIndex (inclusive)\n', '    function migrate(address _oldAddress, uint40 _fromIndex, uint40 _toIndex) public onlyOwner whenPaused\n', '    {\n', '        require(_totalSupply() + 1 == _fromIndex);\n', '\n', '        BlockchainCutiesCore old = BlockchainCutiesCore(_oldAddress);\n', '\n', '        for (uint40 i = _fromIndex; i <= _toIndex; i++)\n', '        {\n', '            uint256 genes;\n', '            uint40 birthTime;\n', '            uint40 cooldownEndTime;\n', '            uint40 momId;\n', '            uint40 dadId;\n', '            uint16 cooldownIndex;\n', '            uint16 generation;            \n', '            (genes, birthTime, cooldownEndTime, momId, dadId, cooldownIndex, generation) = old.getCutie(i);\n', '\n', '            Cutie memory _cutie = Cutie({\n', '                genes: genes, \n', '                birthTime: birthTime, \n', '                cooldownEndTime: cooldownEndTime, \n', '                momId: momId, \n', '                dadId: dadId, \n', '                cooldownIndex: cooldownIndex, \n', '                generation: generation,\n', '                optional: 0\n', '            });\n', '            cuties.push(_cutie);\n', '        }\n', '    }\n', '\n', '    /// @dev Import cuties from previous version of Core contract (part 2).\n', '    /// @param _oldAddress Old core contract address\n', '    /// @param _fromIndex (inclusive)\n', '    /// @param _toIndex (inclusive)\n', '    function migrate2(address _oldAddress, uint40 _fromIndex, uint40 _toIndex, address saleAddress, address breedingAddress) public onlyOwner whenPaused\n', '    {\n', '        BlockchainCutiesCore old = BlockchainCutiesCore(_oldAddress);\n', '        MarketInterface oldSaleMarket = MarketInterface(saleAddress);\n', '        MarketInterface oldBreedingMarket = MarketInterface(breedingAddress);\n', '\n', '        for (uint40 i = _fromIndex; i <= _toIndex; i++)\n', '        {\n', '            address owner = old.ownerOf(i);\n', '\n', '            if (owner == saleAddress)\n', '            {\n', '                (owner,,,,,) = oldSaleMarket.getAuctionInfo(i);\n', '            }\n', '\n', '            if (owner == breedingAddress)\n', '            {\n', '                (owner,,,,,) = oldBreedingMarket.getAuctionInfo(i);\n', '            }\n', '            _transfer(0, owner, i);\n', '        }\n', '    }\n', '\n', '    /// @dev Override unpause so it requires upgradedContractAddress not set, because then the contract was upgraded.\n', '    function unpause() public onlyOwner whenPaused\n', '    {\n', '        require(upgradedContractAddress == address(0));\n', '\n', '        paused = false;\n', '    }\n', '\n', '    // Counts the number of cuties the contract owner has created.\n', '    uint40 public promoCutieCreatedCount;\n', '    uint40 public gen0CutieCreatedCount;\n', '    uint40 public gen0Limit = 50000;\n', '    uint40 public promoLimit = 5000;\n', '\n', '    /// @dev Creates a new gen0 cutie with the given genes and\n', '    ///  creates an auction for it.\n', '    function createGen0Auction(uint256 _genes, uint128 startPrice, uint128 endPrice, uint40 duration) public onlyOperator\n', '    {\n', '        require(gen0CutieCreatedCount < gen0Limit);\n', '        uint40 cutieId = _createCutie(0, 0, 0, 0, _genes, address(this), uint40(now));\n', '        _approve(cutieId, saleMarket);\n', '\n', '        saleMarket.createAuction(\n', '            cutieId,\n', '            startPrice,\n', '            endPrice,\n', '            duration,\n', '            address(this)\n', '        );\n', '\n', '        gen0CutieCreatedCount++;\n', '    }\n', '\n', '    function createPromoCutie(uint256 _genes, address _owner) public onlyOperator\n', '    {\n', '        require(promoCutieCreatedCount < promoLimit);\n', '        if (_owner == address(0)) {\n', '             _owner = operatorAddress;\n', '        }\n', '        promoCutieCreatedCount++;\n', '        gen0CutieCreatedCount++;\n', '        _createCutie(0, 0, 0, 0, _genes, _owner, uint40(now));\n', '    }\n', '\n', '    /// @dev Put a cutie up for auction to be dad.\n', '    ///  Performs checks to ensure the cutie can be dad, then\n', '    ///  delegates to reverse auction.\n', '    ///  Optional money amount can be sent to contract to feature auction.\n', '    ///  Pricea are available on web.\n', '    function createBreedingAuction(\n', '        uint40 _cutieId,\n', '        uint128 _startPrice,\n', '        uint128 _endPrice,\n', '        uint40 _duration\n', '    )\n', '        public\n', '        whenNotPaused\n', '        payable\n', '    {\n', '        // Auction contract checks input sizes\n', '        // If cutie is already on any auction, this will throw\n', '        // because it will be owned by the auction contract.\n', '        require(_isOwner(msg.sender, _cutieId));\n', '        require(canBreed(_cutieId));\n', '        _approve(_cutieId, breedingMarket);\n', '        // breeding auction function is called if inputs are invalid and clears\n', '        // transfer and sire approval after escrowing the cutie.\n', '        breedingMarket.createAuction.value(msg.value)(\n', '            _cutieId,\n', '            _startPrice,\n', '            _endPrice,\n', '            _duration,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /// @dev Sets the reference to the breeding auction.\n', '    /// @param _breedingAddress - Address of breeding market contract.\n', '    /// @param _saleAddress - Address of sale market contract.\n', '    function setMarketAddress(address _breedingAddress, address _saleAddress) public onlyOwner\n', '    {\n', '        //require(address(breedingMarket) == address(0));\n', '        //require(address(saleMarket) == address(0));\n', '\n', '        breedingMarket = MarketInterface(_breedingAddress);\n', '        saleMarket = MarketInterface(_saleAddress);\n', '    }\n', '\n', '    /// @dev Completes a breeding auction by bidding.\n', '    ///  Immediately breeds the winning mom with the dad on auction.\n', '    /// @param _dadId - ID of the dad on auction.\n', '    /// @param _momId - ID of the mom owned by the bidder.\n', '    function bidOnBreedingAuction(\n', '        uint40 _dadId,\n', '        uint40 _momId\n', '    )\n', '        public\n', '        payable\n', '        whenNotPaused\n', '        returns (uint256)\n', '    {\n', '        // Auction contract checks input sizes\n', '        require(_isOwner(msg.sender, _momId));\n', '        require(canBreed(_momId));\n', '        require(_canMateViaMarketplace(_momId, _dadId));\n', '        // Take breeding fee\n', '        uint256 fee = getBreedingFee(_momId, _dadId);\n', '        require(msg.value >= fee);\n', '\n', '        // breeding auction will throw if the bid fails.\n', '        breedingMarket.bid.value(msg.value - fee)(_dadId);\n', '        return _breedWith(_momId, _dadId);\n', '    }\n', '\n', '    /// @dev Put a cutie up for auction.\n', '    ///  Does some ownership trickery for creating auctions in one transaction.\n', '    ///  Optional money amount can be sent to contract to feature auction.\n', '    ///  Pricea are available on web.\n', '    function createSaleAuction(\n', '        uint40 _cutieId,\n', '        uint128 _startPrice,\n', '        uint128 _endPrice,\n', '        uint40 _duration\n', '    )\n', '        public\n', '        whenNotPaused\n', '        payable\n', '    {\n', '        // Auction contract checks input sizes\n', '        // If cutie is already on any auction, this will throw\n', '        // because it will be owned by the auction contract.\n', '        require(_isOwner(msg.sender, _cutieId));\n', '        _approve(_cutieId, saleMarket);\n', '        // Sale auction throws if inputs are invalid and clears\n', '        // transfer and sire approval after escrowing the cutie.\n', '        saleMarket.createAuction.value(msg.value)(\n', '            _cutieId,\n', '            _startPrice,\n', '            _endPrice,\n', '            _duration,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /// @dev The address of the sibling contract that is used to implement the genetic combination algorithm.\n', '    GeneMixerInterface geneMixer;\n', '\n', '    /// @dev Check if dad has authorized breeding with the mom. True if both dad\n', '    ///  and mom have the same owner, or if the dad has given breeding permission to\n', "    ///  the mom's owner (via approveBreeding()).\n", '    function _isBreedingPermitted(uint40 _dadId, uint40 _momId) internal view returns (bool)\n', '    {\n', '        address momOwner = cutieIndexToOwner[_momId];\n', '        address dadOwner = cutieIndexToOwner[_dadId];\n', '\n', "        // Breeding is approved if they have same owner, or if the mom's owner was given\n", '        // permission to breed with the dad.\n', '        return (momOwner == dadOwner || sireAllowedToAddress[_dadId] == momOwner);\n', '    }\n', '\n', '    /// @dev Update the address of the genetic contract.\n', '    /// @param _address An address of a GeneMixer contract instance to be used from this point forward.\n', '    function setGeneMixerAddress(address _address) public onlyOwner\n', '    {\n', '        GeneMixerInterface candidateContract = GeneMixerInterface(_address);\n', '\n', '        require(candidateContract.isGeneMixer());\n', '\n', '        // Set the new contract address\n', '        geneMixer = candidateContract;\n', '    }\n', '\n', '    /// @dev Checks that a given cutie is able to breed. Requires that the\n', '    ///  current cooldown is finished (for dads)\n', '    function _canBreed(Cutie _cutie) internal view returns (bool)\n', '    {\n', '        return _cutie.cooldownEndTime <= now;\n', '    }\n', '\n', '    /// @notice Grants approval to another user to sire with one of your Cuties.\n', '    /// @param _addr The address that will be able to sire with your Cutie. Set to\n', '    ///  address(0) to clear all breeding approvals for this Cutie.\n', '    /// @param _dadId A Cutie that you own that _addr will now be able to dad with.\n', '    function approveBreeding(address _addr, uint40 _dadId) public whenNotPaused\n', '    {\n', '        require(_isOwner(msg.sender, _dadId));\n', '        sireAllowedToAddress[_dadId] = _addr;\n', '        emit BreedingApproval(msg.sender, _addr, _dadId);\n', '    }\n', '\n', '    /// @dev Set the cooldownEndTime for the given Cutie, based on its current cooldownIndex.\n', '    ///  Also increments the cooldownIndex (unless it has hit the cap).\n', '    /// @param _cutie A reference to the Cutie in storage which needs its timer started.\n', '    function _triggerCooldown(uint40 _cutieId, Cutie storage _cutie) internal\n', '    {\n', '        // Compute the end of the cooldown time, based on current cooldownIndex\n', '        uint40 oldValue = _cutie.cooldownIndex;\n', '        _cutie.cooldownEndTime = config.getCooldownEndTimeFromIndex(_cutie.cooldownIndex);\n', '        emit CooldownEndTimeChanged(_cutieId, oldValue, _cutie.cooldownEndTime);\n', '\n', '        // Increment the breeding count.\n', '        if (_cutie.cooldownIndex + 1 < config.getCooldownIndexCount()) {\n', '            uint16 oldValue2 = _cutie.cooldownIndex;\n', '            _cutie.cooldownIndex++;\n', '            emit CooldownIndexChanged(_cutieId, oldValue2, _cutie.cooldownIndex);\n', '        }\n', '    }\n', '\n', '    /// @notice Checks that a certain cutie is not\n', '    ///  in the middle of a breeding cooldown and is able to breed.\n', '    /// @param _cutieId reference the id of the cutie, any user can inquire about it\n', '    function canBreed(uint40 _cutieId)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        require(_cutieId > 0);\n', '        Cutie storage cutie = cuties[_cutieId];\n', '        return _canBreed(cutie);\n', '    }\n', '\n', '    /// @dev Check if given mom and dad are a valid mating pair.\n', '    function _canPairMate(\n', '        Cutie storage _mom,\n', '        uint40 _momId,\n', '        Cutie storage _dad,\n', '        uint40 _dadId\n', '    )\n', '        private\n', '        view\n', '        returns(bool)\n', '    {\n', "        // A Cutie can't breed with itself.\n", '        if (_dadId == _momId) { \n', '            return false; \n', '        }\n', '\n', "        // Cuties can't breed with their parents.\n", '        if (_mom.momId == _dadId) {\n', '            return false;\n', '        }\n', '        if (_mom.dadId == _dadId) {\n', '            return false;\n', '        }\n', '\n', '        if (_dad.momId == _momId) {\n', '            return false;\n', '        }\n', '        if (_dad.dadId == _momId) {\n', '            return false;\n', '        }\n', '\n', '        // We can short circuit the sibling check (below) if either cat is\n', '        // gen zero (has a mom ID of zero).\n', '        if (_dad.momId == 0) {\n', '            return true;\n', '        }\n', '        if (_mom.momId == 0) {\n', '            return true;\n', '        }\n', '\n', "        // Cuties can't breed with full or half siblings.\n", '        if (_dad.momId == _mom.momId) {\n', '            return false;\n', '        }\n', '        if (_dad.momId == _mom.dadId) {\n', '            return false;\n', '        }\n', '        if (_dad.dadId == _mom.momId) {\n', '            return false;\n', '        }\n', '        if (_dad.dadId == _mom.dadId) {\n', '            return false;\n', '        }\n', '\n', '        if (geneMixer.canBreed(_momId, _mom.genes, _dadId, _dad.genes)) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /// @notice Checks to see if two cuties can breed together (checks both\n', '    ///  ownership and breeding approvals, but does not check if both cuties are ready for\n', '    ///  breeding).\n', '    /// @param _momId The ID of the proposed mom.\n', '    /// @param _dadId The ID of the proposed dad.\n', '    function canBreedWith(uint40 _momId, uint40 _dadId)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        require(_momId > 0);\n', '        require(_dadId > 0);\n', '        Cutie storage mom = cuties[_momId];\n', '        Cutie storage dad = cuties[_dadId];\n', '        return _canPairMate(mom, _momId, dad, _dadId) && _isBreedingPermitted(_dadId, _momId);\n', '    }\n', '    \n', '    /// @dev Internal check to see if a given dad and mom are a valid mating pair for\n', "    ///  breeding via market (this method doesn't check ownership and if mating is allowed).\n", '    function _canMateViaMarketplace(uint40 _momId, uint40 _dadId)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        Cutie storage mom = cuties[_momId];\n', '        Cutie storage dad = cuties[_dadId];\n', '        return _canPairMate(mom, _momId, dad, _dadId);\n', '    }\n', '\n', '    function getBreedingFee(uint40 _momId, uint40 _dadId)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return config.getBreedingFee(_momId, _dadId);\n', '    }\n', '\n', '\n', '    /// @notice Breed cuties that you own, or for which you\n', '    ///  have previously been given Breeding approval. Will either make your cutie give birth, or will\n', '    ///  fail.\n', '    /// @param _momId The ID of the Cutie acting as mom (will end up give birth if successful)\n', '    /// @param _dadId The ID of the Cutie acting as dad (will begin its breeding cooldown if successful)\n', '    function breedWith(uint40 _momId, uint40 _dadId) \n', '        public\n', '        whenNotPaused\n', '        payable\n', '        returns (uint40)\n', '    {\n', '        // Caller must own the mom.\n', '        require(_isOwner(msg.sender, _momId));\n', '\n', '        // Neither dad nor mom can be on auction during\n', '        // breeding.\n', "        // For mom: The caller of this function can't be the owner of the mom\n", '        //   because the owner of a Cutie on auction is the auction house, and the\n', '        //   auction house will never call breedWith().\n', '        // For dad: Similarly, a dad on auction will be owned by the auction house\n', '        //   and the act of transferring ownership will have cleared any outstanding\n', '        //   breeding approval.\n', "        // Thus we don't need check if either cutie\n", '        // is on auction.\n', '\n', '        // Check that mom and dad are both owned by caller, or that the dad\n', "        // has given breeding permission to caller (i.e. mom's owner).\n", '        // Will fail for _dadId = 0\n', '        require(_isBreedingPermitted(_dadId, _momId));\n', '\n', '        // Check breeding fee\n', '        require(getBreedingFee(_momId, _dadId) <= msg.value);\n', '\n', '        // Grab a reference to the potential mom\n', '        Cutie storage mom = cuties[_momId];\n', '\n', "        // Make sure mom's cooldown isn't active, or in the middle of a breeding cooldown\n", '        require(_canBreed(mom));\n', '\n', '        // Grab a reference to the potential dad\n', '        Cutie storage dad = cuties[_dadId];\n', '\n', "        // Make sure dad cooldown isn't active, or in the middle of a breeding cooldown\n", '        require(_canBreed(dad));\n', '\n', '        // Test that these cuties are a valid mating pair.\n', '        require(_canPairMate(\n', '            mom,\n', '            _momId,\n', '            dad,\n', '            _dadId\n', '        ));\n', '\n', '        return _breedWith(_momId, _dadId);\n', '    }\n', '\n', '    /// @dev Internal utility function to start breeding, assumes that all breeding\n', '    ///  requirements have been checked.\n', '    function _breedWith(uint40 _momId, uint40 _dadId) internal returns (uint40)\n', '    {\n', '        // Grab a reference to the Cuties from storage.\n', '        Cutie storage dad = cuties[_dadId];\n', '        Cutie storage mom = cuties[_momId];\n', '\n', '        // Trigger the cooldown for both parents.\n', '        _triggerCooldown(_dadId, dad);\n', '        _triggerCooldown(_momId, mom);\n', '\n', '        // Clear breeding permission for both parents.\n', '        delete sireAllowedToAddress[_momId];\n', '        delete sireAllowedToAddress[_dadId];\n', '\n', '        // Check that the mom is a valid cutie.\n', '        require(mom.birthTime != 0);\n', '\n', '        // Determine the higher generation number of the two parents\n', '        uint16 babyGen = config.getBabyGen(mom.generation, dad.generation);\n', '\n', '        // Call the gene mixing operation.\n', '        uint256 childGenes = geneMixer.mixGenes(mom.genes, dad.genes);\n', '\n', '        // Make the new cutie\n', '        address owner = cutieIndexToOwner[_momId];\n', '        uint40 cutieId = _createCutie(_momId, _dadId, babyGen, getCooldownIndexFromGeneration(babyGen), childGenes, owner, mom.cooldownEndTime);\n', '\n', "        // return the new cutie's ID\n", '        return cutieId;\n', '    }\n', '\n', '    mapping(address => uint40) isTutorialPetUsed;\n', '\n', '    /// @dev Completes a breeding tutorial cutie (non existing in blockchain)\n', '    ///  with auction by bidding. Immediately breeds with dad on auction.\n', '    /// @param _dadId - ID of the dad on auction.\n', '    function bidOnBreedingAuctionTutorial(\n', '        uint40 _dadId\n', '    )\n', '        public\n', '        payable\n', '        whenNotPaused\n', '        returns (uint)\n', '    {\n', '        require(isTutorialPetUsed[msg.sender] == 0);\n', '\n', '        // Take breeding fee\n', '        uint256 fee = getBreedingFee(0, _dadId);\n', '        require(msg.value >= fee);\n', '\n', '        // breeding auction will throw if the bid fails.\n', '        breedingMarket.bid.value(msg.value - fee)(_dadId);\n', '\n', '        // Grab a reference to the Cuties from storage.\n', '        Cutie storage dad = cuties[_dadId];\n', '\n', '        // Trigger the cooldown for parent.\n', '        _triggerCooldown(_dadId, dad);\n', '\n', '        // Clear breeding permission for parent.\n', '        delete sireAllowedToAddress[_dadId];\n', '\n', '        uint16 babyGen = config.getTutorialBabyGen(dad.generation);\n', '\n', '        // tutorial pet genome is zero\n', '        uint256 childGenes = geneMixer.mixGenes(0x0, dad.genes);\n', '\n', '        // tutorial pet id is zero\n', '        uint40 cutieId = _createCutie(0, _dadId, babyGen, getCooldownIndexFromGeneration(babyGen), childGenes, msg.sender, 12);\n', '\n', '        isTutorialPetUsed[msg.sender] = cutieId;\n', '\n', "        // return the new cutie's ID\n", '        return cutieId;\n', '    }\n', '\n', '    address party1address;\n', '    address party2address;\n', '    address party3address;\n', '    address party4address;\n', '    address party5address;\n', '\n', '    /// @dev Setup project owners\n', '    function setParties(address _party1, address _party2, address _party3, address _party4, address _party5) public onlyOwner\n', '    {\n', '        require(_party1 != address(0));\n', '        require(_party2 != address(0));\n', '        require(_party3 != address(0));\n', '        require(_party4 != address(0));\n', '        require(_party5 != address(0));\n', '\n', '        party1address = _party1;\n', '        party2address = _party2;\n', '        party3address = _party3;\n', '        party4address = _party4;\n', '        party5address = _party5;\n', '    }\n', '\n', '    /// @dev Reject all Ether which is not from game contracts from being sent here.\n', '    function() external payable {\n', '        require(\n', '            msg.sender == address(saleMarket) ||\n', '            msg.sender == address(breedingMarket) ||\n', '            address(plugins[msg.sender]) != address(0)\n', '        );\n', '    }\n', '\n', '    /// @dev The balance transfer from the market and plugins contract\n', '    /// to the CutieCore contract.\n', '    function withdrawBalances() external\n', '    {\n', '        require(\n', '            msg.sender == ownerAddress || \n', '            msg.sender == operatorAddress);\n', '\n', '        saleMarket.withdrawEthFromBalance();\n', '        breedingMarket.withdrawEthFromBalance();\n', '        for (uint32 i = 0; i < pluginsArray.length; ++i)        \n', '        {\n', '            pluginsArray[i].withdraw();\n', '        }\n', '    }\n', '\n', '    /// @dev The balance transfer from CutieCore contract to project owners\n', '    function withdrawEthFromBalance() external\n', '    {\n', '        require(\n', '            msg.sender == party1address ||\n', '            msg.sender == party2address ||\n', '            msg.sender == party3address ||\n', '            msg.sender == party4address ||\n', '            msg.sender == party5address ||\n', '            msg.sender == ownerAddress || \n', '            msg.sender == operatorAddress);\n', '\n', '        require(party1address != 0);\n', '        require(party2address != 0);\n', '        require(party3address != 0);\n', '        require(party4address != 0);\n', '        require(party5address != 0);\n', '\n', '        uint256 total = address(this).balance;\n', '\n', '        party1address.transfer(total*105/1000);\n', '        party2address.transfer(total*105/1000);\n', '        party3address.transfer(total*140/1000);\n', '        party4address.transfer(total*140/1000);\n', '        party5address.transfer(total*510/1000);\n', '    }\n', '\n', '/*\n', ' * @title String & slice utility library for Solidity contracts.\n', ' * @author Nick Johnson <arachnid@notdot.net>\n', ' *\n', ' * @dev Functionality in this library is largely implemented using an\n', " *      abstraction called a 'slice'. A slice represents a part of a string -\n", ' *      anything from the entire string to a single character, or even no\n', ' *      characters at all (a 0-length slice). Since a slice only has to specify\n', ' *      an offset and a length, copying and manipulating slices is a lot less\n', ' *      expensive than copying and manipulating the strings they reference.\n', ' *\n', ' *      To further reduce gas costs, most functions on slice that need to return\n', ' *      a slice modify the original one instead of allocating a new one; for\n', ' *      instance, `s.split(".")` will return the text up to the first \'.\',\n', " *      modifying s to only contain the remainder of the string after the '.'.\n", ' *      In situations where you do not want to modify the original slice, you\n', ' *      can make a copy first with `.copy()`, for example:\n', ' *      `s.copy().split(".")`. Try and avoid using this idiom in loops; since\n', ' *      Solidity has no memory management, it will result in allocating many\n', ' *      short-lived slices that are later discarded.\n', ' *\n', ' *      Functions that return two slices come in two versions: a non-allocating\n', ' *      version that takes the second slice as an argument, modifying it in\n', ' *      place, and an allocating version that allocates and returns the second\n', ' *      slice; see `nextRune` for example.\n', ' *\n', ' *      Functions that have to copy string data will return strings rather than\n', ' *      slices; these can be cast back to slices for further processing if\n', ' *      required.\n', ' *\n', ' *      For convenience, some functions are provided with non-modifying\n', ' *      variants that create a new slice and return both; for instance,\n', " *      `s.splitNew('.')` leaves s unmodified, and returns two values\n", ' *      corresponding to the left and right parts of the string.\n', ' */\n', '\n', '    struct slice\n', '    {\n', '        uint _len;\n', '        uint _ptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire string.\n', '     * @param self The string to make a slice from.\n', '     * @return A newly allocated slice containing the entire string.\n', '     */\n', '    function toSlice(string self) internal pure returns (slice)\n', '    {\n', '        uint ptr;\n', '        assembly {\n', '            ptr := add(self, 0x20)\n', '        }\n', '        return slice(bytes(self).length, ptr);\n', '    }\n', '\n', '    function memcpy(uint dest, uint src, uint len) private pure\n', '    {\n', '        // Copy word-length chunks while possible\n', '        for(; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a newly allocated string containing the concatenation of\n', '     *      `self` and `other`.\n', '     * @param self The first slice to concatenate.\n', '     * @param other The second slice to concatenate.\n', '     * @return The concatenation of the two strings.\n', '     */\n', '    function concat(slice self, slice other) internal pure returns (string)\n', '    {\n', '        string memory ret = new string(self._len + other._len);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '        memcpy(retptr, self._ptr, self._len);\n', '        memcpy(retptr + self._len, other._ptr, other._len);\n', '        return ret;\n', '    }\n', '\n', '\n', '    function uintToString(uint256 a) internal pure returns (string result)\n', '    {\n', '        string memory r = "";\n', '        do\n', '        {\n', '            uint b = a % 10;\n', '            a /= 10;\n', '\n', '            string memory c = "";\n', '\n', '            if (b == 0) c = "0";\n', '            else if (b == 1) c = "1";\n', '            else if (b == 2) c = "2";\n', '            else if (b == 3) c = "3";\n', '            else if (b == 4) c = "4";\n', '            else if (b == 5) c = "5";\n', '            else if (b == 6) c = "6";\n', '            else if (b == 7) c = "7";\n', '            else if (b == 8) c = "8";\n', '            else if (b == 9) c = "9";\n', '\n', '            r = concat(toSlice(c), toSlice(r));\n', '        }\n', '        while (a > 0);\n', '        result = r;\n', '    }\n', '}']
