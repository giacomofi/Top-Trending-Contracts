['pragma solidity ^0.4.17;\n', '\n', 'contract J8TTokenConfig {\n', '    // The J8T decimals\n', '    uint8 public constant TOKEN_DECIMALS = 8;\n', '\n', '    // The J8T decimal factor to obtain luckys\n', '    uint256 public constant J8T_DECIMALS_FACTOR = 10**uint256(TOKEN_DECIMALS);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // require (_value <= _allowance);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   */\n', '  function increaseApproval (address _spender, uint _addedValue)\n', '    returns (bool success) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval (address _spender, uint _subtractedValue)\n', '    returns (bool success) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is StandardToken {\n', '\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    /**\n', '     * @dev Burns a specific amount of tokens.\n', '     * @param _value The amount of token to be burned.\n', '     */\n', '    function burn(uint256 _value) public {\n', '        require(_value > 0);\n', '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Burn(burner, _value);\n', '    }\n', '}\n', '\n', '//////////////////////////////////////////////////////////////////////\n', '// @title J8T Token                                                 //\n', '// @dev ERC20 J8T Token                                             //\n', '//                                                                  //\n', '// J8T Tokens are divisible by 1e8 (100,000,000) base               //\n', '//                                                                  //\n', '// J8T are displayed using 8 decimal places of precision.           //\n', '//                                                                  //\n', '// 1 J8T is equivalent to 100000000 luckys:                         //\n', '//   100000000 == 1 * 10**8 == 1e8 == One Hundred Million luckys    //\n', '//                                                                  //\n', '// 1,5 Billion J8T (total supply) is equivalent to:                 //\n', '//   150000000000000000 == 1500000000 * 10**8 == 1,5e17 luckys      //\n', '//                                                                  //\n', '//////////////////////////////////////////////////////////////////////\n', '\n', 'contract J8TToken is J8TTokenConfig, BurnableToken, Ownable {\n', '    string public constant name            = "J8T Token";\n', '    string public constant symbol          = "J8T";\n', '    uint256 public constant decimals       = TOKEN_DECIMALS;\n', '    uint256 public constant INITIAL_SUPPLY = 1500000000 * (10 ** uint256(decimals));\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    function J8TToken() {\n', '        totalSupply = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '\n', '        //https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer-1\n', '        //EIP 20: A token contract which creates new tokens SHOULD trigger a\n', '        //Transfer event with the _from address set to 0x0\n', '        //when tokens are created.\n', '        Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n', '     }\n', '}\n', '\n', '\n', 'contract ACLManaged is Ownable {\n', '    \n', '    ///////////////////////////\n', '    // ACLManaged PROPERTIES //\n', '    ///////////////////////////\n', '\n', '    // The operational acl address\n', '    address public opsAddress;\n', '\n', '    // The admin acl address\n', '    address public adminAddress;\n', '\n', '    ////////////////////////////////////////\n', '    // ACLManaged FUNCTIONS and MODIFIERS //\n', '    ////////////////////////////////////////\n', '\n', '    function ACLManaged() public Ownable() {}\n', '\n', '    // Updates the opsAddress propety with the new _opsAddress value\n', '    function setOpsAddress(address _opsAddress) external onlyOwner returns (bool) {\n', '        require(_opsAddress != address(0));\n', '        require(_opsAddress != address(this));\n', '\n', '        opsAddress = _opsAddress;\n', '        return true;\n', '    }\n', '\n', '    // Updates the adminAddress propety with the new _adminAddress value\n', '    function setAdminAddress(address _adminAddress) external onlyOwner returns (bool) {\n', '        require(_adminAddress != address(0));\n', '        require(_adminAddress != address(this));\n', '\n', '        adminAddress = _adminAddress;\n', '        return true;\n', '    }\n', '\n', '    //Checks if an address is owner\n', '    function isOwner(address _address) public view returns (bool) {\n', '        bool result = (_address == owner);\n', '        return result;\n', '    }\n', '\n', '    //Checks if an address is operator\n', '    function isOps(address _address) public view returns (bool) {\n', '        bool result = (_address == opsAddress);\n', '        return result;\n', '    }\n', '\n', '    //Checks if an address is ops or admin\n', '    function isOpsOrAdmin(address _address) public view returns (bool) {\n', '        bool result = (_address == opsAddress || _address == adminAddress);\n', '        return result;\n', '    }\n', '\n', '    //Checks if an address is ops,owner or admin\n', '    function isOwnerOrOpsOrAdmin(address _address) public view returns (bool) {\n', '        bool result = (_address == opsAddress || _address == adminAddress || _address == owner);\n', '        return result;\n', '    }\n', '\n', '    //Checks whether the msg.sender address is equal to the adminAddress property or not\n', '    modifier onlyAdmin() {\n', '        //Needs to be set. Default constructor will set 0x0;\n', '        address _address = msg.sender;\n', '        require(_address != address(0));\n', '        require(_address == adminAddress);\n', '        _;\n', '    }\n', '\n', '    // Checks whether the msg.sender address is equal to the opsAddress property or not\n', '    modifier onlyOps() {\n', '        //Needs to be set. Default constructor will set 0x0;\n', '        address _address = msg.sender;\n', '        require(_address != address(0));\n', '        require(_address == opsAddress);\n', '        _;\n', '    }\n', '\n', '    // Checks whether the msg.sender address is equal to the opsAddress or adminAddress property\n', '    modifier onlyAdminAndOps() {\n', '        //Needs to be set. Default constructor will set 0x0;\n', '        address _address = msg.sender;\n', '        require(_address != address(0));\n', '        require(_address == opsAddress || _address == adminAddress);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract CrowdsaleConfig is J8TTokenConfig {\n', '    using SafeMath for uint256;\n', '\n', '    // Default start token sale date is 28th February 15:00 SGP 2018\n', '    uint256 public constant START_TIMESTAMP = 1519801200;\n', '\n', '    // Default end token sale date is 14th March 15:00 SGP 2018\n', '    uint256 public constant END_TIMESTAMP   = 1521010800;\n', '\n', '    // The ETH decimal factor to obtain weis\n', '    uint256 public constant ETH_DECIMALS_FACTOR = 10**uint256(18);\n', '\n', '    // The token sale supply \n', '    uint256 public constant TOKEN_SALE_SUPPLY = 450000000 * J8T_DECIMALS_FACTOR;\n', '\n', '    // The minimum contribution amount in weis\n', '    uint256 public constant MIN_CONTRIBUTION_WEIS = 0.1 ether;\n', '\n', '    // The maximum contribution amount in weis\n', '    uint256 public constant MAX_CONTRIBUTION_WEIS = 10 ether;\n', '\n', '    //@WARNING: WORKING WITH KILO-MULTIPLES TO AVOID IMPOSSIBLE DIVISIONS OF FLOATING POINTS.\n', '    uint256 constant dollar_per_kilo_token = 100; //0.1 dollar per token\n', '    uint256 public constant dollars_per_kilo_ether = 900000; //900$ per ether\n', '    //TOKENS_PER_ETHER = dollars_per_ether / dollar_per_token\n', '    uint256 public constant INITIAL_TOKENS_PER_ETHER = dollars_per_kilo_ether.div(dollar_per_kilo_token);\n', '}\n', '\n', 'contract Ledger is ACLManaged {\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    ///////////////////////\n', '    // Ledger PROPERTIES //\n', '    ///////////////////////\n', '\n', '    // The Allocation struct represents a token sale purchase\n', '    // amountGranted is the amount of tokens purchased\n', '    // hasClaimedBonusTokens whether the allocation has been alredy claimed\n', '    struct Allocation {\n', '        uint256 amountGranted;\n', '        uint256 amountBonusGranted;\n', '        bool hasClaimedBonusTokens;\n', '    }\n', '\n', '    // ContributionPhase enum cases are\n', '    // PreSaleContribution, the contribution has been made in the presale phase\n', '    // PartnerContribution, the contribution has been made in the private phase\n', '    enum ContributionPhase {\n', '        PreSaleContribution, PartnerContribution\n', '    }\n', '\n', '    // Map of adresses that purchased tokens on the presale phase\n', '    mapping(address => Allocation) public presaleAllocations;\n', '\n', '    // Map of adresses that purchased tokens on the private phase\n', '    mapping(address => Allocation) public partnerAllocations;\n', '\n', '    // Reference to the J8TToken contract\n', '    J8TToken public tokenContract;\n', '\n', '    // Reference to the Crowdsale contract\n', '    Crowdsale public crowdsaleContract;\n', '\n', '    // Total private allocation, counting the amount of tokens from the\n', '    // partner and the presale phase\n', '    uint256 public totalPrivateAllocation;\n', '\n', '    // Whether the token allocations can be claimed on the partner sale phase\n', '    bool public canClaimPartnerTokens;\n', '\n', '    // Whether the token allocations can be claimed on the presale sale phase\n', '    bool public canClaimPresaleTokens;\n', '\n', '    // Whether the bonus token allocations can be claimed\n', '    bool public canClaimPresaleBonusTokensPhase1;\n', '    bool public canClaimPresaleBonusTokensPhase2;\n', '\n', '    // Whether the bonus token allocations can be claimed\n', '    bool public canClaimPartnerBonusTokensPhase1;\n', '    bool public canClaimPartnerBonusTokensPhase2;\n', '\n', '    ///////////////////\n', '    // Ledger EVENTS //\n', '    ///////////////////\n', '\n', '    // Triggered when an allocation has been granted\n', '    event AllocationGranted(address _contributor, uint256 _amount, uint8 _phase);\n', '\n', '    // Triggered when an allocation has been revoked\n', '    event AllocationRevoked(address _contributor, uint256 _amount, uint8 _phase);\n', '\n', '    // Triggered when an allocation has been claimed\n', '    event AllocationClaimed(address _contributor, uint256 _amount);\n', '\n', '    // Triggered when a bonus allocation has been claimed\n', '    event AllocationBonusClaimed(address _contributor, uint256 _amount);\n', '\n', '    // Triggered when crowdsale contract updated\n', '    event CrowdsaleContractUpdated(address _who, address _old_address, address _new_address);\n', '\n', '    //Triggered when any can claim token boolean is updated. _type param indicates which is updated.\n', '    event CanClaimTokensUpdated(address _who, string _type, bool _oldCanClaim, bool _newCanClaim);\n', '\n', '    //////////////////////\n', '    // Ledger FUNCTIONS //\n', '    //////////////////////\n', '\n', '    // Ledger constructor\n', '    // Sets default values for canClaimPresaleTokens and canClaimPartnerTokens properties\n', '    function Ledger(J8TToken _tokenContract) public {\n', '        require(address(_tokenContract) != address(0));\n', '        tokenContract = _tokenContract;\n', '        canClaimPresaleTokens = false;\n', '        canClaimPartnerTokens = false;\n', '        canClaimPresaleBonusTokensPhase1 = false;\n', '        canClaimPresaleBonusTokensPhase2 = false;\n', '        canClaimPartnerBonusTokensPhase1 = false;\n', '        canClaimPartnerBonusTokensPhase2 = false;\n', '    }\n', '\n', '    function () external payable {\n', '        claimTokens();\n', '    }\n', '\n', '    // Revokes an allocation from the contributor with address _contributor\n', '    // Deletes the allocation from the corresponding mapping property and transfers\n', '    // the total amount of tokens of the allocation back to the Crowdsale contract\n', '    function revokeAllocation(address _contributor, uint8 _phase) public onlyAdminAndOps payable returns (uint256) {\n', '        require(_contributor != address(0));\n', '        require(_contributor != address(this));\n', '\n', "        // Can't revoke  an allocation if the contribution phase is not in the ContributionPhase enum\n", '        ContributionPhase _contributionPhase = ContributionPhase(_phase);\n', '        require(_contributionPhase == ContributionPhase.PreSaleContribution ||\n', '                _contributionPhase == ContributionPhase.PartnerContribution);\n', '\n', '        uint256 grantedAllocation = 0;\n', '\n', '        // Deletes the allocation from the respective mapping\n', '        if (_contributionPhase == ContributionPhase.PreSaleContribution) {\n', '            grantedAllocation = presaleAllocations[_contributor].amountGranted.add(presaleAllocations[_contributor].amountBonusGranted);\n', '            delete presaleAllocations[_contributor];\n', '        } else if (_contributionPhase == ContributionPhase.PartnerContribution) {\n', '            grantedAllocation = partnerAllocations[_contributor].amountGranted.add(partnerAllocations[_contributor].amountBonusGranted);\n', '            delete partnerAllocations[_contributor];\n', '        }\n', '\n', '        // The granted amount allocation must be less that the current token supply on the contract\n', '        uint256 currentSupply = tokenContract.balanceOf(address(this));\n', '        require(grantedAllocation <= currentSupply);\n', '\n', '        // Updates the total private allocation substracting the amount of tokens that has been revoked\n', '        require(grantedAllocation <= totalPrivateAllocation);\n', '        totalPrivateAllocation = totalPrivateAllocation.sub(grantedAllocation);\n', '        \n', '        // We sent back the amount of tokens that has been revoked to the corwdsale contract\n', '        require(tokenContract.transfer(address(crowdsaleContract), grantedAllocation));\n', '\n', '        AllocationRevoked(_contributor, grantedAllocation, _phase);\n', '\n', '        return grantedAllocation;\n', '\n', '    }\n', '\n', '    // Adds a new allocation for the contributor with address _contributor\n', '    function addAllocation(address _contributor, uint256 _amount, uint256 _bonus, uint8 _phase) public onlyAdminAndOps returns (bool) {\n', '        require(_contributor != address(0));\n', '        require(_contributor != address(this));\n', '\n', "        // Can't create or update an allocation if the amount of tokens to be allocated is not greater than zero\n", '        require(_amount > 0);\n', '\n', "        // Can't create an allocation if the contribution phase is not in the ContributionPhase enum\n", '        ContributionPhase _contributionPhase = ContributionPhase(_phase);\n', '        require(_contributionPhase == ContributionPhase.PreSaleContribution ||\n', '                _contributionPhase == ContributionPhase.PartnerContribution);\n', '\n', '\n', '        uint256 totalAmount = _amount.add(_bonus);\n', '        uint256 totalGrantedAllocation = 0;\n', '        uint256 totalGrantedBonusAllocation = 0;\n', '\n', '        // Fetch the allocation from the respective mapping and updates the granted amount of tokens\n', '        if (_contributionPhase == ContributionPhase.PreSaleContribution) {\n', '            totalGrantedAllocation = presaleAllocations[_contributor].amountGranted.add(_amount);\n', '            totalGrantedBonusAllocation = presaleAllocations[_contributor].amountBonusGranted.add(_bonus);\n', '            presaleAllocations[_contributor] = Allocation(totalGrantedAllocation, totalGrantedBonusAllocation, false);\n', '        } else if (_contributionPhase == ContributionPhase.PartnerContribution) {\n', '            totalGrantedAllocation = partnerAllocations[_contributor].amountGranted.add(_amount);\n', '            totalGrantedBonusAllocation = partnerAllocations[_contributor].amountBonusGranted.add(_bonus);\n', '            partnerAllocations[_contributor] = Allocation(totalGrantedAllocation, totalGrantedBonusAllocation, false);\n', '        }\n', '\n', '        // Updates the contract data\n', '        totalPrivateAllocation = totalPrivateAllocation.add(totalAmount);\n', '\n', '        AllocationGranted(_contributor, totalAmount, _phase);\n', '\n', '        return true;\n', '    }\n', '\n', '    // The claimTokens() function handles the contribution token claim.\n', '    // Tokens can only be claimed after we open this phase.\n', '    // The lockouts periods are defined by the foundation.\n', '    // There are 2 different lockouts:\n', '    //      Presale lockout\n', '    //      Partner lockout\n', '    //\n', '    // A contributor that has contributed in all the phases can claim\n', '    // all its tokens, but only the ones that are accesible to claim\n', '    // be transfered.\n', '    // \n', '    // A contributor can claim its tokens after each phase has been opened\n', '    function claimTokens() public payable returns (bool) {\n', '        require(msg.sender != address(0));\n', '        require(msg.sender != address(this));\n', '\n', '        uint256 amountToTransfer = 0;\n', '\n', '        // We need to check if the contributor has made a contribution on each\n', '        // phase, presale and partner\n', '        Allocation storage presaleA = presaleAllocations[msg.sender];\n', '        if (presaleA.amountGranted > 0 && canClaimPresaleTokens) {\n', '            amountToTransfer = amountToTransfer.add(presaleA.amountGranted);\n', '            presaleA.amountGranted = 0;\n', '        }\n', '\n', '        Allocation storage partnerA = partnerAllocations[msg.sender];\n', '        if (partnerA.amountGranted > 0 && canClaimPartnerTokens) {\n', '            amountToTransfer = amountToTransfer.add(partnerA.amountGranted);\n', '            partnerA.amountGranted = 0;\n', '        }\n', '\n', '        // The amount to transfer must greater than zero\n', '        require(amountToTransfer > 0);\n', '\n', '        // The amount to transfer must be less or equal to the current supply\n', '        uint256 currentSupply = tokenContract.balanceOf(address(this));\n', '        require(amountToTransfer <= currentSupply);\n', '        \n', '        // Transfer the token allocation to contributor\n', '        require(tokenContract.transfer(msg.sender, amountToTransfer));\n', '        AllocationClaimed(msg.sender, amountToTransfer);\n', '    \n', '        return true;\n', '    }\n', '\n', '    function claimBonus() external payable returns (bool) {\n', '        require(msg.sender != address(0));\n', '        require(msg.sender != address(this));\n', '\n', '        uint256 amountToTransfer = 0;\n', '\n', '        // BONUS PHASE 1\n', '        Allocation storage presale = presaleAllocations[msg.sender];\n', '        if (presale.amountBonusGranted > 0 && !presale.hasClaimedBonusTokens && canClaimPresaleBonusTokensPhase1) {\n', '            uint256 amountPresale = presale.amountBonusGranted.div(2);\n', '            amountToTransfer = amountPresale;\n', '            presale.amountBonusGranted = amountPresale;\n', '            presale.hasClaimedBonusTokens = true;\n', '        }\n', '\n', '        Allocation storage partner = partnerAllocations[msg.sender];\n', '        if (partner.amountBonusGranted > 0 && !partner.hasClaimedBonusTokens && canClaimPartnerBonusTokensPhase1) {\n', '            uint256 amountPartner = partner.amountBonusGranted.div(2);\n', '            amountToTransfer = amountToTransfer.add(amountPartner);\n', '            partner.amountBonusGranted = amountPartner;\n', '            partner.hasClaimedBonusTokens = true;\n', '        }\n', '\n', '        // BONUS PHASE 2\n', '        if (presale.amountBonusGranted > 0 && canClaimPresaleBonusTokensPhase2) {\n', '            amountToTransfer = amountToTransfer.add(presale.amountBonusGranted);\n', '            presale.amountBonusGranted = 0;\n', '        }\n', '\n', '        if (partner.amountBonusGranted > 0 && canClaimPartnerBonusTokensPhase2) {\n', '            amountToTransfer = amountToTransfer.add(partner.amountBonusGranted);\n', '            partner.amountBonusGranted = 0;\n', '        }\n', '\n', '        // The amount to transfer must greater than zero\n', '        require(amountToTransfer > 0);\n', '\n', '        // The amount to transfer must be less or equal to the current supply\n', '        uint256 currentSupply = tokenContract.balanceOf(address(this));\n', '        require(amountToTransfer <= currentSupply);\n', '        \n', '        // Transfer the token allocation to contributor\n', '        require(tokenContract.transfer(msg.sender, amountToTransfer));\n', '        AllocationBonusClaimed(msg.sender, amountToTransfer);\n', '\n', '        return true;\n', '    }\n', '\n', '    // Updates the canClaimPresaleTokens propety with the new _canClaimTokens value\n', '    function setCanClaimPresaleTokens(bool _canClaimTokens) external onlyAdmin returns (bool) {\n', '        bool _oldCanClaim = canClaimPresaleTokens;\n', '        canClaimPresaleTokens = _canClaimTokens;\n', "        CanClaimTokensUpdated(msg.sender, 'canClaimPresaleTokens', _oldCanClaim, _canClaimTokens);\n", '        return true;\n', '    }\n', '\n', '    // Updates the canClaimPartnerTokens property with the new _canClaimTokens value\n', '    function setCanClaimPartnerTokens(bool _canClaimTokens) external onlyAdmin returns (bool) {\n', '        bool _oldCanClaim = canClaimPartnerTokens;\n', '        canClaimPartnerTokens = _canClaimTokens;\n', "        CanClaimTokensUpdated(msg.sender, 'canClaimPartnerTokens', _oldCanClaim, _canClaimTokens);\n", '        return true;\n', '    }\n', '\n', '    // Updates the canClaimBonusTokens property with the new _canClaimTokens value\n', '    function setCanClaimPresaleBonusTokensPhase1(bool _canClaimTokens) external onlyAdmin returns (bool) {\n', '        bool _oldCanClaim = canClaimPresaleBonusTokensPhase1;\n', '        canClaimPresaleBonusTokensPhase1 = _canClaimTokens;\n', "        CanClaimTokensUpdated(msg.sender, 'canClaimPresaleBonusTokensPhase1', _oldCanClaim, _canClaimTokens);\n", '        return true;\n', '    }\n', '\n', '    // Updates the canClaimBonusTokens property with the new _canClaimTokens value\n', '    function setCanClaimPresaleBonusTokensPhase2(bool _canClaimTokens) external onlyAdmin returns (bool) {\n', '        bool _oldCanClaim = canClaimPresaleBonusTokensPhase2;\n', '        canClaimPresaleBonusTokensPhase2 = _canClaimTokens;\n', "        CanClaimTokensUpdated(msg.sender, 'canClaimPresaleBonusTokensPhase2', _oldCanClaim, _canClaimTokens);\n", '        return true;\n', '    }\n', '\n', '    // Updates the canClaimBonusTokens property with the new _canClaimTokens value\n', '    function setCanClaimPartnerBonusTokensPhase1(bool _canClaimTokens) external onlyAdmin returns (bool) {\n', '        bool _oldCanClaim = canClaimPartnerBonusTokensPhase1;\n', '        canClaimPartnerBonusTokensPhase1 = _canClaimTokens;\n', "        CanClaimTokensUpdated(msg.sender, 'canClaimPartnerBonusTokensPhase1', _oldCanClaim, _canClaimTokens);\n", '        return true;\n', '    }\n', '\n', '    // Updates the canClaimBonusTokens property with the new _canClaimTokens value\n', '    function setCanClaimPartnerBonusTokensPhase2(bool _canClaimTokens) external onlyAdmin returns (bool) {\n', '        bool _oldCanClaim = canClaimPartnerBonusTokensPhase2;\n', '        canClaimPartnerBonusTokensPhase2 = _canClaimTokens;\n', "        CanClaimTokensUpdated(msg.sender, 'canClaimPartnerBonusTokensPhase2', _oldCanClaim, _canClaimTokens);\n", '        return true;\n', '    }\n', '\n', '    // Updates the crowdsale contract property with the new _crowdsaleContract value\n', '    function setCrowdsaleContract(Crowdsale _crowdsaleContract) public onlyOwner returns (bool) {\n', '        address old_crowdsale_address = crowdsaleContract;\n', '\n', '        crowdsaleContract = _crowdsaleContract;\n', '\n', '        CrowdsaleContractUpdated(msg.sender, old_crowdsale_address, crowdsaleContract);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract Crowdsale is ACLManaged, CrowdsaleConfig {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    //////////////////////////\n', '    // Crowdsale PROPERTIES //\n', '    //////////////////////////\n', '\n', '    // The J8TToken smart contract reference\n', '    J8TToken public tokenContract;\n', '\n', '    // The Ledger smart contract reference\n', '    Ledger public ledgerContract;\n', '\n', '    // The start token sale date represented as a timestamp\n', '    uint256 public startTimestamp;\n', '\n', '    // The end token sale date represented as a timestamp\n', '    uint256 public endTimestamp;\n', '\n', '    // Ratio of J8T tokens to per ether\n', '    uint256 public tokensPerEther;\n', '\n', '    // The total amount of wei raised in the token sale\n', '    // Including presales (in eth) and public sale\n', '    uint256 public weiRaised;\n', '\n', '    // The current total amount of tokens sold in the token sale\n', '    uint256 public totalTokensSold;\n', '\n', '    // The minimum and maximum eth contribution accepted in the token sale\n', '    uint256 public minContribution;\n', '    uint256 public maxContribution;\n', '\n', '    // The wallet address where the token sale sends all eth contributions\n', '    address public wallet;\n', '\n', '    // Controls whether the token sale has finished or not\n', '    bool public isFinalized = false;\n', '\n', '    // Map of adresses that requested to purchase tokens\n', '    // Contributors of the token sale are segmented as:\n', '    //  CannotContribute: Cannot contribute in any phase (uint8  - 0)\n', '    //  PreSaleContributor: Can contribute on both pre-sale and pubic sale phases (uint8  - 1)\n', '    //  PublicSaleContributor: Can contribute on he public sale phase (uint8  - 2)\n', '    mapping(address => WhitelistPermission) public whitelist;\n', '\n', '    // Map of addresses that has already contributed on the token sale\n', '    mapping(address => bool) public hasContributed;\n', '\n', '    enum WhitelistPermission {\n', '        CannotContribute, PreSaleContributor, PublicSaleContributor \n', '    }\n', '\n', '    //////////////////////\n', '    // Crowdsale EVENTS //\n', '    //////////////////////\n', '\n', '    // Triggered when a contribution in the public sale has been processed correctly\n', '    event TokensPurchased(address _contributor, uint256 _amount);\n', '\n', '    // Triggered when the whitelist has been updated\n', '    event WhiteListUpdated(address _who, address _account, WhitelistPermission _phase);\n', '\n', '    // Triggered when the Crowdsale has been created\n', '    event ContractCreated();\n', '\n', '    // Triggered when a presale has been added\n', '    // The phase parameter can be a strategic partner contribution or a presale contribution\n', '    event PresaleAdded(address _contributor, uint256 _amount, uint8 _phase);\n', '\n', '    // Triggered when the tokensPerEther property has been updated\n', '    event TokensPerEtherUpdated(address _who, uint256 _oldValue, uint256 _newValue);\n', '\n', '    // Triggered when the startTimestamp property has been updated\n', '    event StartTimestampUpdated(address _who, uint256 _oldValue, uint256 _newValue);\n', '\n', '    // Triggered when the endTimestamp property has been updated\n', '    event EndTimestampUpdated(address _who, uint256 _oldValue, uint256 _newValue);\n', '\n', '    // Triggered when the wallet property has been updated\n', '    event WalletUpdated(address _who, address _oldWallet, address _newWallet);\n', '\n', '    // Triggered when the minContribution property has been updated\n', '    event MinContributionUpdated(address _who, uint256 _oldValue, uint256 _newValue);\n', '\n', '    // Triggered when the maxContribution property has been updated\n', '    event MaxContributionUpdated(address _who, uint256 _oldValue, uint256 _newValue);\n', '\n', '    // Triggered when the token sale has finalized\n', '    event Finalized(address _who, uint256 _timestamp);\n', '\n', '    // Triggered when the token sale has finalized and there where still token to sale\n', '    // When the token are not sold, we burn them\n', '    event Burned(address _who, uint256 _amount, uint256 _timestamp);\n', '\n', '    /////////////////////////\n', '    // Crowdsale FUNCTIONS //\n', '    /////////////////////////\n', '    \n', '\n', '    // Crowdsale constructor\n', '    // Takes default values from the CrowdsaleConfig smart contract\n', '    function Crowdsale(\n', '        J8TToken _tokenContract,\n', '        Ledger _ledgerContract,\n', '        address _wallet\n', '    ) public\n', '    {\n', '        uint256 _start            = START_TIMESTAMP;\n', '        uint256 _end              = END_TIMESTAMP;\n', '        uint256 _supply           = TOKEN_SALE_SUPPLY;\n', '        uint256 _min_contribution = MIN_CONTRIBUTION_WEIS;\n', '        uint256 _max_contribution = MAX_CONTRIBUTION_WEIS;\n', '        uint256 _tokensPerEther   = INITIAL_TOKENS_PER_ETHER;\n', '\n', '        require(_start > currentTime());\n', '        require(_end > _start);\n', '        require(_tokensPerEther > 0);\n', '        require(address(_tokenContract) != address(0));\n', '        require(address(_ledgerContract) != address(0));\n', '        require(_wallet != address(0));\n', '\n', '        ledgerContract   = _ledgerContract;\n', '        tokenContract    = _tokenContract;\n', '        startTimestamp   = _start;\n', '        endTimestamp     = _end;\n', '        tokensPerEther   = _tokensPerEther;\n', '        minContribution = _min_contribution;\n', '        maxContribution = _max_contribution;\n', '        wallet           = _wallet;\n', '        totalTokensSold  = 0;\n', '        weiRaised        = 0;\n', '        isFinalized      = false;  \n', '\n', '        ContractCreated();\n', '    }\n', '\n', '    // Updates the tokenPerEther propety with the new _tokensPerEther value\n', '    function setTokensPerEther(uint256 _tokensPerEther) external onlyAdmin onlyBeforeSale returns (bool) {\n', '        require(_tokensPerEther > 0);\n', '\n', '        uint256 _oldValue = tokensPerEther;\n', '        tokensPerEther = _tokensPerEther;\n', '\n', '        TokensPerEtherUpdated(msg.sender, _oldValue, tokensPerEther);\n', '        return true;\n', '    }\n', '\n', '    // Updates the startTimestamp propety with the new _start value\n', '    function setStartTimestamp(uint256 _start) external onlyAdmin returns (bool) {\n', '        require(_start < endTimestamp);\n', '        require(_start > currentTime());\n', '\n', '        uint256 _oldValue = startTimestamp;\n', '        startTimestamp = _start;\n', '\n', '        StartTimestampUpdated(msg.sender, _oldValue, startTimestamp);\n', '\n', '        return true;\n', '    }\n', '\n', '    // Updates the endTimestamp propety with the new _end value\n', '    function setEndTimestamp(uint256 _end) external onlyAdmin returns (bool) {\n', '        require(_end > startTimestamp);\n', '\n', '        uint256 _oldValue = endTimestamp;\n', '        endTimestamp = _end;\n', '\n', '        EndTimestampUpdated(msg.sender, _oldValue, endTimestamp);\n', '        \n', '        return true;\n', '    }\n', '\n', '    // Updates the wallet propety with the new _newWallet value\n', '    function updateWallet(address _newWallet) external onlyAdmin returns (bool) {\n', '        require(_newWallet != address(0));\n', '        \n', '        address _oldValue = wallet;\n', '        wallet = _newWallet;\n', '        \n', '        WalletUpdated(msg.sender, _oldValue, wallet);\n', '        \n', '        return true;\n', '    }\n', '\n', '    // Updates the minContribution propety with the new _newMinControbution value\n', '    function setMinContribution(uint256 _newMinContribution) external onlyAdmin returns (bool) {\n', '        require(_newMinContribution <= maxContribution);\n', '\n', '        uint256 _oldValue = minContribution;\n', '        minContribution = _newMinContribution;\n', '        \n', '        MinContributionUpdated(msg.sender, _oldValue, minContribution);\n', '        \n', '        return true;\n', '    }\n', '\n', '    // Updates the maxContribution propety with the new _newMaxContribution value\n', '    function setMaxContribution(uint256 _newMaxContribution) external onlyAdmin returns (bool) {\n', '        require(_newMaxContribution > minContribution);\n', '\n', '        uint256 _oldValue = maxContribution;\n', '        maxContribution = _newMaxContribution;\n', '        \n', '        MaxContributionUpdated(msg.sender, _oldValue, maxContribution);\n', '        \n', '        return true;\n', '    }\n', '\n', '    // Main public function.\n', '    function () external payable {\n', '        purchaseTokens();\n', '    }\n', '\n', '    // Revokes a presale allocation from the contributor with address _contributor\n', '    // Updates the totalTokensSold property substracting the amount of tokens that where previously allocated\n', '    function revokePresale(address _contributor, uint8 _contributorPhase) external onlyAdmin returns (bool) {\n', '        require(_contributor != address(0));\n', '\n', '        // We can only revoke allocations from pre sale or strategic partners\n', '        // ContributionPhase.PreSaleContribution == 0,  ContributionPhase.PartnerContribution == 1\n', '        require(_contributorPhase == 0 || _contributorPhase == 1);\n', '\n', '        uint256 luckys = ledgerContract.revokeAllocation(_contributor, _contributorPhase);\n', '        \n', '        require(luckys > 0);\n', '        require(luckys <= totalTokensSold);\n', '        \n', '        totalTokensSold = totalTokensSold.sub(luckys);\n', '        \n', '        return true;\n', '    }\n', '\n', '    // Adds a new presale allocation for the contributor with address _contributor\n', '    // We can only allocate presale before the token sale has been initialized\n', '    function addPresale(address _contributor, uint256 _tokens, uint256 _bonus, uint8 _contributorPhase) external onlyAdminAndOps onlyBeforeSale returns (bool) {\n', '        require(_tokens > 0);\n', '        require(_bonus > 0);\n', '\n', '        // Converts the amount of tokens to our smallest J8T value, lucky\n', '        uint256 luckys = _tokens.mul(J8T_DECIMALS_FACTOR);\n', '        uint256 bonusLuckys = _bonus.mul(J8T_DECIMALS_FACTOR);\n', '        uint256 totalTokens = luckys.add(bonusLuckys);\n', '\n', '        uint256 availableTokensToPurchase = tokenContract.balanceOf(address(this));\n', '        \n', '        require(totalTokens <= availableTokensToPurchase);\n', '\n', '        // Insert the new allocation to the Ledger\n', '        require(ledgerContract.addAllocation(_contributor, luckys, bonusLuckys, _contributorPhase));\n', '        // Transfers the tokens form the Crowdsale contract to the Ledger contract\n', '        require(tokenContract.transfer(address(ledgerContract), totalTokens));\n', '\n', '        // Updates totalTokensSold property\n', '        totalTokensSold = totalTokensSold.add(totalTokens);\n', '\n', '        // If we reach the total amount of tokens to sell we finilize the token sale\n', '        availableTokensToPurchase = tokenContract.balanceOf(address(this));\n', '        if (availableTokensToPurchase == 0) {\n', '            finalization();\n', '        }\n', '\n', '        // Trigger PresaleAdded event\n', '        PresaleAdded(_contributor, totalTokens, _contributorPhase);\n', '    }\n', '\n', '    // The purchaseTokens function handles the token purchase flow\n', '    function purchaseTokens() public payable onlyDuringSale returns (bool) {\n', '        address contributor = msg.sender;\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // A contributor can only contribute once on the public sale\n', '        require(hasContributed[contributor] == false);\n', '        // The contributor address must be whitelisted in order to be able to purchase tokens\n', '        require(contributorCanContribute(contributor));\n', '        // The weiAmount must be greater or equal than minContribution\n', '        require(weiAmount >= minContribution);\n', '        // The weiAmount cannot be greater than maxContribution\n', '        require(weiAmount <= maxContribution);\n', '        // The availableTokensToPurchase must be greater than 0\n', '        require(totalTokensSold < TOKEN_SALE_SUPPLY);\n', '        uint256 availableTokensToPurchase = TOKEN_SALE_SUPPLY.sub(totalTokensSold);\n', '\n', '        // We need to convert the tokensPerEther to luckys (10**8)\n', '        uint256 luckyPerEther = tokensPerEther.mul(J8T_DECIMALS_FACTOR);\n', '\n', '        // In order to calculate the tokens amount to be allocated to the contrbutor\n', '        // we need to multiply the amount of wei sent by luckyPerEther and divide the\n', '        // result for the ether decimal factor (10**18)\n', '        uint256 tokensAmount = weiAmount.mul(luckyPerEther).div(ETH_DECIMALS_FACTOR);\n', '        \n', '\n', '        uint256 refund = 0;\n', '        uint256 tokensToPurchase = tokensAmount;\n', '        \n', '        // If the token purchase amount is bigger than the remaining token allocation\n', '        // we can only sell the remainging tokens and refund the unused amount of eth\n', '        if (availableTokensToPurchase < tokensAmount) {\n', '            tokensToPurchase = availableTokensToPurchase;\n', '            weiAmount = tokensToPurchase.mul(ETH_DECIMALS_FACTOR).div(luckyPerEther);\n', '            refund = msg.value.sub(weiAmount);\n', '        }\n', '\n', '        // We update the token sale contract data\n', '        totalTokensSold = totalTokensSold.add(tokensToPurchase);\n', '        uint256 weiToPurchase = tokensToPurchase.div(tokensPerEther);\n', '        weiRaised = weiRaised.add(weiToPurchase);\n', '\n', '        // Transfers the tokens form the Crowdsale contract to contriutors wallet\n', '        require(tokenContract.transfer(contributor, tokensToPurchase));\n', '\n', '        // Issue a refund for any unused ether \n', '        if (refund > 0) {\n', '            contributor.transfer(refund);\n', '        }\n', '\n', '        // Transfer ether contribution to the wallet\n', '        wallet.transfer(weiAmount);\n', '\n', '        // Update hasContributed mapping\n', '        hasContributed[contributor] = true;\n', '\n', '        TokensPurchased(contributor, tokensToPurchase);\n', '\n', '        // If we reach the total amount of tokens to sell we finilize the token sale\n', '        if (totalTokensSold == TOKEN_SALE_SUPPLY) {\n', '            finalization();\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    // Updates the whitelist\n', '    function updateWhitelist(address _account, WhitelistPermission _permission) external onlyAdminAndOps returns (bool) {\n', '        require(_account != address(0));\n', '        require(_permission == WhitelistPermission.PreSaleContributor || _permission == WhitelistPermission.PublicSaleContributor || _permission == WhitelistPermission.CannotContribute);\n', '        require(!saleHasFinished());\n', '\n', '        whitelist[_account] = _permission;\n', '\n', '        address _who = msg.sender;\n', '        WhiteListUpdated(_who, _account, _permission);\n', '\n', '        return true;\n', '    }\n', '\n', '    function updateWhitelist_batch(address[] _accounts, WhitelistPermission _permission) external onlyAdminAndOps returns (bool) {\n', '        require(_permission == WhitelistPermission.PreSaleContributor || _permission == WhitelistPermission.PublicSaleContributor || _permission == WhitelistPermission.CannotContribute);\n', '        require(!saleHasFinished());\n', '\n', '        for(uint i = 0; i < _accounts.length; ++i) {\n', '            require(_accounts[i] != address(0));\n', '            whitelist[_accounts[i]] = _permission;\n', '            WhiteListUpdated(msg.sender, _accounts[i], _permission);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    // Checks that the status of an address account\n', '    // Contributors of the token sale are segmented as:\n', '    //  PreSaleContributor: Can contribute on both pre-sale and pubic sale phases\n', '    //  PublicSaleContributor: Can contribute on he public sale phase\n', '    //  CannotContribute: Cannot contribute in any phase\n', '    function contributorCanContribute(address _contributorAddress) private view returns (bool) {\n', '        WhitelistPermission _contributorPhase = whitelist[_contributorAddress];\n', '\n', '        if (_contributorPhase == WhitelistPermission.CannotContribute) {\n', '            return false;\n', '        }\n', '\n', '        if (_contributorPhase == WhitelistPermission.PreSaleContributor || \n', '            _contributorPhase == WhitelistPermission.PublicSaleContributor) {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    // Returns the current time\n', '    function currentTime() public view returns (uint256) {\n', '        return now;\n', '    }\n', '\n', '    // Checks if the sale has finished\n', '    function saleHasFinished() public view returns (bool) {\n', '        if (isFinalized) {\n', '            return true;\n', '        }\n', '\n', '        if (endTimestamp < currentTime()) {\n', '            return true;\n', '        }\n', '\n', '        if (totalTokensSold == TOKEN_SALE_SUPPLY) {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    modifier onlyBeforeSale() {\n', '        require(currentTime() < startTimestamp);\n', '        _;\n', '    }\n', '\n', '    modifier onlyDuringSale() {\n', '        uint256 _currentTime = currentTime();\n', '        require(startTimestamp < _currentTime);\n', '        require(_currentTime < endTimestamp);\n', '        _;\n', '    }\n', '\n', '    modifier onlyPostSale() {\n', '        require(endTimestamp < currentTime());\n', '        _;\n', '    }\n', '\n', '    ///////////////////////\n', '    // PRIVATE FUNCTIONS //\n', '    ///////////////////////\n', '\n', '    // This method is for to be called only for the owner. This way we protect for anyone who wanna finalize the ICO.\n', '    function finalize() external onlyAdmin returns (bool) {\n', '        return finalization();\n', '    }\n', '\n', '    // Only used by finalize and setFinalized.\n', '    // Overloaded logic for two uses.\n', '    // NOTE: In case finalize is called by an user and not from addPresale()/purchaseToken()\n', '    // will diff total supply with sold supply to burn token.\n', '    function finalization() private returns (bool) {\n', '        require(!isFinalized);\n', '\n', '        isFinalized = true;\n', '\n', '        \n', '        if (totalTokensSold < TOKEN_SALE_SUPPLY) {\n', '            uint256 toBurn = TOKEN_SALE_SUPPLY.sub(totalTokensSold);\n', '            tokenContract.burn(toBurn);\n', '            Burned(msg.sender, toBurn, currentTime());\n', '        }\n', '\n', '        Finalized(msg.sender, currentTime());\n', '\n', '        return true;\n', '    }\n', '\n', '    function saleSupply() public view returns (uint256) {\n', '        return tokenContract.balanceOf(address(this));\n', '    }\n', '}']