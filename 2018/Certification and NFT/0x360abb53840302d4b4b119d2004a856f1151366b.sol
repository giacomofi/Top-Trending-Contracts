['pragma solidity ^0.4.18;\n', '\n', 'contract ERC721 {\n', '    // Required methods\n', '    function totalSupply() public view returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint _tokenId) external view returns (address _owner);\n', '    function approve(address _to, uint _tokenId) external;\n', '    function transferFrom(address _from, address _to, uint _tokenId) external;\n', '    function transfer(address _to, uint _tokenId) external;\n', '    \n', '    // Events\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '    // Optional functions\n', '    // function name() public view returns (string _name);\n', '    // function symbol() public view returns (string _symbol);\n', '    // function tokenOfOwnerByIndex(address _owner, uint _index) external view returns (uint _tokenId);\n', '    // function tokenMetadata(uint _tokenId) public view returns (string _infoUrl);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    \n', '  address public owner;\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract AccessControl is Ownable {\n', '    \n', '    bool public paused = false;\n', '    \n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '    \n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '    \n', '    function pause() external onlyOwner whenNotPaused {\n', '        paused = true;\n', '    }\n', '    \n', '    function unpause() external onlyOwner whenPaused {\n', '        paused = false;\n', '    }\n', '    \n', '}\n', '\n', 'contract DetailBase is AccessControl {\n', '    \n', '    event Create(address owner, uint256 detailId, uint256 dna);\n', '\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '\n', '    struct Detail {\n', '        uint256 dna;\n', '        uint256 idParent;\n', '        uint64 releaseTime;\n', '    }\n', '\n', '    Detail[] details;\n', '\n', '    mapping (uint256 => address) public detailIndexToOwner;\n', '    mapping (address => uint256) public ownershipTokenCount;\n', '    mapping (uint256 => address) public detailIndexToApproved;\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        ownershipTokenCount[_to]++;\n', '        detailIndexToOwner[_tokenId] = _to;\n', '        if (_from != address(0)) {\n', '            ownershipTokenCount[_from]--;\n', '            delete detailIndexToApproved[_tokenId];\n', '        }\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function createDetail(address _owner, uint256 _dna) internal whenNotPaused returns (uint) {\n', '        Detail memory _detail = Detail(_dna, 0, uint64(now));\n', '        uint256 newDetailId = details.push(_detail) - 1;\n', '        require(newDetailId == uint256(uint32(newDetailId)));\n', '        Create(_owner, newDetailId, _detail.dna);\n', '        _transfer(0, _owner, newDetailId);\n', '\n', '        return newDetailId;\n', '    }\n', '\n', '    function getDetail(uint _id) public view returns (uint256, uint256, uint64) {\n', '        return (details[_id].dna, details[_id].idParent, details[_id].releaseTime);\n', '    }\n', '    \n', '}\n', '\n', 'contract AssemblyBase is DetailBase {\n', '        \n', '    struct Assembly {\n', '        uint256 idParent;\n', '        uint256 dna;\n', '        uint64 releaseTime;\n', '        uint64 updateTime;\n', '        uint64 startMiningTime;\n', '        uint64[] spares;\n', '        uint8 countMiningDetail;\n', '        uint8 rang;\n', '    }\n', '    \n', '    uint8[] private rangIndex = [\n', '        3,\n', '        4,\n', '        5,\n', '        6\n', '    ];\n', '    \n', '    Assembly[] assemblys;\n', '    \n', '    mapping (uint256 => address) public assemblIndexToOwner;\n', '    mapping (address => uint256) public ownershipAssemblyCount;\n', '    mapping (uint256 => address) public robotIndexToApproved;\n', '    \n', '    function gatherDetails(uint64[] _arrIdDetails) public whenNotPaused returns (uint) {\n', '        \n', '        require(_arrIdDetails.length == 7);\n', '        \n', '        for (uint i = 0; i < _arrIdDetails.length; i++) {\n', '            _checkDetail(_arrIdDetails[i], uint8(i+1));\n', '        }\n', '        \n', '        Assembly memory _ass = Assembly(0, _makeDna(_arrIdDetails), uint64(now), uint64(now), 0, _arrIdDetails, 0,  _range(_arrIdDetails));\n', '        \n', '        uint256 newAssemblyId = assemblys.push(_ass) - 1;\n', '        \n', '        for (uint j = 0; j < _arrIdDetails.length; j++) {\n', '            details[_arrIdDetails[j]].idParent = newAssemblyId;\n', '        }\n', '        \n', '        assemblIndexToOwner[newAssemblyId] = msg.sender;\n', '        ownershipAssemblyCount[msg.sender]++;\n', '        \n', '        return newAssemblyId;\n', '    }\n', '    \n', '    function changeAssembly(uint _id, uint64[] _index, uint64[] _arrIdReplace) public whenNotPaused {\n', '        require(_index.length == _arrIdReplace.length &&\n', '                assemblIndexToOwner[_id] == msg.sender &&\n', '                assemblys[_id].startMiningTime == 0);\n', '        for (uint i = 0; i < _arrIdReplace.length; i++) {\n', '            _checkDetail(_arrIdReplace[i], uint8(_index[i] + 1));\n', '        }\n', '        \n', '        Assembly storage _assStorage = assemblys[_id];\n', '        \n', '        for (uint j = 0; j < _index.length; j++) {\n', '            details[_assStorage.spares[_index[j]]].idParent = 0;\n', '            _assStorage.spares[_index[j]] = _arrIdReplace[j];\n', '            details[_arrIdReplace[j]].idParent = _id;\n', '        }\n', '        \n', '        _assStorage.dna = _makeDna(_assStorage.spares);\n', '        _assStorage.updateTime = uint64(now);\n', '        _assStorage.rang = _range(_assStorage.spares);\n', '    }\n', '    \n', '    function startMining(uint _id) public whenNotPaused returns(bool) {\n', '        require(assemblIndexToOwner[_id] == msg.sender &&\n', '                assemblys[_id].rang > 0 &&\n', '                assemblys[_id].startMiningTime == 0);\n', '        assemblys[_id].startMiningTime = uint64(now);\n', '        return true;\n', '    }\n', '    \n', '    function getAssembly(uint _id) public view returns (uint256, uint64, uint64, uint64, uint64[], uint8, uint8) {\n', '        return (assemblys[_id].dna,\n', '                assemblys[_id].releaseTime,\n', '                assemblys[_id].updateTime,\n', '                assemblys[_id].startMiningTime,\n', '                assemblys[_id].spares,\n', '                assemblys[_id].countMiningDetail,\n', '                assemblys[_id].rang);\n', '    }\n', '    \n', '    function getAllAssembly(address _owner) public view returns(uint[], uint[], uint[]) {\n', '        uint[] memory resultIndex = new uint[](ownershipAssemblyCount[_owner]);\n', '        uint[] memory resultDna = new uint[](ownershipAssemblyCount[_owner]);\n', '        uint[] memory resultRang = new uint[](ownershipAssemblyCount[_owner]);\n', '        uint counter = 0;\n', '        for (uint i = 0; i < assemblys.length; i++) {\n', '          if (assemblIndexToOwner[i] == _owner) {\n', '            resultIndex[counter] = i; // index\n', '            resultDna[counter] = assemblys[i].dna;\n', '            resultRang[counter] = assemblys[i].rang;\n', '            counter++;\n', '          }\n', '        }\n', '        return (resultIndex, resultDna, resultRang);\n', '    }\n', '    \n', '    function _checkDetail(uint _id, uint8 _mask) internal view {\n', '        require(detailIndexToOwner[_id] == msg.sender\n', '        && details[_id].idParent == 0\n', '        && details[_id].dna / 1000 == _mask);\n', '    }\n', '    \n', '    function _isCanMining(uint64[] memory _arrIdDetails) internal view returns(uint) {\n', '        uint _ch = details[_arrIdDetails[i]].dna % 100;\n', '        for (uint i = 1; i < _arrIdDetails.length; i++) {\n', '            if (_ch != details[_arrIdDetails[i]].dna % 100) {\n', '                return 0;\n', '            }\n', '        }\n', '        return _ch;\n', '    }\n', '    \n', '    function costRecharge(uint _robotId) public view returns(uint) {\n', '        uint8 _rang = assemblys[_robotId].rang;\n', '        if (_rang == 3) {\n', '            return 0.015 ether;\n', '        } else if (_rang == 4) {\n', '            return 0.02 ether;\n', '        } else if (_rang == 5) {\n', '            return 0.025 ether;\n', '        } else if (_rang == 6) {\n', '            return 0.025 ether;\n', '        }\n', '    }\n', '    \n', '    function _range(uint64[] memory _arrIdDetails) internal view returns(uint8) {\n', '        uint8 rang;\n', '        uint _ch = _isCanMining(_arrIdDetails);\n', '        if (_ch == 0) {\n', '            rang = 0;\n', '        } else if (_ch < 29) {\n', '            rang = rangIndex[0];\n', '        } else if (_ch > 28 && _ch < 37) {\n', '            rang = rangIndex[1];\n', '        } else if (_ch > 36 && _ch < 40) {\n', '            rang = rangIndex[2];\n', '        } else if (_ch < 39) {\n', '            rang = rangIndex[3];\n', '        }\n', '        return rang;\n', '    }\n', '    \n', '    function _makeDna(uint64[] memory _arrIdDetails) internal view returns(uint) {\n', '        uint _dna = 0;\n', '        for (uint i = 0; i < _arrIdDetails.length; i++) {\n', '            _dna += details[_arrIdDetails[i]].dna * (10000 ** i);\n', '        }\n', '        return _dna;\n', '    }\n', '    \n', '    function _transferRobot(address _from, address _to, uint256 _robotId) internal {\n', '        ownershipAssemblyCount[_to]++;\n', '        assemblIndexToOwner[_robotId] = _to;\n', '        if (_from != address(0)) {\n', '            ownershipAssemblyCount[_from]--;\n', '            delete robotIndexToApproved[_robotId];\n', '        }\n', '        Transfer(_from, _to, _robotId);\n', '    }\n', '    \n', '}\n', '\n', 'contract BaseContract is AssemblyBase, ERC721 {\n', '    \n', '    using SafeMath for uint;\n', '    address wallet1;\n', '    address wallet2;\n', '    address wallet3;\n', '    address wallet4;\n', '    address wallet5;\n', '    \n', '    string public constant name = "Robots Crypto";\n', '    string public constant symbol = "RC";\n', '\n', '    uint[] dHead;\n', '    uint[] dHousing;\n', '    uint[] dLeftHand;\n', '    uint[] dRightHand;\n', '    uint[] dPelvic;\n', '    uint[] dLeftLeg;\n', '    uint[] dRightLeg;\n', '    \n', '    uint randNonce = 0;\n', '\n', '    function BaseContract() public {\n', '        Detail memory _detail = Detail(0, 0, 0);\n', '        details.push(_detail);\n', '        Assembly memory _ass = Assembly(0, 0, 0, 0, 0, new uint64[](0), 0, 0);\n', '        assemblys.push(_ass);\n', '    }\n', '\n', '    function transferOnWallet() public payable {\n', '        uint value84 = msg.value.mul(84).div(100);\n', '        uint val79 = msg.value.mul(79).div(100);\n', '        \n', '        wallet1.transfer(msg.value - value84);\n', '        wallet2.transfer(msg.value - val79);\n', '        wallet3.transfer(msg.value - val79);\n', '        wallet4.transfer(msg.value - val79);\n', '        wallet5.transfer(msg.value - val79);\n', '        \n', '    }\n', '    \n', '    function setWallet(address _wall1, address _wall2, address _wall3, address _wall4, address _wall5) public onlyOwner {\n', '        wallet1 = _wall1;\n', '        wallet2 = _wall2;\n', '        wallet3 = _wall3;\n', '        wallet4 = _wall4;\n', '        wallet5 = _wall5;\n', '    }\n', '    \n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return detailIndexToOwner[_tokenId] == _claimant;\n', '    }\n', '    \n', '    function _ownsRobot(address _claimant, uint256 _robotId) internal view returns (bool) {\n', '        return assemblIndexToOwner[_robotId] == _claimant;\n', '    }\n', '    \n', '    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return detailIndexToApproved[_tokenId] == _claimant;\n', '    }\n', '\n', '    function _approve(uint256 _tokenId, address _approved) internal {\n', '        detailIndexToApproved[_tokenId] = _approved;\n', '    }\n', '    \n', '    function _approveRobot(uint256 _robotId, address _approved) internal {\n', '        robotIndexToApproved[_robotId] = _approved;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 count) {\n', '        return ownershipTokenCount[_owner];\n', '    }\n', '    \n', '    function balanceOfRobots(address _owner) public view returns (uint256 count) {\n', '        return ownershipAssemblyCount[_owner];\n', '    }\n', '\n', '    function transfer(\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '    {\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '    \n', '    function transferRobot(\n', '        address _to,\n', '        uint256 _robotId\n', '    )\n', '        external\n', '    {\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        _transferRobot(msg.sender, _to, _robotId);\n', '        uint64[] storage spares = assemblys[_robotId].spares;\n', '        for (uint i = 0; i < spares.length; i++) {\n', '            _transfer(msg.sender, _to, spares[i]);\n', '        }\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) external {\n', '        require(_owns(msg.sender, _tokenId));\n', '        _approve(_tokenId, _to);\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '    \n', '    function approveRobot(address _to, uint256 _robotId) external {\n', '        require(_ownsRobot(msg.sender, _robotId));\n', '        _approveRobot(_robotId, _to);\n', '        Approval(msg.sender, _to, _robotId);\n', '    }\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        \n', '    {\n', '        require(_to != address(0));\n', '        require(_owns(_from, _tokenId));\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '    \n', '    function transferFromRobot(\n', '        address _from,\n', '        address _to,\n', '        uint256 _robotId\n', '    )\n', '        external\n', '        \n', '    {\n', '        require(_to != address(0));\n', '        require(_ownsRobot(_from, _robotId));\n', '\n', '        _transferRobot(_from, _to, _robotId);\n', '        ownershipTokenCount[_from] -= 7;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return details.length - 1;\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId)\n', '        external\n', '        view\n', '        returns (address owner)\n', '    {\n', '        owner = detailIndexToOwner[_tokenId];\n', '        require(owner != address(0));\n', '    }\n', '    \n', '    function ownerOfRobot(uint256 _robotId)\n', '        external\n', '        view\n', '        returns (address owner)\n', '    {\n', '        owner = assemblIndexToOwner[_robotId];\n', '        require(owner != address(0));\n', '    }\n', '\n', '\n', '    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '\n', '        if (tokenCount == 0) {\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            uint256 totalDetails = totalSupply();\n', '            uint256 resultIndex = 0;\n', '            uint256 detailId;\n', '\n', '            for (detailId = 1; detailId <= totalDetails; detailId++) {\n', '                if (detailIndexToOwner[detailId] == _owner) {\n', '                    result[resultIndex] = detailId;\n', '                    resultIndex++;\n', '                }\n', '            }\n', '\n', '            return result;\n', '        }\n', '    }\n', '    \n', '    modifier canMining(uint _id) {\n', '        if (assemblys[_id].rang == 6) {\n', '            require(assemblys[_id].countMiningDetail < (assemblys[_id].rang - 1));\n', '        } else {\n', '            require(assemblys[_id].countMiningDetail < assemblys[_id].rang);\n', '        }\n', '        _;\n', '      }\n', '    \n', '    function getAllHead() public view returns (uint[]) {\n', '        return dHead;\n', '    }\n', '    \n', '    function getAllHousing() public view returns (uint[]) {\n', '        return dHousing;\n', '    }\n', '    \n', '    function getAllLeftHand() public view returns (uint[]) {\n', '        return dLeftHand;\n', '    }\n', '    \n', '    function getAllRightHand() public view returns (uint[]) {\n', '        return dRightHand;\n', '    }\n', '    \n', '    function getAllPelvic() public view returns (uint[]) {\n', '        return dPelvic;\n', '    }\n', '    \n', '    function getAllLeftLeg() public view returns (uint[]) {\n', '        return dLeftLeg;\n', '    }\n', '    \n', '    function getAllRightLeg() public view returns (uint[]) {\n', '        return dRightLeg;\n', '    }\n', '    \n', '}\n', '\n', 'contract MainContract is BaseContract {\n', '    \n', '    event BuyChestSuccess(uint count);\n', '    \n', '    mapping (address => uint256) public ownershipChestCount;\n', '    \n', '        modifier isMultiplePrice() {\n', '        require((msg.value % 0.1 ether) == 0);\n', '        _;\n', '    }\n', '    \n', '    modifier isMinValue() {\n', '        require(msg.value >= 0.1 ether);\n', '        _;\n', '    }\n', '    \n', '    function addOwnershipChest(address _owner, uint _num) external onlyOwner {\n', '        ownershipChestCount[_owner] += _num;\n', '    }\n', '    \n', '    function getMyChest(address _owner) external view returns(uint) {\n', '        return ownershipChestCount[_owner];\n', '    }\n', '    \n', '    function buyChest() public payable whenNotPaused isMinValue isMultiplePrice {\n', '        transferOnWallet();\n', '        uint tokens = msg.value.div(0.1 ether);\n', '        ownershipChestCount[msg.sender] += tokens;\n', '        BuyChestSuccess(tokens);\n', '    }\n', '    \n', '    \n', '    function getMiningDetail(uint _id) public canMining(_id) whenNotPaused returns(bool) {\n', '        require(assemblIndexToOwner[_id] == msg.sender);\n', '        if (assemblys[_id].startMiningTime + 259200 <= now) {\n', '            if (assemblys[_id].rang == 6) {\n', '                _generateDetail(40);\n', '            } else {\n', '                _generateDetail(28);\n', '            }\n', '            assemblys[_id].startMiningTime = uint64(now);\n', '            assemblys[_id].countMiningDetail++;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    function getAllDetails(address _owner) public view returns(uint[], uint[]) {\n', '        uint[] memory resultIndex = new uint[](ownershipTokenCount[_owner] - (ownershipAssemblyCount[_owner] * 7));\n', '        uint[] memory resultDna = new uint[](ownershipTokenCount[_owner] - (ownershipAssemblyCount[_owner] * 7));\n', '        uint counter = 0;\n', '        for (uint i = 0; i < details.length; i++) {\n', '          if (detailIndexToOwner[i] == _owner && details[i].idParent == 0) {\n', '            resultIndex[counter] = i;\n', '            resultDna[counter] = details[i].dna;\n', '            counter++;\n', '          }\n', '        }\n', '        return (resultIndex, resultDna);\n', '    }\n', '    \n', '    function _generateDetail(uint _randLim) internal {\n', '        uint _dna = randMod(7);\n', '            \n', '        uint256 newDetailId = createDetail(msg.sender, (_dna * 1000 + randMod(_randLim)));\n', '                \n', '        if (_dna == 1) {\n', '            dHead.push(newDetailId);\n', '        } else if (_dna == 2) {\n', '            dHousing.push(newDetailId);\n', '        } else if (_dna == 3) {\n', '            dLeftHand.push(newDetailId);\n', '        } else if (_dna == 4) {\n', '            dRightHand.push(newDetailId);\n', '        } else if (_dna == 5) {\n', '            dPelvic.push(newDetailId);\n', '        } else if (_dna == 6) {\n', '            dLeftLeg.push(newDetailId);\n', '        } else if (_dna == 7) {\n', '            dRightLeg.push(newDetailId);\n', '        }\n', '    }\n', '    \n', '    function init(address _owner, uint _color) external onlyOwner {\n', '        \n', '        uint _dna = 1;\n', '        \n', '        for (uint i = 0; i < 7; i++) {\n', '            \n', '            uint256 newDetailId = createDetail(_owner, (_dna * 1000 + _color));\n', '            \n', '            if (_dna == 1) {\n', '                dHead.push(newDetailId);\n', '            } else if (_dna == 2) {\n', '                dHousing.push(newDetailId);\n', '            } else if (_dna == 3) {\n', '                dLeftHand.push(newDetailId);\n', '            } else if (_dna == 4) {\n', '                dRightHand.push(newDetailId);\n', '            } else if (_dna == 5) {\n', '                dPelvic.push(newDetailId);\n', '            } else if (_dna == 6) {\n', '                dLeftLeg.push(newDetailId);\n', '            } else if (_dna == 7) {\n', '                dRightLeg.push(newDetailId);\n', '            }\n', '            _dna++;\n', '        }\n', '    }\n', '    \n', '    function randMod(uint _modulus) internal returns(uint) {\n', '        randNonce++;\n', '        return (uint(keccak256(now, msg.sender, randNonce)) % _modulus) + 1;\n', '    }\n', '    \n', '    function openChest() public whenNotPaused {\n', '        require(ownershipChestCount[msg.sender] >= 1);\n', '        for (uint i = 0; i < 5; i++) {\n', '            _generateDetail(40);\n', '        }\n', '        ownershipChestCount[msg.sender]--;\n', '    }\n', '    \n', '    function open5Chest() public whenNotPaused {\n', '        require(ownershipChestCount[msg.sender] >= 5);\n', '        for (uint i = 0; i < 5; i++) {\n', '            openChest();\n', '        }\n', '    }\n', '    \n', '    function rechargeRobot(uint _robotId) external whenNotPaused payable {\n', '        require(assemblIndexToOwner[_robotId] == msg.sender &&\n', '                msg.value == costRecharge(_robotId));\n', '        if (assemblys[_robotId].rang == 6) {\n', '            require(assemblys[_robotId].countMiningDetail == (assemblys[_robotId].rang - 1));\n', '        } else {\n', '            require(assemblys[_robotId].countMiningDetail == assemblys[_robotId].rang);\n', '        }   \n', '        transferOnWallet();        \n', '        assemblys[_robotId].countMiningDetail = 0;\n', '        assemblys[_robotId].startMiningTime = 0;\n', '    }\n', '    \n', '    \n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract ERC721 {\n', '    // Required methods\n', '    function totalSupply() public view returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint _tokenId) external view returns (address _owner);\n', '    function approve(address _to, uint _tokenId) external;\n', '    function transferFrom(address _from, address _to, uint _tokenId) external;\n', '    function transfer(address _to, uint _tokenId) external;\n', '    \n', '    // Events\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '    // Optional functions\n', '    // function name() public view returns (string _name);\n', '    // function symbol() public view returns (string _symbol);\n', '    // function tokenOfOwnerByIndex(address _owner, uint _index) external view returns (uint _tokenId);\n', '    // function tokenMetadata(uint _tokenId) public view returns (string _infoUrl);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    \n', '  address public owner;\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract AccessControl is Ownable {\n', '    \n', '    bool public paused = false;\n', '    \n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '    \n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '    \n', '    function pause() external onlyOwner whenNotPaused {\n', '        paused = true;\n', '    }\n', '    \n', '    function unpause() external onlyOwner whenPaused {\n', '        paused = false;\n', '    }\n', '    \n', '}\n', '\n', 'contract DetailBase is AccessControl {\n', '    \n', '    event Create(address owner, uint256 detailId, uint256 dna);\n', '\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '\n', '    struct Detail {\n', '        uint256 dna;\n', '        uint256 idParent;\n', '        uint64 releaseTime;\n', '    }\n', '\n', '    Detail[] details;\n', '\n', '    mapping (uint256 => address) public detailIndexToOwner;\n', '    mapping (address => uint256) public ownershipTokenCount;\n', '    mapping (uint256 => address) public detailIndexToApproved;\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        ownershipTokenCount[_to]++;\n', '        detailIndexToOwner[_tokenId] = _to;\n', '        if (_from != address(0)) {\n', '            ownershipTokenCount[_from]--;\n', '            delete detailIndexToApproved[_tokenId];\n', '        }\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function createDetail(address _owner, uint256 _dna) internal whenNotPaused returns (uint) {\n', '        Detail memory _detail = Detail(_dna, 0, uint64(now));\n', '        uint256 newDetailId = details.push(_detail) - 1;\n', '        require(newDetailId == uint256(uint32(newDetailId)));\n', '        Create(_owner, newDetailId, _detail.dna);\n', '        _transfer(0, _owner, newDetailId);\n', '\n', '        return newDetailId;\n', '    }\n', '\n', '    function getDetail(uint _id) public view returns (uint256, uint256, uint64) {\n', '        return (details[_id].dna, details[_id].idParent, details[_id].releaseTime);\n', '    }\n', '    \n', '}\n', '\n', 'contract AssemblyBase is DetailBase {\n', '        \n', '    struct Assembly {\n', '        uint256 idParent;\n', '        uint256 dna;\n', '        uint64 releaseTime;\n', '        uint64 updateTime;\n', '        uint64 startMiningTime;\n', '        uint64[] spares;\n', '        uint8 countMiningDetail;\n', '        uint8 rang;\n', '    }\n', '    \n', '    uint8[] private rangIndex = [\n', '        3,\n', '        4,\n', '        5,\n', '        6\n', '    ];\n', '    \n', '    Assembly[] assemblys;\n', '    \n', '    mapping (uint256 => address) public assemblIndexToOwner;\n', '    mapping (address => uint256) public ownershipAssemblyCount;\n', '    mapping (uint256 => address) public robotIndexToApproved;\n', '    \n', '    function gatherDetails(uint64[] _arrIdDetails) public whenNotPaused returns (uint) {\n', '        \n', '        require(_arrIdDetails.length == 7);\n', '        \n', '        for (uint i = 0; i < _arrIdDetails.length; i++) {\n', '            _checkDetail(_arrIdDetails[i], uint8(i+1));\n', '        }\n', '        \n', '        Assembly memory _ass = Assembly(0, _makeDna(_arrIdDetails), uint64(now), uint64(now), 0, _arrIdDetails, 0,  _range(_arrIdDetails));\n', '        \n', '        uint256 newAssemblyId = assemblys.push(_ass) - 1;\n', '        \n', '        for (uint j = 0; j < _arrIdDetails.length; j++) {\n', '            details[_arrIdDetails[j]].idParent = newAssemblyId;\n', '        }\n', '        \n', '        assemblIndexToOwner[newAssemblyId] = msg.sender;\n', '        ownershipAssemblyCount[msg.sender]++;\n', '        \n', '        return newAssemblyId;\n', '    }\n', '    \n', '    function changeAssembly(uint _id, uint64[] _index, uint64[] _arrIdReplace) public whenNotPaused {\n', '        require(_index.length == _arrIdReplace.length &&\n', '                assemblIndexToOwner[_id] == msg.sender &&\n', '                assemblys[_id].startMiningTime == 0);\n', '        for (uint i = 0; i < _arrIdReplace.length; i++) {\n', '            _checkDetail(_arrIdReplace[i], uint8(_index[i] + 1));\n', '        }\n', '        \n', '        Assembly storage _assStorage = assemblys[_id];\n', '        \n', '        for (uint j = 0; j < _index.length; j++) {\n', '            details[_assStorage.spares[_index[j]]].idParent = 0;\n', '            _assStorage.spares[_index[j]] = _arrIdReplace[j];\n', '            details[_arrIdReplace[j]].idParent = _id;\n', '        }\n', '        \n', '        _assStorage.dna = _makeDna(_assStorage.spares);\n', '        _assStorage.updateTime = uint64(now);\n', '        _assStorage.rang = _range(_assStorage.spares);\n', '    }\n', '    \n', '    function startMining(uint _id) public whenNotPaused returns(bool) {\n', '        require(assemblIndexToOwner[_id] == msg.sender &&\n', '                assemblys[_id].rang > 0 &&\n', '                assemblys[_id].startMiningTime == 0);\n', '        assemblys[_id].startMiningTime = uint64(now);\n', '        return true;\n', '    }\n', '    \n', '    function getAssembly(uint _id) public view returns (uint256, uint64, uint64, uint64, uint64[], uint8, uint8) {\n', '        return (assemblys[_id].dna,\n', '                assemblys[_id].releaseTime,\n', '                assemblys[_id].updateTime,\n', '                assemblys[_id].startMiningTime,\n', '                assemblys[_id].spares,\n', '                assemblys[_id].countMiningDetail,\n', '                assemblys[_id].rang);\n', '    }\n', '    \n', '    function getAllAssembly(address _owner) public view returns(uint[], uint[], uint[]) {\n', '        uint[] memory resultIndex = new uint[](ownershipAssemblyCount[_owner]);\n', '        uint[] memory resultDna = new uint[](ownershipAssemblyCount[_owner]);\n', '        uint[] memory resultRang = new uint[](ownershipAssemblyCount[_owner]);\n', '        uint counter = 0;\n', '        for (uint i = 0; i < assemblys.length; i++) {\n', '          if (assemblIndexToOwner[i] == _owner) {\n', '            resultIndex[counter] = i; // index\n', '            resultDna[counter] = assemblys[i].dna;\n', '            resultRang[counter] = assemblys[i].rang;\n', '            counter++;\n', '          }\n', '        }\n', '        return (resultIndex, resultDna, resultRang);\n', '    }\n', '    \n', '    function _checkDetail(uint _id, uint8 _mask) internal view {\n', '        require(detailIndexToOwner[_id] == msg.sender\n', '        && details[_id].idParent == 0\n', '        && details[_id].dna / 1000 == _mask);\n', '    }\n', '    \n', '    function _isCanMining(uint64[] memory _arrIdDetails) internal view returns(uint) {\n', '        uint _ch = details[_arrIdDetails[i]].dna % 100;\n', '        for (uint i = 1; i < _arrIdDetails.length; i++) {\n', '            if (_ch != details[_arrIdDetails[i]].dna % 100) {\n', '                return 0;\n', '            }\n', '        }\n', '        return _ch;\n', '    }\n', '    \n', '    function costRecharge(uint _robotId) public view returns(uint) {\n', '        uint8 _rang = assemblys[_robotId].rang;\n', '        if (_rang == 3) {\n', '            return 0.015 ether;\n', '        } else if (_rang == 4) {\n', '            return 0.02 ether;\n', '        } else if (_rang == 5) {\n', '            return 0.025 ether;\n', '        } else if (_rang == 6) {\n', '            return 0.025 ether;\n', '        }\n', '    }\n', '    \n', '    function _range(uint64[] memory _arrIdDetails) internal view returns(uint8) {\n', '        uint8 rang;\n', '        uint _ch = _isCanMining(_arrIdDetails);\n', '        if (_ch == 0) {\n', '            rang = 0;\n', '        } else if (_ch < 29) {\n', '            rang = rangIndex[0];\n', '        } else if (_ch > 28 && _ch < 37) {\n', '            rang = rangIndex[1];\n', '        } else if (_ch > 36 && _ch < 40) {\n', '            rang = rangIndex[2];\n', '        } else if (_ch < 39) {\n', '            rang = rangIndex[3];\n', '        }\n', '        return rang;\n', '    }\n', '    \n', '    function _makeDna(uint64[] memory _arrIdDetails) internal view returns(uint) {\n', '        uint _dna = 0;\n', '        for (uint i = 0; i < _arrIdDetails.length; i++) {\n', '            _dna += details[_arrIdDetails[i]].dna * (10000 ** i);\n', '        }\n', '        return _dna;\n', '    }\n', '    \n', '    function _transferRobot(address _from, address _to, uint256 _robotId) internal {\n', '        ownershipAssemblyCount[_to]++;\n', '        assemblIndexToOwner[_robotId] = _to;\n', '        if (_from != address(0)) {\n', '            ownershipAssemblyCount[_from]--;\n', '            delete robotIndexToApproved[_robotId];\n', '        }\n', '        Transfer(_from, _to, _robotId);\n', '    }\n', '    \n', '}\n', '\n', 'contract BaseContract is AssemblyBase, ERC721 {\n', '    \n', '    using SafeMath for uint;\n', '    address wallet1;\n', '    address wallet2;\n', '    address wallet3;\n', '    address wallet4;\n', '    address wallet5;\n', '    \n', '    string public constant name = "Robots Crypto";\n', '    string public constant symbol = "RC";\n', '\n', '    uint[] dHead;\n', '    uint[] dHousing;\n', '    uint[] dLeftHand;\n', '    uint[] dRightHand;\n', '    uint[] dPelvic;\n', '    uint[] dLeftLeg;\n', '    uint[] dRightLeg;\n', '    \n', '    uint randNonce = 0;\n', '\n', '    function BaseContract() public {\n', '        Detail memory _detail = Detail(0, 0, 0);\n', '        details.push(_detail);\n', '        Assembly memory _ass = Assembly(0, 0, 0, 0, 0, new uint64[](0), 0, 0);\n', '        assemblys.push(_ass);\n', '    }\n', '\n', '    function transferOnWallet() public payable {\n', '        uint value84 = msg.value.mul(84).div(100);\n', '        uint val79 = msg.value.mul(79).div(100);\n', '        \n', '        wallet1.transfer(msg.value - value84);\n', '        wallet2.transfer(msg.value - val79);\n', '        wallet3.transfer(msg.value - val79);\n', '        wallet4.transfer(msg.value - val79);\n', '        wallet5.transfer(msg.value - val79);\n', '        \n', '    }\n', '    \n', '    function setWallet(address _wall1, address _wall2, address _wall3, address _wall4, address _wall5) public onlyOwner {\n', '        wallet1 = _wall1;\n', '        wallet2 = _wall2;\n', '        wallet3 = _wall3;\n', '        wallet4 = _wall4;\n', '        wallet5 = _wall5;\n', '    }\n', '    \n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return detailIndexToOwner[_tokenId] == _claimant;\n', '    }\n', '    \n', '    function _ownsRobot(address _claimant, uint256 _robotId) internal view returns (bool) {\n', '        return assemblIndexToOwner[_robotId] == _claimant;\n', '    }\n', '    \n', '    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return detailIndexToApproved[_tokenId] == _claimant;\n', '    }\n', '\n', '    function _approve(uint256 _tokenId, address _approved) internal {\n', '        detailIndexToApproved[_tokenId] = _approved;\n', '    }\n', '    \n', '    function _approveRobot(uint256 _robotId, address _approved) internal {\n', '        robotIndexToApproved[_robotId] = _approved;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 count) {\n', '        return ownershipTokenCount[_owner];\n', '    }\n', '    \n', '    function balanceOfRobots(address _owner) public view returns (uint256 count) {\n', '        return ownershipAssemblyCount[_owner];\n', '    }\n', '\n', '    function transfer(\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '    {\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '    \n', '    function transferRobot(\n', '        address _to,\n', '        uint256 _robotId\n', '    )\n', '        external\n', '    {\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        _transferRobot(msg.sender, _to, _robotId);\n', '        uint64[] storage spares = assemblys[_robotId].spares;\n', '        for (uint i = 0; i < spares.length; i++) {\n', '            _transfer(msg.sender, _to, spares[i]);\n', '        }\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) external {\n', '        require(_owns(msg.sender, _tokenId));\n', '        _approve(_tokenId, _to);\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '    \n', '    function approveRobot(address _to, uint256 _robotId) external {\n', '        require(_ownsRobot(msg.sender, _robotId));\n', '        _approveRobot(_robotId, _to);\n', '        Approval(msg.sender, _to, _robotId);\n', '    }\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        \n', '    {\n', '        require(_to != address(0));\n', '        require(_owns(_from, _tokenId));\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '    \n', '    function transferFromRobot(\n', '        address _from,\n', '        address _to,\n', '        uint256 _robotId\n', '    )\n', '        external\n', '        \n', '    {\n', '        require(_to != address(0));\n', '        require(_ownsRobot(_from, _robotId));\n', '\n', '        _transferRobot(_from, _to, _robotId);\n', '        ownershipTokenCount[_from] -= 7;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return details.length - 1;\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId)\n', '        external\n', '        view\n', '        returns (address owner)\n', '    {\n', '        owner = detailIndexToOwner[_tokenId];\n', '        require(owner != address(0));\n', '    }\n', '    \n', '    function ownerOfRobot(uint256 _robotId)\n', '        external\n', '        view\n', '        returns (address owner)\n', '    {\n', '        owner = assemblIndexToOwner[_robotId];\n', '        require(owner != address(0));\n', '    }\n', '\n', '\n', '    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '\n', '        if (tokenCount == 0) {\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            uint256 totalDetails = totalSupply();\n', '            uint256 resultIndex = 0;\n', '            uint256 detailId;\n', '\n', '            for (detailId = 1; detailId <= totalDetails; detailId++) {\n', '                if (detailIndexToOwner[detailId] == _owner) {\n', '                    result[resultIndex] = detailId;\n', '                    resultIndex++;\n', '                }\n', '            }\n', '\n', '            return result;\n', '        }\n', '    }\n', '    \n', '    modifier canMining(uint _id) {\n', '        if (assemblys[_id].rang == 6) {\n', '            require(assemblys[_id].countMiningDetail < (assemblys[_id].rang - 1));\n', '        } else {\n', '            require(assemblys[_id].countMiningDetail < assemblys[_id].rang);\n', '        }\n', '        _;\n', '      }\n', '    \n', '    function getAllHead() public view returns (uint[]) {\n', '        return dHead;\n', '    }\n', '    \n', '    function getAllHousing() public view returns (uint[]) {\n', '        return dHousing;\n', '    }\n', '    \n', '    function getAllLeftHand() public view returns (uint[]) {\n', '        return dLeftHand;\n', '    }\n', '    \n', '    function getAllRightHand() public view returns (uint[]) {\n', '        return dRightHand;\n', '    }\n', '    \n', '    function getAllPelvic() public view returns (uint[]) {\n', '        return dPelvic;\n', '    }\n', '    \n', '    function getAllLeftLeg() public view returns (uint[]) {\n', '        return dLeftLeg;\n', '    }\n', '    \n', '    function getAllRightLeg() public view returns (uint[]) {\n', '        return dRightLeg;\n', '    }\n', '    \n', '}\n', '\n', 'contract MainContract is BaseContract {\n', '    \n', '    event BuyChestSuccess(uint count);\n', '    \n', '    mapping (address => uint256) public ownershipChestCount;\n', '    \n', '        modifier isMultiplePrice() {\n', '        require((msg.value % 0.1 ether) == 0);\n', '        _;\n', '    }\n', '    \n', '    modifier isMinValue() {\n', '        require(msg.value >= 0.1 ether);\n', '        _;\n', '    }\n', '    \n', '    function addOwnershipChest(address _owner, uint _num) external onlyOwner {\n', '        ownershipChestCount[_owner] += _num;\n', '    }\n', '    \n', '    function getMyChest(address _owner) external view returns(uint) {\n', '        return ownershipChestCount[_owner];\n', '    }\n', '    \n', '    function buyChest() public payable whenNotPaused isMinValue isMultiplePrice {\n', '        transferOnWallet();\n', '        uint tokens = msg.value.div(0.1 ether);\n', '        ownershipChestCount[msg.sender] += tokens;\n', '        BuyChestSuccess(tokens);\n', '    }\n', '    \n', '    \n', '    function getMiningDetail(uint _id) public canMining(_id) whenNotPaused returns(bool) {\n', '        require(assemblIndexToOwner[_id] == msg.sender);\n', '        if (assemblys[_id].startMiningTime + 259200 <= now) {\n', '            if (assemblys[_id].rang == 6) {\n', '                _generateDetail(40);\n', '            } else {\n', '                _generateDetail(28);\n', '            }\n', '            assemblys[_id].startMiningTime = uint64(now);\n', '            assemblys[_id].countMiningDetail++;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    function getAllDetails(address _owner) public view returns(uint[], uint[]) {\n', '        uint[] memory resultIndex = new uint[](ownershipTokenCount[_owner] - (ownershipAssemblyCount[_owner] * 7));\n', '        uint[] memory resultDna = new uint[](ownershipTokenCount[_owner] - (ownershipAssemblyCount[_owner] * 7));\n', '        uint counter = 0;\n', '        for (uint i = 0; i < details.length; i++) {\n', '          if (detailIndexToOwner[i] == _owner && details[i].idParent == 0) {\n', '            resultIndex[counter] = i;\n', '            resultDna[counter] = details[i].dna;\n', '            counter++;\n', '          }\n', '        }\n', '        return (resultIndex, resultDna);\n', '    }\n', '    \n', '    function _generateDetail(uint _randLim) internal {\n', '        uint _dna = randMod(7);\n', '            \n', '        uint256 newDetailId = createDetail(msg.sender, (_dna * 1000 + randMod(_randLim)));\n', '                \n', '        if (_dna == 1) {\n', '            dHead.push(newDetailId);\n', '        } else if (_dna == 2) {\n', '            dHousing.push(newDetailId);\n', '        } else if (_dna == 3) {\n', '            dLeftHand.push(newDetailId);\n', '        } else if (_dna == 4) {\n', '            dRightHand.push(newDetailId);\n', '        } else if (_dna == 5) {\n', '            dPelvic.push(newDetailId);\n', '        } else if (_dna == 6) {\n', '            dLeftLeg.push(newDetailId);\n', '        } else if (_dna == 7) {\n', '            dRightLeg.push(newDetailId);\n', '        }\n', '    }\n', '    \n', '    function init(address _owner, uint _color) external onlyOwner {\n', '        \n', '        uint _dna = 1;\n', '        \n', '        for (uint i = 0; i < 7; i++) {\n', '            \n', '            uint256 newDetailId = createDetail(_owner, (_dna * 1000 + _color));\n', '            \n', '            if (_dna == 1) {\n', '                dHead.push(newDetailId);\n', '            } else if (_dna == 2) {\n', '                dHousing.push(newDetailId);\n', '            } else if (_dna == 3) {\n', '                dLeftHand.push(newDetailId);\n', '            } else if (_dna == 4) {\n', '                dRightHand.push(newDetailId);\n', '            } else if (_dna == 5) {\n', '                dPelvic.push(newDetailId);\n', '            } else if (_dna == 6) {\n', '                dLeftLeg.push(newDetailId);\n', '            } else if (_dna == 7) {\n', '                dRightLeg.push(newDetailId);\n', '            }\n', '            _dna++;\n', '        }\n', '    }\n', '    \n', '    function randMod(uint _modulus) internal returns(uint) {\n', '        randNonce++;\n', '        return (uint(keccak256(now, msg.sender, randNonce)) % _modulus) + 1;\n', '    }\n', '    \n', '    function openChest() public whenNotPaused {\n', '        require(ownershipChestCount[msg.sender] >= 1);\n', '        for (uint i = 0; i < 5; i++) {\n', '            _generateDetail(40);\n', '        }\n', '        ownershipChestCount[msg.sender]--;\n', '    }\n', '    \n', '    function open5Chest() public whenNotPaused {\n', '        require(ownershipChestCount[msg.sender] >= 5);\n', '        for (uint i = 0; i < 5; i++) {\n', '            openChest();\n', '        }\n', '    }\n', '    \n', '    function rechargeRobot(uint _robotId) external whenNotPaused payable {\n', '        require(assemblIndexToOwner[_robotId] == msg.sender &&\n', '                msg.value == costRecharge(_robotId));\n', '        if (assemblys[_robotId].rang == 6) {\n', '            require(assemblys[_robotId].countMiningDetail == (assemblys[_robotId].rang - 1));\n', '        } else {\n', '            require(assemblys[_robotId].countMiningDetail == assemblys[_robotId].rang);\n', '        }   \n', '        transferOnWallet();        \n', '        assemblys[_robotId].countMiningDetail = 0;\n', '        assemblys[_robotId].startMiningTime = 0;\n', '    }\n', '    \n', '    \n', '}']
