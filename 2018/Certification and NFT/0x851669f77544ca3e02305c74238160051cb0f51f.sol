['pragma solidity 0.4.20;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed burner, uint256 value);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// VIOLET ERC20 Standard Token\n', '// ----------------------------------------------------------------------------\n', 'contract VLTToken is ERC20Interface {\n', '    using SafeMath for uint256;\n', '\n', '    address public owner = msg.sender;\n', '\n', '    bytes32 public symbol;\n', '    bytes32 public name;\n', '    uint8 public decimals;\n', '    uint256 public _totalSupply;\n', '\n', '    mapping(address => uint256) internal balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    function VLTToken() public {\n', '        symbol = "VAI";\n', '        name = "VIOLET";\n', '        decimals = 18;\n', '        _totalSupply = 250000000 * 10**uint256(decimals);\n', '        balances[owner] = _totalSupply;\n', '        Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev total number of tokens in existence\n', '    */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        // allow sending 0 tokens\n', '        if (_value == 0) {\n', '            Transfer(msg.sender, _to, _value);    // Follow the spec to louch the event when transfer 0\n', '            return;\n', '        }\n', '        \n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        // SafeMath.sub will throw if there is not enough balance.\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    *\n', '    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '    * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer tokens from one address to another\n', '    * @param _from address The address which you want to send tokens from\n', '    * @param _to address The address which you want to transfer to\n', '    * @param _value uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        // allow sending 0 tokens\n', '        if (_value == 0) {\n', '            Transfer(_from, _to, _value);    // Follow the spec to louch the event when transfer 0\n', '            return;\n', '        }\n', '\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    * @param _owner address The address which owns the funds.\n', '    * @param _spender address The address which will spend the funds.\n', '    * @return A uint256 specifying the amount of tokens still available for the spender.\n', '    */\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '    *\n', '    * approve should be called when allowed[_spender] == 0. To increment\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _addedValue The amount of tokens to increase the allowance by.\n', '    */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '    *\n', '    * approve should be called when allowed[_spender] == 0. To decrement\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '    */\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '        allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Burns a specific amount of tokens.\n', '    * @param _value The amount of token to be burned.\n', '    */\n', '    function burn(uint256 _value) public {\n', '        require(_value <= balances[msg.sender]);\n', '        // no need to require value <= totalSupply, since that would imply the\n', '        // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        _totalSupply = _totalSupply.sub(_value);\n', '        Burn(burner, _value);\n', '        Transfer(burner, address(0), _value);\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) public returns (bool) {\n', '        require(_value <= balances[_from]);               // Check if the targeted balance is enough\n', '        require(_value <= allowed[_from][msg.sender]);    // Check allowed allowance\n', '        balances[_from] = balances[_from].sub(_value);  // Subtract from the targeted balance\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);             // Subtract from the sender&#39;s allowance\n', '        _totalSupply = _totalSupply.sub(_value);                              // Update totalSupply\n', '        Burn(_from, _value);\n', '        Transfer(_from, address(0), _value);\n', '        return true;\n', '    } \n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ViolaCrowdsale\n', ' * @dev ViolaCrowdsale reserves token from supply when eth is received\n', ' * funds will be forwarded after the end of crowdsale. Tokens will be claimable\n', ' * within 7 days after crowdsale ends.\n', ' */\n', ' \n', 'contract ViolaCrowdsale is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  enum State { Deployed, PendingStart, Active, Paused, Ended, Completed }\n', '\n', '  //Status of contract\n', '  State public status = State.Deployed;\n', '\n', '  // The token being sold\n', '  VLTToken public violaToken;\n', '\n', '  //For keeping track of whitelist address. cap >0 = whitelisted\n', '  mapping(address=>uint) public maxBuyCap;\n', '\n', '  //For checking if address passed KYC\n', '  mapping(address => bool)public addressKYC;\n', '\n', '  //Total wei sum an address has invested\n', '  mapping(address=>uint) public investedSum;\n', '\n', '  //Total violaToken an address is allocated\n', '  mapping(address=>uint) public tokensAllocated;\n', '\n', '    //Total violaToken an address purchased externally is allocated\n', '  mapping(address=>uint) public externalTokensAllocated;\n', '\n', '  //Total bonus violaToken an address is entitled after vesting\n', '  mapping(address=>uint) public bonusTokensAllocated;\n', '\n', '  //Total bonus violaToken an address purchased externally is entitled after vesting\n', '  mapping(address=>uint) public externalBonusTokensAllocated;\n', '\n', '  //Store addresses that has registered for crowdsale before (pushed via setWhitelist)\n', '  //Does not mean whitelisted as it can be revoked. Just to track address for loop\n', '  address[] public registeredAddress;\n', '\n', '  //Total amount not approved for withdrawal\n', '  uint256 public totalApprovedAmount = 0;\n', '\n', '  //Start and end timestamps where investments are allowed (both inclusive)\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '  uint256 public bonusVestingPeriod = 60 days;\n', '\n', '\n', '  /**\n', '   * Note all values are calculated in wei(uint256) including token amount\n', '   * 1 ether = 1000000000000000000 wei\n', '   * 1 viola = 1000000000000000000 vi lawei\n', '   */\n', '\n', '\n', '  //Address where funds are collected\n', '  address public wallet;\n', '\n', '  //Min amount investor can purchase\n', '  uint256 public minWeiToPurchase;\n', '\n', '  // how many token units *in wei* a buyer gets *per wei*\n', '  uint256 public rate;\n', '\n', '  //Extra bonus token to give *in percentage*\n', '  uint public bonusTokenRateLevelOne = 20;\n', '  uint public bonusTokenRateLevelTwo = 15;\n', '  uint public bonusTokenRateLevelThree = 10;\n', '  uint public bonusTokenRateLevelFour = 0;\n', '\n', '  //Total amount of tokens allocated for crowdsale\n', '  uint256 public totalTokensAllocated;\n', '\n', '  //Total amount of tokens reserved from external sources\n', '  //Sub set of totalTokensAllocated ( totalTokensAllocated - totalReservedTokenAllocated = total tokens allocated for purchases using ether )\n', '  uint256 public totalReservedTokenAllocated;\n', '\n', '  //Numbers of token left above 0 to still be considered sold\n', '  uint256 public leftoverTokensBuffer;\n', '\n', '  /**\n', '   * event for front end logging\n', '   */\n', '\n', '  event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount, uint256 bonusAmount);\n', '  event ExternalTokenPurchase(address indexed purchaser, uint256 amount, uint256 bonusAmount);\n', '  event ExternalPurchaseRefunded(address indexed purchaser, uint256 amount, uint256 bonusAmount);\n', '  event TokenDistributed(address indexed tokenReceiver, uint256 tokenAmount);\n', '  event BonusTokenDistributed(address indexed tokenReceiver, uint256 tokenAmount);\n', '  event TopupTokenAllocated(address indexed tokenReceiver, uint256 amount, uint256 bonusAmount);\n', '  event CrowdsalePending();\n', '  event CrowdsaleStarted();\n', '  event CrowdsaleEnded();\n', '  event BonusRateChanged();\n', '  event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '  //Set inital arguments of the crowdsale\n', '  function initialiseCrowdsale (uint256 _startTime, uint256 _rate, address _tokenAddress, address _wallet) onlyOwner external {\n', '    require(status == State.Deployed);\n', '    require(_startTime >= now);\n', '    require(_rate > 0);\n', '    require(address(_tokenAddress) != address(0));\n', '    require(_wallet != address(0));\n', '\n', '    startTime = _startTime;\n', '    endTime = _startTime + 30 days;\n', '    rate = _rate;\n', '    wallet = _wallet;\n', '    violaToken = VLTToken(_tokenAddress);\n', '\n', '    status = State.PendingStart;\n', '\n', '    CrowdsalePending();\n', '\n', '  }\n', '\n', '  /**\n', '   * Crowdsale state functions\n', '   * To track state of current crowdsale\n', '   */\n', '\n', '\n', '  // To be called by Ethereum alarm clock or anyone\n', '  //Can only be called successfully when time is valid\n', '  function startCrowdsale() external {\n', '    require(withinPeriod());\n', '    require(violaToken != address(0));\n', '    require(getTokensLeft() > 0);\n', '    require(status == State.PendingStart);\n', '\n', '    status = State.Active;\n', '\n', '    CrowdsaleStarted();\n', '  }\n', '\n', '  //To be called by owner or contract\n', '  //Ends the crowdsale when tokens are sold out\n', '  function endCrowdsale() public {\n', '    if (!tokensHasSoldOut()) {\n', '      require(msg.sender == owner);\n', '    }\n', '    require(status == State.Active);\n', '\n', '    bonusVestingPeriod = now + 60 days;\n', '\n', '    status = State.Ended;\n', '\n', '    CrowdsaleEnded();\n', '  }\n', '  //Emergency pause\n', '  function pauseCrowdsale() onlyOwner external {\n', '    require(status == State.Active);\n', '\n', '    status = State.Paused;\n', '  }\n', '  //Resume paused crowdsale\n', '  function unpauseCrowdsale() onlyOwner external {\n', '    require(status == State.Paused);\n', '\n', '    status = State.Active;\n', '  }\n', '\n', '  function completeCrowdsale() onlyOwner external {\n', '    require(hasEnded());\n', '    require(violaToken.allowance(owner, this) == 0);\n', '    status = State.Completed;\n', '\n', '    _forwardFunds();\n', '\n', '    assert(this.balance == 0);\n', '  }\n', '\n', '  function burnExtraTokens() onlyOwner external {\n', '    require(hasEnded());\n', '    uint256 extraTokensToBurn = violaToken.allowance(owner, this);\n', '    violaToken.burnFrom(owner, extraTokensToBurn);\n', '    assert(violaToken.allowance(owner, this) == 0);\n', '  }\n', '\n', '  // send ether to the fund collection wallet\n', '  function _forwardFunds() internal {\n', '    wallet.transfer(this.balance);\n', '  }\n', '\n', '  function partialForwardFunds(uint _amountToTransfer) onlyOwner external {\n', '    require(status == State.Ended);\n', '    require(_amountToTransfer < totalApprovedAmount);\n', '    totalApprovedAmount = totalApprovedAmount.sub(_amountToTransfer);\n', '    \n', '    wallet.transfer(_amountToTransfer);\n', '  }\n', '\n', '  /**\n', '   * Setter functions for crowdsale parameters\n', '   * Only owner can set values\n', '   */\n', '\n', '\n', '  function setLeftoverTokensBuffer(uint256 _tokenBuffer) onlyOwner external {\n', '    require(_tokenBuffer > 0);\n', '    require(getTokensLeft() >= _tokenBuffer);\n', '    leftoverTokensBuffer = _tokenBuffer;\n', '  }\n', '\n', '  //Set the ether to token rate\n', '  function setRate(uint _rate) onlyOwner external {\n', '    require(_rate > 0);\n', '    rate = _rate;\n', '  }\n', '\n', '  function setBonusTokenRateLevelOne(uint _rate) onlyOwner external {\n', '    //require(_rate > 0);\n', '    bonusTokenRateLevelOne = _rate;\n', '    BonusRateChanged();\n', '  }\n', '\n', '  function setBonusTokenRateLevelTwo(uint _rate) onlyOwner external {\n', '    //require(_rate > 0);\n', '    bonusTokenRateLevelTwo = _rate;\n', '    BonusRateChanged();\n', '  }\n', '\n', '  function setBonusTokenRateLevelThree(uint _rate) onlyOwner external {\n', '    //require(_rate > 0);\n', '    bonusTokenRateLevelThree = _rate;\n', '    BonusRateChanged();\n', '  }\n', '  function setBonusTokenRateLevelFour(uint _rate) onlyOwner external {\n', '    //require(_rate > 0);\n', '    bonusTokenRateLevelFour = _rate;\n', '    BonusRateChanged();\n', '  }\n', '\n', '  function setMinWeiToPurchase(uint _minWeiToPurchase) onlyOwner external {\n', '    minWeiToPurchase = _minWeiToPurchase;\n', '  }\n', '\n', '\n', '  /**\n', '   * Whitelisting and KYC functions\n', '   * Whitelisted address can buy tokens, KYC successful purchaser can claim token. Refund if fail KYC\n', '   */\n', '\n', '\n', '  //Set the amount of wei an address can purchase up to\n', '  //@dev Value of 0 = not whitelisted\n', '  //@dev cap is in *18 decimals* ( 1 token = 1*10^18)\n', '  \n', '  function setWhitelistAddress( address _investor, uint _cap ) onlyOwner external {\n', '        require(_cap > 0);\n', '        require(_investor != address(0));\n', '        maxBuyCap[_investor] = _cap;\n', '        registeredAddress.push(_investor);\n', '        //add event\n', '    }\n', '\n', '  //Remove the address from whitelist\n', '  function removeWhitelistAddress(address _investor) onlyOwner external {\n', '    require(_investor != address(0));\n', '    \n', '    maxBuyCap[_investor] = 0;\n', '    uint256 weiAmount = investedSum[_investor];\n', '\n', '    if (weiAmount > 0) {\n', '      _refund(_investor);\n', '    }\n', '  }\n', '\n', '  //Flag address as KYC approved. Address is now approved to claim tokens\n', '  function approveKYC(address _kycAddress) onlyOwner external {\n', '    require(_kycAddress != address(0));\n', '    addressKYC[_kycAddress] = true;\n', '\n', '    uint256 weiAmount = investedSum[_kycAddress];\n', '    totalApprovedAmount = totalApprovedAmount.add(weiAmount);\n', '  }\n', '\n', '  //Set KYC status as failed. Refund any eth back to address\n', '  function revokeKYC(address _kycAddress) onlyOwner external {\n', '    require(_kycAddress != address(0));\n', '    addressKYC[_kycAddress] = false;\n', '\n', '    uint256 weiAmount = investedSum[_kycAddress];\n', '    totalApprovedAmount = totalApprovedAmount.sub(weiAmount);\n', '\n', '    if (weiAmount > 0) {\n', '      _refund(_kycAddress);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Getter functions for crowdsale parameters\n', '   * Does not use gas\n', '   */\n', '\n', '  //Checks if token has been sold out\n', '    function tokensHasSoldOut() view internal returns (bool) {\n', '      if (getTokensLeft() <= leftoverTokensBuffer) {\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '      // @return true if the transaction can buy tokens\n', '  function withinPeriod() public view returns (bool) {\n', '    return now >= startTime && now <= endTime;\n', '  }\n', '\n', '  // @return true if crowdsale event has ended\n', '  function hasEnded() public view returns (bool) {\n', '    if (status == State.Ended) {\n', '      return true;\n', '    }\n', '    return now > endTime;\n', '  }\n', '\n', '  function getTokensLeft() public view returns (uint) {\n', '    return violaToken.allowance(owner, this).sub(totalTokensAllocated);\n', '  }\n', '\n', '  function transferTokens (address receiver, uint tokenAmount) internal {\n', '     require(violaToken.transferFrom(owner, receiver, tokenAmount));\n', '  }\n', '\n', '  function getTimeBasedBonusRate() public view returns(uint) {\n', '    bool bonusDuration1 = now >= startTime && now <= (startTime + 1 days);  //First 24hr\n', '    bool bonusDuration2 = now > (startTime + 1 days) && now <= (startTime + 3 days);//Next 48 hr\n', '    bool bonusDuration3 = now > (startTime + 3 days) && now <= (startTime + 10 days);//4th to 10th day\n', '    bool bonusDuration4 = now > (startTime + 10 days) && now <= endTime;//11th day onwards\n', '    if (bonusDuration1) {\n', '      return bonusTokenRateLevelOne;\n', '    } else if (bonusDuration2) {\n', '      return bonusTokenRateLevelTwo;\n', '    } else if (bonusDuration3) {\n', '      return bonusTokenRateLevelThree;\n', '    } else if (bonusDuration4) {\n', '      return bonusTokenRateLevelFour;\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function getTotalTokensByAddress(address _investor) public view returns(uint) {\n', '    return getTotalNormalTokensByAddress(_investor).add(getTotalBonusTokensByAddress(_investor));\n', '  }\n', '\n', '  function getTotalNormalTokensByAddress(address _investor) public view returns(uint) {\n', '    return tokensAllocated[_investor].add(externalTokensAllocated[_investor]);\n', '  }\n', '\n', '  function getTotalBonusTokensByAddress(address _investor) public view returns(uint) {\n', '    return bonusTokensAllocated[_investor].add(externalBonusTokensAllocated[_investor]);\n', '  }\n', '\n', '  function _clearTotalNormalTokensByAddress(address _investor) internal {\n', '    tokensAllocated[_investor] = 0;\n', '    externalTokensAllocated[_investor] = 0;\n', '  }\n', '\n', '  function _clearTotalBonusTokensByAddress(address _investor) internal {\n', '    bonusTokensAllocated[_investor] = 0;\n', '    externalBonusTokensAllocated[_investor] = 0;\n', '  }\n', '\n', '\n', '  /**\n', '   * Functions to handle buy tokens\n', '   * Fallback function as entry point for eth\n', '   */\n', '\n', '\n', '  // Called when ether is sent to contract\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  //Used to buy tokens\n', '  function buyTokens(address investor) internal {\n', '    require(status == State.Active);\n', '    require(msg.value >= minWeiToPurchase);\n', '\n', '    uint weiAmount = msg.value;\n', '\n', '    checkCapAndRecord(investor,weiAmount);\n', '\n', '    allocateToken(investor,weiAmount);\n', '    \n', '  }\n', '\n', '  //Internal call to check max user cap\n', '  function checkCapAndRecord(address investor, uint weiAmount) internal {\n', '      uint remaindingCap = maxBuyCap[investor];\n', '      require(remaindingCap >= weiAmount);\n', '      maxBuyCap[investor] = remaindingCap.sub(weiAmount);\n', '      investedSum[investor] = investedSum[investor].add(weiAmount);\n', '  }\n', '\n', '  //Internal call to allocated tokens purchased\n', '    function allocateToken(address investor, uint weiAmount) internal {\n', '        // calculate token amount to be created\n', '        uint tokens = weiAmount.mul(rate);\n', '        uint bonusTokens = tokens.mul(getTimeBasedBonusRate()).div(100);\n', '        \n', '        uint tokensToAllocate = tokens.add(bonusTokens);\n', '        \n', '        require(getTokensLeft() >= tokensToAllocate);\n', '        totalTokensAllocated = totalTokensAllocated.add(tokensToAllocate);\n', '\n', '        tokensAllocated[investor] = tokensAllocated[investor].add(tokens);\n', '        bonusTokensAllocated[investor] = bonusTokensAllocated[investor].add(bonusTokens);\n', '\n', '        if (tokensHasSoldOut()) {\n', '          endCrowdsale();\n', '        }\n', '        TokenPurchase(investor, weiAmount, tokens, bonusTokens);\n', '  }\n', '\n', '\n', '\n', '  /**\n', '   * Functions for refunds & claim tokens\n', '   * \n', '   */\n', '\n', '\n', '\n', '  //Refund users in case of unsuccessful crowdsale\n', '  function _refund(address _investor) internal {\n', '    uint256 investedAmt = investedSum[_investor];\n', '    require(investedAmt > 0);\n', '\n', '  \n', '      uint totalInvestorTokens = tokensAllocated[_investor].add(bonusTokensAllocated[_investor]);\n', '\n', '    if (status == State.Active) {\n', '      //Refunded tokens go back to sale pool\n', '      totalTokensAllocated = totalTokensAllocated.sub(totalInvestorTokens);\n', '    }\n', '\n', '    _clearAddressFromCrowdsale(_investor);\n', '\n', '    _investor.transfer(investedAmt);\n', '\n', '    Refunded(_investor, investedAmt);\n', '  }\n', '\n', '    //Partial refund users\n', '  function refundPartial(address _investor, uint _refundAmt, uint _tokenAmt, uint _bonusTokenAmt) onlyOwner external {\n', '\n', '    uint investedAmt = investedSum[_investor];\n', '    require(investedAmt > _refundAmt);\n', '    require(tokensAllocated[_investor] > _tokenAmt);\n', '    require(bonusTokensAllocated[_investor] > _bonusTokenAmt);\n', '\n', '    investedSum[_investor] = investedSum[_investor].sub(_refundAmt);\n', '    tokensAllocated[_investor] = tokensAllocated[_investor].sub(_tokenAmt);\n', '    bonusTokensAllocated[_investor] = bonusTokensAllocated[_investor].sub(_bonusTokenAmt);\n', '\n', '\n', '    uint totalRefundTokens = _tokenAmt.add(_bonusTokenAmt);\n', '\n', '    if (status == State.Active) {\n', '      //Refunded tokens go back to sale pool\n', '      totalTokensAllocated = totalTokensAllocated.sub(totalRefundTokens);\n', '    }\n', '\n', '    _investor.transfer(_refundAmt);\n', '\n', '    Refunded(_investor, _refundAmt);\n', '  }\n', '\n', '  //Used by investor to claim token\n', '    function claimTokens() external {\n', '      require(hasEnded());\n', '      require(addressKYC[msg.sender]);\n', '      address tokenReceiver = msg.sender;\n', '      uint tokensToClaim = getTotalNormalTokensByAddress(tokenReceiver);\n', '\n', '      require(tokensToClaim > 0);\n', '      _clearTotalNormalTokensByAddress(tokenReceiver);\n', '\n', '      violaToken.transferFrom(owner, tokenReceiver, tokensToClaim);\n', '\n', '      TokenDistributed(tokenReceiver, tokensToClaim);\n', '\n', '    }\n', '\n', '    //Used by investor to claim bonus token\n', '    function claimBonusTokens() external {\n', '      require(hasEnded());\n', '      require(now >= bonusVestingPeriod);\n', '      require(addressKYC[msg.sender]);\n', '\n', '      address tokenReceiver = msg.sender;\n', '      uint tokensToClaim = getTotalBonusTokensByAddress(tokenReceiver);\n', '\n', '      require(tokensToClaim > 0);\n', '      _clearTotalBonusTokensByAddress(tokenReceiver);\n', '\n', '      violaToken.transferFrom(owner, tokenReceiver, tokensToClaim);\n', '\n', '      BonusTokenDistributed(tokenReceiver, tokensToClaim);\n', '    }\n', '\n', '    //Used by owner to distribute bonus token\n', '    function distributeBonusTokens(address _tokenReceiver) onlyOwner external {\n', '      require(hasEnded());\n', '      require(now >= bonusVestingPeriod);\n', '\n', '      address tokenReceiver = _tokenReceiver;\n', '      uint tokensToClaim = getTotalBonusTokensByAddress(tokenReceiver);\n', '\n', '      require(tokensToClaim > 0);\n', '      _clearTotalBonusTokensByAddress(tokenReceiver);\n', '\n', '      transferTokens(tokenReceiver, tokensToClaim);\n', '\n', '      BonusTokenDistributed(tokenReceiver,tokensToClaim);\n', '\n', '    }\n', '\n', '    //Used by owner to distribute token\n', '    function distributeICOTokens(address _tokenReceiver) onlyOwner external {\n', '      require(hasEnded());\n', '\n', '      address tokenReceiver = _tokenReceiver;\n', '      uint tokensToClaim = getTotalNormalTokensByAddress(tokenReceiver);\n', '\n', '      require(tokensToClaim > 0);\n', '      _clearTotalNormalTokensByAddress(tokenReceiver);\n', '\n', '      transferTokens(tokenReceiver, tokensToClaim);\n', '\n', '      TokenDistributed(tokenReceiver,tokensToClaim);\n', '\n', '    }\n', '\n', '    //For owner to reserve token for presale\n', '    // function reserveTokens(uint _amount) onlyOwner external {\n', '\n', '    //   require(getTokensLeft() >= _amount);\n', '    //   totalTokensAllocated = totalTokensAllocated.add(_amount);\n', '    //   totalReservedTokenAllocated = totalReservedTokenAllocated.add(_amount);\n', '\n', '    // }\n', '\n', '    // //To distribute tokens not allocated by crowdsale contract\n', '    // function distributePresaleTokens(address _tokenReceiver, uint _amount) onlyOwner external {\n', '    //   require(hasEnded());\n', '    //   require(_tokenReceiver != address(0));\n', '    //   require(_amount > 0);\n', '\n', '    //   violaToken.transferFrom(owner, _tokenReceiver, _amount);\n', '\n', '    //   TokenDistributed(_tokenReceiver,_amount);\n', '\n', '    // }\n', '\n', '    //For external purchases & pre-sale via btc/fiat\n', '    function externalPurchaseTokens(address _investor, uint _amount, uint _bonusAmount) onlyOwner external {\n', '      require(_amount > 0);\n', '      uint256 totalTokensToAllocate = _amount.add(_bonusAmount);\n', '\n', '      require(getTokensLeft() >= totalTokensToAllocate);\n', '      totalTokensAllocated = totalTokensAllocated.add(totalTokensToAllocate);\n', '      totalReservedTokenAllocated = totalReservedTokenAllocated.add(totalTokensToAllocate);\n', '\n', '      externalTokensAllocated[_investor] = externalTokensAllocated[_investor].add(_amount);\n', '      externalBonusTokensAllocated[_investor] = externalBonusTokensAllocated[_investor].add(_bonusAmount);\n', '      \n', '      ExternalTokenPurchase(_investor,  _amount, _bonusAmount);\n', '\n', '    }\n', '\n', '    function refundAllExternalPurchase(address _investor) onlyOwner external {\n', '      require(_investor != address(0));\n', '      require(externalTokensAllocated[_investor] > 0);\n', '\n', '      uint externalTokens = externalTokensAllocated[_investor];\n', '      uint externalBonusTokens = externalBonusTokensAllocated[_investor];\n', '\n', '      externalTokensAllocated[_investor] = 0;\n', '      externalBonusTokensAllocated[_investor] = 0;\n', '\n', '      uint totalInvestorTokens = externalTokens.add(externalBonusTokens);\n', '\n', '      totalReservedTokenAllocated = totalReservedTokenAllocated.sub(totalInvestorTokens);\n', '      totalTokensAllocated = totalTokensAllocated.sub(totalInvestorTokens);\n', '\n', '      ExternalPurchaseRefunded(_investor,externalTokens,externalBonusTokens);\n', '    }\n', '\n', '    function refundExternalPurchase(address _investor, uint _amountToRefund, uint _bonusAmountToRefund) onlyOwner external {\n', '      require(_investor != address(0));\n', '      require(externalTokensAllocated[_investor] >= _amountToRefund);\n', '      require(externalBonusTokensAllocated[_investor] >= _bonusAmountToRefund);\n', '\n', '      uint totalTokensToRefund = _amountToRefund.add(_bonusAmountToRefund);\n', '      externalTokensAllocated[_investor] = externalTokensAllocated[_investor].sub(_amountToRefund);\n', '      externalBonusTokensAllocated[_investor] = externalBonusTokensAllocated[_investor].sub(_bonusAmountToRefund);\n', '\n', '      totalReservedTokenAllocated = totalReservedTokenAllocated.sub(totalTokensToRefund);\n', '      totalTokensAllocated = totalTokensAllocated.sub(totalTokensToRefund);\n', '\n', '      ExternalPurchaseRefunded(_investor,_amountToRefund,_bonusAmountToRefund);\n', '    }\n', '\n', '    function _clearAddressFromCrowdsale(address _investor) internal {\n', '      tokensAllocated[_investor] = 0;\n', '      bonusTokensAllocated[_investor] = 0;\n', '      investedSum[_investor] = 0;\n', '      maxBuyCap[_investor] = 0;\n', '    }\n', '\n', '    function allocateTopupToken(address _investor, uint _amount, uint _bonusAmount) onlyOwner external {\n', '      require(hasEnded());\n', '      require(_amount > 0);\n', '      uint256 tokensToAllocate = _amount.add(_bonusAmount);\n', '\n', '      require(getTokensLeft() >= tokensToAllocate);\n', '      totalTokensAllocated = totalTokensAllocated.add(_amount);\n', '\n', '      tokensAllocated[_investor] = tokensAllocated[_investor].add(_amount);\n', '      bonusTokensAllocated[_investor] = bonusTokensAllocated[_investor].add(_bonusAmount);\n', '\n', '      TopupTokenAllocated(_investor,  _amount, _bonusAmount);\n', '    }\n', '\n', '  //For cases where token are mistakenly sent / airdrops\n', '  function emergencyERC20Drain( ERC20 token, uint amount ) external onlyOwner {\n', '    require(status == State.Completed);\n', '    token.transfer(owner,amount);\n', '  }\n', '\n', '}']
['pragma solidity 0.4.20;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed burner, uint256 value);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// VIOLET ERC20 Standard Token\n', '// ----------------------------------------------------------------------------\n', 'contract VLTToken is ERC20Interface {\n', '    using SafeMath for uint256;\n', '\n', '    address public owner = msg.sender;\n', '\n', '    bytes32 public symbol;\n', '    bytes32 public name;\n', '    uint8 public decimals;\n', '    uint256 public _totalSupply;\n', '\n', '    mapping(address => uint256) internal balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    function VLTToken() public {\n', '        symbol = "VAI";\n', '        name = "VIOLET";\n', '        decimals = 18;\n', '        _totalSupply = 250000000 * 10**uint256(decimals);\n', '        balances[owner] = _totalSupply;\n', '        Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev total number of tokens in existence\n', '    */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        // allow sending 0 tokens\n', '        if (_value == 0) {\n', '            Transfer(msg.sender, _to, _value);    // Follow the spec to louch the event when transfer 0\n', '            return;\n', '        }\n', '        \n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        // SafeMath.sub will throw if there is not enough balance.\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    *\n', '    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer tokens from one address to another\n', '    * @param _from address The address which you want to send tokens from\n', '    * @param _to address The address which you want to transfer to\n', '    * @param _value uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        // allow sending 0 tokens\n', '        if (_value == 0) {\n', '            Transfer(_from, _to, _value);    // Follow the spec to louch the event when transfer 0\n', '            return;\n', '        }\n', '\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    * @param _owner address The address which owns the funds.\n', '    * @param _spender address The address which will spend the funds.\n', '    * @return A uint256 specifying the amount of tokens still available for the spender.\n', '    */\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '    *\n', '    * approve should be called when allowed[_spender] == 0. To increment\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _addedValue The amount of tokens to increase the allowance by.\n', '    */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '    *\n', '    * approve should be called when allowed[_spender] == 0. To decrement\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '    */\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '        allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Burns a specific amount of tokens.\n', '    * @param _value The amount of token to be burned.\n', '    */\n', '    function burn(uint256 _value) public {\n', '        require(_value <= balances[msg.sender]);\n', '        // no need to require value <= totalSupply, since that would imply the\n', "        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        _totalSupply = _totalSupply.sub(_value);\n', '        Burn(burner, _value);\n', '        Transfer(burner, address(0), _value);\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) public returns (bool) {\n', '        require(_value <= balances[_from]);               // Check if the targeted balance is enough\n', '        require(_value <= allowed[_from][msg.sender]);    // Check allowed allowance\n', '        balances[_from] = balances[_from].sub(_value);  // Subtract from the targeted balance\n', "        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);             // Subtract from the sender's allowance\n", '        _totalSupply = _totalSupply.sub(_value);                              // Update totalSupply\n', '        Burn(_from, _value);\n', '        Transfer(_from, address(0), _value);\n', '        return true;\n', '    } \n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ViolaCrowdsale\n', ' * @dev ViolaCrowdsale reserves token from supply when eth is received\n', ' * funds will be forwarded after the end of crowdsale. Tokens will be claimable\n', ' * within 7 days after crowdsale ends.\n', ' */\n', ' \n', 'contract ViolaCrowdsale is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  enum State { Deployed, PendingStart, Active, Paused, Ended, Completed }\n', '\n', '  //Status of contract\n', '  State public status = State.Deployed;\n', '\n', '  // The token being sold\n', '  VLTToken public violaToken;\n', '\n', '  //For keeping track of whitelist address. cap >0 = whitelisted\n', '  mapping(address=>uint) public maxBuyCap;\n', '\n', '  //For checking if address passed KYC\n', '  mapping(address => bool)public addressKYC;\n', '\n', '  //Total wei sum an address has invested\n', '  mapping(address=>uint) public investedSum;\n', '\n', '  //Total violaToken an address is allocated\n', '  mapping(address=>uint) public tokensAllocated;\n', '\n', '    //Total violaToken an address purchased externally is allocated\n', '  mapping(address=>uint) public externalTokensAllocated;\n', '\n', '  //Total bonus violaToken an address is entitled after vesting\n', '  mapping(address=>uint) public bonusTokensAllocated;\n', '\n', '  //Total bonus violaToken an address purchased externally is entitled after vesting\n', '  mapping(address=>uint) public externalBonusTokensAllocated;\n', '\n', '  //Store addresses that has registered for crowdsale before (pushed via setWhitelist)\n', '  //Does not mean whitelisted as it can be revoked. Just to track address for loop\n', '  address[] public registeredAddress;\n', '\n', '  //Total amount not approved for withdrawal\n', '  uint256 public totalApprovedAmount = 0;\n', '\n', '  //Start and end timestamps where investments are allowed (both inclusive)\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '  uint256 public bonusVestingPeriod = 60 days;\n', '\n', '\n', '  /**\n', '   * Note all values are calculated in wei(uint256) including token amount\n', '   * 1 ether = 1000000000000000000 wei\n', '   * 1 viola = 1000000000000000000 vi lawei\n', '   */\n', '\n', '\n', '  //Address where funds are collected\n', '  address public wallet;\n', '\n', '  //Min amount investor can purchase\n', '  uint256 public minWeiToPurchase;\n', '\n', '  // how many token units *in wei* a buyer gets *per wei*\n', '  uint256 public rate;\n', '\n', '  //Extra bonus token to give *in percentage*\n', '  uint public bonusTokenRateLevelOne = 20;\n', '  uint public bonusTokenRateLevelTwo = 15;\n', '  uint public bonusTokenRateLevelThree = 10;\n', '  uint public bonusTokenRateLevelFour = 0;\n', '\n', '  //Total amount of tokens allocated for crowdsale\n', '  uint256 public totalTokensAllocated;\n', '\n', '  //Total amount of tokens reserved from external sources\n', '  //Sub set of totalTokensAllocated ( totalTokensAllocated - totalReservedTokenAllocated = total tokens allocated for purchases using ether )\n', '  uint256 public totalReservedTokenAllocated;\n', '\n', '  //Numbers of token left above 0 to still be considered sold\n', '  uint256 public leftoverTokensBuffer;\n', '\n', '  /**\n', '   * event for front end logging\n', '   */\n', '\n', '  event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount, uint256 bonusAmount);\n', '  event ExternalTokenPurchase(address indexed purchaser, uint256 amount, uint256 bonusAmount);\n', '  event ExternalPurchaseRefunded(address indexed purchaser, uint256 amount, uint256 bonusAmount);\n', '  event TokenDistributed(address indexed tokenReceiver, uint256 tokenAmount);\n', '  event BonusTokenDistributed(address indexed tokenReceiver, uint256 tokenAmount);\n', '  event TopupTokenAllocated(address indexed tokenReceiver, uint256 amount, uint256 bonusAmount);\n', '  event CrowdsalePending();\n', '  event CrowdsaleStarted();\n', '  event CrowdsaleEnded();\n', '  event BonusRateChanged();\n', '  event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '  //Set inital arguments of the crowdsale\n', '  function initialiseCrowdsale (uint256 _startTime, uint256 _rate, address _tokenAddress, address _wallet) onlyOwner external {\n', '    require(status == State.Deployed);\n', '    require(_startTime >= now);\n', '    require(_rate > 0);\n', '    require(address(_tokenAddress) != address(0));\n', '    require(_wallet != address(0));\n', '\n', '    startTime = _startTime;\n', '    endTime = _startTime + 30 days;\n', '    rate = _rate;\n', '    wallet = _wallet;\n', '    violaToken = VLTToken(_tokenAddress);\n', '\n', '    status = State.PendingStart;\n', '\n', '    CrowdsalePending();\n', '\n', '  }\n', '\n', '  /**\n', '   * Crowdsale state functions\n', '   * To track state of current crowdsale\n', '   */\n', '\n', '\n', '  // To be called by Ethereum alarm clock or anyone\n', '  //Can only be called successfully when time is valid\n', '  function startCrowdsale() external {\n', '    require(withinPeriod());\n', '    require(violaToken != address(0));\n', '    require(getTokensLeft() > 0);\n', '    require(status == State.PendingStart);\n', '\n', '    status = State.Active;\n', '\n', '    CrowdsaleStarted();\n', '  }\n', '\n', '  //To be called by owner or contract\n', '  //Ends the crowdsale when tokens are sold out\n', '  function endCrowdsale() public {\n', '    if (!tokensHasSoldOut()) {\n', '      require(msg.sender == owner);\n', '    }\n', '    require(status == State.Active);\n', '\n', '    bonusVestingPeriod = now + 60 days;\n', '\n', '    status = State.Ended;\n', '\n', '    CrowdsaleEnded();\n', '  }\n', '  //Emergency pause\n', '  function pauseCrowdsale() onlyOwner external {\n', '    require(status == State.Active);\n', '\n', '    status = State.Paused;\n', '  }\n', '  //Resume paused crowdsale\n', '  function unpauseCrowdsale() onlyOwner external {\n', '    require(status == State.Paused);\n', '\n', '    status = State.Active;\n', '  }\n', '\n', '  function completeCrowdsale() onlyOwner external {\n', '    require(hasEnded());\n', '    require(violaToken.allowance(owner, this) == 0);\n', '    status = State.Completed;\n', '\n', '    _forwardFunds();\n', '\n', '    assert(this.balance == 0);\n', '  }\n', '\n', '  function burnExtraTokens() onlyOwner external {\n', '    require(hasEnded());\n', '    uint256 extraTokensToBurn = violaToken.allowance(owner, this);\n', '    violaToken.burnFrom(owner, extraTokensToBurn);\n', '    assert(violaToken.allowance(owner, this) == 0);\n', '  }\n', '\n', '  // send ether to the fund collection wallet\n', '  function _forwardFunds() internal {\n', '    wallet.transfer(this.balance);\n', '  }\n', '\n', '  function partialForwardFunds(uint _amountToTransfer) onlyOwner external {\n', '    require(status == State.Ended);\n', '    require(_amountToTransfer < totalApprovedAmount);\n', '    totalApprovedAmount = totalApprovedAmount.sub(_amountToTransfer);\n', '    \n', '    wallet.transfer(_amountToTransfer);\n', '  }\n', '\n', '  /**\n', '   * Setter functions for crowdsale parameters\n', '   * Only owner can set values\n', '   */\n', '\n', '\n', '  function setLeftoverTokensBuffer(uint256 _tokenBuffer) onlyOwner external {\n', '    require(_tokenBuffer > 0);\n', '    require(getTokensLeft() >= _tokenBuffer);\n', '    leftoverTokensBuffer = _tokenBuffer;\n', '  }\n', '\n', '  //Set the ether to token rate\n', '  function setRate(uint _rate) onlyOwner external {\n', '    require(_rate > 0);\n', '    rate = _rate;\n', '  }\n', '\n', '  function setBonusTokenRateLevelOne(uint _rate) onlyOwner external {\n', '    //require(_rate > 0);\n', '    bonusTokenRateLevelOne = _rate;\n', '    BonusRateChanged();\n', '  }\n', '\n', '  function setBonusTokenRateLevelTwo(uint _rate) onlyOwner external {\n', '    //require(_rate > 0);\n', '    bonusTokenRateLevelTwo = _rate;\n', '    BonusRateChanged();\n', '  }\n', '\n', '  function setBonusTokenRateLevelThree(uint _rate) onlyOwner external {\n', '    //require(_rate > 0);\n', '    bonusTokenRateLevelThree = _rate;\n', '    BonusRateChanged();\n', '  }\n', '  function setBonusTokenRateLevelFour(uint _rate) onlyOwner external {\n', '    //require(_rate > 0);\n', '    bonusTokenRateLevelFour = _rate;\n', '    BonusRateChanged();\n', '  }\n', '\n', '  function setMinWeiToPurchase(uint _minWeiToPurchase) onlyOwner external {\n', '    minWeiToPurchase = _minWeiToPurchase;\n', '  }\n', '\n', '\n', '  /**\n', '   * Whitelisting and KYC functions\n', '   * Whitelisted address can buy tokens, KYC successful purchaser can claim token. Refund if fail KYC\n', '   */\n', '\n', '\n', '  //Set the amount of wei an address can purchase up to\n', '  //@dev Value of 0 = not whitelisted\n', '  //@dev cap is in *18 decimals* ( 1 token = 1*10^18)\n', '  \n', '  function setWhitelistAddress( address _investor, uint _cap ) onlyOwner external {\n', '        require(_cap > 0);\n', '        require(_investor != address(0));\n', '        maxBuyCap[_investor] = _cap;\n', '        registeredAddress.push(_investor);\n', '        //add event\n', '    }\n', '\n', '  //Remove the address from whitelist\n', '  function removeWhitelistAddress(address _investor) onlyOwner external {\n', '    require(_investor != address(0));\n', '    \n', '    maxBuyCap[_investor] = 0;\n', '    uint256 weiAmount = investedSum[_investor];\n', '\n', '    if (weiAmount > 0) {\n', '      _refund(_investor);\n', '    }\n', '  }\n', '\n', '  //Flag address as KYC approved. Address is now approved to claim tokens\n', '  function approveKYC(address _kycAddress) onlyOwner external {\n', '    require(_kycAddress != address(0));\n', '    addressKYC[_kycAddress] = true;\n', '\n', '    uint256 weiAmount = investedSum[_kycAddress];\n', '    totalApprovedAmount = totalApprovedAmount.add(weiAmount);\n', '  }\n', '\n', '  //Set KYC status as failed. Refund any eth back to address\n', '  function revokeKYC(address _kycAddress) onlyOwner external {\n', '    require(_kycAddress != address(0));\n', '    addressKYC[_kycAddress] = false;\n', '\n', '    uint256 weiAmount = investedSum[_kycAddress];\n', '    totalApprovedAmount = totalApprovedAmount.sub(weiAmount);\n', '\n', '    if (weiAmount > 0) {\n', '      _refund(_kycAddress);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Getter functions for crowdsale parameters\n', '   * Does not use gas\n', '   */\n', '\n', '  //Checks if token has been sold out\n', '    function tokensHasSoldOut() view internal returns (bool) {\n', '      if (getTokensLeft() <= leftoverTokensBuffer) {\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '      // @return true if the transaction can buy tokens\n', '  function withinPeriod() public view returns (bool) {\n', '    return now >= startTime && now <= endTime;\n', '  }\n', '\n', '  // @return true if crowdsale event has ended\n', '  function hasEnded() public view returns (bool) {\n', '    if (status == State.Ended) {\n', '      return true;\n', '    }\n', '    return now > endTime;\n', '  }\n', '\n', '  function getTokensLeft() public view returns (uint) {\n', '    return violaToken.allowance(owner, this).sub(totalTokensAllocated);\n', '  }\n', '\n', '  function transferTokens (address receiver, uint tokenAmount) internal {\n', '     require(violaToken.transferFrom(owner, receiver, tokenAmount));\n', '  }\n', '\n', '  function getTimeBasedBonusRate() public view returns(uint) {\n', '    bool bonusDuration1 = now >= startTime && now <= (startTime + 1 days);  //First 24hr\n', '    bool bonusDuration2 = now > (startTime + 1 days) && now <= (startTime + 3 days);//Next 48 hr\n', '    bool bonusDuration3 = now > (startTime + 3 days) && now <= (startTime + 10 days);//4th to 10th day\n', '    bool bonusDuration4 = now > (startTime + 10 days) && now <= endTime;//11th day onwards\n', '    if (bonusDuration1) {\n', '      return bonusTokenRateLevelOne;\n', '    } else if (bonusDuration2) {\n', '      return bonusTokenRateLevelTwo;\n', '    } else if (bonusDuration3) {\n', '      return bonusTokenRateLevelThree;\n', '    } else if (bonusDuration4) {\n', '      return bonusTokenRateLevelFour;\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function getTotalTokensByAddress(address _investor) public view returns(uint) {\n', '    return getTotalNormalTokensByAddress(_investor).add(getTotalBonusTokensByAddress(_investor));\n', '  }\n', '\n', '  function getTotalNormalTokensByAddress(address _investor) public view returns(uint) {\n', '    return tokensAllocated[_investor].add(externalTokensAllocated[_investor]);\n', '  }\n', '\n', '  function getTotalBonusTokensByAddress(address _investor) public view returns(uint) {\n', '    return bonusTokensAllocated[_investor].add(externalBonusTokensAllocated[_investor]);\n', '  }\n', '\n', '  function _clearTotalNormalTokensByAddress(address _investor) internal {\n', '    tokensAllocated[_investor] = 0;\n', '    externalTokensAllocated[_investor] = 0;\n', '  }\n', '\n', '  function _clearTotalBonusTokensByAddress(address _investor) internal {\n', '    bonusTokensAllocated[_investor] = 0;\n', '    externalBonusTokensAllocated[_investor] = 0;\n', '  }\n', '\n', '\n', '  /**\n', '   * Functions to handle buy tokens\n', '   * Fallback function as entry point for eth\n', '   */\n', '\n', '\n', '  // Called when ether is sent to contract\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  //Used to buy tokens\n', '  function buyTokens(address investor) internal {\n', '    require(status == State.Active);\n', '    require(msg.value >= minWeiToPurchase);\n', '\n', '    uint weiAmount = msg.value;\n', '\n', '    checkCapAndRecord(investor,weiAmount);\n', '\n', '    allocateToken(investor,weiAmount);\n', '    \n', '  }\n', '\n', '  //Internal call to check max user cap\n', '  function checkCapAndRecord(address investor, uint weiAmount) internal {\n', '      uint remaindingCap = maxBuyCap[investor];\n', '      require(remaindingCap >= weiAmount);\n', '      maxBuyCap[investor] = remaindingCap.sub(weiAmount);\n', '      investedSum[investor] = investedSum[investor].add(weiAmount);\n', '  }\n', '\n', '  //Internal call to allocated tokens purchased\n', '    function allocateToken(address investor, uint weiAmount) internal {\n', '        // calculate token amount to be created\n', '        uint tokens = weiAmount.mul(rate);\n', '        uint bonusTokens = tokens.mul(getTimeBasedBonusRate()).div(100);\n', '        \n', '        uint tokensToAllocate = tokens.add(bonusTokens);\n', '        \n', '        require(getTokensLeft() >= tokensToAllocate);\n', '        totalTokensAllocated = totalTokensAllocated.add(tokensToAllocate);\n', '\n', '        tokensAllocated[investor] = tokensAllocated[investor].add(tokens);\n', '        bonusTokensAllocated[investor] = bonusTokensAllocated[investor].add(bonusTokens);\n', '\n', '        if (tokensHasSoldOut()) {\n', '          endCrowdsale();\n', '        }\n', '        TokenPurchase(investor, weiAmount, tokens, bonusTokens);\n', '  }\n', '\n', '\n', '\n', '  /**\n', '   * Functions for refunds & claim tokens\n', '   * \n', '   */\n', '\n', '\n', '\n', '  //Refund users in case of unsuccessful crowdsale\n', '  function _refund(address _investor) internal {\n', '    uint256 investedAmt = investedSum[_investor];\n', '    require(investedAmt > 0);\n', '\n', '  \n', '      uint totalInvestorTokens = tokensAllocated[_investor].add(bonusTokensAllocated[_investor]);\n', '\n', '    if (status == State.Active) {\n', '      //Refunded tokens go back to sale pool\n', '      totalTokensAllocated = totalTokensAllocated.sub(totalInvestorTokens);\n', '    }\n', '\n', '    _clearAddressFromCrowdsale(_investor);\n', '\n', '    _investor.transfer(investedAmt);\n', '\n', '    Refunded(_investor, investedAmt);\n', '  }\n', '\n', '    //Partial refund users\n', '  function refundPartial(address _investor, uint _refundAmt, uint _tokenAmt, uint _bonusTokenAmt) onlyOwner external {\n', '\n', '    uint investedAmt = investedSum[_investor];\n', '    require(investedAmt > _refundAmt);\n', '    require(tokensAllocated[_investor] > _tokenAmt);\n', '    require(bonusTokensAllocated[_investor] > _bonusTokenAmt);\n', '\n', '    investedSum[_investor] = investedSum[_investor].sub(_refundAmt);\n', '    tokensAllocated[_investor] = tokensAllocated[_investor].sub(_tokenAmt);\n', '    bonusTokensAllocated[_investor] = bonusTokensAllocated[_investor].sub(_bonusTokenAmt);\n', '\n', '\n', '    uint totalRefundTokens = _tokenAmt.add(_bonusTokenAmt);\n', '\n', '    if (status == State.Active) {\n', '      //Refunded tokens go back to sale pool\n', '      totalTokensAllocated = totalTokensAllocated.sub(totalRefundTokens);\n', '    }\n', '\n', '    _investor.transfer(_refundAmt);\n', '\n', '    Refunded(_investor, _refundAmt);\n', '  }\n', '\n', '  //Used by investor to claim token\n', '    function claimTokens() external {\n', '      require(hasEnded());\n', '      require(addressKYC[msg.sender]);\n', '      address tokenReceiver = msg.sender;\n', '      uint tokensToClaim = getTotalNormalTokensByAddress(tokenReceiver);\n', '\n', '      require(tokensToClaim > 0);\n', '      _clearTotalNormalTokensByAddress(tokenReceiver);\n', '\n', '      violaToken.transferFrom(owner, tokenReceiver, tokensToClaim);\n', '\n', '      TokenDistributed(tokenReceiver, tokensToClaim);\n', '\n', '    }\n', '\n', '    //Used by investor to claim bonus token\n', '    function claimBonusTokens() external {\n', '      require(hasEnded());\n', '      require(now >= bonusVestingPeriod);\n', '      require(addressKYC[msg.sender]);\n', '\n', '      address tokenReceiver = msg.sender;\n', '      uint tokensToClaim = getTotalBonusTokensByAddress(tokenReceiver);\n', '\n', '      require(tokensToClaim > 0);\n', '      _clearTotalBonusTokensByAddress(tokenReceiver);\n', '\n', '      violaToken.transferFrom(owner, tokenReceiver, tokensToClaim);\n', '\n', '      BonusTokenDistributed(tokenReceiver, tokensToClaim);\n', '    }\n', '\n', '    //Used by owner to distribute bonus token\n', '    function distributeBonusTokens(address _tokenReceiver) onlyOwner external {\n', '      require(hasEnded());\n', '      require(now >= bonusVestingPeriod);\n', '\n', '      address tokenReceiver = _tokenReceiver;\n', '      uint tokensToClaim = getTotalBonusTokensByAddress(tokenReceiver);\n', '\n', '      require(tokensToClaim > 0);\n', '      _clearTotalBonusTokensByAddress(tokenReceiver);\n', '\n', '      transferTokens(tokenReceiver, tokensToClaim);\n', '\n', '      BonusTokenDistributed(tokenReceiver,tokensToClaim);\n', '\n', '    }\n', '\n', '    //Used by owner to distribute token\n', '    function distributeICOTokens(address _tokenReceiver) onlyOwner external {\n', '      require(hasEnded());\n', '\n', '      address tokenReceiver = _tokenReceiver;\n', '      uint tokensToClaim = getTotalNormalTokensByAddress(tokenReceiver);\n', '\n', '      require(tokensToClaim > 0);\n', '      _clearTotalNormalTokensByAddress(tokenReceiver);\n', '\n', '      transferTokens(tokenReceiver, tokensToClaim);\n', '\n', '      TokenDistributed(tokenReceiver,tokensToClaim);\n', '\n', '    }\n', '\n', '    //For owner to reserve token for presale\n', '    // function reserveTokens(uint _amount) onlyOwner external {\n', '\n', '    //   require(getTokensLeft() >= _amount);\n', '    //   totalTokensAllocated = totalTokensAllocated.add(_amount);\n', '    //   totalReservedTokenAllocated = totalReservedTokenAllocated.add(_amount);\n', '\n', '    // }\n', '\n', '    // //To distribute tokens not allocated by crowdsale contract\n', '    // function distributePresaleTokens(address _tokenReceiver, uint _amount) onlyOwner external {\n', '    //   require(hasEnded());\n', '    //   require(_tokenReceiver != address(0));\n', '    //   require(_amount > 0);\n', '\n', '    //   violaToken.transferFrom(owner, _tokenReceiver, _amount);\n', '\n', '    //   TokenDistributed(_tokenReceiver,_amount);\n', '\n', '    // }\n', '\n', '    //For external purchases & pre-sale via btc/fiat\n', '    function externalPurchaseTokens(address _investor, uint _amount, uint _bonusAmount) onlyOwner external {\n', '      require(_amount > 0);\n', '      uint256 totalTokensToAllocate = _amount.add(_bonusAmount);\n', '\n', '      require(getTokensLeft() >= totalTokensToAllocate);\n', '      totalTokensAllocated = totalTokensAllocated.add(totalTokensToAllocate);\n', '      totalReservedTokenAllocated = totalReservedTokenAllocated.add(totalTokensToAllocate);\n', '\n', '      externalTokensAllocated[_investor] = externalTokensAllocated[_investor].add(_amount);\n', '      externalBonusTokensAllocated[_investor] = externalBonusTokensAllocated[_investor].add(_bonusAmount);\n', '      \n', '      ExternalTokenPurchase(_investor,  _amount, _bonusAmount);\n', '\n', '    }\n', '\n', '    function refundAllExternalPurchase(address _investor) onlyOwner external {\n', '      require(_investor != address(0));\n', '      require(externalTokensAllocated[_investor] > 0);\n', '\n', '      uint externalTokens = externalTokensAllocated[_investor];\n', '      uint externalBonusTokens = externalBonusTokensAllocated[_investor];\n', '\n', '      externalTokensAllocated[_investor] = 0;\n', '      externalBonusTokensAllocated[_investor] = 0;\n', '\n', '      uint totalInvestorTokens = externalTokens.add(externalBonusTokens);\n', '\n', '      totalReservedTokenAllocated = totalReservedTokenAllocated.sub(totalInvestorTokens);\n', '      totalTokensAllocated = totalTokensAllocated.sub(totalInvestorTokens);\n', '\n', '      ExternalPurchaseRefunded(_investor,externalTokens,externalBonusTokens);\n', '    }\n', '\n', '    function refundExternalPurchase(address _investor, uint _amountToRefund, uint _bonusAmountToRefund) onlyOwner external {\n', '      require(_investor != address(0));\n', '      require(externalTokensAllocated[_investor] >= _amountToRefund);\n', '      require(externalBonusTokensAllocated[_investor] >= _bonusAmountToRefund);\n', '\n', '      uint totalTokensToRefund = _amountToRefund.add(_bonusAmountToRefund);\n', '      externalTokensAllocated[_investor] = externalTokensAllocated[_investor].sub(_amountToRefund);\n', '      externalBonusTokensAllocated[_investor] = externalBonusTokensAllocated[_investor].sub(_bonusAmountToRefund);\n', '\n', '      totalReservedTokenAllocated = totalReservedTokenAllocated.sub(totalTokensToRefund);\n', '      totalTokensAllocated = totalTokensAllocated.sub(totalTokensToRefund);\n', '\n', '      ExternalPurchaseRefunded(_investor,_amountToRefund,_bonusAmountToRefund);\n', '    }\n', '\n', '    function _clearAddressFromCrowdsale(address _investor) internal {\n', '      tokensAllocated[_investor] = 0;\n', '      bonusTokensAllocated[_investor] = 0;\n', '      investedSum[_investor] = 0;\n', '      maxBuyCap[_investor] = 0;\n', '    }\n', '\n', '    function allocateTopupToken(address _investor, uint _amount, uint _bonusAmount) onlyOwner external {\n', '      require(hasEnded());\n', '      require(_amount > 0);\n', '      uint256 tokensToAllocate = _amount.add(_bonusAmount);\n', '\n', '      require(getTokensLeft() >= tokensToAllocate);\n', '      totalTokensAllocated = totalTokensAllocated.add(_amount);\n', '\n', '      tokensAllocated[_investor] = tokensAllocated[_investor].add(_amount);\n', '      bonusTokensAllocated[_investor] = bonusTokensAllocated[_investor].add(_bonusAmount);\n', '\n', '      TopupTokenAllocated(_investor,  _amount, _bonusAmount);\n', '    }\n', '\n', '  //For cases where token are mistakenly sent / airdrops\n', '  function emergencyERC20Drain( ERC20 token, uint amount ) external onlyOwner {\n', '    require(status == State.Completed);\n', '    token.transfer(owner,amount);\n', '  }\n', '\n', '}']
