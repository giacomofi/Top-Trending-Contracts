['pragma solidity 0.4.24;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  // it is recommended to define functions which can neither read the state of blockchain nor write in it as pure instead of constant\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public creater;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable(address _owner) public {\n', '        creater = msg.sender;\n', '        if (_owner != 0) {\n', '            owner = _owner;\n', '\n', '        }\n', '        else {\n', '            owner = creater;\n', '        }\n', '\n', '    }\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier isCreator() {\n', '        require(msg.sender == creater);\n', '        _;\n', '    }\n', '\n', '   \n', '\n', '}\n', '\n', '\n', 'contract TravelHelperToken {\n', '    function transfer (address, uint) public pure { }\n', '    function burnTokensForSale() public returns (bool);\n', '    function saleTransfer(address _to, uint256 _value) public returns (bool) {}\n', '    function finalize() public pure { }\n', '}\n', '\n', 'contract Crowdsale is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  // The token being sold\n', '  TravelHelperToken public token;\n', '  \n', '  uint public ethPrice;\n', '\n', '  // Address where funds are collected\n', '  address public wallet;\n', '\n', '  // Amount of wei raised\n', '  uint256 public weiRaised;\n', '  bool public crowdsaleStarted = false;\n', '  uint256 public preIcoCap = uint256(1000000000).mul(1 ether);\n', '  uint256 public icoCap = uint256(1500000000).mul(1 ether);\n', '  uint256 public preIcoTokensSold = 0;\n', '  uint256 public discountedIcoTokensSold = 0;\n', '  uint256 public icoTokensSold = 0;\n', '  \n', '  \n', '  uint256 public mainTokensPerDollar = 400 * 1 ether;\n', '  \n', '  uint256 public totalRaisedInCents;\n', '  uint256 public presaleTokensPerDollar = 533.3333 * 1 ether;\n', '  uint256 public discountedTokensPerDollar = 444.4444 * 1 ether;\n', '  uint256 public hardCapInCents = 525000000;\n', '  uint256 public preIcoStartBlock;\n', '  uint256 public discountedIcoStartBlock;\n', '  uint256 public mainIcoStartBlock;\n', '  uint256 public mainIcoEndBlock;\n', '  uint public preSaleDuration =  (7 days)/(15);\n', '  uint public discountedSaleDuration = (15 days)/(15); \n', '  uint public mainSaleDuration = (15 days)/(15); \n', '  \n', '  \n', '  modifier CrowdsaleStarted(){\n', '      require(crowdsaleStarted);\n', '      _;\n', '  }\n', ' \n', '  /**\n', '   * Event for token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param value weis paid for purchase\n', '   * @param amount amount of tokens purchased\n', '   */\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '  /**\n', '   * @param _newOwner Address who has special power to change the ether price in cents according to the market price\n', '   * @param _wallet Address where collected funds will be forwarded to\n', '   * @param _token Address of the token being sold\n', '   *  @param _ethPriceInCents ether price in cents\n', '   */\n', '  function Crowdsale(address _newOwner, address _wallet, TravelHelperToken _token,uint256 _ethPriceInCents) Ownable(_newOwner) public {\n', '    require(_wallet != address(0));\n', '    require(_token != address(0));\n', '    require(_ethPriceInCents > 0);\n', '    wallet = _wallet;\n', '    owner = _newOwner;\n', '    token = _token;\n', '    ethPrice = _ethPriceInCents; //ethPrice in cents\n', '  }\n', '\n', '  function startCrowdsale() onlyOwner public returns (bool) {\n', '      require(!crowdsaleStarted);\n', '      crowdsaleStarted = true;\n', '      preIcoStartBlock = block.number;\n', '      discountedIcoStartBlock = block.number + preSaleDuration;\n', '      mainIcoStartBlock = block.number + preSaleDuration + discountedSaleDuration;\n', '      mainIcoEndBlock = block.number + preSaleDuration + discountedSaleDuration + mainSaleDuration;\n', '      \n', '  }\n', '  \n', '  // -----------------------------------------\n', '  // Crowdsale external interface\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev fallback function ***DO NOT OVERRIDE***\n', '   */\n', '  function () external payable {\n', '    require(msg.sender != owner);\n', '     buyTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @param _beneficiary Address performing the token purchase\n', '   */\n', '  function buyTokens(address _beneficiary) CrowdsaleStarted public payable {\n', '    uint256 weiAmount = msg.value;\n', '    require(weiAmount > 0);\n', '    require(ethPrice > 0);\n', '    uint256 usdCents = weiAmount.mul(ethPrice).div(1 ether); \n', '\n', '    // calculate token amount to be created\n', '    uint256 tokens = _getTokenAmount(usdCents);\n', '\n', '    _validateTokensLimits(tokens);\n', '\n', '    // update state\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    totalRaisedInCents = totalRaisedInCents.add(usdCents);\n', '    _processPurchase(_beneficiary,tokens);\n', '     emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '    _forwardFunds();\n', '  }\n', '  \n', ' \n', '   /**\n', '   * @dev sets the value of ether price in cents.Can be called only by the owner account.\n', '   * @param _ethPriceInCents price in cents .\n', '   */\n', ' function setEthPriceInDollar(uint _ethPriceInCents) onlyOwner public returns(bool) {\n', '      ethPrice = _ethPriceInCents;\n', '      return true;\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Internal interface (extensible)\n', '  // -----------------------------------------\n', '\n', '\n', '  /**\n', '   * @dev Validation of the capped restrictions.\n', '   * @param _tokens tokens amount\n', '   */\n', '  function _validateTokensLimits(uint256 _tokens) internal {\n', '    if (block.number > preIcoStartBlock && block.number < discountedIcoStartBlock) {\n', '      preIcoTokensSold = preIcoTokensSold.add(_tokens);\n', '      require(preIcoTokensSold <= preIcoCap && totalRaisedInCents <= hardCapInCents);\n', '    } else if(block.number >= discountedIcoStartBlock && block.number < mainIcoStartBlock ) {\n', '       require(discountedIcoTokensSold <= icoCap && totalRaisedInCents <= hardCapInCents);\n', '    } else if(block.number >= mainIcoStartBlock && block.number < mainIcoEndBlock ) {\n', '      icoTokensSold = icoTokensSold.add(_tokens);\n', '      require(icoTokensSold <= icoCap && totalRaisedInCents < hardCapInCents);\n', '    } else {\n', '      revert();\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n', '   * @param _beneficiary Address performing the token purchase\n', '   * @param _tokenAmount Number of tokens to be emitted\n', '   */\n', '  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '    require(token.saleTransfer(_beneficiary, _tokenAmount));\n', '  }\n', '\n', '  /**\n', '   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n', '   * @param _beneficiary Address receiving the tokens\n', '   * @param _tokenAmount Number of tokens to be purchased\n', '   */\n', '  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '    _deliverTokens(_beneficiary, _tokenAmount);\n', '  }\n', '  \n', '\n', '  /**\n', '   * @param _usdCents Value in usd cents to be converted into tokens\n', '   * @return Number of tokens that can be purchased with the specified _usdCents\n', '   */\n', '  function _getTokenAmount(uint256 _usdCents) CrowdsaleStarted public view returns (uint256) {\n', '    uint256 tokens;\n', '    \n', '    if (block.number > preIcoStartBlock && block.number < discountedIcoStartBlock ) tokens = _usdCents.div(100).mul(presaleTokensPerDollar);\n', '    if (block.number >= discountedIcoStartBlock && block.number < mainIcoStartBlock )  tokens = _usdCents.div(100).mul(discountedTokensPerDollar);\n', '    if (block.number >= mainIcoStartBlock && block.number < mainIcoEndBlock )  tokens = _usdCents.div(100).mul(mainTokensPerDollar);\n', '    \n', '\n', '    return tokens;\n', '  }\n', '  \n', '   /**\n', '   * @return returns the current stage of sale\n', '   */\n', '    function getStage() public view returns (string) {\n', '        if(!crowdsaleStarted){\n', '            return &#39;Crowdsale not started yet&#39;;\n', '        }\n', '        if (block.number > preIcoStartBlock && block.number < discountedIcoStartBlock )\n', '        {\n', '            return &#39;Presale&#39;;\n', '        }\n', '        else if (block.number >= discountedIcoStartBlock  && block.number < mainIcoStartBlock ) {\n', '            return &#39;Discounted sale&#39;;\n', '        }\n', '        else if (block.number >= mainIcoStartBlock && block.number < mainIcoEndBlock )\n', '        {\n', '            return &#39;Crowdsale&#39;;\n', '        }\n', '        else if(block.number > mainIcoEndBlock)\n', '        {\n', '            return &#39;Sale ended&#39;;\n', '        }\n', '      \n', '     }\n', '      \n', '    /**\n', '       * @dev burn the unsold tokens.\n', '       \n', '       */\n', '     function burnTokens() public onlyOwner {\n', '        require(block.number > mainIcoEndBlock);\n', '        require(token.burnTokensForSale());\n', '      }\n', '        \n', '  /**\n', '   * @dev finalize the crowdsale.After finalizing ,tokens transfer can be done.\n', '   */\n', '  function finalizeSale() public onlyOwner {\n', '    require(block.number > mainIcoEndBlock);\n', '    token.finalize();\n', '  }\n', '  \n', '  \n', '  /**\n', '   * @dev Determines how ETH is stored/forwarded on purchases.\n', '   */\n', '  function _forwardFunds() internal {\n', '    wallet.transfer(msg.value);\n', '  }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  // it is recommended to define functions which can neither read the state of blockchain nor write in it as pure instead of constant\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public creater;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable(address _owner) public {\n', '        creater = msg.sender;\n', '        if (_owner != 0) {\n', '            owner = _owner;\n', '\n', '        }\n', '        else {\n', '            owner = creater;\n', '        }\n', '\n', '    }\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier isCreator() {\n', '        require(msg.sender == creater);\n', '        _;\n', '    }\n', '\n', '   \n', '\n', '}\n', '\n', '\n', 'contract TravelHelperToken {\n', '    function transfer (address, uint) public pure { }\n', '    function burnTokensForSale() public returns (bool);\n', '    function saleTransfer(address _to, uint256 _value) public returns (bool) {}\n', '    function finalize() public pure { }\n', '}\n', '\n', 'contract Crowdsale is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  // The token being sold\n', '  TravelHelperToken public token;\n', '  \n', '  uint public ethPrice;\n', '\n', '  // Address where funds are collected\n', '  address public wallet;\n', '\n', '  // Amount of wei raised\n', '  uint256 public weiRaised;\n', '  bool public crowdsaleStarted = false;\n', '  uint256 public preIcoCap = uint256(1000000000).mul(1 ether);\n', '  uint256 public icoCap = uint256(1500000000).mul(1 ether);\n', '  uint256 public preIcoTokensSold = 0;\n', '  uint256 public discountedIcoTokensSold = 0;\n', '  uint256 public icoTokensSold = 0;\n', '  \n', '  \n', '  uint256 public mainTokensPerDollar = 400 * 1 ether;\n', '  \n', '  uint256 public totalRaisedInCents;\n', '  uint256 public presaleTokensPerDollar = 533.3333 * 1 ether;\n', '  uint256 public discountedTokensPerDollar = 444.4444 * 1 ether;\n', '  uint256 public hardCapInCents = 525000000;\n', '  uint256 public preIcoStartBlock;\n', '  uint256 public discountedIcoStartBlock;\n', '  uint256 public mainIcoStartBlock;\n', '  uint256 public mainIcoEndBlock;\n', '  uint public preSaleDuration =  (7 days)/(15);\n', '  uint public discountedSaleDuration = (15 days)/(15); \n', '  uint public mainSaleDuration = (15 days)/(15); \n', '  \n', '  \n', '  modifier CrowdsaleStarted(){\n', '      require(crowdsaleStarted);\n', '      _;\n', '  }\n', ' \n', '  /**\n', '   * Event for token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param value weis paid for purchase\n', '   * @param amount amount of tokens purchased\n', '   */\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '  /**\n', '   * @param _newOwner Address who has special power to change the ether price in cents according to the market price\n', '   * @param _wallet Address where collected funds will be forwarded to\n', '   * @param _token Address of the token being sold\n', '   *  @param _ethPriceInCents ether price in cents\n', '   */\n', '  function Crowdsale(address _newOwner, address _wallet, TravelHelperToken _token,uint256 _ethPriceInCents) Ownable(_newOwner) public {\n', '    require(_wallet != address(0));\n', '    require(_token != address(0));\n', '    require(_ethPriceInCents > 0);\n', '    wallet = _wallet;\n', '    owner = _newOwner;\n', '    token = _token;\n', '    ethPrice = _ethPriceInCents; //ethPrice in cents\n', '  }\n', '\n', '  function startCrowdsale() onlyOwner public returns (bool) {\n', '      require(!crowdsaleStarted);\n', '      crowdsaleStarted = true;\n', '      preIcoStartBlock = block.number;\n', '      discountedIcoStartBlock = block.number + preSaleDuration;\n', '      mainIcoStartBlock = block.number + preSaleDuration + discountedSaleDuration;\n', '      mainIcoEndBlock = block.number + preSaleDuration + discountedSaleDuration + mainSaleDuration;\n', '      \n', '  }\n', '  \n', '  // -----------------------------------------\n', '  // Crowdsale external interface\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev fallback function ***DO NOT OVERRIDE***\n', '   */\n', '  function () external payable {\n', '    require(msg.sender != owner);\n', '     buyTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @param _beneficiary Address performing the token purchase\n', '   */\n', '  function buyTokens(address _beneficiary) CrowdsaleStarted public payable {\n', '    uint256 weiAmount = msg.value;\n', '    require(weiAmount > 0);\n', '    require(ethPrice > 0);\n', '    uint256 usdCents = weiAmount.mul(ethPrice).div(1 ether); \n', '\n', '    // calculate token amount to be created\n', '    uint256 tokens = _getTokenAmount(usdCents);\n', '\n', '    _validateTokensLimits(tokens);\n', '\n', '    // update state\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    totalRaisedInCents = totalRaisedInCents.add(usdCents);\n', '    _processPurchase(_beneficiary,tokens);\n', '     emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '    _forwardFunds();\n', '  }\n', '  \n', ' \n', '   /**\n', '   * @dev sets the value of ether price in cents.Can be called only by the owner account.\n', '   * @param _ethPriceInCents price in cents .\n', '   */\n', ' function setEthPriceInDollar(uint _ethPriceInCents) onlyOwner public returns(bool) {\n', '      ethPrice = _ethPriceInCents;\n', '      return true;\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Internal interface (extensible)\n', '  // -----------------------------------------\n', '\n', '\n', '  /**\n', '   * @dev Validation of the capped restrictions.\n', '   * @param _tokens tokens amount\n', '   */\n', '  function _validateTokensLimits(uint256 _tokens) internal {\n', '    if (block.number > preIcoStartBlock && block.number < discountedIcoStartBlock) {\n', '      preIcoTokensSold = preIcoTokensSold.add(_tokens);\n', '      require(preIcoTokensSold <= preIcoCap && totalRaisedInCents <= hardCapInCents);\n', '    } else if(block.number >= discountedIcoStartBlock && block.number < mainIcoStartBlock ) {\n', '       require(discountedIcoTokensSold <= icoCap && totalRaisedInCents <= hardCapInCents);\n', '    } else if(block.number >= mainIcoStartBlock && block.number < mainIcoEndBlock ) {\n', '      icoTokensSold = icoTokensSold.add(_tokens);\n', '      require(icoTokensSold <= icoCap && totalRaisedInCents < hardCapInCents);\n', '    } else {\n', '      revert();\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n', '   * @param _beneficiary Address performing the token purchase\n', '   * @param _tokenAmount Number of tokens to be emitted\n', '   */\n', '  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '    require(token.saleTransfer(_beneficiary, _tokenAmount));\n', '  }\n', '\n', '  /**\n', '   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n', '   * @param _beneficiary Address receiving the tokens\n', '   * @param _tokenAmount Number of tokens to be purchased\n', '   */\n', '  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '    _deliverTokens(_beneficiary, _tokenAmount);\n', '  }\n', '  \n', '\n', '  /**\n', '   * @param _usdCents Value in usd cents to be converted into tokens\n', '   * @return Number of tokens that can be purchased with the specified _usdCents\n', '   */\n', '  function _getTokenAmount(uint256 _usdCents) CrowdsaleStarted public view returns (uint256) {\n', '    uint256 tokens;\n', '    \n', '    if (block.number > preIcoStartBlock && block.number < discountedIcoStartBlock ) tokens = _usdCents.div(100).mul(presaleTokensPerDollar);\n', '    if (block.number >= discountedIcoStartBlock && block.number < mainIcoStartBlock )  tokens = _usdCents.div(100).mul(discountedTokensPerDollar);\n', '    if (block.number >= mainIcoStartBlock && block.number < mainIcoEndBlock )  tokens = _usdCents.div(100).mul(mainTokensPerDollar);\n', '    \n', '\n', '    return tokens;\n', '  }\n', '  \n', '   /**\n', '   * @return returns the current stage of sale\n', '   */\n', '    function getStage() public view returns (string) {\n', '        if(!crowdsaleStarted){\n', "            return 'Crowdsale not started yet';\n", '        }\n', '        if (block.number > preIcoStartBlock && block.number < discountedIcoStartBlock )\n', '        {\n', "            return 'Presale';\n", '        }\n', '        else if (block.number >= discountedIcoStartBlock  && block.number < mainIcoStartBlock ) {\n', "            return 'Discounted sale';\n", '        }\n', '        else if (block.number >= mainIcoStartBlock && block.number < mainIcoEndBlock )\n', '        {\n', "            return 'Crowdsale';\n", '        }\n', '        else if(block.number > mainIcoEndBlock)\n', '        {\n', "            return 'Sale ended';\n", '        }\n', '      \n', '     }\n', '      \n', '    /**\n', '       * @dev burn the unsold tokens.\n', '       \n', '       */\n', '     function burnTokens() public onlyOwner {\n', '        require(block.number > mainIcoEndBlock);\n', '        require(token.burnTokensForSale());\n', '      }\n', '        \n', '  /**\n', '   * @dev finalize the crowdsale.After finalizing ,tokens transfer can be done.\n', '   */\n', '  function finalizeSale() public onlyOwner {\n', '    require(block.number > mainIcoEndBlock);\n', '    token.finalize();\n', '  }\n', '  \n', '  \n', '  /**\n', '   * @dev Determines how ETH is stored/forwarded on purchases.\n', '   */\n', '  function _forwardFunds() internal {\n', '    wallet.transfer(msg.value);\n', '  }\n', '}']
