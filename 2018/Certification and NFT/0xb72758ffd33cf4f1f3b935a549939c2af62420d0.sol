['pragma solidity ^0.4.13;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract CanReclaimToken is Ownable {\n', '  using SafeERC20 for ERC20Basic;\n', '\n', '  /**\n', '   * @dev Reclaim all ERC20Basic compatible tokens\n', '   * @param token ERC20Basic The address of the token contract\n', '   */\n', '  function reclaimToken(ERC20Basic token) external onlyOwner {\n', '    uint256 balance = token.balanceOf(this);\n', '    token.safeTransfer(owner, balance);\n', '  }\n', '\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', 'contract Whitelist is Ownable {\n', '  mapping(address => bool) public whitelist;\n', '\n', '  event WhitelistedAddressAdded(address addr);\n', '  event WhitelistedAddressRemoved(address addr);\n', '\n', '  /**\n', '   * @dev Throws if called by any account that&#39;s not whitelisted.\n', '   */\n', '  modifier onlyWhitelisted() {\n', '    require(whitelist[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param addr address\n', '   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '   */\n', '  function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n', '    if (!whitelist[addr]) {\n', '      whitelist[addr] = true;\n', '      emit WhitelistedAddressAdded(addr);\n', '      success = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev add addresses to the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was added to the whitelist,\n', '   * false if all addresses were already in the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      if (addAddressToWhitelist(addrs[i])) {\n', '        success = true;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param addr address\n', '   * @return true if the address was removed from the whitelist,\n', '   * false if the address wasn&#39;t in the whitelist in the first place\n', '   */\n', '  function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n', '    if (whitelist[addr]) {\n', '      whitelist[addr] = false;\n', '      emit WhitelistedAddressRemoved(addr);\n', '      success = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove addresses from the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was removed from the whitelist,\n', '   * false if all addresses weren&#39;t in the whitelist in the first place\n', '   */\n', '  function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      if (removeAddressFromWhitelist(addrs[i])) {\n', '        success = true;\n', '      }\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    assert(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 token,\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    internal\n', '  {\n', '    assert(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    assert(token.approve(spender, value));\n', '  }\n', '}\n', '\n', 'contract Distribution is CanReclaimToken, Claimable, Whitelist {\n', '\n', '    using SafeERC20 for ERC20Basic;\n', '\n', '    event Distributed(address beneficiary, uint256 amount);\n', '\n', '    address[] public receivers;\n', '    // Also used to indicate the distribution state.\n', '    uint256 public amount = 0;\n', '    ERC20Basic public token;\n', '\n', '    constructor(ERC20Basic _token) public {\n', '        token = _token;\n', '    }\n', '\n', '    function setReceivers(address[] _receivers, uint256 _amount) onlyWhitelisted external {\n', '        // Be conservative about the size.\n', '        require(_receivers.length <= 80);\n', '        require(_amount > 0);\n', '\n', '        receivers = _receivers;\n', '        amount = _amount;\n', '    }\n', '\n', '    function distribute() onlyWhitelisted external {\n', '        require(receivers.length > 0);\n', '        require(amount > 0);\n', '        for (uint256 i = 0; i < receivers.length; ++i) {\n', '            address beneficiary = receivers[i];\n', '            token.safeTransfer(beneficiary, amount);\n', '            emit Distributed(beneficiary, amount);\n', '        }\n', '        // Clear.\n', '        amount = 0;\n', '        delete receivers;\n', '    }\n', '\n', '    function batchDistribute(\n', '        address[] batchReceivers,\n', '        uint256 batchAmount\n', '    ) onlyWhitelisted external\n', '    {\n', '        require(batchReceivers.length > 0);\n', '        require(batchAmount > 0);\n', '        for (uint256 i = 0; i < batchReceivers.length; ++i) {\n', '            address beneficiary = batchReceivers[i];\n', '            token.safeTransfer(beneficiary, batchAmount);\n', '            emit Distributed(beneficiary, batchAmount);\n', '        }\n', '    }\n', '    \n', '    function batchDistributeWithAmount(\n', '        address[] batchReceivers,\n', '        uint256[] batchAmounts\n', '    ) onlyWhitelisted external\n', '    {\n', '        require(batchReceivers.length > 0);\n', '        require(batchAmounts.length == batchReceivers.length);\n', '        for (uint256 i = 0; i < batchReceivers.length; ++i) {\n', '            address beneficiary = batchReceivers[i];\n', '            uint256 v = batchAmounts[i];\n', '            token.safeTransfer(beneficiary, v);\n', '            emit Distributed(beneficiary, v);\n', '        }\n', '    }\n', '    \n', '\n', '    function finished() public view returns (bool) {\n', '        return amount == 0;\n', '    }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract CanReclaimToken is Ownable {\n', '  using SafeERC20 for ERC20Basic;\n', '\n', '  /**\n', '   * @dev Reclaim all ERC20Basic compatible tokens\n', '   * @param token ERC20Basic The address of the token contract\n', '   */\n', '  function reclaimToken(ERC20Basic token) external onlyOwner {\n', '    uint256 balance = token.balanceOf(this);\n', '    token.safeTransfer(owner, balance);\n', '  }\n', '\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', 'contract Whitelist is Ownable {\n', '  mapping(address => bool) public whitelist;\n', '\n', '  event WhitelistedAddressAdded(address addr);\n', '  event WhitelistedAddressRemoved(address addr);\n', '\n', '  /**\n', "   * @dev Throws if called by any account that's not whitelisted.\n", '   */\n', '  modifier onlyWhitelisted() {\n', '    require(whitelist[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param addr address\n', '   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '   */\n', '  function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n', '    if (!whitelist[addr]) {\n', '      whitelist[addr] = true;\n', '      emit WhitelistedAddressAdded(addr);\n', '      success = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev add addresses to the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was added to the whitelist,\n', '   * false if all addresses were already in the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      if (addAddressToWhitelist(addrs[i])) {\n', '        success = true;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param addr address\n', '   * @return true if the address was removed from the whitelist,\n', "   * false if the address wasn't in the whitelist in the first place\n", '   */\n', '  function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n', '    if (whitelist[addr]) {\n', '      whitelist[addr] = false;\n', '      emit WhitelistedAddressRemoved(addr);\n', '      success = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove addresses from the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was removed from the whitelist,\n', "   * false if all addresses weren't in the whitelist in the first place\n", '   */\n', '  function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      if (removeAddressFromWhitelist(addrs[i])) {\n', '        success = true;\n', '      }\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    assert(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 token,\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    internal\n', '  {\n', '    assert(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    assert(token.approve(spender, value));\n', '  }\n', '}\n', '\n', 'contract Distribution is CanReclaimToken, Claimable, Whitelist {\n', '\n', '    using SafeERC20 for ERC20Basic;\n', '\n', '    event Distributed(address beneficiary, uint256 amount);\n', '\n', '    address[] public receivers;\n', '    // Also used to indicate the distribution state.\n', '    uint256 public amount = 0;\n', '    ERC20Basic public token;\n', '\n', '    constructor(ERC20Basic _token) public {\n', '        token = _token;\n', '    }\n', '\n', '    function setReceivers(address[] _receivers, uint256 _amount) onlyWhitelisted external {\n', '        // Be conservative about the size.\n', '        require(_receivers.length <= 80);\n', '        require(_amount > 0);\n', '\n', '        receivers = _receivers;\n', '        amount = _amount;\n', '    }\n', '\n', '    function distribute() onlyWhitelisted external {\n', '        require(receivers.length > 0);\n', '        require(amount > 0);\n', '        for (uint256 i = 0; i < receivers.length; ++i) {\n', '            address beneficiary = receivers[i];\n', '            token.safeTransfer(beneficiary, amount);\n', '            emit Distributed(beneficiary, amount);\n', '        }\n', '        // Clear.\n', '        amount = 0;\n', '        delete receivers;\n', '    }\n', '\n', '    function batchDistribute(\n', '        address[] batchReceivers,\n', '        uint256 batchAmount\n', '    ) onlyWhitelisted external\n', '    {\n', '        require(batchReceivers.length > 0);\n', '        require(batchAmount > 0);\n', '        for (uint256 i = 0; i < batchReceivers.length; ++i) {\n', '            address beneficiary = batchReceivers[i];\n', '            token.safeTransfer(beneficiary, batchAmount);\n', '            emit Distributed(beneficiary, batchAmount);\n', '        }\n', '    }\n', '    \n', '    function batchDistributeWithAmount(\n', '        address[] batchReceivers,\n', '        uint256[] batchAmounts\n', '    ) onlyWhitelisted external\n', '    {\n', '        require(batchReceivers.length > 0);\n', '        require(batchAmounts.length == batchReceivers.length);\n', '        for (uint256 i = 0; i < batchReceivers.length; ++i) {\n', '            address beneficiary = batchReceivers[i];\n', '            uint256 v = batchAmounts[i];\n', '            token.safeTransfer(beneficiary, v);\n', '            emit Distributed(beneficiary, v);\n', '        }\n', '    }\n', '    \n', '\n', '    function finished() public view returns (bool) {\n', '        return amount == 0;\n', '    }\n', '}']
