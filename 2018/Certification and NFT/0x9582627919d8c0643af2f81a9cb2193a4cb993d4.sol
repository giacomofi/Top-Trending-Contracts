['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() constant public returns (uint);\n', '\n', '  function balanceOf(address who) constant public returns (uint256);\n', '\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '}\n', '\n', '/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n', '///  later changed\n', 'contract Owned {\n', '\n', '    /// @dev `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Owned() public {owner = msg.sender;}\n', '\n', '    /// @notice `owner` can step down and assign some other address to this role\n', '    /// @param _newOwner The address of the new owner. 0x0 can be used to create\n', '    ///  an unowned neutral vault, however that cannot be undone\n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'contract Callable is Owned {\n', '\n', '    //sender => _allowed\n', '    mapping(address => bool) public callers;\n', '\n', '    //modifiers\n', '    modifier onlyCaller {\n', '        require(callers[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    //management of the repositories\n', '    function updateCaller(address _caller, bool allowed) public onlyOwner {\n', '        callers[_caller] = allowed;\n', '    }\n', '}\n', '\n', 'contract EternalStorage is Callable {\n', '\n', '    mapping(bytes32 => uint) uIntStorage;\n', '    mapping(bytes32 => string) stringStorage;\n', '    mapping(bytes32 => address) addressStorage;\n', '    mapping(bytes32 => bytes) bytesStorage;\n', '    mapping(bytes32 => bool) boolStorage;\n', '    mapping(bytes32 => int) intStorage;\n', '\n', '    // *** Getter Methods ***\n', '    function getUint(bytes32 _key) external view returns (uint) {\n', '        return uIntStorage[_key];\n', '    }\n', '\n', '    function getString(bytes32 _key) external view returns (string) {\n', '        return stringStorage[_key];\n', '    }\n', '\n', '    function getAddress(bytes32 _key) external view returns (address) {\n', '        return addressStorage[_key];\n', '    }\n', '\n', '    function getBytes(bytes32 _key) external view returns (bytes) {\n', '        return bytesStorage[_key];\n', '    }\n', '\n', '    function getBool(bytes32 _key) external view returns (bool) {\n', '        return boolStorage[_key];\n', '    }\n', '\n', '    function getInt(bytes32 _key) external view returns (int) {\n', '        return intStorage[_key];\n', '    }\n', '\n', '    // *** Setter Methods ***\n', '    function setUint(bytes32 _key, uint _value) onlyCaller external {\n', '        uIntStorage[_key] = _value;\n', '    }\n', '\n', '    function setString(bytes32 _key, string _value) onlyCaller external {\n', '        stringStorage[_key] = _value;\n', '    }\n', '\n', '    function setAddress(bytes32 _key, address _value) onlyCaller external {\n', '        addressStorage[_key] = _value;\n', '    }\n', '\n', '    function setBytes(bytes32 _key, bytes _value) onlyCaller external {\n', '        bytesStorage[_key] = _value;\n', '    }\n', '\n', '    function setBool(bytes32 _key, bool _value) onlyCaller external {\n', '        boolStorage[_key] = _value;\n', '    }\n', '\n', '    function setInt(bytes32 _key, int _value) onlyCaller external {\n', '        intStorage[_key] = _value;\n', '    }\n', '\n', '    // *** Delete Methods ***\n', '    function deleteUint(bytes32 _key) onlyCaller external {\n', '        delete uIntStorage[_key];\n', '    }\n', '\n', '    function deleteString(bytes32 _key) onlyCaller external {\n', '        delete stringStorage[_key];\n', '    }\n', '\n', '    function deleteAddress(bytes32 _key) onlyCaller external {\n', '        delete addressStorage[_key];\n', '    }\n', '\n', '    function deleteBytes(bytes32 _key) onlyCaller external {\n', '        delete bytesStorage[_key];\n', '    }\n', '\n', '    function deleteBool(bytes32 _key) onlyCaller external {\n', '        delete boolStorage[_key];\n', '    }\n', '\n', '    function deleteInt(bytes32 _key) onlyCaller external {\n', '        delete intStorage[_key];\n', '    }\n', '}\n', '\n', '/*\n', ' * Database Contract\n', ' * Davy Van Roy\n', ' * Quinten De Swaef\n', ' */\n', 'contract FundRepository is Callable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    EternalStorage public db;\n', '\n', '    //platform -> platformId => _funding\n', '    mapping(bytes32 => mapping(string => Funding)) funds;\n', '\n', '    struct Funding {\n', '        address[] funders; //funders that funded tokens\n', '        address[] tokens; //tokens that were funded\n', '        mapping(address => TokenFunding) tokenFunding;\n', '    }\n', '\n', '    struct TokenFunding {\n', '        mapping(address => uint256) balance;\n', '        uint256 totalTokenBalance;\n', '    }\n', '\n', '    constructor(address _eternalStorage) public {\n', '        db = EternalStorage(_eternalStorage);\n', '    }\n', '\n', '    function updateFunders(address _from, bytes32 _platform, string _platformId) public onlyCaller {\n', '        bool existing = db.getBool(keccak256(abi.encodePacked("funds.userHasFunded", _platform, _platformId, _from)));\n', '        if (!existing) {\n', '            uint funderCount = getFunderCount(_platform, _platformId);\n', '            db.setAddress(keccak256(abi.encodePacked("funds.funders.address", _platform, _platformId, funderCount)), _from);\n', '            db.setUint(keccak256(abi.encodePacked("funds.funderCount", _platform, _platformId)), funderCount.add(1));\n', '        }\n', '    }\n', '\n', '    function updateBalances(address _from, bytes32 _platform, string _platformId, address _token, uint256 _value) public onlyCaller {\n', '        if (db.getBool(keccak256(abi.encodePacked("funds.token.address", _platform, _platformId, _token))) == false) {\n', '            db.setBool(keccak256(abi.encodePacked("funds.token.address", _platform, _platformId, _token)), true);\n', '            //add to the list of tokens for this platformId\n', '            uint tokenCount = getFundedTokenCount(_platform, _platformId);\n', '            db.setAddress(keccak256(abi.encodePacked("funds.token.address", _platform, _platformId, tokenCount)), _token);\n', '            db.setUint(keccak256(abi.encodePacked("funds.tokenCount", _platform, _platformId)), tokenCount.add(1));\n', '        }\n', '\n', '        //add to the balance of this platformId for this token\n', '        db.setUint(keccak256(abi.encodePacked("funds.tokenBalance", _platform, _platformId, _token)), balance(_platform, _platformId, _token).add(_value));\n', '\n', '        //add to the balance the user has funded for the request\n', '        db.setUint(keccak256(abi.encodePacked("funds.amountFundedByUser", _platform, _platformId, _from, _token)), amountFunded(_platform, _platformId, _from, _token).add(_value));\n', '\n', '        //add the fact that the user has now funded this platformId\n', '        db.setBool(keccak256(abi.encodePacked("funds.userHasFunded", _platform, _platformId, _from)), true);\n', '    }\n', '\n', '    function claimToken(bytes32 platform, string platformId, address _token) public onlyCaller returns (uint256) {\n', '        require(!issueResolved(platform, platformId), "Can&#39;t claim token, issue is already resolved.");\n', '        uint256 totalTokenBalance = balance(platform, platformId, _token);\n', '        db.deleteUint(keccak256(abi.encodePacked("funds.tokenBalance", platform, platformId, _token)));\n', '        return totalTokenBalance;\n', '    }\n', '\n', '    function refundToken(bytes32 _platform, string _platformId, address _owner, address _token) public onlyCaller returns (uint256) {\n', '        require(!issueResolved(_platform, _platformId), "Can&#39;t refund token, issue is already resolved.");\n', '\n', '        //delete amount from user, so he can&#39;t refund again\n', '        uint256 userTokenBalance = amountFunded(_platform, _platformId, _owner, _token);\n', '        db.deleteUint(keccak256(abi.encodePacked("funds.amountFundedByUser", _platform, _platformId, _owner, _token)));\n', '\n', '\n', '        uint256 oldBalance = balance(_platform, _platformId, _token);\n', '        uint256 newBalance = oldBalance.sub(userTokenBalance);\n', '\n', '        require(newBalance <= oldBalance);\n', '\n', '        //subtract amount from tokenBalance\n', '        db.setUint(keccak256(abi.encodePacked("funds.tokenBalance", _platform, _platformId, _token)), newBalance);\n', '\n', '        return userTokenBalance;\n', '    }\n', '\n', '    function finishResolveFund(bytes32 platform, string platformId) public onlyCaller returns (bool) {\n', '        db.setBool(keccak256(abi.encodePacked("funds.issueResolved", platform, platformId)), true);\n', '        db.deleteUint(keccak256(abi.encodePacked("funds.funderCount", platform, platformId)));\n', '        return true;\n', '    }\n', '\n', '    //constants\n', '    function getFundInfo(bytes32 _platform, string _platformId, address _funder, address _token) public view returns (uint256, uint256, uint256) {\n', '        return (\n', '        getFunderCount(_platform, _platformId),\n', '        balance(_platform, _platformId, _token),\n', '        amountFunded(_platform, _platformId, _funder, _token)\n', '        );\n', '    }\n', '\n', '    function issueResolved(bytes32 _platform, string _platformId) public view returns (bool) {\n', '        return db.getBool(keccak256(abi.encodePacked("funds.issueResolved", _platform, _platformId)));\n', '    }\n', '\n', '    function getFundedTokenCount(bytes32 _platform, string _platformId) public view returns (uint256) {\n', '        return db.getUint(keccak256(abi.encodePacked("funds.tokenCount", _platform, _platformId)));\n', '    }\n', '\n', '    function getFundedTokensByIndex(bytes32 _platform, string _platformId, uint _index) public view returns (address) {\n', '        return db.getAddress(keccak256(abi.encodePacked("funds.token.address", _platform, _platformId, _index)));\n', '    }\n', '\n', '    function getFunderCount(bytes32 _platform, string _platformId) public view returns (uint) {\n', '        return db.getUint(keccak256(abi.encodePacked("funds.funderCount", _platform, _platformId)));\n', '    }\n', '\n', '    function getFunderByIndex(bytes32 _platform, string _platformId, uint index) external view returns (address) {\n', '        return db.getAddress(keccak256(abi.encodePacked("funds.funders.address", _platform, _platformId, index)));\n', '    }\n', '\n', '    function amountFunded(bytes32 _platform, string _platformId, address _funder, address _token) public view returns (uint256) {\n', '        return db.getUint(keccak256(abi.encodePacked("funds.amountFundedByUser", _platform, _platformId, _funder, _token)));\n', '    }\n', '\n', '    function balance(bytes32 _platform, string _platformId, address _token) view public returns (uint256) {\n', '        return db.getUint(keccak256(abi.encodePacked("funds.tokenBalance", _platform, _platformId, _token)));\n', '    }\n', '}\n', '\n', 'contract ClaimRepository is Callable {\n', '    using SafeMath for uint256;\n', '\n', '    EternalStorage public db;\n', '\n', '    constructor(address _eternalStorage) public {\n', '        //constructor\n', '        require(_eternalStorage != address(0), "Eternal storage cannot be 0x0");\n', '        db = EternalStorage(_eternalStorage);\n', '    }\n', '\n', '    function addClaim(address _solverAddress, bytes32 _platform, string _platformId, string _solver, address _token, uint256 _requestBalance) public onlyCaller returns (bool) {\n', '        if (db.getAddress(keccak256(abi.encodePacked("claims.solver_address", _platform, _platformId))) != address(0)) {\n', '            require(db.getAddress(keccak256(abi.encodePacked("claims.solver_address", _platform, _platformId))) == _solverAddress, "Adding a claim needs to happen with the same claimer as before");\n', '        } else {\n', '            db.setString(keccak256(abi.encodePacked("claims.solver", _platform, _platformId)), _solver);\n', '            db.setAddress(keccak256(abi.encodePacked("claims.solver_address", _platform, _platformId)), _solverAddress);\n', '        }\n', '\n', '        uint tokenCount = db.getUint(keccak256(abi.encodePacked("claims.tokenCount", _platform, _platformId)));\n', '        db.setUint(keccak256(abi.encodePacked("claims.tokenCount", _platform, _platformId)), tokenCount.add(1));\n', '        db.setUint(keccak256(abi.encodePacked("claims.token.amount", _platform, _platformId, _token)), _requestBalance);\n', '        db.setAddress(keccak256(abi.encodePacked("claims.token.address", _platform, _platformId, tokenCount)), _token);\n', '        return true;\n', '    }\n', '\n', '    function isClaimed(bytes32 _platform, string _platformId) view external returns (bool claimed) {\n', '        return db.getAddress(keccak256(abi.encodePacked("claims.solver_address", _platform, _platformId))) != address(0);\n', '    }\n', '\n', '    function getSolverAddress(bytes32 _platform, string _platformId) view external returns (address solverAddress) {\n', '        return db.getAddress(keccak256(abi.encodePacked("claims.solver_address", _platform, _platformId)));\n', '    }\n', '\n', '    function getSolver(bytes32 _platform, string _platformId) view external returns (string){\n', '        return db.getString(keccak256(abi.encodePacked("claims.solver", _platform, _platformId)));\n', '    }\n', '\n', '    function getTokenCount(bytes32 _platform, string _platformId) view external returns (uint count) {\n', '        return db.getUint(keccak256(abi.encodePacked("claims.tokenCount", _platform, _platformId)));\n', '    }\n', '\n', '    function getTokenByIndex(bytes32 _platform, string _platformId, uint _index) view external returns (address token) {\n', '        return db.getAddress(keccak256(abi.encodePacked("claims.token.address", _platform, _platformId, _index)));\n', '    }\n', '\n', '    function getAmountByToken(bytes32 _platform, string _platformId, address _token) view external returns (uint token) {\n', '        return db.getUint(keccak256(abi.encodePacked("claims.token.amount", _platform, _platformId, _token)));\n', '    }\n', '}\n', '\n', 'contract ApproveAndCallFallBack {\n', '  function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n', '}\n', '\n', '/*\n', ' * @title String & slice utility library for Solidity contracts.\n', ' * @author Nick Johnson <arachnid@notdot.net>\n', ' *\n', ' * @dev Functionality in this library is largely implemented using an\n', ' *      abstraction called a &#39;slice&#39;. A slice represents a part of a string -\n', ' *      anything from the entire string to a single character, or even no\n', ' *      characters at all (a 0-length slice). Since a slice only has to specify\n', ' *      an offset and a length, copying and manipulating slices is a lot less\n', ' *      expensive than copying and manipulating the strings they reference.\n', ' *\n', ' *      To further reduce gas costs, most functions on slice that need to return\n', ' *      a slice modify the original one instead of allocating a new one; for\n', ' *      instance, `s.split(".")` will return the text up to the first &#39;.&#39;,\n', ' *      modifying s to only contain the remainder of the string after the &#39;.&#39;.\n', ' *      In situations where you do not want to modify the original slice, you\n', ' *      can make a copy first with `.copy()`, for example:\n', ' *      `s.copy().split(".")`. Try and avoid using this idiom in loops; since\n', ' *      Solidity has no memory management, it will result in allocating many\n', ' *      short-lived slices that are later discarded.\n', ' *\n', ' *      Functions that return two slices come in two versions: a non-allocating\n', ' *      version that takes the second slice as an argument, modifying it in\n', ' *      place, and an allocating version that allocates and returns the second\n', ' *      slice; see `nextRune` for example.\n', ' *\n', ' *      Functions that have to copy string data will return strings rather than\n', ' *      slices; these can be cast back to slices for further processing if\n', ' *      required.\n', ' *\n', ' *      For convenience, some functions are provided with non-modifying\n', ' *      variants that create a new slice and return both; for instance,\n', ' *      `s.splitNew(&#39;.&#39;)` leaves s unmodified, and returns two values\n', ' *      corresponding to the left and right parts of the string.\n', ' */\n', '\n', '\n', '\n', 'library strings {\n', '    struct slice {\n', '        uint _len;\n', '        uint _ptr;\n', '    }\n', '\n', '    function memcpy(uint dest, uint src, uint len) private pure {\n', '        // Copy word-length chunks while possible\n', '        for (; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire string.\n', '     * @param self The string to make a slice from.\n', '     * @return A newly allocated slice containing the entire string.\n', '     */\n', '    function toSlice(string self) internal pure returns (slice) {\n', '        uint ptr;\n', '        assembly {\n', '            ptr := add(self, 0x20)\n', '        }\n', '        return slice(bytes(self).length, ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the length of a null-terminated bytes32 string.\n', '     * @param self The value to find the length of.\n', '     * @return The length of the string, from 0 to 32.\n', '     */\n', '    function len(bytes32 self) internal pure returns (uint) {\n', '        uint ret;\n', '        if (self == 0)\n', '            return 0;\n', '        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n', '            ret += 16;\n', '            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n', '        }\n', '        if (self & 0xffffffffffffffff == 0) {\n', '            ret += 8;\n', '            self = bytes32(uint(self) / 0x10000000000000000);\n', '        }\n', '        if (self & 0xffffffff == 0) {\n', '            ret += 4;\n', '            self = bytes32(uint(self) / 0x100000000);\n', '        }\n', '        if (self & 0xffff == 0) {\n', '            ret += 2;\n', '            self = bytes32(uint(self) / 0x10000);\n', '        }\n', '        if (self & 0xff == 0) {\n', '            ret += 1;\n', '        }\n', '        return 32 - ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire bytes32, interpreted as a\n', '     *      null-termintaed utf-8 string.\n', '     * @param self The bytes32 value to convert to a slice.\n', '     * @return A new slice containing the value of the input argument up to the\n', '     *         first null.\n', '     */\n', '    function toSliceB32(bytes32 self) internal pure returns (slice ret) {\n', '        // Allocate space for `self` in memory, copy it there, and point ret at it\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(0x40, add(ptr, 0x20))\n', '            mstore(ptr, self)\n', '            mstore(add(ret, 0x20), ptr)\n', '        }\n', '        ret._len = len(self);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a new slice containing the same data as the current slice.\n', '     * @param self The slice to copy.\n', '     * @return A new slice containing the same data as `self`.\n', '     */\n', '    function copy(slice self) internal pure returns (slice) {\n', '        return slice(self._len, self._ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Copies a slice to a new string.\n', '     * @param self The slice to copy.\n', '     * @return A newly allocated string containing the slice&#39;s text.\n', '     */\n', '    function toString(slice self) internal pure returns (string) {\n', '        string memory ret = new string(self._len);\n', '        uint retptr;\n', '        assembly {retptr := add(ret, 32)}\n', '\n', '        memcpy(retptr, self._ptr, self._len);\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the length in runes of the slice. Note that this operation\n', '     *      takes time proportional to the length of the slice; avoid using it\n', '     *      in loops, and call `slice.empty()` if you only need to know whether\n', '     *      the slice is empty or not.\n', '     * @param self The slice to operate on.\n', '     * @return The length of the slice in runes.\n', '     */\n', '    function len(slice self) internal pure returns (uint l) {\n', '        // Starting at ptr-31 means the LSB will be the byte we care about\n', '        uint ptr = self._ptr - 31;\n', '        uint end = ptr + self._len;\n', '        for (l = 0; ptr < end; l++) {\n', '            uint8 b;\n', '            assembly {b := and(mload(ptr), 0xFF)}\n', '            if (b < 0x80) {\n', '                ptr += 1;\n', '            } else if (b < 0xE0) {\n', '                ptr += 2;\n', '            } else if (b < 0xF0) {\n', '                ptr += 3;\n', '            } else if (b < 0xF8) {\n', '                ptr += 4;\n', '            } else if (b < 0xFC) {\n', '                ptr += 5;\n', '            } else {\n', '                ptr += 6;\n', '            }\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the slice is empty (has a length of 0).\n', '     * @param self The slice to operate on.\n', '     * @return True if the slice is empty, False otherwise.\n', '     */\n', '    function empty(slice self) internal pure returns (bool) {\n', '        return self._len == 0;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a positive number if `other` comes lexicographically after\n', '     *      `self`, a negative number if it comes before, or zero if the\n', '     *      contents of the two slices are equal. Comparison is done per-rune,\n', '     *      on unicode codepoints.\n', '     * @param self The first slice to compare.\n', '     * @param other The second slice to compare.\n', '     * @return The result of the comparison.\n', '     */\n', '    function compare(slice self, slice other) internal pure returns (int) {\n', '        uint shortest = self._len;\n', '        if (other._len < self._len)\n', '            shortest = other._len;\n', '\n', '        uint selfptr = self._ptr;\n', '        uint otherptr = other._ptr;\n', '        for (uint idx = 0; idx < shortest; idx += 32) {\n', '            uint a;\n', '            uint b;\n', '            assembly {\n', '                a := mload(selfptr)\n', '                b := mload(otherptr)\n', '            }\n', '            if (a != b) {\n', '                // Mask out irrelevant bytes and check again\n', '                uint256 mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n', '                uint256 diff = (a & mask) - (b & mask);\n', '                if (diff != 0)\n', '                    return int(diff);\n', '            }\n', '            selfptr += 32;\n', '            otherptr += 32;\n', '        }\n', '        return int(self._len) - int(other._len);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the two slices contain the same text.\n', '     * @param self The first slice to compare.\n', '     * @param self The second slice to compare.\n', '     * @return True if the slices are equal, false otherwise.\n', '     */\n', '    function equals(slice self, slice other) internal pure returns (bool) {\n', '        return compare(self, other) == 0;\n', '    }\n', '\n', '    /*\n', '     * @dev Extracts the first rune in the slice into `rune`, advancing the\n', '     *      slice to point to the next rune and returning `self`.\n', '     * @param self The slice to operate on.\n', '     * @param rune The slice that will contain the first rune.\n', '     * @return `rune`.\n', '     */\n', '    function nextRune(slice self, slice rune) internal pure returns (slice) {\n', '        rune._ptr = self._ptr;\n', '\n', '        if (self._len == 0) {\n', '            rune._len = 0;\n', '            return rune;\n', '        }\n', '\n', '        uint l;\n', '        uint b;\n', '        // Load the first byte of the rune into the LSBs of b\n', '        assembly {b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF)}\n', '        if (b < 0x80) {\n', '            l = 1;\n', '        } else if (b < 0xE0) {\n', '            l = 2;\n', '        } else if (b < 0xF0) {\n', '            l = 3;\n', '        } else {\n', '            l = 4;\n', '        }\n', '\n', '        // Check for truncated codepoints\n', '        if (l > self._len) {\n', '            rune._len = self._len;\n', '            self._ptr += self._len;\n', '            self._len = 0;\n', '            return rune;\n', '        }\n', '\n', '        self._ptr += l;\n', '        self._len -= l;\n', '        rune._len = l;\n', '        return rune;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the first rune in the slice, advancing the slice to point\n', '     *      to the next rune.\n', '     * @param self The slice to operate on.\n', '     * @return A slice containing only the first rune from `self`.\n', '     */\n', '    function nextRune(slice self) internal pure returns (slice ret) {\n', '        nextRune(self, ret);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the number of the first codepoint in the slice.\n', '     * @param self The slice to operate on.\n', '     * @return The number of the first codepoint in the slice.\n', '     */\n', '    function ord(slice self) internal pure returns (uint ret) {\n', '        if (self._len == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint word;\n', '        uint length;\n', '        uint divisor = 2 ** 248;\n', '\n', '        // Load the rune into the MSBs of b\n', '        assembly {word := mload(mload(add(self, 32)))}\n', '        uint b = word / divisor;\n', '        if (b < 0x80) {\n', '            ret = b;\n', '            length = 1;\n', '        } else if (b < 0xE0) {\n', '            ret = b & 0x1F;\n', '            length = 2;\n', '        } else if (b < 0xF0) {\n', '            ret = b & 0x0F;\n', '            length = 3;\n', '        } else {\n', '            ret = b & 0x07;\n', '            length = 4;\n', '        }\n', '\n', '        // Check for truncated codepoints\n', '        if (length > self._len) {\n', '            return 0;\n', '        }\n', '\n', '        for (uint i = 1; i < length; i++) {\n', '            divisor = divisor / 256;\n', '            b = (word / divisor) & 0xFF;\n', '            if (b & 0xC0 != 0x80) {\n', '                // Invalid UTF-8 sequence\n', '                return 0;\n', '            }\n', '            ret = (ret * 64) | (b & 0x3F);\n', '        }\n', '\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the keccak-256 hash of the slice.\n', '     * @param self The slice to hash.\n', '     * @return The hash of the slice.\n', '     */\n', '    function keccak(slice self) internal pure returns (bytes32 ret) {\n', '        assembly {\n', '            ret := keccak256(mload(add(self, 32)), mload(self))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if `self` starts with `needle`.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return True if the slice starts with the provided text, false otherwise.\n', '     */\n', '    function startsWith(slice self, slice needle) internal pure returns (bool) {\n', '        if (self._len < needle._len) {\n', '            return false;\n', '        }\n', '\n', '        if (self._ptr == needle._ptr) {\n', '            return true;\n', '        }\n', '\n', '        bool equal;\n', '        assembly {\n', '            let length := mload(needle)\n', '            let selfptr := mload(add(self, 0x20))\n', '            let needleptr := mload(add(needle, 0x20))\n', '            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '        }\n', '        return equal;\n', '    }\n', '\n', '    /*\n', '     * @dev If `self` starts with `needle`, `needle` is removed from the\n', '     *      beginning of `self`. Otherwise, `self` is unmodified.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return `self`\n', '     */\n', '    function beyond(slice self, slice needle) internal pure returns (slice) {\n', '        if (self._len < needle._len) {\n', '            return self;\n', '        }\n', '\n', '        bool equal = true;\n', '        if (self._ptr != needle._ptr) {\n', '            assembly {\n', '                let length := mload(needle)\n', '                let selfptr := mload(add(self, 0x20))\n', '                let needleptr := mload(add(needle, 0x20))\n', '                equal := eq(sha3(selfptr, length), sha3(needleptr, length))\n', '            }\n', '        }\n', '\n', '        if (equal) {\n', '            self._len -= needle._len;\n', '            self._ptr += needle._len;\n', '        }\n', '\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the slice ends with `needle`.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return True if the slice starts with the provided text, false otherwise.\n', '     */\n', '    function endsWith(slice self, slice needle) internal pure returns (bool) {\n', '        if (self._len < needle._len) {\n', '            return false;\n', '        }\n', '\n', '        uint selfptr = self._ptr + self._len - needle._len;\n', '\n', '        if (selfptr == needle._ptr) {\n', '            return true;\n', '        }\n', '\n', '        bool equal;\n', '        assembly {\n', '            let length := mload(needle)\n', '            let needleptr := mload(add(needle, 0x20))\n', '            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '        }\n', '\n', '        return equal;\n', '    }\n', '\n', '    /*\n', '     * @dev If `self` ends with `needle`, `needle` is removed from the\n', '     *      end of `self`. Otherwise, `self` is unmodified.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return `self`\n', '     */\n', '    function until(slice self, slice needle) internal pure returns (slice) {\n', '        if (self._len < needle._len) {\n', '            return self;\n', '        }\n', '\n', '        uint selfptr = self._ptr + self._len - needle._len;\n', '        bool equal = true;\n', '        if (selfptr != needle._ptr) {\n', '            assembly {\n', '                let length := mload(needle)\n', '                let needleptr := mload(add(needle, 0x20))\n', '                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '            }\n', '        }\n', '\n', '        if (equal) {\n', '            self._len -= needle._len;\n', '        }\n', '\n', '        return self;\n', '    }\n', '\n', '    event log_bytemask(bytes32 mask);\n', '\n', '    // Returns the memory address of the first byte of the first occurrence of\n', '    // `needle` in `self`, or the first byte after `self` if not found.\n', '    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n', '        uint ptr = selfptr;\n', '        uint idx;\n', '\n', '        if (needlelen <= selflen) {\n', '            if (needlelen <= 32) {\n', '                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n', '\n', '                bytes32 needledata;\n', '                assembly {needledata := and(mload(needleptr), mask)}\n', '\n', '                uint end = selfptr + selflen - needlelen;\n', '                bytes32 ptrdata;\n', '                assembly {ptrdata := and(mload(ptr), mask)}\n', '\n', '                while (ptrdata != needledata) {\n', '                    if (ptr >= end)\n', '                        return selfptr + selflen;\n', '                    ptr++;\n', '                    assembly {ptrdata := and(mload(ptr), mask)}\n', '                }\n', '                return ptr;\n', '            } else {\n', '                // For long needles, use hashing\n', '                bytes32 hash;\n', '                assembly {hash := sha3(needleptr, needlelen)}\n', '\n', '                for (idx = 0; idx <= selflen - needlelen; idx++) {\n', '                    bytes32 testHash;\n', '                    assembly {testHash := sha3(ptr, needlelen)}\n', '                    if (hash == testHash)\n', '                        return ptr;\n', '                    ptr += 1;\n', '                }\n', '            }\n', '        }\n', '        return selfptr + selflen;\n', '    }\n', '\n', '    // Returns the memory address of the first byte after the last occurrence of\n', '    // `needle` in `self`, or the address of `self` if not found.\n', '    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n', '        uint ptr;\n', '\n', '        if (needlelen <= selflen) {\n', '            if (needlelen <= 32) {\n', '                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n', '\n', '                bytes32 needledata;\n', '                assembly {needledata := and(mload(needleptr), mask)}\n', '\n', '                ptr = selfptr + selflen - needlelen;\n', '                bytes32 ptrdata;\n', '                assembly {ptrdata := and(mload(ptr), mask)}\n', '\n', '                while (ptrdata != needledata) {\n', '                    if (ptr <= selfptr)\n', '                        return selfptr;\n', '                    ptr--;\n', '                    assembly {ptrdata := and(mload(ptr), mask)}\n', '                }\n', '                return ptr + needlelen;\n', '            } else {\n', '                // For long needles, use hashing\n', '                bytes32 hash;\n', '                assembly {hash := sha3(needleptr, needlelen)}\n', '                ptr = selfptr + (selflen - needlelen);\n', '                while (ptr >= selfptr) {\n', '                    bytes32 testHash;\n', '                    assembly {testHash := sha3(ptr, needlelen)}\n', '                    if (hash == testHash)\n', '                        return ptr + needlelen;\n', '                    ptr -= 1;\n', '                }\n', '            }\n', '        }\n', '        return selfptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Modifies `self` to contain everything from the first occurrence of\n', '     *      `needle` to the end of the slice. `self` is set to the empty slice\n', '     *      if `needle` is not found.\n', '     * @param self The slice to search and modify.\n', '     * @param needle The text to search for.\n', '     * @return `self`.\n', '     */\n', '    function find(slice self, slice needle) internal pure returns (slice) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        self._len -= ptr - self._ptr;\n', '        self._ptr = ptr;\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Modifies `self` to contain the part of the string from the start of\n', '     *      `self` to the end of the first occurrence of `needle`. If `needle`\n', '     *      is not found, `self` is set to the empty slice.\n', '     * @param self The slice to search and modify.\n', '     * @param needle The text to search for.\n', '     * @return `self`.\n', '     */\n', '    function rfind(slice self, slice needle) internal pure returns (slice) {\n', '        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        self._len = ptr - self._ptr;\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything after the first\n', '     *      occurrence of `needle`, and `token` to everything before it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and `token` is set to the entirety of `self`.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @param token An output parameter to which the first token is written.\n', '     * @return `token`.\n', '     */\n', '    function split(slice self, slice needle, slice token) internal pure returns (slice) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        token._ptr = self._ptr;\n', '        token._len = ptr - self._ptr;\n', '        if (ptr == self._ptr + self._len) {\n', '            // Not found\n', '            self._len = 0;\n', '        } else {\n', '            self._len -= token._len + needle._len;\n', '            self._ptr = ptr + needle._len;\n', '        }\n', '        return token;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything after the first\n', '     *      occurrence of `needle`, and returning everything before it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and the entirety of `self` is returned.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The part of `self` up to the first occurrence of `delim`.\n', '     */\n', '    function split(slice self, slice needle) internal pure returns (slice token) {\n', '        split(self, needle, token);\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything before the last\n', '     *      occurrence of `needle`, and `token` to everything after it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and `token` is set to the entirety of `self`.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @param token An output parameter to which the first token is written.\n', '     * @return `token`.\n', '     */\n', '    function rsplit(slice self, slice needle, slice token) internal pure returns (slice) {\n', '        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        token._ptr = ptr;\n', '        token._len = self._len - (ptr - self._ptr);\n', '        if (ptr == self._ptr) {\n', '            // Not found\n', '            self._len = 0;\n', '        } else {\n', '            self._len -= token._len + needle._len;\n', '        }\n', '        return token;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything before the last\n', '     *      occurrence of `needle`, and returning everything after it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and the entirety of `self` is returned.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The part of `self` after the last occurrence of `delim`.\n', '     */\n', '    function rsplit(slice self, slice needle) internal pure returns (slice token) {\n', '        rsplit(self, needle, token);\n', '    }\n', '\n', '    /*\n', '     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n', '     * @param self The slice to search.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The number of occurrences of `needle` found in `self`.\n', '     */\n', '    function count(slice self, slice needle) internal pure returns (uint cnt) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n', '        while (ptr <= self._ptr + self._len) {\n', '            cnt++;\n', '            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns True if `self` contains `needle`.\n', '     * @param self The slice to search.\n', '     * @param needle The text to search for in `self`.\n', '     * @return True if `needle` is found in `self`, false otherwise.\n', '     */\n', '    function contains(slice self, slice needle) internal pure returns (bool) {\n', '        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a newly allocated string containing the concatenation of\n', '     *      `self` and `other`.\n', '     * @param self The first slice to concatenate.\n', '     * @param other The second slice to concatenate.\n', '     * @return The concatenation of the two strings.\n', '     */\n', '    function concat(slice self, slice other) internal pure returns (string) {\n', '        string memory ret = new string(self._len + other._len);\n', '        uint retptr;\n', '        assembly {retptr := add(ret, 32)}\n', '        memcpy(retptr, self._ptr, self._len);\n', '        memcpy(retptr + self._len, other._ptr, other._len);\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n', '     *      newly allocated string.\n', '     * @param self The delimiter to use.\n', '     * @param parts A list of slices to join.\n', '     * @return A newly allocated string containing all the slices in `parts`,\n', '     *         joined with `self`.\n', '     */\n', '    function join(slice self, slice[] parts) internal pure returns (string) {\n', '        if (parts.length == 0)\n', '            return "";\n', '\n', '        uint length = self._len * (parts.length - 1);\n', '        for (uint i = 0; i < parts.length; i++)\n', '            length += parts[i]._len;\n', '\n', '        string memory ret = new string(length);\n', '        uint retptr;\n', '        assembly {retptr := add(ret, 32)}\n', '\n', '        for (i = 0; i < parts.length; i++) {\n', '            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n', '            retptr += parts[i]._len;\n', '            if (i < parts.length - 1) {\n', '                memcpy(retptr, self._ptr, self._len);\n', '                retptr += self._len;\n', '            }\n', '        }\n', '\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '    * Additions by the FundRequest Team\n', '    */\n', '\n', '    function toBytes32(slice self) internal pure returns (bytes32 result) {\n', '        string memory source = toString(self);\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c, string _d, string _e) pure internal returns (string){\n', '        bytes memory _ba = bytes(_a);\n', '        bytes memory _bb = bytes(_b);\n', '        bytes memory _bc = bytes(_c);\n', '        bytes memory _bd = bytes(_d);\n', '        bytes memory _be = bytes(_e);\n', '        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '        bytes memory babcde = bytes(abcde);\n', '        uint k = 0;\n', '        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '        return string(babcde);\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c, string _d) pure internal returns (string) {\n', '        return strConcat(_a, _b, _c, _d, "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c) pure internal returns (string) {\n', '        return strConcat(_a, _b, _c, "", "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b) pure internal returns (string) {\n', '        return strConcat(_a, _b, "", "", "");\n', '    }\n', '\n', '    function addressToString(address x) internal pure returns (string) {\n', '        bytes memory s = new bytes(40);\n', '        for (uint i = 0; i < 20; i++) {\n', '            byte b = byte(uint8(uint(x) / (2 ** (8 * (19 - i)))));\n', '            byte hi = byte(uint8(b) / 16);\n', '            byte lo = byte(uint8(b) - 16 * uint8(hi));\n', '            s[2 * i] = charToByte(hi);\n', '            s[2 * i + 1] = charToByte(lo);\n', '        }\n', '        return strConcat("0x", string(s));\n', '    }\n', '\n', '    function charToByte(byte b) internal pure returns (byte c) {\n', '        if (b < 10) return byte(uint8(b) + 0x30);\n', '        else return byte(uint8(b) + 0x57);\n', '    }\n', '\n', '    function bytes32ToString(bytes32 x) internal pure returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '            byte ch = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '            if (ch != 0) {\n', '                bytesString[charCount] = ch;\n', '                charCount++;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '}\n', '\n', 'contract Precondition is Owned {\n', '\n', '    string public name;\n', '    uint public version;\n', '    bool public active = false;\n', '\n', '    constructor(string _name, uint _version, bool _active) public {\n', '        name = _name;\n', '        version = _version;\n', '        active = _active;\n', '    }\n', '\n', '    function setActive(bool _active) external onlyOwner {\n', '        active = _active;\n', '    }\n', '\n', '    function isValid(bytes32 _platform, string _platformId, address _token, uint256 _value, address _funder) external view returns (bool valid);\n', '}\n', '\n', '/*\n', ' * Main FundRequest Contract. The entrypoint for every claim/refund\n', ' * Davy Van Roy\n', ' * Quinten De Swaef\n', ' */\n', 'contract FundRequestContract is Callable, ApproveAndCallFallBack {\n', '\n', '    using SafeMath for uint256;\n', '    using strings for *;\n', '\n', '    event Funded(address indexed from, bytes32 platform, string platformId, address token, uint256 value);\n', '\n', '    event Claimed(address indexed solverAddress, bytes32 platform, string platformId, string solver, address token, uint256 value);\n', '\n', '    event Refund(address indexed owner, bytes32 platform, string platformId, address token, uint256 value);\n', '\n', '    address constant public ETHER_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n', '\n', '    //repositories\n', '    FundRepository public fundRepository;\n', '\n', '    ClaimRepository public claimRepository;\n', '\n', '    address public claimSignerAddress;\n', '\n', '    Precondition[] public preconditions;\n', '\n', '    constructor(address _fundRepository, address _claimRepository) public {\n', '        setFundRepository(_fundRepository);\n', '        setClaimRepository(_claimRepository);\n', '    }\n', '\n', '    //ENTRYPOINTS\n', '\n', '    /*\n', '     * Public function, can only be called from the outside.\n', '     * Fund an issue, providing a token and value.\n', '     * Requires an allowance > _value of the token.\n', '     */\n', '    function fund(bytes32 _platform, string _platformId, address _token, uint256 _value) external returns (bool success) {\n', '        require(doFunding(_platform, _platformId, _token, _value, msg.sender), "funding with token failed");\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Public function, can only be called from the outside.\n', '     * Fund an issue, ether as value of the transaction.\n', '     * Requires ether to be whitelisted in a precondition.\n', '     */\n', '    function etherFund(bytes32 _platform, string _platformId) payable external returns (bool success) {\n', '        require(doFunding(_platform, _platformId, ETHER_ADDRESS, msg.value, msg.sender), "funding with ether failed");\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Public function, supposed to be called from another contract, after receiving approval\n', '     * Funds an issue, expects platform, platformid to be concatted with |AAC| as delimiter and provided as _data\n', '     * Only used with the FundRequest approveAndCall function at the moment. Might be removed later in favor of 2 calls.\n', '     */\n', '    function receiveApproval(address _from, uint _amount, address _token, bytes _data) public {\n', '        var sliced = string(_data).toSlice();\n', '        var platform = sliced.split("|AAC|".toSlice());\n', '        var platformId = sliced.split("|AAC|".toSlice());\n', '        require(doFunding(platform.toBytes32(), platformId.toString(), _token, _amount, _from));\n', '    }\n', '\n', '    /*\n', '     * Claim: Public function, only supposed to be called from the outside\n', '     * Anyone can call this function, but a valid signature from FundRequest is required\n', '     */\n', '    function claim(bytes32 platform, string platformId, string solver, address solverAddress, bytes32 r, bytes32 s, uint8 v) public returns (bool) {\n', '        require(validClaim(platform, platformId, solver, solverAddress, r, s, v), "Claimsignature was not valid");\n', '        uint256 tokenCount = fundRepository.getFundedTokenCount(platform, platformId);\n', '        for (uint i = 0; i < tokenCount; i++) {\n', '            address token = fundRepository.getFundedTokensByIndex(platform, platformId, i);\n', '            uint256 tokenAmount = fundRepository.claimToken(platform, platformId, token);\n', '            if (token == ETHER_ADDRESS) {\n', '                solverAddress.transfer(tokenAmount);\n', '            } else {\n', '                require(ERC20(token).transfer(solverAddress, tokenAmount), "transfer of tokens from contract failed");\n', '            }\n', '            require(claimRepository.addClaim(solverAddress, platform, platformId, solver, token, tokenAmount), "adding claim to repository failed");\n', '            emit Claimed(solverAddress, platform, platformId, solver, token, tokenAmount);\n', '        }\n', '        require(fundRepository.finishResolveFund(platform, platformId), "Resolving the fund failed");\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Claim: Public function, only supposed to be called from the outside\n', '     * Only FundRequest can call this function for now, which will refund a user for a specific issue.\n', '     */\n', '    function refund(bytes32 _platform, string _platformId, address _funder) external onlyCaller returns (bool) {\n', '        uint256 tokenCount = fundRepository.getFundedTokenCount(_platform, _platformId);\n', '        for (uint i = 0; i < tokenCount; i++) {\n', '            address token = fundRepository.getFundedTokensByIndex(_platform, _platformId, i);\n', '            uint256 tokenAmount = fundRepository.refundToken(_platform, _platformId, _funder, token);\n', '            if (tokenAmount > 0) {\n', '                if (token == ETHER_ADDRESS) {\n', '                    _funder.transfer(tokenAmount);\n', '                } else {\n', '                    require(ERC20(token).transfer(_funder, tokenAmount), "transfer of tokens from contract failed");\n', '                }\n', '            }\n', '            emit Refund(_funder, _platform, _platformId, token, tokenAmount);\n', '        }\n', '    }\n', '\n', '    /*\n', '     * only called from within the this contract itself, will actually do the funding\n', '     */\n', '    function doFunding(bytes32 _platform, string _platformId, address _token, uint256 _value, address _funder) internal returns (bool success) {\n', '        if (_token == ETHER_ADDRESS) {\n', '            //must check this, so we don&#39;t have people foefeling with the amounts\n', '            require(msg.value == _value);\n', '        }\n', '        require(!fundRepository.issueResolved(_platform, _platformId), "Can&#39;t fund tokens, platformId already claimed");\n', '        for (uint idx = 0; idx < preconditions.length; idx++) {\n', '            if (address(preconditions[idx]) != address(0)) {\n', '                require(preconditions[idx].isValid(_platform, _platformId, _token, _value, _funder));\n', '            }\n', '        }\n', '        require(_value > 0, "amount of tokens needs to be more than 0");\n', '\n', '        if (_token != ETHER_ADDRESS) {\n', '            require(ERC20(_token).transferFrom(_funder, address(this), _value), "Transfer of tokens to contract failed");\n', '        }\n', '\n', '        fundRepository.updateFunders(_funder, _platform, _platformId);\n', '        fundRepository.updateBalances(_funder, _platform, _platformId, _token, _value);\n', '        emit Funded(_funder, _platform, _platformId, _token, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * checks if a claim is valid, by checking the signature\n', '     */\n', '    function validClaim(bytes32 platform, string platformId, string solver, address solverAddress, bytes32 r, bytes32 s, uint8 v) internal view returns (bool) {\n', '        bytes32 h = keccak256(abi.encodePacked(createClaimMsg(platform, platformId, solver, solverAddress)));\n', '        address signerAddress = ecrecover(h, v, r, s);\n', '        return claimSignerAddress == signerAddress;\n', '    }\n', '\n', '    function createClaimMsg(bytes32 platform, string platformId, string solver, address solverAddress) internal pure returns (string) {\n', '        return strings.bytes32ToString(platform)\n', '        .strConcat(prependUnderscore(platformId))\n', '        .strConcat(prependUnderscore(solver))\n', '        .strConcat(prependUnderscore(strings.addressToString(solverAddress)));\n', '    }\n', '\n', '    function addPrecondition(address _precondition) external onlyOwner {\n', '        preconditions.push(Precondition(_precondition));\n', '    }\n', '\n', '    function removePrecondition(uint _index) external onlyOwner {\n', '        if (_index >= preconditions.length) return;\n', '\n', '        for (uint i = _index; i < preconditions.length - 1; i++) {\n', '            preconditions[i] = preconditions[i + 1];\n', '        }\n', '\n', '        delete preconditions[preconditions.length - 1];\n', '        preconditions.length--;\n', '    }\n', '\n', '    function setFundRepository(address _repositoryAddress) public onlyOwner {\n', '        fundRepository = FundRepository(_repositoryAddress);\n', '    }\n', '\n', '    function setClaimRepository(address _claimRepository) public onlyOwner {\n', '        claimRepository = ClaimRepository(_claimRepository);\n', '    }\n', '\n', '    function setClaimSignerAddress(address _claimSignerAddress) addressNotNull(_claimSignerAddress) public onlyOwner {\n', '        claimSignerAddress = _claimSignerAddress;\n', '    }\n', '\n', '    function prependUnderscore(string str) internal pure returns (string) {\n', '        return "_".strConcat(str);\n', '    }\n', '\n', '    //required to be able to migrate to a new FundRequestContract\n', '    function migrateTokens(address _token, address newContract) external onlyOwner {\n', '        require(newContract != address(0));\n', '        if (_token == ETHER_ADDRESS) {\n', '            newContract.transfer(address(this).balance);\n', '        } else {\n', '            ERC20 token = ERC20(_token);\n', '            token.transfer(newContract, token.balanceOf(address(this)));\n', '        }\n', '    }\n', '\n', '    modifier addressNotNull(address target) {\n', '        require(target != address(0), "target address can not be 0x0");\n', '        _;\n', '    }\n', '\n', '    //required should there be an issue with available ether\n', '    function deposit() external onlyOwner payable {\n', '        require(msg.value > 0, "Should at least be 1 wei deposited");\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() constant public returns (uint);\n', '\n', '  function balanceOf(address who) constant public returns (uint256);\n', '\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '}\n', '\n', '/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n', '///  later changed\n', 'contract Owned {\n', '\n', '    /// @dev `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Owned() public {owner = msg.sender;}\n', '\n', '    /// @notice `owner` can step down and assign some other address to this role\n', '    /// @param _newOwner The address of the new owner. 0x0 can be used to create\n', '    ///  an unowned neutral vault, however that cannot be undone\n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'contract Callable is Owned {\n', '\n', '    //sender => _allowed\n', '    mapping(address => bool) public callers;\n', '\n', '    //modifiers\n', '    modifier onlyCaller {\n', '        require(callers[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    //management of the repositories\n', '    function updateCaller(address _caller, bool allowed) public onlyOwner {\n', '        callers[_caller] = allowed;\n', '    }\n', '}\n', '\n', 'contract EternalStorage is Callable {\n', '\n', '    mapping(bytes32 => uint) uIntStorage;\n', '    mapping(bytes32 => string) stringStorage;\n', '    mapping(bytes32 => address) addressStorage;\n', '    mapping(bytes32 => bytes) bytesStorage;\n', '    mapping(bytes32 => bool) boolStorage;\n', '    mapping(bytes32 => int) intStorage;\n', '\n', '    // *** Getter Methods ***\n', '    function getUint(bytes32 _key) external view returns (uint) {\n', '        return uIntStorage[_key];\n', '    }\n', '\n', '    function getString(bytes32 _key) external view returns (string) {\n', '        return stringStorage[_key];\n', '    }\n', '\n', '    function getAddress(bytes32 _key) external view returns (address) {\n', '        return addressStorage[_key];\n', '    }\n', '\n', '    function getBytes(bytes32 _key) external view returns (bytes) {\n', '        return bytesStorage[_key];\n', '    }\n', '\n', '    function getBool(bytes32 _key) external view returns (bool) {\n', '        return boolStorage[_key];\n', '    }\n', '\n', '    function getInt(bytes32 _key) external view returns (int) {\n', '        return intStorage[_key];\n', '    }\n', '\n', '    // *** Setter Methods ***\n', '    function setUint(bytes32 _key, uint _value) onlyCaller external {\n', '        uIntStorage[_key] = _value;\n', '    }\n', '\n', '    function setString(bytes32 _key, string _value) onlyCaller external {\n', '        stringStorage[_key] = _value;\n', '    }\n', '\n', '    function setAddress(bytes32 _key, address _value) onlyCaller external {\n', '        addressStorage[_key] = _value;\n', '    }\n', '\n', '    function setBytes(bytes32 _key, bytes _value) onlyCaller external {\n', '        bytesStorage[_key] = _value;\n', '    }\n', '\n', '    function setBool(bytes32 _key, bool _value) onlyCaller external {\n', '        boolStorage[_key] = _value;\n', '    }\n', '\n', '    function setInt(bytes32 _key, int _value) onlyCaller external {\n', '        intStorage[_key] = _value;\n', '    }\n', '\n', '    // *** Delete Methods ***\n', '    function deleteUint(bytes32 _key) onlyCaller external {\n', '        delete uIntStorage[_key];\n', '    }\n', '\n', '    function deleteString(bytes32 _key) onlyCaller external {\n', '        delete stringStorage[_key];\n', '    }\n', '\n', '    function deleteAddress(bytes32 _key) onlyCaller external {\n', '        delete addressStorage[_key];\n', '    }\n', '\n', '    function deleteBytes(bytes32 _key) onlyCaller external {\n', '        delete bytesStorage[_key];\n', '    }\n', '\n', '    function deleteBool(bytes32 _key) onlyCaller external {\n', '        delete boolStorage[_key];\n', '    }\n', '\n', '    function deleteInt(bytes32 _key) onlyCaller external {\n', '        delete intStorage[_key];\n', '    }\n', '}\n', '\n', '/*\n', ' * Database Contract\n', ' * Davy Van Roy\n', ' * Quinten De Swaef\n', ' */\n', 'contract FundRepository is Callable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    EternalStorage public db;\n', '\n', '    //platform -> platformId => _funding\n', '    mapping(bytes32 => mapping(string => Funding)) funds;\n', '\n', '    struct Funding {\n', '        address[] funders; //funders that funded tokens\n', '        address[] tokens; //tokens that were funded\n', '        mapping(address => TokenFunding) tokenFunding;\n', '    }\n', '\n', '    struct TokenFunding {\n', '        mapping(address => uint256) balance;\n', '        uint256 totalTokenBalance;\n', '    }\n', '\n', '    constructor(address _eternalStorage) public {\n', '        db = EternalStorage(_eternalStorage);\n', '    }\n', '\n', '    function updateFunders(address _from, bytes32 _platform, string _platformId) public onlyCaller {\n', '        bool existing = db.getBool(keccak256(abi.encodePacked("funds.userHasFunded", _platform, _platformId, _from)));\n', '        if (!existing) {\n', '            uint funderCount = getFunderCount(_platform, _platformId);\n', '            db.setAddress(keccak256(abi.encodePacked("funds.funders.address", _platform, _platformId, funderCount)), _from);\n', '            db.setUint(keccak256(abi.encodePacked("funds.funderCount", _platform, _platformId)), funderCount.add(1));\n', '        }\n', '    }\n', '\n', '    function updateBalances(address _from, bytes32 _platform, string _platformId, address _token, uint256 _value) public onlyCaller {\n', '        if (db.getBool(keccak256(abi.encodePacked("funds.token.address", _platform, _platformId, _token))) == false) {\n', '            db.setBool(keccak256(abi.encodePacked("funds.token.address", _platform, _platformId, _token)), true);\n', '            //add to the list of tokens for this platformId\n', '            uint tokenCount = getFundedTokenCount(_platform, _platformId);\n', '            db.setAddress(keccak256(abi.encodePacked("funds.token.address", _platform, _platformId, tokenCount)), _token);\n', '            db.setUint(keccak256(abi.encodePacked("funds.tokenCount", _platform, _platformId)), tokenCount.add(1));\n', '        }\n', '\n', '        //add to the balance of this platformId for this token\n', '        db.setUint(keccak256(abi.encodePacked("funds.tokenBalance", _platform, _platformId, _token)), balance(_platform, _platformId, _token).add(_value));\n', '\n', '        //add to the balance the user has funded for the request\n', '        db.setUint(keccak256(abi.encodePacked("funds.amountFundedByUser", _platform, _platformId, _from, _token)), amountFunded(_platform, _platformId, _from, _token).add(_value));\n', '\n', '        //add the fact that the user has now funded this platformId\n', '        db.setBool(keccak256(abi.encodePacked("funds.userHasFunded", _platform, _platformId, _from)), true);\n', '    }\n', '\n', '    function claimToken(bytes32 platform, string platformId, address _token) public onlyCaller returns (uint256) {\n', '        require(!issueResolved(platform, platformId), "Can\'t claim token, issue is already resolved.");\n', '        uint256 totalTokenBalance = balance(platform, platformId, _token);\n', '        db.deleteUint(keccak256(abi.encodePacked("funds.tokenBalance", platform, platformId, _token)));\n', '        return totalTokenBalance;\n', '    }\n', '\n', '    function refundToken(bytes32 _platform, string _platformId, address _owner, address _token) public onlyCaller returns (uint256) {\n', '        require(!issueResolved(_platform, _platformId), "Can\'t refund token, issue is already resolved.");\n', '\n', "        //delete amount from user, so he can't refund again\n", '        uint256 userTokenBalance = amountFunded(_platform, _platformId, _owner, _token);\n', '        db.deleteUint(keccak256(abi.encodePacked("funds.amountFundedByUser", _platform, _platformId, _owner, _token)));\n', '\n', '\n', '        uint256 oldBalance = balance(_platform, _platformId, _token);\n', '        uint256 newBalance = oldBalance.sub(userTokenBalance);\n', '\n', '        require(newBalance <= oldBalance);\n', '\n', '        //subtract amount from tokenBalance\n', '        db.setUint(keccak256(abi.encodePacked("funds.tokenBalance", _platform, _platformId, _token)), newBalance);\n', '\n', '        return userTokenBalance;\n', '    }\n', '\n', '    function finishResolveFund(bytes32 platform, string platformId) public onlyCaller returns (bool) {\n', '        db.setBool(keccak256(abi.encodePacked("funds.issueResolved", platform, platformId)), true);\n', '        db.deleteUint(keccak256(abi.encodePacked("funds.funderCount", platform, platformId)));\n', '        return true;\n', '    }\n', '\n', '    //constants\n', '    function getFundInfo(bytes32 _platform, string _platformId, address _funder, address _token) public view returns (uint256, uint256, uint256) {\n', '        return (\n', '        getFunderCount(_platform, _platformId),\n', '        balance(_platform, _platformId, _token),\n', '        amountFunded(_platform, _platformId, _funder, _token)\n', '        );\n', '    }\n', '\n', '    function issueResolved(bytes32 _platform, string _platformId) public view returns (bool) {\n', '        return db.getBool(keccak256(abi.encodePacked("funds.issueResolved", _platform, _platformId)));\n', '    }\n', '\n', '    function getFundedTokenCount(bytes32 _platform, string _platformId) public view returns (uint256) {\n', '        return db.getUint(keccak256(abi.encodePacked("funds.tokenCount", _platform, _platformId)));\n', '    }\n', '\n', '    function getFundedTokensByIndex(bytes32 _platform, string _platformId, uint _index) public view returns (address) {\n', '        return db.getAddress(keccak256(abi.encodePacked("funds.token.address", _platform, _platformId, _index)));\n', '    }\n', '\n', '    function getFunderCount(bytes32 _platform, string _platformId) public view returns (uint) {\n', '        return db.getUint(keccak256(abi.encodePacked("funds.funderCount", _platform, _platformId)));\n', '    }\n', '\n', '    function getFunderByIndex(bytes32 _platform, string _platformId, uint index) external view returns (address) {\n', '        return db.getAddress(keccak256(abi.encodePacked("funds.funders.address", _platform, _platformId, index)));\n', '    }\n', '\n', '    function amountFunded(bytes32 _platform, string _platformId, address _funder, address _token) public view returns (uint256) {\n', '        return db.getUint(keccak256(abi.encodePacked("funds.amountFundedByUser", _platform, _platformId, _funder, _token)));\n', '    }\n', '\n', '    function balance(bytes32 _platform, string _platformId, address _token) view public returns (uint256) {\n', '        return db.getUint(keccak256(abi.encodePacked("funds.tokenBalance", _platform, _platformId, _token)));\n', '    }\n', '}\n', '\n', 'contract ClaimRepository is Callable {\n', '    using SafeMath for uint256;\n', '\n', '    EternalStorage public db;\n', '\n', '    constructor(address _eternalStorage) public {\n', '        //constructor\n', '        require(_eternalStorage != address(0), "Eternal storage cannot be 0x0");\n', '        db = EternalStorage(_eternalStorage);\n', '    }\n', '\n', '    function addClaim(address _solverAddress, bytes32 _platform, string _platformId, string _solver, address _token, uint256 _requestBalance) public onlyCaller returns (bool) {\n', '        if (db.getAddress(keccak256(abi.encodePacked("claims.solver_address", _platform, _platformId))) != address(0)) {\n', '            require(db.getAddress(keccak256(abi.encodePacked("claims.solver_address", _platform, _platformId))) == _solverAddress, "Adding a claim needs to happen with the same claimer as before");\n', '        } else {\n', '            db.setString(keccak256(abi.encodePacked("claims.solver", _platform, _platformId)), _solver);\n', '            db.setAddress(keccak256(abi.encodePacked("claims.solver_address", _platform, _platformId)), _solverAddress);\n', '        }\n', '\n', '        uint tokenCount = db.getUint(keccak256(abi.encodePacked("claims.tokenCount", _platform, _platformId)));\n', '        db.setUint(keccak256(abi.encodePacked("claims.tokenCount", _platform, _platformId)), tokenCount.add(1));\n', '        db.setUint(keccak256(abi.encodePacked("claims.token.amount", _platform, _platformId, _token)), _requestBalance);\n', '        db.setAddress(keccak256(abi.encodePacked("claims.token.address", _platform, _platformId, tokenCount)), _token);\n', '        return true;\n', '    }\n', '\n', '    function isClaimed(bytes32 _platform, string _platformId) view external returns (bool claimed) {\n', '        return db.getAddress(keccak256(abi.encodePacked("claims.solver_address", _platform, _platformId))) != address(0);\n', '    }\n', '\n', '    function getSolverAddress(bytes32 _platform, string _platformId) view external returns (address solverAddress) {\n', '        return db.getAddress(keccak256(abi.encodePacked("claims.solver_address", _platform, _platformId)));\n', '    }\n', '\n', '    function getSolver(bytes32 _platform, string _platformId) view external returns (string){\n', '        return db.getString(keccak256(abi.encodePacked("claims.solver", _platform, _platformId)));\n', '    }\n', '\n', '    function getTokenCount(bytes32 _platform, string _platformId) view external returns (uint count) {\n', '        return db.getUint(keccak256(abi.encodePacked("claims.tokenCount", _platform, _platformId)));\n', '    }\n', '\n', '    function getTokenByIndex(bytes32 _platform, string _platformId, uint _index) view external returns (address token) {\n', '        return db.getAddress(keccak256(abi.encodePacked("claims.token.address", _platform, _platformId, _index)));\n', '    }\n', '\n', '    function getAmountByToken(bytes32 _platform, string _platformId, address _token) view external returns (uint token) {\n', '        return db.getUint(keccak256(abi.encodePacked("claims.token.amount", _platform, _platformId, _token)));\n', '    }\n', '}\n', '\n', 'contract ApproveAndCallFallBack {\n', '  function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n', '}\n', '\n', '/*\n', ' * @title String & slice utility library for Solidity contracts.\n', ' * @author Nick Johnson <arachnid@notdot.net>\n', ' *\n', ' * @dev Functionality in this library is largely implemented using an\n', " *      abstraction called a 'slice'. A slice represents a part of a string -\n", ' *      anything from the entire string to a single character, or even no\n', ' *      characters at all (a 0-length slice). Since a slice only has to specify\n', ' *      an offset and a length, copying and manipulating slices is a lot less\n', ' *      expensive than copying and manipulating the strings they reference.\n', ' *\n', ' *      To further reduce gas costs, most functions on slice that need to return\n', ' *      a slice modify the original one instead of allocating a new one; for\n', ' *      instance, `s.split(".")` will return the text up to the first \'.\',\n', " *      modifying s to only contain the remainder of the string after the '.'.\n", ' *      In situations where you do not want to modify the original slice, you\n', ' *      can make a copy first with `.copy()`, for example:\n', ' *      `s.copy().split(".")`. Try and avoid using this idiom in loops; since\n', ' *      Solidity has no memory management, it will result in allocating many\n', ' *      short-lived slices that are later discarded.\n', ' *\n', ' *      Functions that return two slices come in two versions: a non-allocating\n', ' *      version that takes the second slice as an argument, modifying it in\n', ' *      place, and an allocating version that allocates and returns the second\n', ' *      slice; see `nextRune` for example.\n', ' *\n', ' *      Functions that have to copy string data will return strings rather than\n', ' *      slices; these can be cast back to slices for further processing if\n', ' *      required.\n', ' *\n', ' *      For convenience, some functions are provided with non-modifying\n', ' *      variants that create a new slice and return both; for instance,\n', " *      `s.splitNew('.')` leaves s unmodified, and returns two values\n", ' *      corresponding to the left and right parts of the string.\n', ' */\n', '\n', '\n', '\n', 'library strings {\n', '    struct slice {\n', '        uint _len;\n', '        uint _ptr;\n', '    }\n', '\n', '    function memcpy(uint dest, uint src, uint len) private pure {\n', '        // Copy word-length chunks while possible\n', '        for (; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire string.\n', '     * @param self The string to make a slice from.\n', '     * @return A newly allocated slice containing the entire string.\n', '     */\n', '    function toSlice(string self) internal pure returns (slice) {\n', '        uint ptr;\n', '        assembly {\n', '            ptr := add(self, 0x20)\n', '        }\n', '        return slice(bytes(self).length, ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the length of a null-terminated bytes32 string.\n', '     * @param self The value to find the length of.\n', '     * @return The length of the string, from 0 to 32.\n', '     */\n', '    function len(bytes32 self) internal pure returns (uint) {\n', '        uint ret;\n', '        if (self == 0)\n', '            return 0;\n', '        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n', '            ret += 16;\n', '            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n', '        }\n', '        if (self & 0xffffffffffffffff == 0) {\n', '            ret += 8;\n', '            self = bytes32(uint(self) / 0x10000000000000000);\n', '        }\n', '        if (self & 0xffffffff == 0) {\n', '            ret += 4;\n', '            self = bytes32(uint(self) / 0x100000000);\n', '        }\n', '        if (self & 0xffff == 0) {\n', '            ret += 2;\n', '            self = bytes32(uint(self) / 0x10000);\n', '        }\n', '        if (self & 0xff == 0) {\n', '            ret += 1;\n', '        }\n', '        return 32 - ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire bytes32, interpreted as a\n', '     *      null-termintaed utf-8 string.\n', '     * @param self The bytes32 value to convert to a slice.\n', '     * @return A new slice containing the value of the input argument up to the\n', '     *         first null.\n', '     */\n', '    function toSliceB32(bytes32 self) internal pure returns (slice ret) {\n', '        // Allocate space for `self` in memory, copy it there, and point ret at it\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(0x40, add(ptr, 0x20))\n', '            mstore(ptr, self)\n', '            mstore(add(ret, 0x20), ptr)\n', '        }\n', '        ret._len = len(self);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a new slice containing the same data as the current slice.\n', '     * @param self The slice to copy.\n', '     * @return A new slice containing the same data as `self`.\n', '     */\n', '    function copy(slice self) internal pure returns (slice) {\n', '        return slice(self._len, self._ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Copies a slice to a new string.\n', '     * @param self The slice to copy.\n', "     * @return A newly allocated string containing the slice's text.\n", '     */\n', '    function toString(slice self) internal pure returns (string) {\n', '        string memory ret = new string(self._len);\n', '        uint retptr;\n', '        assembly {retptr := add(ret, 32)}\n', '\n', '        memcpy(retptr, self._ptr, self._len);\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the length in runes of the slice. Note that this operation\n', '     *      takes time proportional to the length of the slice; avoid using it\n', '     *      in loops, and call `slice.empty()` if you only need to know whether\n', '     *      the slice is empty or not.\n', '     * @param self The slice to operate on.\n', '     * @return The length of the slice in runes.\n', '     */\n', '    function len(slice self) internal pure returns (uint l) {\n', '        // Starting at ptr-31 means the LSB will be the byte we care about\n', '        uint ptr = self._ptr - 31;\n', '        uint end = ptr + self._len;\n', '        for (l = 0; ptr < end; l++) {\n', '            uint8 b;\n', '            assembly {b := and(mload(ptr), 0xFF)}\n', '            if (b < 0x80) {\n', '                ptr += 1;\n', '            } else if (b < 0xE0) {\n', '                ptr += 2;\n', '            } else if (b < 0xF0) {\n', '                ptr += 3;\n', '            } else if (b < 0xF8) {\n', '                ptr += 4;\n', '            } else if (b < 0xFC) {\n', '                ptr += 5;\n', '            } else {\n', '                ptr += 6;\n', '            }\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the slice is empty (has a length of 0).\n', '     * @param self The slice to operate on.\n', '     * @return True if the slice is empty, False otherwise.\n', '     */\n', '    function empty(slice self) internal pure returns (bool) {\n', '        return self._len == 0;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a positive number if `other` comes lexicographically after\n', '     *      `self`, a negative number if it comes before, or zero if the\n', '     *      contents of the two slices are equal. Comparison is done per-rune,\n', '     *      on unicode codepoints.\n', '     * @param self The first slice to compare.\n', '     * @param other The second slice to compare.\n', '     * @return The result of the comparison.\n', '     */\n', '    function compare(slice self, slice other) internal pure returns (int) {\n', '        uint shortest = self._len;\n', '        if (other._len < self._len)\n', '            shortest = other._len;\n', '\n', '        uint selfptr = self._ptr;\n', '        uint otherptr = other._ptr;\n', '        for (uint idx = 0; idx < shortest; idx += 32) {\n', '            uint a;\n', '            uint b;\n', '            assembly {\n', '                a := mload(selfptr)\n', '                b := mload(otherptr)\n', '            }\n', '            if (a != b) {\n', '                // Mask out irrelevant bytes and check again\n', '                uint256 mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n', '                uint256 diff = (a & mask) - (b & mask);\n', '                if (diff != 0)\n', '                    return int(diff);\n', '            }\n', '            selfptr += 32;\n', '            otherptr += 32;\n', '        }\n', '        return int(self._len) - int(other._len);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the two slices contain the same text.\n', '     * @param self The first slice to compare.\n', '     * @param self The second slice to compare.\n', '     * @return True if the slices are equal, false otherwise.\n', '     */\n', '    function equals(slice self, slice other) internal pure returns (bool) {\n', '        return compare(self, other) == 0;\n', '    }\n', '\n', '    /*\n', '     * @dev Extracts the first rune in the slice into `rune`, advancing the\n', '     *      slice to point to the next rune and returning `self`.\n', '     * @param self The slice to operate on.\n', '     * @param rune The slice that will contain the first rune.\n', '     * @return `rune`.\n', '     */\n', '    function nextRune(slice self, slice rune) internal pure returns (slice) {\n', '        rune._ptr = self._ptr;\n', '\n', '        if (self._len == 0) {\n', '            rune._len = 0;\n', '            return rune;\n', '        }\n', '\n', '        uint l;\n', '        uint b;\n', '        // Load the first byte of the rune into the LSBs of b\n', '        assembly {b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF)}\n', '        if (b < 0x80) {\n', '            l = 1;\n', '        } else if (b < 0xE0) {\n', '            l = 2;\n', '        } else if (b < 0xF0) {\n', '            l = 3;\n', '        } else {\n', '            l = 4;\n', '        }\n', '\n', '        // Check for truncated codepoints\n', '        if (l > self._len) {\n', '            rune._len = self._len;\n', '            self._ptr += self._len;\n', '            self._len = 0;\n', '            return rune;\n', '        }\n', '\n', '        self._ptr += l;\n', '        self._len -= l;\n', '        rune._len = l;\n', '        return rune;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the first rune in the slice, advancing the slice to point\n', '     *      to the next rune.\n', '     * @param self The slice to operate on.\n', '     * @return A slice containing only the first rune from `self`.\n', '     */\n', '    function nextRune(slice self) internal pure returns (slice ret) {\n', '        nextRune(self, ret);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the number of the first codepoint in the slice.\n', '     * @param self The slice to operate on.\n', '     * @return The number of the first codepoint in the slice.\n', '     */\n', '    function ord(slice self) internal pure returns (uint ret) {\n', '        if (self._len == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint word;\n', '        uint length;\n', '        uint divisor = 2 ** 248;\n', '\n', '        // Load the rune into the MSBs of b\n', '        assembly {word := mload(mload(add(self, 32)))}\n', '        uint b = word / divisor;\n', '        if (b < 0x80) {\n', '            ret = b;\n', '            length = 1;\n', '        } else if (b < 0xE0) {\n', '            ret = b & 0x1F;\n', '            length = 2;\n', '        } else if (b < 0xF0) {\n', '            ret = b & 0x0F;\n', '            length = 3;\n', '        } else {\n', '            ret = b & 0x07;\n', '            length = 4;\n', '        }\n', '\n', '        // Check for truncated codepoints\n', '        if (length > self._len) {\n', '            return 0;\n', '        }\n', '\n', '        for (uint i = 1; i < length; i++) {\n', '            divisor = divisor / 256;\n', '            b = (word / divisor) & 0xFF;\n', '            if (b & 0xC0 != 0x80) {\n', '                // Invalid UTF-8 sequence\n', '                return 0;\n', '            }\n', '            ret = (ret * 64) | (b & 0x3F);\n', '        }\n', '\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the keccak-256 hash of the slice.\n', '     * @param self The slice to hash.\n', '     * @return The hash of the slice.\n', '     */\n', '    function keccak(slice self) internal pure returns (bytes32 ret) {\n', '        assembly {\n', '            ret := keccak256(mload(add(self, 32)), mload(self))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if `self` starts with `needle`.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return True if the slice starts with the provided text, false otherwise.\n', '     */\n', '    function startsWith(slice self, slice needle) internal pure returns (bool) {\n', '        if (self._len < needle._len) {\n', '            return false;\n', '        }\n', '\n', '        if (self._ptr == needle._ptr) {\n', '            return true;\n', '        }\n', '\n', '        bool equal;\n', '        assembly {\n', '            let length := mload(needle)\n', '            let selfptr := mload(add(self, 0x20))\n', '            let needleptr := mload(add(needle, 0x20))\n', '            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '        }\n', '        return equal;\n', '    }\n', '\n', '    /*\n', '     * @dev If `self` starts with `needle`, `needle` is removed from the\n', '     *      beginning of `self`. Otherwise, `self` is unmodified.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return `self`\n', '     */\n', '    function beyond(slice self, slice needle) internal pure returns (slice) {\n', '        if (self._len < needle._len) {\n', '            return self;\n', '        }\n', '\n', '        bool equal = true;\n', '        if (self._ptr != needle._ptr) {\n', '            assembly {\n', '                let length := mload(needle)\n', '                let selfptr := mload(add(self, 0x20))\n', '                let needleptr := mload(add(needle, 0x20))\n', '                equal := eq(sha3(selfptr, length), sha3(needleptr, length))\n', '            }\n', '        }\n', '\n', '        if (equal) {\n', '            self._len -= needle._len;\n', '            self._ptr += needle._len;\n', '        }\n', '\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the slice ends with `needle`.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return True if the slice starts with the provided text, false otherwise.\n', '     */\n', '    function endsWith(slice self, slice needle) internal pure returns (bool) {\n', '        if (self._len < needle._len) {\n', '            return false;\n', '        }\n', '\n', '        uint selfptr = self._ptr + self._len - needle._len;\n', '\n', '        if (selfptr == needle._ptr) {\n', '            return true;\n', '        }\n', '\n', '        bool equal;\n', '        assembly {\n', '            let length := mload(needle)\n', '            let needleptr := mload(add(needle, 0x20))\n', '            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '        }\n', '\n', '        return equal;\n', '    }\n', '\n', '    /*\n', '     * @dev If `self` ends with `needle`, `needle` is removed from the\n', '     *      end of `self`. Otherwise, `self` is unmodified.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return `self`\n', '     */\n', '    function until(slice self, slice needle) internal pure returns (slice) {\n', '        if (self._len < needle._len) {\n', '            return self;\n', '        }\n', '\n', '        uint selfptr = self._ptr + self._len - needle._len;\n', '        bool equal = true;\n', '        if (selfptr != needle._ptr) {\n', '            assembly {\n', '                let length := mload(needle)\n', '                let needleptr := mload(add(needle, 0x20))\n', '                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '            }\n', '        }\n', '\n', '        if (equal) {\n', '            self._len -= needle._len;\n', '        }\n', '\n', '        return self;\n', '    }\n', '\n', '    event log_bytemask(bytes32 mask);\n', '\n', '    // Returns the memory address of the first byte of the first occurrence of\n', '    // `needle` in `self`, or the first byte after `self` if not found.\n', '    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n', '        uint ptr = selfptr;\n', '        uint idx;\n', '\n', '        if (needlelen <= selflen) {\n', '            if (needlelen <= 32) {\n', '                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n', '\n', '                bytes32 needledata;\n', '                assembly {needledata := and(mload(needleptr), mask)}\n', '\n', '                uint end = selfptr + selflen - needlelen;\n', '                bytes32 ptrdata;\n', '                assembly {ptrdata := and(mload(ptr), mask)}\n', '\n', '                while (ptrdata != needledata) {\n', '                    if (ptr >= end)\n', '                        return selfptr + selflen;\n', '                    ptr++;\n', '                    assembly {ptrdata := and(mload(ptr), mask)}\n', '                }\n', '                return ptr;\n', '            } else {\n', '                // For long needles, use hashing\n', '                bytes32 hash;\n', '                assembly {hash := sha3(needleptr, needlelen)}\n', '\n', '                for (idx = 0; idx <= selflen - needlelen; idx++) {\n', '                    bytes32 testHash;\n', '                    assembly {testHash := sha3(ptr, needlelen)}\n', '                    if (hash == testHash)\n', '                        return ptr;\n', '                    ptr += 1;\n', '                }\n', '            }\n', '        }\n', '        return selfptr + selflen;\n', '    }\n', '\n', '    // Returns the memory address of the first byte after the last occurrence of\n', '    // `needle` in `self`, or the address of `self` if not found.\n', '    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n', '        uint ptr;\n', '\n', '        if (needlelen <= selflen) {\n', '            if (needlelen <= 32) {\n', '                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n', '\n', '                bytes32 needledata;\n', '                assembly {needledata := and(mload(needleptr), mask)}\n', '\n', '                ptr = selfptr + selflen - needlelen;\n', '                bytes32 ptrdata;\n', '                assembly {ptrdata := and(mload(ptr), mask)}\n', '\n', '                while (ptrdata != needledata) {\n', '                    if (ptr <= selfptr)\n', '                        return selfptr;\n', '                    ptr--;\n', '                    assembly {ptrdata := and(mload(ptr), mask)}\n', '                }\n', '                return ptr + needlelen;\n', '            } else {\n', '                // For long needles, use hashing\n', '                bytes32 hash;\n', '                assembly {hash := sha3(needleptr, needlelen)}\n', '                ptr = selfptr + (selflen - needlelen);\n', '                while (ptr >= selfptr) {\n', '                    bytes32 testHash;\n', '                    assembly {testHash := sha3(ptr, needlelen)}\n', '                    if (hash == testHash)\n', '                        return ptr + needlelen;\n', '                    ptr -= 1;\n', '                }\n', '            }\n', '        }\n', '        return selfptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Modifies `self` to contain everything from the first occurrence of\n', '     *      `needle` to the end of the slice. `self` is set to the empty slice\n', '     *      if `needle` is not found.\n', '     * @param self The slice to search and modify.\n', '     * @param needle The text to search for.\n', '     * @return `self`.\n', '     */\n', '    function find(slice self, slice needle) internal pure returns (slice) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        self._len -= ptr - self._ptr;\n', '        self._ptr = ptr;\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Modifies `self` to contain the part of the string from the start of\n', '     *      `self` to the end of the first occurrence of `needle`. If `needle`\n', '     *      is not found, `self` is set to the empty slice.\n', '     * @param self The slice to search and modify.\n', '     * @param needle The text to search for.\n', '     * @return `self`.\n', '     */\n', '    function rfind(slice self, slice needle) internal pure returns (slice) {\n', '        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        self._len = ptr - self._ptr;\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything after the first\n', '     *      occurrence of `needle`, and `token` to everything before it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and `token` is set to the entirety of `self`.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @param token An output parameter to which the first token is written.\n', '     * @return `token`.\n', '     */\n', '    function split(slice self, slice needle, slice token) internal pure returns (slice) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        token._ptr = self._ptr;\n', '        token._len = ptr - self._ptr;\n', '        if (ptr == self._ptr + self._len) {\n', '            // Not found\n', '            self._len = 0;\n', '        } else {\n', '            self._len -= token._len + needle._len;\n', '            self._ptr = ptr + needle._len;\n', '        }\n', '        return token;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything after the first\n', '     *      occurrence of `needle`, and returning everything before it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and the entirety of `self` is returned.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The part of `self` up to the first occurrence of `delim`.\n', '     */\n', '    function split(slice self, slice needle) internal pure returns (slice token) {\n', '        split(self, needle, token);\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything before the last\n', '     *      occurrence of `needle`, and `token` to everything after it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and `token` is set to the entirety of `self`.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @param token An output parameter to which the first token is written.\n', '     * @return `token`.\n', '     */\n', '    function rsplit(slice self, slice needle, slice token) internal pure returns (slice) {\n', '        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        token._ptr = ptr;\n', '        token._len = self._len - (ptr - self._ptr);\n', '        if (ptr == self._ptr) {\n', '            // Not found\n', '            self._len = 0;\n', '        } else {\n', '            self._len -= token._len + needle._len;\n', '        }\n', '        return token;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything before the last\n', '     *      occurrence of `needle`, and returning everything after it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and the entirety of `self` is returned.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The part of `self` after the last occurrence of `delim`.\n', '     */\n', '    function rsplit(slice self, slice needle) internal pure returns (slice token) {\n', '        rsplit(self, needle, token);\n', '    }\n', '\n', '    /*\n', '     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n', '     * @param self The slice to search.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The number of occurrences of `needle` found in `self`.\n', '     */\n', '    function count(slice self, slice needle) internal pure returns (uint cnt) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n', '        while (ptr <= self._ptr + self._len) {\n', '            cnt++;\n', '            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns True if `self` contains `needle`.\n', '     * @param self The slice to search.\n', '     * @param needle The text to search for in `self`.\n', '     * @return True if `needle` is found in `self`, false otherwise.\n', '     */\n', '    function contains(slice self, slice needle) internal pure returns (bool) {\n', '        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a newly allocated string containing the concatenation of\n', '     *      `self` and `other`.\n', '     * @param self The first slice to concatenate.\n', '     * @param other The second slice to concatenate.\n', '     * @return The concatenation of the two strings.\n', '     */\n', '    function concat(slice self, slice other) internal pure returns (string) {\n', '        string memory ret = new string(self._len + other._len);\n', '        uint retptr;\n', '        assembly {retptr := add(ret, 32)}\n', '        memcpy(retptr, self._ptr, self._len);\n', '        memcpy(retptr + self._len, other._ptr, other._len);\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n', '     *      newly allocated string.\n', '     * @param self The delimiter to use.\n', '     * @param parts A list of slices to join.\n', '     * @return A newly allocated string containing all the slices in `parts`,\n', '     *         joined with `self`.\n', '     */\n', '    function join(slice self, slice[] parts) internal pure returns (string) {\n', '        if (parts.length == 0)\n', '            return "";\n', '\n', '        uint length = self._len * (parts.length - 1);\n', '        for (uint i = 0; i < parts.length; i++)\n', '            length += parts[i]._len;\n', '\n', '        string memory ret = new string(length);\n', '        uint retptr;\n', '        assembly {retptr := add(ret, 32)}\n', '\n', '        for (i = 0; i < parts.length; i++) {\n', '            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n', '            retptr += parts[i]._len;\n', '            if (i < parts.length - 1) {\n', '                memcpy(retptr, self._ptr, self._len);\n', '                retptr += self._len;\n', '            }\n', '        }\n', '\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '    * Additions by the FundRequest Team\n', '    */\n', '\n', '    function toBytes32(slice self) internal pure returns (bytes32 result) {\n', '        string memory source = toString(self);\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c, string _d, string _e) pure internal returns (string){\n', '        bytes memory _ba = bytes(_a);\n', '        bytes memory _bb = bytes(_b);\n', '        bytes memory _bc = bytes(_c);\n', '        bytes memory _bd = bytes(_d);\n', '        bytes memory _be = bytes(_e);\n', '        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '        bytes memory babcde = bytes(abcde);\n', '        uint k = 0;\n', '        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '        return string(babcde);\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c, string _d) pure internal returns (string) {\n', '        return strConcat(_a, _b, _c, _d, "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c) pure internal returns (string) {\n', '        return strConcat(_a, _b, _c, "", "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b) pure internal returns (string) {\n', '        return strConcat(_a, _b, "", "", "");\n', '    }\n', '\n', '    function addressToString(address x) internal pure returns (string) {\n', '        bytes memory s = new bytes(40);\n', '        for (uint i = 0; i < 20; i++) {\n', '            byte b = byte(uint8(uint(x) / (2 ** (8 * (19 - i)))));\n', '            byte hi = byte(uint8(b) / 16);\n', '            byte lo = byte(uint8(b) - 16 * uint8(hi));\n', '            s[2 * i] = charToByte(hi);\n', '            s[2 * i + 1] = charToByte(lo);\n', '        }\n', '        return strConcat("0x", string(s));\n', '    }\n', '\n', '    function charToByte(byte b) internal pure returns (byte c) {\n', '        if (b < 10) return byte(uint8(b) + 0x30);\n', '        else return byte(uint8(b) + 0x57);\n', '    }\n', '\n', '    function bytes32ToString(bytes32 x) internal pure returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '            byte ch = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '            if (ch != 0) {\n', '                bytesString[charCount] = ch;\n', '                charCount++;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '}\n', '\n', 'contract Precondition is Owned {\n', '\n', '    string public name;\n', '    uint public version;\n', '    bool public active = false;\n', '\n', '    constructor(string _name, uint _version, bool _active) public {\n', '        name = _name;\n', '        version = _version;\n', '        active = _active;\n', '    }\n', '\n', '    function setActive(bool _active) external onlyOwner {\n', '        active = _active;\n', '    }\n', '\n', '    function isValid(bytes32 _platform, string _platformId, address _token, uint256 _value, address _funder) external view returns (bool valid);\n', '}\n', '\n', '/*\n', ' * Main FundRequest Contract. The entrypoint for every claim/refund\n', ' * Davy Van Roy\n', ' * Quinten De Swaef\n', ' */\n', 'contract FundRequestContract is Callable, ApproveAndCallFallBack {\n', '\n', '    using SafeMath for uint256;\n', '    using strings for *;\n', '\n', '    event Funded(address indexed from, bytes32 platform, string platformId, address token, uint256 value);\n', '\n', '    event Claimed(address indexed solverAddress, bytes32 platform, string platformId, string solver, address token, uint256 value);\n', '\n', '    event Refund(address indexed owner, bytes32 platform, string platformId, address token, uint256 value);\n', '\n', '    address constant public ETHER_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n', '\n', '    //repositories\n', '    FundRepository public fundRepository;\n', '\n', '    ClaimRepository public claimRepository;\n', '\n', '    address public claimSignerAddress;\n', '\n', '    Precondition[] public preconditions;\n', '\n', '    constructor(address _fundRepository, address _claimRepository) public {\n', '        setFundRepository(_fundRepository);\n', '        setClaimRepository(_claimRepository);\n', '    }\n', '\n', '    //ENTRYPOINTS\n', '\n', '    /*\n', '     * Public function, can only be called from the outside.\n', '     * Fund an issue, providing a token and value.\n', '     * Requires an allowance > _value of the token.\n', '     */\n', '    function fund(bytes32 _platform, string _platformId, address _token, uint256 _value) external returns (bool success) {\n', '        require(doFunding(_platform, _platformId, _token, _value, msg.sender), "funding with token failed");\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Public function, can only be called from the outside.\n', '     * Fund an issue, ether as value of the transaction.\n', '     * Requires ether to be whitelisted in a precondition.\n', '     */\n', '    function etherFund(bytes32 _platform, string _platformId) payable external returns (bool success) {\n', '        require(doFunding(_platform, _platformId, ETHER_ADDRESS, msg.value, msg.sender), "funding with ether failed");\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Public function, supposed to be called from another contract, after receiving approval\n', '     * Funds an issue, expects platform, platformid to be concatted with |AAC| as delimiter and provided as _data\n', '     * Only used with the FundRequest approveAndCall function at the moment. Might be removed later in favor of 2 calls.\n', '     */\n', '    function receiveApproval(address _from, uint _amount, address _token, bytes _data) public {\n', '        var sliced = string(_data).toSlice();\n', '        var platform = sliced.split("|AAC|".toSlice());\n', '        var platformId = sliced.split("|AAC|".toSlice());\n', '        require(doFunding(platform.toBytes32(), platformId.toString(), _token, _amount, _from));\n', '    }\n', '\n', '    /*\n', '     * Claim: Public function, only supposed to be called from the outside\n', '     * Anyone can call this function, but a valid signature from FundRequest is required\n', '     */\n', '    function claim(bytes32 platform, string platformId, string solver, address solverAddress, bytes32 r, bytes32 s, uint8 v) public returns (bool) {\n', '        require(validClaim(platform, platformId, solver, solverAddress, r, s, v), "Claimsignature was not valid");\n', '        uint256 tokenCount = fundRepository.getFundedTokenCount(platform, platformId);\n', '        for (uint i = 0; i < tokenCount; i++) {\n', '            address token = fundRepository.getFundedTokensByIndex(platform, platformId, i);\n', '            uint256 tokenAmount = fundRepository.claimToken(platform, platformId, token);\n', '            if (token == ETHER_ADDRESS) {\n', '                solverAddress.transfer(tokenAmount);\n', '            } else {\n', '                require(ERC20(token).transfer(solverAddress, tokenAmount), "transfer of tokens from contract failed");\n', '            }\n', '            require(claimRepository.addClaim(solverAddress, platform, platformId, solver, token, tokenAmount), "adding claim to repository failed");\n', '            emit Claimed(solverAddress, platform, platformId, solver, token, tokenAmount);\n', '        }\n', '        require(fundRepository.finishResolveFund(platform, platformId), "Resolving the fund failed");\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Claim: Public function, only supposed to be called from the outside\n', '     * Only FundRequest can call this function for now, which will refund a user for a specific issue.\n', '     */\n', '    function refund(bytes32 _platform, string _platformId, address _funder) external onlyCaller returns (bool) {\n', '        uint256 tokenCount = fundRepository.getFundedTokenCount(_platform, _platformId);\n', '        for (uint i = 0; i < tokenCount; i++) {\n', '            address token = fundRepository.getFundedTokensByIndex(_platform, _platformId, i);\n', '            uint256 tokenAmount = fundRepository.refundToken(_platform, _platformId, _funder, token);\n', '            if (tokenAmount > 0) {\n', '                if (token == ETHER_ADDRESS) {\n', '                    _funder.transfer(tokenAmount);\n', '                } else {\n', '                    require(ERC20(token).transfer(_funder, tokenAmount), "transfer of tokens from contract failed");\n', '                }\n', '            }\n', '            emit Refund(_funder, _platform, _platformId, token, tokenAmount);\n', '        }\n', '    }\n', '\n', '    /*\n', '     * only called from within the this contract itself, will actually do the funding\n', '     */\n', '    function doFunding(bytes32 _platform, string _platformId, address _token, uint256 _value, address _funder) internal returns (bool success) {\n', '        if (_token == ETHER_ADDRESS) {\n', "            //must check this, so we don't have people foefeling with the amounts\n", '            require(msg.value == _value);\n', '        }\n', '        require(!fundRepository.issueResolved(_platform, _platformId), "Can\'t fund tokens, platformId already claimed");\n', '        for (uint idx = 0; idx < preconditions.length; idx++) {\n', '            if (address(preconditions[idx]) != address(0)) {\n', '                require(preconditions[idx].isValid(_platform, _platformId, _token, _value, _funder));\n', '            }\n', '        }\n', '        require(_value > 0, "amount of tokens needs to be more than 0");\n', '\n', '        if (_token != ETHER_ADDRESS) {\n', '            require(ERC20(_token).transferFrom(_funder, address(this), _value), "Transfer of tokens to contract failed");\n', '        }\n', '\n', '        fundRepository.updateFunders(_funder, _platform, _platformId);\n', '        fundRepository.updateBalances(_funder, _platform, _platformId, _token, _value);\n', '        emit Funded(_funder, _platform, _platformId, _token, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * checks if a claim is valid, by checking the signature\n', '     */\n', '    function validClaim(bytes32 platform, string platformId, string solver, address solverAddress, bytes32 r, bytes32 s, uint8 v) internal view returns (bool) {\n', '        bytes32 h = keccak256(abi.encodePacked(createClaimMsg(platform, platformId, solver, solverAddress)));\n', '        address signerAddress = ecrecover(h, v, r, s);\n', '        return claimSignerAddress == signerAddress;\n', '    }\n', '\n', '    function createClaimMsg(bytes32 platform, string platformId, string solver, address solverAddress) internal pure returns (string) {\n', '        return strings.bytes32ToString(platform)\n', '        .strConcat(prependUnderscore(platformId))\n', '        .strConcat(prependUnderscore(solver))\n', '        .strConcat(prependUnderscore(strings.addressToString(solverAddress)));\n', '    }\n', '\n', '    function addPrecondition(address _precondition) external onlyOwner {\n', '        preconditions.push(Precondition(_precondition));\n', '    }\n', '\n', '    function removePrecondition(uint _index) external onlyOwner {\n', '        if (_index >= preconditions.length) return;\n', '\n', '        for (uint i = _index; i < preconditions.length - 1; i++) {\n', '            preconditions[i] = preconditions[i + 1];\n', '        }\n', '\n', '        delete preconditions[preconditions.length - 1];\n', '        preconditions.length--;\n', '    }\n', '\n', '    function setFundRepository(address _repositoryAddress) public onlyOwner {\n', '        fundRepository = FundRepository(_repositoryAddress);\n', '    }\n', '\n', '    function setClaimRepository(address _claimRepository) public onlyOwner {\n', '        claimRepository = ClaimRepository(_claimRepository);\n', '    }\n', '\n', '    function setClaimSignerAddress(address _claimSignerAddress) addressNotNull(_claimSignerAddress) public onlyOwner {\n', '        claimSignerAddress = _claimSignerAddress;\n', '    }\n', '\n', '    function prependUnderscore(string str) internal pure returns (string) {\n', '        return "_".strConcat(str);\n', '    }\n', '\n', '    //required to be able to migrate to a new FundRequestContract\n', '    function migrateTokens(address _token, address newContract) external onlyOwner {\n', '        require(newContract != address(0));\n', '        if (_token == ETHER_ADDRESS) {\n', '            newContract.transfer(address(this).balance);\n', '        } else {\n', '            ERC20 token = ERC20(_token);\n', '            token.transfer(newContract, token.balanceOf(address(this)));\n', '        }\n', '    }\n', '\n', '    modifier addressNotNull(address target) {\n', '        require(target != address(0), "target address can not be 0x0");\n', '        _;\n', '    }\n', '\n', '    //required should there be an issue with available ether\n', '    function deposit() external onlyOwner payable {\n', '        require(msg.value > 0, "Should at least be 1 wei deposited");\n', '    }\n', '}']
