['pragma solidity 0.4.24;\n', '\n', 'interface token {\n', '    function transfer(address receiver, uint amount) external;\n', '    function burn(uint amount) external returns(bool success);\n', '}\n', '\n', 'contract InterbetCoinCrowdsale {\n', '\n', '    /* Global constants */\n', '    uint constant ibcTokenDecimals = 18; // Decimal places of IBC\n', '\n', '    token public tokenReward = token(0xCBbb6861423440170680b538d136FfE17A4b661a); // IBC token contract\n', '    address public beneficiary = 0x560b989db52368696bDC1db587eA52787Fdc3406; // Interbet team\n', '    address public admin = 0x8dd4866a5BaB83e1e2433e6e74B8385D12b838A3; // Crowdsale admin\n', '\n', '    /* Events */\n', '    event FundTransfer(SaleStage indexed saleStage, address indexed contributor, uint amount, bool isContribution);\n', '    event CrowdsaleClosed(address recipient, uint totalAmountRaised);\n', '    event TokenClaimed(address indexed contributor, uint tokenAmount);\n', '\n', '    /* Crowdsale Core */\n', '    enum SaleStage {\n', '        NotStarted,\n', '        Presale,\n', '        Break,\n', '        ICO,\n', '        Closed\n', '    }\n', '\n', '    SaleStage public currentSaleStage;\n', '\n', '    uint public minFundInEther = 10 * 1 finney; // Minimum contribution for Presale and ICO\n', '\n', '    uint public presalePrice = 10000; // Base price of Presale: 10,000 IBC = 1 ETH\n', '    uint public presaleFundingTargetInEther = 3000 * 1 ether; // 3,000 ETH target of Presale\n', '\n', '    uint public breakDurationBetweenPresaleAndICO = 1 weeks; // A short break for preparing ICO\n', '    uint public icoPhaseTimeInterval = 1 weeks; // Interval of ICO phases\n', '\n', '    uint public icoStart; // ICO starts one week after Presale ended\n', '    uint public icoTimeBonusPhase1End; // ICO&#39;s phase 1 end\n', '    uint public icoTimeBonusPhase2End; // ICO&#39;s phase 2 end\n', '    uint public icoEnd; // ICO&#39;s phase 3 end\n', '    uint public icoPrice = 5000; // Base price of ICO: 5,000 IBC = 1 ETH\n', '    uint public totalFundingGoalInIBC = 630000000 * (10 ** ibcTokenDecimals); // Funding goal is 630 Mil IBC: 30 Mil (Presale) + 600 Mil (ICO)\n', '    uint public fundingRatePredictionBonusPoolInIBC = 70000000 * (10 ** ibcTokenDecimals); // Funding rate prediction bonus pool of minimum 70 Mil IBC\n', '\n', '    uint public icoReferralBonusInPercentage = 5; // 5% bonus for both referrer and contributor\n', '    uint public icoPhase1TimeBonusInPercentage = 20; // 20% bonus for ICO&#39;s phase 1\n', '    uint public icoPhase2TimeBonusInPercentage = 10; // 10% bonus for ICO&#39;s phase 2\n', '    uint public icoPhase3TimeBonusInPercentage = 0; // No bonus for ICO&#39;s phase 3\n', '    uint public icoFundingRatePredictionBonusInPercentage = 25; // 25% bonus for predicting the correct final funding rate\n', '\n', '    uint public fundingRatePredictionBonusClaimWindow = 4 weeks; // After this window, the remaining pool of prediction bonus tokens will be destroyed\n', '\n', '    uint public etherRaised = 0; // All ether contributed\n', '    uint public ibcFunded = 0; // Counting only the tokens distributed before ICO ended, without counting funding rate prediction bonus\n', '    uint public ibcDistributed = 0; // Total tokens distributed\n', '    uint public contributionCount = 0; // Number of contributions\n', '\n', '    mapping(address => uint256) public balanceOf; // Ether contributed\n', '    mapping(address => uint256) public ibcVaultBalanceOf; // IBC hold in vault\n', '    mapping(address => uint256) public baseRewardTokenBalanceOf; // IBC base reward without counting any bonus\n', '\n', '    mapping(address => uint256) public fundingRatePredictionOf; // The funding rate prediction\n', '    mapping(address => bool) public fundingRatePredictionBingoOf; // Bingo or not\n', '\n', '    constructor() public {\n', '        currentSaleStage = SaleStage.Presale;\n', '    }\n', '\n', '    /// Participate by sending ether\n', '    function () external payable {\n', '        require(currentSaleStage == SaleStage.Presale || currentSaleStage == SaleStage.Break || currentSaleStage == SaleStage.ICO);\n', '\n', '        if (currentSaleStage == SaleStage.Presale) {\n', '            participatePresaleNow();\n', '        } else if (currentSaleStage == SaleStage.Break || currentSaleStage == SaleStage.ICO) {\n', '            participateICONow(address(0), 0);\n', '        }\n', '    }\n', '\n', '    /// Participate Presale\n', '    function participatePresale() external payable {\n', '        participatePresaleNow();\n', '    }\n', '\n', '    function participatePresaleNow() private {\n', '        require(currentSaleStage == SaleStage.Presale);\n', '        require(etherRaised < presaleFundingTargetInEther);\n', '\n', '        require(msg.value >= minFundInEther);\n', '\n', '        uint amount = msg.value;\n', '\n', '        uint price = presalePrice;\n', '\n', '        uint tokenAmount = mul(amount, price);\n', '        require(add(ibcFunded, tokenAmount) <= totalFundingGoalInIBC);\n', '\n', '        if (add(etherRaised, amount) >= presaleFundingTargetInEther) {\n', '            updateSaleStage(SaleStage.Break);\n', '        }\n', '\n', '        balanceOf[msg.sender] = add(balanceOf[msg.sender], amount);\n', '\n', '        etherRaised = add(etherRaised, amount);\n', '\n', '        contributionCount++;\n', '\n', '        ibcFunded = add(ibcFunded, tokenAmount);\n', '\n', '        ibcVaultBalanceOf[msg.sender] = add(ibcVaultBalanceOf[msg.sender], tokenAmount);\n', '\n', '        emit FundTransfer(SaleStage.Presale, msg.sender, amount, true);\n', '    }    \n', '\n', '    /// Participate ICO\n', '    function participateICO(address referrer, uint fundingRatePrediction) external payable {\n', '        participateICONow(referrer, fundingRatePrediction);\n', '    }\n', '\n', '    function participateICONow(address referrer, uint fundingRatePrediction) private {\n', '        require(currentSaleStage == SaleStage.Break || currentSaleStage == SaleStage.ICO);\n', '        if (currentSaleStage == SaleStage.Break) {\n', '            if (now >= icoStart && now < icoEnd) {\n', '                updateSaleStage(SaleStage.ICO);\n', '            } else {\n', '                revert();\n', '            }\n', '        } else if (currentSaleStage == SaleStage.ICO) {\n', '            require(now >= icoStart && now < icoEnd);\n', '        }\n', '\n', '        require(referrer != msg.sender);\n', '        require(fundingRatePrediction >= 1 && fundingRatePrediction <= 100);\n', '\n', '        uint amount = msg.value;\n', '\n', '        uint price = icoPrice;\n', '\n', '        uint baseRewardTokenAmount = mul(amount, price);\n', '        uint tokenAmount = add(baseRewardTokenAmount, calculateInstantBonusAmount(baseRewardTokenAmount, referrer));\n', '        \n', '        uint referrerReferralBonus = 0;\n', '        if (referrer != address(0)) {\n', '            referrerReferralBonus = mul(baseRewardTokenAmount, icoReferralBonusInPercentage) / 100;\n', '        }\n', '\n', '        if (add(add(ibcFunded, tokenAmount), referrerReferralBonus) < totalFundingGoalInIBC) {\n', '            require(msg.value >= minFundInEther);\n', '        } else {\n', '            require(add(add(ibcFunded, tokenAmount), referrerReferralBonus) == totalFundingGoalInIBC);\n', '        }\n', '\n', '        if (add(add(ibcFunded, tokenAmount), referrerReferralBonus) == totalFundingGoalInIBC) {\n', '            updateSaleStage(SaleStage.Closed);\n', '        }\n', '\n', '        balanceOf[msg.sender] = add(balanceOf[msg.sender], amount);\n', '\n', '        baseRewardTokenBalanceOf[msg.sender] = add(baseRewardTokenBalanceOf[msg.sender], baseRewardTokenAmount);\n', '        fundingRatePredictionOf[msg.sender] = fundingRatePrediction;\n', '\n', '        etherRaised = add(etherRaised, amount);\n', '\n', '        contributionCount++;\n', '\n', '        ibcFunded = add(ibcFunded, tokenAmount);\n', '\n', '        ibcVaultBalanceOf[msg.sender] = add(ibcVaultBalanceOf[msg.sender], tokenAmount);\n', '\n', '        if (referrerReferralBonus != 0) {\n', '            ibcFunded = add(ibcFunded, referrerReferralBonus);\n', '            ibcVaultBalanceOf[referrer] = add(ibcVaultBalanceOf[referrer], referrerReferralBonus);\n', '        }\n', '\n', '        emit FundTransfer(SaleStage.ICO, msg.sender, amount, true);\n', '    }\n', '\n', '    /// Calculate time and referral bonus with base tokens\n', '    function calculateInstantBonusAmount(uint baseRewardTokenAmount, address referrer) internal view returns(uint) {\n', '        uint timeBonus = 0;\n', '        uint timeBonusInPercentage = checkTimeBonusPercentage();\n', '        if (timeBonusInPercentage != 0) {\n', '            timeBonus = mul(baseRewardTokenAmount, timeBonusInPercentage) / 100;\n', '        }\n', '\n', '        uint referralBonus = 0;\n', '        if (referrer != address(0)) {\n', '            referralBonus = mul(baseRewardTokenAmount, icoReferralBonusInPercentage) / 100;\n', '        }\n', '\n', '        uint instantBonus = add(timeBonus, referralBonus);\n', '\n', '        return instantBonus;\n', '    }\n', '\n', '    /// Get time bonus percentage\n', '    function checkTimeBonusPercentage() internal view returns(uint) {\n', '        uint timeBonusInPercentage = 0;\n', '\n', '        if (now < icoTimeBonusPhase1End) {\n', '            timeBonusInPercentage = icoPhase1TimeBonusInPercentage;\n', '        } else if (now < icoTimeBonusPhase2End) {\n', '            timeBonusInPercentage = icoPhase2TimeBonusInPercentage;\n', '        }\n', '\n', '        return timeBonusInPercentage;\n', '    }\n', '\n', '    /// Claim IBC\n', '    function claimToken() external {\n', '        require(currentSaleStage == SaleStage.ICO || currentSaleStage == SaleStage.Closed);\n', '        if (currentSaleStage == SaleStage.ICO) {\n', '            if (ibcFunded == totalFundingGoalInIBC || now >= icoEnd) {\n', '                updateSaleStage(SaleStage.Closed);\n', '            } else {\n', '                revert();\n', '            }\n', '        }\n', '\n', '        require(ibcVaultBalanceOf[msg.sender] > 0);\n', '\n', '        uint tokenAmount = ibcVaultBalanceOf[msg.sender];\n', '\n', '        if (now < icoEnd + fundingRatePredictionBonusClaimWindow) {\n', '            if (fundingRatePredictionBonusPoolInIBC > 0) {\n', '                uint finalFundingRate = mul(ibcFunded, 100) / totalFundingGoalInIBC;\n', '                if (finalFundingRate > 100) {\n', '                    finalFundingRate = 100;\n', '                }\n', '\n', '                if (fundingRatePredictionOf[msg.sender] == finalFundingRate) {\n', '                    if (!fundingRatePredictionBingoOf[msg.sender]) {\n', '                        fundingRatePredictionBingoOf[msg.sender] = true;\n', '\n', '                        uint fundingRatePredictionBingoBonus = mul(baseRewardTokenBalanceOf[msg.sender], icoFundingRatePredictionBonusInPercentage) / 100;\n', '\n', '                        if (fundingRatePredictionBingoBonus > fundingRatePredictionBonusPoolInIBC) {\n', '                            fundingRatePredictionBingoBonus = fundingRatePredictionBonusPoolInIBC;\n', '                        }\n', '\n', '                        fundingRatePredictionBonusPoolInIBC = sub(fundingRatePredictionBonusPoolInIBC, fundingRatePredictionBingoBonus);\n', '\n', '                        tokenAmount = add(tokenAmount, fundingRatePredictionBingoBonus);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        ibcVaultBalanceOf[msg.sender] = 0;\n', '\n', '        ibcDistributed = add(ibcDistributed, tokenAmount);\n', '\n', '        tokenReward.transfer(msg.sender, tokenAmount);\n', '\n', '        emit TokenClaimed(msg.sender, tokenAmount);\n', '    }    \n', '\n', '    function updateSaleStage(SaleStage saleStage) private {\n', '        currentSaleStage = saleStage;\n', '\n', '        if (saleStage == SaleStage.Break) {\n', '            icoStart = now + breakDurationBetweenPresaleAndICO;\n', '            icoTimeBonusPhase1End = icoStart + icoPhaseTimeInterval;\n', '            icoTimeBonusPhase2End = icoTimeBonusPhase1End + icoPhaseTimeInterval;\n', '            icoEnd = icoTimeBonusPhase2End + icoPhaseTimeInterval;\n', '        } else if (saleStage == SaleStage.Closed) {\n', '            if (now < icoEnd) {\n', '                icoEnd = now;\n', '            }\n', '\n', '            if (ibcFunded < totalFundingGoalInIBC) {\n', '                fundingRatePredictionBonusPoolInIBC = add(fundingRatePredictionBonusPoolInIBC, sub(totalFundingGoalInIBC, ibcFunded));\n', '            }\n', '\n', '            emit CrowdsaleClosed(beneficiary, etherRaised);\n', '        }\n', '    }\n', '\n', '    /// Update sale stage manually\n', '    function updateSaleStageManually(uint saleStage) external {\n', '        require(msg.sender == admin);\n', '\n', '        require(saleStage >= 1 && saleStage <= 4);\n', '\n', '        require(saleStage > uint(currentSaleStage));\n', '\n', '        updateSaleStage(SaleStage(saleStage));\n', '    }\n', '\n', '    /// Withdraw Ether\n', '    function withdrawEther(uint amount) external {\n', '        require(msg.sender == beneficiary);\n', '\n', '        if (beneficiary.send(amount)) {\n', '           emit FundTransfer(SaleStage.Closed, beneficiary, amount, false);\n', '        }\n', '    }\n', '\n', '    /// Burn the remaining pool of prediction bonus tokens\n', '    function burnAllRemainingIBC() external {\n', '        require(currentSaleStage == SaleStage.Closed);\n', '\n', '        require(now >= icoEnd + fundingRatePredictionBonusClaimWindow);\n', '\n', '        require(msg.sender == admin);\n', '\n', '        require(fundingRatePredictionBonusPoolInIBC > 0);\n', '\n', '        uint currentFundingRatePredictionBonusPoolInIBC = fundingRatePredictionBonusPoolInIBC;\n', '        fundingRatePredictionBonusPoolInIBC = 0;\n', '\n', '        if (!tokenReward.burn(currentFundingRatePredictionBonusPoolInIBC)) {\n', '            fundingRatePredictionBonusPoolInIBC = currentFundingRatePredictionBonusPoolInIBC;\n', '        }\n', '    }\n', '\n', '    /* Math utilities */\n', '    function mul(uint256 _a, uint256 _b) private pure returns(uint256 c) {\n', '        if (_a == 0) {\n', '          return 0;\n', '        }\n', '\n', '        c = _a * _b;\n', '        assert(c / _a == _b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 _a, uint256 _b) private pure returns(uint256) {\n', '        assert(_b <= _a);\n', '        return _a - _b;\n', '    }\n', '\n', '    function add(uint256 _a, uint256 _b) private pure returns(uint256 c) {\n', '        c = _a + _b;\n', '        assert(c >= _a);\n', '        return c;\n', '    }\n', '\n', '}']