['pragma solidity 0.4.24;\n', '\n', 'contract Ownable {\n', '    address public owner=0x28970854Bfa61C0d6fE56Cc9daAAe5271CEaEC09;\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor()public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', 'contract PricingStrategy {\n', '\n', '  /** Interface declaration. */\n', '  function isPricingStrategy() public pure  returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /** Self check if all references are correctly set.\n', '   *\n', '   * Checks that pricing strategy matches crowdsale parameters.\n', '   */\n', '  function isSane() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Pricing tells if this is a presale purchase or not.\n', '     @param purchaser Address of the purchaser\n', '     @return False by default, true if a presale purchaser\n', '   */\n', '  function isPresalePurchase(address purchaser) public pure returns (bool) {\n', '    return false;\n', '  }\n', '\n', '  /**\n', '   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\n', '   *\n', '   *\n', '   * @param value - What is the value of the transaction send in as wei\n', '   * @param tokensSold - how much tokens have been sold this far\n', '   * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale\n', '   * @param msgSender - who is the investor of this transaction\n', '   * @param decimals - how many decimal units the token has\n', '   * @return Amount of tokens the investor receives\n', '   */\n', '  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public pure returns (uint tokenAmount){\n', '      \n', '  }\n', '  \n', '}\n', 'contract FinalizeAgent {\n', '\n', '  function isFinalizeAgent() public pure returns(bool) {\n', '    return true;\n', '  }\n', '\n', '  /** Return true if we can run finalizeCrowdsale() properly.\n', '   *\n', '   * This is a safety check function that doesn&#39;t allow crowdsale to begin\n', '   * unless the finalizer has been set up properly.\n', '   */\n', '  function isSane() public pure returns (bool){\n', '      return true;\n', '}\n', '  /** Called once by crowdsale finalize() if the sale was success. */\n', '  function finalizeCrowdsale() pure public{\n', '     \n', '  }\n', '  \n', '\n', '}\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract UbricoinPresale {\n', '\n', '    /*/\n', '     *  Token state\n', '    /*/\n', '\n', '    enum Phase {\n', '        Created,\n', '        Running,\n', '        Paused,\n', '        Migrating,\n', '        Migrated\n', '    }\n', '\n', '    Phase public currentPhase = Phase.Created;\n', '    uint public totalSupply = 0; // amount of tokens already sold\n', '    \n', '\n', '    // Token manager has exclusive priveleges to call administrative\n', '    // functions on this contract.\n', '    address public tokenManager;\n', '\n', '    // Gathered funds can be withdrawn only to escrow&#39;s address.\n', '    address public escrow;\n', '\n', '    // Crowdsale manager has exclusive priveleges to burn presale tokens.\n', '    address public crowdsaleManager;\n', '\n', '    mapping (address => uint256) private balance;\n', '\n', '\n', '    modifier onlyTokenManager()     { if(msg.sender != tokenManager) revert(); _; }\n', '    modifier onlyCrowdsaleManager() { if(msg.sender != crowdsaleManager) revert(); _; }\n', '\n', '\n', '    /*/\n', '     *  Events\n', '    /*/\n', '\n', '    event LogBuy(address indexed owner, uint256 value);\n', '    event LogBurn(address indexed owner, uint256 value);\n', '    event LogPhaseSwitch(Phase newPhase);\n', '\n', '\n', '    /*/\n', '     *  Public functions\n', '    /*/\n', '\n', ' \n', '    /// @dev Returns number of tokens owned by given address.\n', '    /// @param _owner Address of token owner.\n', '    function burnTokens(address _owner) public\n', '        onlyCrowdsaleManager\n', '    {\n', '        // Available only during migration phase\n', '        if(currentPhase != Phase.Migrating) revert();\n', '\n', '        uint256 tokens = balance[_owner];\n', '        if(tokens == 0) revert();\n', '        balance[_owner] = 0;\n', '        \n', '        emit LogBurn(_owner, tokens);\n', '\n', '        // Automatically switch phase when migration is done.\n', '       \n', '    }\n', '\n', '    /*/\n', '     *  Administrative functions\n', '    /*/\n', '\n', '    function setPresalePhase(Phase _nextPhase) public\n', '        onlyTokenManager\n', '    {\n', '        bool canSwitchPhase\n', '            =  (currentPhase == Phase.Created && _nextPhase == Phase.Running)\n', '            || (currentPhase == Phase.Running && _nextPhase == Phase.Paused)\n', '                // switch to migration phase only if crowdsale manager is set\n', '            || ((currentPhase == Phase.Running || currentPhase == Phase.Paused)\n', '                && _nextPhase == Phase.Migrating\n', '                && crowdsaleManager != 0x0)\n', '            || (currentPhase == Phase.Paused && _nextPhase == Phase.Running)\n', '                // switch to migrated only if everyting is migrated\n', '            || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated\n', '                && totalSupply == 0);\n', '\n', '        if(!canSwitchPhase) revert();\n', '        currentPhase = _nextPhase;\n', '        emit LogPhaseSwitch(_nextPhase); \n', '           \n', '    }\n', '\n', '\n', '    function withdrawEther() public\n', '        onlyTokenManager\n', '    {\n', '        // Available at any phase.\n', '        if(address(this).balance > 0) {\n', '            if(!escrow.send(address(this).balance)) revert();\n', '        }\n', '    }\n', '\n', '\n', '    function setCrowdsaleManager(address _mgr) public\n', '        onlyTokenManager\n', '    {\n', '        // You can&#39;t change crowdsale contract when migration is in progress.\n', '        if(currentPhase == Phase.Migrating) revert();\n', '        crowdsaleManager = _mgr;\n', '    }\n', '}\n', 'contract Haltable is Ownable  {\n', '    \n', '  bool public halted;\n', '  \n', '   modifier stopInEmergency {\n', '    if (halted) revert();\n', '    _;\n', '  }\n', '\n', '  modifier stopNonOwnersInEmergency {\n', '    if (halted && msg.sender != owner) revert();\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    if (!halted) revert();\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function halt() external onlyOwner {\n', '    halted = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function unhalt() external onlyOwner onlyInEmergency {\n', '    halted = false;\n', '  }\n', '\n', '}\n', 'contract WhitelistedCrowdsale is Ownable {\n', '\n', '  mapping(address => bool) public whitelist;\n', '\n', '  /**\n', '   * @dev Reverts if beneficiary is not whitelisted. Can be used when extending this contract.\n', '   */\n', '  modifier isWhitelisted(address _beneficiary) {\n', '    require(whitelist[_beneficiary]);\n', '    _;\n', '  }\n', '  \n', '  /**\n', '   * @dev Adds single address to whitelist.\n', '   * @param _beneficiary Address to be added to the whitelist\n', '   */\n', '  function addToWhitelist(address _beneficiary) onlyOwner public  {\n', '    whitelist[_beneficiary] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds list of addresses to whitelist. \n', '   * @param _beneficiaries Addresses to be added to the whitelist\n', '   */\n', '  function addManyToWhitelist(address[] _beneficiaries) onlyOwner public {\n', '    for (uint256 i = 0; i < _beneficiaries.length; i++) {\n', '      whitelist[_beneficiaries[i]] = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Removes single address from whitelist.\n', '   * @param _beneficiary Address to be removed to the whitelist\n', '   */\n', '  function removeFromWhitelist(address _beneficiary)onlyOwner public {\n', '    whitelist[_beneficiary] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev Extend parent behavior requiring beneficiary to be in whitelist.\n', '   * @param _beneficiary Token beneficiary\n', '   * @param _weiAmount Amount of wei contributed\n', '   */\n', '  \n', '}\n', '\n', '   contract UbricoinCrowdsale is FinalizeAgent,WhitelistedCrowdsale {\n', '    using SafeMath for uint256;\n', '    address public beneficiary;\n', '    uint256 public fundingGoal;\n', '    uint256 public amountRaised;\n', '    uint256 public deadline;\n', '       \n', '    mapping(address => uint256) public balanceOf;\n', '    bool fundingGoalReached = false;\n', '    bool crowdsaleClosed = false;\n', '    uint256 public investorCount = 0;\n', '    \n', '    bool public requiredSignedAddress;\n', '    bool public requireCustomerId;\n', '    \n', '\n', '    bool public paused = false;\n', '\n', '    \n', '    event GoalReached(address recipient, uint256 totalAmountRaised);\n', '    event FundTransfer(address backer, uint256 amount, bool isContribution);\n', '    \n', '    // A new investment was made\n', '    event Invested(address investor, uint256 weiAmount, uint256 tokenAmount, uint256 customerId);\n', '\n', '  // The rules were changed what kind of investments we accept\n', '    event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\n', '    event Pause();\n', '    event Unpause();\n', ' \n', '     \n', ' \n', '    modifier afterDeadline() { if (now >= deadline) _; }\n', '    \n', '\n', '    /**\n', '     * Check if goal was reached\n', '     *\n', '     * Checks if the goal or time limit has been reached and ends the campaign\n', '     */\n', '     \n', '    function invest(address ) public payable {\n', '    if(requireCustomerId) revert(); // Crowdsale needs to track partipants for thank you email\n', '    if(requiredSignedAddress) revert(); // Crowdsale allows only server-side signed participants\n', '   \n', '  }\n', '     \n', '    function investWithCustomerId(address , uint256 customerId) public payable {\n', '    if(requiredSignedAddress) revert(); // Crowdsale allows only server-side signed participants\n', '    if(customerId == 0)revert();  // UUIDv4 sanity check\n', '\n', '  }\n', '  \n', '    function buyWithCustomerId(uint256 customerId) public payable {\n', '    investWithCustomerId(msg.sender, customerId);\n', '  }\n', '     \n', '     \n', '    function checkGoalReached() afterDeadline public {\n', '        if (amountRaised >= fundingGoal){\n', '            fundingGoalReached = true;\n', '            emit GoalReached(beneficiary, amountRaised);\n', '        }\n', '        crowdsaleClosed = true;\n', '    }\n', '\n', '   \n', '\n', '    /**\n', '     * Withdraw the funds\n', '     *\n', '     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\n', '     * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw\n', '     * the amount they contributed.\n', '     */\n', '    function safeWithdrawal() afterDeadline public {\n', '        if (!fundingGoalReached) {\n', '            uint256 amount = balanceOf[msg.sender];\n', '            balanceOf[msg.sender] = 0;\n', '            if (amount > 0) {\n', '                if (msg.sender.send(amount)) {\n', '                emit FundTransfer(beneficiary,amountRaised,false);\n', '                } else {\n', '                    balanceOf[msg.sender] = amount;\n', '                }\n', '            }\n', '        }\n', '\n', '        if  (fundingGoalReached && beneficiary == msg.sender) {\n', '            if (beneficiary.send(amountRaised)) {\n', '               emit FundTransfer(beneficiary,amountRaised,false);\n', '            } else {\n', '                //If we fail to send the funds to beneficiary, unlock funders balance\n', '                fundingGoalReached = false;\n', '            }\n', '        }\n', '    }\n', '    \n', '     /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public returns (bool) {\n', '    paused = true;\n', '    emit Pause();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public returns (bool) {\n', '    paused = false;\n', '    emit Unpause();\n', '    return true;\n', '  }\n', '\n', '}\n', 'contract Upgradeable {\n', '    mapping(bytes4=>uint32) _sizes;\n', '    address _dest;\n', '\n', '    /**\n', '     * This function is called using delegatecall from the dispatcher when the\n', '     * target contract is first initialized. It should use this opportunity to\n', '     * insert any return data sizes in _sizes, and perform any other upgrades\n', '     * necessary to change over from the old contract implementation (if any).\n', '     * \n', '     * Implementers of this function should either perform strictly harmless,\n', '     * idempotent operations like setting return sizes, or use some form of\n', '     * access control, to prevent outside callers.\n', '     */\n', '    function initialize() public{\n', '        \n', '    }\n', '    \n', '    /**\n', '     * Performs a handover to a new implementing contract.\n', '     */\n', '    function replace(address target) internal {\n', '        _dest = target;\n', '        require(target.delegatecall(bytes4(keccak256("initialize()"))));\n', '    }\n', '}\n', '/**\n', ' * The dispatcher is a minimal &#39;shim&#39; that dispatches calls to a targeted\n', ' * contract. Calls are made using &#39;delegatecall&#39;, meaning all storage and value\n', ' * is kept on the dispatcher. As a result, when the target is updated, the new\n', ' * contract inherits all the stored data and value from the old contract.\n', ' */\n', 'contract Dispatcher is Upgradeable {\n', '    \n', '    constructor (address target) public {\n', '        replace(target);\n', '    }\n', '    \n', '    function initialize() public {\n', '        // Should only be called by on target contracts, not on the dispatcher\n', '        revert();\n', '    }\n', '\n', '    function() public {\n', '        uint len;\n', '        address target;\n', '        bytes4 sig;\n', '        assembly { sig := calldataload(0) }\n', '        len = _sizes[sig];\n', '        target = _dest;\n', '        \n', '        bool ret;\n', '        assembly {\n', '            // return _dest.delegatecall(msg.data)\n', '            calldatacopy(0x0, 0x0, calldatasize)\n', '            ret:=delegatecall(sub(gas, 10000), target, 0x0, calldatasize, 0, len)\n', '            return(0, len)\n', '        }\n', '        if (!ret) revert();\n', '    }\n', '}\n', 'contract Example is Upgradeable {\n', '    uint _value;\n', '    \n', '    function initialize() public {\n', '        _sizes[bytes4(keccak256("getUint()"))] = 32;\n', '    }\n', '    \n', '    function getUint() public view returns (uint) {\n', '        return _value;\n', '    }\n', '    \n', '    function setUint(uint value) public {\n', '        _value = value;\n', '    }\n', '}\n', 'interface tokenRecipient { \n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData)external;\n', '    \n', '}\n', '\n', ' /**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', '\n', 'contract Ubricoin is UbricoinPresale,Ownable,Haltable, UbricoinCrowdsale,Upgradeable {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    // Public variables of the token\n', '    string public name =&#39;Ubricoin&#39;;\n', '    string public symbol =&#39;UBN&#39;;\n', '    string public version= "1.0";\n', '    uint public decimals=18;\n', '    // 18 decimals is the strongly suggested default, avoid changing it\n', '    uint public totalSupply = 10000000000;\n', '    uint256 public constant RATE = 1000;\n', '    uint256 initialSupply;\n', '\n', '    \n', '    \n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    \n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '    \n', '    uint256 public AVAILABLE_AIRDROP_SUPPLY = 100000000* decimals; // 100% Released at Token distribution\n', '    uint256 public grandTotalClaimed = 1;\n', '    uint256 public startTime;\n', '    \n', '    struct Allocation {\n', '    uint8 AllocationSupply; // Type of allocation\n', '    uint256 totalAllocated; // Total tokens allocated\n', '    uint256 amountClaimed;  // Total tokens claimed\n', '}\n', '    \n', '    \n', '    mapping (address => Allocation) public allocations;\n', '\n', '    // List of admins\n', '    mapping (address => bool) public airdropAdmins;\n', '\n', '    // Keeps track of whether or not an Ubricoin airdrop has been made to a particular address\n', '    mapping (address => bool) public airdrops;\n', '\n', '  modifier onlyOwnerOrAdmin() {\n', '    require(msg.sender == owner || airdropAdmins[msg.sender]);\n', '    _;\n', '}\n', '    \n', '    \n', '    \n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '        bytes32 public currentChallenge;                         // The coin starts with a challenge\n', '        uint256 public timeOfLastProof;                             // Variable to keep track of when rewards were given\n', '        uint256 public difficulty = 10**32;                         // Difficulty starts reasonably low\n', '\n', '     \n', '    function proofOfWork(uint256 nonce) public{\n', '        bytes8 n = bytes8(keccak256(abi.encodePacked(nonce, currentChallenge)));    // Generate a random hash based on input\n', '        require(n >= bytes8(difficulty));                   // Check if it&#39;s under the difficulty\n', '\n', '        uint256 timeSinceLastProof = (now - timeOfLastProof);  // Calculate time since last reward was given\n', '        require(timeSinceLastProof >=  5 seconds);         // Rewards cannot be given too quickly\n', '        balanceOf[msg.sender] += timeSinceLastProof / 60 seconds;  // The reward to the winner grows by the minute\n', '\n', '        difficulty = difficulty * 10 minutes / timeSinceLastProof + 1;  // Adjusts the difficulty\n', '\n', '        timeOfLastProof = now;                              // Reset the counter\n', '        currentChallenge = keccak256(abi.encodePacked(nonce, currentChallenge, blockhash(block.number - 1)));  // Save a hash that will be used as the next proof\n', '    }\n', '\n', '\n', '   function () payable public whenNotPaused {\n', '        require(msg.value > 0);\n', '        uint256 tokens = msg.value.mul(RATE);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(tokens);\n', '        totalSupply = totalSupply.add(tokens);\n', '        owner.transfer(msg.value);\n', '}\n', '    \n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint256 _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '     function transfer(address _to, uint256 _value) public {\n', '\t\tbalanceOf[msg.sender] -= _value;\n', '\t\tbalanceOf[_to] += _value;\n', '\t}\n', '     \n', '   function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\n', '        return balanceOf[tokenOwner];\n', '        \n', '}\n', '\n', '   function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {\n', '        return allowance[tokenOwner][spender];\n', '}\n', '   \n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` on behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply -= _value;                      // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '  \n', '    function mintToken(address target, uint256 mintedAmount)private onlyOwner {\n', '        balanceOf[target] += mintedAmount;\n', '        totalSupply += mintedAmount;\n', '        emit Transfer(0, owner, mintedAmount);\n', '        emit Transfer(owner, target, mintedAmount);\n', '    }\n', '\n', '    function validPurchase() internal returns (bool) {\n', '    bool lessThanMaxInvestment = msg.value <= 1000 ether; // change the value to whatever you need\n', '    return validPurchase() && lessThanMaxInvestment;\n', '}\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n', '        allowance[_from][msg.sender] -= _value;             // Subtract from the sender&#39;s allowance\n', '        totalSupply -= _value;                              // Update totalSupply\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '    \n', '   /**\n', '    * @dev Add an airdrop admin\n', '    */\n', '  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n', '    airdropAdmins[_admin] = _isAdmin;\n', '  }\n', '\n', '  /**\n', '    * @dev perform a transfer of allocations\n', '    * @param _recipient is a list of recipients\n', '    */\n', '  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n', '    \n', '    uint airdropped;\n', '    for(uint256 i = 0; i< _recipient.length; i++)\n', '    {\n', '        if (!airdrops[_recipient[i]]) {\n', '          airdrops[_recipient[i]] = true;\n', '          Ubricoin.transfer(_recipient[i], 1 * decimals);\n', '          airdropped = airdropped.add(1 * decimals);\n', '        }\n', '    }\n', '    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n', '    totalSupply = totalSupply.sub(airdropped);\n', '    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n', '}\n', '    \n', '}']
['pragma solidity 0.4.24;\n', '\n', 'contract Ownable {\n', '    address public owner=0x28970854Bfa61C0d6fE56Cc9daAAe5271CEaEC09;\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor()public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', 'contract PricingStrategy {\n', '\n', '  /** Interface declaration. */\n', '  function isPricingStrategy() public pure  returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /** Self check if all references are correctly set.\n', '   *\n', '   * Checks that pricing strategy matches crowdsale parameters.\n', '   */\n', '  function isSane() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Pricing tells if this is a presale purchase or not.\n', '     @param purchaser Address of the purchaser\n', '     @return False by default, true if a presale purchaser\n', '   */\n', '  function isPresalePurchase(address purchaser) public pure returns (bool) {\n', '    return false;\n', '  }\n', '\n', '  /**\n', '   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\n', '   *\n', '   *\n', '   * @param value - What is the value of the transaction send in as wei\n', '   * @param tokensSold - how much tokens have been sold this far\n', '   * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale\n', '   * @param msgSender - who is the investor of this transaction\n', '   * @param decimals - how many decimal units the token has\n', '   * @return Amount of tokens the investor receives\n', '   */\n', '  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public pure returns (uint tokenAmount){\n', '      \n', '  }\n', '  \n', '}\n', 'contract FinalizeAgent {\n', '\n', '  function isFinalizeAgent() public pure returns(bool) {\n', '    return true;\n', '  }\n', '\n', '  /** Return true if we can run finalizeCrowdsale() properly.\n', '   *\n', "   * This is a safety check function that doesn't allow crowdsale to begin\n", '   * unless the finalizer has been set up properly.\n', '   */\n', '  function isSane() public pure returns (bool){\n', '      return true;\n', '}\n', '  /** Called once by crowdsale finalize() if the sale was success. */\n', '  function finalizeCrowdsale() pure public{\n', '     \n', '  }\n', '  \n', '\n', '}\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract UbricoinPresale {\n', '\n', '    /*/\n', '     *  Token state\n', '    /*/\n', '\n', '    enum Phase {\n', '        Created,\n', '        Running,\n', '        Paused,\n', '        Migrating,\n', '        Migrated\n', '    }\n', '\n', '    Phase public currentPhase = Phase.Created;\n', '    uint public totalSupply = 0; // amount of tokens already sold\n', '    \n', '\n', '    // Token manager has exclusive priveleges to call administrative\n', '    // functions on this contract.\n', '    address public tokenManager;\n', '\n', "    // Gathered funds can be withdrawn only to escrow's address.\n", '    address public escrow;\n', '\n', '    // Crowdsale manager has exclusive priveleges to burn presale tokens.\n', '    address public crowdsaleManager;\n', '\n', '    mapping (address => uint256) private balance;\n', '\n', '\n', '    modifier onlyTokenManager()     { if(msg.sender != tokenManager) revert(); _; }\n', '    modifier onlyCrowdsaleManager() { if(msg.sender != crowdsaleManager) revert(); _; }\n', '\n', '\n', '    /*/\n', '     *  Events\n', '    /*/\n', '\n', '    event LogBuy(address indexed owner, uint256 value);\n', '    event LogBurn(address indexed owner, uint256 value);\n', '    event LogPhaseSwitch(Phase newPhase);\n', '\n', '\n', '    /*/\n', '     *  Public functions\n', '    /*/\n', '\n', ' \n', '    /// @dev Returns number of tokens owned by given address.\n', '    /// @param _owner Address of token owner.\n', '    function burnTokens(address _owner) public\n', '        onlyCrowdsaleManager\n', '    {\n', '        // Available only during migration phase\n', '        if(currentPhase != Phase.Migrating) revert();\n', '\n', '        uint256 tokens = balance[_owner];\n', '        if(tokens == 0) revert();\n', '        balance[_owner] = 0;\n', '        \n', '        emit LogBurn(_owner, tokens);\n', '\n', '        // Automatically switch phase when migration is done.\n', '       \n', '    }\n', '\n', '    /*/\n', '     *  Administrative functions\n', '    /*/\n', '\n', '    function setPresalePhase(Phase _nextPhase) public\n', '        onlyTokenManager\n', '    {\n', '        bool canSwitchPhase\n', '            =  (currentPhase == Phase.Created && _nextPhase == Phase.Running)\n', '            || (currentPhase == Phase.Running && _nextPhase == Phase.Paused)\n', '                // switch to migration phase only if crowdsale manager is set\n', '            || ((currentPhase == Phase.Running || currentPhase == Phase.Paused)\n', '                && _nextPhase == Phase.Migrating\n', '                && crowdsaleManager != 0x0)\n', '            || (currentPhase == Phase.Paused && _nextPhase == Phase.Running)\n', '                // switch to migrated only if everyting is migrated\n', '            || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated\n', '                && totalSupply == 0);\n', '\n', '        if(!canSwitchPhase) revert();\n', '        currentPhase = _nextPhase;\n', '        emit LogPhaseSwitch(_nextPhase); \n', '           \n', '    }\n', '\n', '\n', '    function withdrawEther() public\n', '        onlyTokenManager\n', '    {\n', '        // Available at any phase.\n', '        if(address(this).balance > 0) {\n', '            if(!escrow.send(address(this).balance)) revert();\n', '        }\n', '    }\n', '\n', '\n', '    function setCrowdsaleManager(address _mgr) public\n', '        onlyTokenManager\n', '    {\n', "        // You can't change crowdsale contract when migration is in progress.\n", '        if(currentPhase == Phase.Migrating) revert();\n', '        crowdsaleManager = _mgr;\n', '    }\n', '}\n', 'contract Haltable is Ownable  {\n', '    \n', '  bool public halted;\n', '  \n', '   modifier stopInEmergency {\n', '    if (halted) revert();\n', '    _;\n', '  }\n', '\n', '  modifier stopNonOwnersInEmergency {\n', '    if (halted && msg.sender != owner) revert();\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    if (!halted) revert();\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function halt() external onlyOwner {\n', '    halted = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function unhalt() external onlyOwner onlyInEmergency {\n', '    halted = false;\n', '  }\n', '\n', '}\n', 'contract WhitelistedCrowdsale is Ownable {\n', '\n', '  mapping(address => bool) public whitelist;\n', '\n', '  /**\n', '   * @dev Reverts if beneficiary is not whitelisted. Can be used when extending this contract.\n', '   */\n', '  modifier isWhitelisted(address _beneficiary) {\n', '    require(whitelist[_beneficiary]);\n', '    _;\n', '  }\n', '  \n', '  /**\n', '   * @dev Adds single address to whitelist.\n', '   * @param _beneficiary Address to be added to the whitelist\n', '   */\n', '  function addToWhitelist(address _beneficiary) onlyOwner public  {\n', '    whitelist[_beneficiary] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds list of addresses to whitelist. \n', '   * @param _beneficiaries Addresses to be added to the whitelist\n', '   */\n', '  function addManyToWhitelist(address[] _beneficiaries) onlyOwner public {\n', '    for (uint256 i = 0; i < _beneficiaries.length; i++) {\n', '      whitelist[_beneficiaries[i]] = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Removes single address from whitelist.\n', '   * @param _beneficiary Address to be removed to the whitelist\n', '   */\n', '  function removeFromWhitelist(address _beneficiary)onlyOwner public {\n', '    whitelist[_beneficiary] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev Extend parent behavior requiring beneficiary to be in whitelist.\n', '   * @param _beneficiary Token beneficiary\n', '   * @param _weiAmount Amount of wei contributed\n', '   */\n', '  \n', '}\n', '\n', '   contract UbricoinCrowdsale is FinalizeAgent,WhitelistedCrowdsale {\n', '    using SafeMath for uint256;\n', '    address public beneficiary;\n', '    uint256 public fundingGoal;\n', '    uint256 public amountRaised;\n', '    uint256 public deadline;\n', '       \n', '    mapping(address => uint256) public balanceOf;\n', '    bool fundingGoalReached = false;\n', '    bool crowdsaleClosed = false;\n', '    uint256 public investorCount = 0;\n', '    \n', '    bool public requiredSignedAddress;\n', '    bool public requireCustomerId;\n', '    \n', '\n', '    bool public paused = false;\n', '\n', '    \n', '    event GoalReached(address recipient, uint256 totalAmountRaised);\n', '    event FundTransfer(address backer, uint256 amount, bool isContribution);\n', '    \n', '    // A new investment was made\n', '    event Invested(address investor, uint256 weiAmount, uint256 tokenAmount, uint256 customerId);\n', '\n', '  // The rules were changed what kind of investments we accept\n', '    event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\n', '    event Pause();\n', '    event Unpause();\n', ' \n', '     \n', ' \n', '    modifier afterDeadline() { if (now >= deadline) _; }\n', '    \n', '\n', '    /**\n', '     * Check if goal was reached\n', '     *\n', '     * Checks if the goal or time limit has been reached and ends the campaign\n', '     */\n', '     \n', '    function invest(address ) public payable {\n', '    if(requireCustomerId) revert(); // Crowdsale needs to track partipants for thank you email\n', '    if(requiredSignedAddress) revert(); // Crowdsale allows only server-side signed participants\n', '   \n', '  }\n', '     \n', '    function investWithCustomerId(address , uint256 customerId) public payable {\n', '    if(requiredSignedAddress) revert(); // Crowdsale allows only server-side signed participants\n', '    if(customerId == 0)revert();  // UUIDv4 sanity check\n', '\n', '  }\n', '  \n', '    function buyWithCustomerId(uint256 customerId) public payable {\n', '    investWithCustomerId(msg.sender, customerId);\n', '  }\n', '     \n', '     \n', '    function checkGoalReached() afterDeadline public {\n', '        if (amountRaised >= fundingGoal){\n', '            fundingGoalReached = true;\n', '            emit GoalReached(beneficiary, amountRaised);\n', '        }\n', '        crowdsaleClosed = true;\n', '    }\n', '\n', '   \n', '\n', '    /**\n', '     * Withdraw the funds\n', '     *\n', '     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\n', '     * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw\n', '     * the amount they contributed.\n', '     */\n', '    function safeWithdrawal() afterDeadline public {\n', '        if (!fundingGoalReached) {\n', '            uint256 amount = balanceOf[msg.sender];\n', '            balanceOf[msg.sender] = 0;\n', '            if (amount > 0) {\n', '                if (msg.sender.send(amount)) {\n', '                emit FundTransfer(beneficiary,amountRaised,false);\n', '                } else {\n', '                    balanceOf[msg.sender] = amount;\n', '                }\n', '            }\n', '        }\n', '\n', '        if  (fundingGoalReached && beneficiary == msg.sender) {\n', '            if (beneficiary.send(amountRaised)) {\n', '               emit FundTransfer(beneficiary,amountRaised,false);\n', '            } else {\n', '                //If we fail to send the funds to beneficiary, unlock funders balance\n', '                fundingGoalReached = false;\n', '            }\n', '        }\n', '    }\n', '    \n', '     /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public returns (bool) {\n', '    paused = true;\n', '    emit Pause();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public returns (bool) {\n', '    paused = false;\n', '    emit Unpause();\n', '    return true;\n', '  }\n', '\n', '}\n', 'contract Upgradeable {\n', '    mapping(bytes4=>uint32) _sizes;\n', '    address _dest;\n', '\n', '    /**\n', '     * This function is called using delegatecall from the dispatcher when the\n', '     * target contract is first initialized. It should use this opportunity to\n', '     * insert any return data sizes in _sizes, and perform any other upgrades\n', '     * necessary to change over from the old contract implementation (if any).\n', '     * \n', '     * Implementers of this function should either perform strictly harmless,\n', '     * idempotent operations like setting return sizes, or use some form of\n', '     * access control, to prevent outside callers.\n', '     */\n', '    function initialize() public{\n', '        \n', '    }\n', '    \n', '    /**\n', '     * Performs a handover to a new implementing contract.\n', '     */\n', '    function replace(address target) internal {\n', '        _dest = target;\n', '        require(target.delegatecall(bytes4(keccak256("initialize()"))));\n', '    }\n', '}\n', '/**\n', " * The dispatcher is a minimal 'shim' that dispatches calls to a targeted\n", " * contract. Calls are made using 'delegatecall', meaning all storage and value\n", ' * is kept on the dispatcher. As a result, when the target is updated, the new\n', ' * contract inherits all the stored data and value from the old contract.\n', ' */\n', 'contract Dispatcher is Upgradeable {\n', '    \n', '    constructor (address target) public {\n', '        replace(target);\n', '    }\n', '    \n', '    function initialize() public {\n', '        // Should only be called by on target contracts, not on the dispatcher\n', '        revert();\n', '    }\n', '\n', '    function() public {\n', '        uint len;\n', '        address target;\n', '        bytes4 sig;\n', '        assembly { sig := calldataload(0) }\n', '        len = _sizes[sig];\n', '        target = _dest;\n', '        \n', '        bool ret;\n', '        assembly {\n', '            // return _dest.delegatecall(msg.data)\n', '            calldatacopy(0x0, 0x0, calldatasize)\n', '            ret:=delegatecall(sub(gas, 10000), target, 0x0, calldatasize, 0, len)\n', '            return(0, len)\n', '        }\n', '        if (!ret) revert();\n', '    }\n', '}\n', 'contract Example is Upgradeable {\n', '    uint _value;\n', '    \n', '    function initialize() public {\n', '        _sizes[bytes4(keccak256("getUint()"))] = 32;\n', '    }\n', '    \n', '    function getUint() public view returns (uint) {\n', '        return _value;\n', '    }\n', '    \n', '    function setUint(uint value) public {\n', '        _value = value;\n', '    }\n', '}\n', 'interface tokenRecipient { \n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData)external;\n', '    \n', '}\n', '\n', ' /**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', '\n', 'contract Ubricoin is UbricoinPresale,Ownable,Haltable, UbricoinCrowdsale,Upgradeable {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    // Public variables of the token\n', "    string public name ='Ubricoin';\n", "    string public symbol ='UBN';\n", '    string public version= "1.0";\n', '    uint public decimals=18;\n', '    // 18 decimals is the strongly suggested default, avoid changing it\n', '    uint public totalSupply = 10000000000;\n', '    uint256 public constant RATE = 1000;\n', '    uint256 initialSupply;\n', '\n', '    \n', '    \n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    \n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '    \n', '    uint256 public AVAILABLE_AIRDROP_SUPPLY = 100000000* decimals; // 100% Released at Token distribution\n', '    uint256 public grandTotalClaimed = 1;\n', '    uint256 public startTime;\n', '    \n', '    struct Allocation {\n', '    uint8 AllocationSupply; // Type of allocation\n', '    uint256 totalAllocated; // Total tokens allocated\n', '    uint256 amountClaimed;  // Total tokens claimed\n', '}\n', '    \n', '    \n', '    mapping (address => Allocation) public allocations;\n', '\n', '    // List of admins\n', '    mapping (address => bool) public airdropAdmins;\n', '\n', '    // Keeps track of whether or not an Ubricoin airdrop has been made to a particular address\n', '    mapping (address => bool) public airdrops;\n', '\n', '  modifier onlyOwnerOrAdmin() {\n', '    require(msg.sender == owner || airdropAdmins[msg.sender]);\n', '    _;\n', '}\n', '    \n', '    \n', '    \n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '        bytes32 public currentChallenge;                         // The coin starts with a challenge\n', '        uint256 public timeOfLastProof;                             // Variable to keep track of when rewards were given\n', '        uint256 public difficulty = 10**32;                         // Difficulty starts reasonably low\n', '\n', '     \n', '    function proofOfWork(uint256 nonce) public{\n', '        bytes8 n = bytes8(keccak256(abi.encodePacked(nonce, currentChallenge)));    // Generate a random hash based on input\n', "        require(n >= bytes8(difficulty));                   // Check if it's under the difficulty\n", '\n', '        uint256 timeSinceLastProof = (now - timeOfLastProof);  // Calculate time since last reward was given\n', '        require(timeSinceLastProof >=  5 seconds);         // Rewards cannot be given too quickly\n', '        balanceOf[msg.sender] += timeSinceLastProof / 60 seconds;  // The reward to the winner grows by the minute\n', '\n', '        difficulty = difficulty * 10 minutes / timeSinceLastProof + 1;  // Adjusts the difficulty\n', '\n', '        timeOfLastProof = now;                              // Reset the counter\n', '        currentChallenge = keccak256(abi.encodePacked(nonce, currentChallenge, blockhash(block.number - 1)));  // Save a hash that will be used as the next proof\n', '    }\n', '\n', '\n', '   function () payable public whenNotPaused {\n', '        require(msg.value > 0);\n', '        uint256 tokens = msg.value.mul(RATE);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(tokens);\n', '        totalSupply = totalSupply.add(tokens);\n', '        owner.transfer(msg.value);\n', '}\n', '    \n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint256 _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '     function transfer(address _to, uint256 _value) public {\n', '\t\tbalanceOf[msg.sender] -= _value;\n', '\t\tbalanceOf[_to] += _value;\n', '\t}\n', '     \n', '   function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\n', '        return balanceOf[tokenOwner];\n', '        \n', '}\n', '\n', '   function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {\n', '        return allowance[tokenOwner][spender];\n', '}\n', '   \n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` on behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply -= _value;                      // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '  \n', '    function mintToken(address target, uint256 mintedAmount)private onlyOwner {\n', '        balanceOf[target] += mintedAmount;\n', '        totalSupply += mintedAmount;\n', '        emit Transfer(0, owner, mintedAmount);\n', '        emit Transfer(owner, target, mintedAmount);\n', '    }\n', '\n', '    function validPurchase() internal returns (bool) {\n', '    bool lessThanMaxInvestment = msg.value <= 1000 ether; // change the value to whatever you need\n', '    return validPurchase() && lessThanMaxInvestment;\n', '}\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n', "        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n", '        totalSupply -= _value;                              // Update totalSupply\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '    \n', '   /**\n', '    * @dev Add an airdrop admin\n', '    */\n', '  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n', '    airdropAdmins[_admin] = _isAdmin;\n', '  }\n', '\n', '  /**\n', '    * @dev perform a transfer of allocations\n', '    * @param _recipient is a list of recipients\n', '    */\n', '  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n', '    \n', '    uint airdropped;\n', '    for(uint256 i = 0; i< _recipient.length; i++)\n', '    {\n', '        if (!airdrops[_recipient[i]]) {\n', '          airdrops[_recipient[i]] = true;\n', '          Ubricoin.transfer(_recipient[i], 1 * decimals);\n', '          airdropped = airdropped.add(1 * decimals);\n', '        }\n', '    }\n', '    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n', '    totalSupply = totalSupply.sub(airdropped);\n', '    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n', '}\n', '    \n', '}']
