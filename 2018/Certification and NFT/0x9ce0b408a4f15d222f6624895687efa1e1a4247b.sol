['pragma solidity ^0.4.20;\n', '\n', 'library SafeMath {\n', '\n', '  /**0\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath32\n', ' * @dev SafeMath library implemented for uint32\n', ' */\n', 'library SafeMath32 {\n', '\n', '  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint32 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint32 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    uint32 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath16\n', ' * @dev SafeMath library implemented for uint16\n', ' */\n', 'library SafeMath16 {\n', '\n', '  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint16 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint16 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ETHERKUN {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', ' function ETHERKUN() public {\n', '    owner = msg.sender;\n', ' }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '    \n', '    using SafeMath for uint256;\n', '    uint cooldownTime = 10 minutes;\n', '    \n', '    struct kun {\n', '        uint price;\n', '        uint atk;\n', '        uint readyTime;\n', '    }\n', '    \n', '    kun[] public kuns;\n', '    \n', '    mapping (uint => address) public kunToOwner;\n', '    \n', '    function getKun() external {\n', '        uint id = kuns.push(kun(0, 0, now)) - 1;\n', '        kunToOwner[id] = msg.sender;\n', '    }\n', '    \n', '    //查询拥有的kun\n', '  function getKunsByOwner(address _owner) external view returns(uint[]) {\n', '    uint[] memory result = new uint[](kuns.length);\n', '    uint counter = 0;\n', '    for (uint i = 0; i < kuns.length; i++) {\n', '      if (kunToOwner[i] == _owner) {\n', '        result[counter] = i;\n', '        counter++;\n', '      }\n', '    }\n', '    return result;\n', '  }\n', '  \n', '  function getKunsNum() external view returns(uint) {\n', '    return kuns.length;\n', '  }\n', '  \n', '  //\n', '  function getBattleKuns(uint _price) external view returns(uint[]) {\n', '    uint[] memory result = new uint[](kuns.length);\n', '    uint counter = 0;\n', '    for (uint i = 0; i < kuns.length; i++) {\n', '      if (kuns[i].price > _price && kunToOwner[i] != msg.sender) {\n', '        result[counter] = i;\n', '        counter++;\n', '      }\n', '    }\n', '    return result;\n', '  }\n', '  \n', '  uint randNonce = 0;\n', '    //Evolution price\n', '    uint public testFee = 0.001 ether;\n', '  \n', '  event Evolution(address indexed owner, uint kunId,uint newAtk, uint oldAtk);\n', '  event KunSell(address indexed owner, uint kunId,uint price);\n', '  \n', '  function randMod() internal returns(uint) {\n', '    randNonce = randNonce.add(1);\n', '    return uint(keccak256(now, randNonce, block.blockhash(block.number - 1), block.coinbase)) % 100;\n', '  }\n', '  \n', '  //owner可以调整费率\n', '  function setTestFee(uint _fee) external onlyOwner {\n', '    testFee = _fee;\n', '  }\n', '  //检查必须是拥有者\n', '  modifier onlyOwnerOf(uint _kunId) {\n', '    require(msg.sender == kunToOwner[_kunId]);\n', '    _;\n', '  }\n', '  \n', '    //进入冷却 change to uint\n', '  function _triggerCooldown(kun storage _kun) internal {\n', '    _kun.readyTime = uint(now + cooldownTime);\n', '  }\n', '\n', '  //test逻辑\n', '  function feed1(uint _kunId) external onlyOwnerOf(_kunId) payable {\n', '    require(msg.value == testFee);\n', '    kun storage mykun = kuns[_kunId];\n', '    uint oldAtk = mykun.atk;\n', '    uint random = randMod();\n', '    if (random < 20) {\n', '        mykun.atk = mykun.atk.add(50);\n', '    } else if (random < 70) {\n', '        mykun.atk = mykun.atk.add(100);\n', '    } else if (random < 90) {\n', '        mykun.atk = mykun.atk.add(200);\n', '    } else {\n', '         mykun.atk = mykun.atk.add(500);\n', '    }\n', '    mykun.price = mykun.price.add(msg.value);\n', '    _triggerCooldown(mykun);\n', '    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\n', '  }\n', '  \n', '  function feed10(uint _kunId) external onlyOwnerOf(_kunId) payable {\n', '    require(msg.value == testFee * 10);\n', '    kun storage mykun = kuns[_kunId];\n', '    uint oldAtk = mykun.atk;\n', '    uint random = randMod();\n', '    if (random < 20) {\n', '        mykun.atk = mykun.atk.add(550);\n', '    } else if (random < 70) {\n', '        mykun.atk = mykun.atk.add(1100);\n', '    } else if (random < 90) {\n', '        mykun.atk = mykun.atk.add(2200);\n', '    } else {\n', '         mykun.atk = mykun.atk.add(5500);\n', '    }\n', '    mykun.price = mykun.price.add(msg.value);\n', '    _triggerCooldown(mykun);\n', '    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\n', '  }\n', '  \n', '  function feed50(uint _kunId) external onlyOwnerOf(_kunId) payable {\n', '    require(msg.value == testFee * 50);\n', '    kun storage mykun = kuns[_kunId];\n', '    uint oldAtk = mykun.atk;\n', '    uint random = randMod();\n', '    if (random < 20) {\n', '        mykun.atk = mykun.atk.add(2750);\n', '    } else if (random < 70) {\n', '        mykun.atk = mykun.atk.add(5500);\n', '    } else if (random < 90) {\n', '        mykun.atk = mykun.atk.add(11000);\n', '    } else {\n', '         mykun.atk = mykun.atk.add(27500);\n', '    }\n', '    mykun.price = mykun.price.add(msg.value);\n', '    _triggerCooldown(mykun);\n', '    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\n', '  }\n', '  \n', '  function feed100(uint _kunId) external onlyOwnerOf(_kunId) payable {\n', '    require(msg.value == testFee * 100);\n', '    kun storage mykun = kuns[_kunId];\n', '    uint oldAtk = mykun.atk;\n', '    uint random = randMod();\n', '    if (random < 20) {\n', '        mykun.atk = mykun.atk.add(6000);\n', '    } else if (random < 70) {\n', '        mykun.atk = mykun.atk.add(12000);\n', '    } else if (random < 90) {\n', '        mykun.atk = mykun.atk.add(24000);\n', '    } else {\n', '         mykun.atk = mykun.atk.add(60000);\n', '    }\n', '    mykun.price = mykun.price.add(msg.value);\n', '    _triggerCooldown(mykun);\n', '    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\n', '  }\n', '  \n', '  function feed100AndPay(uint _kunId) external onlyOwnerOf(_kunId) payable {\n', '    require(msg.value == testFee * 110);\n', '    kun storage mykun = kuns[_kunId];\n', '    uint oldAtk = mykun.atk;\n', '    mykun.atk = mykun.atk.add(60000);\n', '    mykun.price = mykun.price.add(testFee * 100);\n', '    owner.transfer(testFee * 10);\n', '    _triggerCooldown(mykun);\n', '    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\n', '  }\n', '    \n', '    //sellKun\n', '    function sellKun(uint _kunId) external onlyOwnerOf(_kunId) {\n', '        kun storage mykun = kuns[_kunId];\n', '        if(now > mykun.readyTime) {\n', '            msg.sender.transfer(mykun.price);\n', '             KunSell( msg.sender, _kunId, mykun.price);\n', '        } else{\n', '            uint award = mykun.price * 19 / 20;\n', '            msg.sender.transfer(award);\n', '            owner.transfer(mykun.price - award);\n', '             KunSell( msg.sender, _kunId, mykun.price * 19 / 20);\n', '        }\n', '        mykun.price = 0;\n', '        mykun.atk = 0;\n', '        kunToOwner[_kunId] = 0;\n', '    }\n', '    \n', '    event kunAttackResult(address indexed _from,uint atk1, address _to, uint atk2, uint random, uint price);\n', '  \n', '  //判断是否ready\n', '  function _isReady(kun storage _kun) internal view returns (bool) {\n', '      return (_kun.readyTime <= now);\n', '  }\n', '  \n', '  //attack\n', '  function attack(uint _kunId, uint _targetId) external onlyOwnerOf(_kunId) {\n', '    kun storage mykun = kuns[_kunId];\n', '    kun storage enemykun = kuns[_targetId]; \n', '    require(_isReady(enemykun));\n', '    require(enemykun.atk > 299 && mykun.atk > 0);\n', '    uint rand = randMod();\n', '    uint probability = mykun.atk * 100 /(mykun.atk + enemykun.atk) ;\n', '    \n', '    if (rand < probability) {\n', '        //win\n', '        msg.sender.transfer(enemykun.price);\n', '        kunAttackResult(msg.sender, mykun.atk, kunToOwner[_targetId], enemykun.atk, rand, enemykun.price);\n', '        enemykun.price = 0;\n', '        enemykun.atk = 0;\n', '        mykun.readyTime = now;\n', '    } else {\n', '        //loss\n', '        uint award1 = mykun.price*9/10;\n', '        kunToOwner[_targetId].transfer(award1);\n', '        owner.transfer(mykun.price - award1);\n', '        kunAttackResult(msg.sender, mykun.atk, kunToOwner[_targetId], enemykun.atk, rand, mykun.price*9/10);\n', '        mykun.price = 0;\n', '        mykun.atk = 0;\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.20;\n', '\n', 'library SafeMath {\n', '\n', '  /**0\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath32\n', ' * @dev SafeMath library implemented for uint32\n', ' */\n', 'library SafeMath32 {\n', '\n', '  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint32 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint32 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    uint32 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath16\n', ' * @dev SafeMath library implemented for uint16\n', ' */\n', 'library SafeMath16 {\n', '\n', '  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint16 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint16 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ETHERKUN {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', ' function ETHERKUN() public {\n', '    owner = msg.sender;\n', ' }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '    \n', '    using SafeMath for uint256;\n', '    uint cooldownTime = 10 minutes;\n', '    \n', '    struct kun {\n', '        uint price;\n', '        uint atk;\n', '        uint readyTime;\n', '    }\n', '    \n', '    kun[] public kuns;\n', '    \n', '    mapping (uint => address) public kunToOwner;\n', '    \n', '    function getKun() external {\n', '        uint id = kuns.push(kun(0, 0, now)) - 1;\n', '        kunToOwner[id] = msg.sender;\n', '    }\n', '    \n', '    //查询拥有的kun\n', '  function getKunsByOwner(address _owner) external view returns(uint[]) {\n', '    uint[] memory result = new uint[](kuns.length);\n', '    uint counter = 0;\n', '    for (uint i = 0; i < kuns.length; i++) {\n', '      if (kunToOwner[i] == _owner) {\n', '        result[counter] = i;\n', '        counter++;\n', '      }\n', '    }\n', '    return result;\n', '  }\n', '  \n', '  function getKunsNum() external view returns(uint) {\n', '    return kuns.length;\n', '  }\n', '  \n', '  //\n', '  function getBattleKuns(uint _price) external view returns(uint[]) {\n', '    uint[] memory result = new uint[](kuns.length);\n', '    uint counter = 0;\n', '    for (uint i = 0; i < kuns.length; i++) {\n', '      if (kuns[i].price > _price && kunToOwner[i] != msg.sender) {\n', '        result[counter] = i;\n', '        counter++;\n', '      }\n', '    }\n', '    return result;\n', '  }\n', '  \n', '  uint randNonce = 0;\n', '    //Evolution price\n', '    uint public testFee = 0.001 ether;\n', '  \n', '  event Evolution(address indexed owner, uint kunId,uint newAtk, uint oldAtk);\n', '  event KunSell(address indexed owner, uint kunId,uint price);\n', '  \n', '  function randMod() internal returns(uint) {\n', '    randNonce = randNonce.add(1);\n', '    return uint(keccak256(now, randNonce, block.blockhash(block.number - 1), block.coinbase)) % 100;\n', '  }\n', '  \n', '  //owner可以调整费率\n', '  function setTestFee(uint _fee) external onlyOwner {\n', '    testFee = _fee;\n', '  }\n', '  //检查必须是拥有者\n', '  modifier onlyOwnerOf(uint _kunId) {\n', '    require(msg.sender == kunToOwner[_kunId]);\n', '    _;\n', '  }\n', '  \n', '    //进入冷却 change to uint\n', '  function _triggerCooldown(kun storage _kun) internal {\n', '    _kun.readyTime = uint(now + cooldownTime);\n', '  }\n', '\n', '  //test逻辑\n', '  function feed1(uint _kunId) external onlyOwnerOf(_kunId) payable {\n', '    require(msg.value == testFee);\n', '    kun storage mykun = kuns[_kunId];\n', '    uint oldAtk = mykun.atk;\n', '    uint random = randMod();\n', '    if (random < 20) {\n', '        mykun.atk = mykun.atk.add(50);\n', '    } else if (random < 70) {\n', '        mykun.atk = mykun.atk.add(100);\n', '    } else if (random < 90) {\n', '        mykun.atk = mykun.atk.add(200);\n', '    } else {\n', '         mykun.atk = mykun.atk.add(500);\n', '    }\n', '    mykun.price = mykun.price.add(msg.value);\n', '    _triggerCooldown(mykun);\n', '    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\n', '  }\n', '  \n', '  function feed10(uint _kunId) external onlyOwnerOf(_kunId) payable {\n', '    require(msg.value == testFee * 10);\n', '    kun storage mykun = kuns[_kunId];\n', '    uint oldAtk = mykun.atk;\n', '    uint random = randMod();\n', '    if (random < 20) {\n', '        mykun.atk = mykun.atk.add(550);\n', '    } else if (random < 70) {\n', '        mykun.atk = mykun.atk.add(1100);\n', '    } else if (random < 90) {\n', '        mykun.atk = mykun.atk.add(2200);\n', '    } else {\n', '         mykun.atk = mykun.atk.add(5500);\n', '    }\n', '    mykun.price = mykun.price.add(msg.value);\n', '    _triggerCooldown(mykun);\n', '    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\n', '  }\n', '  \n', '  function feed50(uint _kunId) external onlyOwnerOf(_kunId) payable {\n', '    require(msg.value == testFee * 50);\n', '    kun storage mykun = kuns[_kunId];\n', '    uint oldAtk = mykun.atk;\n', '    uint random = randMod();\n', '    if (random < 20) {\n', '        mykun.atk = mykun.atk.add(2750);\n', '    } else if (random < 70) {\n', '        mykun.atk = mykun.atk.add(5500);\n', '    } else if (random < 90) {\n', '        mykun.atk = mykun.atk.add(11000);\n', '    } else {\n', '         mykun.atk = mykun.atk.add(27500);\n', '    }\n', '    mykun.price = mykun.price.add(msg.value);\n', '    _triggerCooldown(mykun);\n', '    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\n', '  }\n', '  \n', '  function feed100(uint _kunId) external onlyOwnerOf(_kunId) payable {\n', '    require(msg.value == testFee * 100);\n', '    kun storage mykun = kuns[_kunId];\n', '    uint oldAtk = mykun.atk;\n', '    uint random = randMod();\n', '    if (random < 20) {\n', '        mykun.atk = mykun.atk.add(6000);\n', '    } else if (random < 70) {\n', '        mykun.atk = mykun.atk.add(12000);\n', '    } else if (random < 90) {\n', '        mykun.atk = mykun.atk.add(24000);\n', '    } else {\n', '         mykun.atk = mykun.atk.add(60000);\n', '    }\n', '    mykun.price = mykun.price.add(msg.value);\n', '    _triggerCooldown(mykun);\n', '    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\n', '  }\n', '  \n', '  function feed100AndPay(uint _kunId) external onlyOwnerOf(_kunId) payable {\n', '    require(msg.value == testFee * 110);\n', '    kun storage mykun = kuns[_kunId];\n', '    uint oldAtk = mykun.atk;\n', '    mykun.atk = mykun.atk.add(60000);\n', '    mykun.price = mykun.price.add(testFee * 100);\n', '    owner.transfer(testFee * 10);\n', '    _triggerCooldown(mykun);\n', '    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\n', '  }\n', '    \n', '    //sellKun\n', '    function sellKun(uint _kunId) external onlyOwnerOf(_kunId) {\n', '        kun storage mykun = kuns[_kunId];\n', '        if(now > mykun.readyTime) {\n', '            msg.sender.transfer(mykun.price);\n', '             KunSell( msg.sender, _kunId, mykun.price);\n', '        } else{\n', '            uint award = mykun.price * 19 / 20;\n', '            msg.sender.transfer(award);\n', '            owner.transfer(mykun.price - award);\n', '             KunSell( msg.sender, _kunId, mykun.price * 19 / 20);\n', '        }\n', '        mykun.price = 0;\n', '        mykun.atk = 0;\n', '        kunToOwner[_kunId] = 0;\n', '    }\n', '    \n', '    event kunAttackResult(address indexed _from,uint atk1, address _to, uint atk2, uint random, uint price);\n', '  \n', '  //判断是否ready\n', '  function _isReady(kun storage _kun) internal view returns (bool) {\n', '      return (_kun.readyTime <= now);\n', '  }\n', '  \n', '  //attack\n', '  function attack(uint _kunId, uint _targetId) external onlyOwnerOf(_kunId) {\n', '    kun storage mykun = kuns[_kunId];\n', '    kun storage enemykun = kuns[_targetId]; \n', '    require(_isReady(enemykun));\n', '    require(enemykun.atk > 299 && mykun.atk > 0);\n', '    uint rand = randMod();\n', '    uint probability = mykun.atk * 100 /(mykun.atk + enemykun.atk) ;\n', '    \n', '    if (rand < probability) {\n', '        //win\n', '        msg.sender.transfer(enemykun.price);\n', '        kunAttackResult(msg.sender, mykun.atk, kunToOwner[_targetId], enemykun.atk, rand, enemykun.price);\n', '        enemykun.price = 0;\n', '        enemykun.atk = 0;\n', '        mykun.readyTime = now;\n', '    } else {\n', '        //loss\n', '        uint award1 = mykun.price*9/10;\n', '        kunToOwner[_targetId].transfer(award1);\n', '        owner.transfer(mykun.price - award1);\n', '        kunAttackResult(msg.sender, mykun.atk, kunToOwner[_targetId], enemykun.atk, rand, mykun.price*9/10);\n', '        mykun.price = 0;\n', '        mykun.atk = 0;\n', '    }\n', '  }\n', '}']
