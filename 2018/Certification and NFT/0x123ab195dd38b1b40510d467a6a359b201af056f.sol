['pragma solidity ^0.4.13;\n', '\n', 'contract EIP20Interface {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @notice Transfer ownership from `owner` to `newOwner`\n', '    /// @param _newOwner The new contract owner\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        if (_newOwner != address(0)) {\n', '            newOwner = _newOwner;\n', '        }\n', '    }\n', '\n', '    /// @notice accept ownership of the contract\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract LegolasBase is Ownable {\n', '\n', '    mapping (address => uint256) public balances;\n', '\n', '    // Initial amount received from the pre-sale (doesn&#39;t include bonus)\n', '    mapping (address => uint256) public initialAllocations;\n', '    // Initial amount received from the pre-sale (includes bonus)\n', '    mapping (address => uint256) public allocations;\n', '    // False if part of the allocated amount is spent\n', '    mapping (uint256 => mapping(address => bool)) public eligibleForBonus;\n', '    // unspent allocated amount by period\n', '    mapping (uint256 => uint256) public unspentAmounts;\n', '    // List of founders addresses\n', '    mapping (address => bool) public founders;\n', '    // List of advisors addresses\n', '    mapping (address => bool) public advisors;\n', '\n', '    // Release dates for adviors: one twelfth released each month.\n', '    uint256[12] public ADVISORS_LOCK_DATES = [1521072000, 1523750400, 1526342400,\n', '                                       1529020800, 1531612800, 1534291200,\n', '                                       1536969600, 1539561600, 1542240000,\n', '                                       1544832000, 1547510400, 1550188800];\n', '    // Release dates for founders: After one year, one twelfth released each month.\n', '    uint256[12] public FOUNDERS_LOCK_DATES = [1552608000, 1555286400, 1557878400,\n', '                                       1560556800, 1563148800, 1565827200,\n', '                                       1568505600, 1571097600, 1573776000,\n', '                                       1576368000, 1579046400, 1581724800];\n', '\n', '    // Bonus dates: each 6 months during 2 years\n', '    uint256[4] public BONUS_DATES = [1534291200, 1550188800, 1565827200, 1581724800];\n', '\n', '    /// @param _address The address from which the locked amount will be retrieved\n', '    /// @return The amount locked for _address.\n', '    function getLockedAmount(address _address) internal view returns (uint256 lockedAmount) {\n', '        // Only founders and advisors have locks\n', '        if (!advisors[_address] && !founders[_address]) return 0;\n', '        // Determine release dates\n', '        uint256[12] memory lockDates = advisors[_address] ? ADVISORS_LOCK_DATES : FOUNDERS_LOCK_DATES;\n', '        // Determine how many twelfths are locked\n', '        for (uint8 i = 11; i >= 0; i--) {\n', '            if (now >= lockDates[i]) {\n', '                return (allocations[_address] / 12) * (11 - i);\n', '            }\n', '        }\n', '        return allocations[_address];\n', '    }\n', '\n', '    function updateBonusEligibity(address _from) internal {\n', '        if (now < BONUS_DATES[3] &&\n', '            initialAllocations[_from] > 0 &&\n', '            balances[_from] < allocations[_from]) {\n', '            for (uint8 i = 0; i < 4; i++) {\n', '                if (now < BONUS_DATES[i] && eligibleForBonus[BONUS_DATES[i]][_from]) {\n', '                    unspentAmounts[BONUS_DATES[i]] -= initialAllocations[_from];\n', '                    eligibleForBonus[BONUS_DATES[i]][_from] = false;\n', '                }\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract EIP20 is EIP20Interface, LegolasBase {\n', '\n', '    uint256 constant private MAX_UINT256 = 2**256 - 1;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '\n', '    /*\n', '    NOTE:\n', '    The following variables are OPTIONAL vanities. One does not have to include them.\n', '    They allow one to customise the token contract & in no way influences the core functionality.\n', '    Some wallets/interfaces might not even bother to look at this information.\n', '    */\n', '    string public name;                   //fancy name: eg Simon Bucks\n', '    uint8 public decimals;                //How many decimals to show.\n', '    string public symbol;                 //An identifier: eg SBX\n', '\n', '    function EIP20(\n', '        uint256 _initialAmount,\n', '        string _tokenName,\n', '        uint8 _decimalUnits,\n', '        string _tokenSymbol\n', '    ) public {\n', '        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n', '        totalSupply = _initialAmount;                        // Update total supply\n', '        name = _tokenName;                                   // Set the name for display purposes\n', '        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n', '        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        // Check locked amount\n', '        require(balances[msg.sender] - _value >= getLockedAmount(msg.sender));\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '\n', '        // Bonus lost if balance is lower than the original allocation\n', '        updateBonusEligibity(msg.sender);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value && allowance >= _value);\n', '\n', '        // Check locked amount\n', '        require(balances[_from] - _value >= getLockedAmount(_from));\n', '\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        if (allowance < MAX_UINT256) {\n', '            allowed[_from][msg.sender] -= _value;\n', '        }\n', '\n', '        // Bonus lost if balance is lower than the original allocation\n', '        updateBonusEligibity(_from);\n', '\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract Legolas is EIP20 {\n', '\n', '    // Standard ERC20 information\n', '    string  constant NAME = "LGO Token";\n', '    string  constant SYMBOL = "LGO";\n', '    uint8   constant DECIMALS = 8;\n', '    uint256 constant UNIT = 10**uint256(DECIMALS);\n', '\n', '    uint256 constant onePercent = 181415052000000;\n', '\n', '    // 5% for advisors\n', '    uint256 constant ADVISORS_AMOUNT =   5 * onePercent;\n', '    // 15% for founders\n', '    uint256 constant FOUNDERS_AMOUNT =  15 * onePercent;\n', '    // 60% sold in pre-sale\n', '    uint256 constant HOLDERS_AMOUNT  =  60 * onePercent;\n', '    // 20% reserve\n', '    uint256 constant RESERVE_AMOUNT  =  20 * onePercent;\n', '    // ADVISORS_AMOUNT + FOUNDERS_AMOUNT + HOLDERS_AMOUNT +RESERVE_AMOUNT\n', '    uint256 constant INITIAL_AMOUNT  = 100 * onePercent;\n', '    // 20% for holder bonus\n', '    uint256 constant BONUS_AMOUNT    =  20 * onePercent;\n', '    // amount already allocated to advisors\n', '    uint256 public advisorsAllocatedAmount = 0;\n', '    // amount already allocated to funders\n', '    uint256 public foundersAllocatedAmount = 0;\n', '    // amount already allocated to holders\n', '    uint256 public holdersAllocatedAmount = 0;\n', '    // list of all initial holders\n', '    address[] initialHolders;\n', '    // not distributed because the defaut value is false\n', '    mapping (uint256 => mapping(address => bool)) bonusNotDistributed;\n', '\n', '    event Allocate(address _address, uint256 _value);\n', '\n', '    function Legolas() EIP20( // EIP20 constructor\n', '        INITIAL_AMOUNT + BONUS_AMOUNT,\n', '        NAME,\n', '        DECIMALS,\n', '        SYMBOL\n', '    ) public {}\n', '\n', '    /// @param _address The address of the recipient\n', '    /// @param _amount Amount of the allocation\n', '    /// @param _type Type of the recipient. 0 for advisor, 1 for founders.\n', '    /// @return Whether the allocation was successful or not\n', '    function allocate(address _address, uint256 _amount, uint8 _type) public onlyOwner returns (bool success) {\n', '        // one allocations by address\n', '        require(allocations[_address] == 0);\n', '\n', '        if (_type == 0) { // advisor\n', '            // check allocated amount\n', '            require(advisorsAllocatedAmount + _amount <= ADVISORS_AMOUNT);\n', '            // increase allocated amount\n', '            advisorsAllocatedAmount += _amount;\n', '            // mark address as advisor\n', '            advisors[_address] = true;\n', '        } else if (_type == 1) { // founder\n', '            // check allocated amount\n', '            require(foundersAllocatedAmount + _amount <= FOUNDERS_AMOUNT);\n', '            // increase allocated amount\n', '            foundersAllocatedAmount += _amount;\n', '            // mark address as founder\n', '            founders[_address] = true;\n', '        } else {\n', '            // check allocated amount\n', '            require(holdersAllocatedAmount + _amount <= HOLDERS_AMOUNT + RESERVE_AMOUNT);\n', '            // increase allocated amount\n', '            holdersAllocatedAmount += _amount;\n', '        }\n', '        // set allocation\n', '        allocations[_address] = _amount;\n', '        initialAllocations[_address] = _amount;\n', '\n', '        // increase balance\n', '        balances[_address] += _amount;\n', '\n', '        // update variables for bonus distribution\n', '        for (uint8 i = 0; i < 4; i++) {\n', '            // increase unspent amount\n', '            unspentAmounts[BONUS_DATES[i]] += _amount;\n', '            // initialize bonus eligibility\n', '            eligibleForBonus[BONUS_DATES[i]][_address] = true;\n', '            bonusNotDistributed[BONUS_DATES[i]][_address] = true;\n', '        }\n', '\n', '        // add to initial holders list\n', '        initialHolders.push(_address);\n', '\n', '        Allocate(_address, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @param _address Holder address.\n', '    /// @param _bonusDate Date of the bonus to distribute.\n', '    /// @return Whether the bonus distribution was successful or not\n', '    function claimBonus(address _address, uint256 _bonusDate) public returns (bool success) {\n', '        /// bonus date must be past\n', '        require(_bonusDate <= now);\n', '        /// disrtibute bonus only once\n', '        require(bonusNotDistributed[_bonusDate][_address]);\n', '        /// disrtibute bonus only if eligible\n', '        require(eligibleForBonus[_bonusDate][_address]);\n', '\n', '        // calculate the bonus for one holded LGO\n', '        uint256 bonusByLgo = (BONUS_AMOUNT / 4) / unspentAmounts[_bonusDate];\n', '\n', '        // distribute the bonus\n', '        uint256 holderBonus = initialAllocations[_address] * bonusByLgo;\n', '        balances[_address] += holderBonus;\n', '        allocations[_address] += holderBonus;\n', '\n', '        // set bonus as distributed\n', '        bonusNotDistributed[_bonusDate][_address] = false;\n', '        return true;\n', '    }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract EIP20Interface {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @notice Transfer ownership from `owner` to `newOwner`\n', '    /// @param _newOwner The new contract owner\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        if (_newOwner != address(0)) {\n', '            newOwner = _newOwner;\n', '        }\n', '    }\n', '\n', '    /// @notice accept ownership of the contract\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract LegolasBase is Ownable {\n', '\n', '    mapping (address => uint256) public balances;\n', '\n', "    // Initial amount received from the pre-sale (doesn't include bonus)\n", '    mapping (address => uint256) public initialAllocations;\n', '    // Initial amount received from the pre-sale (includes bonus)\n', '    mapping (address => uint256) public allocations;\n', '    // False if part of the allocated amount is spent\n', '    mapping (uint256 => mapping(address => bool)) public eligibleForBonus;\n', '    // unspent allocated amount by period\n', '    mapping (uint256 => uint256) public unspentAmounts;\n', '    // List of founders addresses\n', '    mapping (address => bool) public founders;\n', '    // List of advisors addresses\n', '    mapping (address => bool) public advisors;\n', '\n', '    // Release dates for adviors: one twelfth released each month.\n', '    uint256[12] public ADVISORS_LOCK_DATES = [1521072000, 1523750400, 1526342400,\n', '                                       1529020800, 1531612800, 1534291200,\n', '                                       1536969600, 1539561600, 1542240000,\n', '                                       1544832000, 1547510400, 1550188800];\n', '    // Release dates for founders: After one year, one twelfth released each month.\n', '    uint256[12] public FOUNDERS_LOCK_DATES = [1552608000, 1555286400, 1557878400,\n', '                                       1560556800, 1563148800, 1565827200,\n', '                                       1568505600, 1571097600, 1573776000,\n', '                                       1576368000, 1579046400, 1581724800];\n', '\n', '    // Bonus dates: each 6 months during 2 years\n', '    uint256[4] public BONUS_DATES = [1534291200, 1550188800, 1565827200, 1581724800];\n', '\n', '    /// @param _address The address from which the locked amount will be retrieved\n', '    /// @return The amount locked for _address.\n', '    function getLockedAmount(address _address) internal view returns (uint256 lockedAmount) {\n', '        // Only founders and advisors have locks\n', '        if (!advisors[_address] && !founders[_address]) return 0;\n', '        // Determine release dates\n', '        uint256[12] memory lockDates = advisors[_address] ? ADVISORS_LOCK_DATES : FOUNDERS_LOCK_DATES;\n', '        // Determine how many twelfths are locked\n', '        for (uint8 i = 11; i >= 0; i--) {\n', '            if (now >= lockDates[i]) {\n', '                return (allocations[_address] / 12) * (11 - i);\n', '            }\n', '        }\n', '        return allocations[_address];\n', '    }\n', '\n', '    function updateBonusEligibity(address _from) internal {\n', '        if (now < BONUS_DATES[3] &&\n', '            initialAllocations[_from] > 0 &&\n', '            balances[_from] < allocations[_from]) {\n', '            for (uint8 i = 0; i < 4; i++) {\n', '                if (now < BONUS_DATES[i] && eligibleForBonus[BONUS_DATES[i]][_from]) {\n', '                    unspentAmounts[BONUS_DATES[i]] -= initialAllocations[_from];\n', '                    eligibleForBonus[BONUS_DATES[i]][_from] = false;\n', '                }\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract EIP20 is EIP20Interface, LegolasBase {\n', '\n', '    uint256 constant private MAX_UINT256 = 2**256 - 1;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '\n', '    /*\n', '    NOTE:\n', '    The following variables are OPTIONAL vanities. One does not have to include them.\n', '    They allow one to customise the token contract & in no way influences the core functionality.\n', '    Some wallets/interfaces might not even bother to look at this information.\n', '    */\n', '    string public name;                   //fancy name: eg Simon Bucks\n', '    uint8 public decimals;                //How many decimals to show.\n', '    string public symbol;                 //An identifier: eg SBX\n', '\n', '    function EIP20(\n', '        uint256 _initialAmount,\n', '        string _tokenName,\n', '        uint8 _decimalUnits,\n', '        string _tokenSymbol\n', '    ) public {\n', '        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n', '        totalSupply = _initialAmount;                        // Update total supply\n', '        name = _tokenName;                                   // Set the name for display purposes\n', '        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n', '        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        // Check locked amount\n', '        require(balances[msg.sender] - _value >= getLockedAmount(msg.sender));\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '\n', '        // Bonus lost if balance is lower than the original allocation\n', '        updateBonusEligibity(msg.sender);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value && allowance >= _value);\n', '\n', '        // Check locked amount\n', '        require(balances[_from] - _value >= getLockedAmount(_from));\n', '\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        if (allowance < MAX_UINT256) {\n', '            allowed[_from][msg.sender] -= _value;\n', '        }\n', '\n', '        // Bonus lost if balance is lower than the original allocation\n', '        updateBonusEligibity(_from);\n', '\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract Legolas is EIP20 {\n', '\n', '    // Standard ERC20 information\n', '    string  constant NAME = "LGO Token";\n', '    string  constant SYMBOL = "LGO";\n', '    uint8   constant DECIMALS = 8;\n', '    uint256 constant UNIT = 10**uint256(DECIMALS);\n', '\n', '    uint256 constant onePercent = 181415052000000;\n', '\n', '    // 5% for advisors\n', '    uint256 constant ADVISORS_AMOUNT =   5 * onePercent;\n', '    // 15% for founders\n', '    uint256 constant FOUNDERS_AMOUNT =  15 * onePercent;\n', '    // 60% sold in pre-sale\n', '    uint256 constant HOLDERS_AMOUNT  =  60 * onePercent;\n', '    // 20% reserve\n', '    uint256 constant RESERVE_AMOUNT  =  20 * onePercent;\n', '    // ADVISORS_AMOUNT + FOUNDERS_AMOUNT + HOLDERS_AMOUNT +RESERVE_AMOUNT\n', '    uint256 constant INITIAL_AMOUNT  = 100 * onePercent;\n', '    // 20% for holder bonus\n', '    uint256 constant BONUS_AMOUNT    =  20 * onePercent;\n', '    // amount already allocated to advisors\n', '    uint256 public advisorsAllocatedAmount = 0;\n', '    // amount already allocated to funders\n', '    uint256 public foundersAllocatedAmount = 0;\n', '    // amount already allocated to holders\n', '    uint256 public holdersAllocatedAmount = 0;\n', '    // list of all initial holders\n', '    address[] initialHolders;\n', '    // not distributed because the defaut value is false\n', '    mapping (uint256 => mapping(address => bool)) bonusNotDistributed;\n', '\n', '    event Allocate(address _address, uint256 _value);\n', '\n', '    function Legolas() EIP20( // EIP20 constructor\n', '        INITIAL_AMOUNT + BONUS_AMOUNT,\n', '        NAME,\n', '        DECIMALS,\n', '        SYMBOL\n', '    ) public {}\n', '\n', '    /// @param _address The address of the recipient\n', '    /// @param _amount Amount of the allocation\n', '    /// @param _type Type of the recipient. 0 for advisor, 1 for founders.\n', '    /// @return Whether the allocation was successful or not\n', '    function allocate(address _address, uint256 _amount, uint8 _type) public onlyOwner returns (bool success) {\n', '        // one allocations by address\n', '        require(allocations[_address] == 0);\n', '\n', '        if (_type == 0) { // advisor\n', '            // check allocated amount\n', '            require(advisorsAllocatedAmount + _amount <= ADVISORS_AMOUNT);\n', '            // increase allocated amount\n', '            advisorsAllocatedAmount += _amount;\n', '            // mark address as advisor\n', '            advisors[_address] = true;\n', '        } else if (_type == 1) { // founder\n', '            // check allocated amount\n', '            require(foundersAllocatedAmount + _amount <= FOUNDERS_AMOUNT);\n', '            // increase allocated amount\n', '            foundersAllocatedAmount += _amount;\n', '            // mark address as founder\n', '            founders[_address] = true;\n', '        } else {\n', '            // check allocated amount\n', '            require(holdersAllocatedAmount + _amount <= HOLDERS_AMOUNT + RESERVE_AMOUNT);\n', '            // increase allocated amount\n', '            holdersAllocatedAmount += _amount;\n', '        }\n', '        // set allocation\n', '        allocations[_address] = _amount;\n', '        initialAllocations[_address] = _amount;\n', '\n', '        // increase balance\n', '        balances[_address] += _amount;\n', '\n', '        // update variables for bonus distribution\n', '        for (uint8 i = 0; i < 4; i++) {\n', '            // increase unspent amount\n', '            unspentAmounts[BONUS_DATES[i]] += _amount;\n', '            // initialize bonus eligibility\n', '            eligibleForBonus[BONUS_DATES[i]][_address] = true;\n', '            bonusNotDistributed[BONUS_DATES[i]][_address] = true;\n', '        }\n', '\n', '        // add to initial holders list\n', '        initialHolders.push(_address);\n', '\n', '        Allocate(_address, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @param _address Holder address.\n', '    /// @param _bonusDate Date of the bonus to distribute.\n', '    /// @return Whether the bonus distribution was successful or not\n', '    function claimBonus(address _address, uint256 _bonusDate) public returns (bool success) {\n', '        /// bonus date must be past\n', '        require(_bonusDate <= now);\n', '        /// disrtibute bonus only once\n', '        require(bonusNotDistributed[_bonusDate][_address]);\n', '        /// disrtibute bonus only if eligible\n', '        require(eligibleForBonus[_bonusDate][_address]);\n', '\n', '        // calculate the bonus for one holded LGO\n', '        uint256 bonusByLgo = (BONUS_AMOUNT / 4) / unspentAmounts[_bonusDate];\n', '\n', '        // distribute the bonus\n', '        uint256 holderBonus = initialAllocations[_address] * bonusByLgo;\n', '        balances[_address] += holderBonus;\n', '        allocations[_address] += holderBonus;\n', '\n', '        // set bonus as distributed\n', '        bonusNotDistributed[_bonusDate][_address] = false;\n', '        return true;\n', '    }\n', '}']
