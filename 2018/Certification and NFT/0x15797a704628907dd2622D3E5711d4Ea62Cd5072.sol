['pragma solidity ^0.4.19;\n', '\n', 'library itMaps {\n', '    /* itMapAddressUint\n', '         address =>  Uint\n', '    */\n', '    struct entryAddressUint {\n', '    // Equal to the index of the key of this item in keys, plus 1.\n', '    uint keyIndex;\n', '    uint value;\n', '    }\n', '\n', '    struct itMapAddressUint {\n', '    mapping(address => entryAddressUint) data;\n', '    address[] keys;\n', '    }\n', '\n', '    function insert(itMapAddressUint storage self, address key, uint value) internal returns (bool replaced) {\n', '        entryAddressUint storage e = self.data[key];\n', '        e.value = value;\n', '        if (e.keyIndex > 0) {\n', '            return true;\n', '        } else {\n', '            e.keyIndex = ++self.keys.length;\n', '            self.keys[e.keyIndex - 1] = key;\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function remove(itMapAddressUint storage self, address key) internal returns (bool success) {\n', '        entryAddressUint storage e = self.data[key];\n', '        if (e.keyIndex == 0)\n', '        return false;\n', '\n', '        if (e.keyIndex <= self.keys.length) {\n', '            // Move an existing element into the vacated key slot.\n', '            self.data[self.keys[self.keys.length - 1]].keyIndex = e.keyIndex;\n', '            self.keys[e.keyIndex - 1] = self.keys[self.keys.length - 1];\n', '            self.keys.length -= 1;\n', '            delete self.data[key];\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function destroy(itMapAddressUint storage self) internal  {\n', '        for (uint i; i<self.keys.length; i++) {\n', '            delete self.data[ self.keys[i]];\n', '        }\n', '        delete self.keys;\n', '        return ;\n', '    }\n', '\n', '    function contains(itMapAddressUint storage self, address key) internal constant returns (bool exists) {\n', '        return self.data[key].keyIndex > 0;\n', '    }\n', '\n', '    function size(itMapAddressUint storage self) internal constant returns (uint) {\n', '        return self.keys.length;\n', '    }\n', '\n', '    function get(itMapAddressUint storage self, address key) internal constant returns (uint) {\n', '        return self.data[key].value;\n', '    }\n', '\n', '    function getKeyByIndex(itMapAddressUint storage self, uint idx) internal constant returns (address) {\n', '        return self.keys[idx];\n', '    }\n', '\n', '    function getValueByIndex(itMapAddressUint storage self, uint idx) internal constant returns (uint) {\n', '        return self.data[self.keys[idx]].value;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public constant returns (uint256 supply);\n', '    function balanceOf(address who) public constant returns (uint value);\n', '    function allowance(address owner, address spender) public constant returns (uint _allowance);\n', '\n', '    function transfer(address to, uint value) public returns (bool ok);\n', '    function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '    function approve(address spender, uint value) public returns (bool ok);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract TakeMyEther is ERC20{\n', '    using itMaps for itMaps.itMapAddressUint;\n', '\n', '    uint private initialSupply = 2800000;\n', '    uint public soldTokens = 0; //reduces when somebody returns money\n', '    string public constant name = "TakeMyEther";\n', '    string public constant symbol = "TMEther";\n', '    address public TakeMyEtherTeamAddress;\n', '\n', '    itMaps.itMapAddressUint tokenBalances; //amount of tokens each address holds\n', '    mapping (address => uint256) weiBalances; //amount of Wei, paid for tokens that smb holds. Used only before project completed.\n', '    mapping (address => uint256) weiBalancesReturned;\n', '\n', '    uint public percentsOfProjectComplete = 0;\n', '    uint public lastStageSubmitted;\n', '    uint public lastTimeWithdrawal;\n', '\n', '    uint public constant softCapTokensAmount = 500000;\n', '    uint public constant hardCapTokensAmount = 2250000;\n', '\n', '    uint public constant lockDownPeriod = 1 weeks;\n', '    uint public constant minimumStageDuration = 2 weeks;\n', '\n', '    bool public isICOfinalized = false;\n', '    bool public projectCompleted = false;\n', '\n', '    modifier onlyTeam {\n', '        if (msg.sender == TakeMyEtherTeamAddress) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    event StageSubmitted(uint last);\n', '    event etherPassedToTheTeam(uint weiAmount, uint when);\n', '    event etherWithdrawFromTheContract(address tokenHolder, uint numberOfTokensSoldBack, uint weiValue);\n', '    event Burned(address indexed from, uint amount);\n', '    event DividendsTransfered(address to, uint tokensAmount, uint weiAmount);\n', '\n', '    // ERC20 interface implementation\n', '\n', '    function totalSupply() public constant returns (uint256) {\n', '        return initialSupply;\n', '    }\n', '\n', '    function balanceOf(address tokenHolder) public view returns (uint256 balance) {\n', '        return tokenBalances.get(tokenHolder);\n', '    }\n', '\n', '    function allowance(address owner, address spender) public constant returns (uint256) {\n', '        return allowed[owner][spender];\n', '    }\n', '\n', '    function transfer(address to, uint value) public returns (bool success) {\n', '        if (tokenBalances.get(msg.sender) >= value && value > 0) {\n', '            if (to == address(this)) { // if you send even 1 token back to the contract, it will return all available funds to you\n', '                returnAllAvailableFunds();\n', '                return true;\n', '            }\n', '            else {\n', '                return transferTokensAndEtherValue(msg.sender, to, value, getAverageTokenPrice(msg.sender) * value);\n', '            }\n', '        } else return false;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n', '        if (tokenBalances.get(from)>=value && allowed[from][to] >= value && value > 0) {\n', '            if (transferTokensAndEtherValue(from, to, value, getAverageTokenPrice(from) * value)) {\n', '                allowed[from][to] -= value;\n', '                return true;\n', '            }\n', '            return false;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function approve(address spender, uint value) public returns (bool success) {\n', '        if ((value != 0) && (tokenBalances.get(msg.sender) >= value)){\n', '            allowed[msg.sender][spender] = value;\n', '            emit Approval(msg.sender, spender, value);\n', '            return true;\n', '        } else{\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Constructor, fallback, return funds\n', '\n', '    function TakeMyEther() public {\n', '        TakeMyEtherTeamAddress = msg.sender;\n', '        tokenBalances.insert(address(this), initialSupply);\n', '        lastStageSubmitted = now;\n', '    } //tested\n', '\n', '    function () public payable {\n', '        require (!projectCompleted);\n', '        uint weiToSpend = msg.value; //recieved value\n', '        uint currentPrice = getCurrentSellPrice(); //0.5 ETH or 1 ETH for 1000 tokens\n', '        uint valueInWei = 0;\n', '        uint valueToPass = 0;\n', '\n', '        if (weiToSpend < currentPrice) {// return ETH back if nothing to buy\n', '            return;\n', '        }\n', '\n', '        if (!tokenBalances.contains(msg.sender))\n', '        tokenBalances.insert(msg.sender, 0);\n', '\n', '        if (soldTokens < softCapTokensAmount) {\n', '            uint valueLeftForSoftCap = softCapTokensAmount - soldTokens;\n', '            valueToPass = weiToSpend / currentPrice;\n', '\n', '            if (valueToPass > valueLeftForSoftCap)\n', '            valueToPass = valueLeftForSoftCap;\n', '\n', '            valueInWei = valueToPass * currentPrice;\n', '            weiToSpend -= valueInWei;\n', '            soldTokens += valueToPass;\n', '            weiBalances[address(this)] += valueInWei;\n', '            transferTokensAndEtherValue(address(this), msg.sender, valueToPass, valueInWei);\n', '        }\n', '\n', '        currentPrice = getCurrentSellPrice(); //renew current price\n', '\n', '        if (weiToSpend < currentPrice) {\n', '            return;\n', '        }\n', '\n', '        if (soldTokens < hardCapTokensAmount && soldTokens >= softCapTokensAmount) {\n', '            uint valueLeftForHardCap = hardCapTokensAmount - soldTokens;\n', '            valueToPass = weiToSpend / currentPrice;\n', '\n', '            if (valueToPass > valueLeftForHardCap)\n', '            valueToPass = valueLeftForHardCap;\n', '\n', '            valueInWei = valueToPass * currentPrice;\n', '            weiToSpend -= valueInWei;\n', '            soldTokens += valueToPass;\n', '            weiBalances[address(this)] += valueInWei;\n', '            transferTokensAndEtherValue(address(this), msg.sender, valueToPass, valueInWei);\n', '        }\n', '\n', '        if (weiToSpend / 10**17 > 1) { //return unspent funds if they are greater than 0.1 ETH\n', '            msg.sender.transfer(weiToSpend);\n', '        }\n', '    }\n', '\n', '    function returnAllAvailableFunds() public {\n', '        require (tokenBalances.contains(msg.sender)); //you need to be a tokenHolder\n', '        require (!projectCompleted); //you can not return tokens after project is completed\n', '\n', '        uint avPrice = getAverageTokenPrice(msg.sender);\n', '        weiBalances[msg.sender] = getWeiAvailableToReturn(msg.sender); //depends on project completeness level\n', '\n', '        uint amountOfTokensToReturn = weiBalances[msg.sender] / avPrice;\n', '\n', '        require (amountOfTokensToReturn>0);\n', '\n', '        uint valueInWei = weiBalances[msg.sender];\n', '\n', '        transferTokensAndEtherValue(msg.sender, address(this), amountOfTokensToReturn, valueInWei);\n', '        emit etherWithdrawFromTheContract(msg.sender, amountOfTokensToReturn, valueInWei);\n', '        weiBalances[address(this)] -= valueInWei;\n', '        soldTokens -= amountOfTokensToReturn;\n', '        msg.sender.transfer(valueInWei);\n', '    }\n', '\n', '    // View functions\n', '\n', '    function getWeiBalance(address a) public view returns (uint) {\n', '        return weiBalances[a];\n', '    }\n', '\n', '    function getWeiAvailableToReturn(address holder) public view returns (uint amount) {\n', '        if (!isICOfinalized) return weiBalances[holder];\n', '        uint percentsBlocked = 0;\n', '        if (percentsOfProjectComplete > 10 && lastStageSubmitted + lockDownPeriod > now)\n', '        percentsBlocked = percentsOfProjectComplete - 10;\n', '        else\n', '        percentsBlocked = percentsOfProjectComplete;\n', '        return ((weiBalances[holder]  / 100) * (100 - percentsOfProjectComplete));\n', '    }\n', '\n', '    function getAverageTokenPrice(address holder) public view returns (uint avPriceInWei) {\n', '        return weiBalances[holder] / tokenBalances.get(holder);\n', '    }\n', '\n', '    function getNumberOfTokensForTheTeam() public view returns (uint amount) {\n', '        if (soldTokens == softCapTokensAmount) return soldTokens * 4; // 80%\n', '        if (soldTokens == hardCapTokensAmount) return soldTokens/4; // 20%\n', '        uint teamPercents = (80 - ((soldTokens - softCapTokensAmount) / ((hardCapTokensAmount - softCapTokensAmount)/60)));\n', '        return ((soldTokens / (100 - teamPercents)) * teamPercents); // tokens for the team\n', '    }\n', '\n', '    function getCurrentSellPrice() public view returns (uint priceInWei) {\n', '        if (!isICOfinalized) {\n', '            if (soldTokens < softCapTokensAmount) return 10**14 * 5 ; //this is equal to 0.0005 ETH\n', '            else return 10**15; //this is equal to 0.001 ETH\n', '        }\n', '        else { //if someone returns tokens after ICO finished, he can buy them until project is finished. But the price will depend on the project completeness level.\n', '            if (!projectCompleted) //if project is finished, no one can buy tokens\n', '            return (1 * 10**15 + 5 * (percentsOfProjectComplete * 10**13)) ; //each percent of completeness adds 5% to the tokenPrice.\n', '            else return 0; // there is no problem, because project is completed and fallback function won&#39;t work;\n', '        }\n', '    }\n', '\n', '    function getAvailableFundsForTheTeam() public view returns (uint amount) {\n', '        if (percentsOfProjectComplete == 100) return address(this).balance; // take all the rest\n', '        return (address(this).balance /(100 - (percentsOfProjectComplete - 10))) * 10; // take next 10% of funds, left on the contract.\n', '        /*So if, for example, percentsOfProjectComplete is 30 (increased by 10 from previous stage)\n', '        there are 80% of funds, left on the contract. So we devide balance by 80 to get 1%, and then multiply by 10*/\n', '    }\n', '\n', '    // Team functions\n', '\n', '    function finalizeICO() public onlyTeam {\n', '        require(!isICOfinalized); // this function can be called only once\n', '        if (soldTokens < hardCapTokensAmount)\n', '        require (lastStageSubmitted + minimumStageDuration < now); // ICO duration is at least 2 weeks\n', '        require(soldTokens >= softCapTokensAmount); //means, that the softCap Reached\n', '        uint tokensToPass = passTokensToTheTeam(); //but without weiValue, so the team can not withdraw ether by returning tokens to the contract\n', '        burnUndistributedTokens(tokensToPass);//tokensToPass); // undistributed tokens are destroyed\n', '        lastStageSubmitted = now;\n', '        emit StageSubmitted(lastStageSubmitted);\n', '        increaseProjectCompleteLevel(); // Now, team can withdraw 10% of funds raised to begin the project\n', '        passFundsToTheTeam();\n', '        isICOfinalized = true;\n', '    }\n', '\n', '    function submitNextStage() public onlyTeam returns (bool success) {\n', '        if (lastStageSubmitted + minimumStageDuration > now) return false; //Team submitted the completeness of previous stage more then 2 weeks before.\n', '        lastStageSubmitted = now;\n', '        emit StageSubmitted(lastStageSubmitted);\n', '        increaseProjectCompleteLevel();\n', '        return true;\n', '    }\n', '\n', '    function unlockFundsAndPassEther() public onlyTeam returns (bool success) {\n', '        require (lastTimeWithdrawal<=lastStageSubmitted);\n', '        if (lastStageSubmitted + lockDownPeriod > now) return false; //funds can not be passed until lockDownPeriod ends\n', '        if (percentsOfProjectComplete == 100 && !projectCompleted) {\n', '            projectCompleted = true;\n', '            if (tokenBalances.get(address(this))>0) {\n', '                uint toTransferAmount = tokenBalances.get(address(this));\n', '                tokenBalances.insert(TakeMyEtherTeamAddress, tokenBalances.get(address(this)) + tokenBalances.get(TakeMyEtherTeamAddress));\n', '                tokenBalances.insert(address(this), 0);\n', '                emit Transfer(address(this), TakeMyEtherTeamAddress, toTransferAmount);\n', '            }\n', '        }\n', '        passFundsToTheTeam();\n', '        return true;\n', '    }\n', '\n', '    // Receive dividends\n', '\n', '    function topUpWithEtherAndTokensForHolders(address tokensContractAddress, uint tokensAmount) public payable {\n', '        uint weiPerToken = msg.value / initialSupply;\n', '        uint tokensPerToken = 100 * tokensAmount / initialSupply; //Multiplication for more precise amount\n', '        uint weiAmountForHolder = 0;\n', '        uint tokensForHolder = 0;\n', '\n', '        for (uint i = 0; i< tokenBalances.size(); i += 1) {\n', '            address tokenHolder = tokenBalances.getKeyByIndex(i);\n', '            if (tokenBalances.get(tokenHolder)>0) {\n', '                weiAmountForHolder = tokenBalances.get(tokenHolder)*weiPerToken;\n', '                tokensForHolder = tokenBalances.get(tokenHolder) * tokensPerToken / 100; // Dividing because of the previous multiplication\n', '                tokenHolder.transfer(weiAmountForHolder); //This will pass a certain amount of ether to TakeMyEther platform tokenHolders\n', '                if (tokensContractAddress.call(bytes4(keccak256("authorizedTransfer(address,address,uint256)")), msg.sender, tokenHolder, tokensForHolder)) //This will pass a certain amount of tokens to TakeMyEther platform tokenHolders\n', '                emit DividendsTransfered(tokenHolder, tokensForHolder, weiAmountForHolder);\n', '            }\n', '        }\n', '    }\n', '\n', '    function passUndistributedEther() public {\n', '        require (projectCompleted);\n', '        uint weiPerToken = (address(this).balance * 100) / initialSupply;\n', '\n', '        for (uint i = 0; i< tokenBalances.size(); i += 1) {\n', '            address tokenHolder = tokenBalances.getKeyByIndex(i);\n', '            if (tokenBalances.get(tokenHolder)>0) {\n', '                uint weiAmountForHolder = (tokenBalances.get(tokenHolder)*weiPerToken)/100;\n', '                tokenHolder.transfer(weiAmountForHolder); //This will pass a certain amount of ether to TakeMyEther platform tokenHolders\n', '                emit DividendsTransfered(tokenHolder, 0, weiAmountForHolder);\n', '            }\n', '        }\n', '    } // When project is finished and Dividends are passed to the tokenHolders, there is some wei, left on the contract. Gradually, there can be a large amount of wei left, so it should be also distributed among tokenHolders.\n', '\n', '    // Internal functions\n', '\n', '    function transferTokensAndEtherValue(address from, address to, uint value, uint weiValue) internal returns (bool success){\n', '        if (tokenBalances.contains(from) && tokenBalances.get(from) >= value) {\n', '            tokenBalances.insert(to, tokenBalances.get(to) + value);\n', '            tokenBalances.insert(from, tokenBalances.get(from) - value);\n', '\n', '            weiBalances[from] -= weiValue;\n', '            weiBalances[to] += weiValue;\n', '\n', '            emit Transfer(from, to, value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function passFundsToTheTeam() internal {\n', '        uint weiAmount = getAvailableFundsForTheTeam();\n', '        TakeMyEtherTeamAddress.transfer(weiAmount);\n', '        emit etherPassedToTheTeam(weiAmount, now);\n', '        lastTimeWithdrawal = now;\n', '    }\n', '\n', '    function passTokensToTheTeam() internal returns (uint tokenAmount) { //This function passes tokens to the team without weiValue, so the team can not withdraw ether by returning tokens to the contract\n', '        uint tokensToPass = getNumberOfTokensForTheTeam();\n', '        tokenBalances.insert(TakeMyEtherTeamAddress, tokensToPass);\n', '        weiBalances[TakeMyEtherTeamAddress] = 0; // those tokens don&#39;t cost any ether\n', '        emit Transfer(address(this), TakeMyEtherTeamAddress, tokensToPass);\n', '        return tokensToPass;\n', '    }\n', '\n', '    function increaseProjectCompleteLevel() internal {\n', '        if (percentsOfProjectComplete<60)\n', '        percentsOfProjectComplete += 10;\n', '        else\n', '        percentsOfProjectComplete = 100;\n', '    }\n', '\n', '    function burnUndistributedTokens(uint tokensToPassToTheTeam) internal {\n', '        uint toBurn = initialSupply - (tokensToPassToTheTeam + soldTokens);\n', '        initialSupply -=  toBurn;\n', '        tokenBalances.insert(address(this), 0);\n', '        emit Burned(address(this), toBurn);\n', '    }\n', '}']