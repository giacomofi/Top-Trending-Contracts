['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract UserManager {\n', '\n', '    struct User {\n', '        string username;\n', '        bytes32 hashToProfilePicture;\n', '        bool exists;\n', '    }\n', '\n', '    uint public numberOfUsers;\n', '\n', '    mapping(string => bool) internal usernameExists;\n', '    mapping(address => User) public addressToUser;\n', '\n', '    mapping(bytes32 => bool) public profilePictureExists;\n', '    mapping(string => address) internal usernameToAddress;\n', '\n', '    event NewUser(address indexed user, string username, bytes32 profilePicture);\n', '\n', '    function register(string _username, bytes32 _hashToProfilePicture) public {\n', '        require(usernameExists[_username] == false || \n', '                keccak256(abi.encodePacked(getUsername(msg.sender))) == keccak256(abi.encodePacked(_username))\n', '        );\n', '\n', '        if (usernameExists[getUsername(msg.sender)]) {\n', '            // if he already had username, that username is free now\n', '            usernameExists[getUsername(msg.sender)] = false;\n', '        } else {\n', '            numberOfUsers++;\n', '            emit NewUser(msg.sender, _username, _hashToProfilePicture);\n', '        }\n', '\n', '        addressToUser[msg.sender] = User({\n', '            username: _username,\n', '            hashToProfilePicture: _hashToProfilePicture,\n', '            exists: true\n', '        });\n', '\n', '        usernameExists[_username] = true;\n', '        profilePictureExists[_hashToProfilePicture] = true;\n', '        usernameToAddress[_username] = msg.sender;\n', '    }\n', '\n', '    function changeProfilePicture(bytes32 _hashToProfilePicture) public {\n', '        require(addressToUser[msg.sender].exists, "User doesn&#39;t exists");\n', '\n', '        addressToUser[msg.sender].hashToProfilePicture = _hashToProfilePicture;\n', '    }\n', '\n', '    function getUserInfo(address _address) public view returns(string, bytes32) {\n', '        User memory user = addressToUser[_address];\n', '        return (user.username, user.hashToProfilePicture);\n', '    }\n', '\n', '    function getUsername(address _address) public view returns(string) {\n', '        return addressToUser[_address].username;\n', '    } \n', '\n', '    function getProfilePicture(address _address) public view returns(bytes32) {\n', '        return addressToUser[_address].hashToProfilePicture;\n', '    }\n', '\n', '    function isUsernameExists(string _username) public view returns(bool) {\n', '        return usernameExists[_username];\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', 'contract AssetManager is Ownable {\n', '\n', '    struct Asset {\n', '        uint id;\n', '        uint packId;\n', '        /// atributes field is going to be 3 digit uint where every digit can be "1" or "2"\n', '        /// 1st digit will tell us if asset is background 1 - true / 2 - false\n', '        /// 2nd digit will tell us if rotation is enabled 1 - true / 2 - false\n', '        /// 3rd digit will tell us if scaling  is enabled 1 - true / 2 - false\n', '        uint attributes;\n', '        bytes32 ipfsHash; // image\n', '    }\n', '\n', '    struct AssetPack {\n', '        bytes32 packCover;\n', '        uint[] assetIds;\n', '        address creator;\n', '        uint price;\n', '        string ipfsHash; // containing title and description\n', '    }\n', '\n', '    uint public numberOfAssets;\n', '    uint public numberOfAssetPacks;\n', '\n', '    Asset[] public assets;\n', '    AssetPack[] public assetPacks;\n', '\n', '    UserManager public userManager;\n', '\n', '    mapping(address => uint) public artistBalance;\n', '    mapping(bytes32 => bool) public hashExists;\n', '\n', '    mapping(address => uint[]) public createdAssetPacks;\n', '    mapping(address => uint[]) public boughtAssetPacks;\n', '    mapping(address => mapping(uint => bool)) public hasPermission;\n', '    mapping(uint => address) public approvedTakeover;\n', '\n', '    event AssetPackCreated(uint indexed id, address indexed owner);\n', '    event AssetPackBought(uint indexed id, address indexed buyer);\n', '\n', '    function addUserManager(address _userManager) public onlyOwner {\n', '        require(userManager == address(0));\n', '\n', '        userManager = UserManager(_userManager);\n', '    }\n', '\n', '    /// @notice Function to create assetpack\n', '    /// @param _packCover is cover image for asset pack\n', '    /// @param _attributes is array of attributes\n', '    /// @param _ipfsHashes is array containing all ipfsHashes for assets we&#39;d like to put in pack\n', '    /// @param _packPrice is price for total assetPack (every asset will have average price)\n', '    /// @param _ipfsHash ipfs hash containing title and description in json format\n', '    function createAssetPack(\n', '        bytes32 _packCover, \n', '        uint[] _attributes, \n', '        bytes32[] _ipfsHashes, \n', '        uint _packPrice,\n', '        string _ipfsHash) public {\n', '        \n', '        require(_ipfsHashes.length > 0);\n', '        require(_ipfsHashes.length < 50);\n', '        require(_attributes.length == _ipfsHashes.length);\n', '\n', '        uint[] memory ids = new uint[](_ipfsHashes.length);\n', '\n', '        for (uint i = 0; i < _ipfsHashes.length; i++) {\n', '            ids[i] = createAsset(_attributes[i], _ipfsHashes[i], numberOfAssetPacks);\n', '        }\n', '\n', '        assetPacks.push(AssetPack({\n', '            packCover: _packCover,\n', '            assetIds: ids,\n', '            creator: msg.sender,\n', '            price: _packPrice,\n', '            ipfsHash: _ipfsHash\n', '        }));\n', '\n', '        createdAssetPacks[msg.sender].push(numberOfAssetPacks);\n', '        numberOfAssetPacks++;\n', '\n', '        emit AssetPackCreated(numberOfAssetPacks-1, msg.sender);\n', '    }\n', '\n', '    /// @notice Function which creates an asset\n', '    /// @param _attributes is meta info for asset\n', '    /// @param _ipfsHash is ipfsHash to image of asset\n', '    function createAsset(uint _attributes, bytes32 _ipfsHash, uint _packId) internal returns(uint) {\n', '        uint id = numberOfAssets;\n', '\n', '        require(isAttributesValid(_attributes), "Attributes are not valid.");\n', '\n', '        assets.push(Asset({\n', '            id : id,\n', '            packId: _packId,\n', '            attributes: _attributes,\n', '            ipfsHash : _ipfsHash\n', '        }));\n', '\n', '        numberOfAssets++;\n', '\n', '        return id;\n', '    }\n', '\n', '    /// @notice Method to buy right to use specific asset pack\n', '    /// @param _to is address of user who will get right on that asset pack\n', '    /// @param _assetPackId is id of asset pack user is buying\n', '    function buyAssetPack(address _to, uint _assetPackId) public payable {\n', '        require(!checkHasPermissionForPack(_to, _assetPackId));\n', '\n', '        AssetPack memory assetPack = assetPacks[_assetPackId];\n', '        require(msg.value >= assetPack.price);\n', '        // if someone wants to pay more money for asset pack, we will give all of it to creator\n', '        artistBalance[assetPack.creator] += msg.value * 95 / 100;\n', '        artistBalance[owner] += msg.value * 5 / 100;\n', '        boughtAssetPacks[_to].push(_assetPackId);\n', '        hasPermission[_to][_assetPackId] = true;\n', '\n', '        emit AssetPackBought(_assetPackId, _to);\n', '    }\n', '\n', '    /// @notice Change price of asset pack\n', '    /// @param _assetPackId is id of asset pack for changing price\n', '    /// @param _newPrice is new price for that asset pack\n', '    function changeAssetPackPrice(uint _assetPackId, uint _newPrice) public {\n', '        require(assetPacks[_assetPackId].creator == msg.sender);\n', '\n', '        assetPacks[_assetPackId].price = _newPrice;\n', '    }\n', '\n', '    /// @notice Approve address to become creator of that pack\n', '    /// @param _assetPackId id of asset pack for other address to claim\n', '    /// @param _newCreator address that will be able to claim that asset pack\n', '    function approveTakeover(uint _assetPackId, address _newCreator) public {\n', '        require(assetPacks[_assetPackId].creator == msg.sender);\n', '\n', '        approvedTakeover[_assetPackId] = _newCreator;\n', '    }\n', '\n', '    /// @notice claim asset pack that is previously approved by creator\n', '    /// @param _assetPackId id of asset pack that is changing creator\n', '    function claimAssetPack(uint _assetPackId) public {\n', '        require(approvedTakeover[_assetPackId] == msg.sender);\n', '        \n', '        approvedTakeover[_assetPackId] = address(0);\n', '        assetPacks[_assetPackId].creator = msg.sender;\n', '    }\n', '\n', '    ///@notice Function where all artists can withdraw their funds\n', '    function withdraw() public {\n', '        uint amount = artistBalance[msg.sender];\n', '        artistBalance[msg.sender] = 0;\n', '\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    /// @notice Function to fetch total number of assets\n', '    /// @return numberOfAssets\n', '    function getNumberOfAssets() public view returns (uint) {\n', '        return numberOfAssets;\n', '    }\n', '\n', '    /// @notice Function to fetch total number of assetpacks\n', '    /// @return uint numberOfAssetPacks\n', '    function getNumberOfAssetPacks() public view returns(uint) {\n', '        return numberOfAssetPacks;\n', '    }\n', '\n', '    /// @notice Function to check if user have permission (owner / bought) for pack\n', '    /// @param _address is address of user\n', '    /// @param _packId is id of pack\n', '    function checkHasPermissionForPack(address _address, uint _packId) public view returns (bool) {\n', '\n', '        return (assetPacks[_packId].creator == _address) || hasPermission[_address][_packId];\n', '    }\n', '\n', '    /// @notice Function to check does hash exist in mapping\n', '    /// @param _ipfsHash is bytes32 representation of hash\n', '    function checkHashExists(bytes32 _ipfsHash) public view returns (bool) {\n', '        return hashExists[_ipfsHash];\n', '    }\n', '\n', '    /// @notice method that gets all unique packs from array of assets\n', '    function pickUniquePacks(uint[] assetIds) public view returns (uint[]) {\n', '        require(assetIds.length > 0);\n', '\n', '        uint[] memory packs = new uint[](assetIds.length);\n', '        uint packsCount = 0;\n', '        \n', '        for (uint i = 0; i < assetIds.length; i++) {\n', '            Asset memory asset = assets[assetIds[i]];\n', '            bool exists = false;\n', '\n', '            for (uint j = 0; j < packsCount; j++) {\n', '                if (asset.packId == packs[j]) {\n', '                    exists = true;\n', '                }\n', '            }\n', '\n', '            if (!exists) {\n', '                packs[packsCount] = asset.packId;\n', '                packsCount++;\n', '            }\n', '        }\n', '\n', '        uint[] memory finalPacks = new uint[](packsCount);\n', '        for (i = 0; i < packsCount; i++) {\n', '            finalPacks[i] = packs[i];\n', '        }\n', '\n', '        return finalPacks;\n', '    }\n', '\n', '    /// @notice Method to get all info for an asset\n', '    /// @param id is id of asset\n', '    /// @return All data for an asset\n', '    function getAssetInfo(uint id) public view returns (uint, uint, uint, bytes32) {\n', '        require(id >= 0);\n', '        require(id < numberOfAssets);\n', '        Asset memory asset = assets[id];\n', '\n', '        return (asset.id, asset.packId, asset.attributes, asset.ipfsHash);\n', '    }\n', '\n', '    /// @notice method returns all asset packs created by _address\n', '    /// @param _address is creator address\n', '    function getAssetPacksUserCreated(address _address) public view returns(uint[]) {\n', '        return createdAssetPacks[_address];\n', '    }\n', '\n', '    /// @notice Function to get ipfsHash for selected asset\n', '    /// @param _id is id of asset we&#39;d like to get ipfs hash\n', '    /// @return string representation of ipfs hash of that asset\n', '    function getAssetIpfs(uint _id) public view returns (bytes32) {\n', '        require(_id < numberOfAssets);\n', '        \n', '        return assets[_id].ipfsHash;\n', '    }\n', '\n', '    /// @notice Function to get attributes for selected asset\n', '    /// @param _id is id of asset we&#39;d like to get ipfs hash\n', '    /// @return uint representation of attributes of that asset\n', '    function getAssetAttributes(uint _id) public view returns (uint) {\n', '        require(_id < numberOfAssets);\n', '        \n', '        return assets[_id].attributes;\n', '    }\n', '\n', '    /// @notice Function to get array of ipfsHashes for specific assets\n', '    /// @dev need for data parsing on frontend efficiently\n', '    /// @param _ids is array of ids\n', '    /// @return bytes32 array of hashes\n', '    function getIpfsForAssets(uint[] _ids) public view returns (bytes32[]) {\n', '        bytes32[] memory hashes = new bytes32[](_ids.length);\n', '        for (uint i = 0; i < _ids.length; i++) {\n', '            Asset memory asset = assets[_ids[i]];\n', '            hashes[i] = asset.ipfsHash;\n', '        }\n', '\n', '        return hashes;\n', '    }\n', '\n', '    /// @notice method that returns attributes for many assets\n', '    function getAttributesForAssets(uint[] _ids) public view returns(uint[]) {\n', '        uint[] memory attributes = new uint[](_ids.length);\n', '        \n', '        for (uint i = 0; i < _ids.length; i++) {\n', '            Asset memory asset = assets[_ids[i]];\n', '            attributes[i] = asset.attributes;\n', '        }\n', '        return attributes;\n', '    }\n', '\n', '    /// @notice Function to get ipfs hash and id for all assets in one asset pack\n', '    /// @param _assetPackId is id of asset pack\n', '    /// @return two arrays with data\n', '    function getAssetPackData(uint _assetPackId) public view \n', '    returns(bytes32, address, uint, uint[], uint[], bytes32[], string, string, bytes32) {\n', '        require(_assetPackId < numberOfAssetPacks);\n', '\n', '        AssetPack memory assetPack = assetPacks[_assetPackId];\n', '        bytes32[] memory hashes = new bytes32[](assetPack.assetIds.length);\n', '\n', '        for (uint i = 0; i < assetPack.assetIds.length; i++) {\n', '            hashes[i] = getAssetIpfs(assetPack.assetIds[i]);\n', '        }\n', '\n', '        uint[] memory attributes = getAttributesForAssets(assetPack.assetIds);\n', '\n', '        return(\n', '            assetPack.packCover, \n', '            assetPack.creator, \n', '            assetPack.price, \n', '            assetPack.assetIds, \n', '            attributes, \n', '            hashes,\n', '            assetPack.ipfsHash,\n', '            userManager.getUsername(assetPack.creator),\n', '            userManager.getProfilePicture(assetPack.creator)\n', '        );\n', '    }\n', '\n', '    function getAssetPackPrice(uint _assetPackId) public view returns (uint) {\n', '        require(_assetPackId < numberOfAssetPacks);\n', '\n', '        return assetPacks[_assetPackId].price;\n', '    }\n', '\n', '    function getBoughtAssetPacks(address _address) public view returns (uint[]) {\n', '        return boughtAssetPacks[_address];\n', '    }\n', '\n', '    /// @notice Function to get cover image for every assetpack\n', '    /// @param _packIds is array of asset pack ids\n', '    /// @return bytes32[] array of hashes\n', '    function getCoversForPacks(uint[] _packIds) public view returns (bytes32[]) {\n', '        require(_packIds.length > 0);\n', '        bytes32[] memory covers = new bytes32[](_packIds.length);\n', '        for (uint i = 0; i < _packIds.length; i++) {\n', '            AssetPack memory assetPack = assetPacks[_packIds[i]];\n', '            covers[i] = assetPack.packCover;\n', '        }\n', '        return covers;\n', '    }\n', '\n', '    function isAttributesValid(uint attributes) private pure returns(bool) {\n', '        if (attributes < 100 || attributes > 999) {\n', '            return false;\n', '        }\n', '\n', '        uint num = attributes;\n', '\n', '        while (num > 0) {\n', '            if (num % 10 != 1 && num % 10 != 2) {\n', '                return false;\n', '            } \n', '            num = num / 10;\n', '        }\n', '\n', '        return true;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract UserManager {\n', '\n', '    struct User {\n', '        string username;\n', '        bytes32 hashToProfilePicture;\n', '        bool exists;\n', '    }\n', '\n', '    uint public numberOfUsers;\n', '\n', '    mapping(string => bool) internal usernameExists;\n', '    mapping(address => User) public addressToUser;\n', '\n', '    mapping(bytes32 => bool) public profilePictureExists;\n', '    mapping(string => address) internal usernameToAddress;\n', '\n', '    event NewUser(address indexed user, string username, bytes32 profilePicture);\n', '\n', '    function register(string _username, bytes32 _hashToProfilePicture) public {\n', '        require(usernameExists[_username] == false || \n', '                keccak256(abi.encodePacked(getUsername(msg.sender))) == keccak256(abi.encodePacked(_username))\n', '        );\n', '\n', '        if (usernameExists[getUsername(msg.sender)]) {\n', '            // if he already had username, that username is free now\n', '            usernameExists[getUsername(msg.sender)] = false;\n', '        } else {\n', '            numberOfUsers++;\n', '            emit NewUser(msg.sender, _username, _hashToProfilePicture);\n', '        }\n', '\n', '        addressToUser[msg.sender] = User({\n', '            username: _username,\n', '            hashToProfilePicture: _hashToProfilePicture,\n', '            exists: true\n', '        });\n', '\n', '        usernameExists[_username] = true;\n', '        profilePictureExists[_hashToProfilePicture] = true;\n', '        usernameToAddress[_username] = msg.sender;\n', '    }\n', '\n', '    function changeProfilePicture(bytes32 _hashToProfilePicture) public {\n', '        require(addressToUser[msg.sender].exists, "User doesn\'t exists");\n', '\n', '        addressToUser[msg.sender].hashToProfilePicture = _hashToProfilePicture;\n', '    }\n', '\n', '    function getUserInfo(address _address) public view returns(string, bytes32) {\n', '        User memory user = addressToUser[_address];\n', '        return (user.username, user.hashToProfilePicture);\n', '    }\n', '\n', '    function getUsername(address _address) public view returns(string) {\n', '        return addressToUser[_address].username;\n', '    } \n', '\n', '    function getProfilePicture(address _address) public view returns(bytes32) {\n', '        return addressToUser[_address].hashToProfilePicture;\n', '    }\n', '\n', '    function isUsernameExists(string _username) public view returns(bool) {\n', '        return usernameExists[_username];\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', 'contract AssetManager is Ownable {\n', '\n', '    struct Asset {\n', '        uint id;\n', '        uint packId;\n', '        /// atributes field is going to be 3 digit uint where every digit can be "1" or "2"\n', '        /// 1st digit will tell us if asset is background 1 - true / 2 - false\n', '        /// 2nd digit will tell us if rotation is enabled 1 - true / 2 - false\n', '        /// 3rd digit will tell us if scaling  is enabled 1 - true / 2 - false\n', '        uint attributes;\n', '        bytes32 ipfsHash; // image\n', '    }\n', '\n', '    struct AssetPack {\n', '        bytes32 packCover;\n', '        uint[] assetIds;\n', '        address creator;\n', '        uint price;\n', '        string ipfsHash; // containing title and description\n', '    }\n', '\n', '    uint public numberOfAssets;\n', '    uint public numberOfAssetPacks;\n', '\n', '    Asset[] public assets;\n', '    AssetPack[] public assetPacks;\n', '\n', '    UserManager public userManager;\n', '\n', '    mapping(address => uint) public artistBalance;\n', '    mapping(bytes32 => bool) public hashExists;\n', '\n', '    mapping(address => uint[]) public createdAssetPacks;\n', '    mapping(address => uint[]) public boughtAssetPacks;\n', '    mapping(address => mapping(uint => bool)) public hasPermission;\n', '    mapping(uint => address) public approvedTakeover;\n', '\n', '    event AssetPackCreated(uint indexed id, address indexed owner);\n', '    event AssetPackBought(uint indexed id, address indexed buyer);\n', '\n', '    function addUserManager(address _userManager) public onlyOwner {\n', '        require(userManager == address(0));\n', '\n', '        userManager = UserManager(_userManager);\n', '    }\n', '\n', '    /// @notice Function to create assetpack\n', '    /// @param _packCover is cover image for asset pack\n', '    /// @param _attributes is array of attributes\n', "    /// @param _ipfsHashes is array containing all ipfsHashes for assets we'd like to put in pack\n", '    /// @param _packPrice is price for total assetPack (every asset will have average price)\n', '    /// @param _ipfsHash ipfs hash containing title and description in json format\n', '    function createAssetPack(\n', '        bytes32 _packCover, \n', '        uint[] _attributes, \n', '        bytes32[] _ipfsHashes, \n', '        uint _packPrice,\n', '        string _ipfsHash) public {\n', '        \n', '        require(_ipfsHashes.length > 0);\n', '        require(_ipfsHashes.length < 50);\n', '        require(_attributes.length == _ipfsHashes.length);\n', '\n', '        uint[] memory ids = new uint[](_ipfsHashes.length);\n', '\n', '        for (uint i = 0; i < _ipfsHashes.length; i++) {\n', '            ids[i] = createAsset(_attributes[i], _ipfsHashes[i], numberOfAssetPacks);\n', '        }\n', '\n', '        assetPacks.push(AssetPack({\n', '            packCover: _packCover,\n', '            assetIds: ids,\n', '            creator: msg.sender,\n', '            price: _packPrice,\n', '            ipfsHash: _ipfsHash\n', '        }));\n', '\n', '        createdAssetPacks[msg.sender].push(numberOfAssetPacks);\n', '        numberOfAssetPacks++;\n', '\n', '        emit AssetPackCreated(numberOfAssetPacks-1, msg.sender);\n', '    }\n', '\n', '    /// @notice Function which creates an asset\n', '    /// @param _attributes is meta info for asset\n', '    /// @param _ipfsHash is ipfsHash to image of asset\n', '    function createAsset(uint _attributes, bytes32 _ipfsHash, uint _packId) internal returns(uint) {\n', '        uint id = numberOfAssets;\n', '\n', '        require(isAttributesValid(_attributes), "Attributes are not valid.");\n', '\n', '        assets.push(Asset({\n', '            id : id,\n', '            packId: _packId,\n', '            attributes: _attributes,\n', '            ipfsHash : _ipfsHash\n', '        }));\n', '\n', '        numberOfAssets++;\n', '\n', '        return id;\n', '    }\n', '\n', '    /// @notice Method to buy right to use specific asset pack\n', '    /// @param _to is address of user who will get right on that asset pack\n', '    /// @param _assetPackId is id of asset pack user is buying\n', '    function buyAssetPack(address _to, uint _assetPackId) public payable {\n', '        require(!checkHasPermissionForPack(_to, _assetPackId));\n', '\n', '        AssetPack memory assetPack = assetPacks[_assetPackId];\n', '        require(msg.value >= assetPack.price);\n', '        // if someone wants to pay more money for asset pack, we will give all of it to creator\n', '        artistBalance[assetPack.creator] += msg.value * 95 / 100;\n', '        artistBalance[owner] += msg.value * 5 / 100;\n', '        boughtAssetPacks[_to].push(_assetPackId);\n', '        hasPermission[_to][_assetPackId] = true;\n', '\n', '        emit AssetPackBought(_assetPackId, _to);\n', '    }\n', '\n', '    /// @notice Change price of asset pack\n', '    /// @param _assetPackId is id of asset pack for changing price\n', '    /// @param _newPrice is new price for that asset pack\n', '    function changeAssetPackPrice(uint _assetPackId, uint _newPrice) public {\n', '        require(assetPacks[_assetPackId].creator == msg.sender);\n', '\n', '        assetPacks[_assetPackId].price = _newPrice;\n', '    }\n', '\n', '    /// @notice Approve address to become creator of that pack\n', '    /// @param _assetPackId id of asset pack for other address to claim\n', '    /// @param _newCreator address that will be able to claim that asset pack\n', '    function approveTakeover(uint _assetPackId, address _newCreator) public {\n', '        require(assetPacks[_assetPackId].creator == msg.sender);\n', '\n', '        approvedTakeover[_assetPackId] = _newCreator;\n', '    }\n', '\n', '    /// @notice claim asset pack that is previously approved by creator\n', '    /// @param _assetPackId id of asset pack that is changing creator\n', '    function claimAssetPack(uint _assetPackId) public {\n', '        require(approvedTakeover[_assetPackId] == msg.sender);\n', '        \n', '        approvedTakeover[_assetPackId] = address(0);\n', '        assetPacks[_assetPackId].creator = msg.sender;\n', '    }\n', '\n', '    ///@notice Function where all artists can withdraw their funds\n', '    function withdraw() public {\n', '        uint amount = artistBalance[msg.sender];\n', '        artistBalance[msg.sender] = 0;\n', '\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    /// @notice Function to fetch total number of assets\n', '    /// @return numberOfAssets\n', '    function getNumberOfAssets() public view returns (uint) {\n', '        return numberOfAssets;\n', '    }\n', '\n', '    /// @notice Function to fetch total number of assetpacks\n', '    /// @return uint numberOfAssetPacks\n', '    function getNumberOfAssetPacks() public view returns(uint) {\n', '        return numberOfAssetPacks;\n', '    }\n', '\n', '    /// @notice Function to check if user have permission (owner / bought) for pack\n', '    /// @param _address is address of user\n', '    /// @param _packId is id of pack\n', '    function checkHasPermissionForPack(address _address, uint _packId) public view returns (bool) {\n', '\n', '        return (assetPacks[_packId].creator == _address) || hasPermission[_address][_packId];\n', '    }\n', '\n', '    /// @notice Function to check does hash exist in mapping\n', '    /// @param _ipfsHash is bytes32 representation of hash\n', '    function checkHashExists(bytes32 _ipfsHash) public view returns (bool) {\n', '        return hashExists[_ipfsHash];\n', '    }\n', '\n', '    /// @notice method that gets all unique packs from array of assets\n', '    function pickUniquePacks(uint[] assetIds) public view returns (uint[]) {\n', '        require(assetIds.length > 0);\n', '\n', '        uint[] memory packs = new uint[](assetIds.length);\n', '        uint packsCount = 0;\n', '        \n', '        for (uint i = 0; i < assetIds.length; i++) {\n', '            Asset memory asset = assets[assetIds[i]];\n', '            bool exists = false;\n', '\n', '            for (uint j = 0; j < packsCount; j++) {\n', '                if (asset.packId == packs[j]) {\n', '                    exists = true;\n', '                }\n', '            }\n', '\n', '            if (!exists) {\n', '                packs[packsCount] = asset.packId;\n', '                packsCount++;\n', '            }\n', '        }\n', '\n', '        uint[] memory finalPacks = new uint[](packsCount);\n', '        for (i = 0; i < packsCount; i++) {\n', '            finalPacks[i] = packs[i];\n', '        }\n', '\n', '        return finalPacks;\n', '    }\n', '\n', '    /// @notice Method to get all info for an asset\n', '    /// @param id is id of asset\n', '    /// @return All data for an asset\n', '    function getAssetInfo(uint id) public view returns (uint, uint, uint, bytes32) {\n', '        require(id >= 0);\n', '        require(id < numberOfAssets);\n', '        Asset memory asset = assets[id];\n', '\n', '        return (asset.id, asset.packId, asset.attributes, asset.ipfsHash);\n', '    }\n', '\n', '    /// @notice method returns all asset packs created by _address\n', '    /// @param _address is creator address\n', '    function getAssetPacksUserCreated(address _address) public view returns(uint[]) {\n', '        return createdAssetPacks[_address];\n', '    }\n', '\n', '    /// @notice Function to get ipfsHash for selected asset\n', "    /// @param _id is id of asset we'd like to get ipfs hash\n", '    /// @return string representation of ipfs hash of that asset\n', '    function getAssetIpfs(uint _id) public view returns (bytes32) {\n', '        require(_id < numberOfAssets);\n', '        \n', '        return assets[_id].ipfsHash;\n', '    }\n', '\n', '    /// @notice Function to get attributes for selected asset\n', "    /// @param _id is id of asset we'd like to get ipfs hash\n", '    /// @return uint representation of attributes of that asset\n', '    function getAssetAttributes(uint _id) public view returns (uint) {\n', '        require(_id < numberOfAssets);\n', '        \n', '        return assets[_id].attributes;\n', '    }\n', '\n', '    /// @notice Function to get array of ipfsHashes for specific assets\n', '    /// @dev need for data parsing on frontend efficiently\n', '    /// @param _ids is array of ids\n', '    /// @return bytes32 array of hashes\n', '    function getIpfsForAssets(uint[] _ids) public view returns (bytes32[]) {\n', '        bytes32[] memory hashes = new bytes32[](_ids.length);\n', '        for (uint i = 0; i < _ids.length; i++) {\n', '            Asset memory asset = assets[_ids[i]];\n', '            hashes[i] = asset.ipfsHash;\n', '        }\n', '\n', '        return hashes;\n', '    }\n', '\n', '    /// @notice method that returns attributes for many assets\n', '    function getAttributesForAssets(uint[] _ids) public view returns(uint[]) {\n', '        uint[] memory attributes = new uint[](_ids.length);\n', '        \n', '        for (uint i = 0; i < _ids.length; i++) {\n', '            Asset memory asset = assets[_ids[i]];\n', '            attributes[i] = asset.attributes;\n', '        }\n', '        return attributes;\n', '    }\n', '\n', '    /// @notice Function to get ipfs hash and id for all assets in one asset pack\n', '    /// @param _assetPackId is id of asset pack\n', '    /// @return two arrays with data\n', '    function getAssetPackData(uint _assetPackId) public view \n', '    returns(bytes32, address, uint, uint[], uint[], bytes32[], string, string, bytes32) {\n', '        require(_assetPackId < numberOfAssetPacks);\n', '\n', '        AssetPack memory assetPack = assetPacks[_assetPackId];\n', '        bytes32[] memory hashes = new bytes32[](assetPack.assetIds.length);\n', '\n', '        for (uint i = 0; i < assetPack.assetIds.length; i++) {\n', '            hashes[i] = getAssetIpfs(assetPack.assetIds[i]);\n', '        }\n', '\n', '        uint[] memory attributes = getAttributesForAssets(assetPack.assetIds);\n', '\n', '        return(\n', '            assetPack.packCover, \n', '            assetPack.creator, \n', '            assetPack.price, \n', '            assetPack.assetIds, \n', '            attributes, \n', '            hashes,\n', '            assetPack.ipfsHash,\n', '            userManager.getUsername(assetPack.creator),\n', '            userManager.getProfilePicture(assetPack.creator)\n', '        );\n', '    }\n', '\n', '    function getAssetPackPrice(uint _assetPackId) public view returns (uint) {\n', '        require(_assetPackId < numberOfAssetPacks);\n', '\n', '        return assetPacks[_assetPackId].price;\n', '    }\n', '\n', '    function getBoughtAssetPacks(address _address) public view returns (uint[]) {\n', '        return boughtAssetPacks[_address];\n', '    }\n', '\n', '    /// @notice Function to get cover image for every assetpack\n', '    /// @param _packIds is array of asset pack ids\n', '    /// @return bytes32[] array of hashes\n', '    function getCoversForPacks(uint[] _packIds) public view returns (bytes32[]) {\n', '        require(_packIds.length > 0);\n', '        bytes32[] memory covers = new bytes32[](_packIds.length);\n', '        for (uint i = 0; i < _packIds.length; i++) {\n', '            AssetPack memory assetPack = assetPacks[_packIds[i]];\n', '            covers[i] = assetPack.packCover;\n', '        }\n', '        return covers;\n', '    }\n', '\n', '    function isAttributesValid(uint attributes) private pure returns(bool) {\n', '        if (attributes < 100 || attributes > 999) {\n', '            return false;\n', '        }\n', '\n', '        uint num = attributes;\n', '\n', '        while (num > 0) {\n', '            if (num % 10 != 1 && num % 10 != 2) {\n', '                return false;\n', '            } \n', '            num = num / 10;\n', '        }\n', '\n', '        return true;\n', '    }\n', '}']
