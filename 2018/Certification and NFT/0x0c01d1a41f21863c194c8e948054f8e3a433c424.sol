['pragma solidity ^0.4.13;\n', '\n', 'contract ERC721 {\n', '    function implementsERC721() public pure returns (bool);\n', '    function totalSupply() public view returns (uint256 total);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner);\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function transfer(address _to, uint256 _tokenId) public;\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    // Optional\n', '    // function name() public view returns (string name);\n', '    // function symbol() public view returns (string symbol);\n', '    // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n', '    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n', '}\n', '\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract TombAccessControl {\n', '    address public ownerAddress;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == ownerAddress);\n', '        _;\n', '    }\n', '\n', '    function withdrawBalance() external onlyOwner {\n', '        address contractAddress = this;\n', '        ownerAddress.transfer(contractAddress.balance);\n', '    }\n', '}\n', '\n', 'contract TombBase is TombAccessControl {\n', '    using SafeMath for uint256;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    struct Tomb {\n', '        // The timestamp from the block when this tomb came into existence.\n', '        address sculptor;\n', '        string data;\n', '    }\n', '\n', '    // An array containing all existing tomb\n', '    Tomb[] tombs;\n', '    mapping (uint => address) public tombToOwner;\n', '    mapping (address => uint) ownerTombCount;\n', '    mapping (uint => address) tombApprovals;\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        tombToOwner[_tokenId] = _to;\n', '        ownerTombCount[_to] = ownerTombCount[_to].add(1);\n', '        if (_from != address(0)) {\n', '            ownerTombCount[_from] = ownerTombCount[_from].sub(1);\n', '            delete tombApprovals[_tokenId];\n', '        }\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function _createTombWithData(address _owner, string givenData) internal returns (uint) {\n', '        Tomb memory _tomb = Tomb({\n', '            data: givenData,\n', '            sculptor: _owner\n', '        });\n', '        uint256 newTombId = (tombs.push(_tomb)).sub(1);\n', '        _transfer(0, _owner, newTombId);\n', '        return newTombId;\n', '    }\n', '\n', '    function getTombByOwner(address _owner) external view returns(uint[]) {\n', '        uint[] memory result = new uint[](ownerTombCount[_owner]);\n', '        uint counter = 0;\n', '        for (uint i = 0; i < tombs.length; i++) {\n', '            if (tombToOwner[i] == _owner) {\n', '                result[counter] = i;\n', '                counter++;\n', '            }\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function getAllTombs() external view returns(uint[]) {\n', '        uint[] memory result = new uint[](tombs.length);\n', '        for (uint i = 0; i < tombs.length; i++) {\n', '            result[i] = i;\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function getTombDetail(uint index) external view returns(address, address, string) {\n', '        return (tombToOwner[index], tombs[index].sculptor, tombs[index].data);\n', '    }\n', '}\n', '\n', 'contract TombOwnership is ERC721, TombBase {\n', '    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '    string public name = "EtherFen";\n', '    string public symbol = "ETF";\n', '\n', '    function implementsERC721() public pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return tombs.length;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 _balance) {\n', '        return ownerTombCount[_owner];\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner) {\n', '        return tombToOwner[_tokenId];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\n', '        tombApprovals[_tokenId] = _to;\n', '        emit Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public\n', '    {\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        require(tombApprovals[_tokenId] == msg.sender);\n', '        require(tombToOwner[_tokenId] == _from);\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    modifier onlyOwnerOf(uint256 _tokenId) {\n', '        require(tombToOwner[_tokenId] == msg.sender);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract TombAction is TombOwnership {\n', '    uint256 currentPrice;\n', '\n', '    function buyAndCrave(string data) payable external {\n', '        if (msg.value < currentPrice) revert();\n', '        _createTombWithData(msg.sender, data);\n', '    }\n', ' \n', '    function changePrice(uint256 newPrice) external onlyOwner {\n', '        //gwei to ether\n', '        uint256 gweiUnit = 1000000000;\n', '        currentPrice = newPrice.mul(gweiUnit);\n', '    }\n', '\n', '    function getPrice() external view returns(uint256) {\n', '        return currentPrice;\n', '    }\n', '}\n', '\n', 'contract TombCore is TombAction {\n', '    function TombCore() public {\n', '        ownerAddress = msg.sender;\n', '        currentPrice = 0.02 ether;\n', '    }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract ERC721 {\n', '    function implementsERC721() public pure returns (bool);\n', '    function totalSupply() public view returns (uint256 total);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner);\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '    function transfer(address _to, uint256 _tokenId) public;\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    // Optional\n', '    // function name() public view returns (string name);\n', '    // function symbol() public view returns (string symbol);\n', '    // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n', '    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n', '}\n', '\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract TombAccessControl {\n', '    address public ownerAddress;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == ownerAddress);\n', '        _;\n', '    }\n', '\n', '    function withdrawBalance() external onlyOwner {\n', '        address contractAddress = this;\n', '        ownerAddress.transfer(contractAddress.balance);\n', '    }\n', '}\n', '\n', 'contract TombBase is TombAccessControl {\n', '    using SafeMath for uint256;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    struct Tomb {\n', '        // The timestamp from the block when this tomb came into existence.\n', '        address sculptor;\n', '        string data;\n', '    }\n', '\n', '    // An array containing all existing tomb\n', '    Tomb[] tombs;\n', '    mapping (uint => address) public tombToOwner;\n', '    mapping (address => uint) ownerTombCount;\n', '    mapping (uint => address) tombApprovals;\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        tombToOwner[_tokenId] = _to;\n', '        ownerTombCount[_to] = ownerTombCount[_to].add(1);\n', '        if (_from != address(0)) {\n', '            ownerTombCount[_from] = ownerTombCount[_from].sub(1);\n', '            delete tombApprovals[_tokenId];\n', '        }\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function _createTombWithData(address _owner, string givenData) internal returns (uint) {\n', '        Tomb memory _tomb = Tomb({\n', '            data: givenData,\n', '            sculptor: _owner\n', '        });\n', '        uint256 newTombId = (tombs.push(_tomb)).sub(1);\n', '        _transfer(0, _owner, newTombId);\n', '        return newTombId;\n', '    }\n', '\n', '    function getTombByOwner(address _owner) external view returns(uint[]) {\n', '        uint[] memory result = new uint[](ownerTombCount[_owner]);\n', '        uint counter = 0;\n', '        for (uint i = 0; i < tombs.length; i++) {\n', '            if (tombToOwner[i] == _owner) {\n', '                result[counter] = i;\n', '                counter++;\n', '            }\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function getAllTombs() external view returns(uint[]) {\n', '        uint[] memory result = new uint[](tombs.length);\n', '        for (uint i = 0; i < tombs.length; i++) {\n', '            result[i] = i;\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function getTombDetail(uint index) external view returns(address, address, string) {\n', '        return (tombToOwner[index], tombs[index].sculptor, tombs[index].data);\n', '    }\n', '}\n', '\n', 'contract TombOwnership is ERC721, TombBase {\n', '    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '    string public name = "EtherFen";\n', '    string public symbol = "ETF";\n', '\n', '    function implementsERC721() public pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return tombs.length;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 _balance) {\n', '        return ownerTombCount[_owner];\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner) {\n', '        return tombToOwner[_tokenId];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\n', '        tombApprovals[_tokenId] = _to;\n', '        emit Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public\n', '    {\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        require(tombApprovals[_tokenId] == msg.sender);\n', '        require(tombToOwner[_tokenId] == _from);\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    modifier onlyOwnerOf(uint256 _tokenId) {\n', '        require(tombToOwner[_tokenId] == msg.sender);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract TombAction is TombOwnership {\n', '    uint256 currentPrice;\n', '\n', '    function buyAndCrave(string data) payable external {\n', '        if (msg.value < currentPrice) revert();\n', '        _createTombWithData(msg.sender, data);\n', '    }\n', ' \n', '    function changePrice(uint256 newPrice) external onlyOwner {\n', '        //gwei to ether\n', '        uint256 gweiUnit = 1000000000;\n', '        currentPrice = newPrice.mul(gweiUnit);\n', '    }\n', '\n', '    function getPrice() external view returns(uint256) {\n', '        return currentPrice;\n', '    }\n', '}\n', '\n', 'contract TombCore is TombAction {\n', '    function TombCore() public {\n', '        ownerAddress = msg.sender;\n', '        currentPrice = 0.02 ether;\n', '    }\n', '}']
