['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' *\n', ' * @title McFly.aero - main contract\n', ' * @author Copyright (c) 2018 McFly.aero\n', ' * @author Dmitriy Khizhinskiy\n', ' * @author "MIT"\n', ' *\n', ' */ \n', '\n', '/**\n', ' * @title ERC20 Basic smart contract\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f89599968d9d94998a999782b89f95999194d69b9795">[email&#160;protected]</a>>"\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @author modification: Dmitriy Khizhinskiy @McFly.aero\n', ' */\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Ownable smart contract\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="91fcf0ffe4f4fdf0e3f0feebd1f6fcf0f8fdbff2fefc">[email&#160;protected]</a>>"\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @author modification: Dmitriy Khizhinskiy @McFly.aero\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '    address public candidate;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Allows the current owner to _request_ transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function requestOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        candidate = newOwner;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Allows the _NEW_ candidate to complete transfer control of the contract to him.\n', '    */\n', '    function confirmOwnership() public {\n', '        require(candidate == msg.sender);\n', '        owner = candidate;\n', '        OwnershipTransferred(owner, candidate);        \n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title MultiOwners smart contract\n', ' * @author Copyright (c) 2018 McFly.aero\n', ' * @author Dmitriy Khizhinskiy\n', ' * @author "MIT"\n', ' */\n', 'contract MultiOwners {\n', '\n', '    event AccessGrant(address indexed owner);\n', '    event AccessRevoke(address indexed owner);\n', '    \n', '    mapping(address => bool) owners;\n', '    address public publisher;\n', '\n', '\n', '    function MultiOwners() public {\n', '        owners[msg.sender] = true;\n', '        publisher = msg.sender;\n', '    }\n', '\n', '\n', '    modifier onlyOwner() { \n', '        require(owners[msg.sender] == true);\n', '        _; \n', '    }\n', '\n', '\n', '    function isOwner() constant public returns (bool) {\n', '        return owners[msg.sender] ? true : false;\n', '    }\n', '\n', '\n', '    function checkOwner(address maybe_owner) constant public returns (bool) {\n', '        return owners[maybe_owner] ? true : false;\n', '    }\n', '\n', '\n', '    function grant(address _owner) onlyOwner public {\n', '        owners[_owner] = true;\n', '        AccessGrant(_owner);\n', '    }\n', '\n', '\n', '    function revoke(address _owner) onlyOwner public {\n', '        require(_owner != publisher);\n', '        require(msg.sender != _owner);\n', '\n', '        owners[_owner] = false;\n', '        AccessRevoke(_owner);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="660b070813030a071407091c26010b070f0a4805090b">[email&#160;protected]</a>>"\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title BasicToken smart contract\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c0ada1aeb5a5aca1b2a1afba80a7ada1a9aceea3afad">[email&#160;protected]</a>>"\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @author modification: Dmitriy Khizhinskiy @McFly.aero\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    uint256 totalSupply_;\n', '\n', '    /**\n', '    * @dev total number of tokens in existence\n', '    */\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        // SafeMath.sub will throw if there is not enough balance.\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 smart contract\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b3ded2ddc6d6dfd2c1d2dcc9f3d4ded2dadf9dd0dcde">[email&#160;protected]</a>>"\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @author modification: Dmitriy Khizhinskiy @McFly.aero\n', ' */\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d7bab6b9a2b2bbb6a5b6b8ad97b0bab6bebbf9b4b8ba">[email&#160;protected]</a>>"\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @author modification: Dmitriy Khizhinskiy @McFly.aero\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '  \n', '    /** \n', '    * @dev Transfer tokens from one address to another\n', '    * @param _from address The address which you want to send tokens from\n', '    * @param _to address The address which you want to transfer to\n', '    * @param _value uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    *\n', '    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '    * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    * @param _owner address The address which owns the funds.\n', '    * @param _spender address The address which will spend the funds.\n', '    * @return A uint256 specifying the amount of tokens still available for the spender.\n', '    */\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '    *\n', '    * approve should be called when allowed[_spender] == 0. To increment\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _addedValue The amount of tokens to increase the allowance by.\n', '    */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '    *\n', '    * approve should be called when allowed[_spender] == 0. To decrement\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '    */\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Mintable token smart contract\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5538343b2030393427343a2f153238343c397b363a38">[email&#160;protected]</a>>"\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @author modification: Dmitriy Khizhinskiy @McFly.aero\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MintFinished();\n', '\n', '    bool public mintingFinished = false;\n', '\n', '    modifier canMint() {\n', '        require(!mintingFinished);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Function to mint tokens\n', '    * @param _to The address that will receive the minted tokens.\n', '    * @param _amount The amount of tokens to mint.\n', '    * @return A boolean that indicates if the operation was successful.\n', '    */\n', '    function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Mint(_to, _amount);\n', '        Transfer(address(0), _to, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Function to stop minting new tokens.\n', '    * @return True if the operation was successful.\n', '    */\n', '    function finishMinting() onlyOwner canMint public returns (bool) {\n', '        mintingFinished = true;\n', '        MintFinished();\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title McFly token smart contract\n', ' * @author Copyright (c) 2018 McFly.aero\n', ' * @author Dmitriy Khizhinskiy\n', ' * @author "MIT"\n', ' */\n', 'contract McFlyToken is MintableToken {\n', '    string public constant name = "McFlyToken";\n', '    string public constant symbol = "McFLY";\n', '    uint8 public constant decimals = 18;\n', '\n', '    /// @dev mapping for whitelist\n', '    mapping(address=>bool) whitelist;\n', '\n', '    /// @dev event throw when allowed to transfer address added to whitelist\n', '    /// @param from address\n', '    event AllowTransfer(address from);\n', '\n', '    /// @dev check for allowence of transfer\n', '    modifier canTransfer() {\n', '        require(mintingFinished || whitelist[msg.sender]);\n', '        _;        \n', '    }\n', '\n', '    /// @dev add address to whitelist\n', '    /// @param from address to add\n', '    function allowTransfer(address from) onlyOwner public {\n', '        whitelist[from] = true;\n', '        AllowTransfer(from);\n', '    }\n', '\n', '    /// @dev Do the transfer from address to address value\n', '    /// @param from address from\n', '    /// @param to address to\n', '    /// @param value uint256\n', '    function transferFrom(address from, address to, uint256 value) canTransfer public returns (bool) {\n', '        return super.transferFrom(from, to, value);\n', '    }\n', '\n', '    /// @dev Do the transfer from token address to "to" address value\n', '    /// @param to address to\n', '    /// @param value uint256 value\n', '    function transfer(address to, uint256 value) canTransfer public returns (bool) {\n', '        return super.transfer(to, value);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Haltable smart contract - controls owner access\n', ' * @author Copyright (c) 2018 McFly.aero\n', ' * @author Dmitriy Khizhinskiy\n', ' * @author "MIT"\n', ' */\n', 'contract Haltable is MultiOwners {\n', '    bool public halted;\n', '\n', '    modifier stopInEmergency {\n', '        require(!halted);\n', '        _;\n', '    }\n', '\n', '\n', '    modifier onlyInEmergency {\n', '        require(halted);\n', '        _;\n', '    }\n', '\n', '\n', '    /// @dev called by the owner on emergency, triggers stopped state\n', '    function halt() external onlyOwner {\n', '        halted = true;\n', '    }\n', '\n', '\n', '    /// @dev called by the owner on end of emergency, returns to normal state\n', '    function unhalt() external onlyOwner onlyInEmergency {\n', '        halted = false;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title McFly crowdsale smart contract \n', ' * @author Copyright (c) 2018 McFly.aero\n', ' * @author Dmitriy Khizhinskiy\n', ' * @author "MIT"\n', ' * @dev inherited from MultiOwners & Haltable\n', ' */\n', 'contract McFlyCrowd is MultiOwners, Haltable {\n', '    using SafeMath for uint256;\n', '\n', '    /// @dev Total ETH received during WAVES, TLP1.2 & window[1-5]\n', '    uint256 public counter_in; // tlp2\n', '    \n', '    /// @dev minimum ETH to partisipate in window 1-5\n', '    uint256 public minETHin = 1e18; // 1 ETH\n', '\n', '    /// @dev Token\n', '    McFlyToken public token;\n', '\n', '    /// @dev Withdraw wallet\n', '    address public wallet;\n', '\n', '    /// @dev start and end timestamp for TLP 1.2, other values callculated\n', '    uint256 public sT2; // startTimeTLP2\n', '    uint256 constant dTLP2 = 118 days; // days of TLP2\n', '    uint256 constant dBt = 60 days; // days between Windows\n', '    uint256 constant dW = 12 days; // 12 days for 3,4,5,6,7 windows;\n', '\n', '    /// @dev Cap maximum possible tokens for minting\n', '    uint256 public constant hardCapInTokens = 1800e24; // 1,800,000,000 MFL\n', '\n', '    /// @dev maximum possible tokens for sell \n', '    uint256 public constant mintCapInTokens = 1260e24; // 1,260,000,000 MFL\n', '\n', '    /// @dev tokens crowd within TLP2\n', '    uint256 public crowdTokensTLP2;\n', '\n', '    uint256 public _preMcFly;\n', '\n', '    /// @dev maximum possible tokens for fund minting\n', '    uint256 constant fundTokens = 270e24; // 270,000,000 MFL\n', '    uint256 public fundTotalSupply;\n', '    address public fundMintingAgent;\n', '\n', '    /// @dev maximum possible tokens to convert from WAVES\n', '    uint256 constant wavesTokens = 100e24; // 100,000,000 MFL\n', '    address public wavesAgent;\n', '    address public wavesGW;\n', '\n', '    /// @dev Vesting param for team, advisory, reserve.\n', '    uint256 constant VestingPeriodInSeconds = 30 days; // 24 month\n', '    uint256 constant VestingPeriodsCount = 24;\n', '\n', '    /// @dev Team 10%\n', '    uint256 constant _teamTokens = 180e24;\n', '    uint256 public teamTotalSupply;\n', '    address public teamWallet;\n', '\n', '    /// @dev Bounty 5% (2% + 3%)\n', '    /// @dev Bounty online 2%\n', '    uint256 constant _bountyOnlineTokens = 36e24;\n', '    address public bountyOnlineWallet;\n', '    address public bountyOnlineGW;\n', '\n', '    /// @dev Bounty offline 3%\n', '    uint256 constant _bountyOfflineTokens = 54e24;\n', '    address public bountyOfflineWallet;\n', '\n', '    /// @dev Advisory 5%\n', '    uint256 constant _advisoryTokens = 90e24;\n', '    uint256 public advisoryTotalSupply;\n', '    address public advisoryWallet;\n', '\n', '    /// @dev Reserved for future 9%\n', '    uint256 constant _reservedTokens = 162e24;\n', '    uint256 public reservedTotalSupply;\n', '    address public reservedWallet;\n', '\n', '    /// @dev AirDrop 1%\n', '    uint256 constant _airdropTokens = 18e24;\n', '    address public airdropWallet;\n', '    address public airdropGW;\n', '\n', '    /// @dev PreMcFly wallet (MFL)\n', '    address public preMcFlyWallet;\n', '\n', '    /// @dev Ppl structure for Win1-5\n', '    struct Ppl {\n', '        address addr;\n', '        uint256 amount;\n', '    }\n', '    mapping (uint32 => Ppl) public ppls;\n', '\n', '    /// @dev Window structure for Win1-5\n', '    struct Window {\n', '        bool active;\n', '        uint256 totalEthInWindow;\n', '        uint32 totalTransCnt;\n', '        uint32 refundIndex;\n', '        uint256 tokenPerWindow;\n', '    } \n', '    mapping (uint8 => Window) public ww;\n', '\n', '\n', '    /// @dev Events\n', '    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);\n', '    event TokenPurchaseInWindow(address indexed beneficiary, uint256 value, uint8 winnum, uint32 totalcnt, uint256 totaleth1);\n', '    event TransferOddEther(address indexed beneficiary, uint256 value);\n', '    event FundMinting(address indexed beneficiary, uint256 value);\n', '    event WithdrawVesting(address indexed beneficiary, uint256 period, uint256 value, uint256 valueTotal);\n', '    event TokenWithdrawAtWindow(address indexed beneficiary, uint256 value);\n', '    event SetFundMintingAgent(address newAgent);\n', '    event SetTeamWallet(address newTeamWallet);\n', '    event SetAdvisoryWallet(address newAdvisoryWallet);\n', '    event SetReservedWallet(address newReservedWallet);\n', '    event SetStartTimeTLP2(uint256 newStartTimeTLP2);\n', '    event SetMinETHincome(uint256 newMinETHin);\n', '    event NewWindow(uint8 winNum, uint256 amountTokensPerWin);\n', '    event TokenETH(uint256 totalEth, uint32 totalCnt);\n', '\n', '\n', '    /// @dev check for Non zero value\n', '    modifier validPurchase() {\n', '        require(msg.value != 0);\n', '        _;        \n', '    }\n', '\n', '\n', '    /**\n', '     * @dev conctructor of contract, set main params, create new token, do minting for some wallets\n', '     * @param _startTimeTLP2 - set date time of starting of TLP2 (main date!)\n', '     * @param _preMcFlyTotalSupply - set amount in wei total supply of previouse contract (MFL)\n', '     * @param _wallet - wallet for transfer ETH to it\n', '     * @param _wavesAgent - wallet for WAVES gw\n', '     * @param _wavesGW    - wallet for WAVES gw\n', '     * @param _fundMintingAgent - wallet who allowed to mint before TLP2\n', '     * @param _teamWallet - wallet for team vesting\n', '     * @param _bountyOnlineWallet - wallet for online bounty\n', '     * @param _bountyOnlineGW - wallet for online bounty GW\n', '     * @param _bountyOfflineWallet - wallet for offline bounty\n', '     * @param _advisoryWallet - wallet for advisory vesting\n', '     * @param _reservedWallet - wallet for reserved vesting\n', '     * @param _airdropWallet - wallet for airdrop\n', '     * @param _airdropGW - wallet for airdrop GW\n', '     * @param _preMcFlyWallet - wallet for transfer old MFL->McFly (once)\n', '     */\n', '    function McFlyCrowd(\n', '        uint256 _startTimeTLP2,\n', '        uint256 _preMcFlyTotalSupply,\n', '        address _wallet,\n', '        address _wavesAgent,\n', '        address _wavesGW,\n', '        address _fundMintingAgent,\n', '        address _teamWallet,\n', '        address _bountyOnlineWallet,\n', '        address _bountyOnlineGW,\n', '        address _bountyOfflineWallet,\n', '        address _advisoryWallet,\n', '        address _reservedWallet,\n', '        address _airdropWallet,\n', '        address _airdropGW,\n', '        address _preMcFlyWallet\n', '    ) public \n', '    {   \n', '        require(_startTimeTLP2 >= block.timestamp);\n', '        require(_preMcFlyTotalSupply > 0);\n', '        require(_wallet != 0x0);\n', '        require(_wavesAgent != 0x0);\n', '        require(_wavesGW != 0x0);\n', '        require(_fundMintingAgent != 0x0);\n', '        require(_teamWallet != 0x0);\n', '        require(_bountyOnlineWallet != 0x0);\n', '        require(_bountyOnlineGW != 0x0);\n', '        require(_bountyOfflineWallet != 0x0);\n', '        require(_advisoryWallet != 0x0);\n', '        require(_reservedWallet != 0x0);\n', '        require(_airdropWallet != 0x0);\n', '        require(_airdropGW != 0x0);\n', '        require(_preMcFlyWallet != 0x0);\n', '\n', '        token = new McFlyToken();\n', '\n', '        wallet = _wallet;\n', '\n', '        sT2 = _startTimeTLP2;\n', '\n', '        wavesAgent = _wavesAgent;\n', '        wavesGW = _wavesGW;\n', '\n', '        fundMintingAgent = _fundMintingAgent;\n', '\n', '        teamWallet = _teamWallet;\n', '        bountyOnlineWallet = _bountyOnlineWallet;\n', '        bountyOnlineGW = _bountyOnlineGW;\n', '        bountyOfflineWallet = _bountyOfflineWallet;\n', '        advisoryWallet = _advisoryWallet;\n', '        reservedWallet = _reservedWallet;\n', '        airdropWallet = _airdropWallet;\n', '        airdropGW = _airdropGW;\n', '        preMcFlyWallet = _preMcFlyWallet;\n', '\n', '        /// @dev Mint all tokens and than control it by vesting\n', '        _preMcFly = _preMcFlyTotalSupply;\n', '        token.mint(preMcFlyWallet, _preMcFly); // McFly for thansfer to old MFL owners\n', '        token.allowTransfer(preMcFlyWallet);\n', '        crowdTokensTLP2 = crowdTokensTLP2.add(_preMcFly);\n', '\n', '        token.mint(wavesAgent, wavesTokens); // 100,000,000 MFL\n', '        token.allowTransfer(wavesAgent);\n', '        token.allowTransfer(wavesGW);\n', '        crowdTokensTLP2 = crowdTokensTLP2.add(wavesTokens);\n', '\n', '        token.mint(this, _teamTokens); // mint to contract address\n', '\n', '        token.mint(bountyOnlineWallet, _bountyOnlineTokens);\n', '        token.allowTransfer(bountyOnlineWallet);\n', '        token.allowTransfer(bountyOnlineGW);\n', '\n', '        token.mint(bountyOfflineWallet, _bountyOfflineTokens);\n', '        token.allowTransfer(bountyOfflineWallet);\n', '\n', '        token.mint(this, _advisoryTokens);\n', '\n', '        token.mint(this, _reservedTokens);\n', '\n', '        token.mint(airdropWallet, _airdropTokens);\n', '        token.allowTransfer(airdropWallet);\n', '        token.allowTransfer(airdropGW);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev check is TLP2 is active?\n', '     * @return false if crowd TLP2 event was ended\n', '     */\n', '    function withinPeriod() constant public returns (bool) {\n', '        return (now >= sT2 && now <= (sT2+dTLP2));\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev check is TLP2 is active and minting Not finished\n', '     * @return false if crowd event was ended\n', '     */\n', '    function running() constant public returns (bool) {\n', '        return withinPeriod() && !token.mintingFinished();\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev check current stage name\n', '     * @return uint8 stage number\n', '     */\n', '    function stageName() constant public returns (uint8) {\n', '        uint256 eT2 = sT2+dTLP2;\n', '\n', '        if (now < sT2) {return 101;} // not started\n', '        if (now >= sT2 && now <= eT2) {return (102);} // TLP1.2\n', '\n', '        if (now > eT2 && now < eT2+dBt) {return (103);} // preTLP1.3\n', '        if (now >= (eT2+dBt) && now <= (eT2+dBt+dW)) {return (0);} // TLP1.3\n', '        if (now > (eT2+dBt+dW) && now < (eT2+dBt+dW+dBt)) {return (104);} // preTLP1.4\n', '        if (now >= (eT2+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW)) {return (1);} // TLP1.4\n', '        if (now > (eT2+dBt+dW+dBt+dW) && now < (eT2+dBt+dW+dBt+dW+dBt)) {return (105);} // preTLP1.5\n', '        if (now >= (eT2+dBt+dW+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW+dBt+dW)) {return (2);} // TLP1.5\n', '        if (now > (eT2+dBt+dW+dBt+dW+dBt+dW) && now < (eT2+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (106);} // preTLP1.6\n', '        if (now >= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (3);} // TLP1.6\n', '        if (now > (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW) && now < (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (107);} // preTLP1.7\n', '        if (now >= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (4);} // TLP1.7"\n', '        if (now > (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (200);} // Finished\n', '        return (201); // unknown\n', '    }\n', '\n', '\n', '    /** \n', '     * @dev change agent for minting\n', '     * @param agent - new agent address\n', '     */\n', '    function setFundMintingAgent(address agent) onlyOwner public {\n', '        fundMintingAgent = agent;\n', '        SetFundMintingAgent(agent);\n', '    }\n', '\n', '\n', '    /** \n', '     * @dev change wallet for team vesting (this make possible to set smart-contract address later)\n', '     * @param _newTeamWallet - new wallet address\n', '     */\n', '    function setTeamWallet(address _newTeamWallet) onlyOwner public {\n', '        teamWallet = _newTeamWallet;\n', '        SetTeamWallet(_newTeamWallet);\n', '    }\n', '\n', '\n', '    /** \n', '     * @dev change wallet for advisory vesting (this make possible to set smart-contract address later)\n', '     * @param _newAdvisoryWallet - new wallet address\n', '     */\n', '    function setAdvisoryWallet(address _newAdvisoryWallet) onlyOwner public {\n', '        advisoryWallet = _newAdvisoryWallet;\n', '        SetAdvisoryWallet(_newAdvisoryWallet);\n', '    }\n', '\n', '\n', '    /** \n', '     * @dev change wallet for reserved vesting (this make possible to set smart-contract address later)\n', '     * @param _newReservedWallet - new wallet address\n', '     */\n', '    function setReservedWallet(address _newReservedWallet) onlyOwner public {\n', '        reservedWallet = _newReservedWallet;\n', '        SetReservedWallet(_newReservedWallet);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev change min ETH income during Window1-5\n', '     * @param _minETHin - new limit\n', '     */\n', '    function setMinETHin(uint256 _minETHin) onlyOwner public {\n', '        minETHin = _minETHin;\n', '        SetMinETHincome(_minETHin);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev set TLP1.X (2-7) start & end dates\n', '     * @param _at - new or old start date\n', '     */\n', '    function setStartEndTimeTLP(uint256 _at) onlyOwner public {\n', '        require(block.timestamp < sT2); // forbid change time when TLP1.2 is active\n', '        require(block.timestamp < _at); // should be great than current block timestamp\n', '\n', '        sT2 = _at;\n', '        SetStartTimeTLP2(_at);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Large Token Holder minting \n', '     * @param to - mint to address\n', '     * @param amount - how much mint\n', '     */\n', '    function fundMinting(address to, uint256 amount) stopInEmergency public {\n', '        require(msg.sender == fundMintingAgent || isOwner());\n', '        require(block.timestamp < sT2);\n', '        require(fundTotalSupply.add(amount) <= fundTokens);\n', '        require(token.totalSupply().add(amount) <= hardCapInTokens);\n', '\n', '        fundTotalSupply = fundTotalSupply.add(amount);\n', '        token.mint(to, amount);\n', '        FundMinting(to, amount);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev calculate amount\n', '     * @param  amount - ether to be converted to tokens\n', '     * @param  at - current time\n', '     * @param  _totalSupply - total supplied tokens\n', '     * @return tokens amount that we should send to our dear ppl\n', '     * @return odd ethers amount, which contract should send back\n', '     */\n', '    function calcAmountAt(\n', '        uint256 amount,\n', '        uint256 at,\n', '        uint256 _totalSupply\n', '    ) public constant returns (uint256, uint256) \n', '    {\n', '        uint256 estimate;\n', '        uint256 price;\n', '        \n', '        if (at >= sT2 && at <= (sT2+dTLP2)) {\n', '            if (at <= sT2 + 15 days) {price = 12e13;} else if (at <= sT2 + 30 days) {\n', '                price = 14e13;} else if (at <= sT2 + 45 days) {\n', '                    price = 16e13;} else if (at <= sT2 + 60 days) {\n', '                        price = 18e13;} else if (at <= sT2 + 75 days) {\n', '                            price = 20e13;} else if (at <= sT2 + 90 days) {\n', '                                price = 22e13;} else if (at <= sT2 + 105 days) {\n', '                                    price = 24e13;} else if (at <= sT2 + 118 days) {\n', '                                        price = 26e13;} else {revert();}\n', '        } else {revert();}\n', '\n', '        estimate = _totalSupply.add(amount.mul(1e18).div(price));\n', '\n', '        if (estimate > hardCapInTokens) {\n', '            return (\n', '                hardCapInTokens.sub(_totalSupply),\n', '                estimate.sub(hardCapInTokens).mul(price).div(1e18)\n', '            );\n', '        }\n', '        return (estimate.sub(_totalSupply), 0);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev fallback for processing ether\n', '     */\n', '    function() external payable {\n', '        return getTokens(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev sell token and send to contributor address\n', '     * @param contributor address\n', '     */\n', '    function getTokens(address contributor) payable stopInEmergency validPurchase public {\n', '        uint256 amount;\n', '        uint256 oddEthers;\n', '        uint256 ethers;\n', '        uint256 _at;\n', '        uint8 _winNum;\n', '\n', '        _at = block.timestamp;\n', '\n', '        require(contributor != 0x0);\n', '       \n', '        if (withinPeriod()) {\n', '        \n', '            (amount, oddEthers) = calcAmountAt(msg.value, _at, token.totalSupply());\n', '  \n', '            require(amount.add(token.totalSupply()) <= hardCapInTokens);\n', '\n', '            ethers = msg.value.sub(oddEthers);\n', '\n', '            token.mint(contributor, amount); // fail if minting is finished\n', '            TokenPurchase(contributor, ethers, amount);\n', '            counter_in = counter_in.add(ethers);\n', '            crowdTokensTLP2 = crowdTokensTLP2.add(amount);\n', '\n', '            if (oddEthers > 0) {\n', '                require(oddEthers < msg.value);\n', '                contributor.transfer(oddEthers);\n', '                TransferOddEther(contributor, oddEthers);\n', '            }\n', '\n', '            wallet.transfer(ethers);\n', '        } else {\n', '            require(msg.value >= minETHin); // checks min ETH income\n', '            _winNum = stageName();\n', '            require(_winNum >= 0 && _winNum < 5);\n', '            Window storage w = ww[_winNum];\n', '\n', '            require(w.tokenPerWindow > 0); // check that we have tokens!\n', '\n', '            w.totalEthInWindow = w.totalEthInWindow.add(msg.value);\n', '            ppls[w.totalTransCnt].addr = contributor;\n', '            ppls[w.totalTransCnt].amount = msg.value;\n', '            w.totalTransCnt++;\n', '            TokenPurchaseInWindow(contributor, msg.value, _winNum, w.totalTransCnt, w.totalEthInWindow);\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev close Window and transfer Eth to wallet address\n', '     * @param _winNum - number of window 0-4 to close\n', '     */\n', '    function closeWindow(uint8 _winNum) onlyOwner stopInEmergency public {\n', '        require(ww[_winNum].active);\n', '        ww[_winNum].active = false;\n', '\n', '        wallet.transfer(this.balance);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev transfer tokens to ppl accts (window1-5)\n', '     * @param _winNum - number of window 0-4 to close\n', '     */\n', '    function sendTokensWindow(uint8 _winNum) onlyOwner stopInEmergency public {\n', '        uint256 _tokenPerETH;\n', '        uint256 _tokenToSend = 0;\n', '        address _tempAddr;\n', '        uint32 index = ww[_winNum].refundIndex;\n', '\n', '        TokenETH(ww[_winNum].totalEthInWindow, ww[_winNum].totalTransCnt);\n', '\n', '        require(ww[_winNum].active);\n', '        require(ww[_winNum].totalEthInWindow > 0);\n', '        require(ww[_winNum].totalTransCnt > 0);\n', '\n', '        _tokenPerETH = ww[_winNum].tokenPerWindow.div(ww[_winNum].totalEthInWindow); // max McFly in window / ethInWindow\n', '\n', '        while (index < ww[_winNum].totalTransCnt && msg.gas > 100000) {\n', '            _tokenToSend = _tokenPerETH.mul(ppls[index].amount);\n', '            ppls[index].amount = 0;\n', '            _tempAddr = ppls[index].addr;\n', '            ppls[index].addr = 0;\n', '            index++;\n', '            token.transfer(_tempAddr, _tokenToSend);\n', '            TokenWithdrawAtWindow(_tempAddr, _tokenToSend);\n', '        }\n', '        ww[_winNum].refundIndex = index;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev open new window 0-5 and write totl token per window in structure\n', '     * @param _winNum - number of window 0-4 to close\n', '     * @param _tokenPerWindow - total token for window 0-4\n', '     */\n', '    function newWindow(uint8 _winNum, uint256 _tokenPerWindow) private {\n', '        ww[_winNum] = Window(true, 0, 0, 0, _tokenPerWindow);\n', '        NewWindow(_winNum, _tokenPerWindow);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Finish crowdsale TLP1.2 period and open window1-5 crowdsale\n', '     */\n', '    function finishCrowd() onlyOwner public {\n', '        uint256 _tokenPerWindow;\n', '        require(now > (sT2.add(dTLP2)) || hardCapInTokens == token.totalSupply());\n', '        require(!token.mintingFinished());\n', '\n', '        _tokenPerWindow = (mintCapInTokens.sub(crowdTokensTLP2).sub(fundTotalSupply)).div(5);\n', '        token.mint(this, _tokenPerWindow.mul(5)); // mint to contract address\n', '        // shoud be MAX tokens minted!!! 1,800,000,000\n', '        for (uint8 y = 0; y < 5; y++) {\n', '            newWindow(y, _tokenPerWindow);\n', '        }\n', '\n', '        token.finishMinting();\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev withdraw tokens amount within vesting rules for team, advisory and reserved\n', '     * @param withdrawWallet - wallet to transfer tokens\n', '     * @param withdrawTokens - amount of tokens to transfer to\n', '     * @param withdrawTotalSupply - total amount of tokens transfered to account\n', '     * @return unit256 total amount of tokens after transfer\n', '     */\n', '    function vestingWithdraw(address withdrawWallet, uint256 withdrawTokens, uint256 withdrawTotalSupply) private returns (uint256) {\n', '        require(token.mintingFinished());\n', '        require(msg.sender == withdrawWallet || isOwner());\n', '\n', '        uint256 currentPeriod = (block.timestamp.sub(sT2.add(dTLP2))).div(VestingPeriodInSeconds);\n', '        if (currentPeriod > VestingPeriodsCount) {\n', '            currentPeriod = VestingPeriodsCount;\n', '        }\n', '        uint256 tokenAvailable = withdrawTokens.mul(currentPeriod).div(VestingPeriodsCount).sub(withdrawTotalSupply);  // RECHECK!!!!!\n', '\n', '        require((withdrawTotalSupply.add(tokenAvailable)) <= withdrawTokens);\n', '\n', '        uint256 _withdrawTotalSupply = withdrawTotalSupply.add(tokenAvailable);\n', '\n', '        token.transfer(withdrawWallet, tokenAvailable);\n', '        WithdrawVesting(withdrawWallet, currentPeriod, tokenAvailable, _withdrawTotalSupply);\n', '\n', '        return _withdrawTotalSupply;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev withdraw tokens amount within vesting rules for team\n', '     */\n', '    function teamWithdraw() public {\n', '        teamTotalSupply = vestingWithdraw(teamWallet, _teamTokens, teamTotalSupply);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev withdraw tokens amount within vesting rules for advisory\n', '     */\n', '    function advisoryWithdraw() public {\n', '        advisoryTotalSupply = vestingWithdraw(advisoryWallet, _advisoryTokens, advisoryTotalSupply);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev withdraw tokens amount within vesting rules for reserved wallet\n', '     */\n', '    function reservedWithdraw() public {\n', '        reservedTotalSupply = vestingWithdraw(reservedWallet, _reservedTokens, reservedTotalSupply);\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' *\n', ' * @title McFly.aero - main contract\n', ' * @author Copyright (c) 2018 McFly.aero\n', ' * @author Dmitriy Khizhinskiy\n', ' * @author "MIT"\n', ' *\n', ' */ \n', '\n', '/**\n', ' * @title ERC20 Basic smart contract\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <manuelaraoz@gmail.com>"\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @author modification: Dmitriy Khizhinskiy @McFly.aero\n', ' */\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Ownable smart contract\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <manuelaraoz@gmail.com>"\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @author modification: Dmitriy Khizhinskiy @McFly.aero\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '    address public candidate;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Allows the current owner to _request_ transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function requestOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        candidate = newOwner;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Allows the _NEW_ candidate to complete transfer control of the contract to him.\n', '    */\n', '    function confirmOwnership() public {\n', '        require(candidate == msg.sender);\n', '        owner = candidate;\n', '        OwnershipTransferred(owner, candidate);        \n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title MultiOwners smart contract\n', ' * @author Copyright (c) 2018 McFly.aero\n', ' * @author Dmitriy Khizhinskiy\n', ' * @author "MIT"\n', ' */\n', 'contract MultiOwners {\n', '\n', '    event AccessGrant(address indexed owner);\n', '    event AccessRevoke(address indexed owner);\n', '    \n', '    mapping(address => bool) owners;\n', '    address public publisher;\n', '\n', '\n', '    function MultiOwners() public {\n', '        owners[msg.sender] = true;\n', '        publisher = msg.sender;\n', '    }\n', '\n', '\n', '    modifier onlyOwner() { \n', '        require(owners[msg.sender] == true);\n', '        _; \n', '    }\n', '\n', '\n', '    function isOwner() constant public returns (bool) {\n', '        return owners[msg.sender] ? true : false;\n', '    }\n', '\n', '\n', '    function checkOwner(address maybe_owner) constant public returns (bool) {\n', '        return owners[maybe_owner] ? true : false;\n', '    }\n', '\n', '\n', '    function grant(address _owner) onlyOwner public {\n', '        owners[_owner] = true;\n', '        AccessGrant(_owner);\n', '    }\n', '\n', '\n', '    function revoke(address _owner) onlyOwner public {\n', '        require(_owner != publisher);\n', '        require(msg.sender != _owner);\n', '\n', '        owners[_owner] = false;\n', '        AccessRevoke(_owner);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <manuelaraoz@gmail.com>"\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title BasicToken smart contract\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <manuelaraoz@gmail.com>"\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @author modification: Dmitriy Khizhinskiy @McFly.aero\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    uint256 totalSupply_;\n', '\n', '    /**\n', '    * @dev total number of tokens in existence\n', '    */\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        // SafeMath.sub will throw if there is not enough balance.\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 smart contract\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <manuelaraoz@gmail.com>"\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @author modification: Dmitriy Khizhinskiy @McFly.aero\n', ' */\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <manuelaraoz@gmail.com>"\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @author modification: Dmitriy Khizhinskiy @McFly.aero\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '  \n', '    /** \n', '    * @dev Transfer tokens from one address to another\n', '    * @param _from address The address which you want to send tokens from\n', '    * @param _to address The address which you want to transfer to\n', '    * @param _value uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    *\n', '    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    * @param _owner address The address which owns the funds.\n', '    * @param _spender address The address which will spend the funds.\n', '    * @return A uint256 specifying the amount of tokens still available for the spender.\n', '    */\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '    *\n', '    * approve should be called when allowed[_spender] == 0. To increment\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _addedValue The amount of tokens to increase the allowance by.\n', '    */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '    *\n', '    * approve should be called when allowed[_spender] == 0. To decrement\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '    */\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Mintable token smart contract\n', ' * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' * @author "Manuel Araoz <manuelaraoz@gmail.com>"\n', ' * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity\n', ' * @author modification: Dmitriy Khizhinskiy @McFly.aero\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MintFinished();\n', '\n', '    bool public mintingFinished = false;\n', '\n', '    modifier canMint() {\n', '        require(!mintingFinished);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Function to mint tokens\n', '    * @param _to The address that will receive the minted tokens.\n', '    * @param _amount The amount of tokens to mint.\n', '    * @return A boolean that indicates if the operation was successful.\n', '    */\n', '    function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Mint(_to, _amount);\n', '        Transfer(address(0), _to, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Function to stop minting new tokens.\n', '    * @return True if the operation was successful.\n', '    */\n', '    function finishMinting() onlyOwner canMint public returns (bool) {\n', '        mintingFinished = true;\n', '        MintFinished();\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title McFly token smart contract\n', ' * @author Copyright (c) 2018 McFly.aero\n', ' * @author Dmitriy Khizhinskiy\n', ' * @author "MIT"\n', ' */\n', 'contract McFlyToken is MintableToken {\n', '    string public constant name = "McFlyToken";\n', '    string public constant symbol = "McFLY";\n', '    uint8 public constant decimals = 18;\n', '\n', '    /// @dev mapping for whitelist\n', '    mapping(address=>bool) whitelist;\n', '\n', '    /// @dev event throw when allowed to transfer address added to whitelist\n', '    /// @param from address\n', '    event AllowTransfer(address from);\n', '\n', '    /// @dev check for allowence of transfer\n', '    modifier canTransfer() {\n', '        require(mintingFinished || whitelist[msg.sender]);\n', '        _;        \n', '    }\n', '\n', '    /// @dev add address to whitelist\n', '    /// @param from address to add\n', '    function allowTransfer(address from) onlyOwner public {\n', '        whitelist[from] = true;\n', '        AllowTransfer(from);\n', '    }\n', '\n', '    /// @dev Do the transfer from address to address value\n', '    /// @param from address from\n', '    /// @param to address to\n', '    /// @param value uint256\n', '    function transferFrom(address from, address to, uint256 value) canTransfer public returns (bool) {\n', '        return super.transferFrom(from, to, value);\n', '    }\n', '\n', '    /// @dev Do the transfer from token address to "to" address value\n', '    /// @param to address to\n', '    /// @param value uint256 value\n', '    function transfer(address to, uint256 value) canTransfer public returns (bool) {\n', '        return super.transfer(to, value);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Haltable smart contract - controls owner access\n', ' * @author Copyright (c) 2018 McFly.aero\n', ' * @author Dmitriy Khizhinskiy\n', ' * @author "MIT"\n', ' */\n', 'contract Haltable is MultiOwners {\n', '    bool public halted;\n', '\n', '    modifier stopInEmergency {\n', '        require(!halted);\n', '        _;\n', '    }\n', '\n', '\n', '    modifier onlyInEmergency {\n', '        require(halted);\n', '        _;\n', '    }\n', '\n', '\n', '    /// @dev called by the owner on emergency, triggers stopped state\n', '    function halt() external onlyOwner {\n', '        halted = true;\n', '    }\n', '\n', '\n', '    /// @dev called by the owner on end of emergency, returns to normal state\n', '    function unhalt() external onlyOwner onlyInEmergency {\n', '        halted = false;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title McFly crowdsale smart contract \n', ' * @author Copyright (c) 2018 McFly.aero\n', ' * @author Dmitriy Khizhinskiy\n', ' * @author "MIT"\n', ' * @dev inherited from MultiOwners & Haltable\n', ' */\n', 'contract McFlyCrowd is MultiOwners, Haltable {\n', '    using SafeMath for uint256;\n', '\n', '    /// @dev Total ETH received during WAVES, TLP1.2 & window[1-5]\n', '    uint256 public counter_in; // tlp2\n', '    \n', '    /// @dev minimum ETH to partisipate in window 1-5\n', '    uint256 public minETHin = 1e18; // 1 ETH\n', '\n', '    /// @dev Token\n', '    McFlyToken public token;\n', '\n', '    /// @dev Withdraw wallet\n', '    address public wallet;\n', '\n', '    /// @dev start and end timestamp for TLP 1.2, other values callculated\n', '    uint256 public sT2; // startTimeTLP2\n', '    uint256 constant dTLP2 = 118 days; // days of TLP2\n', '    uint256 constant dBt = 60 days; // days between Windows\n', '    uint256 constant dW = 12 days; // 12 days for 3,4,5,6,7 windows;\n', '\n', '    /// @dev Cap maximum possible tokens for minting\n', '    uint256 public constant hardCapInTokens = 1800e24; // 1,800,000,000 MFL\n', '\n', '    /// @dev maximum possible tokens for sell \n', '    uint256 public constant mintCapInTokens = 1260e24; // 1,260,000,000 MFL\n', '\n', '    /// @dev tokens crowd within TLP2\n', '    uint256 public crowdTokensTLP2;\n', '\n', '    uint256 public _preMcFly;\n', '\n', '    /// @dev maximum possible tokens for fund minting\n', '    uint256 constant fundTokens = 270e24; // 270,000,000 MFL\n', '    uint256 public fundTotalSupply;\n', '    address public fundMintingAgent;\n', '\n', '    /// @dev maximum possible tokens to convert from WAVES\n', '    uint256 constant wavesTokens = 100e24; // 100,000,000 MFL\n', '    address public wavesAgent;\n', '    address public wavesGW;\n', '\n', '    /// @dev Vesting param for team, advisory, reserve.\n', '    uint256 constant VestingPeriodInSeconds = 30 days; // 24 month\n', '    uint256 constant VestingPeriodsCount = 24;\n', '\n', '    /// @dev Team 10%\n', '    uint256 constant _teamTokens = 180e24;\n', '    uint256 public teamTotalSupply;\n', '    address public teamWallet;\n', '\n', '    /// @dev Bounty 5% (2% + 3%)\n', '    /// @dev Bounty online 2%\n', '    uint256 constant _bountyOnlineTokens = 36e24;\n', '    address public bountyOnlineWallet;\n', '    address public bountyOnlineGW;\n', '\n', '    /// @dev Bounty offline 3%\n', '    uint256 constant _bountyOfflineTokens = 54e24;\n', '    address public bountyOfflineWallet;\n', '\n', '    /// @dev Advisory 5%\n', '    uint256 constant _advisoryTokens = 90e24;\n', '    uint256 public advisoryTotalSupply;\n', '    address public advisoryWallet;\n', '\n', '    /// @dev Reserved for future 9%\n', '    uint256 constant _reservedTokens = 162e24;\n', '    uint256 public reservedTotalSupply;\n', '    address public reservedWallet;\n', '\n', '    /// @dev AirDrop 1%\n', '    uint256 constant _airdropTokens = 18e24;\n', '    address public airdropWallet;\n', '    address public airdropGW;\n', '\n', '    /// @dev PreMcFly wallet (MFL)\n', '    address public preMcFlyWallet;\n', '\n', '    /// @dev Ppl structure for Win1-5\n', '    struct Ppl {\n', '        address addr;\n', '        uint256 amount;\n', '    }\n', '    mapping (uint32 => Ppl) public ppls;\n', '\n', '    /// @dev Window structure for Win1-5\n', '    struct Window {\n', '        bool active;\n', '        uint256 totalEthInWindow;\n', '        uint32 totalTransCnt;\n', '        uint32 refundIndex;\n', '        uint256 tokenPerWindow;\n', '    } \n', '    mapping (uint8 => Window) public ww;\n', '\n', '\n', '    /// @dev Events\n', '    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);\n', '    event TokenPurchaseInWindow(address indexed beneficiary, uint256 value, uint8 winnum, uint32 totalcnt, uint256 totaleth1);\n', '    event TransferOddEther(address indexed beneficiary, uint256 value);\n', '    event FundMinting(address indexed beneficiary, uint256 value);\n', '    event WithdrawVesting(address indexed beneficiary, uint256 period, uint256 value, uint256 valueTotal);\n', '    event TokenWithdrawAtWindow(address indexed beneficiary, uint256 value);\n', '    event SetFundMintingAgent(address newAgent);\n', '    event SetTeamWallet(address newTeamWallet);\n', '    event SetAdvisoryWallet(address newAdvisoryWallet);\n', '    event SetReservedWallet(address newReservedWallet);\n', '    event SetStartTimeTLP2(uint256 newStartTimeTLP2);\n', '    event SetMinETHincome(uint256 newMinETHin);\n', '    event NewWindow(uint8 winNum, uint256 amountTokensPerWin);\n', '    event TokenETH(uint256 totalEth, uint32 totalCnt);\n', '\n', '\n', '    /// @dev check for Non zero value\n', '    modifier validPurchase() {\n', '        require(msg.value != 0);\n', '        _;        \n', '    }\n', '\n', '\n', '    /**\n', '     * @dev conctructor of contract, set main params, create new token, do minting for some wallets\n', '     * @param _startTimeTLP2 - set date time of starting of TLP2 (main date!)\n', '     * @param _preMcFlyTotalSupply - set amount in wei total supply of previouse contract (MFL)\n', '     * @param _wallet - wallet for transfer ETH to it\n', '     * @param _wavesAgent - wallet for WAVES gw\n', '     * @param _wavesGW    - wallet for WAVES gw\n', '     * @param _fundMintingAgent - wallet who allowed to mint before TLP2\n', '     * @param _teamWallet - wallet for team vesting\n', '     * @param _bountyOnlineWallet - wallet for online bounty\n', '     * @param _bountyOnlineGW - wallet for online bounty GW\n', '     * @param _bountyOfflineWallet - wallet for offline bounty\n', '     * @param _advisoryWallet - wallet for advisory vesting\n', '     * @param _reservedWallet - wallet for reserved vesting\n', '     * @param _airdropWallet - wallet for airdrop\n', '     * @param _airdropGW - wallet for airdrop GW\n', '     * @param _preMcFlyWallet - wallet for transfer old MFL->McFly (once)\n', '     */\n', '    function McFlyCrowd(\n', '        uint256 _startTimeTLP2,\n', '        uint256 _preMcFlyTotalSupply,\n', '        address _wallet,\n', '        address _wavesAgent,\n', '        address _wavesGW,\n', '        address _fundMintingAgent,\n', '        address _teamWallet,\n', '        address _bountyOnlineWallet,\n', '        address _bountyOnlineGW,\n', '        address _bountyOfflineWallet,\n', '        address _advisoryWallet,\n', '        address _reservedWallet,\n', '        address _airdropWallet,\n', '        address _airdropGW,\n', '        address _preMcFlyWallet\n', '    ) public \n', '    {   \n', '        require(_startTimeTLP2 >= block.timestamp);\n', '        require(_preMcFlyTotalSupply > 0);\n', '        require(_wallet != 0x0);\n', '        require(_wavesAgent != 0x0);\n', '        require(_wavesGW != 0x0);\n', '        require(_fundMintingAgent != 0x0);\n', '        require(_teamWallet != 0x0);\n', '        require(_bountyOnlineWallet != 0x0);\n', '        require(_bountyOnlineGW != 0x0);\n', '        require(_bountyOfflineWallet != 0x0);\n', '        require(_advisoryWallet != 0x0);\n', '        require(_reservedWallet != 0x0);\n', '        require(_airdropWallet != 0x0);\n', '        require(_airdropGW != 0x0);\n', '        require(_preMcFlyWallet != 0x0);\n', '\n', '        token = new McFlyToken();\n', '\n', '        wallet = _wallet;\n', '\n', '        sT2 = _startTimeTLP2;\n', '\n', '        wavesAgent = _wavesAgent;\n', '        wavesGW = _wavesGW;\n', '\n', '        fundMintingAgent = _fundMintingAgent;\n', '\n', '        teamWallet = _teamWallet;\n', '        bountyOnlineWallet = _bountyOnlineWallet;\n', '        bountyOnlineGW = _bountyOnlineGW;\n', '        bountyOfflineWallet = _bountyOfflineWallet;\n', '        advisoryWallet = _advisoryWallet;\n', '        reservedWallet = _reservedWallet;\n', '        airdropWallet = _airdropWallet;\n', '        airdropGW = _airdropGW;\n', '        preMcFlyWallet = _preMcFlyWallet;\n', '\n', '        /// @dev Mint all tokens and than control it by vesting\n', '        _preMcFly = _preMcFlyTotalSupply;\n', '        token.mint(preMcFlyWallet, _preMcFly); // McFly for thansfer to old MFL owners\n', '        token.allowTransfer(preMcFlyWallet);\n', '        crowdTokensTLP2 = crowdTokensTLP2.add(_preMcFly);\n', '\n', '        token.mint(wavesAgent, wavesTokens); // 100,000,000 MFL\n', '        token.allowTransfer(wavesAgent);\n', '        token.allowTransfer(wavesGW);\n', '        crowdTokensTLP2 = crowdTokensTLP2.add(wavesTokens);\n', '\n', '        token.mint(this, _teamTokens); // mint to contract address\n', '\n', '        token.mint(bountyOnlineWallet, _bountyOnlineTokens);\n', '        token.allowTransfer(bountyOnlineWallet);\n', '        token.allowTransfer(bountyOnlineGW);\n', '\n', '        token.mint(bountyOfflineWallet, _bountyOfflineTokens);\n', '        token.allowTransfer(bountyOfflineWallet);\n', '\n', '        token.mint(this, _advisoryTokens);\n', '\n', '        token.mint(this, _reservedTokens);\n', '\n', '        token.mint(airdropWallet, _airdropTokens);\n', '        token.allowTransfer(airdropWallet);\n', '        token.allowTransfer(airdropGW);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev check is TLP2 is active?\n', '     * @return false if crowd TLP2 event was ended\n', '     */\n', '    function withinPeriod() constant public returns (bool) {\n', '        return (now >= sT2 && now <= (sT2+dTLP2));\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev check is TLP2 is active and minting Not finished\n', '     * @return false if crowd event was ended\n', '     */\n', '    function running() constant public returns (bool) {\n', '        return withinPeriod() && !token.mintingFinished();\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev check current stage name\n', '     * @return uint8 stage number\n', '     */\n', '    function stageName() constant public returns (uint8) {\n', '        uint256 eT2 = sT2+dTLP2;\n', '\n', '        if (now < sT2) {return 101;} // not started\n', '        if (now >= sT2 && now <= eT2) {return (102);} // TLP1.2\n', '\n', '        if (now > eT2 && now < eT2+dBt) {return (103);} // preTLP1.3\n', '        if (now >= (eT2+dBt) && now <= (eT2+dBt+dW)) {return (0);} // TLP1.3\n', '        if (now > (eT2+dBt+dW) && now < (eT2+dBt+dW+dBt)) {return (104);} // preTLP1.4\n', '        if (now >= (eT2+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW)) {return (1);} // TLP1.4\n', '        if (now > (eT2+dBt+dW+dBt+dW) && now < (eT2+dBt+dW+dBt+dW+dBt)) {return (105);} // preTLP1.5\n', '        if (now >= (eT2+dBt+dW+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW+dBt+dW)) {return (2);} // TLP1.5\n', '        if (now > (eT2+dBt+dW+dBt+dW+dBt+dW) && now < (eT2+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (106);} // preTLP1.6\n', '        if (now >= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (3);} // TLP1.6\n', '        if (now > (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW) && now < (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (107);} // preTLP1.7\n', '        if (now >= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (4);} // TLP1.7"\n', '        if (now > (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (200);} // Finished\n', '        return (201); // unknown\n', '    }\n', '\n', '\n', '    /** \n', '     * @dev change agent for minting\n', '     * @param agent - new agent address\n', '     */\n', '    function setFundMintingAgent(address agent) onlyOwner public {\n', '        fundMintingAgent = agent;\n', '        SetFundMintingAgent(agent);\n', '    }\n', '\n', '\n', '    /** \n', '     * @dev change wallet for team vesting (this make possible to set smart-contract address later)\n', '     * @param _newTeamWallet - new wallet address\n', '     */\n', '    function setTeamWallet(address _newTeamWallet) onlyOwner public {\n', '        teamWallet = _newTeamWallet;\n', '        SetTeamWallet(_newTeamWallet);\n', '    }\n', '\n', '\n', '    /** \n', '     * @dev change wallet for advisory vesting (this make possible to set smart-contract address later)\n', '     * @param _newAdvisoryWallet - new wallet address\n', '     */\n', '    function setAdvisoryWallet(address _newAdvisoryWallet) onlyOwner public {\n', '        advisoryWallet = _newAdvisoryWallet;\n', '        SetAdvisoryWallet(_newAdvisoryWallet);\n', '    }\n', '\n', '\n', '    /** \n', '     * @dev change wallet for reserved vesting (this make possible to set smart-contract address later)\n', '     * @param _newReservedWallet - new wallet address\n', '     */\n', '    function setReservedWallet(address _newReservedWallet) onlyOwner public {\n', '        reservedWallet = _newReservedWallet;\n', '        SetReservedWallet(_newReservedWallet);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev change min ETH income during Window1-5\n', '     * @param _minETHin - new limit\n', '     */\n', '    function setMinETHin(uint256 _minETHin) onlyOwner public {\n', '        minETHin = _minETHin;\n', '        SetMinETHincome(_minETHin);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev set TLP1.X (2-7) start & end dates\n', '     * @param _at - new or old start date\n', '     */\n', '    function setStartEndTimeTLP(uint256 _at) onlyOwner public {\n', '        require(block.timestamp < sT2); // forbid change time when TLP1.2 is active\n', '        require(block.timestamp < _at); // should be great than current block timestamp\n', '\n', '        sT2 = _at;\n', '        SetStartTimeTLP2(_at);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Large Token Holder minting \n', '     * @param to - mint to address\n', '     * @param amount - how much mint\n', '     */\n', '    function fundMinting(address to, uint256 amount) stopInEmergency public {\n', '        require(msg.sender == fundMintingAgent || isOwner());\n', '        require(block.timestamp < sT2);\n', '        require(fundTotalSupply.add(amount) <= fundTokens);\n', '        require(token.totalSupply().add(amount) <= hardCapInTokens);\n', '\n', '        fundTotalSupply = fundTotalSupply.add(amount);\n', '        token.mint(to, amount);\n', '        FundMinting(to, amount);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev calculate amount\n', '     * @param  amount - ether to be converted to tokens\n', '     * @param  at - current time\n', '     * @param  _totalSupply - total supplied tokens\n', '     * @return tokens amount that we should send to our dear ppl\n', '     * @return odd ethers amount, which contract should send back\n', '     */\n', '    function calcAmountAt(\n', '        uint256 amount,\n', '        uint256 at,\n', '        uint256 _totalSupply\n', '    ) public constant returns (uint256, uint256) \n', '    {\n', '        uint256 estimate;\n', '        uint256 price;\n', '        \n', '        if (at >= sT2 && at <= (sT2+dTLP2)) {\n', '            if (at <= sT2 + 15 days) {price = 12e13;} else if (at <= sT2 + 30 days) {\n', '                price = 14e13;} else if (at <= sT2 + 45 days) {\n', '                    price = 16e13;} else if (at <= sT2 + 60 days) {\n', '                        price = 18e13;} else if (at <= sT2 + 75 days) {\n', '                            price = 20e13;} else if (at <= sT2 + 90 days) {\n', '                                price = 22e13;} else if (at <= sT2 + 105 days) {\n', '                                    price = 24e13;} else if (at <= sT2 + 118 days) {\n', '                                        price = 26e13;} else {revert();}\n', '        } else {revert();}\n', '\n', '        estimate = _totalSupply.add(amount.mul(1e18).div(price));\n', '\n', '        if (estimate > hardCapInTokens) {\n', '            return (\n', '                hardCapInTokens.sub(_totalSupply),\n', '                estimate.sub(hardCapInTokens).mul(price).div(1e18)\n', '            );\n', '        }\n', '        return (estimate.sub(_totalSupply), 0);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev fallback for processing ether\n', '     */\n', '    function() external payable {\n', '        return getTokens(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev sell token and send to contributor address\n', '     * @param contributor address\n', '     */\n', '    function getTokens(address contributor) payable stopInEmergency validPurchase public {\n', '        uint256 amount;\n', '        uint256 oddEthers;\n', '        uint256 ethers;\n', '        uint256 _at;\n', '        uint8 _winNum;\n', '\n', '        _at = block.timestamp;\n', '\n', '        require(contributor != 0x0);\n', '       \n', '        if (withinPeriod()) {\n', '        \n', '            (amount, oddEthers) = calcAmountAt(msg.value, _at, token.totalSupply());\n', '  \n', '            require(amount.add(token.totalSupply()) <= hardCapInTokens);\n', '\n', '            ethers = msg.value.sub(oddEthers);\n', '\n', '            token.mint(contributor, amount); // fail if minting is finished\n', '            TokenPurchase(contributor, ethers, amount);\n', '            counter_in = counter_in.add(ethers);\n', '            crowdTokensTLP2 = crowdTokensTLP2.add(amount);\n', '\n', '            if (oddEthers > 0) {\n', '                require(oddEthers < msg.value);\n', '                contributor.transfer(oddEthers);\n', '                TransferOddEther(contributor, oddEthers);\n', '            }\n', '\n', '            wallet.transfer(ethers);\n', '        } else {\n', '            require(msg.value >= minETHin); // checks min ETH income\n', '            _winNum = stageName();\n', '            require(_winNum >= 0 && _winNum < 5);\n', '            Window storage w = ww[_winNum];\n', '\n', '            require(w.tokenPerWindow > 0); // check that we have tokens!\n', '\n', '            w.totalEthInWindow = w.totalEthInWindow.add(msg.value);\n', '            ppls[w.totalTransCnt].addr = contributor;\n', '            ppls[w.totalTransCnt].amount = msg.value;\n', '            w.totalTransCnt++;\n', '            TokenPurchaseInWindow(contributor, msg.value, _winNum, w.totalTransCnt, w.totalEthInWindow);\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev close Window and transfer Eth to wallet address\n', '     * @param _winNum - number of window 0-4 to close\n', '     */\n', '    function closeWindow(uint8 _winNum) onlyOwner stopInEmergency public {\n', '        require(ww[_winNum].active);\n', '        ww[_winNum].active = false;\n', '\n', '        wallet.transfer(this.balance);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev transfer tokens to ppl accts (window1-5)\n', '     * @param _winNum - number of window 0-4 to close\n', '     */\n', '    function sendTokensWindow(uint8 _winNum) onlyOwner stopInEmergency public {\n', '        uint256 _tokenPerETH;\n', '        uint256 _tokenToSend = 0;\n', '        address _tempAddr;\n', '        uint32 index = ww[_winNum].refundIndex;\n', '\n', '        TokenETH(ww[_winNum].totalEthInWindow, ww[_winNum].totalTransCnt);\n', '\n', '        require(ww[_winNum].active);\n', '        require(ww[_winNum].totalEthInWindow > 0);\n', '        require(ww[_winNum].totalTransCnt > 0);\n', '\n', '        _tokenPerETH = ww[_winNum].tokenPerWindow.div(ww[_winNum].totalEthInWindow); // max McFly in window / ethInWindow\n', '\n', '        while (index < ww[_winNum].totalTransCnt && msg.gas > 100000) {\n', '            _tokenToSend = _tokenPerETH.mul(ppls[index].amount);\n', '            ppls[index].amount = 0;\n', '            _tempAddr = ppls[index].addr;\n', '            ppls[index].addr = 0;\n', '            index++;\n', '            token.transfer(_tempAddr, _tokenToSend);\n', '            TokenWithdrawAtWindow(_tempAddr, _tokenToSend);\n', '        }\n', '        ww[_winNum].refundIndex = index;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev open new window 0-5 and write totl token per window in structure\n', '     * @param _winNum - number of window 0-4 to close\n', '     * @param _tokenPerWindow - total token for window 0-4\n', '     */\n', '    function newWindow(uint8 _winNum, uint256 _tokenPerWindow) private {\n', '        ww[_winNum] = Window(true, 0, 0, 0, _tokenPerWindow);\n', '        NewWindow(_winNum, _tokenPerWindow);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Finish crowdsale TLP1.2 period and open window1-5 crowdsale\n', '     */\n', '    function finishCrowd() onlyOwner public {\n', '        uint256 _tokenPerWindow;\n', '        require(now > (sT2.add(dTLP2)) || hardCapInTokens == token.totalSupply());\n', '        require(!token.mintingFinished());\n', '\n', '        _tokenPerWindow = (mintCapInTokens.sub(crowdTokensTLP2).sub(fundTotalSupply)).div(5);\n', '        token.mint(this, _tokenPerWindow.mul(5)); // mint to contract address\n', '        // shoud be MAX tokens minted!!! 1,800,000,000\n', '        for (uint8 y = 0; y < 5; y++) {\n', '            newWindow(y, _tokenPerWindow);\n', '        }\n', '\n', '        token.finishMinting();\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev withdraw tokens amount within vesting rules for team, advisory and reserved\n', '     * @param withdrawWallet - wallet to transfer tokens\n', '     * @param withdrawTokens - amount of tokens to transfer to\n', '     * @param withdrawTotalSupply - total amount of tokens transfered to account\n', '     * @return unit256 total amount of tokens after transfer\n', '     */\n', '    function vestingWithdraw(address withdrawWallet, uint256 withdrawTokens, uint256 withdrawTotalSupply) private returns (uint256) {\n', '        require(token.mintingFinished());\n', '        require(msg.sender == withdrawWallet || isOwner());\n', '\n', '        uint256 currentPeriod = (block.timestamp.sub(sT2.add(dTLP2))).div(VestingPeriodInSeconds);\n', '        if (currentPeriod > VestingPeriodsCount) {\n', '            currentPeriod = VestingPeriodsCount;\n', '        }\n', '        uint256 tokenAvailable = withdrawTokens.mul(currentPeriod).div(VestingPeriodsCount).sub(withdrawTotalSupply);  // RECHECK!!!!!\n', '\n', '        require((withdrawTotalSupply.add(tokenAvailable)) <= withdrawTokens);\n', '\n', '        uint256 _withdrawTotalSupply = withdrawTotalSupply.add(tokenAvailable);\n', '\n', '        token.transfer(withdrawWallet, tokenAvailable);\n', '        WithdrawVesting(withdrawWallet, currentPeriod, tokenAvailable, _withdrawTotalSupply);\n', '\n', '        return _withdrawTotalSupply;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev withdraw tokens amount within vesting rules for team\n', '     */\n', '    function teamWithdraw() public {\n', '        teamTotalSupply = vestingWithdraw(teamWallet, _teamTokens, teamTotalSupply);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev withdraw tokens amount within vesting rules for advisory\n', '     */\n', '    function advisoryWithdraw() public {\n', '        advisoryTotalSupply = vestingWithdraw(advisoryWallet, _advisoryTokens, advisoryTotalSupply);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev withdraw tokens amount within vesting rules for reserved wallet\n', '     */\n', '    function reservedWithdraw() public {\n', '        reservedTotalSupply = vestingWithdraw(reservedWallet, _reservedTokens, reservedTotalSupply);\n', '    }\n', '}']
