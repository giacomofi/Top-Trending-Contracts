['/*\n', '-----------------------------------------------------------------\n', 'FILE HEADER\n', '-----------------------------------------------------------------\n', '\n', 'file:       HavvenEscrow.sol\n', 'version:    1.0\n', 'authors:    Anton Jurisevic\n', '            Dominic Romanowski\n', '            Mike Spain\n', '\n', 'date:       2018-02-28\n', 'checked:    Mike Spain\n', 'approved:   Samuel Brooks\n', '\n', 'repo:       https://github.com/Havven/havven\n', 'commit:     34e66009b98aa18976226c139270970d105045e3\n', '\n', '-----------------------------------------------------------------\n', '*/\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '/*\n', '-----------------------------------------------------------------\n', 'CONTRACT DESCRIPTION\n', '-----------------------------------------------------------------\n', '\n', 'A contract with a limited setup period. Any function modified\n', 'with the setup modifier will cease to work after the\n', 'conclusion of the configurable-length post-construction setup period.\n', '\n', '-----------------------------------------------------------------\n', '*/\n', '\n', 'contract LimitedSetup {\n', '\n', '    uint constructionTime;\n', '    uint setupDuration;\n', '\n', '    function LimitedSetup(uint _setupDuration)\n', '        public\n', '    {\n', '        constructionTime = now;\n', '        setupDuration = _setupDuration;\n', '    }\n', '\n', '    modifier setupFunction\n', '    {\n', '        require(now < constructionTime + setupDuration);\n', '        _;\n', '    }\n', '}\n', '\n', '/*\n', '-----------------------------------------------------------------\n', 'CONTRACT DESCRIPTION\n', '-----------------------------------------------------------------\n', '\n', 'An Owned contract, to be inherited by other contracts.\n', 'Requires its owner to be explicitly set in the constructor.\n', 'Provides an onlyOwner access modifier.\n', '\n', 'To change owner, the current owner must nominate the next owner,\n', 'who then has to accept the nomination. The nomination can be\n', 'cancelled before it is accepted by the new owner by having the\n', 'previous owner change the nomination (setting it to 0).\n', '\n', '-----------------------------------------------------------------\n', '*/\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public nominatedOwner;\n', '\n', '    function Owned(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '    function nominateOwner(address _owner)\n', '        external\n', '        onlyOwner\n', '    {\n', '        nominatedOwner = _owner;\n', '        emit OwnerNominated(_owner);\n', '    }\n', '\n', '    function acceptOwnership()\n', '        external\n', '    {\n', '        require(msg.sender == nominatedOwner);\n', '        emit OwnerChanged(owner, nominatedOwner);\n', '        owner = nominatedOwner;\n', '        nominatedOwner = address(0);\n', '    }\n', '\n', '    modifier onlyOwner\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    event OwnerNominated(address newOwner);\n', '    event OwnerChanged(address oldOwner, address newOwner);\n', '}\n', '\n', '/*\n', '-----------------------------------------------------------------\n', 'CONTRACT DESCRIPTION\n', '-----------------------------------------------------------------\n', '\n', 'A proxy contract that, if it does not recognise the function\n', 'being called on it, passes all value and call data to an\n', 'underlying target contract.\n', '\n', '-----------------------------------------------------------------\n', '*/\n', '\n', 'contract Proxy is Owned {\n', '    Proxyable target;\n', '\n', '    function Proxy(Proxyable _target, address _owner)\n', '        Owned(_owner)\n', '        public\n', '    {\n', '        target = _target;\n', '        emit TargetChanged(_target);\n', '    }\n', '\n', '    function _setTarget(address _target) \n', '        external\n', '        onlyOwner\n', '    {\n', '        require(_target != address(0));\n', '        target = Proxyable(_target);\n', '        emit TargetChanged(_target);\n', '    }\n', '\n', '    function () \n', '        public\n', '        payable\n', '    {\n', '        target.setMessageSender(msg.sender);\n', '        assembly {\n', '            // Copy call data into free memory region.\n', '            let free_ptr := mload(0x40)\n', '            calldatacopy(free_ptr, 0, calldatasize)\n', '\n', '            // Forward all gas, ether, and data to the target contract.\n', '            let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n', '            returndatacopy(free_ptr, 0, returndatasize)\n', '\n', '            // Revert if the call failed, otherwise return the result.\n', '            if iszero(result) { revert(free_ptr, calldatasize) }\n', '            return(free_ptr, returndatasize)\n', '        } \n', '    }\n', '\n', '    event TargetChanged(address targetAddress);\n', '}\n', '\n', '/*\n', '-----------------------------------------------------------------\n', 'CONTRACT DESCRIPTION\n', '-----------------------------------------------------------------\n', '\n', 'This contract contains the Proxyable interface.\n', 'Any contract the proxy wraps must implement this, in order\n', 'for the proxy to be able to pass msg.sender into the underlying\n', 'contract as the state parameter, messageSender.\n', '\n', '-----------------------------------------------------------------\n', '*/\n', '\n', 'contract Proxyable is Owned {\n', '    // the proxy this contract exists behind.\n', '    Proxy public proxy;\n', '\n', '    // The caller of the proxy, passed through to this contract.\n', '    // Note that every function using this member must apply the onlyProxy or\n', '    // optionalProxy modifiers, otherwise their invocations can use stale values.\n', '    address messageSender;\n', '\n', '    function Proxyable(address _owner)\n', '        Owned(_owner)\n', '        public { }\n', '\n', '    function setProxy(Proxy _proxy)\n', '        external\n', '        onlyOwner\n', '    {\n', '        proxy = _proxy;\n', '        emit ProxyChanged(_proxy);\n', '    }\n', '\n', '    function setMessageSender(address sender)\n', '        external\n', '        onlyProxy\n', '    {\n', '        messageSender = sender;\n', '    }\n', '\n', '    modifier onlyProxy\n', '    {\n', '        require(Proxy(msg.sender) == proxy);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner_Proxy\n', '    {\n', '        require(messageSender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier optionalProxy\n', '    {\n', '        if (Proxy(msg.sender) != proxy) {\n', '            messageSender = msg.sender;\n', '        }\n', '        _;\n', '    }\n', '\n', '    // Combine the optionalProxy and onlyOwner_Proxy modifiers.\n', '    // This is slightly cheaper and safer, since there is an ordering requirement.\n', '    modifier optionalProxy_onlyOwner\n', '    {\n', '        if (Proxy(msg.sender) != proxy) {\n', '            messageSender = msg.sender;\n', '        }\n', '        require(messageSender == owner);\n', '        _;\n', '    }\n', '\n', '    event ProxyChanged(address proxyAddress);\n', '\n', '}\n', '\n', '/*\n', '-----------------------------------------------------------------\n', 'CONTRACT DESCRIPTION\n', '-----------------------------------------------------------------\n', '\n', 'A fixed point decimal library that provides basic mathematical\n', 'operations, and checks for unsafe arguments, for example that\n', 'would lead to overflows.\n', '\n', 'Exceptions are thrown whenever those unsafe operations\n', 'occur.\n', '\n', '-----------------------------------------------------------------\n', '*/\n', '\n', 'contract SafeDecimalMath {\n', '\n', '    // Number of decimal places in the representation.\n', '    uint8 public constant decimals = 18;\n', '\n', '    // The number representing 1.0.\n', '    uint public constant UNIT = 10 ** uint(decimals);\n', '\n', '    /* True iff adding x and y will not overflow. */\n', '    function addIsSafe(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return x + y >= y;\n', '    }\n', '\n', '    /* Return the result of adding x and y, throwing an exception in case of overflow. */\n', '    function safeAdd(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        require(x + y >= y);\n', '        return x + y;\n', '    }\n', '\n', '    /* True iff subtracting y from x will not overflow in the negative direction. */\n', '    function subIsSafe(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return y <= x;\n', '    }\n', '\n', '    /* Return the result of subtracting y from x, throwing an exception in case of overflow. */\n', '    function safeSub(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        require(y <= x);\n', '        return x - y;\n', '    }\n', '\n', '    /* True iff multiplying x and y would not overflow. */\n', '    function mulIsSafe(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        if (x == 0) {\n', '            return true;\n', '        }\n', '        return (x * y) / x == y;\n', '    }\n', '\n', '    /* Return the result of multiplying x and y, throwing an exception in case of overflow.*/\n', '    function safeMul(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        if (x == 0) {\n', '            return 0;\n', '        }\n', '        uint p = x * y;\n', '        require(p / x == y);\n', '        return p;\n', '    }\n', '\n', '    /* Return the result of multiplying x and y, interpreting the operands as fixed-point\n', '     * demicimals. Throws an exception in case of overflow. A unit factor is divided out\n', '     * after the product of x and y is evaluated, so that product must be less than 2**256.\n', '     * \n', '     * Incidentally, the internal division always rounds down: we could have rounded to the nearest integer,\n', '     * but then we would be spending a significant fraction of a cent (of order a microether\n', '     * at present gas prices) in order to save less than one part in 0.5 * 10^18 per operation, if the operands\n', '     * contain small enough fractional components. It would also marginally diminish the \n', '     * domain this function is defined upon. \n', '     */\n', '    function safeMul_dec(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        // Divide by UNIT to remove the extra factor introduced by the product.\n', '        // UNIT be 0.\n', '        return safeMul(x, y) / UNIT;\n', '\n', '    }\n', '\n', '    /* True iff the denominator of x/y is nonzero. */\n', '    function divIsSafe(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return y != 0;\n', '    }\n', '\n', '    /* Return the result of dividing x by y, throwing an exception if the divisor is zero. */\n', '    function safeDiv(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        // Although a 0 denominator already throws an exception,\n', '        // it is equivalent to a THROW operation, which consumes all gas.\n', '        // A require statement emits REVERT instead, which remits remaining gas.\n', '        require(y != 0);\n', '        return x / y;\n', '    }\n', '\n', '    /* Return the result of dividing x by y, interpreting the operands as fixed point decimal numbers.\n', '     * Throws an exception in case of overflow or zero divisor; x must be less than 2^256 / UNIT.\n', '     * Internal rounding is downward: a similar caveat holds as with safeDecMul().*/\n', '    function safeDiv_dec(uint x, uint y)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        // Reintroduce the UNIT factor that will be divided out by y.\n', '        return safeDiv(safeMul(x, UNIT), y);\n', '    }\n', '\n', '    /* Convert an unsigned integer to a unsigned fixed-point decimal.\n', '     * Throw an exception if the result would be out of range. */\n', '    function intToDec(uint i)\n', '        pure\n', '        internal\n', '        returns (uint)\n', '    {\n', '        return safeMul(i, UNIT);\n', '    }\n', '}\n', '\n', '/*\n', '-----------------------------------------------------------------\n', 'CONTRACT DESCRIPTION\n', '-----------------------------------------------------------------\n', '\n', 'This court provides the nomin contract with a confiscation\n', 'facility, if enough havven owners vote to confiscate a target\n', 'account&#39;s nomins.\n', '\n', 'This is designed to provide a mechanism to respond to abusive\n', 'contracts such as nomin wrappers, which would allow users to\n', 'trade wrapped nomins without accruing fees on those transactions.\n', '\n', 'In order to prevent tyranny, an account may only be frozen if\n', 'users controlling at least 30% of the value of havvens participate,\n', 'and a two thirds majority is attained in that vote.\n', 'In order to prevent tyranny of the majority or mob justice,\n', 'confiscation motions are only approved if the havven foundation\n', 'approves the result.\n', 'This latter requirement may be lifted in future versions.\n', '\n', 'The foundation, or any user with a sufficient havven balance may bring a\n', 'confiscation motion.\n', 'A motion lasts for a default period of one week, with a further confirmation\n', 'period in which the foundation approves the result.\n', 'The latter period may conclude early upon the foundation&#39;s decision to either\n', 'veto or approve the mooted confiscation motion.\n', 'If the confirmation period elapses without the foundation making a decision,\n', 'the motion fails.\n', '\n', 'The weight of a havven holder&#39;s vote is determined by examining their\n', 'average balance over the last completed fee period prior to the\n', 'beginning of a given motion.\n', 'Thus, since a fee period can roll over in the middle of a motion, we must\n', 'also track a user&#39;s average balance of the last two periods.\n', 'This system is designed such that it cannot be attacked by users transferring\n', 'funds between themselves, while also not requiring them to lock their havvens\n', 'for the duration of the vote. This is possible since any transfer that increases\n', 'the average balance in one account will be reflected by an equivalent reduction\n', 'in the voting weight in the other.\n', 'At present a user may cast a vote only for one motion at a time,\n', 'but may cancel their vote at any time except during the confirmation period,\n', 'when the vote tallies must remain static until the matter has been settled.\n', '\n', 'A motion to confiscate the balance of a given address composes\n', 'a state machine built of the following states:\n', '\n', '\n', 'Waiting:\n', '  - A user with standing brings a motion:\n', '    If the target address is not frozen;\n', '    initialise vote tallies to 0;\n', '    transition to the Voting state.\n', '\n', '  - An account cancels a previous residual vote:\n', '    remain in the Waiting state.\n', '\n', 'Voting:\n', '  - The foundation vetoes the in-progress motion:\n', '    transition to the Waiting state.\n', '\n', '  - The voting period elapses:\n', '    transition to the Confirmation state.\n', '\n', '  - An account votes (for or against the motion):\n', '    its weight is added to the appropriate tally;\n', '    remain in the Voting state.\n', '\n', '  - An account cancels its previous vote:\n', '    its weight is deducted from the appropriate tally (if any);\n', '    remain in the Voting state.\n', '\n', 'Confirmation:\n', '  - The foundation vetoes the completed motion:\n', '    transition to the Waiting state.\n', '\n', '  - The foundation approves confiscation of the target account:\n', '    freeze the target account, transfer its nomin balance to the fee pool;\n', '    transition to the Waiting state.\n', '\n', '  - The confirmation period elapses:\n', '    transition to the Waiting state.\n', '\n', '\n', 'User votes are not automatically cancelled upon the conclusion of a motion.\n', 'Therefore, after a motion comes to a conclusion, if a user wishes to vote \n', 'in another motion, they must manually cancel their vote in order to do so.\n', '\n', 'This procedure is designed to be relatively simple.\n', 'There are some things that can be added to enhance the functionality\n', 'at the expense of simplicity and efficiency:\n', '  \n', '  - Democratic unfreezing of nomin accounts (induces multiple categories of vote)\n', '  - Configurable per-vote durations;\n', '  - Vote standing denominated in a fiat quantity rather than a quantity of havvens;\n', '  - Confiscate from multiple addresses in a single vote;\n', '\n', 'We might consider updating the contract with any of these features at a later date if necessary.\n', '\n', '-----------------------------------------------------------------\n', '*/\n', '\n', 'contract Court is Owned, SafeDecimalMath {\n', '\n', '    /* ========== STATE VARIABLES ========== */\n', '\n', '    // The addresses of the token contracts this confiscation court interacts with.\n', '    Havven public havven;\n', '    EtherNomin public nomin;\n', '\n', '    // The minimum havven balance required to be considered to have standing\n', '    // to begin confiscation proceedings.\n', '    uint public minStandingBalance = 100 * UNIT;\n', '\n', '    // The voting period lasts for this duration,\n', '    // and if set, must fall within the given bounds.\n', '    uint public votingPeriod = 1 weeks;\n', '    uint constant MIN_VOTING_PERIOD = 3 days;\n', '    uint constant MAX_VOTING_PERIOD = 4 weeks;\n', '\n', '    // Duration of the period during which the foundation may confirm\n', '    // or veto a motion that has concluded.\n', '    // If set, the confirmation duration must fall within the given bounds.\n', '    uint public confirmationPeriod = 1 weeks;\n', '    uint constant MIN_CONFIRMATION_PERIOD = 1 days;\n', '    uint constant MAX_CONFIRMATION_PERIOD = 2 weeks;\n', '\n', '    // No fewer than this fraction of havvens must participate in a motion\n', '    // in order for a quorum to be reached.\n', '    // The participation fraction required may be set no lower than 10%.\n', '    uint public requiredParticipation = 3 * UNIT / 10;\n', '    uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10;\n', '\n', '    // At least this fraction of participating votes must be in favour of\n', '    // confiscation for the motion to pass.\n', '    // The required majority may be no lower than 50%.\n', '    uint public requiredMajority = (2 * UNIT) / 3;\n', '    uint constant MIN_REQUIRED_MAJORITY = UNIT / 2;\n', '\n', '    // The next ID to use for opening a motion.\n', '    uint nextMotionID = 1;\n', '\n', '    // Mapping from motion IDs to target addresses.\n', '    mapping(uint => address) public motionTarget;\n', '\n', '    // The ID a motion on an address is currently operating at.\n', '    // Zero if no such motion is running.\n', '    mapping(address => uint) public targetMotionID;\n', '\n', '    // The timestamp at which a motion began. This is used to determine\n', '    // whether a motion is: running, in the confirmation period,\n', '    // or has concluded.\n', '    // A motion runs from its start time t until (t + votingPeriod),\n', '    // and then the confirmation period terminates no later than\n', '    // (t + votingPeriod + confirmationPeriod).\n', '    mapping(uint => uint) public motionStartTime;\n', '\n', '    // The tallies for and against confiscation of a given balance.\n', '    // These are set to zero at the start of a motion, and also on conclusion,\n', '    // just to keep the state clean.\n', '    mapping(uint => uint) public votesFor;\n', '    mapping(uint => uint) public votesAgainst;\n', '\n', '    // The last/penultimate average balance of a user at the time they voted\n', '    // in a particular motion.\n', '    // If we did not save this information then we would have to\n', '    // disallow transfers into an account lest it cancel a vote\n', '    // with greater weight than that with which it originally voted,\n', '    // and the fee period rolled over in between.\n', '    mapping(address => mapping(uint => uint)) voteWeight;\n', '\n', '    // The possible vote types.\n', '    // Abstention: not participating in a motion; This is the default value.\n', '    // Yea: voting in favour of a motion.\n', '    // Nay: voting against a motion.\n', '    enum Vote {Abstention, Yea, Nay}\n', '\n', '    // A given account&#39;s vote in some confiscation motion.\n', '    // This requires the default value of the Vote enum to correspond to an abstention.\n', '    mapping(address => mapping(uint => Vote)) public vote;\n', '\n', '    /* ========== CONSTRUCTOR ========== */\n', '\n', '    function Court(Havven _havven, EtherNomin _nomin, address _owner)\n', '        Owned(_owner)\n', '        public\n', '    {\n', '        havven = _havven;\n', '        nomin = _nomin;\n', '    }\n', '\n', '\n', '    /* ========== SETTERS ========== */\n', '\n', '    function setMinStandingBalance(uint balance)\n', '        external\n', '        onlyOwner\n', '    {\n', '        // No requirement on the standing threshold here;\n', '        // the foundation can set this value such that\n', '        // anyone or no one can actually start a motion.\n', '        minStandingBalance = balance;\n', '    }\n', '\n', '    function setVotingPeriod(uint duration)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(MIN_VOTING_PERIOD <= duration &&\n', '                duration <= MAX_VOTING_PERIOD);\n', '        // Require that the voting period is no longer than a single fee period,\n', '        // So that a single vote can span at most two fee periods.\n', '        require(duration <= havven.targetFeePeriodDurationSeconds());\n', '        votingPeriod = duration;\n', '    }\n', '\n', '    function setConfirmationPeriod(uint duration)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(MIN_CONFIRMATION_PERIOD <= duration &&\n', '                duration <= MAX_CONFIRMATION_PERIOD);\n', '        confirmationPeriod = duration;\n', '    }\n', '\n', '    function setRequiredParticipation(uint fraction)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(MIN_REQUIRED_PARTICIPATION <= fraction);\n', '        requiredParticipation = fraction;\n', '    }\n', '\n', '    function setRequiredMajority(uint fraction)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(MIN_REQUIRED_MAJORITY <= fraction);\n', '        requiredMajority = fraction;\n', '    }\n', '\n', '\n', '    /* ========== VIEW FUNCTIONS ========== */\n', '\n', '    /* There is a motion in progress on the specified\n', '     * account, and votes are being accepted in that motion. */\n', '    function motionVoting(uint motionID)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        // No need to check (startTime < now) as there is no way\n', '        // to set future start times for votes.\n', '        // These values are timestamps, they will not overflow\n', '        // as they can only ever be initialised to relatively small values.\n', '        return now < motionStartTime[motionID] + votingPeriod;\n', '    }\n', '\n', '    /* A vote on the target account has concluded, but the motion\n', '     * has not yet been approved, vetoed, or closed. */\n', '    function motionConfirming(uint motionID)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        // These values are timestamps, they will not overflow\n', '        // as they can only ever be initialised to relatively small values.\n', '        uint startTime = motionStartTime[motionID];\n', '        return startTime + votingPeriod <= now &&\n', '               now < startTime + votingPeriod + confirmationPeriod;\n', '    }\n', '\n', '    /* A vote motion either not begun, or it has completely terminated. */\n', '    function motionWaiting(uint motionID)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        // These values are timestamps, they will not overflow\n', '        // as they can only ever be initialised to relatively small values.\n', '        return motionStartTime[motionID] + votingPeriod + confirmationPeriod <= now;\n', '    }\n', '\n', '    /* If the motion was to terminate at this instant, it would pass.\n', '     * That is: there was sufficient participation and a sizeable enough majority. */\n', '    function motionPasses(uint motionID)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        uint yeas = votesFor[motionID];\n', '        uint nays = votesAgainst[motionID];\n', '        uint totalVotes = safeAdd(yeas, nays);\n', '\n', '        if (totalVotes == 0) {\n', '            return false;\n', '        }\n', '\n', '        uint participation = safeDiv_dec(totalVotes, havven.totalSupply());\n', '        uint fractionInFavour = safeDiv_dec(yeas, totalVotes);\n', '\n', '        // We require the result to be strictly greater than the requirement\n', '        // to enforce a majority being "50% + 1", and so on.\n', '        return participation > requiredParticipation &&\n', '               fractionInFavour > requiredMajority;\n', '    }\n', '\n', '    function hasVoted(address account, uint motionID)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return vote[account][motionID] != Vote.Abstention;\n', '    }\n', '\n', '\n', '    /* ========== MUTATIVE FUNCTIONS ========== */\n', '\n', '    /* Begin a motion to confiscate the funds in a given nomin account.\n', '     * Only the foundation, or accounts with sufficient havven balances\n', '     * may elect to start such a motion.\n', '     * Returns the ID of the motion that was begun. */\n', '    function beginMotion(address target)\n', '        external\n', '        returns (uint)\n', '    {\n', '        // A confiscation motion must be mooted by someone with standing.\n', '        require((havven.balanceOf(msg.sender) >= minStandingBalance) ||\n', '                msg.sender == owner);\n', '\n', '        // Require that the voting period is longer than a single fee period,\n', '        // So that a single vote can span at most two fee periods.\n', '        require(votingPeriod <= havven.targetFeePeriodDurationSeconds());\n', '\n', '        // There must be no confiscation motion already running for this account.\n', '        require(targetMotionID[target] == 0);\n', '\n', '        // Disallow votes on accounts that have previously been frozen.\n', '        require(!nomin.frozen(target));\n', '\n', '        uint motionID = nextMotionID++;\n', '        motionTarget[motionID] = target;\n', '        targetMotionID[target] = motionID;\n', '\n', '        motionStartTime[motionID] = now;\n', '        emit MotionBegun(msg.sender, msg.sender, target, target, motionID, motionID);\n', '\n', '        return motionID;\n', '    }\n', '\n', '    /* Shared vote setup function between voteFor and voteAgainst.\n', '     * Returns the voter&#39;s vote weight. */\n', '    function setupVote(uint motionID)\n', '        internal\n', '        returns (uint)\n', '    {\n', '        // There must be an active vote for this target running.\n', '        // Vote totals must only change during the voting phase.\n', '        require(motionVoting(motionID));\n', '\n', '        // The voter must not have an active vote this motion.\n', '        require(!hasVoted(msg.sender, motionID));\n', '\n', '        // The voter may not cast votes on themselves.\n', '        require(msg.sender != motionTarget[motionID]);\n', '\n', '        // Ensure the voter&#39;s vote weight is current.\n', '        havven.recomputeAccountLastAverageBalance(msg.sender);\n', '\n', '        uint weight;\n', '        // We use a fee period guaranteed to have terminated before\n', '        // the start of the vote. Select the right period if\n', '        // a fee period rolls over in the middle of the vote.\n', '        if (motionStartTime[motionID] < havven.feePeriodStartTime()) {\n', '            weight = havven.penultimateAverageBalance(msg.sender);\n', '        } else {\n', '            weight = havven.lastAverageBalance(msg.sender);\n', '        }\n', '\n', '        // Users must have a nonzero voting weight to vote.\n', '        require(weight > 0);\n', '\n', '        voteWeight[msg.sender][motionID] = weight;\n', '\n', '        return weight;\n', '    }\n', '\n', '    /* The sender casts a vote in favour of confiscation of the\n', '     * target account&#39;s nomin balance. */\n', '    function voteFor(uint motionID)\n', '        external\n', '    {\n', '        uint weight = setupVote(motionID);\n', '        vote[msg.sender][motionID] = Vote.Yea;\n', '        votesFor[motionID] = safeAdd(votesFor[motionID], weight);\n', '        emit VotedFor(msg.sender, msg.sender, motionID, motionID, weight);\n', '    }\n', '\n', '    /* The sender casts a vote against confiscation of the\n', '     * target account&#39;s nomin balance. */\n', '    function voteAgainst(uint motionID)\n', '        external\n', '    {\n', '        uint weight = setupVote(motionID);\n', '        vote[msg.sender][motionID] = Vote.Nay;\n', '        votesAgainst[motionID] = safeAdd(votesAgainst[motionID], weight);\n', '        emit VotedAgainst(msg.sender, msg.sender, motionID, motionID, weight);\n', '    }\n', '\n', '    /* Cancel an existing vote by the sender on a motion\n', '     * to confiscate the target balance. */\n', '    function cancelVote(uint motionID)\n', '        external\n', '    {\n', '        // An account may cancel its vote either before the confirmation phase\n', '        // when the motion is still open, or after the confirmation phase,\n', '        // when the motion has concluded.\n', '        // But the totals must not change during the confirmation phase itself.\n', '        require(!motionConfirming(motionID));\n', '\n', '        Vote senderVote = vote[msg.sender][motionID];\n', '\n', '        // If the sender has not voted then there is no need to update anything.\n', '        require(senderVote != Vote.Abstention);\n', '\n', '        // If we are not voting, there is no reason to update the vote totals.\n', '        if (motionVoting(motionID)) {\n', '            if (senderVote == Vote.Yea) {\n', '                votesFor[motionID] = safeSub(votesFor[motionID], voteWeight[msg.sender][motionID]);\n', '            } else {\n', '                // Since we already ensured that the vote is not an abstention,\n', '                // the only option remaining is Vote.Nay.\n', '                votesAgainst[motionID] = safeSub(votesAgainst[motionID], voteWeight[msg.sender][motionID]);\n', '            }\n', '            // A cancelled vote is only meaningful if a vote is running\n', '            emit VoteCancelled(msg.sender, msg.sender, motionID, motionID);\n', '        }\n', '\n', '        delete voteWeight[msg.sender][motionID];\n', '        delete vote[msg.sender][motionID];\n', '    }\n', '\n', '    function _closeMotion(uint motionID)\n', '        internal\n', '    {\n', '        delete targetMotionID[motionTarget[motionID]];\n', '        delete motionTarget[motionID];\n', '        delete motionStartTime[motionID];\n', '        delete votesFor[motionID];\n', '        delete votesAgainst[motionID];\n', '        emit MotionClosed(motionID, motionID);\n', '    }\n', '\n', '    /* If a motion has concluded, or if it lasted its full duration but not passed,\n', '     * then anyone may close it. */\n', '    function closeMotion(uint motionID)\n', '        external\n', '    {\n', '        require((motionConfirming(motionID) && !motionPasses(motionID)) || motionWaiting(motionID));\n', '        _closeMotion(motionID);\n', '    }\n', '\n', '    /* The foundation may only confiscate a balance during the confirmation\n', '     * period after a motion has passed. */\n', '    function approveMotion(uint motionID)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(motionConfirming(motionID) && motionPasses(motionID));\n', '        address target = motionTarget[motionID];\n', '        nomin.confiscateBalance(target);\n', '        _closeMotion(motionID);\n', '        emit MotionApproved(motionID, motionID);\n', '    }\n', '\n', '    /* The foundation may veto a motion at any time. */\n', '    function vetoMotion(uint motionID)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(!motionWaiting(motionID));\n', '        _closeMotion(motionID);\n', '        emit MotionVetoed(motionID, motionID);\n', '    }\n', '\n', '\n', '    /* ========== EVENTS ========== */\n', '\n', '    event MotionBegun(address initiator, address indexed initiatorIndex, address target, address indexed targetIndex, uint motionID, uint indexed motionIDIndex);\n', '\n', '    event VotedFor(address voter, address indexed voterIndex, uint motionID, uint indexed motionIDIndex, uint weight);\n', '\n', '    event VotedAgainst(address voter, address indexed voterIndex, uint motionID, uint indexed motionIDIndex, uint weight);\n', '\n', '    event VoteCancelled(address voter, address indexed voterIndex, uint motionID, uint indexed motionIDIndex);\n', '\n', '    event MotionClosed(uint motionID, uint indexed motionIDIndex);\n', '\n', '    event MotionVetoed(uint motionID, uint indexed motionIDIndex);\n', '\n', '    event MotionApproved(uint motionID, uint indexed motionIDIndex);\n', '}\n', '\n', '/*\n', '-----------------------------------------------------------------\n', 'CONTRACT DESCRIPTION\n', '-----------------------------------------------------------------\n', '\n', 'A token which also has a configurable fee rate\n', 'charged on its transfers. This is designed to be overridden in\n', 'order to produce an ERC20-compliant token.\n', '\n', 'These fees accrue into a pool, from which a nominated authority\n', 'may withdraw.\n', '\n', 'This contract utilises a state for upgradability purposes.\n', 'It relies on being called underneath a proxy contract, as\n', 'included in Proxy.sol.\n', '\n', '-----------------------------------------------------------------\n', '*/\n', '\n', 'contract ExternStateProxyFeeToken is Proxyable, SafeDecimalMath {\n', '\n', '    /* ========== STATE VARIABLES ========== */\n', '\n', '    // Stores balances and allowances.\n', '    TokenState public state;\n', '\n', '    // Other ERC20 fields\n', '    string public name;\n', '    string public symbol;\n', '    uint public totalSupply;\n', '\n', '    // A percentage fee charged on each transfer.\n', '    uint public transferFeeRate;\n', '    // Fee may not exceed 10%.\n', '    uint constant MAX_TRANSFER_FEE_RATE = UNIT / 10;\n', '    // The address with the authority to distribute fees.\n', '    address public feeAuthority;\n', '\n', '\n', '    /* ========== CONSTRUCTOR ========== */\n', '\n', '    function ExternStateProxyFeeToken(string _name, string _symbol,\n', '                                      uint _transferFeeRate, address _feeAuthority,\n', '                                      TokenState _state, address _owner)\n', '        Proxyable(_owner)\n', '        public\n', '    {\n', '        if (_state == TokenState(0)) {\n', '            state = new TokenState(_owner, address(this));\n', '        } else {\n', '            state = _state;\n', '        }\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '        transferFeeRate = _transferFeeRate;\n', '        feeAuthority = _feeAuthority;\n', '    }\n', '\n', '    /* ========== SETTERS ========== */\n', '\n', '    function setTransferFeeRate(uint _transferFeeRate)\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        require(_transferFeeRate <= MAX_TRANSFER_FEE_RATE);\n', '        transferFeeRate = _transferFeeRate;\n', '        emit TransferFeeRateUpdated(_transferFeeRate);\n', '    }\n', '\n', '    function setFeeAuthority(address _feeAuthority)\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        feeAuthority = _feeAuthority;\n', '        emit FeeAuthorityUpdated(_feeAuthority);\n', '    }\n', '\n', '    function setState(TokenState _state)\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        state = _state;\n', '        emit StateUpdated(_state);\n', '    }\n', '\n', '    /* ========== VIEWS ========== */\n', '\n', '    function balanceOf(address account)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return state.balanceOf(account);\n', '    }\n', '\n', '    function allowance(address from, address to)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return state.allowance(from, to);\n', '    }\n', '\n', '    // Return the fee charged on top in order to transfer _value worth of tokens.\n', '    function transferFeeIncurred(uint value)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return safeMul_dec(value, transferFeeRate);\n', '        // Transfers less than the reciprocal of transferFeeRate should be completely eaten up by fees.\n', '        // This is on the basis that transfers less than this value will result in a nil fee.\n', '        // Probably too insignificant to worry about, but the following code will achieve it.\n', '        //      if (fee == 0 && transferFeeRate != 0) {\n', '        //          return _value;\n', '        //      }\n', '        //      return fee;\n', '    }\n', '\n', '    // The value that you would need to send so that the recipient receives\n', '    // a specified value.\n', '    function transferPlusFee(uint value)\n', '        external\n', '        view\n', '        returns (uint)\n', '    {\n', '        return safeAdd(value, transferFeeIncurred(value));\n', '    }\n', '\n', '    // The quantity to send in order that the sender spends a certain value of tokens.\n', '    function priceToSpend(uint value)\n', '        external\n', '        view\n', '        returns (uint)\n', '    {\n', '        return safeDiv_dec(value, safeAdd(UNIT, transferFeeRate));\n', '    }\n', '\n', '    // The balance of the nomin contract itself is the fee pool.\n', '    // Collected fees sit here until they are distributed.\n', '    function feePool()\n', '        external\n', '        view\n', '        returns (uint)\n', '    {\n', '        return state.balanceOf(address(this));\n', '    }\n', '\n', '\n', '    /* ========== MUTATIVE FUNCTIONS ========== */\n', '\n', '    /* Whatever calls this should have either the optionalProxy or onlyProxy modifier,\n', '     * and pass in messageSender. */\n', '    function _transfer_byProxy(address sender, address to, uint value)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        require(to != address(0));\n', '\n', '        // The fee is deducted from the sender&#39;s balance, in addition to\n', '        // the transferred quantity.\n', '        uint fee = transferFeeIncurred(value);\n', '        uint totalCharge = safeAdd(value, fee);\n', '\n', '        // Insufficient balance will be handled by the safe subtraction.\n', '        state.setBalanceOf(sender, safeSub(state.balanceOf(sender), totalCharge));\n', '        state.setBalanceOf(to, safeAdd(state.balanceOf(to), value));\n', '        state.setBalanceOf(address(this), safeAdd(state.balanceOf(address(this)), fee));\n', '\n', '        emit Transfer(sender, to, value);\n', '        emit TransferFeePaid(sender, fee);\n', '        emit Transfer(sender, address(this), fee);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* Whatever calls this should have either the optionalProxy or onlyProxy modifier,\n', '     * and pass in messageSender. */\n', '    function _transferFrom_byProxy(address sender, address from, address to, uint value)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        require(to != address(0));\n', '\n', '        // The fee is deducted from the sender&#39;s balance, in addition to\n', '        // the transferred quantity.\n', '        uint fee = transferFeeIncurred(value);\n', '        uint totalCharge = safeAdd(value, fee);\n', '\n', '        // Insufficient balance will be handled by the safe subtraction.\n', '        state.setBalanceOf(from, safeSub(state.balanceOf(from), totalCharge));\n', '        state.setAllowance(from, sender, safeSub(state.allowance(from, sender), totalCharge));\n', '        state.setBalanceOf(to, safeAdd(state.balanceOf(to), value));\n', '        state.setBalanceOf(address(this), safeAdd(state.balanceOf(address(this)), fee));\n', '\n', '        emit Transfer(from, to, value);\n', '        emit TransferFeePaid(sender, fee);\n', '        emit Transfer(from, address(this), fee);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint value)\n', '        external\n', '        optionalProxy\n', '        returns (bool)\n', '    {\n', '        address sender = messageSender;\n', '        state.setAllowance(sender, spender, value);\n', '\n', '        emit Approval(sender, spender, value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* Withdraw tokens from the fee pool into a given account. */\n', '    function withdrawFee(address account, uint value)\n', '        external\n', '        returns (bool)\n', '    {\n', '        require(msg.sender == feeAuthority && account != address(0));\n', '        \n', '        // 0-value withdrawals do nothing.\n', '        if (value == 0) {\n', '            return false;\n', '        }\n', '\n', '        // Safe subtraction ensures an exception is thrown if the balance is insufficient.\n', '        state.setBalanceOf(address(this), safeSub(state.balanceOf(address(this)), value));\n', '        state.setBalanceOf(account, safeAdd(state.balanceOf(account), value));\n', '\n', '        emit FeesWithdrawn(account, account, value);\n', '        emit Transfer(address(this), account, value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* Donate tokens from the sender&#39;s balance into the fee pool. */\n', '    function donateToFeePool(uint n)\n', '        external\n', '        optionalProxy\n', '        returns (bool)\n', '    {\n', '        address sender = messageSender;\n', '\n', '        // Empty donations are disallowed.\n', '        uint balance = state.balanceOf(sender);\n', '        require(balance != 0);\n', '\n', '        // safeSub ensures the donor has sufficient balance.\n', '        state.setBalanceOf(sender, safeSub(balance, n));\n', '        state.setBalanceOf(address(this), safeAdd(state.balanceOf(address(this)), n));\n', '\n', '        emit FeesDonated(sender, sender, n);\n', '        emit Transfer(sender, address(this), n);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* ========== EVENTS ========== */\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    event TransferFeePaid(address indexed account, uint value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '    event TransferFeeRateUpdated(uint newFeeRate);\n', '\n', '    event FeeAuthorityUpdated(address feeAuthority);\n', '\n', '    event StateUpdated(address newState);\n', '\n', '    event FeesWithdrawn(address account, address indexed accountIndex, uint value);\n', '\n', '    event FeesDonated(address donor, address indexed donorIndex, uint value);\n', '}\n', '\n', '/*\n', '-----------------------------------------------------------------\n', 'CONTRACT DESCRIPTION\n', '-----------------------------------------------------------------\n', '\n', 'Ether-backed nomin stablecoin contract.\n', '\n', 'This contract issues nomins, which are tokens worth 1 USD each. They are backed\n', 'by a pool of ether collateral, so that if a user has nomins, they may\n', 'redeem them for ether from the pool, or if they want to obtain nomins,\n', 'they may pay ether into the pool in order to do so.\n', '\n', 'The supply of nomins that may be in circulation at any time is limited.\n', 'The contract owner may increase this quantity, but only if they provide\n', 'ether to back it. The backing the owner provides at issuance must\n', 'keep each nomin at least twice overcollateralised.\n', 'The owner may also destroy nomins in the pool, which is potential avenue\n', 'by which to maintain healthy collateralisation levels, as it reduces\n', 'supply without withdrawing ether collateral.\n', '\n', 'A configurable fee is charged on nomin transfers and deposited\n', 'into a common pot, which havven holders may withdraw from once per\n', 'fee period.\n', '\n', 'Ether price is continually updated by an external oracle, and the value\n', 'of the backing is computed on this basis. To ensure the integrity of\n', 'this system, if the contract&#39;s price has not been updated recently enough,\n', 'it will temporarily disable itself until it receives more price information.\n', '\n', 'The contract owner may at any time initiate contract liquidation.\n', 'During the liquidation period, most contract functions will be deactivated.\n', 'No new nomins may be issued or bought, but users may sell nomins back\n', 'to the system.\n', 'If the system&#39;s collateral falls below a specified level, then anyone\n', 'may initiate liquidation.\n', '\n', 'After the liquidation period has elapsed, which is initially 90 days,\n', 'the owner may destroy the contract, transferring any remaining collateral\n', 'to a nominated beneficiary address.\n', 'This liquidation period may be extended up to a maximum of 180 days.\n', 'If the contract is recollateralised, the owner may terminate liquidation.\n', '\n', '-----------------------------------------------------------------\n', '*/\n', '\n', 'contract EtherNomin is ExternStateProxyFeeToken {\n', '\n', '    /* ========== STATE VARIABLES ========== */\n', '\n', '    // The oracle provides price information to this contract.\n', '    // It may only call the updatePrice() function.\n', '    address public oracle;\n', '\n', '    // The address of the contract which manages confiscation votes.\n', '    Court public court;\n', '\n', '    // Foundation wallet for funds to go to post liquidation.\n', '    address public beneficiary;\n', '\n', '    // Nomins in the pool ready to be sold.\n', '    uint public nominPool;\n', '\n', '    // Impose a 50 basis-point fee for buying from and selling to the nomin pool.\n', '    uint public poolFeeRate = UNIT / 200;\n', '\n', '    // The minimum purchasable quantity of nomins is 1 cent.\n', '    uint constant MINIMUM_PURCHASE = UNIT / 100;\n', '\n', '    // When issuing, nomins must be overcollateralised by this ratio.\n', '    uint constant MINIMUM_ISSUANCE_RATIO =  2 * UNIT;\n', '\n', '    // If the collateralisation ratio of the contract falls below this level,\n', '    // immediately begin liquidation.\n', '    uint constant AUTO_LIQUIDATION_RATIO = UNIT;\n', '\n', '    // The liquidation period is the duration that must pass before the liquidation period is complete.\n', '    // It can be extended up to a given duration.\n', '    uint constant DEFAULT_LIQUIDATION_PERIOD = 90 days;\n', '    uint constant MAX_LIQUIDATION_PERIOD = 180 days;\n', '    uint public liquidationPeriod = DEFAULT_LIQUIDATION_PERIOD;\n', '\n', '    // The timestamp when liquidation was activated. We initialise this to\n', '    // uint max, so that we know that we are under liquidation if the\n', '    // liquidation timestamp is in the past.\n', '    uint public liquidationTimestamp = ~uint(0);\n', '\n', '    // Ether price from oracle (fiat per ether).\n', '    uint public etherPrice;\n', '\n', '    // Last time the price was updated.\n', '    uint public lastPriceUpdate;\n', '\n', '    // The period it takes for the price to be considered stale.\n', '    // If the price is stale, functions that require the price are disabled.\n', '    uint public stalePeriod = 2 days;\n', '\n', '    // Accounts which have lost the privilege to transact in nomins.\n', '    mapping(address => bool) public frozen;\n', '\n', '\n', '    /* ========== CONSTRUCTOR ========== */\n', '\n', '    function EtherNomin(address _havven, address _oracle,\n', '                        address _beneficiary,\n', '                        uint initialEtherPrice,\n', '                        address _owner, TokenState initialState)\n', '        ExternStateProxyFeeToken("Ether-Backed USD Nomins", "eUSD",\n', '                                 15 * UNIT / 10000, // nomin transfers incur a 15 bp fee\n', '                                 _havven, // the havven contract is the fee authority\n', '                                 initialState,\n', '                                 _owner)\n', '        public\n', '    {\n', '        oracle = _oracle;\n', '        beneficiary = _beneficiary;\n', '\n', '        etherPrice = initialEtherPrice;\n', '        lastPriceUpdate = now;\n', '        emit PriceUpdated(etherPrice);\n', '\n', '        // It should not be possible to transfer to the nomin contract itself.\n', '        frozen[this] = true;\n', '    }\n', '\n', '\n', '    /* ========== SETTERS ========== */\n', '\n', '    function setOracle(address _oracle)\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        oracle = _oracle;\n', '        emit OracleUpdated(_oracle);\n', '    }\n', '\n', '    function setCourt(Court _court)\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        court = _court;\n', '        emit CourtUpdated(_court);\n', '    }\n', '\n', '    function setBeneficiary(address _beneficiary)\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        beneficiary = _beneficiary;\n', '        emit BeneficiaryUpdated(_beneficiary);\n', '    }\n', '\n', '    function setPoolFeeRate(uint _poolFeeRate)\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        require(_poolFeeRate <= UNIT);\n', '        poolFeeRate = _poolFeeRate;\n', '        emit PoolFeeRateUpdated(_poolFeeRate);\n', '    }\n', '\n', '    function setStalePeriod(uint _stalePeriod)\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        stalePeriod = _stalePeriod;\n', '        emit StalePeriodUpdated(_stalePeriod);\n', '    }\n', ' \n', '\n', '    /* ========== VIEW FUNCTIONS ========== */ \n', '\n', '    /* Return the equivalent fiat value of the given quantity\n', '     * of ether at the current price.\n', '     * Reverts if the price is stale. */\n', '    function fiatValue(uint eth)\n', '        public\n', '        view\n', '        priceNotStale\n', '        returns (uint)\n', '    {\n', '        return safeMul_dec(eth, etherPrice);\n', '    }\n', '\n', '    /* Return the current fiat value of the contract&#39;s balance.\n', '     * Reverts if the price is stale. */\n', '    function fiatBalance()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        // Price staleness check occurs inside the call to fiatValue.\n', '        return fiatValue(address(this).balance);\n', '    }\n', '\n', '    /* Return the equivalent ether value of the given quantity\n', '     * of fiat at the current price.\n', '     * Reverts if the price is stale. */\n', '    function etherValue(uint fiat)\n', '        public\n', '        view\n', '        priceNotStale\n', '        returns (uint)\n', '    {\n', '        return safeDiv_dec(fiat, etherPrice);\n', '    }\n', '\n', '    /* The same as etherValue(), but without the stale price check. */\n', '    function etherValueAllowStale(uint fiat) \n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        return safeDiv_dec(fiat, etherPrice);\n', '    }\n', '\n', '    /* Return the units of fiat per nomin in the supply.\n', '     * Reverts if the price is stale. */\n', '    function collateralisationRatio()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return safeDiv_dec(fiatBalance(), _nominCap());\n', '    }\n', '\n', '    /* Return the maximum number of extant nomins,\n', '     * equal to the nomin pool plus total (circulating) supply. */\n', '    function _nominCap()\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        return safeAdd(nominPool, totalSupply);\n', '    }\n', '\n', '    /* Return the fee charged on a purchase or sale of n nomins. */\n', '    function poolFeeIncurred(uint n)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return safeMul_dec(n, poolFeeRate);\n', '    }\n', '\n', '    /* Return the fiat cost (including fee) of purchasing n nomins.\n', '     * Nomins are purchased for $1, plus the fee. */\n', '    function purchaseCostFiat(uint n)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return safeAdd(n, poolFeeIncurred(n));\n', '    }\n', '\n', '    /* Return the ether cost (including fee) of purchasing n nomins.\n', '     * Reverts if the price is stale. */\n', '    function purchaseCostEther(uint n)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        // Price staleness check occurs inside the call to etherValue.\n', '        return etherValue(purchaseCostFiat(n));\n', '    }\n', '\n', '    /* Return the fiat proceeds (less the fee) of selling n nomins.\n', '     * Nomins are sold for $1, minus the fee. */\n', '    function saleProceedsFiat(uint n)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return safeSub(n, poolFeeIncurred(n));\n', '    }\n', '\n', '    /* Return the ether proceeds (less the fee) of selling n\n', '     * nomins.\n', '     * Reverts if the price is stale. */\n', '    function saleProceedsEther(uint n)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        // Price staleness check occurs inside the call to etherValue.\n', '        return etherValue(saleProceedsFiat(n));\n', '    }\n', '\n', '    /* The same as saleProceedsEther(), but without the stale price check. */\n', '    function saleProceedsEtherAllowStale(uint n)\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        return etherValueAllowStale(saleProceedsFiat(n));\n', '    }\n', '\n', '    /* True iff the current block timestamp is later than the time\n', '     * the price was last updated, plus the stale period. */\n', '    function priceIsStale()\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return safeAdd(lastPriceUpdate, stalePeriod) < now;\n', '    }\n', '\n', '    function isLiquidating()\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return liquidationTimestamp <= now;\n', '    }\n', '\n', '    /* True if the contract is self-destructible. \n', '     * This is true if either the complete liquidation period has elapsed,\n', '     * or if all tokens have been returned to the contract and it has been\n', '     * in liquidation for at least a week.\n', '     * Since the contract is only destructible after the liquidationTimestamp,\n', '     * a fortiori canSelfDestruct() implies isLiquidating(). */\n', '    function canSelfDestruct()\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        // Not being in liquidation implies the timestamp is uint max, so it would roll over.\n', '        // We need to check whether we&#39;re in liquidation first.\n', '        if (isLiquidating()) {\n', '            // These timestamps and durations have values clamped within reasonable values and\n', '            // cannot overflow.\n', '            bool totalPeriodElapsed = liquidationTimestamp + liquidationPeriod < now;\n', '            // Total supply of 0 means all tokens have returned to the pool.\n', '            bool allTokensReturned = (liquidationTimestamp + 1 weeks < now) && (totalSupply == 0);\n', '            return totalPeriodElapsed || allTokensReturned;\n', '        }\n', '        return false;\n', '    }\n', '\n', '\n', '    /* ========== MUTATIVE FUNCTIONS ========== */\n', '\n', '    /* Override ERC20 transfer function in order to check\n', '     * whether the recipient account is frozen. Note that there is\n', '     * no need to check whether the sender has a frozen account,\n', '     * since their funds have already been confiscated,\n', '     * and no new funds can be transferred to it.*/\n', '    function transfer(address to, uint value)\n', '        public\n', '        optionalProxy\n', '        returns (bool)\n', '    {\n', '        require(!frozen[to]);\n', '        return _transfer_byProxy(messageSender, to, value);\n', '    }\n', '\n', '    /* Override ERC20 transferFrom function in order to check\n', '     * whether the recipient account is frozen. */\n', '    function transferFrom(address from, address to, uint value)\n', '        public\n', '        optionalProxy\n', '        returns (bool)\n', '    {\n', '        require(!frozen[to]);\n', '        return _transferFrom_byProxy(messageSender, from, to, value);\n', '    }\n', '\n', '    /* Update the current ether price and update the last updated time,\n', '     * refreshing the price staleness.\n', '     * Also checks whether the contract&#39;s collateral levels have fallen to low,\n', '     * and initiates liquidation if that is the case.\n', '     * Exceptional conditions:\n', '     *     Not called by the oracle.\n', '     *     Not the most recently sent price. */\n', '    function updatePrice(uint price, uint timeSent)\n', '        external\n', '        postCheckAutoLiquidate\n', '    {\n', '        // Should be callable only by the oracle.\n', '        require(msg.sender == oracle);\n', '        // Must be the most recently sent price, but not too far in the future.\n', '        // (so we can&#39;t lock ourselves out of updating the oracle for longer than this)\n', '        require(lastPriceUpdate < timeSent && timeSent < now + 10 minutes);\n', '\n', '        etherPrice = price;\n', '        lastPriceUpdate = timeSent;\n', '        emit PriceUpdated(price);\n', '    }\n', '\n', '    /* Issues n nomins into the pool available to be bought by users.\n', '     * Must be accompanied by $n worth of ether.\n', '     * Exceptional conditions:\n', '     *     Not called by contract owner.\n', '     *     Insufficient backing funds provided (post-issuance collateralisation below minimum requirement).\n', '     *     Price is stale. */\n', '    function replenishPool(uint n)\n', '        external\n', '        payable\n', '        notLiquidating\n', '        optionalProxy_onlyOwner\n', '    {\n', '        // Price staleness check occurs inside the call to fiatBalance.\n', '        // Safe additions are unnecessary here, as either the addition is checked on the following line\n', '        // or the overflow would cause the requirement not to be satisfied.\n', '        require(fiatBalance() >= safeMul_dec(safeAdd(_nominCap(), n), MINIMUM_ISSUANCE_RATIO));\n', '        nominPool = safeAdd(nominPool, n);\n', '        emit PoolReplenished(n, msg.value);\n', '    }\n', '\n', '    /* Burns n nomins from the pool.\n', '     * Exceptional conditions:\n', '     *     Not called by contract owner.\n', '     *     There are fewer than n nomins in the pool. */\n', '    function diminishPool(uint n)\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        // Require that there are enough nomins in the accessible pool to burn\n', '        require(nominPool >= n);\n', '        nominPool = safeSub(nominPool, n);\n', '        emit PoolDiminished(n);\n', '    }\n', '\n', '    /* Sends n nomins to the sender from the pool, in exchange for\n', '     * $n plus the fee worth of ether.\n', '     * Exceptional conditions:\n', '     *     Insufficient or too many funds provided.\n', '     *     More nomins requested than are in the pool.\n', '     *     n below the purchase minimum (1 cent).\n', '     *     contract in liquidation.\n', '     *     Price is stale. */\n', '    function buy(uint n)\n', '        external\n', '        payable\n', '        notLiquidating\n', '        optionalProxy\n', '    {\n', '        // Price staleness check occurs inside the call to purchaseEtherCost.\n', '        require(n >= MINIMUM_PURCHASE &&\n', '                msg.value == purchaseCostEther(n));\n', '        address sender = messageSender;\n', '        // sub requires that nominPool >= n\n', '        nominPool = safeSub(nominPool, n);\n', '        state.setBalanceOf(sender, safeAdd(state.balanceOf(sender), n));\n', '        emit Purchased(sender, sender, n, msg.value);\n', '        emit Transfer(0, sender, n);\n', '        totalSupply = safeAdd(totalSupply, n);\n', '    }\n', '\n', '    /* Sends n nomins to the pool from the sender, in exchange for\n', '     * $n minus the fee worth of ether.\n', '     * Exceptional conditions:\n', '     *     Insufficient nomins in sender&#39;s wallet.\n', '     *     Insufficient funds in the pool to pay sender.\n', '     *     Price is stale if not in liquidation. */\n', '    function sell(uint n)\n', '        external\n', '        optionalProxy\n', '    {\n', '\n', '        // Price staleness check occurs inside the call to saleProceedsEther,\n', '        // but we allow people to sell their nomins back to the system\n', '        // if we&#39;re in liquidation, regardless.\n', '        uint proceeds;\n', '        if (isLiquidating()) {\n', '            proceeds = saleProceedsEtherAllowStale(n);\n', '        } else {\n', '            proceeds = saleProceedsEther(n);\n', '        }\n', '\n', '        require(address(this).balance >= proceeds);\n', '\n', '        address sender = messageSender;\n', '        // sub requires that the balance is greater than n\n', '        state.setBalanceOf(sender, safeSub(state.balanceOf(sender), n));\n', '        nominPool = safeAdd(nominPool, n);\n', '        emit Sold(sender, sender, n, proceeds);\n', '        emit Transfer(sender, 0, n);\n', '        totalSupply = safeSub(totalSupply, n);\n', '        sender.transfer(proceeds);\n', '    }\n', '\n', '    /* Lock nomin purchase function in preparation for destroying the contract.\n', '     * While the contract is under liquidation, users may sell nomins back to the system.\n', '     * After liquidation period has terminated, the contract may be self-destructed,\n', '     * returning all remaining ether to the beneficiary address.\n', '     * Exceptional cases:\n', '     *     Not called by contract owner;\n', '     *     contract already in liquidation; */\n', '    function forceLiquidation()\n', '        external\n', '        notLiquidating\n', '        optionalProxy_onlyOwner\n', '    {\n', '        beginLiquidation();\n', '    }\n', '\n', '    function beginLiquidation()\n', '        internal\n', '    {\n', '        liquidationTimestamp = now;\n', '        emit LiquidationBegun(liquidationPeriod);\n', '    }\n', '\n', '    /* If the contract is liquidating, the owner may extend the liquidation period.\n', '     * It may only get longer, not shorter, and it may not be extended past\n', '     * the liquidation max. */\n', '    function extendLiquidationPeriod(uint extension)\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        require(isLiquidating());\n', '        uint sum = safeAdd(liquidationPeriod, extension);\n', '        require(sum <= MAX_LIQUIDATION_PERIOD);\n', '        liquidationPeriod = sum;\n', '        emit LiquidationExtended(extension);\n', '    }\n', '\n', '    /* Liquidation can only be stopped if the collateralisation ratio\n', '     * of this contract has recovered above the automatic liquidation\n', '     * threshold, for example if the ether price has increased,\n', '     * or by including enough ether in this transaction. */\n', '    function terminateLiquidation()\n', '        external\n', '        payable\n', '        priceNotStale\n', '        optionalProxy_onlyOwner\n', '    {\n', '        require(isLiquidating());\n', '        require(_nominCap() == 0 || collateralisationRatio() >= AUTO_LIQUIDATION_RATIO);\n', '        liquidationTimestamp = ~uint(0);\n', '        liquidationPeriod = DEFAULT_LIQUIDATION_PERIOD;\n', '        emit LiquidationTerminated();\n', '    }\n', '\n', '    /* The owner may destroy this contract, returning all funds back to the beneficiary\n', '     * wallet, may only be called after the contract has been in\n', '     * liquidation for at least liquidationPeriod, or all circulating\n', '     * nomins have been sold back into the pool. */\n', '    function selfDestruct()\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        require(canSelfDestruct());\n', '        emit SelfDestructed(beneficiary);\n', '        selfdestruct(beneficiary);\n', '    }\n', '\n', '    /* If a confiscation court motion has passed and reached the confirmation\n', '     * state, the court may transfer the target account&#39;s balance to the fee pool\n', '     * and freeze its participation in further transactions. */\n', '    function confiscateBalance(address target)\n', '        external\n', '    {\n', '        // Should be callable only by the confiscation court.\n', '        require(Court(msg.sender) == court);\n', '        \n', '        // A motion must actually be underway.\n', '        uint motionID = court.targetMotionID(target);\n', '        require(motionID != 0);\n', '\n', '        // These checks are strictly unnecessary,\n', '        // since they are already checked in the court contract itself.\n', '        // I leave them in out of paranoia.\n', '        require(court.motionConfirming(motionID));\n', '        require(court.motionPasses(motionID));\n', '        require(!frozen[target]);\n', '\n', '        // Confiscate the balance in the account and freeze it.\n', '        uint balance = state.balanceOf(target);\n', '        state.setBalanceOf(address(this), safeAdd(state.balanceOf(address(this)), balance));\n', '        state.setBalanceOf(target, 0);\n', '        frozen[target] = true;\n', '        emit AccountFrozen(target, target, balance);\n', '        emit Transfer(target, address(this), balance);\n', '    }\n', '\n', '    /* The owner may allow a previously-frozen contract to once\n', '     * again accept and transfer nomins. */\n', '    function unfreezeAccount(address target)\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        if (frozen[target] && EtherNomin(target) != this) {\n', '            frozen[target] = false;\n', '            emit AccountUnfrozen(target, target);\n', '        }\n', '    }\n', '\n', '    /* Fallback function allows convenient collateralisation of the contract,\n', '     * including by non-foundation parties. */\n', '    function() public payable {}\n', '\n', '\n', '    /* ========== MODIFIERS ========== */\n', '\n', '    modifier notLiquidating\n', '    {\n', '        require(!isLiquidating());\n', '        _;\n', '    }\n', '\n', '    modifier priceNotStale\n', '    {\n', '        require(!priceIsStale());\n', '        _;\n', '    }\n', '\n', '    /* Any function modified by this will automatically liquidate\n', '     * the system if the collateral levels are too low.\n', '     * This is called on collateral-value/nomin-supply modifying functions that can\n', '     * actually move the contract into liquidation. This is really only\n', '     * the price update, since issuance requires that the contract is overcollateralised,\n', '     * burning can only destroy tokens without withdrawing backing, buying from the pool can only\n', '     * asymptote to a collateralisation level of unity, while selling into the pool can only \n', '     * increase the collateralisation ratio.\n', '     * Additionally, price update checks should/will occur frequently. */\n', '    modifier postCheckAutoLiquidate\n', '    {\n', '        _;\n', '        if (!isLiquidating() && _nominCap() != 0 && collateralisationRatio() < AUTO_LIQUIDATION_RATIO) {\n', '            beginLiquidation();\n', '        }\n', '    }\n', '\n', '\n', '    /* ========== EVENTS ========== */\n', '\n', '    event PoolReplenished(uint nominsCreated, uint collateralDeposited);\n', '\n', '    event PoolDiminished(uint nominsDestroyed);\n', '\n', '    event Purchased(address buyer, address indexed buyerIndex, uint nomins, uint eth);\n', '\n', '    event Sold(address seller, address indexed sellerIndex, uint nomins, uint eth);\n', '\n', '    event PriceUpdated(uint newPrice);\n', '\n', '    event StalePeriodUpdated(uint newPeriod);\n', '\n', '    event OracleUpdated(address newOracle);\n', '\n', '    event CourtUpdated(address newCourt);\n', '\n', '    event BeneficiaryUpdated(address newBeneficiary);\n', '\n', '    event LiquidationBegun(uint duration);\n', '\n', '    event LiquidationTerminated();\n', '\n', '    event LiquidationExtended(uint extension);\n', '\n', '    event PoolFeeRateUpdated(uint newFeeRate);\n', '\n', '    event SelfDestructed(address beneficiary);\n', '\n', '    event AccountFrozen(address target, address indexed targetIndex, uint balance);\n', '\n', '    event AccountUnfrozen(address target, address indexed targetIndex);\n', '}\n', '\n', '/*\n', '-----------------------------------------------------------------\n', 'CONTRACT DESCRIPTION\n', '-----------------------------------------------------------------\n', '\n', 'A token interface to be overridden to produce an ERC20-compliant\n', 'token contract. It relies on being called underneath a proxy,\n', 'as described in Proxy.sol.\n', '\n', 'This contract utilises a state for upgradability purposes.\n', '\n', '-----------------------------------------------------------------\n', '*/\n', '\n', 'contract ExternStateProxyToken is SafeDecimalMath, Proxyable {\n', '\n', '    /* ========== STATE VARIABLES ========== */\n', '\n', '    // Stores balances and allowances.\n', '    TokenState public state;\n', '\n', '    // Other ERC20 fields\n', '    string public name;\n', '    string public symbol;\n', '    uint public totalSupply;\n', '\n', '\n', '    /* ========== CONSTRUCTOR ========== */\n', '\n', '    function ExternStateProxyToken(string _name, string _symbol,\n', '                                   uint initialSupply, address initialBeneficiary,\n', '                                   TokenState _state, address _owner)\n', '        Proxyable(_owner)\n', '        public\n', '    {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        totalSupply = initialSupply;\n', '\n', '        // if the state isn&#39;t set, create a new one\n', '        if (_state == TokenState(0)) {\n', '            state = new TokenState(_owner, address(this));\n', '            state.setBalanceOf(initialBeneficiary, totalSupply);\n', '            emit Transfer(address(0), initialBeneficiary, initialSupply);\n', '        } else {\n', '            state = _state;\n', '        }\n', '   }\n', '\n', '    /* ========== VIEWS ========== */\n', '\n', '    function allowance(address tokenOwner, address spender)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return state.allowance(tokenOwner, spender);\n', '    }\n', '\n', '    function balanceOf(address account)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return state.balanceOf(account);\n', '    }\n', '\n', '    /* ========== MUTATIVE FUNCTIONS ========== */\n', '\n', '    function setState(TokenState _state)\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        state = _state;\n', '        emit StateUpdated(_state);\n', '    } \n', '\n', '    /* Anything calling this must apply the onlyProxy or optionalProxy modifiers.*/\n', '    function _transfer_byProxy(address sender, address to, uint value)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        require(to != address(0));\n', '\n', '        // Insufficient balance will be handled by the safe subtraction.\n', '        state.setBalanceOf(sender, safeSub(state.balanceOf(sender), value));\n', '        state.setBalanceOf(to, safeAdd(state.balanceOf(to), value));\n', '\n', '        emit Transfer(sender, to, value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* Anything calling this must apply the onlyProxy or optionalProxy modifiers.*/\n', '    function _transferFrom_byProxy(address sender, address from, address to, uint value)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        require(from != address(0) && to != address(0));\n', '\n', '        // Insufficient balance will be handled by the safe subtraction.\n', '        state.setBalanceOf(from, safeSub(state.balanceOf(from), value));\n', '        state.setAllowance(from, sender, safeSub(state.allowance(from, sender), value));\n', '        state.setBalanceOf(to, safeAdd(state.balanceOf(to), value));\n', '\n', '        emit Transfer(from, to, value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint value)\n', '        external\n', '        optionalProxy\n', '        returns (bool)\n', '    {\n', '        address sender = messageSender;\n', '        state.setAllowance(sender, spender, value);\n', '        emit Approval(sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /* ========== EVENTS ========== */\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '    event StateUpdated(address newState);\n', '}\n', '\n', '/*\n', '-----------------------------------------------------------------\n', 'CONTRACT DESCRIPTION\n', '-----------------------------------------------------------------\n', '\n', 'This contract allows the foundation to apply unique vesting\n', 'schedules to havven funds sold at various discounts in the token\n', 'sale. HavvenEscrow gives users the ability to inspect their\n', 'vested funds, their quantities and vesting dates, and to withdraw\n', 'the fees that accrue on those funds.\n', '\n', 'The fees are handled by withdrawing the entire fee allocation\n', 'for all havvens inside the escrow contract, and then allowing\n', 'the contract itself to subdivide that pool up proportionally within\n', 'itself. Every time the fee period rolls over in the main Havven\n', 'contract, the HavvenEscrow fee pool is remitted back into the \n', 'main fee pool to be redistributed in the next fee period.\n', '\n', '-----------------------------------------------------------------\n', '\n', '*/\n', '\n', 'contract HavvenEscrow is Owned, LimitedSetup(8 weeks), SafeDecimalMath {    \n', '    // The corresponding Havven contract.\n', '    Havven public havven;\n', '\n', '    // Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\n', '    // These are the times at which each given quantity of havvens vests.\n', '    mapping(address => uint[2][]) public vestingSchedules;\n', '\n', '    // An account&#39;s total vested havven balance to save recomputing this for fee extraction purposes.\n', '    mapping(address => uint) public totalVestedAccountBalance;\n', '\n', '    // The total remaining vested balance, for verifying the actual havven balance of this contract against.\n', '    uint public totalVestedBalance;\n', '\n', '\n', '    /* ========== CONSTRUCTOR ========== */\n', '\n', '    function HavvenEscrow(address _owner, Havven _havven)\n', '        Owned(_owner)\n', '        public\n', '    {\n', '        havven = _havven;\n', '    }\n', '\n', '\n', '    /* ========== SETTERS ========== */\n', '\n', '    function setHavven(Havven _havven)\n', '        external\n', '        onlyOwner\n', '    {\n', '        havven = _havven;\n', '        emit HavvenUpdated(_havven);\n', '    }\n', '\n', '\n', '    /* ========== VIEW FUNCTIONS ========== */\n', '\n', '    /* A simple alias to totalVestedAccountBalance: provides ERC20 balance integration. */\n', '    function balanceOf(address account)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return totalVestedAccountBalance[account];\n', '    }\n', '\n', '    /* The number of vesting dates in an account&#39;s schedule. */\n', '    function numVestingEntries(address account)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return vestingSchedules[account].length;\n', '    }\n', '\n', '    /* Get a particular schedule entry for an account.\n', '     * The return value is a pair (timestamp, havven quantity) */\n', '    function getVestingScheduleEntry(address account, uint index)\n', '        public\n', '        view\n', '        returns (uint[2])\n', '    {\n', '        return vestingSchedules[account][index];\n', '    }\n', '\n', '    /* Get the time at which a given schedule entry will vest. */\n', '    function getVestingTime(address account, uint index)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return vestingSchedules[account][index][0];\n', '    }\n', '\n', '    /* Get the quantity of havvens associated with a given schedule entry. */\n', '    function getVestingQuantity(address account, uint index)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return vestingSchedules[account][index][1];\n', '    }\n', '\n', '    /* Obtain the index of the next schedule entry that will vest for a given user. */\n', '    function getNextVestingIndex(address account)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint len = numVestingEntries(account);\n', '        for (uint i = 0; i < len; i++) {\n', '            if (getVestingTime(account, i) != 0) {\n', '                return i;\n', '            }\n', '        }\n', '        return len;\n', '    }\n', '\n', '    /* Obtain the next schedule entry that will vest for a given user.\n', '     * The return value is a pair (timestamp, havven quantity) */\n', '    function getNextVestingEntry(address account)\n', '        external\n', '        view\n', '        returns (uint[2])\n', '    {\n', '        uint index = getNextVestingIndex(account);\n', '        if (index == numVestingEntries(account)) {\n', '            return [uint(0), 0];\n', '        }\n', '        return getVestingScheduleEntry(account, index);\n', '    }\n', '\n', '    /* Obtain the time at which the next schedule entry will vest for a given user. */\n', '    function getNextVestingTime(address account)\n', '        external\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint index = getNextVestingIndex(account);\n', '        if (index == numVestingEntries(account)) {\n', '            return 0;\n', '        }\n', '        return getVestingTime(account, index);\n', '    }\n', '\n', '    /* Obtain the quantity which the next schedule entry will vest for a given user. */\n', '    function getNextVestingQuantity(address account)\n', '        external\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint index = getNextVestingIndex(account);\n', '        if (index == numVestingEntries(account)) {\n', '            return 0;\n', '        }\n', '        return getVestingQuantity(account, index);\n', '    }\n', '\n', '\n', '    /* ========== MUTATIVE FUNCTIONS ========== */\n', '\n', '    /* Withdraws a quantity of havvens back to the havven contract. */\n', '    function withdrawHavvens(uint quantity)\n', '        external\n', '        onlyOwner\n', '        setupFunction\n', '    {\n', '        havven.transfer(havven, quantity);\n', '    }\n', '\n', '    /* Destroy the vesting information associated with an account. */\n', '    function purgeAccount(address account)\n', '        external\n', '        onlyOwner\n', '        setupFunction\n', '    {\n', '        delete vestingSchedules[account];\n', '        totalVestedBalance = safeSub(totalVestedBalance, totalVestedAccountBalance[account]);\n', '        delete totalVestedAccountBalance[account];\n', '    }\n', '\n', '    /* Add a new vesting entry at a given time and quantity to an account&#39;s schedule.\n', '     * A call to this should be accompanied by either enough balance already available\n', '     * in this contract, or a corresponding call to havven.endow(), to ensure that when\n', '     * the funds are withdrawn, there is enough balance, as well as correctly calculating\n', '     * the fees.\n', '     * Note; although this function could technically be used to produce unbounded\n', '     * arrays, it&#39;s only in the foundation&#39;s command to add to these lists. */\n', '    function appendVestingEntry(address account, uint time, uint quantity)\n', '        public\n', '        onlyOwner\n', '        setupFunction\n', '    {\n', '        // No empty or already-passed vesting entries allowed.\n', '        require(now < time);\n', '        require(quantity != 0);\n', '        totalVestedBalance = safeAdd(totalVestedBalance, quantity);\n', '        require(totalVestedBalance <= havven.balanceOf(this));\n', '\n', '        if (vestingSchedules[account].length == 0) {\n', '            totalVestedAccountBalance[account] = quantity;\n', '        } else {\n', '            // Disallow adding new vested havvens earlier than the last one.\n', '            // Since entries are only appended, this means that no vesting date can be repeated.\n', '            require(getVestingTime(account, numVestingEntries(account) - 1) < time);\n', '            totalVestedAccountBalance[account] = safeAdd(totalVestedAccountBalance[account], quantity);\n', '        }\n', '\n', '        vestingSchedules[account].push([time, quantity]);\n', '    }\n', '\n', '    /* Construct a vesting schedule to release a quantities of havvens\n', '     * over a series of intervals. Assumes that the quantities are nonzero\n', '     * and that the sequence of timestamps is strictly increasing. */\n', '    function addVestingSchedule(address account, uint[] times, uint[] quantities)\n', '        external\n', '        onlyOwner\n', '        setupFunction\n', '    {\n', '        for (uint i = 0; i < times.length; i++) {\n', '            appendVestingEntry(account, times[i], quantities[i]);\n', '        }\n', '\n', '    }\n', '\n', '    /* Allow a user to withdraw any tokens that have vested. */\n', '    function vest() \n', '        external\n', '    {\n', '        uint total;\n', '        for (uint i = 0; i < numVestingEntries(msg.sender); i++) {\n', '            uint time = getVestingTime(msg.sender, i);\n', '            // The list is sorted; when we reach the first future time, bail out.\n', '            if (time > now) {\n', '                break;\n', '            }\n', '            uint qty = getVestingQuantity(msg.sender, i);\n', '            if (qty == 0) {\n', '                continue;\n', '            }\n', '\n', '            vestingSchedules[msg.sender][i] = [0, 0];\n', '            total = safeAdd(total, qty);\n', '            totalVestedAccountBalance[msg.sender] = safeSub(totalVestedAccountBalance[msg.sender], qty);\n', '        }\n', '\n', '        if (total != 0) {\n', '            totalVestedBalance = safeSub(totalVestedBalance, total);\n', '            havven.transfer(msg.sender, total);\n', '            emit Vested(msg.sender, msg.sender,\n', '                   now, total);\n', '        }\n', '    }\n', '\n', '\n', '    /* ========== EVENTS ========== */\n', '\n', '    event HavvenUpdated(address newHavven);\n', '\n', '    event Vested(address beneficiary, address indexed beneficiaryIndex, uint time, uint value);\n', '}\n', '\n', '/*\n', '-----------------------------------------------------------------\n', 'CONTRACT DESCRIPTION\n', '-----------------------------------------------------------------\n', '\n', 'This contract allows an inheriting contract to be destroyed after\n', 'its owner indicates an intention and then waits for a period\n', 'without changing their mind.\n', '\n', '-----------------------------------------------------------------\n', '*/\n', '\n', 'contract SelfDestructible is Owned {\n', '\t\n', '\tuint public initiationTime = ~uint(0);\n', '\tuint constant SD_DURATION = 3 days;\n', '\taddress public beneficiary;\n', '\n', '\tfunction SelfDestructible(address _owner, address _beneficiary)\n', '\t\tpublic\n', '\t\tOwned(_owner)\n', '\t{\n', '\t\tbeneficiary = _beneficiary;\n', '\t}\n', '\n', '\tfunction setBeneficiary(address _beneficiary)\n', '\t\texternal\n', '\t\tonlyOwner\n', '\t{\n', '\t\tbeneficiary = _beneficiary;\n', '\t\temit SelfDestructBeneficiaryUpdated(_beneficiary);\n', '\t}\n', '\n', '\tfunction initiateSelfDestruct()\n', '\t\texternal\n', '\t\tonlyOwner\n', '\t{\n', '\t\tinitiationTime = now;\n', '\t\temit SelfDestructInitiated(SD_DURATION);\n', '\t}\n', '\n', '\tfunction terminateSelfDestruct()\n', '\t\texternal\n', '\t\tonlyOwner\n', '\t{\n', '\t\tinitiationTime = ~uint(0);\n', '\t\temit SelfDestructTerminated();\n', '\t}\n', '\n', '\tfunction selfDestruct()\n', '\t\texternal\n', '\t\tonlyOwner\n', '\t{\n', '\t\trequire(initiationTime + SD_DURATION < now);\n', '\t\temit SelfDestructed(beneficiary);\n', '\t\tselfdestruct(beneficiary);\n', '\t}\n', '\n', '\tevent SelfDestructBeneficiaryUpdated(address newBeneficiary);\n', '\n', '\tevent SelfDestructInitiated(uint duration);\n', '\n', '\tevent SelfDestructTerminated();\n', '\n', '\tevent SelfDestructed(address beneficiary);\n', '}\n', '\n', '/*\n', '-----------------------------------------------------------------\n', 'CONTRACT DESCRIPTION\n', '-----------------------------------------------------------------\n', '\n', 'Havven token contract. Havvens are transferable ERC20 tokens,\n', 'and also give their holders the following privileges.\n', 'An owner of havvens is entitled to a share in the fees levied on\n', 'nomin transactions, and additionally may participate in nomin\n', 'confiscation votes.\n', '\n', 'After a fee period terminates, the duration and fees collected for that\n', 'period are computed, and the next period begins.\n', 'Thus an account may only withdraw the fees owed to them for the previous\n', 'period, and may only do so once per period.\n', 'Any unclaimed fees roll over into the common pot for the next period.\n', '\n', 'The fee entitlement of a havven holder is proportional to their average\n', 'havven balance over the last fee period. This is computed by measuring the\n', 'area under the graph of a user&#39;s balance over time, and then when fees are\n', 'distributed, dividing through by the duration of the fee period.\n', '\n', 'We need only update fee entitlement on transfer when the havven balances of the sender\n', 'and recipient are modified. This is for efficiency, and adds an implicit friction to\n', 'trading in the havven market. A havven holder pays for his own recomputation whenever\n', 'he wants to change his position, which saves the foundation having to maintain a pot\n', 'dedicated to resourcing this.\n', '\n', 'A hypothetical user&#39;s balance history over one fee period, pictorially:\n', '\n', '      s ____\n', '       |    |\n', '       |    |___ p\n', '       |____|___|___ __ _  _\n', '       f    t   n\n', '\n', 'Here, the balance was s between times f and t, at which time a transfer\n', 'occurred, updating the balance to p, until n, when the present transfer occurs.\n', 'When a new transfer occurs at time n, the balance being p,\n', 'we must:\n', '\n', '  - Add the area p * (n - t) to the total area recorded so far\n', '  - Update the last transfer time to p\n', '\n', 'So if this graph represents the entire current fee period,\n', 'the average havvens held so far is ((t-f)*s + (n-t)*p) / (n-f).\n', 'The complementary computations must be performed for both sender and\n', 'recipient.\n', '\n', 'Note that a transfer keeps global supply of havvens invariant.\n', 'The sum of all balances is constant, and unmodified by any transfer.\n', 'So the sum of all balances multiplied by the duration of a fee period is also\n', 'constant, and this is equivalent to the sum of the area of every user&#39;s\n', 'time/balance graph. Dividing through by that duration yields back the total\n', 'havven supply. So, at the end of a fee period, we really do yield a user&#39;s\n', 'average share in the havven supply over that period.\n', '\n', 'A slight wrinkle is introduced if we consider the time r when the fee period\n', 'rolls over. Then the previous fee period k-1 is before r, and the current fee\n', 'period k is afterwards. If the last transfer took place before r,\n', 'but the latest transfer occurred afterwards:\n', '\n', 'k-1       |        k\n', '      s __|_\n', '       |  | |\n', '       |  | |____ p\n', '       |__|_|____|___ __ _  _\n', '          |\n', '       f  | t    n\n', '          r\n', '\n', 'In this situation the area (r-f)*s contributes to fee period k-1, while\n', 'the area (t-r)*s contributes to fee period k. We will implicitly consider a\n', 'zero-value transfer to have occurred at time r. Their fee entitlement for the\n', 'previous period will be finalised at the time of their first transfer during the\n', 'current fee period, or when they query or withdraw their fee entitlement.\n', '\n', 'In the implementation, the duration of different fee periods may be slightly irregular,\n', 'as the check that they have rolled over occurs only when state-changing havven\n', 'operations are performed.\n', '\n', 'Additionally, we keep track also of the penultimate and not just the last\n', 'average balance, in order to support the voting functionality detailed in Court.sol.\n', '\n', '-----------------------------------------------------------------\n', '\n', '*/\n', '\n', 'contract Havven is ExternStateProxyToken, SelfDestructible {\n', '\n', '    /* ========== STATE VARIABLES ========== */\n', '\n', '    // Sums of balances*duration in the current fee period.\n', '    // range: decimals; units: havven-seconds\n', '    mapping(address => uint) public currentBalanceSum;\n', '\n', '    // Average account balances in the last completed fee period. This is proportional\n', '    // to that account&#39;s last period fee entitlement.\n', '    // (i.e. currentBalanceSum for the previous period divided through by duration)\n', '    // WARNING: This may not have been updated for the latest fee period at the\n', '    //          time it is queried.\n', '    // range: decimals; units: havvens\n', '    mapping(address => uint) public lastAverageBalance;\n', '\n', '    // The average account balances in the period before the last completed fee period.\n', '    // This is used as a person&#39;s weight in a confiscation vote, so it implies that\n', '    // the vote duration must be no longer than the fee period in order to guarantee that \n', '    // no portion of a fee period used for determining vote weights falls within the\n', '    // duration of a vote it contributes to.\n', '    // WARNING: This may not have been updated for the latest fee period at the\n', '    //          time it is queried.\n', '    mapping(address => uint) public penultimateAverageBalance;\n', '\n', '    // The time an account last made a transfer.\n', '    // range: naturals\n', '    mapping(address => uint) public lastTransferTimestamp;\n', '\n', '    // The time the current fee period began.\n', '    uint public feePeriodStartTime = 3;\n', '    // The actual start of the last fee period (seconds).\n', '    // This, and the penultimate fee period can be initially set to any value\n', '    //   0 < val < now, as everyone&#39;s individual lastTransferTime will be 0\n', '    //   and as such, their lastAvgBal/penultimateAvgBal will be set to that value\n', '    //   apart from the contract, which will have totalSupply\n', '    uint public lastFeePeriodStartTime = 2;\n', '    // The actual start of the penultimate fee period (seconds).\n', '    uint public penultimateFeePeriodStartTime = 1;\n', '\n', '    // Fee periods will roll over in no shorter a time than this.\n', '    uint public targetFeePeriodDurationSeconds = 4 weeks;\n', '    // And may not be set to be shorter than a day.\n', '    uint constant MIN_FEE_PERIOD_DURATION_SECONDS = 1 days;\n', '    // And may not be set to be longer than six months.\n', '    uint constant MAX_FEE_PERIOD_DURATION_SECONDS = 26 weeks;\n', '\n', '    // The quantity of nomins that were in the fee pot at the time\n', '    // of the last fee rollover (feePeriodStartTime).\n', '    uint public lastFeesCollected;\n', '\n', '    mapping(address => bool) public hasWithdrawnLastPeriodFees;\n', '\n', '    EtherNomin public nomin;\n', '    HavvenEscrow public escrow;\n', '\n', '\n', '    /* ========== CONSTRUCTOR ========== */\n', '\n', '    function Havven(TokenState initialState, address _owner)\n', '        ExternStateProxyToken("Havven", "HAV", 1e8 * UNIT, address(this), initialState, _owner)\n', '        SelfDestructible(_owner, _owner)\n', '        // Owned is initialised in ExternStateProxyToken\n', '        public\n', '    {\n', '        lastTransferTimestamp[this] = now;\n', '        feePeriodStartTime = now;\n', '        lastFeePeriodStartTime = now - targetFeePeriodDurationSeconds;\n', '        penultimateFeePeriodStartTime = now - 2*targetFeePeriodDurationSeconds;\n', '    }\n', '\n', '\n', '    /* ========== SETTERS ========== */\n', '\n', '    function setNomin(EtherNomin _nomin) \n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        nomin = _nomin;\n', '    }\n', '\n', '    function setEscrow(HavvenEscrow _escrow)\n', '        external\n', '        optionalProxy_onlyOwner\n', '    {\n', '        escrow = _escrow;\n', '    }\n', '\n', '    function setTargetFeePeriodDuration(uint duration)\n', '        external\n', '        postCheckFeePeriodRollover\n', '        optionalProxy_onlyOwner\n', '    {\n', '        require(MIN_FEE_PERIOD_DURATION_SECONDS <= duration &&\n', '                duration <= MAX_FEE_PERIOD_DURATION_SECONDS);\n', '        targetFeePeriodDurationSeconds = duration;\n', '        emit FeePeriodDurationUpdated(duration);\n', '    }\n', '\n', '\n', '    /* ========== MUTATIVE FUNCTIONS ========== */\n', '\n', '    /* Allow the owner of this contract to endow any address with havvens\n', '     * from the initial supply. Since the entire initial supply resides\n', '     * in the havven contract, this disallows the foundation from withdrawing\n', '     * fees on undistributed balances. This function can also be used\n', '     * to retrieve any havvens sent to the Havven contract itself. */\n', '    function endow(address account, uint value)\n', '        external\n', '        optionalProxy_onlyOwner\n', '        returns (bool)\n', '    {\n', '\n', '        // Use "this" in order that the havven account is the sender.\n', '        // That this is an explicit transfer also initialises fee entitlement information.\n', '        return _transfer(this, account, value);\n', '    }\n', '\n', '    /* Allow the owner of this contract to emit transfer events for\n', '     * contract setup purposes. */\n', '    function emitTransferEvents(address sender, address[] recipients, uint[] values)\n', '        external\n', '        onlyOwner\n', '    {\n', '        for (uint i = 0; i < recipients.length; ++i) {\n', '            emit Transfer(sender, recipients[i], values[i]);\n', '        }\n', '    }\n', '\n', '    /* Override ERC20 transfer function in order to perform\n', '     * fee entitlement recomputation whenever balances are updated. */\n', '    function transfer(address to, uint value)\n', '        external\n', '        optionalProxy\n', '        returns (bool)\n', '    {\n', '        return _transfer(messageSender, to, value);\n', '    }\n', '\n', '    /* Anything calling this must apply the optionalProxy or onlyProxy modifier. */\n', '    function _transfer(address sender, address to, uint value)\n', '        internal\n', '        preCheckFeePeriodRollover\n', '        returns (bool)\n', '    {\n', '\n', '        uint senderPreBalance = state.balanceOf(sender);\n', '        uint recipientPreBalance = state.balanceOf(to);\n', '\n', '        // Perform the transfer: if there is a problem,\n', '        // an exception will be thrown in this call.\n', '        _transfer_byProxy(sender, to, value);\n', '\n', '        // Zero-value transfers still update fee entitlement information,\n', '        // and may roll over the fee period.\n', '        adjustFeeEntitlement(sender, senderPreBalance);\n', '        adjustFeeEntitlement(to, recipientPreBalance);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* Override ERC20 transferFrom function in order to perform\n', '     * fee entitlement recomputation whenever balances are updated. */\n', '    function transferFrom(address from, address to, uint value)\n', '        external\n', '        preCheckFeePeriodRollover\n', '        optionalProxy\n', '        returns (bool)\n', '    {\n', '        uint senderPreBalance = state.balanceOf(from);\n', '        uint recipientPreBalance = state.balanceOf(to);\n', '\n', '        // Perform the transfer: if there is a problem,\n', '        // an exception will be thrown in this call.\n', '        _transferFrom_byProxy(messageSender, from, to, value);\n', '\n', '        // Zero-value transfers still update fee entitlement information,\n', '        // and may roll over the fee period.\n', '        adjustFeeEntitlement(from, senderPreBalance);\n', '        adjustFeeEntitlement(to, recipientPreBalance);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* Compute the last period&#39;s fee entitlement for the message sender\n', '     * and then deposit it into their nomin account. */\n', '    function withdrawFeeEntitlement()\n', '        public\n', '        preCheckFeePeriodRollover\n', '        optionalProxy\n', '    {\n', '        address sender = messageSender;\n', '\n', '        // Do not deposit fees into frozen accounts.\n', '        require(!nomin.frozen(sender));\n', '\n', '        // check the period has rolled over first\n', '        rolloverFee(sender, lastTransferTimestamp[sender], state.balanceOf(sender));\n', '\n', '        // Only allow accounts to withdraw fees once per period.\n', '        require(!hasWithdrawnLastPeriodFees[sender]);\n', '\n', '        uint feesOwed;\n', '\n', '        if (escrow != HavvenEscrow(0)) {\n', '            feesOwed = escrow.totalVestedAccountBalance(sender);\n', '        }\n', '\n', '        feesOwed = safeDiv_dec(safeMul_dec(safeAdd(feesOwed, lastAverageBalance[sender]),\n', '                                           lastFeesCollected),\n', '                               totalSupply);\n', '\n', '        hasWithdrawnLastPeriodFees[sender] = true;\n', '        if (feesOwed != 0) {\n', '            nomin.withdrawFee(sender, feesOwed);\n', '            emit FeesWithdrawn(sender, sender, feesOwed);\n', '        }\n', '    }\n', '\n', '    /* Update the fee entitlement since the last transfer or entitlement\n', '     * adjustment. Since this updates the last transfer timestamp, if invoked\n', '     * consecutively, this function will do nothing after the first call. */\n', '    function adjustFeeEntitlement(address account, uint preBalance)\n', '        internal\n', '    {\n', '        // The time since the last transfer clamps at the last fee rollover time if the last transfer\n', '        // was earlier than that.\n', '        rolloverFee(account, lastTransferTimestamp[account], preBalance);\n', '\n', '        currentBalanceSum[account] = safeAdd(\n', '            currentBalanceSum[account],\n', '            safeMul(preBalance, now - lastTransferTimestamp[account])\n', '        );\n', '\n', '        // Update the last time this user&#39;s balance changed.\n', '        lastTransferTimestamp[account] = now;\n', '    }\n', '\n', '    /* Update the given account&#39;s previous period fee entitlement value.\n', '     * Do nothing if the last transfer occurred since the fee period rolled over.\n', '     * If the entitlement was updated, also update the last transfer time to be\n', '     * at the timestamp of the rollover, so if this should do nothing if called more\n', '     * than once during a given period.\n', '     *\n', '     * Consider the case where the entitlement is updated. If the last transfer\n', '     * occurred at time t in the last period, then the starred region is added to the\n', '     * entitlement, the last transfer timestamp is moved to r, and the fee period is\n', '     * rolled over from k-1 to k so that the new fee period start time is at time r.\n', '     * \n', '     *   k-1       |        k\n', '     *         s __|\n', '     *  _  _ ___|**|\n', '     *          |**|\n', '     *  _  _ ___|**|___ __ _  _\n', '     *             |\n', '     *          t  |\n', '     *             r\n', '     * \n', '     * Similar computations are performed according to the fee period in which the\n', '     * last transfer occurred.\n', '     */\n', '    function rolloverFee(address account, uint lastTransferTime, uint preBalance)\n', '        internal\n', '    {\n', '        if (lastTransferTime < feePeriodStartTime) {\n', '            if (lastTransferTime < lastFeePeriodStartTime) {\n', '                // The last transfer predated the previous two fee periods.\n', '                if (lastTransferTime < penultimateFeePeriodStartTime) {\n', '                    // The balance did nothing in the penultimate fee period, so the average balance\n', '                    // in this period is their pre-transfer balance.\n', '                    penultimateAverageBalance[account] = preBalance;\n', '                // The last transfer occurred within the one-before-the-last fee period.\n', '                } else {\n', '                    // No overflow risk here: the failed guard implies (penultimateFeePeriodStartTime <= lastTransferTime).\n', '                    penultimateAverageBalance[account] = safeDiv(\n', '                        safeAdd(currentBalanceSum[account], safeMul(preBalance, (lastFeePeriodStartTime - lastTransferTime))),\n', '                        (lastFeePeriodStartTime - penultimateFeePeriodStartTime)\n', '                    );\n', '                }\n', '\n', '                // The balance did nothing in the last fee period, so the average balance\n', '                // in this period is their pre-transfer balance.\n', '                lastAverageBalance[account] = preBalance;\n', '\n', '            // The last transfer occurred within the last fee period.\n', '            } else {\n', '                // The previously-last average balance becomes the penultimate balance.\n', '                penultimateAverageBalance[account] = lastAverageBalance[account];\n', '\n', '                // No overflow risk here: the failed guard implies (lastFeePeriodStartTime <= lastTransferTime).\n', '                lastAverageBalance[account] = safeDiv(\n', '                    safeAdd(currentBalanceSum[account], safeMul(preBalance, (feePeriodStartTime - lastTransferTime))),\n', '                    (feePeriodStartTime - lastFeePeriodStartTime)\n', '                );\n', '            }\n', '\n', '            // Roll over to the next fee period.\n', '            currentBalanceSum[account] = 0;\n', '            hasWithdrawnLastPeriodFees[account] = false;\n', '            lastTransferTimestamp[account] = feePeriodStartTime;\n', '        }\n', '    }\n', '\n', '    /* Recompute and return the given account&#39;s average balance information.\n', '     * This also rolls over the fee period if necessary, and brings\n', '     * the account&#39;s current balance sum up to date. */\n', '    function _recomputeAccountLastAverageBalance(address account)\n', '        internal\n', '        preCheckFeePeriodRollover\n', '        returns (uint)\n', '    {\n', '        adjustFeeEntitlement(account, state.balanceOf(account));\n', '        return lastAverageBalance[account];\n', '    }\n', '\n', '    /* Recompute and return the sender&#39;s average balance information. */\n', '    function recomputeLastAverageBalance()\n', '        external\n', '        optionalProxy\n', '        returns (uint)\n', '    {\n', '        return _recomputeAccountLastAverageBalance(messageSender);\n', '    }\n', '\n', '    /* Recompute and return the given account&#39;s average balance information. */\n', '    function recomputeAccountLastAverageBalance(address account)\n', '        external\n', '        returns (uint)\n', '    {\n', '        return _recomputeAccountLastAverageBalance(account);\n', '    }\n', '\n', '    function rolloverFeePeriod()\n', '        public\n', '    {\n', '        checkFeePeriodRollover();\n', '    }\n', '\n', '\n', '    /* ========== MODIFIERS ========== */\n', '\n', '    /* If the fee period has rolled over, then\n', '     * save the start times of the last fee period,\n', '     * as well as the penultimate fee period.\n', '     */\n', '    function checkFeePeriodRollover()\n', '        internal\n', '    {\n', '        // If the fee period has rolled over...\n', '        if (feePeriodStartTime + targetFeePeriodDurationSeconds <= now) {\n', '            lastFeesCollected = nomin.feePool();\n', '\n', '            // Shift the three period start times back one place\n', '            penultimateFeePeriodStartTime = lastFeePeriodStartTime;\n', '            lastFeePeriodStartTime = feePeriodStartTime;\n', '            feePeriodStartTime = now;\n', '            \n', '            emit FeePeriodRollover(now);\n', '        }\n', '    }\n', '\n', '    modifier postCheckFeePeriodRollover\n', '    {\n', '        _;\n', '        checkFeePeriodRollover();\n', '    }\n', '\n', '    modifier preCheckFeePeriodRollover\n', '    {\n', '        checkFeePeriodRollover();\n', '        _;\n', '    }\n', '\n', '\n', '    /* ========== EVENTS ========== */\n', '\n', '    event FeePeriodRollover(uint timestamp);\n', '\n', '    event FeePeriodDurationUpdated(uint duration);\n', '\n', '    event FeesWithdrawn(address account, address indexed accountIndex, uint value);\n', '}\n', '\n', '/*\n', '-----------------------------------------------------------------\n', 'CONTRACT DESCRIPTION\n', '-----------------------------------------------------------------\n', '\n', 'A contract that holds the state of an ERC20 compliant token.\n', '\n', 'This contract is used side by side with external state token\n', 'contracts, such as Havven and EtherNomin.\n', 'It provides an easy way to upgrade contract logic while\n', 'maintaining all user balances and allowances. This is designed\n', 'to to make the changeover as easy as possible, since mappings\n', 'are not so cheap or straightforward to migrate.\n', '\n', 'The first deployed contract would create this state contract,\n', 'using it as its store of balances.\n', 'When a new contract is deployed, it links to the existing\n', 'state contract, whose owner would then change its associated\n', 'contract to the new one.\n', '\n', '-----------------------------------------------------------------\n', '*/\n', '\n', 'contract TokenState is Owned {\n', '\n', '    // the address of the contract that can modify balances and allowances\n', '    // this can only be changed by the owner of this contract\n', '    address public associatedContract;\n', '\n', '    // ERC20 fields.\n', '    mapping(address => uint) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '\n', '    function TokenState(address _owner, address _associatedContract)\n', '        Owned(_owner)\n', '        public\n', '    {\n', '        associatedContract = _associatedContract;\n', '        emit AssociatedContractUpdated(_associatedContract);\n', '    }\n', '\n', '    /* ========== SETTERS ========== */\n', '\n', '    // Change the associated contract to a new address\n', '    function setAssociatedContract(address _associatedContract)\n', '        external\n', '        onlyOwner\n', '    {\n', '        associatedContract = _associatedContract;\n', '        emit AssociatedContractUpdated(_associatedContract);\n', '    }\n', '\n', '    function setAllowance(address tokenOwner, address spender, uint value)\n', '        external\n', '        onlyAssociatedContract\n', '    {\n', '        allowance[tokenOwner][spender] = value;\n', '    }\n', '\n', '    function setBalanceOf(address account, uint value)\n', '        external\n', '        onlyAssociatedContract\n', '    {\n', '        balanceOf[account] = value;\n', '    }\n', '\n', '\n', '    /* ========== MODIFIERS ========== */\n', '\n', '    modifier onlyAssociatedContract\n', '    {\n', '        require(msg.sender == associatedContract);\n', '        _;\n', '    }\n', '\n', '    /* ========== EVENTS ========== */\n', '\n', '    event AssociatedContractUpdated(address _associatedContract);\n', '}\n', '\n', '/*\n', 'MIT License\n', '\n', 'Copyright (c) 2018 Havven\n', '\n', 'Permission is hereby granted, free of charge, to any person obtaining a copy\n', 'of this software and associated documentation files (the "Software"), to deal\n', 'in the Software without restriction, including without limitation the rights\n', 'to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n', 'copies of the Software, and to permit persons to whom the Software is\n', 'furnished to do so, subject to the following conditions:\n', '\n', 'The above copyright notice and this permission notice shall be included in all\n', 'copies or substantial portions of the Software.\n', '\n', 'THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', 'IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', 'FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', 'AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', 'LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', 'OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', 'SOFTWARE.\n', '*/']