['pragma solidity 0.4.18;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/// @title A library for implementing a generic state machine pattern.\n', 'library StateMachineLib {\n', '\n', '    struct Stage {\n', '        // The id of the next stage\n', '        bytes32 nextId;\n', '\n', '        // The identifiers for the available functions in each stage\n', '        mapping(bytes4 => bool) allowedFunctions;\n', '    }\n', '\n', '    struct State {\n', '        // The current stage id\n', '        bytes32 currentStageId;\n', '\n', '        // A callback that is called when entering this stage\n', '        function(bytes32) internal onTransition;\n', '\n', '        // Checks if a stage id is valid\n', '        mapping(bytes32 => bool) validStage;\n', '\n', '        // Maps stage ids to their Stage structs\n', '        mapping(bytes32 => Stage) stages;\n', '    }\n', '\n', '    /// @dev Creates and sets the initial stage. It has to be called before creating any transitions.\n', '    /// @param stageId The id of the (new) stage to set as initial stage.\n', '    function setInitialStage(State storage self, bytes32 stageId) internal {\n', '        self.validStage[stageId] = true;\n', '        self.currentStageId = stageId;\n', '    }\n', '\n', '    /// @dev Creates a transition from &#39;fromId&#39; to &#39;toId&#39;. If fromId already had a nextId, it deletes the now unreachable stage.\n', '    /// @param fromId The id of the stage from which the transition begins.\n', '    /// @param toId The id of the stage that will be reachable from "fromId".\n', '    function createTransition(State storage self, bytes32 fromId, bytes32 toId) internal {\n', '        require(self.validStage[fromId]);\n', '\n', '        Stage storage from = self.stages[fromId];\n', '\n', '        // Invalidate the stage that won&#39;t be reachable any more\n', '        if (from.nextId != 0) {\n', '            self.validStage[from.nextId] = false;\n', '            delete self.stages[from.nextId];\n', '        }\n', '\n', '        from.nextId = toId;\n', '        self.validStage[toId] = true;\n', '    }\n', '\n', '    /// @dev Goes to the next stage if posible (if the next stage is valid)\n', '    function goToNextStage(State storage self) internal {\n', '        Stage storage current = self.stages[self.currentStageId];\n', '\n', '        require(self.validStage[current.nextId]);\n', '\n', '        self.currentStageId = current.nextId;\n', '\n', '        self.onTransition(current.nextId);\n', '    }\n', '\n', '    /// @dev Checks if the a function is allowed in the current stage.\n', '    /// @param selector A function selector (bytes4[keccak256(functionSignature)])\n', '    /// @return true If the function is allowed in the current stage\n', '    function checkAllowedFunction(State storage self, bytes4 selector) internal constant returns(bool) {\n', '        return self.stages[self.currentStageId].allowedFunctions[selector];\n', '    }\n', '\n', '    /// @dev Allow a function in the given stage.\n', '    /// @param stageId The id of the stage\n', '    /// @param selector A function selector (bytes4[keccak256(functionSignature)])\n', '    function allowFunction(State storage self, bytes32 stageId, bytes4 selector) internal {\n', '        require(self.validStage[stageId]);\n', '        self.stages[stageId].allowedFunctions[selector] = true;\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '\n', 'contract StateMachine {\n', '    using StateMachineLib for StateMachineLib.State;\n', '\n', '    event LogTransition(bytes32 indexed stageId, uint256 blockNumber);\n', '\n', '    StateMachineLib.State internal state;\n', '\n', '    /* This modifier performs the conditional transitions and checks that the function \n', '     * to be executed is allowed in the current stage\n', '     */\n', '    modifier checkAllowed {\n', '        conditionalTransitions();\n', '        require(state.checkAllowedFunction(msg.sig));\n', '        _;\n', '    }\n', '\n', '    function StateMachine() public {\n', '        // Register the startConditions function and the onTransition callback\n', '        state.onTransition = onTransition;\n', '    }\n', '\n', '    /// @dev Gets the current stage id.\n', '    /// @return The current stage id.\n', '    function getCurrentStageId() public view returns(bytes32) {\n', '        return state.currentStageId;\n', '    }\n', '\n', '    /// @dev Performs conditional transitions. Can be called by anyone.\n', '    function conditionalTransitions() public {\n', '\n', '        bytes32 nextId = state.stages[state.currentStageId].nextId;\n', '\n', '        while (state.validStage[nextId]) {\n', '            StateMachineLib.Stage storage next = state.stages[nextId];\n', '            // If the next stage&#39;s condition is true, go to next stage and continue\n', '            if (startConditions(nextId)) {\n', '                state.goToNextStage();\n', '                nextId = next.nextId;\n', '            } else {\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Determines whether the conditions for transitioning to the given stage are met.\n', '    /// @return true if the conditions are met for the given stageId. False by default (must override in child contracts).\n', '    function startConditions(bytes32) internal constant returns(bool) {\n', '        return false;\n', '    }\n', '\n', '    /// @dev Callback called when there is a stage transition. It should be overridden for additional functionality.\n', '    function onTransition(bytes32 stageId) internal {\n', '        LogTransition(stageId, block.number);\n', '    }\n', '\n', '\n', '}\n', '\n', '/// @title A contract that implements the state machine pattern and adds time dependant transitions.\n', 'contract TimedStateMachine is StateMachine {\n', '\n', '    event LogSetStageStartTime(bytes32 indexed stageId, uint256 startTime);\n', '\n', '    // Stores the start timestamp for each stage (the value is 0 if the stage doesn&#39;t have a start timestamp).\n', '    mapping(bytes32 => uint256) internal startTime;\n', '\n', '    /// @dev This function overrides the startConditions function in the parent class in order to enable automatic transitions that depend on the timestamp.\n', '    function startConditions(bytes32 stageId) internal constant returns(bool) {\n', '        // Get the startTime for stage\n', '        uint256 start = startTime[stageId];\n', '        // If the startTime is set and has already passed, return true.\n', '        return start != 0 && block.timestamp > start;\n', '    }\n', '\n', '    /// @dev Sets the starting timestamp for a stage.\n', '    /// @param stageId The id of the stage for which we want to set the start timestamp.\n', '    /// @param timestamp The start timestamp for the given stage. It should be bigger than the current one.\n', '    function setStageStartTime(bytes32 stageId, uint256 timestamp) internal {\n', '        require(state.validStage[stageId]);\n', '        require(timestamp > block.timestamp);\n', '\n', '        startTime[stageId] = timestamp;\n', '        LogSetStageStartTime(stageId, timestamp);\n', '    }\n', '\n', '    /// @dev Returns the timestamp for the given stage id.\n', '    /// @param stageId The id of the stage for which we want to set the start timestamp.\n', '    function getStageStartTime(bytes32 stageId) public view returns(uint256) {\n', '        return startTime[stageId];\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '    Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner canMint public returns (bool) {\n', '    mintingFinished = true;\n', '    MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '\n', 'contract ERC223Basic is ERC20Basic {\n', '\n', '    /**\n', '      * @dev Transfer the specified amount of tokens to the specified address.\n', '      *      Now with a new parameter _data.\n', '      *\n', '      * @param _to    Receiver address.\n', '      * @param _value Amount of tokens that will be transferred.\n', '      * @param _data  Transaction metadata.\n', '      */\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool);\n', '\n', '    /**\n', '      * @dev triggered when transfer is successfully called.\n', '      *\n', '      * @param _from  Sender address.\n', '      * @param _to    Receiver address.\n', '      * @param _value Amount of tokens that will be transferred.\n', '      * @param _data  Transaction metadata.\n', '      */\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data);\n', '}\n', '\n', '/// @title Contract that supports the receival of ERC223 tokens.\n', 'contract ERC223ReceivingContract {\n', '\n', '    /// @dev Standard ERC223 function that will handle incoming token transfers.\n', '    /// @param _from  Token sender address.\n', '    /// @param _value Amount of tokens.\n', '    /// @param _data  Transaction metadata.\n', '    function tokenFallback(address _from, uint _value, bytes _data);\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC223 standard token implementation.\n', ' */\n', 'contract ERC223BasicToken is ERC223Basic, BasicToken {\n', '\n', '    /**\n', '      * @dev Transfer the specified amount of tokens to the specified address.\n', '      *      Invokes the `tokenFallback` function if the recipient is a contract.\n', '      *      The token transfer fails if the recipient is a contract\n', '      *      but does not implement the `tokenFallback` function\n', '      *      or the fallback function to receive funds.\n', '      *\n', '      * @param _to    Receiver address.\n', '      * @param _value Amount of tokens that will be transferred.\n', '      * @param _data  Transaction metadata.\n', '      */\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n', '        // Standard function transfer similar to ERC20 transfer with no _data .\n', '        // Added due to backwards compatibility reasons .\n', '        uint codeLength;\n', '\n', '        assembly {\n', '            // Retrieve the size of the code on target address, this needs assembly .\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        require(super.transfer(_to, _value));\n', '\n', '        if(codeLength>0) {\n', '            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '            receiver.tokenFallback(msg.sender, _value, _data);\n', '        }\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '      /**\n', '      * @dev Transfer the specified amount of tokens to the specified address.\n', '      *      Invokes the `tokenFallback` function if the recipient is a contract.\n', '      *      The token transfer fails if the recipient is a contract\n', '      *      but does not implement the `tokenFallback` function\n', '      *      or the fallback function to receive funds.\n', '      *\n', '      * @param _to    Receiver address.\n', '      * @param _value Amount of tokens that will be transferred.\n', '      */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        bytes memory empty;\n', '        require(transfer(_to, _value, empty));\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '/// @title Token for the Pryze project.\n', 'contract PryzeToken is DetailedERC20, MintableToken, ERC223BasicToken {\n', '    string constant NAME = "Pryze";\n', '    string constant SYMBOL = "PRYZ";\n', '    uint8 constant DECIMALS = 18;\n', '\n', '    //// @dev Constructor that sets details of the ERC20 token.\n', '    function PryzeToken()\n', '        DetailedERC20(NAME, SYMBOL, DECIMALS)\n', '        public\n', '    {}\n', '}\n', '\n', '\n', '\n', 'contract Whitelistable is Ownable {\n', '    \n', '    event LogUserRegistered(address indexed sender, address indexed userAddress);\n', '    event LogUserUnregistered(address indexed sender, address indexed userAddress);\n', '    \n', '    mapping(address => bool) public whitelisted;\n', '\n', '    function registerUser(address userAddress) \n', '        public \n', '        onlyOwner \n', '    {\n', '        require(userAddress != 0);\n', '        whitelisted[userAddress] = true;\n', '        LogUserRegistered(msg.sender, userAddress);\n', '    }\n', '\n', '    function unregisterUser(address userAddress) \n', '        public \n', '        onlyOwner \n', '    {\n', '        require(whitelisted[userAddress] == true);\n', '        whitelisted[userAddress] = false;\n', '        LogUserUnregistered(msg.sender, userAddress);\n', '    }\n', '}\n', '\n', '\n', 'contract DisbursementHandler is Ownable {\n', '\n', '    struct Disbursement {\n', '        uint256 timestamp;\n', '        uint256 tokens;\n', '    }\n', '\n', '    event LogSetup(address indexed vestor, uint256 tokens, uint256 timestamp);\n', '    event LogChangeTimestamp(address indexed vestor, uint256 index, uint256 timestamp);\n', '    event LogWithdraw(address indexed to, uint256 value);\n', '\n', '    ERC20 public token;\n', '    mapping(address => Disbursement[]) public disbursements;\n', '    mapping(address => uint256) public withdrawnTokens;\n', '\n', '    function DisbursementHandler(address _token) public {\n', '        token = ERC20(_token);\n', '    }\n', '\n', '    /// @dev Called by the sale contract to create a disbursement.\n', '    /// @param vestor The address of the beneficiary.\n', '    /// @param tokens Amount of tokens to be locked.\n', '    /// @param timestamp Funds will be locked until this timestamp.\n', '    function setupDisbursement(\n', '        address vestor,\n', '        uint256 tokens,\n', '        uint256 timestamp\n', '    )\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(block.timestamp < timestamp);\n', '        disbursements[vestor].push(Disbursement(timestamp, tokens));\n', '        LogSetup(vestor, timestamp, tokens);\n', '    }\n', '\n', '    /// @dev Change an existing disbursement.\n', '    /// @param vestor The address of the beneficiary.\n', '    /// @param timestamp Funds will be locked until this timestamp.\n', '    /// @param index Index of the DisbursementVesting in the vesting array.\n', '    function changeTimestamp(\n', '        address vestor,\n', '        uint256 index,\n', '        uint256 timestamp\n', '    )\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(block.timestamp < timestamp);\n', '        require(index < disbursements[vestor].length);\n', '        disbursements[vestor][index].timestamp = timestamp;\n', '        LogChangeTimestamp(vestor, index, timestamp);\n', '    }\n', '\n', '    /// @dev Transfers tokens to a given address\n', '    /// @param to Address of token receiver\n', '    /// @param value Number of tokens to transfer\n', '    function withdraw(address to, uint256 value)\n', '        public\n', '    {\n', '        uint256 maxTokens = calcMaxWithdraw();\n', '        uint256 withdrawAmount = value < maxTokens ? value : maxTokens;\n', '        withdrawnTokens[msg.sender] = SafeMath.add(withdrawnTokens[msg.sender], withdrawAmount);\n', '        token.transfer(to, withdrawAmount);\n', '        LogWithdraw(to, value);\n', '    }\n', '\n', '    /// @dev Calculates the maximum amount of vested tokens\n', '    /// @return Number of vested tokens to withdraw\n', '    function calcMaxWithdraw()\n', '        public\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        uint256 maxTokens = 0;\n', '        Disbursement[] storage temp = disbursements[msg.sender];\n', '        for (uint256 i = 0; i < temp.length; i++) {\n', '            if (block.timestamp > temp[i].timestamp) {\n', '                maxTokens = SafeMath.add(maxTokens, temp[i].tokens);\n', '            }\n', '        }\n', '        maxTokens = SafeMath.sub(maxTokens, withdrawnTokens[msg.sender]);\n', '        return maxTokens;\n', '    }\n', '}\n', '\n', '\n', '/// @title Sale base contract\n', 'contract Sale is Ownable, TimedStateMachine {\n', '    using SafeMath for uint256;\n', '\n', '    event LogContribution(address indexed contributor, uint256 amountSent, uint256 excessRefunded);\n', '    event LogTokenAllocation(address indexed contributor, uint256 contribution, uint256 tokens);\n', '    event LogDisbursement(address indexed beneficiary, uint256 tokens);\n', '\n', '    // Stages for the state machine\n', '    bytes32 public constant SETUP = "setup";\n', '    bytes32 public constant SETUP_DONE = "setupDone";\n', '    bytes32 public constant SALE_IN_PROGRESS = "saleInProgress";\n', '    bytes32 public constant SALE_ENDED = "saleEnded";\n', '\n', '    mapping(address => uint256) public contributions;\n', '\n', '    uint256 public weiContributed = 0;\n', '    uint256 public contributionCap;\n', '\n', '    // Wallet where funds will be sent\n', '    address public wallet;\n', '\n', '    MintableToken public token;\n', '\n', '    DisbursementHandler public disbursementHandler;\n', '\n', '    function Sale(\n', '        address _wallet, \n', '        uint256 _contributionCap\n', '    ) \n', '        public \n', '    {\n', '        require(_wallet != 0);\n', '        require(_contributionCap != 0);\n', '\n', '        wallet = _wallet;\n', '\n', '        token = createTokenContract();\n', '        disbursementHandler = new DisbursementHandler(token);\n', '\n', '        contributionCap = _contributionCap;\n', '\n', '        setupStages();\n', '    }\n', '\n', '    function() external payable {\n', '        contribute();\n', '    }\n', '\n', '    /// @dev Sets the start timestamp for the SALE_IN_PROGRESS stage.\n', '    /// @param timestamp The start timestamp.\n', '    function setSaleStartTime(uint256 timestamp) \n', '        external \n', '        onlyOwner \n', '        checkAllowed\n', '    {\n', '        // require(_startTime < getStageStartTime(SALE_ENDED));\n', '        setStageStartTime(SALE_IN_PROGRESS, timestamp);\n', '    }\n', '\n', '    /// @dev Sets the start timestamp for the SALE_ENDED stage.\n', '    /// @param timestamp The start timestamp.\n', '    function setSaleEndTime(uint256 timestamp) \n', '        external \n', '        onlyOwner \n', '        checkAllowed\n', '    {\n', '        require(getStageStartTime(SALE_IN_PROGRESS) < timestamp);\n', '        setStageStartTime(SALE_ENDED, timestamp);\n', '    }\n', '\n', '    /// @dev Called in the SETUP stage, check configurations and to go to the SETUP_DONE stage.\n', '    function setupDone() \n', '        public \n', '        onlyOwner \n', '        checkAllowed\n', '    {\n', '        uint256 _startTime = getStageStartTime(SALE_IN_PROGRESS);\n', '        uint256 _endTime = getStageStartTime(SALE_ENDED);\n', '        require(block.timestamp < _startTime);\n', '        require(_startTime < _endTime);\n', '\n', '        state.goToNextStage();\n', '    }\n', '\n', '    /// @dev Called by users to contribute ETH to the sale.\n', '    function contribute() \n', '        public \n', '        payable\n', '        checkAllowed \n', '    {\n', '        require(msg.value > 0);   \n', '\n', '        uint256 contributionLimit = getContributionLimit(msg.sender);\n', '        require(contributionLimit > 0);\n', '\n', '        // Check that the user is allowed to contribute\n', '        uint256 totalContribution = contributions[msg.sender].add(msg.value);\n', '        uint256 excess = 0;\n', '\n', '        // Check if it goes over the eth cap for the sale.\n', '        if (weiContributed.add(msg.value) > contributionCap) {\n', '            // Subtract the excess\n', '            excess = weiContributed.add(msg.value).sub(contributionCap);\n', '            totalContribution = totalContribution.sub(excess);\n', '        }\n', '\n', '        // Check if it goes over the contribution limit of the user. \n', '        if (totalContribution > contributionLimit) {\n', '            excess = excess.add(totalContribution).sub(contributionLimit);\n', '            contributions[msg.sender] = contributionLimit;\n', '        } else {\n', '            contributions[msg.sender] = totalContribution;\n', '        }\n', '\n', '        // We are only able to refund up to msg.value because the contract will not contain ether\n', '        excess = excess < msg.value ? excess : msg.value;\n', '\n', '        weiContributed = weiContributed.add(msg.value).sub(excess);\n', '\n', '        if (excess > 0) {\n', '            msg.sender.transfer(excess);\n', '        }\n', '\n', '        wallet.transfer(this.balance);\n', '\n', '        assert(contributions[msg.sender] <= contributionLimit);\n', '        LogContribution(msg.sender, msg.value, excess);\n', '    }\n', '\n', '    /// @dev Create a disbursement of tokens.\n', '    /// @param beneficiary The beneficiary of the disbursement.\n', '    /// @param tokenAmount Amount of tokens to be locked.\n', '    /// @param timestamp Tokens will be locked until this timestamp.\n', '    function distributeTimelockedTokens(\n', '        address beneficiary,\n', '        uint256 tokenAmount,\n', '        uint256 timestamp\n', '    ) \n', '        external\n', '        onlyOwner\n', '        checkAllowed\n', '    { \n', '        disbursementHandler.setupDisbursement(\n', '            beneficiary,\n', '            tokenAmount,\n', '            timestamp\n', '        );\n', '        token.mint(disbursementHandler, tokenAmount);\n', '        LogDisbursement(beneficiary, tokenAmount);\n', '    }\n', '    \n', '    function setupStages() internal {\n', '        // Set the stages\n', '        state.setInitialStage(SETUP);\n', '        state.createTransition(SETUP, SETUP_DONE);\n', '        state.createTransition(SETUP_DONE, SALE_IN_PROGRESS);\n', '        state.createTransition(SALE_IN_PROGRESS, SALE_ENDED);\n', '\n', '        // The selectors should be hardcoded\n', '        state.allowFunction(SETUP, this.distributeTimelockedTokens.selector);\n', '        state.allowFunction(SETUP, this.setSaleStartTime.selector);\n', '        state.allowFunction(SETUP, this.setSaleEndTime.selector);\n', '        state.allowFunction(SETUP, this.setupDone.selector);\n', '        state.allowFunction(SALE_IN_PROGRESS, this.contribute.selector);\n', '        state.allowFunction(SALE_IN_PROGRESS, 0); // fallback\n', '    }\n', '\n', '    // Override in the child sales\n', '    function createTokenContract() internal returns (MintableToken);\n', '    function getContributionLimit(address userAddress) internal returns (uint256);\n', '\n', '    /// @dev Stage start conditions.\n', '    function startConditions(bytes32 stageId) internal constant returns (bool) {\n', '        // If the cap has been reached, end the sale.\n', '        if (stageId == SALE_ENDED && contributionCap == weiContributed) {\n', '            return true;\n', '        }\n', '        return super.startConditions(stageId);\n', '    }\n', '\n', '    /// @dev State transitions callbacks.\n', '    function onTransition(bytes32 stageId) internal {\n', '        if (stageId == SALE_ENDED) { \n', '            onSaleEnded(); \n', '        }\n', '        super.onTransition(stageId);\n', '    }\n', '\n', '    /// @dev Callback that gets called when entering the SALE_ENDED stage.\n', '    function onSaleEnded() internal {}\n', '}\n', '\n', '\n', '\n', 'contract PryzeSale is Sale, Whitelistable {\n', '\n', '    uint256 public constant PRESALE_WEI = 10695.303 ether; // Amount raised in the presale\n', '    uint256 public constant PRESALE_WEI_WITH_BONUS = 10695.303 ether * 1.5; // Amount raised in the presale times the bonus\n', '\n', '    uint256 public constant MAX_WEI = 24695.303 ether; // Max wei to raise, including PRESALE_WEI\n', '    uint256 public constant WEI_CAP = 14000 ether; // MAX_WEI - PRESALE_WEI\n', '    uint256 public constant MAX_TOKENS = 400000000 * 1000000000000000000; // 4mm times 10^18 (18 decimals)\n', '\n', '    uint256 public presaleWeiContributed = 0;\n', '    uint256 private weiAllocated = 0;\n', '\n', '    mapping(address => uint256) public presaleContributions;\n', '\n', '    function PryzeSale(\n', '        address _wallet\n', '    )\n', '        Sale(_wallet, WEI_CAP)\n', '        public \n', '    {\n', '    }\n', '\n', '    /// @dev Sets the presale contribution for a contributor.\n', '    /// @param _contributor The contributor.\n', '    /// @param _amount The amount contributed in the presale (without the bonus).\n', '    function presaleContribute(address _contributor, uint256 _amount)\n', '        external\n', '        onlyOwner\n', '        checkAllowed\n', '    {\n', '        // If presale contribution is already set, replace the amount in the presaleWeiContributed variable\n', '        if (presaleContributions[_contributor] != 0) {\n', '            presaleWeiContributed = presaleWeiContributed.sub(presaleContributions[_contributor]);\n', '        } \n', '        presaleWeiContributed = presaleWeiContributed.add(_amount);\n', '        require(presaleWeiContributed <= PRESALE_WEI);\n', '        presaleContributions[_contributor] = _amount;\n', '    }\n', '\n', '    /// @dev Called to allocate the tokens depending on eth contributed.\n', '    /// @param contributor The address of the contributor.\n', '    function allocateTokens(address contributor) \n', '        external \n', '        checkAllowed\n', '    {\n', '        require(presaleContributions[contributor] != 0 || contributions[contributor] != 0);\n', '        uint256 tokensToAllocate = calculateAllocation(contributor);\n', '\n', '        // We keep a record of how much wei contributed has already been used for allocations\n', '        weiAllocated = weiAllocated.add(presaleContributions[contributor]).add(contributions[contributor]);\n', '\n', '        // Set contributions to 0\n', '        presaleContributions[contributor] = 0;\n', '        contributions[contributor] = 0;\n', '\n', '        // Mint the respective tokens to the contributor\n', '        token.mint(contributor, tokensToAllocate);\n', '\n', '        // If all tokens were allocated, stop minting functionality\n', '        if (weiAllocated == PRESALE_WEI.add(weiContributed)) {\n', '          token.finishMinting();\n', '        }\n', '    }\n', '\n', '    function setupDone() \n', '        public \n', '        onlyOwner \n', '        checkAllowed\n', '    {\n', '        require(presaleWeiContributed == PRESALE_WEI);\n', '        super.setupDone();\n', '    }\n', '\n', '    /// @dev Calculate the PRYZ allocation for the given contributor. The allocation is proportional to the amount of wei contributed.\n', '    /// @param contributor The address of the contributor\n', '    /// @return The amount of tokens to allocate\n', '    function calculateAllocation(address contributor) public constant returns (uint256) {\n', '        uint256 presale = presaleContributions[contributor].mul(15).div(10); // Multiply by 1.5\n', '        uint256 totalContribution = presale.add(contributions[contributor]);\n', '        return totalContribution.mul(MAX_TOKENS).div(PRESALE_WEI_WITH_BONUS.add(weiContributed));\n', '    }\n', '\n', '    function setupStages() internal {\n', '        super.setupStages();\n', '        state.allowFunction(SETUP, this.presaleContribute.selector);\n', '        state.allowFunction(SALE_ENDED, this.allocateTokens.selector);\n', '    }\n', '\n', '    function createTokenContract() internal returns(MintableToken) {\n', '        return new PryzeToken();\n', '    }\n', '\n', '    function getContributionLimit(address userAddress) internal returns (uint256) {\n', '        // No contribution cap if whitelisted\n', '        return whitelisted[userAddress] ? 2**256 - 1 : 0;\n', '    }\n', '\n', '}']
['pragma solidity 0.4.18;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/// @title A library for implementing a generic state machine pattern.\n', 'library StateMachineLib {\n', '\n', '    struct Stage {\n', '        // The id of the next stage\n', '        bytes32 nextId;\n', '\n', '        // The identifiers for the available functions in each stage\n', '        mapping(bytes4 => bool) allowedFunctions;\n', '    }\n', '\n', '    struct State {\n', '        // The current stage id\n', '        bytes32 currentStageId;\n', '\n', '        // A callback that is called when entering this stage\n', '        function(bytes32) internal onTransition;\n', '\n', '        // Checks if a stage id is valid\n', '        mapping(bytes32 => bool) validStage;\n', '\n', '        // Maps stage ids to their Stage structs\n', '        mapping(bytes32 => Stage) stages;\n', '    }\n', '\n', '    /// @dev Creates and sets the initial stage. It has to be called before creating any transitions.\n', '    /// @param stageId The id of the (new) stage to set as initial stage.\n', '    function setInitialStage(State storage self, bytes32 stageId) internal {\n', '        self.validStage[stageId] = true;\n', '        self.currentStageId = stageId;\n', '    }\n', '\n', "    /// @dev Creates a transition from 'fromId' to 'toId'. If fromId already had a nextId, it deletes the now unreachable stage.\n", '    /// @param fromId The id of the stage from which the transition begins.\n', '    /// @param toId The id of the stage that will be reachable from "fromId".\n', '    function createTransition(State storage self, bytes32 fromId, bytes32 toId) internal {\n', '        require(self.validStage[fromId]);\n', '\n', '        Stage storage from = self.stages[fromId];\n', '\n', "        // Invalidate the stage that won't be reachable any more\n", '        if (from.nextId != 0) {\n', '            self.validStage[from.nextId] = false;\n', '            delete self.stages[from.nextId];\n', '        }\n', '\n', '        from.nextId = toId;\n', '        self.validStage[toId] = true;\n', '    }\n', '\n', '    /// @dev Goes to the next stage if posible (if the next stage is valid)\n', '    function goToNextStage(State storage self) internal {\n', '        Stage storage current = self.stages[self.currentStageId];\n', '\n', '        require(self.validStage[current.nextId]);\n', '\n', '        self.currentStageId = current.nextId;\n', '\n', '        self.onTransition(current.nextId);\n', '    }\n', '\n', '    /// @dev Checks if the a function is allowed in the current stage.\n', '    /// @param selector A function selector (bytes4[keccak256(functionSignature)])\n', '    /// @return true If the function is allowed in the current stage\n', '    function checkAllowedFunction(State storage self, bytes4 selector) internal constant returns(bool) {\n', '        return self.stages[self.currentStageId].allowedFunctions[selector];\n', '    }\n', '\n', '    /// @dev Allow a function in the given stage.\n', '    /// @param stageId The id of the stage\n', '    /// @param selector A function selector (bytes4[keccak256(functionSignature)])\n', '    function allowFunction(State storage self, bytes32 stageId, bytes4 selector) internal {\n', '        require(self.validStage[stageId]);\n', '        self.stages[stageId].allowedFunctions[selector] = true;\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '\n', 'contract StateMachine {\n', '    using StateMachineLib for StateMachineLib.State;\n', '\n', '    event LogTransition(bytes32 indexed stageId, uint256 blockNumber);\n', '\n', '    StateMachineLib.State internal state;\n', '\n', '    /* This modifier performs the conditional transitions and checks that the function \n', '     * to be executed is allowed in the current stage\n', '     */\n', '    modifier checkAllowed {\n', '        conditionalTransitions();\n', '        require(state.checkAllowedFunction(msg.sig));\n', '        _;\n', '    }\n', '\n', '    function StateMachine() public {\n', '        // Register the startConditions function and the onTransition callback\n', '        state.onTransition = onTransition;\n', '    }\n', '\n', '    /// @dev Gets the current stage id.\n', '    /// @return The current stage id.\n', '    function getCurrentStageId() public view returns(bytes32) {\n', '        return state.currentStageId;\n', '    }\n', '\n', '    /// @dev Performs conditional transitions. Can be called by anyone.\n', '    function conditionalTransitions() public {\n', '\n', '        bytes32 nextId = state.stages[state.currentStageId].nextId;\n', '\n', '        while (state.validStage[nextId]) {\n', '            StateMachineLib.Stage storage next = state.stages[nextId];\n', "            // If the next stage's condition is true, go to next stage and continue\n", '            if (startConditions(nextId)) {\n', '                state.goToNextStage();\n', '                nextId = next.nextId;\n', '            } else {\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Determines whether the conditions for transitioning to the given stage are met.\n', '    /// @return true if the conditions are met for the given stageId. False by default (must override in child contracts).\n', '    function startConditions(bytes32) internal constant returns(bool) {\n', '        return false;\n', '    }\n', '\n', '    /// @dev Callback called when there is a stage transition. It should be overridden for additional functionality.\n', '    function onTransition(bytes32 stageId) internal {\n', '        LogTransition(stageId, block.number);\n', '    }\n', '\n', '\n', '}\n', '\n', '/// @title A contract that implements the state machine pattern and adds time dependant transitions.\n', 'contract TimedStateMachine is StateMachine {\n', '\n', '    event LogSetStageStartTime(bytes32 indexed stageId, uint256 startTime);\n', '\n', "    // Stores the start timestamp for each stage (the value is 0 if the stage doesn't have a start timestamp).\n", '    mapping(bytes32 => uint256) internal startTime;\n', '\n', '    /// @dev This function overrides the startConditions function in the parent class in order to enable automatic transitions that depend on the timestamp.\n', '    function startConditions(bytes32 stageId) internal constant returns(bool) {\n', '        // Get the startTime for stage\n', '        uint256 start = startTime[stageId];\n', '        // If the startTime is set and has already passed, return true.\n', '        return start != 0 && block.timestamp > start;\n', '    }\n', '\n', '    /// @dev Sets the starting timestamp for a stage.\n', '    /// @param stageId The id of the stage for which we want to set the start timestamp.\n', '    /// @param timestamp The start timestamp for the given stage. It should be bigger than the current one.\n', '    function setStageStartTime(bytes32 stageId, uint256 timestamp) internal {\n', '        require(state.validStage[stageId]);\n', '        require(timestamp > block.timestamp);\n', '\n', '        startTime[stageId] = timestamp;\n', '        LogSetStageStartTime(stageId, timestamp);\n', '    }\n', '\n', '    /// @dev Returns the timestamp for the given stage id.\n', '    /// @param stageId The id of the stage for which we want to set the start timestamp.\n', '    function getStageStartTime(bytes32 stageId) public view returns(uint256) {\n', '        return startTime[stageId];\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '    Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner canMint public returns (bool) {\n', '    mintingFinished = true;\n', '    MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '\n', 'contract ERC223Basic is ERC20Basic {\n', '\n', '    /**\n', '      * @dev Transfer the specified amount of tokens to the specified address.\n', '      *      Now with a new parameter _data.\n', '      *\n', '      * @param _to    Receiver address.\n', '      * @param _value Amount of tokens that will be transferred.\n', '      * @param _data  Transaction metadata.\n', '      */\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool);\n', '\n', '    /**\n', '      * @dev triggered when transfer is successfully called.\n', '      *\n', '      * @param _from  Sender address.\n', '      * @param _to    Receiver address.\n', '      * @param _value Amount of tokens that will be transferred.\n', '      * @param _data  Transaction metadata.\n', '      */\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data);\n', '}\n', '\n', '/// @title Contract that supports the receival of ERC223 tokens.\n', 'contract ERC223ReceivingContract {\n', '\n', '    /// @dev Standard ERC223 function that will handle incoming token transfers.\n', '    /// @param _from  Token sender address.\n', '    /// @param _value Amount of tokens.\n', '    /// @param _data  Transaction metadata.\n', '    function tokenFallback(address _from, uint _value, bytes _data);\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC223 standard token implementation.\n', ' */\n', 'contract ERC223BasicToken is ERC223Basic, BasicToken {\n', '\n', '    /**\n', '      * @dev Transfer the specified amount of tokens to the specified address.\n', '      *      Invokes the `tokenFallback` function if the recipient is a contract.\n', '      *      The token transfer fails if the recipient is a contract\n', '      *      but does not implement the `tokenFallback` function\n', '      *      or the fallback function to receive funds.\n', '      *\n', '      * @param _to    Receiver address.\n', '      * @param _value Amount of tokens that will be transferred.\n', '      * @param _data  Transaction metadata.\n', '      */\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n', '        // Standard function transfer similar to ERC20 transfer with no _data .\n', '        // Added due to backwards compatibility reasons .\n', '        uint codeLength;\n', '\n', '        assembly {\n', '            // Retrieve the size of the code on target address, this needs assembly .\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        require(super.transfer(_to, _value));\n', '\n', '        if(codeLength>0) {\n', '            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '            receiver.tokenFallback(msg.sender, _value, _data);\n', '        }\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '      /**\n', '      * @dev Transfer the specified amount of tokens to the specified address.\n', '      *      Invokes the `tokenFallback` function if the recipient is a contract.\n', '      *      The token transfer fails if the recipient is a contract\n', '      *      but does not implement the `tokenFallback` function\n', '      *      or the fallback function to receive funds.\n', '      *\n', '      * @param _to    Receiver address.\n', '      * @param _value Amount of tokens that will be transferred.\n', '      */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        bytes memory empty;\n', '        require(transfer(_to, _value, empty));\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '/// @title Token for the Pryze project.\n', 'contract PryzeToken is DetailedERC20, MintableToken, ERC223BasicToken {\n', '    string constant NAME = "Pryze";\n', '    string constant SYMBOL = "PRYZ";\n', '    uint8 constant DECIMALS = 18;\n', '\n', '    //// @dev Constructor that sets details of the ERC20 token.\n', '    function PryzeToken()\n', '        DetailedERC20(NAME, SYMBOL, DECIMALS)\n', '        public\n', '    {}\n', '}\n', '\n', '\n', '\n', 'contract Whitelistable is Ownable {\n', '    \n', '    event LogUserRegistered(address indexed sender, address indexed userAddress);\n', '    event LogUserUnregistered(address indexed sender, address indexed userAddress);\n', '    \n', '    mapping(address => bool) public whitelisted;\n', '\n', '    function registerUser(address userAddress) \n', '        public \n', '        onlyOwner \n', '    {\n', '        require(userAddress != 0);\n', '        whitelisted[userAddress] = true;\n', '        LogUserRegistered(msg.sender, userAddress);\n', '    }\n', '\n', '    function unregisterUser(address userAddress) \n', '        public \n', '        onlyOwner \n', '    {\n', '        require(whitelisted[userAddress] == true);\n', '        whitelisted[userAddress] = false;\n', '        LogUserUnregistered(msg.sender, userAddress);\n', '    }\n', '}\n', '\n', '\n', 'contract DisbursementHandler is Ownable {\n', '\n', '    struct Disbursement {\n', '        uint256 timestamp;\n', '        uint256 tokens;\n', '    }\n', '\n', '    event LogSetup(address indexed vestor, uint256 tokens, uint256 timestamp);\n', '    event LogChangeTimestamp(address indexed vestor, uint256 index, uint256 timestamp);\n', '    event LogWithdraw(address indexed to, uint256 value);\n', '\n', '    ERC20 public token;\n', '    mapping(address => Disbursement[]) public disbursements;\n', '    mapping(address => uint256) public withdrawnTokens;\n', '\n', '    function DisbursementHandler(address _token) public {\n', '        token = ERC20(_token);\n', '    }\n', '\n', '    /// @dev Called by the sale contract to create a disbursement.\n', '    /// @param vestor The address of the beneficiary.\n', '    /// @param tokens Amount of tokens to be locked.\n', '    /// @param timestamp Funds will be locked until this timestamp.\n', '    function setupDisbursement(\n', '        address vestor,\n', '        uint256 tokens,\n', '        uint256 timestamp\n', '    )\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(block.timestamp < timestamp);\n', '        disbursements[vestor].push(Disbursement(timestamp, tokens));\n', '        LogSetup(vestor, timestamp, tokens);\n', '    }\n', '\n', '    /// @dev Change an existing disbursement.\n', '    /// @param vestor The address of the beneficiary.\n', '    /// @param timestamp Funds will be locked until this timestamp.\n', '    /// @param index Index of the DisbursementVesting in the vesting array.\n', '    function changeTimestamp(\n', '        address vestor,\n', '        uint256 index,\n', '        uint256 timestamp\n', '    )\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(block.timestamp < timestamp);\n', '        require(index < disbursements[vestor].length);\n', '        disbursements[vestor][index].timestamp = timestamp;\n', '        LogChangeTimestamp(vestor, index, timestamp);\n', '    }\n', '\n', '    /// @dev Transfers tokens to a given address\n', '    /// @param to Address of token receiver\n', '    /// @param value Number of tokens to transfer\n', '    function withdraw(address to, uint256 value)\n', '        public\n', '    {\n', '        uint256 maxTokens = calcMaxWithdraw();\n', '        uint256 withdrawAmount = value < maxTokens ? value : maxTokens;\n', '        withdrawnTokens[msg.sender] = SafeMath.add(withdrawnTokens[msg.sender], withdrawAmount);\n', '        token.transfer(to, withdrawAmount);\n', '        LogWithdraw(to, value);\n', '    }\n', '\n', '    /// @dev Calculates the maximum amount of vested tokens\n', '    /// @return Number of vested tokens to withdraw\n', '    function calcMaxWithdraw()\n', '        public\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        uint256 maxTokens = 0;\n', '        Disbursement[] storage temp = disbursements[msg.sender];\n', '        for (uint256 i = 0; i < temp.length; i++) {\n', '            if (block.timestamp > temp[i].timestamp) {\n', '                maxTokens = SafeMath.add(maxTokens, temp[i].tokens);\n', '            }\n', '        }\n', '        maxTokens = SafeMath.sub(maxTokens, withdrawnTokens[msg.sender]);\n', '        return maxTokens;\n', '    }\n', '}\n', '\n', '\n', '/// @title Sale base contract\n', 'contract Sale is Ownable, TimedStateMachine {\n', '    using SafeMath for uint256;\n', '\n', '    event LogContribution(address indexed contributor, uint256 amountSent, uint256 excessRefunded);\n', '    event LogTokenAllocation(address indexed contributor, uint256 contribution, uint256 tokens);\n', '    event LogDisbursement(address indexed beneficiary, uint256 tokens);\n', '\n', '    // Stages for the state machine\n', '    bytes32 public constant SETUP = "setup";\n', '    bytes32 public constant SETUP_DONE = "setupDone";\n', '    bytes32 public constant SALE_IN_PROGRESS = "saleInProgress";\n', '    bytes32 public constant SALE_ENDED = "saleEnded";\n', '\n', '    mapping(address => uint256) public contributions;\n', '\n', '    uint256 public weiContributed = 0;\n', '    uint256 public contributionCap;\n', '\n', '    // Wallet where funds will be sent\n', '    address public wallet;\n', '\n', '    MintableToken public token;\n', '\n', '    DisbursementHandler public disbursementHandler;\n', '\n', '    function Sale(\n', '        address _wallet, \n', '        uint256 _contributionCap\n', '    ) \n', '        public \n', '    {\n', '        require(_wallet != 0);\n', '        require(_contributionCap != 0);\n', '\n', '        wallet = _wallet;\n', '\n', '        token = createTokenContract();\n', '        disbursementHandler = new DisbursementHandler(token);\n', '\n', '        contributionCap = _contributionCap;\n', '\n', '        setupStages();\n', '    }\n', '\n', '    function() external payable {\n', '        contribute();\n', '    }\n', '\n', '    /// @dev Sets the start timestamp for the SALE_IN_PROGRESS stage.\n', '    /// @param timestamp The start timestamp.\n', '    function setSaleStartTime(uint256 timestamp) \n', '        external \n', '        onlyOwner \n', '        checkAllowed\n', '    {\n', '        // require(_startTime < getStageStartTime(SALE_ENDED));\n', '        setStageStartTime(SALE_IN_PROGRESS, timestamp);\n', '    }\n', '\n', '    /// @dev Sets the start timestamp for the SALE_ENDED stage.\n', '    /// @param timestamp The start timestamp.\n', '    function setSaleEndTime(uint256 timestamp) \n', '        external \n', '        onlyOwner \n', '        checkAllowed\n', '    {\n', '        require(getStageStartTime(SALE_IN_PROGRESS) < timestamp);\n', '        setStageStartTime(SALE_ENDED, timestamp);\n', '    }\n', '\n', '    /// @dev Called in the SETUP stage, check configurations and to go to the SETUP_DONE stage.\n', '    function setupDone() \n', '        public \n', '        onlyOwner \n', '        checkAllowed\n', '    {\n', '        uint256 _startTime = getStageStartTime(SALE_IN_PROGRESS);\n', '        uint256 _endTime = getStageStartTime(SALE_ENDED);\n', '        require(block.timestamp < _startTime);\n', '        require(_startTime < _endTime);\n', '\n', '        state.goToNextStage();\n', '    }\n', '\n', '    /// @dev Called by users to contribute ETH to the sale.\n', '    function contribute() \n', '        public \n', '        payable\n', '        checkAllowed \n', '    {\n', '        require(msg.value > 0);   \n', '\n', '        uint256 contributionLimit = getContributionLimit(msg.sender);\n', '        require(contributionLimit > 0);\n', '\n', '        // Check that the user is allowed to contribute\n', '        uint256 totalContribution = contributions[msg.sender].add(msg.value);\n', '        uint256 excess = 0;\n', '\n', '        // Check if it goes over the eth cap for the sale.\n', '        if (weiContributed.add(msg.value) > contributionCap) {\n', '            // Subtract the excess\n', '            excess = weiContributed.add(msg.value).sub(contributionCap);\n', '            totalContribution = totalContribution.sub(excess);\n', '        }\n', '\n', '        // Check if it goes over the contribution limit of the user. \n', '        if (totalContribution > contributionLimit) {\n', '            excess = excess.add(totalContribution).sub(contributionLimit);\n', '            contributions[msg.sender] = contributionLimit;\n', '        } else {\n', '            contributions[msg.sender] = totalContribution;\n', '        }\n', '\n', '        // We are only able to refund up to msg.value because the contract will not contain ether\n', '        excess = excess < msg.value ? excess : msg.value;\n', '\n', '        weiContributed = weiContributed.add(msg.value).sub(excess);\n', '\n', '        if (excess > 0) {\n', '            msg.sender.transfer(excess);\n', '        }\n', '\n', '        wallet.transfer(this.balance);\n', '\n', '        assert(contributions[msg.sender] <= contributionLimit);\n', '        LogContribution(msg.sender, msg.value, excess);\n', '    }\n', '\n', '    /// @dev Create a disbursement of tokens.\n', '    /// @param beneficiary The beneficiary of the disbursement.\n', '    /// @param tokenAmount Amount of tokens to be locked.\n', '    /// @param timestamp Tokens will be locked until this timestamp.\n', '    function distributeTimelockedTokens(\n', '        address beneficiary,\n', '        uint256 tokenAmount,\n', '        uint256 timestamp\n', '    ) \n', '        external\n', '        onlyOwner\n', '        checkAllowed\n', '    { \n', '        disbursementHandler.setupDisbursement(\n', '            beneficiary,\n', '            tokenAmount,\n', '            timestamp\n', '        );\n', '        token.mint(disbursementHandler, tokenAmount);\n', '        LogDisbursement(beneficiary, tokenAmount);\n', '    }\n', '    \n', '    function setupStages() internal {\n', '        // Set the stages\n', '        state.setInitialStage(SETUP);\n', '        state.createTransition(SETUP, SETUP_DONE);\n', '        state.createTransition(SETUP_DONE, SALE_IN_PROGRESS);\n', '        state.createTransition(SALE_IN_PROGRESS, SALE_ENDED);\n', '\n', '        // The selectors should be hardcoded\n', '        state.allowFunction(SETUP, this.distributeTimelockedTokens.selector);\n', '        state.allowFunction(SETUP, this.setSaleStartTime.selector);\n', '        state.allowFunction(SETUP, this.setSaleEndTime.selector);\n', '        state.allowFunction(SETUP, this.setupDone.selector);\n', '        state.allowFunction(SALE_IN_PROGRESS, this.contribute.selector);\n', '        state.allowFunction(SALE_IN_PROGRESS, 0); // fallback\n', '    }\n', '\n', '    // Override in the child sales\n', '    function createTokenContract() internal returns (MintableToken);\n', '    function getContributionLimit(address userAddress) internal returns (uint256);\n', '\n', '    /// @dev Stage start conditions.\n', '    function startConditions(bytes32 stageId) internal constant returns (bool) {\n', '        // If the cap has been reached, end the sale.\n', '        if (stageId == SALE_ENDED && contributionCap == weiContributed) {\n', '            return true;\n', '        }\n', '        return super.startConditions(stageId);\n', '    }\n', '\n', '    /// @dev State transitions callbacks.\n', '    function onTransition(bytes32 stageId) internal {\n', '        if (stageId == SALE_ENDED) { \n', '            onSaleEnded(); \n', '        }\n', '        super.onTransition(stageId);\n', '    }\n', '\n', '    /// @dev Callback that gets called when entering the SALE_ENDED stage.\n', '    function onSaleEnded() internal {}\n', '}\n', '\n', '\n', '\n', 'contract PryzeSale is Sale, Whitelistable {\n', '\n', '    uint256 public constant PRESALE_WEI = 10695.303 ether; // Amount raised in the presale\n', '    uint256 public constant PRESALE_WEI_WITH_BONUS = 10695.303 ether * 1.5; // Amount raised in the presale times the bonus\n', '\n', '    uint256 public constant MAX_WEI = 24695.303 ether; // Max wei to raise, including PRESALE_WEI\n', '    uint256 public constant WEI_CAP = 14000 ether; // MAX_WEI - PRESALE_WEI\n', '    uint256 public constant MAX_TOKENS = 400000000 * 1000000000000000000; // 4mm times 10^18 (18 decimals)\n', '\n', '    uint256 public presaleWeiContributed = 0;\n', '    uint256 private weiAllocated = 0;\n', '\n', '    mapping(address => uint256) public presaleContributions;\n', '\n', '    function PryzeSale(\n', '        address _wallet\n', '    )\n', '        Sale(_wallet, WEI_CAP)\n', '        public \n', '    {\n', '    }\n', '\n', '    /// @dev Sets the presale contribution for a contributor.\n', '    /// @param _contributor The contributor.\n', '    /// @param _amount The amount contributed in the presale (without the bonus).\n', '    function presaleContribute(address _contributor, uint256 _amount)\n', '        external\n', '        onlyOwner\n', '        checkAllowed\n', '    {\n', '        // If presale contribution is already set, replace the amount in the presaleWeiContributed variable\n', '        if (presaleContributions[_contributor] != 0) {\n', '            presaleWeiContributed = presaleWeiContributed.sub(presaleContributions[_contributor]);\n', '        } \n', '        presaleWeiContributed = presaleWeiContributed.add(_amount);\n', '        require(presaleWeiContributed <= PRESALE_WEI);\n', '        presaleContributions[_contributor] = _amount;\n', '    }\n', '\n', '    /// @dev Called to allocate the tokens depending on eth contributed.\n', '    /// @param contributor The address of the contributor.\n', '    function allocateTokens(address contributor) \n', '        external \n', '        checkAllowed\n', '    {\n', '        require(presaleContributions[contributor] != 0 || contributions[contributor] != 0);\n', '        uint256 tokensToAllocate = calculateAllocation(contributor);\n', '\n', '        // We keep a record of how much wei contributed has already been used for allocations\n', '        weiAllocated = weiAllocated.add(presaleContributions[contributor]).add(contributions[contributor]);\n', '\n', '        // Set contributions to 0\n', '        presaleContributions[contributor] = 0;\n', '        contributions[contributor] = 0;\n', '\n', '        // Mint the respective tokens to the contributor\n', '        token.mint(contributor, tokensToAllocate);\n', '\n', '        // If all tokens were allocated, stop minting functionality\n', '        if (weiAllocated == PRESALE_WEI.add(weiContributed)) {\n', '          token.finishMinting();\n', '        }\n', '    }\n', '\n', '    function setupDone() \n', '        public \n', '        onlyOwner \n', '        checkAllowed\n', '    {\n', '        require(presaleWeiContributed == PRESALE_WEI);\n', '        super.setupDone();\n', '    }\n', '\n', '    /// @dev Calculate the PRYZ allocation for the given contributor. The allocation is proportional to the amount of wei contributed.\n', '    /// @param contributor The address of the contributor\n', '    /// @return The amount of tokens to allocate\n', '    function calculateAllocation(address contributor) public constant returns (uint256) {\n', '        uint256 presale = presaleContributions[contributor].mul(15).div(10); // Multiply by 1.5\n', '        uint256 totalContribution = presale.add(contributions[contributor]);\n', '        return totalContribution.mul(MAX_TOKENS).div(PRESALE_WEI_WITH_BONUS.add(weiContributed));\n', '    }\n', '\n', '    function setupStages() internal {\n', '        super.setupStages();\n', '        state.allowFunction(SETUP, this.presaleContribute.selector);\n', '        state.allowFunction(SALE_ENDED, this.allocateTokens.selector);\n', '    }\n', '\n', '    function createTokenContract() internal returns(MintableToken) {\n', '        return new PryzeToken();\n', '    }\n', '\n', '    function getContributionLimit(address userAddress) internal returns (uint256) {\n', '        // No contribution cap if whitelisted\n', '        return whitelisted[userAddress] ? 2**256 - 1 : 0;\n', '    }\n', '\n', '}']
