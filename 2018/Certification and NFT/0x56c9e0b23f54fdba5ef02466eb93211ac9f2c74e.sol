['contract SafeMath {\n', '    \n', '    uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require(x <= MAX_UINT256 - y);\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require(x >= y);\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) {\n', '            return 0;\n', '        }\n', '        require(x <= (MAX_UINT256 / y));\n', '        return x * y;\n', '    }\n', '}\n', '\n', 'contract ReentrancyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', '\n', 'contract Lockable is Owned {\n', '\n', '    uint256 public lockedUntilBlock;\n', '\n', '    event ContractLocked(uint256 _untilBlock, string _reason);\n', '\n', '    modifier lockAffected {\n', '        require(block.number > lockedUntilBlock);\n', '        _;\n', '    }\n', '\n', '    function lockFromSelf(uint256 _untilBlock, string _reason) internal {\n', '        lockedUntilBlock = _untilBlock;\n', '        ContractLocked(_untilBlock, _reason);\n', '    }\n', '\n', '\n', '    function lockUntil(uint256 _untilBlock, string _reason) onlyOwner public {\n', '        lockedUntilBlock = _untilBlock;\n', '        ContractLocked(_untilBlock, _reason);\n', '    }\n', '}\n', '\n', 'contract LinkedList {\n', '\n', '\tstruct Element {\n', '    \tuint previous;\n', '    \tuint next;\n', '\n', '    \taddress data;\n', '  \t}\n', '\n', '  \tuint public size;\n', '  \tuint public tail;\n', '  \tuint public head;\n', '  \tmapping(uint => Element) elements;\n', '  \tmapping(address => uint) elementLocation;\n', '\n', '\tfunction addItem(address _newItem) returns (bool) {\n', '\t\tElement memory elem = Element(0, 0, _newItem);\n', '\n', '\t\tif (size == 0) {\n', '        \thead = 1;\n', '      \t} else {\n', '        \telements[tail].next = tail + 1;\n', '        \telem.previous = tail;\n', '      \t}\n', '\n', '      \telementLocation[_newItem] = tail + 1;\n', '      \telements[tail + 1] = elem;\n', '      \tsize++;\n', '      \ttail++;\n', '      \treturn true;\n', '\t}\n', '\n', '    function removeItem(address _item) returns (bool) {\n', '        uint key;\n', '        if (elementLocation[_item] == 0) {\n', '            return false;\n', '        }else {\n', '            key = elementLocation[_item];\n', '        }\n', '\n', '        if (size == 1) {\n', '            tail = 0;\n', '            head = 0;\n', '        }else if (key == head) {\n', '            head = elements[head].next;\n', '        }else if (key == tail) {\n', '            tail = elements[tail].previous;\n', '            elements[tail].next = 0;\n', '        }else {\n', '            elements[key - 1].next = elements[key].next;\n', '            elements[key + 1].previous = elements[key].previous;\n', '        }\n', '\n', '        size--;\n', '        delete elements[key];\n', '        elementLocation[_item] = 0;\n', '        return true;\n', '    }\n', '\n', '    function getAllElements() constant returns(address[]) {\n', '        address[] memory tempElementArray = new address[](size);\n', '        uint cnt = 0;\n', '        uint currentElemId = head;\n', '        while (cnt < size) {\n', '            tempElementArray[cnt] = elements[currentElemId].data;\n', '            currentElemId = elements[currentElemId].next;\n', '            cnt += 1;\n', '        }\n', '        return tempElementArray;\n', '    }\n', '\n', '    function getElementAt(uint _index) constant returns (address) {\n', '        return elements[_index].data;\n', '    }\n', '\n', '    function getElementLocation(address _element) constant returns (uint) {\n', '        return elementLocation[_element];\n', '    }\n', '\n', '    function getNextElement(uint _currElementId) constant returns (uint) {\n', '        return elements[_currElementId].next;\n', '    }\n', '}\n', '\n', 'contract RootDonationsContract is Owned {\n', '\n', '    LinkedList donationsList = new LinkedList();\n', '\n', '    function addNewDonation(address _donationAddress) public onlyOwner {\n', '        require(donationsList.getElementLocation(_donationAddress) != 0);\n', '        donationsList.addItem(_donationAddress);\n', '    }\n', '\n', '    function removeDonation(address _donationAddress) public onlyOwner {\n', '        require(donationsList.getElementLocation(_donationAddress) == 0);\n', '        donationsList.removeItem(_donationAddress);\n', '    }\n', '\n', '    function getDonations() constant public returns (address[]) {\n', '        address[] memory tempElementArray = new address[](donationsList.size());\n', '        uint cnt = 0;\n', '        uint tempArrayCnt = 0;\n', '        uint currentElemId = donationsList.head();\n', '        while (cnt < donationsList.size()) {\n', '            tempElementArray[tempArrayCnt] = donationsList.getElementAt(currentElemId);\n', '            \n', '            currentElemId = donationsList.getNextElement(currentElemId);\n', '            cnt++;\n', '            return tempElementArray;\n', '        }\n', '        \n', '    }\n', '}\n', '\n', 'contract DonationContract is Owned {\n', '\n', '    struct ContributorData {\n', '        bool active;\n', '        uint contributionAmount;\n', '        bool hasVotedForDisable;\n', '    }\n', '    mapping(address => ContributorData) public contributorList;\n', '    uint public nextContributorIndex;\n', '    mapping(uint => address) public contributorIndexes;\n', '    uint public nextContributorToReturn;\n', '\n', '    enum phase { pendingStart, started, EndedFail, EndedSucess, disabled, finished}\n', '    phase public donationPhase;\n', '\n', '    uint public maxCap;\n', '    uint public minCap;\n', '\n', '    uint public donationsStartTime;\n', '    uint public donationsEndedTime;\n', '\n', '    address tokenAddress;\n', '    uint public tokensDonated;\n', '\n', '    event MinCapReached(uint blockNumber);\n', '    event MaxCapReached(uint blockNumber);\n', '    event FundsClaimed(address athlete, uint _value, uint blockNumber);\n', '\n', '    uint public athleteCanClaimPercent;\n', '    uint public tick;\n', '    uint public lastClaimed;\n', '    uint public athleteAlreadyClaimed;\n', '    address public athlete;\n', '    uint public contractFee;\n', '    address public feeWallet;\n', '\n', '    uint public tokensVotedForDisable;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '    function DonationContract(  address _tokenAddress,\n', '                                uint _minCap,\n', '                                uint _maxCap,\n', '                                uint _donationsStartTime,\n', '                                uint _donationsEndedTime,\n', '                                uint _athleteCanClaimPercent,\n', '                                uint _tick,\n', '                                address _athlete,\n', '                                uint _contractFee,\n', '                                address _feeWallet) {\n', '        tokenAddress = _tokenAddress;\n', '        minCap = _minCap;\n', '        maxCap = _maxCap;\n', '        donationsStartTime = _donationsStartTime;\n', '        donationsEndedTime = _donationsEndedTime;\n', '        donationPhase = phase.pendingStart;\n', '        require(_athleteCanClaimPercent <= 100);\n', '        athleteCanClaimPercent = _athleteCanClaimPercent;\n', '        tick = _tick;\n', '        athlete = _athlete;\n', '        require(_athleteCanClaimPercent <= 100);\n', '        contractFee = _contractFee;\n', '        feeWallet = _feeWallet;\n', '    }\n', '\n', '    function receiveApproval(address _from, uint256 _value, address _to, bytes _extraData) public {\n', '        require(_to == tokenAddress);\n', '        require(_value != 0);\n', '\n', '        if (donationPhase == phase.pendingStart) {\n', '            if (now >= donationsStartTime) {\n', '                donationPhase = phase.started;\n', '            } else {\n', '                revert();\n', '            }\n', '        }\n', '\n', '        if(donationPhase == phase.started) {\n', '            if (now > donationsEndedTime){\n', '                if(tokensDonated >= minCap){\n', '                    donationPhase = phase.EndedSucess;\n', '                }else{\n', '                    donationPhase = phase.EndedFail;\n', '                }\n', '            }else{\n', '                uint tokensToTake = processTransaction(_from, _value);\n', '                ERC20TokenInterface(tokenAddress).transferFrom(_from, address(this), tokensToTake);\n', '            }\n', '        }else{\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function processTransaction(address _from, uint _value) internal returns (uint) {\n', '        uint valueToProcess = 0;\n', '        if (tokensDonated + _value >= maxCap) {\n', '            valueToProcess = maxCap - tokensDonated;\n', '            donationPhase = phase.EndedSucess;\n', '            MaxCapReached(block.number);\n', '        } else {\n', '            valueToProcess = _value;\n', '            if (tokensDonated < minCap && tokensDonated + valueToProcess >= minCap) {\n', '                MinCapReached(block.number);\n', '            }\n', '        }\n', '        if (!contributorList[_from].active) {\n', '            contributorList[_from].active = true;\n', '            contributorList[_from].contributionAmount = valueToProcess;\n', '            contributorIndexes[nextContributorIndex] = _from;\n', '            nextContributorIndex++;\n', '        }else{\n', '            contributorList[_from].contributionAmount += valueToProcess;\n', '        }\n', '        tokensDonated += valueToProcess;\n', '        return valueToProcess;\n', '    }\n', '\n', '    function manuallyProcessTransaction(address _from, uint _value) onlyOwner public {\n', '        require(_value != 0);\n', '        require(ERC20TokenInterface(tokenAddress).balanceOf(address(this)) >= _value + tokensDonated);\n', '\n', '        if (donationPhase == phase.pendingStart) {\n', '            if (now >= donationsStartTime) {\n', '                donationPhase = phase.started;\n', '            } else {\n', '                ERC20TokenInterface(tokenAddress).transfer(_from, _value);\n', '            }\n', '        }\n', '\n', '        if(donationPhase == phase.started) {\n', '            uint tokensToTake = processTransaction(_from, _value);\n', '            ERC20TokenInterface(tokenAddress).transfer(_from, _value - tokensToTake);\n', '        }else{\n', '            ERC20TokenInterface(tokenAddress).transfer(_from, _value);\n', '        }\n', '    }\n', '\n', '    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n', '        require(_tokenAddress != tokenAddress);\n', '        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '\n', '    function claimFunds() public {\n', '        require(donationPhase == phase.EndedSucess);\n', '        require(athleteAlreadyClaimed < tokensDonated);\n', '        require(athlete == msg.sender);\n', '        if (lastClaimed == 0) {\n', '            lastClaimed = now;\n', '        } else {\n', '            require(lastClaimed + tick <= now);\n', '        }\n', '        uint claimAmount = (athleteCanClaimPercent * tokensDonated) / 100;\n', '        if (athleteAlreadyClaimed + claimAmount >= tokensDonated) {\n', '            claimAmount = tokensDonated - athleteAlreadyClaimed;\n', '            donationPhase = phase.finished;\n', '        }\n', '        athleteAlreadyClaimed += claimAmount;\n', '        lastClaimed += tick;\n', '        uint fee = (claimAmount * contractFee) / 100;\n', '        ERC20TokenInterface(tokenAddress).transfer(athlete, claimAmount - fee);\n', '        ERC20TokenInterface(tokenAddress).transfer(feeWallet, fee);\n', '        FundsClaimed(athlete, claimAmount, block.number);\n', '    }\n', '\n', '    function disableDonationContract() public {\n', '        require(msg.sender == athlete);\n', '        require(donationPhase == phase.EndedSucess);\n', '\n', '        donationPhase = phase.disabled;\n', '    }\n', '\n', '    function voteForDisable() public {\n', '        require(donationPhase == phase.EndedSucess);\n', '        require(contributorList[msg.sender].active);\n', '        require(!contributorList[msg.sender].hasVotedForDisable);\n', '\n', '        tokensVotedForDisable += contributorList[msg.sender].contributionAmount;\n', '        contributorList[msg.sender].hasVotedForDisable = true;\n', '\n', '        if (tokensVotedForDisable >= tokensDonated/2) {\n', '            donationPhase = phase.disabled;\n', '        }\n', '    }\n', '\n', '    function batchReturnTokensIfFailed(uint _numberOfReturns) public {\n', '        require(donationPhase == phase.EndedFail);\n', '        address currentParticipantAddress;\n', '        uint contribution;\n', '        for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\n', '            currentParticipantAddress = contributorIndexes[nextContributorToReturn];\n', '            if (currentParticipantAddress == 0x0) {\n', '                donationPhase = phase.finished;\n', '                return;\n', '            }\n', '            contribution = contributorList[currentParticipantAddress].contributionAmount;\n', '            ERC20TokenInterface(tokenAddress).transfer(currentParticipantAddress, contribution);\n', '            nextContributorToReturn += 1;\n', '        }\n', '    }\n', '\n', '    function batchReturnTokensIfDisabled(uint _numberOfReturns) public {\n', '        require(donationPhase == phase.disabled);\n', '        address currentParticipantAddress;\n', '        uint contribution;\n', '        for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\n', '            currentParticipantAddress = contributorIndexes[nextContributorToReturn];\n', '            if (currentParticipantAddress == 0x0) {\n', '                donationPhase = phase.finished;\n', '                return;\n', '            }\n', '            contribution = (contributorList[currentParticipantAddress].contributionAmount * (tokensDonated - athleteAlreadyClaimed)) / tokensDonated;\n', '            ERC20TokenInterface(tokenAddress).transfer(currentParticipantAddress, contribution);\n', '            nextContributorToReturn += 1;\n', '        }\n', '    }\n', '\n', '    function getSaleFinancialData() public constant returns(uint,uint){\n', '        return (tokensDonated, maxCap);\n', '    }\n', '\n', '    function getClaimedFinancialData() public constant returns(uint,uint){\n', '        return (athleteAlreadyClaimed, tokensDonated);\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20TokenInterface {\n', '  function totalSupply() public constant returns (uint256 _totalSupply);\n', '  function balanceOf(address _owner) public constant returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', 'contract tokenRecipientInterface {\n', '  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\n', '}\n', 'contract SportifyTokenInterface {\n', '    function mint(address _to, uint256 _amount) public;\n', '}']