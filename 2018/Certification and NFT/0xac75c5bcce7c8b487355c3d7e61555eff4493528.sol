['pragma solidity ^0.4.23;\n', '\n', 'contract Contract {\n', '  struct Contributor {\n', '    uint256 balance;\n', '    uint256 balance_bonus;\n', '    uint256 fee;\n', '    bool whitelisted;\n', '  }\n', '  mapping (address => Contributor) public contributors;\n', '  uint256 public contract_eth_value;\n', '  uint256 public contract_eth_value_fee;\n', '}\n', '\n', 'contract ERC20 {\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function balanceOf(address _owner) public constant returns (uint256 balance);\n', '}\n', '\n', 'contract HybridProxy {\n', '\n', '  struct Contributor {\n', '    uint256 balance;\n', '    uint256 balance_bonus;\n', '    uint256 fee;\n', '    bool whitelisted;\n', '  }\n', '\n', '  struct Snapshot {\n', '    uint256 tokens_balance;\n', '    uint256 eth_balance;\n', '  }\n', '\n', '  //FEES RELATED\n', '  //============================\n', '  address constant public DEVELOPER1 = 0xEE06BdDafFA56a303718DE53A5bc347EfbE4C68f;\n', '  address constant public DEVELOPER2 = 0x63F7547Ac277ea0B52A0B060Be6af8C5904953aa;\n', '  uint256 constant public FEE_DEV = 500; //0.2% fee per dev -> so 0.4% fee in total\n', '  //============================\n', '\n', '  Contract contr;\n', '  uint256 public eth_balance;\n', '  uint256 public fee_balance;\n', '  ERC20 public token;\n', '  mapping (address => uint8) public contributor_rounds;\n', '  Snapshot[] public snapshots;\n', '  address owner;\n', '  uint8 public rounds;\n', '\n', '  constructor(address _contract) {\n', '    owner = msg.sender;\n', '    contr = Contract(_contract);\n', '    eth_balance = contr.contract_eth_value();\n', '    require(eth_balance != 0);\n', '  }\n', '\n', '  function dev_fee(uint256 tokens_this_round) returns (uint256) {\n', '    uint256 tokens_individual;\n', '    tokens_individual = tokens_this_round/FEE_DEV;\n', '    require(token.transfer(DEVELOPER1, tokens_individual));\n', '    require(token.transfer(DEVELOPER2, tokens_individual));\n', '    tokens_this_round -= (2*tokens_individual);\n', '    return tokens_this_round;\n', '  }\n', '\n', '  //public functions\n', '\n', '  function withdraw()  {\n', '    uint256 contract_token_balance = token.balanceOf(address(this));\n', '\t\tvar (balance, balance_bonus, fee, whitelisted) = contr.contributors(msg.sender);\n', '\t\tif (contributor_rounds[msg.sender] < rounds) {\n', '\t\t\tSnapshot storage snapshot = snapshots[contributor_rounds[msg.sender]];\n', '      uint256 tokens_to_withdraw = (balance * snapshot.tokens_balance) / snapshot.eth_balance;\n', '\t\t\tsnapshot.tokens_balance -= tokens_to_withdraw;\n', '\t\t\tsnapshot.eth_balance -= balance;\n', '      contributor_rounds[msg.sender]++;\n', '      require(token.transfer(msg.sender, tokens_to_withdraw));\n', '    }\n', '  }\n', '\n', '  function emergency_withdraw(address _token) {\n', '    require(msg.sender == owner);\n', '    require(ERC20(_token).transfer(owner, ERC20(_token).balanceOf(this)));\n', '  }\n', '\n', '  function set_tokens_received() {\n', '    require(msg.sender == owner);\n', '    uint256 previous_balance;\n', '    uint256 tokens_this_round;\n', '    for (uint8 i = 0; i < snapshots.length; i++) {\n', '      previous_balance += snapshots[i].tokens_balance;\n', '    }\n', '    tokens_this_round = token.balanceOf(address(this)) - previous_balance;\n', '    require(tokens_this_round != 0);\n', '    tokens_this_round = dev_fee(tokens_this_round);\n', '    snapshots.push(Snapshot(tokens_this_round, eth_balance));\n', '    rounds++;\n', '  }\n', '\n', '  function set_token_address(address _token) {\n', '    require(msg.sender == owner && _token != 0x0);\n', '    token = ERC20(_token);\n', '  }\n', '}']