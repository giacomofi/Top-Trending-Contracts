['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Crowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale,\n', ' * allowing investors to purchase tokens with ether. This contract implements\n', ' * such functionality in its most fundamental form and can be extended to provide additional\n', ' * functionality and/or custom behavior.\n', ' * The external interface represents the basic interface for purchasing tokens, and conform\n', ' * the base architecture for crowdsales. They are *not* intended to be modified / overriden.\n', ' * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\n', ' * the methods to add functionality. Consider using &#39;super&#39; where appropiate to concatenate\n', ' * behavior.\n', ' */\n', 'contract XDMCCrowdsale is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  event Log(string _a, uint256 _b);\n', '\n', '  // The token being sold\n', '  ERC20 public token;\n', '\n', '  address wallet; //address for contribution receiving\n', '\n', '  uint256 public icoRate = 0; // will be set manually when ico starts\n', '  uint256 public icoOver1 = 0; // will be set manually when ico starts\n', '  uint256 public icoBonus1 = 0; // will be set manually when ico starts\n', '  uint256 public icoOver2 = 0; // will be set manually when ico starts\n', '  uint256 public icoBonus2 = 0; // will be set manually when ico starts\n', '  uint256 public icoOver3 = 0; // will be set manually when ico starts\n', '  uint256 public icoBonus3 = 0; // will be set manually when ico starts\n', '  uint256 public icoOver4 = 0; // will be set manually when ico starts\n', '  uint256 public icoBonus4 = 0; // will be set manually when ico starts\n', '  uint256 public icoOver5 = 0; // will be set manually when ico starts\n', '  uint256 public icoBonus5 = 0; // will be set manually when ico starts\n', '  uint256 public ico1cap = uint256(224502081).mul(1 ether);\n', '  uint256 public ico2cap = uint256(190996929).mul(1 ether);\n', '  uint256 public ico3cap = uint256(127331286).mul(1 ether);\n', '  enum Stages {Pause, Ico1, Ico1End, Ico2, Ico2End, Ico3, Ico3End}\n', '  Stages currentStage;\n', '  address public teamAddress = 0x4B58EBeEb96b7551Bb752Ea9512771615C554De3;\n', '  uint256 public vestingStartTime = 0;\n', '  uint256 public vestingPeriod = 15552000; // 180 days\n', '  uint256 public teamTokens = uint256(198639670).mul(1 ether);\n', '  uint256 public teamTokensPerPeriod = uint256(33768743).mul(1 ether);\n', '  uint256 public teamTokensReleased = 0;\n', '  uint256 public devTokensIco1 = uint256(52060948).mul(1 ether);\n', '  uint256 public devTokensIco2 = uint256(52060948).mul(1 ether);\n', '  uint256 public devTokensIco3 = uint256(53638554).mul(1 ether);\n', '  uint256 public ico1endTime = 0;\n', '  uint256 public ico2endTime = 0;\n', '  uint256 public ico3endTime = 0;\n', '  uint256 public getUnsoldPeriod = 8640000; // 100 days\n', '  uint256 public ico1total = 0;\n', '  uint256 public ico2total = 0;\n', '  uint256 public ico3total = 0;\n', '  uint256 public ico1receivedTotal = 0;\n', '  uint256 public ico2receivedTotal = 0;\n', '  uint256 public ico3receivedTotal = 0;\n', '  mapping(address => uint256) ico1amount;\n', '  mapping(address => uint256) ico2amount;\n', '  mapping(address => uint256) ico3amount;\n', '  mapping(address => uint256) ico1received;\n', '  mapping(address => uint256) ico2received;\n', '  mapping(address => uint256) ico3received;\n', '\n', '  // Amount of wei raised\n', '  uint256 public weiRaised;\n', '\n', '  /**\n', '   * Event for token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param value weis paid for purchase\n', '   * @param amount amount of tokens purchased\n', '   */\n', '  event TokenPurchase(\n', '    address indexed purchaser,\n', '    address indexed beneficiary,\n', '    uint256 value,\n', '    uint256 amount\n', '  );\n', '\n', '  event TokenPriceDescription(\n', '    uint256 basePrice,\n', '    uint256 bonus,\n', '    uint256 tokens\n', '  );\n', '\n', '  /**\n', '   * \n', '   * @param _owner Address where collected funds will be forwarded to\n', '   * @param _token Address of the token being sold\n', '   */\n', '  constructor(address _owner, address _wallet, ERC20 _token) public {\n', '    require(_owner != address(0));\n', '    require(_wallet != address(0));\n', '    require(_token != address(0));\n', '    currentStage = Stages.Pause;\n', '    vestingStartTime = now;\n', '    owner = _owner;\n', '    token = _token;\n', '    wallet = _wallet;\n', '    teamTokensReleased = teamTokensReleased.add(teamTokensPerPeriod);\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Crowdsale external interface\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev fallback function ***DO NOT OVERRIDE***\n', '   */\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function startIco1(\n', '    uint256 _rate, \n', '    uint256 _over1, \n', '    uint256 _bonus1, \n', '    uint256 _over2, \n', '    uint256 _bonus2, \n', '    uint256 _over3, \n', '    uint256 _bonus3, \n', '    uint256 _over4, \n', '    uint256 _bonus4, \n', '    uint256 _over5, \n', '    uint256 _bonus5\n', '  ) public onlyOwner returns (bool) {\n', '    require(currentStage == Stages.Pause);\n', '    require(token.balanceOf(address(this)) >= uint256(865461673).mul(1 ether));\n', '    require(_rate > 0);\n', '    currentStage = Stages.Ico1;\n', '    icoRate = _rate;\n', '    icoOver1 = _over1.mul(1 ether);\n', '    icoBonus1 = _bonus1;\n', '    icoOver2 = _over2.mul(1 ether);\n', '    icoBonus2 = _bonus2;\n', '    icoOver3 = _over3.mul(1 ether);\n', '    icoBonus3 = _bonus3;\n', '    icoOver4 = _over4.mul(1 ether);\n', '    icoBonus4 = _bonus4;\n', '    icoOver5 = _over5.mul(1 ether);\n', '    icoBonus5 = _bonus5;\n', '    require(token.transfer(owner, devTokensIco1));\n', '    return true;\n', '  }\n', '\n', '  function endIco1() public onlyOwner returns (bool) {\n', '    require(currentStage == Stages.Ico1);\n', '    currentStage = Stages.Ico1End;\n', '    ico1endTime = now;\n', '    return true;\n', '  }\n', '\n', '  function startIco2(\n', '    uint256 _rate, \n', '    uint256 _over1, \n', '    uint256 _bonus1, \n', '    uint256 _over2, \n', '    uint256 _bonus2, \n', '    uint256 _over3, \n', '    uint256 _bonus3, \n', '    uint256 _over4, \n', '    uint256 _bonus4, \n', '    uint256 _over5, \n', '    uint256 _bonus5\n', '  ) public onlyOwner returns (bool) {\n', '    require(currentStage == Stages.Ico1End);\n', '    currentStage = Stages.Ico2;\n', '    if (_rate > 0) icoRate = _rate;\n', '    icoOver1 = _over1.mul(1 ether);\n', '    icoBonus1 = _bonus1;\n', '    icoOver2 = _over2.mul(1 ether);\n', '    icoBonus2 = _bonus2;\n', '    icoOver3 = _over3.mul(1 ether);\n', '    icoBonus3 = _bonus3;\n', '    icoOver4 = _over4.mul(1 ether);\n', '    icoBonus4 = _bonus4;\n', '    icoOver5 = _over5.mul(1 ether);\n', '    icoBonus5 = _bonus5;\n', '    require(token.transfer(owner, devTokensIco2));\n', '    return true;\n', '  }\n', '\n', '  function endIco2() public onlyOwner returns (bool) {\n', '    require(currentStage == Stages.Ico2);\n', '    currentStage = Stages.Ico2End;\n', '    ico2endTime = now;\n', '    return true;\n', '  }\n', '\n', '  function startIco3(\n', '    uint256 _rate, \n', '    uint256 _over1, \n', '    uint256 _bonus1, \n', '    uint256 _over2, \n', '    uint256 _bonus2, \n', '    uint256 _over3, \n', '    uint256 _bonus3, \n', '    uint256 _over4, \n', '    uint256 _bonus4, \n', '    uint256 _over5, \n', '    uint256 _bonus5\n', '  ) public onlyOwner returns (bool) {\n', '    require(currentStage == Stages.Ico2End);\n', '    currentStage = Stages.Ico3;\n', '    if (_rate > 0) icoRate = _rate;\n', '    icoOver1 = _over1.mul(1 ether);\n', '    icoBonus1 = _bonus1;\n', '    icoOver2 = _over2.mul(1 ether);\n', '    icoBonus2 = _bonus2;\n', '    icoOver3 = _over3.mul(1 ether);\n', '    icoBonus3 = _bonus3;\n', '    icoOver4 = _over4.mul(1 ether);\n', '    icoBonus4 = _bonus4;\n', '    icoOver5 = _over5.mul(1 ether);\n', '    icoBonus5 = _bonus5;\n', '    require(token.transfer(owner, devTokensIco3));\n', '    return true;\n', '  }\n', '\n', '  function endIco3() public onlyOwner returns (bool) {\n', '    require(currentStage == Stages.Ico3);\n', '    currentStage = Stages.Ico3End;\n', '    ico3endTime = now;\n', '    return true;\n', '  }\n', '\n', '  function getUnsoldReceived(uint256 _stage, address _address) public view returns (uint256) {\n', '    if (_stage == 1) return ico1received[_address];\n', '    else if (_stage == 2) return ico2received[_address];\n', '    else if (_stage == 3) return ico3received[_address];\n', '    else return 0;\n', '  }\n', '\n', '  function getStageAmount(uint256 _stage, address _address) public view returns (uint256) {\n', '    if (_stage == 1) return ico1amount[_address];\n', '    else if (_stage == 2) return ico2amount[_address];\n', '    else if (_stage == 3) return ico3amount[_address];\n', '    else return 0;\n', '  }\n', '\n', '  function getStageName() public view returns (string) {\n', '    if (currentStage == Stages.Pause) return &#39;ICO is not started yet&#39;;\n', '    else if (currentStage == Stages.Ico1) return &#39;ICO 1&#39;;\n', '    else if (currentStage == Stages.Ico1End) return &#39;ICO 1 end&#39;;\n', '    else if (currentStage == Stages.Ico2) return &#39;ICO 2&#39;;\n', '    else if (currentStage == Stages.Ico2End) return &#39;ICO 2 end&#39;;\n', '    else if (currentStage == Stages.Ico3) return &#39;ICO 3&#39;;\n', '    else if (currentStage == Stages.Ico3End) return &#39;ICO 3 end&#39;;\n', '    return &#39;Undefined&#39;;\n', '  }\n', '\n', '  function getPrice() public view returns (uint256) {\n', '    if (currentStage == Stages.Ico1) return icoRate;\n', '    else if (currentStage == Stages.Ico2) return icoRate;\n', '    else if (currentStage == Stages.Ico3) return icoRate;\n', '    return 0;\n', '  }\n', '\n', '  function getBonus(uint256 _ether) public view returns (uint256) {\n', '    return _getBonus(_ether.mul(1 ether));\n', '  }\n', '\n', '  function _getBonus(uint256 _wei) internal view returns (uint256) {\n', '    if (\n', '        currentStage == Stages.Ico1 || \n', '        currentStage == Stages.Ico2 || \n', '        currentStage == Stages.Ico3\n', '      ) {\n', '      if (_wei >= icoOver1) return icoBonus1;\n', '      else if (_wei >= icoOver2) return icoBonus2;\n', '      else if (_wei >= icoOver3) return icoBonus3;\n', '      else if (_wei >= icoOver4) return icoBonus4;\n', '      else if (_wei >= icoOver5) return icoBonus5;\n', '      return 0;\n', '    }\n', '    return 0;\n', '  }\n', '\n', '  function getVestingPeriodNumber() public view returns (uint256) {\n', '    if (vestingStartTime == 0) return 0;\n', '    return now.sub(vestingStartTime).div(vestingPeriod).add(1);\n', '  }\n', '\n', '  function getTeamToken() public {\n', '    uint256 vestingPeriodNumber = getVestingPeriodNumber();\n', '    require(vestingPeriodNumber > 1);\n', '    require(teamTokensReleased < teamTokens);\n', '    uint256 toRelease;\n', '    if (vestingPeriodNumber >= 6) toRelease = teamTokens;\n', '    else toRelease = vestingPeriodNumber.mul(teamTokensPerPeriod);\n', '    if (toRelease > teamTokens) toRelease = teamTokens;\n', '    toRelease = toRelease.sub(teamTokensReleased);\n', '    require(toRelease > 0);\n', '    teamTokensReleased = teamTokensReleased.add(toRelease);\n', '    require(token.transfer(teamAddress, toRelease));\n', '  }\n', '\n', '  /**\n', '   * @dev low level token purchase ***DO NOT OVERRIDE***\n', '   * @param _beneficiary Address performing the token purchase\n', '   */\n', '  function buyTokens(address _beneficiary) public payable {\n', '\n', '    uint256 weiAmount = msg.value;\n', '\n', '    _preValidatePurchase(_beneficiary, weiAmount);\n', '\n', '    // calculate token amount to be created\n', '    uint256 tokens = _getTokenAmount(weiAmount);\n', '\n', '    _validateTokensAmount(tokens);\n', '\n', '    if (currentStage == Stages.Ico1) {\n', '      ico1amount[msg.sender] = ico1amount[msg.sender].add(tokens);\n', '      ico1total = ico1total.add(tokens);\n', '    } else if (currentStage == Stages.Ico2) {\n', '      ico2amount[msg.sender] = ico2amount[msg.sender].add(tokens);\n', '      ico2total = ico2total.add(tokens);\n', '    } else if (currentStage == Stages.Ico3) {\n', '      ico3amount[msg.sender] = ico3amount[msg.sender].add(tokens);\n', '      ico3total = ico3total.add(tokens);\n', '    }\n', '\n', '    weiRaised = weiRaised.add(weiAmount);\n', '\n', '    _processPurchase(_beneficiary, tokens);\n', '\n', '    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '\n', '    _forwardFunds(weiAmount);\n', '  }\n', '\n', '  /**\n', '   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n', '   * @param _beneficiary Address performing the token purchase\n', '   * @param _weiAmount Value in wei involved in the purchase\n', '   */\n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view {\n', '    require(_beneficiary != address(0));\n', '    require(_weiAmount >= 100 finney);\n', '    if (currentStage == Stages.Ico1) require(_weiAmount <= 1000 ether);\n', '    else if (currentStage == Stages.Ico2) require(_weiAmount <= 500 ether);\n', '    else if (currentStage == Stages.Ico3) require(_weiAmount <= 500 ether);\n', '    else revert();\n', '  }\n', '\n', '  function _validateTokensAmount(uint256 _tokens) internal view {\n', '    require(_tokens > 0);\n', '    if (currentStage == Stages.Ico1) require(_tokens <= ico1cap);\n', '    else if (currentStage == Stages.Ico2) require(_tokens <= ico2cap);\n', '    else if (currentStage == Stages.Ico3) require(_tokens <= ico3cap);\n', '  }\n', '\n', '  /**\n', '   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n', '   * @param _beneficiary Address performing the token purchase\n', '   * @param _tokenAmount Number of tokens to be emitted\n', '   */\n', '  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '    require(token.transfer(_beneficiary, _tokenAmount));\n', '  }\n', '\n', '  /**\n', '   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n', '   * @param _beneficiary Address receiving the tokens\n', '   * @param _tokenAmount Number of tokens to be purchased\n', '   */\n', '  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '    _deliverTokens(_beneficiary, _tokenAmount);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Override to extend the way in which ether is converted to tokens.\n', '   * @param _weiAmount Value in wei to be converted into tokens\n', '   * @return Number of tokens that can be purchased with the specified _weiAmount\n', '   */\n', '  function _getTokenAmount(uint256 _weiAmount) internal returns (uint256) {\n', '    uint256 basePrice = icoRate;\n', '    uint256 tokens = _weiAmount.mul(basePrice);\n', '    uint256 bonuses = _getBonus(_weiAmount);\n', '    if (bonuses > 0) {\n', '      uint256 bonusTokens = tokens.mul(bonuses).div(100);\n', '      tokens = tokens.add(bonusTokens);\n', '    }\n', '\n', '    emit TokenPriceDescription(basePrice, bonuses, tokens);\n', '    return tokens;\n', '  }\n', '\n', '  /**\n', '   * @dev Determines how ETH is stored/forwarded on purchases.\n', '   */\n', '  function _forwardFunds(uint256 _weiAmount) internal {\n', '    require(wallet != address(0));\n', '    wallet.transfer(_weiAmount);\n', '  }\n', '\n', '  function getUnsoldOwner() public onlyOwner returns (bool) {\n', '    uint256 unsoldTokensRemains = 0;\n', '    uint256 stageRemains;\n', '    if (\n', '      ico1endTime > 0 && \n', '      now.sub(ico1endTime) > getUnsoldPeriod && \n', '      ico1receivedTotal < ico1cap.sub(ico1total)\n', '    ) {\n', '      stageRemains = ico1cap.sub(ico1total).sub(ico1receivedTotal);\n', '      unsoldTokensRemains = unsoldTokensRemains.add(stageRemains);\n', '      ico1receivedTotal = ico1cap.sub(ico1total);\n', '    }\n', '    if (\n', '      ico2endTime > 0 && \n', '      now.sub(ico2endTime) > getUnsoldPeriod && \n', '      ico2receivedTotal < ico2cap.sub(ico1total)\n', '    ) {\n', '      stageRemains = ico2cap.sub(ico2total).sub(ico2receivedTotal);\n', '      unsoldTokensRemains = unsoldTokensRemains.add(stageRemains);\n', '      ico2receivedTotal = ico2cap.sub(ico2total);\n', '    }\n', '    if (\n', '      ico3endTime > 0 && \n', '      now.sub(ico3endTime) > getUnsoldPeriod && \n', '      ico3receivedTotal < ico3cap.sub(ico3total)\n', '    ) {\n', '      stageRemains = ico3cap.sub(ico3total).sub(ico3receivedTotal);\n', '      unsoldTokensRemains = unsoldTokensRemains.add(stageRemains);\n', '      ico3receivedTotal = ico3cap.sub(ico3total);\n', '    }\n', '\n', '    require(unsoldTokensRemains > 0);\n', '    require(token.transfer(owner, unsoldTokensRemains));\n', '\n', '    return true;\n', '  }\n', '\n', '  function getUnsold() public returns (bool) {\n', '    uint256 unsoldTokensShare = 0;\n', '    uint256 tokenBalance = token.balanceOf(msg.sender);\n', '    uint256 stageShare;\n', '    uint256 stageRemains;\n', '\n', '    if (\n', '      ico1endTime > 0 && \n', '      now.sub(ico1endTime) < getUnsoldPeriod && \n', '      ico1received[msg.sender] == 0 &&\n', '      tokenBalance >= ico1amount[msg.sender]\n', '    ) {\n', '      tokenBalance = tokenBalance.sub(ico1amount[msg.sender]);\n', '      stageRemains = ico1cap.sub(ico1total);\n', '      stageShare = stageRemains.mul(ico1amount[msg.sender]).div(ico1total);\n', '      unsoldTokensShare = unsoldTokensShare.add(stageShare);\n', '      ico1received[msg.sender] = stageShare;\n', '      ico1receivedTotal = ico1receivedTotal.add(stageShare);\n', '      require(ico1receivedTotal <= ico1cap.sub(ico1total));\n', '    }\n', '\n', '    if (\n', '      ico2endTime > 0 && \n', '      now.sub(ico2endTime) < getUnsoldPeriod && \n', '      ico2received[msg.sender] == 0 &&\n', '      tokenBalance >= ico2amount[msg.sender]\n', '    ) {\n', '      tokenBalance = tokenBalance.sub(ico2amount[msg.sender]);\n', '      stageRemains = ico2cap.sub(ico2total);\n', '      stageShare = stageRemains.mul(ico2amount[msg.sender]).div(ico2total);\n', '      unsoldTokensShare = unsoldTokensShare.add(stageShare);\n', '      ico2received[msg.sender] = stageShare;\n', '      ico2receivedTotal = ico2receivedTotal.add(stageShare);\n', '      require(ico2receivedTotal <= ico2cap.sub(ico2total));\n', '    }\n', '\n', '    if (\n', '      ico3endTime > 0 && \n', '      now.sub(ico3endTime) < getUnsoldPeriod && \n', '      ico3received[msg.sender] == 0 &&\n', '      tokenBalance >= ico3amount[msg.sender]\n', '    ) {\n', '      stageRemains = ico3cap.sub(ico3total);\n', '      stageShare = stageRemains.mul(ico3amount[msg.sender]).div(ico3total);\n', '      unsoldTokensShare = unsoldTokensShare.add(stageShare);\n', '      ico3received[msg.sender] = stageShare;\n', '      ico3receivedTotal = ico3receivedTotal.add(stageShare);\n', '      require(ico3receivedTotal <= ico3cap.sub(ico3total));\n', '    }\n', '\n', '    require(unsoldTokensShare > 0);\n', '    require(token.transfer(msg.sender, unsoldTokensShare));\n', '\n', '    return true;\n', '  }\n', '}']